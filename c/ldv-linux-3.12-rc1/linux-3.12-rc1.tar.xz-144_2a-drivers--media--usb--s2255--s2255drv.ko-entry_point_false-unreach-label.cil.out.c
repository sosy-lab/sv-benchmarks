/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 19 "include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 18 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 40 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 48 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 32 "include/uapi/linux/types.h"
typedef __u16 __le16;
#line 34 "include/uapi/linux/types.h"
typedef __u32 __le32;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 146 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 39 "include/linux/mod_devicetable.h"
struct usb_device_id {
   __u16 match_flags ;
   __u16 idVendor ;
   __u16 idProduct ;
   __u16 bcdDevice_lo ;
   __u16 bcdDevice_hi ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 bInterfaceNumber ;
   kernel_ulong_t driver_info ;
};
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 253 "include/uapi/linux/usb/ch9.h"
struct usb_device_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 bcdUSB ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bMaxPacketSize0 ;
   __le16 idVendor ;
   __le16 idProduct ;
   __le16 bcdDevice ;
   __u8 iManufacturer ;
   __u8 iProduct ;
   __u8 iSerialNumber ;
   __u8 bNumConfigurations ;
};
#line 275 "include/uapi/linux/usb/ch9.h"
struct usb_config_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumInterfaces ;
   __u8 bConfigurationValue ;
   __u8 iConfiguration ;
   __u8 bmAttributes ;
   __u8 bMaxPower ;
};
#line 343 "include/uapi/linux/usb/ch9.h"
struct usb_interface_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bInterfaceNumber ;
   __u8 bAlternateSetting ;
   __u8 bNumEndpoints ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 iInterface ;
};
#line 363 "include/uapi/linux/usb/ch9.h"
struct usb_endpoint_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bEndpointAddress ;
   __u8 bmAttributes ;
   __le16 wMaxPacketSize ;
   __u8 bInterval ;
   __u8 bRefresh ;
   __u8 bSynchAddress ;
};
#line 613 "include/uapi/linux/usb/ch9.h"
struct usb_ss_ep_comp_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bMaxBurst ;
   __u8 bmAttributes ;
   __le16 wBytesPerInterval ;
};
#line 692 "include/uapi/linux/usb/ch9.h"
struct usb_interface_assoc_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bFirstInterface ;
   __u8 bInterfaceCount ;
   __u8 bFunctionClass ;
   __u8 bFunctionSubClass ;
   __u8 bFunctionProtocol ;
   __u8 iFunction ;
};
#line 751 "include/uapi/linux/usb/ch9.h"
struct usb_bos_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumDeviceCaps ;
};
#line 801 "include/uapi/linux/usb/ch9.h"
struct usb_ext_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __le32 bmAttributes ;
};
#line 811 "include/uapi/linux/usb/ch9.h"
struct usb_ss_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bmAttributes ;
   __le16 wSpeedSupported ;
   __u8 bFunctionalitySupport ;
   __u8 bU1devExitLat ;
   __le16 bU2DevExitLat ;
};
#line 840 "include/uapi/linux/usb/ch9.h"
struct usb_ss_container_id_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bReserved ;
   __u8 ContainerID[16U] ;
};
#line 905
enum usb_device_speed {
    USB_SPEED_UNKNOWN = 0,
    USB_SPEED_LOW = 1,
    USB_SPEED_FULL = 2,
    USB_SPEED_HIGH = 3,
    USB_SPEED_WIRELESS = 4,
    USB_SPEED_SUPER = 5
} ;
#line 914
enum usb_device_state {
    USB_STATE_NOTATTACHED = 0,
    USB_STATE_ATTACHED = 1,
    USB_STATE_POWERED = 2,
    USB_STATE_RECONNECTING = 3,
    USB_STATE_UNAUTHENTICATED = 4,
    USB_STATE_DEFAULT = 5,
    USB_STATE_ADDRESS = 6,
    USB_STATE_CONFIGURED = 7,
    USB_STATE_SUSPENDED = 8
} ;
#line 54 "include/linux/usb/ch9.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 65 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 144 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 161 "include/linux/init.h"
struct __anonstruct_ldv_1821_12 {
   unsigned int a ;
   unsigned int b ;
};
#line 161 "include/linux/init.h"
struct __anonstruct_ldv_1836_13 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 161 "include/linux/init.h"
union __anonunion_ldv_1837_11 {
   struct __anonstruct_ldv_1821_12 ldv_1821 ;
   struct __anonstruct_ldv_1836_13 ldv_1836 ;
};
#line 161 "include/linux/init.h"
struct desc_struct {
   union __anonunion_ldv_1837_11 ldv_1837 ;
};
#line 15 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 20 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 242 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 244 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_15 {
   pgdval_t pgd ;
};
#line 244 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_15 pgd_t;
#line 332
struct page;
#line 332 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 340
struct file;
#line 353
struct seq_file;
#line 385
struct thread_struct;
#line 387
struct mm_struct;
#line 388
struct task_struct;
#line 389
struct cpumask;
#line 327 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/paravirt_types.h"
struct arch_spinlock;
#line 18 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 19 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 20 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/spinlock_types.h"
union __anonunion_ldv_2243_18 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion_ldv_2243_18 ldv_2243 ;
};
#line 33 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 33 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/rwlock.h"
struct __anonstruct_ldv_2250_20 {
   u32 read ;
   s32 write ;
};
#line 33 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/rwlock.h"
union __anonunion_arch_rwlock_t_19 {
   s64 lock ;
   struct __anonstruct_ldv_2250_20 ldv_2250 ;
};
#line 33 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/rwlock.h"
typedef union __anonunion_arch_rwlock_t_19 arch_rwlock_t;
#line 354 "include/linux/printk.h"
struct file_operations;
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 23 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/sysinfo.h"
struct completion;
#line 383 "include/linux/kernel.h"
struct pid;
#line 54 "include/linux/delay.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct timespec;
#line 127 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/vm86.h"
union __anonunion_ldv_3460_25 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_ldv_3460_25 ldv_3460 ;
};
#line 306 "include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[64U] ;
};
#line 14 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 663 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 195 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/paravirt.h"
struct static_key;
#line 294 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 312 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5545_30 {
   u64 rip ;
   u64 rdp ;
};
#line 312 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5551_31 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 312 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
union __anonunion_ldv_5552_29 {
   struct __anonstruct_ldv_5545_30 ldv_5545 ;
   struct __anonstruct_ldv_5551_31 ldv_5551 ;
};
#line 312 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
union __anonunion_ldv_5561_32 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 312 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_ldv_5552_29 ldv_5552 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_ldv_5561_32 ldv_5561 ;
};
#line 346 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 367 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 372 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
#line 378 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
};
#line 384 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 392 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 439
struct kmem_cache;
#line 440
struct perf_event;
#line 441 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 115 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/barrier.h"
struct lockdep_map;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 26 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 2 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 11 ;
};
#line 533 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct_ldv_7685_100 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion_ldv_7686_99 {
   struct raw_spinlock rlock ;
   struct __anonstruct_ldv_7685_100 ldv_7685 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_ldv_7686_99 ldv_7686 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_101 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_101 rwlock_t;
#line 28 "include/linux/rwlock_types.h"
struct static_key {
   atomic_t enabled ;
};
#line 402 "include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
};
#line 47 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 328 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 13 "include/uapi/linux/time.h"
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
#line 317 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 105 "include/linux/debugobjects.h"
struct tvec_base;
#line 106 "include/linux/debugobjects.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 254 "include/linux/timer.h"
struct hrtimer;
#line 255
enum hrtimer_restart;
#line 266
struct workqueue_struct;
#line 267
struct work_struct;
#line 54 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 107 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 11 "include/linux/wait.h"
struct __wait_queue;
#line 11 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 14 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 33 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 38 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 986 "include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 301
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 308
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 316
struct wakeup_source;
#line 506 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 513
struct dev_pm_qos;
#line 513 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool ignore_children ;
   bool early_init ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   struct dev_pm_qos *qos ;
};
#line 570 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 98 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_103 {
   unsigned long bits[16U] ;
};
#line 98 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_103 nodemask_t;
#line 81 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/numa.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 22 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_104 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 22 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_104 mm_context_t;
#line 18 "include/asm-generic/pci_iomap.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 40 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 87
struct vm_area_struct;
#line 339 "include/linux/clocksource.h"
struct device_node;
#line 796 "include/linux/mmzone.h"
struct rw_semaphore;
#line 797 "include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct lockdep_map dep_map ;
};
#line 347 "include/linux/irq.h"
struct proc_dir_entry;
#line 72 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/smap.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 59 "include/linux/hardirq.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 163 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 463 "include/linux/hrtimer.h"
struct kref {
   atomic_t refcount ;
};
#line 624 "include/linux/interrupt.h"
struct sock;
#line 625
struct kobject;
#line 626
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 632 "include/linux/interrupt.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 24 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_133 {
   uid_t val ;
};
#line 24 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_133 kuid_t;
#line 29 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_134 {
   gid_t val ;
};
#line 29 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_134 kgid_t;
#line 149 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 36 "include/linux/stat.h"
struct bin_attribute;
#line 37 "include/linux/stat.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 36 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 66 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 129 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct kobject * , struct attribute  const  * ) ;
};
#line 178
struct sysfs_dirent;
#line 50 "include/linux/kobject.h"
struct kset;
#line 50
struct kobj_type;
#line 50 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 111 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 119 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 126 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 143 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 218
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 42 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 42 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct iommu_ops;
#line 21
struct iommu_group;
#line 22 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type * , char * ) ;
   ssize_t (*store)(struct bus_type * , char const   * , size_t  ) ;
};
#line 59 "include/linux/device.h"
struct device_attribute;
#line 59
struct driver_attribute;
#line 59 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 141
struct device_type;
#line 198 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 263 "include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver * , char * ) ;
   ssize_t (*store)(struct device_driver * , char const   * , size_t  ) ;
};
#line 324
struct class_attribute;
#line 324 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct bin_attribute *dev_bin_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 421 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct class * , struct class_attribute  const  * ) ;
};
#line 477 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 505 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 616 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 625 "include/linux/device.h"
struct acpi_dev_node {
   void *handle ;
};
#line 630
struct dma_coherent_mem;
#line 630 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 772 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 93 "include/linux/bit_spinlock.h"
struct hlist_bl_node;
#line 93 "include/linux/bit_spinlock.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct_ldv_16410_136 {
   spinlock_t lock ;
   unsigned int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion_ldv_16411_135 {
   struct __anonstruct_ldv_16410_136 ldv_16410 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion_ldv_16411_135 ldv_16411 ;
};
#line 38 "include/linux/lockref.h"
struct nameidata;
#line 39
struct path;
#line 40
struct vfsmount;
#line 41 "include/linux/lockref.h"
struct __anonstruct_ldv_16432_138 {
   u32 hash ;
   u32 len ;
};
#line 41 "include/linux/lockref.h"
union __anonunion_ldv_16434_137 {
   struct __anonstruct_ldv_16432_138 ldv_16432 ;
   u64 hash_len ;
};
#line 41 "include/linux/lockref.h"
struct qstr {
   union __anonunion_ldv_16434_137 ldv_16434 ;
   unsigned char const   *name ;
};
#line 88 "include/linux/dcache.h"
struct inode;
#line 88
struct dentry_operations;
#line 88
struct super_block;
#line 88 "include/linux/dcache.h"
union __anonunion_d_u_139 {
   struct list_head d_child ;
   struct callback_head d_rcu ;
};
#line 88 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_139 d_u ;
   struct list_head d_subdirs ;
   struct hlist_node d_alias ;
};
#line 140 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 403 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 26 "include/linux/path.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_head list ;
   long nr_items ;
};
#line 28 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   nodemask_t active_nodes ;
};
#line 131
struct llist_node;
#line 131 "include/linux/list_lru.h"
struct llist_head {
   struct llist_node *first ;
};
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node;
#line 58 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 381
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 388
struct pid_namespace;
#line 388 "include/linux/radix-tree.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/fiemap.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   nodemask_t nodes_to_scan ;
   int nid ;
};
#line 26 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 70
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 30 "include/linux/percpu-rwsem.h"
struct block_device;
#line 31
struct io_context;
#line 56 "include/uapi/linux/fs.h"
struct export_operations;
#line 58
struct iovec;
#line 59
struct kiocb;
#line 60
struct pipe_inode_info;
#line 61
struct poll_table_struct;
#line 62
struct kstatfs;
#line 63
struct cred;
#line 64
struct swap_info_struct;
#line 68 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 243 "include/linux/fs.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 176 "include/linux/percpu_counter.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8U] ;
};
#line 76 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 151 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 152 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 166 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestatv {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
   __u32 qfs_pad ;
};
#line 196 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_statv {
   __s8 qs_version ;
   __u8 qs_pad1 ;
   __u16 qs_flags ;
   __u32 qs_incoredqs ;
   struct fs_qfilestatv qs_uquota ;
   struct fs_qfilestatv qs_gquota ;
   struct fs_qfilestatv qs_pquota ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
   __u64 qs_pad2[8U] ;
};
#line 212
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 25 "include/linux/projid.h"
struct __anonstruct_kprojid_t_141 {
   projid_t val ;
};
#line 25 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_141 kprojid_t;
#line 119 "include/uapi/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 152
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 60 "include/linux/quota.h"
typedef long long qsize_t;
#line 61 "include/linux/quota.h"
union __anonunion_ldv_17577_142 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 61 "include/linux/quota.h"
struct kqid {
   union __anonunion_ldv_17577_142 ldv_17577 ;
   enum quota_type type ;
};
#line 178 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 200
struct quota_format_type;
#line 201 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 264 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 291 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 302 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 316 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xstatev)(struct super_block * , struct fs_quota_statv * ) ;
};
#line 333 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 379 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 410
struct address_space;
#line 411
struct writeback_control;
#line 342 "include/linux/fs.h"
union __anonunion_arg_144 {
   char *buf ;
   void *data ;
};
#line 342 "include/linux/fs.h"
struct __anonstruct_read_descriptor_t_143 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_144 arg ;
   int error ;
};
#line 342 "include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_143 read_descriptor_t;
#line 345 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  * , loff_t  ,
                        unsigned long  ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 405
struct backing_dev_info;
#line 406 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct rb_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 427
struct request_queue;
#line 428
struct hd_struct;
#line 428
struct gendisk;
#line 428 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 500
struct posix_acl;
#line 501
struct inode_operations;
#line 501 "include/linux/fs.h"
union __anonunion_ldv_18024_145 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 501 "include/linux/fs.h"
union __anonunion_ldv_18044_146 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 501
struct file_lock;
#line 501
struct cdev;
#line 501 "include/linux/fs.h"
union __anonunion_ldv_18060_147 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 501 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_ldv_18024_145 ldv_18024 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_ldv_18044_146 ldv_18044 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   struct file_operations  const  *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2U] ;
   struct list_head i_devices ;
   union __anonunion_ldv_18060_147 ldv_18060 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   atomic_t i_readcount ;
   void *i_private ;
};
#line 731 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 739 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 762 "include/linux/fs.h"
union __anonunion_f_u_148 {
   struct list_head fu_list ;
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 762 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_148 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   int f_sb_list_cpu ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
   unsigned long f_mnt_write_state ;
};
#line 906
struct files_struct;
#line 906 "include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 907 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 912 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int  ) ;
};
#line 930
struct nlm_lockowner;
#line 931 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_150 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_149 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_150 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_149 fl_u ;
};
#line 1033 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1225 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1241
struct file_system_type;
#line 1241
struct super_operations;
#line 1241
struct xattr_handler;
#line 1241
struct mtd_info;
#line 1241 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head *s_files ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
};
#line 1475 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1513 "include/linux/fs.h"
struct dir_context {
   int (*actor)(void * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1518 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   int (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1556 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
};
#line 1600 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , int  ) ;
   long (*free_cached_objects)(struct super_block * , long  , int  ) ;
};
#line 1814 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 42 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 60 "include/linux/uprobes.h"
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 67
struct return_instance;
#line 67
struct uprobe;
#line 67 "include/linux/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   struct arch_uprobe_task autask ;
   struct return_instance *return_instances ;
   unsigned int depth ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   unsigned long vaddr ;
};
#line 83 "include/linux/uprobes.h"
struct xol_area {
   wait_queue_head_t wq ;
   atomic_t slot_count ;
   unsigned long *bitmap ;
   struct page *page ;
   unsigned long vaddr ;
};
#line 102 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 128 "include/linux/uprobes.h"
union __anonunion_ldv_20205_152 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 128 "include/linux/uprobes.h"
struct __anonstruct_ldv_20215_156 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 128 "include/linux/uprobes.h"
union __anonunion_ldv_20217_155 {
   atomic_t _mapcount ;
   struct __anonstruct_ldv_20215_156 ldv_20215 ;
   int units ;
};
#line 128 "include/linux/uprobes.h"
struct __anonstruct_ldv_20219_154 {
   union __anonunion_ldv_20217_155 ldv_20217 ;
   atomic_t _count ;
};
#line 128 "include/linux/uprobes.h"
union __anonunion_ldv_20220_153 {
   unsigned long counters ;
   struct __anonstruct_ldv_20219_154 ldv_20219 ;
};
#line 128 "include/linux/uprobes.h"
struct __anonstruct_ldv_20221_151 {
   union __anonunion_ldv_20205_152 ldv_20205 ;
   union __anonunion_ldv_20220_153 ldv_20220 ;
};
#line 128 "include/linux/uprobes.h"
struct __anonstruct_ldv_20228_158 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 128
struct slab;
#line 128 "include/linux/uprobes.h"
union __anonunion_ldv_20232_157 {
   struct list_head lru ;
   struct __anonstruct_ldv_20228_158 ldv_20228 ;
   struct list_head list ;
   struct slab *slab_page ;
};
#line 128 "include/linux/uprobes.h"
union __anonunion_ldv_20237_159 {
   unsigned long private ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 128 "include/linux/uprobes.h"
struct page {
   unsigned long flags ;
   struct address_space *mapping ;
   struct __anonstruct_ldv_20221_151 ldv_20221 ;
   union __anonunion_ldv_20232_157 ldv_20232 ;
   union __anonunion_ldv_20237_159 ldv_20237 ;
   unsigned long debug_flags ;
};
#line 168 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 220 "include/linux/mm_types.h"
struct __anonstruct_linear_161 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 220 "include/linux/mm_types.h"
union __anonunion_shared_160 {
   struct __anonstruct_linear_161 linear ;
   struct list_head nonlinear ;
};
#line 220
struct anon_vma;
#line 220
struct vm_operations_struct;
#line 220
struct mempolicy;
#line 220 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   union __anonunion_shared_160 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 292 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 298 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 311 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 324
struct kioctx_table;
#line 325
struct linux_binfmt;
#line 325
struct mmu_notifier_mm;
#line 325 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[44U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   pgtable_t pmd_huge_pte ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_next_reset ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   int first_nid ;
   struct uprobes_state uprobes_state ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 24 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_162 {
   unsigned long sig[1U] ;
};
#line 24 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_162 sigset_t;
#line 25
struct siginfo;
#line 17 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_164 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_165 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_166 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_167 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_168 {
   void *_addr ;
   short _addr_lsb ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_169 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_170 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_163 {
   int _pad[28U] ;
   struct __anonstruct__kill_164 _kill ;
   struct __anonstruct__timer_165 _timer ;
   struct __anonstruct__rt_166 _rt ;
   struct __anonstruct__sigchld_167 _sigchld ;
   struct __anonstruct__sigfault_168 _sigfault ;
   struct __anonstruct__sigpoll_169 _sigpoll ;
   struct __anonstruct__sigsys_170 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_163 _sifields ;
};
#line 109 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 11 "include/linux/signal.h"
struct user_struct;
#line 21 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 251 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 265 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 46 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 47 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 80 "include/linux/seccomp.h"
struct plist_head {
   struct list_head node_list ;
};
#line 84 "include/linux/seccomp.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 38 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
#line 11 "include/linux/resource.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 835 "include/uapi/linux/sysctl.h"
struct nsproxy;
#line 30 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 33 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 34
struct key;
#line 35
struct signal_struct;
#line 36
struct key_type;
#line 38
struct keyring_list;
#line 116 "include/linux/key.h"
union __anonunion_ldv_21902_175 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 116
struct key_user;
#line 116 "include/linux/key.h"
union __anonunion_ldv_21911_176 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 116 "include/linux/key.h"
union __anonunion_type_data_177 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 116 "include/linux/key.h"
union __anonunion_payload_178 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   struct keyring_list *subscriptions ;
};
#line 116 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_ldv_21902_175 ldv_21902 ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_ldv_21911_176 ldv_21911 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_177 type_data ;
   union __anonunion_payload_178 payload ;
};
#line 323
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 78 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 344
struct futex_pi_state;
#line 345
struct robust_list_head;
#line 346
struct bio_list;
#line 347
struct fs_struct;
#line 348
struct perf_event_context;
#line 349
struct blk_plug;
#line 113 "include/linux/sched.h"
struct cfs_rq;
#line 114
struct task_group;
#line 324 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 371 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 379 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 386 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 398 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 418 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 454
struct autogroup;
#line 455
struct tty_struct;
#line 455
struct taskstats;
#line 455
struct tty_audit_buf;
#line 455 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 634 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 678
struct reclaim_state;
#line 679 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 694 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 906 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
#line 913 "include/linux/sched.h"
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
#line 925 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 960 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 991
struct rt_rq;
#line 991 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1015
struct mem_cgroup;
#line 1015 "include/linux/sched.h"
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
#line 1395 "include/linux/sched.h"
struct memcg_oom_info {
   unsigned char may_oom : 1 ;
   unsigned char in_memcg_oom : 1 ;
   unsigned char oom_locked : 1 ;
   int wakeups ;
   struct mem_cgroup *wait_on_memcg ;
};
#line 1403
struct sched_class;
#line 1403
struct css_set;
#line 1403
struct compat_robust_list_head;
#line 1403 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct hlist_head preempt_notifiers ;
   unsigned char fpu_counter ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char did_exec : 1 ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char no_new_privs : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   int numa_migrate_seq ;
   unsigned int numa_scan_period ;
   u64 node_stamp ;
   struct callback_head numa_work ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   unsigned int memcg_kmem_skip_account ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
};
#line 258 "include/linux/pm_runtime.h"
struct usb_device;
#line 259
struct usb_driver;
#line 260
struct wusb_dev;
#line 261
struct ep_device;
#line 262 "include/linux/pm_runtime.h"
struct usb_host_endpoint {
   struct usb_endpoint_descriptor desc ;
   struct usb_ss_ep_comp_descriptor ss_ep_comp ;
   struct list_head urb_list ;
   void *hcpriv ;
   struct ep_device *ep_dev ;
   unsigned char *extra ;
   int extralen ;
   int enabled ;
};
#line 75 "include/linux/usb.h"
struct usb_host_interface {
   struct usb_interface_descriptor desc ;
   int extralen ;
   unsigned char *extra ;
   struct usb_host_endpoint *endpoint ;
   char *string ;
};
#line 90
enum usb_interface_condition {
    USB_INTERFACE_UNBOUND = 0,
    USB_INTERFACE_BINDING = 1,
    USB_INTERFACE_BOUND = 2,
    USB_INTERFACE_UNBINDING = 3
} ;
#line 97 "include/linux/usb.h"
struct usb_interface {
   struct usb_host_interface *altsetting ;
   struct usb_host_interface *cur_altsetting ;
   unsigned int num_altsetting ;
   struct usb_interface_assoc_descriptor *intf_assoc ;
   int minor ;
   enum usb_interface_condition condition ;
   unsigned char sysfs_files_created : 1 ;
   unsigned char ep_devs_created : 1 ;
   unsigned char unregistering : 1 ;
   unsigned char needs_remote_wakeup : 1 ;
   unsigned char needs_altsetting0 : 1 ;
   unsigned char needs_binding : 1 ;
   unsigned char reset_running : 1 ;
   unsigned char resetting_device : 1 ;
   struct device dev ;
   struct device *usb_dev ;
   atomic_t pm_usage_cnt ;
   struct work_struct reset_ws ;
};
#line 204 "include/linux/usb.h"
struct usb_interface_cache {
   unsigned int num_altsetting ;
   struct kref ref ;
   struct usb_host_interface altsetting[0U] ;
};
#line 231 "include/linux/usb.h"
struct usb_host_config {
   struct usb_config_descriptor desc ;
   char *string ;
   struct usb_interface_assoc_descriptor *intf_assoc[16U] ;
   struct usb_interface *interface[32U] ;
   struct usb_interface_cache *intf_cache[32U] ;
   unsigned char *extra ;
   int extralen ;
};
#line 295 "include/linux/usb.h"
struct usb_host_bos {
   struct usb_bos_descriptor *desc ;
   struct usb_ext_cap_descriptor *ext_cap ;
   struct usb_ss_cap_descriptor *ss_cap ;
   struct usb_ss_container_id_descriptor *ss_id ;
};
#line 307 "include/linux/usb.h"
struct usb_devmap {
   unsigned long devicemap[2U] ;
};
#line 319
struct mon_bus;
#line 319 "include/linux/usb.h"
struct usb_bus {
   struct device *controller ;
   int busnum ;
   char const   *bus_name ;
   u8 uses_dma ;
   u8 uses_pio_for_control ;
   u8 otg_port ;
   unsigned char is_b_host : 1 ;
   unsigned char b_hnp_enable : 1 ;
   unsigned char no_stop_on_short : 1 ;
   unsigned char no_sg_constraint : 1 ;
   unsigned int sg_tablesize ;
   int devnum_next ;
   struct usb_devmap devmap ;
   struct usb_device *root_hub ;
   struct usb_bus *hs_companion ;
   struct list_head bus_list ;
   int bandwidth_allocated ;
   int bandwidth_int_reqs ;
   int bandwidth_isoc_reqs ;
   unsigned int resuming_ports ;
   struct mon_bus *mon_bus ;
   int monitored ;
};
#line 367
struct usb_tt;
#line 368
enum usb_device_removable {
    USB_DEVICE_REMOVABLE_UNKNOWN = 0,
    USB_DEVICE_REMOVABLE = 1,
    USB_DEVICE_FIXED = 2
} ;
#line 381 "include/linux/usb.h"
struct usb2_lpm_parameters {
   unsigned int besl ;
   int timeout ;
};
#line 401 "include/linux/usb.h"
struct usb3_lpm_parameters {
   unsigned int mel ;
   unsigned int pel ;
   unsigned int sel ;
   int timeout ;
};
#line 440 "include/linux/usb.h"
struct usb_device {
   int devnum ;
   char devpath[16U] ;
   u32 route ;
   enum usb_device_state state ;
   enum usb_device_speed speed ;
   struct usb_tt *tt ;
   int ttport ;
   unsigned int toggle[2U] ;
   struct usb_device *parent ;
   struct usb_bus *bus ;
   struct usb_host_endpoint ep0 ;
   struct device dev ;
   struct usb_device_descriptor descriptor ;
   struct usb_host_bos *bos ;
   struct usb_host_config *config ;
   struct usb_host_config *actconfig ;
   struct usb_host_endpoint *ep_in[16U] ;
   struct usb_host_endpoint *ep_out[16U] ;
   char **rawdescriptors ;
   unsigned short bus_mA ;
   u8 portnum ;
   u8 level ;
   unsigned char can_submit : 1 ;
   unsigned char persist_enabled : 1 ;
   unsigned char have_langid : 1 ;
   unsigned char authorized : 1 ;
   unsigned char authenticated : 1 ;
   unsigned char wusb : 1 ;
   unsigned char lpm_capable : 1 ;
   unsigned char usb2_hw_lpm_capable : 1 ;
   unsigned char usb2_hw_lpm_besl_capable : 1 ;
   unsigned char usb2_hw_lpm_enabled : 1 ;
   unsigned char usb3_lpm_enabled : 1 ;
   int string_langid ;
   char *product ;
   char *manufacturer ;
   char *serial ;
   struct list_head filelist ;
   int maxchild ;
   u32 quirks ;
   atomic_t urbnum ;
   unsigned long active_duration ;
   unsigned long connect_time ;
   unsigned char do_remote_wakeup : 1 ;
   unsigned char reset_resume : 1 ;
   unsigned char port_is_suspended : 1 ;
   struct wusb_dev *wusb_dev ;
   int slot_id ;
   enum usb_device_removable removable ;
   struct usb2_lpm_parameters l1_params ;
   struct usb3_lpm_parameters u1_params ;
   struct usb3_lpm_parameters u2_params ;
   unsigned int lpm_disable_count ;
};
#line 783 "include/linux/usb.h"
struct usb_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 970 "include/linux/usb.h"
struct usbdrv_wrap {
   struct device_driver driver ;
   int for_devices ;
};
#line 980 "include/linux/usb.h"
struct usb_driver {
   char const   *name ;
   int (*probe)(struct usb_interface * , struct usb_device_id  const  * ) ;
   void (*disconnect)(struct usb_interface * ) ;
   int (*unlocked_ioctl)(struct usb_interface * , unsigned int  , void * ) ;
   int (*suspend)(struct usb_interface * , pm_message_t  ) ;
   int (*resume)(struct usb_interface * ) ;
   int (*reset_resume)(struct usb_interface * ) ;
   int (*pre_reset)(struct usb_interface * ) ;
   int (*post_reset)(struct usb_interface * ) ;
   struct usb_device_id  const  *id_table ;
   struct usb_dynids dynids ;
   struct usbdrv_wrap drvwrap ;
   unsigned char no_dynamic_id : 1 ;
   unsigned char supports_autosuspend : 1 ;
   unsigned char disable_hub_initiated_lpm : 1 ;
   unsigned char soft_unbind : 1 ;
};
#line 1163 "include/linux/usb.h"
struct usb_iso_packet_descriptor {
   unsigned int offset ;
   unsigned int length ;
   unsigned int actual_length ;
   int status ;
};
#line 1205
struct urb;
#line 1206 "include/linux/usb.h"
struct usb_anchor {
   struct list_head urb_list ;
   wait_queue_head_t wait ;
   spinlock_t lock ;
   unsigned char poisoned : 1 ;
};
#line 1223
struct scatterlist;
#line 1223 "include/linux/usb.h"
struct urb {
   struct kref kref ;
   void *hcpriv ;
   atomic_t use_count ;
   atomic_t reject ;
   int unlinked ;
   struct list_head urb_list ;
   struct list_head anchor_list ;
   struct usb_anchor *anchor ;
   struct usb_device *dev ;
   struct usb_host_endpoint *ep ;
   unsigned int pipe ;
   unsigned int stream_id ;
   int status ;
   unsigned int transfer_flags ;
   void *transfer_buffer ;
   dma_addr_t transfer_dma ;
   struct scatterlist *sg ;
   int num_mapped_sgs ;
   int num_sgs ;
   u32 transfer_buffer_length ;
   u32 actual_length ;
   unsigned char *setup_packet ;
   dma_addr_t setup_dma ;
   int start_frame ;
   int number_of_packets ;
   int interval ;
   int error_count ;
   void *context ;
   void (*complete)(struct urb * ) ;
   struct usb_iso_packet_descriptor iso_frame_desc[0U] ;
};
#line 6 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/termbits.h"
typedef unsigned char cc_t;
#line 7 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/termbits.h"
typedef unsigned int speed_t;
#line 8 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/termbits.h"
typedef unsigned int tcflag_t;
#line 30 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/termbits.h"
struct ktermios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[19U] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 41 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/termbits.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 93 "include/asm-generic/termios.h"
struct termiox {
   __u16 x_hflag ;
   __u16 x_cflag ;
   __u16 x_rflag[5U] ;
   __u16 x_sflag ;
};
#line 16 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/termios.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
#line 34 "include/linux/cdev.h"
struct tty_driver;
#line 35
struct serial_icounter_struct;
#line 36 "include/linux/cdev.h"
struct tty_operations {
   struct tty_struct *(*lookup)(struct tty_driver * , struct inode * , int  ) ;
   int (*install)(struct tty_driver * , struct tty_struct * ) ;
   void (*remove)(struct tty_driver * , struct tty_struct * ) ;
   int (*open)(struct tty_struct * , struct file * ) ;
   void (*close)(struct tty_struct * , struct file * ) ;
   void (*shutdown)(struct tty_struct * ) ;
   void (*cleanup)(struct tty_struct * ) ;
   int (*write)(struct tty_struct * , unsigned char const   * , int  ) ;
   int (*put_char)(struct tty_struct * , unsigned char  ) ;
   void (*flush_chars)(struct tty_struct * ) ;
   int (*write_room)(struct tty_struct * ) ;
   int (*chars_in_buffer)(struct tty_struct * ) ;
   int (*ioctl)(struct tty_struct * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct tty_struct * , unsigned int  , unsigned long  ) ;
   void (*set_termios)(struct tty_struct * , struct ktermios * ) ;
   void (*throttle)(struct tty_struct * ) ;
   void (*unthrottle)(struct tty_struct * ) ;
   void (*stop)(struct tty_struct * ) ;
   void (*start)(struct tty_struct * ) ;
   void (*hangup)(struct tty_struct * ) ;
   int (*break_ctl)(struct tty_struct * , int  ) ;
   void (*flush_buffer)(struct tty_struct * ) ;
   void (*set_ldisc)(struct tty_struct * ) ;
   void (*wait_until_sent)(struct tty_struct * , int  ) ;
   void (*send_xchar)(struct tty_struct * , char  ) ;
   int (*tiocmget)(struct tty_struct * ) ;
   int (*tiocmset)(struct tty_struct * , unsigned int  , unsigned int  ) ;
   int (*resize)(struct tty_struct * , struct winsize * ) ;
   int (*set_termiox)(struct tty_struct * , struct termiox * ) ;
   int (*get_icount)(struct tty_struct * , struct serial_icounter_struct * ) ;
   int (*poll_init)(struct tty_driver * , int  , char * ) ;
   int (*poll_get_char)(struct tty_driver * , int  ) ;
   void (*poll_put_char)(struct tty_driver * , int  , char  ) ;
   struct file_operations  const  *proc_fops ;
};
#line 289 "include/linux/tty_driver.h"
struct tty_port;
#line 289 "include/linux/tty_driver.h"
struct tty_driver {
   int magic ;
   struct kref kref ;
   struct cdev *cdevs ;
   struct module *owner ;
   char const   *driver_name ;
   char const   *name ;
   int name_base ;
   int major ;
   int minor_start ;
   unsigned int num ;
   short type ;
   short subtype ;
   struct ktermios init_termios ;
   unsigned long flags ;
   struct proc_dir_entry *proc_entry ;
   struct tty_driver *other ;
   struct tty_struct **ttys ;
   struct tty_port **ports ;
   struct ktermios **termios ;
   void *driver_state ;
   struct tty_operations  const  *ops ;
   struct list_head tty_drivers ;
};
#line 356 "include/linux/tty_driver.h"
struct ld_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   unsigned int wait_readers ;
   struct list_head read_wait ;
   struct list_head write_wait ;
   struct lockdep_map dep_map ;
};
#line 166 "include/linux/tty_ldisc.h"
struct tty_ldisc_ops {
   int magic ;
   char *name ;
   int num ;
   int flags ;
   int (*open)(struct tty_struct * ) ;
   void (*close)(struct tty_struct * ) ;
   void (*flush_buffer)(struct tty_struct * ) ;
   ssize_t (*chars_in_buffer)(struct tty_struct * ) ;
   ssize_t (*read)(struct tty_struct * , struct file * , unsigned char * , size_t  ) ;
   ssize_t (*write)(struct tty_struct * , struct file * , unsigned char const   * ,
                    size_t  ) ;
   int (*ioctl)(struct tty_struct * , struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct tty_struct * , struct file * , unsigned int  , unsigned long  ) ;
   void (*set_termios)(struct tty_struct * , struct ktermios * ) ;
   unsigned int (*poll)(struct tty_struct * , struct file * , struct poll_table_struct * ) ;
   int (*hangup)(struct tty_struct * ) ;
   void (*receive_buf)(struct tty_struct * , unsigned char const   * , char * , int  ) ;
   void (*write_wakeup)(struct tty_struct * ) ;
   void (*dcd_change)(struct tty_struct * , unsigned int  ) ;
   void (*fasync)(struct tty_struct * , int  ) ;
   int (*receive_buf2)(struct tty_struct * , unsigned char const   * , char * , int  ) ;
   struct module *owner ;
   int refcount ;
};
#line 216 "include/linux/tty_ldisc.h"
struct tty_ldisc {
   struct tty_ldisc_ops *ops ;
   struct tty_struct *tty ;
};
#line 221 "include/linux/tty_ldisc.h"
union __anonunion_ldv_24795_180 {
   struct tty_buffer *next ;
   struct llist_node free ;
};
#line 221 "include/linux/tty_ldisc.h"
struct tty_buffer {
   union __anonunion_ldv_24795_180 ldv_24795 ;
   int used ;
   int size ;
   int commit ;
   int read ;
   unsigned long data[0U] ;
};
#line 55 "include/linux/tty.h"
struct tty_bufhead {
   struct tty_buffer *head ;
   struct work_struct work ;
   struct mutex lock ;
   atomic_t priority ;
   struct tty_buffer sentinel ;
   struct llist_head free ;
   atomic_t memory_used ;
   struct tty_buffer *tail ;
};
#line 66 "include/linux/tty.h"
struct tty_port_operations {
   int (*carrier_raised)(struct tty_port * ) ;
   void (*dtr_rts)(struct tty_port * , int  ) ;
   void (*shutdown)(struct tty_port * ) ;
   void (*drop)(struct tty_port * ) ;
   int (*activate)(struct tty_port * , struct tty_struct * ) ;
   void (*destruct)(struct tty_port * ) ;
};
#line 192 "include/linux/tty.h"
struct tty_port {
   struct tty_bufhead buf ;
   struct tty_struct *tty ;
   struct tty_struct *itty ;
   struct tty_port_operations  const  *ops ;
   spinlock_t lock ;
   int blocked_open ;
   int count ;
   wait_queue_head_t open_wait ;
   wait_queue_head_t close_wait ;
   wait_queue_head_t delta_msr_wait ;
   unsigned long flags ;
   unsigned char console : 1 ;
   unsigned char low_latency : 1 ;
   struct mutex mutex ;
   struct mutex buf_mutex ;
   unsigned char *xmit_buf ;
   unsigned int close_delay ;
   unsigned int closing_wait ;
   int drain_delay ;
   struct kref kref ;
};
#line 217 "include/linux/tty.h"
struct tty_struct {
   int magic ;
   struct kref kref ;
   struct device *dev ;
   struct tty_driver *driver ;
   struct tty_operations  const  *ops ;
   int index ;
   struct ld_semaphore ldisc_sem ;
   struct tty_ldisc *ldisc ;
   struct mutex atomic_write_lock ;
   struct mutex legacy_mutex ;
   struct mutex throttle_mutex ;
   struct rw_semaphore termios_rwsem ;
   struct mutex winsize_mutex ;
   spinlock_t ctrl_lock ;
   struct ktermios termios ;
   struct ktermios termios_locked ;
   struct termiox *termiox ;
   char name[64U] ;
   struct pid *pgrp ;
   struct pid *session ;
   unsigned long flags ;
   int count ;
   struct winsize winsize ;
   unsigned char stopped : 1 ;
   unsigned char hw_stopped : 1 ;
   unsigned char flow_stopped : 1 ;
   unsigned char packet : 1 ;
   unsigned char ctrl_status ;
   unsigned int receive_room ;
   int flow_change ;
   struct tty_struct *link ;
   struct fasync_struct *fasync ;
   int alt_speed ;
   wait_queue_head_t write_wait ;
   wait_queue_head_t read_wait ;
   struct work_struct hangup_work ;
   void *disc_data ;
   void *driver_data ;
   struct list_head tty_files ;
   unsigned char closing : 1 ;
   unsigned char *write_buf ;
   int write_cnt ;
   struct work_struct SAK_work ;
   struct tty_port *port ;
};
#line 348 "include/linux/slab.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   unsigned int stat[26U] ;
};
#line 48 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 58
struct memcg_cache_params;
#line 58
struct kmem_cache_node;
#line 58 "include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct memcg_cache_params *memcg_params ;
   int max_attr_size ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
#line 445 "include/linux/slab.h"
struct __anonstruct_ldv_25537_182 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache *root_cache ;
   bool dead ;
   atomic_t nr_pages ;
   struct work_struct destroy ;
};
#line 445 "include/linux/slab.h"
union __anonunion_ldv_25538_181 {
   struct kmem_cache *memcg_caches[0U] ;
   struct __anonstruct_ldv_25537_182 ldv_25537 ;
};
#line 445 "include/linux/slab.h"
struct memcg_cache_params {
   bool is_root_cache ;
   union __anonunion_ldv_25538_181 ldv_25538 ;
};
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct videobuf_queue;
#line 35
struct videobuf_buffer;
#line 37
struct v4l2_buffer;
#line 41
struct v4l2_streamparm;
#line 46
struct v4l2_format;
#line 51
struct v4l2_event_subscription;
#line 53
struct v4l2_fh;
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 48 "include/linux/elf.h"
struct kernel_param;
#line 53 "include/linux/elf.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 58 "include/linux/moduleparam.h"
struct kparam_string;
#line 58
struct kparam_array;
#line 58 "include/linux/moduleparam.h"
union __anonunion_ldv_26089_187 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 58 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion_ldv_26089_187 ldv_26089 ;
};
#line 70 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 76 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 463
struct tracepoint;
#line 464 "include/linux/moduleparam.h"
struct tracepoint_func {
   void *func ;
   void *data ;
};
#line 29 "include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   struct static_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
#line 86 "include/linux/tracepoint.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 47 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 207
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 214 "include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
#line 228
struct module_sect_attrs;
#line 228
struct module_notes_attrs;
#line 228
struct ftrace_event_call;
#line 228 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct list_head source_list ;
   struct list_head target_list ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 654 "include/linux/module.h"
struct firmware {
   size_t size ;
   u8 const   *data ;
   struct page **pages ;
   void *priv ;
};
#line 519 "include/linux/firmware.h"
enum v4l2_field {
    V4L2_FIELD_ANY = 0,
    V4L2_FIELD_NONE = 1,
    V4L2_FIELD_TOP = 2,
    V4L2_FIELD_BOTTOM = 3,
    V4L2_FIELD_INTERLACED = 4,
    V4L2_FIELD_SEQ_TB = 5,
    V4L2_FIELD_SEQ_BT = 6,
    V4L2_FIELD_ALTERNATE = 7,
    V4L2_FIELD_INTERLACED_TB = 8,
    V4L2_FIELD_INTERLACED_BT = 9
} ;
#line 532
enum v4l2_buf_type {
    V4L2_BUF_TYPE_VIDEO_CAPTURE = 1,
    V4L2_BUF_TYPE_VIDEO_OUTPUT = 2,
    V4L2_BUF_TYPE_VIDEO_OVERLAY = 3,
    V4L2_BUF_TYPE_VBI_CAPTURE = 4,
    V4L2_BUF_TYPE_VBI_OUTPUT = 5,
    V4L2_BUF_TYPE_SLICED_VBI_CAPTURE = 6,
    V4L2_BUF_TYPE_SLICED_VBI_OUTPUT = 7,
    V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8,
    V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE = 9,
    V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE = 10,
    V4L2_BUF_TYPE_PRIVATE = 128
} ;
#line 552
enum v4l2_memory {
    V4L2_MEMORY_MMAP = 1,
    V4L2_MEMORY_USERPTR = 2,
    V4L2_MEMORY_OVERLAY = 3,
    V4L2_MEMORY_DMABUF = 4
} ;
#line 570
enum v4l2_priority {
    V4L2_PRIORITY_UNSET = 0,
    V4L2_PRIORITY_BACKGROUND = 1,
    V4L2_PRIORITY_INTERACTIVE = 2,
    V4L2_PRIORITY_RECORD = 3,
    V4L2_PRIORITY_DEFAULT = 2
} ;
#line 578 "include/linux/firmware.h"
struct v4l2_rect {
   __s32 left ;
   __s32 top ;
   __s32 width ;
   __s32 height ;
};
#line 213 "include/uapi/linux/videodev2.h"
struct v4l2_fract {
   __u32 numerator ;
   __u32 denominator ;
};
#line 218 "include/uapi/linux/videodev2.h"
struct v4l2_capability {
   __u8 driver[16U] ;
   __u8 card[32U] ;
   __u8 bus_info[32U] ;
   __u32 version ;
   __u32 capabilities ;
   __u32 device_caps ;
   __u32 reserved[3U] ;
};
#line 239 "include/uapi/linux/videodev2.h"
struct v4l2_pix_format {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   __u32 field ;
   __u32 bytesperline ;
   __u32 sizeimage ;
   __u32 colorspace ;
   __u32 priv ;
};
#line 286 "include/uapi/linux/videodev2.h"
struct v4l2_fmtdesc {
   __u32 index ;
   __u32 type ;
   __u32 flags ;
   __u8 description[32U] ;
   __u32 pixelformat ;
   __u32 reserved[4U] ;
};
#line 451 "include/uapi/linux/videodev2.h"
struct v4l2_frmsize_discrete {
   __u32 width ;
   __u32 height ;
};
#line 464 "include/uapi/linux/videodev2.h"
struct v4l2_frmsize_stepwise {
   __u32 min_width ;
   __u32 max_width ;
   __u32 step_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u32 step_height ;
};
#line 473 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_27008_188 {
   struct v4l2_frmsize_discrete discrete ;
   struct v4l2_frmsize_stepwise stepwise ;
};
#line 473 "include/uapi/linux/videodev2.h"
struct v4l2_frmsizeenum {
   __u32 index ;
   __u32 pixel_format ;
   __u32 type ;
   union __anonunion_ldv_27008_188 ldv_27008 ;
   __u32 reserved[2U] ;
};
#line 492 "include/uapi/linux/videodev2.h"
struct v4l2_frmival_stepwise {
   struct v4l2_fract min ;
   struct v4l2_fract max ;
   struct v4l2_fract step ;
};
#line 501 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_27027_189 {
   struct v4l2_fract discrete ;
   struct v4l2_frmival_stepwise stepwise ;
};
#line 501 "include/uapi/linux/videodev2.h"
struct v4l2_frmivalenum {
   __u32 index ;
   __u32 pixel_format ;
   __u32 width ;
   __u32 height ;
   __u32 type ;
   union __anonunion_ldv_27027_189 ldv_27027 ;
   __u32 reserved[2U] ;
};
#line 516 "include/uapi/linux/videodev2.h"
struct v4l2_timecode {
   __u32 type ;
   __u32 flags ;
   __u8 frames ;
   __u8 seconds ;
   __u8 minutes ;
   __u8 hours ;
   __u8 userbits[4U] ;
};
#line 530 "include/uapi/linux/videodev2.h"
struct v4l2_jpegcompression {
   int quality ;
   int APPn ;
   int APP_len ;
   char APP_data[60U] ;
   int COM_len ;
   char COM_data[60U] ;
   __u32 jpeg_markers ;
};
#line 559 "include/uapi/linux/videodev2.h"
struct v4l2_requestbuffers {
   __u32 count ;
   __u32 type ;
   __u32 memory ;
   __u32 reserved[2U] ;
};
#line 584 "include/uapi/linux/videodev2.h"
union __anonunion_m_190 {
   __u32 mem_offset ;
   unsigned long userptr ;
   __s32 fd ;
};
#line 584 "include/uapi/linux/videodev2.h"
struct v4l2_plane {
   __u32 bytesused ;
   __u32 length ;
   union __anonunion_m_190 m ;
   __u32 data_offset ;
   __u32 reserved[11U] ;
};
#line 616 "include/uapi/linux/videodev2.h"
union __anonunion_m_191 {
   __u32 offset ;
   unsigned long userptr ;
   struct v4l2_plane *planes ;
   __s32 fd ;
};
#line 616 "include/uapi/linux/videodev2.h"
struct v4l2_buffer {
   __u32 index ;
   __u32 type ;
   __u32 bytesused ;
   __u32 flags ;
   __u32 field ;
   struct timeval timestamp ;
   struct v4l2_timecode timecode ;
   __u32 sequence ;
   __u32 memory ;
   union __anonunion_m_191 m ;
   __u32 length ;
   __u32 reserved2 ;
   __u32 reserved ;
};
#line 670 "include/uapi/linux/videodev2.h"
struct v4l2_exportbuffer {
   __u32 type ;
   __u32 index ;
   __u32 plane ;
   __u32 flags ;
   __s32 fd ;
   __u32 reserved[11U] ;
};
#line 717 "include/uapi/linux/videodev2.h"
struct v4l2_framebuffer {
   __u32 capability ;
   __u32 flags ;
   void *base ;
   struct v4l2_pix_format fmt ;
};
#line 729 "include/uapi/linux/videodev2.h"
struct v4l2_clip {
   struct v4l2_rect c ;
   struct v4l2_clip *next ;
};
#line 751 "include/uapi/linux/videodev2.h"
struct v4l2_window {
   struct v4l2_rect w ;
   __u32 field ;
   __u32 chromakey ;
   struct v4l2_clip *clips ;
   __u32 clipcount ;
   void *bitmap ;
   __u8 global_alpha ;
};
#line 761 "include/uapi/linux/videodev2.h"
struct v4l2_captureparm {
   __u32 capability ;
   __u32 capturemode ;
   struct v4l2_fract timeperframe ;
   __u32 extendedmode ;
   __u32 readbuffers ;
   __u32 reserved[4U] ;
};
#line 773 "include/uapi/linux/videodev2.h"
struct v4l2_outputparm {
   __u32 capability ;
   __u32 outputmode ;
   struct v4l2_fract timeperframe ;
   __u32 extendedmode ;
   __u32 writebuffers ;
   __u32 reserved[4U] ;
};
#line 786 "include/uapi/linux/videodev2.h"
struct v4l2_cropcap {
   __u32 type ;
   struct v4l2_rect bounds ;
   struct v4l2_rect defrect ;
   struct v4l2_fract pixelaspect ;
};
#line 796 "include/uapi/linux/videodev2.h"
struct v4l2_crop {
   __u32 type ;
   struct v4l2_rect c ;
};
#line 801 "include/uapi/linux/videodev2.h"
struct v4l2_selection {
   __u32 type ;
   __u32 target ;
   __u32 flags ;
   struct v4l2_rect r ;
   __u32 reserved[9U] ;
};
#line 828 "include/uapi/linux/videodev2.h"
typedef __u64 v4l2_std_id;
#line 964 "include/uapi/linux/videodev2.h"
struct v4l2_bt_timings {
   __u32 width ;
   __u32 height ;
   __u32 interlaced ;
   __u32 polarities ;
   __u64 pixelclock ;
   __u32 hfrontporch ;
   __u32 hsync ;
   __u32 hbackporch ;
   __u32 vfrontporch ;
   __u32 vsync ;
   __u32 vbackporch ;
   __u32 il_vfrontporch ;
   __u32 il_vsync ;
   __u32 il_vbackporch ;
   __u32 standards ;
   __u32 flags ;
   __u32 reserved[14U] ;
};
#line 1020 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_27160_192 {
   struct v4l2_bt_timings bt ;
   __u32 reserved[32U] ;
};
#line 1020 "include/uapi/linux/videodev2.h"
struct v4l2_dv_timings {
   __u32 type ;
   union __anonunion_ldv_27160_192 ldv_27160 ;
};
#line 1082 "include/uapi/linux/videodev2.h"
struct v4l2_enum_dv_timings {
   __u32 index ;
   __u32 reserved[3U] ;
   struct v4l2_dv_timings timings ;
};
#line 1097 "include/uapi/linux/videodev2.h"
struct v4l2_bt_timings_cap {
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u64 min_pixelclock ;
   __u64 max_pixelclock ;
   __u32 standards ;
   __u32 capabilities ;
   __u32 reserved[16U] ;
};
#line 1120 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_27181_193 {
   struct v4l2_bt_timings_cap bt ;
   __u32 raw_data[32U] ;
};
#line 1120 "include/uapi/linux/videodev2.h"
struct v4l2_dv_timings_cap {
   __u32 type ;
   __u32 reserved[3U] ;
   union __anonunion_ldv_27181_193 ldv_27181 ;
};
#line 1142 "include/uapi/linux/videodev2.h"
struct v4l2_input {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 audioset ;
   __u32 tuner ;
   v4l2_std_id std ;
   __u32 status ;
   __u32 capabilities ;
   __u32 reserved[3U] ;
};
#line 1158 "include/uapi/linux/videodev2.h"
struct v4l2_output {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 audioset ;
   __u32 modulator ;
   v4l2_std_id std ;
   __u32 capabilities ;
   __u32 reserved[3U] ;
};
#line 1205 "include/uapi/linux/videodev2.h"
struct v4l2_control {
   __u32 id ;
   __s32 value ;
};
#line 1222 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_27212_194 {
   __s32 value ;
   __s64 value64 ;
   char *string ;
};
#line 1222 "include/uapi/linux/videodev2.h"
struct v4l2_ext_control {
   __u32 id ;
   __u32 size ;
   __u32 reserved2[1U] ;
   union __anonunion_ldv_27212_194 ldv_27212 ;
};
#line 1233 "include/uapi/linux/videodev2.h"
struct v4l2_ext_controls {
   __u32 ctrl_class ;
   __u32 count ;
   __u32 error_idx ;
   __u32 reserved[2U] ;
   struct v4l2_ext_control *controls ;
};
#line 1241
enum v4l2_ctrl_type {
    V4L2_CTRL_TYPE_INTEGER = 1,
    V4L2_CTRL_TYPE_BOOLEAN = 2,
    V4L2_CTRL_TYPE_MENU = 3,
    V4L2_CTRL_TYPE_BUTTON = 4,
    V4L2_CTRL_TYPE_INTEGER64 = 5,
    V4L2_CTRL_TYPE_CTRL_CLASS = 6,
    V4L2_CTRL_TYPE_STRING = 7,
    V4L2_CTRL_TYPE_BITMASK = 8,
    V4L2_CTRL_TYPE_INTEGER_MENU = 9
} ;
#line 1253 "include/uapi/linux/videodev2.h"
struct v4l2_queryctrl {
   __u32 id ;
   __u32 type ;
   __u8 name[32U] ;
   __s32 minimum ;
   __s32 maximum ;
   __s32 step ;
   __s32 default_value ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1270 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_27245_195 {
   __u8 name[32U] ;
   __s64 value ;
};
#line 1270 "include/uapi/linux/videodev2.h"
struct v4l2_querymenu {
   __u32 id ;
   __u32 index ;
   union __anonunion_ldv_27245_195 ldv_27245 ;
   __u32 reserved ;
};
#line 1281 "include/uapi/linux/videodev2.h"
struct v4l2_tuner {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 rxsubchans ;
   __u32 audmode ;
   __s32 signal ;
   __s32 afc ;
   __u32 reserved[4U] ;
};
#line 1317 "include/uapi/linux/videodev2.h"
struct v4l2_modulator {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 txsubchans ;
   __u32 reserved[4U] ;
};
#line 1327 "include/uapi/linux/videodev2.h"
struct v4l2_frequency {
   __u32 tuner ;
   __u32 type ;
   __u32 frequency ;
   __u32 reserved[8U] ;
};
#line 1365 "include/uapi/linux/videodev2.h"
struct v4l2_frequency_band {
   __u32 tuner ;
   __u32 type ;
   __u32 index ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 modulation ;
   __u32 reserved[9U] ;
};
#line 1380 "include/uapi/linux/videodev2.h"
struct v4l2_hw_freq_seek {
   __u32 tuner ;
   __u32 type ;
   __u32 seek_upward ;
   __u32 wrap_around ;
   __u32 spacing ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 reserved[5U] ;
};
#line 1401 "include/uapi/linux/videodev2.h"
struct v4l2_audio {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 mode ;
   __u32 reserved[2U] ;
};
#line 1423 "include/uapi/linux/videodev2.h"
struct v4l2_audioout {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 mode ;
   __u32 reserved[2U] ;
};
#line 1438 "include/uapi/linux/videodev2.h"
struct v4l2_enc_idx_entry {
   __u64 offset ;
   __u64 pts ;
   __u32 length ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1457 "include/uapi/linux/videodev2.h"
struct v4l2_enc_idx {
   __u32 entries ;
   __u32 entries_cap ;
   __u32 reserved[4U] ;
   struct v4l2_enc_idx_entry entry[64U] ;
};
#line 1465 "include/uapi/linux/videodev2.h"
struct __anonstruct_raw_197 {
   __u32 data[8U] ;
};
#line 1465 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_27324_196 {
   struct __anonstruct_raw_197 raw ;
};
#line 1465 "include/uapi/linux/videodev2.h"
struct v4l2_encoder_cmd {
   __u32 cmd ;
   __u32 flags ;
   union __anonunion_ldv_27324_196 ldv_27324 ;
};
#line 1484 "include/uapi/linux/videodev2.h"
struct __anonstruct_stop_199 {
   __u64 pts ;
};
#line 1484 "include/uapi/linux/videodev2.h"
struct __anonstruct_start_200 {
   __s32 speed ;
   __u32 format ;
};
#line 1484 "include/uapi/linux/videodev2.h"
struct __anonstruct_raw_201 {
   __u32 data[16U] ;
};
#line 1484 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_27339_198 {
   struct __anonstruct_stop_199 stop ;
   struct __anonstruct_start_200 start ;
   struct __anonstruct_raw_201 raw ;
};
#line 1484 "include/uapi/linux/videodev2.h"
struct v4l2_decoder_cmd {
   __u32 cmd ;
   __u32 flags ;
   union __anonunion_ldv_27339_198 ldv_27339 ;
};
#line 1533 "include/uapi/linux/videodev2.h"
struct v4l2_vbi_format {
   __u32 sampling_rate ;
   __u32 offset ;
   __u32 samples_per_line ;
   __u32 sample_format ;
   __s32 start[2U] ;
   __u32 count[2U] ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1553 "include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_format {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 io_size ;
   __u32 reserved[2U] ;
};
#line 1575 "include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_cap {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 type ;
   __u32 reserved[3U] ;
};
#line 1599 "include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_data {
   __u32 id ;
   __u32 field ;
   __u32 line ;
   __u32 reserved ;
   __u8 data[48U] ;
};
#line 1654 "include/uapi/linux/videodev2.h"
struct v4l2_plane_pix_format {
   __u32 sizeimage ;
   __u16 bytesperline ;
   __u16 reserved[7U] ;
};
#line 1671 "include/uapi/linux/videodev2.h"
struct v4l2_pix_format_mplane {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   __u32 field ;
   __u32 colorspace ;
   struct v4l2_plane_pix_format plane_fmt[8U] ;
   __u8 num_planes ;
   __u8 reserved[11U] ;
};
#line 1693 "include/uapi/linux/videodev2.h"
union __anonunion_fmt_203 {
   struct v4l2_pix_format pix ;
   struct v4l2_pix_format_mplane pix_mp ;
   struct v4l2_window win ;
   struct v4l2_vbi_format vbi ;
   struct v4l2_sliced_vbi_format sliced ;
   __u8 raw_data[200U] ;
};
#line 1693 "include/uapi/linux/videodev2.h"
struct v4l2_format {
   __u32 type ;
   union __anonunion_fmt_203 fmt ;
};
#line 1715 "include/uapi/linux/videodev2.h"
union __anonunion_parm_204 {
   struct v4l2_captureparm capture ;
   struct v4l2_outputparm output ;
   __u8 raw_data[200U] ;
};
#line 1715 "include/uapi/linux/videodev2.h"
struct v4l2_streamparm {
   __u32 type ;
   union __anonunion_parm_204 parm ;
};
#line 1781 "include/uapi/linux/videodev2.h"
struct v4l2_event_subscription {
   __u32 type ;
   __u32 id ;
   __u32 flags ;
   __u32 reserved[5U] ;
};
#line 1791 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_27445_207 {
   __u32 addr ;
   char name[32U] ;
};
#line 1791 "include/uapi/linux/videodev2.h"
struct v4l2_dbg_match {
   __u32 type ;
   union __anonunion_ldv_27445_207 ldv_27445 ;
};
#line 1817 "include/uapi/linux/videodev2.h"
struct v4l2_dbg_register {
   struct v4l2_dbg_match match ;
   __u32 size ;
   __u64 reg ;
   __u64 val ;
};
#line 1824 "include/uapi/linux/videodev2.h"
struct v4l2_dbg_chip_info {
   struct v4l2_dbg_match match ;
   char name[32U] ;
   __u32 flags ;
   __u32 reserved[32U] ;
};
#line 1835 "include/uapi/linux/videodev2.h"
struct v4l2_create_buffers {
   __u32 index ;
   __u32 count ;
   __u32 memory ;
   struct v4l2_format format ;
   __u32 reserved[8U] ;
};
#line 171 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
#line 196 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t const   * , nodemask_t const   * ,
                  unsigned long  ) ;
   int (*remap_pages)(struct vm_area_struct * , unsigned long  , unsigned long  ,
                      unsigned long  ) ;
};
#line 32 "include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 40 "include/linux/poll.h"
typedef struct poll_table_struct poll_table;
#line 163 "include/linux/poll.h"
struct videobuf_mapping {
   unsigned int count ;
   struct videobuf_queue *q ;
};
#line 55 "include/media/videobuf-core.h"
enum videobuf_state {
    VIDEOBUF_NEEDS_INIT = 0,
    VIDEOBUF_PREPARED = 1,
    VIDEOBUF_QUEUED = 2,
    VIDEOBUF_ACTIVE = 3,
    VIDEOBUF_DONE = 4,
    VIDEOBUF_ERROR = 5,
    VIDEOBUF_IDLE = 6
} ;
#line 65 "include/media/videobuf-core.h"
struct videobuf_buffer {
   unsigned int i ;
   u32 magic ;
   unsigned int width ;
   unsigned int height ;
   unsigned int bytesperline ;
   unsigned long size ;
   enum v4l2_field field ;
   enum videobuf_state state ;
   struct list_head stream ;
   struct list_head queue ;
   wait_queue_head_t done ;
   unsigned int field_count ;
   struct timeval ts ;
   enum v4l2_memory memory ;
   size_t bsize ;
   size_t boff ;
   unsigned long baddr ;
   struct videobuf_mapping *map ;
   int privsize ;
   void *priv ;
};
#line 104 "include/media/videobuf-core.h"
struct videobuf_queue_ops {
   int (*buf_setup)(struct videobuf_queue * , unsigned int * , unsigned int * ) ;
   int (*buf_prepare)(struct videobuf_queue * , struct videobuf_buffer * , enum v4l2_field  ) ;
   void (*buf_queue)(struct videobuf_queue * , struct videobuf_buffer * ) ;
   void (*buf_release)(struct videobuf_queue * , struct videobuf_buffer * ) ;
};
#line 115 "include/media/videobuf-core.h"
struct videobuf_qtype_ops {
   u32 magic ;
   struct videobuf_buffer *(*alloc_vb)(size_t  ) ;
   void *(*vaddr)(struct videobuf_buffer * ) ;
   int (*iolock)(struct videobuf_queue * , struct videobuf_buffer * , struct v4l2_framebuffer * ) ;
   int (*sync)(struct videobuf_queue * , struct videobuf_buffer * ) ;
   int (*mmap_mapper)(struct videobuf_queue * , struct videobuf_buffer * , struct vm_area_struct * ) ;
};
#line 132 "include/media/videobuf-core.h"
struct videobuf_queue {
   struct mutex vb_lock ;
   struct mutex *ext_lock ;
   spinlock_t *irqlock ;
   struct device *dev ;
   wait_queue_head_t wait ;
   enum v4l2_buf_type type ;
   unsigned int msize ;
   enum v4l2_field field ;
   enum v4l2_field last ;
   struct videobuf_buffer *bufs[32U] ;
   struct videobuf_queue_ops  const  *ops ;
   struct videobuf_qtype_ops *int_ops ;
   unsigned char streaming : 1 ;
   unsigned char reading : 1 ;
   struct list_head stream ;
   unsigned int read_off ;
   struct videobuf_buffer *read_buf ;
   void *priv_data ;
};
#line 128 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/media.h"
struct media_pipeline {

};
#line 131
struct media_pad;
#line 131 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/media.h"
struct media_link {
   struct media_pad *source ;
   struct media_pad *sink ;
   struct media_link *reverse ;
   unsigned long flags ;
};
#line 39 "include/media/media-entity.h"
struct media_entity;
#line 39 "include/media/media-entity.h"
struct media_pad {
   struct media_entity *entity ;
   u16 index ;
   unsigned long flags ;
};
#line 45 "include/media/media-entity.h"
struct media_entity_operations {
   int (*link_setup)(struct media_entity * , struct media_pad  const  * , struct media_pad  const  * ,
                     u32  ) ;
   int (*link_validate)(struct media_link * ) ;
};
#line 52
struct media_device;
#line 52 "include/media/media-entity.h"
struct __anonstruct_v4l_214 {
   u32 major ;
   u32 minor ;
};
#line 52 "include/media/media-entity.h"
struct __anonstruct_fb_215 {
   u32 major ;
   u32 minor ;
};
#line 52 "include/media/media-entity.h"
struct __anonstruct_alsa_216 {
   u32 card ;
   u32 device ;
   u32 subdevice ;
};
#line 52 "include/media/media-entity.h"
union __anonunion_info_213 {
   struct __anonstruct_v4l_214 v4l ;
   struct __anonstruct_fb_215 fb ;
   struct __anonstruct_alsa_216 alsa ;
   int dvb ;
};
#line 52 "include/media/media-entity.h"
struct media_entity {
   struct list_head list ;
   struct media_device *parent ;
   u32 id ;
   char const   *name ;
   u32 type ;
   u32 revision ;
   unsigned long flags ;
   u32 group_id ;
   u16 num_pads ;
   u16 num_links ;
   u16 num_backlinks ;
   u16 max_links ;
   struct media_pad *pads ;
   struct media_link *links ;
   struct media_entity_operations  const  *ops ;
   int stream_count ;
   int use_count ;
   struct media_pipeline *pipe ;
   union __anonunion_info_213 info ;
};
#line 155
struct video_device;
#line 156
struct v4l2_device;
#line 157
struct v4l2_ctrl_handler;
#line 158 "include/media/media-entity.h"
struct v4l2_prio_state {
   atomic_t prios[4U] ;
};
#line 62 "include/media/v4l2-dev.h"
struct v4l2_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl32)(struct file * , unsigned int  , unsigned long  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct file * ) ;
   int (*release)(struct file * ) ;
};
#line 80
struct vb2_queue;
#line 80
struct v4l2_ioctl_ops;
#line 80 "include/media/v4l2-dev.h"
struct video_device {
   struct media_entity entity ;
   struct v4l2_file_operations  const  *fops ;
   struct device dev ;
   struct cdev *cdev ;
   struct v4l2_device *v4l2_dev ;
   struct device *dev_parent ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct vb2_queue *queue ;
   struct v4l2_prio_state *prio ;
   char name[32U] ;
   int vfl_type ;
   int vfl_dir ;
   int minor ;
   u16 num ;
   unsigned long flags ;
   int index ;
   spinlock_t fh_lock ;
   struct list_head fh_list ;
   int debug ;
   v4l2_std_id tvnorms ;
   void (*release)(struct video_device * ) ;
   struct v4l2_ioctl_ops  const  *ioctl_ops ;
   unsigned long valid_ioctls[3U] ;
   unsigned long disable_locking[3U] ;
   struct mutex *lock ;
};
#line 104 "include/media/v4l2-common.h"
struct v4l2_subdev;
#line 105
struct v4l2_subdev_ops;
#line 162 "include/media/v4l2-common.h"
struct v4l2_priv_tun_config {
   int tuner ;
   void *priv ;
};
#line 206 "include/media/v4l2-common.h"
struct media_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*open)(struct file * ) ;
   int (*release)(struct file * ) ;
};
#line 53 "include/media/media-devnode.h"
struct media_devnode {
   struct media_file_operations  const  *fops ;
   struct device dev ;
   struct cdev cdev ;
   struct device *parent ;
   int minor ;
   unsigned long flags ;
   void (*release)(struct media_devnode * ) ;
};
#line 97 "include/media/media-devnode.h"
struct media_device {
   struct device *dev ;
   struct media_devnode devnode ;
   char model[32U] ;
   char serial[40U] ;
   char bus_info[32U] ;
   u32 hw_revision ;
   u32 driver_version ;
   u32 entity_id ;
   struct list_head entities ;
   spinlock_t lock ;
   struct mutex graph_mutex ;
   int (*link_notify)(struct media_link * , u32  , unsigned int  ) ;
};
#line 96 "include/media/media-device.h"
enum v4l2_mbus_pixelcode {
    V4L2_MBUS_FMT_FIXED = 1,
    V4L2_MBUS_FMT_RGB444_2X8_PADHI_BE = 4097,
    V4L2_MBUS_FMT_RGB444_2X8_PADHI_LE = 4098,
    V4L2_MBUS_FMT_RGB555_2X8_PADHI_BE = 4099,
    V4L2_MBUS_FMT_RGB555_2X8_PADHI_LE = 4100,
    V4L2_MBUS_FMT_BGR565_2X8_BE = 4101,
    V4L2_MBUS_FMT_BGR565_2X8_LE = 4102,
    V4L2_MBUS_FMT_RGB565_2X8_BE = 4103,
    V4L2_MBUS_FMT_RGB565_2X8_LE = 4104,
    V4L2_MBUS_FMT_RGB666_1X18 = 4105,
    V4L2_MBUS_FMT_RGB888_1X24 = 4106,
    V4L2_MBUS_FMT_RGB888_2X12_BE = 4107,
    V4L2_MBUS_FMT_RGB888_2X12_LE = 4108,
    V4L2_MBUS_FMT_ARGB8888_1X32 = 4109,
    V4L2_MBUS_FMT_Y8_1X8 = 8193,
    V4L2_MBUS_FMT_UV8_1X8 = 8213,
    V4L2_MBUS_FMT_UYVY8_1_5X8 = 8194,
    V4L2_MBUS_FMT_VYUY8_1_5X8 = 8195,
    V4L2_MBUS_FMT_YUYV8_1_5X8 = 8196,
    V4L2_MBUS_FMT_YVYU8_1_5X8 = 8197,
    V4L2_MBUS_FMT_UYVY8_2X8 = 8198,
    V4L2_MBUS_FMT_VYUY8_2X8 = 8199,
    V4L2_MBUS_FMT_YUYV8_2X8 = 8200,
    V4L2_MBUS_FMT_YVYU8_2X8 = 8201,
    V4L2_MBUS_FMT_Y10_1X10 = 8202,
    V4L2_MBUS_FMT_YUYV10_2X10 = 8203,
    V4L2_MBUS_FMT_YVYU10_2X10 = 8204,
    V4L2_MBUS_FMT_Y12_1X12 = 8211,
    V4L2_MBUS_FMT_UYVY8_1X16 = 8207,
    V4L2_MBUS_FMT_VYUY8_1X16 = 8208,
    V4L2_MBUS_FMT_YUYV8_1X16 = 8209,
    V4L2_MBUS_FMT_YVYU8_1X16 = 8210,
    V4L2_MBUS_FMT_YDYUYDYV8_1X16 = 8212,
    V4L2_MBUS_FMT_YUYV10_1X20 = 8205,
    V4L2_MBUS_FMT_YVYU10_1X20 = 8206,
    V4L2_MBUS_FMT_YUV10_1X30 = 8214,
    V4L2_MBUS_FMT_AYUV8_1X32 = 8215,
    V4L2_MBUS_FMT_SBGGR8_1X8 = 12289,
    V4L2_MBUS_FMT_SGBRG8_1X8 = 12307,
    V4L2_MBUS_FMT_SGRBG8_1X8 = 12290,
    V4L2_MBUS_FMT_SRGGB8_1X8 = 12308,
    V4L2_MBUS_FMT_SBGGR10_ALAW8_1X8 = 12309,
    V4L2_MBUS_FMT_SGBRG10_ALAW8_1X8 = 12310,
    V4L2_MBUS_FMT_SGRBG10_ALAW8_1X8 = 12311,
    V4L2_MBUS_FMT_SRGGB10_ALAW8_1X8 = 12312,
    V4L2_MBUS_FMT_SBGGR10_DPCM8_1X8 = 12299,
    V4L2_MBUS_FMT_SGBRG10_DPCM8_1X8 = 12300,
    V4L2_MBUS_FMT_SGRBG10_DPCM8_1X8 = 12297,
    V4L2_MBUS_FMT_SRGGB10_DPCM8_1X8 = 12301,
    V4L2_MBUS_FMT_SBGGR10_2X8_PADHI_BE = 12291,
    V4L2_MBUS_FMT_SBGGR10_2X8_PADHI_LE = 12292,
    V4L2_MBUS_FMT_SBGGR10_2X8_PADLO_BE = 12293,
    V4L2_MBUS_FMT_SBGGR10_2X8_PADLO_LE = 12294,
    V4L2_MBUS_FMT_SBGGR10_1X10 = 12295,
    V4L2_MBUS_FMT_SGBRG10_1X10 = 12302,
    V4L2_MBUS_FMT_SGRBG10_1X10 = 12298,
    V4L2_MBUS_FMT_SRGGB10_1X10 = 12303,
    V4L2_MBUS_FMT_SBGGR12_1X12 = 12296,
    V4L2_MBUS_FMT_SGBRG12_1X12 = 12304,
    V4L2_MBUS_FMT_SGRBG12_1X12 = 12305,
    V4L2_MBUS_FMT_SRGGB12_1X12 = 12306,
    V4L2_MBUS_FMT_JPEG_1X8 = 16385,
    V4L2_MBUS_FMT_S5C_UYVY_JPEG_1X8 = 20481
} ;
#line 162 "include/media/media-device.h"
struct v4l2_mbus_framefmt {
   __u32 width ;
   __u32 height ;
   __u32 code ;
   __u32 field ;
   __u32 colorspace ;
   __u32 reserved[7U] ;
};
#line 136 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/v4l2-mediabus.h"
struct v4l2_subdev_format {
   __u32 which ;
   __u32 pad ;
   struct v4l2_mbus_framefmt format ;
   __u32 reserved[8U] ;
};
#line 53 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_crop {
   __u32 which ;
   __u32 pad ;
   struct v4l2_rect rect ;
   __u32 reserved[8U] ;
};
#line 66 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_mbus_code_enum {
   __u32 pad ;
   __u32 index ;
   __u32 code ;
   __u32 reserved[9U] ;
};
#line 79 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_size_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u32 reserved[9U] ;
};
#line 96 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval {
   __u32 pad ;
   struct v4l2_fract interval ;
   __u32 reserved[9U] ;
};
#line 107 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 width ;
   __u32 height ;
   struct v4l2_fract interval ;
   __u32 reserved[9U] ;
};
#line 126 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_selection {
   __u32 which ;
   __u32 pad ;
   __u32 target ;
   __u32 flags ;
   struct v4l2_rect r ;
   __u32 reserved[8U] ;
};
#line 150 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_edid {
   __u32 pad ;
   __u32 start_block ;
   __u32 blocks ;
   __u32 reserved[5U] ;
   __u8 *edid ;
};
#line 158
struct v4l2_async_notifier;
#line 159
enum v4l2_async_match_type {
    V4L2_ASYNC_MATCH_CUSTOM = 0,
    V4L2_ASYNC_MATCH_DEVNAME = 1,
    V4L2_ASYNC_MATCH_I2C = 2,
    V4L2_ASYNC_MATCH_OF = 3
} ;
#line 166 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_of_219 {
   struct device_node  const  *node ;
};
#line 166 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_device_name_220 {
   char const   *name ;
};
#line 166 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_i2c_221 {
   int adapter_id ;
   unsigned short address ;
};
#line 166 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_custom_222 {
   bool (*match)(struct device * , struct v4l2_async_subdev * ) ;
   void *priv ;
};
#line 166 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/v4l2-subdev.h"
union __anonunion_match_218 {
   struct __anonstruct_of_219 of ;
   struct __anonstruct_device_name_220 device_name ;
   struct __anonstruct_i2c_221 i2c ;
   struct __anonstruct_custom_222 custom ;
};
#line 166 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/v4l2-subdev.h"
struct v4l2_async_subdev {
   enum v4l2_async_match_type match_type ;
   union __anonunion_match_218 match ;
   struct list_head list ;
};
#line 63 "include/media/v4l2-async.h"
struct v4l2_async_notifier {
   unsigned int num_subdevs ;
   struct v4l2_async_subdev **subdevs ;
   struct v4l2_device *v4l2_dev ;
   struct list_head waiting ;
   struct list_head done ;
   struct list_head list ;
   int (*bound)(struct v4l2_async_notifier * , struct v4l2_subdev * , struct v4l2_async_subdev * ) ;
   int (*complete)(struct v4l2_async_notifier * ) ;
   void (*unbind)(struct v4l2_async_notifier * , struct v4l2_subdev * , struct v4l2_async_subdev * ) ;
};
#line 97 "include/media/v4l2-async.h"
struct v4l2_fh {
   struct list_head list ;
   struct video_device *vdev ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   enum v4l2_priority prio ;
   wait_queue_head_t wait ;
   struct list_head subscribed ;
   struct list_head available ;
   unsigned int navailable ;
   u32 sequence ;
};
#line 100 "include/media/v4l2-fh.h"
enum v4l2_mbus_type {
    V4L2_MBUS_PARALLEL = 0,
    V4L2_MBUS_BT656 = 1,
    V4L2_MBUS_CSI2 = 2
} ;
#line 106 "include/media/v4l2-fh.h"
struct v4l2_mbus_config {
   enum v4l2_mbus_type type ;
   unsigned int flags ;
};
#line 109 "include/media/v4l2-mediabus.h"
struct v4l2_subdev_fh;
#line 110
struct tuner_setup;
#line 111
struct v4l2_mbus_frame_desc;
#line 112 "include/media/v4l2-mediabus.h"
struct v4l2_decode_vbi_line {
   u32 is_second_field ;
   u8 *p ;
   u32 line ;
   u32 type ;
};
#line 61 "include/media/v4l2-subdev.h"
struct v4l2_subdev_io_pin_config {
   u32 flags ;
   u8 pin ;
   u8 function ;
   u8 value ;
   u8 strength ;
};
#line 117 "include/media/v4l2-subdev.h"
struct v4l2_subdev_core_ops {
   int (*log_status)(struct v4l2_subdev * ) ;
   int (*s_io_pin_config)(struct v4l2_subdev * , size_t  , struct v4l2_subdev_io_pin_config * ) ;
   int (*init)(struct v4l2_subdev * , u32  ) ;
   int (*load_fw)(struct v4l2_subdev * ) ;
   int (*reset)(struct v4l2_subdev * , u32  ) ;
   int (*s_gpio)(struct v4l2_subdev * , u32  ) ;
   int (*queryctrl)(struct v4l2_subdev * , struct v4l2_queryctrl * ) ;
   int (*g_ctrl)(struct v4l2_subdev * , struct v4l2_control * ) ;
   int (*s_ctrl)(struct v4l2_subdev * , struct v4l2_control * ) ;
   int (*g_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*s_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*try_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*querymenu)(struct v4l2_subdev * , struct v4l2_querymenu * ) ;
   int (*g_std)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*s_std)(struct v4l2_subdev * , v4l2_std_id  ) ;
   long (*ioctl)(struct v4l2_subdev * , unsigned int  , void * ) ;
   int (*g_register)(struct v4l2_subdev * , struct v4l2_dbg_register * ) ;
   int (*s_register)(struct v4l2_subdev * , struct v4l2_dbg_register  const  * ) ;
   int (*s_power)(struct v4l2_subdev * , int  ) ;
   int (*interrupt_service_routine)(struct v4l2_subdev * , u32  , bool * ) ;
   int (*subscribe_event)(struct v4l2_subdev * , struct v4l2_fh * , struct v4l2_event_subscription * ) ;
   int (*unsubscribe_event)(struct v4l2_subdev * , struct v4l2_fh * , struct v4l2_event_subscription * ) ;
};
#line 176 "include/media/v4l2-subdev.h"
struct v4l2_subdev_tuner_ops {
   int (*s_radio)(struct v4l2_subdev * ) ;
   int (*s_frequency)(struct v4l2_subdev * , struct v4l2_frequency  const  * ) ;
   int (*g_frequency)(struct v4l2_subdev * , struct v4l2_frequency * ) ;
   int (*g_tuner)(struct v4l2_subdev * , struct v4l2_tuner * ) ;
   int (*s_tuner)(struct v4l2_subdev * , struct v4l2_tuner  const  * ) ;
   int (*g_modulator)(struct v4l2_subdev * , struct v4l2_modulator * ) ;
   int (*s_modulator)(struct v4l2_subdev * , struct v4l2_modulator  const  * ) ;
   int (*s_type_addr)(struct v4l2_subdev * , struct tuner_setup * ) ;
   int (*s_config)(struct v4l2_subdev * , struct v4l2_priv_tun_config  const  * ) ;
};
#line 202 "include/media/v4l2-subdev.h"
struct v4l2_subdev_audio_ops {
   int (*s_clock_freq)(struct v4l2_subdev * , u32  ) ;
   int (*s_i2s_clock_freq)(struct v4l2_subdev * , u32  ) ;
   int (*s_routing)(struct v4l2_subdev * , u32  , u32  , u32  ) ;
   int (*s_stream)(struct v4l2_subdev * , int  ) ;
};
#line 229 "include/media/v4l2-subdev.h"
struct v4l2_mbus_frame_desc_entry {
   u16 flags ;
   u32 pixelcode ;
   u32 length ;
};
#line 247 "include/media/v4l2-subdev.h"
struct v4l2_mbus_frame_desc {
   struct v4l2_mbus_frame_desc_entry entry[4U] ;
   unsigned short num_entries ;
};
#line 259 "include/media/v4l2-subdev.h"
struct v4l2_subdev_video_ops {
   int (*s_routing)(struct v4l2_subdev * , u32  , u32  , u32  ) ;
   int (*s_crystal_freq)(struct v4l2_subdev * , u32  , u32  ) ;
   int (*s_std_output)(struct v4l2_subdev * , v4l2_std_id  ) ;
   int (*g_std_output)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*querystd)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_tvnorms_output)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_input_status)(struct v4l2_subdev * , u32 * ) ;
   int (*s_stream)(struct v4l2_subdev * , int  ) ;
   int (*cropcap)(struct v4l2_subdev * , struct v4l2_cropcap * ) ;
   int (*g_crop)(struct v4l2_subdev * , struct v4l2_crop * ) ;
   int (*s_crop)(struct v4l2_subdev * , struct v4l2_crop  const  * ) ;
   int (*g_parm)(struct v4l2_subdev * , struct v4l2_streamparm * ) ;
   int (*s_parm)(struct v4l2_subdev * , struct v4l2_streamparm * ) ;
   int (*g_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_frame_interval * ) ;
   int (*s_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_frame_interval * ) ;
   int (*enum_framesizes)(struct v4l2_subdev * , struct v4l2_frmsizeenum * ) ;
   int (*enum_frameintervals)(struct v4l2_subdev * , struct v4l2_frmivalenum * ) ;
   int (*s_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*g_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*enum_dv_timings)(struct v4l2_subdev * , struct v4l2_enum_dv_timings * ) ;
   int (*query_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*dv_timings_cap)(struct v4l2_subdev * , struct v4l2_dv_timings_cap * ) ;
   int (*enum_mbus_fmt)(struct v4l2_subdev * , unsigned int  , enum v4l2_mbus_pixelcode * ) ;
   int (*enum_mbus_fsizes)(struct v4l2_subdev * , struct v4l2_frmsizeenum * ) ;
   int (*g_mbus_fmt)(struct v4l2_subdev * , struct v4l2_mbus_framefmt * ) ;
   int (*try_mbus_fmt)(struct v4l2_subdev * , struct v4l2_mbus_framefmt * ) ;
   int (*s_mbus_fmt)(struct v4l2_subdev * , struct v4l2_mbus_framefmt * ) ;
   int (*g_mbus_config)(struct v4l2_subdev * , struct v4l2_mbus_config * ) ;
   int (*s_mbus_config)(struct v4l2_subdev * , struct v4l2_mbus_config  const  * ) ;
   int (*s_rx_buffer)(struct v4l2_subdev * , void * , unsigned int * ) ;
};
#line 351 "include/media/v4l2-subdev.h"
struct v4l2_subdev_vbi_ops {
   int (*decode_vbi_line)(struct v4l2_subdev * , struct v4l2_decode_vbi_line * ) ;
   int (*s_vbi_data)(struct v4l2_subdev * , struct v4l2_sliced_vbi_data  const  * ) ;
   int (*g_vbi_data)(struct v4l2_subdev * , struct v4l2_sliced_vbi_data * ) ;
   int (*g_sliced_vbi_cap)(struct v4l2_subdev * , struct v4l2_sliced_vbi_cap * ) ;
   int (*s_raw_fmt)(struct v4l2_subdev * , struct v4l2_vbi_format * ) ;
   int (*g_sliced_fmt)(struct v4l2_subdev * , struct v4l2_sliced_vbi_format * ) ;
   int (*s_sliced_fmt)(struct v4l2_subdev * , struct v4l2_sliced_vbi_format * ) ;
};
#line 391 "include/media/v4l2-subdev.h"
struct v4l2_subdev_sensor_ops {
   int (*g_skip_top_lines)(struct v4l2_subdev * , u32 * ) ;
   int (*g_skip_frames)(struct v4l2_subdev * , u32 * ) ;
};
#line 406
enum v4l2_subdev_ir_mode {
    V4L2_SUBDEV_IR_MODE_PULSE_WIDTH = 0
} ;
#line 410 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_parameters {
   unsigned int bytes_per_data_element ;
   enum v4l2_subdev_ir_mode mode ;
   bool enable ;
   bool interrupt_enable ;
   bool shutdown ;
   bool modulation ;
   u32 max_pulse_width ;
   unsigned int carrier_freq ;
   unsigned int duty_cycle ;
   bool invert_level ;
   bool invert_carrier_sense ;
   u32 noise_filter_min_width ;
   unsigned int carrier_range_lower ;
   unsigned int carrier_range_upper ;
   u32 resolution ;
};
#line 458 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_ops {
   int (*rx_read)(struct v4l2_subdev * , u8 * , size_t  , ssize_t * ) ;
   int (*rx_g_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*rx_s_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*tx_write)(struct v4l2_subdev * , u8 * , size_t  , ssize_t * ) ;
   int (*tx_g_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*tx_s_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
};
#line 477 "include/media/v4l2-subdev.h"
struct v4l2_subdev_pad_ops {
   int (*enum_mbus_code)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_mbus_code_enum * ) ;
   int (*enum_frame_size)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_frame_size_enum * ) ;
   int (*enum_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_frame_interval_enum * ) ;
   int (*get_fmt)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_format * ) ;
   int (*set_fmt)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_format * ) ;
   int (*set_crop)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_crop * ) ;
   int (*get_crop)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_crop * ) ;
   int (*get_selection)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_selection * ) ;
   int (*set_selection)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_selection * ) ;
   int (*get_edid)(struct v4l2_subdev * , struct v4l2_subdev_edid * ) ;
   int (*set_edid)(struct v4l2_subdev * , struct v4l2_subdev_edid * ) ;
   int (*link_validate)(struct v4l2_subdev * , struct media_link * , struct v4l2_subdev_format * ,
                        struct v4l2_subdev_format * ) ;
   int (*get_frame_desc)(struct v4l2_subdev * , unsigned int  , struct v4l2_mbus_frame_desc * ) ;
   int (*set_frame_desc)(struct v4l2_subdev * , unsigned int  , struct v4l2_mbus_frame_desc * ) ;
};
#line 517 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ops {
   struct v4l2_subdev_core_ops  const  *core ;
   struct v4l2_subdev_tuner_ops  const  *tuner ;
   struct v4l2_subdev_audio_ops  const  *audio ;
   struct v4l2_subdev_video_ops  const  *video ;
   struct v4l2_subdev_vbi_ops  const  *vbi ;
   struct v4l2_subdev_ir_ops  const  *ir ;
   struct v4l2_subdev_sensor_ops  const  *sensor ;
   struct v4l2_subdev_pad_ops  const  *pad ;
};
#line 529 "include/media/v4l2-subdev.h"
struct v4l2_subdev_internal_ops {
   int (*registered)(struct v4l2_subdev * ) ;
   void (*unregistered)(struct v4l2_subdev * ) ;
   int (*open)(struct v4l2_subdev * , struct v4l2_subdev_fh * ) ;
   int (*close)(struct v4l2_subdev * , struct v4l2_subdev_fh * ) ;
};
#line 550 "include/media/v4l2-subdev.h"
struct v4l2_subdev {
   struct media_entity entity ;
   struct list_head list ;
   struct module *owner ;
   u32 flags ;
   struct v4l2_device *v4l2_dev ;
   struct v4l2_subdev_ops  const  *ops ;
   struct v4l2_subdev_internal_ops  const  *internal_ops ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   char name[32U] ;
   u32 grp_id ;
   void *dev_priv ;
   void *host_priv ;
   struct video_device *devnode ;
   struct device *dev ;
   struct list_head async_list ;
   struct v4l2_async_subdev *asd ;
   struct v4l2_async_notifier *notifier ;
};
#line 596 "include/media/v4l2-subdev.h"
struct __anonstruct_pad_223 {
   struct v4l2_mbus_framefmt try_fmt ;
   struct v4l2_rect try_crop ;
   struct v4l2_rect try_compose ;
};
#line 596 "include/media/v4l2-subdev.h"
struct v4l2_subdev_fh {
   struct v4l2_fh vfh ;
   struct __anonstruct_pad_223 *pad ;
};
#line 665 "include/media/v4l2-subdev.h"
struct v4l2_device {
   struct device *dev ;
   struct media_device *mdev ;
   struct list_head subdevs ;
   spinlock_t lock ;
   char name[36U] ;
   void (*notify)(struct v4l2_subdev * , unsigned int  , void * ) ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct v4l2_prio_state prio ;
   struct mutex ioctl_lock ;
   struct kref ref ;
   void (*release)(struct v4l2_device * ) ;
};
#line 122 "include/media/v4l2-device.h"
struct v4l2_ioctl_ops {
   int (*vidioc_querycap)(struct file * , void * , struct v4l2_capability * ) ;
   int (*vidioc_g_priority)(struct file * , void * , enum v4l2_priority * ) ;
   int (*vidioc_s_priority)(struct file * , void * , enum v4l2_priority  ) ;
   int (*vidioc_enum_fmt_vid_cap)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_overlay)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_out)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_g_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_reqbufs)(struct file * , void * , struct v4l2_requestbuffers * ) ;
   int (*vidioc_querybuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_qbuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_expbuf)(struct file * , void * , struct v4l2_exportbuffer * ) ;
   int (*vidioc_dqbuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_create_bufs)(struct file * , void * , struct v4l2_create_buffers * ) ;
   int (*vidioc_prepare_buf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_overlay)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_g_fbuf)(struct file * , void * , struct v4l2_framebuffer * ) ;
   int (*vidioc_s_fbuf)(struct file * , void * , struct v4l2_framebuffer  const  * ) ;
   int (*vidioc_streamon)(struct file * , void * , enum v4l2_buf_type  ) ;
   int (*vidioc_streamoff)(struct file * , void * , enum v4l2_buf_type  ) ;
   int (*vidioc_g_std)(struct file * , void * , v4l2_std_id * ) ;
   int (*vidioc_s_std)(struct file * , void * , v4l2_std_id  ) ;
   int (*vidioc_querystd)(struct file * , void * , v4l2_std_id * ) ;
   int (*vidioc_enum_input)(struct file * , void * , struct v4l2_input * ) ;
   int (*vidioc_g_input)(struct file * , void * , unsigned int * ) ;
   int (*vidioc_s_input)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_enum_output)(struct file * , void * , struct v4l2_output * ) ;
   int (*vidioc_g_output)(struct file * , void * , unsigned int * ) ;
   int (*vidioc_s_output)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_queryctrl)(struct file * , void * , struct v4l2_queryctrl * ) ;
   int (*vidioc_g_ctrl)(struct file * , void * , struct v4l2_control * ) ;
   int (*vidioc_s_ctrl)(struct file * , void * , struct v4l2_control * ) ;
   int (*vidioc_g_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_s_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_try_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_querymenu)(struct file * , void * , struct v4l2_querymenu * ) ;
   int (*vidioc_enumaudio)(struct file * , void * , struct v4l2_audio * ) ;
   int (*vidioc_g_audio)(struct file * , void * , struct v4l2_audio * ) ;
   int (*vidioc_s_audio)(struct file * , void * , struct v4l2_audio  const  * ) ;
   int (*vidioc_enumaudout)(struct file * , void * , struct v4l2_audioout * ) ;
   int (*vidioc_g_audout)(struct file * , void * , struct v4l2_audioout * ) ;
   int (*vidioc_s_audout)(struct file * , void * , struct v4l2_audioout  const  * ) ;
   int (*vidioc_g_modulator)(struct file * , void * , struct v4l2_modulator * ) ;
   int (*vidioc_s_modulator)(struct file * , void * , struct v4l2_modulator  const  * ) ;
   int (*vidioc_cropcap)(struct file * , void * , struct v4l2_cropcap * ) ;
   int (*vidioc_g_crop)(struct file * , void * , struct v4l2_crop * ) ;
   int (*vidioc_s_crop)(struct file * , void * , struct v4l2_crop  const  * ) ;
   int (*vidioc_g_selection)(struct file * , void * , struct v4l2_selection * ) ;
   int (*vidioc_s_selection)(struct file * , void * , struct v4l2_selection * ) ;
   int (*vidioc_g_jpegcomp)(struct file * , void * , struct v4l2_jpegcompression * ) ;
   int (*vidioc_s_jpegcomp)(struct file * , void * , struct v4l2_jpegcompression  const  * ) ;
   int (*vidioc_g_enc_index)(struct file * , void * , struct v4l2_enc_idx * ) ;
   int (*vidioc_encoder_cmd)(struct file * , void * , struct v4l2_encoder_cmd * ) ;
   int (*vidioc_try_encoder_cmd)(struct file * , void * , struct v4l2_encoder_cmd * ) ;
   int (*vidioc_decoder_cmd)(struct file * , void * , struct v4l2_decoder_cmd * ) ;
   int (*vidioc_try_decoder_cmd)(struct file * , void * , struct v4l2_decoder_cmd * ) ;
   int (*vidioc_g_parm)(struct file * , void * , struct v4l2_streamparm * ) ;
   int (*vidioc_s_parm)(struct file * , void * , struct v4l2_streamparm * ) ;
   int (*vidioc_g_tuner)(struct file * , void * , struct v4l2_tuner * ) ;
   int (*vidioc_s_tuner)(struct file * , void * , struct v4l2_tuner  const  * ) ;
   int (*vidioc_g_frequency)(struct file * , void * , struct v4l2_frequency * ) ;
   int (*vidioc_s_frequency)(struct file * , void * , struct v4l2_frequency  const  * ) ;
   int (*vidioc_enum_freq_bands)(struct file * , void * , struct v4l2_frequency_band * ) ;
   int (*vidioc_g_sliced_vbi_cap)(struct file * , void * , struct v4l2_sliced_vbi_cap * ) ;
   int (*vidioc_log_status)(struct file * , void * ) ;
   int (*vidioc_s_hw_freq_seek)(struct file * , void * , struct v4l2_hw_freq_seek  const  * ) ;
   int (*vidioc_g_register)(struct file * , void * , struct v4l2_dbg_register * ) ;
   int (*vidioc_s_register)(struct file * , void * , struct v4l2_dbg_register  const  * ) ;
   int (*vidioc_g_chip_info)(struct file * , void * , struct v4l2_dbg_chip_info * ) ;
   int (*vidioc_enum_framesizes)(struct file * , void * , struct v4l2_frmsizeenum * ) ;
   int (*vidioc_enum_frameintervals)(struct file * , void * , struct v4l2_frmivalenum * ) ;
   int (*vidioc_s_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_g_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_query_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_enum_dv_timings)(struct file * , void * , struct v4l2_enum_dv_timings * ) ;
   int (*vidioc_dv_timings_cap)(struct file * , void * , struct v4l2_dv_timings_cap * ) ;
   int (*vidioc_subscribe_event)(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
   int (*vidioc_unsubscribe_event)(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
   long (*vidioc_default)(struct file * , void * , bool  , unsigned int  , void * ) ;
};
#line 319 "include/media/v4l2-ioctl.h"
struct v4l2_ctrl_helper;
#line 320
struct v4l2_ctrl;
#line 322 "include/media/v4l2-ioctl.h"
struct v4l2_ctrl_ops {
   int (*g_volatile_ctrl)(struct v4l2_ctrl * ) ;
   int (*try_ctrl)(struct v4l2_ctrl * ) ;
   int (*s_ctrl)(struct v4l2_ctrl * ) ;
};
#line 58 "include/media/v4l2-ctrls.h"
union __anonunion_ldv_32356_224 {
   u32 step ;
   u32 menu_skip_mask ;
};
#line 58 "include/media/v4l2-ctrls.h"
union __anonunion_ldv_32360_225 {
   char const   * const  *qmenu ;
   s64 const   *qmenu_int ;
};
#line 58 "include/media/v4l2-ctrls.h"
union __anonunion_cur_226 {
   s32 val ;
   s64 val64 ;
   char *string ;
};
#line 58 "include/media/v4l2-ctrls.h"
union __anonunion_ldv_32371_227 {
   s32 val ;
   s64 val64 ;
   char *string ;
};
#line 58 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl {
   struct list_head node ;
   struct list_head ev_subs ;
   struct v4l2_ctrl_handler *handler ;
   struct v4l2_ctrl **cluster ;
   unsigned int ncontrols ;
   unsigned char done : 1 ;
   unsigned char is_new : 1 ;
   unsigned char is_private : 1 ;
   unsigned char is_auto : 1 ;
   unsigned char has_volatiles : 1 ;
   unsigned char call_notify : 1 ;
   unsigned char manual_mode_value ;
   struct v4l2_ctrl_ops  const  *ops ;
   u32 id ;
   char const   *name ;
   enum v4l2_ctrl_type type ;
   s32 minimum ;
   s32 maximum ;
   s32 default_value ;
   union __anonunion_ldv_32356_224 ldv_32356 ;
   union __anonunion_ldv_32360_225 ldv_32360 ;
   unsigned long flags ;
   union __anonunion_cur_226 cur ;
   union __anonunion_ldv_32371_227 ldv_32371 ;
   void *priv ;
};
#line 156 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl_ref {
   struct list_head node ;
   struct v4l2_ctrl_ref *next ;
   struct v4l2_ctrl *ctrl ;
   struct v4l2_ctrl_helper *helper ;
};
#line 173 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl_handler {
   struct mutex _lock ;
   struct mutex *lock ;
   struct list_head ctrls ;
   struct list_head ctrl_refs ;
   struct v4l2_ctrl_ref *cached ;
   struct v4l2_ctrl_ref **buckets ;
   void (*notify)(struct v4l2_ctrl * , void * ) ;
   void *notify_priv ;
   u16 nr_of_buckets ;
   int error ;
};
#line 205 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl_config {
   struct v4l2_ctrl_ops  const  *ops ;
   u32 id ;
   char const   *name ;
   enum v4l2_ctrl_type type ;
   s32 min ;
   s32 max ;
   u32 step ;
   s32 def ;
   u32 flags ;
   u32 menu_skip_mask ;
   char const   * const  *qmenu ;
   s64 const   *qmenu_int ;
   unsigned char is_private : 1 ;
};
#line 134 "include/media/v4l2-event.h"
struct s2255_mode {
   u32 format ;
   u32 scale ;
   u32 color ;
   u32 fdec ;
   u32 bright ;
   u32 contrast ;
   u32 saturation ;
   u32 hue ;
   u32 single ;
   u32 usb_block ;
   u32 restart ;
};
#line 221 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct s2255_framei {
   unsigned long size ;
   unsigned long ulState ;
   void *lpvbits ;
   unsigned long cur_size ;
};
#line 233 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct s2255_bufferi {
   unsigned long dwFrames ;
   struct s2255_framei frame[4U] ;
};
#line 239
struct s2255_dev;
#line 239 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct s2255_dmaqueue {
   struct list_head active ;
   struct s2255_dev *dev ;
};
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct s2255_fw {
   int fw_loaded ;
   int fw_size ;
   struct urb *fw_urb ;
   atomic_t fw_state ;
   void *pfw_data ;
   wait_queue_head_t wait_fw ;
   struct firmware  const  *fw ;
};
#line 268 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct s2255_pipeinfo {
   u32 max_transfer_size ;
   u32 cur_transfer_size ;
   u8 *transfer_buffer ;
   u32 state ;
   void *stream_urb ;
   void *dev ;
   u32 err_count ;
   u32 idx ;
};
#line 279
struct s2255_fmt;
#line 280 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct s2255_channel {
   struct video_device vdev ;
   struct v4l2_ctrl_handler hdl ;
   struct v4l2_ctrl *jpegqual_ctrl ;
   int resources ;
   struct s2255_dmaqueue vidq ;
   struct s2255_bufferi buffer ;
   struct s2255_mode mode ;
   v4l2_std_id std ;
   unsigned int jpegqual ;
   struct v4l2_captureparm cap_parm ;
   int cur_frame ;
   int last_frame ;
   int b_acquire ;
   unsigned long req_image_size ;
   unsigned long pkt_size ;
   int bad_payload ;
   unsigned long frame_count ;
   int jpg_size ;
   int configured ;
   wait_queue_head_t wait_setmode ;
   int setmode_ready ;
   int vidstatus ;
   wait_queue_head_t wait_vidstatus ;
   int vidstatus_ready ;
   unsigned int width ;
   unsigned int height ;
   struct s2255_fmt  const  *fmt ;
   int idx ;
};
#line 321 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct s2255_dev {
   struct s2255_channel channel[4U] ;
   struct v4l2_device v4l2_dev ;
   atomic_t num_channels ;
   int frames ;
   struct mutex lock ;
   struct usb_device *udev ;
   struct usb_interface *interface ;
   u8 read_endpoint ;
   struct timer_list timer ;
   struct s2255_fw *fw_data ;
   struct s2255_pipeinfo pipe ;
   u32 cc ;
   int frame_ready ;
   int chn_ready ;
   spinlock_t slock ;
   int dsp_fw_ver ;
   u16 pid ;
};
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct s2255_fmt {
   char *name ;
   u32 fourcc ;
   int depth ;
};
#line 354 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct s2255_buffer {
   struct videobuf_buffer vb ;
   struct s2255_fmt  const  *fmt ;
};
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct s2255_fh {
   struct v4l2_fh fh ;
   struct s2255_dev *dev ;
   struct videobuf_queue vb_vidq ;
   enum v4l2_buf_type type ;
   struct s2255_channel *channel ;
   int resources ;
};
#line 3433 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
typedef int ldv_func_ret_type;
#line 3468 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
typedef int ldv_func_ret_type___0;
#line 3533 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
typedef int ldv_func_ret_type___1;
#line 3562 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
typedef int ldv_func_ret_type___2;
#line 3579 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
typedef int ldv_func_ret_type___3;
#line 1 "<compiler builtins>"
#line 1
long ldv__builtin_expect(long exp , long c ) ;
#line 34 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/string_64.h"
extern void *__memcpy(void * , void const   * , size_t  ) ;
#line 55
extern void *memset(void * , int  , size_t  ) ;
#line 26 "include/linux/string.h"
extern size_t strlcpy(char * , char const   * , size_t  ) ;
#line 448 "include/uapi/linux/usb/ch9.h"
__inline static int usb_endpoint_dir_in(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
#line 450
  return ((int )((signed char )epd->bEndpointAddress) < 0);
}
}
#line 471 "include/uapi/linux/usb/ch9.h"
__inline static int usb_endpoint_xfer_bulk(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
#line 474
  return (((int )epd->bmAttributes & 3) == 2);
}
}
#line 526 "include/uapi/linux/usb/ch9.h"
__inline static int usb_endpoint_is_bulk_in(struct usb_endpoint_descriptor  const  *epd ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 529
  tmp = usb_endpoint_xfer_bulk(epd);
#line 529
  if (tmp != 0) {
#line 529
    tmp___0 = usb_endpoint_dir_in(epd);
#line 529
    if (tmp___0 != 0) {
#line 529
      tmp___1 = 1;
    } else {
#line 529
      tmp___1 = 0;
    }
  } else {
#line 529
    tmp___1 = 0;
  }
#line 529
  return (tmp___1);
}
}
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 70 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 78
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 80
  return;
}
}
#line 124 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 358 "include/linux/kernel.h"
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 88 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 10 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3554;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3554;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3554;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3554;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_3554: ;
#line 14
  return (pfo_ret__);
}
}
#line 23 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 


  {
#line 25
  return ((int )*((int volatile   *)(& v->counter)));
}
}
#line 35 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 37
  v->counter = i;
#line 38
  return;
}
}
#line 93 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 95
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 97
  return;
}
}
#line 119 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/atomic.h"
__inline static int atomic_dec_and_test(atomic_t *v ) 
{ 
  unsigned char c ;

  {
#line 123
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0; sete %1": "+m" (v->counter),
                       "=qm" (c): : "memory");
#line 126
  return ((unsigned int )c != 0U);
}
}
#line 24 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 26
  list->next = list;
#line 27
  list->prev = list;
#line 28
  return;
}
}
#line 47
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 74 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 76
  __list_add(new, head->prev, head);
#line 77
  return;
}
}
#line 112
extern void list_del(struct list_head * ) ;
#line 186 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 188
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 32 "include/linux/spinlock_api_smp.h"
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
#line 43
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 280 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 282
  return (& lock->ldv_7686.rlock);
}
}
#line 346 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 348
  _raw_spin_unlock_irqrestore(& lock->ldv_7686.rlock, flags);
#line 349
  return;
}
}
#line 77 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 297
extern unsigned long msecs_to_jiffies(unsigned int const    ) ;
#line 175 "include/linux/timer.h"
extern int del_timer(struct timer_list * ) ;
#line 178
int ldv_del_timer_1(struct timer_list *ldv_func_arg1 ) ;
#line 182
int ldv_del_timer_6(struct timer_list *ldv_func_arg1 ) ;
#line 186
int ldv_del_timer_20(struct timer_list *ldv_func_arg1 ) ;
#line 188
extern int mod_timer(struct timer_list * , unsigned long  ) ;
#line 191
int ldv_mod_timer_16(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 67 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 143
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 887
extern void prepare_to_wait(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 889
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 892
extern int autoremove_wake_function(wait_queue_t * , unsigned int  , int  , void * ) ;
#line 22 "include/linux/mutex-debug.h"
extern void mutex_destroy(struct mutex * ) ;
#line 119 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 138
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
#line 141
extern int mutex_lock_interruptible_nested(struct mutex * , unsigned int  ) ;
#line 174
extern void mutex_unlock(struct mutex * ) ;
#line 67 "include/linux/vmalloc.h"
extern void *vmalloc(unsigned long  ) ;
#line 79
extern void vfree(void const   * ) ;
#line 84 "include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 86
  return ((char const   *)kobj->name);
}
}
#line 783 "include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 786
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 787
    return ((char const   *)dev->init_name);
  } else {

  }
#line 789
  tmp = kobject_name(& dev->kobj);
#line 789
  return (tmp);
}
}
#line 898
extern void *dev_get_drvdata(struct device  const  * ) ;
#line 899
extern int dev_set_drvdata(struct device * , void * ) ;
#line 1014
extern int dev_err(struct device  const  * , char const   *  , ...) ;
#line 1020
extern int _dev_info(struct device  const  * , char const   *  , ...) ;
#line 298 "include/linux/sched.h"
extern long schedule_timeout(long  ) ;
#line 192 "include/linux/usb.h"
__inline static void *usb_get_intfdata(struct usb_interface *intf ) 
{ 
  void *tmp ;

  {
#line 194
  tmp = dev_get_drvdata((struct device  const  *)(& intf->dev));
#line 194
  return (tmp);
}
}
#line 585
__inline static struct usb_device *interface_to_usbdev(struct usb_interface *intf ) ;
#line 597
struct usb_device *ldv_usb_get_dev_17(struct usb_device *ldv_func_arg1 ) ;
#line 602
void ldv_usb_put_dev_8(struct usb_device *dev ) ;
#line 606
void ldv_usb_put_dev_21(struct usb_device *dev ) ;
#line 615
extern int usb_reset_device(struct usb_device * ) ;
#line 776 "include/linux/usb.h"
__inline static int usb_make_path(struct usb_device *dev , char *buf , size_t size ) 
{ 
  int actual ;

  {
#line 779
  actual = snprintf(buf, size, "usb-%s-%s", (dev->bus)->bus_name, (char *)(& dev->devpath));
#line 781
  return ((int )size > actual ? actual : -1);
}
}
#line 1132
extern int usb_register_driver(struct usb_driver * , struct module * , char const   * ) ;
#line 1136
int ldv_usb_register_driver_22(struct usb_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                               char const   *ldv_func_arg3 ) ;
#line 1143
extern void usb_deregister(struct usb_driver * ) ;
#line 1146
void ldv_usb_deregister_23(struct usb_driver *arg ) ;
#line 1537
__inline static void ldv_usb_fill_bulk_urb_4(struct urb *urb , struct usb_device *dev ,
                                             unsigned int pipe , void *transfer_buffer ,
                                             int buffer_length , void (*complete_fn)(struct urb * ) ,
                                             void *context ) ;
#line 1541
__inline static void ldv_usb_fill_bulk_urb_4(struct urb *urb , struct usb_device *dev ,
                                             unsigned int pipe , void *transfer_buffer ,
                                             int buffer_length , void (*complete_fn)(struct urb * ) ,
                                             void *context ) ;
#line 1545
__inline static void ldv_usb_fill_bulk_urb_4(struct urb *urb , struct usb_device *dev ,
                                             unsigned int pipe , void *transfer_buffer ,
                                             int buffer_length , void (*complete_fn)(struct urb * ) ,
                                             void *context ) ;
#line 1549
__inline static void ldv_usb_fill_bulk_urb_4(struct urb *urb , struct usb_device *dev ,
                                             unsigned int pipe , void *transfer_buffer ,
                                             int buffer_length , void (*complete_fn)(struct urb * ) ,
                                             void *context ) ;
#line 1582
struct urb *ldv_usb_alloc_urb_11(int iso_packets , gfp_t mem_flags ) ;
#line 1586
struct urb *ldv_usb_alloc_urb_18(int iso_packets , gfp_t mem_flags ) ;
#line 1591
void ldv_usb_free_urb_7(struct urb *urb ) ;
#line 1595
void ldv_usb_free_urb_14(struct urb *urb ) ;
#line 1599
void ldv_usb_free_urb_19(struct urb *urb ) ;
#line 1606
int ldv_usb_submit_urb_3(struct urb *ldv_func_arg1 , gfp_t ldv_func_arg2 ) ;
#line 1610
int ldv_usb_submit_urb_5(struct urb *ldv_func_arg1 , gfp_t ldv_func_arg2 ) ;
#line 1614
int ldv_usb_submit_urb_10(struct urb *ldv_func_arg1 , gfp_t ldv_func_arg2 ) ;
#line 1618
int ldv_usb_submit_urb_13(struct urb *ldv_func_arg1 , gfp_t ldv_func_arg2 ) ;
#line 1621
extern void usb_kill_urb(struct urb * ) ;
#line 1636
extern int usb_control_msg(struct usb_device * , unsigned int  , __u8  , __u8  , __u16  ,
                           __u16  , void * , __u16  , int  ) ;
#line 1641
extern int usb_bulk_msg(struct usb_device * , unsigned int  , void * , int  , int * ,
                        int  ) ;
#line 1760 "include/linux/usb.h"
__inline static unsigned int __create_pipe(struct usb_device *dev , unsigned int endpoint ) 
{ 


  {
#line 1763
  return ((unsigned int )(dev->devnum << 8) | (endpoint << 15));
}
}
#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct urb *ldv_alloc_urb(void) ;
#line 7
void ldv_free_urb(struct urb *urb ) ;
#line 10
void ldv_fill_bulk_urb(struct urb *urb , void (*complete_fn)(struct urb * ) ) ;
#line 11
int ldv_submit_urb(struct urb *urb ) ;
#line 13
struct usb_device *ldv_interface_to_usbdev(void) ;
#line 14
struct usb_device *ldv_get_dev(struct usb_device *data ) ;
#line 15
void ldv_put_dev(struct usb_device *data ) ;
#line 135 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 295
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 389 "include/linux/slab.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 406
  tmp___2 = __kmalloc(size, flags);
#line 406
  return (tmp___2);
}
}
#line 636 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 638
  tmp = kmalloc(size, flags | 32768U);
#line 638
  return (tmp);
}
}
#line 6 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t size ) ;
#line 7
extern void *calloc(size_t nmemb , size_t size ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 25
extern unsigned int __VERIFIER_nondet_uint(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int expression ) ;
#line 32 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 53
  tmp = __VERIFIER_nondet_int();
#line 53
  return (tmp);
}
}
#line 56 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 57
  tmp = __VERIFIER_nondet_pointer();
#line 57
  return (tmp);
}
}
#line 60 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 61
  tmp = __VERIFIER_nondet_ulong();
#line 61
  return (tmp);
}
}
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  goto ERROR;
}
}
#line 22 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 51 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 53
  return (exp);
}
}
#line 61 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
void ldv__builtin_trap(void) 
{ 


  {
#line 63
  ldv_error();
#line 64
  return;
}
}
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct file *s2255_ioctl_ops_group4  ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct videobuf_queue *s2255_video_qops_group1  ;
#line 35 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct videobuf_buffer *s2255_video_qops_group2  ;
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int ldv_state_variable_6  ;
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct v4l2_buffer *s2255_ioctl_ops_group5  ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int ldv_state_variable_0  ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int ldv_state_variable_5  ;
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int ldv_state_variable_3  ;
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct v4l2_streamparm *s2255_ioctl_ops_group3  ;
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int ldv_timer_state_1  =    0;
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int ldv_state_variable_2  ;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int ref_cnt  ;
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct usb_interface *s2255_driver_group1  ;
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct v4l2_format *s2255_ioctl_ops_group0  ;
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int ldv_state_variable_1  ;
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int ldv_state_variable_7  ;
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int usb_counter  ;
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct timer_list *ldv_timer_list_1  ;
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct v4l2_event_subscription *s2255_ioctl_ops_group1  ;
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int ldv_state_variable_4  ;
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct v4l2_fh *s2255_ioctl_ops_group2  ;
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct file *s2255_fops_v4l_group0  ;
#line 56
void ldv_usb_driver_2(void) ;
#line 57
void activate_pending_timer_1(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 58
void choose_timer_1(struct timer_list *timer ) ;
#line 59
int reg_timer_1(struct timer_list *timer ) ;
#line 60
void ldv_videobuf_queue_ops_7(void) ;
#line 61
void ldv_initialize_v4l2_ioctl_ops_5(void) ;
#line 62
void disable_suitable_timer_1(struct timer_list *timer ) ;
#line 63
void ldv_initialize_v4l2_file_operations_6(void) ;
#line 42 "include/linux/firmware.h"
extern int request_firmware(struct firmware  const  ** , char const   * , struct device * ) ;
#line 49
extern void release_firmware(struct firmware  const  * ) ;
#line 179 "include/media/videobuf-core.h"
extern int videobuf_iolock(struct videobuf_queue * , struct videobuf_buffer * , struct v4l2_framebuffer * ) ;
#line 198
extern int videobuf_queue_is_busy(struct videobuf_queue * ) ;
#line 202
extern int videobuf_reqbufs(struct videobuf_queue * , struct v4l2_requestbuffers * ) ;
#line 204
extern int videobuf_querybuf(struct videobuf_queue * , struct v4l2_buffer * ) ;
#line 205
extern int videobuf_qbuf(struct videobuf_queue * , struct v4l2_buffer * ) ;
#line 207
extern int videobuf_dqbuf(struct videobuf_queue * , struct v4l2_buffer * , int  ) ;
#line 209
extern int videobuf_streamon(struct videobuf_queue * ) ;
#line 210
extern int videobuf_streamoff(struct videobuf_queue * ) ;
#line 222
extern unsigned int videobuf_poll_stream(struct file * , struct videobuf_queue * ,
                                         poll_table * ) ;
#line 232
extern int videobuf_mmap_free(struct videobuf_queue * ) ;
#line 233
extern int videobuf_mmap_mapper(struct videobuf_queue * , struct vm_area_struct * ) ;
#line 32 "include/media/videobuf-vmalloc.h"
extern void videobuf_queue_vmalloc_init(struct videobuf_queue * , struct videobuf_queue_ops  const  * ,
                                        struct device * , spinlock_t * , enum v4l2_buf_type  ,
                                        enum v4l2_field  , unsigned int  , void * ,
                                        struct mutex * ) ;
#line 42
extern void *videobuf_to_vmalloc(struct videobuf_buffer * ) ;
#line 44
extern void videobuf_vmalloc_free(struct videobuf_buffer * ) ;
#line 150 "include/media/v4l2-dev.h"
extern int __video_register_device(struct video_device * , int  , int  , int  , struct module * ) ;
#line 157 "include/media/v4l2-dev.h"
__inline static int video_register_device(struct video_device *vdev , int type , int nr ) 
{ 
  int tmp ;

  {
#line 160
  tmp = __video_register_device(vdev, type, nr, 1, (vdev->fops)->owner);
#line 160
  return (tmp);
}
}
#line 173
extern void video_unregister_device(struct video_device * ) ;
#line 208 "include/media/v4l2-dev.h"
__inline static void *video_get_drvdata(struct video_device *vdev ) 
{ 
  void *tmp ;

  {
#line 210
  tmp = dev_get_drvdata((struct device  const  *)(& vdev->dev));
#line 210
  return (tmp);
}
}
#line 213 "include/media/v4l2-dev.h"
__inline static void video_set_drvdata(struct video_device *vdev , void *data ) 
{ 


  {
#line 215
  dev_set_drvdata(& vdev->dev, data);
#line 216
  return;
}
}
#line 218
extern struct video_device *video_devdata(struct file * ) ;
#line 222 "include/media/v4l2-dev.h"
__inline static void *video_drvdata(struct file *file ) 
{ 
  struct video_device *tmp ;
  void *tmp___0 ;

  {
#line 224
  tmp = video_devdata(file);
#line 224
  tmp___0 = video_get_drvdata(tmp);
#line 224
  return (tmp___0);
}
}
#line 227 "include/media/v4l2-dev.h"
__inline static char const   *video_device_node_name(struct video_device *vdev ) 
{ 
  char const   *tmp ;

  {
#line 229
  tmp = dev_name((struct device  const  *)(& vdev->dev));
#line 229
  return (tmp);
}
}
#line 205 "include/media/v4l2-common.h"
extern void v4l2_get_timestamp(struct timeval * ) ;
#line 54 "include/media/v4l2-fh.h"
extern void v4l2_fh_init(struct v4l2_fh * , struct video_device * ) ;
#line 59
extern void v4l2_fh_add(struct v4l2_fh * ) ;
#line 72
extern void v4l2_fh_del(struct v4l2_fh * ) ;
#line 79
extern void v4l2_fh_exit(struct v4l2_fh * ) ;
#line 79 "include/media/v4l2-device.h"
extern int v4l2_device_register(struct device * , struct v4l2_device * ) ;
#line 103
extern void v4l2_device_disconnect(struct v4l2_device * ) ;
#line 106
extern void v4l2_device_unregister(struct v4l2_device * ) ;
#line 302 "include/media/v4l2-ioctl.h"
extern char const   *v4l2_type_names[] ;
#line 318
extern long video_ioctl2(struct file * , unsigned int  , unsigned long  ) ;
#line 281 "include/media/v4l2-ctrls.h"
extern int v4l2_ctrl_handler_init_class(struct v4l2_ctrl_handler * , unsigned int  ,
                                        struct lock_class_key * , char const   * ) ;
#line 308
extern void v4l2_ctrl_handler_free(struct v4l2_ctrl_handler * ) ;
#line 343
extern struct v4l2_ctrl *v4l2_ctrl_new_custom(struct v4l2_ctrl_handler * , struct v4l2_ctrl_config  const  * ,
                                              void * ) ;
#line 363
extern struct v4l2_ctrl *v4l2_ctrl_new_std(struct v4l2_ctrl_handler * , struct v4l2_ctrl_ops  const  * ,
                                           u32  , s32  , s32  , u32  , s32  ) ;
#line 618
extern int v4l2_ctrl_s_ctrl(struct v4l2_ctrl * , s32  ) ;
#line 650
extern int v4l2_ctrl_log_status(struct file * , void * ) ;
#line 654
extern int v4l2_ctrl_subscribe_event(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
#line 658
extern unsigned int v4l2_ctrl_poll(struct file * , struct poll_table_struct * ) ;
#line 130 "include/media/v4l2-event.h"
extern int v4l2_event_unsubscribe(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
#line 344 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
__inline static struct s2255_dev *to_s2255_dev(struct v4l2_device *v4l2_dev ) 
{ 
  struct v4l2_device  const  *__mptr ;

  {
#line 346
  __mptr = (struct v4l2_device  const  *)v4l2_dev;
#line 346
  return ((struct s2255_dev *)__mptr + 0xffffffffffffd780UL);
}
}
#line 415 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static unsigned long G_chnmap[4U]  = {      3UL,      2UL,      1UL,      0UL};
#line 417 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int debug  ;
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int *s2255_debug  =    & debug;
#line 420
static int s2255_start_readpipe(struct s2255_dev *dev ) ;
#line 421
static void s2255_stop_readpipe(struct s2255_dev *dev ) ;
#line 422
static int s2255_start_acquire(struct s2255_channel *channel ) ;
#line 423
static int s2255_stop_acquire(struct s2255_channel *channel ) ;
#line 424
static void s2255_fillbuff(struct s2255_channel *channel , struct s2255_buffer *buf ,
                           int jpgsize ) ;
#line 426
static int s2255_set_mode(struct s2255_channel *channel , struct s2255_mode *mode ) ;
#line 427
static int s2255_board_shutdown(struct s2255_dev *dev ) ;
#line 428
static void s2255_fwload_start(struct s2255_dev *dev , int reset ) ;
#line 429
static void s2255_destroy(struct s2255_dev *dev ) ;
#line 430
static long s2255_vendor_req(struct s2255_dev *dev , unsigned char Request , u16 Index ,
                             u16 Value , void *TransferBuffer , s32 TransferBufferLength ,
                             int bOut ) ;
#line 447
static struct usb_driver s2255_driver ;
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static unsigned int vid_limit  =    16U;
#line 453 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int video_nr  =    -1;
#line 456 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int jpeg_enable  =    1;
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static struct usb_device_id s2255_table[3U]  = {      {3U, 6467U, 8789U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      0UL}, 
        {3U, 6467U, 8791U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      0UL}};
#line 474 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct usb_device_id  const  __mod_usb_device_table  ;
#line 480 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static struct s2255_fmt  const  formats[6U]  = {      {(char *)"4:2:2, packed, YUYV", 1448695129U, 16}, 
        {(char *)"4:2:2, packed, UYVY", 1498831189U, 16}, 
        {(char *)"4:2:2, planar, YUV422P", 1345466932U, 16}, 
        {(char *)"8bpp GREY", 1497715271U, 8}, 
        {(char *)"JPG", 1195724874U, 24}, 
        {(char *)"MJPG", 1196444237U, 24}};
#line 510 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int norm_maxw(struct s2255_channel *channel ) 
{ 


  {
#line 512
  return ((channel->std & 63744ULL) != 0ULL ? 640 : 704);
}
}
#line 516 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int norm_maxh(struct s2255_channel *channel ) 
{ 


  {
#line 518
  return ((channel->std & 63744ULL) != 0ULL ? 480 : 576);
}
}
#line 522 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int norm_minw(struct s2255_channel *channel ) 
{ 


  {
#line 524
  return ((channel->std & 63744ULL) != 0ULL ? 320 : 352);
}
}
#line 528 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int norm_minh(struct s2255_channel *channel ) 
{ 


  {
#line 530
  return ((channel->std & 63744ULL) != 0ULL ? 240 : 288);
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static void planar422p_to_yuv_packed(unsigned char const   *in , unsigned char *out ,
                                     int width , int height , int fmt ) 
{ 
  unsigned char *pY ;
  unsigned char *pCb ;
  unsigned char *pCr ;
  unsigned long size ;
  unsigned int i ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;

  {
#line 547
  size = (unsigned long )(height * width);
#line 549
  pY = (unsigned char *)in;
#line 550
  pCr = (unsigned char *)in + (unsigned long )(height * width);
#line 551
  pCb = (unsigned char *)in + ((unsigned long )(height * width) + (unsigned long )((height * width) / 2));
#line 552
  i = 0U;
#line 552
  goto ldv_32848;
  ldv_32847: ;
#line 553
  if (fmt == 1448695129) {
#line 553
    tmp = pY;
#line 553
    pY = pY + 1;
#line 553
    *(out + (unsigned long )i) = *tmp;
  } else {
#line 553
    tmp___0 = pCr;
#line 553
    pCr = pCr + 1;
#line 553
    *(out + (unsigned long )i) = *tmp___0;
  }
#line 554
  if (fmt == 1448695129) {
#line 554
    tmp___1 = pCr;
#line 554
    pCr = pCr + 1;
#line 554
    *(out + (unsigned long )(i + 1U)) = *tmp___1;
  } else {
#line 554
    tmp___2 = pY;
#line 554
    pY = pY + 1;
#line 554
    *(out + (unsigned long )(i + 1U)) = *tmp___2;
  }
#line 555
  if (fmt == 1448695129) {
#line 555
    tmp___3 = pY;
#line 555
    pY = pY + 1;
#line 555
    *(out + (unsigned long )(i + 2U)) = *tmp___3;
  } else {
#line 555
    tmp___4 = pCb;
#line 555
    pCb = pCb + 1;
#line 555
    *(out + (unsigned long )(i + 2U)) = *tmp___4;
  }
#line 556
  if (fmt == 1448695129) {
#line 556
    tmp___5 = pCb;
#line 556
    pCb = pCb + 1;
#line 556
    *(out + (unsigned long )(i + 3U)) = *tmp___5;
  } else {
#line 556
    tmp___6 = pY;
#line 556
    pY = pY + 1;
#line 556
    *(out + (unsigned long )(i + 3U)) = *tmp___6;
  }
#line 552
  i = i + 4U;
  ldv_32848: ;
#line 552
  if ((unsigned long )i < size * 2UL) {
#line 554
    goto ldv_32847;
  } else {

  }

#line 558
  return;
}
}
#line 561 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static void s2255_reset_dsppower(struct s2255_dev *dev ) 
{ 


  {
#line 563
  s2255_vendor_req(dev, 64, 0, 1, (void *)0, 0, 1);
#line 564
  msleep(10U);
#line 565
  s2255_vendor_req(dev, 80, 0, 0, (void *)0, 0, 1);
#line 566
  msleep(600U);
#line 567
  s2255_vendor_req(dev, 16, 0, 0, (void *)0, 0, 1);
#line 568
  return;
}
}
#line 573 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static void s2255_timer(unsigned long user_data ) 
{ 
  struct s2255_fw *data ;
  int tmp ;

  {
#line 575
  data = (struct s2255_fw *)user_data;
#line 576
  if (*s2255_debug > 99) {
#line 576
    printk("\017s2255: %s\n", "s2255_timer");
  } else {

  }
#line 577
  tmp = ldv_usb_submit_urb_3(data->fw_urb, 32U);
#line 577
  if (tmp < 0) {
#line 578
    printk("\vs2255: can\'t submit urb\n");
#line 579
    atomic_set(& data->fw_state, 3);
#line 581
    __wake_up(& data->wait_fw, 3U, 1, (void *)0);
#line 582
    return;
  } else {

  }
#line 584
  return;
}
}
#line 593 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static void s2255_fwchunk_complete(struct urb *urb ) 
{ 
  struct s2255_fw *data ;
  struct usb_device *udev ;
  int len ;
  size_t __len ;
  void *__ret ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 595
  data = (struct s2255_fw *)urb->context;
#line 596
  udev = urb->dev;
#line 598
  if (*s2255_debug > 99) {
#line 598
    printk("\017s2255: %s: udev %p urb %p", "s2255_fwchunk_complete", udev, urb);
  } else {

  }
#line 599
  if (urb->status != 0) {
#line 600
    dev_err((struct device  const  *)(& udev->dev), "URB failed with status %d\n",
            urb->status);
#line 601
    atomic_set(& data->fw_state, 3);
#line 603
    __wake_up(& data->wait_fw, 3U, 1, (void *)0);
#line 604
    return;
  } else {

  }
#line 606
  if ((unsigned long )data->fw_urb == (unsigned long )((struct urb *)0)) {
#line 607
    dev_err((struct device  const  *)(& udev->dev), "s2255 - disconnected\n");
#line 608
    atomic_set(& data->fw_state, 3);
#line 610
    __wake_up(& data->wait_fw, 3U, 1, (void *)0);
#line 611
    return;
  } else {

  }
#line 618
  if (data->fw_loaded < data->fw_size) {
#line 619
    len = data->fw_loaded + 512 > data->fw_size ? data->fw_size % 512 : 512;
#line 622
    if (len <= 511) {
#line 623
      memset(data->pfw_data, 0, 512UL);
    } else {

    }
#line 625
    if (*s2255_debug > 99) {
#line 625
      printk("\017s2255: completed len %d, loaded %d \n", len, data->fw_loaded);
    } else {

    }
#line 628
    __len = (size_t )len;
#line 628
    __ret = __builtin_memcpy(data->pfw_data, (void const   *)(data->fw)->data + (unsigned long )data->fw_loaded,
                             __len);
#line 631
    tmp = __create_pipe(udev, 2U);
#line 631
    ldv_usb_fill_bulk_urb_4(data->fw_urb, udev, tmp | 3221225472U, data->pfw_data,
                            512, & s2255_fwchunk_complete, (void *)data);
#line 634
    tmp___0 = ldv_usb_submit_urb_5(data->fw_urb, 32U);
#line 634
    if (tmp___0 < 0) {
#line 635
      dev_err((struct device  const  *)(& udev->dev), "failed submit URB\n");
#line 636
      atomic_set(& data->fw_state, 3);
#line 638
      __wake_up(& data->wait_fw, 3U, 1, (void *)0);
#line 639
      return;
    } else {

    }
#line 641
    data->fw_loaded = data->fw_loaded + len;
  } else {
#line 643
    atomic_set(& data->fw_state, 1);
#line 644
    if (*s2255_debug > 99) {
#line 644
      printk("\017s2255: %s: firmware upload complete\n", "s2255_fwchunk_complete");
    } else {

    }
  }
#line 646
  return;
}
}
#line 650 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int s2255_got_frame(struct s2255_channel *channel , int jpgsize ) 
{ 
  struct s2255_dmaqueue *dma_q ;
  struct s2255_buffer *buf ;
  struct s2255_dev *dev ;
  struct s2255_dev *tmp ;
  unsigned long flags ;
  int rc ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;
  struct list_head  const  *__mptr ;

  {
#line 652
  dma_q = & channel->vidq;
#line 654
  tmp = to_s2255_dev(channel->vdev.v4l2_dev);
#line 654
  dev = tmp;
#line 655
  flags = 0UL;
#line 656
  rc = 0;
#line 657
  tmp___0 = spinlock_check(& dev->slock);
#line 657
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 658
  tmp___1 = list_empty((struct list_head  const  *)(& dma_q->active));
#line 658
  if (tmp___1 != 0) {
#line 659
    if (*s2255_debug > 0) {
#line 659
      printk("\017s2255: No active queue to serve\n");
    } else {

    }
#line 660
    rc = -1;
#line 661
    goto unlock;
  } else {

  }
#line 663
  __mptr = (struct list_head  const  *)dma_q->active.next;
#line 663
  buf = (struct s2255_buffer *)__mptr + 0xffffffffffffffc8UL;
#line 665
  list_del(& buf->vb.queue);
#line 666
  v4l2_get_timestamp(& buf->vb.ts);
#line 667
  s2255_fillbuff(channel, buf, jpgsize);
#line 668
  __wake_up(& buf->vb.done, 3U, 1, (void *)0);
#line 669
  if (*s2255_debug > 1) {
#line 669
    printk("\017s2255: %s: [buf/i] [%p/%d]\n", "s2255_got_frame", buf, buf->vb.i);
  } else {

  }
  unlock: 
#line 671
  spin_unlock_irqrestore(& dev->slock, flags);
#line 672
  return (rc);
}
}
#line 675 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static struct s2255_fmt  const  *format_by_fourcc(int fourcc ) 
{ 
  unsigned int i ;

  {
#line 678
  i = 0U;
#line 678
  goto ldv_32892;
  ldv_32891: ;
#line 679
  if ((unsigned int )formats[i].fourcc == 4294967295U) {
#line 680
    goto ldv_32890;
  } else {

  }
#line 681
  if (jpeg_enable == 0 && ((unsigned int )formats[i].fourcc == 1195724874U || (unsigned int )formats[i].fourcc == 1196444237U)) {
#line 683
    goto ldv_32890;
  } else {

  }
#line 684
  if ((unsigned int )formats[i].fourcc == (unsigned int )fourcc) {
#line 685
    return ((struct s2255_fmt  const  *)(& formats) + (unsigned long )i);
  } else {

  }
  ldv_32890: 
#line 678
  i = i + 1U;
  ldv_32892: ;
#line 678
  if (i <= 5U) {
#line 680
    goto ldv_32891;
  } else {

  }

#line 687
  return ((struct s2255_fmt  const  *)0);
}
}
#line 698 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static void s2255_fillbuff(struct s2255_channel *channel , struct s2255_buffer *buf ,
                           int jpgsize ) 
{ 
  int pos ;
  char const   *tmpbuf ;
  char *vbuf ;
  void *tmp ;
  unsigned long last_frame ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;

  {
#line 701
  pos = 0;
#line 703
  tmp = videobuf_to_vmalloc(& buf->vb);
#line 703
  vbuf = (char *)tmp;
#line 706
  if ((unsigned long )vbuf == (unsigned long )((char *)0)) {
#line 707
    return;
  } else {

  }
#line 708
  last_frame = (unsigned long )channel->last_frame;
#line 709
  if (last_frame != 0xffffffffffffffffUL) {
#line 710
    tmpbuf = (char const   *)channel->buffer.frame[last_frame].lpvbits;
#line 712
    switch ((buf->fmt)->fourcc) {
    case 1448695129U: ;
    case 1498831189U: 
#line 715
    planar422p_to_yuv_packed((unsigned char const   *)tmpbuf, (unsigned char *)vbuf,
                             (int )buf->vb.width, (int )buf->vb.height, (int )(buf->fmt)->fourcc);
#line 719
    goto ldv_32905;
    case 1497715271U: 
#line 721
    __len = (size_t )(buf->vb.width * buf->vb.height);
#line 721
    __ret = __builtin_memcpy((void *)vbuf, (void const   *)tmpbuf, __len);
#line 722
    goto ldv_32905;
    case 1195724874U: ;
    case 1196444237U: 
#line 725
    buf->vb.size = (unsigned long )jpgsize;
#line 726
    __len___0 = buf->vb.size;
#line 726
    __ret___0 = __builtin_memcpy((void *)vbuf, (void const   *)tmpbuf, __len___0);
#line 727
    goto ldv_32905;
    case 1345466932U: 
#line 729
    __len___1 = (size_t )((buf->vb.width * buf->vb.height) * 2U);
#line 729
    __ret___1 = __builtin_memcpy((void *)vbuf, (void const   *)tmpbuf, __len___1);
#line 731
    goto ldv_32905;
    default: 
#line 733
    printk("\017s2255: unknown format?\n");
    }
    ldv_32905: 
#line 735
    channel->last_frame = -1;
  } else {
#line 737
    printk("\vs2255: =======no frame\n");
#line 738
    return;
  }
#line 741
  if (*s2255_debug > 1) {
#line 741
    printk("\017s2255: s2255fill at : Buffer 0x%08lx size= %d\n", (unsigned long )vbuf,
           pos);
  } else {

  }
#line 745
  buf->vb.field_count = (unsigned int )channel->frame_count * 2U;
#line 746
  v4l2_get_timestamp(& buf->vb.ts);
#line 747
  buf->vb.state = 4;
#line 748
  return;
}
}
#line 755 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int buffer_setup(struct videobuf_queue *vq , unsigned int *count , unsigned int *size ) 
{ 
  struct s2255_fh *fh ;
  struct s2255_channel *channel ;

  {
#line 758
  fh = (struct s2255_fh *)vq->priv_data;
#line 759
  channel = fh->channel;
#line 760
  *size = (channel->width * channel->height) * (unsigned int )((channel->fmt)->depth >> 3);
#line 762
  if (*count == 0U) {
#line 763
    *count = 16U;
  } else {

  }
#line 765
  if (*size * *count > vid_limit * 1048576U) {
#line 766
    *count = (vid_limit * 1048576U) / *size;
  } else {

  }
#line 768
  return (0);
}
}
#line 771 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static void free_buffer(struct videobuf_queue *vq , struct s2255_buffer *buf ) 
{ 


  {
#line 773
  if (*s2255_debug > 3) {
#line 773
    printk("\017s2255: %s\n", "free_buffer");
  } else {

  }
#line 775
  videobuf_vmalloc_free(& buf->vb);
#line 776
  buf->vb.state = 0;
#line 777
  return;
}
}
#line 779 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int buffer_prepare(struct videobuf_queue *vq , struct videobuf_buffer *vb ,
                          enum v4l2_field field ) 
{ 
  struct s2255_fh *fh ;
  struct s2255_channel *channel ;
  struct s2255_buffer *buf ;
  struct videobuf_buffer  const  *__mptr ;
  int rc ;
  int w ;
  int h ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 782
  fh = (struct s2255_fh *)vq->priv_data;
#line 783
  channel = fh->channel;
#line 784
  __mptr = (struct videobuf_buffer  const  *)vb;
#line 784
  buf = (struct s2255_buffer *)__mptr;
#line 786
  w = (int )channel->width;
#line 787
  h = (int )channel->height;
#line 788
  if (*s2255_debug > 3) {
#line 788
    printk("\017s2255: %s, field=%d\n", "buffer_prepare", (unsigned int )field);
  } else {

  }
#line 789
  if ((unsigned long )channel->fmt == (unsigned long )((struct s2255_fmt  const  *)0)) {
#line 790
    return (-22);
  } else {

  }
#line 792
  tmp = norm_minw(channel);
#line 792
  if (tmp > w) {
#line 792
    goto _L;
  } else {
#line 792
    tmp___0 = norm_maxw(channel);
#line 792
    if (tmp___0 < w) {
#line 792
      goto _L;
    } else {
#line 792
      tmp___1 = norm_minh(channel);
#line 792
      if (tmp___1 > h) {
#line 792
        goto _L;
      } else {
#line 792
        tmp___2 = norm_maxh(channel);
#line 792
        if (tmp___2 < h) {
          _L: /* CIL Label */ 
#line 796
          if (*s2255_debug > 3) {
#line 796
            printk("\017s2255: invalid buffer prepare\n");
          } else {

          }
#line 797
          return (-22);
        } else {

        }
      }
    }
  }
#line 799
  buf->vb.size = (unsigned long )((w * h) * (int )((channel->fmt)->depth >> 3));
#line 800
  if (buf->vb.baddr != 0UL && buf->vb.bsize < buf->vb.size) {
#line 801
    if (*s2255_debug > 3) {
#line 801
      printk("\017s2255: invalid buffer prepare\n");
    } else {

    }
#line 802
    return (-22);
  } else {

  }
#line 805
  buf->fmt = channel->fmt;
#line 806
  buf->vb.width = (unsigned int )w;
#line 807
  buf->vb.height = (unsigned int )h;
#line 808
  buf->vb.field = field;
#line 810
  if ((unsigned int )buf->vb.state == 0U) {
#line 811
    rc = videobuf_iolock(vq, & buf->vb, (struct v4l2_framebuffer *)0);
#line 812
    if (rc < 0) {
#line 813
      goto fail;
    } else {

    }
  } else {

  }
#line 816
  buf->vb.state = 1;
#line 817
  return (0);
  fail: 
#line 819
  free_buffer(vq, buf);
#line 820
  return (rc);
}
}
#line 823 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static void buffer_queue(struct videobuf_queue *vq , struct videobuf_buffer *vb ) 
{ 
  struct s2255_buffer *buf ;
  struct videobuf_buffer  const  *__mptr ;
  struct s2255_fh *fh ;
  struct s2255_channel *channel ;
  struct s2255_dmaqueue *vidq ;

  {
#line 825
  __mptr = (struct videobuf_buffer  const  *)vb;
#line 825
  buf = (struct s2255_buffer *)__mptr;
#line 826
  fh = (struct s2255_fh *)vq->priv_data;
#line 827
  channel = fh->channel;
#line 828
  vidq = & channel->vidq;
#line 829
  if (*s2255_debug > 0) {
#line 829
    printk("\017s2255: %s\n", "buffer_queue");
  } else {

  }
#line 830
  buf->vb.state = 2;
#line 831
  list_add_tail(& buf->vb.queue, & vidq->active);
#line 832
  return;
}
}
#line 834 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static void buffer_release(struct videobuf_queue *vq , struct videobuf_buffer *vb ) 
{ 
  struct s2255_buffer *buf ;
  struct videobuf_buffer  const  *__mptr ;
  struct s2255_fh *fh ;

  {
#line 837
  __mptr = (struct videobuf_buffer  const  *)vb;
#line 837
  buf = (struct s2255_buffer *)__mptr;
#line 838
  fh = (struct s2255_fh *)vq->priv_data;
#line 839
  if (*s2255_debug > 3) {
#line 839
    printk("\017s2255: %s %d\n", "buffer_release", (fh->channel)->idx);
  } else {

  }
#line 840
  free_buffer(vq, buf);
#line 841
  return;
}
}
#line 843 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static struct videobuf_queue_ops s2255_video_qops  =    {& buffer_setup, & buffer_prepare, & buffer_queue, & buffer_release};
#line 851 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int res_get(struct s2255_fh *fh ) 
{ 
  struct s2255_channel *channel ;

  {
#line 853
  channel = fh->channel;
#line 855
  if (channel->resources != 0) {
#line 856
    return (0);
  } else {

  }
#line 858
  channel->resources = 1;
#line 859
  fh->resources = 1;
#line 860
  if (*s2255_debug > 0) {
#line 860
    printk("\017s2255: s2255: res: get\n");
  } else {

  }
#line 861
  return (1);
}
}
#line 864 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int res_locked(struct s2255_fh *fh ) 
{ 


  {
#line 866
  return ((fh->channel)->resources);
}
}
#line 869 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int res_check(struct s2255_fh *fh ) 
{ 


  {
#line 871
  return (fh->resources);
}
}
#line 875 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static void res_free(struct s2255_fh *fh ) 
{ 
  struct s2255_channel *channel ;

  {
#line 877
  channel = fh->channel;
#line 878
  channel->resources = 0;
#line 879
  fh->resources = 0;
#line 880
  if (*s2255_debug > 0) {
#line 880
    printk("\017s2255: res: put\n");
  } else {

  }
#line 881
  return;
}
}
#line 883 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int vidioc_querycap(struct file *file , void *priv , struct v4l2_capability *cap ) 
{ 
  struct s2255_fh *fh ;
  struct s2255_dev *dev ;

  {
#line 886
  fh = (struct s2255_fh *)file->private_data;
#line 887
  dev = fh->dev;
#line 889
  strlcpy((char *)(& cap->driver), "s2255", 16UL);
#line 890
  strlcpy((char *)(& cap->card), "s2255", 32UL);
#line 891
  usb_make_path(dev->udev, (char *)(& cap->bus_info), 32UL);
#line 892
  cap->device_caps = 67108865U;
#line 893
  cap->capabilities = cap->device_caps | 2147483648U;
#line 894
  return (0);
}
}
#line 897 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int vidioc_enum_fmt_vid_cap(struct file *file , void *priv , struct v4l2_fmtdesc *f ) 
{ 
  int index ;

  {
#line 900
  index = (int )f->index;
#line 902
  if ((unsigned int )index > 5U) {
#line 903
    return (-22);
  } else {

  }
#line 904
  if (jpeg_enable == 0 && ((unsigned int )formats[index].fourcc == 1195724874U || (unsigned int )formats[index].fourcc == 1196444237U)) {
#line 906
    return (-22);
  } else {

  }
#line 907
  if (*s2255_debug > 3) {
#line 907
    printk("\017s2255: name %s\n", formats[index].name);
  } else {

  }
#line 908
  strlcpy((char *)(& f->description), (char const   *)formats[index].name, 32UL);
#line 909
  f->pixelformat = formats[index].fourcc;
#line 910
  return (0);
}
}
#line 913 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int vidioc_g_fmt_vid_cap(struct file *file , void *priv , struct v4l2_format *f ) 
{ 
  struct s2255_fh *fh ;
  struct s2255_channel *channel ;
  int is_ntsc ;

  {
#line 916
  fh = (struct s2255_fh *)priv;
#line 917
  channel = fh->channel;
#line 918
  is_ntsc = (int )channel->std & 63744;
#line 920
  f->fmt.pix.width = channel->width;
#line 921
  f->fmt.pix.height = channel->height;
#line 922
  if (f->fmt.pix.height >= (is_ntsc != 0 ? 480U : 576U)) {
#line 924
    f->fmt.pix.field = 4U;
  } else {
#line 926
    f->fmt.pix.field = 2U;
  }
#line 927
  f->fmt.pix.pixelformat = (channel->fmt)->fourcc;
#line 928
  f->fmt.pix.bytesperline = f->fmt.pix.width * (__u32 )((channel->fmt)->depth >> 3);
#line 929
  f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
#line 930
  f->fmt.pix.colorspace = 1U;
#line 931
  f->fmt.pix.priv = 0U;
#line 932
  return (0);
}
}
#line 935 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int vidioc_try_fmt_vid_cap(struct file *file , void *priv , struct v4l2_format *f ) 
{ 
  struct s2255_fmt  const  *fmt ;
  enum v4l2_field field ;
  struct s2255_fh *fh ;
  struct s2255_channel *channel ;
  int is_ntsc ;

  {
#line 940
  fh = (struct s2255_fh *)priv;
#line 941
  channel = fh->channel;
#line 942
  is_ntsc = (int )channel->std & 63744;
#line 944
  fmt = format_by_fourcc((int )f->fmt.pix.pixelformat);
#line 946
  if ((unsigned long )fmt == (unsigned long )((struct s2255_fmt  const  *)0)) {
#line 947
    return (-22);
  } else {

  }
#line 949
  field = (enum v4l2_field )f->fmt.pix.field;
#line 951
  if (*s2255_debug > 49) {
#line 951
    printk("\017s2255: %s NTSC: %d suggested width: %d, height: %d\n", "vidioc_try_fmt_vid_cap",
           is_ntsc, f->fmt.pix.width, f->fmt.pix.height);
  } else {

  }
#line 953
  if (is_ntsc != 0) {
#line 955
    if (f->fmt.pix.height > 479U) {
#line 956
      f->fmt.pix.height = 480U;
#line 957
      field = 4;
    } else {
#line 959
      f->fmt.pix.height = 240U;
#line 960
      field = 2;
    }
#line 962
    if (f->fmt.pix.width > 639U) {
#line 963
      f->fmt.pix.width = 640U;
    } else
#line 964
    if (f->fmt.pix.width > 639U) {
#line 965
      f->fmt.pix.width = 640U;
    } else
#line 966
    if (f->fmt.pix.width > 319U) {
#line 967
      f->fmt.pix.width = 320U;
    } else {
#line 969
      f->fmt.pix.width = 320U;
    }
  } else {
#line 972
    if (f->fmt.pix.height > 575U) {
#line 973
      f->fmt.pix.height = 576U;
#line 974
      field = 4;
    } else {
#line 976
      f->fmt.pix.height = 288U;
#line 977
      field = 2;
    }
#line 979
    if (f->fmt.pix.width > 703U) {
#line 980
      f->fmt.pix.width = 704U;
    } else
#line 981
    if (f->fmt.pix.width > 703U) {
#line 982
      f->fmt.pix.width = 704U;
    } else
#line 983
    if (f->fmt.pix.width > 351U) {
#line 984
      f->fmt.pix.width = 352U;
    } else {
#line 986
      f->fmt.pix.width = 352U;
    }
  }
#line 988
  f->fmt.pix.field = (__u32 )field;
#line 989
  f->fmt.pix.bytesperline = f->fmt.pix.width * (__u32 )fmt->depth >> 3;
#line 990
  f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
#line 991
  f->fmt.pix.colorspace = 1U;
#line 992
  f->fmt.pix.priv = 0U;
#line 993
  if (*s2255_debug > 49) {
#line 993
    printk("\017s2255: %s: set width %d height %d field %d\n", "vidioc_try_fmt_vid_cap",
           f->fmt.pix.width, f->fmt.pix.height, f->fmt.pix.field);
  } else {

  }
#line 995
  return (0);
}
}
#line 998 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int vidioc_s_fmt_vid_cap(struct file *file , void *priv , struct v4l2_format *f ) 
{ 
  struct s2255_fh *fh ;
  struct s2255_channel *channel ;
  struct s2255_fmt  const  *fmt ;
  struct videobuf_queue *q ;
  struct s2255_mode mode ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1001
  fh = (struct s2255_fh *)priv;
#line 1002
  channel = fh->channel;
#line 1004
  q = & fh->vb_vidq;
#line 1008
  ret = vidioc_try_fmt_vid_cap(file, (void *)fh, f);
#line 1010
  if (ret < 0) {
#line 1011
    return (ret);
  } else {

  }
#line 1013
  fmt = format_by_fourcc((int )f->fmt.pix.pixelformat);
#line 1015
  if ((unsigned long )fmt == (unsigned long )((struct s2255_fmt  const  *)0)) {
#line 1016
    return (-22);
  } else {

  }
#line 1018
  mutex_lock_nested(& q->vb_lock, 0U);
#line 1020
  tmp = videobuf_queue_is_busy(& fh->vb_vidq);
#line 1020
  if (tmp != 0) {
#line 1021
    if (*s2255_debug > 0) {
#line 1021
      printk("\017s2255: queue busy\n");
    } else {

    }
#line 1022
    ret = -16;
#line 1023
    goto out_s_fmt;
  } else {

  }
#line 1026
  tmp___0 = res_locked(fh);
#line 1026
  if (tmp___0 != 0) {
#line 1027
    if (*s2255_debug > 0) {
#line 1027
      printk("\017s2255: %s: channel busy\n", "vidioc_s_fmt_vid_cap");
    } else {

    }
#line 1028
    ret = -16;
#line 1029
    goto out_s_fmt;
  } else {

  }
#line 1031
  mode = channel->mode;
#line 1032
  channel->fmt = fmt;
#line 1033
  channel->width = f->fmt.pix.width;
#line 1034
  channel->height = f->fmt.pix.height;
#line 1035
  fh->vb_vidq.field = (enum v4l2_field )f->fmt.pix.field;
#line 1036
  fh->type = (enum v4l2_buf_type )f->type;
#line 1037
  tmp___2 = norm_minw(channel);
#line 1037
  if (channel->width > (unsigned int )tmp___2) {
#line 1038
    tmp___1 = norm_minh(channel);
#line 1038
    if (channel->height > (unsigned int )tmp___1) {
#line 1039
      if ((int )channel->cap_parm.capturemode & 1) {
#line 1041
        mode.scale = 4U;
      } else {
#line 1043
        mode.scale = 1U;
      }
    } else {
#line 1045
      mode.scale = 2U;
    }
  } else {
#line 1048
    mode.scale = 3U;
  }
#line 1051
  switch ((channel->fmt)->fourcc) {
  case 1497715271U: 
#line 1053
  mode.color = mode.color & 4294967040U;
#line 1054
  mode.color = mode.color | 4U;
#line 1055
  goto ldv_33030;
  case 1195724874U: ;
  case 1196444237U: 
#line 1058
  mode.color = mode.color & 4294967040U;
#line 1059
  mode.color = mode.color | 5U;
#line 1060
  mode.color = mode.color | (channel->jpegqual << 8);
#line 1061
  goto ldv_33030;
  case 1345466932U: 
#line 1063
  mode.color = mode.color & 4294967040U;
#line 1064
  mode.color = mode.color | 1U;
#line 1065
  goto ldv_33030;
  case 1448695129U: ;
  case 1498831189U: ;
  default: 
#line 1069
  mode.color = mode.color & 4294967040U;
#line 1070
  mode.color = mode.color | 2U;
#line 1071
  goto ldv_33030;
  }
  ldv_33030: ;
#line 1073
  if (((mode.color ^ channel->mode.color) & 255U) != 0U) {
#line 1074
    mode.restart = 1U;
  } else
#line 1075
  if (mode.scale != channel->mode.scale) {
#line 1076
    mode.restart = 1U;
  } else
#line 1077
  if (mode.format != channel->mode.format) {
#line 1078
    mode.restart = 1U;
  } else {

  }
#line 1079
  channel->mode = mode;
#line 1080
  s2255_set_mode(channel, & mode);
#line 1081
  ret = 0;
  out_s_fmt: 
#line 1083
  mutex_unlock(& q->vb_lock);
#line 1084
  return (ret);
}
}
#line 1087 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int vidioc_reqbufs(struct file *file , void *priv , struct v4l2_requestbuffers *p ) 
{ 
  int rc ;
  struct s2255_fh *fh ;

  {
#line 1091
  fh = (struct s2255_fh *)priv;
#line 1092
  rc = videobuf_reqbufs(& fh->vb_vidq, p);
#line 1093
  return (rc);
}
}
#line 1096 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int vidioc_querybuf(struct file *file , void *priv , struct v4l2_buffer *p ) 
{ 
  int rc ;
  struct s2255_fh *fh ;

  {
#line 1099
  fh = (struct s2255_fh *)priv;
#line 1100
  rc = videobuf_querybuf(& fh->vb_vidq, p);
#line 1101
  return (rc);
}
}
#line 1104 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int vidioc_qbuf(struct file *file , void *priv , struct v4l2_buffer *p ) 
{ 
  int rc ;
  struct s2255_fh *fh ;

  {
#line 1107
  fh = (struct s2255_fh *)priv;
#line 1108
  rc = videobuf_qbuf(& fh->vb_vidq, p);
#line 1109
  return (rc);
}
}
#line 1112 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int vidioc_dqbuf(struct file *file , void *priv , struct v4l2_buffer *p ) 
{ 
  int rc ;
  struct s2255_fh *fh ;

  {
#line 1115
  fh = (struct s2255_fh *)priv;
#line 1116
  rc = videobuf_dqbuf(& fh->vb_vidq, p, (int )file->f_flags & 2048);
#line 1117
  return (rc);
}
}
#line 1121 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int s2255_write_config(struct usb_device *udev , unsigned char *pbuf , int size ) 
{ 
  int pipe ;
  int done ;
  long retval ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 1126
  retval = -1L;
#line 1127
  if ((unsigned long )udev != (unsigned long )((struct usb_device *)0)) {
#line 1128
    tmp = __create_pipe(udev, 2U);
#line 1128
    pipe = (int )(tmp | 3221225472U);
#line 1129
    tmp___0 = usb_bulk_msg(udev, (unsigned int )pipe, (void *)pbuf, size, & done,
                           500);
#line 1129
    retval = (long )tmp___0;
  } else {

  }
#line 1131
  return ((int )retval);
}
}
#line 1134 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static u32 get_transfer_size(struct s2255_mode *mode ) 
{ 
  int linesPerFrame ;
  int pixelsPerLine ;
  u32 outImageSize ;
  u32 usbInSize ;
  unsigned int mask_mult ;

  {
#line 1136
  linesPerFrame = 640;
#line 1137
  pixelsPerLine = 240;
#line 1142
  if ((unsigned long )mode == (unsigned long )((struct s2255_mode *)0)) {
#line 1143
    return (0U);
  } else {

  }
#line 1145
  if (mode->format == 1U) {
#line 1146
    switch (mode->scale) {
    case 1U: ;
    case 4U: 
#line 1149
    linesPerFrame = 480;
#line 1150
    pixelsPerLine = 640;
#line 1151
    goto ldv_33083;
    case 2U: 
#line 1153
    linesPerFrame = 240;
#line 1154
    pixelsPerLine = 640;
#line 1155
    goto ldv_33083;
    case 3U: 
#line 1157
    linesPerFrame = 240;
#line 1158
    pixelsPerLine = 320;
#line 1159
    goto ldv_33083;
    default: ;
#line 1161
    goto ldv_33083;
    }
    ldv_33083: ;
  } else
#line 1163
  if (mode->format == 2U) {
#line 1164
    switch (mode->scale) {
    case 1U: ;
    case 4U: 
#line 1167
    linesPerFrame = 576;
#line 1168
    pixelsPerLine = 704;
#line 1169
    goto ldv_33089;
    case 2U: 
#line 1171
    linesPerFrame = 288;
#line 1172
    pixelsPerLine = 704;
#line 1173
    goto ldv_33089;
    case 3U: 
#line 1175
    linesPerFrame = 288;
#line 1176
    pixelsPerLine = 352;
#line 1177
    goto ldv_33089;
    default: ;
#line 1179
    goto ldv_33089;
    }
    ldv_33089: ;
  } else {

  }
#line 1182
  outImageSize = (u32 )(linesPerFrame * pixelsPerLine);
#line 1183
  if ((mode->color & 255U) != 4U) {
#line 1185
    outImageSize = outImageSize * 2U;
  } else {

  }
#line 1190
  usbInSize = outImageSize + 512U;
#line 1191
  mask_mult = 4294950912U;
#line 1193
  if ((~ mask_mult & usbInSize) != 0U) {
#line 1194
    usbInSize = (usbInSize & mask_mult) + 16384U;
  } else {

  }
#line 1195
  return (usbInSize);
}
}
#line 1198 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static void s2255_print_cfg(struct s2255_dev *sdev , struct s2255_mode *mode ) 
{ 
  struct device *dev ;

  {
#line 1200
  dev = & (sdev->udev)->dev;
#line 1201
  _dev_info((struct device  const  *)dev, "------------------------------------------------\n");
#line 1202
  _dev_info((struct device  const  *)dev, "format: %d\nscale %d\n", mode->format,
            mode->scale);
#line 1203
  _dev_info((struct device  const  *)dev, "fdec: %d\ncolor %d\n", mode->fdec, mode->color);
#line 1204
  _dev_info((struct device  const  *)dev, "bright: 0x%x\n", mode->bright);
#line 1205
  _dev_info((struct device  const  *)dev, "------------------------------------------------\n");
#line 1206
  return;
}
}
#line 1216 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int s2255_set_mode(struct s2255_channel *channel , struct s2255_mode *mode ) 
{ 
  int res ;
  __le32 *buffer ;
  unsigned long chn_rev ;
  struct s2255_dev *dev ;
  struct s2255_dev *tmp ;
  int i ;
  u32 tmp___0 ;
  void *tmp___1 ;
  long __ret ;
  unsigned long tmp___2 ;
  wait_queue_t __wait ;
  struct task_struct *tmp___3 ;

  {
#line 1222
  tmp = to_s2255_dev(channel->vdev.v4l2_dev);
#line 1222
  dev = tmp;
#line 1225
  chn_rev = G_chnmap[channel->idx];
#line 1226
  if (*s2255_debug > 2) {
#line 1226
    printk("\017s2255: %s channel: %d\n", "s2255_set_mode", channel->idx);
  } else {

  }
#line 1228
  if ((mode->color & 255U) == 5U) {
#line 1229
    mode->color = mode->color & 4294967040U;
#line 1230
    mode->color = mode->color | 5U;
#line 1231
    mode->color = mode->color & 4294902015U;
#line 1232
    mode->color = mode->color | (channel->jpegqual << 8);
  } else {

  }
#line 1235
  channel->mode = *mode;
#line 1236
  tmp___0 = get_transfer_size(mode);
#line 1236
  channel->req_image_size = (unsigned long )tmp___0;
#line 1237
  if (*s2255_debug > 0) {
#line 1237
    printk("\017s2255: %s: reqsize %ld\n", "s2255_set_mode", channel->req_image_size);
  } else {

  }
#line 1238
  tmp___1 = kzalloc(512UL, 208U);
#line 1238
  buffer = (__le32 *)tmp___1;
#line 1239
  if ((unsigned long )buffer == (unsigned long )((__le32 *)0U)) {
#line 1240
    dev_err((struct device  const  *)(& (dev->udev)->dev), "out of mem\n");
#line 1241
    return (-12);
  } else {

  }
#line 1244
  *buffer = 576045278U;
#line 1245
  *(buffer + 1UL) = (unsigned int )chn_rev;
#line 1246
  *(buffer + 2UL) = 3257225232U;
#line 1247
  i = 0;
#line 1247
  goto ldv_33109;
  ldv_33108: 
#line 1248
  *(buffer + (unsigned long )(i + 3)) = *((u32 *)(& channel->mode) + (unsigned long )i);
#line 1247
  i = i + 1;
  ldv_33109: ;
#line 1247
  if ((unsigned int )i <= 10U) {
#line 1249
    goto ldv_33108;
  } else {

  }
#line 1249
  channel->setmode_ready = 0;
#line 1250
  res = s2255_write_config(dev->udev, (unsigned char *)buffer, 512);
#line 1251
  if (debug != 0) {
#line 1252
    s2255_print_cfg(dev, mode);
  } else {

  }
#line 1253
  kfree((void const   *)buffer);
#line 1255
  if (mode->restart != 0U) {
#line 1256
    tmp___2 = msecs_to_jiffies(500U);
#line 1256
    __ret = (long )tmp___2;
#line 1256
    if (channel->setmode_ready == 0) {
#line 1256
      tmp___3 = get_current();
#line 1256
      __wait.flags = 0U;
#line 1256
      __wait.private = (void *)tmp___3;
#line 1256
      __wait.func = & autoremove_wake_function;
#line 1256
      __wait.task_list.next = & __wait.task_list;
#line 1256
      __wait.task_list.prev = & __wait.task_list;
      ldv_33114: 
#line 1256
      prepare_to_wait(& channel->wait_setmode, & __wait, 2);
#line 1256
      if (channel->setmode_ready != 0) {
#line 1256
        goto ldv_33113;
      } else {

      }
#line 1256
      __ret = schedule_timeout(__ret);
#line 1256
      if (__ret == 0L) {
#line 1256
        goto ldv_33113;
      } else {

      }
#line 1256
      goto ldv_33114;
      ldv_33113: ;
#line 1256
      if (__ret == 0L && channel->setmode_ready != 0) {
#line 1256
        __ret = 1L;
      } else {

      }
#line 1256
      finish_wait(& channel->wait_setmode, & __wait);
    } else {

    }
#line 1259
    if (channel->setmode_ready != 1) {
#line 1260
      printk("\017s2255: no set mode response\n");
#line 1261
      res = -14;
    } else {

    }
  } else {

  }
#line 1265
  channel->mode.restart = 0U;
#line 1266
  if (*s2255_debug > 0) {
#line 1266
    printk("\017s2255: %s chn %d, result: %d\n", "s2255_set_mode", channel->idx, res);
  } else {

  }
#line 1267
  return (res);
}
}
#line 1270 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int s2255_cmd_status(struct s2255_channel *channel , u32 *pstatus ) 
{ 
  int res ;
  __le32 *buffer ;
  u32 chn_rev ;
  struct s2255_dev *dev ;
  struct s2255_dev *tmp ;
  void *tmp___0 ;
  long __ret ;
  unsigned long tmp___1 ;
  wait_queue_t __wait ;
  struct task_struct *tmp___2 ;

  {
#line 1275
  tmp = to_s2255_dev(channel->vdev.v4l2_dev);
#line 1275
  dev = tmp;
#line 1276
  chn_rev = (u32 )G_chnmap[channel->idx];
#line 1277
  if (*s2255_debug > 3) {
#line 1277
    printk("\017s2255: %s chan %d\n", "s2255_cmd_status", channel->idx);
  } else {

  }
#line 1278
  tmp___0 = kzalloc(512UL, 208U);
#line 1278
  buffer = (__le32 *)tmp___0;
#line 1279
  if ((unsigned long )buffer == (unsigned long )((__le32 *)0U)) {
#line 1280
    dev_err((struct device  const  *)(& (dev->udev)->dev), "out of mem\n");
#line 1281
    return (-12);
  } else {

  }
#line 1284
  *buffer = 576045278U;
#line 1285
  *(buffer + 1UL) = chn_rev;
#line 1286
  *(buffer + 2UL) = 3257225280U;
#line 1287
  *pstatus = 0U;
#line 1288
  channel->vidstatus_ready = 0;
#line 1289
  res = s2255_write_config(dev->udev, (unsigned char *)buffer, 512);
#line 1290
  kfree((void const   *)buffer);
#line 1291
  tmp___1 = msecs_to_jiffies(350U);
#line 1291
  __ret = (long )tmp___1;
#line 1291
  if (channel->vidstatus_ready == 0) {
#line 1291
    tmp___2 = get_current();
#line 1291
    __wait.flags = 0U;
#line 1291
    __wait.private = (void *)tmp___2;
#line 1291
    __wait.func = & autoremove_wake_function;
#line 1291
    __wait.task_list.next = & __wait.task_list;
#line 1291
    __wait.task_list.prev = & __wait.task_list;
    ldv_33128: 
#line 1291
    prepare_to_wait(& channel->wait_vidstatus, & __wait, 2);
#line 1291
    if (channel->vidstatus_ready != 0) {
#line 1291
      goto ldv_33127;
    } else {

    }
#line 1291
    __ret = schedule_timeout(__ret);
#line 1291
    if (__ret == 0L) {
#line 1291
      goto ldv_33127;
    } else {

    }
#line 1291
    goto ldv_33128;
    ldv_33127: ;
#line 1291
    if (__ret == 0L && channel->vidstatus_ready != 0) {
#line 1291
      __ret = 1L;
    } else {

    }
#line 1291
    finish_wait(& channel->wait_vidstatus, & __wait);
  } else {

  }
#line 1294
  if (channel->vidstatus_ready != 1) {
#line 1295
    printk("\017s2255: no vidstatus response\n");
#line 1296
    res = -14;
  } else {

  }
#line 1298
  *pstatus = (u32 )channel->vidstatus;
#line 1299
  if (*s2255_debug > 3) {
#line 1299
    printk("\017s2255: %s, vid status %d\n", "s2255_cmd_status", *pstatus);
  } else {

  }
#line 1300
  return (res);
}
}
#line 1303 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int vidioc_streamon(struct file *file , void *priv , enum v4l2_buf_type i ) 
{ 
  int res ;
  struct s2255_fh *fh ;
  struct s2255_dev *dev ;
  struct s2255_channel *channel ;
  int j ;
  int tmp ;

  {
#line 1306
  fh = (struct s2255_fh *)priv;
#line 1307
  dev = fh->dev;
#line 1308
  channel = fh->channel;
#line 1310
  if (*s2255_debug > 3) {
#line 1310
    printk("\017s2255: %s\n", "vidioc_streamon");
  } else {

  }
#line 1311
  if ((unsigned int )fh->type != 1U) {
#line 1312
    dev_err((struct device  const  *)(& (dev->udev)->dev), "invalid fh type0\n");
#line 1313
    return (-22);
  } else {

  }
#line 1315
  if ((unsigned int )fh->type != (unsigned int )i) {
#line 1316
    dev_err((struct device  const  *)(& (dev->udev)->dev), "invalid fh type1\n");
#line 1317
    return (-22);
  } else {

  }
#line 1320
  tmp = res_get(fh);
#line 1320
  if (tmp == 0) {
#line 1321
    dev_err((struct device  const  *)(& (dev->udev)->dev), "s2255 - stream busy\n");
#line 1322
    return (-16);
  } else {

  }
#line 1324
  channel->last_frame = -1;
#line 1325
  channel->bad_payload = 0;
#line 1326
  channel->cur_frame = 0;
#line 1327
  channel->frame_count = 0UL;
#line 1328
  j = 0;
#line 1328
  goto ldv_33142;
  ldv_33141: 
#line 1329
  channel->buffer.frame[j].ulState = 0UL;
#line 1330
  channel->buffer.frame[j].cur_size = 0UL;
#line 1328
  j = j + 1;
  ldv_33142: ;
#line 1328
  if (j <= 3) {
#line 1330
    goto ldv_33141;
  } else {

  }
#line 1332
  res = videobuf_streamon(& fh->vb_vidq);
#line 1333
  if (res == 0) {
#line 1334
    s2255_start_acquire(channel);
#line 1335
    channel->b_acquire = 1;
  } else {
#line 1337
    res_free(fh);
  }
#line 1339
  return (res);
}
}
#line 1342 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int vidioc_streamoff(struct file *file , void *priv , enum v4l2_buf_type i ) 
{ 
  struct s2255_fh *fh ;

  {
#line 1344
  fh = (struct s2255_fh *)priv;
#line 1345
  if (*s2255_debug > 3) {
#line 1345
    printk("\017s2255: %s\n, channel: %d", "vidioc_streamoff", (fh->channel)->idx);
  } else {

  }
#line 1346
  if ((unsigned int )fh->type != 1U) {
#line 1347
    printk("\vinvalid fh type0\n");
#line 1348
    return (-22);
  } else {

  }
#line 1350
  if ((unsigned int )fh->type != (unsigned int )i) {
#line 1351
    printk("\vinvalid type i\n");
#line 1352
    return (-22);
  } else {

  }
#line 1354
  s2255_stop_acquire(fh->channel);
#line 1355
  videobuf_streamoff(& fh->vb_vidq);
#line 1356
  res_free(fh);
#line 1357
  return (0);
}
}
#line 1360 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int vidioc_s_std(struct file *file , void *priv , v4l2_std_id i ) 
{ 
  struct s2255_fh *fh ;
  struct s2255_mode mode ;
  struct videobuf_queue *q ;
  struct s2255_channel *channel ;
  int ret ;
  int tmp ;

  {
#line 1362
  fh = (struct s2255_fh *)priv;
#line 1364
  q = & fh->vb_vidq;
#line 1365
  channel = fh->channel;
#line 1366
  ret = 0;
#line 1368
  mutex_lock_nested(& q->vb_lock, 0U);
#line 1369
  tmp = res_locked(fh);
#line 1369
  if (tmp != 0) {
#line 1370
    if (*s2255_debug > 0) {
#line 1370
      printk("\017s2255: can\'t change standard after started\n");
    } else {

    }
#line 1371
    ret = -16;
#line 1372
    goto out_s_std;
  } else {

  }
#line 1374
  mode = (fh->channel)->mode;
#line 1375
  if ((i & 63744ULL) != 0ULL) {
#line 1376
    if (*s2255_debug > 3) {
#line 1376
      printk("\017s2255: %s 60 Hz\n", "vidioc_s_std");
    } else {

    }
#line 1378
    if (mode.format != 1U) {
#line 1379
      mode.restart = 1U;
#line 1380
      mode.format = 1U;
#line 1381
      mode.fdec = 1U;
#line 1382
      channel->width = 640U;
#line 1383
      channel->height = 480U;
    } else {

    }
  } else
#line 1385
  if ((i & 16713471ULL) != 0ULL) {
#line 1386
    if (*s2255_debug > 3) {
#line 1386
      printk("\017s2255: %s 50 Hz\n", "vidioc_s_std");
    } else {

    }
#line 1387
    if (mode.format != 2U) {
#line 1388
      mode.restart = 1U;
#line 1389
      mode.format = 2U;
#line 1390
      mode.fdec = 1U;
#line 1391
      channel->width = 704U;
#line 1392
      channel->height = 576U;
    } else {

    }
  } else {
#line 1395
    ret = -22;
#line 1396
    goto out_s_std;
  }
#line 1398
  (fh->channel)->std = i;
#line 1399
  if (mode.restart != 0U) {
#line 1400
    s2255_set_mode(fh->channel, & mode);
  } else {

  }
  out_s_std: 
#line 1402
  mutex_unlock(& q->vb_lock);
#line 1403
  return (ret);
}
}
#line 1406 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int vidioc_g_std(struct file *file , void *priv , v4l2_std_id *i ) 
{ 
  struct s2255_fh *fh ;

  {
#line 1408
  fh = (struct s2255_fh *)priv;
#line 1410
  *i = (fh->channel)->std;
#line 1411
  return (0);
}
}
#line 1421 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int vidioc_enum_input(struct file *file , void *priv , struct v4l2_input *inp ) 
{ 
  struct s2255_fh *fh ;
  struct s2255_dev *dev ;
  struct s2255_channel *channel ;
  u32 status ;
  int rc ;

  {
#line 1424
  fh = (struct s2255_fh *)priv;
#line 1425
  dev = fh->dev;
#line 1426
  channel = fh->channel;
#line 1427
  status = 0U;
#line 1428
  if (inp->index != 0U) {
#line 1429
    return (-22);
  } else {

  }
#line 1430
  inp->type = 2U;
#line 1431
  inp->std = 16777215ULL;
#line 1432
  inp->status = 0U;
#line 1433
  if (dev->dsp_fw_ver > 4) {
#line 1435
    rc = s2255_cmd_status(fh->channel, & status);
#line 1436
    if (*s2255_debug > 3) {
#line 1436
      printk("\017s2255: s2255_cmd_status rc: %d status %x\n", rc, status);
    } else {

    }
#line 1437
    if (rc == 0) {
#line 1438
      inp->status = (int )status & 1 ? 0U : 2U;
    } else {

    }
  } else {

  }
#line 1441
  switch ((int )dev->pid) {
  case 8789: ;
  default: 
#line 1444
  strlcpy((char *)(& inp->name), "Composite", 32UL);
#line 1445
  goto ldv_33181;
  case 8791: 
#line 1447
  strlcpy((char *)(& inp->name), channel->idx <= 1 ? "Composite" : "S-Video", 32UL);
#line 1449
  goto ldv_33181;
  }
  ldv_33181: ;
#line 1451
  return (0);
}
}
#line 1454 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int vidioc_g_input(struct file *file , void *priv , unsigned int *i ) 
{ 


  {
#line 1456
  *i = 0U;
#line 1457
  return (0);
}
}
#line 1459 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int vidioc_s_input(struct file *file , void *priv , unsigned int i ) 
{ 


  {
#line 1461
  if (i != 0U) {
#line 1462
    return (-22);
  } else {

  }
#line 1463
  return (0);
}
}
#line 1466 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int s2255_s_ctrl(struct v4l2_ctrl *ctrl ) 
{ 
  struct s2255_channel *channel ;
  struct v4l2_ctrl_handler  const  *__mptr ;
  struct s2255_mode mode ;

  {
#line 1469
  __mptr = (struct v4l2_ctrl_handler  const  *)ctrl->handler;
#line 1469
  channel = (struct s2255_channel *)__mptr + 0xfffffffffffff8f8UL;
#line 1472
  mode = channel->mode;
#line 1473
  if (*s2255_debug > 3) {
#line 1473
    printk("\017s2255: %s\n", "s2255_s_ctrl");
  } else {

  }
#line 1476
  switch (ctrl->id) {
  case 9963776U: 
#line 1478
  mode.bright = (u32 )ctrl->ldv_32371.val;
#line 1479
  goto ldv_33202;
  case 9963777U: 
#line 1481
  mode.contrast = (u32 )ctrl->ldv_32371.val;
#line 1482
  goto ldv_33202;
  case 9963779U: 
#line 1484
  mode.hue = (u32 )ctrl->ldv_32371.val;
#line 1485
  goto ldv_33202;
  case 9963778U: 
#line 1487
  mode.saturation = (u32 )ctrl->ldv_32371.val;
#line 1488
  goto ldv_33202;
  case 9967920U: 
#line 1490
  mode.color = mode.color & 4293984255U;
#line 1491
  mode.color = mode.color | (ctrl->ldv_32371.val == 0 ? 65536U : 0U);
#line 1492
  goto ldv_33202;
  case 10291459U: 
#line 1494
  channel->jpegqual = (unsigned int )ctrl->ldv_32371.val;
#line 1495
  return (0);
  default: ;
#line 1497
  return (-22);
  }
  ldv_33202: 
#line 1499
  mode.restart = 0U;
#line 1504
  s2255_set_mode(channel, & mode);
#line 1505
  return (0);
}
}
#line 1508 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int vidioc_g_jpegcomp(struct file *file , void *priv , struct v4l2_jpegcompression *jc ) 
{ 
  struct s2255_fh *fh ;
  struct s2255_channel *channel ;

  {
#line 1511
  fh = (struct s2255_fh *)priv;
#line 1512
  channel = fh->channel;
#line 1514
  memset((void *)jc, 0, 140UL);
#line 1515
  jc->quality = (int )channel->jpegqual;
#line 1516
  if (*s2255_debug > 1) {
#line 1516
    printk("\017s2255: %s: quality %d\n", "vidioc_g_jpegcomp", jc->quality);
  } else {

  }
#line 1517
  return (0);
}
}
#line 1520 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int vidioc_s_jpegcomp(struct file *file , void *priv , struct v4l2_jpegcompression  const  *jc ) 
{ 
  struct s2255_fh *fh ;
  struct s2255_channel *channel ;

  {
#line 1523
  fh = (struct s2255_fh *)priv;
#line 1524
  channel = fh->channel;
#line 1525
  if ((int )jc->quality < 0 || (int )jc->quality > 100) {
#line 1526
    return (-22);
  } else {

  }
#line 1527
  v4l2_ctrl_s_ctrl(channel->jpegqual_ctrl, jc->quality);
#line 1528
  if (*s2255_debug > 1) {
#line 1528
    printk("\017s2255: %s: quality %d\n", "vidioc_s_jpegcomp", jc->quality);
  } else {

  }
#line 1529
  return (0);
}
}
#line 1532 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int vidioc_g_parm(struct file *file , void *priv , struct v4l2_streamparm *sp ) 
{ 
  struct s2255_fh *fh ;
  __u32 def_num ;
  __u32 def_dem ;
  struct s2255_channel *channel ;

  {
#line 1535
  fh = (struct s2255_fh *)priv;
#line 1537
  channel = fh->channel;
#line 1538
  if (sp->type != 1U) {
#line 1539
    return (-22);
  } else {

  }
#line 1540
  sp->parm.capture.capability = 4096U;
#line 1541
  sp->parm.capture.capturemode = channel->cap_parm.capturemode;
#line 1542
  def_num = channel->mode.format == 1U ? 1001U : 1000U;
#line 1543
  def_dem = channel->mode.format == 1U ? 30000U : 25000U;
#line 1544
  sp->parm.capture.timeperframe.denominator = def_dem;
#line 1545
  switch (channel->mode.fdec) {
  default: ;
  case 1U: 
#line 1548
  sp->parm.capture.timeperframe.numerator = def_num;
#line 1549
  goto ldv_33236;
  case 2U: 
#line 1551
  sp->parm.capture.timeperframe.numerator = def_num * 2U;
#line 1552
  goto ldv_33236;
  case 3U: 
#line 1554
  sp->parm.capture.timeperframe.numerator = def_num * 3U;
#line 1555
  goto ldv_33236;
  case 5U: 
#line 1557
  sp->parm.capture.timeperframe.numerator = def_num * 5U;
#line 1558
  goto ldv_33236;
  }
  ldv_33236: ;
#line 1560
  if (*s2255_debug > 3) {
#line 1560
    printk("\017s2255: %s capture mode, %d timeperframe %d/%d\n", "vidioc_g_parm",
           sp->parm.capture.capturemode, sp->parm.capture.timeperframe.numerator,
           sp->parm.capture.timeperframe.denominator);
  } else {

  }
#line 1564
  return (0);
}
}
#line 1567 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int vidioc_s_parm(struct file *file , void *priv , struct v4l2_streamparm *sp ) 
{ 
  struct s2255_fh *fh ;
  struct s2255_channel *channel ;
  struct s2255_mode mode ;
  int fdec ;
  __u32 def_num ;
  __u32 def_dem ;
  int tmp ;

  {
#line 1570
  fh = (struct s2255_fh *)priv;
#line 1571
  channel = fh->channel;
#line 1573
  fdec = 1;
#line 1575
  if (sp->type != 1U) {
#line 1576
    return (-22);
  } else {

  }
#line 1577
  mode = channel->mode;
#line 1579
  if (channel->cap_parm.capturemode != sp->parm.capture.capturemode) {
#line 1579
    tmp = res_locked(fh);
#line 1579
    if (tmp != 0) {
#line 1581
      return (-16);
    } else {

    }
  } else {

  }
#line 1582
  def_num = mode.format == 1U ? 1001U : 1000U;
#line 1583
  def_dem = mode.format == 1U ? 30000U : 25000U;
#line 1584
  if (sp->parm.capture.timeperframe.denominator != def_dem) {
#line 1585
    sp->parm.capture.timeperframe.numerator = def_num;
  } else
#line 1586
  if (sp->parm.capture.timeperframe.numerator <= def_num) {
#line 1587
    sp->parm.capture.timeperframe.numerator = def_num;
  } else
#line 1588
  if (sp->parm.capture.timeperframe.numerator <= def_num * 2U) {
#line 1589
    sp->parm.capture.timeperframe.numerator = def_num * 2U;
#line 1590
    fdec = 2;
  } else
#line 1591
  if (sp->parm.capture.timeperframe.numerator <= def_num * 3U) {
#line 1592
    sp->parm.capture.timeperframe.numerator = def_num * 3U;
#line 1593
    fdec = 3;
  } else {
#line 1595
    sp->parm.capture.timeperframe.numerator = def_num * 5U;
#line 1596
    fdec = 5;
  }
#line 1598
  mode.fdec = (u32 )fdec;
#line 1599
  sp->parm.capture.timeperframe.denominator = def_dem;
#line 1600
  s2255_set_mode(channel, & mode);
#line 1601
  if (*s2255_debug > 3) {
#line 1601
    printk("\017s2255: %s capture mode, %d timeperframe %d/%d, fdec %d\n", "vidioc_s_parm",
           sp->parm.capture.capturemode, sp->parm.capture.timeperframe.numerator,
           sp->parm.capture.timeperframe.denominator, fdec);
  } else {

  }
#line 1606
  return (0);
}
}
#line 1610 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static struct v4l2_frmsize_discrete  const  ntsc_sizes[3U]  = {      {640U, 480U}, 
        {640U, 240U}, 
        {320U, 240U}};
#line 1615 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static struct v4l2_frmsize_discrete  const  pal_sizes[3U]  = {      {704U, 576U}, 
        {704U, 288U}, 
        {352U, 288U}};
#line 1621 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int vidioc_enum_framesizes(struct file *file , void *priv , struct v4l2_frmsizeenum *fe ) 
{ 
  struct s2255_fh *fh ;
  struct s2255_channel *channel ;
  int is_ntsc ;
  struct s2255_fmt  const  *fmt ;

  {
#line 1624
  fh = (struct s2255_fh *)priv;
#line 1625
  channel = fh->channel;
#line 1626
  is_ntsc = (int )channel->std & 63744;
#line 1629
  if (fe->index > 2U) {
#line 1630
    return (-22);
  } else {

  }
#line 1632
  fmt = format_by_fourcc((int )fe->pixel_format);
#line 1633
  if ((unsigned long )fmt == (unsigned long )((struct s2255_fmt  const  *)0)) {
#line 1634
    return (-22);
  } else {

  }
#line 1635
  fe->type = 1U;
#line 1636
  fe->ldv_27008.discrete = is_ntsc != 0 ? ntsc_sizes[fe->index] : pal_sizes[fe->index];
#line 1637
  return (0);
}
}
#line 1640 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int vidioc_enum_frameintervals(struct file *file , void *priv , struct v4l2_frmivalenum *fe ) 
{ 
  struct s2255_fh *fh ;
  struct s2255_channel *channel ;
  struct s2255_fmt  const  *fmt ;
  struct v4l2_frmsize_discrete  const  *sizes ;
  int is_ntsc ;
  int frm_dec[4U] ;
  int i ;

  {
#line 1643
  fh = (struct s2255_fh *)priv;
#line 1644
  channel = fh->channel;
#line 1647
  is_ntsc = (int )channel->std & 63744;
#line 1649
  frm_dec[0] = 1;
#line 1649
  frm_dec[1] = 2;
#line 1649
  frm_dec[2] = 3;
#line 1649
  frm_dec[3] = 5;
#line 1652
  if (fe->index > 3U) {
#line 1653
    return (-22);
  } else {

  }
#line 1655
  fmt = format_by_fourcc((int )fe->pixel_format);
#line 1656
  if ((unsigned long )fmt == (unsigned long )((struct s2255_fmt  const  *)0)) {
#line 1657
    return (-22);
  } else {

  }
#line 1659
  sizes = is_ntsc != 0 ? (struct v4l2_frmsize_discrete  const  *)(& ntsc_sizes) : (struct v4l2_frmsize_discrete  const  *)(& pal_sizes);
#line 1660
  i = 0;
#line 1660
  goto ldv_33278;
  ldv_33277: ;
#line 1661
  if (fe->width == (__u32 )sizes->width && fe->height == (__u32 )sizes->height) {
#line 1663
    goto ldv_33276;
  } else {

  }
#line 1660
  i = i + 1;
#line 1660
  sizes = sizes + 1;
  ldv_33278: ;
#line 1660
  if (i <= 2) {
#line 1662
    goto ldv_33277;
  } else {

  }
  ldv_33276: ;
#line 1664
  if (i == 3) {
#line 1665
    return (-22);
  } else {

  }
#line 1667
  fe->type = 1U;
#line 1668
  fe->ldv_27027.discrete.denominator = is_ntsc != 0 ? 30000U : 25000U;
#line 1669
  fe->ldv_27027.discrete.numerator = (__u32 )((is_ntsc != 0 ? 1001 : 1000) * frm_dec[fe->index]);
#line 1670
  if (*s2255_debug > 3) {
#line 1670
    printk("\017s2255: %s discrete %d/%d\n", "vidioc_enum_frameintervals", fe->ldv_27027.discrete.numerator,
           fe->ldv_27027.discrete.denominator);
  } else {

  }
#line 1672
  return (0);
}
}
#line 1675 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int __s2255_open(struct file *file ) 
{ 
  struct video_device *vdev ;
  struct video_device *tmp ;
  struct s2255_channel *channel ;
  void *tmp___0 ;
  struct s2255_dev *dev ;
  struct s2255_dev *tmp___1 ;
  struct s2255_fh *fh ;
  enum v4l2_buf_type type ;
  int state ;
  char const   *tmp___2 ;
  long __ret ;
  unsigned long tmp___3 ;
  wait_queue_t __wait ;
  struct task_struct *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  long __ret___0 ;
  unsigned long tmp___11 ;
  wait_queue_t __wait___0 ;
  struct task_struct *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  void *tmp___19 ;
  char const   *tmp___20 ;
  int tmp___21 ;

  {
#line 1677
  tmp = video_devdata(file);
#line 1677
  vdev = tmp;
#line 1678
  tmp___0 = video_drvdata(file);
#line 1678
  channel = (struct s2255_channel *)tmp___0;
#line 1679
  tmp___1 = to_s2255_dev(vdev->v4l2_dev);
#line 1679
  dev = tmp___1;
#line 1681
  type = 1;
#line 1683
  if (*s2255_debug > 0) {
#line 1683
    tmp___2 = video_device_node_name(vdev);
#line 1683
    printk("\017s2255: s2255: open called (dev=%s)\n", tmp___2);
  } else {

  }
#line 1685
  state = atomic_read((atomic_t const   *)(& (dev->fw_data)->fw_state));
#line 1686
  switch (state) {
  case 4: ;
#line 1688
  return (-19);
  case 3: 
#line 1690
  dev_err((struct device  const  *)(& (dev->udev)->dev), "s2255 - firmware load failed. retrying.\n");
#line 1692
  s2255_fwload_start(dev, 1);
#line 1693
  tmp___3 = msecs_to_jiffies(5800U);
#line 1693
  __ret = (long )tmp___3;
#line 1693
  tmp___9 = atomic_read((atomic_t const   *)(& (dev->fw_data)->fw_state));
#line 1693
  if (tmp___9 != 2) {
#line 1693
    tmp___10 = atomic_read((atomic_t const   *)(& (dev->fw_data)->fw_state));
#line 1693
    if (tmp___10 != 4) {
#line 1693
      tmp___4 = get_current();
#line 1693
      __wait.flags = 0U;
#line 1693
      __wait.private = (void *)tmp___4;
#line 1693
      __wait.func = & autoremove_wake_function;
#line 1693
      __wait.task_list.next = & __wait.task_list;
#line 1693
      __wait.task_list.prev = & __wait.task_list;
      ldv_33294: 
#line 1693
      prepare_to_wait(& (dev->fw_data)->wait_fw, & __wait, 2);
#line 1693
      tmp___5 = atomic_read((atomic_t const   *)(& (dev->fw_data)->fw_state));
#line 1693
      if (tmp___5 == 2) {
#line 1693
        goto ldv_33293;
      } else {
#line 1693
        tmp___6 = atomic_read((atomic_t const   *)(& (dev->fw_data)->fw_state));
#line 1693
        if (tmp___6 == 4) {
#line 1693
          goto ldv_33293;
        } else {

        }
      }
#line 1693
      __ret = schedule_timeout(__ret);
#line 1693
      if (__ret == 0L) {
#line 1693
        goto ldv_33293;
      } else {

      }
#line 1693
      goto ldv_33294;
      ldv_33293: ;
#line 1693
      if (__ret == 0L) {
#line 1693
        tmp___7 = atomic_read((atomic_t const   *)(& (dev->fw_data)->fw_state));
#line 1693
        if (tmp___7 == 2) {
#line 1693
          __ret = 1L;
        } else {
#line 1693
          tmp___8 = atomic_read((atomic_t const   *)(& (dev->fw_data)->fw_state));
#line 1693
          if (tmp___8 == 4) {
#line 1693
            __ret = 1L;
          } else {

          }
        }
      } else {

      }
#line 1693
      finish_wait(& (dev->fw_data)->wait_fw, & __wait);
    } else {

    }
  } else {

  }
#line 1700
  state = atomic_read((atomic_t const   *)(& (dev->fw_data)->fw_state));
#line 1701
  goto ldv_33296;
  case 0: ;
  case 1: 
#line 1706
  printk("\016%s waiting for firmware load\n", "__s2255_open");
#line 1707
  tmp___11 = msecs_to_jiffies(5800U);
#line 1707
  __ret___0 = (long )tmp___11;
#line 1707
  tmp___17 = atomic_read((atomic_t const   *)(& (dev->fw_data)->fw_state));
#line 1707
  if (tmp___17 != 2) {
#line 1707
    tmp___18 = atomic_read((atomic_t const   *)(& (dev->fw_data)->fw_state));
#line 1707
    if (tmp___18 != 4) {
#line 1707
      tmp___12 = get_current();
#line 1707
      __wait___0.flags = 0U;
#line 1707
      __wait___0.private = (void *)tmp___12;
#line 1707
      __wait___0.func = & autoremove_wake_function;
#line 1707
      __wait___0.task_list.next = & __wait___0.task_list;
#line 1707
      __wait___0.task_list.prev = & __wait___0.task_list;
      ldv_33303: 
#line 1707
      prepare_to_wait(& (dev->fw_data)->wait_fw, & __wait___0, 2);
#line 1707
      tmp___13 = atomic_read((atomic_t const   *)(& (dev->fw_data)->fw_state));
#line 1707
      if (tmp___13 == 2) {
#line 1707
        goto ldv_33302;
      } else {
#line 1707
        tmp___14 = atomic_read((atomic_t const   *)(& (dev->fw_data)->fw_state));
#line 1707
        if (tmp___14 == 4) {
#line 1707
          goto ldv_33302;
        } else {

        }
      }
#line 1707
      __ret___0 = schedule_timeout(__ret___0);
#line 1707
      if (__ret___0 == 0L) {
#line 1707
        goto ldv_33302;
      } else {

      }
#line 1707
      goto ldv_33303;
      ldv_33302: ;
#line 1707
      if (__ret___0 == 0L) {
#line 1707
        tmp___15 = atomic_read((atomic_t const   *)(& (dev->fw_data)->fw_state));
#line 1707
        if (tmp___15 == 2) {
#line 1707
          __ret___0 = 1L;
        } else {
#line 1707
          tmp___16 = atomic_read((atomic_t const   *)(& (dev->fw_data)->fw_state));
#line 1707
          if (tmp___16 == 4) {
#line 1707
            __ret___0 = 1L;
          } else {

          }
        }
      } else {

      }
#line 1707
      finish_wait(& (dev->fw_data)->wait_fw, & __wait___0);
    } else {

    }
  } else {

  }
#line 1714
  state = atomic_read((atomic_t const   *)(& (dev->fw_data)->fw_state));
#line 1715
  goto ldv_33296;
  case 2: ;
  default: ;
#line 1718
  goto ldv_33296;
  }
  ldv_33296: ;
#line 1721
  switch (state) {
  case 2: ;
#line 1723
  goto ldv_33308;
  case 3: 
#line 1725
  printk("r255 firmware load failed.\n");
#line 1726
  return (-19);
  case 4: 
#line 1728
  printk("\016%s: disconnecting\n", "__s2255_open");
#line 1729
  return (-19);
  case 1: ;
  case 0: 
#line 1732
  printk("\016%s: firmware not loaded yetplease try again later\n", "__s2255_open");
#line 1740
  atomic_set(& (dev->fw_data)->fw_state, 3);
#line 1742
  return (-11);
  default: 
#line 1744
  printk("\016%s: unknown state\n", "__s2255_open");
#line 1745
  return (-14);
  }
  ldv_33308: 
#line 1748
  tmp___19 = kzalloc(816UL, 208U);
#line 1748
  fh = (struct s2255_fh *)tmp___19;
#line 1749
  if ((unsigned long )fh == (unsigned long )((struct s2255_fh *)0)) {
#line 1750
    return (-12);
  } else {

  }
#line 1751
  v4l2_fh_init(& fh->fh, vdev);
#line 1752
  v4l2_fh_add(& fh->fh);
#line 1753
  file->private_data = (void *)(& fh->fh);
#line 1754
  fh->dev = dev;
#line 1755
  fh->type = 1;
#line 1756
  fh->channel = channel;
#line 1757
  if (channel->configured == 0) {
#line 1759
    channel->fmt = (struct s2255_fmt  const  *)(& formats);
#line 1760
    s2255_set_mode(channel, & channel->mode);
#line 1761
    channel->configured = 1;
  } else {

  }
#line 1763
  if (*s2255_debug > 0) {
#line 1763
    tmp___20 = video_device_node_name(vdev);
#line 1763
    printk("\017s2255: %s: dev=%s type=%s\n", "__s2255_open", tmp___20, v4l2_type_names[(unsigned int )type]);
  } else {

  }
#line 1765
  if (*s2255_debug > 1) {
#line 1765
    printk("\017s2255: %s: fh=0x%08lx, dev=0x%08lx, vidq=0x%08lx\n", "__s2255_open",
           (unsigned long )fh, (unsigned long )dev, (unsigned long )(& channel->vidq));
  } else {

  }
#line 1768
  if (*s2255_debug > 3) {
#line 1768
    tmp___21 = list_empty((struct list_head  const  *)(& channel->vidq.active));
#line 1768
    printk("\017s2255: %s: list_empty active=%d\n", "__s2255_open", tmp___21);
  } else {

  }
#line 1770
  videobuf_queue_vmalloc_init(& fh->vb_vidq, (struct videobuf_queue_ops  const  *)(& s2255_video_qops),
                              (struct device *)0, & dev->slock, fh->type, 4, 248U,
                              (void *)fh, vdev->lock);
#line 1776
  return (0);
}
}
#line 1779 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int s2255_open(struct file *file ) 
{ 
  struct video_device *vdev ;
  struct video_device *tmp ;
  int ret ;
  int tmp___0 ;

  {
#line 1781
  tmp = video_devdata(file);
#line 1781
  vdev = tmp;
#line 1784
  tmp___0 = mutex_lock_interruptible_nested(vdev->lock, 0U);
#line 1784
  if (tmp___0 != 0) {
#line 1785
    return (-512);
  } else {

  }
#line 1786
  ret = __s2255_open(file);
#line 1787
  mutex_unlock(vdev->lock);
#line 1788
  return (ret);
}
}
#line 1791 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static unsigned int s2255_poll(struct file *file , struct poll_table_struct *wait ) 
{ 
  struct s2255_fh *fh ;
  struct s2255_dev *dev ;
  int rc ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 1794
  fh = (struct s2255_fh *)file->private_data;
#line 1795
  dev = fh->dev;
#line 1796
  tmp = v4l2_ctrl_poll(file, wait);
#line 1796
  rc = (int )tmp;
#line 1798
  if (*s2255_debug > 99) {
#line 1798
    printk("\017s2255: %s\n", "s2255_poll");
  } else {

  }
#line 1799
  if ((unsigned int )fh->type != 1U) {
#line 1800
    return (8U);
  } else {

  }
#line 1801
  mutex_lock_nested(& dev->lock, 0U);
#line 1802
  tmp___0 = videobuf_poll_stream(file, & fh->vb_vidq, wait);
#line 1802
  rc = (int )(tmp___0 | (unsigned int )rc);
#line 1803
  mutex_unlock(& dev->lock);
#line 1804
  return ((unsigned int )rc);
}
}
#line 1807 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static void s2255_destroy(struct s2255_dev *dev ) 
{ 


  {
#line 1810
  s2255_board_shutdown(dev);
#line 1812
  ldv_del_timer_6(& dev->timer);
#line 1813
  if ((unsigned long )(dev->fw_data)->fw_urb != (unsigned long )((struct urb *)0)) {
#line 1814
    usb_kill_urb((dev->fw_data)->fw_urb);
#line 1815
    ldv_usb_free_urb_7((dev->fw_data)->fw_urb);
#line 1816
    (dev->fw_data)->fw_urb = (struct urb *)0;
  } else {

  }
#line 1818
  release_firmware((dev->fw_data)->fw);
#line 1819
  kfree((void const   *)(dev->fw_data)->pfw_data);
#line 1820
  kfree((void const   *)dev->fw_data);
#line 1822
  s2255_reset_dsppower(dev);
#line 1823
  mutex_destroy(& dev->lock);
#line 1824
  ldv_usb_put_dev_8(dev->udev);
#line 1825
  v4l2_device_unregister(& dev->v4l2_dev);
#line 1826
  if (*s2255_debug > 0) {
#line 1826
    printk("\017s2255: %s", "s2255_destroy");
  } else {

  }
#line 1827
  kfree((void const   *)dev);
#line 1828
  return;
}
}
#line 1830 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int s2255_release(struct file *file ) 
{ 
  struct s2255_fh *fh ;
  struct s2255_dev *dev ;
  struct video_device *vdev ;
  struct video_device *tmp ;
  struct s2255_channel *channel ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 1832
  fh = (struct s2255_fh *)file->private_data;
#line 1833
  dev = fh->dev;
#line 1834
  tmp = video_devdata(file);
#line 1834
  vdev = tmp;
#line 1835
  channel = fh->channel;
#line 1836
  if ((unsigned long )dev == (unsigned long )((struct s2255_dev *)0)) {
#line 1837
    return (-19);
  } else {

  }
#line 1838
  mutex_lock_nested(& dev->lock, 0U);
#line 1840
  tmp___0 = res_check(fh);
#line 1840
  if (tmp___0 != 0) {
#line 1841
    if (channel->b_acquire != 0) {
#line 1842
      s2255_stop_acquire(fh->channel);
    } else {

    }
#line 1843
    videobuf_streamoff(& fh->vb_vidq);
#line 1844
    res_free(fh);
  } else {

  }
#line 1846
  videobuf_mmap_free(& fh->vb_vidq);
#line 1847
  mutex_unlock(& dev->lock);
#line 1848
  if (*s2255_debug > 0) {
#line 1848
    tmp___1 = video_device_node_name(vdev);
#line 1848
    printk("\017s2255: %s (dev=%s)\n", "s2255_release", tmp___1);
  } else {

  }
#line 1849
  v4l2_fh_del(& fh->fh);
#line 1850
  v4l2_fh_exit(& fh->fh);
#line 1851
  kfree((void const   *)fh);
#line 1852
  return (0);
}
}
#line 1855 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int s2255_mmap_v4l(struct file *file , struct vm_area_struct *vma ) 
{ 
  struct s2255_fh *fh ;
  struct s2255_dev *dev ;
  int ret ;
  int tmp ;

  {
#line 1857
  fh = (struct s2255_fh *)file->private_data;
#line 1861
  if ((unsigned long )fh == (unsigned long )((struct s2255_fh *)0)) {
#line 1862
    return (-19);
  } else {

  }
#line 1863
  dev = fh->dev;
#line 1864
  if (*s2255_debug > 3) {
#line 1864
    printk("\017s2255: %s, vma=0x%08lx\n", "s2255_mmap_v4l", (unsigned long )vma);
  } else {

  }
#line 1865
  tmp = mutex_lock_interruptible_nested(& dev->lock, 0U);
#line 1865
  if (tmp != 0) {
#line 1866
    return (-512);
  } else {

  }
#line 1867
  ret = videobuf_mmap_mapper(& fh->vb_vidq, vma);
#line 1868
  mutex_unlock(& dev->lock);
#line 1869
  if (*s2255_debug > 3) {
#line 1869
    printk("\017s2255: %s vma start=0x%08lx, size=%ld, ret=%d\n", "s2255_mmap_v4l",
           vma->vm_start, vma->vm_end - vma->vm_start, ret);
  } else {

  }
#line 1872
  return (ret);
}
}
#line 1875 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static struct v4l2_file_operations  const  s2255_fops_v4l  = 
#line 1875
     {& __this_module, 0, 0, & s2255_poll, 0, & video_ioctl2, 0, 0, & s2255_mmap_v4l,
    & s2255_open, & s2255_release};
#line 1884 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static struct v4l2_ioctl_ops  const  s2255_ioctl_ops  = 
#line 1884
     {& vidioc_querycap, 0, 0, & vidioc_enum_fmt_vid_cap, 0, 0, 0, 0, & vidioc_g_fmt_vid_cap,
    0, 0, 0, 0, 0, 0, 0, 0, 0, & vidioc_s_fmt_vid_cap, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    & vidioc_try_fmt_vid_cap, 0, 0, 0, 0, 0, 0, 0, 0, 0, & vidioc_reqbufs, & vidioc_querybuf,
    & vidioc_qbuf, 0, & vidioc_dqbuf, 0, 0, 0, 0, 0, & vidioc_streamon, & vidioc_streamoff,
    & vidioc_g_std, & vidioc_s_std, 0, & vidioc_enum_input, & vidioc_g_input, & vidioc_s_input,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & vidioc_g_jpegcomp,
    & vidioc_s_jpegcomp, 0, 0, 0, 0, 0, & vidioc_g_parm, & vidioc_s_parm, 0, 0, 0,
    0, 0, 0, & v4l2_ctrl_log_status, 0, 0, 0, 0, & vidioc_enum_framesizes, & vidioc_enum_frameintervals,
    0, 0, 0, 0, 0, & v4l2_ctrl_subscribe_event, & v4l2_event_unsubscribe, 0};
#line 1912 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static void s2255_video_device_release(struct video_device *vdev ) 
{ 
  struct s2255_dev *dev ;
  struct s2255_dev *tmp ;
  struct s2255_channel *channel ;
  struct video_device  const  *__mptr ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1914
  tmp = to_s2255_dev(vdev->v4l2_dev);
#line 1914
  dev = tmp;
#line 1916
  __mptr = (struct video_device  const  *)vdev;
#line 1916
  channel = (struct s2255_channel *)__mptr;
#line 1918
  v4l2_ctrl_handler_free(& channel->hdl);
#line 1919
  if (*s2255_debug > 3) {
#line 1919
    tmp___0 = atomic_read((atomic_t const   *)(& dev->num_channels));
#line 1919
    printk("\017s2255: %s, chnls: %d\n", "s2255_video_device_release", tmp___0);
  } else {

  }
#line 1922
  tmp___1 = atomic_dec_and_test(& dev->num_channels);
#line 1922
  if (tmp___1 != 0) {
#line 1923
    s2255_destroy(dev);
  } else {

  }
#line 1924
  return;
}
}
#line 1927 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static struct video_device template  = 
#line 1927
     {{{0, 0}, 0, 0U, 0, 0U, 0U, 0UL, 0U, (unsigned short)0, (unsigned short)0, (unsigned short)0,
     (unsigned short)0, 0, 0, 0, 0, 0, 0, {.alsa = {0U, 0U, 0U}}}, & s2255_fops_v4l,
    {0, 0, {0, {0, 0}, 0, 0, 0, 0, {{0}}, {{{0L}, {0, 0}, 0, {0, {0, 0}, 0, 0, 0UL}},
                                           {{0, 0}, 0UL, 0, 0, 0UL, 0, 0, 0, {(char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0},
                                            {0, {0, 0}, 0, 0, 0UL}}, 0, 0}, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
     0, 0, {{0}, {{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}, 0, 0, 0,
            {0, {0, 0}, 0, 0, 0UL}}, 0, 0, 0, {{0}, (unsigned char)0, (unsigned char)0,
                                               (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0,
                                               {{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0,
                                                                      0, 0UL}}}},
                                               {0, 0}, {0U, {{{{{{0U}}, 0U, 0U, 0,
                                                                {0, {0, 0}, 0, 0,
                                                                 0UL}}}}, {0, 0}}},
                                               0, (_Bool)0, (_Bool)0, {{0, 0}, 0UL,
                                                                       0, 0, 0UL,
                                                                       0, 0, 0, {(char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0},
                                                                       {0, {0, 0},
                                                                        0, 0, 0UL}},
                                               0UL, {{0L}, {0, 0}, 0, {0, {0, 0},
                                                                       0, 0, 0UL}},
                                               {{{{{{0U}}, 0U, 0U, 0, {0, {0, 0},
                                                                       0, 0, 0UL}}}},
                                                {0, 0}}, {0}, {0}, (unsigned char)0,
                                               (unsigned char)0, (unsigned char)0,
                                               (unsigned char)0, (unsigned char)0,
                                               (unsigned char)0, (unsigned char)0,
                                               (unsigned char)0, (unsigned char)0,
                                               (unsigned char)0, (unsigned char)0,
                                               0, 0, 0, 0, 0UL, 0UL, 0UL, 0UL, 0,
                                               0}, 0, 0, 0, 0ULL, 0, {0, 0}, 0, {0,
                                                                                 0},
     0, {0}, 0U, 0U, {{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}, {0,
                                                                               {0,
                                                                                0},
                                                                               {{0}}},
     0, 0, 0, 0, (_Bool)0, (_Bool)0}, 0, 0, 0, 0, 0, 0, {'s', '2', '2', '5', '5',
                                                         'v', '\000'}, 0, 0, 0, (unsigned short)0,
    0UL, 0, {{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}, 0, 16777215ULL,
    & s2255_video_device_release, & s2255_ioctl_ops, {0UL, 0UL, 0UL}, {0UL, 0UL, 0UL},
    0};
#line 1935 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static struct v4l2_ctrl_ops  const  s2255_ctrl_ops  =    {0, 0, & s2255_s_ctrl};
#line 1939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static struct v4l2_ctrl_config  const  color_filter_ctrl  = 
#line 1939
     {& s2255_ctrl_ops, 9967920U, "Color Filter", 2, 0, 1, 1U, 1, 0U, 0U, 0, 0, (unsigned char)0};
#line 1949 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int s2255_probe_v4l(struct s2255_dev *dev ) 
{ 
  int ret ;
  int i ;
  int cur_nr ;
  struct s2255_channel *channel ;
  struct lock_class_key _key ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1953
  cur_nr = video_nr;
#line 1955
  ret = v4l2_device_register(& (dev->interface)->dev, & dev->v4l2_dev);
#line 1956
  if (ret != 0) {
#line 1957
    return (ret);
  } else {

  }
#line 1960
  i = 0;
#line 1960
  goto ldv_33371;
  ldv_33370: 
#line 1961
  channel = (struct s2255_channel *)(& dev->channel) + (unsigned long )i;
#line 1962
  INIT_LIST_HEAD(& channel->vidq.active);
#line 1964
  v4l2_ctrl_handler_init_class(& channel->hdl, 6U, & _key, "s2255drv:1964:(&channel->hdl)->_lock");
#line 1965
  v4l2_ctrl_new_std(& channel->hdl, & s2255_ctrl_ops, 9963776U, -127, 127, 1U, 0);
#line 1967
  v4l2_ctrl_new_std(& channel->hdl, & s2255_ctrl_ops, 9963777U, 0, 255, 1U, 92);
#line 1969
  v4l2_ctrl_new_std(& channel->hdl, & s2255_ctrl_ops, 9963778U, 0, 255, 1U, 128);
#line 1971
  v4l2_ctrl_new_std(& channel->hdl, & s2255_ctrl_ops, 9963779U, 0, 255, 1U, 0);
#line 1973
  channel->jpegqual_ctrl = v4l2_ctrl_new_std(& channel->hdl, & s2255_ctrl_ops, 10291459U,
                                             0, 100, 1U, 50);
#line 1977
  if (dev->dsp_fw_ver > 7 && ((unsigned int )dev->pid != 8791U || channel->idx <= 1)) {
#line 1979
    v4l2_ctrl_new_custom(& channel->hdl, & color_filter_ctrl, (void *)0);
  } else {

  }
#line 1980
  if (channel->hdl.error != 0) {
#line 1981
    ret = channel->hdl.error;
#line 1982
    v4l2_ctrl_handler_free(& channel->hdl);
#line 1983
    dev_err((struct device  const  *)(& (dev->udev)->dev), "couldn\'t register control\n");
#line 1984
    goto ldv_33369;
  } else {

  }
#line 1986
  channel->vidq.dev = dev;
#line 1988
  channel->vdev = template;
#line 1989
  channel->vdev.ctrl_handler = & channel->hdl;
#line 1990
  channel->vdev.lock = & dev->lock;
#line 1991
  channel->vdev.v4l2_dev = & dev->v4l2_dev;
#line 1992
  set_bit(2L, (unsigned long volatile   *)(& channel->vdev.flags));
#line 1993
  video_set_drvdata(& channel->vdev, (void *)channel);
#line 1994
  if (video_nr == -1) {
#line 1995
    ret = video_register_device(& channel->vdev, 0, video_nr);
  } else {
#line 1999
    ret = video_register_device(& channel->vdev, 0, cur_nr + i);
  }
#line 2003
  if (ret != 0) {
#line 2004
    dev_err((struct device  const  *)(& (dev->udev)->dev), "failed to register video device!\n");
#line 2006
    goto ldv_33369;
  } else {

  }
#line 2008
  atomic_inc(& dev->num_channels);
#line 2009
  tmp = video_device_node_name(& channel->vdev);
#line 2009
  printk("\016%s: V4L2 device registered as %s\n", (char *)(& dev->v4l2_dev.name),
         tmp);
#line 1960
  i = i + 1;
  ldv_33371: ;
#line 1960
  if (i <= 3) {
#line 1962
    goto ldv_33370;
  } else {

  }
  ldv_33369: 
#line 2013
  printk("\016Sensoray 2255 V4L driver Revision: %s\n", (char *)"1.23.1");
#line 2016
  tmp___0 = atomic_read((atomic_t const   *)(& dev->num_channels));
#line 2016
  if (tmp___0 == 0) {
#line 2017
    v4l2_device_unregister(& dev->v4l2_dev);
#line 2018
    return (ret);
  } else {

  }
#line 2020
  tmp___1 = atomic_read((atomic_t const   *)(& dev->num_channels));
#line 2020
  if (tmp___1 != 4) {
#line 2021
    printk("\fs2255: Not all channels available.\n");
  } else {

  }
#line 2022
  return (0);
}
}
#line 2036 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int save_frame(struct s2255_dev *dev , struct s2255_pipeinfo *pipe_info ) 
{ 
  char *pdest ;
  u32 offset ;
  int bframe ;
  char *psrc ;
  unsigned long copy_size ;
  unsigned long size ;
  s32 idx ;
  struct s2255_framei *frm ;
  unsigned char *pdata ;
  struct s2255_channel *channel ;
  int jj ;
  unsigned int cc ;
  __le32 *pdword ;
  int payload ;
  size_t __len ;
  void *__ret ;

  {
#line 2039
  offset = 0U;
#line 2040
  bframe = 0;
#line 2044
  idx = -1;
#line 2048
  if (*s2255_debug > 99) {
#line 2048
    printk("\017s2255: buffer to user\n");
  } else {

  }
#line 2049
  channel = (struct s2255_channel *)(& dev->channel) + (unsigned long )dev->cc;
#line 2050
  idx = channel->cur_frame;
#line 2051
  frm = (struct s2255_framei *)(& channel->buffer.frame) + (unsigned long )idx;
#line 2052
  if (frm->ulState == 0UL) {
#line 2058
    pdata = pipe_info->transfer_buffer;
#line 2059
    pdword = (__le32 *)pdata;
#line 2060
    jj = 0;
#line 2060
    goto ldv_33401;
    ldv_33400: ;
#line 2061
    switch (*pdword) {
    case 576051786U: ;
#line 2063
    if (*s2255_debug > 3) {
#line 2063
      printk("\017s2255: found frame marker at offset: %d [%x %x]\n", jj, (int )*pdata,
             (int )*(pdata + 1UL));
    } else {

    }
#line 2066
    offset = (u32 )(jj + 512);
#line 2067
    bframe = 1;
#line 2068
    cc = *(pdword + 1UL);
#line 2069
    if (cc > 3U) {
#line 2070
      printk("\vbad channel\n");
#line 2072
      return (-22);
    } else {

    }
#line 2075
    dev->cc = (u32 )G_chnmap[cc];
#line 2076
    channel = (struct s2255_channel *)(& dev->channel) + (unsigned long )dev->cc;
#line 2077
    payload = (int )*(pdword + 3UL);
#line 2078
    if ((unsigned long )payload > channel->req_image_size) {
#line 2079
      channel->bad_payload = channel->bad_payload + 1;
#line 2081
      return (-22);
    } else {

    }
#line 2083
    channel->pkt_size = (unsigned long )payload;
#line 2084
    channel->jpg_size = (int )*(pdword + 4UL);
#line 2085
    goto ldv_33391;
    case 576040108U: 
#line 2088
    pdata = pdata + 16384UL;
#line 2089
    jj = jj + 16384;
#line 2090
    if (*(pdword + 1UL) > 3U) {
#line 2091
      goto ldv_33391;
    } else {

    }
#line 2092
    cc = (unsigned int )G_chnmap[*(pdword + 1UL)];
#line 2093
    if (cc > 3U) {
#line 2094
      goto ldv_33391;
    } else {

    }
#line 2095
    channel = (struct s2255_channel *)(& dev->channel) + (unsigned long )cc;
#line 2096
    switch (*(pdword + 2UL)) {
    case 1U: 
#line 2100
    channel->setmode_ready = 1;
#line 2101
    __wake_up(& channel->wait_setmode, 3U, 1, (void *)0);
#line 2102
    if (*s2255_debug > 4) {
#line 2102
      printk("\017s2255: setmode ready %d\n", cc);
    } else {

    }
#line 2103
    goto ldv_33394;
    case 16U: 
#line 2105
    dev->chn_ready = dev->chn_ready | (1 << (int )cc);
#line 2106
    if ((dev->chn_ready & 15) != 15) {
#line 2107
      goto ldv_33394;
    } else {

    }
#line 2109
    printk("\016s2255: fw loaded\n");
#line 2110
    atomic_set(& (dev->fw_data)->fw_state, 2);
#line 2112
    __wake_up(& (dev->fw_data)->wait_fw, 3U, 1, (void *)0);
#line 2113
    goto ldv_33394;
    case 32U: 
#line 2115
    channel->vidstatus = (int )*(pdword + 3UL);
#line 2116
    channel->vidstatus_ready = 1;
#line 2117
    __wake_up(& channel->wait_vidstatus, 3U, 1, (void *)0);
#line 2118
    if (*s2255_debug > 4) {
#line 2118
      printk("\017s2255: got vidstatus %x chan %d\n", *(pdword + 3UL), cc);
    } else {

    }
#line 2120
    goto ldv_33394;
    default: 
#line 2122
    printk("\016s2255 unknown resp\n");
    }
    ldv_33394: ;
    default: 
#line 2125
    pdata = pdata + 1;
#line 2126
    goto ldv_33391;
    }
    ldv_33391: ;
#line 2128
    if (bframe != 0) {
#line 2129
      goto ldv_33399;
    } else {

    }
#line 2060
    jj = jj + 1;
    ldv_33401: ;
#line 2060
    if ((u32 )jj < pipe_info->cur_transfer_size - 12U) {
#line 2062
      goto ldv_33400;
    } else {

    }
    ldv_33399: ;
#line 2131
    if (bframe == 0) {
#line 2132
      return (-22);
    } else {

    }
  } else {

  }
#line 2134
  channel = (struct s2255_channel *)(& dev->channel) + (unsigned long )dev->cc;
#line 2135
  idx = channel->cur_frame;
#line 2136
  frm = (struct s2255_framei *)(& channel->buffer.frame) + (unsigned long )idx;
#line 2138
  if (channel->b_acquire == 0) {
#line 2140
    frm->ulState = 0UL;
#line 2141
    return (-22);
  } else {

  }
#line 2144
  if (frm->ulState == 0UL) {
#line 2145
    frm->ulState = 1UL;
#line 2146
    frm->cur_size = 0UL;
  } else {

  }
#line 2150
  psrc = (char *)pipe_info->transfer_buffer + (unsigned long )offset;
#line 2153
  if ((unsigned long )frm->lpvbits == (unsigned long )((void *)0)) {
#line 2154
    if (*s2255_debug > 0) {
#line 2154
      printk("\017s2255: s2255 frame buffer == NULL.%p %p %d %d", frm, dev, dev->cc,
             idx);
    } else {

    }
#line 2156
    return (-12);
  } else {

  }
#line 2159
  pdest = (char *)(frm->lpvbits + frm->cur_size);
#line 2161
  copy_size = (unsigned long )(pipe_info->cur_transfer_size - offset);
#line 2163
  size = channel->pkt_size - 512UL;
#line 2166
  if (frm->cur_size + copy_size < channel->req_image_size) {
#line 2167
    __len = copy_size;
#line 2167
    __ret = __builtin_memcpy((void *)pdest, (void const   *)psrc, __len);
  } else {

  }
#line 2169
  frm->cur_size = frm->cur_size + copy_size;
#line 2170
  if (*s2255_debug > 3) {
#line 2170
    printk("\017s2255: cur_size size %lu size %lu \n", frm->cur_size, size);
  } else {

  }
#line 2172
  if (frm->cur_size >= size) {
#line 2173
    if (*s2255_debug > 1) {
#line 2173
      printk("\017s2255: ****************[%d]Buffer[%d]full*************\n", dev->cc,
             idx);
    } else {

    }
#line 2175
    channel->last_frame = channel->cur_frame;
#line 2176
    channel->cur_frame = channel->cur_frame + 1;
#line 2178
    if (channel->cur_frame == 4 || (unsigned long )channel->cur_frame == channel->buffer.dwFrames) {
#line 2180
      channel->cur_frame = 0;
    } else {

    }
#line 2182
    if (channel->b_acquire != 0) {
#line 2183
      s2255_got_frame(channel, channel->jpg_size);
    } else {

    }
#line 2184
    channel->frame_count = channel->frame_count + 1UL;
#line 2185
    frm->ulState = 0UL;
#line 2186
    frm->cur_size = 0UL;
  } else {

  }
#line 2190
  return (0);
}
}
#line 2193 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static void s2255_read_video_callback(struct s2255_dev *dev , struct s2255_pipeinfo *pipe_info ) 
{ 
  int res ;

  {
#line 2197
  if (*s2255_debug > 49) {
#line 2197
    printk("\017s2255: callback read video \n");
  } else {

  }
#line 2199
  if (dev->cc > 3U) {
#line 2200
    dev->cc = 0U;
#line 2201
    dev_err((struct device  const  *)(& (dev->udev)->dev), "invalid channel\n");
#line 2202
    return;
  } else {

  }
#line 2205
  res = save_frame(dev, pipe_info);
#line 2206
  if (res != 0) {
#line 2207
    if (*s2255_debug > 3) {
#line 2207
      printk("\017s2255: s2255: read callback failed\n");
    } else {

    }
  } else {

  }
#line 2209
  if (*s2255_debug > 49) {
#line 2209
    printk("\017s2255: callback read video done\n");
  } else {

  }
#line 2210
  return;
}
}
#line 2213 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static long s2255_vendor_req(struct s2255_dev *dev , unsigned char Request , u16 Index ,
                             u16 Value , void *TransferBuffer , s32 TransferBufferLength ,
                             int bOut ) 
{ 
  int r ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 2218
  if (bOut == 0) {
#line 2219
    tmp = __create_pipe(dev->udev, 0U);
#line 2219
    r = usb_control_msg(dev->udev, tmp | 2147483776U, (int )Request, 192, (int )Value,
                        (int )Index, TransferBuffer, (int )((__u16 )TransferBufferLength),
                        1250);
  } else {
#line 2226
    tmp___0 = __create_pipe(dev->udev, 0U);
#line 2226
    r = usb_control_msg(dev->udev, tmp___0 | 2147483648U, (int )Request, 64, (int )Value,
                        (int )Index, TransferBuffer, (int )((__u16 )TransferBufferLength),
                        1250);
  }
#line 2231
  return ((long )r);
}
}
#line 2239 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int s2255_get_fx2fw(struct s2255_dev *dev ) 
{ 
  int fw ;
  int ret ;
  unsigned char transBuffer[64U] ;
  long tmp ;

  {
#line 2244
  tmp = s2255_vendor_req(dev, 48, 0, 0, (void *)(& transBuffer), 2, 0);
#line 2244
  ret = (int )tmp;
#line 2246
  if (ret < 0) {
#line 2247
    if (*s2255_debug > 1) {
#line 2247
      printk("\017s2255: get fw error: %x\n", ret);
    } else {

    }
  } else {

  }
#line 2248
  fw = (int )transBuffer[0] + ((int )transBuffer[1] << 8);
#line 2249
  if (*s2255_debug > 1) {
#line 2249
    printk("\017s2255: Get FW %x %x\n", (int )transBuffer[0], (int )transBuffer[1]);
  } else {

  }
#line 2250
  return (fw);
}
}
#line 2257 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int s2255_create_sys_buffers(struct s2255_channel *channel ) 
{ 
  unsigned long i ;
  unsigned long reqsize ;

  {
#line 2261
  if (*s2255_debug > 0) {
#line 2261
    printk("\017s2255: create sys buffers\n");
  } else {

  }
#line 2262
  channel->buffer.dwFrames = 4UL;
#line 2264
  reqsize = 833536UL;
#line 2266
  if (reqsize > 833536UL) {
#line 2267
    reqsize = 833536UL;
  } else {

  }
#line 2269
  i = 0UL;
#line 2269
  goto ldv_33433;
  ldv_33432: 
#line 2271
  channel->buffer.frame[i].lpvbits = vmalloc(reqsize);
#line 2272
  if (*s2255_debug > 0) {
#line 2272
    printk("\017s2255: valloc %p chan %d, idx %lu, pdata %p\n", (struct s2255_framei *)(& channel->buffer.frame) + i,
           channel->idx, i, channel->buffer.frame[i].lpvbits);
  } else {

  }
#line 2275
  channel->buffer.frame[i].size = reqsize;
#line 2276
  if ((unsigned long )channel->buffer.frame[i].lpvbits == (unsigned long )((void *)0)) {
#line 2277
    printk("\016out of memory.  using less frames\n");
#line 2278
    channel->buffer.dwFrames = i;
#line 2279
    goto ldv_33431;
  } else {

  }
#line 2269
  i = i + 1UL;
  ldv_33433: ;
#line 2269
  if (i <= 3UL) {
#line 2271
    goto ldv_33432;
  } else {

  }
  ldv_33431: 
#line 2284
  i = 0UL;
#line 2284
  goto ldv_33435;
  ldv_33434: 
#line 2285
  channel->buffer.frame[i].ulState = 0UL;
#line 2286
  channel->buffer.frame[i].cur_size = 0UL;
#line 2284
  i = i + 1UL;
  ldv_33435: ;
#line 2284
  if (i <= 3UL) {
#line 2286
    goto ldv_33434;
  } else {

  }
#line 2289
  channel->cur_frame = 0;
#line 2290
  channel->last_frame = -1;
#line 2291
  return (0);
}
}
#line 2294 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int s2255_release_sys_buffers(struct s2255_channel *channel ) 
{ 
  unsigned long i ;

  {
#line 2297
  if (*s2255_debug > 0) {
#line 2297
    printk("\017s2255: release sys buffers\n");
  } else {

  }
#line 2298
  i = 0UL;
#line 2298
  goto ldv_33442;
  ldv_33441: ;
#line 2299
  if ((unsigned long )channel->buffer.frame[i].lpvbits != (unsigned long )((void *)0)) {
#line 2300
    if (*s2255_debug > 0) {
#line 2300
      printk("\017s2255: vfree %p\n", channel->buffer.frame[i].lpvbits);
    } else {

    }
#line 2302
    vfree((void const   *)channel->buffer.frame[i].lpvbits);
  } else {

  }
#line 2304
  channel->buffer.frame[i].lpvbits = (void *)0;
#line 2298
  i = i + 1UL;
  ldv_33442: ;
#line 2298
  if (i <= 3UL) {
#line 2300
    goto ldv_33441;
  } else {

  }

#line 2306
  return (0);
}
}
#line 2309 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int s2255_board_init(struct s2255_dev *dev ) 
{ 
  struct s2255_mode mode_def ;
  int fw_ver ;
  int j ;
  struct s2255_pipeinfo *pipe ;
  void *tmp ;
  struct s2255_channel *channel ;
  u32 tmp___0 ;

  {
#line 2311
  mode_def.format = 1U;
#line 2311
  mode_def.scale = 1U;
#line 2311
  mode_def.color = 1U;
#line 2311
  mode_def.fdec = 1U;
#line 2311
  mode_def.bright = 0U;
#line 2311
  mode_def.contrast = 92U;
#line 2311
  mode_def.saturation = 128U;
#line 2311
  mode_def.hue = 0U;
#line 2311
  mode_def.single = 0U;
#line 2311
  mode_def.usb_block = 16384U;
#line 2311
  mode_def.restart = 0U;
#line 2314
  pipe = & dev->pipe;
#line 2315
  if (*s2255_debug > 3) {
#line 2315
    printk("\017s2255: board init: %p", dev);
  } else {

  }
#line 2316
  memset((void *)pipe, 0, 48UL);
#line 2317
  pipe->dev = (void *)dev;
#line 2318
  pipe->cur_transfer_size = 16384U;
#line 2319
  pipe->max_transfer_size = 16384U;
#line 2321
  tmp = kzalloc((size_t )pipe->max_transfer_size, 208U);
#line 2321
  pipe->transfer_buffer = (u8 *)tmp;
#line 2323
  if ((unsigned long )pipe->transfer_buffer == (unsigned long )((u8 *)0U)) {
#line 2324
    if (*s2255_debug > 0) {
#line 2324
      printk("\017s2255: out of memory!\n");
    } else {

    }
#line 2325
    return (-12);
  } else {

  }
#line 2328
  fw_ver = s2255_get_fx2fw(dev);
#line 2330
  printk("\016s2255: usb firmware version %d.%d\n", (fw_ver >> 8) & 255, fw_ver & 255);
#line 2334
  if (fw_ver <= 779) {
#line 2335
    printk("\016s2255: newer USB firmware available\n");
  } else {

  }
#line 2337
  j = 0;
#line 2337
  goto ldv_33453;
  ldv_33452: 
#line 2338
  channel = (struct s2255_channel *)(& dev->channel) + (unsigned long )j;
#line 2339
  channel->b_acquire = 0;
#line 2340
  channel->mode = mode_def;
#line 2341
  if ((unsigned int )dev->pid == 8791U && j > 1) {
#line 2342
    channel->mode.color = channel->mode.color | 65536U;
  } else {

  }
#line 2343
  channel->jpegqual = 50U;
#line 2344
  channel->width = 640U;
#line 2345
  channel->height = 480U;
#line 2346
  channel->std = 4096ULL;
#line 2347
  channel->fmt = (struct s2255_fmt  const  *)(& formats);
#line 2348
  channel->mode.restart = 1U;
#line 2349
  tmp___0 = get_transfer_size(& mode_def);
#line 2349
  channel->req_image_size = (unsigned long )tmp___0;
#line 2350
  channel->frame_count = 0UL;
#line 2352
  s2255_create_sys_buffers(channel);
#line 2337
  j = j + 1;
  ldv_33453: ;
#line 2337
  if (j <= 3) {
#line 2339
    goto ldv_33452;
  } else {

  }
#line 2355
  s2255_start_readpipe(dev);
#line 2356
  if (*s2255_debug > 0) {
#line 2356
    printk("\017s2255: %s: success\n", "s2255_board_init");
  } else {

  }
#line 2357
  return (0);
}
}
#line 2360 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int s2255_board_shutdown(struct s2255_dev *dev ) 
{ 
  u32 i ;

  {
#line 2363
  if (*s2255_debug > 0) {
#line 2363
    printk("\017s2255: %s: dev: %p", "s2255_board_shutdown", dev);
  } else {

  }
#line 2365
  i = 0U;
#line 2365
  goto ldv_33462;
  ldv_33461: ;
#line 2366
  if (dev->channel[i].b_acquire != 0) {
#line 2367
    s2255_stop_acquire((struct s2255_channel *)(& dev->channel) + (unsigned long )i);
  } else {

  }
#line 2365
  i = i + 1U;
  ldv_33462: ;
#line 2365
  if (i <= 3U) {
#line 2367
    goto ldv_33461;
  } else {

  }
#line 2369
  s2255_stop_readpipe(dev);
#line 2370
  i = 0U;
#line 2370
  goto ldv_33465;
  ldv_33464: 
#line 2371
  s2255_release_sys_buffers((struct s2255_channel *)(& dev->channel) + (unsigned long )i);
#line 2370
  i = i + 1U;
  ldv_33465: ;
#line 2370
  if (i <= 3U) {
#line 2372
    goto ldv_33464;
  } else {

  }
#line 2373
  kfree((void const   *)dev->pipe.transfer_buffer);
#line 2374
  return (0);
}
}
#line 2377 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static void read_pipe_completion(struct urb *purb ) 
{ 
  struct s2255_pipeinfo *pipe_info ;
  struct s2255_dev *dev ;
  int status ;
  int pipe ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 2383
  pipe_info = (struct s2255_pipeinfo *)purb->context;
#line 2384
  if (*s2255_debug > 99) {
#line 2384
    printk("\017s2255: %s: urb:%p, status %d\n", "read_pipe_completion", purb, purb->status);
  } else {

  }
#line 2386
  if ((unsigned long )pipe_info == (unsigned long )((struct s2255_pipeinfo *)0)) {
#line 2387
    dev_err((struct device  const  *)(& (purb->dev)->dev), "no context!\n");
#line 2388
    return;
  } else {

  }
#line 2391
  dev = (struct s2255_dev *)pipe_info->dev;
#line 2392
  if ((unsigned long )dev == (unsigned long )((struct s2255_dev *)0)) {
#line 2393
    dev_err((struct device  const  *)(& (purb->dev)->dev), "no context!\n");
#line 2394
    return;
  } else {

  }
#line 2396
  status = purb->status;
#line 2398
  if (status == -108) {
#line 2399
    if (*s2255_debug > 1) {
#line 2399
      printk("\017s2255: %s: err shutdown\n", "read_pipe_completion");
    } else {

    }
#line 2400
    pipe_info->err_count = pipe_info->err_count + 1U;
#line 2401
    return;
  } else {

  }
#line 2404
  if (pipe_info->state == 0U) {
#line 2405
    if (*s2255_debug > 1) {
#line 2405
      printk("\017s2255: %s: exiting USB pipe", "read_pipe_completion");
    } else {

    }
#line 2406
    return;
  } else {

  }
#line 2409
  if (status == 0) {
#line 2410
    s2255_read_video_callback(dev, pipe_info);
  } else {
#line 2412
    pipe_info->err_count = pipe_info->err_count + 1U;
#line 2413
    if (*s2255_debug > 0) {
#line 2413
      printk("\017s2255: %s: failed URB %d\n", "read_pipe_completion", status);
    } else {

    }
  }
#line 2416
  tmp = __create_pipe(dev->udev, (unsigned int )dev->read_endpoint);
#line 2416
  pipe = (int )(tmp | 3221225600U);
#line 2418
  ldv_usb_fill_bulk_urb_4((struct urb *)pipe_info->stream_urb, dev->udev, (unsigned int )pipe,
                          (void *)pipe_info->transfer_buffer, (int )pipe_info->cur_transfer_size,
                          & read_pipe_completion, (void *)pipe_info);
#line 2424
  if (pipe_info->state != 0U) {
#line 2425
    tmp___0 = ldv_usb_submit_urb_10((struct urb *)pipe_info->stream_urb, 32U);
#line 2425
    if (tmp___0 != 0) {
#line 2426
      dev_err((struct device  const  *)(& (dev->udev)->dev), "error submitting urb\n");
    } else {

    }
  } else
#line 2429
  if (*s2255_debug > 1) {
#line 2429
    printk("\017s2255: %s :complete state 0\n", "read_pipe_completion");
  } else {

  }
#line 2431
  return;
}
}
#line 2434 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int s2255_start_readpipe(struct s2255_dev *dev ) 
{ 
  int pipe ;
  int retval ;
  struct s2255_pipeinfo *pipe_info ;
  unsigned int tmp ;
  struct urb *tmp___0 ;

  {
#line 2438
  pipe_info = & dev->pipe;
#line 2439
  tmp = __create_pipe(dev->udev, (unsigned int )dev->read_endpoint);
#line 2439
  pipe = (int )(tmp | 3221225600U);
#line 2440
  if (*s2255_debug > 1) {
#line 2440
    printk("\017s2255: %s: IN %d\n", "s2255_start_readpipe", (int )dev->read_endpoint);
  } else {

  }
#line 2441
  pipe_info->state = 1U;
#line 2442
  pipe_info->err_count = 0U;
#line 2443
  tmp___0 = ldv_usb_alloc_urb_11(0, 208U);
#line 2443
  pipe_info->stream_urb = (void *)tmp___0;
#line 2444
  if ((unsigned long )pipe_info->stream_urb == (unsigned long )((void *)0)) {
#line 2445
    dev_err((struct device  const  *)(& (dev->udev)->dev), "ReadStream: Unable to alloc URB\n");
#line 2447
    return (-12);
  } else {

  }
#line 2450
  ldv_usb_fill_bulk_urb_4((struct urb *)pipe_info->stream_urb, dev->udev, (unsigned int )pipe,
                          (void *)pipe_info->transfer_buffer, (int )pipe_info->cur_transfer_size,
                          & read_pipe_completion, (void *)pipe_info);
#line 2455
  retval = ldv_usb_submit_urb_13((struct urb *)pipe_info->stream_urb, 208U);
#line 2456
  if (retval != 0) {
#line 2457
    printk("\vs2255: start read pipe failed\n");
#line 2458
    return (retval);
  } else {

  }
#line 2460
  return (0);
}
}
#line 2464 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int s2255_start_acquire(struct s2255_channel *channel ) 
{ 
  unsigned char *buffer ;
  int res ;
  unsigned long chn_rev ;
  int j ;
  struct s2255_dev *dev ;
  struct s2255_dev *tmp ;
  void *tmp___0 ;

  {
#line 2470
  tmp = to_s2255_dev(channel->vdev.v4l2_dev);
#line 2470
  dev = tmp;
#line 2471
  chn_rev = G_chnmap[channel->idx];
#line 2472
  tmp___0 = kzalloc(512UL, 208U);
#line 2472
  buffer = (unsigned char *)tmp___0;
#line 2473
  if ((unsigned long )buffer == (unsigned long )((unsigned char *)0U)) {
#line 2474
    dev_err((struct device  const  *)(& (dev->udev)->dev), "out of mem\n");
#line 2475
    return (-12);
  } else {

  }
#line 2478
  channel->last_frame = -1;
#line 2479
  channel->bad_payload = 0;
#line 2480
  channel->cur_frame = 0;
#line 2481
  j = 0;
#line 2481
  goto ldv_33491;
  ldv_33490: 
#line 2482
  channel->buffer.frame[j].ulState = 0UL;
#line 2483
  channel->buffer.frame[j].cur_size = 0UL;
#line 2481
  j = j + 1;
  ldv_33491: ;
#line 2481
  if (j <= 3) {
#line 2483
    goto ldv_33490;
  } else {

  }
#line 2487
  *((__le32 *)buffer) = 576045278U;
#line 2488
  *((__le32 *)buffer + 1UL) = (unsigned int )chn_rev;
#line 2489
  *((__le32 *)buffer + 2UL) = 3257225248U;
#line 2490
  res = s2255_write_config(dev->udev, buffer, 512);
#line 2491
  if (res != 0) {
#line 2492
    dev_err((struct device  const  *)(& (dev->udev)->dev), "CMD_START error\n");
  } else {

  }
#line 2494
  if (*s2255_debug > 1) {
#line 2494
    printk("\017s2255: start acquire exit[%d] %d \n", channel->idx, res);
  } else {

  }
#line 2495
  kfree((void const   *)buffer);
#line 2496
  return (0);
}
}
#line 2499 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int s2255_stop_acquire(struct s2255_channel *channel ) 
{ 
  unsigned char *buffer ;
  int res ;
  unsigned long chn_rev ;
  struct s2255_dev *dev ;
  struct s2255_dev *tmp ;
  void *tmp___0 ;

  {
#line 2504
  tmp = to_s2255_dev(channel->vdev.v4l2_dev);
#line 2504
  dev = tmp;
#line 2505
  chn_rev = G_chnmap[channel->idx];
#line 2506
  tmp___0 = kzalloc(512UL, 208U);
#line 2506
  buffer = (unsigned char *)tmp___0;
#line 2507
  if ((unsigned long )buffer == (unsigned long )((unsigned char *)0U)) {
#line 2508
    dev_err((struct device  const  *)(& (dev->udev)->dev), "out of mem\n");
#line 2509
    return (-12);
  } else {

  }
#line 2512
  *((__le32 *)buffer) = 576045278U;
#line 2513
  *((__le32 *)buffer + 1UL) = (unsigned int )chn_rev;
#line 2514
  *((__le32 *)buffer + 2UL) = 3257225264U;
#line 2515
  res = s2255_write_config(dev->udev, buffer, 512);
#line 2516
  if (res != 0) {
#line 2517
    dev_err((struct device  const  *)(& (dev->udev)->dev), "CMD_STOP error\n");
  } else {

  }
#line 2518
  kfree((void const   *)buffer);
#line 2519
  channel->b_acquire = 0;
#line 2520
  if (*s2255_debug > 3) {
#line 2520
    printk("\017s2255: %s: chn %d, res %d\n", "s2255_stop_acquire", channel->idx,
           res);
  } else {

  }
#line 2521
  return (res);
}
}
#line 2524 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static void s2255_stop_readpipe(struct s2255_dev *dev ) 
{ 
  struct s2255_pipeinfo *pipe ;

  {
#line 2526
  pipe = & dev->pipe;
#line 2528
  pipe->state = 0U;
#line 2529
  if ((unsigned long )pipe->stream_urb != (unsigned long )((void *)0)) {
#line 2531
    usb_kill_urb((struct urb *)pipe->stream_urb);
#line 2532
    ldv_usb_free_urb_14((struct urb *)pipe->stream_urb);
#line 2533
    pipe->stream_urb = (void *)0;
  } else {

  }
#line 2535
  if (*s2255_debug > 3) {
#line 2535
    printk("\017s2255: %s", "s2255_stop_readpipe");
  } else {

  }
#line 2536
  return;
}
}
#line 2539 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static void s2255_fwload_start(struct s2255_dev *dev , int reset ) 
{ 
  size_t __len ;
  void *__ret ;
  unsigned int tmp ;

  {
#line 2541
  if (reset != 0) {
#line 2542
    s2255_reset_dsppower(dev);
  } else {

  }
#line 2543
  (dev->fw_data)->fw_size = (int )((dev->fw_data)->fw)->size;
#line 2544
  atomic_set(& (dev->fw_data)->fw_state, 0);
#line 2545
  __len = 512UL;
#line 2545
  if (__len > 63UL) {
#line 2545
    __ret = __memcpy((dev->fw_data)->pfw_data, (void const   *)((dev->fw_data)->fw)->data,
                     __len);
  } else {
#line 2545
    __ret = __builtin_memcpy((dev->fw_data)->pfw_data, (void const   *)((dev->fw_data)->fw)->data,
                             __len);
  }
#line 2547
  (dev->fw_data)->fw_loaded = 512;
#line 2548
  tmp = __create_pipe(dev->udev, 2U);
#line 2548
  ldv_usb_fill_bulk_urb_4((dev->fw_data)->fw_urb, dev->udev, tmp | 3221225472U, (dev->fw_data)->pfw_data,
                          512, & s2255_fwchunk_complete, (void *)dev->fw_data);
#line 2553
  ldv_mod_timer_16(& dev->timer, (unsigned long )jiffies + 250UL);
#line 2554
  return;
}
}
#line 2557 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int s2255_probe(struct usb_interface *interface , struct usb_device_id  const  *id ) 
{ 
  struct s2255_dev *dev ;
  struct usb_host_interface *iface_desc ;
  struct usb_endpoint_descriptor *endpoint ;
  int i ;
  int retval ;
  __le32 *pdata ;
  int fw_size ;
  void *tmp ;
  void *tmp___0 ;
  struct lock_class_key __key ;
  struct usb_device *tmp___1 ;
  int tmp___2 ;
  struct lock_class_key __key___0 ;
  struct s2255_channel *channel ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  int tmp___3 ;
  __le32 *pRel ;
  struct lock_class_key __key___3 ;

  {
#line 2560
  dev = (struct s2255_dev *)0;
#line 2564
  retval = -12;
#line 2567
  if (*s2255_debug > 1) {
#line 2567
    printk("\017s2255: %s\n", "s2255_probe");
  } else {

  }
#line 2569
  tmp = kzalloc(11208UL, 208U);
#line 2569
  dev = (struct s2255_dev *)tmp;
#line 2570
  if ((unsigned long )dev == (unsigned long )((struct s2255_dev *)0)) {
#line 2571
    dev_err((struct device  const  *)(& interface->dev), "s2255 - out of memory\n");
#line 2572
    return (-12);
  } else {

  }
#line 2574
  atomic_set(& dev->num_channels, 0);
#line 2575
  dev->pid = id->idProduct;
#line 2576
  tmp___0 = kzalloc(128UL, 208U);
#line 2576
  dev->fw_data = (struct s2255_fw *)tmp___0;
#line 2577
  if ((unsigned long )dev->fw_data == (unsigned long )((struct s2255_fw *)0)) {
#line 2578
    goto errorFWDATA1;
  } else {

  }
#line 2579
  __mutex_init(& dev->lock, "&dev->lock", & __key);
#line 2581
  tmp___1 = interface_to_usbdev(interface);
#line 2581
  dev->udev = ldv_usb_get_dev_17(tmp___1);
#line 2582
  if ((unsigned long )dev->udev == (unsigned long )((struct usb_device *)0)) {
#line 2583
    dev_err((struct device  const  *)(& interface->dev), "null usb device\n");
#line 2584
    retval = -19;
#line 2585
    goto errorUDEV;
  } else {

  }
#line 2587
  if (*s2255_debug > 0) {
#line 2587
    printk("\017s2255: dev: %p, udev %p interface %p\n", dev, dev->udev, interface);
  } else {

  }
#line 2589
  dev->interface = interface;
#line 2591
  iface_desc = interface->cur_altsetting;
#line 2592
  if (*s2255_debug > 0) {
#line 2592
    printk("\017s2255: num endpoints %d\n", (int )iface_desc->desc.bNumEndpoints);
  } else {

  }
#line 2593
  i = 0;
#line 2593
  goto ldv_33529;
  ldv_33528: 
#line 2594
  endpoint = & (iface_desc->endpoint + (unsigned long )i)->desc;
#line 2595
  if ((unsigned int )dev->read_endpoint == 0U) {
#line 2595
    tmp___2 = usb_endpoint_is_bulk_in((struct usb_endpoint_descriptor  const  *)endpoint);
#line 2595
    if (tmp___2 != 0) {
#line 2597
      dev->read_endpoint = endpoint->bEndpointAddress;
    } else {

    }
  } else {

  }
#line 2593
  i = i + 1;
  ldv_33529: ;
#line 2593
  if ((int )iface_desc->desc.bNumEndpoints > i) {
#line 2595
    goto ldv_33528;
  } else {

  }

#line 2601
  if ((unsigned int )dev->read_endpoint == 0U) {
#line 2602
    dev_err((struct device  const  *)(& interface->dev), "Could not find bulk-in endpoint\n");
#line 2603
    goto errorEP;
  } else {

  }
#line 2605
  reg_timer_1(& dev->timer);
#line 2606
  dev->timer.function = & s2255_timer;
#line 2607
  dev->timer.data = (unsigned long )dev->fw_data;
#line 2608
  __init_waitqueue_head(& (dev->fw_data)->wait_fw, "&dev->fw_data->wait_fw", & __key___0);
#line 2609
  i = 0;
#line 2609
  goto ldv_33537;
  ldv_33536: 
#line 2610
  channel = (struct s2255_channel *)(& dev->channel) + (unsigned long )i;
#line 2611
  dev->channel[i].idx = i;
#line 2612
  __init_waitqueue_head(& channel->wait_setmode, "&channel->wait_setmode", & __key___1);
#line 2613
  __init_waitqueue_head(& channel->wait_vidstatus, "&channel->wait_vidstatus", & __key___2);
#line 2609
  i = i + 1;
  ldv_33537: ;
#line 2609
  if (i <= 3) {
#line 2611
    goto ldv_33536;
  } else {

  }
#line 2616
  (dev->fw_data)->fw_urb = ldv_usb_alloc_urb_18(0, 208U);
#line 2617
  if ((unsigned long )(dev->fw_data)->fw_urb == (unsigned long )((struct urb *)0)) {
#line 2618
    dev_err((struct device  const  *)(& interface->dev), "out of memory!\n");
#line 2619
    goto errorFWURB;
  } else {

  }
#line 2622
  (dev->fw_data)->pfw_data = kzalloc(512UL, 208U);
#line 2623
  if ((unsigned long )(dev->fw_data)->pfw_data == (unsigned long )((void *)0)) {
#line 2624
    dev_err((struct device  const  *)(& interface->dev), "out of memory!\n");
#line 2625
    goto errorFWDATA2;
  } else {

  }
#line 2628
  tmp___3 = request_firmware(& (dev->fw_data)->fw, "f2255usb.bin", & (dev->udev)->dev);
#line 2628
  if (tmp___3 != 0) {
#line 2630
    printk("\vsensoray 2255 failed to get firmware\n");
#line 2631
    goto errorREQFW;
  } else {

  }
#line 2634
  fw_size = (int )((dev->fw_data)->fw)->size;
#line 2635
  pdata = (__le32 *)(((dev->fw_data)->fw)->data + ((unsigned long )fw_size + 0xfffffffffffffff8UL));
#line 2637
  if (*pdata != 576007983U) {
#line 2638
    printk("\016Firmware invalid.\n");
#line 2639
    retval = -19;
#line 2640
    goto errorFWMARKER;
  } else {
#line 2644
    pRel = (__le32 *)(((dev->fw_data)->fw)->data + ((unsigned long )fw_size + 0xfffffffffffffffcUL));
#line 2645
    printk("\016s2255 dsp fw version %x\n", *pRel);
#line 2646
    dev->dsp_fw_ver = (int )*pRel;
#line 2647
    if (dev->dsp_fw_ver <= 10103) {
#line 2648
      printk("\016s2255: f2255usb.bin out of date.\n");
    } else {

    }
#line 2649
    if ((unsigned int )dev->pid == 8791U && dev->dsp_fw_ver <= 7) {
#line 2651
      printk("\fs2255: 2257 requires firmware %d or above.\n", 8);
    } else {

    }
  }
#line 2654
  usb_reset_device(dev->udev);
#line 2656
  retval = s2255_board_init(dev);
#line 2657
  if (retval != 0) {
#line 2658
    goto errorBOARDINIT;
  } else {

  }
#line 2659
  spinlock_check(& dev->slock);
#line 2659
  __raw_spin_lock_init(& dev->slock.ldv_7686.rlock, "&(&dev->slock)->rlock", & __key___3);
#line 2660
  s2255_fwload_start(dev, 0);
#line 2662
  retval = s2255_probe_v4l(dev);
#line 2663
  if (retval != 0) {
#line 2664
    goto errorBOARDINIT;
  } else {

  }
#line 2665
  _dev_info((struct device  const  *)(& interface->dev), "Sensoray 2255 detected\n");
#line 2666
  return (0);
  errorBOARDINIT: 
#line 2668
  s2255_board_shutdown(dev);
  errorFWMARKER: 
#line 2670
  release_firmware((dev->fw_data)->fw);
  errorREQFW: 
#line 2672
  kfree((void const   *)(dev->fw_data)->pfw_data);
  errorFWDATA2: 
#line 2674
  ldv_usb_free_urb_19((dev->fw_data)->fw_urb);
  errorFWURB: 
#line 2676
  ldv_del_timer_20(& dev->timer);
  errorEP: 
#line 2678
  ldv_usb_put_dev_21(dev->udev);
  errorUDEV: 
#line 2680
  kfree((void const   *)dev->fw_data);
#line 2681
  mutex_destroy(& dev->lock);
  errorFWDATA1: 
#line 2683
  kfree((void const   *)dev);
#line 2684
  printk("\fSensoray 2255 driver load failed: 0x%x\n", retval);
#line 2685
  return (retval);
}
}
#line 2689 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static void s2255_disconnect(struct usb_interface *interface ) 
{ 
  struct s2255_dev *dev ;
  void *tmp ;
  struct s2255_dev *tmp___0 ;
  int i ;
  int channels ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2691
  tmp = usb_get_intfdata(interface);
#line 2691
  tmp___0 = to_s2255_dev((struct v4l2_device *)tmp);
#line 2691
  dev = tmp___0;
#line 2693
  tmp___1 = atomic_read((atomic_t const   *)(& dev->num_channels));
#line 2693
  channels = tmp___1;
#line 2694
  mutex_lock_nested(& dev->lock, 0U);
#line 2695
  v4l2_device_disconnect(& dev->v4l2_dev);
#line 2696
  mutex_unlock(& dev->lock);
#line 2698
  atomic_inc(& dev->num_channels);
#line 2700
  i = 0;
#line 2700
  goto ldv_33553;
  ldv_33552: 
#line 2701
  video_unregister_device(& dev->channel[i].vdev);
#line 2700
  i = i + 1;
  ldv_33553: ;
#line 2700
  if (i < channels) {
#line 2702
    goto ldv_33552;
  } else {

  }
#line 2703
  atomic_set(& (dev->fw_data)->fw_state, 4);
#line 2704
  __wake_up(& (dev->fw_data)->wait_fw, 3U, 1, (void *)0);
#line 2705
  i = 0;
#line 2705
  goto ldv_33556;
  ldv_33555: 
#line 2706
  dev->channel[i].setmode_ready = 1;
#line 2707
  __wake_up(& dev->channel[i].wait_setmode, 3U, 1, (void *)0);
#line 2708
  dev->channel[i].vidstatus_ready = 1;
#line 2709
  __wake_up(& dev->channel[i].wait_vidstatus, 3U, 1, (void *)0);
#line 2705
  i = i + 1;
  ldv_33556: ;
#line 2705
  if (i <= 3) {
#line 2707
    goto ldv_33555;
  } else {

  }
#line 2711
  tmp___2 = atomic_dec_and_test(& dev->num_channels);
#line 2711
  if (tmp___2 != 0) {
#line 2712
    s2255_destroy(dev);
  } else {

  }
#line 2713
  _dev_info((struct device  const  *)(& interface->dev), "%s\n", "s2255_disconnect");
#line 2714
  return;
}
}
#line 2716 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static struct usb_driver s2255_driver  = 
#line 2716
     {"s2255", & s2255_probe, & s2255_disconnect, 0, 0, 0, 0, 0, 0, (struct usb_device_id  const  *)(& s2255_table),
    {{{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}}, {{0, 0, 0, 0, (_Bool)0,
                                                                 0, 0, 0, 0, 0, 0,
                                                                 0, 0, 0, 0}, 0},
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0};
#line 2723 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static int s2255_driver_init(void) 
{ 
  int tmp ;

  {
#line 2723
  tmp = ldv_usb_register_driver_22(& s2255_driver, & __this_module, "s2255drv");
#line 2723
  return (tmp);
}
}
#line 2723 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
static void s2255_driver_exit(void) 
{ 


  {
#line 2723
  ldv_usb_deregister_23(& s2255_driver);
#line 2724
  return;
}
}
#line 2731 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int ldv_retval_0  ;
#line 2732
extern int ldv_probe_4(void) ;
#line 2733 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int ldv_retval_1  ;
#line 2734
extern void ldv_initialize(void) ;
#line 2735
void ldv_check_final_state(void) ;
#line 2736 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int ldv_retval_3  ;
#line 2737 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int ldv_retval_2  ;
#line 2741 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
void ldv_usb_driver_2(void) 
{ 
  void *tmp ;

  {
#line 2742
  tmp = ldv_zalloc(1520UL);
#line 2742
  s2255_driver_group1 = (struct usb_interface *)tmp;
#line 2743
  return;
}
}
#line 2746 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
void activate_pending_timer_1(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 2746
  if ((unsigned long )ldv_timer_list_1 == (unsigned long )timer) {
#line 2747
    if (ldv_timer_state_1 == 2 || pending_flag != 0) {
#line 2748
      ldv_timer_list_1 = timer;
#line 2749
      ldv_timer_list_1->data = data;
#line 2750
      ldv_timer_state_1 = 1;
    } else {

    }
#line 2752
    return;
  } else {

  }
#line 2754
  reg_timer_1(timer);
#line 2755
  ldv_timer_list_1->data = data;
#line 2756
  return;
}
}
#line 2759 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
void choose_timer_1(struct timer_list *timer ) 
{ 


  {
#line 2760
  LDV_IN_INTERRUPT = 2;
#line 2761
  (*(timer->function))(timer->data);
#line 2762
  LDV_IN_INTERRUPT = 1;
#line 2763
  ldv_timer_state_1 = 2;
#line 2764
  return;
}
}
#line 2767 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int reg_timer_1(struct timer_list *timer ) 
{ 


  {
#line 2768
  ldv_timer_list_1 = timer;
#line 2769
  ldv_timer_state_1 = 1;
#line 2770
  return (0);
}
}
#line 2773 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
void ldv_videobuf_queue_ops_7(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 2774
  tmp = ldv_zalloc(616UL);
#line 2774
  s2255_video_qops_group1 = (struct videobuf_queue *)tmp;
#line 2775
  tmp___0 = ldv_zalloc(240UL);
#line 2775
  s2255_video_qops_group2 = (struct videobuf_buffer *)tmp___0;
#line 2776
  return;
}
}
#line 2779 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
void ldv_initialize_v4l2_ioctl_ops_5(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 2780
  tmp = ldv_zalloc(360UL);
#line 2780
  s2255_ioctl_ops_group4 = (struct file *)tmp;
#line 2781
  tmp___0 = ldv_zalloc(208UL);
#line 2781
  s2255_ioctl_ops_group0 = (struct v4l2_format *)tmp___0;
#line 2782
  tmp___1 = ldv_zalloc(32UL);
#line 2782
  s2255_ioctl_ops_group1 = (struct v4l2_event_subscription *)tmp___1;
#line 2783
  tmp___2 = ldv_zalloc(88UL);
#line 2783
  s2255_ioctl_ops_group5 = (struct v4l2_buffer *)tmp___2;
#line 2784
  tmp___3 = ldv_zalloc(168UL);
#line 2784
  s2255_ioctl_ops_group2 = (struct v4l2_fh *)tmp___3;
#line 2785
  tmp___4 = ldv_zalloc(204UL);
#line 2785
  s2255_ioctl_ops_group3 = (struct v4l2_streamparm *)tmp___4;
#line 2786
  return;
}
}
#line 2788 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
void disable_suitable_timer_1(struct timer_list *timer ) 
{ 


  {
#line 2789
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_1) {
#line 2790
    ldv_timer_state_1 = 0;
#line 2791
    return;
  } else {

  }
#line 2793
  return;
}
}
#line 2796 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
void ldv_initialize_v4l2_file_operations_6(void) 
{ 
  void *tmp ;

  {
#line 2797
  tmp = ldv_zalloc(360UL);
#line 2797
  s2255_fops_v4l_group0 = (struct file *)tmp;
#line 2798
  return;
}
}
#line 2811 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
void main(void) 
{ 
  unsigned int ldvarg1 ;
  unsigned int tmp ;
  struct vm_area_struct *ldvarg3 ;
  void *tmp___0 ;
  unsigned long ldvarg0 ;
  unsigned long tmp___1 ;
  struct poll_table_struct *ldvarg2 ;
  void *tmp___2 ;
  struct v4l2_ctrl *ldvarg4 ;
  void *tmp___3 ;
  unsigned int *ldvarg7 ;
  void *tmp___4 ;
  enum v4l2_field ldvarg5 ;
  unsigned int *ldvarg6 ;
  void *tmp___5 ;
  struct usb_device_id *ldvarg8 ;
  void *tmp___6 ;
  struct video_device *ldvarg9 ;
  void *tmp___7 ;
  struct v4l2_jpegcompression *ldvarg18 ;
  void *tmp___8 ;
  void *ldvarg11 ;
  void *tmp___9 ;
  void *ldvarg32 ;
  void *tmp___10 ;
  void *ldvarg23 ;
  void *tmp___11 ;
  void *ldvarg43 ;
  void *tmp___12 ;
  v4l2_std_id ldvarg42 ;
  unsigned int ldvarg12 ;
  unsigned int tmp___13 ;
  void *ldvarg46 ;
  void *tmp___14 ;
  enum v4l2_buf_type ldvarg37 ;
  void *ldvarg29 ;
  void *tmp___15 ;
  void *ldvarg44 ;
  void *tmp___16 ;
  struct v4l2_jpegcompression *ldvarg24 ;
  void *tmp___17 ;
  struct v4l2_fmtdesc *ldvarg35 ;
  void *tmp___18 ;
  void *ldvarg38 ;
  void *tmp___19 ;
  void *ldvarg33 ;
  void *tmp___20 ;
  void *ldvarg16 ;
  void *tmp___21 ;
  void *ldvarg14 ;
  void *tmp___22 ;
  void *ldvarg34 ;
  void *tmp___23 ;
  struct v4l2_frmsizeenum *ldvarg28 ;
  void *tmp___24 ;
  void *ldvarg39 ;
  void *tmp___25 ;
  v4l2_std_id *ldvarg20 ;
  void *tmp___26 ;
  unsigned int *ldvarg31 ;
  void *tmp___27 ;
  void *ldvarg41 ;
  void *tmp___28 ;
  void *ldvarg13 ;
  void *tmp___29 ;
  enum v4l2_buf_type ldvarg10 ;
  void *ldvarg36 ;
  void *tmp___30 ;
  void *ldvarg40 ;
  void *tmp___31 ;
  struct v4l2_requestbuffers *ldvarg45 ;
  void *tmp___32 ;
  struct v4l2_capability *ldvarg26 ;
  void *tmp___33 ;
  void *ldvarg27 ;
  void *tmp___34 ;
  struct v4l2_input *ldvarg15 ;
  void *tmp___35 ;
  void *ldvarg30 ;
  void *tmp___36 ;
  void *ldvarg21 ;
  void *tmp___37 ;
  void *ldvarg25 ;
  void *tmp___38 ;
  void *ldvarg17 ;
  void *tmp___39 ;
  struct v4l2_frmivalenum *ldvarg22 ;
  void *tmp___40 ;
  void *ldvarg19 ;
  void *tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;

  {
#line 2814
  tmp = __VERIFIER_nondet_uint();
#line 2814
  ldvarg1 = tmp;
#line 2815
  tmp___0 = ldv_zalloc(184UL);
#line 2815
  ldvarg3 = (struct vm_area_struct *)tmp___0;
#line 2816
  tmp___1 = __VERIFIER_nondet_ulong();
#line 2816
  ldvarg0 = tmp___1;
#line 2817
  tmp___2 = ldv_zalloc(16UL);
#line 2817
  ldvarg2 = (struct poll_table_struct *)tmp___2;
#line 2818
  tmp___3 = ldv_zalloc(144UL);
#line 2818
  ldvarg4 = (struct v4l2_ctrl *)tmp___3;
#line 2819
  tmp___4 = ldv_zalloc(4UL);
#line 2819
  ldvarg7 = (unsigned int *)tmp___4;
#line 2821
  tmp___5 = ldv_zalloc(4UL);
#line 2821
  ldvarg6 = (unsigned int *)tmp___5;
#line 2822
  tmp___6 = ldv_zalloc(32UL);
#line 2822
  ldvarg8 = (struct usb_device_id *)tmp___6;
#line 2823
  tmp___7 = ldv_zalloc(1800UL);
#line 2823
  ldvarg9 = (struct video_device *)tmp___7;
#line 2824
  tmp___8 = ldv_zalloc(140UL);
#line 2824
  ldvarg18 = (struct v4l2_jpegcompression *)tmp___8;
#line 2825
  tmp___9 = ldv_zalloc(1UL);
#line 2825
  ldvarg11 = tmp___9;
#line 2826
  tmp___10 = ldv_zalloc(1UL);
#line 2826
  ldvarg32 = tmp___10;
#line 2827
  tmp___11 = ldv_zalloc(1UL);
#line 2827
  ldvarg23 = tmp___11;
#line 2828
  tmp___12 = ldv_zalloc(1UL);
#line 2828
  ldvarg43 = tmp___12;
#line 2830
  tmp___13 = __VERIFIER_nondet_uint();
#line 2830
  ldvarg12 = tmp___13;
#line 2831
  tmp___14 = ldv_zalloc(1UL);
#line 2831
  ldvarg46 = tmp___14;
#line 2833
  tmp___15 = ldv_zalloc(1UL);
#line 2833
  ldvarg29 = tmp___15;
#line 2834
  tmp___16 = ldv_zalloc(1UL);
#line 2834
  ldvarg44 = tmp___16;
#line 2835
  tmp___17 = ldv_zalloc(140UL);
#line 2835
  ldvarg24 = (struct v4l2_jpegcompression *)tmp___17;
#line 2836
  tmp___18 = ldv_zalloc(64UL);
#line 2836
  ldvarg35 = (struct v4l2_fmtdesc *)tmp___18;
#line 2837
  tmp___19 = ldv_zalloc(1UL);
#line 2837
  ldvarg38 = tmp___19;
#line 2838
  tmp___20 = ldv_zalloc(1UL);
#line 2838
  ldvarg33 = tmp___20;
#line 2839
  tmp___21 = ldv_zalloc(1UL);
#line 2839
  ldvarg16 = tmp___21;
#line 2840
  tmp___22 = ldv_zalloc(1UL);
#line 2840
  ldvarg14 = tmp___22;
#line 2841
  tmp___23 = ldv_zalloc(1UL);
#line 2841
  ldvarg34 = tmp___23;
#line 2842
  tmp___24 = ldv_zalloc(44UL);
#line 2842
  ldvarg28 = (struct v4l2_frmsizeenum *)tmp___24;
#line 2843
  tmp___25 = ldv_zalloc(1UL);
#line 2843
  ldvarg39 = tmp___25;
#line 2844
  tmp___26 = ldv_zalloc(8UL);
#line 2844
  ldvarg20 = (v4l2_std_id *)tmp___26;
#line 2845
  tmp___27 = ldv_zalloc(4UL);
#line 2845
  ldvarg31 = (unsigned int *)tmp___27;
#line 2846
  tmp___28 = ldv_zalloc(1UL);
#line 2846
  ldvarg41 = tmp___28;
#line 2847
  tmp___29 = ldv_zalloc(1UL);
#line 2847
  ldvarg13 = tmp___29;
#line 2849
  tmp___30 = ldv_zalloc(1UL);
#line 2849
  ldvarg36 = tmp___30;
#line 2850
  tmp___31 = ldv_zalloc(1UL);
#line 2850
  ldvarg40 = tmp___31;
#line 2851
  tmp___32 = ldv_zalloc(20UL);
#line 2851
  ldvarg45 = (struct v4l2_requestbuffers *)tmp___32;
#line 2852
  tmp___33 = ldv_zalloc(104UL);
#line 2852
  ldvarg26 = (struct v4l2_capability *)tmp___33;
#line 2853
  tmp___34 = ldv_zalloc(1UL);
#line 2853
  ldvarg27 = tmp___34;
#line 2854
  tmp___35 = ldv_zalloc(80UL);
#line 2854
  ldvarg15 = (struct v4l2_input *)tmp___35;
#line 2855
  tmp___36 = ldv_zalloc(1UL);
#line 2855
  ldvarg30 = tmp___36;
#line 2856
  tmp___37 = ldv_zalloc(1UL);
#line 2856
  ldvarg21 = tmp___37;
#line 2857
  tmp___38 = ldv_zalloc(1UL);
#line 2857
  ldvarg25 = tmp___38;
#line 2858
  tmp___39 = ldv_zalloc(1UL);
#line 2858
  ldvarg17 = tmp___39;
#line 2859
  tmp___40 = ldv_zalloc(52UL);
#line 2859
  ldvarg22 = (struct v4l2_frmivalenum *)tmp___40;
#line 2860
  tmp___41 = ldv_zalloc(1UL);
#line 2860
  ldvarg19 = tmp___41;
#line 2812
  ldv_initialize();
#line 2820
  memset((void *)(& ldvarg5), 0, 4UL);
#line 2829
  memset((void *)(& ldvarg42), 0, 8UL);
#line 2832
  memset((void *)(& ldvarg37), 0, 4UL);
#line 2848
  memset((void *)(& ldvarg10), 0, 4UL);
#line 2862
  ldv_state_variable_6 = 0;
#line 2863
  ldv_state_variable_3 = 0;
#line 2864
  ldv_state_variable_7 = 0;
#line 2865
  ldv_state_variable_2 = 0;
#line 2867
  ldv_state_variable_1 = 1;
#line 2868
  ldv_state_variable_4 = 0;
#line 2869
  ref_cnt = 0;
#line 2870
  ldv_state_variable_0 = 1;
#line 2871
  ldv_state_variable_5 = 0;
  ldv_33749: 
#line 2873
  tmp___42 = __VERIFIER_nondet_int();
#line 2873
  switch (tmp___42) {
  case 0: ;
#line 2877
  if (ldv_state_variable_6 != 0) {
#line 2878
    tmp___43 = __VERIFIER_nondet_int();
#line 2878
    switch (tmp___43) {
    case 0: ;
#line 2881
    if (ldv_state_variable_6 == 1) {
#line 2883
      s2255_mmap_v4l(s2255_fops_v4l_group0, ldvarg3);
#line 2885
      ldv_state_variable_6 = 1;
    } else {

    }
#line 2888
    if (ldv_state_variable_6 == 2) {
#line 2890
      s2255_mmap_v4l(s2255_fops_v4l_group0, ldvarg3);
#line 2892
      ldv_state_variable_6 = 2;
    } else {

    }
#line 2895
    goto ldv_33685;
    case 1: ;
#line 2898
    if (ldv_state_variable_6 == 2) {
#line 2900
      s2255_release(s2255_fops_v4l_group0);
#line 2902
      ldv_state_variable_6 = 1;
#line 2903
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 2906
    goto ldv_33685;
    case 2: ;
#line 2909
    if (ldv_state_variable_6 == 1) {
#line 2911
      s2255_poll(s2255_fops_v4l_group0, ldvarg2);
#line 2913
      ldv_state_variable_6 = 1;
    } else {

    }
#line 2916
    if (ldv_state_variable_6 == 2) {
#line 2918
      s2255_poll(s2255_fops_v4l_group0, ldvarg2);
#line 2920
      ldv_state_variable_6 = 2;
    } else {

    }
#line 2923
    goto ldv_33685;
    case 3: ;
#line 2926
    if (ldv_state_variable_6 == 1) {
#line 2928
      ldv_retval_0 = s2255_open(s2255_fops_v4l_group0);
#line 2930
      if (ldv_retval_0 == 0) {
#line 2931
        ldv_state_variable_6 = 2;
#line 2932
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 2936
    goto ldv_33685;
    case 4: ;
#line 2939
    if (ldv_state_variable_6 == 1) {
#line 2941
      video_ioctl2(s2255_fops_v4l_group0, ldvarg1, ldvarg0);
#line 2943
      ldv_state_variable_6 = 1;
    } else {

    }
#line 2946
    if (ldv_state_variable_6 == 2) {
#line 2948
      video_ioctl2(s2255_fops_v4l_group0, ldvarg1, ldvarg0);
#line 2950
      ldv_state_variable_6 = 2;
    } else {

    }
#line 2953
    goto ldv_33685;
    default: 
#line 2954
    ldv_stop();
    }
    ldv_33685: ;
  } else {

  }
#line 2958
  goto ldv_33691;
  case 1: ;
#line 2962
  if (ldv_state_variable_3 != 0) {
#line 2963
    tmp___44 = __VERIFIER_nondet_int();
#line 2963
    switch (tmp___44) {
    case 0: ;
#line 2966
    if (ldv_state_variable_3 == 1) {
#line 2968
      s2255_s_ctrl(ldvarg4);
#line 2970
      ldv_state_variable_3 = 1;
    } else {

    }
#line 2973
    goto ldv_33694;
    default: 
#line 2974
    ldv_stop();
    }
    ldv_33694: ;
  } else {

  }
#line 2978
  goto ldv_33691;
  case 2: ;
#line 2982
  if (ldv_state_variable_7 != 0) {
#line 2983
    tmp___45 = __VERIFIER_nondet_int();
#line 2983
    switch (tmp___45) {
    case 0: ;
#line 2986
    if (ldv_state_variable_7 == 1) {
#line 2988
      buffer_setup(s2255_video_qops_group1, ldvarg7, ldvarg6);
#line 2990
      ldv_state_variable_7 = 1;
    } else {

    }
#line 2993
    if (ldv_state_variable_7 == 2) {
#line 2995
      buffer_setup(s2255_video_qops_group1, ldvarg7, ldvarg6);
#line 2997
      ldv_state_variable_7 = 2;
    } else {

    }
#line 3000
    goto ldv_33698;
    case 1: ;
#line 3003
    if (ldv_state_variable_7 == 2) {
#line 3005
      buffer_release(s2255_video_qops_group1, s2255_video_qops_group2);
#line 3007
      ldv_state_variable_7 = 1;
#line 3008
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 3011
    goto ldv_33698;
    case 2: ;
#line 3014
    if (ldv_state_variable_7 == 1) {
#line 3016
      buffer_queue(s2255_video_qops_group1, s2255_video_qops_group2);
#line 3018
      ldv_state_variable_7 = 1;
    } else {

    }
#line 3021
    if (ldv_state_variable_7 == 2) {
#line 3023
      buffer_queue(s2255_video_qops_group1, s2255_video_qops_group2);
#line 3025
      ldv_state_variable_7 = 2;
    } else {

    }
#line 3028
    goto ldv_33698;
    case 3: ;
#line 3031
    if (ldv_state_variable_7 == 1) {
#line 3033
      ldv_retval_1 = buffer_prepare(s2255_video_qops_group1, s2255_video_qops_group2,
                                    ldvarg5);
#line 3035
      if (ldv_retval_1 == 0) {
#line 3036
        ldv_state_variable_7 = 2;
#line 3037
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 3041
    goto ldv_33698;
    default: 
#line 3042
    ldv_stop();
    }
    ldv_33698: ;
  } else {

  }
#line 3046
  goto ldv_33691;
  case 3: ;
#line 3050
  if (ldv_state_variable_2 != 0) {
#line 3051
    tmp___46 = __VERIFIER_nondet_int();
#line 3051
    switch (tmp___46) {
    case 0: ;
#line 3054
    if (ldv_state_variable_2 == 1) {
#line 3056
      ldv_retval_2 = s2255_probe(s2255_driver_group1, (struct usb_device_id  const  *)ldvarg8);
#line 3057
      if (ldv_retval_2 == 0) {
#line 3058
        ldv_state_variable_2 = 2;
#line 3059
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 3063
    goto ldv_33705;
    case 1: ;
#line 3066
    if (ldv_state_variable_2 == 2 && usb_counter == 0) {
#line 3068
      s2255_disconnect(s2255_driver_group1);
#line 3069
      ldv_state_variable_2 = 1;
#line 3070
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 3073
    goto ldv_33705;
    default: 
#line 3074
    ldv_stop();
    }
    ldv_33705: ;
  } else {

  }
#line 3078
  goto ldv_33691;
  case 4: ;
#line 3082
  if (ldv_state_variable_1 != 0) {
#line 3083
    choose_timer_1(ldv_timer_list_1);
  } else {

  }
#line 3086
  goto ldv_33691;
  case 5: ;
#line 3090
  if (ldv_state_variable_4 != 0) {
#line 3091
    tmp___47 = __VERIFIER_nondet_int();
#line 3091
    switch (tmp___47) {
    case 0: ;
#line 3094
    if (ldv_state_variable_4 == 2) {
#line 3096
      s2255_video_device_release(ldvarg9);
#line 3098
      ldv_state_variable_4 = 1;
#line 3099
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 3102
    goto ldv_33711;
    case 1: ;
#line 3105
    if (ldv_state_variable_4 == 1) {
#line 3107
      ldv_probe_4();
#line 3109
      ldv_state_variable_4 = 2;
#line 3110
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 3113
    goto ldv_33711;
    default: 
#line 3114
    ldv_stop();
    }
    ldv_33711: ;
  } else {

  }
#line 3118
  goto ldv_33691;
  case 6: ;
#line 3122
  if (ldv_state_variable_0 != 0) {
#line 3123
    tmp___48 = __VERIFIER_nondet_int();
#line 3123
    switch (tmp___48) {
    case 0: ;
#line 3126
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
#line 3128
      s2255_driver_exit();
#line 3129
      ldv_state_variable_0 = 2;
#line 3130
      goto ldv_final;
    } else {

    }
#line 3133
    goto ldv_33717;
    case 1: ;
#line 3136
    if (ldv_state_variable_0 == 1) {
#line 3138
      ldv_retval_3 = s2255_driver_init();
#line 3140
      if (ldv_retval_3 == 0) {
#line 3141
        ldv_state_variable_0 = 3;
#line 3142
        ldv_state_variable_5 = 1;
#line 3143
        ldv_initialize_v4l2_ioctl_ops_5();
#line 3144
        ldv_state_variable_7 = 1;
#line 3145
        ldv_videobuf_queue_ops_7();
#line 3146
        ldv_state_variable_3 = 1;
#line 3147
        ldv_state_variable_4 = 1;
#line 3148
        ldv_state_variable_6 = 1;
#line 3149
        ldv_initialize_v4l2_file_operations_6();
      } else {

      }
#line 3151
      if (ldv_retval_3 != 0) {
#line 3152
        ldv_state_variable_0 = 2;
#line 3153
        goto ldv_final;
      } else {

      }
    } else {

    }
#line 3157
    goto ldv_33717;
    default: 
#line 3158
    ldv_stop();
    }
    ldv_33717: ;
  } else {

  }
#line 3162
  goto ldv_33691;
  case 7: ;
#line 3166
  if (ldv_state_variable_5 != 0) {
#line 3167
    tmp___49 = __VERIFIER_nondet_int();
#line 3167
    switch (tmp___49) {
    case 0: ;
#line 3170
    if (ldv_state_variable_5 == 1) {
#line 3172
      vidioc_reqbufs(s2255_ioctl_ops_group4, ldvarg46, ldvarg45);
#line 3174
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3177
    goto ldv_33722;
    case 1: ;
#line 3180
    if (ldv_state_variable_5 == 1) {
#line 3182
      v4l2_event_unsubscribe(s2255_ioctl_ops_group2, (struct v4l2_event_subscription  const  *)s2255_ioctl_ops_group1);
#line 3184
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3187
    goto ldv_33722;
    case 2: ;
#line 3190
    if (ldv_state_variable_5 == 1) {
#line 3192
      vidioc_try_fmt_vid_cap(s2255_ioctl_ops_group4, ldvarg44, s2255_ioctl_ops_group0);
#line 3194
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3197
    goto ldv_33722;
    case 3: ;
#line 3200
    if (ldv_state_variable_5 == 1) {
#line 3202
      vidioc_s_std(s2255_ioctl_ops_group4, ldvarg43, ldvarg42);
#line 3204
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3207
    goto ldv_33722;
    case 4: ;
#line 3210
    if (ldv_state_variable_5 == 1) {
#line 3212
      v4l2_ctrl_log_status(s2255_ioctl_ops_group4, ldvarg41);
#line 3214
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3217
    goto ldv_33722;
    case 5: ;
#line 3220
    if (ldv_state_variable_5 == 1) {
#line 3222
      vidioc_querybuf(s2255_ioctl_ops_group4, ldvarg40, s2255_ioctl_ops_group5);
#line 3224
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3227
    goto ldv_33722;
    case 6: ;
#line 3230
    if (ldv_state_variable_5 == 1) {
#line 3232
      vidioc_dqbuf(s2255_ioctl_ops_group4, ldvarg39, s2255_ioctl_ops_group5);
#line 3234
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3237
    goto ldv_33722;
    case 7: ;
#line 3240
    if (ldv_state_variable_5 == 1) {
#line 3242
      vidioc_streamoff(s2255_ioctl_ops_group4, ldvarg38, ldvarg37);
#line 3244
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3247
    goto ldv_33722;
    case 8: ;
#line 3250
    if (ldv_state_variable_5 == 1) {
#line 3252
      vidioc_enum_fmt_vid_cap(s2255_ioctl_ops_group4, ldvarg36, ldvarg35);
#line 3254
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3257
    goto ldv_33722;
    case 9: ;
#line 3260
    if (ldv_state_variable_5 == 1) {
#line 3262
      vidioc_s_fmt_vid_cap(s2255_ioctl_ops_group4, ldvarg34, s2255_ioctl_ops_group0);
#line 3264
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3267
    goto ldv_33722;
    case 10: ;
#line 3270
    if (ldv_state_variable_5 == 1) {
#line 3272
      vidioc_g_fmt_vid_cap(s2255_ioctl_ops_group4, ldvarg33, s2255_ioctl_ops_group0);
#line 3274
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3277
    goto ldv_33722;
    case 11: ;
#line 3280
    if (ldv_state_variable_5 == 1) {
#line 3282
      vidioc_g_input(s2255_ioctl_ops_group4, ldvarg32, ldvarg31);
#line 3284
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3287
    goto ldv_33722;
    case 12: ;
#line 3290
    if (ldv_state_variable_5 == 1) {
#line 3292
      vidioc_qbuf(s2255_ioctl_ops_group4, ldvarg30, s2255_ioctl_ops_group5);
#line 3294
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3297
    goto ldv_33722;
    case 13: ;
#line 3300
    if (ldv_state_variable_5 == 1) {
#line 3302
      vidioc_enum_framesizes(s2255_ioctl_ops_group4, ldvarg29, ldvarg28);
#line 3304
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3307
    goto ldv_33722;
    case 14: ;
#line 3310
    if (ldv_state_variable_5 == 1) {
#line 3312
      vidioc_querycap(s2255_ioctl_ops_group4, ldvarg27, ldvarg26);
#line 3314
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3317
    goto ldv_33722;
    case 15: ;
#line 3320
    if (ldv_state_variable_5 == 1) {
#line 3322
      vidioc_s_jpegcomp(s2255_ioctl_ops_group4, ldvarg25, (struct v4l2_jpegcompression  const  *)ldvarg24);
#line 3324
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3327
    goto ldv_33722;
    case 16: ;
#line 3330
    if (ldv_state_variable_5 == 1) {
#line 3332
      vidioc_enum_frameintervals(s2255_ioctl_ops_group4, ldvarg23, ldvarg22);
#line 3334
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3337
    goto ldv_33722;
    case 17: ;
#line 3340
    if (ldv_state_variable_5 == 1) {
#line 3342
      vidioc_g_std(s2255_ioctl_ops_group4, ldvarg21, ldvarg20);
#line 3344
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3347
    goto ldv_33722;
    case 18: ;
#line 3350
    if (ldv_state_variable_5 == 1) {
#line 3352
      vidioc_g_jpegcomp(s2255_ioctl_ops_group4, ldvarg19, ldvarg18);
#line 3354
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3357
    goto ldv_33722;
    case 19: ;
#line 3360
    if (ldv_state_variable_5 == 1) {
#line 3362
      vidioc_g_parm(s2255_ioctl_ops_group4, ldvarg17, s2255_ioctl_ops_group3);
#line 3364
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3367
    goto ldv_33722;
    case 20: ;
#line 3370
    if (ldv_state_variable_5 == 1) {
#line 3372
      vidioc_enum_input(s2255_ioctl_ops_group4, ldvarg16, ldvarg15);
#line 3374
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3377
    goto ldv_33722;
    case 21: ;
#line 3380
    if (ldv_state_variable_5 == 1) {
#line 3382
      v4l2_ctrl_subscribe_event(s2255_ioctl_ops_group2, (struct v4l2_event_subscription  const  *)s2255_ioctl_ops_group1);
#line 3384
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3387
    goto ldv_33722;
    case 22: ;
#line 3390
    if (ldv_state_variable_5 == 1) {
#line 3392
      vidioc_s_parm(s2255_ioctl_ops_group4, ldvarg14, s2255_ioctl_ops_group3);
#line 3394
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3397
    goto ldv_33722;
    case 23: ;
#line 3400
    if (ldv_state_variable_5 == 1) {
#line 3402
      vidioc_s_input(s2255_ioctl_ops_group4, ldvarg13, ldvarg12);
#line 3404
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3407
    goto ldv_33722;
    case 24: ;
#line 3410
    if (ldv_state_variable_5 == 1) {
#line 3412
      vidioc_streamon(s2255_ioctl_ops_group4, ldvarg11, ldvarg10);
#line 3414
      ldv_state_variable_5 = 1;
    } else {

    }
#line 3417
    goto ldv_33722;
    default: 
#line 3418
    ldv_stop();
    }
    ldv_33722: ;
  } else {

  }
#line 3422
  goto ldv_33691;
  default: 
#line 3423
  ldv_stop();
  }
  ldv_33691: ;
#line 3425
  goto ldv_33749;
  ldv_final: 
#line 3427
  ldv_check_final_state();
#line 3428
  return;
}
}
#line 3431 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int ldv_del_timer_1(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;

  {
#line 3435
  tmp = del_timer(ldv_func_arg1);
#line 3435
  ldv_func_res = tmp;
#line 3437
  disable_suitable_timer_1(ldv_func_arg1);
#line 3439
  return (ldv_func_res);
}
}
#line 3442 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
__inline static struct usb_device *interface_to_usbdev(struct usb_interface *intf ) 
{ 
  struct usb_device *tmp ;

  {
#line 3445
  tmp = ldv_interface_to_usbdev();
#line 3445
  return (tmp);
}
}
#line 3448 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int ldv_usb_submit_urb_3(struct urb *ldv_func_arg1 , gfp_t ldv_func_arg2 ) 
{ 
  int tmp ;

  {
#line 3451
  tmp = ldv_submit_urb(ldv_func_arg1);
#line 3451
  return (tmp);
}
}
#line 3454 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
__inline static void ldv_usb_fill_bulk_urb_4(struct urb *urb , struct usb_device *dev ,
                                             unsigned int pipe , void *transfer_buffer ,
                                             int buffer_length , void (*complete_fn)(struct urb * ) ,
                                             void *context ) 
{ 


  {
#line 3457
  ldv_fill_bulk_urb(urb, complete_fn);
#line 3458
  return;
}
}
#line 3460 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int ldv_usb_submit_urb_5(struct urb *ldv_func_arg1 , gfp_t ldv_func_arg2 ) 
{ 
  int tmp ;

  {
#line 3463
  tmp = ldv_submit_urb(ldv_func_arg1);
#line 3463
  return (tmp);
}
}
#line 3466 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int ldv_del_timer_6(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
#line 3470
  tmp = del_timer(ldv_func_arg1);
#line 3470
  ldv_func_res = tmp;
#line 3472
  disable_suitable_timer_1(ldv_func_arg1);
#line 3474
  return (ldv_func_res);
}
}
#line 3477 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
void ldv_usb_free_urb_7(struct urb *urb ) 
{ 


  {
#line 3480
  ldv_free_urb(urb);
#line 3481
  return;
}
}
#line 3483 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
void ldv_usb_put_dev_8(struct usb_device *dev ) 
{ 


  {
#line 3486
  ldv_put_dev(dev);
#line 3487
  return;
}
}
#line 3495 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int ldv_usb_submit_urb_10(struct urb *ldv_func_arg1 , gfp_t ldv_func_arg2 ) 
{ 
  int tmp ;

  {
#line 3498
  tmp = ldv_submit_urb(ldv_func_arg1);
#line 3498
  return (tmp);
}
}
#line 3501 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct urb *ldv_usb_alloc_urb_11(int iso_packets , gfp_t mem_flags ) 
{ 
  struct urb *tmp ;

  {
#line 3504
  tmp = ldv_alloc_urb();
#line 3504
  return (tmp);
}
}
#line 3513 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int ldv_usb_submit_urb_13(struct urb *ldv_func_arg1 , gfp_t ldv_func_arg2 ) 
{ 
  int tmp ;

  {
#line 3516
  tmp = ldv_submit_urb(ldv_func_arg1);
#line 3516
  return (tmp);
}
}
#line 3519 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
void ldv_usb_free_urb_14(struct urb *urb ) 
{ 


  {
#line 3522
  ldv_free_urb(urb);
#line 3523
  return;
}
}
#line 3531 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int ldv_mod_timer_16(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  int tmp ;

  {
#line 3535
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3535
  ldv_func_res = tmp;
#line 3537
  activate_pending_timer_1(ldv_func_arg1, ldv_func_arg2, 1);
#line 3539
  return (ldv_func_res);
}
}
#line 3542 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct usb_device *ldv_usb_get_dev_17(struct usb_device *ldv_func_arg1 ) 
{ 
  struct usb_device *tmp ;

  {
#line 3545
  tmp = ldv_get_dev(ldv_func_arg1);
#line 3545
  return (tmp);
}
}
#line 3548 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
struct urb *ldv_usb_alloc_urb_18(int iso_packets , gfp_t mem_flags ) 
{ 
  struct urb *tmp ;

  {
#line 3551
  tmp = ldv_alloc_urb();
#line 3551
  return (tmp);
}
}
#line 3554 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
void ldv_usb_free_urb_19(struct urb *urb ) 
{ 


  {
#line 3557
  ldv_free_urb(urb);
#line 3558
  return;
}
}
#line 3560 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int ldv_del_timer_20(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
#line 3564
  tmp = del_timer(ldv_func_arg1);
#line 3564
  ldv_func_res = tmp;
#line 3566
  disable_suitable_timer_1(ldv_func_arg1);
#line 3568
  return (ldv_func_res);
}
}
#line 3571 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
void ldv_usb_put_dev_21(struct usb_device *dev ) 
{ 


  {
#line 3574
  ldv_put_dev(dev);
#line 3575
  return;
}
}
#line 3577 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
int ldv_usb_register_driver_22(struct usb_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                               char const   *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 3581
  tmp = usb_register_driver(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 3581
  ldv_func_res = tmp;
#line 3583
  ldv_state_variable_2 = 1;
#line 3584
  usb_counter = 0;
#line 3585
  ldv_usb_driver_2();
#line 3588
  return (ldv_func_res);
}
}
#line 3591 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/dscv/ri/144_2a/drivers/media/usb/s2255/s2255drv.o.c.prepared"
void ldv_usb_deregister_23(struct usb_driver *arg ) 
{ 


  {
#line 3594
  usb_deregister(arg);
#line 3596
  ldv_state_variable_2 = 0;
#line 3597
  return;
}
}
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_error___0(void)  __attribute__((__no_instrument_function__)) ;
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_error___0(void) 
{ 


  {
  ERROR: 
#line 14
  goto ERROR;
}
}
#line 22
__inline static void ldv_stop___0(void)  __attribute__((__no_instrument_function__)) ;
#line 22 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop___0(void) 
{ 


  {
  LDV_STOP: 
#line 23
  goto LDV_STOP;
}
}
#line 8 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
int INTERF_STATE  =    0;
#line 10 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
int SERIAL_STATE  =    0;
#line 13 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void *usb_intfdata  =    0;
#line 16 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
struct urb *usb_urb  =    0;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
struct usb_device *usb_dev  =    0;
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
int dev_counter  =    0;
#line 25 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
int completeFnIntCounter  =    0;
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
int completeFnBulkCounter  =    0;
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void (*completeFnInt)(struct urb * )  ;
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void (*completeFnBulk)(struct urb * )  ;
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void *ldv_usb_get_intfdata(void) 
{ 


  {
#line 39
  return (usb_intfdata);
}
}
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void ldv_usb_set_intfdata(void *data ) 
{ 


  {
#line 46
  usb_intfdata = data;
#line 47
  return;
}
}
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void ldv_usb_put_intf(void) 
{ 


  {
#line 53
  usb_intfdata = 0;
#line 54
  return;
}
}
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
struct urb *ldv_alloc_urb(void) 
{ 
  struct urb *value ;
  void *tmp ;
  int tmp___0 ;

  {
#line 60
  tmp = ldv_undef_ptr();
#line 60
  value = tmp;
#line 61
  tmp___0 = ldv_undef_int();
#line 61
  if (tmp___0) {
#line 63
    if ((unsigned long )value != (unsigned long )((struct urb *)0)) {
#line 66
      usb_urb = value;
    } else {

    }
  } else {

  }
#line 69
  return (usb_urb);
}
}
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void ldv_free_urb(struct urb *urb ) 
{ 


  {
#line 75
  if ((unsigned long )usb_urb == (unsigned long )urb && (unsigned long )usb_urb != (unsigned long )((struct urb *)0)) {
#line 78
    usb_urb = 0;
  } else {

  }
#line 80
  return;
}
}
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void ldv_fill_int_urb(struct urb *urb , void (*complete_fn)(struct urb * ) ) 
{ 


  {
#line 84
  if ((unsigned long )usb_urb == (unsigned long )urb) {
#line 89
    completeFnInt = complete_fn;
#line 91
    completeFnIntCounter = completeFnIntCounter + 1;
  } else {

  }
#line 94
  return;
}
}
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void ldv_fill_bulk_urb(struct urb *urb , void (*complete_fn)(struct urb * ) ) 
{ 


  {
#line 99
  if ((unsigned long )usb_urb == (unsigned long )urb) {
#line 104
    completeFnBulk = complete_fn;
#line 106
    completeFnBulkCounter = completeFnBulkCounter + 1;
  } else {

  }
#line 109
  return;
}
}
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
int ldv_submit_urb(struct urb *urb ) 
{ 
  int res ;
  int tmp ;

  {
#line 115
  tmp = ldv_undef_int();
#line 115
  res = tmp;
#line 117
  if (res <= 0) {

  } else {
#line 117
    ldv_stop___0();
  }
#line 118
  if (res == 0) {
#line 120
    if ((unsigned long )usb_urb == (unsigned long )urb) {
#line 122
      if (completeFnIntCounter != 0) {
#line 125
        (*completeFnInt)(usb_urb);
#line 127
        completeFnIntCounter = 0;
      } else {

      }
#line 129
      if (completeFnBulkCounter != 0) {
#line 132
        (*completeFnBulk)(usb_urb);
#line 134
        completeFnBulkCounter = 0;
      } else {

      }
    } else {

    }
  } else {

  }
#line 138
  return (res);
}
}
#line 142 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
struct usb_device *ldv_interface_to_usbdev(void) 
{ 
  void *result ;
  void *tmp ;

  {
#line 145
  tmp = ldv_undef_ptr();
#line 145
  result = tmp;
#line 147
  if ((unsigned long )result != (unsigned long )((void *)0)) {

  } else {
#line 147
    ldv_stop___0();
  }
#line 148
  return (result);
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
struct usb_device *ldv_get_dev(struct usb_device *data ) 
{ 
  int tmp ;

  {
#line 154
  if ((unsigned long )usb_dev == (unsigned long )((struct usb_device *)0)) {
#line 156
    tmp = ldv_undef_int();
#line 156
    if (tmp) {
#line 159
      dev_counter = dev_counter + 1;
#line 161
      usb_dev = data;
    } else {

    }
  } else
#line 166
  if ((unsigned long )usb_dev == (unsigned long )data) {
#line 169
    dev_counter = dev_counter + 1;
  } else {

  }
#line 173
  return (usb_dev);
}
}
#line 177 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void ldv_put_dev(struct usb_device *data ) 
{ 


  {
#line 179
  if ((unsigned long )usb_dev == (unsigned long )data && (unsigned long )data != (unsigned long )((struct usb_device *)0)) {
#line 182
    dev_counter = dev_counter - 1;
#line 183
    if (dev_counter == 0) {
#line 186
      usb_dev = 0;
    } else {

    }
  } else {

  }
#line 189
  return;
}
}
#line 192 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
int ldv_get_interface(struct usb_interface *intf ) 
{ 
  int res ;
  int tmp ;

  {
#line 195
  tmp = ldv_undef_int();
#line 195
  res = tmp;
#line 197
  if (res <= 0) {

  } else {
#line 197
    ldv_stop___0();
  }
#line 198
  if (res == 0) {
#line 201
    INTERF_STATE = INTERF_STATE + 1;
  } else {

  }
#line 203
  return (res);
}
}
#line 207 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void ldv_put_interface(void) 
{ 


  {
#line 210
  if (INTERF_STATE > 0) {

  } else {
#line 210
    ldv_error___0();
  }
#line 212
  INTERF_STATE = INTERF_STATE - 1;
#line 213
  return;
}
}
#line 216 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
int ldv_serial_register(void) 
{ 
  int res ;
  int tmp ;

  {
#line 219
  tmp = ldv_undef_int();
#line 219
  res = tmp;
#line 221
  if (res <= 0) {

  } else {
#line 221
    ldv_stop___0();
  }
#line 222
  if (res == 0) {
#line 225
    SERIAL_STATE = SERIAL_STATE + 1;
  } else {

  }
#line 227
  return (res);
}
}
#line 231 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void ldv_serial_deregister(void) 
{ 


  {
#line 234
  if (SERIAL_STATE > 0) {

  } else {
#line 234
    ldv_error___0();
  }
#line 236
  SERIAL_STATE = SERIAL_STATE - 1;
#line 237
  return;
}
}
#line 240 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.12-rc1.tar.xz--X--144_2a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/2067/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 243
  if ((unsigned long )usb_urb == (unsigned long )((struct urb *)0)) {

  } else {
#line 243
    ldv_error___0();
  }
#line 245
  if ((unsigned long )usb_dev == (unsigned long )((struct usb_device *)0)) {

  } else {
#line 245
    ldv_error___0();
  }
#line 247
  if (dev_counter == 0) {

  } else {
#line 247
    ldv_error___0();
  }
#line 249
  if (INTERF_STATE == 0) {

  } else {
#line 249
    ldv_error___0();
  }
#line 251
  if (SERIAL_STATE == 0) {

  } else {
#line 251
    ldv_error___0();
  }
#line 252
  return;
}
}
