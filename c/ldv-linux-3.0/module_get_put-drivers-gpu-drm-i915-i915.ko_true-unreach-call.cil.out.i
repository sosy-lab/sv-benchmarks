extern void __VERIFIER_error() __attribute__ ((__noreturn__));
typedef signed char __s8;
typedef unsigned char __u8;
typedef short __s16;
typedef unsigned short __u16;
typedef int __s32;
typedef unsigned int __u32;
typedef long long __s64;
typedef unsigned long long __u64;
typedef unsigned char u8;
typedef unsigned short u16;
typedef int s32;
typedef unsigned int u32;
typedef long long s64;
typedef unsigned long long u64;
typedef unsigned short umode_t;
typedef unsigned int __kernel_mode_t;
typedef unsigned long __kernel_nlink_t;
typedef long __kernel_off_t;
typedef int __kernel_pid_t;
typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;
typedef unsigned long __kernel_size_t;
typedef long __kernel_ssize_t;
typedef long __kernel_time_t;
typedef long __kernel_suseconds_t;
typedef long __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef long long __kernel_loff_t;
typedef __kernel_uid_t __kernel_uid32_t;
typedef __kernel_gid_t __kernel_gid32_t;
typedef __u32 __kernel_dev_t;
typedef __kernel_dev_t dev_t;
typedef __kernel_mode_t mode_t;
typedef __kernel_nlink_t nlink_t;
typedef __kernel_off_t off_t;
typedef __kernel_pid_t pid_t;
typedef __kernel_clockid_t clockid_t;
typedef _Bool bool;
typedef __kernel_uid32_t uid_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_loff_t loff_t;
typedef __kernel_size_t size_t;
typedef __kernel_ssize_t ssize_t;
typedef __kernel_time_t time_t;
typedef __s32 int32_t;
typedef __u8 uint8_t;
typedef __u16 uint16_t;
typedef __u32 uint32_t;
typedef __u64 uint64_t;
typedef unsigned long sector_t;
typedef unsigned long blkcnt_t;
typedef u64 dma_addr_t;
typedef unsigned int gfp_t;
typedef unsigned int fmode_t;
typedef u64 phys_addr_t;
typedef phys_addr_t resource_size_t;
struct __anonstruct_atomic_t_6 {
   int counter ;
};
typedef struct __anonstruct_atomic_t_6 atomic_t;
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct hlist_node;
struct hlist_head {
   struct hlist_node *first ;
};
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
struct module;
typedef void (*ctor_fn_t)(void);
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
struct completion;
struct pt_regs;
struct pid;
struct timespec;
struct compat_timespec;
struct __anonstruct_futex_9 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
struct __anonstruct_nanosleep_10 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
struct pollfd;
struct __anonstruct_poll_11 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
union __anonunion_ldv_2052_8 {
   struct __anonstruct_futex_9 futex ;
   struct __anonstruct_nanosleep_10 nanosleep ;
   struct __anonstruct_poll_11 poll ;
};
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion_ldv_2052_8 ldv_2052 ;
};
struct page;
struct task_struct;
struct exec_domain;
struct mm_struct;
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
union __anonunion_ldv_2292_12 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_ldv_2292_12 ldv_2292 ;
};
typedef unsigned long pgdval_t;
typedef unsigned long pgprotval_t;
struct pgprot {
   pgprotval_t pgprot ;
};
typedef struct pgprot pgprot_t;
struct __anonstruct_pgd_t_15 {
   pgdval_t pgd ;
};
typedef struct __anonstruct_pgd_t_15 pgd_t;
typedef struct page *pgtable_t;
struct file;
struct seq_file;
struct __anonstruct_ldv_2526_19 {
   unsigned int a ;
   unsigned int b ;
};
struct __anonstruct_ldv_2541_20 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
union __anonunion_ldv_2542_18 {
   struct __anonstruct_ldv_2526_19 ldv_2526 ;
   struct __anonstruct_ldv_2541_20 ldv_2541 ;
};
struct desc_struct {
   union __anonunion_ldv_2542_18 ldv_2542 ;
};
struct thread_struct;
struct cpumask;
struct arch_spinlock;
struct cpumask {
   unsigned long bits[64U] ;
};
typedef struct cpumask cpumask_t;
typedef struct cpumask *cpumask_var_t;
struct map_segment;
struct exec_domain {
   char const *name ;
   void (*handler)(int , struct pt_regs * ) ;
   unsigned char pers_low ;
   unsigned char pers_high ;
   unsigned long *signal_map ;
   unsigned long *signal_invmap ;
   struct map_segment *err_map ;
   struct map_segment *socktype_map ;
   struct map_segment *sockopt_map ;
   struct map_segment *af_map ;
   struct module *module ;
   struct exec_domain *next ;
};
struct seq_operations;
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
struct __anonstruct_ldv_5171_24 {
   u64 rip ;
   u64 rdp ;
};
struct __anonstruct_ldv_5177_25 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
union __anonunion_ldv_5178_23 {
   struct __anonstruct_ldv_5171_24 ldv_5171 ;
   struct __anonstruct_ldv_5177_25 ldv_5177 ;
};
union __anonunion_ldv_5187_26 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_ldv_5178_23 ldv_5178 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_ldv_5187_26 ldv_5187 ;
};
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
};
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
struct fpu {
   union thread_xstate *state ;
};
struct kmem_cache;
struct perf_event;
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_no ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
struct __anonstruct_mm_segment_t_28 {
   unsigned long seg ;
};
typedef struct __anonstruct_mm_segment_t_28 mm_segment_t;
typedef atomic64_t atomic_long_t;
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   void *sysenter_return ;
   int uaccess_err ;
};
struct arch_spinlock {
   unsigned int slock ;
};
typedef struct arch_spinlock arch_spinlock_t;
struct __anonstruct_arch_rwlock_t_29 {
   unsigned int lock ;
};
typedef struct __anonstruct_arch_rwlock_t_29 arch_rwlock_t;
struct lockdep_map;
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
struct lockdep_subclass_key {
   char __one_byte ;
};
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const *name ;
   int cpu ;
   unsigned long ip ;
};
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 2 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 11 ;
};
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
typedef struct raw_spinlock raw_spinlock_t;
struct __anonstruct_ldv_6059_31 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
union __anonunion_ldv_6060_30 {
   struct raw_spinlock rlock ;
   struct __anonstruct_ldv_6059_31 ldv_6059 ;
};
struct spinlock {
   union __anonunion_ldv_6060_30 ldv_6060 ;
};
typedef struct spinlock spinlock_t;
struct __anonstruct_rwlock_t_32 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
typedef struct __anonstruct_rwlock_t_32 rwlock_t;
struct seqcount {
   unsigned int sequence ;
};
typedef struct seqcount seqcount_t;
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   uid_t uid ;
   gid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
typedef struct __wait_queue_head wait_queue_head_t;
struct __anonstruct_nodemask_t_34 {
   unsigned long bits[16U] ;
};
typedef struct __anonstruct_nodemask_t_34 nodemask_t;
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
struct rw_semaphore;
struct rw_semaphore {
   long count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct lockdep_map dep_map ;
};
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
struct pci_dev;
struct device;
typedef unsigned long long cycles_t;
union ktime {
   s64 tv64 ;
};
typedef union ktime ktime_t;
struct tvec_base;
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
struct hrtimer;
enum hrtimer_restart;
enum hrtimer_restart;
struct workqueue_struct;
struct work_struct;
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
};
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
struct pm_message {
   int event ;
};
typedef struct pm_message pm_message_t;
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
struct wakeup_source;
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char ignore_children : 1 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   void *subsys_data ;
};
struct dev_power_domain {
   struct dev_pm_ops ops ;
};
struct pci_bus;
struct __anonstruct_mm_context_t_99 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
typedef struct __anonstruct_mm_context_t_99 mm_context_t;
struct vm_area_struct;
struct rcu_head {
   struct rcu_head *next ;
   void (*func)(struct rcu_head * ) ;
};
struct nsproxy;
struct cred;
typedef __u64 Elf64_Addr;
typedef __u16 Elf64_Half;
typedef __u32 Elf64_Word;
typedef __u64 Elf64_Xword;
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
typedef struct elf64_sym Elf64_Sym;
struct sock;
struct kobject;
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   void *(*grab_current_ns)(void) ;
   void const *(*netlink_ns)(struct sock * ) ;
   void const *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
struct attribute {
   char const *name ;
   mode_t mode ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
struct attribute_group {
   char const *name ;
   mode_t (*is_visible)(struct kobject * , struct attribute * , int ) ;
   struct attribute **attrs ;
};
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t , size_t ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t , size_t ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const * , size_t ) ;
};
struct sysfs_dirent;
struct kref {
   atomic_t refcount ;
};
struct kset;
struct kobj_type;
struct kobject {
   char const *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops const *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations const *(*child_ns_type)(struct kobject * ) ;
   void const *(*namespace)(struct kobject * ) ;
};
struct kobj_uevent_env {
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
struct kset_uevent_ops {
   int (* const filter)(struct kset * , struct kobject * ) ;
   char const *(* const name)(struct kset * , struct kobject * ) ;
   int (* const uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops const *uevent_ops ;
};
struct kernel_param;
struct kernel_param_ops {
   int (*set)(char const * , struct kernel_param const * ) ;
   int (*get)(char * , struct kernel_param const * ) ;
   void (*free)(void * ) ;
};
struct kparam_string;
struct kparam_array;
union __anonunion_ldv_12924_129 {
   void *arg ;
   struct kparam_string const *str ;
   struct kparam_array const *arr ;
};
struct kernel_param {
   char const *name ;
   struct kernel_param_ops const *ops ;
   u16 perm ;
   u16 flags ;
   union __anonunion_ldv_12924_129 ldv_12924 ;
};
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops const *ops ;
   void *elem ;
};
struct jump_label_key {
   atomic_t enabled ;
};
struct tracepoint;
struct tracepoint_func {
   void *func ;
   void *data ;
};
struct tracepoint {
   char const *name ;
   struct jump_label_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
struct mod_arch_specific {
};
struct kernel_symbol {
   unsigned long value ;
   char const *name ;
};
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module * , char const * ,
                    size_t ) ;
   void (*setup)(struct module * , char const * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
struct module_param_attrs;
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
struct exception_table_entry;
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
struct module_ref {
   unsigned int incs ;
   unsigned int decs ;
};
struct module_sect_attrs;
struct module_notes_attrs;
struct ftrace_event_call;
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const *version ;
   char const *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol const *syms ;
   unsigned long const *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol const *gpl_syms ;
   unsigned long const *gpl_crcs ;
   struct kernel_symbol const *unused_syms ;
   unsigned long const *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol const *unused_gpl_syms ;
   unsigned long const *unused_gpl_crcs ;
   struct kernel_symbol const *gpl_future_syms ;
   unsigned long const *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   struct list_head source_list ;
   struct list_head target_list ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
struct klist_node;
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
struct dma_map_ops;
struct dev_archdata {
   void *acpi_handle ;
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
struct pdev_archdata {
};
struct device_private;
struct device_driver;
struct driver_private;
struct class;
struct subsys_private;
struct bus_type;
struct device_node;
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type * , char * ) ;
   ssize_t (*store)(struct bus_type * , char const * , size_t ) ;
};
struct device_attribute;
struct driver_attribute;
struct bus_type {
   char const *name ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops const *pm ;
   struct subsys_private *p ;
};
struct of_device_id;
struct device_driver {
   char const *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id const *of_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group const **groups ;
   struct dev_pm_ops const *pm ;
   struct driver_private *p ;
};
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver * , char * ) ;
   ssize_t (*store)(struct device_driver * , char const * , size_t ) ;
};
struct class_attribute;
struct class {
   char const *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct bin_attribute *dev_bin_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , mode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations const *ns_type ;
   void const *(*namespace)(struct device * ) ;
   struct dev_pm_ops const *pm ;
   struct subsys_private *p ;
};
struct device_type;
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const * , size_t ) ;
};
struct device_type {
   char const *name ;
   struct attribute_group const **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , mode_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops const *pm ;
};
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const * ,
                    size_t ) ;
};
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
struct dma_coherent_mem;
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const *init_name ;
   struct device_type const *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   struct dev_pm_info power ;
   struct dev_power_domain *pwr_domain ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   dev_t devt ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group const **groups ;
   void (*release)(struct device * ) ;
};
struct wakeup_source {
   char *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long hit_count ;
   unsigned char active : 1 ;
};
struct file_operations;
struct block_device;
struct hlist_bl_node;
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
struct nameidata;
struct path;
struct vfsmount;
struct qstr {
   unsigned int hash ;
   unsigned int len ;
   unsigned char const *name ;
};
struct inode;
struct dentry_operations;
struct super_block;
union __anonunion_d_u_130 {
   struct list_head d_child ;
   struct rcu_head d_rcu ;
};
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   unsigned int d_count ;
   spinlock_t d_lock ;
   struct dentry_operations const *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_130 d_u ;
   struct list_head d_subdirs ;
   struct list_head d_alias ;
};
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , struct nameidata * ) ;
   int (*d_hash)(struct dentry const * , struct inode const * , struct qstr * ) ;
   int (*d_compare)(struct dentry const * , struct inode const * , struct dentry const * ,
                    struct inode const * , unsigned int , char const * , struct qstr const * ) ;
   int (*d_delete)(struct dentry const * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool ) ;
};
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
struct radix_tree_node;
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
struct prio_tree_node;
struct raw_prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
};
struct prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
   unsigned long start ;
   unsigned long last ;
};
struct prio_tree_root {
   struct prio_tree_node *prio_tree_node ;
   unsigned short index_bits ;
   unsigned short raw ;
};
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
struct pid_namespace;
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct rcu_head rcu ;
   struct upid numbers[1U] ;
};
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
typedef struct kernel_cap_struct kernel_cap_t;
struct user_namespace;
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
struct export_operations;
struct iovec;
struct kiocb;
struct pipe_inode_info;
struct poll_table_struct;
struct kstatfs;
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   uid_t ia_uid ;
   gid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8U] ;
};
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
typedef struct fs_qfilestat fs_qfilestat_t;
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
struct dquot;
typedef __kernel_uid32_t qid_t;
typedef long long qsize_t;
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
struct quota_format_type;
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   unsigned int dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   short dq_type ;
   struct mem_dqblk dq_dqb ;
};
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int ) ;
   int (*read_file_info)(struct super_block * , int ) ;
   int (*write_file_info)(struct super_block * , int ) ;
   int (*free_file_info)(struct super_block * , int ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int , int , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int , int ) ;
   int (*quota_off)(struct super_block * , int ) ;
   int (*quota_sync)(struct super_block * , int , int ) ;
   int (*get_info)(struct super_block * , int , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , int , qid_t , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , int , qid_t , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int , int ) ;
};
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops const *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops const *ops[2U] ;
};
struct address_space;
struct writeback_control;
union __anonunion_arg_133 {
   char *buf ;
   void *data ;
};
struct __anonstruct_read_descriptor_t_132 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_133 arg ;
   int error ;
};
typedef struct __anonstruct_read_descriptor_t_132 read_descriptor_t;
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t , unsigned int ,
                      unsigned int , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t , unsigned int ,
                    unsigned int , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t ) ;
   void (*invalidatepage)(struct page * , unsigned long ) ;
   int (*releasepage)(struct page * , gfp_t ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int , struct kiocb * , struct iovec const * , loff_t ,
                        unsigned long ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long , int , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
};
struct backing_dev_info;
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct prio_tree_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations const *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   struct address_space *assoc_mapping ;
};
struct hd_struct;
struct gendisk;
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
struct posix_acl;
struct inode_operations;
union __anonunion_ldv_15897_134 {
   struct list_head i_dentry ;
   struct rcu_head i_rcu ;
};
struct file_lock;
struct cdev;
union __anonunion_ldv_15923_135 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
struct inode {
   umode_t i_mode ;
   uid_t i_uid ;
   gid_t i_gid ;
   struct inode_operations const *i_op ;
   struct super_block *i_sb ;
   spinlock_t i_lock ;
   unsigned int i_flags ;
   unsigned long i_state ;
   void *i_security ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_ldv_15897_134 ldv_15897 ;
   unsigned long i_ino ;
   atomic_t i_count ;
   unsigned int i_nlink ;
   dev_t i_rdev ;
   unsigned int i_blkbits ;
   u64 i_version ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   blkcnt_t i_blocks ;
   unsigned short i_bytes ;
   struct rw_semaphore i_alloc_sem ;
   struct file_operations const *i_fop ;
   struct file_lock *i_flock ;
   struct address_space *i_mapping ;
   struct address_space i_data ;
   struct dquot *i_dquot[2U] ;
   struct list_head i_devices ;
   union __anonunion_ldv_15923_135 ldv_15923 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   atomic_t i_readcount ;
   atomic_t i_writecount ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   void *i_private ;
};
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   uid_t uid ;
   uid_t euid ;
   int signum ;
};
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
union __anonunion_f_u_136 {
   struct list_head fu_list ;
   struct rcu_head fu_rcuhead ;
};
struct file {
   union __anonunion_f_u_136 f_u ;
   struct path f_path ;
   struct file_operations const *f_op ;
   spinlock_t f_lock ;
   int f_sb_list_cpu ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred const *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct address_space *f_mapping ;
   unsigned long f_mnt_write_state ;
};
struct files_struct;
typedef struct files_struct *fl_owner_t;
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
struct lock_manager_operations {
   int (*fl_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*fl_notify)(struct file_lock * ) ;
   int (*fl_grant)(struct file_lock * , struct file_lock * , int ) ;
   void (*fl_release_private)(struct file_lock * ) ;
   void (*fl_break)(struct file_lock * ) ;
   int (*fl_change)(struct file_lock ** , int ) ;
};
struct nlm_lockowner;
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
struct nfs4_lock_state;
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
struct fasync_struct;
struct __anonstruct_afs_138 {
   struct list_head link ;
   int state ;
};
union __anonunion_fl_u_137 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_138 afs ;
};
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned char fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   struct file_lock_operations const *fl_ops ;
   struct lock_manager_operations const *fl_lmops ;
   union __anonunion_fl_u_137 fl_u ;
};
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct rcu_head fa_rcu ;
};
struct file_system_type;
struct super_operations;
struct xattr_handler;
struct mtd_info;
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_dirt ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations const *s_op ;
   struct dquot_operations const *dq_op ;
   struct quotactl_ops const *s_qcop ;
   struct export_operations const *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   struct mutex s_lock ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler const **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head *s_files ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct list_head s_instances ;
   struct quota_info s_dquot ;
   int s_frozen ;
   wait_queue_head_t s_wait_unfrozen ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations const *s_d_op ;
   int cleancache_poolid ;
};
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t , int ) ;
   ssize_t (*read)(struct file * , char * , size_t , loff_t * ) ;
   ssize_t (*write)(struct file * , char const * , size_t , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec const * , unsigned long ,
                       loff_t ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec const * , unsigned long ,
                        loff_t ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const * , int ,
                                                   loff_t , u64 , unsigned int ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int , unsigned long ) ;
   long (*compat_ioctl)(struct file * , unsigned int , unsigned long ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , int ) ;
   int (*aio_fsync)(struct kiocb * , int ) ;
   int (*fasync)(int , struct file * , int ) ;
   int (*lock)(struct file * , int , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int , size_t , loff_t * ,
                       int ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long , unsigned long ,
                                      unsigned long , unsigned long ) ;
   int (*check_flags)(int ) ;
   int (*flock)(struct file * , int , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t ,
                           unsigned int ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t ,
                          unsigned int ) ;
   int (*setlease)(struct file * , long , struct file_lock ** ) ;
   long (*fallocate)(struct file * , int , loff_t , loff_t ) ;
};
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , struct nameidata * ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int , unsigned int ) ;
   int (*check_acl)(struct inode * , int , unsigned int ) ;
   int (*readlink)(struct dentry * , char * , int ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , int , struct nameidata * ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const * ) ;
   int (*mkdir)(struct inode * , struct dentry * , int ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , int , dev_t ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   void (*truncate)(struct inode * ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const * , void const * , size_t , int ) ;
   ssize_t (*getxattr)(struct dentry * , char const * , void * , size_t ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t ) ;
   int (*removexattr)(struct dentry * , char const * ) ;
   void (*truncate_range)(struct inode * , loff_t , loff_t ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64 , u64 ) ;
};
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   void (*write_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct vfsmount * ) ;
   int (*show_devname)(struct seq_file * , struct vfsmount * ) ;
   int (*show_path)(struct seq_file * , struct vfsmount * ) ;
   int (*show_stats)(struct seq_file * , struct vfsmount * ) ;
   ssize_t (*quota_read)(struct super_block * , int , char * , size_t , loff_t ) ;
   ssize_t (*quota_write)(struct super_block * , int , char const * , size_t ,
                          loff_t ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t ) ;
};
struct file_system_type {
   char const *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int , char const * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct list_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
   struct lock_class_key i_alloc_sem_key ;
};
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   int node ;
   unsigned int stat[19U] ;
};
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
struct kmem_cache_order_objects {
   unsigned long x ;
};
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int objsize ;
   int offset ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const *name ;
   struct list_head list ;
   struct kobject kobj ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
typedef int read_proc_t(char * , char ** , off_t , int , int * , void * );
typedef int write_proc_t(struct file * , char const * , unsigned long , void * );
struct proc_dir_entry {
   unsigned int low_ino ;
   unsigned int namelen ;
   char const *name ;
   mode_t mode ;
   nlink_t nlink ;
   uid_t uid ;
   gid_t gid ;
   loff_t size ;
   struct inode_operations const *proc_iops ;
   struct file_operations const *proc_fops ;
   struct proc_dir_entry *next ;
   struct proc_dir_entry *parent ;
   struct proc_dir_entry *subdir ;
   void *data ;
   read_proc_t *read_proc ;
   write_proc_t *write_proc ;
   atomic_t count ;
   int pde_users ;
   spinlock_t pde_unload_lock ;
   struct completion *pde_unload_completion ;
   struct list_head pde_openers ;
};
struct tty_driver;
typedef unsigned long kernel_ulong_t;
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void *data ;
};
struct platform_device_id {
   char name[20U] ;
   kernel_ulong_t driver_data ;
};
struct mfd_cell;
struct platform_device {
   char const *name ;
   int id ;
   struct device dev ;
   u32 num_resources ;
   struct resource *resource ;
   struct platform_device_id const *id_entry ;
   struct mfd_cell *mfd_cell ;
   struct pdev_archdata archdata ;
};
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
typedef enum irqreturn irqreturn_t;
struct hotplug_slot;
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
typedef int pci_power_t;
typedef unsigned int pci_channel_state_t;
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
typedef unsigned short pci_dev_flags_t;
typedef unsigned short pci_bus_flags_t;
struct pcie_link_state;
struct pci_vpd;
struct pci_sriov;
struct pci_ats;
struct pci_driver;
union __anonunion_ldv_18895_140 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 pcie_type ;
   u8 rom_base_reg ;
   u8 pin ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   int pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned int d3_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[18U] ;
   resource_size_t fw_addr[18U] ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char block_ucfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char is_pcie : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[18U] ;
   struct bin_attribute *res_attr_wc[18U] ;
   struct list_head msi_list ;
   struct pci_vpd *vpd ;
   union __anonunion_ldv_18895_140 ldv_18895 ;
   struct pci_ats *ats ;
};
struct pci_ops;
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct pci_ops *ops ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char secondary ;
   unsigned char subordinate ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
struct pci_ops {
   int (*read)(struct pci_bus * , unsigned int , int , int , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int , int , int , u32 ) ;
};
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
typedef unsigned int pci_ers_result_t;
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*resume)(struct pci_dev * ) ;
};
struct pci_driver {
   struct list_head node ;
   char const *name ;
   struct pci_device_id const *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id const * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   struct pci_error_handlers *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
struct rb_node {
   unsigned long rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
struct rb_root {
   struct rb_node *rb_node ;
};
struct __anonstruct_ldv_19717_142 {
   u16 inuse ;
   u16 objects ;
};
union __anonunion_ldv_19718_141 {
   atomic_t _mapcount ;
   struct __anonstruct_ldv_19717_142 ldv_19717 ;
};
struct __anonstruct_ldv_19723_144 {
   unsigned long private ;
   struct address_space *mapping ;
};
union __anonunion_ldv_19726_143 {
   struct __anonstruct_ldv_19723_144 ldv_19723 ;
   struct kmem_cache *slab ;
   struct page *first_page ;
};
union __anonunion_ldv_19730_145 {
   unsigned long index ;
   void *freelist ;
};
struct page {
   unsigned long flags ;
   atomic_t _count ;
   union __anonunion_ldv_19718_141 ldv_19718 ;
   union __anonunion_ldv_19726_143 ldv_19726 ;
   union __anonunion_ldv_19730_145 ldv_19730 ;
   struct list_head lru ;
};
struct __anonstruct_vm_set_147 {
   struct list_head list ;
   void *parent ;
   struct vm_area_struct *head ;
};
union __anonunion_shared_146 {
   struct __anonstruct_vm_set_147 vm_set ;
   struct raw_prio_tree_node prio_tree_node ;
};
struct anon_vma;
struct vm_operations_struct;
struct mempolicy;
struct vm_area_struct {
   struct mm_struct *vm_mm ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct rb_node vm_rb ;
   union __anonunion_shared_146 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct const *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
struct linux_binfmt;
struct mmu_notifier_mm;
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long , unsigned long ,
                                      unsigned long , unsigned long ) ;
   void (*unmap_area)(struct mm_struct * , unsigned long ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long reserved_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[44U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned int faultstamp ;
   unsigned int token_priority ;
   unsigned int last_interval ;
   atomic_t oom_disable_count ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct task_struct *owner ;
   struct file *exe_file ;
   unsigned long num_exe_file_vmas ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   pgtable_t pmd_huge_pte ;
   struct cpumask cpumask_allocation ;
};
struct user_struct;
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long , void * , int , int ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t const * , nodemask_t const * ,
                  unsigned long ) ;
};
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
};
struct shrinker {
   int (*shrink)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   struct list_head list ;
   long nr ;
};
struct dma_attrs {
   unsigned long flags[1U] ;
};
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
struct dma_map_ops {
   void *(*alloc_coherent)(struct device * , size_t , dma_addr_t * , gfp_t ) ;
   void (*free_coherent)(struct device * , size_t , void * , dma_addr_t ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long , size_t ,
                          enum dma_data_direction , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t , size_t , enum dma_data_direction ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int , enum dma_data_direction ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int , enum dma_data_direction ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int , enum dma_data_direction ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int , enum dma_data_direction ) ;
   int (*mapping_error)(struct device * , dma_addr_t ) ;
   int (*dma_supported)(struct device * , u64 ) ;
   int (*set_dma_mask)(struct device * , u64 ) ;
   int is_phys ;
};
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations const *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
struct exception_table_entry {
   unsigned long insn ;
   unsigned long fixup ;
};
struct sem_undo_list;
struct sem_undo_list {
   atomic_t refcnt ;
   spinlock_t lock ;
   struct list_head list_proc ;
};
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
typedef unsigned long cputime_t;
struct siginfo;
struct __anonstruct_sigset_t_159 {
   unsigned long sig[1U] ;
};
typedef struct __anonstruct_sigset_t_159 sigset_t;
typedef void __signalfn_t(int );
typedef __signalfn_t *__sighandler_t;
typedef void __restorefn_t(void);
typedef __restorefn_t *__sigrestore_t;
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
struct k_sigaction {
   struct sigaction sa ;
};
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval sigval_t;
struct __anonstruct__kill_161 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
struct __anonstruct__timer_162 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
struct __anonstruct__rt_163 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
struct __anonstruct__sigchld_164 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
struct __anonstruct__sigfault_165 {
   void *_addr ;
   short _addr_lsb ;
};
struct __anonstruct__sigpoll_166 {
   long _band ;
   int _fd ;
};
union __anonunion__sifields_160 {
   int _pad[28U] ;
   struct __anonstruct__kill_161 _kill ;
   struct __anonstruct__timer_162 _timer ;
   struct __anonstruct__rt_163 _rt ;
   struct __anonstruct__sigchld_164 _sigchld ;
   struct __anonstruct__sigfault_165 _sigfault ;
   struct __anonstruct__sigpoll_166 _sigpoll ;
};
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_160 _sifields ;
};
typedef struct siginfo siginfo_t;
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
struct prop_local_single {
   unsigned long events ;
   unsigned long period ;
   int shift ;
   spinlock_t lock ;
};
struct __anonstruct_seccomp_t_169 {
   int mode ;
};
typedef struct __anonstruct_seccomp_t_169 seccomp_t;
struct plist_head {
   struct list_head node_list ;
   raw_spinlock_t *rawlock ;
   spinlock_t *spinlock ;
};
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
struct rt_mutex {
   raw_spinlock_t wait_lock ;
   struct plist_head wait_list ;
   struct task_struct *owner ;
   int save_state ;
   char const *name ;
   char const *file ;
   int line ;
   void *magic ;
};
struct rt_mutex_waiter;
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
struct hrtimer_clock_base;
struct hrtimer_cpu_base;
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned long active_bases ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[3U] ;
};
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
typedef int32_t key_serial_t;
typedef uint32_t key_perm_t;
struct key;
struct signal_struct;
struct key_type;
struct keyring_list;
struct key_user;
union __anonunion_ldv_24696_170 {
   time_t expiry ;
   time_t revoked_at ;
};
union __anonunion_type_data_171 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
union __anonunion_payload_172 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   struct keyring_list *subscriptions ;
};
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   struct rb_node serial_node ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_ldv_24696_170 ldv_24696 ;
   uid_t uid ;
   gid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_171 type_data ;
   union __anonunion_payload_172 payload ;
};
struct audit_context;
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   gid_t small_block[32U] ;
   gid_t *blocks[0U] ;
};
struct thread_group_cred {
   atomic_t usage ;
   pid_t tgid ;
   spinlock_t lock ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct rcu_head rcu ;
};
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   uid_t uid ;
   gid_t gid ;
   uid_t suid ;
   gid_t sgid ;
   uid_t euid ;
   gid_t egid ;
   uid_t fsuid ;
   gid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   struct thread_group_cred *tgcred ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct rcu_head rcu ;
};
struct futex_pi_state;
struct robust_list_head;
struct bio_list;
struct fs_struct;
struct perf_event_context;
struct blk_plug;
struct cfs_rq;
struct kioctx;
union __anonunion_ki_obj_173 {
   void *user ;
   struct task_struct *tsk ;
};
struct eventfd_ctx;
struct kiocb {
   struct list_head ki_run_list ;
   unsigned long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_173 ki_obj ;
   __u64 ki_user_data ;
   loff_t ki_pos ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct eventfd_ctx *ki_eventfd ;
};
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8U] ;
};
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct hlist_node list ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct delayed_work wq ;
   struct rcu_head rcu_head ;
};
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   spinlock_t lock ;
};
struct autogroup;
struct tty_struct;
struct taskstats;
struct tty_audit_buf;
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore threadgroup_fork_lock ;
   int oom_adj ;
   int oom_score_adj ;
   int oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   uid_t uid ;
   struct user_namespace *user_ns ;
   atomic_long_t locked_vm ;
};
struct reclaim_state;
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
struct io_context;
struct rq;
struct sched_class {
   struct sched_class const *next ;
   void (*enqueue_task)(struct rq * , struct task_struct * , int ) ;
   void (*dequeue_task)(struct rq * , struct task_struct * , int ) ;
   void (*yield_task)(struct rq * ) ;
   bool (*yield_to_task)(struct rq * , struct task_struct * , bool ) ;
   void (*check_preempt_curr)(struct rq * , struct task_struct * , int ) ;
   struct task_struct *(*pick_next_task)(struct rq * ) ;
   void (*put_prev_task)(struct rq * , struct task_struct * ) ;
   int (*select_task_rq)(struct task_struct * , int , int ) ;
   void (*pre_schedule)(struct rq * , struct task_struct * ) ;
   void (*post_schedule)(struct rq * ) ;
   void (*task_waking)(struct task_struct * ) ;
   void (*task_woken)(struct rq * , struct task_struct * ) ;
   void (*set_cpus_allowed)(struct task_struct * , struct cpumask const * ) ;
   void (*rq_online)(struct rq * ) ;
   void (*rq_offline)(struct rq * ) ;
   void (*set_curr_task)(struct rq * ) ;
   void (*task_tick)(struct rq * , struct task_struct * , int ) ;
   void (*task_fork)(struct task_struct * ) ;
   void (*switched_from)(struct rq * , struct task_struct * ) ;
   void (*switched_to)(struct rq * , struct task_struct * ) ;
   void (*prio_changed)(struct rq * , struct task_struct * , int ) ;
   unsigned int (*get_rr_interval)(struct rq * , struct task_struct * ) ;
   void (*task_move_group)(struct task_struct * , int ) ;
};
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
};
struct rt_rq;
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned int time_slice ;
   int nr_cpus_allowed ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
struct mem_cgroup;
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
struct irqaction;
struct css_set;
struct compat_robust_list_head;
struct ftrace_ret_stack;
struct task_struct {
   long volatile state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct task_struct *wake_entry ;
   int on_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class const *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct hlist_head preempt_notifiers ;
   unsigned char fpu_counter ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int group_stop ;
   unsigned int personality ;
   unsigned char did_exec : 1 ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred const *real_cred ;
   struct cred const *cred ;
   struct cred *replacement_session_keyring ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct audit_context *audit_context ;
   uid_t loginuid ;
   unsigned int sessionid ;
   seccomp_t seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   struct irqaction *irqaction ;
   raw_spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   int mems_allowed_change_disable ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   atomic_t fs_excl ;
   struct rcu_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   struct prop_local_single dirties ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   struct list_head *scm_work_list ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   atomic_t ptrace_bp_refcnt ;
};
typedef s32 compat_time_t;
typedef s32 compat_long_t;
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};
typedef u32 compat_uptr_t;
struct compat_robust_list {
   compat_uptr_t next ;
};
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
enum chipset_type {
    NOT_SUPPORTED = 0,
    SUPPORTED = 1
} ;
struct agp_version {
   u16 major ;
   u16 minor ;
};
struct agp_kern_info {
   struct agp_version version ;
   struct pci_dev *device ;
   enum chipset_type chipset ;
   unsigned long mode ;
   unsigned long aper_base ;
   size_t aper_size ;
   int max_memory ;
   int current_memory ;
   bool cant_use_aperture ;
   unsigned long page_mask ;
   struct vm_operations_struct const *vm_ops ;
};
struct agp_bridge_data;
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
struct poll_table_struct {
   void (*qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long key ;
};
typedef unsigned int drm_magic_t;
struct drm_clip_rect {
   unsigned short x1 ;
   unsigned short y1 ;
   unsigned short x2 ;
   unsigned short y2 ;
};
struct drm_hw_lock {
   unsigned int volatile lock ;
   char padding[60U] ;
};
struct drm_unique {
   size_t unique_len ;
   char *unique ;
};
enum drm_map_type {
    _DRM_FRAME_BUFFER = 0,
    _DRM_REGISTERS = 1,
    _DRM_SHM = 2,
    _DRM_AGP = 3,
    _DRM_SCATTER_GATHER = 4,
    _DRM_CONSISTENT = 5,
    _DRM_GEM = 6
} ;
enum drm_map_flags {
    _DRM_RESTRICTED = 1,
    _DRM_READ_ONLY = 2,
    _DRM_LOCKED = 4,
    _DRM_KERNEL = 8,
    _DRM_WRITE_COMBINING = 16,
    _DRM_CONTAINS_LOCK = 32,
    _DRM_REMOVABLE = 64,
    _DRM_DRIVER = 128
} ;
enum drm_stat_type {
    _DRM_STAT_LOCK = 0,
    _DRM_STAT_OPENS = 1,
    _DRM_STAT_CLOSES = 2,
    _DRM_STAT_IOCTLS = 3,
    _DRM_STAT_LOCKS = 4,
    _DRM_STAT_UNLOCKS = 5,
    _DRM_STAT_VALUE = 6,
    _DRM_STAT_BYTE = 7,
    _DRM_STAT_COUNT = 8,
    _DRM_STAT_IRQ = 9,
    _DRM_STAT_PRIMARY = 10,
    _DRM_STAT_SECONDARY = 11,
    _DRM_STAT_DMA = 12,
    _DRM_STAT_SPECIAL = 13,
    _DRM_STAT_MISSED = 14
} ;
enum drm_ctx_flags {
    _DRM_CONTEXT_PRESERVED = 1,
    _DRM_CONTEXT_2DONLY = 2
} ;
struct drm_irq_busid {
   int irq ;
   int busnum ;
   int devnum ;
   int funcnum ;
};
struct drm_set_version {
   int drm_di_major ;
   int drm_di_minor ;
   int drm_dd_major ;
   int drm_dd_minor ;
};
struct drm_mode_fb_cmd {
   __u32 fb_id ;
   __u32 width ;
   __u32 height ;
   __u32 pitch ;
   __u32 bpp ;
   __u32 depth ;
   __u32 handle ;
};
struct drm_mode_create_dumb {
   uint32_t height ;
   uint32_t width ;
   uint32_t bpp ;
   uint32_t flags ;
   uint32_t handle ;
   uint32_t pitch ;
   uint64_t size ;
};
struct drm_event {
   __u32 type ;
   __u32 length ;
};
struct drm_event_vblank {
   struct drm_event base ;
   __u64 user_data ;
   __u32 tv_sec ;
   __u32 tv_usec ;
   __u32 sequence ;
   __u32 reserved ;
};
struct idr_layer {
   unsigned long bitmap ;
   struct idr_layer *ary[64U] ;
   int count ;
   int layer ;
   struct rcu_head rcu_head ;
};
struct idr {
   struct idr_layer *top ;
   struct idr_layer *id_free ;
   int layers ;
   int id_free_cnt ;
   spinlock_t lock ;
};
struct drm_file;
struct drm_device;
struct irqaction {
   irqreturn_t (*handler)(int , void * ) ;
   unsigned long flags ;
   void *dev_id ;
   struct irqaction *next ;
   int irq ;
   irqreturn_t (*thread_fn)(int , void * ) ;
   struct task_struct *thread ;
   unsigned long thread_flags ;
   unsigned long thread_mask ;
   char const *name ;
   struct proc_dir_entry *dir ;
};
struct drm_hash_item {
   struct hlist_node head ;
   unsigned long key ;
};
struct drm_open_hash {
   struct hlist_head *table ;
   u8 order ;
};
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations const *op ;
   void *private ;
};
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
struct drm_mm;
struct drm_mm_node {
   struct list_head node_list ;
   struct list_head hole_stack ;
   unsigned char hole_follows : 1 ;
   unsigned char scanned_block : 1 ;
   unsigned char scanned_prev_free : 1 ;
   unsigned char scanned_next_free : 1 ;
   unsigned char scanned_preceeds_hole : 1 ;
   unsigned char allocated : 1 ;
   unsigned long start ;
   unsigned long size ;
   struct drm_mm *mm ;
};
struct drm_mm {
   struct list_head hole_stack ;
   struct drm_mm_node head_node ;
   struct list_head unused_nodes ;
   int num_unused ;
   spinlock_t unused_lock ;
   unsigned char scan_check_range : 1 ;
   unsigned int scan_alignment ;
   unsigned long scan_size ;
   unsigned long scan_hit_start ;
   unsigned int scan_hit_size ;
   unsigned int scanned_blocks ;
   unsigned long scan_start ;
   unsigned long scan_end ;
   struct drm_mm_node *prev_scanned_node ;
};
typedef int drm_ioctl_t(struct drm_device * , void * , struct drm_file * );
struct drm_ioctl_desc {
   unsigned int cmd ;
   int flags ;
   drm_ioctl_t *func ;
   unsigned int cmd_drv ;
};
enum ldv_22760 {
    DRM_LIST_NONE = 0,
    DRM_LIST_FREE = 1,
    DRM_LIST_WAIT = 2,
    DRM_LIST_PEND = 3,
    DRM_LIST_PRIO = 4,
    DRM_LIST_RECLAIM = 5
} ;
struct drm_buf {
   int idx ;
   int total ;
   int order ;
   int used ;
   unsigned long offset ;
   void *address ;
   unsigned long bus_address ;
   struct drm_buf *next ;
   int volatile waiting ;
   int volatile pending ;
   wait_queue_head_t dma_wait ;
   struct drm_file *file_priv ;
   int context ;
   int while_locked ;
   enum ldv_22760 list ;
   int dev_priv_size ;
   void *dev_private ;
};
struct drm_waitlist {
   int count ;
   struct drm_buf **bufs ;
   struct drm_buf **rp ;
   struct drm_buf **wp ;
   struct drm_buf **end ;
   spinlock_t read_lock ;
   spinlock_t write_lock ;
};
struct drm_freelist {
   int initialized ;
   atomic_t count ;
   struct drm_buf *next ;
   wait_queue_head_t waiting ;
   int low_mark ;
   int high_mark ;
   atomic_t wfh ;
   spinlock_t lock ;
};
struct drm_dma_handle {
   dma_addr_t busaddr ;
   void *vaddr ;
   size_t size ;
};
typedef struct drm_dma_handle drm_dma_handle_t;
struct drm_buf_entry {
   int buf_size ;
   int buf_count ;
   struct drm_buf *buflist ;
   int seg_count ;
   int page_order ;
   struct drm_dma_handle **seglist ;
   struct drm_freelist freelist ;
};
struct drm_pending_event {
   struct drm_event *event ;
   struct list_head link ;
   struct drm_file *file_priv ;
   pid_t pid ;
   void (*destroy)(struct drm_pending_event * ) ;
};
struct drm_minor;
struct drm_master;
struct drm_file {
   int authenticated ;
   pid_t pid ;
   uid_t uid ;
   drm_magic_t magic ;
   unsigned long ioctl_count ;
   struct list_head lhead ;
   struct drm_minor *minor ;
   unsigned long lock_count ;
   struct idr object_idr ;
   spinlock_t table_lock ;
   struct file *filp ;
   void *driver_priv ;
   int is_master ;
   struct drm_master *master ;
   struct list_head fbs ;
   wait_queue_head_t event_wait ;
   struct list_head event_list ;
   int event_space ;
};
struct drm_queue {
   atomic_t use_count ;
   atomic_t finalization ;
   atomic_t block_count ;
   atomic_t block_read ;
   wait_queue_head_t read_queue ;
   atomic_t block_write ;
   wait_queue_head_t write_queue ;
   atomic_t total_queued ;
   atomic_t total_flushed ;
   atomic_t total_locks ;
   enum drm_ctx_flags flags ;
   struct drm_waitlist waitlist ;
   wait_queue_head_t flush_queue ;
};
struct drm_lock_data {
   struct drm_hw_lock *hw_lock ;
   struct drm_file *file_priv ;
   wait_queue_head_t lock_queue ;
   unsigned long lock_time ;
   spinlock_t spinlock ;
   uint32_t kernel_waiters ;
   uint32_t user_waiters ;
   int idle_has_lock ;
};
enum ldv_22785 {
    _DRM_DMA_USE_AGP = 1,
    _DRM_DMA_USE_SG = 2,
    _DRM_DMA_USE_FB = 4,
    _DRM_DMA_USE_PCI_RO = 8
} ;
struct drm_device_dma {
   struct drm_buf_entry bufs[23U] ;
   int buf_count ;
   struct drm_buf **buflist ;
   int seg_count ;
   int page_count ;
   unsigned long *pagelist ;
   unsigned long byte_count ;
   enum ldv_22785 flags ;
};
struct drm_agp_head {
   struct agp_kern_info agp_info ;
   struct list_head memory ;
   unsigned long mode ;
   struct agp_bridge_data *bridge ;
   int enabled ;
   int acquired ;
   unsigned long base ;
   int agp_mtrr ;
   int cant_use_aperture ;
   unsigned long page_mask ;
};
struct drm_sg_mem {
   unsigned long handle ;
   void *virtual ;
   int pages ;
   struct page **pagelist ;
   dma_addr_t *busaddr ;
};
struct drm_sigdata {
   int context ;
   struct drm_hw_lock *lock ;
};
struct drm_local_map {
   resource_size_t offset ;
   unsigned long size ;
   enum drm_map_type type ;
   enum drm_map_flags flags ;
   void *handle ;
   int mtrr ;
};
typedef struct drm_local_map drm_local_map_t;
struct drm_map_list {
   struct list_head head ;
   struct drm_hash_item hash ;
   struct drm_local_map *map ;
   uint64_t user_token ;
   struct drm_master *master ;
   struct drm_mm_node *file_offset_node ;
};
struct drm_gem_object {
   struct kref refcount ;
   atomic_t handle_count ;
   struct drm_device *dev ;
   struct file *filp ;
   struct drm_map_list map_list ;
   size_t size ;
   int name ;
   uint32_t read_domains ;
   uint32_t write_domain ;
   uint32_t pending_read_domains ;
   uint32_t pending_write_domain ;
   void *driver_private ;
};
typedef u32 phandle;
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
};
struct device_node {
   char const *name ;
   char const *type ;
   phandle phandle ;
   char *full_name ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct device_node *next ;
   struct device_node *allnext ;
   struct proc_dir_entry *pde ;
   struct kref kref ;
   unsigned long _flags ;
   void *data ;
};
struct i2c_msg;
struct i2c_algorithm;
struct i2c_adapter;
union i2c_smbus_data;
struct i2c_algorithm {
   int (*master_xfer)(struct i2c_adapter * , struct i2c_msg * , int ) ;
   int (*smbus_xfer)(struct i2c_adapter * , u16 , unsigned short , char , u8 ,
                     int , union i2c_smbus_data * ) ;
   u32 (*functionality)(struct i2c_adapter * ) ;
};
struct i2c_adapter {
   struct module *owner ;
   unsigned int class ;
   struct i2c_algorithm const *algo ;
   void *algo_data ;
   struct rt_mutex bus_lock ;
   int timeout ;
   int retries ;
   struct device dev ;
   int nr ;
   char name[48U] ;
   struct completion dev_released ;
   struct mutex userspace_clients_lock ;
   struct list_head userspace_clients ;
};
struct i2c_msg {
   __u16 addr ;
   __u16 flags ;
   __u16 len ;
   __u8 *buf ;
};
union i2c_smbus_data {
   __u8 byte ;
   __u16 word ;
   __u8 block[34U] ;
};
struct serial_icounter_struct {
   int cts ;
   int dsr ;
   int rng ;
   int dcd ;
   int rx ;
   int tx ;
   int frame ;
   int overrun ;
   int parity ;
   int brk ;
   int buf_overrun ;
   int reserved[9U] ;
};
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;
struct ktermios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[19U] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
struct termiox {
   __u16 x_hflag ;
   __u16 x_cflag ;
   __u16 x_rflag[5U] ;
   __u16 x_sflag ;
};
struct tty_operations {
   struct tty_struct *(*lookup)(struct tty_driver * , struct inode * , int ) ;
   int (*install)(struct tty_driver * , struct tty_struct * ) ;
   void (*remove)(struct tty_driver * , struct tty_struct * ) ;
   int (*open)(struct tty_struct * , struct file * ) ;
   void (*close)(struct tty_struct * , struct file * ) ;
   void (*shutdown)(struct tty_struct * ) ;
   void (*cleanup)(struct tty_struct * ) ;
   int (*write)(struct tty_struct * , unsigned char const * , int ) ;
   int (*put_char)(struct tty_struct * , unsigned char ) ;
   void (*flush_chars)(struct tty_struct * ) ;
   int (*write_room)(struct tty_struct * ) ;
   int (*chars_in_buffer)(struct tty_struct * ) ;
   int (*ioctl)(struct tty_struct * , unsigned int , unsigned long ) ;
   long (*compat_ioctl)(struct tty_struct * , unsigned int , unsigned long ) ;
   void (*set_termios)(struct tty_struct * , struct ktermios * ) ;
   void (*throttle)(struct tty_struct * ) ;
   void (*unthrottle)(struct tty_struct * ) ;
   void (*stop)(struct tty_struct * ) ;
   void (*start)(struct tty_struct * ) ;
   void (*hangup)(struct tty_struct * ) ;
   int (*break_ctl)(struct tty_struct * , int ) ;
   void (*flush_buffer)(struct tty_struct * ) ;
   void (*set_ldisc)(struct tty_struct * ) ;
   void (*wait_until_sent)(struct tty_struct * , int ) ;
   void (*send_xchar)(struct tty_struct * , char ) ;
   int (*tiocmget)(struct tty_struct * ) ;
   int (*tiocmset)(struct tty_struct * , unsigned int , unsigned int ) ;
   int (*resize)(struct tty_struct * , struct winsize * ) ;
   int (*set_termiox)(struct tty_struct * , struct termiox * ) ;
   int (*get_icount)(struct tty_struct * , struct serial_icounter_struct * ) ;
   int (*poll_init)(struct tty_driver * , int , char * ) ;
   int (*poll_get_char)(struct tty_driver * , int ) ;
   void (*poll_put_char)(struct tty_driver * , int , char ) ;
   struct file_operations const *proc_fops ;
};
struct tty_driver {
   int magic ;
   struct kref kref ;
   struct cdev cdev ;
   struct module *owner ;
   char const *driver_name ;
   char const *name ;
   int name_base ;
   int major ;
   int minor_start ;
   int minor_num ;
   int num ;
   short type ;
   short subtype ;
   struct ktermios init_termios ;
   int flags ;
   struct proc_dir_entry *proc_entry ;
   struct tty_driver *other ;
   struct tty_struct **ttys ;
   struct ktermios **termios ;
   struct ktermios **termios_locked ;
   void *driver_state ;
   struct tty_operations const *ops ;
   struct list_head tty_drivers ;
};
struct pps_event_time {
   struct timespec ts_real ;
};
struct tty_ldisc_ops {
   int magic ;
   char *name ;
   int num ;
   int flags ;
   int (*open)(struct tty_struct * ) ;
   void (*close)(struct tty_struct * ) ;
   void (*flush_buffer)(struct tty_struct * ) ;
   ssize_t (*chars_in_buffer)(struct tty_struct * ) ;
   ssize_t (*read)(struct tty_struct * , struct file * , unsigned char * , size_t ) ;
   ssize_t (*write)(struct tty_struct * , struct file * , unsigned char const * ,
                    size_t ) ;
   int (*ioctl)(struct tty_struct * , struct file * , unsigned int , unsigned long ) ;
   long (*compat_ioctl)(struct tty_struct * , struct file * , unsigned int , unsigned long ) ;
   void (*set_termios)(struct tty_struct * , struct ktermios * ) ;
   unsigned int (*poll)(struct tty_struct * , struct file * , struct poll_table_struct * ) ;
   int (*hangup)(struct tty_struct * ) ;
   void (*receive_buf)(struct tty_struct * , unsigned char const * , char * , int ) ;
   void (*write_wakeup)(struct tty_struct * ) ;
   void (*dcd_change)(struct tty_struct * , unsigned int , struct pps_event_time * ) ;
   struct module *owner ;
   int refcount ;
};
struct tty_ldisc {
   struct tty_ldisc_ops *ops ;
   atomic_t users ;
};
struct tty_buffer {
   struct tty_buffer *next ;
   char *char_buf_ptr ;
   unsigned char *flag_buf_ptr ;
   int used ;
   int size ;
   int commit ;
   int read ;
   unsigned long data[0U] ;
};
struct tty_bufhead {
   struct work_struct work ;
   spinlock_t lock ;
   struct tty_buffer *head ;
   struct tty_buffer *tail ;
   struct tty_buffer *free ;
   int memory_used ;
};
struct tty_port;
struct tty_port_operations {
   int (*carrier_raised)(struct tty_port * ) ;
   void (*dtr_rts)(struct tty_port * , int ) ;
   void (*shutdown)(struct tty_port * ) ;
   void (*drop)(struct tty_port * ) ;
   int (*activate)(struct tty_port * , struct tty_struct * ) ;
   void (*destruct)(struct tty_port * ) ;
};
struct tty_port {
   struct tty_struct *tty ;
   struct tty_port_operations const *ops ;
   spinlock_t lock ;
   int blocked_open ;
   int count ;
   wait_queue_head_t open_wait ;
   wait_queue_head_t close_wait ;
   wait_queue_head_t delta_msr_wait ;
   unsigned long flags ;
   unsigned char console : 1 ;
   struct mutex mutex ;
   struct mutex buf_mutex ;
   unsigned char *xmit_buf ;
   unsigned int close_delay ;
   unsigned int closing_wait ;
   int drain_delay ;
   struct kref kref ;
};
struct tty_struct {
   int magic ;
   struct kref kref ;
   struct device *dev ;
   struct tty_driver *driver ;
   struct tty_operations const *ops ;
   int index ;
   struct mutex ldisc_mutex ;
   struct tty_ldisc *ldisc ;
   struct mutex termios_mutex ;
   spinlock_t ctrl_lock ;
   struct ktermios *termios ;
   struct ktermios *termios_locked ;
   struct termiox *termiox ;
   char name[64U] ;
   struct pid *pgrp ;
   struct pid *session ;
   unsigned long flags ;
   int count ;
   struct winsize winsize ;
   unsigned char stopped : 1 ;
   unsigned char hw_stopped : 1 ;
   unsigned char flow_stopped : 1 ;
   unsigned char packet : 1 ;
   unsigned char low_latency : 1 ;
   unsigned char warned : 1 ;
   unsigned char ctrl_status ;
   unsigned int receive_room ;
   struct tty_struct *link ;
   struct fasync_struct *fasync ;
   struct tty_bufhead buf ;
   int alt_speed ;
   wait_queue_head_t write_wait ;
   wait_queue_head_t read_wait ;
   struct work_struct hangup_work ;
   void *disc_data ;
   void *driver_data ;
   struct list_head tty_files ;
   unsigned int column ;
   unsigned char lnext : 1 ;
   unsigned char erasing : 1 ;
   unsigned char raw : 1 ;
   unsigned char real_raw : 1 ;
   unsigned char icanon : 1 ;
   unsigned char closing : 1 ;
   unsigned char echo_overrun : 1 ;
   unsigned short minimum_to_wake ;
   unsigned long overrun_time ;
   int num_overrun ;
   unsigned long process_char_map[4U] ;
   char *read_buf ;
   int read_head ;
   int read_tail ;
   int read_cnt ;
   unsigned long read_flags[64U] ;
   unsigned char *echo_buf ;
   unsigned int echo_pos ;
   unsigned int echo_cnt ;
   int canon_data ;
   unsigned long canon_head ;
   unsigned int canon_column ;
   struct mutex atomic_read_lock ;
   struct mutex atomic_write_lock ;
   struct mutex output_lock ;
   struct mutex echo_lock ;
   unsigned char *write_buf ;
   int write_cnt ;
   spinlock_t read_lock ;
   struct work_struct SAK_work ;
   struct tty_port *port ;
};
struct fb_fix_screeninfo {
   char id[16U] ;
   unsigned long smem_start ;
   __u32 smem_len ;
   __u32 type ;
   __u32 type_aux ;
   __u32 visual ;
   __u16 xpanstep ;
   __u16 ypanstep ;
   __u16 ywrapstep ;
   __u32 line_length ;
   unsigned long mmio_start ;
   __u32 mmio_len ;
   __u32 accel ;
   __u16 reserved[3U] ;
};
struct fb_bitfield {
   __u32 offset ;
   __u32 length ;
   __u32 msb_right ;
};
struct fb_var_screeninfo {
   __u32 xres ;
   __u32 yres ;
   __u32 xres_virtual ;
   __u32 yres_virtual ;
   __u32 xoffset ;
   __u32 yoffset ;
   __u32 bits_per_pixel ;
   __u32 grayscale ;
   struct fb_bitfield red ;
   struct fb_bitfield green ;
   struct fb_bitfield blue ;
   struct fb_bitfield transp ;
   __u32 nonstd ;
   __u32 activate ;
   __u32 height ;
   __u32 width ;
   __u32 accel_flags ;
   __u32 pixclock ;
   __u32 left_margin ;
   __u32 right_margin ;
   __u32 upper_margin ;
   __u32 lower_margin ;
   __u32 hsync_len ;
   __u32 vsync_len ;
   __u32 sync ;
   __u32 vmode ;
   __u32 rotate ;
   __u32 reserved[5U] ;
};
struct fb_cmap {
   __u32 start ;
   __u32 len ;
   __u16 *red ;
   __u16 *green ;
   __u16 *blue ;
   __u16 *transp ;
};
struct fb_copyarea {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 sx ;
   __u32 sy ;
};
struct fb_fillrect {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 color ;
   __u32 rop ;
};
struct fb_image {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 fg_color ;
   __u32 bg_color ;
   __u8 depth ;
   char const *data ;
   struct fb_cmap cmap ;
};
struct fbcurpos {
   __u16 x ;
   __u16 y ;
};
struct fb_cursor {
   __u16 set ;
   __u16 enable ;
   __u16 rop ;
   char const *mask ;
   struct fbcurpos hot ;
   struct fb_image image ;
};
enum backlight_type {
    BACKLIGHT_RAW = 1,
    BACKLIGHT_PLATFORM = 2,
    BACKLIGHT_FIRMWARE = 3,
    BACKLIGHT_TYPE_MAX = 4
} ;
struct backlight_device;
struct fb_info;
struct backlight_ops {
   unsigned int options ;
   int (*update_status)(struct backlight_device * ) ;
   int (*get_brightness)(struct backlight_device * ) ;
   int (*check_fb)(struct backlight_device * , struct fb_info * ) ;
};
struct backlight_properties {
   int brightness ;
   int max_brightness ;
   int power ;
   int fb_blank ;
   enum backlight_type type ;
   unsigned int state ;
};
struct backlight_device {
   struct backlight_properties props ;
   struct mutex update_lock ;
   struct mutex ops_lock ;
   struct backlight_ops const *ops ;
   struct notifier_block fb_notif ;
   struct device dev ;
};
struct fb_chroma {
   __u32 redx ;
   __u32 greenx ;
   __u32 bluex ;
   __u32 whitex ;
   __u32 redy ;
   __u32 greeny ;
   __u32 bluey ;
   __u32 whitey ;
};
struct fb_videomode;
struct fb_monspecs {
   struct fb_chroma chroma ;
   struct fb_videomode *modedb ;
   __u8 manufacturer[4U] ;
   __u8 monitor[14U] ;
   __u8 serial_no[14U] ;
   __u8 ascii[14U] ;
   __u32 modedb_len ;
   __u32 model ;
   __u32 serial ;
   __u32 year ;
   __u32 week ;
   __u32 hfmin ;
   __u32 hfmax ;
   __u32 dclkmin ;
   __u32 dclkmax ;
   __u16 input ;
   __u16 dpms ;
   __u16 signal ;
   __u16 vfmin ;
   __u16 vfmax ;
   __u16 gamma ;
   unsigned char gtf : 1 ;
   __u16 misc ;
   __u8 version ;
   __u8 revision ;
   __u8 max_x ;
   __u8 max_y ;
};
struct fb_blit_caps {
   u32 x ;
   u32 y ;
   u32 len ;
   u32 flags ;
};
struct fb_pixmap {
   u8 *addr ;
   u32 size ;
   u32 offset ;
   u32 buf_align ;
   u32 scan_align ;
   u32 access_align ;
   u32 flags ;
   u32 blit_x ;
   u32 blit_y ;
   void (*writeio)(struct fb_info * , void * , void * , unsigned int ) ;
   void (*readio)(struct fb_info * , void * , void * , unsigned int ) ;
};
struct fb_deferred_io {
   unsigned long delay ;
   struct mutex lock ;
   struct list_head pagelist ;
   void (*deferred_io)(struct fb_info * , struct list_head * ) ;
};
struct fb_ops {
   struct module *owner ;
   int (*fb_open)(struct fb_info * , int ) ;
   int (*fb_release)(struct fb_info * , int ) ;
   ssize_t (*fb_read)(struct fb_info * , char * , size_t , loff_t * ) ;
   ssize_t (*fb_write)(struct fb_info * , char const * , size_t , loff_t * ) ;
   int (*fb_check_var)(struct fb_var_screeninfo * , struct fb_info * ) ;
   int (*fb_set_par)(struct fb_info * ) ;
   int (*fb_setcolreg)(unsigned int , unsigned int , unsigned int , unsigned int ,
                       unsigned int , struct fb_info * ) ;
   int (*fb_setcmap)(struct fb_cmap * , struct fb_info * ) ;
   int (*fb_blank)(int , struct fb_info * ) ;
   int (*fb_pan_display)(struct fb_var_screeninfo * , struct fb_info * ) ;
   void (*fb_fillrect)(struct fb_info * , struct fb_fillrect const * ) ;
   void (*fb_copyarea)(struct fb_info * , struct fb_copyarea const * ) ;
   void (*fb_imageblit)(struct fb_info * , struct fb_image const * ) ;
   int (*fb_cursor)(struct fb_info * , struct fb_cursor * ) ;
   void (*fb_rotate)(struct fb_info * , int ) ;
   int (*fb_sync)(struct fb_info * ) ;
   int (*fb_ioctl)(struct fb_info * , unsigned int , unsigned long ) ;
   int (*fb_compat_ioctl)(struct fb_info * , unsigned int , unsigned long ) ;
   int (*fb_mmap)(struct fb_info * , struct vm_area_struct * ) ;
   void (*fb_get_caps)(struct fb_info * , struct fb_blit_caps * , struct fb_var_screeninfo * ) ;
   void (*fb_destroy)(struct fb_info * ) ;
   int (*fb_debug_enter)(struct fb_info * ) ;
   int (*fb_debug_leave)(struct fb_info * ) ;
};
struct fb_tilemap {
   __u32 width ;
   __u32 height ;
   __u32 depth ;
   __u32 length ;
   __u8 const *data ;
};
struct fb_tilerect {
   __u32 sx ;
   __u32 sy ;
   __u32 width ;
   __u32 height ;
   __u32 index ;
   __u32 fg ;
   __u32 bg ;
   __u32 rop ;
};
struct fb_tilearea {
   __u32 sx ;
   __u32 sy ;
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
};
struct fb_tileblit {
   __u32 sx ;
   __u32 sy ;
   __u32 width ;
   __u32 height ;
   __u32 fg ;
   __u32 bg ;
   __u32 length ;
   __u32 *indices ;
};
struct fb_tilecursor {
   __u32 sx ;
   __u32 sy ;
   __u32 mode ;
   __u32 shape ;
   __u32 fg ;
   __u32 bg ;
};
struct fb_tile_ops {
   void (*fb_settile)(struct fb_info * , struct fb_tilemap * ) ;
   void (*fb_tilecopy)(struct fb_info * , struct fb_tilearea * ) ;
   void (*fb_tilefill)(struct fb_info * , struct fb_tilerect * ) ;
   void (*fb_tileblit)(struct fb_info * , struct fb_tileblit * ) ;
   void (*fb_tilecursor)(struct fb_info * , struct fb_tilecursor * ) ;
   int (*fb_get_tilemax)(struct fb_info * ) ;
};
struct aperture {
   resource_size_t base ;
   resource_size_t size ;
};
struct apertures_struct {
   unsigned int count ;
   struct aperture ranges[0U] ;
};
struct fb_info {
   atomic_t count ;
   int node ;
   int flags ;
   struct mutex lock ;
   struct mutex mm_lock ;
   struct fb_var_screeninfo var ;
   struct fb_fix_screeninfo fix ;
   struct fb_monspecs monspecs ;
   struct work_struct queue ;
   struct fb_pixmap pixmap ;
   struct fb_pixmap sprite ;
   struct fb_cmap cmap ;
   struct list_head modelist ;
   struct fb_videomode *mode ;
   struct backlight_device *bl_dev ;
   struct mutex bl_curve_mutex ;
   u8 bl_curve[128U] ;
   struct delayed_work deferred_work ;
   struct fb_deferred_io *fbdefio ;
   struct fb_ops *fbops ;
   struct device *device ;
   struct device *dev ;
   int class_flag ;
   struct fb_tile_ops *tileops ;
   char *screen_base ;
   unsigned long screen_size ;
   void *pseudo_palette ;
   u32 state ;
   void *fbcon_par ;
   void *par ;
   struct apertures_struct *apertures ;
};
struct fb_videomode {
   char const *name ;
   u32 refresh ;
   u32 xres ;
   u32 yres ;
   u32 pixclock ;
   u32 left_margin ;
   u32 right_margin ;
   u32 upper_margin ;
   u32 lower_margin ;
   u32 hsync_len ;
   u32 vsync_len ;
   u32 sync ;
   u32 vmode ;
   u32 flag ;
};
struct drm_mode_set;
struct drm_framebuffer;
struct drm_mode_object {
   uint32_t id ;
   uint32_t type ;
};
enum drm_mode_status {
    MODE_OK = 0,
    MODE_HSYNC = 1,
    MODE_VSYNC = 2,
    MODE_H_ILLEGAL = 3,
    MODE_V_ILLEGAL = 4,
    MODE_BAD_WIDTH = 5,
    MODE_NOMODE = 6,
    MODE_NO_INTERLACE = 7,
    MODE_NO_DBLESCAN = 8,
    MODE_NO_VSCAN = 9,
    MODE_MEM = 10,
    MODE_VIRTUAL_X = 11,
    MODE_VIRTUAL_Y = 12,
    MODE_MEM_VIRT = 13,
    MODE_NOCLOCK = 14,
    MODE_CLOCK_HIGH = 15,
    MODE_CLOCK_LOW = 16,
    MODE_CLOCK_RANGE = 17,
    MODE_BAD_HVALUE = 18,
    MODE_BAD_VVALUE = 19,
    MODE_BAD_VSCAN = 20,
    MODE_HSYNC_NARROW = 21,
    MODE_HSYNC_WIDE = 22,
    MODE_HBLANK_NARROW = 23,
    MODE_HBLANK_WIDE = 24,
    MODE_VSYNC_NARROW = 25,
    MODE_VSYNC_WIDE = 26,
    MODE_VBLANK_NARROW = 27,
    MODE_VBLANK_WIDE = 28,
    MODE_PANEL = 29,
    MODE_INTERLACE_WIDTH = 30,
    MODE_ONE_WIDTH = 31,
    MODE_ONE_HEIGHT = 32,
    MODE_ONE_SIZE = 33,
    MODE_NO_REDUCED = 34,
    MODE_UNVERIFIED = -3,
    MODE_BAD = -2,
    MODE_ERROR = -1
} ;
struct drm_display_mode {
   struct list_head head ;
   struct drm_mode_object base ;
   char name[32U] ;
   int connector_count ;
   enum drm_mode_status status ;
   int type ;
   int clock ;
   int hdisplay ;
   int hsync_start ;
   int hsync_end ;
   int htotal ;
   int hskew ;
   int vdisplay ;
   int vsync_start ;
   int vsync_end ;
   int vtotal ;
   int vscan ;
   unsigned int flags ;
   int width_mm ;
   int height_mm ;
   int clock_index ;
   int synth_clock ;
   int crtc_hdisplay ;
   int crtc_hblank_start ;
   int crtc_hblank_end ;
   int crtc_hsync_start ;
   int crtc_hsync_end ;
   int crtc_htotal ;
   int crtc_hskew ;
   int crtc_vdisplay ;
   int crtc_vblank_start ;
   int crtc_vblank_end ;
   int crtc_vsync_start ;
   int crtc_vsync_end ;
   int crtc_vtotal ;
   int crtc_hadjusted ;
   int crtc_vadjusted ;
   int private_size ;
   int *private ;
   int private_flags ;
   int vrefresh ;
   int hsync ;
};
enum drm_connector_status {
    connector_status_connected = 1,
    connector_status_disconnected = 2,
    connector_status_unknown = 3
} ;
enum subpixel_order {
    SubPixelUnknown = 0,
    SubPixelHorizontalRGB = 1,
    SubPixelHorizontalBGR = 2,
    SubPixelVerticalRGB = 3,
    SubPixelVerticalBGR = 4,
    SubPixelNone = 5
} ;
struct drm_display_info {
   char name[32U] ;
   unsigned int width_mm ;
   unsigned int height_mm ;
   unsigned int min_vfreq ;
   unsigned int max_vfreq ;
   unsigned int min_hfreq ;
   unsigned int max_hfreq ;
   unsigned int pixel_clock ;
   unsigned int bpc ;
   enum subpixel_order subpixel_order ;
   u32 color_formats ;
   char *raw_edid ;
};
struct drm_framebuffer_funcs {
   void (*destroy)(struct drm_framebuffer * ) ;
   int (*create_handle)(struct drm_framebuffer * , struct drm_file * , unsigned int * ) ;
   int (*dirty)(struct drm_framebuffer * , struct drm_file * , unsigned int , unsigned int ,
                struct drm_clip_rect * , unsigned int ) ;
};
struct drm_framebuffer {
   struct drm_device *dev ;
   struct list_head head ;
   struct drm_mode_object base ;
   struct drm_framebuffer_funcs const *funcs ;
   unsigned int pitch ;
   unsigned int width ;
   unsigned int height ;
   unsigned int depth ;
   int bits_per_pixel ;
   int flags ;
   struct list_head filp_head ;
   void *helper_private ;
};
struct drm_property_blob {
   struct drm_mode_object base ;
   struct list_head head ;
   unsigned int length ;
   void *data ;
};
struct drm_property {
   struct list_head head ;
   struct drm_mode_object base ;
   uint32_t flags ;
   char name[32U] ;
   uint32_t num_values ;
   uint64_t *values ;
   struct list_head enum_blob_list ;
};
struct drm_crtc;
struct drm_connector;
struct drm_encoder;
struct drm_pending_vblank_event;
struct drm_crtc_funcs {
   void (*save)(struct drm_crtc * ) ;
   void (*restore)(struct drm_crtc * ) ;
   void (*reset)(struct drm_crtc * ) ;
   int (*cursor_set)(struct drm_crtc * , struct drm_file * , uint32_t , uint32_t ,
                     uint32_t ) ;
   int (*cursor_move)(struct drm_crtc * , int , int ) ;
   void (*gamma_set)(struct drm_crtc * , u16 * , u16 * , u16 * , uint32_t , uint32_t ) ;
   void (*destroy)(struct drm_crtc * ) ;
   int (*set_config)(struct drm_mode_set * ) ;
   int (*page_flip)(struct drm_crtc * , struct drm_framebuffer * , struct drm_pending_vblank_event * ) ;
};
struct drm_crtc {
   struct drm_device *dev ;
   struct list_head head ;
   struct drm_mode_object base ;
   struct drm_framebuffer *fb ;
   bool enabled ;
   struct drm_display_mode mode ;
   struct drm_display_mode hwmode ;
   int x ;
   int y ;
   struct drm_crtc_funcs const *funcs ;
   uint32_t gamma_size ;
   uint16_t *gamma_store ;
   s64 framedur_ns ;
   s64 linedur_ns ;
   s64 pixeldur_ns ;
   void *helper_private ;
};
struct drm_connector_funcs {
   void (*dpms)(struct drm_connector * , int ) ;
   void (*save)(struct drm_connector * ) ;
   void (*restore)(struct drm_connector * ) ;
   void (*reset)(struct drm_connector * ) ;
   enum drm_connector_status (*detect)(struct drm_connector * , bool ) ;
   int (*fill_modes)(struct drm_connector * , uint32_t , uint32_t ) ;
   int (*set_property)(struct drm_connector * , struct drm_property * , uint64_t ) ;
   void (*destroy)(struct drm_connector * ) ;
   void (*force)(struct drm_connector * ) ;
};
struct drm_encoder_funcs {
   void (*reset)(struct drm_encoder * ) ;
   void (*destroy)(struct drm_encoder * ) ;
};
struct drm_encoder {
   struct drm_device *dev ;
   struct list_head head ;
   struct drm_mode_object base ;
   int encoder_type ;
   uint32_t possible_crtcs ;
   uint32_t possible_clones ;
   struct drm_crtc *crtc ;
   struct drm_encoder_funcs const *funcs ;
   void *helper_private ;
};
enum drm_connector_force {
    DRM_FORCE_UNSPECIFIED = 0,
    DRM_FORCE_OFF = 1,
    DRM_FORCE_ON = 2,
    DRM_FORCE_ON_DIGITAL = 3
} ;
struct drm_connector {
   struct drm_device *dev ;
   struct device kdev ;
   struct device_attribute *attr ;
   struct list_head head ;
   struct drm_mode_object base ;
   int connector_type ;
   int connector_type_id ;
   bool interlace_allowed ;
   bool doublescan_allowed ;
   struct list_head modes ;
   int initial_x ;
   int initial_y ;
   enum drm_connector_status status ;
   struct list_head probed_modes ;
   struct drm_display_info display_info ;
   struct drm_connector_funcs const *funcs ;
   struct list_head user_modes ;
   struct drm_property_blob *edid_blob_ptr ;
   u32 property_ids[16U] ;
   uint64_t property_values[16U] ;
   uint8_t polled ;
   int dpms ;
   void *helper_private ;
   enum drm_connector_force force ;
   uint32_t encoder_ids[2U] ;
   uint32_t force_encoder_id ;
   struct drm_encoder *encoder ;
   int null_edid_counter ;
};
struct drm_mode_set {
   struct list_head head ;
   struct drm_framebuffer *fb ;
   struct drm_crtc *crtc ;
   struct drm_display_mode *mode ;
   uint32_t x ;
   uint32_t y ;
   struct drm_connector **connectors ;
   size_t num_connectors ;
};
struct drm_mode_config_funcs {
   struct drm_framebuffer *(*fb_create)(struct drm_device * , struct drm_file * ,
                                        struct drm_mode_fb_cmd * ) ;
   void (*output_poll_changed)(struct drm_device * ) ;
};
struct drm_mode_group {
   uint32_t num_crtcs ;
   uint32_t num_encoders ;
   uint32_t num_connectors ;
   uint32_t *id_list ;
};
struct drm_mode_config {
   struct mutex mutex ;
   struct mutex idr_mutex ;
   struct idr crtc_idr ;
   int num_fb ;
   struct list_head fb_list ;
   int num_connector ;
   struct list_head connector_list ;
   int num_encoder ;
   struct list_head encoder_list ;
   int num_crtc ;
   struct list_head crtc_list ;
   struct list_head property_list ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   struct drm_mode_config_funcs *funcs ;
   resource_size_t fb_base ;
   bool poll_enabled ;
   struct delayed_work output_poll_work ;
   struct list_head property_blob_list ;
   struct drm_property *edid_property ;
   struct drm_property *dpms_property ;
   struct drm_property *dvi_i_subconnector_property ;
   struct drm_property *dvi_i_select_subconnector_property ;
   struct drm_property *tv_subconnector_property ;
   struct drm_property *tv_select_subconnector_property ;
   struct drm_property *tv_mode_property ;
   struct drm_property *tv_left_margin_property ;
   struct drm_property *tv_right_margin_property ;
   struct drm_property *tv_top_margin_property ;
   struct drm_property *tv_bottom_margin_property ;
   struct drm_property *tv_brightness_property ;
   struct drm_property *tv_contrast_property ;
   struct drm_property *tv_flicker_reduction_property ;
   struct drm_property *tv_overscan_property ;
   struct drm_property *tv_saturation_property ;
   struct drm_property *tv_hue_property ;
   struct drm_property *scaling_mode_property ;
   struct drm_property *dithering_mode_property ;
   struct drm_property *dirty_info_property ;
};
struct drm_master {
   struct kref refcount ;
   struct list_head head ;
   struct drm_minor *minor ;
   char *unique ;
   int unique_len ;
   int unique_size ;
   int blocked ;
   struct drm_open_hash magiclist ;
   struct list_head magicfree ;
   struct drm_lock_data lock ;
   void *driver_priv ;
};
struct drm_bus {
   int bus_type ;
   int (*get_irq)(struct drm_device * ) ;
   char const *(*get_name)(struct drm_device * ) ;
   int (*set_busid)(struct drm_device * , struct drm_master * ) ;
   int (*set_unique)(struct drm_device * , struct drm_master * , struct drm_unique * ) ;
   int (*irq_by_busid)(struct drm_device * , struct drm_irq_busid * ) ;
   int (*agp_init)(struct drm_device * ) ;
};
struct usb_driver;
union __anonunion_kdriver_183 {
   struct pci_driver *pci ;
   struct platform_device *platform_device ;
   struct usb_driver *usb ;
};
struct drm_driver {
   int (*load)(struct drm_device * , unsigned long ) ;
   int (*firstopen)(struct drm_device * ) ;
   int (*open)(struct drm_device * , struct drm_file * ) ;
   void (*preclose)(struct drm_device * , struct drm_file * ) ;
   void (*postclose)(struct drm_device * , struct drm_file * ) ;
   void (*lastclose)(struct drm_device * ) ;
   int (*unload)(struct drm_device * ) ;
   int (*suspend)(struct drm_device * , pm_message_t ) ;
   int (*resume)(struct drm_device * ) ;
   int (*dma_ioctl)(struct drm_device * , void * , struct drm_file * ) ;
   int (*dma_quiescent)(struct drm_device * ) ;
   int (*context_dtor)(struct drm_device * , int ) ;
   u32 (*get_vblank_counter)(struct drm_device * , int ) ;
   int (*enable_vblank)(struct drm_device * , int ) ;
   void (*disable_vblank)(struct drm_device * , int ) ;
   int (*device_is_agp)(struct drm_device * ) ;
   int (*get_scanout_position)(struct drm_device * , int , int * , int * ) ;
   int (*get_vblank_timestamp)(struct drm_device * , int , int * , struct timeval * ,
                               unsigned int ) ;
   irqreturn_t (*irq_handler)(int , void * ) ;
   void (*irq_preinstall)(struct drm_device * ) ;
   int (*irq_postinstall)(struct drm_device * ) ;
   void (*irq_uninstall)(struct drm_device * ) ;
   void (*reclaim_buffers)(struct drm_device * , struct drm_file * ) ;
   void (*reclaim_buffers_locked)(struct drm_device * , struct drm_file * ) ;
   void (*reclaim_buffers_idlelocked)(struct drm_device * , struct drm_file * ) ;
   void (*set_version)(struct drm_device * , struct drm_set_version * ) ;
   int (*master_create)(struct drm_device * , struct drm_master * ) ;
   void (*master_destroy)(struct drm_device * , struct drm_master * ) ;
   int (*master_set)(struct drm_device * , struct drm_file * , bool ) ;
   void (*master_drop)(struct drm_device * , struct drm_file * , bool ) ;
   int (*debugfs_init)(struct drm_minor * ) ;
   void (*debugfs_cleanup)(struct drm_minor * ) ;
   int (*gem_init_object)(struct drm_gem_object * ) ;
   void (*gem_free_object)(struct drm_gem_object * ) ;
   void (*vgaarb_irq)(struct drm_device * , bool ) ;
   int (*dumb_create)(struct drm_file * , struct drm_device * , struct drm_mode_create_dumb * ) ;
   int (*dumb_map_offset)(struct drm_file * , struct drm_device * , uint32_t , uint64_t * ) ;
   int (*dumb_destroy)(struct drm_file * , struct drm_device * , uint32_t ) ;
   struct vm_operations_struct *gem_vm_ops ;
   int major ;
   int minor ;
   int patchlevel ;
   char *name ;
   char *desc ;
   char *date ;
   u32 driver_features ;
   int dev_priv_size ;
   struct drm_ioctl_desc *ioctls ;
   int num_ioctls ;
   struct file_operations fops ;
   union __anonunion_kdriver_183 kdriver ;
   struct drm_bus *bus ;
   struct list_head device_list ;
};
struct drm_info_list {
   char const *name ;
   int (*show)(struct seq_file * , void * ) ;
   u32 driver_features ;
   void *data ;
};
struct drm_info_node {
   struct list_head list ;
   struct drm_minor *minor ;
   struct drm_info_list *info_ent ;
   struct dentry *dent ;
};
struct drm_minor {
   int index ;
   int type ;
   dev_t device ;
   struct device kdev ;
   struct drm_device *dev ;
   struct proc_dir_entry *proc_root ;
   struct drm_info_node proc_nodes ;
   struct dentry *debugfs_root ;
   struct drm_info_node debugfs_nodes ;
   struct drm_master *master ;
   struct list_head master_list ;
   struct drm_mode_group mode_group ;
};
struct drm_cmdline_mode {
   bool specified ;
   bool refresh_specified ;
   bool bpp_specified ;
   int xres ;
   int yres ;
   int bpp ;
   int refresh ;
   bool rb ;
   bool interlace ;
   bool cvt ;
   bool margins ;
   enum drm_connector_force force ;
};
struct drm_pending_vblank_event {
   struct drm_pending_event base ;
   int pipe ;
   struct drm_event_vblank event ;
};
struct usb_device;
struct drm_device {
   struct list_head driver_item ;
   char *devname ;
   int if_version ;
   spinlock_t count_lock ;
   struct mutex struct_mutex ;
   int open_count ;
   atomic_t ioctl_count ;
   atomic_t vma_count ;
   int buf_use ;
   atomic_t buf_alloc ;
   unsigned long counters ;
   enum drm_stat_type types[15U] ;
   atomic_t counts[15U] ;
   struct list_head filelist ;
   struct list_head maplist ;
   int map_count ;
   struct drm_open_hash map_hash ;
   struct list_head ctxlist ;
   int ctx_count ;
   struct mutex ctxlist_mutex ;
   struct idr ctx_idr ;
   struct list_head vmalist ;
   int queue_count ;
   int queue_reserved ;
   int queue_slots ;
   struct drm_queue **queuelist ;
   struct drm_device_dma *dma ;
   int irq_enabled ;
   long volatile context_flag ;
   long volatile interrupt_flag ;
   long volatile dma_flag ;
   wait_queue_head_t context_wait ;
   int last_checked ;
   int last_context ;
   unsigned long last_switch ;
   struct work_struct work ;
   int vblank_disable_allowed ;
   wait_queue_head_t *vbl_queue ;
   atomic_t *_vblank_count ;
   struct timeval *_vblank_time ;
   spinlock_t vblank_time_lock ;
   spinlock_t vbl_lock ;
   atomic_t *vblank_refcount ;
   u32 *last_vblank ;
   int *vblank_enabled ;
   int *vblank_inmodeset ;
   u32 *last_vblank_wait ;
   struct timer_list vblank_disable_timer ;
   u32 max_vblank_count ;
   struct list_head vblank_event_list ;
   spinlock_t event_lock ;
   cycles_t ctx_start ;
   cycles_t lck_start ;
   struct fasync_struct *buf_async ;
   wait_queue_head_t buf_readers ;
   wait_queue_head_t buf_writers ;
   struct drm_agp_head *agp ;
   struct device *dev ;
   struct pci_dev *pdev ;
   int pci_vendor ;
   int pci_device ;
   struct platform_device *platformdev ;
   struct usb_device *usbdev ;
   struct drm_sg_mem *sg ;
   unsigned int num_crtcs ;
   void *dev_private ;
   void *mm_private ;
   struct address_space *dev_mapping ;
   struct drm_sigdata sigdata ;
   sigset_t sigmask ;
   struct drm_driver *driver ;
   struct drm_local_map *agp_buffer_map ;
   unsigned int agp_buffer_token ;
   struct drm_minor *control ;
   struct drm_minor *primary ;
   struct drm_mode_config mode_config ;
   spinlock_t object_name_lock ;
   struct idr object_name_idr ;
   int switch_power_state ;
};
struct drm_i915_gem_exec_object2 {
   __u32 handle ;
   __u32 relocation_count ;
   __u64 relocs_ptr ;
   __u64 alignment ;
   __u64 offset ;
   __u64 flags ;
   __u64 rsvd1 ;
   __u64 rsvd2 ;
};
struct child_device_config {
   u16 handle ;
   u16 device_type ;
   u8 i2c_speed ;
   u8 rsvd[9U] ;
   u16 addin_offset ;
   u8 dvo_port ;
   u8 i2c_pin ;
   u8 slave_addr ;
   u8 ddc_pin ;
   u16 edid_ptr ;
   u8 dvo_cfg ;
   u8 dvo2_port ;
   u8 i2c2_pin ;
   u8 slave2_addr ;
   u8 ddc2_pin ;
   u8 capabilities ;
   u8 dvo_wiring ;
   u8 dvo2_wiring ;
   u16 extended_type ;
   u8 dvo_function ;
};
struct edp_power_seq {
   u16 t3 ;
   u16 t7 ;
   u16 t9 ;
   u16 t10 ;
   u16 t12 ;
};
struct drm_i915_gem_object;
struct intel_hw_status_page {
   u32 *page_addr ;
   unsigned int gfx_addr ;
   struct drm_i915_gem_object *obj ;
};
enum intel_ring_id {
    RING_RENDER = 1,
    RING_BSD = 2,
    RING_BLT = 4
} ;
struct intel_ring_buffer {
   char const *name ;
   enum intel_ring_id id ;
   u32 mmio_base ;
   void *virtual_start ;
   struct drm_device *dev ;
   struct drm_i915_gem_object *obj ;
   u32 head ;
   u32 tail ;
   int space ;
   int size ;
   int effective_size ;
   struct intel_hw_status_page status_page ;
   spinlock_t irq_lock ;
   u32 irq_refcount ;
   u32 irq_mask ;
   u32 irq_seqno ;
   u32 trace_irq_seqno ;
   u32 waiting_seqno ;
   u32 sync_seqno[2U] ;
   bool (*irq_get)(struct intel_ring_buffer * ) ;
   void (*irq_put)(struct intel_ring_buffer * ) ;
   int (*init)(struct intel_ring_buffer * ) ;
   void (*write_tail)(struct intel_ring_buffer * , u32 ) ;
   int (*flush)(struct intel_ring_buffer * , u32 , u32 ) ;
   int (*add_request)(struct intel_ring_buffer * , u32 * ) ;
   u32 (*get_seqno)(struct intel_ring_buffer * ) ;
   int (*dispatch_execbuffer)(struct intel_ring_buffer * , u32 , u32 ) ;
   void (*cleanup)(struct intel_ring_buffer * ) ;
   struct list_head active_list ;
   struct list_head request_list ;
   struct list_head gpu_write_list ;
   u32 outstanding_lazy_request ;
   wait_queue_head_t irq_queue ;
   drm_local_map_t map ;
   void *private ;
};
struct io_mapping;
struct intel_gtt {
   unsigned int stolen_size ;
   unsigned int gtt_total_entries ;
   unsigned int gtt_mappable_entries ;
   unsigned char needs_dmar : 1 ;
};
struct drm_i915_gem_phys_object {
   int id ;
   struct page **page_list ;
   drm_dma_handle_t *handle ;
   struct drm_i915_gem_object *cur_obj ;
};
struct mem_block {
   struct mem_block *next ;
   struct mem_block *prev ;
   int start ;
   int size ;
   struct drm_file *file_priv ;
};
struct opregion_header;
struct opregion_acpi;
struct opregion_swsci;
struct opregion_asle;
struct intel_opregion {
   struct opregion_header *header ;
   struct opregion_acpi *acpi ;
   struct opregion_swsci *swsci ;
   struct opregion_asle *asle ;
   void *vbt ;
   u32 *lid_state ;
};
struct intel_overlay;
struct intel_overlay_error_state;
struct drm_i915_fence_reg {
   struct list_head lru_list ;
   struct drm_i915_gem_object *obj ;
   uint32_t setup_seqno ;
};
struct sdvo_device_mapping {
   u8 initialized ;
   u8 dvo_port ;
   u8 slave_addr ;
   u8 dvo_wiring ;
   u8 i2c_pin ;
   u8 i2c_speed ;
   u8 ddc_pin ;
};
struct intel_display_error_state;
struct drm_i915_error_object {
   int page_count ;
   u32 gtt_offset ;
   u32 *pages[0U] ;
};
struct drm_i915_error_buffer {
   u32 size ;
   u32 name ;
   u32 seqno ;
   u32 gtt_offset ;
   u32 read_domains ;
   u32 write_domain ;
   signed char fence_reg : 5 ;
   signed char pinned : 2 ;
   unsigned char tiling : 2 ;
   unsigned char dirty : 1 ;
   unsigned char purgeable : 1 ;
   unsigned char ring : 4 ;
   unsigned char cache_level : 2 ;
};
struct drm_i915_error_state {
   u32 eir ;
   u32 pgtbl_er ;
   u32 pipestat[3U] ;
   u32 ipeir ;
   u32 ipehr ;
   u32 instdone ;
   u32 acthd ;
   u32 error ;
   u32 bcs_acthd ;
   u32 bcs_ipehr ;
   u32 bcs_ipeir ;
   u32 bcs_instdone ;
   u32 bcs_seqno ;
   u32 vcs_acthd ;
   u32 vcs_ipehr ;
   u32 vcs_ipeir ;
   u32 vcs_instdone ;
   u32 vcs_seqno ;
   u32 instpm ;
   u32 instps ;
   u32 instdone1 ;
   u32 seqno ;
   u64 bbaddr ;
   u64 fence[16U] ;
   struct timeval time ;
   struct drm_i915_error_object *ringbuffer[3U] ;
   struct drm_i915_error_object *batchbuffer[3U] ;
   struct drm_i915_error_buffer *active_bo ;
   struct drm_i915_error_buffer *pinned_bo ;
   u32 active_bo_count ;
   u32 pinned_bo_count ;
   struct intel_overlay_error_state *overlay ;
   struct intel_display_error_state *display ;
};
struct drm_i915_display_funcs {
   void (*dpms)(struct drm_crtc * , int ) ;
   bool (*fbc_enabled)(struct drm_device * ) ;
   void (*enable_fbc)(struct drm_crtc * , unsigned long ) ;
   void (*disable_fbc)(struct drm_device * ) ;
   int (*get_display_clock_speed)(struct drm_device * ) ;
   int (*get_fifo_size)(struct drm_device * , int ) ;
   void (*update_wm)(struct drm_device * ) ;
   int (*crtc_mode_set)(struct drm_crtc * , struct drm_display_mode * , struct drm_display_mode * ,
                        int , int , struct drm_framebuffer * ) ;
   void (*fdi_link_train)(struct drm_crtc * ) ;
   void (*init_clock_gating)(struct drm_device * ) ;
   void (*init_pch_clock_gating)(struct drm_device * ) ;
   int (*queue_flip)(struct drm_device * , struct drm_crtc * , struct drm_framebuffer * ,
                     struct drm_i915_gem_object * ) ;
};
struct intel_device_info {
   u8 gen ;
   unsigned char is_mobile : 1 ;
   unsigned char is_i85x : 1 ;
   unsigned char is_i915g : 1 ;
   unsigned char is_i945gm : 1 ;
   unsigned char is_g33 : 1 ;
   unsigned char need_gfx_hws : 1 ;
   unsigned char is_g4x : 1 ;
   unsigned char is_pineview : 1 ;
   unsigned char is_broadwater : 1 ;
   unsigned char is_crestline : 1 ;
   unsigned char is_ivybridge : 1 ;
   unsigned char has_fbc : 1 ;
   unsigned char has_pipe_cxsr : 1 ;
   unsigned char has_hotplug : 1 ;
   unsigned char cursor_needs_physical : 1 ;
   unsigned char has_overlay : 1 ;
   unsigned char overlay_needs_physical : 1 ;
   unsigned char supports_tv : 1 ;
   unsigned char has_bsd_ring : 1 ;
   unsigned char has_blt_ring : 1 ;
};
enum no_fbc_reason {
    FBC_NO_OUTPUT = 0,
    FBC_STOLEN_TOO_SMALL = 1,
    FBC_UNSUPPORTED_MODE = 2,
    FBC_MODE_TOO_LARGE = 3,
    FBC_BAD_PLANE = 4,
    FBC_NOT_TILED = 5,
    FBC_MULTIPLE_PIPES = 6,
    FBC_MODULE_PARAM = 7
} ;
enum intel_pch {
    PCH_IBX = 0,
    PCH_CPT = 1
} ;
struct intel_fbdev;
struct intel_gmbus {
   struct i2c_adapter adapter ;
   struct i2c_adapter *force_bit ;
   u32 reg0 ;
};
struct __anonstruct_edp_184 {
   int rate ;
   int lanes ;
   int preemphasis ;
   int vswing ;
   bool initialized ;
   bool support ;
   int bpp ;
   struct edp_power_seq pps ;
};
struct __anonstruct_mm_185 {
   struct intel_gtt const *gtt ;
   struct drm_mm stolen ;
   struct drm_mm gtt_space ;
   struct list_head gtt_list ;
   unsigned long gtt_start ;
   unsigned long gtt_mappable_end ;
   unsigned long gtt_end ;
   struct io_mapping *gtt_mapping ;
   int gtt_mtrr ;
   struct shrinker inactive_shrinker ;
   struct list_head active_list ;
   struct list_head flushing_list ;
   struct list_head inactive_list ;
   struct list_head pinned_list ;
   struct list_head fence_list ;
   struct list_head deferred_free_list ;
   struct delayed_work retire_work ;
   bool interruptible ;
   int suspended ;
   atomic_t wedged ;
   uint32_t bit_6_swizzle_x ;
   uint32_t bit_6_swizzle_y ;
   struct drm_i915_gem_phys_object *phys_objs[3U] ;
   size_t gtt_total ;
   size_t mappable_gtt_total ;
   size_t object_memory ;
   u32 object_count ;
};
struct drm_i915_private {
   struct drm_device *dev ;
   struct intel_device_info const *info ;
   int has_gem ;
   int relative_constants_mode ;
   void *regs ;
   struct intel_gmbus *gmbus ;
   struct pci_dev *bridge_dev ;
   struct intel_ring_buffer ring[3U] ;
   uint32_t next_seqno ;
   drm_dma_handle_t *status_page_dmah ;
   uint32_t counter ;
   drm_local_map_t hws_map ;
   struct drm_i915_gem_object *pwrctx ;
   struct drm_i915_gem_object *renderctx ;
   struct resource mch_res ;
   unsigned int cpp ;
   int back_offset ;
   int front_offset ;
   int current_page ;
   int page_flipping ;
   atomic_t irq_received ;
   spinlock_t irq_lock ;
   u32 pipestat[2U] ;
   u32 irq_mask ;
   u32 gt_irq_mask ;
   u32 pch_irq_mask ;
   u32 hotplug_supported_mask ;
   struct work_struct hotplug_work ;
   int tex_lru_log_granularity ;
   int allow_batchbuffer ;
   struct mem_block *agp_heap ;
   unsigned int sr01 ;
   unsigned int adpa ;
   unsigned int ppcr ;
   unsigned int dvob ;
   unsigned int dvoc ;
   unsigned int lvds ;
   int vblank_pipe ;
   int num_pipe ;
   struct timer_list hangcheck_timer ;
   int hangcheck_count ;
   uint32_t last_acthd ;
   uint32_t last_instdone ;
   uint32_t last_instdone1 ;
   unsigned long cfb_size ;
   unsigned long cfb_pitch ;
   unsigned long cfb_offset ;
   int cfb_fence ;
   int cfb_plane ;
   int cfb_y ;
   struct intel_opregion opregion ;
   struct intel_overlay *overlay ;
   int backlight_level ;
   bool backlight_enabled ;
   struct drm_display_mode *panel_fixed_mode ;
   struct drm_display_mode *lfp_lvds_vbt_mode ;
   struct drm_display_mode *sdvo_lvds_vbt_mode ;
   unsigned char int_tv_support : 1 ;
   unsigned char lvds_dither : 1 ;
   unsigned char lvds_vbt : 1 ;
   unsigned char int_crt_support : 1 ;
   unsigned char lvds_use_ssc : 1 ;
   int lvds_ssc_freq ;
   struct __anonstruct_edp_184 edp ;
   bool no_aux_handshake ;
   struct notifier_block lid_notifier ;
   int crt_ddc_pin ;
   struct drm_i915_fence_reg fence_regs[16U] ;
   int fence_reg_start ;
   int num_fence_regs ;
   unsigned int fsb_freq ;
   unsigned int mem_freq ;
   unsigned int is_ddr3 ;
   spinlock_t error_lock ;
   struct drm_i915_error_state *first_error ;
   struct work_struct error_work ;
   struct completion error_completion ;
   struct workqueue_struct *wq ;
   struct drm_i915_display_funcs display ;
   enum intel_pch pch_type ;
   unsigned long quirks ;
   bool modeset_on_lid ;
   u8 saveLBB ;
   u32 saveDSPACNTR ;
   u32 saveDSPBCNTR ;
   u32 saveDSPARB ;
   u32 saveHWS ;
   u32 savePIPEACONF ;
   u32 savePIPEBCONF ;
   u32 savePIPEASRC ;
   u32 savePIPEBSRC ;
   u32 saveFPA0 ;
   u32 saveFPA1 ;
   u32 saveDPLL_A ;
   u32 saveDPLL_A_MD ;
   u32 saveHTOTAL_A ;
   u32 saveHBLANK_A ;
   u32 saveHSYNC_A ;
   u32 saveVTOTAL_A ;
   u32 saveVBLANK_A ;
   u32 saveVSYNC_A ;
   u32 saveBCLRPAT_A ;
   u32 saveTRANSACONF ;
   u32 saveTRANS_HTOTAL_A ;
   u32 saveTRANS_HBLANK_A ;
   u32 saveTRANS_HSYNC_A ;
   u32 saveTRANS_VTOTAL_A ;
   u32 saveTRANS_VBLANK_A ;
   u32 saveTRANS_VSYNC_A ;
   u32 savePIPEASTAT ;
   u32 saveDSPASTRIDE ;
   u32 saveDSPASIZE ;
   u32 saveDSPAPOS ;
   u32 saveDSPAADDR ;
   u32 saveDSPASURF ;
   u32 saveDSPATILEOFF ;
   u32 savePFIT_PGM_RATIOS ;
   u32 saveBLC_HIST_CTL ;
   u32 saveBLC_PWM_CTL ;
   u32 saveBLC_PWM_CTL2 ;
   u32 saveBLC_CPU_PWM_CTL ;
   u32 saveBLC_CPU_PWM_CTL2 ;
   u32 saveFPB0 ;
   u32 saveFPB1 ;
   u32 saveDPLL_B ;
   u32 saveDPLL_B_MD ;
   u32 saveHTOTAL_B ;
   u32 saveHBLANK_B ;
   u32 saveHSYNC_B ;
   u32 saveVTOTAL_B ;
   u32 saveVBLANK_B ;
   u32 saveVSYNC_B ;
   u32 saveBCLRPAT_B ;
   u32 saveTRANSBCONF ;
   u32 saveTRANS_HTOTAL_B ;
   u32 saveTRANS_HBLANK_B ;
   u32 saveTRANS_HSYNC_B ;
   u32 saveTRANS_VTOTAL_B ;
   u32 saveTRANS_VBLANK_B ;
   u32 saveTRANS_VSYNC_B ;
   u32 savePIPEBSTAT ;
   u32 saveDSPBSTRIDE ;
   u32 saveDSPBSIZE ;
   u32 saveDSPBPOS ;
   u32 saveDSPBADDR ;
   u32 saveDSPBSURF ;
   u32 saveDSPBTILEOFF ;
   u32 saveVGA0 ;
   u32 saveVGA1 ;
   u32 saveVGA_PD ;
   u32 saveVGACNTRL ;
   u32 saveADPA ;
   u32 saveLVDS ;
   u32 savePP_ON_DELAYS ;
   u32 savePP_OFF_DELAYS ;
   u32 saveDVOA ;
   u32 saveDVOB ;
   u32 saveDVOC ;
   u32 savePP_ON ;
   u32 savePP_OFF ;
   u32 savePP_CONTROL ;
   u32 savePP_DIVISOR ;
   u32 savePFIT_CONTROL ;
   u32 save_palette_a[256U] ;
   u32 save_palette_b[256U] ;
   u32 saveDPFC_CB_BASE ;
   u32 saveFBC_CFB_BASE ;
   u32 saveFBC_LL_BASE ;
   u32 saveFBC_CONTROL ;
   u32 saveFBC_CONTROL2 ;
   u32 saveIER ;
   u32 saveIIR ;
   u32 saveIMR ;
   u32 saveDEIER ;
   u32 saveDEIMR ;
   u32 saveGTIER ;
   u32 saveGTIMR ;
   u32 saveFDI_RXA_IMR ;
   u32 saveFDI_RXB_IMR ;
   u32 saveCACHE_MODE_0 ;
   u32 saveMI_ARB_STATE ;
   u32 saveSWF0[16U] ;
   u32 saveSWF1[16U] ;
   u32 saveSWF2[3U] ;
   u8 saveMSR ;
   u8 saveSR[8U] ;
   u8 saveGR[25U] ;
   u8 saveAR_INDEX ;
   u8 saveAR[21U] ;
   u8 saveDACMASK ;
   u8 saveCR[37U] ;
   uint64_t saveFENCE[16U] ;
   u32 saveCURACNTR ;
   u32 saveCURAPOS ;
   u32 saveCURABASE ;
   u32 saveCURBCNTR ;
   u32 saveCURBPOS ;
   u32 saveCURBBASE ;
   u32 saveCURSIZE ;
   u32 saveDP_B ;
   u32 saveDP_C ;
   u32 saveDP_D ;
   u32 savePIPEA_GMCH_DATA_M ;
   u32 savePIPEB_GMCH_DATA_M ;
   u32 savePIPEA_GMCH_DATA_N ;
   u32 savePIPEB_GMCH_DATA_N ;
   u32 savePIPEA_DP_LINK_M ;
   u32 savePIPEB_DP_LINK_M ;
   u32 savePIPEA_DP_LINK_N ;
   u32 savePIPEB_DP_LINK_N ;
   u32 saveFDI_RXA_CTL ;
   u32 saveFDI_TXA_CTL ;
   u32 saveFDI_RXB_CTL ;
   u32 saveFDI_TXB_CTL ;
   u32 savePFA_CTL_1 ;
   u32 savePFB_CTL_1 ;
   u32 savePFA_WIN_SZ ;
   u32 savePFB_WIN_SZ ;
   u32 savePFA_WIN_POS ;
   u32 savePFB_WIN_POS ;
   u32 savePCH_DREF_CONTROL ;
   u32 saveDISP_ARB_CTL ;
   u32 savePIPEA_DATA_M1 ;
   u32 savePIPEA_DATA_N1 ;
   u32 savePIPEA_LINK_M1 ;
   u32 savePIPEA_LINK_N1 ;
   u32 savePIPEB_DATA_M1 ;
   u32 savePIPEB_DATA_N1 ;
   u32 savePIPEB_LINK_M1 ;
   u32 savePIPEB_LINK_N1 ;
   u32 saveMCHBAR_RENDER_STANDBY ;
   struct __anonstruct_mm_185 mm ;
   struct sdvo_device_mapping sdvo_mappings[2U] ;
   unsigned int lvds_border_bits ;
   u32 pch_pf_pos ;
   u32 pch_pf_size ;
   int panel_t3 ;
   int panel_t12 ;
   struct drm_crtc *plane_to_crtc_mapping[2U] ;
   struct drm_crtc *pipe_to_crtc_mapping[2U] ;
   wait_queue_head_t pending_flip_queue ;
   bool flip_pending_is_done ;
   bool render_reclock_avail ;
   bool lvds_downclock_avail ;
   int lvds_downclock ;
   struct work_struct idle_work ;
   struct timer_list idle_timer ;
   bool busy ;
   u16 orig_clock ;
   int child_dev_num ;
   struct child_device_config *child_dev ;
   struct drm_connector *int_lvds_connector ;
   bool mchbar_need_disable ;
   struct work_struct rps_work ;
   spinlock_t rps_lock ;
   u32 pm_iir ;
   u8 cur_delay ;
   u8 min_delay ;
   u8 max_delay ;
   u8 fmax ;
   u8 fstart ;
   u64 last_count1 ;
   unsigned long last_time1 ;
   u64 last_count2 ;
   struct timespec last_time2 ;
   unsigned long gfx_power ;
   int c_m ;
   int r_t ;
   u8 corr ;
   spinlock_t *mchdev_lock ;
   enum no_fbc_reason no_fbc_reason ;
   struct drm_mm_node *compressed_fb ;
   struct drm_mm_node *compressed_llb ;
   unsigned long last_gpu_reset ;
   struct intel_fbdev *fbdev ;
   struct drm_property *broadcast_rgb_property ;
   struct drm_property *force_audio_property ;
   atomic_t forcewake_count ;
};
typedef struct drm_i915_private drm_i915_private_t;
struct drm_i915_gem_object {
   struct drm_gem_object base ;
   struct drm_mm_node *gtt_space ;
   struct list_head gtt_list ;
   struct list_head ring_list ;
   struct list_head mm_list ;
   struct list_head gpu_write_list ;
   struct list_head exec_list ;
   unsigned char active : 1 ;
   unsigned char dirty : 1 ;
   unsigned char pending_gpu_write : 1 ;
   signed char fence_reg : 5 ;
   unsigned char madv : 2 ;
   unsigned char tiling_mode : 2 ;
   unsigned char tiling_changed : 1 ;
   unsigned char pin_count : 4 ;
   unsigned char map_and_fenceable : 1 ;
   unsigned char fault_mappable : 1 ;
   unsigned char pin_mappable : 1 ;
   unsigned char pending_fenced_gpu_access : 1 ;
   unsigned char fenced_gpu_access : 1 ;
   unsigned char cache_level : 2 ;
   struct page **pages ;
   struct scatterlist *sg_list ;
   int num_sg ;
   struct hlist_node exec_node ;
   unsigned long exec_handle ;
   struct drm_i915_gem_exec_object2 *exec_entry ;
   uint32_t gtt_offset ;
   uint32_t last_rendering_seqno ;
   struct intel_ring_buffer *ring ;
   uint32_t last_fenced_seqno ;
   struct intel_ring_buffer *last_fenced_ring ;
   uint32_t stride ;
   unsigned long *bit_17 ;
   uint8_t *page_cpu_valid ;
   uint32_t user_pin_count ;
   struct drm_file *pin_filp ;
   struct drm_i915_gem_phys_object *phys_obj ;
   atomic_t pending_flip ;
};
struct drm_fb_helper;
struct drm_fb_helper_crtc {
   uint32_t crtc_id ;
   struct drm_mode_set mode_set ;
   struct drm_display_mode *desired_mode ;
};
struct drm_fb_helper_surface_size {
   u32 fb_width ;
   u32 fb_height ;
   u32 surface_width ;
   u32 surface_height ;
   u32 surface_bpp ;
   u32 surface_depth ;
};
struct drm_fb_helper_funcs {
   void (*gamma_set)(struct drm_crtc * , u16 , u16 , u16 , int ) ;
   void (*gamma_get)(struct drm_crtc * , u16 * , u16 * , u16 * , int ) ;
   int (*fb_probe)(struct drm_fb_helper * , struct drm_fb_helper_surface_size * ) ;
};
struct drm_fb_helper_connector {
   struct drm_connector *connector ;
   struct drm_cmdline_mode cmdline_mode ;
};
struct drm_fb_helper {
   struct drm_framebuffer *fb ;
   struct drm_framebuffer *saved_fb ;
   struct drm_device *dev ;
   struct drm_display_mode *mode ;
   int crtc_count ;
   struct drm_fb_helper_crtc *crtc_info ;
   int connector_count ;
   struct drm_fb_helper_connector **connector_info ;
   struct drm_fb_helper_funcs *funcs ;
   int conn_limit ;
   struct fb_info *fbdev ;
   u32 pseudo_palette[17U] ;
   struct list_head kernel_fb_list ;
   bool delayed_hotplug ;
};
struct intel_framebuffer {
   struct drm_framebuffer base ;
   struct drm_i915_gem_object *obj ;
};
struct intel_fbdev {
   struct drm_fb_helper helper ;
   struct intel_framebuffer ifb ;
   struct list_head fbdev_list ;
   struct drm_display_mode *our_mode ;
};
enum hrtimer_restart;
enum hrtimer_restart;
typedef unsigned int drm_handle_t;
struct drm_tex_region {
   unsigned char next ;
   unsigned char prev ;
   unsigned char in_use ;
   unsigned char padding ;
   unsigned int age ;
};
struct _drm_i915_sarea;
struct drm_i915_master_private {
   drm_local_map_t *sarea ;
   struct _drm_i915_sarea *sarea_priv ;
};
struct drm_i915_file_private;
struct __anonstruct_mm_186 {
   struct spinlock lock ;
   struct list_head request_list ;
};
struct drm_i915_file_private {
   struct __anonstruct_mm_186 mm ;
};
enum ldv_26036 {
    I915_INIT_DMA = 1,
    I915_CLEANUP_DMA = 2,
    I915_RESUME_DMA = 3
} ;
struct _drm_i915_init {
   enum ldv_26036 func ;
   unsigned int mmio_offset ;
   int sarea_priv_offset ;
   unsigned int ring_start ;
   unsigned int ring_end ;
   unsigned int ring_size ;
   unsigned int front_offset ;
   unsigned int back_offset ;
   unsigned int depth_offset ;
   unsigned int w ;
   unsigned int h ;
   unsigned int pitch ;
   unsigned int pitch_bits ;
   unsigned int back_pitch ;
   unsigned int depth_pitch ;
   unsigned int cpp ;
   unsigned int chipset ;
};
typedef struct _drm_i915_init drm_i915_init_t;
struct _drm_i915_sarea {
   struct drm_tex_region texList[256U] ;
   int last_upload ;
   int last_enqueue ;
   int last_dispatch ;
   int ctxOwner ;
   int texAge ;
   int pf_enabled ;
   int pf_active ;
   int pf_current_page ;
   int perf_boxes ;
   int width ;
   int height ;
   drm_handle_t front_handle ;
   int front_offset ;
   int front_size ;
   drm_handle_t back_handle ;
   int back_offset ;
   int back_size ;
   drm_handle_t depth_handle ;
   int depth_offset ;
   int depth_size ;
   drm_handle_t tex_handle ;
   int tex_offset ;
   int tex_size ;
   int log_tex_granularity ;
   int pitch ;
   int rotation ;
   int rotated_offset ;
   int rotated_size ;
   int rotated_pitch ;
   int virtualX ;
   int virtualY ;
   unsigned int front_tiled ;
   unsigned int back_tiled ;
   unsigned int depth_tiled ;
   unsigned int rotated_tiled ;
   unsigned int rotated2_tiled ;
   int pipeA_x ;
   int pipeA_y ;
   int pipeA_w ;
   int pipeA_h ;
   int pipeB_x ;
   int pipeB_y ;
   int pipeB_w ;
   int pipeB_h ;
   drm_handle_t unused_handle ;
   __u32 unused1 ;
   __u32 unused2 ;
   __u32 unused3 ;
   __u32 front_bo_handle ;
   __u32 back_bo_handle ;
   __u32 unused_bo_handle ;
   __u32 depth_bo_handle ;
};
typedef struct _drm_i915_sarea drm_i915_sarea_t;
struct drm_i915_batchbuffer {
   int start ;
   int used ;
   int DR1 ;
   int DR4 ;
   int num_cliprects ;
   struct drm_clip_rect *cliprects ;
};
typedef struct drm_i915_batchbuffer drm_i915_batchbuffer_t;
struct _drm_i915_cmdbuffer {
   char *buf ;
   int sz ;
   int DR1 ;
   int DR4 ;
   int num_cliprects ;
   struct drm_clip_rect *cliprects ;
};
typedef struct _drm_i915_cmdbuffer drm_i915_cmdbuffer_t;
struct drm_i915_getparam {
   int param ;
   int *value ;
};
typedef struct drm_i915_getparam drm_i915_getparam_t;
struct drm_i915_setparam {
   int param ;
   int value ;
};
typedef struct drm_i915_setparam drm_i915_setparam_t;
struct drm_i915_hws_addr {
   __u64 addr ;
};
typedef struct drm_i915_hws_addr drm_i915_hws_addr_t;
enum vga_switcheroo_state {
    VGA_SWITCHEROO_OFF = 0,
    VGA_SWITCHEROO_ON = 1
} ;
struct cparams {
   u16 i ;
   u16 t ;
   u16 m ;
   u16 c ;
};
struct v_table {
   u16 vd ;
   u16 vm ;
};
typedef __s16 int16_t;
struct paravirt_callee_save {
   void *func ;
};
struct pv_irq_ops {
   struct paravirt_callee_save save_fl ;
   struct paravirt_callee_save restore_fl ;
   struct paravirt_callee_save irq_disable ;
   struct paravirt_callee_save irq_enable ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
   void (*adjust_exception_frame)(void) ;
};
struct __wait_queue;
typedef struct __wait_queue wait_queue_t;
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int , int , void * ) ;
   struct list_head task_list ;
};
enum hrtimer_restart;
enum hrtimer_restart;
enum kobject_action {
    KOBJ_ADD = 0,
    KOBJ_REMOVE = 1,
    KOBJ_CHANGE = 2,
    KOBJ_MOVE = 3,
    KOBJ_ONLINE = 4,
    KOBJ_OFFLINE = 5,
    KOBJ_MAX = 6
} ;
struct drm_i915_irq_emit {
   int *irq_seq ;
};
typedef struct drm_i915_irq_emit drm_i915_irq_emit_t;
struct drm_i915_irq_wait {
   int irq_seq ;
};
typedef struct drm_i915_irq_wait drm_i915_irq_wait_t;
struct drm_i915_vblank_pipe {
   int pipe ;
};
typedef struct drm_i915_vblank_pipe drm_i915_vblank_pipe_t;
enum pipe {
    PIPE_A = 0,
    PIPE_B = 1,
    PIPE_C = 2,
    I915_MAX_PIPES = 3
} ;
enum plane {
    PLANE_A = 0,
    PLANE_B = 1,
    PLANE_C = 2
} ;
struct drm_i915_gem_request {
   struct intel_ring_buffer *ring ;
   uint32_t seqno ;
   unsigned long emitted_jiffies ;
   struct list_head list ;
   struct drm_i915_file_private *file_priv ;
   struct list_head client_list ;
};
struct intel_encoder {
   struct drm_encoder base ;
   int type ;
   bool needs_tv_clock ;
   void (*hot_plug)(struct intel_encoder * ) ;
   int crtc_mask ;
   int clone_mask ;
};
struct intel_unpin_work;
struct intel_crtc {
   struct drm_crtc base ;
   enum pipe pipe ;
   enum plane plane ;
   u8 lut_r[256U] ;
   u8 lut_g[256U] ;
   u8 lut_b[256U] ;
   int dpms_mode ;
   bool active ;
   bool busy ;
   struct timer_list idle_timer ;
   bool lowfreq_avail ;
   struct intel_overlay *overlay ;
   struct intel_unpin_work *unpin_work ;
   int fdi_lanes ;
   struct drm_i915_gem_object *cursor_bo ;
   uint32_t cursor_addr ;
   int16_t cursor_x ;
   int16_t cursor_y ;
   int16_t cursor_width ;
   int16_t cursor_height ;
   bool cursor_visible ;
};
struct intel_unpin_work {
   struct work_struct work ;
   struct drm_device *dev ;
   struct drm_i915_gem_object *old_fb_obj ;
   struct drm_i915_gem_object *pending_flip_obj ;
   struct drm_pending_vblank_event *event ;
   int pending ;
   bool enable_stall_check ;
};
enum hrtimer_restart;
enum hrtimer_restart;
struct drm_i915_mem_alloc {
   int region ;
   int alignment ;
   int size ;
   int *region_offset ;
};
typedef struct drm_i915_mem_alloc drm_i915_mem_alloc_t;
struct drm_i915_mem_free {
   int region ;
   int region_offset ;
};
typedef struct drm_i915_mem_free drm_i915_mem_free_t;
struct drm_i915_mem_init_heap {
   int region ;
   int size ;
   int start ;
};
typedef struct drm_i915_mem_init_heap drm_i915_mem_init_heap_t;
struct drm_i915_mem_destroy_heap {
   int region ;
};
typedef struct drm_i915_mem_destroy_heap drm_i915_mem_destroy_heap_t;
typedef unsigned long uintptr_t;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
struct __large_struct {
   unsigned long buf[100U] ;
};
struct drm_gem_mm {
   struct drm_mm offset_manager ;
   struct drm_open_hash offset_hash ;
};
struct drm_i915_gem_init {
   __u64 gtt_start ;
   __u64 gtt_end ;
};
struct drm_i915_gem_create {
   __u64 size ;
   __u32 handle ;
   __u32 pad ;
};
struct drm_i915_gem_pread {
   __u32 handle ;
   __u32 pad ;
   __u64 offset ;
   __u64 size ;
   __u64 data_ptr ;
};
struct drm_i915_gem_pwrite {
   __u32 handle ;
   __u32 pad ;
   __u64 offset ;
   __u64 size ;
   __u64 data_ptr ;
};
struct drm_i915_gem_mmap {
   __u32 handle ;
   __u32 pad ;
   __u64 offset ;
   __u64 size ;
   __u64 addr_ptr ;
};
struct drm_i915_gem_mmap_gtt {
   __u32 handle ;
   __u32 pad ;
   __u64 offset ;
};
struct drm_i915_gem_set_domain {
   __u32 handle ;
   __u32 read_domains ;
   __u32 write_domain ;
};
struct drm_i915_gem_sw_finish {
   __u32 handle ;
};
struct drm_i915_gem_pin {
   __u32 handle ;
   __u32 pad ;
   __u64 alignment ;
   __u64 offset ;
};
struct drm_i915_gem_busy {
   __u32 handle ;
   __u32 busy ;
};
struct drm_i915_gem_get_aperture {
   __u64 aper_size ;
   __u64 aper_available_size ;
};
struct drm_i915_gem_madvise {
   __u32 handle ;
   __u32 madv ;
   __u32 retained ;
};
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
struct cgroupfs_root;
struct cgroup;
struct css_id;
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   atomic_t refcnt ;
   unsigned long flags ;
   struct css_id *id ;
};
struct cgroup {
   unsigned long flags ;
   atomic_t count ;
   struct list_head sibling ;
   struct list_head children ;
   struct cgroup *parent ;
   struct dentry *dentry ;
   struct cgroup_subsys_state *subsys[64U] ;
   struct cgroupfs_root *root ;
   struct cgroup *top_cgroup ;
   struct list_head css_sets ;
   struct list_head release_list ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   struct rcu_head rcu_head ;
   struct list_head event_list ;
   spinlock_t event_list_lock ;
};
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head cg_links ;
   struct cgroup_subsys_state *subsys[64U] ;
   struct rcu_head rcu_head ;
};
struct reclaim_state {
   unsigned long reclaimed_slab ;
};
union __anonunion_v_193 {
   short preferred_node ;
   nodemask_t nodes ;
};
union __anonunion_w_194 {
   nodemask_t cpuset_mems_allowed ;
   nodemask_t user_nodemask ;
};
struct mempolicy {
   atomic_t refcnt ;
   unsigned short mode ;
   unsigned short flags ;
   union __anonunion_v_193 v ;
   union __anonunion_w_194 w ;
};
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
struct drm_i915_gem_relocation_entry {
   __u32 target_handle ;
   __u32 delta ;
   __u64 offset ;
   __u64 presumed_offset ;
   __u32 read_domains ;
   __u32 write_domain ;
};
struct drm_i915_gem_exec_object {
   __u32 handle ;
   __u32 relocation_count ;
   __u64 relocs_ptr ;
   __u64 alignment ;
   __u64 offset ;
};
struct drm_i915_gem_execbuffer {
   __u64 buffers_ptr ;
   __u32 buffer_count ;
   __u32 batch_start_offset ;
   __u32 batch_len ;
   __u32 DR1 ;
   __u32 DR4 ;
   __u32 num_cliprects ;
   __u64 cliprects_ptr ;
};
struct drm_i915_gem_execbuffer2 {
   __u64 buffers_ptr ;
   __u32 buffer_count ;
   __u32 batch_start_offset ;
   __u32 batch_len ;
   __u32 DR1 ;
   __u32 DR4 ;
   __u32 num_cliprects ;
   __u64 cliprects_ptr ;
   __u64 flags ;
   __u64 rsvd1 ;
   __u64 rsvd2 ;
};
struct change_domains {
   uint32_t invalidate_domains ;
   uint32_t flush_domains ;
   uint32_t flush_rings ;
   uint32_t flips ;
};
struct eb_objects {
   int and ;
   struct hlist_head buckets[0U] ;
};
enum hrtimer_restart;
enum hrtimer_restart;
enum i915_cache_level {
    I915_CACHE_NONE = 0,
    I915_CACHE_LLC = 1,
    I915_CACHE_LLC_MLC = 2
} ;
enum hrtimer_restart;
enum hrtimer_restart;
struct drm_i915_gem_set_tiling {
   __u32 handle ;
   __u32 tiling_mode ;
   __u32 stride ;
   __u32 swizzle_mode ;
};
struct drm_i915_gem_get_tiling {
   __u32 handle ;
   __u32 tiling_mode ;
   __u32 swizzle_mode ;
};
enum hrtimer_restart;
enum hrtimer_restart;
struct net;
struct uts_namespace;
struct ring_buffer_iter;
struct trace_seq;
struct trace_seq {
   unsigned char buffer[4096U] ;
   unsigned int len ;
   unsigned int readpos ;
   int full ;
};
union __anonunion_ldv_37100_187 {
   __u64 sample_period ;
   __u64 sample_freq ;
};
union __anonunion_ldv_37125_188 {
   __u32 wakeup_events ;
   __u32 wakeup_watermark ;
};
union __anonunion_ldv_37130_189 {
   __u64 bp_addr ;
   __u64 config1 ;
};
union __anonunion_ldv_37134_190 {
   __u64 bp_len ;
   __u64 config2 ;
};
struct perf_event_attr {
   __u32 type ;
   __u32 size ;
   __u64 config ;
   union __anonunion_ldv_37100_187 ldv_37100 ;
   __u64 sample_type ;
   __u64 read_format ;
   unsigned char disabled : 1 ;
   unsigned char inherit : 1 ;
   unsigned char pinned : 1 ;
   unsigned char exclusive : 1 ;
   unsigned char exclude_user : 1 ;
   unsigned char exclude_kernel : 1 ;
   unsigned char exclude_hv : 1 ;
   unsigned char exclude_idle : 1 ;
   unsigned char mmap : 1 ;
   unsigned char comm : 1 ;
   unsigned char freq : 1 ;
   unsigned char inherit_stat : 1 ;
   unsigned char enable_on_exec : 1 ;
   unsigned char task : 1 ;
   unsigned char watermark : 1 ;
   unsigned char precise_ip : 2 ;
   unsigned char mmap_data : 1 ;
   unsigned char sample_id_all : 1 ;
   unsigned long __reserved_1 : 45 ;
   union __anonunion_ldv_37125_188 ldv_37125 ;
   __u32 bp_type ;
   union __anonunion_ldv_37130_189 ldv_37130 ;
   union __anonunion_ldv_37134_190 ldv_37134 ;
};
struct perf_event_mmap_page {
   __u32 version ;
   __u32 compat_version ;
   __u32 lock ;
   __u32 index ;
   __s64 offset ;
   __u64 time_enabled ;
   __u64 time_running ;
   __u64 __reserved[123U] ;
   __u64 data_head ;
   __u64 data_tail ;
};
struct __anonstruct_local_t_194 {
   atomic_long_t a ;
};
typedef struct __anonstruct_local_t_194 local_t;
struct __anonstruct_local64_t_195 {
   local_t a ;
};
typedef struct __anonstruct_local64_t_195 local64_t;
struct arch_hw_breakpoint {
   unsigned long address ;
   u8 len ;
   u8 type ;
};
struct pmu;
struct mnt_namespace;
struct ipc_namespace;
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns ;
   struct net *net_ns ;
};
struct pidmap {
   atomic_t nr_free ;
   void *page ;
};
struct bsd_acct_struct;
struct pid_namespace {
   struct kref kref ;
   struct pidmap pidmap[128U] ;
   int last_pid ;
   struct task_struct *child_reaper ;
   struct kmem_cache *pid_cachep ;
   unsigned int level ;
   struct pid_namespace *parent ;
   struct vfsmount *proc_mnt ;
   struct bsd_acct_struct *bacct ;
};
struct ftrace_ret_stack {
   unsigned long ret ;
   unsigned long func ;
   unsigned long long calltime ;
   unsigned long long subtime ;
   unsigned long fp ;
};
struct irq_work {
   struct irq_work *next ;
   void (*func)(struct irq_work * ) ;
};
struct perf_callchain_entry {
   __u64 nr ;
   __u64 ip[255U] ;
};
struct perf_raw_record {
   u32 size ;
   void *data ;
};
struct __anonstruct_ldv_38574_199 {
   u64 config ;
   u64 last_tag ;
   unsigned long config_base ;
   unsigned long event_base ;
   int idx ;
   int last_cpu ;
   unsigned int extra_reg ;
   u64 extra_config ;
   int extra_alloc ;
};
struct __anonstruct_ldv_38577_200 {
   struct hrtimer hrtimer ;
};
struct __anonstruct_ldv_38582_201 {
   struct arch_hw_breakpoint info ;
   struct list_head bp_list ;
   struct task_struct *bp_target ;
};
union __anonunion_ldv_38583_198 {
   struct __anonstruct_ldv_38574_199 ldv_38574 ;
   struct __anonstruct_ldv_38577_200 ldv_38577 ;
   struct __anonstruct_ldv_38582_201 ldv_38582 ;
};
struct hw_perf_event {
   union __anonunion_ldv_38583_198 ldv_38583 ;
   int state ;
   local64_t prev_count ;
   u64 sample_period ;
   u64 last_period ;
   local64_t period_left ;
   u64 interrupts ;
   u64 freq_time_stamp ;
   u64 freq_count_stamp ;
};
struct perf_cpu_context;
struct pmu {
   struct list_head entry ;
   struct device *dev ;
   char *name ;
   int type ;
   int *pmu_disable_count ;
   struct perf_cpu_context *pmu_cpu_context ;
   int task_ctx_nr ;
   void (*pmu_enable)(struct pmu * ) ;
   void (*pmu_disable)(struct pmu * ) ;
   int (*event_init)(struct perf_event * ) ;
   int (*add)(struct perf_event * , int ) ;
   void (*del)(struct perf_event * , int ) ;
   void (*start)(struct perf_event * , int ) ;
   void (*stop)(struct perf_event * , int ) ;
   void (*read)(struct perf_event * ) ;
   void (*start_txn)(struct pmu * ) ;
   int (*commit_txn)(struct pmu * ) ;
   void (*cancel_txn)(struct pmu * ) ;
};
enum perf_event_active_state {
    PERF_EVENT_STATE_ERROR = -2,
    PERF_EVENT_STATE_OFF = -1,
    PERF_EVENT_STATE_INACTIVE = 0,
    PERF_EVENT_STATE_ACTIVE = 1
} ;
struct perf_buffer {
   atomic_t refcount ;
   struct rcu_head rcu_head ;
   struct work_struct work ;
   int page_order ;
   int nr_pages ;
   int writable ;
   atomic_t poll ;
   local_t head ;
   local_t nest ;
   local_t events ;
   local_t wakeup ;
   local_t lost ;
   long watermark ;
   struct perf_event_mmap_page *user_page ;
   void *data_pages[0U] ;
};
struct perf_sample_data;
struct perf_cgroup_info {
   u64 time ;
   u64 timestamp ;
};
struct perf_cgroup {
   struct cgroup_subsys_state css ;
   struct perf_cgroup_info *info ;
};
struct event_filter;
struct perf_event {
   struct list_head group_entry ;
   struct list_head event_entry ;
   struct list_head sibling_list ;
   struct hlist_node hlist_entry ;
   int nr_siblings ;
   int group_flags ;
   struct perf_event *group_leader ;
   struct pmu *pmu ;
   enum perf_event_active_state state ;
   unsigned int attach_state ;
   local64_t count ;
   atomic64_t child_count ;
   u64 total_time_enabled ;
   u64 total_time_running ;
   u64 tstamp_enabled ;
   u64 tstamp_running ;
   u64 tstamp_stopped ;
   u64 shadow_ctx_time ;
   struct perf_event_attr attr ;
   u16 header_size ;
   u16 id_header_size ;
   u16 read_size ;
   struct hw_perf_event hw ;
   struct perf_event_context *ctx ;
   struct file *filp ;
   atomic64_t child_total_time_enabled ;
   atomic64_t child_total_time_running ;
   struct mutex child_mutex ;
   struct list_head child_list ;
   struct perf_event *parent ;
   int oncpu ;
   int cpu ;
   struct list_head owner_entry ;
   struct task_struct *owner ;
   struct mutex mmap_mutex ;
   atomic_t mmap_count ;
   int mmap_locked ;
   struct user_struct *mmap_user ;
   struct perf_buffer *buffer ;
   wait_queue_head_t waitq ;
   struct fasync_struct *fasync ;
   int pending_wakeup ;
   int pending_kill ;
   int pending_disable ;
   struct irq_work pending ;
   atomic_t event_limit ;
   void (*destroy)(struct perf_event * ) ;
   struct rcu_head rcu_head ;
   struct pid_namespace *ns ;
   u64 id ;
   void (*overflow_handler)(struct perf_event * , int , struct perf_sample_data * ,
                            struct pt_regs * ) ;
   struct ftrace_event_call *tp_event ;
   struct event_filter *filter ;
   struct perf_cgroup *cgrp ;
   int cgrp_defer_enabled ;
};
enum perf_event_context_type {
    task_context = 0,
    cpu_context = 1
} ;
struct perf_event_context {
   struct pmu *pmu ;
   enum perf_event_context_type type ;
   raw_spinlock_t lock ;
   struct mutex mutex ;
   struct list_head pinned_groups ;
   struct list_head flexible_groups ;
   struct list_head event_list ;
   int nr_events ;
   int nr_active ;
   int is_active ;
   int nr_stat ;
   int rotate_disable ;
   atomic_t refcount ;
   struct task_struct *task ;
   u64 time ;
   u64 timestamp ;
   struct perf_event_context *parent_ctx ;
   u64 parent_gen ;
   u64 generation ;
   int pin_count ;
   struct rcu_head rcu_head ;
   int nr_cgroups ;
};
struct perf_cpu_context {
   struct perf_event_context ctx ;
   struct perf_event_context *task_ctx ;
   int active_oncpu ;
   int exclusive ;
   struct list_head rotation_list ;
   int jiffies_interval ;
   struct pmu *active_pmu ;
   struct perf_cgroup *cgrp ;
};
struct __anonstruct_tid_entry_202 {
   u32 pid ;
   u32 tid ;
};
struct __anonstruct_cpu_entry_203 {
   u32 cpu ;
   u32 reserved ;
};
struct perf_sample_data {
   u64 type ;
   u64 ip ;
   struct __anonstruct_tid_entry_202 tid_entry ;
   u64 time ;
   u64 addr ;
   u64 id ;
   u64 stream_id ;
   struct __anonstruct_cpu_entry_203 cpu_entry ;
   u64 period ;
   struct perf_callchain_entry *callchain ;
   struct perf_raw_record *raw ;
};
struct trace_array;
struct tracer;
struct trace_entry {
   unsigned short type ;
   unsigned char flags ;
   unsigned char preempt_count ;
   int pid ;
   int padding ;
};
struct trace_iterator {
   struct trace_array *tr ;
   struct tracer *trace ;
   void *private ;
   int cpu_file ;
   struct mutex mutex ;
   struct ring_buffer_iter *buffer_iter[4096U] ;
   unsigned long iter_flags ;
   struct trace_seq tmp_seq ;
   struct trace_seq seq ;
   struct trace_entry *ent ;
   unsigned long lost_events ;
   int leftover ;
   int cpu ;
   u64 ts ;
   loff_t pos ;
   long idx ;
   cpumask_var_t started ;
};
struct trace_event;
enum print_line_t;
enum print_line_t;
struct trace_event_functions {
   enum print_line_t (*trace)(struct trace_iterator * , int , struct trace_event * ) ;
   enum print_line_t (*raw)(struct trace_iterator * , int , struct trace_event * ) ;
   enum print_line_t (*hex)(struct trace_iterator * , int , struct trace_event * ) ;
   enum print_line_t (*binary)(struct trace_iterator * , int , struct trace_event * ) ;
};
struct trace_event {
   struct hlist_node node ;
   struct list_head list ;
   int type ;
   struct trace_event_functions *funcs ;
};
enum print_line_t {
    TRACE_TYPE_PARTIAL_LINE = 0,
    TRACE_TYPE_HANDLED = 1,
    TRACE_TYPE_UNHANDLED = 2,
    TRACE_TYPE_NO_CONSUME = 3
} ;
enum trace_reg {
    TRACE_REG_REGISTER = 0,
    TRACE_REG_UNREGISTER = 1,
    TRACE_REG_PERF_REGISTER = 2,
    TRACE_REG_PERF_UNREGISTER = 3
} ;
struct ftrace_event_class {
   char *system ;
   void *probe ;
   void *perf_probe ;
   int (*reg)(struct ftrace_event_call * , enum trace_reg ) ;
   int (*define_fields)(struct ftrace_event_call * ) ;
   struct list_head *(*get_fields)(struct ftrace_event_call * ) ;
   struct list_head fields ;
   int (*raw_init)(struct ftrace_event_call * ) ;
};
struct ftrace_event_call {
   struct list_head list ;
   struct ftrace_event_class *class ;
   char *name ;
   struct dentry *dir ;
   struct trace_event event ;
   char const *print_fmt ;
   struct event_filter *filter ;
   void *mod ;
   void *data ;
   unsigned int flags ;
   int perf_refcount ;
   struct hlist_head *perf_events ;
};
enum hrtimer_restart;
enum hrtimer_restart;
enum mode_set_atomic {
    LEAVE_ATOMIC_MODE_SET = 0,
    ENTER_ATOMIC_MODE_SET = 1
} ;
struct drm_crtc_helper_funcs {
   void (*dpms)(struct drm_crtc * , int ) ;
   void (*prepare)(struct drm_crtc * ) ;
   void (*commit)(struct drm_crtc * ) ;
   bool (*mode_fixup)(struct drm_crtc * , struct drm_display_mode * , struct drm_display_mode * ) ;
   int (*mode_set)(struct drm_crtc * , struct drm_display_mode * , struct drm_display_mode * ,
                   int , int , struct drm_framebuffer * ) ;
   int (*mode_set_base)(struct drm_crtc * , int , int , struct drm_framebuffer * ) ;
   int (*mode_set_base_atomic)(struct drm_crtc * , struct drm_framebuffer * , int ,
                               int , enum mode_set_atomic ) ;
   void (*load_lut)(struct drm_crtc * ) ;
   void (*disable)(struct drm_crtc * ) ;
};
struct drm_encoder_helper_funcs {
   void (*dpms)(struct drm_encoder * , int ) ;
   void (*save)(struct drm_encoder * ) ;
   void (*restore)(struct drm_encoder * ) ;
   bool (*mode_fixup)(struct drm_encoder * , struct drm_display_mode * , struct drm_display_mode * ) ;
   void (*prepare)(struct drm_encoder * ) ;
   void (*commit)(struct drm_encoder * ) ;
   void (*mode_set)(struct drm_encoder * , struct drm_display_mode * , struct drm_display_mode * ) ;
   struct drm_crtc *(*get_crtc)(struct drm_encoder * ) ;
   enum drm_connector_status (*detect)(struct drm_encoder * , struct drm_connector * ) ;
   void (*disable)(struct drm_encoder * ) ;
};
struct intel_connector {
   struct drm_connector base ;
   struct intel_encoder *encoder ;
};
struct intel_load_detect_pipe {
   struct drm_framebuffer *release_fb ;
   bool load_detect_temp ;
   int dpms_mode ;
};
struct drm_i915_get_pipe_from_crtc_id {
   __u32 crtc_id ;
   __u32 pipe ;
};
struct __anonstruct_intel_clock_t_190 {
   int n ;
   int m1 ;
   int m2 ;
   int p1 ;
   int p2 ;
   int dot ;
   int vco ;
   int m ;
   int p ;
};
typedef struct __anonstruct_intel_clock_t_190 intel_clock_t;
struct __anonstruct_intel_range_t_191 {
   int min ;
   int max ;
};
typedef struct __anonstruct_intel_range_t_191 intel_range_t;
struct __anonstruct_intel_p2_t_192 {
   int dot_limit ;
   int p2_slow ;
   int p2_fast ;
};
typedef struct __anonstruct_intel_p2_t_192 intel_p2_t;
struct intel_limit;
typedef struct intel_limit intel_limit_t;
struct intel_limit {
   intel_range_t dot ;
   intel_range_t vco ;
   intel_range_t n ;
   intel_range_t m ;
   intel_range_t m1 ;
   intel_range_t m2 ;
   intel_range_t p ;
   intel_range_t p1 ;
   intel_p2_t p2 ;
   bool (*find_pll)(intel_limit_t const * , struct drm_crtc * , int , int , intel_clock_t * ) ;
};
struct fdi_m_n {
   u32 tu ;
   u32 gmch_m ;
   u32 gmch_n ;
   u32 link_m ;
   u32 link_n ;
};
struct intel_watermark_params {
   unsigned long fifo_size ;
   unsigned long max_wm ;
   unsigned long default_wm ;
   unsigned long guard_size ;
   unsigned long cacheline_size ;
};
struct cxsr_latency {
   int is_desktop ;
   int is_ddr3 ;
   unsigned long fsb_freq ;
   unsigned long mem_freq ;
   unsigned long display_sr ;
   unsigned long display_hpll_disable ;
   unsigned long cursor_sr ;
   unsigned long cursor_hpll_disable ;
};
struct intel_quirk {
   int device ;
   int subsystem_vendor ;
   int subsystem_device ;
   void (*hook)(struct drm_device * ) ;
};
struct intel_cursor_error_state {
   u32 control ;
   u32 position ;
   u32 base ;
   u32 size ;
};
struct intel_pipe_error_state {
   u32 conf ;
   u32 source ;
   u32 htotal ;
   u32 hblank ;
   u32 hsync ;
   u32 vtotal ;
   u32 vblank ;
   u32 vsync ;
};
struct intel_plane_error_state {
   u32 control ;
   u32 stride ;
   u32 size ;
   u32 pos ;
   u32 addr ;
   u32 surface ;
   u32 tile_offset ;
};
struct intel_display_error_state {
   struct intel_cursor_error_state cursor[2U] ;
   struct intel_pipe_error_state pipe[2U] ;
   struct intel_plane_error_state plane[2U] ;
};
typedef __u16 __le16;
enum hrtimer_restart;
enum hrtimer_restart;
struct edid;
struct drm_connector_helper_funcs {
   int (*get_modes)(struct drm_connector * ) ;
   int (*mode_valid)(struct drm_connector * , struct drm_display_mode * ) ;
   struct drm_encoder *(*best_encoder)(struct drm_connector * ) ;
};
struct est_timings {
   u8 t1 ;
   u8 t2 ;
   u8 mfg_rsvd ;
};
struct std_timing {
   u8 hsize ;
   u8 vfreq_aspect ;
};
struct detailed_pixel_timing {
   u8 hactive_lo ;
   u8 hblank_lo ;
   u8 hactive_hblank_hi ;
   u8 vactive_lo ;
   u8 vblank_lo ;
   u8 vactive_vblank_hi ;
   u8 hsync_offset_lo ;
   u8 hsync_pulse_width_lo ;
   u8 vsync_offset_pulse_width_lo ;
   u8 hsync_vsync_offset_pulse_width_hi ;
   u8 width_mm_lo ;
   u8 height_mm_lo ;
   u8 width_height_mm_hi ;
   u8 hborder ;
   u8 vborder ;
   u8 misc ;
};
struct detailed_data_string {
   u8 str[13U] ;
};
struct detailed_data_monitor_range {
   u8 min_vfreq ;
   u8 max_vfreq ;
   u8 min_hfreq_khz ;
   u8 max_hfreq_khz ;
   u8 pixel_clock_mhz ;
   __le16 sec_gtf_toggle ;
   u8 hfreq_start_khz ;
   u8 c ;
   __le16 m ;
   u8 k ;
   u8 j ;
};
struct detailed_data_wpindex {
   u8 white_yx_lo ;
   u8 white_x_hi ;
   u8 white_y_hi ;
   u8 gamma ;
};
struct cvt_timing {
   u8 code[3U] ;
};
union __anonunion_data_184 {
   struct detailed_data_string str ;
   struct detailed_data_monitor_range range ;
   struct detailed_data_wpindex color ;
   struct std_timing timings[6U] ;
   struct cvt_timing cvt[4U] ;
};
struct detailed_non_pixel {
   u8 pad1 ;
   u8 type ;
   u8 pad2 ;
   union __anonunion_data_184 data ;
};
union __anonunion_data_185 {
   struct detailed_pixel_timing pixel_data ;
   struct detailed_non_pixel other_data ;
};
struct detailed_timing {
   __le16 pixel_clock ;
   union __anonunion_data_185 data ;
};
struct edid {
   u8 header[8U] ;
   u8 mfg_id[2U] ;
   u8 prod_code[2U] ;
   u32 serial ;
   u8 mfg_week ;
   u8 mfg_year ;
   u8 version ;
   u8 revision ;
   u8 input ;
   u8 width_cm ;
   u8 height_cm ;
   u8 gamma ;
   u8 features ;
   u8 red_green_lo ;
   u8 black_white_lo ;
   u8 red_x ;
   u8 red_y ;
   u8 green_x ;
   u8 green_y ;
   u8 blue_x ;
   u8 blue_y ;
   u8 white_x ;
   u8 white_y ;
   struct est_timings established_timings ;
   struct std_timing standard_timings[8U] ;
   struct detailed_timing detailed_timings[4U] ;
   u8 extensions ;
   u8 checksum ;
};
struct intel_crt {
   struct intel_encoder base ;
   bool force_hotplug_required ;
};
enum hrtimer_restart;
enum hrtimer_restart;
struct dmi_strmatch {
   unsigned char slot ;
   char substr[79U] ;
};
struct dmi_system_id {
   int (*callback)(struct dmi_system_id const * ) ;
   char const *ident ;
   struct dmi_strmatch matches[4U] ;
   void *driver_data ;
};
struct intel_lvds {
   struct intel_encoder base ;
   struct edid *edid ;
   int fitting_mode ;
   u32 pfit_control ;
   u32 pfit_pgm_ratios ;
   bool pfit_dirty ;
   struct drm_display_mode *fixed_mode ;
};
enum hrtimer_restart;
enum hrtimer_restart;
struct vbt_header {
   u8 signature[20U] ;
   u16 version ;
   u16 header_size ;
   u16 vbt_size ;
   u8 vbt_checksum ;
   u8 reserved0 ;
   u32 bdb_offset ;
   u32 aim_offset[4U] ;
};
struct bdb_header {
   u8 signature[16U] ;
   u16 version ;
   u16 header_size ;
   u16 bdb_size ;
};
struct bdb_general_features {
   unsigned char panel_fitting : 2 ;
   unsigned char flexaim : 1 ;
   unsigned char msg_enable : 1 ;
   unsigned char clear_screen : 3 ;
   unsigned char color_flip : 1 ;
   unsigned char download_ext_vbt : 1 ;
   unsigned char enable_ssc : 1 ;
   unsigned char ssc_freq : 1 ;
   unsigned char enable_lfp_on_override : 1 ;
   unsigned char disable_ssc_ddt : 1 ;
   unsigned char rsvd8 : 3 ;
   unsigned char disable_smooth_vision : 1 ;
   unsigned char single_dvi : 1 ;
   unsigned char rsvd9 : 6 ;
   u8 legacy_monitor_detect ;
   unsigned char int_crt_support : 1 ;
   unsigned char int_tv_support : 1 ;
   unsigned char rsvd11 : 6 ;
};
struct bdb_general_definitions {
   u8 crt_ddc_gmbus_pin ;
   unsigned char dpms_acpi : 1 ;
   unsigned char skip_boot_crt_detect : 1 ;
   unsigned char dpms_aim : 1 ;
   unsigned char rsvd1 : 5 ;
   u8 boot_display[2U] ;
   u8 child_dev_size ;
   struct child_device_config devices[0U] ;
};
struct bdb_lvds_options {
   u8 panel_type ;
   u8 rsvd1 ;
   unsigned char pfit_mode : 2 ;
   unsigned char pfit_text_mode_enhanced : 1 ;
   unsigned char pfit_gfx_mode_enhanced : 1 ;
   unsigned char pfit_ratio_auto : 1 ;
   unsigned char pixel_dither : 1 ;
   unsigned char lvds_edid : 1 ;
   unsigned char rsvd2 : 1 ;
   u8 rsvd4 ;
};
struct bdb_lvds_lfp_data_ptr {
   u16 fp_timing_offset ;
   u8 fp_table_size ;
   u16 dvo_timing_offset ;
   u8 dvo_table_size ;
   u16 panel_pnp_id_offset ;
   u8 pnp_table_size ;
};
struct bdb_lvds_lfp_data_ptrs {
   u8 lvds_entries ;
   struct bdb_lvds_lfp_data_ptr ptr[16U] ;
};
struct lvds_fp_timing {
   u16 x_res ;
   u16 y_res ;
   u32 lvds_reg ;
   u32 lvds_reg_val ;
   u32 pp_on_reg ;
   u32 pp_on_reg_val ;
   u32 pp_off_reg ;
   u32 pp_off_reg_val ;
   u32 pp_cycle_reg ;
   u32 pp_cycle_reg_val ;
   u32 pfit_reg ;
   u32 pfit_reg_val ;
   u16 terminator ;
};
struct lvds_dvo_timing {
   u16 clock ;
   u8 hactive_lo ;
   u8 hblank_lo ;
   unsigned char hblank_hi : 4 ;
   unsigned char hactive_hi : 4 ;
   u8 vactive_lo ;
   u8 vblank_lo ;
   unsigned char vblank_hi : 4 ;
   unsigned char vactive_hi : 4 ;
   u8 hsync_off_lo ;
   u8 hsync_pulse_width ;
   unsigned char vsync_pulse_width : 4 ;
   unsigned char vsync_off : 4 ;
   unsigned char rsvd0 : 6 ;
   unsigned char hsync_off_hi : 2 ;
   u8 h_image ;
   u8 v_image ;
   u8 max_hv ;
   u8 h_border ;
   u8 v_border ;
   unsigned char rsvd1 : 3 ;
   unsigned char digital : 2 ;
   unsigned char vsync_positive : 1 ;
   unsigned char hsync_positive : 1 ;
   unsigned char rsvd2 : 1 ;
};
struct lvds_pnp_id {
   u16 mfg_name ;
   u16 product_code ;
   u32 serial ;
   u8 mfg_week ;
   u8 mfg_year ;
};
struct bdb_lvds_lfp_data_entry {
   struct lvds_fp_timing fp_timing ;
   struct lvds_dvo_timing dvo_timing ;
   struct lvds_pnp_id pnp_id ;
};
struct bdb_lvds_lfp_data {
   struct bdb_lvds_lfp_data_entry data[16U] ;
};
struct bdb_sdvo_lvds_options {
   u8 panel_backlight ;
   u8 h40_set_panel_type ;
   u8 panel_type ;
   u8 ssc_clk_freq ;
   u16 als_low_trip ;
   u16 als_high_trip ;
   u8 sclalarcoeff_tab_row_num ;
   u8 sclalarcoeff_tab_row_size ;
   u8 coefficient[8U] ;
   u8 panel_misc_bits_1 ;
   u8 panel_misc_bits_2 ;
   u8 panel_misc_bits_3 ;
   u8 panel_misc_bits_4 ;
};
struct bdb_driver_features {
   unsigned char boot_dev_algorithm : 1 ;
   unsigned char block_display_switch : 1 ;
   unsigned char allow_display_switch : 1 ;
   unsigned char hotplug_dvo : 1 ;
   unsigned char dual_view_zoom : 1 ;
   unsigned char int15h_hook : 1 ;
   unsigned char sprite_in_clone : 1 ;
   unsigned char primary_lfp_id : 1 ;
   u16 boot_mode_x ;
   u16 boot_mode_y ;
   u8 boot_mode_bpp ;
   u8 boot_mode_refresh ;
   unsigned char enable_lfp_primary : 1 ;
   unsigned char selective_mode_pruning : 1 ;
   unsigned char dual_frequency : 1 ;
   unsigned char render_clock_freq : 1 ;
   unsigned char nt_clone_support : 1 ;
   unsigned char power_scheme_ui : 1 ;
   unsigned char sprite_display_assign : 1 ;
   unsigned char cui_aspect_scaling : 1 ;
   unsigned char preserve_aspect_ratio : 1 ;
   unsigned char sdvo_device_power_down : 1 ;
   unsigned char crt_hotplug : 1 ;
   unsigned char lvds_config : 2 ;
   unsigned char tv_hotplug : 1 ;
   unsigned char hdmi_config : 2 ;
   unsigned char static_display : 1 ;
   unsigned char reserved2 : 7 ;
   u16 legacy_crt_max_x ;
   u16 legacy_crt_max_y ;
   u8 legacy_crt_max_refresh ;
   u8 hdmi_termination ;
   u8 custom_vbt_version ;
};
struct edp_link_params {
   unsigned char rate : 4 ;
   unsigned char lanes : 4 ;
   unsigned char preemphasis : 4 ;
   unsigned char vswing : 4 ;
};
struct bdb_edp {
   struct edp_power_seq power_seqs[16U] ;
   u32 color_depth ;
   u32 sdrrs_msa_timing_delay ;
   struct edp_link_params link_params[16U] ;
};
enum hrtimer_restart;
enum hrtimer_restart;
struct i2c_algo_dp_aux_data {
   bool running ;
   u16 address ;
   int (*aux_ch)(struct i2c_adapter * , int , uint8_t , uint8_t * ) ;
};
struct intel_dp {
   struct intel_encoder base ;
   uint32_t output_reg ;
   uint32_t DP ;
   uint8_t link_configuration[9U] ;
   bool has_audio ;
   int force_audio ;
   uint32_t color_range ;
   uint8_t link_bw ;
   uint8_t lane_count ;
   uint8_t dpcd[4U] ;
   struct i2c_adapter adapter ;
   struct i2c_algo_dp_aux_data algo ;
   bool is_pch_edp ;
   uint8_t train_set[4U] ;
   uint8_t link_status[6U] ;
};
struct intel_dp_m_n {
   uint32_t tu ;
   uint32_t gmch_m ;
   uint32_t gmch_n ;
   uint32_t link_m ;
   uint32_t link_n ;
};
enum hrtimer_restart;
enum hrtimer_restart;
struct __anonstruct_avi_190 {
   uint8_t Y_A_B_S ;
   uint8_t C_M_R ;
   uint8_t ITC_EC_Q_SC ;
   uint8_t VIC ;
   uint8_t PR ;
   uint16_t top_bar_end ;
   uint16_t bottom_bar_start ;
   uint16_t left_bar_end ;
   uint16_t right_bar_start ;
};
union __anonunion_body_189 {
   struct __anonstruct_avi_190 avi ;
   uint8_t payload[27U] ;
};
struct dip_infoframe {
   uint8_t type ;
   uint8_t ver ;
   uint8_t len ;
   uint8_t ecc ;
   uint8_t checksum ;
   union __anonunion_body_189 body ;
};
struct intel_hdmi {
   struct intel_encoder base ;
   u32 sdvox_reg ;
   int ddc_bus ;
   uint32_t color_range ;
   bool has_hdmi_sink ;
   bool has_audio ;
   int force_audio ;
};
enum hrtimer_restart;
enum hrtimer_restart;
struct intel_sdvo_caps {
   u8 vendor_id ;
   u8 device_id ;
   u8 device_rev_id ;
   u8 sdvo_version_major ;
   u8 sdvo_version_minor ;
   unsigned char sdvo_inputs_mask : 2 ;
   unsigned char smooth_scaling : 1 ;
   unsigned char sharp_scaling : 1 ;
   unsigned char up_scaling : 1 ;
   unsigned char down_scaling : 1 ;
   unsigned char stall_support : 1 ;
   unsigned char pad : 1 ;
   u16 output_flags ;
};
struct __anonstruct_part1_191 {
   u16 clock ;
   u8 h_active ;
   u8 h_blank ;
   u8 h_high ;
   u8 v_active ;
   u8 v_blank ;
   u8 v_high ;
};
struct __anonstruct_part2_192 {
   u8 h_sync_off ;
   u8 h_sync_width ;
   u8 v_sync_off_width ;
   u8 sync_off_width_high ;
   u8 dtd_flags ;
   u8 sdvo_flags ;
   u8 v_sync_off_high ;
   u8 reserved ;
};
struct intel_sdvo_dtd {
   struct __anonstruct_part1_191 part1 ;
   struct __anonstruct_part2_192 part2 ;
};
struct intel_sdvo_pixel_clock_range {
   u16 min ;
   u16 max ;
};
struct intel_sdvo_preferred_input_timing_args {
   u16 clock ;
   u16 width ;
   u16 height ;
   unsigned char interlace : 1 ;
   unsigned char scaled : 1 ;
   unsigned char pad : 6 ;
};
struct intel_sdvo_get_trained_inputs_response {
   unsigned char input0_trained : 1 ;
   unsigned char input1_trained : 1 ;
   unsigned char pad : 6 ;
};
struct intel_sdvo_in_out_map {
   u16 in0 ;
   u16 in1 ;
};
struct intel_sdvo_set_target_input_args {
   unsigned char target_1 : 1 ;
   unsigned char pad : 7 ;
};
struct intel_sdvo_tv_format {
   unsigned char ntsc_m : 1 ;
   unsigned char ntsc_j : 1 ;
   unsigned char ntsc_443 : 1 ;
   unsigned char pal_b : 1 ;
   unsigned char pal_d : 1 ;
   unsigned char pal_g : 1 ;
   unsigned char pal_h : 1 ;
   unsigned char pal_i : 1 ;
   unsigned char pal_m : 1 ;
   unsigned char pal_n : 1 ;
   unsigned char pal_nc : 1 ;
   unsigned char pal_60 : 1 ;
   unsigned char secam_b : 1 ;
   unsigned char secam_d : 1 ;
   unsigned char secam_g : 1 ;
   unsigned char secam_k : 1 ;
   unsigned char secam_k1 : 1 ;
   unsigned char secam_l : 1 ;
   unsigned char secam_60 : 1 ;
   unsigned char hdtv_std_smpte_240m_1080i_59 : 1 ;
   unsigned char hdtv_std_smpte_240m_1080i_60 : 1 ;
   unsigned char hdtv_std_smpte_260m_1080i_59 : 1 ;
   unsigned char hdtv_std_smpte_260m_1080i_60 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080i_50 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080i_59 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080i_60 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_23 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_24 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_25 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_29 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_30 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_50 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_59 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_60 : 1 ;
   unsigned char hdtv_std_smpte_295m_1080i_50 : 1 ;
   unsigned char hdtv_std_smpte_295m_1080p_50 : 1 ;
   unsigned char hdtv_std_smpte_296m_720p_59 : 1 ;
   unsigned char hdtv_std_smpte_296m_720p_60 : 1 ;
   unsigned char hdtv_std_smpte_296m_720p_50 : 1 ;
   unsigned char hdtv_std_smpte_293m_480p_59 : 1 ;
   unsigned char hdtv_std_smpte_170m_480i_59 : 1 ;
   unsigned char hdtv_std_iturbt601_576i_50 : 1 ;
   unsigned char hdtv_std_iturbt601_576p_50 : 1 ;
   unsigned char hdtv_std_eia_7702a_480i_60 : 1 ;
   unsigned char hdtv_std_eia_7702a_480p_60 : 1 ;
   unsigned char pad : 3 ;
};
struct intel_sdvo_sdtv_resolution_request {
   unsigned char ntsc_m : 1 ;
   unsigned char ntsc_j : 1 ;
   unsigned char ntsc_443 : 1 ;
   unsigned char pal_b : 1 ;
   unsigned char pal_d : 1 ;
   unsigned char pal_g : 1 ;
   unsigned char pal_h : 1 ;
   unsigned char pal_i : 1 ;
   unsigned char pal_m : 1 ;
   unsigned char pal_n : 1 ;
   unsigned char pal_nc : 1 ;
   unsigned char pal_60 : 1 ;
   unsigned char secam_b : 1 ;
   unsigned char secam_d : 1 ;
   unsigned char secam_g : 1 ;
   unsigned char secam_k : 1 ;
   unsigned char secam_k1 : 1 ;
   unsigned char secam_l : 1 ;
   unsigned char secam_60 : 1 ;
   unsigned char pad : 5 ;
};
struct intel_sdvo_enhancements_reply {
   unsigned char flicker_filter : 1 ;
   unsigned char flicker_filter_adaptive : 1 ;
   unsigned char flicker_filter_2d : 1 ;
   unsigned char saturation : 1 ;
   unsigned char hue : 1 ;
   unsigned char brightness : 1 ;
   unsigned char contrast : 1 ;
   unsigned char overscan_h : 1 ;
   unsigned char overscan_v : 1 ;
   unsigned char hpos : 1 ;
   unsigned char vpos : 1 ;
   unsigned char sharpness : 1 ;
   unsigned char dot_crawl : 1 ;
   unsigned char dither : 1 ;
   unsigned char tv_chroma_filter : 1 ;
   unsigned char tv_luma_filter : 1 ;
};
struct intel_sdvo_encode {
   u8 dvi_rev ;
   u8 hdmi_rev ;
};
struct intel_sdvo {
   struct intel_encoder base ;
   struct i2c_adapter *i2c ;
   u8 slave_addr ;
   struct i2c_adapter ddc ;
   int sdvo_reg ;
   uint16_t controlled_output ;
   struct intel_sdvo_caps caps ;
   int pixel_clock_min ;
   int pixel_clock_max ;
   uint16_t attached_output ;
   uint32_t color_range ;
   bool is_tv ;
   int tv_format_index ;
   bool is_hdmi ;
   bool has_hdmi_monitor ;
   bool has_hdmi_audio ;
   bool is_lvds ;
   struct drm_display_mode *sdvo_lvds_fixed_mode ;
   uint8_t ddc_bus ;
   struct intel_sdvo_dtd input_dtd ;
};
struct intel_sdvo_connector {
   struct intel_connector base ;
   uint16_t output_flag ;
   int force_audio ;
   u8 tv_format_supported[19U] ;
   int format_supported_num ;
   struct drm_property *tv_format ;
   struct drm_property *left ;
   struct drm_property *right ;
   struct drm_property *top ;
   struct drm_property *bottom ;
   struct drm_property *hpos ;
   struct drm_property *vpos ;
   struct drm_property *contrast ;
   struct drm_property *saturation ;
   struct drm_property *hue ;
   struct drm_property *sharpness ;
   struct drm_property *flicker_filter ;
   struct drm_property *flicker_filter_adaptive ;
   struct drm_property *flicker_filter_2d ;
   struct drm_property *tv_chroma_filter ;
   struct drm_property *tv_luma_filter ;
   struct drm_property *dot_crawl ;
   struct drm_property *brightness ;
   u32 left_margin ;
   u32 right_margin ;
   u32 top_margin ;
   u32 bottom_margin ;
   u32 max_hscan ;
   u32 max_vscan ;
   u32 max_hpos ;
   u32 cur_hpos ;
   u32 max_vpos ;
   u32 cur_vpos ;
   u32 cur_brightness ;
   u32 max_brightness ;
   u32 cur_contrast ;
   u32 max_contrast ;
   u32 cur_saturation ;
   u32 max_saturation ;
   u32 cur_hue ;
   u32 max_hue ;
   u32 cur_sharpness ;
   u32 max_sharpness ;
   u32 cur_flicker_filter ;
   u32 max_flicker_filter ;
   u32 cur_flicker_filter_adaptive ;
   u32 max_flicker_filter_adaptive ;
   u32 cur_flicker_filter_2d ;
   u32 max_flicker_filter_2d ;
   u32 cur_tv_chroma_filter ;
   u32 max_tv_chroma_filter ;
   u32 cur_tv_luma_filter ;
   u32 max_tv_luma_filter ;
   u32 cur_dot_crawl ;
   u32 max_dot_crawl ;
};
struct _sdvo_cmd_name {
   u8 cmd ;
   char const *name ;
};
union __anonunion_enhancements_197 {
   struct intel_sdvo_enhancements_reply reply ;
   uint16_t response ;
};
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
struct i2c_algo_bit_data {
   void *data ;
   void (*setsda)(void * , int ) ;
   void (*setscl)(void * , int ) ;
   int (*getsda)(void * ) ;
   int (*getscl)(void * ) ;
   int (*pre_xfer)(struct i2c_adapter * ) ;
   void (*post_xfer)(struct i2c_adapter * ) ;
   int udelay ;
   int timeout ;
};
struct intel_gpio {
   struct i2c_adapter adapter ;
   struct i2c_algo_bit_data algo ;
   struct drm_i915_private *dev_priv ;
   u32 reg ;
};
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
struct intel_tv {
   struct intel_encoder base ;
   int type ;
   char const *tv_format ;
   int margin[4U] ;
   u32 save_TV_H_CTL_1 ;
   u32 save_TV_H_CTL_2 ;
   u32 save_TV_H_CTL_3 ;
   u32 save_TV_V_CTL_1 ;
   u32 save_TV_V_CTL_2 ;
   u32 save_TV_V_CTL_3 ;
   u32 save_TV_V_CTL_4 ;
   u32 save_TV_V_CTL_5 ;
   u32 save_TV_V_CTL_6 ;
   u32 save_TV_V_CTL_7 ;
   u32 save_TV_SC_CTL_1 ;
   u32 save_TV_SC_CTL_2 ;
   u32 save_TV_SC_CTL_3 ;
   u32 save_TV_CSC_Y ;
   u32 save_TV_CSC_Y2 ;
   u32 save_TV_CSC_U ;
   u32 save_TV_CSC_U2 ;
   u32 save_TV_CSC_V ;
   u32 save_TV_CSC_V2 ;
   u32 save_TV_CLR_KNOBS ;
   u32 save_TV_CLR_LEVEL ;
   u32 save_TV_WIN_POS ;
   u32 save_TV_WIN_SIZE ;
   u32 save_TV_FILTER_CTL_1 ;
   u32 save_TV_FILTER_CTL_2 ;
   u32 save_TV_FILTER_CTL_3 ;
   u32 save_TV_H_LUMA[60U] ;
   u32 save_TV_H_CHROMA[60U] ;
   u32 save_TV_V_LUMA[43U] ;
   u32 save_TV_V_CHROMA[43U] ;
   u32 save_TV_DAC ;
   u32 save_TV_CTL ;
};
struct video_levels {
   int blank ;
   int black ;
   int burst ;
};
struct color_conversion {
   u16 ry ;
   u16 gy ;
   u16 by ;
   u16 ay ;
   u16 ru ;
   u16 gu ;
   u16 bu ;
   u16 au ;
   u16 rv ;
   u16 gv ;
   u16 bv ;
   u16 av ;
};
struct tv_mode {
   char const *name ;
   int clock ;
   int refresh ;
   u32 oversample ;
   int hsync_end ;
   int hblank_start ;
   int hblank_end ;
   int htotal ;
   bool progressive ;
   bool trilevel_sync ;
   bool component_only ;
   int vsync_start_f1 ;
   int vsync_start_f2 ;
   int vsync_len ;
   bool veq_ena ;
   int veq_start_f1 ;
   int veq_start_f2 ;
   int veq_len ;
   int vi_end_f1 ;
   int vi_end_f2 ;
   int nbr_end ;
   bool burst_ena ;
   int hburst_start ;
   int hburst_len ;
   int vburst_start_f1 ;
   int vburst_end_f1 ;
   int vburst_start_f2 ;
   int vburst_end_f2 ;
   int vburst_start_f3 ;
   int vburst_end_f3 ;
   int vburst_start_f4 ;
   int vburst_end_f4 ;
   int dda2_size ;
   int dda3_size ;
   int dda1_inc ;
   int dda2_inc ;
   int dda3_inc ;
   u32 sc_reset ;
   bool pal_burst ;
   struct video_levels const *composite_levels ;
   struct video_levels const *svideo_levels ;
   struct color_conversion const *composite_color ;
   struct color_conversion const *svideo_color ;
   u32 const *filter_table ;
   int max_srcw ;
};
struct input_res {
   char const *name ;
   int w ;
   int h ;
};
enum hrtimer_restart;
enum hrtimer_restart;
struct intel_dvo_dev_ops;
struct intel_dvo_device {
   char const *name ;
   int type ;
   u32 dvo_reg ;
   u32 gpio ;
   int slave_addr ;
   struct intel_dvo_dev_ops const *dev_ops ;
   void *dev_priv ;
   struct i2c_adapter *i2c_bus ;
};
struct intel_dvo_dev_ops {
   bool (*init)(struct intel_dvo_device * , struct i2c_adapter * ) ;
   void (*create_resources)(struct intel_dvo_device * ) ;
   void (*dpms)(struct intel_dvo_device * , int ) ;
   int (*mode_valid)(struct intel_dvo_device * , struct drm_display_mode * ) ;
   bool (*mode_fixup)(struct intel_dvo_device * , struct drm_display_mode * , struct drm_display_mode * ) ;
   void (*prepare)(struct intel_dvo_device * ) ;
   void (*commit)(struct intel_dvo_device * ) ;
   void (*mode_set)(struct intel_dvo_device * , struct drm_display_mode * , struct drm_display_mode * ) ;
   enum drm_connector_status (*detect)(struct intel_dvo_device * ) ;
   struct drm_display_mode *(*get_modes)(struct intel_dvo_device * ) ;
   void (*destroy)(struct intel_dvo_device * ) ;
   void (*dump_regs)(struct intel_dvo_device * ) ;
};
struct intel_dvo {
   struct intel_encoder base ;
   struct intel_dvo_device dev ;
   struct drm_display_mode *panel_fixed_mode ;
   bool panel_wants_dither ;
};
enum hrtimer_restart;
enum hrtimer_restart;
struct pipe_control {
   struct drm_i915_gem_object *obj ;
   u32 volatile *cpu_page ;
   u32 gtt_offset ;
};
enum hrtimer_restart;
enum hrtimer_restart;
struct drm_intel_overlay_put_image {
   __u32 flags ;
   __u32 bo_handle ;
   __u16 stride_Y ;
   __u16 stride_UV ;
   __u32 offset_Y ;
   __u32 offset_U ;
   __u32 offset_V ;
   __u16 src_width ;
   __u16 src_height ;
   __u16 src_scan_width ;
   __u16 src_scan_height ;
   __u32 crtc_id ;
   __u16 dst_x ;
   __u16 dst_y ;
   __u16 dst_width ;
   __u16 dst_height ;
};
struct drm_intel_overlay_attrs {
   __u32 flags ;
   __u32 color_key ;
   __s32 brightness ;
   __u32 contrast ;
   __u32 saturation ;
   __u32 gamma0 ;
   __u32 gamma1 ;
   __u32 gamma2 ;
   __u32 gamma3 ;
   __u32 gamma4 ;
   __u32 gamma5 ;
};
struct overlay_registers {
   u32 OBUF_0Y ;
   u32 OBUF_1Y ;
   u32 OBUF_0U ;
   u32 OBUF_0V ;
   u32 OBUF_1U ;
   u32 OBUF_1V ;
   u32 OSTRIDE ;
   u32 YRGB_VPH ;
   u32 UV_VPH ;
   u32 HORZ_PH ;
   u32 INIT_PHS ;
   u32 DWINPOS ;
   u32 DWINSZ ;
   u32 SWIDTH ;
   u32 SWIDTHSW ;
   u32 SHEIGHT ;
   u32 YRGBSCALE ;
   u32 UVSCALE ;
   u32 OCLRC0 ;
   u32 OCLRC1 ;
   u32 DCLRKV ;
   u32 DCLRKM ;
   u32 SCLRKVH ;
   u32 SCLRKVL ;
   u32 SCLRKEN ;
   u32 OCONFIG ;
   u32 OCMD ;
   u32 RESERVED1 ;
   u32 OSTART_0Y ;
   u32 OSTART_1Y ;
   u32 OSTART_0U ;
   u32 OSTART_0V ;
   u32 OSTART_1U ;
   u32 OSTART_1V ;
   u32 OTILEOFF_0Y ;
   u32 OTILEOFF_1Y ;
   u32 OTILEOFF_0U ;
   u32 OTILEOFF_0V ;
   u32 OTILEOFF_1U ;
   u32 OTILEOFF_1V ;
   u32 FASTHSCALE ;
   u32 UVSCALEV ;
   u32 RESERVEDC[86U] ;
   u16 Y_VCOEFS[51U] ;
   u16 RESERVEDD[77U] ;
   u16 Y_HCOEFS[85U] ;
   u16 RESERVEDE[171U] ;
   u16 UV_VCOEFS[51U] ;
   u16 RESERVEDF[77U] ;
   u16 UV_HCOEFS[51U] ;
   u16 RESERVEDG[77U] ;
};
struct intel_overlay {
   struct drm_device *dev ;
   struct intel_crtc *crtc ;
   struct drm_i915_gem_object *vid_bo ;
   struct drm_i915_gem_object *old_vid_bo ;
   int active ;
   int pfit_active ;
   u32 pfit_vscale_ratio ;
   u32 color_key ;
   u32 brightness ;
   u32 contrast ;
   u32 saturation ;
   u32 old_xscale ;
   u32 old_yscale ;
   u32 flip_addr ;
   struct drm_i915_gem_object *reg_bo ;
   uint32_t last_flip_req ;
   void (*flip_tail)(struct intel_overlay * ) ;
};
struct put_image_params {
   int format ;
   short dst_x ;
   short dst_y ;
   short dst_w ;
   short dst_h ;
   short src_w ;
   short src_scan_h ;
   short src_scan_w ;
   short src_h ;
   short stride_Y ;
   short stride_UV ;
   int offset_Y ;
   int offset_U ;
   int offset_V ;
};
struct intel_overlay_error_state {
   struct overlay_registers regs ;
   unsigned long base ;
   u32 dovsta ;
   u32 isr ;
};
enum hrtimer_restart;
enum hrtimer_restart;
struct acpi_device_id {
   __u8 id[16U] ;
   kernel_ulong_t driver_data ;
};
typedef u64 acpi_size;
typedef u64 acpi_io_address;
typedef u64 acpi_physical_address;
typedef u32 acpi_status;
typedef char *acpi_string;
typedef void *acpi_handle;
typedef u32 acpi_object_type;
struct __anonstruct_integer_155 {
   acpi_object_type type ;
   u64 value ;
};
struct __anonstruct_string_156 {
   acpi_object_type type ;
   u32 length ;
   char *pointer ;
};
struct __anonstruct_buffer_157 {
   acpi_object_type type ;
   u32 length ;
   u8 *pointer ;
};
union acpi_object;
struct __anonstruct_package_158 {
   acpi_object_type type ;
   u32 count ;
   union acpi_object *elements ;
};
struct __anonstruct_reference_159 {
   acpi_object_type type ;
   acpi_object_type actual_type ;
   acpi_handle handle ;
};
struct __anonstruct_processor_160 {
   acpi_object_type type ;
   u32 proc_id ;
   acpi_io_address pblk_address ;
   u32 pblk_length ;
};
struct __anonstruct_power_resource_161 {
   acpi_object_type type ;
   u32 system_level ;
   u32 resource_order ;
};
union acpi_object {
   acpi_object_type type ;
   struct __anonstruct_integer_155 integer ;
   struct __anonstruct_string_156 string ;
   struct __anonstruct_buffer_157 buffer ;
   struct __anonstruct_package_158 package ;
   struct __anonstruct_reference_159 reference ;
   struct __anonstruct_processor_160 processor ;
   struct __anonstruct_power_resource_161 power_resource ;
};
struct acpi_object_list {
   u32 count ;
   union acpi_object *pointer ;
};
struct acpi_handle_list {
   u32 count ;
   acpi_handle handles[10U] ;
};
enum acpi_bus_removal_type {
    ACPI_BUS_REMOVAL_NORMAL = 0,
    ACPI_BUS_REMOVAL_EJECT = 1,
    ACPI_BUS_REMOVAL_SUPRISE = 2,
    ACPI_BUS_REMOVAL_TYPE_COUNT = 3
} ;
struct acpi_driver;
struct acpi_device;
struct acpi_bus_ops {
   unsigned char acpi_op_add : 1 ;
   unsigned char acpi_op_start : 1 ;
};
struct acpi_device_ops {
   int (*add)(struct acpi_device * ) ;
   int (*remove)(struct acpi_device * , int ) ;
   int (*start)(struct acpi_device * ) ;
   int (*suspend)(struct acpi_device * , pm_message_t ) ;
   int (*resume)(struct acpi_device * ) ;
   int (*bind)(struct acpi_device * ) ;
   int (*unbind)(struct acpi_device * ) ;
   void (*notify)(struct acpi_device * , u32 ) ;
};
struct acpi_driver {
   char name[80U] ;
   char class[80U] ;
   struct acpi_device_id const *ids ;
   unsigned int flags ;
   struct acpi_device_ops ops ;
   struct device_driver drv ;
   struct module *owner ;
};
struct acpi_device_status {
   unsigned char present : 1 ;
   unsigned char enabled : 1 ;
   unsigned char show_in_ui : 1 ;
   unsigned char functional : 1 ;
   unsigned char battery_present : 1 ;
   unsigned int reserved : 27 ;
};
struct acpi_device_flags {
   unsigned char dynamic_status : 1 ;
   unsigned char bus_address : 1 ;
   unsigned char removable : 1 ;
   unsigned char ejectable : 1 ;
   unsigned char lockable : 1 ;
   unsigned char suprise_removal_ok : 1 ;
   unsigned char power_manageable : 1 ;
   unsigned char performance_manageable : 1 ;
   unsigned int reserved : 24 ;
};
struct acpi_device_dir {
   struct proc_dir_entry *entry ;
};
typedef char acpi_bus_id[8U];
typedef unsigned long acpi_bus_address;
typedef char acpi_device_name[40U];
typedef char acpi_device_class[20U];
struct acpi_device_pnp {
   acpi_bus_id bus_id ;
   acpi_bus_address bus_address ;
   char *unique_id ;
   struct list_head ids ;
   acpi_device_name device_name ;
   acpi_device_class device_class ;
};
struct acpi_device_power_flags {
   unsigned char explicit_get : 1 ;
   unsigned char power_resources : 1 ;
   unsigned char inrush_current : 1 ;
   unsigned char power_removed : 1 ;
   unsigned int reserved : 28 ;
};
struct __anonstruct_flags_170 {
   unsigned char valid : 1 ;
   unsigned char explicit_set : 1 ;
   unsigned char reserved : 6 ;
};
struct acpi_device_power_state {
   struct __anonstruct_flags_170 flags ;
   int power ;
   int latency ;
   struct acpi_handle_list resources ;
};
struct acpi_device_power {
   int state ;
   struct acpi_device_power_flags flags ;
   struct acpi_device_power_state states[5U] ;
};
struct acpi_device_perf_flags {
   u8 reserved ;
};
struct __anonstruct_flags_171 {
   unsigned char valid : 1 ;
   unsigned char reserved : 7 ;
};
struct acpi_device_perf_state {
   struct __anonstruct_flags_171 flags ;
   u8 power ;
   u8 performance ;
   int latency ;
};
struct acpi_device_perf {
   int state ;
   struct acpi_device_perf_flags flags ;
   int state_count ;
   struct acpi_device_perf_state *states ;
};
struct acpi_device_wakeup_flags {
   unsigned char valid : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char notifier_present : 1 ;
};
struct acpi_device_wakeup {
   acpi_handle gpe_device ;
   u64 gpe_number ;
   u64 sleep_state ;
   struct acpi_handle_list resources ;
   struct acpi_device_wakeup_flags flags ;
   int prepare_count ;
};
struct acpi_device {
   int device_type ;
   acpi_handle handle ;
   struct acpi_device *parent ;
   struct list_head children ;
   struct list_head node ;
   struct list_head wakeup_list ;
   struct acpi_device_status status ;
   struct acpi_device_flags flags ;
   struct acpi_device_pnp pnp ;
   struct acpi_device_power power ;
   struct acpi_device_wakeup wakeup ;
   struct acpi_device_perf performance ;
   struct acpi_device_dir dir ;
   struct acpi_device_ops ops ;
   struct acpi_driver *driver ;
   void *driver_data ;
   struct device dev ;
   struct acpi_bus_ops bus_ops ;
   enum acpi_bus_removal_type removal_type ;
};
struct opregion_header {
   u8 signature[16U] ;
   u32 size ;
   u32 opregion_ver ;
   u8 bios_ver[32U] ;
   u8 vbios_ver[16U] ;
   u8 driver_ver[16U] ;
   u32 mboxes ;
   u8 reserved[164U] ;
};
struct opregion_acpi {
   u32 drdy ;
   u32 csts ;
   u32 cevt ;
   u8 rsvd1[20U] ;
   u32 didl[8U] ;
   u32 cpdl[8U] ;
   u32 cadl[8U] ;
   u32 nadl[8U] ;
   u32 aslp ;
   u32 tidx ;
   u32 chpd ;
   u32 clid ;
   u32 cdck ;
   u32 sxsw ;
   u32 evts ;
   u32 cnot ;
   u32 nrdy ;
   u8 rsvd2[60U] ;
};
struct opregion_swsci {
   u32 scic ;
   u32 parm ;
   u32 dslp ;
   u8 rsvd[244U] ;
};
struct opregion_asle {
   u32 ardy ;
   u32 aslc ;
   u32 tche ;
   u32 alsi ;
   u32 bclp ;
   u32 pfit ;
   u32 cblv ;
   u16 bclm[20U] ;
   u32 cpfm ;
   u32 epfm ;
   u8 plut[74U] ;
   u32 pfmb ;
   u8 rsvd[102U] ;
};
enum hrtimer_restart;
enum hrtimer_restart;
struct ch7xxx_id_struct {
   uint8_t vid ;
   char *name ;
};
struct ch7xxx_priv {
   bool quiet ;
};
enum hrtimer_restart;
enum hrtimer_restart;
struct ch7017_priv {
   uint8_t dummy ;
};
enum hrtimer_restart;
enum hrtimer_restart;
struct ivch_priv {
   bool quiet ;
   uint16_t width ;
   uint16_t height ;
};
enum hrtimer_restart;
enum hrtimer_restart;
struct tfp410_priv {
   bool quiet ;
};
enum hrtimer_restart;
enum hrtimer_restart;
struct sil164_priv {
   bool quiet ;
};
enum hrtimer_restart;
enum hrtimer_restart;
typedef int drm_ioctl_compat_t(struct file * , unsigned int , unsigned long );
struct _drm_i915_batchbuffer32 {
   int start ;
   int used ;
   int DR1 ;
   int DR4 ;
   int num_cliprects ;
   u32 cliprects ;
};
typedef struct _drm_i915_batchbuffer32 drm_i915_batchbuffer32_t;
struct _drm_i915_cmdbuffer32 {
   u32 buf ;
   int sz ;
   int DR1 ;
   int DR4 ;
   int num_cliprects ;
   u32 cliprects ;
};
typedef struct _drm_i915_cmdbuffer32 drm_i915_cmdbuffer32_t;
struct drm_i915_irq_emit32 {
   u32 irq_seq ;
};
typedef struct drm_i915_irq_emit32 drm_i915_irq_emit32_t;
struct drm_i915_getparam32 {
   int param ;
   u32 value ;
};
typedef struct drm_i915_getparam32 drm_i915_getparam32_t;
struct drm_i915_mem_alloc32 {
   int region ;
   int alignment ;
   int size ;
   u32 region_offset ;
};
typedef struct drm_i915_mem_alloc32 drm_i915_mem_alloc32_t;
enum hrtimer_restart;
enum hrtimer_restart;
struct acpi_buffer {
   acpi_size length ;
   void *pointer ;
};
struct intel_dsm_priv {
   acpi_handle dhandle ;
};
extern void warn_slowpath_null(char const * , int const ) ;
extern void __bad_percpu_size(void) ;
__inline static int atomic_read(atomic_t const *v )
{
  {
  return ((int )*((int volatile *)(& v->counter)));
}
}
__inline static int atomic_dec_and_test(atomic_t *v )
{ unsigned char c ;
  {
  __asm__ volatile (".section .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.previous\n671:\n\tlock; decl %0; sete %1": "+m" (v->counter),
                       "=qm" (c): : "memory");
  return ((unsigned int )c != 0U);
}
}
__inline static int atomic_add_return(int i , atomic_t *v )
{ int __i ;
  {
  __i = i;
  __asm__ volatile (".section .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.previous\n671:\n\tlock; xaddl %0, %1": "+r" (i),
                       "+m" (v->counter): : "memory");
  return (i + __i);
}
}
extern unsigned long kernel_stack ;
__inline static struct thread_info *current_thread_info(void)
{ struct thread_info *ti ;
  unsigned long pfo_ret__ ;
  {
  if (1) {
    goto case_8;
  } else {
    goto switch_default;
    if (0) {
      __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& kernel_stack));
      goto ldv_5782;
      __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
      goto ldv_5782;
      __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
      goto ldv_5782;
      case_8:
      __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
      goto ldv_5782;
      switch_default:
      {
      __bad_percpu_size();
      }
    } else {
    }
  }
  ldv_5782:
  ti = (struct thread_info *)(pfo_ret__ - 8152UL);
  return (ti);
}
}
extern void lockdep_rcu_dereference(char const * , int const ) ;
extern unsigned long get_seconds(void) ;
__inline static int mutex_is_locked(struct mutex *lock )
{ int tmp ;
  {
  {
  tmp = atomic_read((atomic_t const *)(& lock->count));
  }
  return (tmp != 1);
}
}
extern void mutex_lock_nested(struct mutex * , unsigned int ) ;
extern int mutex_trylock(struct mutex * ) ;
extern void mutex_unlock(struct mutex * ) ;
extern unsigned long volatile jiffies ;
extern unsigned long msecs_to_jiffies(unsigned int const ) ;
__inline static unsigned int readl(void const volatile *addr )
{ unsigned int ret ;
  {
  __asm__ volatile ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile *)addr)): "memory");
  return (ret);
}
}
__inline static void writel(unsigned int val , void volatile *addr )
{
  {
  __asm__ volatile ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile *)addr)): "memory");
  return;
}
}
extern int cpu_number ;
extern int debug_lockdep_rcu_enabled(void) ;
__inline static int rcu_read_lock_sched_held(void)
{
  {
  return (1);
}
}
__inline static void rcu_read_lock_sched_notrace(void)
{
  {
  return;
}
}
__inline static bool static_branch(struct jump_label_key *key )
{ int tmp ;
  long tmp___0 ;
  {
  {
  tmp = atomic_read((atomic_t const *)(& key->enabled));
  tmp___0 = __builtin_expect((long )(tmp != 0), 0L);
  }
  if (tmp___0 != 0L) {
    return ((bool )1);
  } else {
  }
  return ((bool )0);
}
}
extern struct module __this_module ;
int ldv_try_module_get(struct module *module ) ;
void ldv_module_get(struct module *module ) ;
void ldv_module_put(struct module *module ) ;
unsigned int ldv_module_refcount(void) ;
void ldv_module_put_and_exit(void) ;
extern void *dev_get_drvdata(struct device const * ) ;
extern int dev_err(struct device const * , char const * , ...) ;
extern loff_t noop_llseek(struct file * , loff_t , int ) ;
extern void pci_dev_put(struct pci_dev * ) ;
extern struct pci_dev *pci_get_class(unsigned int , struct pci_dev * ) ;
extern int pci_bus_read_config_byte(struct pci_bus * , unsigned int , int , u8 * ) ;
extern int pci_bus_write_config_byte(struct pci_bus * , unsigned int , int , u8 ) ;
__inline static int pci_read_config_byte(struct pci_dev *dev , int where , u8 *val )
{ int tmp ;
  {
  {
  tmp = pci_bus_read_config_byte(dev->bus, dev->devfn, where, val);
  }
  return (tmp);
}
}
__inline static int pci_write_config_byte(struct pci_dev *dev , int where , u8 val )
{ int tmp ;
  {
  {
  tmp = pci_bus_write_config_byte(dev->bus, dev->devfn, where, (u8 )((int )val));
  }
  return (tmp);
}
}
extern int pci_enable_device(struct pci_dev * ) ;
extern void pci_disable_device(struct pci_dev * ) ;
extern void pci_set_master(struct pci_dev * ) ;
extern int pci_save_state(struct pci_dev * ) ;
extern int pci_set_power_state(struct pci_dev * , pci_power_t ) ;
__inline static void *pci_get_drvdata(struct pci_dev *pdev )
{ void *tmp ;
  {
  {
  tmp = dev_get_drvdata((struct device const *)(& pdev->dev));
  }
  return (tmp);
}
}
extern void __const_udelay(unsigned long ) ;
extern void msleep(unsigned int ) ;
extern void drm_ut_debug_printk(unsigned int , char const * , char const * ,
                                char const * , ...) ;
extern int drm_err(char const * , char const * , ...) ;
extern atomic_t kgdb_active ;
extern void drm_mode_config_reset(struct drm_device * ) ;
__inline static int drm_core_check_feature(struct drm_device *dev , int feature )
{
  {
  return (((dev->driver)->driver_features & (u32 )feature) != 0U);
}
}
extern long drm_ioctl(struct file * , unsigned int , unsigned long ) ;
extern int drm_open(struct inode * , struct file * ) ;
extern int drm_fasync(int , struct file * , int ) ;
extern ssize_t drm_read(struct file * , char * , size_t , loff_t * ) ;
extern int drm_release(struct inode * , struct file * ) ;
extern unsigned int drm_poll(struct file * , struct poll_table_struct * ) ;
extern void drm_core_reclaim_buffers(struct drm_device * , struct drm_file * ) ;
extern int drm_irq_install(struct drm_device * ) ;
extern int drm_irq_uninstall(struct drm_device * ) ;
extern void drm_put_dev(struct drm_device * ) ;
extern void drm_gem_vm_open(struct vm_area_struct * ) ;
extern void drm_gem_vm_close(struct vm_area_struct * ) ;
extern int drm_gem_mmap(struct file * , struct vm_area_struct * ) ;
extern int drm_pci_init(struct drm_driver * , struct pci_driver * ) ;
extern void drm_pci_exit(struct drm_driver * , struct pci_driver * ) ;
extern int drm_get_pci_dev(struct pci_dev * , struct pci_device_id const * , struct drm_driver * ) ;
struct tracepoint __tracepoint_i915_reg_rw ;
__inline static void trace_i915_reg_rw(bool write , u32 reg , u64 val , int len )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_reg_rw.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_reg_rw.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )411);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_36536:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , bool , u32 , u64 , int ))it_func))(__data, (bool )((int )write),
                                                                   reg, val, len);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_36536;
      } else {
        goto ldv_36537;
      }
      ldv_36537: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
struct drm_ioctl_desc i915_ioctls[42U] ;
int i915_max_ioctl ;
unsigned int i915_fbpercrtc ;
int i915_panel_ignore_lid ;
unsigned int i915_powersave ;
unsigned int i915_semaphores ;
unsigned int i915_lvds_downclock ;
unsigned int i915_panel_use_ssc ;
int i915_vbt_sdvo_panel_type ;
unsigned int i915_enable_rc6 ;
unsigned int i915_enable_fbc ;
int i915_suspend(struct drm_device *dev , pm_message_t state ) ;
int i915_resume(struct drm_device *dev ) ;
int i915_master_create(struct drm_device *dev , struct drm_master *master ) ;
void i915_master_destroy(struct drm_device *dev , struct drm_master *master ) ;
int i915_driver_load(struct drm_device *dev , unsigned long flags ) ;
int i915_driver_unload(struct drm_device *dev ) ;
int i915_driver_open(struct drm_device *dev , struct drm_file *file ) ;
void i915_driver_lastclose(struct drm_device *dev ) ;
void i915_driver_preclose(struct drm_device *dev , struct drm_file *file_priv ) ;
void i915_driver_postclose(struct drm_device *dev , struct drm_file *file ) ;
int i915_driver_device_is_agp(struct drm_device *dev ) ;
long i915_compat_ioctl(struct file *filp , unsigned int cmd , unsigned long arg ) ;
int i915_reset(struct drm_device *dev , u8 flags ) ;
int i915_gem_init_object(struct drm_gem_object *obj ) ;
void i915_gem_free_object(struct drm_gem_object *gem_obj ) ;
int i915_gem_dumb_create(struct drm_file *file , struct drm_device *dev , struct drm_mode_create_dumb *args ) ;
int i915_gem_mmap_gtt(struct drm_file *file , struct drm_device *dev , uint32_t handle ,
                      uint64_t *offset ) ;
int i915_gem_dumb_destroy(struct drm_file *file , struct drm_device *dev , uint32_t handle ) ;
void i915_gem_reset(struct drm_device *dev ) ;
int i915_gem_init_ringbuffer(struct drm_device *dev ) ;
int i915_gem_idle(struct drm_device *dev ) ;
int i915_gem_fault(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
void i915_gem_restore_gtt_mappings(struct drm_device *dev ) ;
int i915_debugfs_init(struct drm_minor *minor ) ;
void i915_debugfs_cleanup(struct drm_minor *minor ) ;
int i915_save_state(struct drm_device *dev ) ;
int i915_restore_state(struct drm_device *dev ) ;
__inline bool intel_gmbus_is_forced_bit(struct i2c_adapter *adapter )
{ struct i2c_adapter const *__mptr ;
  {
  __mptr = (struct i2c_adapter const *)adapter;
  return ((bool )((unsigned long )((struct intel_gmbus *)__mptr)->force_bit != (unsigned long )((struct i2c_adapter *)0)));
}
}
int intel_opregion_setup(struct drm_device *dev ) ;
void intel_opregion_init(struct drm_device *dev ) ;
void intel_opregion_fini(struct drm_device *dev ) ;
void ironlake_enable_rc6(struct drm_device *dev ) ;
void intel_detect_pch(struct drm_device *dev ) ;
void gen6_gt_force_wake_get(struct drm_i915_private *dev_priv ) ;
void gen6_gt_force_wake_put(struct drm_i915_private *dev_priv ) ;
void __gen6_gt_wait_for_fifo(struct drm_i915_private *dev_priv ) ;
__inline static u32 i915_read32(struct drm_i915_private *dev_priv , u32 reg )
{ u32 val ;
  {
  val = 0U;
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        gen6_gt_force_wake_get(dev_priv);
        val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
        gen6_gt_force_wake_put(dev_priv);
        }
      } else {
        {
        val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
        }
      }
    } else {
      {
      val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
      }
    }
  } else {
    {
    val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
    }
  }
  {
  trace_i915_reg_rw((bool )0, reg, (u64 )val, 4);
  }
  return (val);
}
}
__inline static void i915_write32(struct drm_i915_private *dev_priv , u32 reg , u32 val )
{
  {
  {
  trace_i915_reg_rw((bool )1, reg, (u64 )val, 4);
  }
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        __gen6_gt_wait_for_fifo(dev_priv);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  writel(val, (void volatile *)dev_priv->regs + (unsigned long )reg);
  }
  return;
}
}
extern int drm_helper_resume_force_mode(struct drm_device * ) ;
extern void drm_kms_helper_poll_disable(struct drm_device * ) ;
extern void drm_kms_helper_poll_enable(struct drm_device * ) ;
extern bool vgacon_text_force(void) ;
static int i915_modeset = -1;
unsigned int i915_fbpercrtc = 0U;
int i915_panel_ignore_lid = 0;
unsigned int i915_powersave = 1U;
unsigned int i915_semaphores = 0U;
unsigned int i915_enable_rc6 = 0U;
unsigned int i915_enable_fbc = 0U;
unsigned int i915_lvds_downclock = 0U;
unsigned int i915_panel_use_ssc = 1U;
int i915_vbt_sdvo_panel_type = -1;
static bool i915_try_reset = (bool )1;
static struct drm_driver driver ;
extern int intel_agp_enabled ;
static struct intel_device_info const intel_i830_info =
     {(u8 )2U, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0,
    (unsigned char)0};
static struct intel_device_info const intel_845g_info =
     {(u8 )2U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0,
    (unsigned char)0};
static struct intel_device_info const intel_i85x_info =
     {(u8 )2U, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0,
    (unsigned char)0};
static struct intel_device_info const intel_i865g_info =
     {(u8 )2U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0,
    (unsigned char)0};
static struct intel_device_info const intel_i915g_info =
     {(u8 )3U, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0,
    (unsigned char)0};
static struct intel_device_info const intel_i915gm_info =
     {(u8 )3U, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0,
    (unsigned char)0};
static struct intel_device_info const intel_i945g_info =
     {(u8 )3U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1,
    (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0,
    (unsigned char)0};
static struct intel_device_info const intel_i945gm_info =
     {(u8 )3U, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)1,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1,
    (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0,
    (unsigned char)0};
static struct intel_device_info const intel_i965g_info =
     {(u8 )4U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1,
    (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0};
static struct intel_device_info const intel_i965gm_info =
     {(u8 )4U, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)1,
    (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)0,
    (unsigned char)0};
static struct intel_device_info const intel_g33_info =
     {(u8 )3U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1,
    (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0};
static struct intel_device_info const intel_g45_info =
     {(u8 )4U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1,
    (unsigned char)0};
static struct intel_device_info const intel_gm45_info =
     {(u8 )4U, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1,
    (unsigned char)0};
static struct intel_device_info const intel_pineview_info =
     {(u8 )3U, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1,
    (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0};
static struct intel_device_info const intel_ironlake_d_info =
     {(u8 )5U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1,
    (unsigned char)0};
static struct intel_device_info const intel_ironlake_m_info =
     {(u8 )5U, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)1,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1,
    (unsigned char)0};
static struct intel_device_info const intel_sandybridge_d_info =
     {(u8 )6U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1,
    (unsigned char)1};
static struct intel_device_info const intel_sandybridge_m_info =
     {(u8 )6U, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)1,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1,
    (unsigned char)1};
static struct intel_device_info const intel_ivybridge_d_info =
     {(u8 )7U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)1,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1,
    (unsigned char)1};
static struct intel_device_info const intel_ivybridge_m_info =
     {(u8 )7U, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)1,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1,
    (unsigned char)1};
static struct pci_device_id const pciidlist[44U] =
  { {32902U, 13687U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_i830_info)},
        {32902U,
      9570U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_845g_info)},
        {32902U,
      13698U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_i85x_info)},
        {32902U,
      13710U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_i85x_info)},
        {32902U,
      9586U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_i865g_info)},
        {32902U,
      9602U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_i915g_info)},
        {32902U,
      9610U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_i915g_info)},
        {32902U,
      9618U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_i915gm_info)},
        {32902U,
      10098U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_i945g_info)},
        {32902U,
      10146U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_i945gm_info)},
        {32902U,
      10158U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_i945gm_info)},
        {32902U,
      10610U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_i965g_info)},
        {32902U,
      10626U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_i965g_info)},
        {32902U,
      10642U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_i965g_info)},
        {32902U,
      10658U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_i965g_info)},
        {32902U,
      10674U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_g33_info)},
        {32902U,
      10690U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_g33_info)},
        {32902U,
      10706U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_g33_info)},
        {32902U,
      10754U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_i965gm_info)},
        {32902U,
      10770U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_i965gm_info)},
        {32902U,
      10818U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_gm45_info)},
        {32902U,
      11778U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_g45_info)},
        {32902U,
      11794U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_g45_info)},
        {32902U,
      11810U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_g45_info)},
        {32902U,
      11826U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_g45_info)},
        {32902U,
      11842U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_g45_info)},
        {32902U,
      11922U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_g45_info)},
        {32902U,
      40961U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_pineview_info)},
        {32902U,
      40977U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_pineview_info)},
        {32902U,
      66U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_ironlake_d_info)},
        {32902U,
      70U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_ironlake_m_info)},
        {32902U,
      258U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_sandybridge_d_info)},
        {32902U,
      274U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_sandybridge_d_info)},
        {32902U,
      290U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_sandybridge_d_info)},
        {32902U,
      262U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_sandybridge_m_info)},
        {32902U,
      278U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_sandybridge_m_info)},
        {32902U,
      294U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_sandybridge_m_info)},
        {32902U,
      266U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_sandybridge_d_info)},
        {32902U,
      342U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_ivybridge_m_info)},
        {32902U,
      358U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_ivybridge_m_info)},
        {32902U,
      338U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_ivybridge_d_info)},
        {32902U,
      354U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_ivybridge_d_info)},
        {32902U,
      346U, 4294967295U, 4294967295U, 196608U, 16711680U, (unsigned long )(& intel_ivybridge_d_info)},
        {0U,
      0U, 0U, 0U, 0U, 0U, 0UL}};
struct pci_device_id const __mod_pci_device_table ;
void intel_detect_pch(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct pci_dev *pch ;
  int id ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  pch = pci_get_class(393472U, (struct pci_dev *)0);
  }
  if ((unsigned long )pch != (unsigned long )((struct pci_dev *)0)) {
    if ((unsigned int )pch->vendor == 32902U) {
      id = (int )pch->device & 65280;
      if (id == 15104) {
        {
        dev_priv->pch_type = (enum intel_pch )0;
        drm_ut_debug_printk(4U, "drm", "intel_detect_pch", "Found Ibex Peak PCH\n");
        }
      } else
      if (id == 7168) {
        {
        dev_priv->pch_type = (enum intel_pch )1;
        drm_ut_debug_printk(4U, "drm", "intel_detect_pch", "Found CougarPoint PCH\n");
        }
      } else
      if (id == 7680) {
        {
        dev_priv->pch_type = (enum intel_pch )1;
        drm_ut_debug_printk(4U, "drm", "intel_detect_pch", "Found PatherPoint PCH\n");
        }
      } else {
      }
    } else {
    }
    {
    pci_dev_put(pch);
    }
  } else {
  }
  return;
}
}
static void __gen6_gt_force_wake_get(struct drm_i915_private *dev_priv )
{ int count ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  {
  count = 0;
  goto ldv_37927;
  ldv_37926:
  {
  __const_udelay(42950UL);
  }
  ldv_37927:
  tmp = count;
  count = count + 1;
  if (tmp <= 49) {
    {
    tmp___0 = readl((void const volatile *)dev_priv->regs + 1245328U);
    }
    if ((int )tmp___0 & 1) {
      goto ldv_37926;
    } else {
      goto ldv_37928;
    }
  } else {
    goto ldv_37928;
  }
  ldv_37928:
  {
  writel(1U, (void volatile *)dev_priv->regs + 41356U);
  readl((void const volatile *)dev_priv->regs + 41356U);
  count = 0;
  }
  goto ldv_37930;
  ldv_37929:
  {
  __const_udelay(42950UL);
  }
  ldv_37930:
  tmp___1 = count;
  count = count + 1;
  if (tmp___1 <= 49) {
    {
    tmp___2 = readl((void const volatile *)dev_priv->regs + 1245328U);
    }
    if ((tmp___2 & 1U) == 0U) {
      goto ldv_37929;
    } else {
      goto ldv_37931;
    }
  } else {
    goto ldv_37931;
  }
  ldv_37931: ;
  return;
}
}
void gen6_gt_force_wake_get(struct drm_i915_private *dev_priv )
{ int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  {
  {
  tmp = mutex_is_locked(& (dev_priv->dev)->struct_mutex);
  __ret_warn_on = tmp == 0;
  tmp___0 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp___0 != 0L) {
    {
    warn_slowpath_null("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_drv.c.p",
                       (int const )330);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on != 0), 0L);
  tmp___1 = atomic_add_return(1, & dev_priv->forcewake_count);
  }
  if (tmp___1 == 1) {
    {
    __gen6_gt_force_wake_get(dev_priv);
    }
  } else {
  }
  return;
}
}
static void __gen6_gt_force_wake_put(struct drm_i915_private *dev_priv )
{
  {
  {
  writel(0U, (void volatile *)dev_priv->regs + 41356U);
  readl((void const volatile *)dev_priv->regs + 41356U);
  }
  return;
}
}
void gen6_gt_force_wake_put(struct drm_i915_private *dev_priv )
{ int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  {
  {
  tmp = mutex_is_locked(& (dev_priv->dev)->struct_mutex);
  __ret_warn_on = tmp == 0;
  tmp___0 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp___0 != 0L) {
    {
    warn_slowpath_null("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_drv.c.p",
                       (int const )348);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on != 0), 0L);
  tmp___1 = atomic_dec_and_test(& dev_priv->forcewake_count);
  }
  if (tmp___1 != 0) {
    {
    __gen6_gt_force_wake_put(dev_priv);
    }
  } else {
  }
  return;
}
}
void __gen6_gt_wait_for_fifo(struct drm_i915_private *dev_priv )
{ int loop ;
  u32 fifo ;
  unsigned int tmp ;
  int tmp___0 ;
  {
  {
  loop = 500;
  tmp = readl((void const volatile *)dev_priv->regs + 1179656U);
  fifo = tmp;
  }
  goto ldv_37951;
  ldv_37950:
  {
  __const_udelay(42950UL);
  fifo = readl((void const volatile *)dev_priv->regs + 1179656U);
  }
  ldv_37951: ;
  if (fifo <= 19U) {
    tmp___0 = loop;
    loop = loop - 1;
    if (tmp___0 != 0) {
      goto ldv_37950;
    } else {
      goto ldv_37952;
    }
  } else {
    goto ldv_37952;
  }
  ldv_37952: ;
  return;
}
}
static int i915_drm_freeze(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  int error ;
  int tmp ;
  int tmp___0 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  drm_kms_helper_poll_disable(dev);
  pci_save_state(dev->pdev);
  tmp___0 = drm_core_check_feature(dev, 8192);
  }
  if (tmp___0 != 0) {
    {
    tmp = i915_gem_idle(dev);
    error = tmp;
    }
    if (error != 0) {
      {
      dev_err((struct device const *)(& (dev->pdev)->dev), "GEM idle failed, resume might fail\n");
      }
      return (error);
    } else {
    }
    {
    drm_irq_uninstall(dev);
    }
  } else {
  }
  {
  i915_save_state(dev);
  intel_opregion_fini(dev);
  dev_priv->modeset_on_lid = (bool )0;
  }
  return (0);
}
}
int i915_suspend(struct drm_device *dev , pm_message_t state )
{ int error ;
  {
  if ((unsigned long )dev == (unsigned long )((struct drm_device *)0)) {
    {
    drm_err("i915_suspend", "dev: %p\n", dev);
    drm_err("i915_suspend", "DRM not initialized, aborting suspend.\n");
    }
    return (-19);
  } else
  if ((unsigned long )dev->dev_private == (unsigned long )((void *)0)) {
    {
    drm_err("i915_suspend", "dev: %p\n", dev);
    drm_err("i915_suspend", "DRM not initialized, aborting suspend.\n");
    }
    return (-19);
  } else {
  }
  if (state.event == 8) {
    return (0);
  } else {
  }
  if (dev->switch_power_state == 1) {
    return (0);
  } else {
  }
  {
  error = i915_drm_freeze(dev);
  }
  if (error != 0) {
    return (error);
  } else {
  }
  if (state.event == 2) {
    {
    pci_disable_device(dev->pdev);
    pci_set_power_state(dev->pdev, 3);
    }
  } else {
  }
  return (0);
}
}
static int i915_drm_thaw(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  int error ;
  int tmp ;
  int tmp___0 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  error = 0;
  tmp = drm_core_check_feature(dev, 8192);
  }
  if (tmp != 0) {
    {
    mutex_lock_nested(& dev->struct_mutex, 0U);
    i915_gem_restore_gtt_mappings(dev);
    mutex_unlock(& dev->struct_mutex);
    }
  } else {
  }
  {
  i915_restore_state(dev);
  intel_opregion_setup(dev);
  tmp___0 = drm_core_check_feature(dev, 8192);
  }
  if (tmp___0 != 0) {
    {
    mutex_lock_nested(& dev->struct_mutex, 0U);
    dev_priv->mm.suspended = 0;
    error = i915_gem_init_ringbuffer(dev);
    mutex_unlock(& dev->struct_mutex);
    drm_mode_config_reset(dev);
    drm_irq_install(dev);
    drm_helper_resume_force_mode(dev);
    }
    if (dev->pci_device == 70) {
      {
      ironlake_enable_rc6(dev);
      }
    } else {
    }
  } else {
  }
  {
  intel_opregion_init(dev);
  dev_priv->modeset_on_lid = (bool )0;
  }
  return (error);
}
}
int i915_resume(struct drm_device *dev )
{ int ret ;
  int tmp ;
  {
  if (dev->switch_power_state == 1) {
    return (0);
  } else {
  }
  {
  tmp = pci_enable_device(dev->pdev);
  }
  if (tmp != 0) {
    return (-5);
  } else {
  }
  {
  pci_set_master(dev->pdev);
  ret = i915_drm_thaw(dev);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  drm_kms_helper_poll_enable(dev);
  }
  return (0);
}
}
static int i8xx_do_reset(struct drm_device *dev , u8 flags )
{ struct drm_i915_private *dev_priv ;
  u32 tmp ;
  u32 tmp___0 ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    return (-19);
  } else {
  }
  {
  tmp = i915_read32(dev_priv, 24836U);
  i915_write32(dev_priv, 24836U, tmp | 64U);
  readl((void const volatile *)dev_priv->regs + 24836U);
  }
  if (dev->pci_device == 13687) {
    {
    i915_write32(dev_priv, 24688U, 896U);
    readl((void const volatile *)dev_priv->regs + 24688U);
    msleep(1U);
    i915_write32(dev_priv, 24688U, 0U);
    readl((void const volatile *)dev_priv->regs + 24688U);
    }
  } else
  if (dev->pci_device == 9570) {
    {
    i915_write32(dev_priv, 24688U, 896U);
    readl((void const volatile *)dev_priv->regs + 24688U);
    msleep(1U);
    i915_write32(dev_priv, 24688U, 0U);
    readl((void const volatile *)dev_priv->regs + 24688U);
    }
  } else {
  }
  {
  msleep(1U);
  tmp___0 = i915_read32(dev_priv, 24836U);
  i915_write32(dev_priv, 24836U, tmp___0 & 4294967231U);
  readl((void const volatile *)dev_priv->regs + 24836U);
  }
  return (0);
}
}
static int i965_reset_complete(struct drm_device *dev )
{ u8 gdrst ;
  {
  {
  pci_read_config_byte(dev->pdev, 192, & gdrst);
  }
  return ((int )gdrst & 1);
}
}
static int i965_do_reset(struct drm_device *dev , u8 flags )
{ u8 gdrst ;
  unsigned long timeout__ ;
  unsigned long tmp ;
  int ret__ ;
  struct thread_info *tmp___0 ;
  int pfo_ret__ ;
  int tmp___1 ;
  int tmp___2 ;
  {
  {
  pci_read_config_byte(dev->pdev, 192, & gdrst);
  pci_write_config_byte(dev->pdev, 192, (u8 )((int )((unsigned int )((int )gdrst | (int )flags) | 1U)));
  tmp = msecs_to_jiffies((unsigned int const )500U);
  timeout__ = tmp + (unsigned long )jiffies;
  ret__ = 0;
  }
  goto ldv_38005;
  ldv_38004: ;
  if ((long )timeout__ - (long )jiffies < 0L) {
    ret__ = -110;
    goto ldv_37995;
  } else {
  }
  {
  tmp___0 = current_thread_info();
  }
  if ((tmp___0->preempt_count & -268435457) == 0) {
    if (1) {
      goto case_4;
    } else {
      goto switch_default;
      if (0) {
        __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
        goto ldv_37998;
        __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_37998;
        case_4:
        __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_37998;
        __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_37998;
        switch_default:
        {
        __bad_percpu_size();
        }
      } else {
      }
    }
    ldv_37998:
    {
    tmp___1 = atomic_read((atomic_t const *)(& kgdb_active));
    }
    if (pfo_ret__ != tmp___1) {
      {
      msleep(1U);
      }
    } else {
    }
  } else {
  }
  ldv_38005:
  {
  tmp___2 = i965_reset_complete(dev);
  }
  if (tmp___2 == 0) {
    goto ldv_38004;
  } else {
    goto ldv_37995;
  }
  ldv_37995: ;
  return (ret__);
}
}
static int ironlake_do_reset(struct drm_device *dev , u8 flags )
{ struct drm_i915_private *dev_priv ;
  u32 gdrst ;
  u32 tmp ;
  unsigned long timeout__ ;
  unsigned long tmp___0 ;
  int ret__ ;
  struct thread_info *tmp___1 ;
  int pfo_ret__ ;
  int tmp___2 ;
  u32 tmp___3 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = i915_read32(dev_priv, 76964U);
  gdrst = tmp;
  i915_write32(dev_priv, 76964U, ((u32 )flags | gdrst) | 1U);
  tmp___0 = msecs_to_jiffies((unsigned int const )500U);
  timeout__ = tmp___0 + (unsigned long )jiffies;
  ret__ = 0;
  }
  goto ldv_38031;
  ldv_38030: ;
  if ((long )timeout__ - (long )jiffies < 0L) {
    ret__ = -110;
    goto ldv_38021;
  } else {
  }
  {
  tmp___1 = current_thread_info();
  }
  if ((tmp___1->preempt_count & -268435457) == 0) {
    if (1) {
      goto case_4;
    } else {
      goto switch_default;
      if (0) {
        __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
        goto ldv_38024;
        __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_38024;
        case_4:
        __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_38024;
        __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_38024;
        switch_default:
        {
        __bad_percpu_size();
        }
      } else {
      }
    }
    ldv_38024:
    {
    tmp___2 = atomic_read((atomic_t const *)(& kgdb_active));
    }
    if (pfo_ret__ != tmp___2) {
      {
      msleep(1U);
      }
    } else {
    }
  } else {
  }
  ldv_38031:
  {
  tmp___3 = i915_read32(dev_priv, 76964U);
  }
  if ((tmp___3 & 1U) == 0U) {
    goto ldv_38030;
  } else {
    goto ldv_38021;
  }
  ldv_38021: ;
  return (ret__);
}
}
static int gen6_do_reset(struct drm_device *dev , u8 flags )
{ struct drm_i915_private *dev_priv ;
  unsigned long timeout__ ;
  unsigned long tmp ;
  int ret__ ;
  struct thread_info *tmp___0 ;
  int pfo_ret__ ;
  int tmp___1 ;
  u32 tmp___2 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  i915_write32(dev_priv, 37916U, 1U);
  tmp = msecs_to_jiffies((unsigned int const )500U);
  timeout__ = tmp + (unsigned long )jiffies;
  ret__ = 0;
  }
  goto ldv_38056;
  ldv_38055: ;
  if ((long )timeout__ - (long )jiffies < 0L) {
    ret__ = -110;
    goto ldv_38046;
  } else {
  }
  {
  tmp___0 = current_thread_info();
  }
  if ((tmp___0->preempt_count & -268435457) == 0) {
    if (1) {
      goto case_4;
    } else {
      goto switch_default;
      if (0) {
        __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
        goto ldv_38049;
        __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_38049;
        case_4:
        __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_38049;
        __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_38049;
        switch_default:
        {
        __bad_percpu_size();
        }
      } else {
      }
    }
    ldv_38049:
    {
    tmp___1 = atomic_read((atomic_t const *)(& kgdb_active));
    }
    if (pfo_ret__ != tmp___1) {
      {
      msleep(1U);
      }
    } else {
    }
  } else {
  }
  ldv_38056:
  {
  tmp___2 = i915_read32(dev_priv, 37916U);
  }
  if ((int )tmp___2 & 1) {
    goto ldv_38055;
  } else {
    goto ldv_38046;
  }
  ldv_38046: ;
  return (ret__);
}
}
int i915_reset(struct drm_device *dev , u8 flags )
{ drm_i915_private_t *dev_priv ;
  bool need_display ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  need_display = (bool )1;
  if (! i915_try_reset) {
    return (0);
  } else {
  }
  {
  tmp = mutex_trylock(& dev->struct_mutex);
  }
  if (tmp == 0) {
    return (-16);
  } else {
  }
  {
  i915_gem_reset(dev);
  ret = -19;
  tmp___1 = get_seconds();
  }
  if (tmp___1 - dev_priv->last_gpu_reset <= 4UL) {
    {
    drm_err("i915_reset", "GPU hanging too fast, declaring wedged!\n");
    }
  } else {
    if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 7) {
      goto case_7;
    } else
    if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 6) {
      goto case_6;
    } else
    if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 5) {
      goto case_5;
    } else
    if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 4) {
      goto case_4;
    } else
    if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 2) {
      goto case_2;
    } else
    if (0) {
      case_7: ;
      case_6:
      {
      ret = gen6_do_reset(dev, (u8 )((int )flags));
      tmp___0 = atomic_read((atomic_t const *)(& dev_priv->forcewake_count));
      }
      if (tmp___0 != 0) {
        {
        __gen6_gt_force_wake_get(dev_priv);
        }
      } else {
      }
      goto ldv_38068;
      case_5:
      {
      ret = ironlake_do_reset(dev, (u8 )((int )flags));
      }
      goto ldv_38068;
      case_4:
      {
      ret = i965_do_reset(dev, (u8 )((int )flags));
      }
      goto ldv_38068;
      case_2:
      {
      ret = i8xx_do_reset(dev, (u8 )((int )flags));
      }
      goto ldv_38068;
    } else {
    }
    ldv_38068: ;
  }
  {
  dev_priv->last_gpu_reset = get_seconds();
  }
  if (ret != 0) {
    {
    drm_err("i915_reset", "Failed to reset chip.\n");
    mutex_unlock(& dev->struct_mutex);
    }
    return (ret);
  } else {
  }
  {
  tmp___2 = drm_core_check_feature(dev, 8192);
  }
  if (tmp___2 != 0) {
    goto _L;
  } else
  if (dev_priv->mm.suspended == 0) {
    _L:
    {
    dev_priv->mm.suspended = 0;
    (*(dev_priv->ring[0].init))((struct intel_ring_buffer *)(& dev_priv->ring));
    }
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 3UL) != 0U) {
      {
      (*(dev_priv->ring[1].init))((struct intel_ring_buffer *)(& dev_priv->ring) + 1UL);
      }
    } else {
    }
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 3UL) != 0U) {
      {
      (*(dev_priv->ring[2].init))((struct intel_ring_buffer *)(& dev_priv->ring) + 2UL);
      }
    } else {
    }
    {
    mutex_unlock(& dev->struct_mutex);
    drm_irq_uninstall(dev);
    drm_mode_config_reset(dev);
    drm_irq_install(dev);
    mutex_lock_nested(& dev->struct_mutex, 0U);
    }
  } else {
  }
  {
  mutex_unlock(& dev->struct_mutex);
  }
  if ((int )need_display) {
    {
    mutex_lock_nested(& dev->mode_config.mutex, 0U);
    drm_helper_resume_force_mode(dev);
    mutex_unlock(& dev->mode_config.mutex);
    }
  } else {
  }
  return (0);
}
}
static int i915_pci_probe(struct pci_dev *pdev , struct pci_device_id const *ent )
{ int tmp ;
  {
  if ((pdev->devfn & 7U) != 0U) {
    return (-19);
  } else {
  }
  {
  tmp = drm_get_pci_dev(pdev, ent, & driver);
  }
  return (tmp);
}
}
static void i915_pci_remove(struct pci_dev *pdev )
{ struct drm_device *dev ;
  void *tmp ;
  {
  {
  tmp = pci_get_drvdata(pdev);
  dev = (struct drm_device *)tmp;
  drm_put_dev(dev);
  }
  return;
}
}
static int i915_pm_suspend(struct device *dev )
{ struct pci_dev *pdev ;
  struct device const *__mptr ;
  struct drm_device *drm_dev ;
  void *tmp ;
  int error ;
  {
  {
  __mptr = (struct device const *)dev;
  pdev = (struct pci_dev *)__mptr + 0x0fffffffffffff70UL;
  tmp = pci_get_drvdata(pdev);
  drm_dev = (struct drm_device *)tmp;
  }
  if ((unsigned long )drm_dev == (unsigned long )((struct drm_device *)0)) {
    {
    dev_err((struct device const *)dev, "DRM not initialized, aborting suspend.\n");
    }
    return (-19);
  } else
  if ((unsigned long )drm_dev->dev_private == (unsigned long )((void *)0)) {
    {
    dev_err((struct device const *)dev, "DRM not initialized, aborting suspend.\n");
    }
    return (-19);
  } else {
  }
  if (drm_dev->switch_power_state == 1) {
    return (0);
  } else {
  }
  {
  error = i915_drm_freeze(drm_dev);
  }
  if (error != 0) {
    return (error);
  } else {
  }
  {
  pci_disable_device(pdev);
  pci_set_power_state(pdev, 3);
  }
  return (0);
}
}
static int i915_pm_resume(struct device *dev )
{ struct pci_dev *pdev ;
  struct device const *__mptr ;
  struct drm_device *drm_dev ;
  void *tmp ;
  int tmp___0 ;
  {
  {
  __mptr = (struct device const *)dev;
  pdev = (struct pci_dev *)__mptr + 0x0fffffffffffff70UL;
  tmp = pci_get_drvdata(pdev);
  drm_dev = (struct drm_device *)tmp;
  tmp___0 = i915_resume(drm_dev);
  }
  return (tmp___0);
}
}
static int i915_pm_freeze(struct device *dev )
{ struct pci_dev *pdev ;
  struct device const *__mptr ;
  struct drm_device *drm_dev ;
  void *tmp ;
  int tmp___0 ;
  {
  {
  __mptr = (struct device const *)dev;
  pdev = (struct pci_dev *)__mptr + 0x0fffffffffffff70UL;
  tmp = pci_get_drvdata(pdev);
  drm_dev = (struct drm_device *)tmp;
  }
  if ((unsigned long )drm_dev == (unsigned long )((struct drm_device *)0)) {
    {
    dev_err((struct device const *)dev, "DRM not initialized, aborting suspend.\n");
    }
    return (-19);
  } else
  if ((unsigned long )drm_dev->dev_private == (unsigned long )((void *)0)) {
    {
    dev_err((struct device const *)dev, "DRM not initialized, aborting suspend.\n");
    }
    return (-19);
  } else {
  }
  {
  tmp___0 = i915_drm_freeze(drm_dev);
  }
  return (tmp___0);
}
}
static int i915_pm_thaw(struct device *dev )
{ struct pci_dev *pdev ;
  struct device const *__mptr ;
  struct drm_device *drm_dev ;
  void *tmp ;
  int tmp___0 ;
  {
  {
  __mptr = (struct device const *)dev;
  pdev = (struct pci_dev *)__mptr + 0x0fffffffffffff70UL;
  tmp = pci_get_drvdata(pdev);
  drm_dev = (struct drm_device *)tmp;
  tmp___0 = i915_drm_thaw(drm_dev);
  }
  return (tmp___0);
}
}
static int i915_pm_poweroff(struct device *dev )
{ struct pci_dev *pdev ;
  struct device const *__mptr ;
  struct drm_device *drm_dev ;
  void *tmp ;
  int tmp___0 ;
  {
  {
  __mptr = (struct device const *)dev;
  pdev = (struct pci_dev *)__mptr + 0x0fffffffffffff70UL;
  tmp = pci_get_drvdata(pdev);
  drm_dev = (struct drm_device *)tmp;
  tmp___0 = i915_drm_freeze(drm_dev);
  }
  return (tmp___0);
}
}
static struct dev_pm_ops const i915_pm_ops =
     {(int (*)(struct device * ))0, (void (*)(struct device * ))0, & i915_pm_suspend,
    & i915_pm_resume, & i915_pm_freeze, & i915_pm_thaw, & i915_pm_poweroff, & i915_pm_resume,
    (int (*)(struct device * ))0, (int (*)(struct device * ))0, (int (*)(struct device * ))0,
    (int (*)(struct device * ))0, (int (*)(struct device * ))0, (int (*)(struct device * ))0,
    (int (*)(struct device * ))0, (int (*)(struct device * ))0, (int (*)(struct device * ))0};
static struct vm_operations_struct i915_gem_vm_ops =
     {& drm_gem_vm_open, & drm_gem_vm_close, & i915_gem_fault, (int (*)(struct vm_area_struct * ,
                                                                      struct vm_fault * ))0,
    (int (*)(struct vm_area_struct * , unsigned long , void * , int , int ))0,
    (int (*)(struct vm_area_struct * , struct mempolicy * ))0, (struct mempolicy *(*)(struct vm_area_struct * ,
                                                                                      unsigned long ))0,
    (int (*)(struct vm_area_struct * , nodemask_t const * , nodemask_t const * ,
             unsigned long ))0};
static struct drm_driver driver =
     {& i915_driver_load, (int (*)(struct drm_device * ))0, & i915_driver_open, & i915_driver_preclose,
    & i915_driver_postclose, & i915_driver_lastclose, & i915_driver_unload, & i915_suspend,
    & i915_resume, (int (*)(struct drm_device * , void * , struct drm_file * ))0,
    (int (*)(struct drm_device * ))0, (int (*)(struct drm_device * , int ))0, (u32 (*)(struct drm_device * ,
                                                                                        int ))0,
    (int (*)(struct drm_device * , int ))0, (void (*)(struct drm_device * , int ))0,
    & i915_driver_device_is_agp, (int (*)(struct drm_device * , int , int * , int * ))0,
    (int (*)(struct drm_device * , int , int * , struct timeval * , unsigned int ))0,
    (irqreturn_t (*)(int , void * ))0, (void (*)(struct drm_device * ))0, (int (*)(struct drm_device * ))0,
    (void (*)(struct drm_device * ))0, & drm_core_reclaim_buffers, (void (*)(struct drm_device * ,
                                                                             struct drm_file * ))0,
    (void (*)(struct drm_device * , struct drm_file * ))0, (void (*)(struct drm_device * ,
                                                                     struct drm_set_version * ))0,
    & i915_master_create, & i915_master_destroy, (int (*)(struct drm_device * , struct drm_file * ,
                                                          bool ))0, (void (*)(struct drm_device * ,
                                                                               struct drm_file * ,
                                                                               bool ))0,
    & i915_debugfs_init, & i915_debugfs_cleanup, & i915_gem_init_object, & i915_gem_free_object,
    (void (*)(struct drm_device * , bool ))0, & i915_gem_dumb_create, & i915_gem_mmap_gtt,
    & i915_gem_dumb_destroy, & i915_gem_vm_ops, 1, 6, 0, (char *)"i915", (char *)"Intel Graphics",
    (char *)"20080730", 4291U, 0, (struct drm_ioctl_desc *)(& i915_ioctls), 0, {& __this_module,
                                                                                & noop_llseek,
                                                                                & drm_read,
                                                                                (ssize_t (*)(struct file * ,
                                                                                             char const * ,
                                                                                             size_t ,
                                                                                             loff_t * ))0,
                                                                                (ssize_t (*)(struct kiocb * ,
                                                                                             struct iovec const * ,
                                                                                             unsigned long ,
                                                                                             loff_t ))0,
                                                                                (ssize_t (*)(struct kiocb * ,
                                                                                             struct iovec const * ,
                                                                                             unsigned long ,
                                                                                             loff_t ))0,
                                                                                (int (*)(struct file * ,
                                                                                         void * ,
                                                                                         int (*)(void * ,
                                                                                                 char const * ,
                                                                                                 int ,
                                                                                                 loff_t ,
                                                                                                 u64 ,
                                                                                                 unsigned int ) ))0,
                                                                                & drm_poll,
                                                                                & drm_ioctl,
                                                                                & i915_compat_ioctl,
                                                                                & drm_gem_mmap,
                                                                                & drm_open,
                                                                                (int (*)(struct file * ,
                                                                                         fl_owner_t ))0,
                                                                                & drm_release,
                                                                                (int (*)(struct file * ,
                                                                                         int ))0,
                                                                                (int (*)(struct kiocb * ,
                                                                                         int ))0,
                                                                                & drm_fasync,
                                                                                (int (*)(struct file * ,
                                                                                         int ,
                                                                                         struct file_lock * ))0,
                                                                                (ssize_t (*)(struct file * ,
                                                                                             struct page * ,
                                                                                             int ,
                                                                                             size_t ,
                                                                                             loff_t * ,
                                                                                             int ))0,
                                                                                (unsigned long (*)(struct file * ,
                                                                                                   unsigned long ,
                                                                                                   unsigned long ,
                                                                                                   unsigned long ,
                                                                                                   unsigned long ))0,
                                                                                (int (*)(int ))0,
                                                                                (int (*)(struct file * ,
                                                                                         int ,
                                                                                         struct file_lock * ))0,
                                                                                (ssize_t (*)(struct pipe_inode_info * ,
                                                                                             struct file * ,
                                                                                             loff_t * ,
                                                                                             size_t ,
                                                                                             unsigned int ))0,
                                                                                (ssize_t (*)(struct file * ,
                                                                                             loff_t * ,
                                                                                             struct pipe_inode_info * ,
                                                                                             size_t ,
                                                                                             unsigned int ))0,
                                                                                (int (*)(struct file * ,
                                                                                         long ,
                                                                                         struct file_lock ** ))0,
                                                                                (long (*)(struct file * ,
                                                                                          int ,
                                                                                          loff_t ,
                                                                                          loff_t ))0},
    {(struct pci_driver *)0}, (struct drm_bus *)0, {(struct list_head *)0, (struct list_head *)0}};
static struct pci_driver i915_pci_driver =
     {{(struct list_head *)0, (struct list_head *)0}, "i915", (struct pci_device_id const *)(& pciidlist),
    & i915_pci_probe, & i915_pci_remove, (int (*)(struct pci_dev * , pm_message_t ))0,
    (int (*)(struct pci_dev * , pm_message_t ))0, (int (*)(struct pci_dev * ))0,
    (int (*)(struct pci_dev * ))0, (void (*)(struct pci_dev * ))0, (struct pci_error_handlers *)0,
    {(char const *)0, (struct bus_type *)0, (struct module *)0, (char const *)0,
     (_Bool)0, (struct of_device_id const *)0, (int (*)(struct device * ))0, (int (*)(struct device * ))0,
     (void (*)(struct device * ))0, (int (*)(struct device * , pm_message_t ))0,
     (int (*)(struct device * ))0, (struct attribute_group const **)0, & i915_pm_ops,
     (struct driver_private *)0}, {{{{{0U}, 0U, 0U, (void *)0, {(struct lock_class_key *)0,
                                                                {(struct lock_class *)0,
                                                                 (struct lock_class *)0},
                                                                (char const *)0,
                                                                0, 0UL}}}}, {(struct list_head *)0,
                                                                             (struct list_head *)0}}};
static int i915_init(void)
{ bool tmp ;
  int tmp___0 ;
  {
  if (intel_agp_enabled == 0) {
    {
    drm_err("i915_init", "drm/i915 can\'t work without intel_agp module!\n");
    }
    return (-19);
  } else {
  }
  driver.num_ioctls = i915_max_ioctl;
  if (i915_modeset != 0) {
    driver.driver_features = driver.driver_features | 8192U;
  } else {
  }
  if (i915_modeset == 1) {
    driver.driver_features = driver.driver_features | 8192U;
  } else {
  }
  {
  tmp = vgacon_text_force();
  }
  if ((int )tmp) {
    if (i915_modeset == -1) {
      driver.driver_features = driver.driver_features & 4294959103U;
    } else {
    }
  } else {
  }
  if ((driver.driver_features & 8192U) == 0U) {
    driver.get_vblank_timestamp = (int (*)(struct drm_device * , int , int * , struct timeval * ,
                                           unsigned int ))0;
  } else {
  }
  {
  tmp___0 = drm_pci_init(& driver, & i915_pci_driver);
  }
  return (tmp___0);
}
}
static void i915_exit(void)
{
  {
  {
  drm_pci_exit(& driver, & i915_pci_driver);
  }
  return;
}
}
void ldv_check_final_state(void) ;
extern void ldv_check_return_value(int ) ;
extern void ldv_initialize(void) ;
extern int __VERIFIER_nondet_int(void) ;
int LDV_IN_INTERRUPT ;
void ldv_blast_assert(void)
{
  {
  ERROR: __VERIFIER_error();
}
}
extern int ldv_undefined_int(void) ;
int ldv_module_refcounter = 1;
void ldv_module_get(struct module *module )
{
  {
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    ldv_module_refcounter = ldv_module_refcounter + 1;
  } else {
  }
  return;
}
}
int ldv_try_module_get(struct module *module )
{ int module_get_succeeded ;
  {
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    {
    module_get_succeeded = ldv_undefined_int();
    }
    if (module_get_succeeded == 1) {
      ldv_module_refcounter = ldv_module_refcounter + 1;
      return (1);
    } else {
      return (0);
    }
  } else {
  }
  return (0);
}
}
void ldv_module_put(struct module *module )
{
  {
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    if (ldv_module_refcounter <= 1) {
      {
      ldv_blast_assert();
      }
    } else {
    }
    ldv_module_refcounter = ldv_module_refcounter - 1;
  } else {
  }
  return;
}
}
void ldv_module_put_and_exit(void)
{
  {
  {
  ldv_module_put((struct module *)1);
  }
  LDV_STOP: ;
  goto LDV_STOP;
}
}
unsigned int ldv_module_refcount(void)
{
  {
  return ((unsigned int )(ldv_module_refcounter + -1));
}
}
void ldv_check_final_state(void)
{
  {
  if (ldv_module_refcounter != 1) {
    {
    ldv_blast_assert();
    }
  } else {
  }
  return;
}
}
__inline static void INIT_LIST_HEAD(struct list_head *list )
{
  {
  list->next = list;
  list->prev = list;
  return;
}
}
extern int printk(char const * , ...) ;
extern void warn_slowpath_fmt(char const * , int const , char const * , ...) ;
extern void might_fault(void) ;
extern void *memset(void * , int , size_t ) ;
__inline static u64 div_u64_rem(u64 dividend , u32 divisor , u32 *remainder )
{
  {
  *remainder = (u32 )(dividend % (u64 )divisor);
  return (dividend / (u64 )divisor);
}
}
__inline static u64 div_u64(u64 dividend , u32 divisor )
{ u32 remainder ;
  u64 tmp ;
  {
  {
  tmp = div_u64_rem(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
extern void __raw_spin_lock_init(raw_spinlock_t * , char const * , struct lock_class_key * ) ;
extern void _raw_spin_lock(raw_spinlock_t * ) ;
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock )
{
  {
  return (& lock->ldv_6060.rlock);
}
}
__inline static void spin_lock(spinlock_t *lock )
{
  {
  {
  _raw_spin_lock(& lock->ldv_6060.rlock);
  }
  return;
}
}
__inline static void spin_unlock(spinlock_t *lock )
{
  {
  {
  _raw_spin_unlock(& lock->ldv_6060.rlock);
  }
  return;
}
}
extern void set_normalized_timespec(struct timespec * , time_t , s64 ) ;
__inline static struct timespec timespec_sub(struct timespec lhs , struct timespec rhs )
{ struct timespec ts_delta ;
  {
  {
  set_normalized_timespec(& ts_delta, lhs.tv_sec - rhs.tv_sec, (s64 )(lhs.tv_nsec - rhs.tv_nsec));
  }
  return (ts_delta);
}
}
extern void getrawmonotonic(struct timespec * ) ;
extern unsigned long pci_mem_start ;
extern int release_resource(struct resource * ) ;
extern unsigned int jiffies_to_msecs(unsigned long const ) ;
extern void init_timer_key(struct timer_list * , char const * , struct lock_class_key * ) ;
__inline static void setup_timer_key(struct timer_list *timer , char const *name ,
                                     struct lock_class_key *key , void (*function)(unsigned long ) ,
                                     unsigned long data )
{
  {
  {
  timer->function = function;
  timer->data = data;
  init_timer_key(timer, name, key);
  }
  return;
}
}
extern int del_timer_sync(struct timer_list * ) ;
extern struct workqueue_struct *__alloc_workqueue_key(char const * , unsigned int ,
                                                      int , struct lock_class_key * ,
                                                      char const * ) ;
extern void destroy_workqueue(struct workqueue_struct * ) ;
extern void flush_workqueue(struct workqueue_struct * ) ;
extern bool cancel_work_sync(struct work_struct * ) ;
extern bool cancel_delayed_work_sync(struct delayed_work * ) ;
__inline static unsigned char readb(void const volatile *addr )
{ unsigned char ret ;
  {
  __asm__ volatile ("movb %1,%0": "=q" (ret): "m" (*((unsigned char volatile *)addr)): "memory");
  return (ret);
}
}
__inline static unsigned short readw(void const volatile *addr )
{ unsigned short ret ;
  {
  __asm__ volatile ("movw %1,%0": "=r" (ret): "m" (*((unsigned short volatile *)addr)): "memory");
  return (ret);
}
}
extern void iounmap(void volatile * ) ;
extern unsigned int ioread32(void * ) ;
extern void iowrite32(u32 , void * ) ;
extern void *pci_iomap(struct pci_dev * , int , unsigned long ) ;
extern void pci_iounmap(struct pci_dev * , void * ) ;
__inline static void memset_io(void volatile *addr , unsigned char val , size_t count )
{
  {
  {
  memset((void *)addr, (int )val, count);
  }
  return;
}
}
extern void *ioremap_wc(resource_size_t , unsigned long ) ;
extern void kfree(void const * ) ;
extern void *__symbol_get(char const * ) ;
extern void __symbol_put(char const * ) ;
extern void *__kmalloc(size_t , gfp_t ) ;
__inline static void *kmalloc(size_t size , gfp_t flags )
{ void *tmp___2 ;
  {
  {
  tmp___2 = __kmalloc(size, flags);
  }
  return (tmp___2);
}
}
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags )
{ void *tmp ;
  {
  if (size != 0UL) {
    if (0x0fffffffffffffffUL / size < n) {
      return ((void *)0);
    } else {
    }
  } else {
  }
  {
  tmp = __kmalloc(n * size, flags | 32768U);
  }
  return (tmp);
}
}
__inline static void *kzalloc(size_t size , gfp_t flags )
{ void *tmp ;
  {
  {
  tmp = kmalloc(size, flags | 32768U);
  }
  return (tmp);
}
}
extern resource_size_t pcibios_align_resource(void * , struct resource const * ,
                                              resource_size_t , resource_size_t ) ;
extern struct pci_dev *pci_get_domain_bus_and_slot(int , unsigned int , unsigned int ) ;
__inline static struct pci_dev *pci_get_bus_and_slot(unsigned int bus , unsigned int devfn )
{ struct pci_dev *tmp ;
  {
  {
  tmp = pci_get_domain_bus_and_slot(0, bus, devfn);
  }
  return (tmp);
}
}
extern int pci_bus_read_config_word(struct pci_bus * , unsigned int , int , u16 * ) ;
extern int pci_bus_read_config_dword(struct pci_bus * , unsigned int , int , u32 * ) ;
extern int pci_bus_write_config_dword(struct pci_bus * , unsigned int , int , u32 ) ;
__inline static int pci_read_config_word(struct pci_dev *dev , int where , u16 *val )
{ int tmp ;
  {
  {
  tmp = pci_bus_read_config_word(dev->bus, dev->devfn, where, val);
  }
  return (tmp);
}
}
__inline static int pci_read_config_dword(struct pci_dev *dev , int where , u32 *val )
{ int tmp ;
  {
  {
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
  }
  return (tmp);
}
}
__inline static int pci_write_config_dword(struct pci_dev *dev , int where , u32 val )
{ int tmp ;
  {
  {
  tmp = pci_bus_write_config_dword(dev->bus, dev->devfn, where, val);
  }
  return (tmp);
}
}
extern int pci_bus_alloc_resource(struct pci_bus * , struct resource * , resource_size_t ,
                                  resource_size_t , resource_size_t , unsigned int ,
                                  resource_size_t (*)(void * , struct resource const * ,
                                                      resource_size_t , resource_size_t ) ,
                                  void * ) ;
extern int pci_enable_msi_block(struct pci_dev * , unsigned int ) ;
extern void pci_disable_msi(struct pci_dev * ) ;
extern void unregister_shrinker(struct shrinker * ) ;
extern int dma_supported(struct device * , u64 ) ;
__inline static int dma_set_coherent_mask(struct device *dev , u64 mask )
{ int tmp ;
  {
  {
  tmp = dma_supported(dev, mask);
  }
  if (tmp == 0) {
    return (-5);
  } else {
  }
  dev->coherent_dma_mask = mask;
  return (0);
}
}
extern unsigned long _copy_to_user(void * , void const * , unsigned int ) ;
extern unsigned long _copy_from_user(void * , void const * , unsigned int ) ;
__inline static unsigned long copy_from_user(void *to , void const *from , unsigned long n )
{ int sz ;
  unsigned long tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  {
  {
  tmp = __builtin_object_size((void *)((void const *)to), 0);
  sz = (int )tmp;
  might_fault();
  tmp___1 = __builtin_expect((long )(sz == -1), 1L);
  }
  if (tmp___1 != 0L) {
    {
    n = _copy_from_user(to, from, (unsigned int )n);
    }
  } else {
    {
    tmp___2 = __builtin_expect((long )((unsigned long )sz >= n), 1L);
    }
    if (tmp___2 != 0L) {
      {
      n = _copy_from_user(to, from, (unsigned int )n);
      }
    } else {
      {
      __ret_warn_on = 1;
      tmp___0 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
      }
      if (tmp___0 != 0L) {
        {
        warn_slowpath_fmt("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/uaccess_64.h",
                          (int const )57, "Buffer overflow detected!\n");
        }
      } else {
      }
      {
      __builtin_expect((long )(__ret_warn_on != 0), 0L);
      }
    }
  }
  return (n);
}
}
__inline static int copy_to_user(void *dst , void const *src , unsigned int size )
{ unsigned long tmp ;
  {
  {
  might_fault();
  tmp = _copy_to_user(dst, src, size);
  }
  return ((int )tmp);
}
}
extern int mtrr_add(unsigned long , unsigned long , unsigned int , bool ) ;
extern int mtrr_del(int , unsigned long , unsigned long ) ;
extern struct drm_mm_node *drm_mm_get_block_generic(struct drm_mm_node * , unsigned long ,
                                                    unsigned int , int ) ;
__inline static struct drm_mm_node *drm_mm_get_block(struct drm_mm_node *parent ,
                                                     unsigned long size , unsigned int alignment )
{ struct drm_mm_node *tmp ;
  {
  {
  tmp = drm_mm_get_block_generic(parent, size, alignment, 0);
  }
  return (tmp);
}
}
extern void drm_mm_put_block(struct drm_mm_node * ) ;
extern struct drm_mm_node *drm_mm_search_free(struct drm_mm const * , unsigned long ,
                                              unsigned int , int ) ;
extern int drm_mm_init(struct drm_mm * , unsigned long , unsigned long ) ;
extern void drm_mm_takedown(struct drm_mm * ) ;
extern int drm_vblank_init(struct drm_device * , int ) ;
extern struct drm_local_map *drm_getsarea(struct drm_device * ) ;
extern drm_dma_handle_t *drm_pci_alloc(struct drm_device * , size_t , size_t ) ;
extern void drm_pci_free(struct drm_device * , drm_dma_handle_t * ) ;
extern void drm_core_ioremap_wc(struct drm_local_map * , struct drm_device * ) ;
extern void drm_core_ioremapfree(struct drm_local_map * , struct drm_device * ) ;
extern void drm_kms_helper_poll_init(struct drm_device * ) ;
void intel_setup_bios(struct drm_device *dev ) ;
bool intel_parse_bios(struct drm_device *dev ) ;
__inline static u32 intel_read_status_page(struct intel_ring_buffer *ring , int reg )
{ unsigned int tmp ;
  {
  {
  tmp = ioread32((void *)ring->status_page.page_addr + (unsigned long )reg);
  }
  return (tmp);
}
}
void intel_cleanup_ring_buffer(struct intel_ring_buffer *ring ) ;
int intel_wait_ring_buffer(struct intel_ring_buffer *ring , int n ) ;
__inline static int intel_wait_ring_idle(struct intel_ring_buffer *ring )
{ int tmp ;
  {
  {
  tmp = intel_wait_ring_buffer(ring, ring->size + -8);
  }
  return (tmp);
}
}
int intel_ring_begin(struct intel_ring_buffer *ring , int num_dwords ) ;
__inline static void intel_ring_emit(struct intel_ring_buffer *ring , u32 data )
{
  {
  {
  iowrite32(data, ring->virtual_start + (unsigned long )ring->tail);
  ring->tail = ring->tail + 4U;
  }
  return;
}
}
void intel_ring_advance(struct intel_ring_buffer *ring ) ;
void intel_ring_setup_status_page(struct intel_ring_buffer *ring ) ;
int intel_render_ring_init_dri(struct drm_device *dev , u64 start , u32 size ) ;
__inline static struct io_mapping *io_mapping_create_wc(resource_size_t base , unsigned long size )
{ void *tmp ;
  {
  {
  tmp = ioremap_wc(base, size);
  }
  return ((struct io_mapping *)tmp);
}
}
__inline static void io_mapping_free(struct io_mapping *mapping )
{
  {
  {
  iounmap((void volatile *)mapping);
  }
  return;
}
}
extern struct intel_gtt const *intel_gtt_get(void) ;
__inline static void trace_i915_reg_rw___0(bool write , u32 reg , u64 val , int len )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_reg_rw.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_reg_rw.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )411);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_36474:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , bool , u32 , u64 , int ))it_func))(__data, (bool )((int )write),
                                                                   reg, val, len);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_36474;
      } else {
        goto ldv_36475;
      }
      ldv_36475: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
void i915_kernel_lost_context(struct drm_device *dev ) ;
int i915_emit_box(struct drm_device *dev , struct drm_clip_rect *box , int DR1 , int DR4 ) ;
unsigned long i915_chipset_val(struct drm_i915_private *dev_priv ) ;
unsigned long i915_mch_val(struct drm_i915_private *dev_priv ) ;
unsigned long i915_gfx_val(struct drm_i915_private *dev_priv ) ;
void i915_update_gfx_val(struct drm_i915_private *dev_priv ) ;
void i915_hangcheck_elapsed(unsigned long data ) ;
int i915_irq_emit(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int i915_irq_wait(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
void intel_irq_init(struct drm_device *dev ) ;
int i915_vblank_pipe_set(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int i915_vblank_pipe_get(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int i915_vblank_swap(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
void i915_destroy_error_state(struct drm_device *dev ) ;
int i915_mem_alloc(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int i915_mem_free(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int i915_mem_init_heap(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int i915_mem_destroy_heap(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
void i915_mem_takedown(struct mem_block **heap ) ;
void i915_mem_release(struct drm_device *dev , struct drm_file *file_priv , struct mem_block *heap ) ;
int i915_gem_init_ioctl(struct drm_device *dev , void *data , struct drm_file *file ) ;
int i915_gem_create_ioctl(struct drm_device *dev , void *data , struct drm_file *file ) ;
int i915_gem_pread_ioctl(struct drm_device *dev , void *data , struct drm_file *file ) ;
int i915_gem_pwrite_ioctl(struct drm_device *dev , void *data , struct drm_file *file ) ;
int i915_gem_mmap_ioctl(struct drm_device *dev , void *data , struct drm_file *file ) ;
int i915_gem_mmap_gtt_ioctl(struct drm_device *dev , void *data , struct drm_file *file ) ;
int i915_gem_set_domain_ioctl(struct drm_device *dev , void *data , struct drm_file *file ) ;
int i915_gem_sw_finish_ioctl(struct drm_device *dev , void *data , struct drm_file *file ) ;
int i915_gem_execbuffer(struct drm_device *dev , void *data , struct drm_file *file ) ;
int i915_gem_execbuffer2(struct drm_device *dev , void *data , struct drm_file *file ) ;
int i915_gem_pin_ioctl(struct drm_device *dev , void *data , struct drm_file *file ) ;
int i915_gem_unpin_ioctl(struct drm_device *dev , void *data , struct drm_file *file ) ;
int i915_gem_busy_ioctl(struct drm_device *dev , void *data , struct drm_file *file ) ;
int i915_gem_throttle_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int i915_gem_madvise_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int i915_gem_entervt_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int i915_gem_leavevt_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int i915_gem_set_tiling(struct drm_device *dev , void *data , struct drm_file *file ) ;
int i915_gem_get_tiling(struct drm_device *dev , void *data , struct drm_file *file ) ;
int i915_gem_get_aperture_ioctl(struct drm_device *dev , void *data , struct drm_file *file ) ;
void i915_gem_load(struct drm_device *dev ) ;
void i915_gem_lastclose(struct drm_device *dev ) ;
void i915_gem_cleanup_ringbuffer(struct drm_device *dev ) ;
void i915_gem_do_init(struct drm_device *dev , unsigned long start , unsigned long mappable_end ,
                      unsigned long end ) ;
int i915_gpu_idle(struct drm_device *dev ) ;
void i915_gem_free_all_phys_object(struct drm_device *dev ) ;
void i915_gem_release(struct drm_device *dev , struct drm_file *file ) ;
int intel_setup_gmbus(struct drm_device *dev ) ;
void intel_teardown_gmbus(struct drm_device *dev ) ;
void intel_register_dsm_handler(void) ;
void intel_modeset_init(struct drm_device *dev ) ;
void intel_modeset_gem_init(struct drm_device *dev ) ;
void intel_modeset_cleanup(struct drm_device *dev ) ;
int intel_modeset_vga_set_state(struct drm_device *dev , bool state ) ;
void intel_disable_fbc(struct drm_device *dev ) ;
bool ironlake_set_drps(struct drm_device *dev , u8 val ) ;
__inline static u8 i915_read8(struct drm_i915_private *dev_priv , u32 reg )
{ u8 val ;
  {
  val = (u8 )0U;
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        gen6_gt_force_wake_get(dev_priv);
        val = readb((void const volatile *)dev_priv->regs + (unsigned long )reg);
        gen6_gt_force_wake_put(dev_priv);
        }
      } else {
        {
        val = readb((void const volatile *)dev_priv->regs + (unsigned long )reg);
        }
      }
    } else {
      {
      val = readb((void const volatile *)dev_priv->regs + (unsigned long )reg);
      }
    }
  } else {
    {
    val = readb((void const volatile *)dev_priv->regs + (unsigned long )reg);
    }
  }
  {
  trace_i915_reg_rw___0((bool )0, reg, (u64 )val, 1);
  }
  return (val);
}
}
__inline static u16 i915_read16(struct drm_i915_private *dev_priv , u32 reg )
{ u16 val ;
  {
  val = (u16 )0U;
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        gen6_gt_force_wake_get(dev_priv);
        val = readw((void const volatile *)dev_priv->regs + (unsigned long )reg);
        gen6_gt_force_wake_put(dev_priv);
        }
      } else {
        {
        val = readw((void const volatile *)dev_priv->regs + (unsigned long )reg);
        }
      }
    } else {
      {
      val = readw((void const volatile *)dev_priv->regs + (unsigned long )reg);
      }
    }
  } else {
    {
    val = readw((void const volatile *)dev_priv->regs + (unsigned long )reg);
    }
  }
  {
  trace_i915_reg_rw___0((bool )0, reg, (u64 )val, 2);
  }
  return (val);
}
}
__inline static u32 i915_read32___0(struct drm_i915_private *dev_priv , u32 reg )
{ u32 val ;
  {
  val = 0U;
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        gen6_gt_force_wake_get(dev_priv);
        val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
        gen6_gt_force_wake_put(dev_priv);
        }
      } else {
        {
        val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
        }
      }
    } else {
      {
      val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
      }
    }
  } else {
    {
    val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
    }
  }
  {
  trace_i915_reg_rw___0((bool )0, reg, (u64 )val, 4);
  }
  return (val);
}
}
__inline static void i915_write32___0(struct drm_i915_private *dev_priv , u32 reg ,
                                      u32 val )
{
  {
  {
  trace_i915_reg_rw___0((bool )1, reg, (u64 )val, 4);
  }
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        __gen6_gt_wait_for_fifo(dev_priv);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  writel(val, (void volatile *)dev_priv->regs + (unsigned long )reg);
  }
  return;
}
}
int intel_get_pipe_from_crtc_id(struct drm_device *dev , void *data , struct drm_file *file ) ;
int intel_fbdev_init(struct drm_device *dev ) ;
void intel_fbdev_fini(struct drm_device *dev ) ;
void intel_cleanup_overlay(struct drm_device *dev ) ;
int intel_overlay_put_image(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int intel_overlay_attrs(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
void intel_fb_restore_mode(struct drm_device *dev ) ;
unsigned long i915_read_mch_val(void) ;
bool i915_gpu_raise(void) ;
bool i915_gpu_lower(void) ;
bool i915_gpu_busy(void) ;
bool i915_gpu_turbo_disable(void) ;
extern int vga_client_register(struct pci_dev * , void * , void (*)(void * , bool ) ,
                               unsigned int (*)(void * , bool ) ) ;
extern int pnp_range_reserved(resource_size_t , resource_size_t ) ;
extern void vga_switcheroo_unregister_client(struct pci_dev * ) ;
extern int vga_switcheroo_register_client(struct pci_dev * , void (*)(struct pci_dev * ,
                                                                      enum vga_switcheroo_state ) ,
                                          void (*)(struct pci_dev * ) , bool (*)(struct pci_dev * ) ) ;
extern int vga_switcheroo_process_delayed_switch(void) ;
extern int acpi_video_register(void) ;
extern void acpi_video_unregister(void) ;
static void i915_write_hws_pga(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  u32 addr ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  addr = (u32 )(dev_priv->status_page_dmah)->busaddr;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    addr = ((u32 )((dev_priv->status_page_dmah)->busaddr >> 28) & 240U) | addr;
  } else {
  }
  {
  i915_write32___0(dev_priv, 8320U, addr);
  }
  return;
}
}
static int i915_init_phys_hws(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  struct intel_ring_buffer *ring ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ring = (struct intel_ring_buffer *)(& dev_priv->ring);
  dev_priv->status_page_dmah = drm_pci_alloc(dev, 4096UL, 4096UL);
  }
  if ((unsigned long )dev_priv->status_page_dmah == (unsigned long )((drm_dma_handle_t *)0)) {
    {
    drm_err("i915_init_phys_hws", "Can not allocate hardware status page\n");
    }
    return (-12);
  } else {
  }
  {
  ring->status_page.page_addr = (u32 *)(dev_priv->status_page_dmah)->vaddr;
  memset_io((void volatile *)ring->status_page.page_addr, (unsigned char)0, 4096UL);
  i915_write_hws_pga(dev);
  drm_ut_debug_printk(2U, "drm", "i915_init_phys_hws", "Enabled hardware status page\n");
  }
  return (0);
}
}
static void i915_free_hws(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  struct intel_ring_buffer *ring ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ring = (struct intel_ring_buffer *)(& dev_priv->ring);
  if ((unsigned long )dev_priv->status_page_dmah != (unsigned long )((drm_dma_handle_t *)0)) {
    {
    drm_pci_free(dev, dev_priv->status_page_dmah);
    dev_priv->status_page_dmah = (drm_dma_handle_t *)0;
    }
  } else {
  }
  if (ring->status_page.gfx_addr != 0U) {
    {
    ring->status_page.gfx_addr = 0U;
    drm_core_ioremapfree(& dev_priv->hws_map, dev);
    }
  } else {
  }
  {
  i915_write32___0(dev_priv, 8320U, 536866816U);
  }
  return;
}
}
void i915_kernel_lost_context(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  struct drm_i915_master_private *master_priv ;
  struct intel_ring_buffer *ring ;
  int tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ring = (struct intel_ring_buffer *)(& dev_priv->ring);
  tmp = drm_core_check_feature(dev, 8192);
  }
  if (tmp != 0) {
    return;
  } else {
  }
  {
  tmp___0 = i915_read32___0(dev_priv, ring->mmio_base + 52U);
  ring->head = tmp___0 & 2097148U;
  tmp___1 = i915_read32___0(dev_priv, ring->mmio_base + 48U);
  ring->tail = tmp___1 & 2097144U;
  ring->space = (int )((ring->head - ring->tail) - 8U);
  }
  if (ring->space < 0) {
    ring->space = ring->space + ring->size;
  } else {
  }
  if ((unsigned long )(dev->primary)->master == (unsigned long )((struct drm_master *)0)) {
    return;
  } else {
  }
  master_priv = (struct drm_i915_master_private *)((dev->primary)->master)->driver_priv;
  if (ring->head == ring->tail) {
    if ((unsigned long )master_priv->sarea_priv != (unsigned long )((struct _drm_i915_sarea *)0)) {
      (master_priv->sarea_priv)->perf_boxes = (master_priv->sarea_priv)->perf_boxes | 1;
    } else {
    }
  } else {
  }
  return;
}
}
static int i915_dma_cleanup(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  int i ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  if (dev->irq_enabled != 0) {
    {
    drm_irq_uninstall(dev);
    }
  } else {
  }
  {
  mutex_lock_nested(& dev->struct_mutex, 0U);
  i = 0;
  }
  goto ldv_40292;
  ldv_40291:
  {
  intel_cleanup_ring_buffer((struct intel_ring_buffer *)(& dev_priv->ring) + (unsigned long )i);
  i = i + 1;
  }
  ldv_40292: ;
  if (i <= 2) {
    goto ldv_40291;
  } else {
    goto ldv_40293;
  }
  ldv_40293:
  {
  mutex_unlock(& dev->struct_mutex);
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    {
    i915_free_hws(dev);
    }
  } else {
  }
  return (0);
}
}
static int i915_initialize(struct drm_device *dev , drm_i915_init_t *init )
{ drm_i915_private_t *dev_priv ;
  struct drm_i915_master_private *master_priv ;
  int ret ;
  struct drm_local_map *tmp ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  master_priv = (struct drm_i915_master_private *)((dev->primary)->master)->driver_priv;
  tmp = drm_getsarea(dev);
  master_priv->sarea = tmp;
  }
  if ((unsigned long )master_priv->sarea != (unsigned long )((drm_local_map_t *)0)) {
    master_priv->sarea_priv = (struct _drm_i915_sarea *)(master_priv->sarea)->handle + (unsigned long )init->sarea_priv_offset;
  } else {
    {
    drm_ut_debug_printk(2U, "drm", "i915_initialize", "sarea not found assuming DRI2 userspace\n");
    }
  }
  if (init->ring_size != 0U) {
    if ((unsigned long )((struct intel_ring_buffer *)(& dev_priv->ring))->obj != (unsigned long )((struct drm_i915_gem_object *)0)) {
      {
      i915_dma_cleanup(dev);
      drm_err("i915_initialize", "Client tried to initialize ringbuffer in GEM mode\n");
      }
      return (-22);
    } else {
    }
    {
    ret = intel_render_ring_init_dri(dev, (u64 )init->ring_start, init->ring_size);
    }
    if (ret != 0) {
      {
      i915_dma_cleanup(dev);
      }
      return (ret);
    } else {
    }
  } else {
  }
  dev_priv->cpp = init->cpp;
  dev_priv->back_offset = (int )init->back_offset;
  dev_priv->front_offset = (int )init->front_offset;
  dev_priv->current_page = 0;
  if ((unsigned long )master_priv->sarea_priv != (unsigned long )((struct _drm_i915_sarea *)0)) {
    (master_priv->sarea_priv)->pf_current_page = 0;
  } else {
  }
  dev_priv->allow_batchbuffer = 1;
  return (0);
}
}
static int i915_dma_resume(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  struct intel_ring_buffer *ring ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ring = (struct intel_ring_buffer *)(& dev_priv->ring);
  drm_ut_debug_printk(2U, "drm", "i915_dma_resume", "%s\n", "i915_dma_resume");
  }
  if ((unsigned long )ring->map.handle == (unsigned long )((void *)0)) {
    {
    drm_err("i915_dma_resume", "can not ioremap virtual address for ring buffer\n");
    }
    return (-12);
  } else {
  }
  if ((unsigned long )ring->status_page.page_addr == (unsigned long )((u32 *)0)) {
    {
    drm_err("i915_dma_resume", "Can not find hardware status page\n");
    }
    return (-22);
  } else {
  }
  {
  drm_ut_debug_printk(2U, "drm", "i915_dma_resume", "hw status page @ %p\n", ring->status_page.page_addr);
  }
  if (ring->status_page.gfx_addr != 0U) {
    {
    intel_ring_setup_status_page(ring);
    }
  } else {
    {
    i915_write_hws_pga(dev);
    }
  }
  {
  drm_ut_debug_printk(2U, "drm", "i915_dma_resume", "Enabled hardware status page\n");
  }
  return (0);
}
}
static int i915_dma_init(struct drm_device *dev , void *data , struct drm_file *file_priv )
{ drm_i915_init_t *init ;
  int retcode ;
  {
  init = (drm_i915_init_t *)data;
  retcode = 0;
  if ((int )((unsigned int )init->func) == 1) {
    goto case_1;
  } else
  if ((int )((unsigned int )init->func) == 2) {
    goto case_2;
  } else
  if ((int )((unsigned int )init->func) == 3) {
    goto case_3;
  } else {
    goto switch_default;
    if (0) {
      case_1:
      {
      retcode = i915_initialize(dev, init);
      }
      goto ldv_40316;
      case_2:
      {
      retcode = i915_dma_cleanup(dev);
      }
      goto ldv_40316;
      case_3:
      {
      retcode = i915_dma_resume(dev);
      }
      goto ldv_40316;
      switch_default:
      retcode = -22;
      goto ldv_40316;
    } else {
    }
  }
  ldv_40316: ;
  return (retcode);
}
}
static int validate_cmd(int cmd )
{
  {
  if ((int )((unsigned int )cmd >> 29) == 0) {
    goto case_0;
  } else
  if ((int )((unsigned int )cmd >> 29) == 1) {
    goto case_1;
  } else
  if ((int )((unsigned int )cmd >> 29) == 2) {
    goto case_2;
  } else
  if ((int )((unsigned int )cmd >> 29) == 3) {
    goto case_3;
  } else {
    goto switch_default___2;
    if (0) {
      case_0: ;
      if (((cmd >> 23) & 63) == 0) {
        goto case_0___0;
      } else
      if (((cmd >> 23) & 63) == 4) {
        goto case_4;
      } else {
        goto switch_default;
        if (0) {
          case_0___0: ;
          return (1);
          case_4: ;
          return (1);
          switch_default: ;
          return (0);
        } else {
        }
      }
      goto ldv_40327;
      case_1: ;
      return (0);
      case_2: ;
      return ((cmd & 255) + 2);
      case_3: ;
      if (((cmd >> 24) & 31) <= 24) {
        return (1);
      } else {
      }
      if (((cmd >> 24) & 31) == 28) {
        goto case_28;
      } else
      if (((cmd >> 24) & 31) == 29) {
        goto case_29;
      } else
      if (((cmd >> 24) & 31) == 30) {
        goto case_30;
      } else
      if (((cmd >> 24) & 31) == 31) {
        goto case_31;
      } else {
        goto switch_default___1;
        if (0) {
          case_28: ;
          return (1);
          case_29: ;
          if (((cmd >> 16) & 255) == 3) {
            goto case_3___0;
          } else
          if (((cmd >> 16) & 255) == 4) {
            goto case_4___0;
          } else {
            goto switch_default___0;
            if (0) {
              case_3___0: ;
              return ((cmd & 31) + 2);
              case_4___0: ;
              return ((cmd & 15) + 2);
              switch_default___0: ;
              return ((cmd & 65535) + 2);
            } else {
            }
          }
          case_30: ;
          if ((cmd & 8388608) != 0) {
            return ((cmd & 65535) + 1);
          } else {
            return (1);
          }
          case_31: ;
          if ((cmd & 8388608) == 0) {
            return ((cmd & 131071) + 2);
          } else
          if ((cmd & 131072) != 0) {
            if ((cmd & 65535) == 0) {
              return (0);
            } else {
              return (((cmd & 65535) + 1) / 2 + 1);
            }
          } else {
            return (2);
          }
          switch_default___1: ;
          return (0);
        } else {
        }
      }
      switch_default___2: ;
      return (0);
    } else {
    }
  }
  ldv_40327: ;
  return (0);
}
}
static int i915_emit_cmds(struct drm_device *dev , int *buffer , int dwords )
{ drm_i915_private_t *dev_priv ;
  int i ;
  int ret ;
  int sz ;
  int tmp ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  if ((unsigned long )(dwords + 1) * 4UL >= (unsigned long )(((struct intel_ring_buffer *)(& dev_priv->ring))->size + -8)) {
    return (-22);
  } else {
  }
  i = 0;
  goto ldv_40350;
  ldv_40349:
  {
  tmp = validate_cmd(*(buffer + (unsigned long )i));
  sz = tmp;
  }
  if (sz == 0) {
    return (-22);
  } else
  if (i + sz > dwords) {
    return (-22);
  } else {
  }
  i = i + sz;
  ldv_40350: ;
  if (i < dwords) {
    goto ldv_40349;
  } else {
    goto ldv_40351;
  }
  ldv_40351:
  {
  ret = intel_ring_begin((struct intel_ring_buffer *)(& dev_priv->ring), (dwords + 1) & -2);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  i = 0;
  goto ldv_40353;
  ldv_40352:
  {
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), (u32 )*(buffer + (unsigned long )i));
  i = i + 1;
  }
  ldv_40353: ;
  if (i < dwords) {
    goto ldv_40352;
  } else {
    goto ldv_40354;
  }
  ldv_40354: ;
  if (dwords & 1) {
    {
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 0U);
    }
  } else {
  }
  {
  intel_ring_advance((struct intel_ring_buffer *)(& dev_priv->ring));
  }
  return (0);
}
}
int i915_emit_box(struct drm_device *dev , struct drm_clip_rect *box , int DR1 , int DR4 )
{ struct drm_i915_private *dev_priv ;
  int ret ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((int )box->y2 <= (int )box->y1) {
    {
    drm_err("i915_emit_box", "Bad box %d,%d..%d,%d\n", (int )box->x1, (int )box->y1,
            (int )box->x2, (int )box->y2);
    }
    return (-22);
  } else
  if ((int )box->x2 <= (int )box->x1) {
    {
    drm_err("i915_emit_box", "Bad box %d,%d..%d,%d\n", (int )box->x1, (int )box->y1,
            (int )box->x2, (int )box->y2);
    }
    return (-22);
  } else
  if ((unsigned int )box->y2 == 0U) {
    {
    drm_err("i915_emit_box", "Bad box %d,%d..%d,%d\n", (int )box->x1, (int )box->y1,
            (int )box->x2, (int )box->y2);
    }
    return (-22);
  } else
  if ((unsigned int )box->x2 == 0U) {
    {
    drm_err("i915_emit_box", "Bad box %d,%d..%d,%d\n", (int )box->x1, (int )box->y1,
            (int )box->x2, (int )box->y2);
    }
    return (-22);
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    {
    ret = intel_ring_begin((struct intel_ring_buffer *)(& dev_priv->ring), 4);
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
    {
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 2030043138U);
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), (u32 )((int )box->x1 | ((int )box->y1 << 16)));
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), (u32 )((((int )box->x2 + -1) & 65535) | (((int )box->y2 + -1) << 16)));
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), (u32 )DR4);
    }
  } else {
    {
    ret = intel_ring_begin((struct intel_ring_buffer *)(& dev_priv->ring), 6);
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
    {
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 2105540611U);
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), (u32 )DR1);
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), (u32 )((int )box->x1 | ((int )box->y1 << 16)));
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), (u32 )((((int )box->x2 + -1) & 65535) | (((int )box->y2 + -1) << 16)));
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), (u32 )DR4);
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 0U);
    }
  }
  {
  intel_ring_advance((struct intel_ring_buffer *)(& dev_priv->ring));
  }
  return (0);
}
}
static void i915_emit_breadcrumb(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  struct drm_i915_master_private *master_priv ;
  int tmp ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  master_priv = (struct drm_i915_master_private *)((dev->primary)->master)->driver_priv;
  dev_priv->counter = dev_priv->counter + 1U;
  if ((int )dev_priv->counter < 0) {
    dev_priv->counter = 0U;
  } else {
  }
  if ((unsigned long )master_priv->sarea_priv != (unsigned long )((struct _drm_i915_sarea *)0)) {
    (master_priv->sarea_priv)->last_enqueue = (int )dev_priv->counter;
  } else {
  }
  {
  tmp = intel_ring_begin((struct intel_ring_buffer *)(& dev_priv->ring), 4);
  }
  if (tmp == 0) {
    {
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 276824065U);
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 132U);
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), dev_priv->counter);
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 0U);
    intel_ring_advance((struct intel_ring_buffer *)(& dev_priv->ring));
    }
  } else {
  }
  return;
}
}
static int i915_dispatch_cmdbuffer(struct drm_device *dev , drm_i915_cmdbuffer_t *cmd ,
                                   struct drm_clip_rect *cliprects , void *cmdbuf )
{ int nbox ;
  int i ;
  int count ;
  int ret ;
  {
  nbox = cmd->num_cliprects;
  i = 0;
  if ((cmd->sz & 3) != 0) {
    {
    drm_err("i915_dispatch_cmdbuffer", "alignment");
    }
    return (-22);
  } else {
  }
  {
  i915_kernel_lost_context(dev);
  }
  if (nbox != 0) {
    count = nbox;
  } else {
    count = 1;
  }
  i = 0;
  goto ldv_40381;
  ldv_40380: ;
  if (i < nbox) {
    {
    ret = i915_emit_box(dev, cliprects + (unsigned long )i, cmd->DR1, cmd->DR4);
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
  } else {
  }
  {
  ret = i915_emit_cmds(dev, (int *)cmdbuf, cmd->sz / 4);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  i = i + 1;
  ldv_40381: ;
  if (i < count) {
    goto ldv_40380;
  } else {
    goto ldv_40382;
  }
  ldv_40382:
  {
  i915_emit_breadcrumb(dev);
  }
  return (0);
}
}
static int i915_dispatch_batchbuffer(struct drm_device *dev , drm_i915_batchbuffer_t *batch ,
                                     struct drm_clip_rect *cliprects )
{ struct drm_i915_private *dev_priv ;
  int nbox ;
  int i ;
  int count ;
  int ret ;
  int tmp ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  nbox = batch->num_cliprects;
  if (((batch->start | batch->used) & 7) != 0) {
    {
    drm_err("i915_dispatch_batchbuffer", "alignment");
    }
    return (-22);
  } else {
  }
  {
  i915_kernel_lost_context(dev);
  }
  if (nbox != 0) {
    count = nbox;
  } else {
    count = 1;
  }
  i = 0;
  goto ldv_40395;
  ldv_40394: ;
  if (i < nbox) {
    {
    ret = i915_emit_box(dev, cliprects + (unsigned long )i, batch->DR1, batch->DR4);
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
  } else {
  }
  if (dev->pci_device != 13687) {
    if (dev->pci_device != 9570) {
      {
      ret = intel_ring_begin((struct intel_ring_buffer *)(& dev_priv->ring), 2);
      }
      if (ret != 0) {
        return (ret);
      } else {
      }
      if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
        {
        intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 411042176U);
        intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), (u32 )batch->start);
        }
      } else {
        {
        intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 411041920U);
        intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), (u32 )(batch->start | 1));
        }
      }
    } else {
      goto _L;
    }
  } else {
    _L:
    {
    ret = intel_ring_begin((struct intel_ring_buffer *)(& dev_priv->ring), 4);
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
    {
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 402653185U);
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), (u32 )(batch->start | 1));
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), (u32 )((batch->start + batch->used) + -4));
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 0U);
    }
  }
  {
  intel_ring_advance((struct intel_ring_buffer *)(& dev_priv->ring));
  i = i + 1;
  }
  ldv_40395: ;
  if (i < count) {
    goto ldv_40394;
  } else {
    goto ldv_40396;
  }
  ldv_40396: ;
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    goto _L___0;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    _L___0:
    {
    tmp = intel_ring_begin((struct intel_ring_buffer *)(& dev_priv->ring), 2);
    }
    if (tmp == 0) {
      {
      intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 33554468U);
      intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 0U);
      intel_ring_advance((struct intel_ring_buffer *)(& dev_priv->ring));
      }
    } else {
    }
  } else {
  }
  {
  i915_emit_breadcrumb(dev);
  }
  return (0);
}
}
static int i915_dispatch_flip(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  struct drm_i915_master_private *master_priv ;
  int ret ;
  uint32_t tmp ;
  int tmp___0 ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  master_priv = (struct drm_i915_master_private *)((dev->primary)->master)->driver_priv;
  if ((unsigned long )master_priv->sarea_priv == (unsigned long )((struct _drm_i915_sarea *)0)) {
    return (-22);
  } else {
  }
  {
  drm_ut_debug_printk(2U, "drm", "i915_dispatch_flip", "%s: page=%d pfCurrentPage=%d\n",
                      "i915_dispatch_flip", dev_priv->current_page, (master_priv->sarea_priv)->pf_current_page);
  i915_kernel_lost_context(dev);
  ret = intel_ring_begin((struct intel_ring_buffer *)(& dev_priv->ring), 10);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 33554433U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 0U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 171966466U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 0U);
  }
  if (dev_priv->current_page == 0) {
    {
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), (u32 )dev_priv->back_offset);
    dev_priv->current_page = 1;
    }
  } else {
    {
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), (u32 )dev_priv->front_offset);
    dev_priv->current_page = 0;
    }
  }
  {
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 0U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 25165828U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 0U);
  intel_ring_advance((struct intel_ring_buffer *)(& dev_priv->ring));
  tmp = dev_priv->counter;
  dev_priv->counter = dev_priv->counter + 1U;
  (master_priv->sarea_priv)->last_enqueue = (int )tmp;
  tmp___0 = intel_ring_begin((struct intel_ring_buffer *)(& dev_priv->ring), 4);
  }
  if (tmp___0 == 0) {
    {
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 276824065U);
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 132U);
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), dev_priv->counter);
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 0U);
    intel_ring_advance((struct intel_ring_buffer *)(& dev_priv->ring));
    }
  } else {
  }
  (master_priv->sarea_priv)->pf_current_page = dev_priv->current_page;
  return (0);
}
}
static int i915_quiescent(struct drm_device *dev )
{ struct intel_ring_buffer *ring ;
  int tmp ;
  {
  {
  ring = (struct intel_ring_buffer *)(& ((struct drm_i915_private *)dev->dev_private)->ring);
  i915_kernel_lost_context(dev);
  tmp = intel_wait_ring_idle(ring);
  }
  return (tmp);
}
}
static int i915_flush_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv )
{ int ret ;
  {
  if ((unsigned long )((struct intel_ring_buffer *)(& ((struct drm_i915_private *)dev->dev_private)->ring))->obj == (unsigned long )((struct drm_i915_gem_object *)0)) {
    if ((int )((file_priv->master)->lock.hw_lock)->lock >= 0) {
      {
      drm_err("i915_flush_ioctl", "%s called without lock held, held  %d owner %p %p\n",
              "i915_flush_ioctl", (unsigned int )((file_priv->master)->lock.hw_lock)->lock & 2147483648U,
              (file_priv->master)->lock.file_priv, file_priv);
      }
      return (-22);
    } else
    if ((unsigned long )(file_priv->master)->lock.file_priv != (unsigned long )file_priv) {
      {
      drm_err("i915_flush_ioctl", "%s called without lock held, held  %d owner %p %p\n",
              "i915_flush_ioctl", (unsigned int )((file_priv->master)->lock.hw_lock)->lock & 2147483648U,
              (file_priv->master)->lock.file_priv, file_priv);
      }
      return (-22);
    } else {
    }
  } else {
  }
  {
  mutex_lock_nested(& dev->struct_mutex, 0U);
  ret = i915_quiescent(dev);
  mutex_unlock(& dev->struct_mutex);
  }
  return (ret);
}
}
static int i915_batchbuffer(struct drm_device *dev , void *data , struct drm_file *file_priv )
{ drm_i915_private_t *dev_priv ;
  struct drm_i915_master_private *master_priv ;
  drm_i915_sarea_t *sarea_priv ;
  drm_i915_batchbuffer_t *batch ;
  int ret ;
  struct drm_clip_rect *cliprects ;
  void *tmp ;
  unsigned long tmp___0 ;
  u32 tmp___1 ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  master_priv = (struct drm_i915_master_private *)((dev->primary)->master)->driver_priv;
  sarea_priv = master_priv->sarea_priv;
  batch = (drm_i915_batchbuffer_t *)data;
  cliprects = (struct drm_clip_rect *)0;
  if (dev_priv->allow_batchbuffer == 0) {
    {
    drm_err("i915_batchbuffer", "Batchbuffer ioctl disabled\n");
    }
    return (-22);
  } else {
  }
  {
  drm_ut_debug_printk(2U, "drm", "i915_batchbuffer", "i915 batchbuffer, start %x used %d cliprects %d\n",
                      batch->start, batch->used, batch->num_cliprects);
  }
  if ((unsigned long )((struct intel_ring_buffer *)(& ((struct drm_i915_private *)dev->dev_private)->ring))->obj == (unsigned long )((struct drm_i915_gem_object *)0)) {
    if ((int )((file_priv->master)->lock.hw_lock)->lock >= 0) {
      {
      drm_err("i915_batchbuffer", "%s called without lock held, held  %d owner %p %p\n",
              "i915_batchbuffer", (unsigned int )((file_priv->master)->lock.hw_lock)->lock & 2147483648U,
              (file_priv->master)->lock.file_priv, file_priv);
      }
      return (-22);
    } else
    if ((unsigned long )(file_priv->master)->lock.file_priv != (unsigned long )file_priv) {
      {
      drm_err("i915_batchbuffer", "%s called without lock held, held  %d owner %p %p\n",
              "i915_batchbuffer", (unsigned int )((file_priv->master)->lock.hw_lock)->lock & 2147483648U,
              (file_priv->master)->lock.file_priv, file_priv);
      }
      return (-22);
    } else {
    }
  } else {
  }
  if (batch->num_cliprects < 0) {
    return (-22);
  } else {
  }
  if (batch->num_cliprects != 0) {
    {
    tmp = kcalloc((size_t )batch->num_cliprects, 8UL, 208U);
    cliprects = (struct drm_clip_rect *)tmp;
    }
    if ((unsigned long )cliprects == (unsigned long )((struct drm_clip_rect *)0)) {
      return (-12);
    } else {
    }
    {
    tmp___0 = copy_from_user((void *)cliprects, (void const *)batch->cliprects,
                             (unsigned long )batch->num_cliprects * 8UL);
    ret = (int )tmp___0;
    }
    if (ret != 0) {
      ret = -14;
      goto fail_free;
    } else {
    }
  } else {
  }
  {
  mutex_lock_nested(& dev->struct_mutex, 0U);
  ret = i915_dispatch_batchbuffer(dev, batch, cliprects);
  mutex_unlock(& dev->struct_mutex);
  }
  if ((unsigned long )sarea_priv != (unsigned long )((drm_i915_sarea_t *)0)) {
    {
    tmp___1 = intel_read_status_page((struct intel_ring_buffer *)(& dev_priv->ring),
                                     33);
    sarea_priv->last_dispatch = (int )tmp___1;
    }
  } else {
  }
  fail_free:
  {
  kfree((void const *)cliprects);
  }
  return (ret);
}
}
static int i915_cmdbuffer(struct drm_device *dev , void *data , struct drm_file *file_priv )
{ drm_i915_private_t *dev_priv ;
  struct drm_i915_master_private *master_priv ;
  drm_i915_sarea_t *sarea_priv ;
  drm_i915_cmdbuffer_t *cmdbuf ;
  struct drm_clip_rect *cliprects ;
  void *batch_data ;
  int ret ;
  unsigned long tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  u32 tmp___2 ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  master_priv = (struct drm_i915_master_private *)((dev->primary)->master)->driver_priv;
  sarea_priv = master_priv->sarea_priv;
  cmdbuf = (drm_i915_cmdbuffer_t *)data;
  cliprects = (struct drm_clip_rect *)0;
  drm_ut_debug_printk(2U, "drm", "i915_cmdbuffer", "i915 cmdbuffer, buf %p sz %d cliprects %d\n",
                      cmdbuf->buf, cmdbuf->sz, cmdbuf->num_cliprects);
  }
  if ((unsigned long )((struct intel_ring_buffer *)(& ((struct drm_i915_private *)dev->dev_private)->ring))->obj == (unsigned long )((struct drm_i915_gem_object *)0)) {
    if ((int )((file_priv->master)->lock.hw_lock)->lock >= 0) {
      {
      drm_err("i915_cmdbuffer", "%s called without lock held, held  %d owner %p %p\n",
              "i915_cmdbuffer", (unsigned int )((file_priv->master)->lock.hw_lock)->lock & 2147483648U,
              (file_priv->master)->lock.file_priv, file_priv);
      }
      return (-22);
    } else
    if ((unsigned long )(file_priv->master)->lock.file_priv != (unsigned long )file_priv) {
      {
      drm_err("i915_cmdbuffer", "%s called without lock held, held  %d owner %p %p\n",
              "i915_cmdbuffer", (unsigned int )((file_priv->master)->lock.hw_lock)->lock & 2147483648U,
              (file_priv->master)->lock.file_priv, file_priv);
      }
      return (-22);
    } else {
    }
  } else {
  }
  if (cmdbuf->num_cliprects < 0) {
    return (-22);
  } else {
  }
  {
  batch_data = kmalloc((size_t )cmdbuf->sz, 208U);
  }
  if ((unsigned long )batch_data == (unsigned long )((void *)0)) {
    return (-12);
  } else {
  }
  {
  tmp = copy_from_user(batch_data, (void const *)cmdbuf->buf, (unsigned long )cmdbuf->sz);
  ret = (int )tmp;
  }
  if (ret != 0) {
    ret = -14;
    goto fail_batch_free;
  } else {
  }
  if (cmdbuf->num_cliprects != 0) {
    {
    tmp___0 = kcalloc((size_t )cmdbuf->num_cliprects, 8UL, 208U);
    cliprects = (struct drm_clip_rect *)tmp___0;
    }
    if ((unsigned long )cliprects == (unsigned long )((struct drm_clip_rect *)0)) {
      ret = -12;
      goto fail_batch_free;
    } else {
    }
    {
    tmp___1 = copy_from_user((void *)cliprects, (void const *)cmdbuf->cliprects,
                             (unsigned long )cmdbuf->num_cliprects * 8UL);
    ret = (int )tmp___1;
    }
    if (ret != 0) {
      ret = -14;
      goto fail_clip_free;
    } else {
    }
  } else {
  }
  {
  mutex_lock_nested(& dev->struct_mutex, 0U);
  ret = i915_dispatch_cmdbuffer(dev, cmdbuf, cliprects, batch_data);
  mutex_unlock(& dev->struct_mutex);
  }
  if (ret != 0) {
    {
    drm_err("i915_cmdbuffer", "i915_dispatch_cmdbuffer failed\n");
    }
    goto fail_clip_free;
  } else {
  }
  if ((unsigned long )sarea_priv != (unsigned long )((drm_i915_sarea_t *)0)) {
    {
    tmp___2 = intel_read_status_page((struct intel_ring_buffer *)(& dev_priv->ring),
                                     33);
    sarea_priv->last_dispatch = (int )tmp___2;
    }
  } else {
  }
  fail_clip_free:
  {
  kfree((void const *)cliprects);
  }
  fail_batch_free:
  {
  kfree((void const *)batch_data);
  }
  return (ret);
}
}
static int i915_flip_bufs(struct drm_device *dev , void *data , struct drm_file *file_priv )
{ int ret ;
  {
  {
  drm_ut_debug_printk(2U, "drm", "i915_flip_bufs", "%s\n", "i915_flip_bufs");
  }
  if ((unsigned long )((struct intel_ring_buffer *)(& ((struct drm_i915_private *)dev->dev_private)->ring))->obj == (unsigned long )((struct drm_i915_gem_object *)0)) {
    if ((int )((file_priv->master)->lock.hw_lock)->lock >= 0) {
      {
      drm_err("i915_flip_bufs", "%s called without lock held, held  %d owner %p %p\n",
              "i915_flip_bufs", (unsigned int )((file_priv->master)->lock.hw_lock)->lock & 2147483648U,
              (file_priv->master)->lock.file_priv, file_priv);
      }
      return (-22);
    } else
    if ((unsigned long )(file_priv->master)->lock.file_priv != (unsigned long )file_priv) {
      {
      drm_err("i915_flip_bufs", "%s called without lock held, held  %d owner %p %p\n",
              "i915_flip_bufs", (unsigned int )((file_priv->master)->lock.hw_lock)->lock & 2147483648U,
              (file_priv->master)->lock.file_priv, file_priv);
      }
      return (-22);
    } else {
    }
  } else {
  }
  {
  mutex_lock_nested(& dev->struct_mutex, 0U);
  ret = i915_dispatch_flip(dev);
  mutex_unlock(& dev->struct_mutex);
  }
  return (ret);
}
}
static int i915_getparam(struct drm_device *dev , void *data , struct drm_file *file_priv )
{ drm_i915_private_t *dev_priv ;
  drm_i915_getparam_t *param ;
  int value ;
  u32 tmp ;
  int tmp___0 ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  param = (drm_i915_getparam_t *)data;
  if ((unsigned long )dev_priv == (unsigned long )((drm_i915_private_t *)0)) {
    {
    drm_err("i915_getparam", "called with no initialization\n");
    }
    return (-22);
  } else {
  }
  if (param->param == 1) {
    goto case_1;
  } else
  if (param->param == 2) {
    goto case_2;
  } else
  if (param->param == 3) {
    goto case_3;
  } else
  if (param->param == 4) {
    goto case_4;
  } else
  if (param->param == 5) {
    goto case_5;
  } else
  if (param->param == 6) {
    goto case_6;
  } else
  if (param->param == 7) {
    goto case_7;
  } else
  if (param->param == 8) {
    goto case_8;
  } else
  if (param->param == 9) {
    goto case_9;
  } else
  if (param->param == 10) {
    goto case_10;
  } else
  if (param->param == 11) {
    goto case_11;
  } else
  if (param->param == 12) {
    goto case_12;
  } else
  if (param->param == 13) {
    goto case_13;
  } else
  if (param->param == 14) {
    goto case_14;
  } else
  if (param->param == 15) {
    goto case_15;
  } else {
    goto switch_default;
    if (0) {
      case_1:
      value = (dev->pdev)->irq != 0U;
      goto ldv_40460;
      case_2:
      value = dev_priv->allow_batchbuffer != 0;
      goto ldv_40460;
      case_3:
      {
      tmp = intel_read_status_page((struct intel_ring_buffer *)(& dev_priv->ring),
                                   33);
      value = (int )tmp;
      }
      goto ldv_40460;
      case_4:
      value = dev->pci_device;
      goto ldv_40460;
      case_5:
      value = dev_priv->has_gem;
      goto ldv_40460;
      case_6:
      value = dev_priv->num_fence_regs - dev_priv->fence_reg_start;
      goto ldv_40460;
      case_7:
      value = (unsigned long )dev_priv->overlay != (unsigned long )((struct intel_overlay *)0);
      goto ldv_40460;
      case_8:
      value = 1;
      goto ldv_40460;
      case_9:
      value = dev_priv->has_gem;
      goto ldv_40460;
      case_10:
      value = (int )(((struct drm_i915_private *)dev->dev_private)->info)->has_bsd_ring;
      goto ldv_40460;
      case_11:
      value = (int )(((struct drm_i915_private *)dev->dev_private)->info)->has_blt_ring;
      goto ldv_40460;
      case_12:
      value = 1;
      goto ldv_40460;
      case_13:
      value = 1;
      goto ldv_40460;
      case_14:
      value = (unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U;
      goto ldv_40460;
      case_15:
      value = 1;
      goto ldv_40460;
      switch_default:
      {
      drm_ut_debug_printk(2U, "drm", "i915_getparam", "Unknown parameter %d\n", param->param);
      }
      return (-22);
    } else {
    }
  }
  ldv_40460:
  {
  tmp___0 = copy_to_user((void *)param->value, (void const *)(& value), 4U);
  }
  if (tmp___0 != 0) {
    {
    drm_err("i915_getparam", "DRM_COPY_TO_USER failed\n");
    }
    return (-14);
  } else {
  }
  return (0);
}
}
static int i915_setparam(struct drm_device *dev , void *data , struct drm_file *file_priv )
{ drm_i915_private_t *dev_priv ;
  drm_i915_setparam_t *param ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  param = (drm_i915_setparam_t *)data;
  if ((unsigned long )dev_priv == (unsigned long )((drm_i915_private_t *)0)) {
    {
    drm_err("i915_setparam", "called with no initialization\n");
    }
    return (-22);
  } else {
  }
  if (param->param == 1) {
    goto case_1;
  } else
  if (param->param == 2) {
    goto case_2;
  } else
  if (param->param == 3) {
    goto case_3;
  } else
  if (param->param == 4) {
    goto case_4;
  } else {
    goto switch_default;
    if (0) {
      case_1: ;
      goto ldv_40485;
      case_2:
      dev_priv->tex_lru_log_granularity = param->value;
      goto ldv_40485;
      case_3:
      dev_priv->allow_batchbuffer = param->value;
      goto ldv_40485;
      case_4: ;
      if (param->value > dev_priv->num_fence_regs) {
        return (-22);
      } else
      if (param->value < 0) {
        return (-22);
      } else {
      }
      dev_priv->fence_reg_start = param->value;
      goto ldv_40485;
      switch_default:
      {
      drm_ut_debug_printk(2U, "drm", "i915_setparam", "unknown parameter %d\n", param->param);
      }
      return (-22);
    } else {
    }
  }
  ldv_40485: ;
  return (0);
}
}
static int i915_set_status_page(struct drm_device *dev , void *data , struct drm_file *file_priv )
{ drm_i915_private_t *dev_priv ;
  drm_i915_hws_addr_t *hws ;
  struct intel_ring_buffer *ring ;
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  hws = (drm_i915_hws_addr_t *)data;
  ring = (struct intel_ring_buffer *)(& dev_priv->ring);
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) == 0U) {
    return (-22);
  } else {
  }
  if ((unsigned long )dev_priv == (unsigned long )((drm_i915_private_t *)0)) {
    {
    drm_err("i915_set_status_page", "called with no initialization\n");
    }
    return (-22);
  } else {
  }
  {
  tmp___0 = drm_core_check_feature(dev, 8192);
  }
  if (tmp___0 != 0) {
    {
    __ret_warn_on = 1;
    tmp = __builtin_expect((long )(__ret_warn_on != 0), 0L);
    }
    if (tmp != 0L) {
      {
      warn_slowpath_fmt("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_dma.c.p",
                        (int const )858, "tried to set status page when mode setting active\n");
      }
    } else {
    }
    {
    __builtin_expect((long )(__ret_warn_on != 0), 0L);
    }
    return (0);
  } else {
  }
  {
  drm_ut_debug_printk(2U, "drm", "i915_set_status_page", "set status page addr 0x%08x\n",
                      (unsigned int )hws->addr);
  ring->status_page.gfx_addr = (unsigned int )hws->addr & 536866816U;
  dev_priv->hws_map.offset = (unsigned long long )(dev->agp)->base + hws->addr;
  dev_priv->hws_map.size = 4096UL;
  dev_priv->hws_map.type = (enum drm_map_type )0;
  dev_priv->hws_map.flags = (enum drm_map_flags )0;
  dev_priv->hws_map.mtrr = 0;
  drm_core_ioremap_wc(& dev_priv->hws_map, dev);
  }
  if ((unsigned long )dev_priv->hws_map.handle == (unsigned long )((void *)0)) {
    {
    i915_dma_cleanup(dev);
    ring->status_page.gfx_addr = 0U;
    drm_err("i915_set_status_page", "can not ioremap virtual address for G33 hw status page\n");
    }
    return (-12);
  } else {
  }
  {
  ring->status_page.page_addr = (u32 *)dev_priv->hws_map.handle;
  memset_io((void volatile *)ring->status_page.page_addr, (unsigned char)0, 4096UL);
  i915_write32___0(dev_priv, 8320U, ring->status_page.gfx_addr);
  drm_ut_debug_printk(2U, "drm", "i915_set_status_page", "load hws HWS_PGA with gfx mem 0x%x\n",
                      ring->status_page.gfx_addr);
  drm_ut_debug_printk(2U, "drm", "i915_set_status_page", "load hws at %p\n", ring->status_page.page_addr);
  }
  return (0);
}
}
static int i915_get_bridge_dev(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  dev_priv->bridge_dev = pci_get_bus_and_slot(0U, 0U);
  }
  if ((unsigned long )dev_priv->bridge_dev == (unsigned long )((struct pci_dev *)0)) {
    {
    drm_err("i915_get_bridge_dev", "bridge device not found\n");
    }
    return (-1);
  } else {
  }
  return (0);
}
}
static int intel_alloc_mchbar_resource(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  int reg ;
  int tmp ;
  u32 temp_lo ;
  u32 temp_hi ;
  u64 mchbar_addr ;
  int ret ;
  int tmp___0 ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    tmp = 72;
  } else {
    tmp = 68;
  }
  reg = tmp;
  temp_hi = 0U;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    {
    pci_read_config_dword(dev_priv->bridge_dev, reg + 4, & temp_hi);
    }
  } else {
  }
  {
  pci_read_config_dword(dev_priv->bridge_dev, reg, & temp_lo);
  mchbar_addr = ((unsigned long long )temp_hi << 32) | (unsigned long long )temp_lo;
  }
  if (mchbar_addr != 0ULL) {
    {
    tmp___0 = pnp_range_reserved(mchbar_addr, mchbar_addr + 16384ULL);
    }
    if (tmp___0 != 0) {
      return (0);
    } else {
    }
  } else {
  }
  {
  dev_priv->mch_res.name = "i915 MCHBAR";
  dev_priv->mch_res.flags = 512UL;
  ret = pci_bus_alloc_resource((dev_priv->bridge_dev)->bus, & dev_priv->mch_res, 16384ULL,
                               16384ULL, (resource_size_t )pci_mem_start, 0U, & pcibios_align_resource,
                               (void *)dev_priv->bridge_dev);
  }
  if (ret != 0) {
    {
    drm_ut_debug_printk(2U, "drm", "intel_alloc_mchbar_resource", "failed bus alloc: %d\n",
                        ret);
    dev_priv->mch_res.start = 0ULL;
    }
    return (ret);
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    {
    pci_write_config_dword(dev_priv->bridge_dev, reg + 4, (unsigned int )(dev_priv->mch_res.start >> 32ULL));
    }
  } else {
  }
  {
  pci_write_config_dword(dev_priv->bridge_dev, reg, (unsigned int )dev_priv->mch_res.start);
  }
  return (0);
}
}
static void intel_setup_mchbar(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  int mchbar_reg ;
  int tmp ;
  u32 temp ;
  bool enabled ;
  int tmp___0 ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    tmp = 72;
  } else {
    tmp = 68;
  }
  mchbar_reg = tmp;
  dev_priv->mchbar_need_disable = (bool )0;
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    {
    pci_read_config_dword(dev_priv->bridge_dev, 84, & temp);
    enabled = (bool )((temp & 268435456U) != 0U);
    }
  } else
  if (dev->pci_device == 9618) {
    {
    pci_read_config_dword(dev_priv->bridge_dev, 84, & temp);
    enabled = (bool )((temp & 268435456U) != 0U);
    }
  } else {
    {
    pci_read_config_dword(dev_priv->bridge_dev, mchbar_reg, & temp);
    enabled = (bool )((temp & 1U) != 0U);
    }
  }
  if ((int )enabled) {
    return;
  } else {
  }
  {
  tmp___0 = intel_alloc_mchbar_resource(dev);
  }
  if (tmp___0 != 0) {
    return;
  } else {
  }
  dev_priv->mchbar_need_disable = (bool )1;
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    {
    pci_write_config_dword(dev_priv->bridge_dev, 84, temp | 268435456U);
    }
  } else
  if (dev->pci_device == 9618) {
    {
    pci_write_config_dword(dev_priv->bridge_dev, 84, temp | 268435456U);
    }
  } else {
    {
    pci_read_config_dword(dev_priv->bridge_dev, mchbar_reg, & temp);
    pci_write_config_dword(dev_priv->bridge_dev, mchbar_reg, temp | 1U);
    }
  }
  return;
}
}
static void intel_teardown_mchbar(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  int mchbar_reg ;
  int tmp ;
  u32 temp ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    tmp = 72;
  } else {
    tmp = 68;
  }
  mchbar_reg = tmp;
  if ((int )dev_priv->mchbar_need_disable) {
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
      {
      pci_read_config_dword(dev_priv->bridge_dev, 84, & temp);
      temp = temp & 4026531839U;
      pci_write_config_dword(dev_priv->bridge_dev, 84, temp);
      }
    } else
    if (dev->pci_device == 9618) {
      {
      pci_read_config_dword(dev_priv->bridge_dev, 84, & temp);
      temp = temp & 4026531839U;
      pci_write_config_dword(dev_priv->bridge_dev, 84, temp);
      }
    } else {
      {
      pci_read_config_dword(dev_priv->bridge_dev, mchbar_reg, & temp);
      temp = temp & 4294967294U;
      pci_write_config_dword(dev_priv->bridge_dev, mchbar_reg, temp);
      }
    }
  } else {
  }
  if (dev_priv->mch_res.start != 0ULL) {
    {
    release_resource(& dev_priv->mch_res);
    }
  } else {
  }
  return;
}
}
static unsigned long i915_stolen_to_phys(struct drm_device *dev , u32 offset )
{ struct drm_i915_private *dev_priv ;
  struct pci_dev *pdev ;
  u32 base ;
  u16 val ;
  u8 val___0 ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  pdev = dev_priv->bridge_dev;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    {
    pci_read_config_word(pdev, 176, & val);
    base = (u32 )(((int )val >> 4) << 20);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    {
    pci_read_config_word(pdev, 176, & val);
    base = (u32 )(((int )val >> 4) << 20);
    }
  } else {
    {
    pci_read_config_byte(pdev, 156, & val___0);
    base = (u32 )(((int )val___0 >> 3) << 27);
    }
  }
  base = base - (u32 )(dev_priv->mm.gtt)->stolen_size;
  return ((unsigned long )(base + offset));
}
}
static void i915_warn_stolen(struct drm_device *dev )
{
  {
  {
  drm_err("i915_warn_stolen", "not enough stolen space for compressed buffer, disabling\n");
  drm_err("i915_warn_stolen", "hint: you may be able to increase stolen memory size in the BIOS to avoid this\n");
  }
  return;
}
}
static void i915_setup_compression(struct drm_device *dev , int size )
{ struct drm_i915_private *dev_priv ;
  struct drm_mm_node *compressed_fb ;
  struct drm_mm_node *compressed_llb ;
  unsigned long cfb_base ;
  unsigned long ll_base ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  compressed_llb = compressed_llb;
  ll_base = 0UL;
  compressed_fb = drm_mm_search_free((struct drm_mm const *)(& dev_priv->mm.stolen),
                                     (unsigned long )size, 4096U, 0);
  }
  if ((unsigned long )compressed_fb != (unsigned long )((struct drm_mm_node *)0)) {
    {
    compressed_fb = drm_mm_get_block(compressed_fb, (unsigned long )size, 4096U);
    }
  } else {
  }
  if ((unsigned long )compressed_fb == (unsigned long )((struct drm_mm_node *)0)) {
    goto err;
  } else {
  }
  {
  cfb_base = i915_stolen_to_phys(dev, (u32 )compressed_fb->start);
  }
  if (cfb_base == 0UL) {
    goto err_fb;
  } else {
  }
  if (dev->pci_device != 10818) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 5U) {
      if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 6U) {
        if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) == 0U) {
          {
          compressed_llb = drm_mm_search_free((struct drm_mm const *)(& dev_priv->mm.stolen),
                                              4096UL, 4096U, 0);
          }
          if ((unsigned long )compressed_llb != (unsigned long )((struct drm_mm_node *)0)) {
            {
            compressed_llb = drm_mm_get_block(compressed_llb, 4096UL, 4096U);
            }
          } else {
          }
          if ((unsigned long )compressed_llb == (unsigned long )((struct drm_mm_node *)0)) {
            goto err_fb;
          } else {
          }
          {
          ll_base = i915_stolen_to_phys(dev, (u32 )compressed_llb->start);
          }
          if (ll_base == 0UL) {
            goto err_llb;
          } else {
          }
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  dev_priv->cfb_size = (unsigned long )size;
  intel_disable_fbc(dev);
  dev_priv->compressed_fb = compressed_fb;
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    i915_write32___0(dev_priv, 274944U, (u32 )compressed_fb->start);
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    i915_write32___0(dev_priv, 274944U, (u32 )compressed_fb->start);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    i915_write32___0(dev_priv, 274944U, (u32 )compressed_fb->start);
    }
  } else
  if (dev->pci_device == 10818) {
    {
    i915_write32___0(dev_priv, 12800U, (u32 )compressed_fb->start);
    }
  } else {
    {
    i915_write32___0(dev_priv, 12800U, (u32 )cfb_base);
    i915_write32___0(dev_priv, 12804U, (u32 )ll_base);
    dev_priv->compressed_llb = compressed_llb;
    }
  }
  {
  drm_ut_debug_printk(4U, "drm", "i915_setup_compression", "FBC base 0x%08lx, ll base 0x%08lx, size %dM\n",
                      cfb_base, ll_base, size >> 20);
  }
  return;
  err_llb:
  {
  drm_mm_put_block(compressed_llb);
  }
  err_fb:
  {
  drm_mm_put_block(compressed_fb);
  }
  err:
  {
  dev_priv->no_fbc_reason = (enum no_fbc_reason )1;
  i915_warn_stolen(dev);
  }
  return;
}
}
static void i915_cleanup_compression(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  drm_mm_put_block(dev_priv->compressed_fb);
  }
  if ((unsigned long )dev_priv->compressed_llb != (unsigned long )((struct drm_mm_node *)0)) {
    {
    drm_mm_put_block(dev_priv->compressed_llb);
    }
  } else {
  }
  return;
}
}
static unsigned int i915_vga_set_decode(void *cookie , bool state )
{ struct drm_device *dev ;
  {
  {
  dev = (struct drm_device *)cookie;
  intel_modeset_vga_set_state(dev, (bool )((int )state));
  }
  if ((int )state) {
    return (15U);
  } else {
    return (12U);
  }
}
}
static void i915_switcheroo_set_state(struct pci_dev *pdev , enum vga_switcheroo_state state )
{ struct drm_device *dev ;
  void *tmp ;
  pm_message_t pmm ;
  {
  {
  tmp = pci_get_drvdata(pdev);
  dev = (struct drm_device *)tmp;
  pmm.event = 2;
  }
  if ((unsigned int )state == 1U) {
    {
    printk("<6>i915: switched on\n");
    dev->switch_power_state = 2;
    pci_set_power_state(dev->pdev, 0);
    i915_resume(dev);
    dev->switch_power_state = 0;
    }
  } else {
    {
    printk("<3>i915: switched off\n");
    dev->switch_power_state = 2;
    i915_suspend(dev, pmm);
    dev->switch_power_state = 1;
    }
  }
  return;
}
}
static bool i915_switcheroo_can_switch(struct pci_dev *pdev )
{ struct drm_device *dev ;
  void *tmp ;
  bool can_switch ;
  {
  {
  tmp = pci_get_drvdata(pdev);
  dev = (struct drm_device *)tmp;
  spin_lock(& dev->count_lock);
  can_switch = (bool )(dev->open_count == 0);
  spin_unlock(& dev->count_lock);
  }
  return (can_switch);
}
}
static int i915_load_gem_init(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  unsigned long prealloc_size ;
  unsigned long gtt_size ;
  unsigned long mappable_size ;
  int ret ;
  int cfb_size ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  prealloc_size = (unsigned long )(dev_priv->mm.gtt)->stolen_size;
  gtt_size = (unsigned long )((dev_priv->mm.gtt)->gtt_total_entries << 12);
  mappable_size = (unsigned long )((dev_priv->mm.gtt)->gtt_mappable_entries << 12);
  drm_mm_init(& dev_priv->mm.stolen, 0UL, prealloc_size);
  i915_gem_do_init(dev, 0UL, mappable_size, gtt_size - 4096UL);
  mutex_lock_nested(& dev->struct_mutex, 0U);
  ret = i915_gem_init_ringbuffer(dev);
  mutex_unlock(& dev->struct_mutex);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    if (i915_powersave != 0U) {
      if (prealloc_size > 37748736UL) {
        cfb_size = 33554432;
      } else {
        cfb_size = (int )((prealloc_size * 7UL) / 8UL);
      }
      {
      i915_setup_compression(dev, cfb_size);
      }
    } else {
    }
  } else {
  }
  dev_priv->allow_batchbuffer = 1;
  return (0);
}
}
static int i915_load_modeset_init(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  int ret ;
  bool tmp ;
  u32 tmp___0 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = intel_parse_bios(dev);
  ret = (int )tmp;
  }
  if (ret != 0) {
    {
    printk("<6>[drm] failed to find VBIOS tables\n");
    }
  } else {
  }
  {
  ret = vga_client_register(dev->pdev, (void *)dev, (void (*)(void * , bool ))0,
                            & i915_vga_set_decode);
  }
  if (ret != 0) {
    if (ret != -19) {
      goto out;
    } else {
    }
  } else {
  }
  {
  intel_register_dsm_handler();
  ret = vga_switcheroo_register_client(dev->pdev, & i915_switcheroo_set_state, (void (*)(struct pci_dev * ))0,
                                       & i915_switcheroo_can_switch);
  }
  if (ret != 0) {
    goto cleanup_vga_client;
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 3U) {
    {
    tmp___0 = i915_read32___0(dev_priv, 8656U);
    }
    if ((int )tmp___0 & 1) {
      dev_priv->flip_pending_is_done = (bool )1;
    } else {
    }
  } else {
  }
  {
  intel_modeset_init(dev);
  ret = i915_load_gem_init(dev);
  }
  if (ret != 0) {
    goto cleanup_vga_switcheroo;
  } else {
  }
  {
  intel_modeset_gem_init(dev);
  ret = drm_irq_install(dev);
  }
  if (ret != 0) {
    goto cleanup_gem;
  } else {
  }
  {
  dev->vblank_disable_allowed = 1;
  ret = intel_fbdev_init(dev);
  }
  if (ret != 0) {
    goto cleanup_irq;
  } else {
  }
  {
  drm_kms_helper_poll_init(dev);
  dev_priv->mm.suspended = 0;
  }
  return (0);
  cleanup_irq:
  {
  drm_irq_uninstall(dev);
  }
  cleanup_gem:
  {
  mutex_lock_nested(& dev->struct_mutex, 0U);
  i915_gem_cleanup_ringbuffer(dev);
  mutex_unlock(& dev->struct_mutex);
  }
  cleanup_vga_switcheroo:
  {
  vga_switcheroo_unregister_client(dev->pdev);
  }
  cleanup_vga_client:
  {
  vga_client_register(dev->pdev, (void *)0, (void (*)(void * , bool ))0, (unsigned int (*)(void * ,
                                                                                            bool ))0);
  }
  out: ;
  return (ret);
}
}
int i915_master_create(struct drm_device *dev , struct drm_master *master )
{ struct drm_i915_master_private *master_priv ;
  void *tmp ;
  {
  {
  tmp = kzalloc(16UL, 208U);
  master_priv = (struct drm_i915_master_private *)tmp;
  }
  if ((unsigned long )master_priv == (unsigned long )((struct drm_i915_master_private *)0)) {
    return (-12);
  } else {
  }
  master->driver_priv = (void *)master_priv;
  return (0);
}
}
void i915_master_destroy(struct drm_device *dev , struct drm_master *master )
{ struct drm_i915_master_private *master_priv ;
  {
  master_priv = (struct drm_i915_master_private *)master->driver_priv;
  if ((unsigned long )master_priv == (unsigned long )((struct drm_i915_master_private *)0)) {
    return;
  } else {
  }
  {
  kfree((void const *)master_priv);
  master->driver_priv = (void *)0;
  }
  return;
}
}
static void i915_pineview_get_mem_freq(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  u32 tmp ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = i915_read32___0(dev_priv, 68608U);
  }
  if ((int )(tmp & 7U) == 1) {
    goto case_1;
  } else
  if ((int )(tmp & 7U) == 2) {
    goto case_2;
  } else
  if ((int )(tmp & 7U) == 3) {
    goto case_3;
  } else
  if ((int )(tmp & 7U) == 5) {
    goto case_5;
  } else
  if (0) {
    case_1:
    dev_priv->fsb_freq = 533U;
    goto ldv_40610;
    case_2:
    dev_priv->fsb_freq = 800U;
    goto ldv_40610;
    case_3:
    dev_priv->fsb_freq = 667U;
    goto ldv_40610;
    case_5:
    dev_priv->fsb_freq = 400U;
    goto ldv_40610;
  } else {
  }
  ldv_40610: ;
  if ((int )(tmp & 112U) == 16) {
    goto case_16;
  } else
  if ((int )(tmp & 112U) == 32) {
    goto case_32;
  } else
  if ((int )(tmp & 112U) == 48) {
    goto case_48;
  } else
  if (0) {
    case_16:
    dev_priv->mem_freq = 533U;
    goto ldv_40615;
    case_32:
    dev_priv->mem_freq = 667U;
    goto ldv_40615;
    case_48:
    dev_priv->mem_freq = 800U;
    goto ldv_40615;
  } else {
  }
  ldv_40615:
  {
  tmp = i915_read32___0(dev_priv, 65960U);
  dev_priv->is_ddr3 = (unsigned int )((tmp & 4U) != 0U);
  }
  return;
}
}
static void i915_ironlake_get_mem_freq(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  u16 ddrpll ;
  u16 csipll ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ddrpll = i915_read16(dev_priv, 76832U);
  csipll = i915_read16(dev_priv, 76816U);
  }
  if (((int )ddrpll & 255) == 12) {
    goto case_12;
  } else
  if (((int )ddrpll & 255) == 16) {
    goto case_16;
  } else
  if (((int )ddrpll & 255) == 20) {
    goto case_20;
  } else
  if (((int )ddrpll & 255) == 24) {
    goto case_24;
  } else {
    goto switch_default;
    if (0) {
      case_12:
      dev_priv->mem_freq = 800U;
      goto ldv_40625;
      case_16:
      dev_priv->mem_freq = 1066U;
      goto ldv_40625;
      case_20:
      dev_priv->mem_freq = 1333U;
      goto ldv_40625;
      case_24:
      dev_priv->mem_freq = 1600U;
      goto ldv_40625;
      switch_default:
      {
      drm_ut_debug_printk(2U, "drm", "i915_ironlake_get_mem_freq", "unknown memory frequency 0x%02x\n",
                          (int )ddrpll & 255);
      dev_priv->mem_freq = 0U;
      }
      goto ldv_40625;
    } else {
    }
  }
  ldv_40625:
  dev_priv->r_t = (int )dev_priv->mem_freq;
  if (((int )csipll & 1023) == 12) {
    goto case_12___0;
  } else
  if (((int )csipll & 1023) == 14) {
    goto case_14;
  } else
  if (((int )csipll & 1023) == 16) {
    goto case_16___0;
  } else
  if (((int )csipll & 1023) == 18) {
    goto case_18;
  } else
  if (((int )csipll & 1023) == 20) {
    goto case_20___0;
  } else
  if (((int )csipll & 1023) == 22) {
    goto case_22;
  } else
  if (((int )csipll & 1023) == 24) {
    goto case_24___0;
  } else {
    goto switch_default___0;
    if (0) {
      case_12___0:
      dev_priv->fsb_freq = 3200U;
      goto ldv_40632;
      case_14:
      dev_priv->fsb_freq = 3733U;
      goto ldv_40632;
      case_16___0:
      dev_priv->fsb_freq = 4266U;
      goto ldv_40632;
      case_18:
      dev_priv->fsb_freq = 4800U;
      goto ldv_40632;
      case_20___0:
      dev_priv->fsb_freq = 5333U;
      goto ldv_40632;
      case_22:
      dev_priv->fsb_freq = 5866U;
      goto ldv_40632;
      case_24___0:
      dev_priv->fsb_freq = 6400U;
      goto ldv_40632;
      switch_default___0:
      {
      drm_ut_debug_printk(2U, "drm", "i915_ironlake_get_mem_freq", "unknown fsb frequency 0x%04x\n",
                          (int )csipll & 1023);
      dev_priv->fsb_freq = 0U;
      }
      goto ldv_40632;
    } else {
    }
  }
  ldv_40632: ;
  if (dev_priv->fsb_freq == 3200U) {
    dev_priv->c_m = 0;
  } else
  if (dev_priv->fsb_freq > 3200U) {
    if (dev_priv->fsb_freq <= 4800U) {
      dev_priv->c_m = 1;
    } else {
      dev_priv->c_m = 2;
    }
  } else {
    dev_priv->c_m = 2;
  }
  return;
}
}
static struct cparams const cparams[6U] = { {(u16 )1U, (u16 )1333U, (u16 )301U, (u16 )28664U},
        {(u16 )1U, (u16 )1066U, (u16 )294U, (u16 )24460U},
        {(u16 )1U, (u16 )800U, (u16 )294U, (u16 )25192U},
        {(u16 )0U, (u16 )1333U, (u16 )276U, (u16 )27605U},
        {(u16 )0U, (u16 )1066U, (u16 )276U, (u16 )27605U},
        {(u16 )0U, (u16 )800U, (u16 )231U, (u16 )23784U}};
unsigned long i915_chipset_val(struct drm_i915_private *dev_priv )
{ u64 total_count ;
  u64 diff ;
  u64 ret ;
  u32 count1 ;
  u32 count2 ;
  u32 count3 ;
  u32 m ;
  u32 c ;
  unsigned long now ;
  unsigned int tmp ;
  unsigned long diff1 ;
  int i ;
  {
  {
  m = 0U;
  c = 0U;
  tmp = jiffies_to_msecs((unsigned long const )jiffies);
  now = (unsigned long )tmp;
  diff1 = now - dev_priv->last_time1;
  count1 = i915_read32___0(dev_priv, 70372U);
  count2 = i915_read32___0(dev_priv, 70376U);
  count3 = i915_read32___0(dev_priv, 70368U);
  total_count = (u64 )((count1 + count2) + count3);
  }
  if (dev_priv->last_count1 > total_count) {
    diff = ~ dev_priv->last_count1;
    diff = diff + total_count;
  } else {
    diff = total_count - dev_priv->last_count1;
  }
  i = 0;
  goto ldv_40664;
  ldv_40663: ;
  if ((int )cparams[i].i == dev_priv->c_m) {
    if ((int )cparams[i].t == dev_priv->r_t) {
      m = (u32 )cparams[i].m;
      c = (u32 )cparams[i].c;
      goto ldv_40662;
    } else {
    }
  } else {
  }
  i = i + 1;
  ldv_40664: ;
  if ((unsigned int )i <= 5U) {
    goto ldv_40663;
  } else {
    goto ldv_40662;
  }
  ldv_40662:
  {
  diff = div_u64(diff, (u32 )diff1);
  ret = (u64 )m * diff + (u64 )c;
  ret = div_u64(ret, 10U);
  dev_priv->last_count1 = total_count;
  dev_priv->last_time1 = now;
  }
  return ((unsigned long )ret);
}
}
unsigned long i915_mch_val(struct drm_i915_private *dev_priv )
{ unsigned long m ;
  unsigned long x ;
  unsigned long b ;
  u32 tsfs ;
  u8 tmp ;
  {
  {
  tsfs = i915_read32___0(dev_priv, 69664U);
  m = (unsigned long )((tsfs & 65280U) >> 8);
  tmp = i915_read8(dev_priv, 69638U);
  x = (unsigned long )tmp;
  b = (unsigned long )tsfs & 255UL;
  }
  return ((m * x) / 127UL - b);
}
}
static u16 pvid_to_extvid(struct drm_i915_private *dev_priv , u8 pxvid )
{ struct v_table v_table[128U] ;
  {
  v_table[0].vd = (u16 )0U;
  v_table[0].vm = (u16 )0U;
  v_table[1].vd = (u16 )375U;
  v_table[1].vm = (u16 )0U;
  v_table[2].vd = (u16 )500U;
  v_table[2].vm = (u16 )0U;
  v_table[3].vd = (u16 )625U;
  v_table[3].vm = (u16 )0U;
  v_table[4].vd = (u16 )750U;
  v_table[4].vm = (u16 )0U;
  v_table[5].vd = (u16 )875U;
  v_table[5].vm = (u16 )0U;
  v_table[6].vd = (u16 )1000U;
  v_table[6].vm = (u16 )0U;
  v_table[7].vd = (u16 )1125U;
  v_table[7].vm = (u16 )0U;
  v_table[8].vd = (u16 )4125U;
  v_table[8].vm = (u16 )3000U;
  v_table[9].vd = (u16 )4125U;
  v_table[9].vm = (u16 )3000U;
  v_table[10].vd = (u16 )4125U;
  v_table[10].vm = (u16 )3000U;
  v_table[11].vd = (u16 )4125U;
  v_table[11].vm = (u16 )3000U;
  v_table[12].vd = (u16 )4125U;
  v_table[12].vm = (u16 )3000U;
  v_table[13].vd = (u16 )4125U;
  v_table[13].vm = (u16 )3000U;
  v_table[14].vd = (u16 )4125U;
  v_table[14].vm = (u16 )3000U;
  v_table[15].vd = (u16 )4125U;
  v_table[15].vm = (u16 )3000U;
  v_table[16].vd = (u16 )4125U;
  v_table[16].vm = (u16 )3000U;
  v_table[17].vd = (u16 )4125U;
  v_table[17].vm = (u16 )3000U;
  v_table[18].vd = (u16 )4125U;
  v_table[18].vm = (u16 )3000U;
  v_table[19].vd = (u16 )4125U;
  v_table[19].vm = (u16 )3000U;
  v_table[20].vd = (u16 )4125U;
  v_table[20].vm = (u16 )3000U;
  v_table[21].vd = (u16 )4125U;
  v_table[21].vm = (u16 )3000U;
  v_table[22].vd = (u16 )4125U;
  v_table[22].vm = (u16 )3000U;
  v_table[23].vd = (u16 )4125U;
  v_table[23].vm = (u16 )3000U;
  v_table[24].vd = (u16 )4125U;
  v_table[24].vm = (u16 )3000U;
  v_table[25].vd = (u16 )4125U;
  v_table[25].vm = (u16 )3000U;
  v_table[26].vd = (u16 )4125U;
  v_table[26].vm = (u16 )3000U;
  v_table[27].vd = (u16 )4125U;
  v_table[27].vm = (u16 )3000U;
  v_table[28].vd = (u16 )4125U;
  v_table[28].vm = (u16 )3000U;
  v_table[29].vd = (u16 )4125U;
  v_table[29].vm = (u16 )3000U;
  v_table[30].vd = (u16 )4125U;
  v_table[30].vm = (u16 )3000U;
  v_table[31].vd = (u16 )4125U;
  v_table[31].vm = (u16 )3000U;
  v_table[32].vd = (u16 )4250U;
  v_table[32].vm = (u16 )3125U;
  v_table[33].vd = (u16 )4375U;
  v_table[33].vm = (u16 )3250U;
  v_table[34].vd = (u16 )4500U;
  v_table[34].vm = (u16 )3375U;
  v_table[35].vd = (u16 )4625U;
  v_table[35].vm = (u16 )3500U;
  v_table[36].vd = (u16 )4750U;
  v_table[36].vm = (u16 )3625U;
  v_table[37].vd = (u16 )4875U;
  v_table[37].vm = (u16 )3750U;
  v_table[38].vd = (u16 )5000U;
  v_table[38].vm = (u16 )3875U;
  v_table[39].vd = (u16 )5125U;
  v_table[39].vm = (u16 )4000U;
  v_table[40].vd = (u16 )5250U;
  v_table[40].vm = (u16 )4125U;
  v_table[41].vd = (u16 )5375U;
  v_table[41].vm = (u16 )4250U;
  v_table[42].vd = (u16 )5500U;
  v_table[42].vm = (u16 )4375U;
  v_table[43].vd = (u16 )5625U;
  v_table[43].vm = (u16 )4500U;
  v_table[44].vd = (u16 )5750U;
  v_table[44].vm = (u16 )4625U;
  v_table[45].vd = (u16 )5875U;
  v_table[45].vm = (u16 )4750U;
  v_table[46].vd = (u16 )6000U;
  v_table[46].vm = (u16 )4875U;
  v_table[47].vd = (u16 )6125U;
  v_table[47].vm = (u16 )5000U;
  v_table[48].vd = (u16 )6250U;
  v_table[48].vm = (u16 )5125U;
  v_table[49].vd = (u16 )6375U;
  v_table[49].vm = (u16 )5250U;
  v_table[50].vd = (u16 )6500U;
  v_table[50].vm = (u16 )5375U;
  v_table[51].vd = (u16 )6625U;
  v_table[51].vm = (u16 )5500U;
  v_table[52].vd = (u16 )6750U;
  v_table[52].vm = (u16 )5625U;
  v_table[53].vd = (u16 )6875U;
  v_table[53].vm = (u16 )5750U;
  v_table[54].vd = (u16 )7000U;
  v_table[54].vm = (u16 )5875U;
  v_table[55].vd = (u16 )7125U;
  v_table[55].vm = (u16 )6000U;
  v_table[56].vd = (u16 )7250U;
  v_table[56].vm = (u16 )6125U;
  v_table[57].vd = (u16 )7375U;
  v_table[57].vm = (u16 )6250U;
  v_table[58].vd = (u16 )7500U;
  v_table[58].vm = (u16 )6375U;
  v_table[59].vd = (u16 )7625U;
  v_table[59].vm = (u16 )6500U;
  v_table[60].vd = (u16 )7750U;
  v_table[60].vm = (u16 )6625U;
  v_table[61].vd = (u16 )7875U;
  v_table[61].vm = (u16 )6750U;
  v_table[62].vd = (u16 )8000U;
  v_table[62].vm = (u16 )6875U;
  v_table[63].vd = (u16 )8125U;
  v_table[63].vm = (u16 )7000U;
  v_table[64].vd = (u16 )8250U;
  v_table[64].vm = (u16 )7125U;
  v_table[65].vd = (u16 )8375U;
  v_table[65].vm = (u16 )7250U;
  v_table[66].vd = (u16 )8500U;
  v_table[66].vm = (u16 )7375U;
  v_table[67].vd = (u16 )8625U;
  v_table[67].vm = (u16 )7500U;
  v_table[68].vd = (u16 )8750U;
  v_table[68].vm = (u16 )7625U;
  v_table[69].vd = (u16 )8875U;
  v_table[69].vm = (u16 )7750U;
  v_table[70].vd = (u16 )9000U;
  v_table[70].vm = (u16 )7875U;
  v_table[71].vd = (u16 )9125U;
  v_table[71].vm = (u16 )8000U;
  v_table[72].vd = (u16 )9250U;
  v_table[72].vm = (u16 )8125U;
  v_table[73].vd = (u16 )9375U;
  v_table[73].vm = (u16 )8250U;
  v_table[74].vd = (u16 )9500U;
  v_table[74].vm = (u16 )8375U;
  v_table[75].vd = (u16 )9625U;
  v_table[75].vm = (u16 )8500U;
  v_table[76].vd = (u16 )9750U;
  v_table[76].vm = (u16 )8625U;
  v_table[77].vd = (u16 )9875U;
  v_table[77].vm = (u16 )8750U;
  v_table[78].vd = (u16 )10000U;
  v_table[78].vm = (u16 )8875U;
  v_table[79].vd = (u16 )10125U;
  v_table[79].vm = (u16 )9000U;
  v_table[80].vd = (u16 )10250U;
  v_table[80].vm = (u16 )9125U;
  v_table[81].vd = (u16 )10375U;
  v_table[81].vm = (u16 )9250U;
  v_table[82].vd = (u16 )10500U;
  v_table[82].vm = (u16 )9375U;
  v_table[83].vd = (u16 )10625U;
  v_table[83].vm = (u16 )9500U;
  v_table[84].vd = (u16 )10750U;
  v_table[84].vm = (u16 )9625U;
  v_table[85].vd = (u16 )10875U;
  v_table[85].vm = (u16 )9750U;
  v_table[86].vd = (u16 )11000U;
  v_table[86].vm = (u16 )9875U;
  v_table[87].vd = (u16 )11125U;
  v_table[87].vm = (u16 )10000U;
  v_table[88].vd = (u16 )11250U;
  v_table[88].vm = (u16 )10125U;
  v_table[89].vd = (u16 )11375U;
  v_table[89].vm = (u16 )10250U;
  v_table[90].vd = (u16 )11500U;
  v_table[90].vm = (u16 )10375U;
  v_table[91].vd = (u16 )11625U;
  v_table[91].vm = (u16 )10500U;
  v_table[92].vd = (u16 )11750U;
  v_table[92].vm = (u16 )10625U;
  v_table[93].vd = (u16 )11875U;
  v_table[93].vm = (u16 )10750U;
  v_table[94].vd = (u16 )12000U;
  v_table[94].vm = (u16 )10875U;
  v_table[95].vd = (u16 )12125U;
  v_table[95].vm = (u16 )11000U;
  v_table[96].vd = (u16 )12250U;
  v_table[96].vm = (u16 )11125U;
  v_table[97].vd = (u16 )12375U;
  v_table[97].vm = (u16 )11250U;
  v_table[98].vd = (u16 )12500U;
  v_table[98].vm = (u16 )11375U;
  v_table[99].vd = (u16 )12625U;
  v_table[99].vm = (u16 )11500U;
  v_table[100].vd = (u16 )12750U;
  v_table[100].vm = (u16 )11625U;
  v_table[101].vd = (u16 )12875U;
  v_table[101].vm = (u16 )11750U;
  v_table[102].vd = (u16 )13000U;
  v_table[102].vm = (u16 )11875U;
  v_table[103].vd = (u16 )13125U;
  v_table[103].vm = (u16 )12000U;
  v_table[104].vd = (u16 )13250U;
  v_table[104].vm = (u16 )12125U;
  v_table[105].vd = (u16 )13375U;
  v_table[105].vm = (u16 )12250U;
  v_table[106].vd = (u16 )13500U;
  v_table[106].vm = (u16 )12375U;
  v_table[107].vd = (u16 )13625U;
  v_table[107].vm = (u16 )12500U;
  v_table[108].vd = (u16 )13750U;
  v_table[108].vm = (u16 )12625U;
  v_table[109].vd = (u16 )13875U;
  v_table[109].vm = (u16 )12750U;
  v_table[110].vd = (u16 )14000U;
  v_table[110].vm = (u16 )12875U;
  v_table[111].vd = (u16 )14125U;
  v_table[111].vm = (u16 )13000U;
  v_table[112].vd = (u16 )14250U;
  v_table[112].vm = (u16 )13125U;
  v_table[113].vd = (u16 )14375U;
  v_table[113].vm = (u16 )13250U;
  v_table[114].vd = (u16 )14500U;
  v_table[114].vm = (u16 )13375U;
  v_table[115].vd = (u16 )14625U;
  v_table[115].vm = (u16 )13500U;
  v_table[116].vd = (u16 )14750U;
  v_table[116].vm = (u16 )13625U;
  v_table[117].vd = (u16 )14875U;
  v_table[117].vm = (u16 )13750U;
  v_table[118].vd = (u16 )15000U;
  v_table[118].vm = (u16 )13875U;
  v_table[119].vd = (u16 )15125U;
  v_table[119].vm = (u16 )14000U;
  v_table[120].vd = (u16 )15250U;
  v_table[120].vm = (u16 )14125U;
  v_table[121].vd = (u16 )15375U;
  v_table[121].vm = (u16 )14250U;
  v_table[122].vd = (u16 )15500U;
  v_table[122].vm = (u16 )14375U;
  v_table[123].vd = (u16 )15625U;
  v_table[123].vm = (u16 )14500U;
  v_table[124].vd = (u16 )15750U;
  v_table[124].vm = (u16 )14625U;
  v_table[125].vd = (u16 )15875U;
  v_table[125].vm = (u16 )14750U;
  v_table[126].vd = (u16 )16000U;
  v_table[126].vm = (u16 )14875U;
  v_table[127].vd = (u16 )16125U;
  v_table[127].vm = (u16 )15000U;
  if ((unsigned int )*((unsigned char *)dev_priv->info + 1UL) != 0U) {
    return (v_table[(int )pxvid].vm);
  } else {
    return (v_table[(int )pxvid].vd);
  }
}
}
void i915_update_gfx_val(struct drm_i915_private *dev_priv )
{ struct timespec now ;
  struct timespec diff1 ;
  u64 diff ;
  unsigned long diffms ;
  u32 count ;
  {
  {
  getrawmonotonic(& now);
  diff1 = timespec_sub(now, dev_priv->last_time2);
  diffms = (unsigned long )(diff1.tv_sec * 1000L + diff1.tv_nsec / 1000000L);
  }
  if (diffms == 0UL) {
    return;
  } else {
  }
  {
  count = i915_read32___0(dev_priv, 70388U);
  }
  if ((u64 )count < dev_priv->last_count2) {
    diff = ~ dev_priv->last_count2;
    diff = (u64 )count + diff;
  } else {
    diff = (u64 )count - dev_priv->last_count2;
  }
  {
  dev_priv->last_count2 = (u64 )count;
  dev_priv->last_time2 = now;
  diff = diff * 1181ULL;
  diff = div_u64(diff, (u32 )diffms * 10U);
  dev_priv->gfx_power = (unsigned long )diff;
  }
  return;
}
}
unsigned long i915_gfx_val(struct drm_i915_private *dev_priv )
{ unsigned long t ;
  unsigned long corr ;
  unsigned long state1 ;
  unsigned long corr2 ;
  unsigned long state2 ;
  u32 pxvid ;
  u32 ext_v ;
  u16 tmp ;
  {
  {
  pxvid = i915_read32___0(dev_priv, (u32 )(((int )dev_priv->cur_delay + 17476) * 4));
  pxvid = (pxvid >> 24) & 127U;
  tmp = pvid_to_extvid(dev_priv, (u8 )((int )((u8 )pxvid)));
  ext_v = (u32 )tmp;
  state1 = (unsigned long )ext_v;
  t = i915_mch_val(dev_priv);
  }
  if (t > 80UL) {
    corr = t * 2349UL + 135940UL;
  } else
  if (t > 49UL) {
    corr = t * 964UL + 29317UL;
  } else {
    corr = t * 301UL + 1004UL;
  }
  {
  corr = ((state1 * 150142UL) / 10000UL - 78642UL) * corr;
  corr = corr / 100000UL;
  corr2 = (unsigned long )dev_priv->corr * corr;
  state2 = (corr2 * state1) / 10000UL;
  state2 = state2 / 100UL;
  i915_update_gfx_val(dev_priv);
  }
  return (dev_priv->gfx_power + state2);
}
}
static struct drm_i915_private *i915_mch_dev ;
static spinlock_t mchdev_lock = {{{{0U}, 3735899821U, 4294967295U, (void *)0x0fffffffffffffffUL, {(struct lock_class_key *)0,
                                                                     {(struct lock_class *)0,
                                                                      (struct lock_class *)0},
                                                                     "mchdev_lock",
                                                                     0, 0UL}}}};
unsigned long i915_read_mch_val(void)
{ struct drm_i915_private *dev_priv ;
  unsigned long chipset_val ;
  unsigned long graphics_val ;
  unsigned long ret ;
  {
  {
  ret = 0UL;
  spin_lock(& mchdev_lock);
  }
  if ((unsigned long )i915_mch_dev == (unsigned long )((struct drm_i915_private *)0)) {
    goto out_unlock;
  } else {
  }
  {
  dev_priv = i915_mch_dev;
  chipset_val = i915_chipset_val(dev_priv);
  graphics_val = i915_gfx_val(dev_priv);
  ret = chipset_val + graphics_val;
  }
  out_unlock:
  {
  spin_unlock(& mchdev_lock);
  }
  return (ret);
}
}
bool i915_gpu_raise(void)
{ struct drm_i915_private *dev_priv ;
  bool ret ;
  {
  {
  ret = (bool )1;
  spin_lock(& mchdev_lock);
  }
  if ((unsigned long )i915_mch_dev == (unsigned long )((struct drm_i915_private *)0)) {
    ret = (bool )0;
    goto out_unlock;
  } else {
  }
  dev_priv = i915_mch_dev;
  if ((int )dev_priv->max_delay > (int )dev_priv->fmax) {
    dev_priv->max_delay = (u8 )((int )dev_priv->max_delay - 1);
  } else {
  }
  out_unlock:
  {
  spin_unlock(& mchdev_lock);
  }
  return (ret);
}
}
bool i915_gpu_lower(void)
{ struct drm_i915_private *dev_priv ;
  bool ret ;
  {
  {
  ret = (bool )1;
  spin_lock(& mchdev_lock);
  }
  if ((unsigned long )i915_mch_dev == (unsigned long )((struct drm_i915_private *)0)) {
    ret = (bool )0;
    goto out_unlock;
  } else {
  }
  dev_priv = i915_mch_dev;
  if ((int )dev_priv->max_delay < (int )dev_priv->min_delay) {
    dev_priv->max_delay = (u8 )((int )dev_priv->max_delay + 1);
  } else {
  }
  out_unlock:
  {
  spin_unlock(& mchdev_lock);
  }
  return (ret);
}
}
bool i915_gpu_busy(void)
{ struct drm_i915_private *dev_priv ;
  bool ret ;
  {
  {
  ret = (bool )0;
  spin_lock(& mchdev_lock);
  }
  if ((unsigned long )i915_mch_dev == (unsigned long )((struct drm_i915_private *)0)) {
    goto out_unlock;
  } else {
  }
  dev_priv = i915_mch_dev;
  ret = dev_priv->busy;
  out_unlock:
  {
  spin_unlock(& mchdev_lock);
  }
  return (ret);
}
}
bool i915_gpu_turbo_disable(void)
{ struct drm_i915_private *dev_priv ;
  bool ret ;
  bool tmp ;
  int tmp___0 ;
  {
  {
  ret = (bool )1;
  spin_lock(& mchdev_lock);
  }
  if ((unsigned long )i915_mch_dev == (unsigned long )((struct drm_i915_private *)0)) {
    ret = (bool )0;
    goto out_unlock;
  } else {
  }
  {
  dev_priv = i915_mch_dev;
  dev_priv->max_delay = dev_priv->fstart;
  tmp = ironlake_set_drps(dev_priv->dev, (u8 )((int )dev_priv->fstart));
  }
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    ret = (bool )0;
  } else {
  }
  out_unlock:
  {
  spin_unlock(& mchdev_lock);
  }
  return (ret);
}
}
static void ips_ping_for_i915_load(void)
{ void (*link)(void) ;
  void *tmp ;
  {
  {
  tmp = __symbol_get("ips_link_to_i915_driver");
  link = (void (*)(void))tmp;
  }
  if ((unsigned long )link != (unsigned long )((void (*)(void))0)) {
    {
    (*link)();
    __symbol_put("ips_link_to_i915_driver");
    }
  } else {
  }
  return;
}
}
int i915_driver_load(struct drm_device *dev , unsigned long flags )
{ struct drm_i915_private *dev_priv ;
  int ret ;
  int mmio_bar ;
  uint32_t agp_size ;
  void *tmp ;
  int tmp___0 ;
  struct lock_class_key __key ;
  char const *__lock_name ;
  struct workqueue_struct *tmp___1 ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  int tmp___2 ;
  struct lock_class_key __key___3 ;
  {
  {
  ret = 0;
  dev->counters = dev->counters + 4UL;
  dev->types[6] = (enum drm_stat_type )9;
  dev->types[7] = (enum drm_stat_type )10;
  dev->types[8] = (enum drm_stat_type )11;
  dev->types[9] = (enum drm_stat_type )12;
  tmp = kzalloc(7688UL, 208U);
  dev_priv = (struct drm_i915_private *)tmp;
  }
  if ((unsigned long )dev_priv == (unsigned long )((struct drm_i915_private *)0)) {
    return (-12);
  } else {
  }
  {
  dev->dev_private = (void *)dev_priv;
  dev_priv->dev = dev;
  dev_priv->info = (struct intel_device_info const *)flags;
  tmp___0 = i915_get_bridge_dev(dev);
  }
  if (tmp___0 != 0) {
    ret = -5;
    goto free_priv;
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 2U) {
    {
    dma_set_coherent_mask(& (dev->pdev)->dev, 1073741823ULL);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    dma_set_coherent_mask(& (dev->pdev)->dev, 4294967295ULL);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    dma_set_coherent_mask(& (dev->pdev)->dev, 4294967295ULL);
    }
  } else {
  }
  {
  mmio_bar = (unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 2U;
  dev_priv->regs = pci_iomap(dev->pdev, mmio_bar, 0UL);
  }
  if ((unsigned long )dev_priv->regs == (unsigned long )((void *)0)) {
    {
    drm_err("i915_driver_load", "failed to map registers\n");
    ret = -5;
    }
    goto put_bridge;
  } else {
  }
  {
  dev_priv->mm.gtt = intel_gtt_get();
  }
  if ((unsigned long )dev_priv->mm.gtt == (unsigned long )((struct intel_gtt const *)0)) {
    {
    drm_err("i915_driver_load", "Failed to initialize GTT\n");
    ret = -19;
    }
    goto out_rmmap;
  } else {
  }
  {
  agp_size = (uint32_t )((dev_priv->mm.gtt)->gtt_mappable_entries << 12);
  dev_priv->mm.gtt_mapping = io_mapping_create_wc((resource_size_t )(dev->agp)->base,
                                                  (unsigned long )agp_size);
  }
  if ((unsigned long )dev_priv->mm.gtt_mapping == (unsigned long )((struct io_mapping *)0)) {
    ret = -5;
    goto out_rmmap;
  } else {
  }
  {
  dev_priv->mm.gtt_mtrr = mtrr_add((dev->agp)->base, (unsigned long )agp_size, 1U,
                                   (bool )1);
  }
  if (dev_priv->mm.gtt_mtrr < 0) {
    {
    printk("<6>[drm] MTRR allocation failed.  Graphics performance may suffer.\n");
    }
  } else {
  }
  {
  __lock_name = "i915";
  tmp___1 = __alloc_workqueue_key("i915", 3U, 1, & __key, __lock_name);
  dev_priv->wq = tmp___1;
  }
  if ((unsigned long )dev_priv->wq == (unsigned long )((struct workqueue_struct *)0)) {
    {
    drm_err("i915_driver_load", "Failed to create our workqueue.\n");
    ret = -12;
    }
    goto out_mtrrfree;
  } else {
  }
  {
  dev_priv->has_gem = 1;
  intel_irq_init(dev);
  intel_setup_mchbar(dev);
  intel_setup_gmbus(dev);
  intel_opregion_setup(dev);
  intel_setup_bios(dev);
  i915_gem_load(dev);
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) == 0U) {
    {
    ret = i915_init_phys_hws(dev);
    }
    if (ret != 0) {
      goto out_gem_unload;
    } else {
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    {
    i915_pineview_get_mem_freq(dev);
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    i915_ironlake_get_mem_freq(dev);
    }
  } else {
  }
  if (dev->pci_device != 10098) {
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) == 0U) {
      {
      pci_enable_msi_block(dev->pdev, 1U);
      }
    } else {
    }
  } else {
  }
  {
  spinlock_check(& dev_priv->irq_lock);
  __raw_spin_lock_init(& dev_priv->irq_lock.ldv_6060.rlock, "&(&dev_priv->irq_lock)->rlock",
                       & __key___0);
  spinlock_check(& dev_priv->error_lock);
  __raw_spin_lock_init(& dev_priv->error_lock.ldv_6060.rlock, "&(&dev_priv->error_lock)->rlock",
                       & __key___1);
  spinlock_check(& dev_priv->rps_lock);
  __raw_spin_lock_init(& dev_priv->rps_lock.ldv_6060.rlock, "&(&dev_priv->rps_lock)->rlock",
                       & __key___2);
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    dev_priv->num_pipe = 2;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 2U) {
    dev_priv->num_pipe = 2;
  } else {
    dev_priv->num_pipe = 1;
  }
  {
  ret = drm_vblank_init(dev, dev_priv->num_pipe);
  }
  if (ret != 0) {
    goto out_gem_unload;
  } else {
  }
  {
  dev_priv->mm.suspended = 1;
  intel_detect_pch(dev);
  tmp___2 = drm_core_check_feature(dev, 8192);
  }
  if (tmp___2 != 0) {
    {
    ret = i915_load_modeset_init(dev);
    }
    if (ret < 0) {
      {
      drm_err("i915_driver_load", "failed to init modeset\n");
      }
      goto out_gem_unload;
    } else {
    }
  } else {
  }
  {
  intel_opregion_init(dev);
  acpi_video_register();
  setup_timer_key(& dev_priv->hangcheck_timer, "&dev_priv->hangcheck_timer", & __key___3,
                  & i915_hangcheck_elapsed, (unsigned long )dev);
  spin_lock(& mchdev_lock);
  i915_mch_dev = dev_priv;
  dev_priv->mchdev_lock = & mchdev_lock;
  spin_unlock(& mchdev_lock);
  ips_ping_for_i915_load();
  }
  return (0);
  out_gem_unload: ;
  if ((unsigned long )dev_priv->mm.inactive_shrinker.shrink != (unsigned long )((int (*)(struct shrinker * ,
                                                                                         struct shrink_control * ))0)) {
    {
    unregister_shrinker(& dev_priv->mm.inactive_shrinker);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)dev->pdev + 2417UL) != 0U) {
    {
    pci_disable_msi(dev->pdev);
    }
  } else {
  }
  {
  intel_teardown_gmbus(dev);
  intel_teardown_mchbar(dev);
  destroy_workqueue(dev_priv->wq);
  }
  out_mtrrfree: ;
  if (dev_priv->mm.gtt_mtrr >= 0) {
    {
    mtrr_del(dev_priv->mm.gtt_mtrr, (dev->agp)->base, (dev->agp)->agp_info.aper_size * 1048576UL);
    dev_priv->mm.gtt_mtrr = -1;
    }
  } else {
  }
  {
  io_mapping_free(dev_priv->mm.gtt_mapping);
  }
  out_rmmap:
  {
  pci_iounmap(dev->pdev, dev_priv->regs);
  }
  put_bridge:
  {
  pci_dev_put(dev_priv->bridge_dev);
  }
  free_priv:
  {
  kfree((void const *)dev_priv);
  }
  return (ret);
}
}
int i915_driver_unload(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  spin_lock(& mchdev_lock);
  i915_mch_dev = (struct drm_i915_private *)0;
  spin_unlock(& mchdev_lock);
  }
  if ((unsigned long )dev_priv->mm.inactive_shrinker.shrink != (unsigned long )((int (*)(struct shrinker * ,
                                                                                         struct shrink_control * ))0)) {
    {
    unregister_shrinker(& dev_priv->mm.inactive_shrinker);
    }
  } else {
  }
  {
  mutex_lock_nested(& dev->struct_mutex, 0U);
  ret = i915_gpu_idle(dev);
  }
  if (ret != 0) {
    {
    drm_err("i915_driver_unload", "failed to idle hardware: %d\n", ret);
    }
  } else {
  }
  {
  mutex_unlock(& dev->struct_mutex);
  cancel_delayed_work_sync(& dev_priv->mm.retire_work);
  io_mapping_free(dev_priv->mm.gtt_mapping);
  }
  if (dev_priv->mm.gtt_mtrr >= 0) {
    {
    mtrr_del(dev_priv->mm.gtt_mtrr, (dev->agp)->base, (dev->agp)->agp_info.aper_size * 1048576UL);
    dev_priv->mm.gtt_mtrr = -1;
    }
  } else {
  }
  {
  acpi_video_unregister();
  tmp = drm_core_check_feature(dev, 8192);
  }
  if (tmp != 0) {
    {
    intel_fbdev_fini(dev);
    intel_modeset_cleanup(dev);
    }
    if ((unsigned long )dev_priv->child_dev != (unsigned long )((struct child_device_config *)0)) {
      if (dev_priv->child_dev_num != 0) {
        {
        kfree((void const *)dev_priv->child_dev);
        dev_priv->child_dev = (struct child_device_config *)0;
        dev_priv->child_dev_num = 0;
        }
      } else {
      }
    } else {
    }
    {
    vga_switcheroo_unregister_client(dev->pdev);
    vga_client_register(dev->pdev, (void *)0, (void (*)(void * , bool ))0, (unsigned int (*)(void * ,
                                                                                              bool ))0);
    }
  } else {
  }
  {
  del_timer_sync(& dev_priv->hangcheck_timer);
  cancel_work_sync(& dev_priv->error_work);
  i915_destroy_error_state(dev);
  }
  if ((unsigned int )*((unsigned char *)dev->pdev + 2417UL) != 0U) {
    {
    pci_disable_msi(dev->pdev);
    }
  } else {
  }
  {
  intel_opregion_fini(dev);
  tmp___0 = drm_core_check_feature(dev, 8192);
  }
  if (tmp___0 != 0) {
    {
    flush_workqueue(dev_priv->wq);
    mutex_lock_nested(& dev->struct_mutex, 0U);
    i915_gem_free_all_phys_object(dev);
    i915_gem_cleanup_ringbuffer(dev);
    mutex_unlock(& dev->struct_mutex);
    }
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
      if (i915_powersave != 0U) {
        {
        i915_cleanup_compression(dev);
        }
      } else {
      }
    } else {
    }
    {
    drm_mm_takedown(& dev_priv->mm.stolen);
    intel_cleanup_overlay(dev);
    }
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) == 0U) {
      {
      i915_free_hws(dev);
      }
    } else {
    }
  } else {
  }
  if ((unsigned long )dev_priv->regs != (unsigned long )((void *)0)) {
    {
    pci_iounmap(dev->pdev, dev_priv->regs);
    }
  } else {
  }
  {
  intel_teardown_gmbus(dev);
  intel_teardown_mchbar(dev);
  destroy_workqueue(dev_priv->wq);
  pci_dev_put(dev_priv->bridge_dev);
  kfree((void const *)dev->dev_private);
  }
  return (0);
}
}
int i915_driver_open(struct drm_device *dev , struct drm_file *file )
{ struct drm_i915_file_private *file_priv ;
  void *tmp ;
  struct lock_class_key __key ;
  {
  {
  drm_ut_debug_printk(2U, "drm", "i915_driver_open", "\n");
  tmp = kmalloc(88UL, 208U);
  file_priv = (struct drm_i915_file_private *)tmp;
  }
  if ((unsigned long )file_priv == (unsigned long )((struct drm_i915_file_private *)0)) {
    return (-12);
  } else {
  }
  {
  file->driver_priv = (void *)file_priv;
  spinlock_check(& file_priv->mm.lock);
  __raw_spin_lock_init(& file_priv->mm.lock.ldv_6060.rlock, "&(&file_priv->mm.lock)->rlock",
                       & __key);
  INIT_LIST_HEAD(& file_priv->mm.request_list);
  }
  return (0);
}
}
void i915_driver_lastclose(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  int tmp ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  if ((unsigned long )dev_priv == (unsigned long )((drm_i915_private_t *)0)) {
    {
    intel_fb_restore_mode(dev);
    vga_switcheroo_process_delayed_switch();
    }
    return;
  } else {
    {
    tmp = drm_core_check_feature(dev, 8192);
    }
    if (tmp != 0) {
      {
      intel_fb_restore_mode(dev);
      vga_switcheroo_process_delayed_switch();
      }
      return;
    } else {
    }
  }
  {
  i915_gem_lastclose(dev);
  }
  if ((unsigned long )dev_priv->agp_heap != (unsigned long )((struct mem_block *)0)) {
    {
    i915_mem_takedown(& dev_priv->agp_heap);
    }
  } else {
  }
  {
  i915_dma_cleanup(dev);
  }
  return;
}
}
void i915_driver_preclose(struct drm_device *dev , struct drm_file *file_priv )
{ drm_i915_private_t *dev_priv ;
  int tmp ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  i915_gem_release(dev, file_priv);
  tmp = drm_core_check_feature(dev, 8192);
  }
  if (tmp == 0) {
    {
    i915_mem_release(dev, file_priv, dev_priv->agp_heap);
    }
  } else {
  }
  return;
}
}
void i915_driver_postclose(struct drm_device *dev , struct drm_file *file )
{ struct drm_i915_file_private *file_priv ;
  {
  {
  file_priv = (struct drm_i915_file_private *)file->driver_priv;
  kfree((void const *)file_priv);
  }
  return;
}
}
struct drm_ioctl_desc i915_ioctls[42U] =
  { {0U, 7, & i915_dma_init, 1078223936U},
        {1U, 1, & i915_flush_ioctl, 25665U},
        {2U, 1, & i915_flip_bufs, 25666U},
        {3U, 1, & i915_batchbuffer, 1075864643U},
        {4U, 1, & i915_irq_emit, 3221775428U},
        {5U, 1, & i915_irq_wait, 1074029637U},
        {6U, 1, & i915_getparam, 3222299718U},
        {7U, 7, & i915_setparam, 1074291783U},
        {8U, 1, & i915_mem_alloc, 3222824008U},
        {9U, 1, & i915_mem_free, 1074291785U},
        {10U, 7, & i915_mem_init_heap, 1074553930U},
        {11U, 1, & i915_cmdbuffer, 1075864651U},
        {12U, 7, & i915_mem_destroy_heap, 1074029644U},
        {13U, 7, & i915_vblank_pipe_set, 1074029645U},
        {14U, 1, & i915_vblank_pipe_get, 2147771470U},
        {15U, 1, & i915_vblank_swap, 3222037583U},
        {0U, 0, (drm_ioctl_t *)0, 0U},
        {17U, 7, & i915_set_status_page, 1074816081U},
        {0U, 0, (drm_ioctl_t *)0, 0U},
        {19U, 23, & i915_gem_init_ioctl, 1074816083U},
        {20U, 17, & i915_gem_execbuffer, 1076388948U},
        {21U, 21, & i915_gem_pin_ioctl, 3222824021U},
        {22U, 21, & i915_gem_unpin_ioctl, 1074291798U},
        {23U, 17, & i915_gem_busy_ioctl, 3221775447U},
        {24U, 17, & i915_gem_throttle_ioctl, 25688U},
        {25U, 23, & i915_gem_entervt_ioctl, 25689U},
        {26U, 23, & i915_gem_leavevt_ioctl, 25690U},
        {27U, 16, & i915_gem_create_ioctl, 3222299739U},
        {28U, 16, & i915_gem_pread_ioctl, 1075864668U},
        {29U, 16, & i915_gem_pwrite_ioctl, 1075864669U},
        {30U, 16, & i915_gem_mmap_ioctl, 3223348318U},
        {31U, 16, & i915_gem_set_domain_ioctl, 1074553951U},
        {32U, 16, & i915_gem_sw_finish_ioctl, 1074029664U},
        {33U, 16, & i915_gem_set_tiling, 3222299745U},
        {34U, 16, & i915_gem_get_tiling, 3222037602U},
        {35U, 16, & i915_gem_get_aperture_ioctl, 2148557923U},
        {36U, 16, & i915_gem_mmap_gtt_ioctl, 3222299748U},
        {37U, 16, & intel_get_pipe_from_crtc_id, 3221775461U},
        {38U, 16, & i915_gem_madvise_ioctl, 3222037606U},
        {39U, 26, & intel_overlay_put_image, 3224134824U},
        {40U, 26, & intel_overlay_attrs, 3224134760U},
        {41U, 17, & i915_gem_execbuffer2, 1077961833U}};
int i915_max_ioctl = 42;
int i915_driver_device_is_agp(struct drm_device *dev )
{
  {
  return (1);
}
}
__inline static int list_empty(struct list_head const *head )
{
  {
  return ((unsigned long )((struct list_head const *)head->next) == (unsigned long )head);
}
}
__inline static int variable_test_bit(int nr , unsigned long const volatile *addr )
{ int oldbit ;
  {
  __asm__ volatile ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
  return (oldbit);
}
}
extern struct task_struct *current_task ;
__inline static struct task_struct *get_current(void)
{ struct task_struct *pfo_ret__ ;
  {
  if (1) {
    goto case_8;
  } else {
    goto switch_default;
    if (0) {
      __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
      goto ldv_2386;
      __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
      goto ldv_2386;
      __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
      goto ldv_2386;
      case_8:
      __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
      goto ldv_2386;
      switch_default:
      {
      __bad_percpu_size();
      }
    } else {
    }
  }
  ldv_2386: ;
  return (pfo_ret__);
}
}
extern struct pv_irq_ops pv_irq_ops ;
__inline static unsigned long arch_local_save_flags(void)
{ unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;
  {
  {
  __edi = __edi;
  __esi = __esi;
  __edx = __edx;
  __ecx = __ecx;
  __eax = __eax;
  tmp = __builtin_expect((long )((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0)),
                         0L);
  }
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/paravirt.h"),
                         "i" (853), "i" (12UL));
    ldv_4705: ;
    goto ldv_4705;
  } else {
  }
  __asm__ volatile ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (46UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
  __ret = __eax;
  return (__ret);
}
}
__inline static void arch_local_irq_restore(unsigned long f )
{ unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;
  {
  {
  __edi = __edi;
  __esi = __esi;
  __edx = __edx;
  __ecx = __ecx;
  __eax = __eax;
  tmp = __builtin_expect((long )((unsigned long )pv_irq_ops.restore_fl.func == (unsigned long )((void *)0)),
                         0L);
  }
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/paravirt.h"),
                         "i" (858), "i" (12UL));
    ldv_4715: ;
    goto ldv_4715;
  } else {
  }
  __asm__ volatile ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (47UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.restore_fl.func), [paravirt_clobber] "i" (1),
                       "D" (f): "memory", "cc");
  return;
}
}
__inline static void arch_local_irq_disable(void)
{ unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;
  {
  {
  __edi = __edi;
  __esi = __esi;
  __edx = __edx;
  __ecx = __ecx;
  __eax = __eax;
  tmp = __builtin_expect((long )((unsigned long )pv_irq_ops.irq_disable.func == (unsigned long )((void *)0)),
                         0L);
  }
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/paravirt.h"),
                         "i" (863), "i" (12UL));
    ldv_4724: ;
    goto ldv_4724;
  } else {
  }
  __asm__ volatile ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (48UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.irq_disable.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
  return;
}
}
__inline static unsigned long arch_local_irq_save(void)
{ unsigned long f ;
  {
  {
  f = arch_local_save_flags();
  arch_local_irq_disable();
  }
  return (f);
}
}
__inline static int arch_irqs_disabled_flags(unsigned long flags )
{
  {
  return ((flags & 512UL) == 0UL);
}
}
extern void trace_hardirqs_on(void) ;
extern void trace_hardirqs_off(void) ;
__inline static void atomic_set(atomic_t *v , int i )
{
  {
  v->counter = i;
  return;
}
}
__inline static void atomic_inc(atomic_t *v )
{
  {
  __asm__ volatile (".section .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.previous\n671:\n\tlock; incl %0": "+m" (v->counter));
  return;
}
}
__inline static int test_ti_thread_flag(struct thread_info *ti , int flag )
{ int tmp ;
  {
  {
  tmp = variable_test_bit(flag, (unsigned long const volatile *)(& ti->flags));
  }
  return (tmp);
}
}
extern void lockdep_init_map(struct lockdep_map * , char const * , struct lock_class_key * ,
                             int ) ;
extern void _raw_spin_lock_irq(raw_spinlock_t * ) ;
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
extern void _raw_spin_unlock_irq(raw_spinlock_t * ) ;
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long ) ;
__inline static void spin_lock_irq(spinlock_t *lock )
{
  {
  {
  _raw_spin_lock_irq(& lock->ldv_6060.rlock);
  }
  return;
}
}
__inline static void spin_unlock_irq(spinlock_t *lock )
{
  {
  {
  _raw_spin_unlock_irq(& lock->ldv_6060.rlock);
  }
  return;
}
}
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags )
{
  {
  {
  _raw_spin_unlock_irqrestore(& lock->ldv_6060.rlock, flags);
  }
  return;
}
}
extern void do_gettimeofday(struct timeval * ) ;
extern int default_wake_function(wait_queue_t * , unsigned int , int , void * ) ;
extern void __init_waitqueue_head(wait_queue_head_t * , struct lock_class_key * ) ;
__inline static int waitqueue_active(wait_queue_head_t *q )
{ int tmp ;
  {
  {
  tmp = list_empty((struct list_head const *)(& q->task_list));
  }
  return (tmp == 0);
}
}
extern void add_wait_queue(wait_queue_head_t * , wait_queue_t * ) ;
extern void remove_wait_queue(wait_queue_head_t * , wait_queue_t * ) ;
extern void __wake_up(wait_queue_head_t * , unsigned int , int , void * ) ;
extern int mod_timer(struct timer_list * , unsigned long ) ;
extern void __init_work(struct work_struct * , int ) ;
extern int queue_work(struct workqueue_struct * , struct work_struct * ) ;
extern void complete_all(struct completion * ) ;
__inline static void writew(unsigned short val , void volatile *addr )
{
  {
  __asm__ volatile ("movw %0,%1": : "r" (val), "m" (*((unsigned short volatile *)addr)): "memory");
  return;
}
}
__inline static unsigned long readq(void const volatile *addr )
{ unsigned long ret ;
  {
  __asm__ volatile ("movq %1,%0": "=r" (ret): "m" (*((unsigned long volatile *)addr)): "memory");
  return (ret);
}
}
__inline static void memcpy_fromio(void *dst , void const volatile *src , size_t count )
{ size_t __len ;
  void *__ret ;
  {
  {
  __len = count;
  __ret = memcpy(dst, (void const *)src, __len);
  }
  return;
}
}
extern int kobject_uevent_env(struct kobject * , enum kobject_action , char ** ) ;
extern long schedule_timeout(long ) ;
__inline static int test_tsk_thread_flag(struct task_struct *tsk , int flag )
{ int tmp ;
  {
  {
  tmp = test_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
  return (tmp);
}
}
__inline static int signal_pending(struct task_struct *p )
{ int tmp ;
  long tmp___0 ;
  {
  {
  tmp = test_tsk_thread_flag(p, 2);
  tmp___0 = __builtin_expect((long )(tmp != 0), 0L);
  }
  return ((int )tmp___0);
}
}
extern bool drm_handle_vblank(struct drm_device * , int ) ;
extern int drm_calc_vbltimestamp_from_scanoutpos(struct drm_device * , int , int * ,
                                                 struct timeval * , unsigned int ,
                                                 struct drm_crtc * ) ;
__inline static void *io_mapping_map_atomic_wc(struct io_mapping *mapping , unsigned long offset )
{
  {
  return ((void *)mapping + offset);
}
}
__inline static void io_mapping_unmap_atomic(void *vaddr )
{
  {
  return;
}
}
struct tracepoint __tracepoint_i915_gem_request_complete ;
__inline static void trace_i915_gem_request_complete(struct intel_ring_buffer *ring ,
                                                     u32 seqno )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_gem_request_complete.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_gem_request_complete.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )307);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_36254:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct intel_ring_buffer * , u32 ))it_func))(__data,
                                                                          ring, seqno);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_36254;
      } else {
        goto ldv_36255;
      }
      ldv_36255: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
void i915_handle_error(struct drm_device *dev , bool wedged ) ;
void i915_enable_pipestat(drm_i915_private_t *dev_priv , int pipe , u32 mask ) ;
void i915_disable_pipestat(drm_i915_private_t *dev_priv , int pipe , u32 mask ) ;
void intel_enable_asle(struct drm_device *dev ) ;
__inline static bool i915_seqno_passed(uint32_t seq1 , uint32_t seq2 )
{
  {
  return ((bool )((int )(seq1 - seq2) >= 0));
}
}
void intel_opregion_asle_intr(struct drm_device *dev ) ;
void intel_opregion_gse_intr(struct drm_device *dev ) ;
void intel_opregion_enable_asle(struct drm_device *dev ) ;
void gen6_set_rps(struct drm_device *dev , u8 val ) ;
struct intel_overlay_error_state *intel_overlay_capture_error_state(struct drm_device *dev ) ;
struct intel_display_error_state *intel_display_capture_error_state(struct drm_device *dev ) ;
__inline static u64 i915_read64(struct drm_i915_private *dev_priv , u32 reg )
{ u64 val ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  {
  val = 0ULL;
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        gen6_gt_force_wake_get(dev_priv);
        tmp = readq((void const volatile *)dev_priv->regs + (unsigned long )reg);
        val = (u64 )tmp;
        gen6_gt_force_wake_put(dev_priv);
        }
      } else {
        {
        tmp___0 = readq((void const volatile *)dev_priv->regs + (unsigned long )reg);
        val = (u64 )tmp___0;
        }
      }
    } else {
      {
      tmp___0 = readq((void const volatile *)dev_priv->regs + (unsigned long )reg);
      val = (u64 )tmp___0;
      }
    }
  } else {
    {
    tmp___0 = readq((void const volatile *)dev_priv->regs + (unsigned long )reg);
    val = (u64 )tmp___0;
    }
  }
  {
  trace_i915_reg_rw((bool )0, reg, val, 8);
  }
  return (val);
}
}
__inline static void i915_write16(struct drm_i915_private *dev_priv , u32 reg , u16 val )
{
  {
  {
  trace_i915_reg_rw((bool )1, reg, (u64 )val, 2);
  }
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        __gen6_gt_wait_for_fifo(dev_priv);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  writew((unsigned short )((int )val), (void volatile *)dev_priv->regs + (unsigned long )reg);
  }
  return;
}
}
extern void drm_helper_hpd_irq_event(struct drm_device * ) ;
__inline static struct drm_crtc *intel_get_crtc_for_pipe(struct drm_device *dev ,
                                                         int pipe )
{ struct drm_i915_private *dev_priv ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  return (dev_priv->pipe_to_crtc_mapping[pipe]);
}
}
void intel_prepare_page_flip(struct drm_device *dev , int plane ) ;
void intel_finish_page_flip(struct drm_device *dev , int pipe ) ;
void intel_finish_page_flip_plane(struct drm_device *dev , int plane ) ;
static void ironlake_enable_display_irq(drm_i915_private_t *dev_priv , u32 mask )
{
  {
  if ((dev_priv->irq_mask & mask) != 0U) {
    {
    dev_priv->irq_mask = dev_priv->irq_mask & ~ mask;
    i915_write32(dev_priv, 278532U, dev_priv->irq_mask);
    readl((void const volatile *)dev_priv->regs + 278532U);
    }
  } else {
  }
  return;
}
}
__inline static void ironlake_disable_display_irq(drm_i915_private_t *dev_priv , u32 mask )
{
  {
  if ((dev_priv->irq_mask & mask) != mask) {
    {
    dev_priv->irq_mask = dev_priv->irq_mask | mask;
    i915_write32(dev_priv, 278532U, dev_priv->irq_mask);
    readl((void const volatile *)dev_priv->regs + 278532U);
    }
  } else {
  }
  return;
}
}
void i915_enable_pipestat(drm_i915_private_t *dev_priv , int pipe , u32 mask )
{ u32 reg ;
  {
  if ((dev_priv->pipestat[pipe] & mask) != mask) {
    {
    reg = (u32 )(pipe * 4096 + 458788);
    dev_priv->pipestat[pipe] = dev_priv->pipestat[pipe] | mask;
    i915_write32(dev_priv, reg, dev_priv->pipestat[pipe] | (mask >> 16));
    readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
    }
  } else {
  }
  return;
}
}
void i915_disable_pipestat(drm_i915_private_t *dev_priv , int pipe , u32 mask )
{ u32 reg ;
  {
  if ((dev_priv->pipestat[pipe] & mask) != 0U) {
    {
    reg = (u32 )(pipe * 4096 + 458788);
    dev_priv->pipestat[pipe] = dev_priv->pipestat[pipe] & ~ mask;
    i915_write32(dev_priv, reg, dev_priv->pipestat[pipe]);
    readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
    }
  } else {
  }
  return;
}
}
void intel_enable_asle(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  unsigned long irqflags ;
  raw_spinlock_t *tmp ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = spinlock_check(& dev_priv->irq_lock);
  irqflags = _raw_spin_lock_irqsave(tmp);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    ironlake_enable_display_irq(dev_priv, 262144U);
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    ironlake_enable_display_irq(dev_priv, 262144U);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    ironlake_enable_display_irq(dev_priv, 262144U);
    }
  } else {
    {
    i915_enable_pipestat(dev_priv, 1, 4194304U);
    }
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
      {
      i915_enable_pipestat(dev_priv, 0, 4194304U);
      }
    } else {
    }
  }
  {
  spin_unlock_irqrestore(& dev_priv->irq_lock, irqflags);
  }
  return;
}
}
static int i915_pipe_enabled(struct drm_device *dev , int pipe )
{ drm_i915_private_t *dev_priv ;
  u32 tmp ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = i915_read32(dev_priv, (u32 )(pipe * 4096 + 458760));
  }
  return ((int )tmp & (-0x7FFFFFFF-1));
}
}
static u32 i915_get_vblank_counter(struct drm_device *dev , int pipe )
{ drm_i915_private_t *dev_priv ;
  unsigned long high_frame ;
  unsigned long low_frame ;
  u32 high1 ;
  u32 high2 ;
  u32 low ;
  int tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = i915_pipe_enabled(dev, pipe);
  }
  if (tmp == 0) {
    {
    drm_ut_debug_printk(2U, "drm", "i915_get_vblank_counter", "trying to get vblank count for disabled pipe %c\n",
                        pipe + 65);
    }
    return (0U);
  } else {
  }
  high_frame = (unsigned long )(pipe * 4096 + 458816);
  low_frame = (unsigned long )(pipe * 4096 + 458820);
  ldv_37592:
  {
  tmp___0 = i915_read32(dev_priv, (u32 )high_frame);
  high1 = tmp___0 & 65535U;
  tmp___1 = i915_read32(dev_priv, (u32 )low_frame);
  low = tmp___1 & 4278190080U;
  tmp___2 = i915_read32(dev_priv, (u32 )high_frame);
  high2 = tmp___2 & 65535U;
  }
  if (high1 != high2) {
    goto ldv_37592;
  } else {
    goto ldv_37593;
  }
  ldv_37593:
  high1 = high1;
  low = low >> 24;
  return ((high1 << 8) | low);
}
}
static u32 gm45_get_vblank_counter(struct drm_device *dev , int pipe )
{ drm_i915_private_t *dev_priv ;
  int reg ;
  int tmp ;
  u32 tmp___0 ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  reg = pipe * 4096 + 458816;
  tmp = i915_pipe_enabled(dev, pipe);
  }
  if (tmp == 0) {
    {
    drm_ut_debug_printk(2U, "drm", "gm45_get_vblank_counter", "trying to get vblank count for disabled pipe %c\n",
                        pipe + 65);
    }
    return (0U);
  } else {
  }
  {
  tmp___0 = i915_read32(dev_priv, (u32 )reg);
  }
  return (tmp___0);
}
}
static int i915_get_crtc_scanoutpos(struct drm_device *dev , int pipe , int *vpos ,
                                    int *hpos )
{ drm_i915_private_t *dev_priv ;
  u32 vbl ;
  u32 position ;
  int vbl_start ;
  int vbl_end ;
  int htotal ;
  int vtotal ;
  bool in_vbl ;
  int ret ;
  int tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  vbl = 0U;
  position = 0U;
  in_vbl = (bool )1;
  ret = 0;
  tmp = i915_pipe_enabled(dev, pipe);
  }
  if (tmp == 0) {
    {
    drm_ut_debug_printk(2U, "drm", "i915_get_crtc_scanoutpos", "trying to get scanoutpos for disabled pipe %c\n",
                        pipe + 65);
    }
    return (0);
  } else {
  }
  {
  tmp___0 = i915_read32(dev_priv, (u32 )(pipe * 4096 + 393228));
  vtotal = (int )(((tmp___0 >> 16) & 8191U) + 1U);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    {
    position = i915_read32(dev_priv, (u32 )((pipe + 112) * 4096));
    *vpos = (int )position & 8191;
    *hpos = 0;
    }
  } else {
    {
    tmp___1 = i915_read32(dev_priv, (u32 )(pipe * 4096 + 458820));
    position = tmp___1 & 16777215U;
    tmp___2 = i915_read32(dev_priv, (u32 )((pipe + 96) * 4096));
    htotal = (int )(((tmp___2 >> 16) & 8191U) + 1U);
    *vpos = (int )(position / (u32 )htotal);
    *hpos = (int )(position - (u32 )(*vpos * htotal));
    }
  }
  {
  vbl = i915_read32(dev_priv, (u32 )(pipe * 4096 + 393232));
  vbl_start = (int )vbl & 8191;
  vbl_end = (int )(vbl >> 16) & 8191;
  }
  if (*vpos < vbl_start) {
    in_vbl = (bool )0;
  } else
  if (*vpos > vbl_end) {
    in_vbl = (bool )0;
  } else {
  }
  if ((int )in_vbl) {
    if (*vpos >= vbl_start) {
      *vpos = *vpos - vtotal;
    } else {
    }
  } else {
  }
  if (vbl != 0U) {
    ret = ret | 5;
  } else {
  }
  if ((int )in_vbl) {
    ret = ret | 2;
  } else {
  }
  return (ret);
}
}
static int i915_get_vblank_timestamp(struct drm_device *dev , int pipe , int *max_error ,
                                     struct timeval *vblank_time , unsigned int flags )
{ struct drm_i915_private *dev_priv ;
  struct drm_crtc *crtc ;
  int tmp ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if (pipe < 0) {
    {
    drm_err("i915_get_vblank_timestamp", "Invalid crtc %d\n", pipe);
    }
    return (-22);
  } else
  if (dev_priv->num_pipe <= pipe) {
    {
    drm_err("i915_get_vblank_timestamp", "Invalid crtc %d\n", pipe);
    }
    return (-22);
  } else {
  }
  {
  crtc = intel_get_crtc_for_pipe(dev, pipe);
  }
  if ((unsigned long )crtc == (unsigned long )((struct drm_crtc *)0)) {
    {
    drm_err("i915_get_vblank_timestamp", "Invalid crtc %d\n", pipe);
    }
    return (-22);
  } else {
  }
  if (! crtc->enabled) {
    {
    drm_ut_debug_printk(4U, "drm", "i915_get_vblank_timestamp", "crtc %d is disabled\n",
                        pipe);
    }
    return (-16);
  } else {
  }
  {
  tmp = drm_calc_vbltimestamp_from_scanoutpos(dev, pipe, max_error, vblank_time, flags,
                                              crtc);
  }
  return (tmp);
}
}
static void i915_hotplug_work_func(struct work_struct *work )
{ drm_i915_private_t *dev_priv ;
  struct work_struct const *__mptr ;
  struct drm_device *dev ;
  struct drm_mode_config *mode_config ;
  struct intel_encoder *encoder ;
  struct list_head const *__mptr___0 ;
  struct list_head const *__mptr___1 ;
  {
  {
  __mptr = (struct work_struct const *)work;
  dev_priv = (drm_i915_private_t *)__mptr + 0x0ffffffffffff978UL;
  dev = dev_priv->dev;
  mode_config = & dev->mode_config;
  drm_ut_debug_printk(4U, "drm", "i915_hotplug_work_func", "running encoder hotplug functions\n");
  __mptr___0 = (struct list_head const *)mode_config->encoder_list.next;
  encoder = (struct intel_encoder *)__mptr___0 + 0x0ffffffffffffff8UL;
  }
  goto ldv_37642;
  ldv_37641: ;
  if ((unsigned long )encoder->hot_plug != (unsigned long )((void (*)(struct intel_encoder * ))0)) {
    {
    (*(encoder->hot_plug))(encoder);
    }
  } else {
  }
  __mptr___1 = (struct list_head const *)encoder->base.head.next;
  encoder = (struct intel_encoder *)__mptr___1 + 0x0ffffffffffffff8UL;
  ldv_37642: ;
  if ((unsigned long )(& encoder->base.head) != (unsigned long )(& mode_config->encoder_list)) {
    goto ldv_37641;
  } else {
    goto ldv_37643;
  }
  ldv_37643:
  {
  drm_helper_hpd_irq_event(dev);
  }
  return;
}
}
static void i915_handle_rps_change(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  u32 busy_up ;
  u32 busy_down ;
  u32 max_avg ;
  u32 min_avg ;
  u8 new_delay ;
  bool tmp ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  new_delay = dev_priv->cur_delay;
  i915_write16(dev_priv, 70020U, (u16 )16);
  busy_up = i915_read32(dev_priv, 70584U);
  busy_down = i915_read32(dev_priv, 70588U);
  max_avg = i915_read32(dev_priv, 70044U);
  min_avg = i915_read32(dev_priv, 70048U);
  }
  if (busy_up > max_avg) {
    if ((int )dev_priv->cur_delay != (int )dev_priv->max_delay) {
      new_delay = (u8 )((unsigned int )dev_priv->cur_delay + 255U);
    } else {
    }
    if ((int )dev_priv->max_delay > (int )new_delay) {
      new_delay = dev_priv->max_delay;
    } else {
    }
  } else
  if (busy_down < min_avg) {
    if ((int )dev_priv->cur_delay != (int )dev_priv->min_delay) {
      new_delay = (u8 )((unsigned int )dev_priv->cur_delay + 1U);
    } else {
    }
    if ((int )dev_priv->min_delay < (int )new_delay) {
      new_delay = dev_priv->min_delay;
    } else {
    }
  } else {
  }
  {
  tmp = ironlake_set_drps(dev, (u8 )((int )new_delay));
  }
  if ((int )tmp) {
    dev_priv->cur_delay = new_delay;
  } else {
  }
  return;
}
}
static void notify_ring(struct drm_device *dev , struct intel_ring_buffer *ring )
{ struct drm_i915_private *dev_priv ;
  u32 seqno ;
  unsigned long tmp ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned long )ring->obj == (unsigned long )((struct drm_i915_gem_object *)0)) {
    return;
  } else {
  }
  {
  seqno = (*(ring->get_seqno))(ring);
  trace_i915_gem_request_complete(ring, seqno);
  ring->irq_seqno = seqno;
  __wake_up(& ring->irq_queue, 3U, 0, (void *)0);
  dev_priv->hangcheck_count = 0;
  tmp = msecs_to_jiffies((unsigned int const )1500U);
  mod_timer(& dev_priv->hangcheck_timer, tmp + (unsigned long )jiffies);
  }
  return;
}
}
static void gen6_pm_rps_work(struct work_struct *work )
{ drm_i915_private_t *dev_priv ;
  struct work_struct const *__mptr ;
  u8 new_delay ;
  u32 pm_iir ;
  u32 pm_imr ;
  u32 tmp ;
  u32 tmp___0 ;
  {
  {
  __mptr = (struct work_struct const *)work;
  dev_priv = (drm_i915_private_t *)__mptr + 0x0fffffffffffe328UL;
  new_delay = dev_priv->cur_delay;
  spin_lock_irq(& dev_priv->rps_lock);
  pm_iir = dev_priv->pm_iir;
  dev_priv->pm_iir = 0U;
  pm_imr = i915_read32(dev_priv, 278564U);
  spin_unlock_irq(& dev_priv->rps_lock);
  }
  if (pm_iir == 0U) {
    return;
  } else {
  }
  {
  mutex_lock_nested(& (dev_priv->dev)->struct_mutex, 0U);
  }
  if ((pm_iir & 32U) != 0U) {
    if ((int )dev_priv->cur_delay != (int )dev_priv->max_delay) {
      new_delay = (u8 )((unsigned int )dev_priv->cur_delay + 1U);
    } else {
    }
    if ((int )dev_priv->max_delay < (int )new_delay) {
      new_delay = dev_priv->max_delay;
    } else {
    }
  } else
  if ((pm_iir & 80U) != 0U) {
    {
    gen6_gt_force_wake_get(dev_priv);
    }
    if ((int )dev_priv->cur_delay != (int )dev_priv->min_delay) {
      new_delay = (u8 )((unsigned int )dev_priv->cur_delay + 255U);
    } else {
    }
    if ((int )dev_priv->min_delay > (int )new_delay) {
      {
      new_delay = dev_priv->min_delay;
      tmp = i915_read32(dev_priv, 40980U);
      i915_write32(dev_priv, 40980U, tmp | ((u32 )((int )new_delay << 16) & 4128768U));
      }
    } else {
      {
      tmp___0 = i915_read32(dev_priv, 40980U);
      i915_write32(dev_priv, 40980U, tmp___0 & 4290838527U);
      }
    }
    {
    gen6_gt_force_wake_put(dev_priv);
    }
  } else {
  }
  {
  gen6_set_rps(dev_priv->dev, (u8 )((int )new_delay));
  dev_priv->cur_delay = new_delay;
  i915_write32(dev_priv, 278564U, ~ pm_iir & pm_imr);
  mutex_unlock(& (dev_priv->dev)->struct_mutex);
  }
  return;
}
}
static void pch_irq_handler(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  u32 pch_iir ;
  int pipe ;
  u32 tmp ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  pch_iir = i915_read32(dev_priv, 802824U);
  }
  if ((pch_iir & 234881024U) != 0U) {
    {
    drm_ut_debug_printk(2U, "drm", "pch_irq_handler", "PCH audio power change on port %d\n",
                        (pch_iir & 234881024U) >> 25);
    }
  } else {
  }
  if ((pch_iir & 16777216U) != 0U) {
    {
    drm_ut_debug_printk(2U, "drm", "pch_irq_handler", "PCH GMBUS interrupt\n");
    }
  } else {
  }
  if ((pch_iir & 12582912U) != 0U) {
    {
    drm_ut_debug_printk(2U, "drm", "pch_irq_handler", "PCH HDCP audio interrupt\n");
    }
  } else {
  }
  if ((pch_iir & 3145728U) != 0U) {
    {
    drm_ut_debug_printk(2U, "drm", "pch_irq_handler", "PCH transcoder audio interrupt\n");
    }
  } else {
  }
  if ((pch_iir & 524288U) != 0U) {
    {
    drm_err("pch_irq_handler", "PCH poison interrupt\n");
    }
  } else {
  }
  if ((pch_iir & 196608U) != 0U) {
    pipe = 0;
    goto ldv_37676;
    ldv_37675:
    {
    tmp = i915_read32(dev_priv, (u32 )(pipe * 4096 + 983060));
    drm_ut_debug_printk(2U, "drm", "pch_irq_handler", "  pipe %c FDI IIR: 0x%08x\n",
                        pipe + 65, tmp);
    pipe = pipe + 1;
    }
    ldv_37676: ;
    if (dev_priv->num_pipe > pipe) {
      goto ldv_37675;
    } else {
      goto ldv_37677;
    }
    ldv_37677: ;
  } else {
  }
  if ((pch_iir & 36U) != 0U) {
    {
    drm_ut_debug_printk(2U, "drm", "pch_irq_handler", "PCH transcoder CRC done interrupt\n");
    }
  } else {
  }
  if ((pch_iir & 18U) != 0U) {
    {
    drm_ut_debug_printk(2U, "drm", "pch_irq_handler", "PCH transcoder CRC error interrupt\n");
    }
  } else {
  }
  if ((pch_iir & 8U) != 0U) {
    {
    drm_ut_debug_printk(2U, "drm", "pch_irq_handler", "PCH transcoder B underrun interrupt\n");
    }
  } else {
  }
  if ((int )pch_iir & 1) {
    {
    drm_ut_debug_printk(2U, "drm", "pch_irq_handler", "PCH transcoder A underrun interrupt\n");
    }
  } else {
  }
  return;
}
}
static irqreturn_t ivybridge_irq_handler(int irq , void *arg )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  int ret ;
  u32 de_iir ;
  u32 gt_iir ;
  u32 de_ier ;
  u32 pch_iir ;
  u32 pm_iir ;
  struct drm_i915_master_private *master_priv ;
  u32 tmp ;
  unsigned long flags ;
  raw_spinlock_t *tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;
  {
  {
  dev = (struct drm_device *)arg;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ret = 0;
  atomic_inc(& dev_priv->irq_received);
  de_ier = i915_read32(dev_priv, 278540U);
  i915_write32(dev_priv, 278540U, de_ier & 2147483647U);
  readl((void const volatile *)dev_priv->regs + 278540U);
  de_iir = i915_read32(dev_priv, 278536U);
  gt_iir = i915_read32(dev_priv, 278552U);
  pch_iir = i915_read32(dev_priv, 802824U);
  pm_iir = i915_read32(dev_priv, 278568U);
  }
  if (de_iir == 0U) {
    if (gt_iir == 0U) {
      if (pch_iir == 0U) {
        if (pm_iir == 0U) {
          goto done;
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  ret = 1;
  if ((unsigned long )(dev->primary)->master != (unsigned long )((struct drm_master *)0)) {
    master_priv = (struct drm_i915_master_private *)((dev->primary)->master)->driver_priv;
    if ((unsigned long )master_priv->sarea_priv != (unsigned long )((struct _drm_i915_sarea *)0)) {
      {
      tmp = intel_read_status_page((struct intel_ring_buffer *)(& dev_priv->ring),
                                   33);
      (master_priv->sarea_priv)->last_dispatch = (int )tmp;
      }
    } else {
    }
  } else {
  }
  if ((gt_iir & 17U) != 0U) {
    {
    notify_ring(dev, (struct intel_ring_buffer *)(& dev_priv->ring));
    }
  } else {
  }
  if ((gt_iir & 4096U) != 0U) {
    {
    notify_ring(dev, (struct intel_ring_buffer *)(& dev_priv->ring) + 1UL);
    }
  } else {
  }
  if ((gt_iir & 4194304U) != 0U) {
    {
    notify_ring(dev, (struct intel_ring_buffer *)(& dev_priv->ring) + 2UL);
    }
  } else {
  }
  if ((de_iir & 536870912U) != 0U) {
    {
    intel_opregion_gse_intr(dev);
    }
  } else {
  }
  if ((de_iir & 8U) != 0U) {
    {
    intel_prepare_page_flip(dev, 0);
    intel_finish_page_flip_plane(dev, 0);
    }
  } else {
  }
  if ((de_iir & 256U) != 0U) {
    {
    intel_prepare_page_flip(dev, 1);
    intel_finish_page_flip_plane(dev, 1);
    }
  } else {
  }
  if ((int )de_iir & 1) {
    {
    drm_handle_vblank(dev, 0);
    }
  } else {
  }
  if ((de_iir & 32U) != 0U) {
    {
    drm_handle_vblank(dev, 1);
    }
  } else {
  }
  if ((de_iir & 268435456U) != 0U) {
    if ((pch_iir & 15204352U) != 0U) {
      {
      queue_work(dev_priv->wq, & dev_priv->hotplug_work);
      }
    } else {
    }
    {
    pch_irq_handler(dev);
    }
  } else {
  }
  if ((pm_iir & 112U) != 0U) {
    {
    tmp___0 = spinlock_check(& dev_priv->rps_lock);
    flags = _raw_spin_lock_irqsave(tmp___0);
    __ret_warn_on = (dev_priv->pm_iir & pm_iir) != 0U;
    tmp___1 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
    }
    if (tmp___1 != 0L) {
      {
      warn_slowpath_fmt("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_irq.c.p",
                        (int const )540, "Missed a PM interrupt\n");
      }
    } else {
    }
    {
    __builtin_expect((long )(__ret_warn_on != 0), 0L);
    i915_write32(dev_priv, 278564U, pm_iir);
    dev_priv->pm_iir = dev_priv->pm_iir | pm_iir;
    spin_unlock_irqrestore(& dev_priv->rps_lock, flags);
    queue_work(dev_priv->wq, & dev_priv->rps_work);
    }
  } else {
  }
  {
  i915_write32(dev_priv, 802824U, pch_iir);
  i915_write32(dev_priv, 278552U, gt_iir);
  i915_write32(dev_priv, 278536U, de_iir);
  i915_write32(dev_priv, 278568U, pm_iir);
  }
  done:
  {
  i915_write32(dev_priv, 278540U, de_ier);
  readl((void const volatile *)dev_priv->regs + 278540U);
  }
  return ((irqreturn_t )ret);
}
}
static irqreturn_t ironlake_irq_handler(int irq , void *arg )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  int ret ;
  u32 de_iir ;
  u32 gt_iir ;
  u32 de_ier ;
  u32 pch_iir ;
  u32 pm_iir ;
  u32 hotplug_mask ;
  struct drm_i915_master_private *master_priv ;
  u32 bsd_usr_interrupt ;
  u32 tmp ;
  u32 tmp___0 ;
  unsigned long flags ;
  raw_spinlock_t *tmp___1 ;
  int __ret_warn_on ;
  long tmp___2 ;
  {
  {
  dev = (struct drm_device *)arg;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ret = 0;
  bsd_usr_interrupt = 32U;
  atomic_inc(& dev_priv->irq_received);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    bsd_usr_interrupt = 4096U;
  } else {
  }
  {
  de_ier = i915_read32(dev_priv, 278540U);
  i915_write32(dev_priv, 278540U, de_ier & 2147483647U);
  readl((void const volatile *)dev_priv->regs + 278540U);
  de_iir = i915_read32(dev_priv, 278536U);
  gt_iir = i915_read32(dev_priv, 278552U);
  pch_iir = i915_read32(dev_priv, 802824U);
  pm_iir = i915_read32(dev_priv, 278568U);
  }
  if (de_iir == 0U) {
    if (gt_iir == 0U) {
      if (pch_iir == 0U) {
        if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 6U) {
          goto done;
        } else
        if (pm_iir == 0U) {
          goto done;
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 1U) {
    hotplug_mask = 15204352U;
  } else {
    hotplug_mask = 3840U;
  }
  ret = 1;
  if ((unsigned long )(dev->primary)->master != (unsigned long )((struct drm_master *)0)) {
    master_priv = (struct drm_i915_master_private *)((dev->primary)->master)->driver_priv;
    if ((unsigned long )master_priv->sarea_priv != (unsigned long )((struct _drm_i915_sarea *)0)) {
      {
      tmp = intel_read_status_page((struct intel_ring_buffer *)(& dev_priv->ring),
                                   33);
      (master_priv->sarea_priv)->last_dispatch = (int )tmp;
      }
    } else {
    }
  } else {
  }
  if ((gt_iir & 17U) != 0U) {
    {
    notify_ring(dev, (struct intel_ring_buffer *)(& dev_priv->ring));
    }
  } else {
  }
  if ((gt_iir & bsd_usr_interrupt) != 0U) {
    {
    notify_ring(dev, (struct intel_ring_buffer *)(& dev_priv->ring) + 1UL);
    }
  } else {
  }
  if ((gt_iir & 4194304U) != 0U) {
    {
    notify_ring(dev, (struct intel_ring_buffer *)(& dev_priv->ring) + 2UL);
    }
  } else {
  }
  if ((de_iir & 262144U) != 0U) {
    {
    intel_opregion_gse_intr(dev);
    }
  } else {
  }
  if ((de_iir & 67108864U) != 0U) {
    {
    intel_prepare_page_flip(dev, 0);
    intel_finish_page_flip_plane(dev, 0);
    }
  } else {
  }
  if ((de_iir & 134217728U) != 0U) {
    {
    intel_prepare_page_flip(dev, 1);
    intel_finish_page_flip_plane(dev, 1);
    }
  } else {
  }
  if ((de_iir & 128U) != 0U) {
    {
    drm_handle_vblank(dev, 0);
    }
  } else {
  }
  if ((de_iir & 32768U) != 0U) {
    {
    drm_handle_vblank(dev, 1);
    }
  } else {
  }
  if ((de_iir & 2097152U) != 0U) {
    if ((pch_iir & hotplug_mask) != 0U) {
      {
      queue_work(dev_priv->wq, & dev_priv->hotplug_work);
      }
    } else {
    }
    {
    pch_irq_handler(dev);
    }
  } else {
  }
  if ((de_iir & 33554432U) != 0U) {
    {
    tmp___0 = i915_read32(dev_priv, 70020U);
    i915_write16(dev_priv, 70020U, (u16 )((int )((u16 )tmp___0)));
    i915_handle_rps_change(dev);
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    if ((pm_iir & 112U) != 0U) {
      {
      tmp___1 = spinlock_check(& dev_priv->rps_lock);
      flags = _raw_spin_lock_irqsave(tmp___1);
      __ret_warn_on = (dev_priv->pm_iir & pm_iir) != 0U;
      tmp___2 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
      }
      if (tmp___2 != 0L) {
        {
        warn_slowpath_fmt("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_irq.c.p",
                          (int const )653, "Missed a PM interrupt\n");
        }
      } else {
      }
      {
      __builtin_expect((long )(__ret_warn_on != 0), 0L);
      i915_write32(dev_priv, 278564U, pm_iir);
      dev_priv->pm_iir = dev_priv->pm_iir | pm_iir;
      spin_unlock_irqrestore(& dev_priv->rps_lock, flags);
      queue_work(dev_priv->wq, & dev_priv->rps_work);
      }
    } else {
    }
  } else {
  }
  {
  i915_write32(dev_priv, 802824U, pch_iir);
  i915_write32(dev_priv, 278552U, gt_iir);
  i915_write32(dev_priv, 278536U, de_iir);
  i915_write32(dev_priv, 278568U, pm_iir);
  }
  done:
  {
  i915_write32(dev_priv, 278540U, de_ier);
  readl((void const volatile *)dev_priv->regs + 278540U);
  }
  return ((irqreturn_t )ret);
}
}
static void i915_error_work_func(struct work_struct *work )
{ drm_i915_private_t *dev_priv ;
  struct work_struct const *__mptr ;
  struct drm_device *dev ;
  char *error_event[2U] ;
  char *reset_event[2U] ;
  char *reset_done_event[2U] ;
  int tmp ;
  int tmp___0 ;
  {
  {
  __mptr = (struct work_struct const *)work;
  dev_priv = (drm_i915_private_t *)__mptr + 0x0ffffffffffff530UL;
  dev = dev_priv->dev;
  error_event[0] = (char *)"ERROR=1";
  error_event[1] = (char *)0;
  reset_event[0] = (char *)"RESET=1";
  reset_event[1] = (char *)0;
  reset_done_event[0] = (char *)"ERROR=0";
  reset_done_event[1] = (char *)0;
  kobject_uevent_env(& (dev->primary)->kdev.kobj, (enum kobject_action )2, (char **)(& error_event));
  tmp___0 = atomic_read((atomic_t const *)(& dev_priv->mm.wedged));
  }
  if (tmp___0 != 0) {
    {
    drm_ut_debug_printk(2U, "drm", "i915_error_work_func", "resetting chip\n");
    kobject_uevent_env(& (dev->primary)->kdev.kobj, (enum kobject_action )2, (char **)(& reset_event));
    tmp = i915_reset(dev, (u8 )4);
    }
    if (tmp == 0) {
      {
      atomic_set(& dev_priv->mm.wedged, 0);
      kobject_uevent_env(& (dev->primary)->kdev.kobj, (enum kobject_action )2, (char **)(& reset_done_event));
      }
    } else {
    }
    {
    complete_all(& dev_priv->error_completion);
    }
  } else {
  }
  return;
}
}
static struct drm_i915_error_object *i915_error_object_create(struct drm_i915_private *dev_priv ,
                                                              struct drm_i915_gem_object *src )
{ struct drm_i915_error_object *dst ;
  int page ;
  int page_count___0 ;
  u32 reloc_offset ;
  void *tmp ;
  unsigned long flags ;
  void *s ;
  void *d ;
  int tmp___0 ;
  int tmp___1 ;
  {
  if ((unsigned long )src == (unsigned long )((struct drm_i915_gem_object *)0)) {
    return ((struct drm_i915_error_object *)0);
  } else
  if ((unsigned long )src->pages == (unsigned long )((struct page **)0)) {
    return ((struct drm_i915_error_object *)0);
  } else {
  }
  {
  page_count___0 = (int )(src->base.size / 4096UL);
  tmp = kmalloc(((unsigned long )page_count___0 + 1UL) * 8UL, 32U);
  dst = (struct drm_i915_error_object *)tmp;
  }
  if ((unsigned long )dst == (unsigned long )((struct drm_i915_error_object *)0)) {
    return ((struct drm_i915_error_object *)0);
  } else {
  }
  reloc_offset = src->gtt_offset;
  page = 0;
  goto ldv_37757;
  ldv_37756:
  {
  d = kmalloc(4096UL, 32U);
  }
  if ((unsigned long )d == (unsigned long )((void *)0)) {
    goto unwind;
  } else {
  }
  {
  flags = arch_local_irq_save();
  trace_hardirqs_off();
  s = io_mapping_map_atomic_wc(dev_priv->mm.gtt_mapping, (unsigned long )reloc_offset);
  memcpy_fromio(d, (void const volatile *)s, 4096UL);
  io_mapping_unmap_atomic(s);
  tmp___0 = arch_irqs_disabled_flags(flags);
  }
  if (tmp___0 != 0) {
    {
    arch_local_irq_restore(flags);
    trace_hardirqs_off();
    }
  } else {
    {
    trace_hardirqs_on();
    arch_local_irq_restore(flags);
    }
  }
  dst->pages[page] = (u32 *)d;
  reloc_offset = reloc_offset + 4096U;
  page = page + 1;
  ldv_37757: ;
  if (page < page_count___0) {
    goto ldv_37756;
  } else {
    goto ldv_37758;
  }
  ldv_37758:
  dst->page_count = page_count___0;
  dst->gtt_offset = src->gtt_offset;
  return (dst);
  unwind: ;
  goto ldv_37760;
  ldv_37759:
  {
  kfree((void const *)dst->pages[page]);
  }
  ldv_37760:
  tmp___1 = page;
  page = page - 1;
  if (tmp___1 != 0) {
    goto ldv_37759;
  } else {
    goto ldv_37761;
  }
  ldv_37761:
  {
  kfree((void const *)dst);
  }
  return ((struct drm_i915_error_object *)0);
}
}
static void i915_error_object_free(struct drm_i915_error_object *obj )
{ int page ;
  {
  if ((unsigned long )obj == (unsigned long )((struct drm_i915_error_object *)0)) {
    return;
  } else {
  }
  page = 0;
  goto ldv_37767;
  ldv_37766:
  {
  kfree((void const *)obj->pages[page]);
  page = page + 1;
  }
  ldv_37767: ;
  if (obj->page_count > page) {
    goto ldv_37766;
  } else {
    goto ldv_37768;
  }
  ldv_37768:
  {
  kfree((void const *)obj);
  }
  return;
}
}
static void i915_error_state_free(struct drm_device *dev , struct drm_i915_error_state *error )
{ int i ;
  {
  i = 0;
  goto ldv_37777;
  ldv_37776:
  {
  i915_error_object_free(error->batchbuffer[i]);
  i = i + 1;
  }
  ldv_37777: ;
  if ((unsigned int )i <= 2U) {
    goto ldv_37776;
  } else {
    goto ldv_37778;
  }
  ldv_37778:
  i = 0;
  goto ldv_37782;
  ldv_37781:
  {
  i915_error_object_free(error->ringbuffer[i]);
  i = i + 1;
  }
  ldv_37782: ;
  if ((unsigned int )i <= 2U) {
    goto ldv_37781;
  } else {
    goto ldv_37783;
  }
  ldv_37783:
  {
  kfree((void const *)error->active_bo);
  kfree((void const *)error->overlay);
  kfree((void const *)error);
  }
  return;
}
}
static u32 capture_bo_list(struct drm_i915_error_buffer *err , int count , struct list_head *head )
{ struct drm_i915_gem_object *obj ;
  int i ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  {
  i = 0;
  __mptr = (struct list_head const *)head->next;
  obj = (struct drm_i915_gem_object *)__mptr + 0x0fffffffffffff50UL;
  goto ldv_37797;
  ldv_37796:
  err->size = (u32 )obj->base.size;
  err->name = (u32 )obj->base.name;
  err->seqno = obj->last_rendering_seqno;
  err->gtt_offset = obj->gtt_offset;
  err->read_domains = obj->base.read_domains;
  err->write_domain = obj->base.write_domain;
  err->fence_reg = obj->fence_reg;
  err->pinned = (signed char)0;
  if ((int )obj->pin_count > 0) {
    err->pinned = (signed char)1;
  } else {
  }
  if (obj->user_pin_count != 0U) {
    err->pinned = (signed char)-1;
  } else {
  }
  err->tiling = obj->tiling_mode;
  err->dirty = obj->dirty;
  err->purgeable = (unsigned char )((unsigned int )*((unsigned char *)obj + 225UL) != 0U);
  if ((unsigned long )obj->ring != (unsigned long )((struct intel_ring_buffer *)0)) {
    err->ring = (unsigned char )(obj->ring)->id;
  } else {
    err->ring = (unsigned char)0;
  }
  err->cache_level = obj->cache_level;
  i = i + 1;
  if (i == count) {
    goto ldv_37795;
  } else {
  }
  err = err + 1;
  __mptr___0 = (struct list_head const *)obj->mm_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___0 + 0x0fffffffffffff50UL;
  ldv_37797: ;
  if ((unsigned long )(& obj->mm_list) != (unsigned long )head) {
    goto ldv_37796;
  } else {
    goto ldv_37795;
  }
  ldv_37795: ;
  return ((u32 )i);
}
}
static void i915_gem_record_fences(struct drm_device *dev , struct drm_i915_error_state *error )
{ struct drm_i915_private *dev_priv ;
  int i ;
  u32 tmp ;
  u32 tmp___0 ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 6) {
    goto case_6;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 5) {
    goto case_5;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 4) {
    goto case_4;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 3) {
    goto case_3;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 2) {
    goto case_2;
  } else
  if (0) {
    case_6:
    i = 0;
    goto ldv_37806;
    ldv_37805:
    {
    error->fence[i] = i915_read64(dev_priv, (u32 )((i + 131072) * 8));
    i = i + 1;
    }
    ldv_37806: ;
    if (i <= 15) {
      goto ldv_37805;
    } else {
      goto ldv_37807;
    }
    ldv_37807: ;
    goto ldv_37808;
    case_5: ;
    case_4:
    i = 0;
    goto ldv_37812;
    ldv_37811:
    {
    error->fence[i] = i915_read64(dev_priv, (u32 )((i + 1536) * 8));
    i = i + 1;
    }
    ldv_37812: ;
    if (i <= 15) {
      goto ldv_37811;
    } else {
      goto ldv_37813;
    }
    ldv_37813: ;
    goto ldv_37808;
    case_3: ;
    if (dev->pci_device == 10098) {
      goto _L;
    } else
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
      goto _L;
    } else
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
      _L:
      i = 0;
      goto ldv_37816;
      ldv_37815:
      {
      tmp = i915_read32(dev_priv, (u32 )((i + 3072) * 4));
      error->fence[i + 8] = (u64 )tmp;
      i = i + 1;
      }
      ldv_37816: ;
      if (i <= 7) {
        goto ldv_37815;
      } else {
        goto ldv_37817;
      }
      ldv_37817: ;
    } else {
    }
    case_2:
    i = 0;
    goto ldv_37820;
    ldv_37819:
    {
    tmp___0 = i915_read32(dev_priv, (u32 )((i + 2048) * 4));
    error->fence[i] = (u64 )tmp___0;
    i = i + 1;
    }
    ldv_37820: ;
    if (i <= 7) {
      goto ldv_37819;
    } else {
      goto ldv_37821;
    }
    ldv_37821: ;
    goto ldv_37808;
  } else {
  }
  ldv_37808: ;
  return;
}
}
static struct drm_i915_error_object *i915_error_first_batchbuffer(struct drm_i915_private *dev_priv ,
                                                                  struct intel_ring_buffer *ring )
{ struct drm_i915_gem_object *obj ;
  u32 seqno ;
  struct list_head const *__mptr ;
  bool tmp ;
  struct drm_i915_error_object *tmp___0 ;
  struct list_head const *__mptr___0 ;
  {
  if ((unsigned long )ring->get_seqno == (unsigned long )((u32 (*)(struct intel_ring_buffer * ))0)) {
    return ((struct drm_i915_error_object *)0);
  } else {
  }
  {
  seqno = (*(ring->get_seqno))(ring);
  __mptr = (struct list_head const *)dev_priv->mm.active_list.next;
  obj = (struct drm_i915_gem_object *)__mptr + 0x0fffffffffffff50UL;
  }
  goto ldv_37834;
  ldv_37833: ;
  if ((unsigned long )obj->ring != (unsigned long )ring) {
    goto ldv_37832;
  } else {
  }
  {
  tmp = i915_seqno_passed(seqno, obj->last_rendering_seqno);
  }
  if ((int )tmp) {
    goto ldv_37832;
  } else {
  }
  if ((obj->base.read_domains & 8U) == 0U) {
    goto ldv_37832;
  } else {
  }
  {
  tmp___0 = i915_error_object_create(dev_priv, obj);
  }
  return (tmp___0);
  ldv_37832:
  __mptr___0 = (struct list_head const *)obj->mm_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___0 + 0x0fffffffffffff50UL;
  ldv_37834: ;
  if ((unsigned long )(& obj->mm_list) != (unsigned long )(& dev_priv->mm.active_list)) {
    goto ldv_37833;
  } else {
    goto ldv_37835;
  }
  ldv_37835: ;
  return ((struct drm_i915_error_object *)0);
}
}
static void i915_capture_error_state(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct drm_i915_gem_object *obj ;
  struct drm_i915_error_state *error ;
  unsigned long flags ;
  int i ;
  int pipe ;
  raw_spinlock_t *tmp ;
  void *tmp___0 ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  struct list_head const *__mptr___1 ;
  struct list_head const *__mptr___2 ;
  void *tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = spinlock_check(& dev_priv->error_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  error = dev_priv->first_error;
  spin_unlock_irqrestore(& dev_priv->error_lock, flags);
  }
  if ((unsigned long )error != (unsigned long )((struct drm_i915_error_state *)0)) {
    return;
  } else {
  }
  {
  tmp___0 = kmalloc(336UL, 32U);
  error = (struct drm_i915_error_state *)tmp___0;
  }
  if ((unsigned long )error == (unsigned long )((struct drm_i915_error_state *)0)) {
    {
    drm_ut_debug_printk(2U, "drm", "i915_capture_error_state", "out of memory, not capturing error state\n");
    }
    return;
  } else {
  }
  {
  printk("<6>[drm] capturing error event; look for more information in /debug/dri/%d/i915_error_state\n",
         (dev->primary)->index);
  error->seqno = (*(dev_priv->ring[0].get_seqno))((struct intel_ring_buffer *)(& dev_priv->ring));
  error->eir = i915_read32(dev_priv, 8368U);
  error->pgtbl_er = i915_read32(dev_priv, 8228U);
  pipe = 0;
  }
  goto ldv_37850;
  ldv_37849:
  {
  error->pipestat[pipe] = i915_read32(dev_priv, (u32 )(pipe * 4096 + 458788));
  pipe = pipe + 1;
  }
  ldv_37850: ;
  if (dev_priv->num_pipe > pipe) {
    goto ldv_37849;
  } else {
    goto ldv_37851;
  }
  ldv_37851:
  {
  error->instpm = i915_read32(dev_priv, 8384U);
  error->error = 0U;
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 5U) {
    {
    error->error = i915_read32(dev_priv, 16544U);
    error->bcs_acthd = i915_read32(dev_priv, 139380U);
    error->bcs_ipehr = i915_read32(dev_priv, 139368U);
    error->bcs_ipeir = i915_read32(dev_priv, 139364U);
    error->bcs_instdone = i915_read32(dev_priv, 139372U);
    error->bcs_seqno = 0U;
    }
    if ((unsigned long )dev_priv->ring[2].get_seqno != (unsigned long )((u32 (*)(struct intel_ring_buffer * ))0)) {
      {
      error->bcs_seqno = (*(dev_priv->ring[2].get_seqno))((struct intel_ring_buffer *)(& dev_priv->ring) + 2UL);
      }
    } else {
    }
    {
    error->vcs_acthd = i915_read32(dev_priv, 73844U);
    error->vcs_ipehr = i915_read32(dev_priv, 73832U);
    error->vcs_ipeir = i915_read32(dev_priv, 73828U);
    error->vcs_instdone = i915_read32(dev_priv, 73836U);
    error->vcs_seqno = 0U;
    }
    if ((unsigned long )dev_priv->ring[1].get_seqno != (unsigned long )((u32 (*)(struct intel_ring_buffer * ))0)) {
      {
      error->vcs_seqno = (*(dev_priv->ring[1].get_seqno))((struct intel_ring_buffer *)(& dev_priv->ring) + 1UL);
      }
    } else {
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    {
    error->ipeir = i915_read32(dev_priv, 8292U);
    error->ipehr = i915_read32(dev_priv, 8296U);
    error->instdone = i915_read32(dev_priv, 8300U);
    error->instps = i915_read32(dev_priv, 8304U);
    error->instdone1 = i915_read32(dev_priv, 8316U);
    error->acthd = i915_read32(dev_priv, 8308U);
    error->bbaddr = i915_read64(dev_priv, 8512U);
    }
  } else {
    {
    error->ipeir = i915_read32(dev_priv, 8328U);
    error->ipehr = i915_read32(dev_priv, 8332U);
    error->instdone = i915_read32(dev_priv, 8336U);
    error->acthd = i915_read32(dev_priv, 8392U);
    error->bbaddr = 0ULL;
    }
  }
  {
  i915_gem_record_fences(dev, error);
  i = 0;
  }
  goto ldv_37853;
  ldv_37852:
  {
  error->batchbuffer[i] = i915_error_first_batchbuffer(dev_priv, (struct intel_ring_buffer *)(& dev_priv->ring) + (unsigned long )i);
  error->ringbuffer[i] = i915_error_object_create(dev_priv, dev_priv->ring[i].obj);
  i = i + 1;
  }
  ldv_37853: ;
  if (i <= 2) {
    goto ldv_37852;
  } else {
    goto ldv_37854;
  }
  ldv_37854:
  error->active_bo = (struct drm_i915_error_buffer *)0;
  error->pinned_bo = (struct drm_i915_error_buffer *)0;
  i = 0;
  __mptr = (struct list_head const *)dev_priv->mm.active_list.next;
  obj = (struct drm_i915_gem_object *)__mptr + 0x0fffffffffffff50UL;
  goto ldv_37860;
  ldv_37859:
  i = i + 1;
  __mptr___0 = (struct list_head const *)obj->mm_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___0 + 0x0fffffffffffff50UL;
  ldv_37860: ;
  if ((unsigned long )(& obj->mm_list) != (unsigned long )(& dev_priv->mm.active_list)) {
    goto ldv_37859;
  } else {
    goto ldv_37861;
  }
  ldv_37861:
  error->active_bo_count = (u32 )i;
  __mptr___1 = (struct list_head const *)dev_priv->mm.pinned_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___1 + 0x0fffffffffffff50UL;
  goto ldv_37867;
  ldv_37866:
  i = i + 1;
  __mptr___2 = (struct list_head const *)obj->mm_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___2 + 0x0fffffffffffff50UL;
  ldv_37867: ;
  if ((unsigned long )(& obj->mm_list) != (unsigned long )(& dev_priv->mm.pinned_list)) {
    goto ldv_37866;
  } else {
    goto ldv_37868;
  }
  ldv_37868:
  error->pinned_bo_count = (u32 )i - error->active_bo_count;
  error->active_bo = (struct drm_i915_error_buffer *)0;
  error->pinned_bo = (struct drm_i915_error_buffer *)0;
  if (i != 0) {
    {
    tmp___1 = kmalloc((unsigned long )i * 28UL, 32U);
    error->active_bo = (struct drm_i915_error_buffer *)tmp___1;
    }
    if ((unsigned long )error->active_bo != (unsigned long )((struct drm_i915_error_buffer *)0)) {
      error->pinned_bo = error->active_bo + (unsigned long )error->active_bo_count;
    } else {
    }
  } else {
  }
  if ((unsigned long )error->active_bo != (unsigned long )((struct drm_i915_error_buffer *)0)) {
    {
    error->active_bo_count = capture_bo_list(error->active_bo, (int )error->active_bo_count,
                                             & dev_priv->mm.active_list);
    }
  } else {
  }
  if ((unsigned long )error->pinned_bo != (unsigned long )((struct drm_i915_error_buffer *)0)) {
    {
    error->pinned_bo_count = capture_bo_list(error->pinned_bo, (int )error->pinned_bo_count,
                                             & dev_priv->mm.pinned_list);
    }
  } else {
  }
  {
  do_gettimeofday(& error->time);
  error->overlay = intel_overlay_capture_error_state(dev);
  error->display = intel_display_capture_error_state(dev);
  tmp___2 = spinlock_check(& dev_priv->error_lock);
  flags = _raw_spin_lock_irqsave(tmp___2);
  }
  if ((unsigned long )dev_priv->first_error == (unsigned long )((struct drm_i915_error_state *)0)) {
    dev_priv->first_error = error;
    error = (struct drm_i915_error_state *)0;
  } else {
  }
  {
  spin_unlock_irqrestore(& dev_priv->error_lock, flags);
  }
  if ((unsigned long )error != (unsigned long )((struct drm_i915_error_state *)0)) {
    {
    i915_error_state_free(dev, error);
    }
  } else {
  }
  return;
}
}
void i915_destroy_error_state(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct drm_i915_error_state *error ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  spin_lock(& dev_priv->error_lock);
  error = dev_priv->first_error;
  dev_priv->first_error = (struct drm_i915_error_state *)0;
  spin_unlock(& dev_priv->error_lock);
  }
  if ((unsigned long )error != (unsigned long )((struct drm_i915_error_state *)0)) {
    {
    i915_error_state_free(dev, error);
    }
  } else {
  }
  return;
}
}
static void i915_report_and_clear_eir(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 eir ;
  u32 tmp ;
  int pipe ;
  u32 ipeir ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 pgtbl_err ;
  u32 tmp___7 ;
  u32 pgtbl_err___0 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 ipeir___0 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;
  u32 ipeir___1 ;
  u32 tmp___16 ;
  u32 tmp___17 ;
  u32 tmp___18 ;
  u32 tmp___19 ;
  u32 tmp___20 ;
  u32 tmp___21 ;
  u32 tmp___22 ;
  u32 tmp___23 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = i915_read32(dev_priv, 8368U);
  eir = tmp;
  }
  if (eir == 0U) {
    return;
  } else {
  }
  {
  printk("<3>render error detected, EIR: 0x%08x\n", eir);
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    if ((eir & 24U) != 0U) {
      {
      tmp___0 = i915_read32(dev_priv, 8292U);
      ipeir = tmp___0;
      tmp___1 = i915_read32(dev_priv, 8292U);
      printk("<3>  IPEIR: 0x%08x\n", tmp___1);
      tmp___2 = i915_read32(dev_priv, 8296U);
      printk("<3>  IPEHR: 0x%08x\n", tmp___2);
      tmp___3 = i915_read32(dev_priv, 8300U);
      printk("<3>  INSTDONE: 0x%08x\n", tmp___3);
      tmp___4 = i915_read32(dev_priv, 8304U);
      printk("<3>  INSTPS: 0x%08x\n", tmp___4);
      tmp___5 = i915_read32(dev_priv, 8316U);
      printk("<3>  INSTDONE1: 0x%08x\n", tmp___5);
      tmp___6 = i915_read32(dev_priv, 8308U);
      printk("<3>  ACTHD: 0x%08x\n", tmp___6);
      i915_write32(dev_priv, 8292U, ipeir);
      readl((void const volatile *)dev_priv->regs + 8292U);
      }
    } else {
    }
    if ((eir & 32U) != 0U) {
      {
      tmp___7 = i915_read32(dev_priv, 8228U);
      pgtbl_err = tmp___7;
      printk("<3>page table error\n");
      printk("<3>  PGTBL_ER: 0x%08x\n", pgtbl_err);
      i915_write32(dev_priv, 8228U, pgtbl_err);
      readl((void const volatile *)dev_priv->regs + 8228U);
      }
    } else {
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 2U) {
    if ((eir & 16U) != 0U) {
      {
      tmp___8 = i915_read32(dev_priv, 8228U);
      pgtbl_err___0 = tmp___8;
      printk("<3>page table error\n");
      printk("<3>  PGTBL_ER: 0x%08x\n", pgtbl_err___0);
      i915_write32(dev_priv, 8228U, pgtbl_err___0);
      readl((void const volatile *)dev_priv->regs + 8228U);
      }
    } else {
    }
  } else {
  }
  if ((eir & 2U) != 0U) {
    {
    printk("<3>memory refresh error:\n");
    pipe = 0;
    }
    goto ldv_37887;
    ldv_37886:
    {
    tmp___9 = i915_read32(dev_priv, (u32 )(pipe * 4096 + 458788));
    printk("<3>pipe %c stat: 0x%08x\n", pipe + 65, tmp___9);
    pipe = pipe + 1;
    }
    ldv_37887: ;
    if (dev_priv->num_pipe > pipe) {
      goto ldv_37886;
    } else {
      goto ldv_37888;
    }
    ldv_37888: ;
  } else {
  }
  if ((int )eir & 1) {
    {
    printk("<3>instruction error\n");
    tmp___10 = i915_read32(dev_priv, 8384U);
    printk("<3>  INSTPM: 0x%08x\n", tmp___10);
    }
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) <= 3U) {
      {
      tmp___11 = i915_read32(dev_priv, 8328U);
      ipeir___0 = tmp___11;
      tmp___12 = i915_read32(dev_priv, 8328U);
      printk("<3>  IPEIR: 0x%08x\n", tmp___12);
      tmp___13 = i915_read32(dev_priv, 8332U);
      printk("<3>  IPEHR: 0x%08x\n", tmp___13);
      tmp___14 = i915_read32(dev_priv, 8336U);
      printk("<3>  INSTDONE: 0x%08x\n", tmp___14);
      tmp___15 = i915_read32(dev_priv, 8392U);
      printk("<3>  ACTHD: 0x%08x\n", tmp___15);
      i915_write32(dev_priv, 8328U, ipeir___0);
      readl((void const volatile *)dev_priv->regs + 8328U);
      }
    } else {
      {
      tmp___16 = i915_read32(dev_priv, 8292U);
      ipeir___1 = tmp___16;
      tmp___17 = i915_read32(dev_priv, 8292U);
      printk("<3>  IPEIR: 0x%08x\n", tmp___17);
      tmp___18 = i915_read32(dev_priv, 8296U);
      printk("<3>  IPEHR: 0x%08x\n", tmp___18);
      tmp___19 = i915_read32(dev_priv, 8300U);
      printk("<3>  INSTDONE: 0x%08x\n", tmp___19);
      tmp___20 = i915_read32(dev_priv, 8304U);
      printk("<3>  INSTPS: 0x%08x\n", tmp___20);
      tmp___21 = i915_read32(dev_priv, 8316U);
      printk("<3>  INSTDONE1: 0x%08x\n", tmp___21);
      tmp___22 = i915_read32(dev_priv, 8308U);
      printk("<3>  ACTHD: 0x%08x\n", tmp___22);
      i915_write32(dev_priv, 8292U, ipeir___1);
      readl((void const volatile *)dev_priv->regs + 8292U);
      }
    }
  } else {
  }
  {
  i915_write32(dev_priv, 8368U, eir);
  readl((void const volatile *)dev_priv->regs + 8368U);
  eir = i915_read32(dev_priv, 8368U);
  }
  if (eir != 0U) {
    {
    drm_err("i915_report_and_clear_eir", "EIR stuck: 0x%08x, masking\n", eir);
    tmp___23 = i915_read32(dev_priv, 8372U);
    i915_write32(dev_priv, 8372U, tmp___23 | eir);
    i915_write32(dev_priv, 8356U, 32768U);
    }
  } else {
  }
  return;
}
}
void i915_handle_error(struct drm_device *dev , bool wedged )
{ struct drm_i915_private *dev_priv ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  i915_capture_error_state(dev);
  i915_report_and_clear_eir(dev);
  }
  if ((int )wedged) {
    {
    dev_priv->error_completion.done = 0U;
    atomic_set(& dev_priv->mm.wedged, 1);
    __wake_up(& dev_priv->ring[0].irq_queue, 3U, 0, (void *)0);
    }
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 3UL) != 0U) {
      {
      __wake_up(& dev_priv->ring[1].irq_queue, 3U, 0, (void *)0);
      }
    } else {
    }
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 3UL) != 0U) {
      {
      __wake_up(& dev_priv->ring[2].irq_queue, 3U, 0, (void *)0);
      }
    } else {
    }
  } else {
  }
  {
  queue_work(dev_priv->wq, & dev_priv->error_work);
  }
  return;
}
}
static void i915_pageflip_stall_check(struct drm_device *dev , int pipe )
{ drm_i915_private_t *dev_priv ;
  struct drm_crtc *crtc ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  struct drm_i915_gem_object *obj ;
  struct intel_unpin_work *work ;
  unsigned long flags ;
  bool stall_detected ;
  raw_spinlock_t *tmp ;
  int dspsurf ;
  u32 tmp___0 ;
  int dspaddr ;
  u32 tmp___1 ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  crtc = dev_priv->pipe_to_crtc_mapping[pipe];
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  if ((unsigned long )intel_crtc == (unsigned long )((struct intel_crtc *)0)) {
    return;
  } else {
  }
  {
  tmp = spinlock_check(& dev->event_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  work = intel_crtc->unpin_work;
  }
  if ((unsigned long )work == (unsigned long )((struct intel_unpin_work *)0)) {
    {
    spin_unlock_irqrestore(& dev->event_lock, flags);
    }
    return;
  } else
  if (work->pending != 0) {
    {
    spin_unlock_irqrestore(& dev->event_lock, flags);
    }
    return;
  } else
  if (! work->enable_stall_check) {
    {
    spin_unlock_irqrestore(& dev->event_lock, flags);
    }
    return;
  } else {
  }
  obj = work->pending_flip_obj;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    {
    dspsurf = (int )((unsigned int )intel_crtc->plane * 4096U + 459164U);
    tmp___0 = i915_read32(dev_priv, (u32 )dspsurf);
    stall_detected = (bool )(tmp___0 == obj->gtt_offset);
    }
  } else {
    {
    dspaddr = (int )((unsigned int )intel_crtc->plane * 4096U + 459140U);
    tmp___1 = i915_read32(dev_priv, (u32 )dspaddr);
    stall_detected = (bool )(tmp___1 == (obj->gtt_offset + (unsigned int )crtc->y * (crtc->fb)->pitch) + (uint32_t )((crtc->x * (crtc->fb)->bits_per_pixel) / 8));
    }
  }
  {
  spin_unlock_irqrestore(& dev->event_lock, flags);
  }
  if ((int )stall_detected) {
    {
    drm_ut_debug_printk(2U, "drm", "i915_pageflip_stall_check", "Pageflip stall detected\n");
    intel_prepare_page_flip(dev, (int )intel_crtc->plane);
    }
  } else {
  }
  return;
}
}
static irqreturn_t i915_driver_irq_handler(int irq , void *arg )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  struct drm_i915_master_private *master_priv ;
  u32 iir ;
  u32 new_iir ;
  u32 pipe_stats[3U] ;
  u32 vblank_status ;
  int vblank ;
  unsigned long irqflags ;
  int irq_received ;
  int ret ;
  int pipe ;
  bool blc_event ;
  raw_spinlock_t *tmp ;
  int reg ;
  u32 hotplug_status ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  bool tmp___2 ;
  {
  {
  dev = (struct drm_device *)arg;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  vblank = 0;
  ret = 0;
  blc_event = (bool )0;
  atomic_inc(& dev_priv->irq_received);
  iir = i915_read32(dev_priv, 8356U);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    vblank_status = 4U;
  } else {
    vblank_status = 2U;
  }
  ldv_37946:
  {
  irq_received = iir != 0U;
  tmp = spinlock_check(& dev_priv->irq_lock);
  irqflags = _raw_spin_lock_irqsave(tmp);
  }
  if ((iir & 32768U) != 0U) {
    {
    i915_handle_error(dev, (bool )0);
    }
  } else {
  }
  pipe = 0;
  goto ldv_37939;
  ldv_37938:
  {
  reg = pipe * 4096 + 458788;
  pipe_stats[pipe] = i915_read32(dev_priv, (u32 )reg);
  }
  if ((pipe_stats[pipe] & 2147549183U) != 0U) {
    if ((int )pipe_stats[pipe] < 0) {
      {
      drm_ut_debug_printk(2U, "drm", "i915_driver_irq_handler", "pipe %c underrun\n",
                          pipe + 65);
      }
    } else {
    }
    {
    i915_write32(dev_priv, (u32 )reg, pipe_stats[pipe]);
    irq_received = 1;
    }
  } else {
  }
  pipe = pipe + 1;
  ldv_37939: ;
  if (dev_priv->num_pipe > pipe) {
    goto ldv_37938;
  } else {
    goto ldv_37940;
  }
  ldv_37940:
  {
  spin_unlock_irqrestore(& dev_priv->irq_lock, irqflags);
  }
  if (irq_received == 0) {
    goto ldv_37941;
  } else {
  }
  ret = 1;
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    if ((iir & 131072U) != 0U) {
      {
      tmp___0 = i915_read32(dev_priv, 397588U);
      hotplug_status = tmp___0;
      drm_ut_debug_printk(2U, "drm", "i915_driver_irq_handler", "hotplug event received, stat 0x%08x\n",
                          hotplug_status);
      }
      if ((dev_priv->hotplug_supported_mask & hotplug_status) != 0U) {
        {
        queue_work(dev_priv->wq, & dev_priv->hotplug_work);
        }
      } else {
      }
      {
      i915_write32(dev_priv, 397588U, hotplug_status);
      i915_read32(dev_priv, 397588U);
      }
    } else {
    }
  } else {
  }
  {
  i915_write32(dev_priv, 8356U, iir);
  new_iir = i915_read32(dev_priv, 8356U);
  }
  if ((unsigned long )(dev->primary)->master != (unsigned long )((struct drm_master *)0)) {
    master_priv = (struct drm_i915_master_private *)((dev->primary)->master)->driver_priv;
    if ((unsigned long )master_priv->sarea_priv != (unsigned long )((struct _drm_i915_sarea *)0)) {
      {
      tmp___1 = intel_read_status_page((struct intel_ring_buffer *)(& dev_priv->ring),
                                       33);
      (master_priv->sarea_priv)->last_dispatch = (int )tmp___1;
      }
    } else {
    }
  } else {
  }
  if ((iir & 2U) != 0U) {
    {
    notify_ring(dev, (struct intel_ring_buffer *)(& dev_priv->ring));
    }
  } else {
  }
  if ((iir & 33554432U) != 0U) {
    {
    notify_ring(dev, (struct intel_ring_buffer *)(& dev_priv->ring) + 1UL);
    }
  } else {
  }
  if ((iir & 2048U) != 0U) {
    {
    intel_prepare_page_flip(dev, 0);
    }
    if ((int )dev_priv->flip_pending_is_done) {
      {
      intel_finish_page_flip_plane(dev, 0);
      }
    } else {
    }
  } else {
  }
  if ((iir & 1024U) != 0U) {
    {
    intel_prepare_page_flip(dev, 1);
    }
    if ((int )dev_priv->flip_pending_is_done) {
      {
      intel_finish_page_flip_plane(dev, 1);
      }
    } else {
    }
  } else {
  }
  pipe = 0;
  goto ldv_37944;
  ldv_37943: ;
  if ((pipe_stats[pipe] & vblank_status) != 0U) {
    {
    tmp___2 = drm_handle_vblank(dev, pipe);
    }
    if ((int )tmp___2) {
      vblank = vblank + 1;
      if (! dev_priv->flip_pending_is_done) {
        {
        i915_pageflip_stall_check(dev, pipe);
        intel_finish_page_flip(dev, pipe);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  if (((unsigned long )pipe_stats[pipe] & 64UL) != 0UL) {
    blc_event = (bool )1;
  } else {
  }
  pipe = pipe + 1;
  ldv_37944: ;
  if (dev_priv->num_pipe > pipe) {
    goto ldv_37943;
  } else {
    goto ldv_37945;
  }
  ldv_37945: ;
  if ((int )blc_event) {
    {
    intel_opregion_asle_intr(dev);
    }
  } else
  if ((int )iir & 1) {
    {
    intel_opregion_asle_intr(dev);
    }
  } else {
  }
  iir = new_iir;
  goto ldv_37946;
  ldv_37941: ;
  return ((irqreturn_t )ret);
}
}
static int i915_emit_irq(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  struct drm_i915_master_private *master_priv ;
  int tmp ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  master_priv = (struct drm_i915_master_private *)((dev->primary)->master)->driver_priv;
  i915_kernel_lost_context(dev);
  drm_ut_debug_printk(2U, "drm", "i915_emit_irq", "\n");
  dev_priv->counter = dev_priv->counter + 1U;
  }
  if ((int )dev_priv->counter < 0) {
    dev_priv->counter = 1U;
  } else {
  }
  if ((unsigned long )master_priv->sarea_priv != (unsigned long )((struct _drm_i915_sarea *)0)) {
    (master_priv->sarea_priv)->last_enqueue = (int )dev_priv->counter;
  } else {
  }
  {
  tmp = intel_ring_begin((struct intel_ring_buffer *)(& dev_priv->ring), 4);
  }
  if (tmp == 0) {
    {
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 276824065U);
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 132U);
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), dev_priv->counter);
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 16777216U);
    intel_ring_advance((struct intel_ring_buffer *)(& dev_priv->ring));
    }
  } else {
  }
  return ((int )dev_priv->counter);
}
}
static int i915_wait_irq(struct drm_device *dev , int irq_nr )
{ drm_i915_private_t *dev_priv ;
  struct drm_i915_master_private *master_priv ;
  int ret ;
  struct intel_ring_buffer *ring ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  wait_queue_t entry ;
  struct task_struct *tmp___2 ;
  unsigned long end ;
  struct task_struct *tmp___3 ;
  u32 tmp___4 ;
  struct task_struct *tmp___5 ;
  int tmp___6 ;
  struct task_struct *tmp___7 ;
  unsigned long timeout__ ;
  unsigned long tmp___8 ;
  int ret__ ;
  struct thread_info *tmp___9 ;
  int pfo_ret__ ;
  int tmp___10 ;
  u32 tmp___11 ;
  bool tmp___12 ;
  u32 tmp___13 ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  master_priv = (struct drm_i915_master_private *)((dev->primary)->master)->driver_priv;
  ret = 0;
  ring = (struct intel_ring_buffer *)(& dev_priv->ring);
  tmp = intel_read_status_page((struct intel_ring_buffer *)(& dev_priv->ring), 33);
  drm_ut_debug_printk(2U, "drm", "i915_wait_irq", "irq_nr=%d breadcrumb=%d\n", irq_nr,
                      tmp);
  tmp___1 = intel_read_status_page((struct intel_ring_buffer *)(& dev_priv->ring),
                                   33);
  }
  if (tmp___1 >= (u32 )irq_nr) {
    if ((unsigned long )master_priv->sarea_priv != (unsigned long )((struct _drm_i915_sarea *)0)) {
      {
      tmp___0 = intel_read_status_page((struct intel_ring_buffer *)(& dev_priv->ring),
                                       33);
      (master_priv->sarea_priv)->last_dispatch = (int )tmp___0;
      }
    } else {
    }
    return (0);
  } else {
  }
  if ((unsigned long )master_priv->sarea_priv != (unsigned long )((struct _drm_i915_sarea *)0)) {
    (master_priv->sarea_priv)->perf_boxes = (master_priv->sarea_priv)->perf_boxes | 4;
  } else {
  }
  {
  tmp___12 = (*(ring->irq_get))(ring);
  }
  if ((int )tmp___12) {
    {
    tmp___2 = get_current();
    entry.flags = 0U;
    entry.private = (void *)tmp___2;
    entry.func = & default_wake_function;
    entry.task_list.next = (struct list_head *)0;
    entry.task_list.prev = (struct list_head *)0;
    end = (unsigned long )jiffies + 750UL;
    add_wait_queue(& ring->irq_queue, & entry);
    }
    ldv_37971:
    {
    tmp___3 = get_current();
    tmp___3->state = (long volatile )1L;
    tmp___4 = intel_read_status_page((struct intel_ring_buffer *)(& dev_priv->ring),
                                     33);
    }
    if (tmp___4 >= (u32 )irq_nr) {
      goto ldv_37964;
    } else {
    }
    if ((long )jiffies - (long )end >= 0L) {
      ret = -16;
      goto ldv_37964;
    } else {
    }
    {
    schedule_timeout(2L);
    tmp___5 = get_current();
    tmp___6 = signal_pending(tmp___5);
    }
    if (tmp___6 != 0) {
      ret = -4;
      goto ldv_37964;
    } else {
    }
    goto ldv_37971;
    ldv_37964:
    {
    tmp___7 = get_current();
    tmp___7->state = (long volatile )0L;
    remove_wait_queue(& ring->irq_queue, & entry);
    (*(ring->irq_put))(ring);
    }
  } else {
    {
    tmp___8 = msecs_to_jiffies((unsigned int const )3000U);
    timeout__ = tmp___8 + (unsigned long )jiffies;
    ret__ = 0;
    }
    goto ldv_37990;
    ldv_37989: ;
    if ((long )timeout__ - (long )jiffies < 0L) {
      ret__ = -110;
      goto ldv_37980;
    } else {
    }
    {
    tmp___9 = current_thread_info();
    }
    if ((tmp___9->preempt_count & -268435457) == 0) {
      if (1) {
        goto case_4;
      } else {
        goto switch_default;
        if (0) {
          __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
          goto ldv_37983;
          __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
          goto ldv_37983;
          case_4:
          __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
          goto ldv_37983;
          __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
          goto ldv_37983;
          switch_default:
          {
          __bad_percpu_size();
          }
        } else {
        }
      }
      ldv_37983:
      {
      tmp___10 = atomic_read((atomic_t const *)(& kgdb_active));
      }
      if (pfo_ret__ != tmp___10) {
        {
        msleep(1U);
        }
      } else {
      }
    } else {
    }
    ldv_37990:
    {
    tmp___11 = intel_read_status_page((struct intel_ring_buffer *)(& dev_priv->ring),
                                      33);
    }
    if (tmp___11 < (u32 )irq_nr) {
      goto ldv_37989;
    } else {
      goto ldv_37980;
    }
    ldv_37980: ;
    if (ret__ != 0) {
      ret = -16;
    } else {
    }
  }
  if (ret == -16) {
    {
    tmp___13 = intel_read_status_page((struct intel_ring_buffer *)(& dev_priv->ring),
                                      33);
    drm_err("i915_wait_irq", "EBUSY -- rec: %d emitted: %d\n", tmp___13, (int )dev_priv->counter);
    }
  } else {
  }
  return (ret);
}
}
int i915_irq_emit(struct drm_device *dev , void *data , struct drm_file *file_priv )
{ drm_i915_private_t *dev_priv ;
  drm_i915_irq_emit_t *emit ;
  int result ;
  int tmp ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  emit = (drm_i915_irq_emit_t *)data;
  if ((unsigned long )dev_priv == (unsigned long )((drm_i915_private_t *)0)) {
    {
    drm_err("i915_irq_emit", "called with no initialization\n");
    }
    return (-22);
  } else
  if ((unsigned long )((struct intel_ring_buffer *)(& dev_priv->ring))->virtual_start == (unsigned long )((void *)0)) {
    {
    drm_err("i915_irq_emit", "called with no initialization\n");
    }
    return (-22);
  } else {
  }
  if ((unsigned long )((struct intel_ring_buffer *)(& ((struct drm_i915_private *)dev->dev_private)->ring))->obj == (unsigned long )((struct drm_i915_gem_object *)0)) {
    if ((int )((file_priv->master)->lock.hw_lock)->lock >= 0) {
      {
      drm_err("i915_irq_emit", "%s called without lock held, held  %d owner %p %p\n",
              "i915_irq_emit", (unsigned int )((file_priv->master)->lock.hw_lock)->lock & 2147483648U,
              (file_priv->master)->lock.file_priv, file_priv);
      }
      return (-22);
    } else
    if ((unsigned long )(file_priv->master)->lock.file_priv != (unsigned long )file_priv) {
      {
      drm_err("i915_irq_emit", "%s called without lock held, held  %d owner %p %p\n",
              "i915_irq_emit", (unsigned int )((file_priv->master)->lock.hw_lock)->lock & 2147483648U,
              (file_priv->master)->lock.file_priv, file_priv);
      }
      return (-22);
    } else {
    }
  } else {
  }
  {
  mutex_lock_nested(& dev->struct_mutex, 0U);
  result = i915_emit_irq(dev);
  mutex_unlock(& dev->struct_mutex);
  tmp = copy_to_user((void *)emit->irq_seq, (void const *)(& result), 4U);
  }
  if (tmp != 0) {
    {
    drm_err("i915_irq_emit", "copy_to_user\n");
    }
    return (-14);
  } else {
  }
  return (0);
}
}
int i915_irq_wait(struct drm_device *dev , void *data , struct drm_file *file_priv )
{ drm_i915_private_t *dev_priv ;
  drm_i915_irq_wait_t *irqwait ;
  int tmp ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  irqwait = (drm_i915_irq_wait_t *)data;
  if ((unsigned long )dev_priv == (unsigned long )((drm_i915_private_t *)0)) {
    {
    drm_err("i915_irq_wait", "called with no initialization\n");
    }
    return (-22);
  } else {
  }
  {
  tmp = i915_wait_irq(dev, irqwait->irq_seq);
  }
  return (tmp);
}
}
static int i915_enable_vblank(struct drm_device *dev , int pipe )
{ drm_i915_private_t *dev_priv ;
  unsigned long irqflags ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = i915_pipe_enabled(dev, pipe);
  }
  if (tmp == 0) {
    return (-22);
  } else {
  }
  {
  tmp___0 = spinlock_check(& dev_priv->irq_lock);
  irqflags = _raw_spin_lock_irqsave(tmp___0);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    {
    i915_enable_pipestat(dev_priv, pipe, 262144U);
    }
  } else {
    {
    i915_enable_pipestat(dev_priv, pipe, 131072U);
    }
  }
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) == 3U) {
    {
    i915_write32(dev_priv, 8384U, 134217728U);
    }
  } else {
  }
  {
  spin_unlock_irqrestore(& dev_priv->irq_lock, irqflags);
  }
  return (0);
}
}
static int ironlake_enable_vblank(struct drm_device *dev , int pipe )
{ drm_i915_private_t *dev_priv ;
  unsigned long irqflags ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned int tmp___1 ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = i915_pipe_enabled(dev, pipe);
  }
  if (tmp == 0) {
    return (-22);
  } else {
  }
  {
  tmp___0 = spinlock_check(& dev_priv->irq_lock);
  irqflags = _raw_spin_lock_irqsave(tmp___0);
  }
  if (pipe == 0) {
    tmp___1 = 128U;
  } else {
    tmp___1 = 32768U;
  }
  {
  ironlake_enable_display_irq(dev_priv, tmp___1);
  spin_unlock_irqrestore(& dev_priv->irq_lock, irqflags);
  }
  return (0);
}
}
static int ivybridge_enable_vblank(struct drm_device *dev , int pipe )
{ drm_i915_private_t *dev_priv ;
  unsigned long irqflags ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned int tmp___1 ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = i915_pipe_enabled(dev, pipe);
  }
  if (tmp == 0) {
    return (-22);
  } else {
  }
  {
  tmp___0 = spinlock_check(& dev_priv->irq_lock);
  irqflags = _raw_spin_lock_irqsave(tmp___0);
  }
  if (pipe == 0) {
    tmp___1 = 1U;
  } else {
    tmp___1 = 32U;
  }
  {
  ironlake_enable_display_irq(dev_priv, tmp___1);
  spin_unlock_irqrestore(& dev_priv->irq_lock, irqflags);
  }
  return (0);
}
}
static void i915_disable_vblank(struct drm_device *dev , int pipe )
{ drm_i915_private_t *dev_priv ;
  unsigned long irqflags ;
  raw_spinlock_t *tmp ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = spinlock_check(& dev_priv->irq_lock);
  irqflags = _raw_spin_lock_irqsave(tmp);
  }
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) == 3U) {
    {
    i915_write32(dev_priv, 8384U, 134219776U);
    }
  } else {
  }
  {
  i915_disable_pipestat(dev_priv, pipe, 393216U);
  spin_unlock_irqrestore(& dev_priv->irq_lock, irqflags);
  }
  return;
}
}
static void ironlake_disable_vblank(struct drm_device *dev , int pipe )
{ drm_i915_private_t *dev_priv ;
  unsigned long irqflags ;
  raw_spinlock_t *tmp ;
  unsigned int tmp___0 ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = spinlock_check(& dev_priv->irq_lock);
  irqflags = _raw_spin_lock_irqsave(tmp);
  }
  if (pipe == 0) {
    tmp___0 = 128U;
  } else {
    tmp___0 = 32768U;
  }
  {
  ironlake_disable_display_irq(dev_priv, tmp___0);
  spin_unlock_irqrestore(& dev_priv->irq_lock, irqflags);
  }
  return;
}
}
static void ivybridge_disable_vblank(struct drm_device *dev , int pipe )
{ drm_i915_private_t *dev_priv ;
  unsigned long irqflags ;
  raw_spinlock_t *tmp ;
  unsigned int tmp___0 ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = spinlock_check(& dev_priv->irq_lock);
  irqflags = _raw_spin_lock_irqsave(tmp);
  }
  if (pipe == 0) {
    tmp___0 = 1U;
  } else {
    tmp___0 = 32U;
  }
  {
  ironlake_disable_display_irq(dev_priv, tmp___0);
  spin_unlock_irqrestore(& dev_priv->irq_lock, irqflags);
  }
  return;
}
}
int i915_vblank_pipe_set(struct drm_device *dev , void *data , struct drm_file *file_priv )
{ drm_i915_private_t *dev_priv ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  if ((unsigned long )dev_priv == (unsigned long )((drm_i915_private_t *)0)) {
    {
    drm_err("i915_vblank_pipe_set", "called with no initialization\n");
    }
    return (-22);
  } else {
  }
  return (0);
}
}
int i915_vblank_pipe_get(struct drm_device *dev , void *data , struct drm_file *file_priv )
{ drm_i915_private_t *dev_priv ;
  drm_i915_vblank_pipe_t *pipe ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  pipe = (drm_i915_vblank_pipe_t *)data;
  if ((unsigned long )dev_priv == (unsigned long )((drm_i915_private_t *)0)) {
    {
    drm_err("i915_vblank_pipe_get", "called with no initialization\n");
    }
    return (-22);
  } else {
  }
  pipe->pipe = 3;
  return (0);
}
}
int i915_vblank_swap(struct drm_device *dev , void *data , struct drm_file *file_priv )
{
  {
  return (-22);
}
}
static u32 ring_last_seqno(struct intel_ring_buffer *ring )
{ struct list_head const *__mptr ;
  {
  __mptr = (struct list_head const *)ring->request_list.prev;
  return (((struct drm_i915_gem_request *)__mptr + 0x0fffffffffffffe8UL)->seqno);
}
}
static bool i915_hangcheck_ring_idle(struct intel_ring_buffer *ring , bool *err )
{ u32 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  bool tmp___4 ;
  {
  {
  tmp___1 = list_empty((struct list_head const *)(& ring->request_list));
  }
  if (tmp___1 != 0) {
    goto _L;
  } else {
    {
    tmp___2 = ring_last_seqno(ring);
    tmp___3 = (*(ring->get_seqno))(ring);
    tmp___4 = i915_seqno_passed(tmp___3, tmp___2);
    }
    if ((int )tmp___4) {
      _L:
      if (ring->waiting_seqno != 0U) {
        {
        tmp___0 = waitqueue_active(& ring->irq_queue);
        }
        if (tmp___0 != 0) {
          {
          tmp = (*(ring->get_seqno))(ring);
          drm_err("i915_hangcheck_ring_idle", "Hangcheck timer elapsed... %s idle [waiting on %d, at %d], missed IRQ?\n",
                  ring->name, ring->waiting_seqno, tmp);
          __wake_up(& ring->irq_queue, 3U, 0, (void *)0);
          *err = (bool )1;
          }
        } else {
        }
      } else {
      }
      return ((bool )1);
    } else {
    }
  }
  return ((bool )0);
}
}
static bool kick_ring(struct intel_ring_buffer *ring )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  u32 tmp ;
  u32 tmp___0 ;
  {
  {
  dev = ring->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp___0 = i915_read32(dev_priv, ring->mmio_base + 60U);
  tmp = tmp___0;
  }
  if ((tmp & 2048U) != 0U) {
    {
    drm_err("kick_ring", "Kicking stuck wait on %s\n", ring->name);
    i915_write32(dev_priv, ring->mmio_base + 60U, tmp);
    }
    return ((bool )1);
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    if ((tmp & 1024U) != 0U) {
      {
      drm_err("kick_ring", "Kicking stuck semaphore on %s\n", ring->name);
      i915_write32(dev_priv, ring->mmio_base + 60U, tmp);
      }
      return ((bool )1);
    } else {
    }
  } else {
  }
  return ((bool )0);
}
}
void i915_hangcheck_elapsed(unsigned long data )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  uint32_t acthd ;
  uint32_t instdone ;
  uint32_t instdone1 ;
  bool err ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  unsigned long tmp___6 ;
  {
  {
  dev = (struct drm_device *)data;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  err = (bool )0;
  tmp = i915_hangcheck_ring_idle((struct intel_ring_buffer *)(& dev_priv->ring), & err);
  }
  if ((int )tmp) {
    {
    tmp___0 = i915_hangcheck_ring_idle((struct intel_ring_buffer *)(& dev_priv->ring) + 1UL,
                                       & err);
    }
    if ((int )tmp___0) {
      {
      tmp___1 = i915_hangcheck_ring_idle((struct intel_ring_buffer *)(& dev_priv->ring) + 2UL,
                                         & err);
      }
      if ((int )tmp___1) {
        dev_priv->hangcheck_count = 0;
        if ((int )err) {
          goto repeat;
        } else {
        }
        return;
      } else {
      }
    } else {
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) <= 3U) {
    {
    acthd = i915_read32(dev_priv, 8392U);
    instdone = i915_read32(dev_priv, 8336U);
    instdone1 = 0U;
    }
  } else {
    {
    acthd = i915_read32(dev_priv, 8308U);
    instdone = i915_read32(dev_priv, 8300U);
    instdone1 = i915_read32(dev_priv, 8316U);
    }
  }
  if (dev_priv->last_acthd == acthd) {
    if (dev_priv->last_instdone == instdone) {
      if (dev_priv->last_instdone1 == instdone1) {
        tmp___5 = dev_priv->hangcheck_count;
        dev_priv->hangcheck_count = dev_priv->hangcheck_count + 1;
        if (tmp___5 > 1) {
          {
          drm_err("i915_hangcheck_elapsed", "Hangcheck timer elapsed... GPU hung\n");
          }
          if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 2U) {
            {
            tmp___2 = kick_ring((struct intel_ring_buffer *)(& dev_priv->ring));
            }
            if ((int )tmp___2) {
              goto repeat;
            } else {
            }
            if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 3UL) != 0U) {
              {
              tmp___3 = kick_ring((struct intel_ring_buffer *)(& dev_priv->ring) + 1UL);
              }
              if ((int )tmp___3) {
                goto repeat;
              } else {
              }
            } else {
            }
            if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 3UL) != 0U) {
              {
              tmp___4 = kick_ring((struct intel_ring_buffer *)(& dev_priv->ring) + 2UL);
              }
              if ((int )tmp___4) {
                goto repeat;
              } else {
              }
            } else {
            }
          } else {
          }
          {
          i915_handle_error(dev, (bool )1);
          }
          return;
        } else {
          dev_priv->hangcheck_count = 0;
          dev_priv->last_acthd = acthd;
          dev_priv->last_instdone = instdone;
          dev_priv->last_instdone1 = instdone1;
        }
      } else {
      }
    } else {
    }
  } else {
  }
  repeat:
  {
  tmp___6 = msecs_to_jiffies((unsigned int const )1500U);
  mod_timer(& dev_priv->hangcheck_timer, tmp___6 + (unsigned long )jiffies);
  }
  return;
}
}
static void ironlake_irq_preinstall(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_1 ;
  struct lock_class_key __key___1 ;
  atomic_long_t __constr_expr_2 ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  atomic_set(& dev_priv->irq_received, 0);
  __init_work(& dev_priv->hotplug_work, 0);
  __constr_expr_0.counter = 2097664L;
  dev_priv->hotplug_work.data = __constr_expr_0;
  lockdep_init_map(& dev_priv->hotplug_work.lockdep_map, "(&dev_priv->hotplug_work)",
                   & __key, 0);
  INIT_LIST_HEAD(& dev_priv->hotplug_work.entry);
  dev_priv->hotplug_work.func = & i915_hotplug_work_func;
  __init_work(& dev_priv->error_work, 0);
  __constr_expr_1.counter = 2097664L;
  dev_priv->error_work.data = __constr_expr_1;
  lockdep_init_map(& dev_priv->error_work.lockdep_map, "(&dev_priv->error_work)",
                   & __key___0, 0);
  INIT_LIST_HEAD(& dev_priv->error_work.entry);
  dev_priv->error_work.func = & i915_error_work_func;
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    goto _L;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    _L:
    {
    __init_work(& dev_priv->rps_work, 0);
    __constr_expr_2.counter = 2097664L;
    dev_priv->rps_work.data = __constr_expr_2;
    lockdep_init_map(& dev_priv->rps_work.lockdep_map, "(&dev_priv->rps_work)", & __key___1,
                     0);
    INIT_LIST_HEAD(& dev_priv->rps_work.entry);
    dev_priv->rps_work.func = & gen6_pm_rps_work;
    }
  } else {
  }
  {
  i915_write32(dev_priv, 8344U, 61438U);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    i915_write32(dev_priv, 139416U, 4290772991U);
    i915_write32(dev_priv, 73880U, 4294963199U);
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 7U) {
    {
    i915_write32(dev_priv, 139416U, 4290772991U);
    i915_write32(dev_priv, 73880U, 4294963199U);
    }
  } else {
  }
  {
  i915_write32(dev_priv, 278532U, 4294967295U);
  i915_write32(dev_priv, 278540U, 0U);
  readl((void const volatile *)dev_priv->regs + 278540U);
  i915_write32(dev_priv, 278548U, 4294967295U);
  i915_write32(dev_priv, 278556U, 0U);
  readl((void const volatile *)dev_priv->regs + 278556U);
  i915_write32(dev_priv, 802820U, 4294967295U);
  i915_write32(dev_priv, 802828U, 0U);
  readl((void const volatile *)dev_priv->regs + 802828U);
  }
  return;
}
}
static int ironlake_irq_postinstall(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  u32 display_mask ;
  u32 render_irqs ;
  u32 hotplug_mask ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  display_mask = 2351169536U;
  __init_waitqueue_head(& dev_priv->ring[0].irq_queue, & __key);
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 3UL) != 0U) {
    {
    __init_waitqueue_head(& dev_priv->ring[1].irq_queue, & __key___0);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 3UL) != 0U) {
    {
    __init_waitqueue_head(& dev_priv->ring[2].irq_queue, & __key___1);
    }
  } else {
  }
  {
  dev_priv->vblank_pipe = 3;
  dev_priv->irq_mask = ~ display_mask;
  tmp = i915_read32(dev_priv, 278536U);
  i915_write32(dev_priv, 278536U, tmp);
  i915_write32(dev_priv, 278532U, dev_priv->irq_mask);
  i915_write32(dev_priv, 278540U, display_mask | 32896U);
  readl((void const volatile *)dev_priv->regs + 278540U);
  dev_priv->gt_irq_mask = 4294967295U;
  tmp___0 = i915_read32(dev_priv, 278552U);
  i915_write32(dev_priv, 278552U, tmp___0);
  i915_write32(dev_priv, 278548U, dev_priv->gt_irq_mask);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    render_irqs = 4198401U;
  } else {
    render_irqs = 49U;
  }
  {
  i915_write32(dev_priv, 278556U, render_irqs);
  readl((void const volatile *)dev_priv->regs + 278556U);
  }
  if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 1U) {
    hotplug_mask = 15204352U;
  } else {
    hotplug_mask = 61184U;
  }
  {
  dev_priv->pch_irq_mask = ~ hotplug_mask;
  tmp___1 = i915_read32(dev_priv, 802824U);
  i915_write32(dev_priv, 802824U, tmp___1);
  i915_write32(dev_priv, 802820U, dev_priv->pch_irq_mask);
  i915_write32(dev_priv, 802828U, hotplug_mask);
  readl((void const volatile *)dev_priv->regs + 802828U);
  }
  if (dev->pci_device == 70) {
    {
    i915_write32(dev_priv, 278536U, 33554432U);
    tmp___2 = i915_read32(dev_priv, 278540U);
    i915_write32(dev_priv, 278540U, tmp___2 | 33554432U);
    ironlake_enable_display_irq(dev_priv, 33554432U);
    }
  } else {
  }
  return (0);
}
}
static int ivybridge_irq_postinstall(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  u32 display_mask ;
  u32 render_irqs ;
  u32 hotplug_mask ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  display_mask = 2952790280U;
  __init_waitqueue_head(& dev_priv->ring[0].irq_queue, & __key);
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 3UL) != 0U) {
    {
    __init_waitqueue_head(& dev_priv->ring[1].irq_queue, & __key___0);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 3UL) != 0U) {
    {
    __init_waitqueue_head(& dev_priv->ring[2].irq_queue, & __key___1);
    }
  } else {
  }
  {
  dev_priv->vblank_pipe = 3;
  dev_priv->irq_mask = ~ display_mask;
  tmp = i915_read32(dev_priv, 278536U);
  i915_write32(dev_priv, 278536U, tmp);
  i915_write32(dev_priv, 278532U, dev_priv->irq_mask);
  i915_write32(dev_priv, 278540U, display_mask | 33U);
  readl((void const volatile *)dev_priv->regs + 278540U);
  dev_priv->gt_irq_mask = 4294967295U;
  tmp___0 = i915_read32(dev_priv, 278552U);
  i915_write32(dev_priv, 278552U, tmp___0);
  i915_write32(dev_priv, 278548U, dev_priv->gt_irq_mask);
  render_irqs = 4198401U;
  i915_write32(dev_priv, 278556U, render_irqs);
  readl((void const volatile *)dev_priv->regs + 278556U);
  hotplug_mask = 15204352U;
  dev_priv->pch_irq_mask = ~ hotplug_mask;
  tmp___1 = i915_read32(dev_priv, 802824U);
  i915_write32(dev_priv, 802824U, tmp___1);
  i915_write32(dev_priv, 802820U, dev_priv->pch_irq_mask);
  i915_write32(dev_priv, 802828U, hotplug_mask);
  readl((void const volatile *)dev_priv->regs + 802828U);
  }
  return (0);
}
}
static void i915_driver_irq_preinstall(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  int pipe ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_1 ;
  u32 tmp ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  atomic_set(& dev_priv->irq_received, 0);
  __init_work(& dev_priv->hotplug_work, 0);
  __constr_expr_0.counter = 2097664L;
  dev_priv->hotplug_work.data = __constr_expr_0;
  lockdep_init_map(& dev_priv->hotplug_work.lockdep_map, "(&dev_priv->hotplug_work)",
                   & __key, 0);
  INIT_LIST_HEAD(& dev_priv->hotplug_work.entry);
  dev_priv->hotplug_work.func = & i915_hotplug_work_func;
  __init_work(& dev_priv->error_work, 0);
  __constr_expr_1.counter = 2097664L;
  dev_priv->error_work.data = __constr_expr_1;
  lockdep_init_map(& dev_priv->error_work.lockdep_map, "(&dev_priv->error_work)",
                   & __key___0, 0);
  INIT_LIST_HEAD(& dev_priv->error_work.entry);
  dev_priv->error_work.func = & i915_error_work_func;
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    i915_write32(dev_priv, 397584U, 0U);
    tmp = i915_read32(dev_priv, 397588U);
    i915_write32(dev_priv, 397588U, tmp);
    }
  } else {
  }
  {
  i915_write32(dev_priv, 8344U, 61438U);
  pipe = 0;
  }
  goto ldv_38151;
  ldv_38150:
  {
  i915_write32(dev_priv, (u32 )(pipe * 4096 + 458788), 0U);
  pipe = pipe + 1;
  }
  ldv_38151: ;
  if (dev_priv->num_pipe > pipe) {
    goto ldv_38150;
  } else {
    goto ldv_38152;
  }
  ldv_38152:
  {
  i915_write32(dev_priv, 8360U, 4294967295U);
  i915_write32(dev_priv, 8352U, 0U);
  readl((void const volatile *)dev_priv->regs + 8352U);
  }
  return;
}
}
static int i915_driver_irq_postinstall(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  u32 enable_mask ;
  u32 error_mask ;
  u32 hotplug_en ;
  u32 tmp ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  enable_mask = 33590355U;
  dev_priv->vblank_pipe = 3;
  dev_priv->irq_mask = 4294931374U;
  dev_priv->pipestat[0] = 0U;
  dev_priv->pipestat[1] = 0U;
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    enable_mask = enable_mask | 131072U;
    dev_priv->irq_mask = dev_priv->irq_mask & 4294836223U;
  } else {
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    error_mask = 4294967237U;
  } else {
    error_mask = 4294967277U;
  }
  {
  i915_write32(dev_priv, 8372U, error_mask);
  i915_write32(dev_priv, 8360U, dev_priv->irq_mask);
  i915_write32(dev_priv, 8352U, enable_mask);
  readl((void const volatile *)dev_priv->regs + 8352U);
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    tmp = i915_read32(dev_priv, 397584U);
    hotplug_en = tmp;
    }
    if ((dev_priv->hotplug_supported_mask & 536870912U) != 0U) {
      hotplug_en = hotplug_en | 536870912U;
    } else {
    }
    if ((dev_priv->hotplug_supported_mask & 268435456U) != 0U) {
      hotplug_en = hotplug_en | 268435456U;
    } else {
    }
    if ((dev_priv->hotplug_supported_mask & 134217728U) != 0U) {
      hotplug_en = hotplug_en | 134217728U;
    } else {
    }
    if ((dev_priv->hotplug_supported_mask & 128U) != 0U) {
      hotplug_en = hotplug_en | 33554432U;
    } else {
    }
    if ((dev_priv->hotplug_supported_mask & 64U) != 0U) {
      hotplug_en = hotplug_en | 67108864U;
    } else {
    }
    if ((dev_priv->hotplug_supported_mask & 2048U) != 0U) {
      hotplug_en = hotplug_en | 512U;
      if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
        hotplug_en = hotplug_en | 256U;
      } else {
      }
      hotplug_en = hotplug_en | 32U;
    } else {
    }
    {
    i915_write32(dev_priv, 397584U, hotplug_en);
    }
  } else {
  }
  {
  intel_opregion_enable_asle(dev);
  }
  return (0);
}
}
static void ironlake_irq_uninstall(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  u32 tmp ;
  u32 tmp___0 ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  if ((unsigned long )dev_priv == (unsigned long )((drm_i915_private_t *)0)) {
    return;
  } else {
  }
  {
  dev_priv->vblank_pipe = 0;
  i915_write32(dev_priv, 8344U, 4294967295U);
  i915_write32(dev_priv, 278532U, 4294967295U);
  i915_write32(dev_priv, 278540U, 0U);
  tmp = i915_read32(dev_priv, 278536U);
  i915_write32(dev_priv, 278536U, tmp);
  i915_write32(dev_priv, 278548U, 4294967295U);
  i915_write32(dev_priv, 278556U, 0U);
  tmp___0 = i915_read32(dev_priv, 278552U);
  i915_write32(dev_priv, 278552U, tmp___0);
  }
  return;
}
}
static void i915_driver_irq_uninstall(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  int pipe ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  if ((unsigned long )dev_priv == (unsigned long )((drm_i915_private_t *)0)) {
    return;
  } else {
  }
  dev_priv->vblank_pipe = 0;
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    i915_write32(dev_priv, 397584U, 0U);
    tmp = i915_read32(dev_priv, 397588U);
    i915_write32(dev_priv, 397588U, tmp);
    }
  } else {
  }
  {
  i915_write32(dev_priv, 8344U, 4294967295U);
  pipe = 0;
  }
  goto ldv_38170;
  ldv_38169:
  {
  i915_write32(dev_priv, (u32 )(pipe * 4096 + 458788), 0U);
  pipe = pipe + 1;
  }
  ldv_38170: ;
  if (dev_priv->num_pipe > pipe) {
    goto ldv_38169;
  } else {
    goto ldv_38171;
  }
  ldv_38171:
  {
  i915_write32(dev_priv, 8360U, 4294967295U);
  i915_write32(dev_priv, 8352U, 0U);
  pipe = 0;
  }
  goto ldv_38173;
  ldv_38172:
  {
  tmp___0 = i915_read32(dev_priv, (u32 )(pipe * 4096 + 458788));
  i915_write32(dev_priv, (u32 )(pipe * 4096 + 458788), tmp___0 & 2147549183U);
  pipe = pipe + 1;
  }
  ldv_38173: ;
  if (dev_priv->num_pipe > pipe) {
    goto ldv_38172;
  } else {
    goto ldv_38174;
  }
  ldv_38174:
  {
  tmp___1 = i915_read32(dev_priv, 8356U);
  i915_write32(dev_priv, 8356U, tmp___1);
  }
  return;
}
}
void intel_irq_init(struct drm_device *dev )
{
  {
  (dev->driver)->get_vblank_counter = & i915_get_vblank_counter;
  dev->max_vblank_count = 16777215U;
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    dev->max_vblank_count = 4294967295U;
    (dev->driver)->get_vblank_counter = & gm45_get_vblank_counter;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    dev->max_vblank_count = 4294967295U;
    (dev->driver)->get_vblank_counter = & gm45_get_vblank_counter;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    dev->max_vblank_count = 4294967295U;
    (dev->driver)->get_vblank_counter = & gm45_get_vblank_counter;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    dev->max_vblank_count = 4294967295U;
    (dev->driver)->get_vblank_counter = & gm45_get_vblank_counter;
  } else {
  }
  (dev->driver)->get_vblank_timestamp = & i915_get_vblank_timestamp;
  (dev->driver)->get_scanout_position = & i915_get_crtc_scanoutpos;
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    (dev->driver)->irq_handler = & ivybridge_irq_handler;
    (dev->driver)->irq_preinstall = & ironlake_irq_preinstall;
    (dev->driver)->irq_postinstall = & ivybridge_irq_postinstall;
    (dev->driver)->irq_uninstall = & ironlake_irq_uninstall;
    (dev->driver)->enable_vblank = & ivybridge_enable_vblank;
    (dev->driver)->disable_vblank = & ivybridge_disable_vblank;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    goto _L;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    goto _L;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    _L:
    (dev->driver)->irq_handler = & ironlake_irq_handler;
    (dev->driver)->irq_preinstall = & ironlake_irq_preinstall;
    (dev->driver)->irq_postinstall = & ironlake_irq_postinstall;
    (dev->driver)->irq_uninstall = & ironlake_irq_uninstall;
    (dev->driver)->enable_vblank = & ironlake_enable_vblank;
    (dev->driver)->disable_vblank = & ironlake_disable_vblank;
  } else {
    (dev->driver)->irq_preinstall = & i915_driver_irq_preinstall;
    (dev->driver)->irq_postinstall = & i915_driver_irq_postinstall;
    (dev->driver)->irq_uninstall = & i915_driver_irq_uninstall;
    (dev->driver)->irq_handler = & i915_driver_irq_handler;
    (dev->driver)->enable_vblank = & i915_enable_vblank;
    (dev->driver)->disable_vblank = & i915_disable_vblank;
  }
  return;
}
}
static void mark_block(struct drm_device *dev , struct mem_block *p , int in_use )
{ drm_i915_private_t *dev_priv ;
  struct drm_i915_master_private *master_priv ;
  drm_i915_sarea_t *sarea_priv ;
  struct drm_tex_region *list ;
  unsigned int shift ;
  unsigned int nr ;
  unsigned int start ;
  unsigned int end ;
  unsigned int i ;
  int age ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  master_priv = (struct drm_i915_master_private *)((dev->primary)->master)->driver_priv;
  sarea_priv = master_priv->sarea_priv;
  shift = (unsigned int )dev_priv->tex_lru_log_granularity;
  nr = 255U;
  start = (unsigned int )(p->start >> (int )shift);
  end = (unsigned int )(((p->start + p->size) + -1) >> (int )shift);
  sarea_priv->texAge = sarea_priv->texAge + 1;
  age = sarea_priv->texAge;
  list = (struct drm_tex_region *)(& sarea_priv->texList);
  i = start;
  goto ldv_37072;
  ldv_37071:
  (list + (unsigned long )i)->in_use = (unsigned char )in_use;
  (list + (unsigned long )i)->age = (unsigned int )age;
  (list + (unsigned long )(list + (unsigned long )i)->next)->prev = (list + (unsigned long )i)->prev;
  (list + (unsigned long )(list + (unsigned long )i)->prev)->next = (list + (unsigned long )i)->next;
  (list + (unsigned long )i)->prev = (unsigned char )nr;
  (list + (unsigned long )i)->next = (list + (unsigned long )nr)->next;
  (list + (unsigned long )(list + (unsigned long )nr)->next)->prev = (unsigned char )i;
  (list + (unsigned long )nr)->next = (unsigned char )i;
  i = i + 1U;
  ldv_37072: ;
  if (i <= end) {
    goto ldv_37071;
  } else {
    goto ldv_37073;
  }
  ldv_37073: ;
  return;
}
}
static struct mem_block *split_block(struct mem_block *p , int start , int size ,
                                     struct drm_file *file_priv )
{ struct mem_block *newblock ;
  void *tmp ;
  struct mem_block *newblock___0 ;
  void *tmp___0 ;
  {
  if (p->start < start) {
    {
    tmp = kmalloc(32UL, 208U);
    newblock = (struct mem_block *)tmp;
    }
    if ((unsigned long )newblock == (unsigned long )((struct mem_block *)0)) {
      goto out;
    } else {
    }
    newblock->start = start;
    newblock->size = p->size + (p->start - start);
    newblock->file_priv = (struct drm_file *)0;
    newblock->next = p->next;
    newblock->prev = p;
    (p->next)->prev = newblock;
    p->next = newblock;
    p->size = p->size - newblock->size;
    p = newblock;
  } else {
  }
  if (p->size > size) {
    {
    tmp___0 = kmalloc(32UL, 208U);
    newblock___0 = (struct mem_block *)tmp___0;
    }
    if ((unsigned long )newblock___0 == (unsigned long )((struct mem_block *)0)) {
      goto out;
    } else {
    }
    newblock___0->start = start + size;
    newblock___0->size = p->size - size;
    newblock___0->file_priv = (struct drm_file *)0;
    newblock___0->next = p->next;
    newblock___0->prev = p;
    (p->next)->prev = newblock___0;
    p->next = newblock___0;
    p->size = size;
  } else {
  }
  out:
  p->file_priv = file_priv;
  return (p);
}
}
static struct mem_block *alloc_block(struct mem_block *heap , int size , int align2 ,
                                     struct drm_file *file_priv )
{ struct mem_block *p ;
  int mask ;
  int start ;
  struct mem_block *tmp ;
  {
  mask = (1 << align2) + -1;
  p = heap->next;
  goto ldv_37093;
  ldv_37092:
  start = (p->start + mask) & ~ mask;
  if ((unsigned long )p->file_priv == (unsigned long )((struct drm_file *)0)) {
    if (start + size <= p->start + p->size) {
      {
      tmp = split_block(p, start, size, file_priv);
      }
      return (tmp);
    } else {
    }
  } else {
  }
  p = p->next;
  ldv_37093: ;
  if ((unsigned long )p != (unsigned long )heap) {
    goto ldv_37092;
  } else {
    goto ldv_37094;
  }
  ldv_37094: ;
  return ((struct mem_block *)0);
}
}
static struct mem_block *find_block(struct mem_block *heap , int start )
{ struct mem_block *p ;
  {
  p = heap->next;
  goto ldv_37101;
  ldv_37100: ;
  if (p->start == start) {
    return (p);
  } else {
  }
  p = p->next;
  ldv_37101: ;
  if ((unsigned long )p != (unsigned long )heap) {
    goto ldv_37100;
  } else {
    goto ldv_37102;
  }
  ldv_37102: ;
  return ((struct mem_block *)0);
}
}
static void free_block(struct mem_block *p )
{ struct mem_block *q ;
  struct mem_block *q___0 ;
  {
  p->file_priv = (struct drm_file *)0;
  if ((unsigned long )(p->next)->file_priv == (unsigned long )((struct drm_file *)0)) {
    {
    q = p->next;
    p->size = p->size + q->size;
    p->next = q->next;
    (p->next)->prev = p;
    kfree((void const *)q);
    }
  } else {
  }
  if ((unsigned long )(p->prev)->file_priv == (unsigned long )((struct drm_file *)0)) {
    {
    q___0 = p->prev;
    q___0->size = q___0->size + p->size;
    q___0->next = p->next;
    (q___0->next)->prev = q___0;
    kfree((void const *)p);
    }
  } else {
  }
  return;
}
}
static int init_heap(struct mem_block **heap , int start , int size )
{ struct mem_block *blocks ;
  void *tmp ;
  void *tmp___0 ;
  struct mem_block *tmp___1 ;
  struct mem_block *tmp___2 ;
  {
  {
  tmp = kmalloc(32UL, 208U);
  blocks = (struct mem_block *)tmp;
  }
  if ((unsigned long )blocks == (unsigned long )((struct mem_block *)0)) {
    return (-12);
  } else {
  }
  {
  tmp___0 = kmalloc(32UL, 208U);
  *heap = (struct mem_block *)tmp___0;
  }
  if ((unsigned long )*heap == (unsigned long )((struct mem_block *)0)) {
    {
    kfree((void const *)blocks);
    }
    return (-12);
  } else {
  }
  {
  blocks->start = start;
  blocks->size = size;
  blocks->file_priv = (struct drm_file *)0;
  tmp___1 = *heap;
  blocks->prev = tmp___1;
  blocks->next = tmp___1;
  memset((void *)*heap, 0, 32UL);
  (*heap)->file_priv = (struct drm_file *)0x0fffffffffffffffUL;
  tmp___2 = blocks;
  (*heap)->prev = tmp___2;
  (*heap)->next = tmp___2;
  }
  return (0);
}
}
void i915_mem_release(struct drm_device *dev , struct drm_file *file_priv , struct mem_block *heap )
{ struct mem_block *p ;
  struct mem_block *q ;
  {
  if ((unsigned long )heap == (unsigned long )((struct mem_block *)0)) {
    return;
  } else
  if ((unsigned long )heap->next == (unsigned long )((struct mem_block *)0)) {
    return;
  } else {
  }
  p = heap->next;
  goto ldv_37121;
  ldv_37120: ;
  if ((unsigned long )p->file_priv == (unsigned long )file_priv) {
    {
    p->file_priv = (struct drm_file *)0;
    mark_block(dev, p, 0);
    }
  } else {
  }
  p = p->next;
  ldv_37121: ;
  if ((unsigned long )p != (unsigned long )heap) {
    goto ldv_37120;
  } else {
    goto ldv_37122;
  }
  ldv_37122:
  p = heap->next;
  goto ldv_37128;
  ldv_37127: ;
  goto ldv_37125;
  ldv_37124:
  {
  q = p->next;
  p->size = p->size + q->size;
  p->next = q->next;
  (p->next)->prev = p;
  kfree((void const *)q);
  }
  ldv_37125: ;
  if ((unsigned long )p->file_priv == (unsigned long )((struct drm_file *)0)) {
    if ((unsigned long )(p->next)->file_priv == (unsigned long )((struct drm_file *)0)) {
      goto ldv_37124;
    } else {
      goto ldv_37126;
    }
  } else {
    goto ldv_37126;
  }
  ldv_37126:
  p = p->next;
  ldv_37128: ;
  if ((unsigned long )p != (unsigned long )heap) {
    goto ldv_37127;
  } else {
    goto ldv_37129;
  }
  ldv_37129: ;
  return;
}
}
void i915_mem_takedown(struct mem_block **heap )
{ struct mem_block *p ;
  struct mem_block *q ;
  {
  if ((unsigned long )*heap == (unsigned long )((struct mem_block *)0)) {
    return;
  } else {
  }
  p = (*heap)->next;
  goto ldv_37136;
  ldv_37135:
  {
  q = p;
  p = p->next;
  kfree((void const *)q);
  }
  ldv_37136: ;
  if ((unsigned long )*heap != (unsigned long )p) {
    goto ldv_37135;
  } else {
    goto ldv_37137;
  }
  ldv_37137:
  {
  kfree((void const *)*heap);
  *heap = (struct mem_block *)0;
  }
  return;
}
}
static struct mem_block **get_heap(drm_i915_private_t *dev_priv , int region )
{
  {
  if (region == 1) {
    goto case_1;
  } else {
    goto switch_default;
    if (0) {
      case_1: ;
      return (& dev_priv->agp_heap);
      switch_default: ;
      return ((struct mem_block **)0);
    } else {
    }
  }
}
}
int i915_mem_alloc(struct drm_device *dev , void *data , struct drm_file *file_priv )
{ drm_i915_private_t *dev_priv ;
  drm_i915_mem_alloc_t *alloc ;
  struct mem_block *block ;
  struct mem_block **heap ;
  int tmp ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  alloc = (drm_i915_mem_alloc_t *)data;
  if ((unsigned long )dev_priv == (unsigned long )((drm_i915_private_t *)0)) {
    {
    drm_err("i915_mem_alloc", "called with no initialization\n");
    }
    return (-22);
  } else {
  }
  {
  heap = get_heap(dev_priv, alloc->region);
  }
  if ((unsigned long )heap == (unsigned long )((struct mem_block **)0)) {
    return (-14);
  } else
  if ((unsigned long )*heap == (unsigned long )((struct mem_block *)0)) {
    return (-14);
  } else {
  }
  if (alloc->alignment <= 11) {
    alloc->alignment = 12;
  } else {
  }
  {
  block = alloc_block(*heap, alloc->size, alloc->alignment, file_priv);
  }
  if ((unsigned long )block == (unsigned long )((struct mem_block *)0)) {
    return (-12);
  } else {
  }
  {
  mark_block(dev, block, 1);
  tmp = copy_to_user((void *)alloc->region_offset, (void const *)(& block->start),
                     4U);
  }
  if (tmp != 0) {
    {
    drm_err("i915_mem_alloc", "copy_to_user\n");
    }
    return (-14);
  } else {
  }
  return (0);
}
}
int i915_mem_free(struct drm_device *dev , void *data , struct drm_file *file_priv )
{ drm_i915_private_t *dev_priv ;
  drm_i915_mem_free_t *memfree ;
  struct mem_block *block ;
  struct mem_block **heap ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  memfree = (drm_i915_mem_free_t *)data;
  if ((unsigned long )dev_priv == (unsigned long )((drm_i915_private_t *)0)) {
    {
    drm_err("i915_mem_free", "called with no initialization\n");
    }
    return (-22);
  } else {
  }
  {
  heap = get_heap(dev_priv, memfree->region);
  }
  if ((unsigned long )heap == (unsigned long )((struct mem_block **)0)) {
    return (-14);
  } else
  if ((unsigned long )*heap == (unsigned long )((struct mem_block *)0)) {
    return (-14);
  } else {
  }
  {
  block = find_block(*heap, memfree->region_offset);
  }
  if ((unsigned long )block == (unsigned long )((struct mem_block *)0)) {
    return (-14);
  } else {
  }
  if ((unsigned long )block->file_priv != (unsigned long )file_priv) {
    return (-1);
  } else {
  }
  {
  mark_block(dev, block, 0);
  free_block(block);
  }
  return (0);
}
}
int i915_mem_init_heap(struct drm_device *dev , void *data , struct drm_file *file_priv )
{ drm_i915_private_t *dev_priv ;
  drm_i915_mem_init_heap_t *initheap ;
  struct mem_block **heap ;
  int tmp ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  initheap = (drm_i915_mem_init_heap_t *)data;
  if ((unsigned long )dev_priv == (unsigned long )((drm_i915_private_t *)0)) {
    {
    drm_err("i915_mem_init_heap", "called with no initialization\n");
    }
    return (-22);
  } else {
  }
  {
  heap = get_heap(dev_priv, initheap->region);
  }
  if ((unsigned long )heap == (unsigned long )((struct mem_block **)0)) {
    return (-14);
  } else {
  }
  if ((unsigned long )*heap != (unsigned long )((struct mem_block *)0)) {
    {
    drm_err("i915_mem_init_heap", "heap already initialized?");
    }
    return (-14);
  } else {
  }
  {
  tmp = init_heap(heap, initheap->start, initheap->size);
  }
  return (tmp);
}
}
int i915_mem_destroy_heap(struct drm_device *dev , void *data , struct drm_file *file_priv )
{ drm_i915_private_t *dev_priv ;
  drm_i915_mem_destroy_heap_t *destroyheap ;
  struct mem_block **heap ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  destroyheap = (drm_i915_mem_destroy_heap_t *)data;
  if ((unsigned long )dev_priv == (unsigned long )((drm_i915_private_t *)0)) {
    {
    drm_err("i915_mem_destroy_heap", "called with no initialization\n");
    }
    return (-22);
  } else {
  }
  {
  heap = get_heap(dev_priv, destroyheap->region);
  }
  if ((unsigned long )heap == (unsigned long )((struct mem_block **)0)) {
    {
    drm_err("i915_mem_destroy_heap", "get_heap failed");
    }
    return (-14);
  } else {
  }
  if ((unsigned long )*heap == (unsigned long )((struct mem_block *)0)) {
    {
    drm_err("i915_mem_destroy_heap", "heap not initialized?");
    }
    return (-14);
  } else {
  }
  {
  i915_mem_takedown(heap);
  }
  return (0);
}
}
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
__inline static void list_add(struct list_head *new , struct list_head *head )
{
  {
  {
  __list_add(new, head, head->next);
  }
  return;
}
}
extern unsigned long simple_strtoul(char const * , char ** , unsigned int ) ;
extern int snprintf(char * , size_t , char const * , ...) ;
__inline static long PTR_ERR(void const *ptr )
{
  {
  return ((long )ptr);
}
}
__inline static long IS_ERR(void const *ptr )
{ long tmp ;
  {
  {
  tmp = __builtin_expect((long )((unsigned long )ptr > 0x0ffffffffffff000UL), 0L);
  }
  return (tmp);
}
}
extern int mutex_lock_interruptible_nested(struct mutex * , unsigned int ) ;
extern int seq_write(struct seq_file * , void const * , size_t ) ;
extern int seq_printf(struct seq_file * , char const * , ...) ;
extern loff_t default_llseek(struct file * , loff_t , int ) ;
extern ssize_t simple_read_from_buffer(void * , size_t , loff_t * , void const * ,
                                       size_t ) ;
extern struct dentry *debugfs_create_file(char const * , mode_t , struct dentry * ,
                                          void * , struct file_operations const * ) ;
extern void debugfs_remove(struct dentry * ) ;
extern int drm_debugfs_create_files(struct drm_info_list * , int , struct dentry * ,
                                    struct drm_minor * ) ;
extern int drm_debugfs_remove_files(struct drm_info_list * , int , struct drm_minor * ) ;
u32 intel_ring_get_active_head(struct intel_ring_buffer *ring ) ;
__inline static void trace_i915_reg_rw___2(bool write , u32 reg , u64 val , int len )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_reg_rw.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_reg_rw.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )411);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_36339:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , bool , u32 , u64 , int ))it_func))(__data, (bool )((int )write),
                                                                   reg, val, len);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_36339;
      } else {
        goto ldv_36340;
      }
      ldv_36340: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
bool intel_fbc_enabled(struct drm_device *dev ) ;
void intel_overlay_print_error_state(struct seq_file *m , struct intel_overlay_error_state *error ) ;
void intel_display_print_error_state(struct seq_file *m , struct drm_device *dev ,
                                     struct intel_display_error_state *error ) ;
__inline static u16 i915_read16___0(struct drm_i915_private *dev_priv , u32 reg )
{ u16 val ;
  {
  val = (u16 )0U;
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        gen6_gt_force_wake_get(dev_priv);
        val = readw((void const volatile *)dev_priv->regs + (unsigned long )reg);
        gen6_gt_force_wake_put(dev_priv);
        }
      } else {
        {
        val = readw((void const volatile *)dev_priv->regs + (unsigned long )reg);
        }
      }
    } else {
      {
      val = readw((void const volatile *)dev_priv->regs + (unsigned long )reg);
      }
    }
  } else {
    {
    val = readw((void const volatile *)dev_priv->regs + (unsigned long )reg);
    }
  }
  {
  trace_i915_reg_rw___2((bool )0, reg, (u64 )val, 2);
  }
  return (val);
}
}
__inline static u32 i915_read32___2(struct drm_i915_private *dev_priv , u32 reg )
{ u32 val ;
  {
  val = 0U;
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        gen6_gt_force_wake_get(dev_priv);
        val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
        gen6_gt_force_wake_put(dev_priv);
        }
      } else {
        {
        val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
        }
      }
    } else {
      {
      val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
      }
    }
  } else {
    {
    val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
    }
  }
  {
  trace_i915_reg_rw___2((bool )0, reg, (u64 )val, 4);
  }
  return (val);
}
}
static char const *yesno(int v )
{ char const *tmp ;
  {
  if (v != 0) {
    tmp = "yes";
  } else {
    tmp = "no";
  }
  return (tmp);
}
}
static int i915_capabilities(struct seq_file *m , void *data )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  struct intel_device_info const *info ;
  char const *tmp ;
  char const *tmp___0 ;
  char const *tmp___1 ;
  char const *tmp___2 ;
  char const *tmp___3 ;
  char const *tmp___4 ;
  char const *tmp___5 ;
  char const *tmp___6 ;
  char const *tmp___7 ;
  char const *tmp___8 ;
  char const *tmp___9 ;
  char const *tmp___10 ;
  char const *tmp___11 ;
  char const *tmp___12 ;
  char const *tmp___13 ;
  char const *tmp___14 ;
  char const *tmp___15 ;
  char const *tmp___16 ;
  char const *tmp___17 ;
  {
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  info = ((struct drm_i915_private *)dev->dev_private)->info;
  seq_printf(m, "gen: %d\n", (int )info->gen);
  tmp = yesno((int )info->is_mobile);
  seq_printf(m, "is_mobile: %s\n", tmp);
  tmp___0 = yesno((int )info->is_i85x);
  seq_printf(m, "is_i85x: %s\n", tmp___0);
  tmp___1 = yesno((int )info->is_i915g);
  seq_printf(m, "is_i915g: %s\n", tmp___1);
  tmp___2 = yesno((int )info->is_i945gm);
  seq_printf(m, "is_i945gm: %s\n", tmp___2);
  tmp___3 = yesno((int )info->is_g33);
  seq_printf(m, "is_g33: %s\n", tmp___3);
  tmp___4 = yesno((int )info->need_gfx_hws);
  seq_printf(m, "need_gfx_hws: %s\n", tmp___4);
  tmp___5 = yesno((int )info->is_g4x);
  seq_printf(m, "is_g4x: %s\n", tmp___5);
  tmp___6 = yesno((int )info->is_pineview);
  seq_printf(m, "is_pineview: %s\n", tmp___6);
  tmp___7 = yesno((int )info->is_broadwater);
  seq_printf(m, "is_broadwater: %s\n", tmp___7);
  tmp___8 = yesno((int )info->is_crestline);
  seq_printf(m, "is_crestline: %s\n", tmp___8);
  tmp___9 = yesno((int )info->has_fbc);
  seq_printf(m, "has_fbc: %s\n", tmp___9);
  tmp___10 = yesno((int )info->has_pipe_cxsr);
  seq_printf(m, "has_pipe_cxsr: %s\n", tmp___10);
  tmp___11 = yesno((int )info->has_hotplug);
  seq_printf(m, "has_hotplug: %s\n", tmp___11);
  tmp___12 = yesno((int )info->cursor_needs_physical);
  seq_printf(m, "cursor_needs_physical: %s\n", tmp___12);
  tmp___13 = yesno((int )info->has_overlay);
  seq_printf(m, "has_overlay: %s\n", tmp___13);
  tmp___14 = yesno((int )info->overlay_needs_physical);
  seq_printf(m, "overlay_needs_physical: %s\n", tmp___14);
  tmp___15 = yesno((int )info->supports_tv);
  seq_printf(m, "supports_tv: %s\n", tmp___15);
  tmp___16 = yesno((int )info->has_bsd_ring);
  seq_printf(m, "has_bsd_ring: %s\n", tmp___16);
  tmp___17 = yesno((int )info->has_blt_ring);
  seq_printf(m, "has_blt_ring: %s\n", tmp___17);
  }
  return (0);
}
}
static char const *get_pin_flag(struct drm_i915_gem_object *obj )
{
  {
  if (obj->user_pin_count != 0U) {
    return ("P");
  } else
  if ((int )obj->pin_count > 0) {
    return ("p");
  } else {
    return (" ");
  }
}
}
static char const *get_tiling_flag(struct drm_i915_gem_object *obj )
{
  {
  if ((int )obj->tiling_mode == 0) {
    goto case_0;
  } else
  if ((int )obj->tiling_mode == 1) {
    goto case_1;
  } else
  if ((int )obj->tiling_mode == 2) {
    goto case_2;
  } else {
    goto switch_default;
    if (0) {
      switch_default: ;
      case_0: ;
      return (" ");
      case_1: ;
      return ("X");
      case_2: ;
      return ("Y");
    } else {
    }
  }
}
}
static char const *cache_level_str(int type )
{
  {
  if (type == 0) {
    goto case_0;
  } else
  if (type == 1) {
    goto case_1;
  } else
  if (type == 2) {
    goto case_2;
  } else {
    goto switch_default;
    if (0) {
      case_0: ;
      return (" uncached");
      case_1: ;
      return (" snooped (LLC)");
      case_2: ;
      return (" snooped (LLC+MLC)");
      switch_default: ;
      return ("");
    } else {
    }
  }
}
}
static void describe_obj(struct seq_file *m , struct drm_i915_gem_object *obj )
{ char *tmp ;
  char *tmp___0 ;
  char const *tmp___1 ;
  char const *tmp___2 ;
  char const *tmp___3 ;
  char s[3U] ;
  char *t ;
  char *tmp___4 ;
  char *tmp___5 ;
  {
  if ((unsigned int )*((unsigned char *)obj + 225UL) == 1U) {
    tmp = (char *)" purgeable";
  } else {
    tmp = (char *)"";
  }
  if ((unsigned int )*((unsigned char *)obj + 224UL) != 0U) {
    tmp___0 = (char *)" dirty";
  } else {
    tmp___0 = (char *)"";
  }
  {
  tmp___1 = cache_level_str((int )obj->cache_level);
  tmp___2 = get_tiling_flag(obj);
  tmp___3 = get_pin_flag(obj);
  seq_printf(m, "%p: %s%s %8zd %04x %04x %d %d%s%s%s", & obj->base, tmp___3, tmp___2,
             obj->base.size, obj->base.read_domains, obj->base.write_domain, obj->last_rendering_seqno,
             obj->last_fenced_seqno, tmp___1, tmp___0, tmp);
  }
  if (obj->base.name != 0) {
    {
    seq_printf(m, " (name: %d)", obj->base.name);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)obj + 224UL) != 248U) {
    {
    seq_printf(m, " (fence: %d)", (int )obj->fence_reg);
    }
  } else {
  }
  if ((unsigned long )obj->gtt_space != (unsigned long )((struct drm_mm_node *)0)) {
    {
    seq_printf(m, " (gtt offset: %08x, size: %08x)", obj->gtt_offset, (unsigned int )(obj->gtt_space)->size);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)obj + 226UL) != 0U) {
    goto _L;
  } else
  if ((unsigned int )*((unsigned char *)obj + 226UL) != 0U) {
    _L:
    t = (char *)(& s);
    if ((unsigned int )*((unsigned char *)obj + 226UL) != 0U) {
      tmp___4 = t;
      t = t + 1;
      *tmp___4 = (char)112;
    } else {
    }
    if ((unsigned int )*((unsigned char *)obj + 226UL) != 0U) {
      tmp___5 = t;
      t = t + 1;
      *tmp___5 = (char)102;
    } else {
    }
    {
    *t = (char)0;
    seq_printf(m, " (%s mappable)", (char *)(& s));
    }
  } else {
  }
  if ((unsigned long )obj->ring != (unsigned long )((struct intel_ring_buffer *)0)) {
    {
    seq_printf(m, " (%s)", (obj->ring)->name);
    }
  } else {
  }
  return;
}
}
static int i915_gem_object_list_info(struct seq_file *m , void *data )
{ struct drm_info_node *node ;
  uintptr_t list ;
  struct list_head *head ;
  struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  struct drm_i915_gem_object *obj ;
  size_t total_obj_size ;
  size_t total_gtt_size ;
  int count ;
  int ret ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  {
  {
  node = (struct drm_info_node *)m->private;
  list = (unsigned long )(node->info_ent)->data;
  dev = (node->minor)->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ret = mutex_lock_interruptible_nested(& dev->struct_mutex, 0U);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  if ((int )list == 0) {
    goto case_0;
  } else
  if ((int )list == 2) {
    goto case_2;
  } else
  if ((int )list == 3) {
    goto case_3;
  } else
  if ((int )list == 1) {
    goto case_1;
  } else
  if ((int )list == 4) {
    goto case_4;
  } else {
    goto switch_default;
    if (0) {
      case_0:
      {
      seq_printf(m, "Active:\n");
      head = & dev_priv->mm.active_list;
      }
      goto ldv_37687;
      case_2:
      {
      seq_printf(m, "Inactive:\n");
      head = & dev_priv->mm.inactive_list;
      }
      goto ldv_37687;
      case_3:
      {
      seq_printf(m, "Pinned:\n");
      head = & dev_priv->mm.pinned_list;
      }
      goto ldv_37687;
      case_1:
      {
      seq_printf(m, "Flushing:\n");
      head = & dev_priv->mm.flushing_list;
      }
      goto ldv_37687;
      case_4:
      {
      seq_printf(m, "Deferred free:\n");
      head = & dev_priv->mm.deferred_free_list;
      }
      goto ldv_37687;
      switch_default:
      {
      mutex_unlock(& dev->struct_mutex);
      }
      return (-22);
    } else {
    }
  }
  ldv_37687:
  count = 0;
  total_gtt_size = 0UL;
  total_obj_size = total_gtt_size;
  __mptr = (struct list_head const *)head->next;
  obj = (struct drm_i915_gem_object *)__mptr + 0x0fffffffffffff50UL;
  goto ldv_37698;
  ldv_37697:
  {
  seq_printf(m, "   ");
  describe_obj(m, obj);
  seq_printf(m, "\n");
  total_obj_size = obj->base.size + total_obj_size;
  total_gtt_size = (obj->gtt_space)->size + total_gtt_size;
  count = count + 1;
  __mptr___0 = (struct list_head const *)obj->mm_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___0 + 0x0fffffffffffff50UL;
  }
  ldv_37698: ;
  if ((unsigned long )(& obj->mm_list) != (unsigned long )head) {
    goto ldv_37697;
  } else {
    goto ldv_37699;
  }
  ldv_37699:
  {
  mutex_unlock(& dev->struct_mutex);
  seq_printf(m, "Total %d objects, %zu bytes, %zu GTT size\n", count, total_obj_size,
             total_gtt_size);
  }
  return (0);
}
}
static int i915_gem_object_info(struct seq_file *m , void *data )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  u32 count ;
  u32 mappable_count ;
  size_t size ;
  size_t mappable_size ;
  struct drm_i915_gem_object *obj ;
  int ret ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  struct list_head const *__mptr___1 ;
  struct list_head const *__mptr___2 ;
  struct list_head const *__mptr___3 ;
  struct list_head const *__mptr___4 ;
  struct list_head const *__mptr___5 ;
  struct list_head const *__mptr___6 ;
  struct list_head const *__mptr___7 ;
  struct list_head const *__mptr___8 ;
  struct list_head const *__mptr___9 ;
  struct list_head const *__mptr___10 ;
  struct list_head const *__mptr___11 ;
  struct list_head const *__mptr___12 ;
  {
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  ret = mutex_lock_interruptible_nested(& dev->struct_mutex, 0U);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  seq_printf(m, "%u objects, %zu bytes\n", dev_priv->mm.object_count, dev_priv->mm.object_memory);
  mappable_count = 0U;
  mappable_size = 0UL;
  count = (u32 )mappable_size;
  size = (size_t )count;
  __mptr = (struct list_head const *)dev_priv->mm.gtt_list.next;
  obj = (struct drm_i915_gem_object *)__mptr + 0x0fffffffffffff70UL;
  }
  goto ldv_37718;
  ldv_37717:
  size = (obj->gtt_space)->size + size;
  count = count + 1U;
  if ((unsigned int )*((unsigned char *)obj + 226UL) != 0U) {
    mappable_size = (obj->gtt_space)->size + mappable_size;
    mappable_count = mappable_count + 1U;
  } else {
  }
  __mptr___0 = (struct list_head const *)obj->gtt_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___0 + 0x0fffffffffffff70UL;
  ldv_37718: ;
  if ((unsigned long )(& obj->gtt_list) != (unsigned long )(& dev_priv->mm.gtt_list)) {
    goto ldv_37717;
  } else {
    goto ldv_37719;
  }
  ldv_37719:
  {
  seq_printf(m, "%u [%u] objects, %zu [%zu] bytes in gtt\n", count, mappable_count,
             size, mappable_size);
  mappable_count = 0U;
  mappable_size = 0UL;
  count = (u32 )mappable_size;
  size = (size_t )count;
  __mptr___1 = (struct list_head const *)dev_priv->mm.active_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___1 + 0x0fffffffffffff50UL;
  }
  goto ldv_37725;
  ldv_37724:
  size = (obj->gtt_space)->size + size;
  count = count + 1U;
  if ((unsigned int )*((unsigned char *)obj + 226UL) != 0U) {
    mappable_size = (obj->gtt_space)->size + mappable_size;
    mappable_count = mappable_count + 1U;
  } else {
  }
  __mptr___2 = (struct list_head const *)obj->mm_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___2 + 0x0fffffffffffff50UL;
  ldv_37725: ;
  if ((unsigned long )(& obj->mm_list) != (unsigned long )(& dev_priv->mm.active_list)) {
    goto ldv_37724;
  } else {
    goto ldv_37726;
  }
  ldv_37726:
  __mptr___3 = (struct list_head const *)dev_priv->mm.flushing_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___3 + 0x0fffffffffffff50UL;
  goto ldv_37732;
  ldv_37731:
  size = (obj->gtt_space)->size + size;
  count = count + 1U;
  if ((unsigned int )*((unsigned char *)obj + 226UL) != 0U) {
    mappable_size = (obj->gtt_space)->size + mappable_size;
    mappable_count = mappable_count + 1U;
  } else {
  }
  __mptr___4 = (struct list_head const *)obj->mm_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___4 + 0x0fffffffffffff50UL;
  ldv_37732: ;
  if ((unsigned long )(& obj->mm_list) != (unsigned long )(& dev_priv->mm.flushing_list)) {
    goto ldv_37731;
  } else {
    goto ldv_37733;
  }
  ldv_37733:
  {
  seq_printf(m, "  %u [%u] active objects, %zu [%zu] bytes\n", count, mappable_count,
             size, mappable_size);
  mappable_count = 0U;
  mappable_size = 0UL;
  count = (u32 )mappable_size;
  size = (size_t )count;
  __mptr___5 = (struct list_head const *)dev_priv->mm.pinned_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___5 + 0x0fffffffffffff50UL;
  }
  goto ldv_37739;
  ldv_37738:
  size = (obj->gtt_space)->size + size;
  count = count + 1U;
  if ((unsigned int )*((unsigned char *)obj + 226UL) != 0U) {
    mappable_size = (obj->gtt_space)->size + mappable_size;
    mappable_count = mappable_count + 1U;
  } else {
  }
  __mptr___6 = (struct list_head const *)obj->mm_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___6 + 0x0fffffffffffff50UL;
  ldv_37739: ;
  if ((unsigned long )(& obj->mm_list) != (unsigned long )(& dev_priv->mm.pinned_list)) {
    goto ldv_37738;
  } else {
    goto ldv_37740;
  }
  ldv_37740:
  {
  seq_printf(m, "  %u [%u] pinned objects, %zu [%zu] bytes\n", count, mappable_count,
             size, mappable_size);
  mappable_count = 0U;
  mappable_size = 0UL;
  count = (u32 )mappable_size;
  size = (size_t )count;
  __mptr___7 = (struct list_head const *)dev_priv->mm.inactive_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___7 + 0x0fffffffffffff50UL;
  }
  goto ldv_37746;
  ldv_37745:
  size = (obj->gtt_space)->size + size;
  count = count + 1U;
  if ((unsigned int )*((unsigned char *)obj + 226UL) != 0U) {
    mappable_size = (obj->gtt_space)->size + mappable_size;
    mappable_count = mappable_count + 1U;
  } else {
  }
  __mptr___8 = (struct list_head const *)obj->mm_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___8 + 0x0fffffffffffff50UL;
  ldv_37746: ;
  if ((unsigned long )(& obj->mm_list) != (unsigned long )(& dev_priv->mm.inactive_list)) {
    goto ldv_37745;
  } else {
    goto ldv_37747;
  }
  ldv_37747:
  {
  seq_printf(m, "  %u [%u] inactive objects, %zu [%zu] bytes\n", count, mappable_count,
             size, mappable_size);
  mappable_count = 0U;
  mappable_size = 0UL;
  count = (u32 )mappable_size;
  size = (size_t )count;
  __mptr___9 = (struct list_head const *)dev_priv->mm.deferred_free_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___9 + 0x0fffffffffffff50UL;
  }
  goto ldv_37753;
  ldv_37752:
  size = (obj->gtt_space)->size + size;
  count = count + 1U;
  if ((unsigned int )*((unsigned char *)obj + 226UL) != 0U) {
    mappable_size = (obj->gtt_space)->size + mappable_size;
    mappable_count = mappable_count + 1U;
  } else {
  }
  __mptr___10 = (struct list_head const *)obj->mm_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___10 + 0x0fffffffffffff50UL;
  ldv_37753: ;
  if ((unsigned long )(& obj->mm_list) != (unsigned long )(& dev_priv->mm.deferred_free_list)) {
    goto ldv_37752;
  } else {
    goto ldv_37754;
  }
  ldv_37754:
  {
  seq_printf(m, "  %u [%u] freed objects, %zu [%zu] bytes\n", count, mappable_count,
             size, mappable_size);
  mappable_count = 0U;
  mappable_size = 0UL;
  count = (u32 )mappable_size;
  size = (size_t )count;
  __mptr___11 = (struct list_head const *)dev_priv->mm.gtt_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___11 + 0x0fffffffffffff70UL;
  }
  goto ldv_37760;
  ldv_37759: ;
  if ((unsigned int )*((unsigned char *)obj + 226UL) != 0U) {
    size = (obj->gtt_space)->size + size;
    count = count + 1U;
  } else {
  }
  if ((unsigned int )*((unsigned char *)obj + 226UL) != 0U) {
    mappable_size = (obj->gtt_space)->size + mappable_size;
    mappable_count = mappable_count + 1U;
  } else {
  }
  __mptr___12 = (struct list_head const *)obj->gtt_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___12 + 0x0fffffffffffff70UL;
  ldv_37760: ;
  if ((unsigned long )(& obj->gtt_list) != (unsigned long )(& dev_priv->mm.gtt_list)) {
    goto ldv_37759;
  } else {
    goto ldv_37761;
  }
  ldv_37761:
  {
  seq_printf(m, "%u pinned mappable objects, %zu bytes\n", mappable_count, mappable_size);
  seq_printf(m, "%u fault mappable objects, %zu bytes\n", count, size);
  seq_printf(m, "%zu [%zu] gtt total\n", dev_priv->mm.gtt_total, dev_priv->mm.mappable_gtt_total);
  mutex_unlock(& dev->struct_mutex);
  }
  return (0);
}
}
static int i915_gem_gtt_info(struct seq_file *m , void *data )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct drm_i915_gem_object *obj ;
  size_t total_obj_size ;
  size_t total_gtt_size ;
  int count ;
  int ret ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  {
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  ret = mutex_lock_interruptible_nested(& dev->struct_mutex, 0U);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  count = 0;
  total_gtt_size = 0UL;
  total_obj_size = total_gtt_size;
  __mptr = (struct list_head const *)dev_priv->mm.gtt_list.next;
  obj = (struct drm_i915_gem_object *)__mptr + 0x0fffffffffffff70UL;
  goto ldv_37779;
  ldv_37778:
  {
  seq_printf(m, "   ");
  describe_obj(m, obj);
  seq_printf(m, "\n");
  total_obj_size = obj->base.size + total_obj_size;
  total_gtt_size = (obj->gtt_space)->size + total_gtt_size;
  count = count + 1;
  __mptr___0 = (struct list_head const *)obj->gtt_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___0 + 0x0fffffffffffff70UL;
  }
  ldv_37779: ;
  if ((unsigned long )(& obj->gtt_list) != (unsigned long )(& dev_priv->mm.gtt_list)) {
    goto ldv_37778;
  } else {
    goto ldv_37780;
  }
  ldv_37780:
  {
  mutex_unlock(& dev->struct_mutex);
  seq_printf(m, "Total %d objects, %zu bytes, %zu GTT size\n", count, total_obj_size,
             total_gtt_size);
  }
  return (0);
}
}
static int i915_gem_pageflip_info(struct seq_file *m , void *data )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  unsigned long flags ;
  struct intel_crtc *crtc ;
  struct list_head const *__mptr ;
  char pipe ;
  char plane ;
  struct intel_unpin_work *work ;
  raw_spinlock_t *tmp ;
  struct drm_i915_gem_object *obj ;
  struct drm_i915_gem_object *obj___0 ;
  struct list_head const *__mptr___0 ;
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  __mptr = (struct list_head const *)dev->mode_config.crtc_list.next;
  crtc = (struct intel_crtc *)__mptr + 0x0ffffffffffffff8UL;
  goto ldv_37802;
  ldv_37801:
  {
  pipe = (char )((char const )((unsigned int )((unsigned char )crtc->pipe) + 65U));
  plane = (char )((char const )((unsigned int )((unsigned char )crtc->plane) + 65U));
  tmp = spinlock_check(& dev->event_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  work = crtc->unpin_work;
  }
  if ((unsigned long )work == (unsigned long )((struct intel_unpin_work *)0)) {
    {
    seq_printf(m, "No flip due on pipe %c (plane %c)\n", (int )pipe, (int )plane);
    }
  } else {
    if (work->pending == 0) {
      {
      seq_printf(m, "Flip queued on pipe %c (plane %c)\n", (int )pipe, (int )plane);
      }
    } else {
      {
      seq_printf(m, "Flip pending (waiting for vsync) on pipe %c (plane %c)\n", (int )pipe,
                 (int )plane);
      }
    }
    if ((int )work->enable_stall_check) {
      {
      seq_printf(m, "Stall check enabled, ");
      }
    } else {
      {
      seq_printf(m, "Stall check waiting for page flip ioctl, ");
      }
    }
    {
    seq_printf(m, "%d prepares\n", work->pending);
    }
    if ((unsigned long )work->old_fb_obj != (unsigned long )((struct drm_i915_gem_object *)0)) {
      obj = work->old_fb_obj;
      if ((unsigned long )obj != (unsigned long )((struct drm_i915_gem_object *)0)) {
        {
        seq_printf(m, "Old framebuffer gtt_offset 0x%08x\n", obj->gtt_offset);
        }
      } else {
      }
    } else {
    }
    if ((unsigned long )work->pending_flip_obj != (unsigned long )((struct drm_i915_gem_object *)0)) {
      obj___0 = work->pending_flip_obj;
      if ((unsigned long )obj___0 != (unsigned long )((struct drm_i915_gem_object *)0)) {
        {
        seq_printf(m, "New framebuffer gtt_offset 0x%08x\n", obj___0->gtt_offset);
        }
      } else {
      }
    } else {
    }
  }
  {
  spin_unlock_irqrestore(& dev->event_lock, flags);
  __mptr___0 = (struct list_head const *)crtc->base.head.next;
  crtc = (struct intel_crtc *)__mptr___0 + 0x0ffffffffffffff8UL;
  }
  ldv_37802: ;
  if ((unsigned long )(& crtc->base.head) != (unsigned long )(& dev->mode_config.crtc_list)) {
    goto ldv_37801;
  } else {
    goto ldv_37803;
  }
  ldv_37803: ;
  return (0);
}
}
static int i915_gem_request_info(struct seq_file *m , void *data )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  struct drm_i915_gem_request *gem_request ;
  int ret ;
  int count ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  int tmp ;
  struct list_head const *__mptr___1 ;
  struct list_head const *__mptr___2 ;
  int tmp___0 ;
  struct list_head const *__mptr___3 ;
  struct list_head const *__mptr___4 ;
  int tmp___1 ;
  {
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ret = mutex_lock_interruptible_nested(& dev->struct_mutex, 0U);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  count = 0;
  tmp = list_empty((struct list_head const *)(& dev_priv->ring[0].request_list));
  }
  if (tmp == 0) {
    {
    seq_printf(m, "Render requests:\n");
    __mptr = (struct list_head const *)dev_priv->ring[0].request_list.next;
    gem_request = (struct drm_i915_gem_request *)__mptr + 0x0fffffffffffffe8UL;
    }
    goto ldv_37819;
    ldv_37818:
    {
    seq_printf(m, "    %d @ %d\n", gem_request->seqno, (int )((unsigned int )jiffies - (unsigned int )gem_request->emitted_jiffies));
    __mptr___0 = (struct list_head const *)gem_request->list.next;
    gem_request = (struct drm_i915_gem_request *)__mptr___0 + 0x0fffffffffffffe8UL;
    }
    ldv_37819: ;
    if ((unsigned long )(& gem_request->list) != (unsigned long )(& dev_priv->ring[0].request_list)) {
      goto ldv_37818;
    } else {
      goto ldv_37820;
    }
    ldv_37820:
    count = count + 1;
  } else {
  }
  {
  tmp___0 = list_empty((struct list_head const *)(& dev_priv->ring[1].request_list));
  }
  if (tmp___0 == 0) {
    {
    seq_printf(m, "BSD requests:\n");
    __mptr___1 = (struct list_head const *)dev_priv->ring[1].request_list.next;
    gem_request = (struct drm_i915_gem_request *)__mptr___1 + 0x0fffffffffffffe8UL;
    }
    goto ldv_37826;
    ldv_37825:
    {
    seq_printf(m, "    %d @ %d\n", gem_request->seqno, (int )((unsigned int )jiffies - (unsigned int )gem_request->emitted_jiffies));
    __mptr___2 = (struct list_head const *)gem_request->list.next;
    gem_request = (struct drm_i915_gem_request *)__mptr___2 + 0x0fffffffffffffe8UL;
    }
    ldv_37826: ;
    if ((unsigned long )(& gem_request->list) != (unsigned long )(& dev_priv->ring[1].request_list)) {
      goto ldv_37825;
    } else {
      goto ldv_37827;
    }
    ldv_37827:
    count = count + 1;
  } else {
  }
  {
  tmp___1 = list_empty((struct list_head const *)(& dev_priv->ring[2].request_list));
  }
  if (tmp___1 == 0) {
    {
    seq_printf(m, "BLT requests:\n");
    __mptr___3 = (struct list_head const *)dev_priv->ring[2].request_list.next;
    gem_request = (struct drm_i915_gem_request *)__mptr___3 + 0x0fffffffffffffe8UL;
    }
    goto ldv_37833;
    ldv_37832:
    {
    seq_printf(m, "    %d @ %d\n", gem_request->seqno, (int )((unsigned int )jiffies - (unsigned int )gem_request->emitted_jiffies));
    __mptr___4 = (struct list_head const *)gem_request->list.next;
    gem_request = (struct drm_i915_gem_request *)__mptr___4 + 0x0fffffffffffffe8UL;
    }
    ldv_37833: ;
    if ((unsigned long )(& gem_request->list) != (unsigned long )(& dev_priv->ring[2].request_list)) {
      goto ldv_37832;
    } else {
      goto ldv_37834;
    }
    ldv_37834:
    count = count + 1;
  } else {
  }
  {
  mutex_unlock(& dev->struct_mutex);
  }
  if (count == 0) {
    {
    seq_printf(m, "No requests\n");
    }
  } else {
  }
  return (0);
}
}
static void i915_ring_seqno_info(struct seq_file *m , struct intel_ring_buffer *ring )
{ u32 tmp ;
  {
  if ((unsigned long )ring->get_seqno != (unsigned long )((u32 (*)(struct intel_ring_buffer * ))0)) {
    {
    tmp = (*(ring->get_seqno))(ring);
    seq_printf(m, "Current sequence (%s): %d\n", ring->name, tmp);
    seq_printf(m, "Waiter sequence (%s):  %d\n", ring->name, ring->waiting_seqno);
    seq_printf(m, "IRQ sequence (%s):     %d\n", ring->name, ring->irq_seqno);
    }
  } else {
  }
  return;
}
}
static int i915_gem_seqno_info(struct seq_file *m , void *data )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  int ret ;
  int i ;
  {
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ret = mutex_lock_interruptible_nested(& dev->struct_mutex, 0U);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  i = 0;
  goto ldv_37849;
  ldv_37848:
  {
  i915_ring_seqno_info(m, (struct intel_ring_buffer *)(& dev_priv->ring) + (unsigned long )i);
  i = i + 1;
  }
  ldv_37849: ;
  if (i <= 2) {
    goto ldv_37848;
  } else {
    goto ldv_37850;
  }
  ldv_37850:
  {
  mutex_unlock(& dev->struct_mutex);
  }
  return (0);
}
}
static int i915_interrupt_info(struct seq_file *m , void *data )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  int ret ;
  int i ;
  int pipe ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  int tmp___12 ;
  u32 tmp___13 ;
  {
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ret = mutex_lock_interruptible_nested(& dev->struct_mutex, 0U);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 5U) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 6U) {
      if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) == 0U) {
        {
        tmp = i915_read32___2(dev_priv, 8352U);
        seq_printf(m, "Interrupt enable:    %08x\n", tmp);
        tmp___0 = i915_read32___2(dev_priv, 8356U);
        seq_printf(m, "Interrupt identity:  %08x\n", tmp___0);
        tmp___1 = i915_read32___2(dev_priv, 8360U);
        seq_printf(m, "Interrupt mask:      %08x\n", tmp___1);
        pipe = 0;
        }
        goto ldv_37862;
        ldv_37861:
        {
        tmp___2 = i915_read32___2(dev_priv, (u32 )(pipe * 4096 + 458788));
        seq_printf(m, "Pipe %c stat:         %08x\n", pipe + 65, tmp___2);
        pipe = pipe + 1;
        }
        ldv_37862: ;
        if (dev_priv->num_pipe > pipe) {
          goto ldv_37861;
        } else {
          goto ldv_37863;
        }
        ldv_37863: ;
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0:
    {
    tmp___3 = i915_read32___2(dev_priv, 278540U);
    seq_printf(m, "North Display Interrupt enable:\t\t%08x\n", tmp___3);
    tmp___4 = i915_read32___2(dev_priv, 278536U);
    seq_printf(m, "North Display Interrupt identity:\t%08x\n", tmp___4);
    tmp___5 = i915_read32___2(dev_priv, 278532U);
    seq_printf(m, "North Display Interrupt mask:\t\t%08x\n", tmp___5);
    tmp___6 = i915_read32___2(dev_priv, 802828U);
    seq_printf(m, "South Display Interrupt enable:\t\t%08x\n", tmp___6);
    tmp___7 = i915_read32___2(dev_priv, 802824U);
    seq_printf(m, "South Display Interrupt identity:\t%08x\n", tmp___7);
    tmp___8 = i915_read32___2(dev_priv, 802820U);
    seq_printf(m, "South Display Interrupt mask:\t\t%08x\n", tmp___8);
    tmp___9 = i915_read32___2(dev_priv, 278556U);
    seq_printf(m, "Graphics Interrupt enable:\t\t%08x\n", tmp___9);
    tmp___10 = i915_read32___2(dev_priv, 278552U);
    seq_printf(m, "Graphics Interrupt identity:\t\t%08x\n", tmp___10);
    tmp___11 = i915_read32___2(dev_priv, 278548U);
    seq_printf(m, "Graphics Interrupt mask:\t\t%08x\n", tmp___11);
    }
  }
  {
  tmp___12 = atomic_read((atomic_t const *)(& dev_priv->irq_received));
  seq_printf(m, "Interrupts received: %d\n", tmp___12);
  i = 0;
  }
  goto ldv_37865;
  ldv_37864: ;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    tmp___13 = i915_read32___2(dev_priv, ((struct intel_ring_buffer *)(& dev_priv->ring) + (unsigned long )i)->mmio_base + 168U);
    seq_printf(m, "Graphics Interrupt mask (%s):\t%08x\n", dev_priv->ring[i].name,
               tmp___13);
    }
  } else {
  }
  {
  i915_ring_seqno_info(m, (struct intel_ring_buffer *)(& dev_priv->ring) + (unsigned long )i);
  i = i + 1;
  }
  ldv_37865: ;
  if (i <= 2) {
    goto ldv_37864;
  } else {
    goto ldv_37866;
  }
  ldv_37866:
  {
  mutex_unlock(& dev->struct_mutex);
  }
  return (0);
}
}
static int i915_gem_fence_regs_info(struct seq_file *m , void *data )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  int i ;
  int ret ;
  struct drm_i915_gem_object *obj ;
  {
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ret = mutex_lock_interruptible_nested(& dev->struct_mutex, 0U);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  seq_printf(m, "Reserved fences = %d\n", dev_priv->fence_reg_start);
  seq_printf(m, "Total fences = %d\n", dev_priv->num_fence_regs);
  i = 0;
  }
  goto ldv_37878;
  ldv_37877:
  {
  obj = dev_priv->fence_regs[i].obj;
  seq_printf(m, "Fenced object[%2d] = ", i);
  }
  if ((unsigned long )obj == (unsigned long )((struct drm_i915_gem_object *)0)) {
    {
    seq_printf(m, "unused");
    }
  } else {
    {
    describe_obj(m, obj);
    }
  }
  {
  seq_printf(m, "\n");
  i = i + 1;
  }
  ldv_37878: ;
  if (dev_priv->num_fence_regs > i) {
    goto ldv_37877;
  } else {
    goto ldv_37879;
  }
  ldv_37879:
  {
  mutex_unlock(& dev->struct_mutex);
  }
  return (0);
}
}
static int i915_hws_info(struct seq_file *m , void *data )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  struct intel_ring_buffer *ring ;
  u32 const volatile *hws ;
  int i ;
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ring = (struct intel_ring_buffer *)(& dev_priv->ring) + (unsigned long )(node->info_ent)->data;
  hws = (u32 const volatile *)ring->status_page.page_addr;
  if ((unsigned long )hws == (unsigned long )((u32 const volatile *)0)) {
    return (0);
  } else {
  }
  i = 0;
  goto ldv_37891;
  ldv_37890:
  {
  seq_printf(m, "0x%08x: 0x%08x 0x%08x 0x%08x 0x%08x\n", i * 4, *(hws + (unsigned long )i),
             *(hws + ((unsigned long )i + 1UL)), *(hws + ((unsigned long )i + 2UL)),
             *(hws + ((unsigned long )i + 3UL)));
  i = i + 4;
  }
  ldv_37891: ;
  if ((unsigned int )i <= 255U) {
    goto ldv_37890;
  } else {
    goto ldv_37892;
  }
  ldv_37892: ;
  return (0);
}
}
static void i915_dump_object(struct seq_file *m , struct io_mapping *mapping , struct drm_i915_gem_object *obj )
{ int page ;
  int page_count___0 ;
  int i ;
  u32 *mem ;
  void *tmp ;
  {
  page_count___0 = (int )(obj->base.size / 4096UL);
  page = 0;
  goto ldv_37906;
  ldv_37905:
  {
  tmp = io_mapping_map_atomic_wc(mapping, (unsigned long )obj->gtt_offset + (unsigned long )page * 4096UL);
  mem = (u32 *)tmp;
  i = 0;
  }
  goto ldv_37903;
  ldv_37902:
  {
  seq_printf(m, "%08x :  %08x\n", i, *(mem + (unsigned long )(i / 4)));
  i = i + 4;
  }
  ldv_37903: ;
  if ((unsigned int )i <= 4095U) {
    goto ldv_37902;
  } else {
    goto ldv_37904;
  }
  ldv_37904:
  {
  io_mapping_unmap_atomic((void *)mem);
  page = page + 1;
  }
  ldv_37906: ;
  if (page < page_count___0) {
    goto ldv_37905;
  } else {
    goto ldv_37907;
  }
  ldv_37907: ;
  return;
}
}
static int i915_batchbuffer_info(struct seq_file *m , void *data )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  struct drm_i915_gem_object *obj ;
  int ret ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  {
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ret = mutex_lock_interruptible_nested(& dev->struct_mutex, 0U);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  __mptr = (struct list_head const *)dev_priv->mm.active_list.next;
  obj = (struct drm_i915_gem_object *)__mptr + 0x0fffffffffffff50UL;
  goto ldv_37922;
  ldv_37921: ;
  if ((obj->base.read_domains & 8U) != 0U) {
    {
    seq_printf(m, "--- gtt_offset = 0x%08x\n", obj->gtt_offset);
    i915_dump_object(m, dev_priv->mm.gtt_mapping, obj);
    }
  } else {
  }
  __mptr___0 = (struct list_head const *)obj->mm_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___0 + 0x0fffffffffffff50UL;
  ldv_37922: ;
  if ((unsigned long )(& obj->mm_list) != (unsigned long )(& dev_priv->mm.active_list)) {
    goto ldv_37921;
  } else {
    goto ldv_37923;
  }
  ldv_37923:
  {
  mutex_unlock(& dev->struct_mutex);
  }
  return (0);
}
}
static int i915_ringbuffer_data(struct seq_file *m , void *data )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  struct intel_ring_buffer *ring ;
  int ret ;
  u8 const *virt ;
  uint32_t off ;
  uint32_t *ptr ;
  {
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ret = mutex_lock_interruptible_nested(& dev->struct_mutex, 0U);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  ring = (struct intel_ring_buffer *)(& dev_priv->ring) + (unsigned long )(node->info_ent)->data;
  if ((unsigned long )ring->obj == (unsigned long )((struct drm_i915_gem_object *)0)) {
    {
    seq_printf(m, "No ringbuffer setup\n");
    }
  } else {
    virt = (u8 const *)ring->virtual_start;
    off = 0U;
    goto ldv_37937;
    ldv_37936:
    {
    ptr = (uint32_t *)virt + (unsigned long )off;
    seq_printf(m, "%08x :  %08x\n", off, *ptr);
    off = off + 4U;
    }
    ldv_37937: ;
    if ((uint32_t )ring->size > off) {
      goto ldv_37936;
    } else {
      goto ldv_37938;
    }
    ldv_37938: ;
  }
  {
  mutex_unlock(& dev->struct_mutex);
  }
  return (0);
}
}
static int i915_ringbuffer_info(struct seq_file *m , void *data )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  struct intel_ring_buffer *ring ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ring = (struct intel_ring_buffer *)(& dev_priv->ring) + (unsigned long )(node->info_ent)->data;
  if (ring->size == 0) {
    return (0);
  } else {
  }
  {
  seq_printf(m, "Ring %s:\n", ring->name);
  tmp = i915_read32___2(dev_priv, ring->mmio_base + 52U);
  seq_printf(m, "  Head :    %08x\n", tmp & 2097148U);
  tmp___0 = i915_read32___2(dev_priv, ring->mmio_base + 48U);
  seq_printf(m, "  Tail :    %08x\n", tmp___0 & 2097144U);
  seq_printf(m, "  Size :    %08x\n", ring->size);
  tmp___1 = intel_ring_get_active_head(ring);
  seq_printf(m, "  Active :  %08x\n", tmp___1);
  tmp___2 = i915_read32___2(dev_priv, ring->mmio_base + 148U);
  seq_printf(m, "  NOPID :   %08x\n", tmp___2);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    tmp___3 = i915_read32___2(dev_priv, ring->mmio_base + 64U);
    seq_printf(m, "  Sync 0 :   %08x\n", tmp___3);
    tmp___4 = i915_read32___2(dev_priv, ring->mmio_base + 68U);
    seq_printf(m, "  Sync 1 :   %08x\n", tmp___4);
    }
  } else {
  }
  {
  tmp___5 = i915_read32___2(dev_priv, ring->mmio_base + 60U);
  seq_printf(m, "  Control : %08x\n", tmp___5);
  tmp___6 = i915_read32___2(dev_priv, ring->mmio_base + 56U);
  seq_printf(m, "  Start :   %08x\n", tmp___6);
  }
  return (0);
}
}
static char const *ring_str(int ring )
{
  {
  if (ring == 1) {
    goto case_1;
  } else
  if (ring == 2) {
    goto case_2;
  } else
  if (ring == 4) {
    goto case_4;
  } else {
    goto switch_default;
    if (0) {
      case_1: ;
      return (" render");
      case_2: ;
      return (" bsd");
      case_4: ;
      return (" blt");
      switch_default: ;
      return ("");
    } else {
    }
  }
}
}
static char const *pin_flag(int pinned )
{
  {
  if (pinned > 0) {
    return (" P");
  } else
  if (pinned < 0) {
    return (" p");
  } else {
    return ("");
  }
}
}
static char const *tiling_flag(int tiling )
{
  {
  if (tiling == 0) {
    goto case_0;
  } else
  if (tiling == 1) {
    goto case_1;
  } else
  if (tiling == 2) {
    goto case_2;
  } else {
    goto switch_default;
    if (0) {
      switch_default: ;
      case_0: ;
      return ("");
      case_1: ;
      return (" X");
      case_2: ;
      return (" Y");
    } else {
    }
  }
}
}
static char const *dirty_flag(int dirty )
{ char const *tmp ;
  {
  if (dirty != 0) {
    tmp = " dirty";
  } else {
    tmp = "";
  }
  return (tmp);
}
}
static char const *purgeable_flag(int purgeable )
{ char const *tmp ;
  {
  if (purgeable != 0) {
    tmp = " purgeable";
  } else {
    tmp = "";
  }
  return (tmp);
}
}
static void print_error_buffers(struct seq_file *m , char const *name , struct drm_i915_error_buffer *err ,
                                int count )
{ char const *tmp ;
  char const *tmp___0 ;
  char const *tmp___1 ;
  char const *tmp___2 ;
  char const *tmp___3 ;
  char const *tmp___4 ;
  int tmp___5 ;
  {
  {
  seq_printf(m, "%s [%d]:\n", name, count);
  }
  goto ldv_37977;
  ldv_37976:
  {
  tmp = cache_level_str((int )err->cache_level);
  tmp___0 = ring_str((int )err->ring);
  tmp___1 = purgeable_flag((int )err->purgeable);
  tmp___2 = dirty_flag((int )err->dirty);
  tmp___3 = tiling_flag((int )err->tiling);
  tmp___4 = pin_flag((int )err->pinned);
  seq_printf(m, "  %08x %8u %04x %04x %08x%s%s%s%s%s%s", err->gtt_offset, err->size,
             err->read_domains, err->write_domain, err->seqno, tmp___4, tmp___3, tmp___2,
             tmp___1, tmp___0, tmp);
  }
  if (err->name != 0U) {
    {
    seq_printf(m, " (name: %d)", err->name);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)err + 24UL) != 31U) {
    {
    seq_printf(m, " (fence: %d)", (int )err->fence_reg);
    }
  } else {
  }
  {
  seq_printf(m, "\n");
  err = err + 1;
  }
  ldv_37977:
  tmp___5 = count;
  count = count - 1;
  if (tmp___5 != 0) {
    goto ldv_37976;
  } else {
    goto ldv_37978;
  }
  ldv_37978: ;
  return;
}
}
static int i915_error_state(struct seq_file *m , void *unused )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  struct drm_i915_error_state *error ;
  unsigned long flags ;
  int i ;
  int page ;
  int offset ;
  int elt ;
  raw_spinlock_t *tmp ;
  struct drm_i915_error_object *obj ;
  struct drm_i915_error_object *obj___0 ;
  {
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = spinlock_check(& dev_priv->error_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  }
  if ((unsigned long )dev_priv->first_error == (unsigned long )((struct drm_i915_error_state *)0)) {
    {
    seq_printf(m, "no error state collected\n");
    }
    goto out;
  } else {
  }
  {
  error = dev_priv->first_error;
  seq_printf(m, "Time: %ld s %ld us\n", error->time.tv_sec, error->time.tv_usec);
  seq_printf(m, "PCI ID: 0x%04x\n", dev->pci_device);
  seq_printf(m, "EIR: 0x%08x\n", error->eir);
  seq_printf(m, "PGTBL_ER: 0x%08x\n", error->pgtbl_er);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 5U) {
    {
    seq_printf(m, "ERROR: 0x%08x\n", error->error);
    seq_printf(m, "Blitter command stream:\n");
    seq_printf(m, "  ACTHD:    0x%08x\n", error->bcs_acthd);
    seq_printf(m, "  IPEIR:    0x%08x\n", error->bcs_ipeir);
    seq_printf(m, "  IPEHR:    0x%08x\n", error->bcs_ipehr);
    seq_printf(m, "  INSTDONE: 0x%08x\n", error->bcs_instdone);
    seq_printf(m, "  seqno:    0x%08x\n", error->bcs_seqno);
    seq_printf(m, "Video (BSD) command stream:\n");
    seq_printf(m, "  ACTHD:    0x%08x\n", error->vcs_acthd);
    seq_printf(m, "  IPEIR:    0x%08x\n", error->vcs_ipeir);
    seq_printf(m, "  IPEHR:    0x%08x\n", error->vcs_ipehr);
    seq_printf(m, "  INSTDONE: 0x%08x\n", error->vcs_instdone);
    seq_printf(m, "  seqno:    0x%08x\n", error->vcs_seqno);
    }
  } else {
  }
  {
  seq_printf(m, "Render command stream:\n");
  seq_printf(m, "  ACTHD: 0x%08x\n", error->acthd);
  seq_printf(m, "  IPEIR: 0x%08x\n", error->ipeir);
  seq_printf(m, "  IPEHR: 0x%08x\n", error->ipehr);
  seq_printf(m, "  INSTDONE: 0x%08x\n", error->instdone);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    {
    seq_printf(m, "  INSTDONE1: 0x%08x\n", error->instdone1);
    seq_printf(m, "  INSTPS: 0x%08x\n", error->instps);
    }
  } else {
  }
  {
  seq_printf(m, "  INSTPM: 0x%08x\n", error->instpm);
  seq_printf(m, "  seqno: 0x%08x\n", error->seqno);
  i = 0;
  }
  goto ldv_37997;
  ldv_37996:
  {
  seq_printf(m, "  fence[%d] = %08llx\n", i, error->fence[i]);
  i = i + 1;
  }
  ldv_37997: ;
  if (dev_priv->num_fence_regs > i) {
    goto ldv_37996;
  } else {
    goto ldv_37998;
  }
  ldv_37998: ;
  if ((unsigned long )error->active_bo != (unsigned long )((struct drm_i915_error_buffer *)0)) {
    {
    print_error_buffers(m, "Active", error->active_bo, (int )error->active_bo_count);
    }
  } else {
  }
  if ((unsigned long )error->pinned_bo != (unsigned long )((struct drm_i915_error_buffer *)0)) {
    {
    print_error_buffers(m, "Pinned", error->pinned_bo, (int )error->pinned_bo_count);
    }
  } else {
  }
  i = 0;
  goto ldv_38009;
  ldv_38008: ;
  if ((unsigned long )error->batchbuffer[i] != (unsigned long )((struct drm_i915_error_object *)0)) {
    {
    obj = error->batchbuffer[i];
    seq_printf(m, "%s --- gtt_offset = 0x%08x\n", dev_priv->ring[i].name, obj->gtt_offset);
    offset = 0;
    page = 0;
    }
    goto ldv_38006;
    ldv_38005:
    elt = 0;
    goto ldv_38003;
    ldv_38002:
    {
    seq_printf(m, "%08x :  %08x\n", offset, *(obj->pages[page] + (unsigned long )elt));
    offset = offset + 4;
    elt = elt + 1;
    }
    ldv_38003: ;
    if ((unsigned int )elt <= 1023U) {
      goto ldv_38002;
    } else {
      goto ldv_38004;
    }
    ldv_38004:
    page = page + 1;
    ldv_38006: ;
    if (obj->page_count > page) {
      goto ldv_38005;
    } else {
      goto ldv_38007;
    }
    ldv_38007: ;
  } else {
  }
  i = i + 1;
  ldv_38009: ;
  if ((unsigned int )i <= 2U) {
    goto ldv_38008;
  } else {
    goto ldv_38010;
  }
  ldv_38010:
  i = 0;
  goto ldv_38021;
  ldv_38020: ;
  if ((unsigned long )error->ringbuffer[i] != (unsigned long )((struct drm_i915_error_object *)0)) {
    {
    obj___0 = error->ringbuffer[i];
    seq_printf(m, "%s --- ringbuffer = 0x%08x\n", dev_priv->ring[i].name, obj___0->gtt_offset);
    offset = 0;
    page = 0;
    }
    goto ldv_38018;
    ldv_38017:
    elt = 0;
    goto ldv_38015;
    ldv_38014:
    {
    seq_printf(m, "%08x :  %08x\n", offset, *(obj___0->pages[page] + (unsigned long )elt));
    offset = offset + 4;
    elt = elt + 1;
    }
    ldv_38015: ;
    if ((unsigned int )elt <= 1023U) {
      goto ldv_38014;
    } else {
      goto ldv_38016;
    }
    ldv_38016:
    page = page + 1;
    ldv_38018: ;
    if (obj___0->page_count > page) {
      goto ldv_38017;
    } else {
      goto ldv_38019;
    }
    ldv_38019: ;
  } else {
  }
  i = i + 1;
  ldv_38021: ;
  if ((unsigned int )i <= 2U) {
    goto ldv_38020;
  } else {
    goto ldv_38022;
  }
  ldv_38022: ;
  if ((unsigned long )error->overlay != (unsigned long )((struct intel_overlay_error_state *)0)) {
    {
    intel_overlay_print_error_state(m, error->overlay);
    }
  } else {
  }
  if ((unsigned long )error->display != (unsigned long )((struct intel_display_error_state *)0)) {
    {
    intel_display_print_error_state(m, dev, error->display);
    }
  } else {
  }
  out:
  {
  spin_unlock_irqrestore(& dev_priv->error_lock, flags);
  }
  return (0);
}
}
static int i915_rstdby_delays(struct seq_file *m , void *unused )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  u16 crstanddelay ;
  u16 tmp ;
  {
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = i915_read16___0(dev_priv, 69888U);
  crstanddelay = tmp;
  seq_printf(m, "w/ctx: %d, w/o ctx: %d\n", ((int )crstanddelay >> 8) & 63, (int )crstanddelay & 63);
  }
  return (0);
}
}
static int i915_cur_delayinfo(struct seq_file *m , void *unused )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  int ret ;
  u16 rgvswctl ;
  u16 tmp ;
  u16 rgvstat ;
  u16 tmp___0 ;
  u32 gt_perf_status ;
  u32 tmp___1 ;
  u32 rp_state_limits ;
  u32 tmp___2 ;
  u32 rp_state_cap ;
  u32 tmp___3 ;
  u32 rpstat ;
  u32 rpupei ;
  u32 rpcurup ;
  u32 rpprevup ;
  u32 rpdownei ;
  u32 rpcurdown ;
  u32 rpprevdown ;
  int max_freq ;
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    tmp = i915_read16___0(dev_priv, 70000U);
    rgvswctl = tmp;
    tmp___0 = i915_read16___0(dev_priv, 70136U);
    rgvstat = tmp___0;
    seq_printf(m, "Requested P-state: %d\n", ((int )rgvswctl >> 8) & 15);
    seq_printf(m, "Requested VID: %d\n", (int )rgvswctl & 63);
    seq_printf(m, "Current VID: %d\n", ((int )rgvstat & 32512) >> 8);
    seq_printf(m, "Current P-state: %d\n", ((int )rgvstat & 248) >> 3);
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    tmp___1 = i915_read32___2(dev_priv, 1333576U);
    gt_perf_status = tmp___1;
    tmp___2 = i915_read32___2(dev_priv, 1333652U);
    rp_state_limits = tmp___2;
    tmp___3 = i915_read32___2(dev_priv, 1333656U);
    rp_state_cap = tmp___3;
    ret = mutex_lock_interruptible_nested(& dev->struct_mutex, 0U);
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
    {
    gen6_gt_force_wake_get(dev_priv);
    rpstat = i915_read32___2(dev_priv, 40988U);
    rpupei = i915_read32___2(dev_priv, 41040U);
    rpcurup = i915_read32___2(dev_priv, 41044U);
    rpprevup = i915_read32___2(dev_priv, 41048U);
    rpdownei = i915_read32___2(dev_priv, 41052U);
    rpcurdown = i915_read32___2(dev_priv, 41056U);
    rpprevdown = i915_read32___2(dev_priv, 41060U);
    gen6_gt_force_wake_put(dev_priv);
    mutex_unlock(& dev->struct_mutex);
    seq_printf(m, "GT_PERF_STATUS: 0x%08x\n", gt_perf_status);
    seq_printf(m, "RPSTAT1: 0x%08x\n", rpstat);
    seq_printf(m, "Render p-state ratio: %d\n", (gt_perf_status & 65280U) >> 8);
    seq_printf(m, "Render p-state VID: %d\n", gt_perf_status & 255U);
    seq_printf(m, "Render p-state limit: %d\n", rp_state_limits & 255U);
    seq_printf(m, "CAGF: %dMHz\n", ((rpstat & 32512U) >> 8) * 50U);
    seq_printf(m, "RP CUR UP EI: %dus\n", rpupei & 16777215U);
    seq_printf(m, "RP CUR UP: %dus\n", rpcurup & 16777215U);
    seq_printf(m, "RP PREV UP: %dus\n", rpprevup & 16777215U);
    seq_printf(m, "RP CUR DOWN EI: %dus\n", rpdownei & 16777215U);
    seq_printf(m, "RP CUR DOWN: %dus\n", rpcurdown & 16777215U);
    seq_printf(m, "RP PREV DOWN: %dus\n", rpprevdown & 16777215U);
    max_freq = (int )((rp_state_cap & 16711680U) >> 16);
    seq_printf(m, "Lowest (RPN) frequency: %dMHz\n", max_freq * 50);
    max_freq = (int )((rp_state_cap & 65280U) >> 8);
    seq_printf(m, "Nominal (RP1) frequency: %dMHz\n", max_freq * 50);
    max_freq = (int )rp_state_cap & 255;
    seq_printf(m, "Max non-overclocked (RP0) frequency: %dMHz\n", max_freq * 50);
    }
  } else {
    {
    seq_printf(m, "no P-state info available\n");
    }
  }
  return (0);
}
}
static int i915_delayfreq_table(struct seq_file *m , void *unused )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  u32 delayfreq ;
  int i ;
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  i = 0;
  goto ldv_38062;
  ldv_38061:
  {
  delayfreq = i915_read32___2(dev_priv, (u32 )((i + 17476) * 4));
  seq_printf(m, "P%02dVIDFREQ: 0x%08x (VID: %d)\n", i, delayfreq, (delayfreq & 2130706432U) >> 24);
  i = i + 1;
  }
  ldv_38062: ;
  if (i <= 15) {
    goto ldv_38061;
  } else {
    goto ldv_38063;
  }
  ldv_38063: ;
  return (0);
}
}
static int i915_inttoext_table(struct seq_file *m , void *unused )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  u32 inttoext ;
  int i ;
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  i = 1;
  goto ldv_38077;
  ldv_38076:
  {
  inttoext = i915_read32___2(dev_priv, (u32 )((i + 17600) * 4));
  seq_printf(m, "INTTOEXT%02d: 0x%08x\n", i, inttoext);
  i = i + 1;
  }
  ldv_38077: ;
  if (i <= 32) {
    goto ldv_38076;
  } else {
    goto ldv_38078;
  }
  ldv_38078: ;
  return (0);
}
}
static int i915_drpc_info(struct seq_file *m , void *unused )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  u32 rgvmodectl ;
  u32 tmp ;
  u32 rstdbyctl ;
  u32 tmp___0 ;
  u16 crstandvid ;
  u16 tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  {
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = i915_read32___2(dev_priv, 70032U);
  rgvmodectl = tmp;
  tmp___0 = i915_read32___2(dev_priv, 70072U);
  rstdbyctl = tmp___0;
  tmp___1 = i915_read16___0(dev_priv, 69888U);
  crstandvid = tmp___1;
  }
  if ((int )rgvmodectl < 0) {
    tmp___2 = (char *)"yes";
  } else {
    tmp___2 = (char *)"no";
  }
  {
  seq_printf(m, "HD boost: %s\n", tmp___2);
  seq_printf(m, "Boost freq: %d\n", (rgvmodectl & 251658240U) >> 24);
  }
  if ((rgvmodectl & 32768U) != 0U) {
    tmp___3 = (char *)"yes";
  } else {
    tmp___3 = (char *)"no";
  }
  {
  seq_printf(m, "HW control enabled: %s\n", tmp___3);
  }
  if ((rgvmodectl & 16384U) != 0U) {
    tmp___4 = (char *)"yes";
  } else {
    tmp___4 = (char *)"no";
  }
  {
  seq_printf(m, "SW control enabled: %s\n", tmp___4);
  }
  if ((rgvmodectl & 8192U) != 0U) {
    tmp___5 = (char *)"yes";
  } else {
    tmp___5 = (char *)"no";
  }
  {
  seq_printf(m, "Gated voltage change: %s\n", tmp___5);
  seq_printf(m, "Starting frequency: P%d\n", (rgvmodectl & 3840U) >> 8);
  seq_printf(m, "Max P-state: P%d\n", (rgvmodectl & 240U) >> 4);
  seq_printf(m, "Min P-state: P%d\n", rgvmodectl & 15U);
  seq_printf(m, "RS1 VID: %d\n", (int )crstandvid & 63);
  seq_printf(m, "RS2 VID: %d\n", ((int )crstandvid >> 8) & 63);
  }
  if ((rstdbyctl & 8388608U) != 0U) {
    tmp___6 = (char *)"no";
  } else {
    tmp___6 = (char *)"yes";
  }
  {
  seq_printf(m, "Render standby enabled: %s\n", tmp___6);
  seq_printf(m, "Current RS state: ");
  }
  if ((int )(rstdbyctl & 7340032U) == 0) {
    goto case_0;
  } else
  if ((int )(rstdbyctl & 7340032U) == 1048576) {
    goto case_1048576;
  } else
  if ((int )(rstdbyctl & 7340032U) == 2097152) {
    goto case_2097152;
  } else
  if ((int )(rstdbyctl & 7340032U) == 3145728) {
    goto case_3145728;
  } else
  if ((int )(rstdbyctl & 7340032U) == 4194304) {
    goto case_4194304;
  } else
  if ((int )(rstdbyctl & 7340032U) == 6291456) {
    goto case_6291456;
  } else {
    goto switch_default;
    if (0) {
      case_0:
      {
      seq_printf(m, "on\n");
      }
      goto ldv_38090;
      case_1048576:
      {
      seq_printf(m, "RC1\n");
      }
      goto ldv_38090;
      case_2097152:
      {
      seq_printf(m, "RC1E\n");
      }
      goto ldv_38090;
      case_3145728:
      {
      seq_printf(m, "RS1\n");
      }
      goto ldv_38090;
      case_4194304:
      {
      seq_printf(m, "RS2 (RC6)\n");
      }
      goto ldv_38090;
      case_6291456:
      {
      seq_printf(m, "RC3 (RC6+)\n");
      }
      goto ldv_38090;
      switch_default:
      {
      seq_printf(m, "unknown\n");
      }
      goto ldv_38090;
    } else {
    }
  }
  ldv_38090: ;
  return (0);
}
}
static int i915_fbc_status(struct seq_file *m , void *unused )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  bool tmp ;
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) == 0U) {
    {
    seq_printf(m, "FBC unsupported on this chipset\n");
    }
    return (0);
  } else {
  }
  {
  tmp = intel_fbc_enabled(dev);
  }
  if ((int )tmp) {
    {
    seq_printf(m, "FBC enabled\n");
    }
  } else {
    {
    seq_printf(m, "FBC disabled: ");
    }
    if ((int )((unsigned int )dev_priv->no_fbc_reason) == 0) {
      goto case_0;
    } else
    if ((int )((unsigned int )dev_priv->no_fbc_reason) == 1) {
      goto case_1;
    } else
    if ((int )((unsigned int )dev_priv->no_fbc_reason) == 2) {
      goto case_2;
    } else
    if ((int )((unsigned int )dev_priv->no_fbc_reason) == 3) {
      goto case_3;
    } else
    if ((int )((unsigned int )dev_priv->no_fbc_reason) == 4) {
      goto case_4;
    } else
    if ((int )((unsigned int )dev_priv->no_fbc_reason) == 5) {
      goto case_5;
    } else
    if ((int )((unsigned int )dev_priv->no_fbc_reason) == 6) {
      goto case_6;
    } else
    if ((int )((unsigned int )dev_priv->no_fbc_reason) == 7) {
      goto case_7;
    } else {
      goto switch_default;
      if (0) {
        case_0:
        {
        seq_printf(m, "no outputs");
        }
        goto ldv_38105;
        case_1:
        {
        seq_printf(m, "not enough stolen memory");
        }
        goto ldv_38105;
        case_2:
        {
        seq_printf(m, "mode not supported");
        }
        goto ldv_38105;
        case_3:
        {
        seq_printf(m, "mode too large");
        }
        goto ldv_38105;
        case_4:
        {
        seq_printf(m, "FBC unsupported on plane");
        }
        goto ldv_38105;
        case_5:
        {
        seq_printf(m, "scanout buffer not tiled");
        }
        goto ldv_38105;
        case_6:
        {
        seq_printf(m, "multiple pipes are enabled");
        }
        goto ldv_38105;
        case_7:
        {
        seq_printf(m, "disabled per module param (default off)");
        }
        goto ldv_38105;
        switch_default:
        {
        seq_printf(m, "unknown reason");
        }
      } else {
      }
    }
    ldv_38105:
    {
    seq_printf(m, "\n");
    }
  }
  return (0);
}
}
static int i915_sr_status(struct seq_file *m , void *unused )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  bool sr_enabled ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  char *tmp___3 ;
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  sr_enabled = (bool )0;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    tmp = i915_read32___2(dev_priv, 282888U);
    sr_enabled = (bool )((tmp & 2147483648U) != 0U);
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    tmp = i915_read32___2(dev_priv, 282888U);
    sr_enabled = (bool )((tmp & 2147483648U) != 0U);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    tmp = i915_read32___2(dev_priv, 282888U);
    sr_enabled = (bool )((tmp & 2147483648U) != 0U);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    tmp___0 = i915_read32___2(dev_priv, 8416U);
    sr_enabled = (bool )((tmp___0 & 32768U) != 0U);
    }
  } else
  if (dev->pci_device == 10098) {
    {
    tmp___0 = i915_read32___2(dev_priv, 8416U);
    sr_enabled = (bool )((tmp___0 & 32768U) != 0U);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    {
    tmp___0 = i915_read32___2(dev_priv, 8416U);
    sr_enabled = (bool )((tmp___0 & 32768U) != 0U);
    }
  } else
  if (dev->pci_device == 9618) {
    {
    tmp___1 = i915_read32___2(dev_priv, 8384U);
    sr_enabled = (bool )((tmp___1 & 4096U) != 0U);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    {
    tmp___2 = i915_read32___2(dev_priv, 458812U);
    sr_enabled = (bool )((tmp___2 & 1073741824U) != 0U);
    }
  } else {
  }
  if ((int )sr_enabled) {
    tmp___3 = (char *)"enabled";
  } else {
    tmp___3 = (char *)"disabled";
  }
  {
  seq_printf(m, "self-refresh: %s\n", tmp___3);
  }
  return (0);
}
}
static int i915_emon_status(struct seq_file *m , void *unused )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  unsigned long temp ;
  unsigned long chipset ;
  unsigned long gfx ;
  int ret ;
  {
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ret = mutex_lock_interruptible_nested(& dev->struct_mutex, 0U);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  temp = i915_mch_val(dev_priv);
  chipset = i915_chipset_val(dev_priv);
  gfx = i915_gfx_val(dev_priv);
  mutex_unlock(& dev->struct_mutex);
  seq_printf(m, "GMCH temp: %ld\n", temp);
  seq_printf(m, "Chipset power: %ld\n", chipset);
  seq_printf(m, "GFX power: %ld\n", gfx);
  seq_printf(m, "Total power: %ld\n", chipset + gfx);
  }
  return (0);
}
}
static int i915_gfxec(struct seq_file *m , void *unused )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  u32 tmp ;
  {
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = i915_read32___2(dev_priv, 70388U);
  seq_printf(m, "GFXEC: %ld\n", (unsigned long )tmp);
  }
  return (0);
}
}
static int i915_opregion(struct seq_file *m , void *unused )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  struct intel_opregion *opregion ;
  int ret ;
  {
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  opregion = & dev_priv->opregion;
  ret = mutex_lock_interruptible_nested(& dev->struct_mutex, 0U);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  if ((unsigned long )opregion->header != (unsigned long )((struct opregion_header *)0)) {
    {
    seq_write(m, (void const *)opregion->header, 8192UL);
    }
  } else {
  }
  {
  mutex_unlock(& dev->struct_mutex);
  }
  return (0);
}
}
static int i915_gem_framebuffer_info(struct seq_file *m , void *data )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  struct intel_fbdev *ifbdev ;
  struct intel_framebuffer *fb ;
  int ret ;
  struct drm_framebuffer const *__mptr ;
  struct list_head const *__mptr___0 ;
  struct list_head const *__mptr___1 ;
  {
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ret = mutex_lock_interruptible_nested(& dev->mode_config.mutex, 0U);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  ifbdev = dev_priv->fbdev;
  __mptr = (struct drm_framebuffer const *)ifbdev->helper.fb;
  fb = (struct intel_framebuffer *)__mptr;
  seq_printf(m, "fbcon size: %d x %d, depth %d, %d bpp, obj ", fb->base.width, fb->base.height,
             fb->base.depth, fb->base.bits_per_pixel);
  describe_obj(m, fb->obj);
  seq_printf(m, "\n");
  __mptr___0 = (struct list_head const *)dev->mode_config.fb_list.next;
  fb = (struct intel_framebuffer *)__mptr___0 + 0x0ffffffffffffff8UL;
  }
  goto ldv_38167;
  ldv_38166: ;
  if ((unsigned long )(& fb->base) == (unsigned long )ifbdev->helper.fb) {
    goto ldv_38165;
  } else {
  }
  {
  seq_printf(m, "user size: %d x %d, depth %d, %d bpp, obj ", fb->base.width, fb->base.height,
             fb->base.depth, fb->base.bits_per_pixel);
  describe_obj(m, fb->obj);
  seq_printf(m, "\n");
  }
  ldv_38165:
  __mptr___1 = (struct list_head const *)fb->base.head.next;
  fb = (struct intel_framebuffer *)__mptr___1 + 0x0ffffffffffffff8UL;
  ldv_38167: ;
  if ((unsigned long )(& fb->base.head) != (unsigned long )(& dev->mode_config.fb_list)) {
    goto ldv_38166;
  } else {
    goto ldv_38168;
  }
  ldv_38168:
  {
  mutex_unlock(& dev->mode_config.mutex);
  }
  return (0);
}
}
static int i915_context_status(struct seq_file *m , void *unused )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  int ret ;
  {
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ret = mutex_lock_interruptible_nested(& dev->mode_config.mutex, 0U);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  if ((unsigned long )dev_priv->pwrctx != (unsigned long )((struct drm_i915_gem_object *)0)) {
    {
    seq_printf(m, "power context ");
    describe_obj(m, dev_priv->pwrctx);
    seq_printf(m, "\n");
    }
  } else {
  }
  if ((unsigned long )dev_priv->renderctx != (unsigned long )((struct drm_i915_gem_object *)0)) {
    {
    seq_printf(m, "render context ");
    describe_obj(m, dev_priv->renderctx);
    seq_printf(m, "\n");
    }
  } else {
  }
  {
  mutex_unlock(& dev->mode_config.mutex);
  }
  return (0);
}
}
static int i915_gen6_forcewake_count_info(struct seq_file *m , void *data )
{ struct drm_info_node *node ;
  struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  int tmp ;
  {
  {
  node = (struct drm_info_node *)m->private;
  dev = (node->minor)->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = atomic_read((atomic_t const *)(& dev_priv->forcewake_count));
  seq_printf(m, "forcewake count = %d\n", tmp);
  }
  return (0);
}
}
static int i915_wedged_open(struct inode *inode , struct file *filp )
{
  {
  filp->private_data = inode->i_private;
  return (0);
}
}
static ssize_t i915_wedged_read(struct file *filp , char *ubuf , size_t max , loff_t *ppos )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  char buf[80U] ;
  int len ;
  int tmp ;
  ssize_t tmp___0 ;
  {
  {
  dev = (struct drm_device *)filp->private_data;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = atomic_read((atomic_t const *)(& dev_priv->mm.wedged));
  len = snprintf((char *)(& buf), 80UL, "wedged :  %d\n", tmp);
  }
  if ((unsigned int )len > 80U) {
    len = 80;
  } else {
  }
  {
  tmp___0 = simple_read_from_buffer((void *)ubuf, max, ppos, (void const *)(& buf),
                                    (size_t )len);
  }
  return (tmp___0);
}
}
static ssize_t i915_wedged_write(struct file *filp , char const *ubuf , size_t cnt ,
                                 loff_t *ppos )
{ struct drm_device *dev ;
  char buf[20U] ;
  int val ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  {
  dev = (struct drm_device *)filp->private_data;
  val = 1;
  if (cnt != 0UL) {
    if (cnt > 19UL) {
      return (-22L);
    } else {
    }
    {
    tmp = copy_from_user((void *)(& buf), (void const *)ubuf, cnt);
    }
    if (tmp != 0UL) {
      return (-14L);
    } else {
    }
    {
    buf[cnt] = (char)0;
    tmp___0 = simple_strtoul((char const *)(& buf), (char **)0, 0U);
    val = (int )tmp___0;
    }
  } else {
  }
  {
  printk("<6>[drm] Manually setting wedged to %d\n", val);
  i915_handle_error(dev, (bool )(val != 0));
  }
  return ((ssize_t )cnt);
}
}
static struct file_operations const i915_wedged_fops =
     {& __this_module, & default_llseek, & i915_wedged_read, & i915_wedged_write, (ssize_t (*)(struct kiocb * ,
                                                                                             struct iovec const * ,
                                                                                             unsigned long ,
                                                                                             loff_t ))0,
    (ssize_t (*)(struct kiocb * , struct iovec const * , unsigned long , loff_t ))0,
    (int (*)(struct file * , void * , int (*)(void * , char const * , int , loff_t ,
                                              u64 , unsigned int ) ))0, (unsigned int (*)(struct file * ,
                                                                                            struct poll_table_struct * ))0,
    (long (*)(struct file * , unsigned int , unsigned long ))0, (long (*)(struct file * ,
                                                                            unsigned int ,
                                                                            unsigned long ))0,
    (int (*)(struct file * , struct vm_area_struct * ))0, & i915_wedged_open, (int (*)(struct file * ,
                                                                                       fl_owner_t ))0,
    (int (*)(struct inode * , struct file * ))0, (int (*)(struct file * , int ))0,
    (int (*)(struct kiocb * , int ))0, (int (*)(int , struct file * , int ))0,
    (int (*)(struct file * , int , struct file_lock * ))0, (ssize_t (*)(struct file * ,
                                                                         struct page * ,
                                                                         int , size_t ,
                                                                         loff_t * ,
                                                                         int ))0,
    (unsigned long (*)(struct file * , unsigned long , unsigned long , unsigned long ,
                       unsigned long ))0, (int (*)(int ))0, (int (*)(struct file * ,
                                                                       int , struct file_lock * ))0,
    (ssize_t (*)(struct pipe_inode_info * , struct file * , loff_t * , size_t , unsigned int ))0,
    (ssize_t (*)(struct file * , loff_t * , struct pipe_inode_info * , size_t , unsigned int ))0,
    (int (*)(struct file * , long , struct file_lock ** ))0, (long (*)(struct file * ,
                                                                        int , loff_t ,
                                                                        loff_t ))0};
static int drm_add_fake_info_node(struct drm_minor *minor , struct dentry *ent , void const *key )
{ struct drm_info_node *node ;
  void *tmp ;
  {
  {
  tmp = kmalloc(40UL, 208U);
  node = (struct drm_info_node *)tmp;
  }
  if ((unsigned long )node == (unsigned long )((struct drm_info_node *)0)) {
    {
    debugfs_remove(ent);
    }
    return (-12);
  } else {
  }
  {
  node->minor = minor;
  node->dent = ent;
  node->info_ent = (struct drm_info_list *)key;
  list_add(& node->list, & minor->debugfs_nodes.list);
  }
  return (0);
}
}
static int i915_wedged_create(struct dentry *root , struct drm_minor *minor )
{ struct drm_device *dev ;
  struct dentry *ent ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  {
  {
  dev = minor->dev;
  ent = debugfs_create_file("i915_wedged", 420U, root, (void *)dev, & i915_wedged_fops);
  tmp___0 = IS_ERR((void const *)ent);
  }
  if (tmp___0 != 0L) {
    {
    tmp = PTR_ERR((void const *)ent);
    }
    return ((int )tmp);
  } else {
  }
  {
  tmp___1 = drm_add_fake_info_node(minor, ent, (void const *)(& i915_wedged_fops));
  }
  return (tmp___1);
}
}
static int i915_forcewake_open(struct inode *inode , struct file *file )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  int ret ;
  {
  dev = (struct drm_device *)inode->i_private;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 6U) {
    return (0);
  } else {
  }
  {
  ret = mutex_lock_interruptible_nested(& dev->struct_mutex, 0U);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  gen6_gt_force_wake_get(dev_priv);
  mutex_unlock(& dev->struct_mutex);
  }
  return (0);
}
}
int i915_forcewake_release(struct inode *inode , struct file *file )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  {
  dev = (struct drm_device *)inode->i_private;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 6U) {
    return (0);
  } else {
  }
  {
  mutex_lock_nested(& dev->struct_mutex, 0U);
  gen6_gt_force_wake_put(dev_priv);
  mutex_unlock(& dev->struct_mutex);
  }
  return (0);
}
}
static struct file_operations const i915_forcewake_fops =
     {& __this_module, (loff_t (*)(struct file * , loff_t , int ))0, (ssize_t (*)(struct file * ,
                                                                                  char * ,
                                                                                  size_t ,
                                                                                  loff_t * ))0,
    (ssize_t (*)(struct file * , char const * , size_t , loff_t * ))0, (ssize_t (*)(struct kiocb * ,
                                                                                       struct iovec const * ,
                                                                                       unsigned long ,
                                                                                       loff_t ))0,
    (ssize_t (*)(struct kiocb * , struct iovec const * , unsigned long , loff_t ))0,
    (int (*)(struct file * , void * , int (*)(void * , char const * , int , loff_t ,
                                              u64 , unsigned int ) ))0, (unsigned int (*)(struct file * ,
                                                                                            struct poll_table_struct * ))0,
    (long (*)(struct file * , unsigned int , unsigned long ))0, (long (*)(struct file * ,
                                                                            unsigned int ,
                                                                            unsigned long ))0,
    (int (*)(struct file * , struct vm_area_struct * ))0, & i915_forcewake_open, (int (*)(struct file * ,
                                                                                          fl_owner_t ))0,
    & i915_forcewake_release, (int (*)(struct file * , int ))0, (int (*)(struct kiocb * ,
                                                                          int ))0,
    (int (*)(int , struct file * , int ))0, (int (*)(struct file * , int , struct file_lock * ))0,
    (ssize_t (*)(struct file * , struct page * , int , size_t , loff_t * , int ))0,
    (unsigned long (*)(struct file * , unsigned long , unsigned long , unsigned long ,
                       unsigned long ))0, (int (*)(int ))0, (int (*)(struct file * ,
                                                                       int , struct file_lock * ))0,
    (ssize_t (*)(struct pipe_inode_info * , struct file * , loff_t * , size_t , unsigned int ))0,
    (ssize_t (*)(struct file * , loff_t * , struct pipe_inode_info * , size_t , unsigned int ))0,
    (int (*)(struct file * , long , struct file_lock ** ))0, (long (*)(struct file * ,
                                                                        int , loff_t ,
                                                                        loff_t ))0};
static int i915_forcewake_create(struct dentry *root , struct drm_minor *minor )
{ struct drm_device *dev ;
  struct dentry *ent ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  {
  {
  dev = minor->dev;
  ent = debugfs_create_file("i915_forcewake_user", 256U, root, (void *)dev, & i915_forcewake_fops);
  tmp___0 = IS_ERR((void const *)ent);
  }
  if (tmp___0 != 0L) {
    {
    tmp = PTR_ERR((void const *)ent);
    }
    return ((int )tmp);
  } else {
  }
  {
  tmp___1 = drm_add_fake_info_node(minor, ent, (void const *)(& i915_forcewake_fops));
  }
  return (tmp___1);
}
}
static struct drm_info_list i915_debugfs_list[37U] =
  { {"i915_capabilities", & i915_capabilities, 0U, (void *)0},
        {"i915_gem_objects", & i915_gem_object_info, 0U, (void *)0},
        {"i915_gem_gtt", & i915_gem_gtt_info, 0U, (void *)0},
        {"i915_gem_active", & i915_gem_object_list_info, 0U, (void *)0},
        {"i915_gem_flushing", & i915_gem_object_list_info, 0U, (void *)1},
        {"i915_gem_inactive", & i915_gem_object_list_info, 0U, (void *)2},
        {"i915_gem_pinned", & i915_gem_object_list_info, 0U, (void *)3},
        {"i915_gem_deferred_free", & i915_gem_object_list_info, 0U, (void *)4},
        {"i915_gem_pageflip", & i915_gem_pageflip_info, 0U, (void *)0},
        {"i915_gem_request", & i915_gem_request_info, 0U, (void *)0},
        {"i915_gem_seqno", & i915_gem_seqno_info, 0U, (void *)0},
        {"i915_gem_fence_regs", & i915_gem_fence_regs_info, 0U, (void *)0},
        {"i915_gem_interrupt", & i915_interrupt_info, 0U, (void *)0},
        {"i915_gem_hws", & i915_hws_info, 0U, (void *)0},
        {"i915_gem_hws_blt", & i915_hws_info, 0U, (void *)2},
        {"i915_gem_hws_bsd", & i915_hws_info, 0U, (void *)1},
        {"i915_ringbuffer_data", & i915_ringbuffer_data, 0U, (void *)0},
        {"i915_ringbuffer_info", & i915_ringbuffer_info, 0U, (void *)0},
        {"i915_bsd_ringbuffer_data", & i915_ringbuffer_data, 0U, (void *)1},
        {"i915_bsd_ringbuffer_info", & i915_ringbuffer_info, 0U, (void *)1},
        {"i915_blt_ringbuffer_data", & i915_ringbuffer_data, 0U, (void *)2},
        {"i915_blt_ringbuffer_info", & i915_ringbuffer_info, 0U, (void *)2},
        {"i915_batchbuffers", & i915_batchbuffer_info, 0U, (void *)0},
        {"i915_error_state", & i915_error_state, 0U, (void *)0},
        {"i915_rstdby_delays", & i915_rstdby_delays, 0U, (void *)0},
        {"i915_cur_delayinfo", & i915_cur_delayinfo, 0U, (void *)0},
        {"i915_delayfreq_table", & i915_delayfreq_table, 0U, (void *)0},
        {"i915_inttoext_table", & i915_inttoext_table, 0U, (void *)0},
        {"i915_drpc_info", & i915_drpc_info, 0U, (void *)0},
        {"i915_emon_status", & i915_emon_status, 0U, (void *)0},
        {"i915_gfxec", & i915_gfxec, 0U, (void *)0},
        {"i915_fbc_status", & i915_fbc_status, 0U, (void *)0},
        {"i915_sr_status", & i915_sr_status, 0U, (void *)0},
        {"i915_opregion", & i915_opregion, 0U, (void *)0},
        {"i915_gem_framebuffer", & i915_gem_framebuffer_info, 0U, (void *)0},
        {"i915_context_status", & i915_context_status, 0U, (void *)0},
        {"i915_gen6_forcewake_count", & i915_gen6_forcewake_count_info, 0U, (void *)0}};
int i915_debugfs_init(struct drm_minor *minor )
{ int ret ;
  int tmp ;
  {
  {
  ret = i915_wedged_create(minor->debugfs_root, minor);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  ret = i915_forcewake_create(minor->debugfs_root, minor);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  tmp = drm_debugfs_create_files((struct drm_info_list *)(& i915_debugfs_list), 37,
                                 minor->debugfs_root, minor);
  }
  return (tmp);
}
}
void i915_debugfs_cleanup(struct drm_minor *minor )
{
  {
  {
  drm_debugfs_remove_files((struct drm_info_list *)(& i915_debugfs_list), 37, minor);
  drm_debugfs_remove_files((struct drm_info_list *)(& i915_forcewake_fops), 1, minor);
  drm_debugfs_remove_files((struct drm_info_list *)(& i915_wedged_fops), 1, minor);
  }
  return;
}
}
__inline static void writeb(unsigned char val , void volatile *addr )
{
  {
  __asm__ volatile ("movb %0,%1": : "q" (val), "m" (*((unsigned char volatile *)addr)): "memory");
  return;
}
}
__inline static void writeq(unsigned long val , void volatile *addr )
{
  {
  __asm__ volatile ("movq %0,%1": : "r" (val), "m" (*((unsigned long volatile *)addr)): "memory");
  return;
}
}
void intel_i2c_reset(struct drm_device *dev ) ;
void i8xx_disable_fbc(struct drm_device *dev ) ;
void g4x_disable_fbc(struct drm_device *dev ) ;
void ironlake_disable_fbc(struct drm_device *dev ) ;
__inline static u8 i915_read8___0(struct drm_i915_private *dev_priv , u32 reg )
{ u8 val ;
  {
  val = (u8 )0U;
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        gen6_gt_force_wake_get(dev_priv);
        val = readb((void const volatile *)dev_priv->regs + (unsigned long )reg);
        gen6_gt_force_wake_put(dev_priv);
        }
      } else {
        {
        val = readb((void const volatile *)dev_priv->regs + (unsigned long )reg);
        }
      }
    } else {
      {
      val = readb((void const volatile *)dev_priv->regs + (unsigned long )reg);
      }
    }
  } else {
    {
    val = readb((void const volatile *)dev_priv->regs + (unsigned long )reg);
    }
  }
  {
  trace_i915_reg_rw((bool )0, reg, (u64 )val, 1);
  }
  return (val);
}
}
__inline static void i915_write8(struct drm_i915_private *dev_priv , u32 reg , u8 val )
{
  {
  {
  trace_i915_reg_rw((bool )1, reg, (u64 )val, 1);
  }
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        __gen6_gt_wait_for_fifo(dev_priv);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  writeb((unsigned char )((int )val), (void volatile *)dev_priv->regs + (unsigned long )reg);
  }
  return;
}
}
__inline static void i915_write64(struct drm_i915_private *dev_priv , u32 reg , u64 val )
{
  {
  {
  trace_i915_reg_rw((bool )1, reg, val, 8);
  }
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        __gen6_gt_wait_for_fifo(dev_priv);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  writeq((unsigned long )val, (void volatile *)dev_priv->regs + (unsigned long )reg);
  }
  return;
}
}
void ironlake_enable_drps(struct drm_device *dev ) ;
void ironlake_disable_drps(struct drm_device *dev ) ;
void gen6_enable_rps(struct drm_i915_private *dev_priv ) ;
void gen6_disable_rps(struct drm_device *dev ) ;
void intel_init_emon(struct drm_device *dev ) ;
void intel_init_clock_gating(struct drm_device *dev ) ;
static bool i915_pipe_enabled___0(struct drm_device *dev , enum pipe pipe )
{ struct drm_i915_private *dev_priv ;
  u32 dpll_reg ;
  u32 tmp ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    goto _L;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    goto _L;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    _L:
    if ((unsigned int )pipe == 0U) {
      dpll_reg = 811028U;
    } else {
      dpll_reg = 811032U;
    }
  } else
  if ((unsigned int )pipe == 0U) {
    dpll_reg = 24596U;
  } else {
    dpll_reg = 24600U;
  }
  {
  tmp = i915_read32(dev_priv, dpll_reg);
  }
  return ((bool )((tmp & 2147483648U) != 0U));
}
}
static void i915_save_palette(struct drm_device *dev , enum pipe pipe )
{ struct drm_i915_private *dev_priv ;
  unsigned long reg ;
  unsigned long tmp ;
  u32 *array ;
  int i ;
  bool tmp___0 ;
  int tmp___1 ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned int )pipe == 0U) {
    tmp = 40960UL;
  } else {
    tmp = 43008UL;
  }
  {
  reg = tmp;
  tmp___0 = i915_pipe_enabled___0(dev, pipe);
  }
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return;
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    goto _L;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    goto _L;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    _L:
    if ((unsigned int )pipe == 0U) {
      reg = 303104UL;
    } else {
      reg = 305152UL;
    }
  } else {
  }
  if ((unsigned int )pipe == 0U) {
    array = (u32 *)(& dev_priv->save_palette_a);
  } else {
    array = (u32 *)(& dev_priv->save_palette_b);
  }
  i = 0;
  goto ldv_37563;
  ldv_37562:
  {
  *(array + (unsigned long )i) = i915_read32(dev_priv, (u32 )(i << 2) + (u32 )reg);
  i = i + 1;
  }
  ldv_37563: ;
  if (i <= 255) {
    goto ldv_37562;
  } else {
    goto ldv_37564;
  }
  ldv_37564: ;
  return;
}
}
static void i915_restore_palette(struct drm_device *dev , enum pipe pipe )
{ struct drm_i915_private *dev_priv ;
  unsigned long reg ;
  unsigned long tmp ;
  u32 *array ;
  int i ;
  bool tmp___0 ;
  int tmp___1 ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned int )pipe == 0U) {
    tmp = 40960UL;
  } else {
    tmp = 43008UL;
  }
  {
  reg = tmp;
  tmp___0 = i915_pipe_enabled___0(dev, pipe);
  }
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return;
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    goto _L;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    goto _L;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    _L:
    if ((unsigned int )pipe == 0U) {
      reg = 303104UL;
    } else {
      reg = 305152UL;
    }
  } else {
  }
  if ((unsigned int )pipe == 0U) {
    array = (u32 *)(& dev_priv->save_palette_a);
  } else {
    array = (u32 *)(& dev_priv->save_palette_b);
  }
  i = 0;
  goto ldv_37574;
  ldv_37573:
  {
  i915_write32(dev_priv, (u32 )(i << 2) + (u32 )reg, *(array + (unsigned long )i));
  i = i + 1;
  }
  ldv_37574: ;
  if (i <= 255) {
    goto ldv_37573;
  } else {
    goto ldv_37575;
  }
  ldv_37575: ;
  return;
}
}
static u8 i915_read_indexed(struct drm_device *dev , u16 index_port , u16 data_port ,
                            u8 reg )
{ struct drm_i915_private *dev_priv ;
  u8 tmp ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  i915_write8(dev_priv, (u32 )index_port, (u8 )((int )reg));
  tmp = i915_read8___0(dev_priv, (u32 )data_port);
  }
  return (tmp);
}
}
static u8 i915_read_ar(struct drm_device *dev , u16 st01 , u8 reg , u16 palette_enable )
{ struct drm_i915_private *dev_priv ;
  u8 tmp ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  i915_read8___0(dev_priv, (u32 )st01);
  i915_write8(dev_priv, 960U, (u8 )((int )((u8 )palette_enable) | (int )reg));
  tmp = i915_read8___0(dev_priv, 961U);
  }
  return (tmp);
}
}
static void i915_write_ar(struct drm_device *dev , u16 st01 , u8 reg , u8 val , u16 palette_enable )
{ struct drm_i915_private *dev_priv ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  i915_read8___0(dev_priv, (u32 )st01);
  i915_write8(dev_priv, 960U, (u8 )((int )((u8 )palette_enable) | (int )reg));
  i915_write8(dev_priv, 960U, (u8 )((int )val));
  }
  return;
}
}
static void i915_write_indexed(struct drm_device *dev , u16 index_port , u16 data_port ,
                               u8 reg , u8 val )
{ struct drm_i915_private *dev_priv ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  i915_write8(dev_priv, (u32 )index_port, (u8 )((int )reg));
  i915_write8(dev_priv, (u32 )data_port, (u8 )((int )val));
  }
  return;
}
}
static void i915_save_vga(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  int i ;
  u16 cr_index ;
  u16 cr_data ;
  u16 st01 ;
  u8 tmp ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  dev_priv->saveDACMASK = i915_read8___0(dev_priv, 966U);
  dev_priv->saveMSR = i915_read8___0(dev_priv, 972U);
  }
  if ((int )dev_priv->saveMSR & 1) {
    cr_index = (u16 )980U;
    cr_data = (u16 )981U;
    st01 = (u16 )986U;
  } else {
    cr_index = (u16 )948U;
    cr_data = (u16 )949U;
    st01 = (u16 )954U;
  }
  {
  tmp = i915_read_indexed(dev, (u16 )((int )cr_index), (u16 )((int )cr_data), (u8 )17);
  i915_write_indexed(dev, (u16 )((int )cr_index), (u16 )((int )cr_data), (u8 )17,
                     (u8 )((int )tmp & 127));
  i = 0;
  }
  goto ldv_37615;
  ldv_37614:
  {
  dev_priv->saveCR[i] = i915_read_indexed(dev, (u16 )((int )cr_index), (u16 )((int )cr_data),
                                          (u8 )((int )((u8 )i)));
  i = i + 1;
  }
  ldv_37615: ;
  if (i <= 36) {
    goto ldv_37614;
  } else {
    goto ldv_37616;
  }
  ldv_37616:
  {
  dev_priv->saveCR[17] = (u8 )((unsigned int )dev_priv->saveCR[17] & 127U);
  i915_read8___0(dev_priv, (u32 )st01);
  dev_priv->saveAR_INDEX = i915_read8___0(dev_priv, 960U);
  i = 0;
  }
  goto ldv_37618;
  ldv_37617:
  {
  dev_priv->saveAR[i] = i915_read_ar(dev, (u16 )((int )st01), (u8 )((int )((u8 )i)),
                                     (u16 )0);
  i = i + 1;
  }
  ldv_37618: ;
  if (i <= 20) {
    goto ldv_37617;
  } else {
    goto ldv_37619;
  }
  ldv_37619:
  {
  i915_read8___0(dev_priv, (u32 )st01);
  i915_write8(dev_priv, 960U, (u8 )((int )dev_priv->saveAR_INDEX));
  i915_read8___0(dev_priv, (u32 )st01);
  i = 0;
  }
  goto ldv_37621;
  ldv_37620:
  {
  dev_priv->saveGR[i] = i915_read_indexed(dev, (u16 )974, (u16 )975, (u8 )((int )((u8 )i)));
  i = i + 1;
  }
  ldv_37621: ;
  if (i <= 8) {
    goto ldv_37620;
  } else {
    goto ldv_37622;
  }
  ldv_37622:
  {
  dev_priv->saveGR[16] = i915_read_indexed(dev, (u16 )974, (u16 )975, (u8 )16);
  dev_priv->saveGR[17] = i915_read_indexed(dev, (u16 )974, (u16 )975, (u8 )17);
  dev_priv->saveGR[24] = i915_read_indexed(dev, (u16 )974, (u16 )975, (u8 )24);
  i = 0;
  }
  goto ldv_37624;
  ldv_37623:
  {
  dev_priv->saveSR[i] = i915_read_indexed(dev, (u16 )964, (u16 )965, (u8 )((int )((u8 )i)));
  i = i + 1;
  }
  ldv_37624: ;
  if (i <= 7) {
    goto ldv_37623;
  } else {
    goto ldv_37625;
  }
  ldv_37625: ;
  return;
}
}
static void i915_restore_vga(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  int i ;
  u16 cr_index ;
  u16 cr_data ;
  u16 st01 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  i915_write8(dev_priv, 962U, (u8 )((int )dev_priv->saveMSR));
  }
  if ((int )dev_priv->saveMSR & 1) {
    cr_index = (u16 )980U;
    cr_data = (u16 )981U;
    st01 = (u16 )986U;
  } else {
    cr_index = (u16 )948U;
    cr_data = (u16 )949U;
    st01 = (u16 )954U;
  }
  i = 0;
  goto ldv_37635;
  ldv_37634:
  {
  i915_write_indexed(dev, (u16 )964, (u16 )965, (u8 )((int )((u8 )i)), (u8 )((int )dev_priv->saveSR[i]));
  i = i + 1;
  }
  ldv_37635: ;
  if (i <= 6) {
    goto ldv_37634;
  } else {
    goto ldv_37636;
  }
  ldv_37636:
  {
  i915_write_indexed(dev, (u16 )((int )cr_index), (u16 )((int )cr_data), (u8 )17,
                     (u8 )((int )dev_priv->saveCR[17]));
  i = 0;
  }
  goto ldv_37638;
  ldv_37637:
  {
  i915_write_indexed(dev, (u16 )((int )cr_index), (u16 )((int )cr_data), (u8 )((int )((u8 )i)),
                     (u8 )((int )dev_priv->saveCR[i]));
  i = i + 1;
  }
  ldv_37638: ;
  if (i <= 36) {
    goto ldv_37637;
  } else {
    goto ldv_37639;
  }
  ldv_37639:
  i = 0;
  goto ldv_37641;
  ldv_37640:
  {
  i915_write_indexed(dev, (u16 )974, (u16 )975, (u8 )((int )((u8 )i)), (u8 )((int )dev_priv->saveGR[i]));
  i = i + 1;
  }
  ldv_37641: ;
  if (i <= 8) {
    goto ldv_37640;
  } else {
    goto ldv_37642;
  }
  ldv_37642:
  {
  i915_write_indexed(dev, (u16 )974, (u16 )975, (u8 )16, (u8 )((int )dev_priv->saveGR[16]));
  i915_write_indexed(dev, (u16 )974, (u16 )975, (u8 )17, (u8 )((int )dev_priv->saveGR[17]));
  i915_write_indexed(dev, (u16 )974, (u16 )975, (u8 )24, (u8 )((int )dev_priv->saveGR[24]));
  i915_read8___0(dev_priv, (u32 )st01);
  i = 0;
  }
  goto ldv_37644;
  ldv_37643:
  {
  i915_write_ar(dev, (u16 )((int )st01), (u8 )((int )((u8 )i)), (u8 )((int )dev_priv->saveAR[i]),
                (u16 )0);
  i = i + 1;
  }
  ldv_37644: ;
  if (i <= 20) {
    goto ldv_37643;
  } else {
    goto ldv_37645;
  }
  ldv_37645:
  {
  i915_read8___0(dev_priv, (u32 )st01);
  i915_write8(dev_priv, 960U, (u8 )((int )((unsigned int )dev_priv->saveAR_INDEX | 32U)));
  i915_read8___0(dev_priv, (u32 )st01);
  i915_write8(dev_priv, 966U, (u8 )((int )dev_priv->saveDACMASK));
  }
  return;
}
}
static void i915_save_modeset_reg(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  int i ;
  int tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = drm_core_check_feature(dev, 8192);
  }
  if (tmp != 0) {
    return;
  } else {
  }
  {
  dev_priv->saveCURACNTR = i915_read32(dev_priv, 458880U);
  dev_priv->saveCURAPOS = i915_read32(dev_priv, 458888U);
  dev_priv->saveCURABASE = i915_read32(dev_priv, 458884U);
  dev_priv->saveCURBCNTR = i915_read32(dev_priv, 458944U);
  dev_priv->saveCURBPOS = i915_read32(dev_priv, 458952U);
  dev_priv->saveCURBBASE = i915_read32(dev_priv, 458948U);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 2U) {
    {
    dev_priv->saveCURSIZE = i915_read32(dev_priv, 458912U);
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    dev_priv->savePCH_DREF_CONTROL = i915_read32(dev_priv, 811520U);
    dev_priv->saveDISP_ARB_CTL = i915_read32(dev_priv, 282624U);
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    dev_priv->savePCH_DREF_CONTROL = i915_read32(dev_priv, 811520U);
    dev_priv->saveDISP_ARB_CTL = i915_read32(dev_priv, 282624U);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    dev_priv->savePCH_DREF_CONTROL = i915_read32(dev_priv, 811520U);
    dev_priv->saveDISP_ARB_CTL = i915_read32(dev_priv, 282624U);
    }
  } else {
  }
  {
  dev_priv->savePIPEACONF = i915_read32(dev_priv, 458760U);
  dev_priv->savePIPEASRC = i915_read32(dev_priv, 393244U);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    dev_priv->saveFPA0 = i915_read32(dev_priv, 811072U);
    dev_priv->saveFPA1 = i915_read32(dev_priv, 811076U);
    dev_priv->saveDPLL_A = i915_read32(dev_priv, 811028U);
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    dev_priv->saveFPA0 = i915_read32(dev_priv, 811072U);
    dev_priv->saveFPA1 = i915_read32(dev_priv, 811076U);
    dev_priv->saveDPLL_A = i915_read32(dev_priv, 811028U);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    dev_priv->saveFPA0 = i915_read32(dev_priv, 811072U);
    dev_priv->saveFPA1 = i915_read32(dev_priv, 811076U);
    dev_priv->saveDPLL_A = i915_read32(dev_priv, 811028U);
    }
  } else {
    {
    dev_priv->saveFPA0 = i915_read32(dev_priv, 24640U);
    dev_priv->saveFPA1 = i915_read32(dev_priv, 24644U);
    dev_priv->saveDPLL_A = i915_read32(dev_priv, 24596U);
    }
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 5U) {
      if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 6U) {
        if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) == 0U) {
          {
          dev_priv->saveDPLL_A_MD = i915_read32(dev_priv, 24604U);
          }
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  dev_priv->saveHTOTAL_A = i915_read32(dev_priv, 393216U);
  dev_priv->saveHBLANK_A = i915_read32(dev_priv, 393220U);
  dev_priv->saveHSYNC_A = i915_read32(dev_priv, 393224U);
  dev_priv->saveVTOTAL_A = i915_read32(dev_priv, 393228U);
  dev_priv->saveVBLANK_A = i915_read32(dev_priv, 393232U);
  dev_priv->saveVSYNC_A = i915_read32(dev_priv, 393236U);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 5U) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 6U) {
      if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) == 0U) {
        {
        dev_priv->saveBCLRPAT_A = i915_read32(dev_priv, 393248U);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    goto _L;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    goto _L;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    _L:
    {
    dev_priv->savePIPEA_DATA_M1 = i915_read32(dev_priv, 393264U);
    dev_priv->savePIPEA_DATA_N1 = i915_read32(dev_priv, 393268U);
    dev_priv->savePIPEA_LINK_M1 = i915_read32(dev_priv, 393280U);
    dev_priv->savePIPEA_LINK_N1 = i915_read32(dev_priv, 393284U);
    dev_priv->saveFDI_TXA_CTL = i915_read32(dev_priv, 393472U);
    dev_priv->saveFDI_RXA_CTL = i915_read32(dev_priv, 983052U);
    dev_priv->savePFA_CTL_1 = i915_read32(dev_priv, 426112U);
    dev_priv->savePFA_WIN_SZ = i915_read32(dev_priv, 426100U);
    dev_priv->savePFA_WIN_POS = i915_read32(dev_priv, 426096U);
    dev_priv->saveTRANSACONF = i915_read32(dev_priv, 983048U);
    dev_priv->saveTRANS_HTOTAL_A = i915_read32(dev_priv, 917504U);
    dev_priv->saveTRANS_HBLANK_A = i915_read32(dev_priv, 917508U);
    dev_priv->saveTRANS_HSYNC_A = i915_read32(dev_priv, 917512U);
    dev_priv->saveTRANS_VTOTAL_A = i915_read32(dev_priv, 917516U);
    dev_priv->saveTRANS_VBLANK_A = i915_read32(dev_priv, 917520U);
    dev_priv->saveTRANS_VSYNC_A = i915_read32(dev_priv, 917524U);
    }
  } else {
  }
  {
  dev_priv->saveDSPACNTR = i915_read32(dev_priv, 459136U);
  dev_priv->saveDSPASTRIDE = i915_read32(dev_priv, 459144U);
  dev_priv->saveDSPASIZE = i915_read32(dev_priv, 459152U);
  dev_priv->saveDSPAPOS = i915_read32(dev_priv, 459148U);
  dev_priv->saveDSPAADDR = i915_read32(dev_priv, 459140U);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    {
    dev_priv->saveDSPASURF = i915_read32(dev_priv, 459164U);
    dev_priv->saveDSPATILEOFF = i915_read32(dev_priv, 459172U);
    }
  } else {
  }
  {
  i915_save_palette(dev, (enum pipe )0);
  dev_priv->savePIPEASTAT = i915_read32(dev_priv, 458788U);
  dev_priv->savePIPEBCONF = i915_read32(dev_priv, 462856U);
  dev_priv->savePIPEBSRC = i915_read32(dev_priv, 397340U);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    dev_priv->saveFPB0 = i915_read32(dev_priv, 811080U);
    dev_priv->saveFPB1 = i915_read32(dev_priv, 811084U);
    dev_priv->saveDPLL_B = i915_read32(dev_priv, 811032U);
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    dev_priv->saveFPB0 = i915_read32(dev_priv, 811080U);
    dev_priv->saveFPB1 = i915_read32(dev_priv, 811084U);
    dev_priv->saveDPLL_B = i915_read32(dev_priv, 811032U);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    dev_priv->saveFPB0 = i915_read32(dev_priv, 811080U);
    dev_priv->saveFPB1 = i915_read32(dev_priv, 811084U);
    dev_priv->saveDPLL_B = i915_read32(dev_priv, 811032U);
    }
  } else {
    {
    dev_priv->saveFPB0 = i915_read32(dev_priv, 24648U);
    dev_priv->saveFPB1 = i915_read32(dev_priv, 24652U);
    dev_priv->saveDPLL_B = i915_read32(dev_priv, 24600U);
    }
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 5U) {
      if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 6U) {
        if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) == 0U) {
          {
          dev_priv->saveDPLL_B_MD = i915_read32(dev_priv, 24608U);
          }
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  dev_priv->saveHTOTAL_B = i915_read32(dev_priv, 397312U);
  dev_priv->saveHBLANK_B = i915_read32(dev_priv, 397316U);
  dev_priv->saveHSYNC_B = i915_read32(dev_priv, 397320U);
  dev_priv->saveVTOTAL_B = i915_read32(dev_priv, 397324U);
  dev_priv->saveVBLANK_B = i915_read32(dev_priv, 397328U);
  dev_priv->saveVSYNC_B = i915_read32(dev_priv, 397332U);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 5U) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 6U) {
      if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) == 0U) {
        {
        dev_priv->saveBCLRPAT_B = i915_read32(dev_priv, 397344U);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    goto _L___0;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    goto _L___0;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    _L___0:
    {
    dev_priv->savePIPEB_DATA_M1 = i915_read32(dev_priv, 397360U);
    dev_priv->savePIPEB_DATA_N1 = i915_read32(dev_priv, 397364U);
    dev_priv->savePIPEB_LINK_M1 = i915_read32(dev_priv, 397376U);
    dev_priv->savePIPEB_LINK_N1 = i915_read32(dev_priv, 397380U);
    dev_priv->saveFDI_TXB_CTL = i915_read32(dev_priv, 397568U);
    dev_priv->saveFDI_RXB_CTL = i915_read32(dev_priv, 987148U);
    dev_priv->savePFB_CTL_1 = i915_read32(dev_priv, 428160U);
    dev_priv->savePFB_WIN_SZ = i915_read32(dev_priv, 428148U);
    dev_priv->savePFB_WIN_POS = i915_read32(dev_priv, 428144U);
    dev_priv->saveTRANSBCONF = i915_read32(dev_priv, 987144U);
    dev_priv->saveTRANS_HTOTAL_B = i915_read32(dev_priv, 921600U);
    dev_priv->saveTRANS_HBLANK_B = i915_read32(dev_priv, 921604U);
    dev_priv->saveTRANS_HSYNC_B = i915_read32(dev_priv, 921608U);
    dev_priv->saveTRANS_VTOTAL_B = i915_read32(dev_priv, 921612U);
    dev_priv->saveTRANS_VBLANK_B = i915_read32(dev_priv, 921616U);
    dev_priv->saveTRANS_VSYNC_B = i915_read32(dev_priv, 921620U);
    }
  } else {
  }
  {
  dev_priv->saveDSPBCNTR = i915_read32(dev_priv, 463232U);
  dev_priv->saveDSPBSTRIDE = i915_read32(dev_priv, 463240U);
  dev_priv->saveDSPBSIZE = i915_read32(dev_priv, 463248U);
  dev_priv->saveDSPBPOS = i915_read32(dev_priv, 463244U);
  dev_priv->saveDSPBADDR = i915_read32(dev_priv, 463236U);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    {
    dev_priv->saveDSPBSURF = i915_read32(dev_priv, 463260U);
    dev_priv->saveDSPBTILEOFF = i915_read32(dev_priv, 463268U);
    }
  } else {
  }
  {
  i915_save_palette(dev, (enum pipe )1);
  dev_priv->savePIPEBSTAT = i915_read32(dev_priv, 462884U);
  }
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 6) {
    goto case_6;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 5) {
    goto case_5;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 4) {
    goto case_4;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 3) {
    goto case_3;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 2) {
    goto case_2;
  } else
  if (0) {
    case_6:
    i = 0;
    goto ldv_37653;
    ldv_37652:
    {
    dev_priv->saveFENCE[i] = i915_read64(dev_priv, (u32 )((i + 131072) * 8));
    i = i + 1;
    }
    ldv_37653: ;
    if (i <= 15) {
      goto ldv_37652;
    } else {
      goto ldv_37654;
    }
    ldv_37654: ;
    goto ldv_37655;
    case_5: ;
    case_4:
    i = 0;
    goto ldv_37659;
    ldv_37658:
    {
    dev_priv->saveFENCE[i] = i915_read64(dev_priv, (u32 )((i + 1536) * 8));
    i = i + 1;
    }
    ldv_37659: ;
    if (i <= 15) {
      goto ldv_37658;
    } else {
      goto ldv_37660;
    }
    ldv_37660: ;
    goto ldv_37655;
    case_3: ;
    if (dev->pci_device == 10098) {
      goto _L___1;
    } else
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
      goto _L___1;
    } else
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
      _L___1:
      i = 0;
      goto ldv_37663;
      ldv_37662:
      {
      tmp___0 = i915_read32(dev_priv, (u32 )((i + 3072) * 4));
      dev_priv->saveFENCE[i + 8] = (uint64_t )tmp___0;
      i = i + 1;
      }
      ldv_37663: ;
      if (i <= 7) {
        goto ldv_37662;
      } else {
        goto ldv_37664;
      }
      ldv_37664: ;
    } else {
    }
    case_2:
    i = 0;
    goto ldv_37667;
    ldv_37666:
    {
    tmp___1 = i915_read32(dev_priv, (u32 )((i + 2048) * 4));
    dev_priv->saveFENCE[i] = (uint64_t )tmp___1;
    i = i + 1;
    }
    ldv_37667: ;
    if (i <= 7) {
      goto ldv_37666;
    } else {
      goto ldv_37668;
    }
    ldv_37668: ;
    goto ldv_37655;
  } else {
  }
  ldv_37655: ;
  return;
}
}
static void i915_restore_modeset_reg(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  int dpll_a_reg ;
  int fpa0_reg ;
  int fpa1_reg ;
  int dpll_b_reg ;
  int fpb0_reg ;
  int fpb1_reg ;
  int i ;
  int tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = drm_core_check_feature(dev, 8192);
  }
  if (tmp != 0) {
    return;
  } else {
  }
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 6) {
    goto case_6;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 5) {
    goto case_5;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 4) {
    goto case_4;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 3) {
    goto case_3;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 2) {
    goto case_2;
  } else
  if (0) {
    case_6:
    i = 0;
    goto ldv_37682;
    ldv_37681:
    {
    i915_write64(dev_priv, (u32 )((i + 131072) * 8), dev_priv->saveFENCE[i]);
    i = i + 1;
    }
    ldv_37682: ;
    if (i <= 15) {
      goto ldv_37681;
    } else {
      goto ldv_37683;
    }
    ldv_37683: ;
    goto ldv_37684;
    case_5: ;
    case_4:
    i = 0;
    goto ldv_37688;
    ldv_37687:
    {
    i915_write64(dev_priv, (u32 )((i + 1536) * 8), dev_priv->saveFENCE[i]);
    i = i + 1;
    }
    ldv_37688: ;
    if (i <= 15) {
      goto ldv_37687;
    } else {
      goto ldv_37689;
    }
    ldv_37689: ;
    goto ldv_37684;
    case_3: ;
    case_2: ;
    if (dev->pci_device == 10098) {
      goto _L;
    } else
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
      goto _L;
    } else
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
      _L:
      i = 0;
      goto ldv_37693;
      ldv_37692:
      {
      i915_write32(dev_priv, (u32 )((i + 3072) * 4), (u32 )dev_priv->saveFENCE[i + 8]);
      i = i + 1;
      }
      ldv_37693: ;
      if (i <= 7) {
        goto ldv_37692;
      } else {
        goto ldv_37694;
      }
      ldv_37694: ;
    } else {
    }
    i = 0;
    goto ldv_37696;
    ldv_37695:
    {
    i915_write32(dev_priv, (u32 )((i + 2048) * 4), (u32 )dev_priv->saveFENCE[i]);
    i = i + 1;
    }
    ldv_37696: ;
    if (i <= 7) {
      goto ldv_37695;
    } else {
      goto ldv_37697;
    }
    ldv_37697: ;
    goto ldv_37684;
  } else {
  }
  ldv_37684: ;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    goto _L___0;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    goto _L___0;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    _L___0:
    dpll_a_reg = 811028;
    dpll_b_reg = 811032;
    fpa0_reg = 811072;
    fpb0_reg = 811080;
    fpa1_reg = 811076;
    fpb1_reg = 811084;
  } else {
    dpll_a_reg = 24596;
    dpll_b_reg = 24600;
    fpa0_reg = 24640;
    fpb0_reg = 24648;
    fpa1_reg = 24644;
    fpb1_reg = 24652;
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    i915_write32(dev_priv, 811520U, dev_priv->savePCH_DREF_CONTROL);
    i915_write32(dev_priv, 282624U, dev_priv->saveDISP_ARB_CTL);
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    i915_write32(dev_priv, 811520U, dev_priv->savePCH_DREF_CONTROL);
    i915_write32(dev_priv, 282624U, dev_priv->saveDISP_ARB_CTL);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    i915_write32(dev_priv, 811520U, dev_priv->savePCH_DREF_CONTROL);
    i915_write32(dev_priv, 282624U, dev_priv->saveDISP_ARB_CTL);
    }
  } else {
  }
  if ((int )dev_priv->saveDPLL_A < 0) {
    {
    i915_write32(dev_priv, (u32 )dpll_a_reg, dev_priv->saveDPLL_A & 2147483647U);
    readl((void const volatile *)dev_priv->regs + (unsigned long )dpll_a_reg);
    __const_udelay(644250UL);
    }
  } else {
  }
  {
  i915_write32(dev_priv, (u32 )fpa0_reg, dev_priv->saveFPA0);
  i915_write32(dev_priv, (u32 )fpa1_reg, dev_priv->saveFPA1);
  i915_write32(dev_priv, (u32 )dpll_a_reg, dev_priv->saveDPLL_A);
  readl((void const volatile *)dev_priv->regs + (unsigned long )dpll_a_reg);
  __const_udelay(644250UL);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 5U) {
      if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 6U) {
        if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) == 0U) {
          {
          i915_write32(dev_priv, 24604U, dev_priv->saveDPLL_A_MD);
          readl((void const volatile *)dev_priv->regs + 24604U);
          }
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  __const_udelay(644250UL);
  i915_write32(dev_priv, 393216U, dev_priv->saveHTOTAL_A);
  i915_write32(dev_priv, 393220U, dev_priv->saveHBLANK_A);
  i915_write32(dev_priv, 393224U, dev_priv->saveHSYNC_A);
  i915_write32(dev_priv, 393228U, dev_priv->saveVTOTAL_A);
  i915_write32(dev_priv, 393232U, dev_priv->saveVBLANK_A);
  i915_write32(dev_priv, 393236U, dev_priv->saveVSYNC_A);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 5U) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 6U) {
      if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) == 0U) {
        {
        i915_write32(dev_priv, 393248U, dev_priv->saveBCLRPAT_A);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    goto _L___1;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    goto _L___1;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    _L___1:
    {
    i915_write32(dev_priv, 393264U, dev_priv->savePIPEA_DATA_M1);
    i915_write32(dev_priv, 393268U, dev_priv->savePIPEA_DATA_N1);
    i915_write32(dev_priv, 393280U, dev_priv->savePIPEA_LINK_M1);
    i915_write32(dev_priv, 393284U, dev_priv->savePIPEA_LINK_N1);
    i915_write32(dev_priv, 983052U, dev_priv->saveFDI_RXA_CTL);
    i915_write32(dev_priv, 393472U, dev_priv->saveFDI_TXA_CTL);
    i915_write32(dev_priv, 426112U, dev_priv->savePFA_CTL_1);
    i915_write32(dev_priv, 426100U, dev_priv->savePFA_WIN_SZ);
    i915_write32(dev_priv, 426096U, dev_priv->savePFA_WIN_POS);
    i915_write32(dev_priv, 983048U, dev_priv->saveTRANSACONF);
    i915_write32(dev_priv, 917504U, dev_priv->saveTRANS_HTOTAL_A);
    i915_write32(dev_priv, 917508U, dev_priv->saveTRANS_HBLANK_A);
    i915_write32(dev_priv, 917512U, dev_priv->saveTRANS_HSYNC_A);
    i915_write32(dev_priv, 917516U, dev_priv->saveTRANS_VTOTAL_A);
    i915_write32(dev_priv, 917520U, dev_priv->saveTRANS_VBLANK_A);
    i915_write32(dev_priv, 917524U, dev_priv->saveTRANS_VSYNC_A);
    }
  } else {
  }
  {
  i915_write32(dev_priv, 459152U, dev_priv->saveDSPASIZE);
  i915_write32(dev_priv, 459148U, dev_priv->saveDSPAPOS);
  i915_write32(dev_priv, 393244U, dev_priv->savePIPEASRC);
  i915_write32(dev_priv, 459140U, dev_priv->saveDSPAADDR);
  i915_write32(dev_priv, 459144U, dev_priv->saveDSPASTRIDE);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    {
    i915_write32(dev_priv, 459164U, dev_priv->saveDSPASURF);
    i915_write32(dev_priv, 459172U, dev_priv->saveDSPATILEOFF);
    }
  } else {
  }
  {
  i915_write32(dev_priv, 458760U, dev_priv->savePIPEACONF);
  i915_restore_palette(dev, (enum pipe )0);
  i915_write32(dev_priv, 459136U, dev_priv->saveDSPACNTR);
  tmp___0 = i915_read32(dev_priv, 459140U);
  i915_write32(dev_priv, 459140U, tmp___0);
  }
  if ((int )dev_priv->saveDPLL_B < 0) {
    {
    i915_write32(dev_priv, (u32 )dpll_b_reg, dev_priv->saveDPLL_B & 2147483647U);
    readl((void const volatile *)dev_priv->regs + (unsigned long )dpll_b_reg);
    __const_udelay(644250UL);
    }
  } else {
  }
  {
  i915_write32(dev_priv, (u32 )fpb0_reg, dev_priv->saveFPB0);
  i915_write32(dev_priv, (u32 )fpb1_reg, dev_priv->saveFPB1);
  i915_write32(dev_priv, (u32 )dpll_b_reg, dev_priv->saveDPLL_B);
  readl((void const volatile *)dev_priv->regs + (unsigned long )dpll_b_reg);
  __const_udelay(644250UL);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 5U) {
      if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 6U) {
        if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) == 0U) {
          {
          i915_write32(dev_priv, 24608U, dev_priv->saveDPLL_B_MD);
          readl((void const volatile *)dev_priv->regs + 24608U);
          }
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  __const_udelay(644250UL);
  i915_write32(dev_priv, 397312U, dev_priv->saveHTOTAL_B);
  i915_write32(dev_priv, 397316U, dev_priv->saveHBLANK_B);
  i915_write32(dev_priv, 397320U, dev_priv->saveHSYNC_B);
  i915_write32(dev_priv, 397324U, dev_priv->saveVTOTAL_B);
  i915_write32(dev_priv, 397328U, dev_priv->saveVBLANK_B);
  i915_write32(dev_priv, 397332U, dev_priv->saveVSYNC_B);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 5U) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 6U) {
      if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) == 0U) {
        {
        i915_write32(dev_priv, 397344U, dev_priv->saveBCLRPAT_B);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    goto _L___2;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    goto _L___2;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    _L___2:
    {
    i915_write32(dev_priv, 397360U, dev_priv->savePIPEB_DATA_M1);
    i915_write32(dev_priv, 397364U, dev_priv->savePIPEB_DATA_N1);
    i915_write32(dev_priv, 397376U, dev_priv->savePIPEB_LINK_M1);
    i915_write32(dev_priv, 397380U, dev_priv->savePIPEB_LINK_N1);
    i915_write32(dev_priv, 987148U, dev_priv->saveFDI_RXB_CTL);
    i915_write32(dev_priv, 397568U, dev_priv->saveFDI_TXB_CTL);
    i915_write32(dev_priv, 428160U, dev_priv->savePFB_CTL_1);
    i915_write32(dev_priv, 428148U, dev_priv->savePFB_WIN_SZ);
    i915_write32(dev_priv, 428144U, dev_priv->savePFB_WIN_POS);
    i915_write32(dev_priv, 987144U, dev_priv->saveTRANSBCONF);
    i915_write32(dev_priv, 921600U, dev_priv->saveTRANS_HTOTAL_B);
    i915_write32(dev_priv, 921604U, dev_priv->saveTRANS_HBLANK_B);
    i915_write32(dev_priv, 921608U, dev_priv->saveTRANS_HSYNC_B);
    i915_write32(dev_priv, 921612U, dev_priv->saveTRANS_VTOTAL_B);
    i915_write32(dev_priv, 921616U, dev_priv->saveTRANS_VBLANK_B);
    i915_write32(dev_priv, 921620U, dev_priv->saveTRANS_VSYNC_B);
    }
  } else {
  }
  {
  i915_write32(dev_priv, 463248U, dev_priv->saveDSPBSIZE);
  i915_write32(dev_priv, 463244U, dev_priv->saveDSPBPOS);
  i915_write32(dev_priv, 397340U, dev_priv->savePIPEBSRC);
  i915_write32(dev_priv, 463236U, dev_priv->saveDSPBADDR);
  i915_write32(dev_priv, 463240U, dev_priv->saveDSPBSTRIDE);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    {
    i915_write32(dev_priv, 463260U, dev_priv->saveDSPBSURF);
    i915_write32(dev_priv, 463268U, dev_priv->saveDSPBTILEOFF);
    }
  } else {
  }
  {
  i915_write32(dev_priv, 462856U, dev_priv->savePIPEBCONF);
  i915_restore_palette(dev, (enum pipe )1);
  i915_write32(dev_priv, 463232U, dev_priv->saveDSPBCNTR);
  tmp___1 = i915_read32(dev_priv, 463236U);
  i915_write32(dev_priv, 463236U, tmp___1);
  i915_write32(dev_priv, 458888U, dev_priv->saveCURAPOS);
  i915_write32(dev_priv, 458880U, dev_priv->saveCURACNTR);
  i915_write32(dev_priv, 458884U, dev_priv->saveCURABASE);
  i915_write32(dev_priv, 458952U, dev_priv->saveCURBPOS);
  i915_write32(dev_priv, 458944U, dev_priv->saveCURBCNTR);
  i915_write32(dev_priv, 458948U, dev_priv->saveCURBBASE);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 2U) {
    {
    i915_write32(dev_priv, 458912U, dev_priv->saveCURSIZE);
    }
  } else {
  }
  return;
}
}
static void i915_save_display(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  dev_priv->saveDSPARB = i915_read32(dev_priv, 458800U);
  i915_save_modeset_reg(dev);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    dev_priv->saveADPA = i915_read32(dev_priv, 921856U);
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    dev_priv->saveADPA = i915_read32(dev_priv, 921856U);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    dev_priv->saveADPA = i915_read32(dev_priv, 921856U);
    }
  } else {
    {
    dev_priv->saveADPA = i915_read32(dev_priv, 397568U);
    }
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    goto _L;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    goto _L;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    _L:
    {
    dev_priv->savePP_CONTROL = i915_read32(dev_priv, 815620U);
    dev_priv->saveBLC_PWM_CTL = i915_read32(dev_priv, 819792U);
    dev_priv->saveBLC_PWM_CTL2 = i915_read32(dev_priv, 819796U);
    dev_priv->saveBLC_CPU_PWM_CTL = i915_read32(dev_priv, 295508U);
    dev_priv->saveBLC_CPU_PWM_CTL2 = i915_read32(dev_priv, 295504U);
    dev_priv->saveLVDS = i915_read32(dev_priv, 921984U);
    }
  } else {
    {
    dev_priv->savePP_CONTROL = i915_read32(dev_priv, 397828U);
    dev_priv->savePFIT_PGM_RATIOS = i915_read32(dev_priv, 397876U);
    dev_priv->saveBLC_PWM_CTL = i915_read32(dev_priv, 397908U);
    dev_priv->saveBLC_HIST_CTL = i915_read32(dev_priv, 397920U);
    }
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
      {
      dev_priv->saveBLC_PWM_CTL2 = i915_read32(dev_priv, 397904U);
      }
    } else {
    }
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
      if (dev->pci_device != 13687) {
        {
        dev_priv->saveLVDS = i915_read32(dev_priv, 397696U);
        }
      } else {
      }
    } else {
    }
  }
  if (dev->pci_device != 13687) {
    if (dev->pci_device != 9570) {
      if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 5U) {
        if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 6U) {
          if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) == 0U) {
            {
            dev_priv->savePFIT_CONTROL = i915_read32(dev_priv, 397872U);
            }
          } else {
          }
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    dev_priv->savePP_ON_DELAYS = i915_read32(dev_priv, 815624U);
    dev_priv->savePP_OFF_DELAYS = i915_read32(dev_priv, 815628U);
    dev_priv->savePP_DIVISOR = i915_read32(dev_priv, 815632U);
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    dev_priv->savePP_ON_DELAYS = i915_read32(dev_priv, 815624U);
    dev_priv->savePP_OFF_DELAYS = i915_read32(dev_priv, 815628U);
    dev_priv->savePP_DIVISOR = i915_read32(dev_priv, 815632U);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    dev_priv->savePP_ON_DELAYS = i915_read32(dev_priv, 815624U);
    dev_priv->savePP_OFF_DELAYS = i915_read32(dev_priv, 815628U);
    dev_priv->savePP_DIVISOR = i915_read32(dev_priv, 815632U);
    }
  } else {
    {
    dev_priv->savePP_ON_DELAYS = i915_read32(dev_priv, 397832U);
    dev_priv->savePP_OFF_DELAYS = i915_read32(dev_priv, 397836U);
    dev_priv->savePP_DIVISOR = i915_read32(dev_priv, 397840U);
    }
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    goto _L___0;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    _L___0:
    {
    dev_priv->saveDP_B = i915_read32(dev_priv, 409856U);
    dev_priv->saveDP_C = i915_read32(dev_priv, 410112U);
    dev_priv->saveDP_D = i915_read32(dev_priv, 410368U);
    dev_priv->savePIPEA_GMCH_DATA_M = i915_read32(dev_priv, 458832U);
    dev_priv->savePIPEB_GMCH_DATA_M = i915_read32(dev_priv, 462928U);
    dev_priv->savePIPEA_GMCH_DATA_N = i915_read32(dev_priv, 458836U);
    dev_priv->savePIPEB_GMCH_DATA_N = i915_read32(dev_priv, 462932U);
    dev_priv->savePIPEA_DP_LINK_M = i915_read32(dev_priv, 458848U);
    dev_priv->savePIPEB_DP_LINK_M = i915_read32(dev_priv, 462944U);
    dev_priv->savePIPEA_DP_LINK_N = i915_read32(dev_priv, 458852U);
    dev_priv->savePIPEB_DP_LINK_N = i915_read32(dev_priv, 462948U);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
      {
      dev_priv->saveDPFC_CB_BASE = i915_read32(dev_priv, 274944U);
      }
    } else
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
      {
      dev_priv->saveDPFC_CB_BASE = i915_read32(dev_priv, 274944U);
      }
    } else
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
      {
      dev_priv->saveDPFC_CB_BASE = i915_read32(dev_priv, 274944U);
      }
    } else
    if (dev->pci_device == 10818) {
      {
      dev_priv->saveDPFC_CB_BASE = i915_read32(dev_priv, 12800U);
      }
    } else {
      {
      dev_priv->saveFBC_CFB_BASE = i915_read32(dev_priv, 12800U);
      dev_priv->saveFBC_LL_BASE = i915_read32(dev_priv, 12804U);
      dev_priv->saveFBC_CONTROL2 = i915_read32(dev_priv, 12820U);
      dev_priv->saveFBC_CONTROL = i915_read32(dev_priv, 12808U);
      }
    }
  } else {
  }
  {
  dev_priv->saveVGA0 = i915_read32(dev_priv, 24576U);
  dev_priv->saveVGA1 = i915_read32(dev_priv, 24580U);
  dev_priv->saveVGA_PD = i915_read32(dev_priv, 24592U);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    dev_priv->saveVGACNTRL = i915_read32(dev_priv, 266240U);
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    dev_priv->saveVGACNTRL = i915_read32(dev_priv, 266240U);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    dev_priv->saveVGACNTRL = i915_read32(dev_priv, 266240U);
    }
  } else {
    {
    dev_priv->saveVGACNTRL = i915_read32(dev_priv, 463872U);
    }
  }
  {
  i915_save_vga(dev);
  }
  return;
}
}
static void i915_restore_display(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  i915_write32(dev_priv, 458800U, dev_priv->saveDSPARB);
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    goto _L;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    _L:
    {
    i915_write32(dev_priv, 458832U, dev_priv->savePIPEA_GMCH_DATA_M);
    i915_write32(dev_priv, 462928U, dev_priv->savePIPEB_GMCH_DATA_M);
    i915_write32(dev_priv, 458836U, dev_priv->savePIPEA_GMCH_DATA_N);
    i915_write32(dev_priv, 462932U, dev_priv->savePIPEB_GMCH_DATA_N);
    i915_write32(dev_priv, 458848U, dev_priv->savePIPEA_DP_LINK_M);
    i915_write32(dev_priv, 462944U, dev_priv->savePIPEB_DP_LINK_M);
    i915_write32(dev_priv, 458852U, dev_priv->savePIPEA_DP_LINK_N);
    i915_write32(dev_priv, 462948U, dev_priv->savePIPEB_DP_LINK_N);
    }
  } else {
  }
  {
  i915_restore_modeset_reg(dev);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    i915_write32(dev_priv, 921856U, dev_priv->saveADPA);
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    i915_write32(dev_priv, 921856U, dev_priv->saveADPA);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    i915_write32(dev_priv, 921856U, dev_priv->saveADPA);
    }
  } else {
    {
    i915_write32(dev_priv, 397568U, dev_priv->saveADPA);
    }
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 5U) {
      if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 6U) {
        if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) == 0U) {
          {
          i915_write32(dev_priv, 397904U, dev_priv->saveBLC_PWM_CTL2);
          }
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    i915_write32(dev_priv, 921984U, dev_priv->saveLVDS);
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    i915_write32(dev_priv, 921984U, dev_priv->saveLVDS);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    i915_write32(dev_priv, 921984U, dev_priv->saveLVDS);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    if (dev->pci_device != 13687) {
      {
      i915_write32(dev_priv, 397696U, dev_priv->saveLVDS);
      }
    } else {
    }
  } else {
  }
  if (dev->pci_device != 13687) {
    if (dev->pci_device != 9570) {
      if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 5U) {
        if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 6U) {
          if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) == 0U) {
            {
            i915_write32(dev_priv, 397872U, dev_priv->savePFIT_CONTROL);
            }
          } else {
          }
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    goto _L___0;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    goto _L___0;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    _L___0:
    {
    i915_write32(dev_priv, 819792U, dev_priv->saveBLC_PWM_CTL);
    i915_write32(dev_priv, 819796U, dev_priv->saveBLC_PWM_CTL2);
    i915_write32(dev_priv, 295508U, dev_priv->saveBLC_CPU_PWM_CTL);
    i915_write32(dev_priv, 295504U, dev_priv->saveBLC_CPU_PWM_CTL2);
    i915_write32(dev_priv, 815624U, dev_priv->savePP_ON_DELAYS);
    i915_write32(dev_priv, 815628U, dev_priv->savePP_OFF_DELAYS);
    i915_write32(dev_priv, 815632U, dev_priv->savePP_DIVISOR);
    i915_write32(dev_priv, 815620U, dev_priv->savePP_CONTROL);
    i915_write32(dev_priv, 70072U, dev_priv->saveMCHBAR_RENDER_STANDBY);
    }
  } else {
    {
    i915_write32(dev_priv, 397876U, dev_priv->savePFIT_PGM_RATIOS);
    i915_write32(dev_priv, 397908U, dev_priv->saveBLC_PWM_CTL);
    i915_write32(dev_priv, 397920U, dev_priv->saveBLC_HIST_CTL);
    i915_write32(dev_priv, 397832U, dev_priv->savePP_ON_DELAYS);
    i915_write32(dev_priv, 397836U, dev_priv->savePP_OFF_DELAYS);
    i915_write32(dev_priv, 397840U, dev_priv->savePP_DIVISOR);
    i915_write32(dev_priv, 397828U, dev_priv->savePP_CONTROL);
    }
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    {
    i915_write32(dev_priv, 409856U, dev_priv->saveDP_B);
    i915_write32(dev_priv, 410112U, dev_priv->saveDP_C);
    i915_write32(dev_priv, 410368U, dev_priv->saveDP_D);
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    i915_write32(dev_priv, 409856U, dev_priv->saveDP_B);
    i915_write32(dev_priv, 410112U, dev_priv->saveDP_C);
    i915_write32(dev_priv, 410368U, dev_priv->saveDP_D);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
      {
      ironlake_disable_fbc(dev);
      i915_write32(dev_priv, 274944U, dev_priv->saveDPFC_CB_BASE);
      }
    } else
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
      {
      ironlake_disable_fbc(dev);
      i915_write32(dev_priv, 274944U, dev_priv->saveDPFC_CB_BASE);
      }
    } else
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
      {
      ironlake_disable_fbc(dev);
      i915_write32(dev_priv, 274944U, dev_priv->saveDPFC_CB_BASE);
      }
    } else
    if (dev->pci_device == 10818) {
      {
      g4x_disable_fbc(dev);
      i915_write32(dev_priv, 12800U, dev_priv->saveDPFC_CB_BASE);
      }
    } else {
      {
      i8xx_disable_fbc(dev);
      i915_write32(dev_priv, 12800U, dev_priv->saveFBC_CFB_BASE);
      i915_write32(dev_priv, 12804U, dev_priv->saveFBC_LL_BASE);
      i915_write32(dev_priv, 12820U, dev_priv->saveFBC_CONTROL2);
      i915_write32(dev_priv, 12808U, dev_priv->saveFBC_CONTROL);
      }
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    i915_write32(dev_priv, 266240U, dev_priv->saveVGACNTRL);
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    i915_write32(dev_priv, 266240U, dev_priv->saveVGACNTRL);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    i915_write32(dev_priv, 266240U, dev_priv->saveVGACNTRL);
    }
  } else {
    {
    i915_write32(dev_priv, 463872U, dev_priv->saveVGACNTRL);
    }
  }
  {
  i915_write32(dev_priv, 24576U, dev_priv->saveVGA0);
  i915_write32(dev_priv, 24580U, dev_priv->saveVGA1);
  i915_write32(dev_priv, 24592U, dev_priv->saveVGA_PD);
  readl((void const volatile *)dev_priv->regs + 24592U);
  __const_udelay(644250UL);
  i915_restore_vga(dev);
  }
  return;
}
}
int i915_save_state(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  int i ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  pci_read_config_byte(dev->pdev, 244, & dev_priv->saveLBB);
  mutex_lock_nested(& dev->struct_mutex, 0U);
  dev_priv->saveHWS = i915_read32(dev_priv, 8320U);
  i915_save_display(dev);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    goto _L;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    goto _L;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    _L:
    {
    dev_priv->saveDEIER = i915_read32(dev_priv, 278540U);
    dev_priv->saveDEIMR = i915_read32(dev_priv, 278532U);
    dev_priv->saveGTIER = i915_read32(dev_priv, 278556U);
    dev_priv->saveGTIMR = i915_read32(dev_priv, 278548U);
    dev_priv->saveFDI_RXA_IMR = i915_read32(dev_priv, 983064U);
    dev_priv->saveFDI_RXB_IMR = i915_read32(dev_priv, 987160U);
    dev_priv->saveMCHBAR_RENDER_STANDBY = i915_read32(dev_priv, 70072U);
    }
  } else {
    {
    dev_priv->saveIER = i915_read32(dev_priv, 8352U);
    dev_priv->saveIMR = i915_read32(dev_priv, 8360U);
    }
  }
  if (dev->pci_device == 70) {
    {
    ironlake_disable_drps(dev);
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    gen6_disable_rps(dev);
    }
  } else {
  }
  {
  dev_priv->saveCACHE_MODE_0 = i915_read32(dev_priv, 8480U);
  dev_priv->saveMI_ARB_STATE = i915_read32(dev_priv, 8420U);
  i = 0;
  }
  goto ldv_37712;
  ldv_37711:
  {
  dev_priv->saveSWF0[i] = i915_read32(dev_priv, (u32 )((i << 2) + 463888));
  dev_priv->saveSWF1[i] = i915_read32(dev_priv, (u32 )((i << 2) + 459792));
  i = i + 1;
  }
  ldv_37712: ;
  if (i <= 15) {
    goto ldv_37711;
  } else {
    goto ldv_37713;
  }
  ldv_37713:
  i = 0;
  goto ldv_37715;
  ldv_37714:
  {
  dev_priv->saveSWF2[i] = i915_read32(dev_priv, (u32 )((i << 2) + 467988));
  i = i + 1;
  }
  ldv_37715: ;
  if (i <= 2) {
    goto ldv_37714;
  } else {
    goto ldv_37716;
  }
  ldv_37716:
  {
  mutex_unlock(& dev->struct_mutex);
  }
  return (0);
}
}
int i915_restore_state(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  int i ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  pci_write_config_byte(dev->pdev, 244, (u8 )((int )dev_priv->saveLBB));
  mutex_lock_nested(& dev->struct_mutex, 0U);
  i915_write32(dev_priv, 8320U, dev_priv->saveHWS);
  i915_restore_display(dev);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    goto _L;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    goto _L;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    _L:
    {
    i915_write32(dev_priv, 278540U, dev_priv->saveDEIER);
    i915_write32(dev_priv, 278532U, dev_priv->saveDEIMR);
    i915_write32(dev_priv, 278556U, dev_priv->saveGTIER);
    i915_write32(dev_priv, 278548U, dev_priv->saveGTIMR);
    i915_write32(dev_priv, 983064U, dev_priv->saveFDI_RXA_IMR);
    i915_write32(dev_priv, 987160U, dev_priv->saveFDI_RXB_IMR);
    }
  } else {
    {
    i915_write32(dev_priv, 8352U, dev_priv->saveIER);
    i915_write32(dev_priv, 8360U, dev_priv->saveIMR);
    }
  }
  {
  mutex_unlock(& dev->struct_mutex);
  intel_init_clock_gating(dev);
  }
  if (dev->pci_device == 70) {
    {
    ironlake_enable_drps(dev);
    intel_init_emon(dev);
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    gen6_enable_rps(dev_priv);
    }
  } else {
  }
  {
  mutex_lock_nested(& dev->struct_mutex, 0U);
  i915_write32(dev_priv, 8480U, dev_priv->saveCACHE_MODE_0 | 4294901760U);
  i915_write32(dev_priv, 8420U, dev_priv->saveMI_ARB_STATE | 4294901760U);
  i = 0;
  }
  goto ldv_37723;
  ldv_37722:
  {
  i915_write32(dev_priv, (u32 )((i << 2) + 463888), dev_priv->saveSWF0[i]);
  i915_write32(dev_priv, (u32 )((i << 2) + 459792), dev_priv->saveSWF1[i]);
  i = i + 1;
  }
  ldv_37723: ;
  if (i <= 15) {
    goto ldv_37722;
  } else {
    goto ldv_37724;
  }
  ldv_37724:
  i = 0;
  goto ldv_37726;
  ldv_37725:
  {
  i915_write32(dev_priv, (u32 )((i << 2) + 467988), dev_priv->saveSWF2[i]);
  i = i + 1;
  }
  ldv_37726: ;
  if (i <= 2) {
    goto ldv_37725;
  } else {
    goto ldv_37727;
  }
  ldv_37727:
  {
  mutex_unlock(& dev->struct_mutex);
  intel_i2c_reset(dev);
  }
  return (0);
}
}
__inline static void list_add_tail(struct list_head *new , struct list_head *head )
{
  {
  {
  __list_add(new, head->prev, head);
  }
  return;
}
}
extern void __list_del_entry(struct list_head * ) ;
extern void list_del(struct list_head * ) ;
__inline static void list_del_init(struct list_head *entry )
{
  {
  {
  __list_del_entry(entry);
  INIT_LIST_HEAD(entry);
  }
  return;
}
}
__inline static void list_move(struct list_head *list , struct list_head *head )
{
  {
  {
  __list_del_entry(list);
  list_add(list, head);
  }
  return;
}
}
__inline static void list_move_tail(struct list_head *list , struct list_head *head )
{
  {
  {
  __list_del_entry(list);
  list_add_tail(list, head);
  }
  return;
}
}
__inline static void set_bit(unsigned int nr , unsigned long volatile *addr )
{
  {
  __asm__ volatile (".section .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.previous\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile *)addr)): "Ir" (nr): "memory");
  return;
}
}
__inline static int ffs(int x )
{ int r ;
  {
  __asm__ ("bsfl %1,%0\n\tcmovzl %2,%0": "=r" (r): "rm" (x), "r" (-1));
  return (r + 1);
}
}
extern void __might_sleep(char const * , int , int ) ;
extern void *memcpy(void * , void const * , size_t ) ;
__inline static void set_ti_thread_flag(struct thread_info *ti , int flag )
{
  {
  {
  set_bit((unsigned int )flag, (unsigned long volatile *)(& ti->flags));
  }
  return;
}
}
extern void prepare_to_wait(wait_queue_head_t * , wait_queue_t * , int ) ;
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
extern int autoremove_wake_function(wait_queue_t * , unsigned int , int , void * ) ;
extern void down_read(struct rw_semaphore * ) ;
extern void down_write(struct rw_semaphore * ) ;
extern void up_read(struct rw_semaphore * ) ;
extern void up_write(struct rw_semaphore * ) ;
extern int queue_delayed_work(struct workqueue_struct * , struct delayed_work * ,
                              unsigned long ) ;
__inline static void init_completion(struct completion *x )
{ struct lock_class_key __key ;
  {
  {
  x->done = 0U;
  __init_waitqueue_head(& x->wait, & __key);
  }
  return;
}
}
extern int wait_for_completion_interruptible(struct completion * ) ;
extern void *__vmalloc(unsigned long , gfp_t , pgprot_t ) ;
extern void vfree(void const * ) ;
__inline static void memcpy_toio(void volatile *dst , void const *src , size_t count )
{ size_t __len ;
  void *__ret ;
  {
  {
  __len = count;
  __ret = memcpy((void *)dst, src, __len);
  }
  return;
}
}
extern void kref_get(struct kref * ) ;
extern int kref_put(struct kref * , void (*)(struct kref * ) ) ;
extern int sysctl_vfs_cache_pressure ;
__inline static void SetPageDirty(struct page *page )
{
  {
  {
  set_bit(4U, (unsigned long volatile *)(& page->flags));
  }
  return;
}
}
__inline static int is_vmalloc_addr(void const *x )
{ unsigned long addr ;
  int tmp ;
  {
  addr = (unsigned long )x;
  if (addr > 0x0fffc8ffffffffffUL) {
    if (addr <= 0x0fffe8fffffffffeUL) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
extern void put_page(struct page * ) ;
__inline static void *lowmem_page_address(struct page *page )
{
  {
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 56L) << 12) + 0x0fff880000000000UL));
}
}
extern void unmap_mapping_range(struct address_space * , loff_t const , loff_t const ,
                                int ) ;
extern int get_user_pages(struct task_struct * , struct mm_struct * , unsigned long ,
                          int , int , int , struct page ** , struct vm_area_struct ** ) ;
extern int set_page_dirty(struct page * ) ;
extern void register_shrinker(struct shrinker * ) ;
extern unsigned long do_mmap_pgoff(struct file * , unsigned long , unsigned long ,
                                   unsigned long , unsigned long , unsigned long ) ;
__inline static unsigned long do_mmap(struct file *file , unsigned long addr , unsigned long len ,
                                      unsigned long prot , unsigned long flag , unsigned long offset )
{ unsigned long ret ;
  {
  ret = 0x0fffffffffffffeaUL;
  if (((len + 4095UL) & 0x0ffffffffffff000UL) + offset < offset) {
    goto out;
  } else {
  }
  if ((offset & 4095UL) == 0UL) {
    {
    ret = do_mmap_pgoff(file, addr, len, prot, flag, offset >> 12);
    }
  } else {
  }
  out: ;
  return (ret);
}
}
extern int vm_insert_pfn(struct vm_area_struct * , unsigned long , unsigned long ) ;
extern int __get_user_bad(void) ;
extern void __put_user_bad(void) ;
extern unsigned long copy_user_generic_string(void * , void const * , unsigned int ) ;
extern unsigned long copy_user_generic_unrolled(void * , void const * , unsigned int ) ;
__inline static unsigned long copy_user_generic(void *to , void const *from , unsigned int len )
{ unsigned int ret ;
  {
  __asm__ volatile ("661:\n\tcall %P4\n662:\n.section .altinstructions,\"a\"\n .balign 8 \n .quad 661b\n .quad 663f\n\t .word (3*32+16)\n\t .byte 662b-661b\n\t .byte 664f-663f\n.previous\n.section .discard,\"aw\",@progbits\n\t .byte 0xff + (664f-663f) - (662b-661b)\n.previous\n.section .altinstr_replacement, \"ax\"\n663:\n\tcall %P5\n664:\n.previous": "=a" (ret),
                       "=D" (to), "=S" (from), "=d" (len): [old] "i" (& copy_user_generic_unrolled),
                       [new] "i" (& copy_user_generic_string), "1" (to), "2" (from),
                       "3" (len): "memory", "rcx", "r8", "r9", "r10", "r11");
  return ((unsigned long )ret);
}
}
__inline static int __copy_from_user_inatomic(void *dst , void const *src , unsigned int size )
{ unsigned long tmp ;
  {
  {
  tmp = copy_user_generic(dst, src, size);
  }
  return ((int )tmp);
}
}
extern long __copy_user_nocache(void * , void const * , unsigned int , int ) ;
__inline static int __copy_from_user_inatomic_nocache(void *dst , void const *src ,
                                                      unsigned int size )
{ long tmp ;
  {
  {
  tmp = __copy_user_nocache(dst, src, size, 0);
  }
  return ((int )tmp);
}
}
extern void schedule(void) ;
__inline static void pagefault_disable(void)
{ struct thread_info *tmp ;
  {
  {
  tmp = current_thread_info();
  tmp->preempt_count = tmp->preempt_count + 1;
  __asm__ volatile ("": : : "memory");
  }
  return;
}
}
__inline static void pagefault_enable(void)
{ struct thread_info *tmp ;
  {
  {
  __asm__ volatile ("": : : "memory");
  tmp = current_thread_info();
  tmp->preempt_count = tmp->preempt_count + -1;
  __asm__ volatile ("": : : "memory");
  }
  return;
}
}
extern int set_memory_wc(unsigned long , int ) ;
extern int set_memory_wb(unsigned long , int ) ;
__inline static void *kmap(struct page *page )
{ void *tmp ;
  {
  {
  __might_sleep("include/linux/highmem.h", 50, 0);
  tmp = lowmem_page_address(page);
  }
  return (tmp);
}
}
__inline static void kunmap(struct page *page )
{
  {
  return;
}
}
__inline static void *__kmap_atomic(struct page *page )
{ void *tmp ;
  {
  {
  pagefault_disable();
  tmp = lowmem_page_address(page);
  }
  return (tmp);
}
}
__inline static void __kunmap_atomic(void *addr )
{
  {
  {
  pagefault_enable();
  }
  return;
}
}
__inline static gfp_t mapping_gfp_mask(struct address_space *mapping )
{
  {
  return ((gfp_t )mapping->flags & 8388607U);
}
}
__inline static void mapping_set_gfp_mask(struct address_space *m , gfp_t mask )
{
  {
  m->flags = (m->flags & 0x0fffffffff800000UL) | (unsigned long )mask;
  return;
}
}
__inline static int fault_in_pages_writeable(char *uaddr , int size )
{ int ret ;
  long tmp ;
  int __pu_err ;
  char *end ;
  int __pu_err___0 ;
  {
  {
  tmp = __builtin_expect((long )(size == 0), 0L);
  }
  if (tmp != 0L) {
    return (0);
  } else {
  }
  __pu_err = 0;
  if (1) {
    goto case_1;
  } else {
    goto switch_default;
    if (0) {
      case_1:
      __asm__ volatile ("1:\tmovb %b1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err): "iq" (0),
                           "m" (*((struct __large_struct *)uaddr)), "i" (-14), "0" (__pu_err));
      goto ldv_28703;
      __asm__ volatile ("1:\tmovw %w1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err): "ir" (0),
                           "m" (*((struct __large_struct *)uaddr)), "i" (-14), "0" (__pu_err));
      goto ldv_28703;
      __asm__ volatile ("1:\tmovl %k1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err): "ir" (0),
                           "m" (*((struct __large_struct *)uaddr)), "i" (-14), "0" (__pu_err));
      goto ldv_28703;
      __asm__ volatile ("1:\tmovq %1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err): "er" (0),
                           "m" (*((struct __large_struct *)uaddr)), "i" (-14), "0" (__pu_err));
      goto ldv_28703;
      switch_default:
      {
      __put_user_bad();
      }
    } else {
    }
  }
  ldv_28703:
  ret = __pu_err;
  if (ret == 0) {
    end = uaddr + ((unsigned long )size + 0x0fffffffffffffffUL);
    if ((((unsigned long )uaddr ^ (unsigned long )end) & 0x0ffffffffffff000UL) != 0UL) {
      __pu_err___0 = 0;
      if (1) {
        goto case_1___0;
      } else {
        goto switch_default___0;
        if (0) {
          case_1___0:
          __asm__ volatile ("1:\tmovb %b1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___0): "iq" (0),
                               "m" (*((struct __large_struct *)end)), "i" (-14), "0" (__pu_err___0));
          goto ldv_28712;
          __asm__ volatile ("1:\tmovw %w1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___0): "ir" (0),
                               "m" (*((struct __large_struct *)end)), "i" (-14), "0" (__pu_err___0));
          goto ldv_28712;
          __asm__ volatile ("1:\tmovl %k1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___0): "ir" (0),
                               "m" (*((struct __large_struct *)end)), "i" (-14), "0" (__pu_err___0));
          goto ldv_28712;
          __asm__ volatile ("1:\tmovq %1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___0): "er" (0),
                               "m" (*((struct __large_struct *)end)), "i" (-14), "0" (__pu_err___0));
          goto ldv_28712;
          switch_default___0:
          {
          __put_user_bad();
          }
        } else {
        }
      }
      ldv_28712:
      ret = __pu_err___0;
    } else {
    }
  } else {
  }
  return (ret);
}
}
__inline static int fault_in_pages_readable(char const *uaddr , int size )
{ char volatile c ;
  int ret ;
  long tmp ;
  int __gu_err ;
  unsigned long __gu_val ;
  int tmp___0 ;
  char const *end ;
  int __gu_err___0 ;
  unsigned long __gu_val___0 ;
  int tmp___1 ;
  {
  {
  tmp = __builtin_expect((long )(size == 0), 0L);
  }
  if (tmp != 0L) {
    return (0);
  } else {
  }
  __gu_err = 0;
  if (1) {
    goto case_1;
  } else {
    goto switch_default;
    if (0) {
      case_1:
      __asm__ volatile ("1:\tmovb %2,%b1\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorb %b1,%b1\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__gu_err),
                           "=q" (__gu_val): "m" (*((struct __large_struct *)uaddr)),
                           "i" (-14), "0" (__gu_err));
      goto ldv_28727;
      __asm__ volatile ("1:\tmovw %2,%w1\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorw %w1,%w1\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__gu_err),
                           "=r" (__gu_val): "m" (*((struct __large_struct *)uaddr)),
                           "i" (-14), "0" (__gu_err));
      goto ldv_28727;
      __asm__ volatile ("1:\tmovl %2,%k1\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorl %k1,%k1\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__gu_err),
                           "=r" (__gu_val): "m" (*((struct __large_struct *)uaddr)),
                           "i" (-14), "0" (__gu_err));
      goto ldv_28727;
      __asm__ volatile ("1:\tmovq %2,%1\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorq %1,%1\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__gu_err),
                           "=r" (__gu_val): "m" (*((struct __large_struct *)uaddr)),
                           "i" (-14), "0" (__gu_err));
      goto ldv_28727;
      switch_default:
      {
      tmp___0 = __get_user_bad();
      __gu_val = (unsigned long )tmp___0;
      }
    } else {
    }
  }
  ldv_28727:
  c = (char volatile )((char )__gu_val);
  ret = __gu_err;
  if (ret == 0) {
    end = uaddr + ((unsigned long )size + 0x0fffffffffffffffUL);
    if ((((unsigned long )uaddr ^ (unsigned long )end) & 0x0ffffffffffff000UL) != 0UL) {
      __gu_err___0 = 0;
      if (1) {
        goto case_1___0;
      } else {
        goto switch_default___0;
        if (0) {
          case_1___0:
          __asm__ volatile ("1:\tmovb %2,%b1\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorb %b1,%b1\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__gu_err___0),
                               "=q" (__gu_val___0): "m" (*((struct __large_struct *)end)),
                               "i" (-14), "0" (__gu_err___0));
          goto ldv_28737;
          __asm__ volatile ("1:\tmovw %2,%w1\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorw %w1,%w1\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__gu_err___0),
                               "=r" (__gu_val___0): "m" (*((struct __large_struct *)end)),
                               "i" (-14), "0" (__gu_err___0));
          goto ldv_28737;
          __asm__ volatile ("1:\tmovl %2,%k1\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorl %k1,%k1\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__gu_err___0),
                               "=r" (__gu_val___0): "m" (*((struct __large_struct *)end)),
                               "i" (-14), "0" (__gu_err___0));
          goto ldv_28737;
          __asm__ volatile ("1:\tmovq %2,%1\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorq %1,%1\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__gu_err___0),
                               "=r" (__gu_val___0): "m" (*((struct __large_struct *)end)),
                               "i" (-14), "0" (__gu_err___0));
          goto ldv_28737;
          switch_default___0:
          {
          tmp___1 = __get_user_bad();
          __gu_val___0 = (unsigned long )tmp___1;
          }
        } else {
        }
      }
      ldv_28737:
      c = (char volatile )((char )__gu_val___0);
      ret = __gu_err___0;
    } else {
    }
  } else {
  }
  return (ret);
}
}
extern int drm_ht_insert_item(struct drm_open_hash * , struct drm_hash_item * ) ;
extern int drm_ht_remove_item(struct drm_open_hash * , struct drm_hash_item * ) ;
extern struct drm_mm_node *drm_mm_get_block_range_generic(struct drm_mm_node * , unsigned long ,
                                                          unsigned int , unsigned long ,
                                                          unsigned long , int ) ;
extern struct drm_mm_node *drm_mm_search_free_in_range(struct drm_mm const * , unsigned long ,
                                                       unsigned int , unsigned long ,
                                                       unsigned long , int ) ;
extern void drm_clflush_pages(struct page ** , unsigned long ) ;
extern void drm_gem_object_release(struct drm_gem_object * ) ;
extern void drm_gem_object_free(struct kref * ) ;
extern int drm_gem_object_init(struct drm_device * , struct drm_gem_object * , size_t ) ;
__inline static void drm_gem_object_reference(struct drm_gem_object *obj )
{
  {
  {
  kref_get(& obj->refcount);
  }
  return;
}
}
__inline static void drm_gem_object_unreference(struct drm_gem_object *obj )
{
  {
  if ((unsigned long )obj != (unsigned long )((struct drm_gem_object *)0)) {
    {
    kref_put(& obj->refcount, & drm_gem_object_free);
    }
  } else {
  }
  return;
}
}
__inline static void drm_gem_object_unreference_unlocked(struct drm_gem_object *obj )
{ struct drm_device *dev ;
  {
  if ((unsigned long )obj != (unsigned long )((struct drm_gem_object *)0)) {
    {
    dev = obj->dev;
    mutex_lock_nested(& dev->struct_mutex, 0U);
    kref_put(& obj->refcount, & drm_gem_object_free);
    mutex_unlock(& dev->struct_mutex);
    }
  } else {
  }
  return;
}
}
extern int drm_gem_handle_create(struct drm_file * , struct drm_gem_object * , u32 * ) ;
extern int drm_gem_handle_delete(struct drm_file * , u32 ) ;
extern struct drm_gem_object *drm_gem_object_lookup(struct drm_device * , struct drm_file * ,
                                                    u32 ) ;
__inline static void *drm_malloc_ab(size_t nmemb , size_t size )
{ void *tmp ;
  pgprot_t __constr_expr_0 ;
  void *tmp___0 ;
  {
  if (size != 0UL) {
    if (0x0fffffffffffffffUL / size < nmemb) {
      return ((void *)0);
    } else {
    }
  } else {
  }
  if (size * nmemb <= 4096UL) {
    {
    tmp = kmalloc(nmemb * size, 208U);
    }
    return (tmp);
  } else {
  }
  {
  __constr_expr_0.pgprot = 0x0000000000000163UL;
  tmp___0 = __vmalloc(size * nmemb, 210U, __constr_expr_0);
  }
  return (tmp___0);
}
}
__inline static void drm_free_large(void *ptr )
{ int tmp ;
  {
  {
  tmp = is_vmalloc_addr((void const *)ptr);
  }
  if (tmp == 0) {
    return;
  } else {
  }
  {
  vfree((void const *)ptr);
  }
  return;
}
}
int intel_init_render_ring_buffer(struct drm_device *dev ) ;
int intel_init_bsd_ring_buffer(struct drm_device *dev ) ;
int intel_init_blt_ring_buffer(struct drm_device *dev ) ;
extern void intel_gtt_chipset_flush(void) ;
extern void intel_gtt_clear_range(unsigned int , unsigned int ) ;
struct tracepoint __tracepoint_i915_gem_object_create ;
__inline static void trace_i915_gem_object_create(struct drm_i915_gem_object *obj )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_gem_object_create.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_gem_object_create.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )34);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_35728:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct drm_i915_gem_object * ))it_func))(__data, obj);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_35728;
      } else {
        goto ldv_35729;
      }
      ldv_35729: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
struct tracepoint __tracepoint_i915_gem_object_bind ;
__inline static void trace_i915_gem_object_bind(struct drm_i915_gem_object *obj ,
                                                bool mappable )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_gem_object_bind.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_gem_object_bind.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )57);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_35761:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct drm_i915_gem_object * , bool ))it_func))(__data,
                                                                             obj,
                                                                             (bool )((int )mappable));
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_35761;
      } else {
        goto ldv_35762;
      }
      ldv_35762: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
struct tracepoint __tracepoint_i915_gem_object_unbind ;
__inline static void trace_i915_gem_object_unbind(struct drm_i915_gem_object *obj )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_gem_object_unbind.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_gem_object_unbind.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )77);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_35795:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct drm_i915_gem_object * ))it_func))(__data, obj);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_35795;
      } else {
        goto ldv_35796;
      }
      ldv_35796: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
struct tracepoint __tracepoint_i915_gem_object_change_domain ;
__inline static void trace_i915_gem_object_change_domain(struct drm_i915_gem_object *obj ,
                                                         u32 old_read , u32 old_write )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_gem_object_change_domain.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_gem_object_change_domain.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )101);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_35830:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct drm_i915_gem_object * , u32 , u32 ))it_func))(__data,
                                                                                   obj,
                                                                                   old_read,
                                                                                   old_write);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_35830;
      } else {
        goto ldv_35831;
      }
      ldv_35831: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
struct tracepoint __tracepoint_i915_gem_object_pwrite ;
__inline static void trace_i915_gem_object_pwrite(struct drm_i915_gem_object *obj ,
                                                  u32 offset , u32 len )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_gem_object_pwrite.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_gem_object_pwrite.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )121);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_35871:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct drm_i915_gem_object * , u32 , u32 ))it_func))(__data,
                                                                                   obj,
                                                                                   offset,
                                                                                   len);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_35871;
      } else {
        goto ldv_35872;
      }
      ldv_35872: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
struct tracepoint __tracepoint_i915_gem_object_pread ;
__inline static void trace_i915_gem_object_pread(struct drm_i915_gem_object *obj ,
                                                 u32 offset , u32 len )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_gem_object_pread.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_gem_object_pread.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )141);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_35912:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct drm_i915_gem_object * , u32 , u32 ))it_func))(__data,
                                                                                   obj,
                                                                                   offset,
                                                                                   len);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_35912;
      } else {
        goto ldv_35913;
      }
      ldv_35913: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
struct tracepoint __tracepoint_i915_gem_object_fault ;
__inline static void trace_i915_gem_object_fault(struct drm_i915_gem_object *obj ,
                                                 u32 index , bool gtt , bool write )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_gem_object_fault.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_gem_object_fault.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )166);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_35955:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct drm_i915_gem_object * , u32 , bool , bool ))it_func))(__data,
                                                                                            obj,
                                                                                            index,
                                                                                            (bool )((int )gtt),
                                                                                            (bool )((int )write));
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_35955;
      } else {
        goto ldv_35956;
      }
      ldv_35956: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
struct tracepoint __tracepoint_i915_gem_object_clflush ;
__inline static void trace_i915_gem_object_clflush(struct drm_i915_gem_object *obj )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_gem_object_clflush.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_gem_object_clflush.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )186);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_35995:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct drm_i915_gem_object * ))it_func))(__data, obj);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_35995;
      } else {
        goto ldv_35996;
      }
      ldv_35996: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
struct tracepoint __tracepoint_i915_gem_object_destroy ;
__inline static void trace_i915_gem_object_destroy(struct drm_i915_gem_object *obj )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_gem_object_destroy.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_gem_object_destroy.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )191);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_36026:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct drm_i915_gem_object * ))it_func))(__data, obj);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_36026;
      } else {
        goto ldv_36027;
      }
      ldv_36027: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
struct tracepoint __tracepoint_i915_gem_ring_flush ;
__inline static void trace_i915_gem_ring_flush(struct intel_ring_buffer *ring , u32 invalidate ,
                                               u32 flush )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_gem_ring_flush.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_gem_ring_flush.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )277);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_36179:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct intel_ring_buffer * , u32 , u32 ))it_func))(__data,
                                                                                 ring,
                                                                                 invalidate,
                                                                                 flush);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_36179;
      } else {
        goto ldv_36180;
      }
      ldv_36180: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
struct tracepoint __tracepoint_i915_gem_request_add ;
__inline static void trace_i915_gem_request_add(struct intel_ring_buffer *ring , u32 seqno )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_gem_request_add.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_gem_request_add.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )302);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_36218:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct intel_ring_buffer * , u32 ))it_func))(__data,
                                                                          ring, seqno);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_36218;
      } else {
        goto ldv_36219;
      }
      ldv_36219: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
struct tracepoint __tracepoint_i915_gem_request_retire ;
__inline static void trace_i915_gem_request_retire(struct intel_ring_buffer *ring ,
                                                   u32 seqno )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_gem_request_retire.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_gem_request_retire.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )312);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_36290:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct intel_ring_buffer * , u32 ))it_func))(__data,
                                                                          ring, seqno);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_36290;
      } else {
        goto ldv_36291;
      }
      ldv_36291: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
struct tracepoint __tracepoint_i915_gem_request_wait_begin ;
__inline static void trace_i915_gem_request_wait_begin(struct intel_ring_buffer *ring ,
                                                       u32 seqno )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_gem_request_wait_begin.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_gem_request_wait_begin.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )317);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_36326:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct intel_ring_buffer * , u32 ))it_func))(__data,
                                                                          ring, seqno);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_36326;
      } else {
        goto ldv_36327;
      }
      ldv_36327: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
struct tracepoint __tracepoint_i915_gem_request_wait_end ;
__inline static void trace_i915_gem_request_wait_end(struct intel_ring_buffer *ring ,
                                                     u32 seqno )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_gem_request_wait_end.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_gem_request_wait_end.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )322);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_36362:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct intel_ring_buffer * , u32 ))it_func))(__data,
                                                                          ring, seqno);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_36362;
      } else {
        goto ldv_36363;
      }
      ldv_36363: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
int i915_gem_flush_ring(struct intel_ring_buffer *ring , uint32_t invalidate_domains ,
                        uint32_t flush_domains ) ;
struct drm_i915_gem_object *i915_gem_alloc_object(struct drm_device *dev , size_t size ) ;
int i915_gem_object_pin(struct drm_i915_gem_object *obj , uint32_t alignment , bool map_and_fenceable ) ;
void i915_gem_object_unpin(struct drm_i915_gem_object *obj ) ;
int i915_gem_object_unbind(struct drm_i915_gem_object *obj ) ;
void i915_gem_release_mmap(struct drm_i915_gem_object *obj ) ;
int i915_mutex_lock_interruptible(struct drm_device *dev ) ;
int i915_gem_object_wait_rendering(struct drm_i915_gem_object *obj ) ;
void i915_gem_object_move_to_active(struct drm_i915_gem_object *obj , struct intel_ring_buffer *ring ,
                                    u32 seqno ) ;
__inline static u32 i915_gem_next_request_seqno(struct intel_ring_buffer *ring )
{ drm_i915_private_t *dev_priv ;
  u32 tmp ;
  {
  dev_priv = (drm_i915_private_t *)(ring->dev)->dev_private;
  tmp = dev_priv->next_seqno;
  ring->outstanding_lazy_request = tmp;
  return (tmp);
}
}
int i915_gem_object_get_fence(struct drm_i915_gem_object *obj , struct intel_ring_buffer *pipelined ) ;
int i915_gem_object_put_fence(struct drm_i915_gem_object *obj ) ;
void i915_gem_retire_requests(struct drm_device *dev ) ;
void i915_gem_clflush_object(struct drm_i915_gem_object *obj ) ;
int i915_gem_object_flush_gpu(struct drm_i915_gem_object *obj ) ;
int i915_add_request(struct intel_ring_buffer *ring , struct drm_file *file , struct drm_i915_gem_request *request ) ;
int i915_wait_request(struct intel_ring_buffer *ring , uint32_t seqno ) ;
int i915_gem_object_set_to_gtt_domain(struct drm_i915_gem_object *obj , bool write ) ;
int i915_gem_object_set_to_display_plane(struct drm_i915_gem_object *obj , struct intel_ring_buffer *pipelined ) ;
int i915_gem_attach_phys_object(struct drm_device *dev , struct drm_i915_gem_object *obj ,
                                int id , int align ) ;
void i915_gem_detach_phys_object(struct drm_device *dev , struct drm_i915_gem_object *obj ) ;
uint32_t i915_gem_get_unfenced_gtt_alignment(struct drm_device *dev , uint32_t size ,
                                             int tiling_mode ) ;
int i915_gem_gtt_bind_object(struct drm_i915_gem_object *obj ) ;
void i915_gem_gtt_unbind_object(struct drm_i915_gem_object *obj ) ;
int i915_gem_evict_something(struct drm_device *dev , int min_size , unsigned int alignment ,
                             bool mappable ) ;
int i915_gem_evict_everything(struct drm_device *dev , bool purgeable_only ) ;
int i915_gem_evict_inactive(struct drm_device *dev , bool purgeable_only ) ;
void i915_gem_detect_bit_6_swizzle(struct drm_device *dev ) ;
void i915_gem_object_do_bit_17_swizzle(struct drm_i915_gem_object *obj ) ;
void i915_gem_object_save_bit_17_swizzle(struct drm_i915_gem_object *obj ) ;
extern void mark_page_accessed(struct page * ) ;
extern struct page *shmem_read_mapping_page_gfp(struct address_space * , unsigned long ,
                                                gfp_t ) ;
extern void shmem_truncate_range(struct inode * , loff_t , loff_t ) ;
__inline static struct page *shmem_read_mapping_page(struct address_space *mapping ,
                                                     unsigned long index )
{ gfp_t tmp ;
  struct page *tmp___0 ;
  {
  {
  tmp = mapping_gfp_mask(mapping);
  tmp___0 = shmem_read_mapping_page_gfp(mapping, index, tmp);
  }
  return (tmp___0);
}
}
static int i915_gem_object_flush_gpu_write_domain(struct drm_i915_gem_object *obj ) ;
static void i915_gem_object_flush_gtt_write_domain(struct drm_i915_gem_object *obj ) ;
static void i915_gem_object_flush_cpu_write_domain(struct drm_i915_gem_object *obj ) ;
static int i915_gem_object_set_to_cpu_domain(struct drm_i915_gem_object *obj , bool write ) ;
static int i915_gem_object_set_cpu_read_domain_range(struct drm_i915_gem_object *obj ,
                                                     uint64_t offset , uint64_t size ) ;
static void i915_gem_object_set_to_full_cpu_read_domain(struct drm_i915_gem_object *obj ) ;
static int i915_gem_object_bind_to_gtt(struct drm_i915_gem_object *obj , unsigned int alignment ,
                                       bool map_and_fenceable ) ;
static void i915_gem_clear_fence_reg(struct drm_device *dev , struct drm_i915_fence_reg *reg ) ;
static int i915_gem_phys_pwrite(struct drm_device *dev , struct drm_i915_gem_object *obj ,
                                struct drm_i915_gem_pwrite *args , struct drm_file *file_priv ) ;
static void i915_gem_free_object_tail(struct drm_i915_gem_object *obj ) ;
static int i915_gem_inactive_shrink(struct shrinker *shrinker , struct shrink_control *sc ) ;
static void i915_gem_info_add_obj(struct drm_i915_private *dev_priv , size_t size )
{
  {
  dev_priv->mm.object_count = dev_priv->mm.object_count + 1U;
  dev_priv->mm.object_memory = dev_priv->mm.object_memory + size;
  return;
}
}
static void i915_gem_info_remove_obj(struct drm_i915_private *dev_priv , size_t size )
{
  {
  dev_priv->mm.object_count = dev_priv->mm.object_count - 1U;
  dev_priv->mm.object_memory = dev_priv->mm.object_memory - size;
  return;
}
}
static int i915_gem_wait_for_error(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct completion *x ;
  unsigned long flags ;
  int ret ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  x = & dev_priv->error_completion;
  tmp = atomic_read((atomic_t const *)(& dev_priv->mm.wedged));
  }
  if (tmp == 0) {
    return (0);
  } else {
  }
  {
  ret = wait_for_completion_interruptible(x);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  tmp___1 = atomic_read((atomic_t const *)(& dev_priv->mm.wedged));
  }
  if (tmp___1 != 0) {
    {
    tmp___0 = spinlock_check(& x->wait.lock);
    flags = _raw_spin_lock_irqsave(tmp___0);
    x->done = x->done + 1U;
    spin_unlock_irqrestore(& x->wait.lock, flags);
    }
  } else {
  }
  return (0);
}
}
int i915_mutex_lock_interruptible(struct drm_device *dev )
{ int ret ;
  int __ret_warn_on ;
  long tmp ;
  {
  {
  ret = i915_gem_wait_for_error(dev);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  ret = mutex_lock_interruptible_nested(& dev->struct_mutex, 0U);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  __ret_warn_on = 0;
  tmp = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp != 0L) {
    {
    warn_slowpath_null("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p",
                       (int const )124);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  return (0);
}
}
__inline static bool i915_gem_object_is_inactive(struct drm_i915_gem_object *obj )
{ int tmp ;
  {
  if ((unsigned long )obj->gtt_space != (unsigned long )((struct drm_mm_node *)0)) {
    if ((unsigned int )*((unsigned char *)obj + 224UL) == 0U) {
      if (*((unsigned int *)obj + 56UL) == 0U) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((bool )tmp);
}
}
void i915_gem_do_init(struct drm_device *dev , unsigned long start , unsigned long mappable_end ,
                      unsigned long end )
{ drm_i915_private_t *dev_priv ;
  unsigned long _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  drm_mm_init(& dev_priv->mm.gtt_space, start, end - start);
  dev_priv->mm.gtt_start = start;
  dev_priv->mm.gtt_mappable_end = mappable_end;
  dev_priv->mm.gtt_end = end;
  dev_priv->mm.gtt_total = end - start;
  _min1 = end;
  _min2 = mappable_end;
  }
  if (_min1 < _min2) {
    tmp = _min1;
  } else {
    tmp = _min2;
  }
  {
  dev_priv->mm.mappable_gtt_total = tmp - start;
  intel_gtt_clear_range((unsigned int )(start / 4096UL), (unsigned int )((end - start) / 4096UL));
  }
  return;
}
}
int i915_gem_init_ioctl(struct drm_device *dev , void *data , struct drm_file *file )
{ struct drm_i915_gem_init *args ;
  {
  args = (struct drm_i915_gem_init *)data;
  if (args->gtt_start >= args->gtt_end) {
    return (-22);
  } else
  if (((args->gtt_end | args->gtt_start) & 4095ULL) != 0ULL) {
    return (-22);
  } else {
  }
  {
  mutex_lock_nested(& dev->struct_mutex, 0U);
  i915_gem_do_init(dev, (unsigned long )args->gtt_start, (unsigned long )args->gtt_end,
                   (unsigned long )args->gtt_end);
  mutex_unlock(& dev->struct_mutex);
  }
  return (0);
}
}
int i915_gem_get_aperture_ioctl(struct drm_device *dev , void *data , struct drm_file *file )
{ struct drm_i915_private *dev_priv ;
  struct drm_i915_gem_get_aperture *args ;
  struct drm_i915_gem_object *obj ;
  size_t pinned ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  args = (struct drm_i915_gem_get_aperture *)data;
  if (((dev->driver)->driver_features & 4096U) == 0U) {
    return (-19);
  } else {
  }
  {
  pinned = 0UL;
  mutex_lock_nested(& dev->struct_mutex, 0U);
  __mptr = (struct list_head const *)dev_priv->mm.pinned_list.next;
  obj = (struct drm_i915_gem_object *)__mptr + 0x0fffffffffffff50UL;
  }
  goto ldv_38798;
  ldv_38797:
  pinned = (obj->gtt_space)->size + pinned;
  __mptr___0 = (struct list_head const *)obj->mm_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___0 + 0x0fffffffffffff50UL;
  ldv_38798: ;
  if ((unsigned long )(& obj->mm_list) != (unsigned long )(& dev_priv->mm.pinned_list)) {
    goto ldv_38797;
  } else {
    goto ldv_38799;
  }
  ldv_38799:
  {
  mutex_unlock(& dev->struct_mutex);
  args->aper_size = (__u64 )dev_priv->mm.gtt_total;
  args->aper_available_size = args->aper_size - (unsigned long long )pinned;
  }
  return (0);
}
}
static int i915_gem_create(struct drm_file *file , struct drm_device *dev , uint64_t size ,
                           uint32_t *handle_p )
{ struct drm_i915_gem_object *obj ;
  int ret ;
  u32 handle ;
  unsigned long __y ;
  {
  {
  __y = 4096UL;
  size = ((((unsigned long long )__y + size) - 1ULL) / (unsigned long long )__y) * (unsigned long long )__y;
  obj = i915_gem_alloc_object(dev, (size_t )size);
  }
  if ((unsigned long )obj == (unsigned long )((struct drm_i915_gem_object *)0)) {
    return (-12);
  } else {
  }
  {
  ret = drm_gem_handle_create(file, & obj->base, & handle);
  }
  if (ret != 0) {
    {
    drm_gem_object_release(& obj->base);
    i915_gem_info_remove_obj((struct drm_i915_private *)dev->dev_private, obj->base.size);
    kfree((void const *)obj);
    }
    return (ret);
  } else {
  }
  {
  drm_gem_object_unreference(& obj->base);
  trace_i915_gem_object_create(obj);
  *handle_p = handle;
  }
  return (0);
}
}
int i915_gem_dumb_create(struct drm_file *file , struct drm_device *dev , struct drm_mode_create_dumb *args )
{ int tmp ;
  {
  {
  args->pitch = (args->width * ((args->bpp + 7U) / 8U) + 63U) & 4294967232U;
  args->size = (uint64_t )(args->pitch * args->height);
  tmp = i915_gem_create(file, dev, args->size, & args->handle);
  }
  return (tmp);
}
}
int i915_gem_dumb_destroy(struct drm_file *file , struct drm_device *dev , uint32_t handle )
{ int tmp ;
  {
  {
  tmp = drm_gem_handle_delete(file, handle);
  }
  return (tmp);
}
}
int i915_gem_create_ioctl(struct drm_device *dev , void *data , struct drm_file *file )
{ struct drm_i915_gem_create *args ;
  int tmp ;
  {
  {
  args = (struct drm_i915_gem_create *)data;
  tmp = i915_gem_create(file, dev, args->size, & args->handle);
  }
  return (tmp);
}
}
static int i915_gem_object_needs_bit17_swizzle(struct drm_i915_gem_object *obj )
{ drm_i915_private_t *dev_priv ;
  int tmp ;
  {
  dev_priv = (drm_i915_private_t *)(obj->base.dev)->dev_private;
  if (dev_priv->mm.bit_6_swizzle_x == 7U) {
    if ((unsigned int )*((unsigned char *)obj + 225UL) != 0U) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
__inline static void slow_shmem_copy(struct page *dst_page , int dst_offset , struct page *src_page ,
                                     int src_offset , int length )
{ char *dst_vaddr ;
  char *src_vaddr ;
  void *tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  {
  {
  tmp = kmap(dst_page);
  dst_vaddr = (char *)tmp;
  tmp___0 = kmap(src_page);
  src_vaddr = (char *)tmp___0;
  __len = (size_t )length;
  __ret = memcpy((void *)dst_vaddr + (unsigned long )dst_offset, (void const *)src_vaddr + (unsigned long )src_offset,
                           __len);
  kunmap(src_page);
  kunmap(dst_page);
  }
  return;
}
}
__inline static void slow_shmem_bit17_copy(struct page *gpu_page , int gpu_offset ,
                                           struct page *cpu_page , int cpu_offset ,
                                           int length , int is_read )
{ char *gpu_vaddr ;
  char *cpu_vaddr ;
  void *tmp ;
  void *tmp___0 ;
  int cacheline_end ;
  int this_length ;
  int _min1 ;
  int _min2 ;
  int tmp___1 ;
  int swizzled_gpu_offset ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  {
  if ((((unsigned long long )(((long )gpu_page + 24189255811072L) / 56L) << 12) & 131072ULL) == 0ULL) {
    if (is_read != 0) {
      return;
    } else {
      return;
    }
  } else {
  }
  {
  tmp = kmap(gpu_page);
  gpu_vaddr = (char *)tmp;
  tmp___0 = kmap(cpu_page);
  cpu_vaddr = (char *)tmp___0;
  }
  goto ldv_38866;
  ldv_38865:
  cacheline_end = (gpu_offset + 64) & -64;
  _min1 = cacheline_end - gpu_offset;
  _min2 = length;
  if (_min1 < _min2) {
    tmp___1 = _min1;
  } else {
    tmp___1 = _min2;
  }
  this_length = tmp___1;
  swizzled_gpu_offset = gpu_offset ^ 64;
  if (is_read != 0) {
    {
    __len = (size_t )this_length;
    __ret = memcpy((void *)cpu_vaddr + (unsigned long )cpu_offset, (void const *)gpu_vaddr + (unsigned long )swizzled_gpu_offset,
                             __len);
    }
  } else {
    {
    __len___0 = (size_t )this_length;
    __ret___0 = memcpy((void *)gpu_vaddr + (unsigned long )swizzled_gpu_offset,
                                 (void const *)cpu_vaddr + (unsigned long )cpu_offset,
                                 __len___0);
    }
  }
  cpu_offset = cpu_offset + this_length;
  gpu_offset = gpu_offset + this_length;
  length = length - this_length;
  ldv_38866: ;
  if (length > 0) {
    goto ldv_38865;
  } else {
    goto ldv_38867;
  }
  ldv_38867:
  {
  kunmap(cpu_page);
  kunmap(gpu_page);
  }
  return;
}
}
static int i915_gem_shmem_pread_fast(struct drm_device *dev , struct drm_i915_gem_object *obj ,
                                     struct drm_i915_gem_pread *args , struct drm_file *file )
{ struct address_space *mapping ;
  ssize_t remain ;
  loff_t offset ;
  char *user_data ;
  int page_offset___0 ;
  int page_length ;
  struct page *page ;
  char *vaddr ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  {
  mapping = (((obj->base.filp)->f_path.dentry)->d_inode)->i_mapping;
  user_data = (char *)args->data_ptr;
  remain = (ssize_t )args->size;
  offset = (loff_t )args->offset;
  goto ldv_38884;
  ldv_38883:
  page_offset___0 = (int )offset & 4095;
  page_length = (int )remain;
  if ((unsigned long )((ssize_t )page_offset___0 + remain) > 4096UL) {
    page_length = (int )(4096U - (unsigned int )page_offset___0);
  } else {
  }
  {
  page = shmem_read_mapping_page(mapping, (unsigned long )(offset >> 12));
  tmp___0 = IS_ERR((void const *)page);
  }
  if (tmp___0 != 0L) {
    {
    tmp = PTR_ERR((void const *)page);
    }
    return ((int )tmp);
  } else {
  }
  {
  tmp___1 = __kmap_atomic(page);
  vaddr = (char *)tmp___1;
  ret = __copy_from_user_inatomic((void *)user_data, (void const *)vaddr + (unsigned long )page_offset___0,
                                  (unsigned int )page_length);
  __kunmap_atomic((void *)vaddr);
  mark_page_accessed(page);
  put_page(page);
  }
  if (ret != 0) {
    return (-14);
  } else {
  }
  remain = remain - (ssize_t )page_length;
  user_data = user_data + (unsigned long )page_length;
  offset = (loff_t )page_length + offset;
  ldv_38884: ;
  if (remain > 0L) {
    goto ldv_38883;
  } else {
    goto ldv_38885;
  }
  ldv_38885: ;
  return (0);
}
}
static int i915_gem_shmem_pread_slow(struct drm_device *dev , struct drm_i915_gem_object *obj ,
                                     struct drm_i915_gem_pread *args , struct drm_file *file )
{ struct address_space *mapping ;
  struct mm_struct *mm ;
  struct task_struct *tmp ;
  struct page **user_pages ;
  ssize_t remain ;
  loff_t offset ;
  loff_t pinned_pages ;
  loff_t i ;
  loff_t first_data_page ;
  loff_t last_data_page ;
  loff_t num_pages ;
  int shmem_page_offset ;
  int data_page_index ;
  int data_page_offset ;
  int page_length ;
  int ret ;
  uint64_t data_ptr ;
  int do_bit17_swizzling ;
  void *tmp___0 ;
  struct task_struct *tmp___1 ;
  int tmp___2 ;
  struct page *page ;
  long tmp___3 ;
  long tmp___4 ;
  {
  {
  mapping = (((obj->base.filp)->f_path.dentry)->d_inode)->i_mapping;
  tmp = get_current();
  mm = tmp->mm;
  data_ptr = args->data_ptr;
  remain = (ssize_t )args->size;
  first_data_page = (loff_t )(data_ptr / 4096ULL);
  last_data_page = (loff_t )(((args->size + data_ptr) - 1ULL) / 4096ULL);
  num_pages = (last_data_page - first_data_page) + 1LL;
  tmp___0 = drm_malloc_ab((size_t )num_pages, 8UL);
  user_pages = (struct page **)tmp___0;
  }
  if ((unsigned long )user_pages == (unsigned long )((struct page **)0)) {
    return (-12);
  } else {
  }
  {
  mutex_unlock(& dev->struct_mutex);
  down_read(& mm->mmap_sem);
  tmp___1 = get_current();
  tmp___2 = get_user_pages(tmp___1, mm, (unsigned long )args->data_ptr, (int )num_pages,
                           1, 0, user_pages, (struct vm_area_struct **)0);
  pinned_pages = (loff_t )tmp___2;
  up_read(& mm->mmap_sem);
  mutex_lock_nested(& dev->struct_mutex, 0U);
  }
  if (pinned_pages < num_pages) {
    ret = -14;
    goto out;
  } else {
  }
  {
  ret = i915_gem_object_set_cpu_read_domain_range(obj, args->offset, args->size);
  }
  if (ret != 0) {
    goto out;
  } else {
  }
  {
  do_bit17_swizzling = i915_gem_object_needs_bit17_swizzle(obj);
  offset = (loff_t )args->offset;
  }
  goto ldv_38912;
  ldv_38911:
  shmem_page_offset = (int )offset & 4095;
  data_page_index = (int )((unsigned int )(data_ptr / 4096ULL) - (unsigned int )first_data_page);
  data_page_offset = (int )data_ptr & 4095;
  page_length = (int )remain;
  if ((unsigned int )(shmem_page_offset + page_length) > 4096U) {
    page_length = (int )(4096U - (unsigned int )shmem_page_offset);
  } else {
  }
  if ((unsigned int )(data_page_offset + page_length) > 4096U) {
    page_length = (int )(4096U - (unsigned int )data_page_offset);
  } else {
  }
  {
  page = shmem_read_mapping_page(mapping, (unsigned long )(offset >> 12));
  tmp___4 = IS_ERR((void const *)page);
  }
  if (tmp___4 != 0L) {
    {
    tmp___3 = PTR_ERR((void const *)page);
    ret = (int )tmp___3;
    }
    goto out;
  } else {
  }
  if (do_bit17_swizzling != 0) {
    {
    slow_shmem_bit17_copy(page, shmem_page_offset, *(user_pages + (unsigned long )data_page_index),
                          data_page_offset, page_length, 1);
    }
  } else {
    {
    slow_shmem_copy(*(user_pages + (unsigned long )data_page_index), data_page_offset,
                    page, shmem_page_offset, page_length);
    }
  }
  {
  mark_page_accessed(page);
  put_page(page);
  remain = remain - (ssize_t )page_length;
  data_ptr = (uint64_t )page_length + data_ptr;
  offset = (loff_t )page_length + offset;
  }
  ldv_38912: ;
  if (remain > 0L) {
    goto ldv_38911;
  } else {
    goto ldv_38913;
  }
  ldv_38913: ;
  out:
  i = 0LL;
  goto ldv_38915;
  ldv_38914:
  {
  SetPageDirty(*(user_pages + (unsigned long )i));
  mark_page_accessed(*(user_pages + (unsigned long )i));
  put_page(*(user_pages + (unsigned long )i));
  i = i + 1LL;
  }
  ldv_38915: ;
  if (i < pinned_pages) {
    goto ldv_38914;
  } else {
    goto ldv_38916;
  }
  ldv_38916:
  {
  drm_free_large((void *)user_pages);
  }
  return (ret);
}
}
int i915_gem_pread_ioctl(struct drm_device *dev , void *data , struct drm_file *file )
{ struct drm_i915_gem_pread *args ;
  struct drm_i915_gem_object *obj ;
  int ret ;
  unsigned long flag ;
  unsigned long roksum ;
  struct thread_info *tmp ;
  long tmp___0 ;
  struct drm_gem_object const *__mptr ;
  struct drm_gem_object *tmp___1 ;
  int tmp___2 ;
  {
  args = (struct drm_i915_gem_pread *)data;
  ret = 0;
  if (args->size == 0ULL) {
    return (0);
  } else {
  }
  {
  tmp = current_thread_info();
  __asm__ ("add %3,%1 ; sbb %0,%0 ; cmp %1,%4 ; sbb $0,%0": "=&r" (flag), "=r" (roksum): "1" ((char *)args->data_ptr),
            "g" ((long )args->size), "rm" (tmp->addr_limit.seg));
  tmp___0 = __builtin_expect((long )(flag == 0UL), 1L);
  }
  if (tmp___0 == 0L) {
    return (-14);
  } else {
  }
  {
  ret = fault_in_pages_writeable((char *)args->data_ptr, (int )args->size);
  }
  if (ret != 0) {
    return (-14);
  } else {
  }
  {
  ret = i915_mutex_lock_interruptible(dev);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  tmp___1 = drm_gem_object_lookup(dev, file, args->handle);
  __mptr = (struct drm_gem_object const *)tmp___1;
  obj = (struct drm_i915_gem_object *)__mptr;
  }
  if ((unsigned long )(& obj->base) == (unsigned long )((struct drm_gem_object *)0)) {
    ret = -2;
    goto unlock;
  } else {
  }
  if (args->offset > (unsigned long long )obj->base.size) {
    ret = -22;
    goto out;
  } else
  if (args->size > (unsigned long long )obj->base.size - args->offset) {
    ret = -22;
    goto out;
  } else {
  }
  {
  trace_i915_gem_object_pread(obj, (u32 )args->offset, (u32 )args->size);
  ret = i915_gem_object_set_cpu_read_domain_range(obj, args->offset, args->size);
  }
  if (ret != 0) {
    goto out;
  } else {
  }
  {
  ret = -14;
  tmp___2 = i915_gem_object_needs_bit17_swizzle(obj);
  }
  if (tmp___2 == 0) {
    {
    ret = i915_gem_shmem_pread_fast(dev, obj, args, file);
    }
  } else {
  }
  if (ret == -14) {
    {
    ret = i915_gem_shmem_pread_slow(dev, obj, args, file);
    }
  } else {
  }
  out:
  {
  drm_gem_object_unreference(& obj->base);
  }
  unlock:
  {
  mutex_unlock(& dev->struct_mutex);
  }
  return (ret);
}
}
__inline static int fast_user_write(struct io_mapping *mapping , loff_t page_base ,
                                    int page_offset___0 , char *user_data , int length )
{ char *vaddr_atomic ;
  unsigned long unwritten ;
  void *tmp ;
  int tmp___0 ;
  {
  {
  tmp = io_mapping_map_atomic_wc(mapping, (unsigned long )page_base);
  vaddr_atomic = (char *)tmp;
  tmp___0 = __copy_from_user_inatomic_nocache((void *)vaddr_atomic + (unsigned long )page_offset___0,
                                              (void const *)user_data, (unsigned int )length);
  unwritten = (unsigned long )tmp___0;
  io_mapping_unmap_atomic((void *)vaddr_atomic);
  }
  return ((int )unwritten);
}
}
__inline static void slow_kernel_write(struct io_mapping *mapping , loff_t gtt_base ,
                                       int gtt_offset , struct page *user_page , int user_offset ,
                                       int length )
{ char *dst_vaddr ;
  char *src_vaddr ;
  void *tmp ;
  void *tmp___0 ;
  {
  {
  tmp = io_mapping_map_atomic_wc(mapping, (unsigned long )gtt_base);
  dst_vaddr = (char *)tmp;
  tmp___0 = kmap(user_page);
  src_vaddr = (char *)tmp___0;
  memcpy_toio((void volatile *)dst_vaddr + (unsigned long )gtt_offset, (void const *)src_vaddr + (unsigned long )user_offset,
              (size_t )length);
  kunmap(user_page);
  io_mapping_unmap_atomic((void *)dst_vaddr);
  }
  return;
}
}
static int i915_gem_gtt_pwrite_fast(struct drm_device *dev , struct drm_i915_gem_object *obj ,
                                    struct drm_i915_gem_pwrite *args , struct drm_file *file )
{ drm_i915_private_t *dev_priv ;
  ssize_t remain ;
  loff_t offset ;
  loff_t page_base ;
  char *user_data ;
  int page_offset___0 ;
  int page_length ;
  int tmp ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  user_data = (char *)args->data_ptr;
  remain = (ssize_t )args->size;
  offset = (loff_t )((__u64 )obj->gtt_offset + args->offset);
  goto ldv_38965;
  ldv_38964:
  page_base = offset & -4096LL;
  page_offset___0 = (int )offset & 4095;
  page_length = (int )remain;
  if ((unsigned long )((ssize_t )page_offset___0 + remain) > 4096UL) {
    page_length = (int )(4096U - (unsigned int )page_offset___0);
  } else {
  }
  {
  tmp = fast_user_write(dev_priv->mm.gtt_mapping, page_base, page_offset___0, user_data,
                        page_length);
  }
  if (tmp != 0) {
    return (-14);
  } else {
  }
  remain = remain - (ssize_t )page_length;
  user_data = user_data + (unsigned long )page_length;
  offset = (loff_t )page_length + offset;
  ldv_38965: ;
  if (remain > 0L) {
    goto ldv_38964;
  } else {
    goto ldv_38966;
  }
  ldv_38966: ;
  return (0);
}
}
static int i915_gem_gtt_pwrite_slow(struct drm_device *dev , struct drm_i915_gem_object *obj ,
                                    struct drm_i915_gem_pwrite *args , struct drm_file *file )
{ drm_i915_private_t *dev_priv ;
  ssize_t remain ;
  loff_t gtt_page_base ;
  loff_t offset ;
  loff_t first_data_page ;
  loff_t last_data_page ;
  loff_t num_pages ;
  loff_t pinned_pages ;
  loff_t i ;
  struct page **user_pages ;
  struct mm_struct *mm ;
  struct task_struct *tmp ;
  int gtt_page_offset ;
  int data_page_offset ;
  int data_page_index ;
  int page_length ;
  int ret ;
  uint64_t data_ptr ;
  void *tmp___0 ;
  struct task_struct *tmp___1 ;
  int tmp___2 ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = get_current();
  mm = tmp->mm;
  data_ptr = args->data_ptr;
  remain = (ssize_t )args->size;
  first_data_page = (loff_t )(data_ptr / 4096ULL);
  last_data_page = (loff_t )(((args->size + data_ptr) - 1ULL) / 4096ULL);
  num_pages = (last_data_page - first_data_page) + 1LL;
  tmp___0 = drm_malloc_ab((size_t )num_pages, 8UL);
  user_pages = (struct page **)tmp___0;
  }
  if ((unsigned long )user_pages == (unsigned long )((struct page **)0)) {
    return (-12);
  } else {
  }
  {
  mutex_unlock(& dev->struct_mutex);
  down_read(& mm->mmap_sem);
  tmp___1 = get_current();
  tmp___2 = get_user_pages(tmp___1, mm, (unsigned long )args->data_ptr, (int )num_pages,
                           0, 0, user_pages, (struct vm_area_struct **)0);
  pinned_pages = (loff_t )tmp___2;
  up_read(& mm->mmap_sem);
  mutex_lock_nested(& dev->struct_mutex, 0U);
  }
  if (pinned_pages < num_pages) {
    ret = -14;
    goto out_unpin_pages;
  } else {
  }
  {
  ret = i915_gem_object_set_to_gtt_domain(obj, (bool )1);
  }
  if (ret != 0) {
    goto out_unpin_pages;
  } else {
  }
  {
  ret = i915_gem_object_put_fence(obj);
  }
  if (ret != 0) {
    goto out_unpin_pages;
  } else {
  }
  offset = (loff_t )((__u64 )obj->gtt_offset + args->offset);
  goto ldv_38992;
  ldv_38991:
  gtt_page_base = offset & -4096LL;
  gtt_page_offset = (int )offset & 4095;
  data_page_index = (int )((unsigned int )(data_ptr / 4096ULL) - (unsigned int )first_data_page);
  data_page_offset = (int )data_ptr & 4095;
  page_length = (int )remain;
  if ((unsigned int )(gtt_page_offset + page_length) > 4096U) {
    page_length = (int )(4096U - (unsigned int )gtt_page_offset);
  } else {
  }
  if ((unsigned int )(data_page_offset + page_length) > 4096U) {
    page_length = (int )(4096U - (unsigned int )data_page_offset);
  } else {
  }
  {
  slow_kernel_write(dev_priv->mm.gtt_mapping, gtt_page_base, gtt_page_offset, *(user_pages + (unsigned long )data_page_index),
                    data_page_offset, page_length);
  remain = remain - (ssize_t )page_length;
  offset = (loff_t )page_length + offset;
  data_ptr = (uint64_t )page_length + data_ptr;
  }
  ldv_38992: ;
  if (remain > 0L) {
    goto ldv_38991;
  } else {
    goto ldv_38993;
  }
  ldv_38993: ;
  out_unpin_pages:
  i = 0LL;
  goto ldv_38995;
  ldv_38994:
  {
  put_page(*(user_pages + (unsigned long )i));
  i = i + 1LL;
  }
  ldv_38995: ;
  if (i < pinned_pages) {
    goto ldv_38994;
  } else {
    goto ldv_38996;
  }
  ldv_38996:
  {
  drm_free_large((void *)user_pages);
  }
  return (ret);
}
}
static int i915_gem_shmem_pwrite_fast(struct drm_device *dev , struct drm_i915_gem_object *obj ,
                                      struct drm_i915_gem_pwrite *args , struct drm_file *file )
{ struct address_space *mapping ;
  ssize_t remain ;
  loff_t offset ;
  char *user_data ;
  int page_offset___0 ;
  int page_length ;
  struct page *page ;
  char *vaddr ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  {
  mapping = (((obj->base.filp)->f_path.dentry)->d_inode)->i_mapping;
  user_data = (char *)args->data_ptr;
  remain = (ssize_t )args->size;
  offset = (loff_t )args->offset;
  obj->dirty = (unsigned char)1;
  goto ldv_39013;
  ldv_39012:
  page_offset___0 = (int )offset & 4095;
  page_length = (int )remain;
  if ((unsigned long )((ssize_t )page_offset___0 + remain) > 4096UL) {
    page_length = (int )(4096U - (unsigned int )page_offset___0);
  } else {
  }
  {
  page = shmem_read_mapping_page(mapping, (unsigned long )(offset >> 12));
  tmp___0 = IS_ERR((void const *)page);
  }
  if (tmp___0 != 0L) {
    {
    tmp = PTR_ERR((void const *)page);
    }
    return ((int )tmp);
  } else {
  }
  {
  tmp___1 = __kmap_atomic(page);
  vaddr = (char *)tmp___1;
  ret = __copy_from_user_inatomic((void *)vaddr + (unsigned long )page_offset___0,
                                  (void const *)user_data, (unsigned int )page_length);
  __kunmap_atomic((void *)vaddr);
  set_page_dirty(page);
  mark_page_accessed(page);
  put_page(page);
  }
  if (ret != 0) {
    return (-14);
  } else {
  }
  remain = remain - (ssize_t )page_length;
  user_data = user_data + (unsigned long )page_length;
  offset = (loff_t )page_length + offset;
  ldv_39013: ;
  if (remain > 0L) {
    goto ldv_39012;
  } else {
    goto ldv_39014;
  }
  ldv_39014: ;
  return (0);
}
}
static int i915_gem_shmem_pwrite_slow(struct drm_device *dev , struct drm_i915_gem_object *obj ,
                                      struct drm_i915_gem_pwrite *args , struct drm_file *file )
{ struct address_space *mapping ;
  struct mm_struct *mm ;
  struct task_struct *tmp ;
  struct page **user_pages ;
  ssize_t remain ;
  loff_t offset ;
  loff_t pinned_pages ;
  loff_t i ;
  loff_t first_data_page ;
  loff_t last_data_page ;
  loff_t num_pages ;
  int shmem_page_offset ;
  int data_page_index ;
  int data_page_offset ;
  int page_length ;
  int ret ;
  uint64_t data_ptr ;
  int do_bit17_swizzling ;
  void *tmp___0 ;
  struct task_struct *tmp___1 ;
  int tmp___2 ;
  struct page *page ;
  long tmp___3 ;
  long tmp___4 ;
  {
  {
  mapping = (((obj->base.filp)->f_path.dentry)->d_inode)->i_mapping;
  tmp = get_current();
  mm = tmp->mm;
  data_ptr = args->data_ptr;
  remain = (ssize_t )args->size;
  first_data_page = (loff_t )(data_ptr / 4096ULL);
  last_data_page = (loff_t )(((args->size + data_ptr) - 1ULL) / 4096ULL);
  num_pages = (last_data_page - first_data_page) + 1LL;
  tmp___0 = drm_malloc_ab((size_t )num_pages, 8UL);
  user_pages = (struct page **)tmp___0;
  }
  if ((unsigned long )user_pages == (unsigned long )((struct page **)0)) {
    return (-12);
  } else {
  }
  {
  mutex_unlock(& dev->struct_mutex);
  down_read(& mm->mmap_sem);
  tmp___1 = get_current();
  tmp___2 = get_user_pages(tmp___1, mm, (unsigned long )args->data_ptr, (int )num_pages,
                           0, 0, user_pages, (struct vm_area_struct **)0);
  pinned_pages = (loff_t )tmp___2;
  up_read(& mm->mmap_sem);
  mutex_lock_nested(& dev->struct_mutex, 0U);
  }
  if (pinned_pages < num_pages) {
    ret = -14;
    goto out;
  } else {
  }
  {
  ret = i915_gem_object_set_to_cpu_domain(obj, (bool )1);
  }
  if (ret != 0) {
    goto out;
  } else {
  }
  {
  do_bit17_swizzling = i915_gem_object_needs_bit17_swizzle(obj);
  offset = (loff_t )args->offset;
  obj->dirty = (unsigned char)1;
  }
  goto ldv_39041;
  ldv_39040:
  shmem_page_offset = (int )offset & 4095;
  data_page_index = (int )((unsigned int )(data_ptr / 4096ULL) - (unsigned int )first_data_page);
  data_page_offset = (int )data_ptr & 4095;
  page_length = (int )remain;
  if ((unsigned int )(shmem_page_offset + page_length) > 4096U) {
    page_length = (int )(4096U - (unsigned int )shmem_page_offset);
  } else {
  }
  if ((unsigned int )(data_page_offset + page_length) > 4096U) {
    page_length = (int )(4096U - (unsigned int )data_page_offset);
  } else {
  }
  {
  page = shmem_read_mapping_page(mapping, (unsigned long )(offset >> 12));
  tmp___4 = IS_ERR((void const *)page);
  }
  if (tmp___4 != 0L) {
    {
    tmp___3 = PTR_ERR((void const *)page);
    ret = (int )tmp___3;
    }
    goto out;
  } else {
  }
  if (do_bit17_swizzling != 0) {
    {
    slow_shmem_bit17_copy(page, shmem_page_offset, *(user_pages + (unsigned long )data_page_index),
                          data_page_offset, page_length, 0);
    }
  } else {
    {
    slow_shmem_copy(page, shmem_page_offset, *(user_pages + (unsigned long )data_page_index),
                    data_page_offset, page_length);
    }
  }
  {
  set_page_dirty(page);
  mark_page_accessed(page);
  put_page(page);
  remain = remain - (ssize_t )page_length;
  data_ptr = (uint64_t )page_length + data_ptr;
  offset = (loff_t )page_length + offset;
  }
  ldv_39041: ;
  if (remain > 0L) {
    goto ldv_39040;
  } else {
    goto ldv_39042;
  }
  ldv_39042: ;
  out:
  i = 0LL;
  goto ldv_39044;
  ldv_39043:
  {
  put_page(*(user_pages + (unsigned long )i));
  i = i + 1LL;
  }
  ldv_39044: ;
  if (i < pinned_pages) {
    goto ldv_39043;
  } else {
    goto ldv_39045;
  }
  ldv_39045:
  {
  drm_free_large((void *)user_pages);
  }
  return (ret);
}
}
int i915_gem_pwrite_ioctl(struct drm_device *dev , void *data , struct drm_file *file )
{ struct drm_i915_gem_pwrite *args ;
  struct drm_i915_gem_object *obj ;
  int ret ;
  unsigned long flag ;
  unsigned long roksum ;
  struct thread_info *tmp ;
  long tmp___0 ;
  struct drm_gem_object const *__mptr ;
  struct drm_gem_object *tmp___1 ;
  int tmp___2 ;
  {
  args = (struct drm_i915_gem_pwrite *)data;
  if (args->size == 0ULL) {
    return (0);
  } else {
  }
  {
  tmp = current_thread_info();
  __asm__ ("add %3,%1 ; sbb %0,%0 ; cmp %1,%4 ; sbb $0,%0": "=&r" (flag), "=r" (roksum): "1" ((char *)args->data_ptr),
            "g" ((long )args->size), "rm" (tmp->addr_limit.seg));
  tmp___0 = __builtin_expect((long )(flag == 0UL), 1L);
  }
  if (tmp___0 == 0L) {
    return (-14);
  } else {
  }
  {
  ret = fault_in_pages_readable((char const *)args->data_ptr, (int )args->size);
  }
  if (ret != 0) {
    return (-14);
  } else {
  }
  {
  ret = i915_mutex_lock_interruptible(dev);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  tmp___1 = drm_gem_object_lookup(dev, file, args->handle);
  __mptr = (struct drm_gem_object const *)tmp___1;
  obj = (struct drm_i915_gem_object *)__mptr;
  }
  if ((unsigned long )(& obj->base) == (unsigned long )((struct drm_gem_object *)0)) {
    ret = -2;
    goto unlock;
  } else {
  }
  if (args->offset > (unsigned long long )obj->base.size) {
    ret = -22;
    goto out;
  } else
  if (args->size > (unsigned long long )obj->base.size - args->offset) {
    ret = -22;
    goto out;
  } else {
  }
  {
  trace_i915_gem_object_pwrite(obj, (u32 )args->offset, (u32 )args->size);
  }
  if ((unsigned long )obj->phys_obj != (unsigned long )((struct drm_i915_gem_phys_object *)0)) {
    {
    ret = i915_gem_phys_pwrite(dev, obj, args, file);
    }
  } else
  if ((unsigned long )obj->gtt_space != (unsigned long )((struct drm_mm_node *)0)) {
    if (obj->base.write_domain != 1U) {
      {
      ret = i915_gem_object_pin(obj, 0U, (bool )1);
      }
      if (ret != 0) {
        goto out;
      } else {
      }
      {
      ret = i915_gem_object_set_to_gtt_domain(obj, (bool )1);
      }
      if (ret != 0) {
        goto out_unpin;
      } else {
      }
      {
      ret = i915_gem_object_put_fence(obj);
      }
      if (ret != 0) {
        goto out_unpin;
      } else {
      }
      {
      ret = i915_gem_gtt_pwrite_fast(dev, obj, args, file);
      }
      if (ret == -14) {
        {
        ret = i915_gem_gtt_pwrite_slow(dev, obj, args, file);
        }
      } else {
      }
      out_unpin:
      {
      i915_gem_object_unpin(obj);
      }
    } else {
      goto _L;
    }
  } else {
    _L:
    {
    ret = i915_gem_object_set_to_cpu_domain(obj, (bool )1);
    }
    if (ret != 0) {
      goto out;
    } else {
    }
    {
    ret = -14;
    tmp___2 = i915_gem_object_needs_bit17_swizzle(obj);
    }
    if (tmp___2 == 0) {
      {
      ret = i915_gem_shmem_pwrite_fast(dev, obj, args, file);
      }
    } else {
    }
    if (ret == -14) {
      {
      ret = i915_gem_shmem_pwrite_slow(dev, obj, args, file);
      }
    } else {
    }
  }
  out:
  {
  drm_gem_object_unreference(& obj->base);
  }
  unlock:
  {
  mutex_unlock(& dev->struct_mutex);
  }
  return (ret);
}
}
int i915_gem_set_domain_ioctl(struct drm_device *dev , void *data , struct drm_file *file )
{ struct drm_i915_gem_set_domain *args ;
  struct drm_i915_gem_object *obj ;
  uint32_t read_domains ;
  uint32_t write_domain ;
  int ret ;
  struct drm_gem_object const *__mptr ;
  struct drm_gem_object *tmp ;
  {
  args = (struct drm_i915_gem_set_domain *)data;
  read_domains = args->read_domains;
  write_domain = args->write_domain;
  if (((dev->driver)->driver_features & 4096U) == 0U) {
    return (-19);
  } else {
  }
  if ((write_domain & 4294967230U) != 0U) {
    return (-22);
  } else {
  }
  if ((read_domains & 4294967230U) != 0U) {
    return (-22);
  } else {
  }
  if (write_domain != 0U) {
    if (read_domains != write_domain) {
      return (-22);
    } else {
    }
  } else {
  }
  {
  ret = i915_mutex_lock_interruptible(dev);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  tmp = drm_gem_object_lookup(dev, file, args->handle);
  __mptr = (struct drm_gem_object const *)tmp;
  obj = (struct drm_i915_gem_object *)__mptr;
  }
  if ((unsigned long )(& obj->base) == (unsigned long )((struct drm_gem_object *)0)) {
    ret = -2;
    goto unlock;
  } else {
  }
  if ((read_domains & 64U) != 0U) {
    {
    ret = i915_gem_object_set_to_gtt_domain(obj, (bool )(write_domain != 0U));
    }
    if (ret == -22) {
      ret = 0;
    } else {
    }
  } else {
    {
    ret = i915_gem_object_set_to_cpu_domain(obj, (bool )(write_domain != 0U));
    }
  }
  {
  drm_gem_object_unreference(& obj->base);
  }
  unlock:
  {
  mutex_unlock(& dev->struct_mutex);
  }
  return (ret);
}
}
int i915_gem_sw_finish_ioctl(struct drm_device *dev , void *data , struct drm_file *file )
{ struct drm_i915_gem_sw_finish *args ;
  struct drm_i915_gem_object *obj ;
  int ret ;
  struct drm_gem_object const *__mptr ;
  struct drm_gem_object *tmp ;
  {
  args = (struct drm_i915_gem_sw_finish *)data;
  ret = 0;
  if (((dev->driver)->driver_features & 4096U) == 0U) {
    return (-19);
  } else {
  }
  {
  ret = i915_mutex_lock_interruptible(dev);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  tmp = drm_gem_object_lookup(dev, file, args->handle);
  __mptr = (struct drm_gem_object const *)tmp;
  obj = (struct drm_i915_gem_object *)__mptr;
  }
  if ((unsigned long )(& obj->base) == (unsigned long )((struct drm_gem_object *)0)) {
    ret = -2;
    goto unlock;
  } else {
  }
  if (*((unsigned int *)obj + 56UL) != 0U) {
    {
    i915_gem_object_flush_cpu_write_domain(obj);
    }
  } else {
  }
  {
  drm_gem_object_unreference(& obj->base);
  }
  unlock:
  {
  mutex_unlock(& dev->struct_mutex);
  }
  return (ret);
}
}
int i915_gem_mmap_ioctl(struct drm_device *dev , void *data , struct drm_file *file )
{ struct drm_i915_private *dev_priv ;
  struct drm_i915_gem_mmap *args ;
  struct drm_gem_object *obj ;
  unsigned long addr ;
  struct task_struct *tmp ;
  struct task_struct *tmp___0 ;
  long tmp___1 ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  args = (struct drm_i915_gem_mmap *)data;
  if (((dev->driver)->driver_features & 4096U) == 0U) {
    return (-19);
  } else {
  }
  {
  obj = drm_gem_object_lookup(dev, file, args->handle);
  }
  if ((unsigned long )obj == (unsigned long )((struct drm_gem_object *)0)) {
    return (-2);
  } else {
  }
  if (obj->size > dev_priv->mm.gtt_mappable_end) {
    {
    drm_gem_object_unreference_unlocked(obj);
    }
    return (-7);
  } else {
  }
  {
  tmp = get_current();
  down_write(& (tmp->mm)->mmap_sem);
  addr = do_mmap(obj->filp, 0UL, (unsigned long )args->size, 3UL, 1UL, (unsigned long )args->offset);
  tmp___0 = get_current();
  up_write(& (tmp___0->mm)->mmap_sem);
  drm_gem_object_unreference_unlocked(obj);
  tmp___1 = IS_ERR((void const *)addr);
  }
  if (tmp___1 != 0L) {
    return ((int )addr);
  } else {
  }
  args->addr_ptr = (unsigned long long )addr;
  return (0);
}
}
int i915_gem_fault(struct vm_area_struct *vma , struct vm_fault *vmf )
{ struct drm_i915_gem_object *obj ;
  struct drm_gem_object const *__mptr ;
  struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  unsigned long page_offset___0 ;
  unsigned long pfn ;
  int ret ;
  bool write ;
  bool tmp ;
  struct thread_info *tmp___0 ;
  {
  {
  __mptr = (struct drm_gem_object const *)vma->vm_private_data;
  obj = (struct drm_i915_gem_object *)__mptr;
  dev = obj->base.dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ret = 0;
  write = (bool )(((int )vmf->flags & 1) != 0);
  page_offset___0 = ((unsigned long )vmf->virtual_address - vma->vm_start) >> 12;
  ret = i915_mutex_lock_interruptible(dev);
  }
  if (ret != 0) {
    goto out;
  } else {
  }
  {
  trace_i915_gem_object_fault(obj, (u32 )page_offset___0, (bool )1, (bool )((int )write));
  }
  if ((unsigned int )*((unsigned char *)obj + 226UL) == 0U) {
    {
    ret = i915_gem_object_unbind(obj);
    }
    if (ret != 0) {
      goto unlock;
    } else {
    }
  } else {
  }
  if ((unsigned long )obj->gtt_space == (unsigned long )((struct drm_mm_node *)0)) {
    {
    ret = i915_gem_object_bind_to_gtt(obj, 0U, (bool )1);
    }
    if (ret != 0) {
      goto unlock;
    } else {
    }
    {
    ret = i915_gem_object_set_to_gtt_domain(obj, (bool )((int )write));
    }
    if (ret != 0) {
      goto unlock;
    } else {
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)obj + 225UL) == 0U) {
    {
    ret = i915_gem_object_put_fence(obj);
    }
  } else {
    {
    ret = i915_gem_object_get_fence(obj, (struct intel_ring_buffer *)0);
    }
  }
  if (ret != 0) {
    goto unlock;
  } else {
  }
  {
  tmp = i915_gem_object_is_inactive(obj);
  }
  if ((int )tmp) {
    {
    list_move_tail(& obj->mm_list, & dev_priv->mm.inactive_list);
    }
  } else {
  }
  {
  obj->fault_mappable = (unsigned char)1;
  pfn = (((dev->agp)->base + (unsigned long )obj->gtt_offset) >> 12) + page_offset___0;
  ret = vm_insert_pfn(vma, (unsigned long )vmf->virtual_address, pfn);
  }
  unlock:
  {
  mutex_unlock(& dev->struct_mutex);
  }
  out: ;
  if (ret == -5) {
    goto case_neg_5;
  } else
  if (ret == -11) {
    goto case_neg_11;
  } else
  if (ret == 0) {
    goto case_0;
  } else
  if (ret == -512) {
    goto case_neg_512;
  } else
  if (ret == -4) {
    goto case_neg_4;
  } else
  if (ret == -12) {
    goto case_neg_12;
  } else {
    goto switch_default;
    if (0) {
      case_neg_5: ;
      case_neg_11:
      {
      tmp___0 = current_thread_info();
      set_ti_thread_flag(tmp___0, 3);
      }
      case_0: ;
      case_neg_512: ;
      case_neg_4: ;
      return (256);
      case_neg_12: ;
      return (1);
      switch_default: ;
      return (2);
    } else {
    }
  }
}
}
static int i915_gem_create_mmap_offset(struct drm_i915_gem_object *obj )
{ struct drm_device *dev ;
  struct drm_gem_mm *mm ;
  struct drm_map_list *list ;
  struct drm_local_map *map ;
  int ret ;
  void *tmp ;
  {
  {
  dev = obj->base.dev;
  mm = (struct drm_gem_mm *)dev->mm_private;
  ret = 0;
  list = & obj->base.map_list;
  tmp = kzalloc(72UL, 208U);
  list->map = (struct drm_local_map *)tmp;
  }
  if ((unsigned long )list->map == (unsigned long )((struct drm_local_map *)0)) {
    return (-12);
  } else {
  }
  {
  map = list->map;
  map->type = (enum drm_map_type )6;
  map->size = obj->base.size;
  map->handle = (void *)obj;
  list->file_offset_node = drm_mm_search_free((struct drm_mm const *)(& mm->offset_manager),
                                              obj->base.size / 4096UL, 0U, 0);
  }
  if ((unsigned long )list->file_offset_node == (unsigned long )((struct drm_mm_node *)0)) {
    {
    drm_err("i915_gem_create_mmap_offset", "failed to allocate offset for bo %d\n",
            obj->base.name);
    ret = -28;
    }
    goto out_free_list;
  } else {
  }
  {
  list->file_offset_node = drm_mm_get_block(list->file_offset_node, obj->base.size / 4096UL,
                                            0U);
  }
  if ((unsigned long )list->file_offset_node == (unsigned long )((struct drm_mm_node *)0)) {
    ret = -12;
    goto out_free_list;
  } else {
  }
  {
  list->hash.key = (list->file_offset_node)->start;
  ret = drm_ht_insert_item(& mm->offset_hash, & list->hash);
  }
  if (ret != 0) {
    {
    drm_err("i915_gem_create_mmap_offset", "failed to add to map hash\n");
    }
    goto out_free_mm;
  } else {
  }
  return (0);
  out_free_mm:
  {
  drm_mm_put_block(list->file_offset_node);
  }
  out_free_list:
  {
  kfree((void const *)list->map);
  list->map = (struct drm_local_map *)0;
  }
  return (ret);
}
}
void i915_gem_release_mmap(struct drm_i915_gem_object *obj )
{
  {
  if ((unsigned int )*((unsigned char *)obj + 226UL) == 0U) {
    return;
  } else {
  }
  if ((unsigned long )(obj->base.dev)->dev_mapping != (unsigned long )((struct address_space *)0)) {
    {
    unmap_mapping_range((obj->base.dev)->dev_mapping, (loff_t const )((long long )obj->base.map_list.hash.key << 12),
                        (loff_t const )obj->base.size, 1);
    }
  } else {
  }
  obj->fault_mappable = (unsigned char)0;
  return;
}
}
static void i915_gem_free_mmap_offset(struct drm_i915_gem_object *obj )
{ struct drm_device *dev ;
  struct drm_gem_mm *mm ;
  struct drm_map_list *list ;
  {
  {
  dev = obj->base.dev;
  mm = (struct drm_gem_mm *)dev->mm_private;
  list = & obj->base.map_list;
  drm_ht_remove_item(& mm->offset_hash, & list->hash);
  drm_mm_put_block(list->file_offset_node);
  kfree((void const *)list->map);
  list->map = (struct drm_local_map *)0;
  }
  return;
}
}
static uint32_t i915_gem_get_gtt_size(struct drm_device *dev , uint32_t size , int tiling_mode )
{ uint32_t gtt_size ;
  {
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    return (size);
  } else
  if (tiling_mode == 0) {
    return (size);
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 3U) {
    gtt_size = 1048576U;
  } else {
    gtt_size = 524288U;
  }
  goto ldv_39144;
  ldv_39143:
  gtt_size = gtt_size << 1;
  ldv_39144: ;
  if (gtt_size < size) {
    goto ldv_39143;
  } else {
    goto ldv_39145;
  }
  ldv_39145: ;
  return (gtt_size);
}
}
static uint32_t i915_gem_get_gtt_alignment(struct drm_device *dev , uint32_t size ,
                                           int tiling_mode )
{ uint32_t tmp ;
  {
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    return (4096U);
  } else
  if (tiling_mode == 0) {
    return (4096U);
  } else {
  }
  {
  tmp = i915_gem_get_gtt_size(dev, size, tiling_mode);
  }
  return (tmp);
}
}
uint32_t i915_gem_get_unfenced_gtt_alignment(struct drm_device *dev , uint32_t size ,
                                             int tiling_mode )
{ uint32_t tmp ;
  {
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    return (4096U);
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    return (4096U);
  } else
  if (tiling_mode == 0) {
    return (4096U);
  } else {
  }
  {
  tmp = i915_gem_get_gtt_size(dev, size, tiling_mode);
  }
  return (tmp);
}
}
int i915_gem_mmap_gtt(struct drm_file *file , struct drm_device *dev , uint32_t handle ,
                      uint64_t *offset )
{ struct drm_i915_private *dev_priv ;
  struct drm_i915_gem_object *obj ;
  int ret ;
  struct drm_gem_object const *__mptr ;
  struct drm_gem_object *tmp ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if (((dev->driver)->driver_features & 4096U) == 0U) {
    return (-19);
  } else {
  }
  {
  ret = i915_mutex_lock_interruptible(dev);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  tmp = drm_gem_object_lookup(dev, file, handle);
  __mptr = (struct drm_gem_object const *)tmp;
  obj = (struct drm_i915_gem_object *)__mptr;
  }
  if ((unsigned long )(& obj->base) == (unsigned long )((struct drm_gem_object *)0)) {
    ret = -2;
    goto unlock;
  } else {
  }
  if (obj->base.size > dev_priv->mm.gtt_mappable_end) {
    ret = -7;
    goto unlock;
  } else {
  }
  if ((unsigned int )*((unsigned char *)obj + 225UL) != 0U) {
    {
    drm_err("i915_gem_mmap_gtt", "Attempting to mmap a purgeable buffer\n");
    ret = -22;
    }
    goto out;
  } else {
  }
  if ((unsigned long )obj->base.map_list.map == (unsigned long )((struct drm_local_map *)0)) {
    {
    ret = i915_gem_create_mmap_offset(obj);
    }
    if (ret != 0) {
      goto out;
    } else {
    }
  } else {
  }
  *offset = (unsigned long long )obj->base.map_list.hash.key << 12;
  out:
  {
  drm_gem_object_unreference(& obj->base);
  }
  unlock:
  {
  mutex_unlock(& dev->struct_mutex);
  }
  return (ret);
}
}
int i915_gem_mmap_gtt_ioctl(struct drm_device *dev , void *data , struct drm_file *file )
{ struct drm_i915_gem_mmap_gtt *args ;
  int tmp ;
  {
  args = (struct drm_i915_gem_mmap_gtt *)data;
  if (((dev->driver)->driver_features & 4096U) == 0U) {
    return (-19);
  } else {
  }
  {
  tmp = i915_gem_mmap_gtt(file, dev, args->handle, & args->offset);
  }
  return (tmp);
}
}
static int i915_gem_object_get_pages_gtt(struct drm_i915_gem_object *obj , gfp_t gfpmask )
{ int page_count___0 ;
  int i ;
  struct address_space *mapping ;
  struct inode *inode ;
  struct page *page ;
  long tmp ;
  void *tmp___0 ;
  gfp_t tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  {
  {
  page_count___0 = (int )(obj->base.size / 4096UL);
  tmp = __builtin_expect((long )((unsigned long )obj->pages != (unsigned long )((struct page **)0)),
                         0L);
  }
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p"),
                         "i" (1550), "i" (12UL));
    ldv_39185: ;
    goto ldv_39185;
  } else {
  }
  {
  tmp___0 = drm_malloc_ab((size_t )page_count___0, 8UL);
  obj->pages = (struct page **)tmp___0;
  }
  if ((unsigned long )obj->pages == (unsigned long )((struct page **)0)) {
    return (-12);
  } else {
  }
  {
  inode = ((obj->base.filp)->f_path.dentry)->d_inode;
  mapping = inode->i_mapping;
  tmp___1 = mapping_gfp_mask(mapping);
  gfpmask = tmp___1 | gfpmask;
  i = 0;
  }
  goto ldv_39188;
  ldv_39187:
  {
  page = shmem_read_mapping_page_gfp(mapping, (unsigned long )i, gfpmask);
  tmp___2 = IS_ERR((void const *)page);
  }
  if (tmp___2 != 0L) {
    goto err_pages;
  } else {
  }
  *(obj->pages + (unsigned long )i) = page;
  i = i + 1;
  ldv_39188: ;
  if (i < page_count___0) {
    goto ldv_39187;
  } else {
    goto ldv_39189;
  }
  ldv_39189: ;
  if ((unsigned int )*((unsigned char *)obj + 225UL) != 0U) {
    {
    i915_gem_object_do_bit_17_swizzle(obj);
    }
  } else {
  }
  return (0);
  err_pages: ;
  goto ldv_39191;
  ldv_39190:
  {
  put_page(*(obj->pages + (unsigned long )i));
  }
  ldv_39191:
  tmp___3 = i;
  i = i - 1;
  if (tmp___3 != 0) {
    goto ldv_39190;
  } else {
    goto ldv_39192;
  }
  ldv_39192:
  {
  drm_free_large((void *)obj->pages);
  obj->pages = (struct page **)0;
  tmp___4 = PTR_ERR((void const *)page);
  }
  return ((int )tmp___4);
}
}
static void i915_gem_object_put_pages_gtt(struct drm_i915_gem_object *obj )
{ int page_count___0 ;
  int i ;
  long tmp ;
  {
  {
  page_count___0 = (int )(obj->base.size / 4096UL);
  tmp = __builtin_expect((long )((unsigned int )*((unsigned char *)obj + 225UL) == 2U),
                         0L);
  }
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p"),
                         "i" (1587), "i" (12UL));
    ldv_39198: ;
    goto ldv_39198;
  } else {
  }
  if ((unsigned int )*((unsigned char *)obj + 225UL) != 0U) {
    {
    i915_gem_object_save_bit_17_swizzle(obj);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)obj + 225UL) == 1U) {
    obj->dirty = (unsigned char)0;
  } else {
  }
  i = 0;
  goto ldv_39200;
  ldv_39199: ;
  if ((unsigned int )*((unsigned char *)obj + 224UL) != 0U) {
    {
    set_page_dirty(*(obj->pages + (unsigned long )i));
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)obj + 225UL) == 0U) {
    {
    mark_page_accessed(*(obj->pages + (unsigned long )i));
    }
  } else {
  }
  {
  put_page(*(obj->pages + (unsigned long )i));
  i = i + 1;
  }
  ldv_39200: ;
  if (i < page_count___0) {
    goto ldv_39199;
  } else {
    goto ldv_39201;
  }
  ldv_39201:
  {
  obj->dirty = (unsigned char)0;
  drm_free_large((void *)obj->pages);
  obj->pages = (struct page **)0;
  }
  return;
}
}
void i915_gem_object_move_to_active(struct drm_i915_gem_object *obj , struct intel_ring_buffer *ring ,
                                    u32 seqno )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  long tmp ;
  struct drm_i915_fence_reg *reg ;
  long tmp___0 ;
  {
  {
  dev = obj->base.dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = __builtin_expect((long )((unsigned long )ring == (unsigned long )((struct intel_ring_buffer *)0)),
                         0L);
  }
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p"),
                         "i" (1618), "i" (12UL));
    ldv_39209: ;
    goto ldv_39209;
  } else {
  }
  obj->ring = ring;
  if ((unsigned int )*((unsigned char *)obj + 224UL) == 0U) {
    {
    drm_gem_object_reference(& obj->base);
    obj->active = (unsigned char)1;
    }
  } else {
  }
  {
  list_move_tail(& obj->mm_list, & dev_priv->mm.active_list);
  list_move_tail(& obj->ring_list, & ring->active_list);
  obj->last_rendering_seqno = seqno;
  }
  if ((unsigned int )*((unsigned char *)obj + 226UL) != 0U) {
    {
    tmp___0 = __builtin_expect((long )((unsigned int )*((unsigned char *)obj + 224UL) == 248U),
                               0L);
    }
    if (tmp___0 != 0L) {
      __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p"),
                           "i" (1635), "i" (12UL));
      ldv_39211: ;
      goto ldv_39211;
    } else {
    }
    {
    obj->last_fenced_seqno = seqno;
    obj->last_fenced_ring = ring;
    reg = (struct drm_i915_fence_reg *)(& dev_priv->fence_regs) + (unsigned long )obj->fence_reg;
    list_move_tail(& reg->lru_list, & dev_priv->mm.fence_list);
    }
  } else {
  }
  return;
}
}
static void i915_gem_object_move_off_active(struct drm_i915_gem_object *obj )
{
  {
  {
  list_del_init(& obj->ring_list);
  obj->last_rendering_seqno = 0U;
  }
  return;
}
}
static void i915_gem_object_move_to_flushing(struct drm_i915_gem_object *obj )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  long tmp ;
  {
  {
  dev = obj->base.dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = __builtin_expect((long )((unsigned int )*((unsigned char *)obj + 224UL) == 0U),
                         0L);
  }
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p"),
                         "i" (1658), "i" (12UL));
    ldv_39220: ;
    goto ldv_39220;
  } else {
  }
  {
  list_move_tail(& obj->mm_list, & dev_priv->mm.flushing_list);
  i915_gem_object_move_off_active(obj);
  }
  return;
}
}
static void i915_gem_object_move_to_inactive(struct drm_i915_gem_object *obj )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int __ret_warn_on ;
  long tmp___2 ;
  {
  dev = obj->base.dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if (*((unsigned int *)obj + 56UL) != 0U) {
    {
    list_move_tail(& obj->mm_list, & dev_priv->mm.pinned_list);
    }
  } else {
    {
    list_move_tail(& obj->mm_list, & dev_priv->mm.inactive_list);
    }
  }
  {
  tmp = list_empty((struct list_head const *)(& obj->gpu_write_list));
  tmp___0 = __builtin_expect((long )(tmp == 0), 0L);
  }
  if (tmp___0 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p"),
                         "i" (1675), "i" (12UL));
    ldv_39226: ;
    goto ldv_39226;
  } else {
  }
  {
  tmp___1 = __builtin_expect((long )((unsigned int )*((unsigned char *)obj + 224UL) == 0U),
                             0L);
  }
  if (tmp___1 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p"),
                         "i" (1676), "i" (12UL));
    ldv_39227: ;
    goto ldv_39227;
  } else {
  }
  {
  obj->ring = (struct intel_ring_buffer *)0;
  i915_gem_object_move_off_active(obj);
  obj->fenced_gpu_access = (unsigned char)0;
  obj->active = (unsigned char)0;
  obj->pending_gpu_write = (unsigned char)0;
  drm_gem_object_unreference(& obj->base);
  __ret_warn_on = 0;
  tmp___2 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp___2 != 0L) {
    {
    warn_slowpath_null("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p",
                       (int const )1686);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  return;
}
}
static void i915_gem_object_truncate(struct drm_i915_gem_object *obj )
{ struct inode *inode ;
  {
  {
  inode = ((obj->base.filp)->f_path.dentry)->d_inode;
  shmem_truncate_range(inode, 0LL, -1LL);
  obj->madv = (unsigned char)2;
  }
  return;
}
}
__inline static int i915_gem_object_is_purgeable(struct drm_i915_gem_object *obj )
{
  {
  return ((unsigned int )*((unsigned char *)obj + 225UL) == 1U);
}
}
static void i915_gem_process_flushing_list(struct intel_ring_buffer *ring , uint32_t flush_domains )
{ struct drm_i915_gem_object *obj ;
  struct drm_i915_gem_object *next ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  uint32_t old_write_domain ;
  u32 tmp ;
  struct list_head const *__mptr___1 ;
  {
  __mptr = (struct list_head const *)ring->gpu_write_list.next;
  obj = (struct drm_i915_gem_object *)__mptr + 0x0fffffffffffff40UL;
  __mptr___0 = (struct list_head const *)obj->gpu_write_list.next;
  next = (struct drm_i915_gem_object *)__mptr___0 + 0x0fffffffffffff40UL;
  goto ldv_39251;
  ldv_39250: ;
  if ((obj->base.write_domain & flush_domains) != 0U) {
    {
    old_write_domain = obj->base.write_domain;
    obj->base.write_domain = 0U;
    list_del_init(& obj->gpu_write_list);
    tmp = i915_gem_next_request_seqno(ring);
    i915_gem_object_move_to_active(obj, ring, tmp);
    trace_i915_gem_object_change_domain(obj, obj->base.read_domains, old_write_domain);
    }
  } else {
  }
  obj = next;
  __mptr___1 = (struct list_head const *)next->gpu_write_list.next;
  next = (struct drm_i915_gem_object *)__mptr___1 + 0x0fffffffffffff40UL;
  ldv_39251: ;
  if ((unsigned long )(& obj->gpu_write_list) != (unsigned long )(& ring->gpu_write_list)) {
    goto ldv_39250;
  } else {
    goto ldv_39252;
  }
  ldv_39252: ;
  return;
}
}
int i915_add_request(struct intel_ring_buffer *ring , struct drm_file *file , struct drm_i915_gem_request *request )
{ drm_i915_private_t *dev_priv ;
  uint32_t seqno ;
  int was_empty ;
  int ret ;
  long tmp ;
  struct drm_i915_file_private *file_priv ;
  unsigned long tmp___0 ;
  {
  {
  dev_priv = (drm_i915_private_t *)(ring->dev)->dev_private;
  tmp = __builtin_expect((long )((unsigned long )request == (unsigned long )((struct drm_i915_gem_request *)0)),
                         0L);
  }
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p"),
                         "i" (1746), "i" (12UL));
    ldv_39262: ;
    goto ldv_39262;
  } else {
  }
  {
  ret = (*(ring->add_request))(ring, & seqno);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  trace_i915_gem_request_add(ring, seqno);
  request->seqno = seqno;
  request->ring = ring;
  request->emitted_jiffies = (unsigned long )jiffies;
  was_empty = list_empty((struct list_head const *)(& ring->request_list));
  list_add_tail(& request->list, & ring->request_list);
  }
  if ((unsigned long )file != (unsigned long )((struct drm_file *)0)) {
    {
    file_priv = (struct drm_i915_file_private *)file->driver_priv;
    spin_lock(& file_priv->mm.lock);
    request->file_priv = file_priv;
    list_add_tail(& request->client_list, & file_priv->mm.request_list);
    spin_unlock(& file_priv->mm.lock);
    }
  } else {
  }
  ring->outstanding_lazy_request = 0U;
  if (dev_priv->mm.suspended == 0) {
    {
    tmp___0 = msecs_to_jiffies((unsigned int const )1500U);
    mod_timer(& dev_priv->hangcheck_timer, tmp___0 + (unsigned long )jiffies);
    }
    if (was_empty != 0) {
      {
      queue_delayed_work(dev_priv->wq, & dev_priv->mm.retire_work, 250UL);
      }
    } else {
    }
  } else {
  }
  return (0);
}
}
__inline static void i915_gem_request_remove_from_client(struct drm_i915_gem_request *request )
{ struct drm_i915_file_private *file_priv ;
  {
  file_priv = request->file_priv;
  if ((unsigned long )file_priv == (unsigned long )((struct drm_i915_file_private *)0)) {
    return;
  } else {
  }
  {
  spin_lock(& file_priv->mm.lock);
  }
  if ((unsigned long )request->file_priv != (unsigned long )((struct drm_i915_file_private *)0)) {
    {
    list_del(& request->client_list);
    request->file_priv = (struct drm_i915_file_private *)0;
    }
  } else {
  }
  {
  spin_unlock(& file_priv->mm.lock);
  }
  return;
}
}
static void i915_gem_reset_ring_lists(struct drm_i915_private *dev_priv , struct intel_ring_buffer *ring )
{ struct drm_i915_gem_request *request ;
  struct list_head const *__mptr ;
  int tmp ;
  struct drm_i915_gem_object *obj ;
  struct list_head const *__mptr___0 ;
  int tmp___0 ;
  {
  goto ldv_39276;
  ldv_39275:
  {
  __mptr = (struct list_head const *)ring->request_list.next;
  request = (struct drm_i915_gem_request *)__mptr + 0x0fffffffffffffe8UL;
  list_del(& request->list);
  i915_gem_request_remove_from_client(request);
  kfree((void const *)request);
  }
  ldv_39276:
  {
  tmp = list_empty((struct list_head const *)(& ring->request_list));
  }
  if (tmp == 0) {
    goto ldv_39275;
  } else {
    goto ldv_39277;
  }
  ldv_39277: ;
  goto ldv_39282;
  ldv_39281:
  {
  __mptr___0 = (struct list_head const *)ring->active_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___0 + 0x0fffffffffffff60UL;
  obj->base.write_domain = 0U;
  list_del_init(& obj->gpu_write_list);
  i915_gem_object_move_to_inactive(obj);
  }
  ldv_39282:
  {
  tmp___0 = list_empty((struct list_head const *)(& ring->active_list));
  }
  if (tmp___0 == 0) {
    goto ldv_39281;
  } else {
    goto ldv_39283;
  }
  ldv_39283: ;
  return;
}
}
static void i915_gem_reset_fences(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  int i ;
  struct drm_i915_fence_reg *reg ;
  struct drm_i915_gem_object *obj ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  i = 0;
  goto ldv_39293;
  ldv_39292:
  reg = (struct drm_i915_fence_reg *)(& dev_priv->fence_regs) + (unsigned long )i;
  obj = reg->obj;
  if ((unsigned long )obj == (unsigned long )((struct drm_i915_gem_object *)0)) {
    goto ldv_39291;
  } else {
  }
  if ((unsigned int )*((unsigned char *)obj + 225UL) != 0U) {
    {
    i915_gem_release_mmap(obj);
    }
  } else {
  }
  {
  (reg->obj)->fence_reg = (signed char)-1;
  (reg->obj)->fenced_gpu_access = (unsigned char)0;
  (reg->obj)->last_fenced_seqno = 0U;
  (reg->obj)->last_fenced_ring = (struct intel_ring_buffer *)0;
  i915_gem_clear_fence_reg(dev, reg);
  }
  ldv_39291:
  i = i + 1;
  ldv_39293: ;
  if (i <= 15) {
    goto ldv_39292;
  } else {
    goto ldv_39294;
  }
  ldv_39294: ;
  return;
}
}
void i915_gem_reset(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct drm_i915_gem_object *obj ;
  int i ;
  struct list_head const *__mptr ;
  int tmp ;
  struct list_head const *__mptr___0 ;
  struct list_head const *__mptr___1 ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  i = 0;
  goto ldv_39302;
  ldv_39301:
  {
  i915_gem_reset_ring_lists(dev_priv, (struct intel_ring_buffer *)(& dev_priv->ring) + (unsigned long )i);
  i = i + 1;
  }
  ldv_39302: ;
  if (i <= 2) {
    goto ldv_39301;
  } else {
    goto ldv_39303;
  }
  ldv_39303: ;
  goto ldv_39307;
  ldv_39306:
  {
  __mptr = (struct list_head const *)dev_priv->mm.flushing_list.next;
  obj = (struct drm_i915_gem_object *)__mptr + 0x0fffffffffffff50UL;
  obj->base.write_domain = 0U;
  list_del_init(& obj->gpu_write_list);
  i915_gem_object_move_to_inactive(obj);
  }
  ldv_39307:
  {
  tmp = list_empty((struct list_head const *)(& dev_priv->mm.flushing_list));
  }
  if (tmp == 0) {
    goto ldv_39306;
  } else {
    goto ldv_39308;
  }
  ldv_39308:
  __mptr___0 = (struct list_head const *)dev_priv->mm.inactive_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___0 + 0x0fffffffffffff50UL;
  goto ldv_39314;
  ldv_39313:
  obj->base.read_domains = obj->base.read_domains & 65U;
  __mptr___1 = (struct list_head const *)obj->mm_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___1 + 0x0fffffffffffff50UL;
  ldv_39314: ;
  if ((unsigned long )(& obj->mm_list) != (unsigned long )(& dev_priv->mm.inactive_list)) {
    goto ldv_39313;
  } else {
    goto ldv_39315;
  }
  ldv_39315:
  {
  i915_gem_reset_fences(dev);
  }
  return;
}
}
static void i915_gem_retire_requests_ring(struct intel_ring_buffer *ring )
{ uint32_t seqno ;
  int i ;
  int tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  struct drm_i915_gem_request *request ;
  struct list_head const *__mptr ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct drm_i915_gem_object *obj ;
  struct list_head const *__mptr___0 ;
  bool tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  bool tmp___8 ;
  long tmp___9 ;
  int __ret_warn_on___0 ;
  long tmp___10 ;
  {
  {
  tmp = list_empty((struct list_head const *)(& ring->request_list));
  }
  if (tmp != 0) {
    return;
  } else {
  }
  {
  __ret_warn_on = 0;
  tmp___0 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp___0 != 0L) {
    {
    warn_slowpath_null("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p",
                       (int const )1898);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on != 0), 0L);
  seqno = (*(ring->get_seqno))(ring);
  i = 0;
  }
  goto ldv_39326;
  ldv_39325: ;
  if (ring->sync_seqno[i] <= seqno) {
    ring->sync_seqno[i] = 0U;
  } else {
  }
  i = i + 1;
  ldv_39326: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_39325;
  } else {
    goto ldv_39327;
  }
  ldv_39327: ;
  goto ldv_39333;
  ldv_39332:
  {
  __mptr = (struct list_head const *)ring->request_list.next;
  request = (struct drm_i915_gem_request *)__mptr + 0x0fffffffffffffe8UL;
  tmp___1 = i915_seqno_passed(seqno, request->seqno);
  }
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    goto ldv_39331;
  } else {
  }
  {
  trace_i915_gem_request_retire(ring, request->seqno);
  list_del(& request->list);
  i915_gem_request_remove_from_client(request);
  kfree((void const *)request);
  }
  ldv_39333:
  {
  tmp___3 = list_empty((struct list_head const *)(& ring->request_list));
  }
  if (tmp___3 == 0) {
    goto ldv_39332;
  } else {
    goto ldv_39331;
  }
  ldv_39331: ;
  goto ldv_39339;
  ldv_39338:
  {
  __mptr___0 = (struct list_head const *)ring->active_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___0 + 0x0fffffffffffff60UL;
  tmp___4 = i915_seqno_passed(seqno, obj->last_rendering_seqno);
  }
  if (tmp___4) {
    tmp___5 = 0;
  } else {
    tmp___5 = 1;
  }
  if (tmp___5) {
    goto ldv_39337;
  } else {
  }
  if (obj->base.write_domain != 0U) {
    {
    i915_gem_object_move_to_flushing(obj);
    }
  } else {
    {
    i915_gem_object_move_to_inactive(obj);
    }
  }
  ldv_39339:
  {
  tmp___6 = list_empty((struct list_head const *)(& ring->active_list));
  }
  if (tmp___6 == 0) {
    goto ldv_39338;
  } else {
    goto ldv_39337;
  }
  ldv_39337:
  {
  tmp___7 = __builtin_expect((long )(ring->trace_irq_seqno != 0U), 0L);
  }
  if (tmp___7 != 0L) {
    {
    tmp___8 = i915_seqno_passed(seqno, ring->trace_irq_seqno);
    tmp___9 = __builtin_expect((long )tmp___8, 0L);
    }
    if (tmp___9 != 0L) {
      {
      (*(ring->irq_put))(ring);
      ring->trace_irq_seqno = 0U;
      }
    } else {
    }
  } else {
  }
  {
  __ret_warn_on___0 = 0;
  tmp___10 = __builtin_expect((long )(__ret_warn_on___0 != 0), 0L);
  }
  if (tmp___10 != 0L) {
    {
    warn_slowpath_null("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p",
                       (int const )1948);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on___0 != 0), 0L);
  }
  return;
}
}
void i915_gem_retire_requests(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  int i ;
  struct drm_i915_gem_object *obj ;
  struct drm_i915_gem_object *next ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  struct list_head const *__mptr___1 ;
  int tmp ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = list_empty((struct list_head const *)(& dev_priv->mm.deferred_free_list));
  }
  if (tmp == 0) {
    __mptr = (struct list_head const *)dev_priv->mm.deferred_free_list.next;
    obj = (struct drm_i915_gem_object *)__mptr + 0x0fffffffffffff50UL;
    __mptr___0 = (struct list_head const *)obj->mm_list.next;
    next = (struct drm_i915_gem_object *)__mptr___0 + 0x0fffffffffffff50UL;
    goto ldv_39356;
    ldv_39355:
    {
    i915_gem_free_object_tail(obj);
    obj = next;
    __mptr___1 = (struct list_head const *)next->mm_list.next;
    next = (struct drm_i915_gem_object *)__mptr___1 + 0x0fffffffffffff50UL;
    }
    ldv_39356: ;
    if ((unsigned long )(& obj->mm_list) != (unsigned long )(& dev_priv->mm.deferred_free_list)) {
      goto ldv_39355;
    } else {
      goto ldv_39357;
    }
    ldv_39357: ;
  } else {
  }
  i = 0;
  goto ldv_39359;
  ldv_39358:
  {
  i915_gem_retire_requests_ring((struct intel_ring_buffer *)(& dev_priv->ring) + (unsigned long )i);
  i = i + 1;
  }
  ldv_39359: ;
  if (i <= 2) {
    goto ldv_39358;
  } else {
    goto ldv_39360;
  }
  ldv_39360: ;
  return;
}
}
static void i915_gem_retire_work_handler(struct work_struct *work )
{ drm_i915_private_t *dev_priv ;
  struct drm_device *dev ;
  bool idle ;
  int i ;
  struct work_struct const *__mptr ;
  int tmp ;
  struct intel_ring_buffer *ring ;
  struct drm_i915_gem_request *request ;
  int ret ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  {
  {
  __mptr = (struct work_struct const *)work;
  dev_priv = (drm_i915_private_t *)__mptr + 0x0fffffffffffe5e0UL;
  dev = dev_priv->dev;
  tmp = mutex_trylock(& dev->struct_mutex);
  }
  if (tmp == 0) {
    {
    queue_delayed_work(dev_priv->wq, & dev_priv->mm.retire_work, 250UL);
    }
    return;
  } else {
  }
  {
  i915_gem_retire_requests(dev);
  idle = (bool )1;
  i = 0;
  }
  goto ldv_39374;
  ldv_39373:
  {
  ring = (struct intel_ring_buffer *)(& dev_priv->ring) + (unsigned long )i;
  tmp___2 = list_empty((struct list_head const *)(& ring->gpu_write_list));
  }
  if (tmp___2 == 0) {
    {
    ret = i915_gem_flush_ring(ring, 0U, 4294967230U);
    tmp___0 = kzalloc(64UL, 208U);
    request = (struct drm_i915_gem_request *)tmp___0;
    }
    if (ret != 0) {
      {
      kfree((void const *)request);
      }
    } else
    if ((unsigned long )request == (unsigned long )((struct drm_i915_gem_request *)0)) {
      {
      kfree((void const *)request);
      }
    } else {
      {
      tmp___1 = i915_add_request(ring, (struct drm_file *)0, request);
      }
      if (tmp___1 != 0) {
        {
        kfree((void const *)request);
        }
      } else {
      }
    }
  } else {
  }
  {
  tmp___3 = list_empty((struct list_head const *)(& ring->request_list));
  idle = (bool )(((int )idle & tmp___3) != 0);
  i = i + 1;
  }
  ldv_39374: ;
  if (i <= 2) {
    goto ldv_39373;
  } else {
    goto ldv_39375;
  }
  ldv_39375: ;
  if (dev_priv->mm.suspended == 0) {
    if (! idle) {
      {
      queue_delayed_work(dev_priv->wq, & dev_priv->mm.retire_work, 250UL);
      }
    } else {
    }
  } else {
  }
  {
  mutex_unlock(& dev->struct_mutex);
  }
  return;
}
}
int i915_wait_request(struct intel_ring_buffer *ring , uint32_t seqno )
{ drm_i915_private_t *dev_priv ;
  u32 ier ;
  int ret ;
  long tmp ;
  struct completion *x ;
  bool recovery_complete ;
  unsigned long flags ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct drm_i915_gem_request *request ;
  void *tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  int __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp___6 ;
  u32 tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;
  struct task_struct *tmp___10 ;
  int tmp___11 ;
  u32 tmp___12 ;
  bool tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  u32 tmp___16 ;
  bool tmp___17 ;
  int tmp___18 ;
  wait_queue_t __wait___0 ;
  struct task_struct *tmp___19 ;
  u32 tmp___20 ;
  bool tmp___21 ;
  int tmp___22 ;
  unsigned long timeout__ ;
  unsigned long tmp___23 ;
  int ret__ ;
  struct thread_info *tmp___24 ;
  int pfo_ret__ ;
  int tmp___25 ;
  u32 tmp___26 ;
  bool tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  bool tmp___30 ;
  u32 tmp___31 ;
  bool tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  u32 tmp___35 ;
  {
  {
  dev_priv = (drm_i915_private_t *)(ring->dev)->dev_private;
  ret = 0;
  tmp = __builtin_expect((long )(seqno == 0U), 0L);
  }
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p"),
                         "i" (2035), "i" (12UL));
    ldv_39383: ;
    goto ldv_39383;
  } else {
  }
  {
  tmp___2 = atomic_read((atomic_t const *)(& dev_priv->mm.wedged));
  }
  if (tmp___2 != 0) {
    {
    x = & dev_priv->error_completion;
    tmp___0 = spinlock_check(& x->wait.lock);
    flags = _raw_spin_lock_irqsave(tmp___0);
    recovery_complete = (bool )(x->done != 0U);
    spin_unlock_irqrestore(& x->wait.lock, flags);
    }
    if ((int )recovery_complete) {
      tmp___1 = -5;
    } else {
      tmp___1 = -11;
    }
    return (tmp___1);
  } else {
  }
  if (ring->outstanding_lazy_request == seqno) {
    {
    tmp___3 = kzalloc(64UL, 208U);
    request = (struct drm_i915_gem_request *)tmp___3;
    }
    if ((unsigned long )request == (unsigned long )((struct drm_i915_gem_request *)0)) {
      return (-12);
    } else {
    }
    {
    ret = i915_add_request(ring, (struct drm_file *)0, request);
    }
    if (ret != 0) {
      {
      kfree((void const *)request);
      }
      return (ret);
    } else {
    }
    seqno = request->seqno;
  } else {
  }
  {
  tmp___31 = (*(ring->get_seqno))(ring);
  tmp___32 = i915_seqno_passed(tmp___31, seqno);
  }
  if (tmp___32) {
    tmp___33 = 0;
  } else {
    tmp___33 = 1;
  }
  if (tmp___33) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)(ring->dev)->dev_private)->info)->gen) == 5U) {
      {
      tmp___4 = i915_read32(dev_priv, 278540U);
      tmp___5 = i915_read32(dev_priv, 278556U);
      ier = tmp___4 | tmp___5;
      }
    } else
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)(ring->dev)->dev_private)->info)->gen) == 6U) {
      {
      tmp___4 = i915_read32(dev_priv, 278540U);
      tmp___5 = i915_read32(dev_priv, 278556U);
      ier = tmp___4 | tmp___5;
      }
    } else
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)(ring->dev)->dev_private)->info + 2UL) != 0U) {
      {
      tmp___4 = i915_read32(dev_priv, 278540U);
      tmp___5 = i915_read32(dev_priv, 278556U);
      ier = tmp___4 | tmp___5;
      }
    } else {
      {
      ier = i915_read32(dev_priv, 8352U);
      }
    }
    if (ier == 0U) {
      {
      drm_err("i915_wait_request", "something (likely vbetool) disabled interrupts, re-enabling\n");
      (*(((ring->dev)->driver)->irq_preinstall))(ring->dev);
      (*(((ring->dev)->driver)->irq_postinstall))(ring->dev);
      }
    } else {
    }
    {
    trace_i915_gem_request_wait_begin(ring, seqno);
    ring->waiting_seqno = seqno;
    tmp___30 = (*(ring->irq_get))(ring);
    }
    if ((int )tmp___30) {
      if ((int )dev_priv->mm.interruptible) {
        {
        __ret = 0;
        tmp___12 = (*(ring->get_seqno))(ring);
        tmp___13 = i915_seqno_passed(tmp___12, seqno);
        }
        if (tmp___13) {
          tmp___14 = 0;
        } else {
          tmp___14 = 1;
        }
        if (tmp___14) {
          {
          tmp___15 = atomic_read((atomic_t const *)(& dev_priv->mm.wedged));
          }
          if (tmp___15 == 0) {
            {
            tmp___6 = get_current();
            __wait.flags = 0U;
            __wait.private = (void *)tmp___6;
            __wait.func = & autoremove_wake_function;
            __wait.task_list.next = & __wait.task_list;
            __wait.task_list.prev = & __wait.task_list;
            }
            ldv_39396:
            {
            prepare_to_wait(& ring->irq_queue, & __wait, 1);
            tmp___7 = (*(ring->get_seqno))(ring);
            tmp___8 = i915_seqno_passed(tmp___7, seqno);
            }
            if ((int )tmp___8) {
              goto ldv_39394;
            } else {
              {
              tmp___9 = atomic_read((atomic_t const *)(& dev_priv->mm.wedged));
              }
              if (tmp___9 != 0) {
                goto ldv_39394;
              } else {
              }
            }
            {
            tmp___10 = get_current();
            tmp___11 = signal_pending(tmp___10);
            }
            if (tmp___11 == 0) {
              {
              schedule();
              }
              goto ldv_39395;
            } else {
            }
            __ret = -512;
            goto ldv_39394;
            ldv_39395: ;
            goto ldv_39396;
            ldv_39394:
            {
            finish_wait(& ring->irq_queue, & __wait);
            }
          } else {
          }
        } else {
        }
        ret = __ret;
      } else {
        {
        tmp___16 = (*(ring->get_seqno))(ring);
        tmp___17 = i915_seqno_passed(tmp___16, seqno);
        }
        if ((int )tmp___17) {
          goto ldv_39398;
        } else {
          {
          tmp___18 = atomic_read((atomic_t const *)(& dev_priv->mm.wedged));
          }
          if (tmp___18 != 0) {
            goto ldv_39398;
          } else {
          }
        }
        {
        tmp___19 = get_current();
        __wait___0.flags = 0U;
        __wait___0.private = (void *)tmp___19;
        __wait___0.func = & autoremove_wake_function;
        __wait___0.task_list.next = & __wait___0.task_list;
        __wait___0.task_list.prev = & __wait___0.task_list;
        }
        ldv_39401:
        {
        prepare_to_wait(& ring->irq_queue, & __wait___0, 2);
        tmp___20 = (*(ring->get_seqno))(ring);
        tmp___21 = i915_seqno_passed(tmp___20, seqno);
        }
        if ((int )tmp___21) {
          goto ldv_39400;
        } else {
          {
          tmp___22 = atomic_read((atomic_t const *)(& dev_priv->mm.wedged));
          }
          if (tmp___22 != 0) {
            goto ldv_39400;
          } else {
          }
        }
        {
        schedule();
        }
        goto ldv_39401;
        ldv_39400:
        {
        finish_wait(& ring->irq_queue, & __wait___0);
        }
        ldv_39398: ;
      }
      {
      (*(ring->irq_put))(ring);
      }
    } else {
      {
      tmp___23 = msecs_to_jiffies((unsigned int const )3000U);
      timeout__ = tmp___23 + (unsigned long )jiffies;
      ret__ = 0;
      }
      goto ldv_39420;
      ldv_39419: ;
      if ((long )timeout__ - (long )jiffies < 0L) {
        ret__ = -110;
        goto ldv_39410;
      } else {
      }
      {
      tmp___24 = current_thread_info();
      }
      if ((tmp___24->preempt_count & -268435457) == 0) {
        if (1) {
          goto case_4;
        } else {
          goto switch_default;
          if (0) {
            __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
            goto ldv_39413;
            __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
            goto ldv_39413;
            case_4:
            __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
            goto ldv_39413;
            __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
            goto ldv_39413;
            switch_default:
            {
            __bad_percpu_size();
            }
          } else {
          }
        }
        ldv_39413:
        {
        tmp___25 = atomic_read((atomic_t const *)(& kgdb_active));
        }
        if (pfo_ret__ != tmp___25) {
          {
          msleep(1U);
          }
        } else {
        }
      } else {
      }
      ldv_39420:
      {
      tmp___26 = (*(ring->get_seqno))(ring);
      tmp___27 = i915_seqno_passed(tmp___26, seqno);
      }
      if (tmp___27) {
        tmp___28 = 0;
      } else {
        tmp___28 = 1;
      }
      if (tmp___28) {
        {
        tmp___29 = atomic_read((atomic_t const *)(& dev_priv->mm.wedged));
        }
        if (tmp___29 == 0) {
          goto ldv_39419;
        } else {
          goto ldv_39410;
        }
      } else {
        goto ldv_39410;
      }
      ldv_39410: ;
      if (ret__ != 0) {
        ret = -16;
      } else {
      }
    }
    {
    ring->waiting_seqno = 0U;
    trace_i915_gem_request_wait_end(ring, seqno);
    }
  } else {
  }
  {
  tmp___34 = atomic_read((atomic_t const *)(& dev_priv->mm.wedged));
  }
  if (tmp___34 != 0) {
    ret = -11;
  } else {
  }
  if (ret != 0) {
    if (ret != -512) {
      {
      tmp___35 = (*(ring->get_seqno))(ring);
      drm_err("i915_wait_request", "%s returns %d (awaiting %d at %d, next %d)\n",
              "i915_wait_request", ret, seqno, tmp___35, dev_priv->next_seqno);
      }
    } else {
    }
  } else {
  }
  if (ret == 0) {
    {
    i915_gem_retire_requests_ring(ring);
    }
  } else {
  }
  return (ret);
}
}
int i915_gem_object_wait_rendering(struct drm_i915_gem_object *obj )
{ int ret ;
  long tmp ;
  {
  {
  tmp = __builtin_expect((long )((obj->base.write_domain & 4294967230U) != 0U), 0L);
  }
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p"),
                         "i" (2131), "i" (12UL));
    ldv_39426: ;
    goto ldv_39426;
  } else {
  }
  if ((unsigned int )*((unsigned char *)obj + 224UL) != 0U) {
    {
    ret = i915_wait_request(obj->ring, obj->last_rendering_seqno);
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
  } else {
  }
  return (0);
}
}
int i915_gem_object_unbind(struct drm_i915_gem_object *obj )
{ int ret ;
  uint32_t tmp ;
  int tmp___0 ;
  {
  ret = 0;
  if ((unsigned long )obj->gtt_space == (unsigned long )((struct drm_mm_node *)0)) {
    return (0);
  } else {
  }
  if (*((unsigned int *)obj + 56UL) != 0U) {
    {
    drm_err("i915_gem_object_unbind", "Attempting to unbind pinned buffer\n");
    }
    return (-22);
  } else {
  }
  {
  i915_gem_release_mmap(obj);
  ret = i915_gem_object_set_to_cpu_domain(obj, (bool )1);
  }
  if (ret == -512) {
    return (ret);
  } else {
  }
  if (ret != 0) {
    {
    i915_gem_clflush_object(obj);
    tmp = 1U;
    obj->base.write_domain = tmp;
    obj->base.read_domains = tmp;
    }
  } else {
  }
  {
  ret = i915_gem_object_put_fence(obj);
  }
  if (ret == -512) {
    return (ret);
  } else {
  }
  {
  trace_i915_gem_object_unbind(obj);
  i915_gem_gtt_unbind_object(obj);
  i915_gem_object_put_pages_gtt(obj);
  list_del_init(& obj->gtt_list);
  list_del_init(& obj->mm_list);
  obj->map_and_fenceable = (unsigned char)1;
  drm_mm_put_block(obj->gtt_space);
  obj->gtt_space = (struct drm_mm_node *)0;
  obj->gtt_offset = 0U;
  tmp___0 = i915_gem_object_is_purgeable(obj);
  }
  if (tmp___0 != 0) {
    {
    i915_gem_object_truncate(obj);
    }
  } else {
  }
  return (ret);
}
}
int i915_gem_flush_ring(struct intel_ring_buffer *ring , uint32_t invalidate_domains ,
                        uint32_t flush_domains )
{ int ret ;
  {
  if (((invalidate_domains | flush_domains) & 4294967230U) == 0U) {
    return (0);
  } else {
  }
  {
  trace_i915_gem_ring_flush(ring, invalidate_domains, flush_domains);
  ret = (*(ring->flush))(ring, invalidate_domains, flush_domains);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  if ((flush_domains & 4294967230U) != 0U) {
    {
    i915_gem_process_flushing_list(ring, flush_domains);
    }
  } else {
  }
  return (0);
}
}
static int i915_ring_idle(struct intel_ring_buffer *ring )
{ int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u32 tmp___2 ;
  int tmp___3 ;
  {
  {
  tmp = list_empty((struct list_head const *)(& ring->gpu_write_list));
  }
  if (tmp != 0) {
    {
    tmp___0 = list_empty((struct list_head const *)(& ring->active_list));
    }
    if (tmp___0 != 0) {
      return (0);
    } else {
    }
  } else {
  }
  {
  tmp___1 = list_empty((struct list_head const *)(& ring->gpu_write_list));
  }
  if (tmp___1 == 0) {
    {
    ret = i915_gem_flush_ring(ring, 4294967230U, 4294967230U);
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
  } else {
  }
  {
  tmp___2 = i915_gem_next_request_seqno(ring);
  tmp___3 = i915_wait_request(ring, tmp___2);
  }
  return (tmp___3);
}
}
int i915_gpu_idle(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  bool lists_empty ;
  int ret ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = list_empty((struct list_head const *)(& dev_priv->mm.flushing_list));
  }
  if (tmp != 0) {
    {
    tmp___0 = list_empty((struct list_head const *)(& dev_priv->mm.active_list));
    }
    if (tmp___0 != 0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  lists_empty = (bool )tmp___1;
  if ((int )lists_empty) {
    return (0);
  } else {
  }
  i = 0;
  goto ldv_39450;
  ldv_39449:
  {
  ret = i915_ring_idle((struct intel_ring_buffer *)(& dev_priv->ring) + (unsigned long )i);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  i = i + 1;
  ldv_39450: ;
  if (i <= 2) {
    goto ldv_39449;
  } else {
    goto ldv_39451;
  }
  ldv_39451: ;
  return (0);
}
}
static int sandybridge_write_fence_reg(struct drm_i915_gem_object *obj , struct intel_ring_buffer *pipelined )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  u32 size ;
  int regnum ;
  uint64_t val ;
  int ret ;
  int tmp ;
  {
  dev = obj->base.dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  size = (u32 )(obj->gtt_space)->size;
  regnum = (int )obj->fence_reg;
  val = ((unsigned long long )((obj->gtt_offset + size) - 4096U) & 4294963200ULL) << 32;
  val = ((uint64_t )obj->gtt_offset & 4294963200ULL) | val;
  val = ((unsigned long long )(obj->stride / 128U - 1U) << 32) | val;
  if ((unsigned int )*((unsigned char *)obj + 225UL) == 8U) {
    val = val | 2ULL;
  } else {
  }
  val = val | 1ULL;
  if ((unsigned long )pipelined != (unsigned long )((struct intel_ring_buffer *)0)) {
    {
    tmp = intel_ring_begin(pipelined, 6);
    ret = tmp;
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
    {
    intel_ring_emit(pipelined, 0U);
    intel_ring_emit(pipelined, 285212675U);
    intel_ring_emit(pipelined, (u32 )((regnum + 131072) * 8));
    intel_ring_emit(pipelined, (unsigned int )val);
    intel_ring_emit(pipelined, (u32 )((regnum + 131072) * 8 + 4));
    intel_ring_emit(pipelined, (unsigned int )(val >> 32));
    intel_ring_advance(pipelined);
    }
  } else {
    {
    i915_write64(dev_priv, (u32 )((regnum + 131072) * 8), val);
    }
  }
  return (0);
}
}
static int i965_write_fence_reg(struct drm_i915_gem_object *obj , struct intel_ring_buffer *pipelined )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  u32 size ;
  int regnum ;
  uint64_t val ;
  int ret ;
  int tmp ;
  {
  dev = obj->base.dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  size = (u32 )(obj->gtt_space)->size;
  regnum = (int )obj->fence_reg;
  val = ((unsigned long long )((obj->gtt_offset + size) - 4096U) & 4294963200ULL) << 32;
  val = ((uint64_t )obj->gtt_offset & 4294963200ULL) | val;
  val = (uint64_t )((obj->stride / 128U - 1U) << 2) | val;
  if ((unsigned int )*((unsigned char *)obj + 225UL) == 8U) {
    val = val | 2ULL;
  } else {
  }
  val = val | 1ULL;
  if ((unsigned long )pipelined != (unsigned long )((struct intel_ring_buffer *)0)) {
    {
    tmp = intel_ring_begin(pipelined, 6);
    ret = tmp;
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
    {
    intel_ring_emit(pipelined, 0U);
    intel_ring_emit(pipelined, 285212675U);
    intel_ring_emit(pipelined, (u32 )((regnum + 1536) * 8));
    intel_ring_emit(pipelined, (unsigned int )val);
    intel_ring_emit(pipelined, (u32 )((regnum + 1536) * 8 + 4));
    intel_ring_emit(pipelined, (unsigned int )(val >> 32));
    intel_ring_advance(pipelined);
    }
  } else {
    {
    i915_write64(dev_priv, (u32 )((regnum + 1536) * 8), val);
    }
  }
  return (0);
}
}
static int i915_write_fence_reg(struct drm_i915_gem_object *obj , struct intel_ring_buffer *pipelined )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  u32 size ;
  u32 fence_reg ;
  u32 val ;
  u32 pitch_val ;
  int tile_width ;
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int ret ;
  int tmp___4 ;
  {
  dev = obj->base.dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  size = (u32 )(obj->gtt_space)->size;
  if ((obj->gtt_offset & 4027580415U) != 0U) {
    tmp = 1;
  } else
  if ((- size & size) != size) {
    tmp = 1;
  } else
  if ((obj->gtt_offset & (size - 1U)) != 0U) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  {
  __ret_warn_on = tmp;
  tmp___0 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp___0 != 0L) {
    {
    warn_slowpath_fmt("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p",
                      (int const )2353, "object 0x%08x [fenceable? %d] not 1M or pot-size (0x%08x) aligned\n",
                      obj->gtt_offset, (int )obj->map_and_fenceable, size);
    }
  } else {
  }
  {
  tmp___1 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp___1 != 0L) {
    return (-22);
  } else {
  }
  if ((unsigned int )*((unsigned char *)obj + 225UL) == 8U) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 2U) {
      if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) == 0U) {
        if (dev->pci_device != 9618) {
          tile_width = 128;
        } else {
          tile_width = 512;
        }
      } else {
        tile_width = 512;
      }
    } else {
      tile_width = 512;
    }
  } else {
    tile_width = 512;
  }
  {
  pitch_val = obj->stride / (uint32_t )tile_width;
  tmp___2 = ffs((int )pitch_val);
  pitch_val = (u32 )(tmp___2 + -1);
  val = obj->gtt_offset;
  }
  if ((unsigned int )*((unsigned char *)obj + 225UL) == 8U) {
    val = val | 4096U;
  } else {
  }
  {
  tmp___3 = ffs((int )(size >> 20));
  val = (u32 )((tmp___3 + -1) << 8) | val;
  val = (pitch_val << 4) | val;
  val = val | 1U;
  fence_reg = (u32 )obj->fence_reg;
  }
  if (fence_reg <= 7U) {
    fence_reg = (fence_reg + 2048U) * 4U;
  } else {
    fence_reg = (fence_reg + 3064U) * 4U;
  }
  if ((unsigned long )pipelined != (unsigned long )((struct intel_ring_buffer *)0)) {
    {
    tmp___4 = intel_ring_begin(pipelined, 4);
    ret = tmp___4;
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
    {
    intel_ring_emit(pipelined, 0U);
    intel_ring_emit(pipelined, 285212673U);
    intel_ring_emit(pipelined, fence_reg);
    intel_ring_emit(pipelined, val);
    intel_ring_advance(pipelined);
    }
  } else {
    {
    i915_write32(dev_priv, fence_reg, val);
    }
  }
  return (0);
}
}
static int i830_write_fence_reg(struct drm_i915_gem_object *obj , struct intel_ring_buffer *pipelined )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  u32 size ;
  int regnum ;
  uint32_t val ;
  uint32_t pitch_val ;
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int ret ;
  int tmp___4 ;
  {
  dev = obj->base.dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  size = (u32 )(obj->gtt_space)->size;
  regnum = (int )obj->fence_reg;
  if ((obj->gtt_offset & 4161273855U) != 0U) {
    tmp = 1;
  } else
  if ((- size & size) != size) {
    tmp = 1;
  } else
  if ((obj->gtt_offset & (size - 1U)) != 0U) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  {
  __ret_warn_on = tmp;
  tmp___0 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp___0 != 0L) {
    {
    warn_slowpath_fmt("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p",
                      (int const )2408, "object 0x%08x not 512K or pot-size 0x%08x aligned\n",
                      obj->gtt_offset, size);
    }
  } else {
  }
  {
  tmp___1 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp___1 != 0L) {
    return (-22);
  } else {
  }
  {
  pitch_val = obj->stride / 128U;
  tmp___2 = ffs((int )pitch_val);
  pitch_val = (uint32_t )(tmp___2 + -1);
  val = obj->gtt_offset;
  }
  if ((unsigned int )*((unsigned char *)obj + 225UL) == 8U) {
    val = val | 4096U;
  } else {
  }
  {
  tmp___3 = ffs((int )(size >> 19));
  val = (uint32_t )((tmp___3 + -1) << 8) | val;
  val = (pitch_val << 4) | val;
  val = val | 1U;
  }
  if ((unsigned long )pipelined != (unsigned long )((struct intel_ring_buffer *)0)) {
    {
    tmp___4 = intel_ring_begin(pipelined, 4);
    ret = tmp___4;
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
    {
    intel_ring_emit(pipelined, 0U);
    intel_ring_emit(pipelined, 285212673U);
    intel_ring_emit(pipelined, (u32 )((regnum + 2048) * 4));
    intel_ring_emit(pipelined, val);
    intel_ring_advance(pipelined);
    }
  } else {
    {
    i915_write32(dev_priv, (u32 )((regnum + 2048) * 4), val);
    }
  }
  return (0);
}
}
static bool ring_passed_seqno(struct intel_ring_buffer *ring , u32 seqno )
{ u32 tmp ;
  bool tmp___0 ;
  {
  {
  tmp = (*(ring->get_seqno))(ring);
  tmp___0 = i915_seqno_passed(tmp, seqno);
  }
  return (tmp___0);
}
}
static int i915_gem_object_flush_fence(struct drm_i915_gem_object *obj , struct intel_ring_buffer *pipelined )
{ int ret ;
  bool tmp ;
  int tmp___0 ;
  {
  if ((unsigned int )*((unsigned char *)obj + 226UL) != 0U) {
    if ((obj->base.write_domain & 4294967230U) != 0U) {
      {
      ret = i915_gem_flush_ring(obj->last_fenced_ring, 0U, obj->base.write_domain);
      }
      if (ret != 0) {
        return (ret);
      } else {
      }
    } else {
    }
    obj->fenced_gpu_access = (unsigned char)0;
  } else {
  }
  if (obj->last_fenced_seqno != 0U) {
    if ((unsigned long )obj->last_fenced_ring != (unsigned long )pipelined) {
      {
      tmp = ring_passed_seqno(obj->last_fenced_ring, obj->last_fenced_seqno);
      }
      if (tmp) {
        tmp___0 = 0;
      } else {
        tmp___0 = 1;
      }
      if (tmp___0) {
        {
        ret = i915_wait_request(obj->last_fenced_ring, obj->last_fenced_seqno);
        }
        if (ret != 0) {
          return (ret);
        } else {
        }
      } else {
      }
      obj->last_fenced_seqno = 0U;
      obj->last_fenced_ring = (struct intel_ring_buffer *)0;
    } else {
    }
  } else {
  }
  if ((obj->base.read_domains & 64U) != 0U) {
    __asm__ volatile ("mfence": : : "memory");
  } else {
  }
  return (0);
}
}
int i915_gem_object_put_fence(struct drm_i915_gem_object *obj )
{ int ret ;
  struct drm_i915_private *dev_priv ;
  {
  if ((unsigned int )*((unsigned char *)obj + 225UL) != 0U) {
    {
    i915_gem_release_mmap(obj);
    }
  } else {
  }
  {
  ret = i915_gem_object_flush_fence(obj, (struct intel_ring_buffer *)0);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  if ((unsigned int )*((unsigned char *)obj + 224UL) != 248U) {
    {
    dev_priv = (struct drm_i915_private *)(obj->base.dev)->dev_private;
    i915_gem_clear_fence_reg(obj->base.dev, (struct drm_i915_fence_reg *)(& dev_priv->fence_regs) + (unsigned long )obj->fence_reg);
    obj->fence_reg = (signed char)-1;
    }
  } else {
  }
  return (0);
}
}
static struct drm_i915_fence_reg *i915_find_fence_reg(struct drm_device *dev , struct intel_ring_buffer *pipelined )
{ struct drm_i915_private *dev_priv ;
  struct drm_i915_fence_reg *reg ;
  struct drm_i915_fence_reg *first ;
  struct drm_i915_fence_reg *avail ;
  int i ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  avail = (struct drm_i915_fence_reg *)0;
  i = dev_priv->fence_reg_start;
  goto ldv_39523;
  ldv_39522:
  reg = (struct drm_i915_fence_reg *)(& dev_priv->fence_regs) + (unsigned long )i;
  if ((unsigned long )reg->obj == (unsigned long )((struct drm_i915_gem_object *)0)) {
    return (reg);
  } else {
  }
  if (*((unsigned int *)reg->obj + 56UL) == 0U) {
    avail = reg;
  } else {
  }
  i = i + 1;
  ldv_39523: ;
  if (dev_priv->num_fence_regs > i) {
    goto ldv_39522;
  } else {
    goto ldv_39524;
  }
  ldv_39524: ;
  if ((unsigned long )avail == (unsigned long )((struct drm_i915_fence_reg *)0)) {
    return ((struct drm_i915_fence_reg *)0);
  } else {
  }
  first = (struct drm_i915_fence_reg *)0;
  avail = first;
  __mptr = (struct list_head const *)dev_priv->mm.fence_list.next;
  reg = (struct drm_i915_fence_reg *)__mptr;
  goto ldv_39532;
  ldv_39531: ;
  if (*((unsigned int *)reg->obj + 56UL) != 0U) {
    goto ldv_39529;
  } else {
  }
  if ((unsigned long )first == (unsigned long )((struct drm_i915_fence_reg *)0)) {
    first = reg;
  } else {
  }
  if ((unsigned long )pipelined == (unsigned long )((struct intel_ring_buffer *)0)) {
    avail = reg;
    goto ldv_39530;
  } else
  if ((unsigned long )(reg->obj)->last_fenced_ring == (unsigned long )((struct intel_ring_buffer *)0)) {
    avail = reg;
    goto ldv_39530;
  } else
  if ((unsigned long )(reg->obj)->last_fenced_ring == (unsigned long )pipelined) {
    avail = reg;
    goto ldv_39530;
  } else {
  }
  ldv_39529:
  __mptr___0 = (struct list_head const *)reg->lru_list.next;
  reg = (struct drm_i915_fence_reg *)__mptr___0;
  ldv_39532: ;
  if ((unsigned long )(& reg->lru_list) != (unsigned long )(& dev_priv->mm.fence_list)) {
    goto ldv_39531;
  } else {
    goto ldv_39530;
  }
  ldv_39530: ;
  if ((unsigned long )avail == (unsigned long )((struct drm_i915_fence_reg *)0)) {
    avail = first;
  } else {
  }
  return (avail);
}
}
int i915_gem_object_get_fence(struct drm_i915_gem_object *obj , struct intel_ring_buffer *pipelined )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct drm_i915_fence_reg *reg ;
  int ret ;
  bool tmp ;
  int tmp___0 ;
  struct drm_i915_gem_object *old ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  {
  dev = obj->base.dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  pipelined = (struct intel_ring_buffer *)0;
  if ((unsigned int )*((unsigned char *)obj + 224UL) != 248U) {
    {
    reg = (struct drm_i915_fence_reg *)(& dev_priv->fence_regs) + (unsigned long )obj->fence_reg;
    list_move_tail(& reg->lru_list, & dev_priv->mm.fence_list);
    }
    if ((unsigned int )*((unsigned char *)obj + 225UL) != 0U) {
      {
      ret = i915_gem_object_flush_fence(obj, pipelined);
      }
      if (ret != 0) {
        return (ret);
      } else {
      }
      if ((unsigned int )*((unsigned char *)obj + 226UL) == 0U) {
        if (obj->last_fenced_seqno == 0U) {
          pipelined = (struct intel_ring_buffer *)0;
        } else {
        }
      } else {
      }
      if ((unsigned long )pipelined != (unsigned long )((struct intel_ring_buffer *)0)) {
        {
        reg->setup_seqno = i915_gem_next_request_seqno(pipelined);
        obj->last_fenced_seqno = reg->setup_seqno;
        obj->last_fenced_ring = pipelined;
        }
      } else {
      }
      goto update;
    } else {
    }
    if ((unsigned long )pipelined == (unsigned long )((struct intel_ring_buffer *)0)) {
      if (reg->setup_seqno != 0U) {
        {
        tmp = ring_passed_seqno(obj->last_fenced_ring, reg->setup_seqno);
        }
        if (tmp) {
          tmp___0 = 0;
        } else {
          tmp___0 = 1;
        }
        if (tmp___0) {
          {
          ret = i915_wait_request(obj->last_fenced_ring, reg->setup_seqno);
          }
          if (ret != 0) {
            return (ret);
          } else {
          }
        } else {
        }
        reg->setup_seqno = 0U;
      } else
      if ((unsigned long )obj->last_fenced_ring != (unsigned long )((struct intel_ring_buffer *)0)) {
        if ((unsigned long )obj->last_fenced_ring != (unsigned long )pipelined) {
          {
          ret = i915_gem_object_flush_fence(obj, pipelined);
          }
          if (ret != 0) {
            return (ret);
          } else {
          }
        } else {
        }
      } else {
      }
    } else {
    }
    return (0);
  } else {
  }
  {
  reg = i915_find_fence_reg(dev, pipelined);
  }
  if ((unsigned long )reg == (unsigned long )((struct drm_i915_fence_reg *)0)) {
    return (-28);
  } else {
  }
  {
  ret = i915_gem_object_flush_fence(obj, pipelined);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  if ((unsigned long )reg->obj != (unsigned long )((struct drm_i915_gem_object *)0)) {
    {
    old = reg->obj;
    drm_gem_object_reference(& old->base);
    }
    if ((unsigned int )*((unsigned char *)old + 225UL) != 0U) {
      {
      i915_gem_release_mmap(old);
      }
    } else {
    }
    {
    ret = i915_gem_object_flush_fence(old, pipelined);
    }
    if (ret != 0) {
      {
      drm_gem_object_unreference(& old->base);
      }
      return (ret);
    } else {
    }
    if (old->last_fenced_seqno == 0U) {
      if (obj->last_fenced_seqno == 0U) {
        pipelined = (struct intel_ring_buffer *)0;
      } else {
      }
    } else {
    }
    old->fence_reg = (signed char)-1;
    old->last_fenced_ring = pipelined;
    if ((unsigned long )pipelined != (unsigned long )((struct intel_ring_buffer *)0)) {
      {
      tmp___1 = i915_gem_next_request_seqno(pipelined);
      old->last_fenced_seqno = tmp___1;
      }
    } else {
      old->last_fenced_seqno = 0U;
    }
    {
    drm_gem_object_unreference(& old->base);
    }
  } else
  if (obj->last_fenced_seqno == 0U) {
    pipelined = (struct intel_ring_buffer *)0;
  } else {
  }
  {
  reg->obj = obj;
  list_move_tail(& reg->lru_list, & dev_priv->mm.fence_list);
  obj->fence_reg = (signed char )(((long )reg - (long )(& dev_priv->fence_regs)) / 32L);
  obj->last_fenced_ring = pipelined;
  }
  if ((unsigned long )pipelined != (unsigned long )((struct intel_ring_buffer *)0)) {
    {
    tmp___2 = i915_gem_next_request_seqno(pipelined);
    reg->setup_seqno = tmp___2;
    }
  } else {
    reg->setup_seqno = 0U;
  }
  obj->last_fenced_seqno = reg->setup_seqno;
  update:
  obj->tiling_changed = (unsigned char)0;
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 7) {
    goto case_7;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 6) {
    goto case_6;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 5) {
    goto case_5;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 4) {
    goto case_4;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 3) {
    goto case_3;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 2) {
    goto case_2;
  } else
  if (0) {
    case_7: ;
    case_6:
    {
    ret = sandybridge_write_fence_reg(obj, pipelined);
    }
    goto ldv_39545;
    case_5: ;
    case_4:
    {
    ret = i965_write_fence_reg(obj, pipelined);
    }
    goto ldv_39545;
    case_3:
    {
    ret = i915_write_fence_reg(obj, pipelined);
    }
    goto ldv_39545;
    case_2:
    {
    ret = i830_write_fence_reg(obj, pipelined);
    }
    goto ldv_39545;
  } else {
  }
  ldv_39545: ;
  return (ret);
}
}
static void i915_gem_clear_fence_reg(struct drm_device *dev , struct drm_i915_fence_reg *reg )
{ drm_i915_private_t *dev_priv ;
  uint32_t fence_reg ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  fence_reg = (uint32_t )(((long )reg - (long )(& dev_priv->fence_regs)) / 32L);
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 7) {
    goto case_7;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 6) {
    goto case_6;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 5) {
    goto case_5;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 4) {
    goto case_4;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 3) {
    goto case_3;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 2) {
    goto case_2;
  } else
  if (0) {
    case_7: ;
    case_6:
    {
    i915_write64(dev_priv, (fence_reg + 131072U) * 8U, 0ULL);
    }
    goto ldv_39558;
    case_5: ;
    case_4:
    {
    i915_write64(dev_priv, (fence_reg + 1536U) * 8U, 0ULL);
    }
    goto ldv_39558;
    case_3: ;
    if (fence_reg > 7U) {
      fence_reg = (fence_reg + 3064U) * 4U;
    } else {
      case_2:
      fence_reg = (fence_reg + 2048U) * 4U;
    }
    {
    i915_write32(dev_priv, fence_reg, 0U);
    }
    goto ldv_39558;
  } else {
  }
  ldv_39558:
  {
  list_del_init(& reg->lru_list);
  reg->obj = (struct drm_i915_gem_object *)0;
  reg->setup_seqno = 0U;
  }
  return;
}
}
static int i915_gem_object_bind_to_gtt(struct drm_i915_gem_object *obj , unsigned int alignment ,
                                       bool map_and_fenceable )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  struct drm_mm_node *free_space ;
  gfp_t gfpmask ;
  u32 size ;
  u32 fence_size ;
  u32 fence_alignment ;
  u32 unfenced_alignment ;
  bool mappable ;
  bool fenceable ;
  int ret ;
  unsigned long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  {
  dev = obj->base.dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  gfpmask = 4608U;
  if ((unsigned int )*((unsigned char *)obj + 225UL) != 0U) {
    {
    drm_err("i915_gem_object_bind_to_gtt", "Attempting to bind a purgeable object\n");
    }
    return (-22);
  } else {
  }
  {
  fence_size = i915_gem_get_gtt_size(dev, (uint32_t )obj->base.size, (int )obj->tiling_mode);
  fence_alignment = i915_gem_get_gtt_alignment(dev, (uint32_t )obj->base.size, (int )obj->tiling_mode);
  unfenced_alignment = i915_gem_get_unfenced_gtt_alignment(dev, (uint32_t )obj->base.size,
                                                           (int )obj->tiling_mode);
  }
  if (alignment == 0U) {
    if ((int )map_and_fenceable) {
      alignment = fence_alignment;
    } else {
      alignment = unfenced_alignment;
    }
  } else {
  }
  if ((int )map_and_fenceable) {
    if (((fence_alignment - 1U) & alignment) != 0U) {
      {
      drm_err("i915_gem_object_bind_to_gtt", "Invalid object alignment requested %u\n",
              alignment);
      }
      return (-22);
    } else {
    }
  } else {
  }
  if ((int )map_and_fenceable) {
    size = fence_size;
  } else {
    size = (u32 )obj->base.size;
  }
  if ((int )map_and_fenceable) {
    tmp = dev_priv->mm.gtt_mappable_end;
  } else {
    tmp = dev_priv->mm.gtt_total;
  }
  if (obj->base.size > tmp) {
    {
    drm_err("i915_gem_object_bind_to_gtt", "Attempting to bind an object larger than the aperture\n");
    }
    return (-7);
  } else {
  }
  search_free: ;
  if ((int )map_and_fenceable) {
    {
    free_space = drm_mm_search_free_in_range((struct drm_mm const *)(& dev_priv->mm.gtt_space),
                                             (unsigned long )size, alignment, 0UL,
                                             dev_priv->mm.gtt_mappable_end, 0);
    }
  } else {
    {
    free_space = drm_mm_search_free((struct drm_mm const *)(& dev_priv->mm.gtt_space),
                                    (unsigned long )size, alignment, 0);
    }
  }
  if ((unsigned long )free_space != (unsigned long )((struct drm_mm_node *)0)) {
    if ((int )map_and_fenceable) {
      {
      obj->gtt_space = drm_mm_get_block_range_generic(free_space, (unsigned long )size,
                                                      alignment, 0UL, dev_priv->mm.gtt_mappable_end,
                                                      0);
      }
    } else {
      {
      obj->gtt_space = drm_mm_get_block(free_space, (unsigned long )size, alignment);
      }
    }
  } else {
  }
  if ((unsigned long )obj->gtt_space == (unsigned long )((struct drm_mm_node *)0)) {
    {
    ret = i915_gem_evict_something(dev, (int )size, alignment, (bool )((int )map_and_fenceable));
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
    goto search_free;
  } else {
  }
  {
  ret = i915_gem_object_get_pages_gtt(obj, gfpmask);
  }
  if (ret != 0) {
    {
    drm_mm_put_block(obj->gtt_space);
    obj->gtt_space = (struct drm_mm_node *)0;
    }
    if (ret == -12) {
      {
      ret = i915_gem_evict_everything(dev, (bool )0);
      }
      if (ret != 0) {
        if (gfpmask != 0U) {
          gfpmask = 0U;
          goto search_free;
        } else {
        }
        return (-12);
      } else {
      }
      goto search_free;
    } else {
    }
    return (ret);
  } else {
  }
  {
  ret = i915_gem_gtt_bind_object(obj);
  }
  if (ret != 0) {
    {
    i915_gem_object_put_pages_gtt(obj);
    drm_mm_put_block(obj->gtt_space);
    obj->gtt_space = (struct drm_mm_node *)0;
    tmp___0 = i915_gem_evict_everything(dev, (bool )0);
    }
    if (tmp___0 != 0) {
      return (ret);
    } else {
    }
    goto search_free;
  } else {
  }
  {
  list_add_tail(& obj->gtt_list, & dev_priv->mm.gtt_list);
  list_add_tail(& obj->mm_list, & dev_priv->mm.inactive_list);
  tmp___1 = __builtin_expect((long )((obj->base.read_domains & 4294967230U) != 0U),
                             0L);
  }
  if (tmp___1 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p"),
                         "i" (2853), "i" (12UL));
    ldv_39581: ;
    goto ldv_39581;
  } else {
  }
  {
  tmp___2 = __builtin_expect((long )((obj->base.write_domain & 4294967230U) != 0U),
                             0L);
  }
  if (tmp___2 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p"),
                         "i" (2854), "i" (12UL));
    ldv_39582: ;
    goto ldv_39582;
  } else {
  }
  obj->gtt_offset = (uint32_t )(obj->gtt_space)->start;
  if ((obj->gtt_space)->size == (unsigned long )fence_size) {
    if (((obj->gtt_space)->start & (unsigned long )(fence_alignment - 1U)) == 0UL) {
      tmp___3 = 1;
    } else {
      tmp___3 = 0;
    }
  } else {
    tmp___3 = 0;
  }
  fenceable = (bool )tmp___3;
  mappable = (bool )((size_t )obj->gtt_offset + obj->base.size <= dev_priv->mm.gtt_mappable_end);
  if ((int )mappable) {
    if ((int )fenceable) {
      tmp___4 = 1;
    } else {
      tmp___4 = 0;
    }
  } else {
    tmp___4 = 0;
  }
  {
  obj->map_and_fenceable = (unsigned char )tmp___4;
  trace_i915_gem_object_bind(obj, (bool )((int )map_and_fenceable));
  }
  return (0);
}
}
void i915_gem_clflush_object(struct drm_i915_gem_object *obj )
{
  {
  if ((unsigned long )obj->pages == (unsigned long )((struct page **)0)) {
    return;
  } else {
  }
  if ((unsigned int )*((unsigned char *)obj + 226UL) != 0U) {
    return;
  } else {
  }
  {
  trace_i915_gem_object_clflush(obj);
  drm_clflush_pages(obj->pages, obj->base.size / 4096UL);
  }
  return;
}
}
static int i915_gem_object_flush_gpu_write_domain(struct drm_i915_gem_object *obj )
{ int tmp ;
  {
  if ((obj->base.write_domain & 4294967230U) == 0U) {
    return (0);
  } else {
  }
  {
  tmp = i915_gem_flush_ring(obj->ring, 0U, obj->base.write_domain);
  }
  return (tmp);
}
}
static void i915_gem_object_flush_gtt_write_domain(struct drm_i915_gem_object *obj )
{ uint32_t old_write_domain ;
  {
  if (obj->base.write_domain != 64U) {
    return;
  } else {
  }
  {
  __asm__ volatile ("sfence": : : "memory");
  old_write_domain = obj->base.write_domain;
  obj->base.write_domain = 0U;
  trace_i915_gem_object_change_domain(obj, obj->base.read_domains, old_write_domain);
  }
  return;
}
}
static void i915_gem_object_flush_cpu_write_domain(struct drm_i915_gem_object *obj )
{ uint32_t old_write_domain ;
  {
  if (obj->base.write_domain != 1U) {
    return;
  } else {
  }
  {
  i915_gem_clflush_object(obj);
  intel_gtt_chipset_flush();
  old_write_domain = obj->base.write_domain;
  obj->base.write_domain = 0U;
  trace_i915_gem_object_change_domain(obj, obj->base.read_domains, old_write_domain);
  }
  return;
}
}
int i915_gem_object_set_to_gtt_domain(struct drm_i915_gem_object *obj , bool write )
{ uint32_t old_write_domain ;
  uint32_t old_read_domains ;
  int ret ;
  long tmp ;
  {
  if ((unsigned long )obj->gtt_space == (unsigned long )((struct drm_mm_node *)0)) {
    return (-22);
  } else {
  }
  if (obj->base.write_domain == 64U) {
    return (0);
  } else {
  }
  {
  ret = i915_gem_object_flush_gpu_write_domain(obj);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  if ((unsigned int )*((unsigned char *)obj + 224UL) != 0U) {
    goto _L;
  } else
  if ((int )write) {
    _L:
    {
    ret = i915_gem_object_wait_rendering(obj);
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
  } else {
  }
  {
  i915_gem_object_flush_cpu_write_domain(obj);
  old_write_domain = obj->base.write_domain;
  old_read_domains = obj->base.read_domains;
  tmp = __builtin_expect((long )((obj->base.write_domain & 4294967231U) != 0U), 0L);
  }
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p"),
                         "i" (2991), "i" (12UL));
    ldv_39604: ;
    goto ldv_39604;
  } else {
  }
  obj->base.read_domains = obj->base.read_domains | 64U;
  if ((int )write) {
    obj->base.read_domains = 64U;
    obj->base.write_domain = 64U;
    obj->dirty = (unsigned char)1;
  } else {
  }
  {
  trace_i915_gem_object_change_domain(obj, old_read_domains, old_write_domain);
  }
  return (0);
}
}
int i915_gem_object_set_to_display_plane(struct drm_i915_gem_object *obj , struct intel_ring_buffer *pipelined )
{ uint32_t old_read_domains ;
  int ret ;
  {
  if ((unsigned long )obj->gtt_space == (unsigned long )((struct drm_mm_node *)0)) {
    return (-22);
  } else {
  }
  {
  ret = i915_gem_object_flush_gpu_write_domain(obj);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  if ((unsigned long )obj->ring != (unsigned long )pipelined) {
    {
    ret = i915_gem_object_wait_rendering(obj);
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
  } else {
  }
  {
  i915_gem_object_flush_cpu_write_domain(obj);
  old_read_domains = obj->base.read_domains;
  obj->base.read_domains = obj->base.read_domains | 64U;
  trace_i915_gem_object_change_domain(obj, old_read_domains, obj->base.write_domain);
  }
  return (0);
}
}
int i915_gem_object_flush_gpu(struct drm_i915_gem_object *obj )
{ int ret ;
  int tmp ;
  {
  if ((unsigned int )*((unsigned char *)obj + 224UL) == 0U) {
    return (0);
  } else {
  }
  if ((obj->base.write_domain & 4294967230U) != 0U) {
    {
    ret = i915_gem_flush_ring(obj->ring, 0U, obj->base.write_domain);
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
  } else {
  }
  {
  tmp = i915_gem_object_wait_rendering(obj);
  }
  return (tmp);
}
}
static int i915_gem_object_set_to_cpu_domain(struct drm_i915_gem_object *obj , bool write )
{ uint32_t old_write_domain ;
  uint32_t old_read_domains ;
  int ret ;
  long tmp ;
  {
  if (obj->base.write_domain == 1U) {
    return (0);
  } else {
  }
  {
  ret = i915_gem_object_flush_gpu_write_domain(obj);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  ret = i915_gem_object_wait_rendering(obj);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  i915_gem_object_flush_gtt_write_domain(obj);
  i915_gem_object_set_to_full_cpu_read_domain(obj);
  old_write_domain = obj->base.write_domain;
  old_read_domains = obj->base.read_domains;
  }
  if ((obj->base.read_domains & 1U) == 0U) {
    {
    i915_gem_clflush_object(obj);
    obj->base.read_domains = obj->base.read_domains | 1U;
    }
  } else {
  }
  {
  tmp = __builtin_expect((long )((obj->base.write_domain & 4294967294U) != 0U), 0L);
  }
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p"),
                         "i" (3105), "i" (12UL));
    ldv_39622: ;
    goto ldv_39622;
  } else {
  }
  if ((int )write) {
    obj->base.read_domains = 1U;
    obj->base.write_domain = 1U;
  } else {
  }
  {
  trace_i915_gem_object_change_domain(obj, old_read_domains, old_write_domain);
  }
  return (0);
}
}
static void i915_gem_object_set_to_full_cpu_read_domain(struct drm_i915_gem_object *obj )
{ int i ;
  {
  if ((unsigned long )obj->page_cpu_valid == (unsigned long )((uint8_t *)0)) {
    return;
  } else {
  }
  if ((int )obj->base.read_domains & 1) {
    i = 0;
    goto ldv_39629;
    ldv_39628: ;
    if ((unsigned int )*(obj->page_cpu_valid + (unsigned long )i) != 0U) {
      goto ldv_39627;
    } else {
    }
    {
    drm_clflush_pages(obj->pages + (unsigned long )i, 1UL);
    }
    ldv_39627:
    i = i + 1;
    ldv_39629: ;
    if ((unsigned long )i <= (obj->base.size - 1UL) / 4096UL) {
      goto ldv_39628;
    } else {
      goto ldv_39630;
    }
    ldv_39630: ;
  } else {
  }
  {
  kfree((void const *)obj->page_cpu_valid);
  obj->page_cpu_valid = (uint8_t *)0;
  }
  return;
}
}
static int i915_gem_object_set_cpu_read_domain_range(struct drm_i915_gem_object *obj ,
                                                     uint64_t offset , uint64_t size )
{ uint32_t old_read_domains ;
  int i ;
  int ret ;
  int tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  {
  if (offset == 0ULL) {
    if ((unsigned long long )obj->base.size == size) {
      {
      tmp = i915_gem_object_set_to_cpu_domain(obj, (bool )0);
      }
      return (tmp);
    } else {
    }
  } else {
  }
  {
  ret = i915_gem_object_flush_gpu_write_domain(obj);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  ret = i915_gem_object_wait_rendering(obj);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  i915_gem_object_flush_gtt_write_domain(obj);
  }
  if ((unsigned long )obj->page_cpu_valid == (unsigned long )((uint8_t *)0)) {
    if ((int )obj->base.read_domains & 1) {
      return (0);
    } else {
    }
  } else {
  }
  if ((unsigned long )obj->page_cpu_valid == (unsigned long )((uint8_t *)0)) {
    {
    tmp___0 = kzalloc(obj->base.size / 4096UL, 208U);
    obj->page_cpu_valid = (uint8_t *)tmp___0;
    }
    if ((unsigned long )obj->page_cpu_valid == (unsigned long )((uint8_t *)0)) {
      return (-12);
    } else {
    }
  } else
  if ((obj->base.read_domains & 1U) == 0U) {
    {
    memset((void *)obj->page_cpu_valid, 0, obj->base.size / 4096UL);
    }
  } else {
  }
  i = (int )(offset / 4096ULL);
  goto ldv_39641;
  ldv_39640: ;
  if ((unsigned int )*(obj->page_cpu_valid + (unsigned long )i) != 0U) {
    goto ldv_39639;
  } else {
  }
  {
  drm_clflush_pages(obj->pages + (unsigned long )i, 1UL);
  *(obj->page_cpu_valid + (unsigned long )i) = (uint8_t )1U;
  }
  ldv_39639:
  i = i + 1;
  ldv_39641: ;
  if ((unsigned long long )i <= ((offset + size) - 1ULL) / 4096ULL) {
    goto ldv_39640;
  } else {
    goto ldv_39642;
  }
  ldv_39642:
  {
  tmp___1 = __builtin_expect((long )((obj->base.write_domain & 4294967294U) != 0U),
                             0L);
  }
  if (tmp___1 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p"),
                         "i" (3217), "i" (12UL));
    ldv_39643: ;
    goto ldv_39643;
  } else {
  }
  {
  old_read_domains = obj->base.read_domains;
  obj->base.read_domains = obj->base.read_domains | 1U;
  trace_i915_gem_object_change_domain(obj, old_read_domains, obj->base.write_domain);
  }
  return (0);
}
}
static int i915_gem_ring_throttle(struct drm_device *dev , struct drm_file *file )
{ struct drm_i915_private *dev_priv ;
  struct drm_i915_file_private *file_priv ;
  unsigned long recent_enough ;
  unsigned long tmp ;
  struct drm_i915_gem_request *request ;
  struct intel_ring_buffer *ring ;
  u32 seqno ;
  int ret ;
  int tmp___0 ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  int __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp___1 ;
  u32 tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  struct task_struct *tmp___5 ;
  int tmp___6 ;
  u32 tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  bool tmp___12 ;
  u32 tmp___13 ;
  bool tmp___14 ;
  int tmp___15 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  file_priv = (struct drm_i915_file_private *)file->driver_priv;
  tmp = msecs_to_jiffies((unsigned int const )20U);
  recent_enough = (unsigned long )jiffies - tmp;
  ring = (struct intel_ring_buffer *)0;
  seqno = 0U;
  tmp___0 = atomic_read((atomic_t const *)(& dev_priv->mm.wedged));
  }
  if (tmp___0 != 0) {
    return (-5);
  } else {
  }
  {
  spin_lock(& file_priv->mm.lock);
  __mptr = (struct list_head const *)file_priv->mm.request_list.next;
  request = (struct drm_i915_gem_request *)__mptr + 0x0fffffffffffffd0UL;
  }
  goto ldv_39667;
  ldv_39666: ;
  if ((long )request->emitted_jiffies - (long )recent_enough >= 0L) {
    goto ldv_39665;
  } else {
  }
  ring = request->ring;
  seqno = request->seqno;
  __mptr___0 = (struct list_head const *)request->client_list.next;
  request = (struct drm_i915_gem_request *)__mptr___0 + 0x0fffffffffffffd0UL;
  ldv_39667: ;
  if ((unsigned long )(& request->client_list) != (unsigned long )(& file_priv->mm.request_list)) {
    goto ldv_39666;
  } else {
    goto ldv_39665;
  }
  ldv_39665:
  {
  spin_unlock(& file_priv->mm.lock);
  }
  if (seqno == 0U) {
    return (0);
  } else {
  }
  {
  ret = 0;
  tmp___13 = (*(ring->get_seqno))(ring);
  tmp___14 = i915_seqno_passed(tmp___13, seqno);
  }
  if (tmp___14) {
    tmp___15 = 0;
  } else {
    tmp___15 = 1;
  }
  if (tmp___15) {
    {
    tmp___12 = (*(ring->irq_get))(ring);
    }
    if ((int )tmp___12) {
      {
      __ret = 0;
      tmp___7 = (*(ring->get_seqno))(ring);
      tmp___8 = i915_seqno_passed(tmp___7, seqno);
      }
      if (tmp___8) {
        tmp___9 = 0;
      } else {
        tmp___9 = 1;
      }
      if (tmp___9) {
        {
        tmp___10 = atomic_read((atomic_t const *)(& dev_priv->mm.wedged));
        }
        if (tmp___10 == 0) {
          {
          tmp___1 = get_current();
          __wait.flags = 0U;
          __wait.private = (void *)tmp___1;
          __wait.func = & autoremove_wake_function;
          __wait.task_list.next = & __wait.task_list;
          __wait.task_list.prev = & __wait.task_list;
          }
          ldv_39672:
          {
          prepare_to_wait(& ring->irq_queue, & __wait, 1);
          tmp___2 = (*(ring->get_seqno))(ring);
          tmp___3 = i915_seqno_passed(tmp___2, seqno);
          }
          if ((int )tmp___3) {
            goto ldv_39670;
          } else {
            {
            tmp___4 = atomic_read((atomic_t const *)(& dev_priv->mm.wedged));
            }
            if (tmp___4 != 0) {
              goto ldv_39670;
            } else {
            }
          }
          {
          tmp___5 = get_current();
          tmp___6 = signal_pending(tmp___5);
          }
          if (tmp___6 == 0) {
            {
            schedule();
            }
            goto ldv_39671;
          } else {
          }
          __ret = -512;
          goto ldv_39670;
          ldv_39671: ;
          goto ldv_39672;
          ldv_39670:
          {
          finish_wait(& ring->irq_queue, & __wait);
          }
        } else {
        }
      } else {
      }
      {
      ret = __ret;
      (*(ring->irq_put))(ring);
      }
      if (ret == 0) {
        {
        tmp___11 = atomic_read((atomic_t const *)(& dev_priv->mm.wedged));
        }
        if (tmp___11 != 0) {
          ret = -5;
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  if (ret == 0) {
    {
    queue_delayed_work(dev_priv->wq, & dev_priv->mm.retire_work, 0UL);
    }
  } else {
  }
  return (ret);
}
}
int i915_gem_object_pin(struct drm_i915_gem_object *obj , uint32_t alignment , bool map_and_fenceable )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  int ret ;
  long tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  int __ret_warn_on___0 ;
  long tmp___1 ;
  unsigned char tmp___2 ;
  int __ret_warn_on___1 ;
  long tmp___3 ;
  {
  {
  dev = obj->base.dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = __builtin_expect((long )(*((unsigned int *)obj + 56UL) == 122880U), 0L);
  }
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p"),
                         "i" (3299), "i" (12UL));
    ldv_39682: ;
    goto ldv_39682;
  } else {
  }
  {
  __ret_warn_on = 0;
  tmp___0 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp___0 != 0L) {
    {
    warn_slowpath_null("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p",
                       (int const )3300);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if ((unsigned long )obj->gtt_space != (unsigned long )((struct drm_mm_node *)0)) {
    if (alignment != 0U) {
      if ((obj->gtt_offset & (alignment - 1U)) != 0U) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else
    _L___0:
    if ((int )map_and_fenceable) {
      if ((unsigned int )*((unsigned char *)obj + 226UL) == 0U) {
        _L:
        {
        __ret_warn_on___0 = *((unsigned int *)obj + 56UL) != 0U;
        tmp___1 = __builtin_expect((long )(__ret_warn_on___0 != 0), 0L);
        }
        if (tmp___1 != 0L) {
          {
          warn_slowpath_fmt("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p",
                            (int const )3311, "bo is already pinned with incorrect alignment: offset=%x, req.alignment=%x, req.map_and_fenceable=%d, obj->map_and_fenceable=%d\n",
                            obj->gtt_offset, alignment, (int )map_and_fenceable, (int )obj->map_and_fenceable);
          }
        } else {
        }
        {
        __builtin_expect((long )(__ret_warn_on___0 != 0), 0L);
        ret = i915_gem_object_unbind(obj);
        }
        if (ret != 0) {
          return (ret);
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  if ((unsigned long )obj->gtt_space == (unsigned long )((struct drm_mm_node *)0)) {
    {
    ret = i915_gem_object_bind_to_gtt(obj, alignment, (bool )((int )map_and_fenceable));
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
  } else {
  }
  tmp___2 = obj->pin_count;
  obj->pin_count = (unsigned char )((int )obj->pin_count + 1);
  if ((unsigned int )tmp___2 == 0U) {
    if ((unsigned int )*((unsigned char *)obj + 224UL) == 0U) {
      {
      list_move_tail(& obj->mm_list, & dev_priv->mm.pinned_list);
      }
    } else {
    }
  } else {
  }
  {
  obj->pin_mappable = (unsigned char )((int )obj->pin_mappable | (int )((unsigned char )map_and_fenceable));
  __ret_warn_on___1 = 0;
  tmp___3 = __builtin_expect((long )(__ret_warn_on___1 != 0), 0L);
  }
  if (tmp___3 != 0L) {
    {
    warn_slowpath_null("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p",
                       (int const )3332);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on___1 != 0), 0L);
  }
  return (0);
}
}
void i915_gem_object_unpin(struct drm_i915_gem_object *obj )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int __ret_warn_on___0 ;
  long tmp___2 ;
  {
  {
  dev = obj->base.dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  __ret_warn_on = 0;
  tmp = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp != 0L) {
    {
    warn_slowpath_null("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p",
                       (int const )3342);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on != 0), 0L);
  tmp___0 = __builtin_expect((long )(*((unsigned int *)obj + 56UL) == 0U), 0L);
  }
  if (tmp___0 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p"),
                         "i" (3343), "i" (12UL));
    ldv_39696: ;
    goto ldv_39696;
  } else {
  }
  {
  tmp___1 = __builtin_expect((long )((unsigned long )obj->gtt_space == (unsigned long )((struct drm_mm_node *)0)),
                             0L);
  }
  if (tmp___1 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p"),
                         "i" (3344), "i" (12UL));
    ldv_39697: ;
    goto ldv_39697;
  } else {
  }
  obj->pin_count = (unsigned char )((int )obj->pin_count - 1);
  if ((unsigned int )obj->pin_count == 0U) {
    if ((unsigned int )*((unsigned char *)obj + 224UL) == 0U) {
      {
      list_move_tail(& obj->mm_list, & dev_priv->mm.inactive_list);
      }
    } else {
    }
    obj->pin_mappable = (unsigned char)0;
  } else {
  }
  {
  __ret_warn_on___0 = 0;
  tmp___2 = __builtin_expect((long )(__ret_warn_on___0 != 0), 0L);
  }
  if (tmp___2 != 0L) {
    {
    warn_slowpath_null("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p",
                       (int const )3352);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on___0 != 0), 0L);
  }
  return;
}
}
int i915_gem_pin_ioctl(struct drm_device *dev , void *data , struct drm_file *file )
{ struct drm_i915_gem_pin *args ;
  struct drm_i915_gem_object *obj ;
  int ret ;
  struct drm_gem_object const *__mptr ;
  struct drm_gem_object *tmp ;
  {
  {
  args = (struct drm_i915_gem_pin *)data;
  ret = i915_mutex_lock_interruptible(dev);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  tmp = drm_gem_object_lookup(dev, file, args->handle);
  __mptr = (struct drm_gem_object const *)tmp;
  obj = (struct drm_i915_gem_object *)__mptr;
  }
  if ((unsigned long )(& obj->base) == (unsigned long )((struct drm_gem_object *)0)) {
    ret = -2;
    goto unlock;
  } else {
  }
  if ((unsigned int )*((unsigned char *)obj + 225UL) != 0U) {
    {
    drm_err("i915_gem_pin_ioctl", "Attempting to pin a purgeable buffer\n");
    ret = -22;
    }
    goto out;
  } else {
  }
  if ((unsigned long )obj->pin_filp != (unsigned long )((struct drm_file *)0)) {
    if ((unsigned long )obj->pin_filp != (unsigned long )file) {
      {
      drm_err("i915_gem_pin_ioctl", "Already pinned in i915_gem_pin_ioctl(): %d\n",
              args->handle);
      ret = -22;
      }
      goto out;
    } else {
    }
  } else {
  }
  obj->user_pin_count = obj->user_pin_count + 1U;
  obj->pin_filp = file;
  if (obj->user_pin_count == 1U) {
    {
    ret = i915_gem_object_pin(obj, (uint32_t )args->alignment, (bool )1);
    }
    if (ret != 0) {
      goto out;
    } else {
    }
  } else {
  }
  {
  i915_gem_object_flush_cpu_write_domain(obj);
  args->offset = (__u64 )obj->gtt_offset;
  }
  out:
  {
  drm_gem_object_unreference(& obj->base);
  }
  unlock:
  {
  mutex_unlock(& dev->struct_mutex);
  }
  return (ret);
}
}
int i915_gem_unpin_ioctl(struct drm_device *dev , void *data , struct drm_file *file )
{ struct drm_i915_gem_pin *args ;
  struct drm_i915_gem_object *obj ;
  int ret ;
  struct drm_gem_object const *__mptr ;
  struct drm_gem_object *tmp ;
  {
  {
  args = (struct drm_i915_gem_pin *)data;
  ret = i915_mutex_lock_interruptible(dev);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  tmp = drm_gem_object_lookup(dev, file, args->handle);
  __mptr = (struct drm_gem_object const *)tmp;
  obj = (struct drm_i915_gem_object *)__mptr;
  }
  if ((unsigned long )(& obj->base) == (unsigned long )((struct drm_gem_object *)0)) {
    ret = -2;
    goto unlock;
  } else {
  }
  if ((unsigned long )obj->pin_filp != (unsigned long )file) {
    {
    drm_err("i915_gem_unpin_ioctl", "Not pinned by caller in i915_gem_pin_ioctl(): %d\n",
            args->handle);
    ret = -22;
    }
    goto out;
  } else {
  }
  obj->user_pin_count = obj->user_pin_count - 1U;
  if (obj->user_pin_count == 0U) {
    {
    obj->pin_filp = (struct drm_file *)0;
    i915_gem_object_unpin(obj);
    }
  } else {
  }
  out:
  {
  drm_gem_object_unreference(& obj->base);
  }
  unlock:
  {
  mutex_unlock(& dev->struct_mutex);
  }
  return (ret);
}
}
int i915_gem_busy_ioctl(struct drm_device *dev , void *data , struct drm_file *file )
{ struct drm_i915_gem_busy *args ;
  struct drm_i915_gem_object *obj ;
  int ret ;
  struct drm_gem_object const *__mptr ;
  struct drm_gem_object *tmp ;
  struct drm_i915_gem_request *request ;
  void *tmp___0 ;
  {
  {
  args = (struct drm_i915_gem_busy *)data;
  ret = i915_mutex_lock_interruptible(dev);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  tmp = drm_gem_object_lookup(dev, file, args->handle);
  __mptr = (struct drm_gem_object const *)tmp;
  obj = (struct drm_i915_gem_object *)__mptr;
  }
  if ((unsigned long )(& obj->base) == (unsigned long )((struct drm_gem_object *)0)) {
    ret = -2;
    goto unlock;
  } else {
  }
  args->busy = (__u32 )obj->active;
  if (args->busy != 0U) {
    if ((obj->base.write_domain & 4294967230U) != 0U) {
      {
      ret = i915_gem_flush_ring(obj->ring, 0U, obj->base.write_domain);
      }
    } else
    if ((obj->ring)->outstanding_lazy_request == obj->last_rendering_seqno) {
      {
      tmp___0 = kzalloc(64UL, 208U);
      request = (struct drm_i915_gem_request *)tmp___0;
      }
      if ((unsigned long )request != (unsigned long )((struct drm_i915_gem_request *)0)) {
        {
        ret = i915_add_request(obj->ring, (struct drm_file *)0, request);
        }
      } else {
        ret = -12;
      }
    } else {
    }
    {
    i915_gem_retire_requests_ring(obj->ring);
    args->busy = (__u32 )obj->active;
    }
  } else {
  }
  {
  drm_gem_object_unreference(& obj->base);
  }
  unlock:
  {
  mutex_unlock(& dev->struct_mutex);
  }
  return (ret);
}
}
int i915_gem_throttle_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv )
{ int tmp ;
  {
  {
  tmp = i915_gem_ring_throttle(dev, file_priv);
  }
  return (tmp);
}
}
int i915_gem_madvise_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv )
{ struct drm_i915_gem_madvise *args ;
  struct drm_i915_gem_object *obj ;
  int ret ;
  struct drm_gem_object const *__mptr ;
  struct drm_gem_object *tmp ;
  int tmp___0 ;
  {
  args = (struct drm_i915_gem_madvise *)data;
  if ((int )args->madv == 1) {
    goto case_1;
  } else
  if ((int )args->madv == 0) {
    goto case_0;
  } else {
    goto switch_default;
    if (0) {
      case_1: ;
      case_0: ;
      goto ldv_39753;
      switch_default: ;
      return (-22);
    } else {
    }
  }
  ldv_39753:
  {
  ret = i915_mutex_lock_interruptible(dev);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  tmp = drm_gem_object_lookup(dev, file_priv, args->handle);
  __mptr = (struct drm_gem_object const *)tmp;
  obj = (struct drm_i915_gem_object *)__mptr;
  }
  if ((unsigned long )(& obj->base) == (unsigned long )((struct drm_gem_object *)0)) {
    ret = -2;
    goto unlock;
  } else {
  }
  if (*((unsigned int *)obj + 56UL) != 0U) {
    ret = -22;
    goto out;
  } else {
  }
  if ((unsigned int )*((unsigned char *)obj + 225UL) != 2U) {
    obj->madv = (unsigned char )args->madv;
  } else {
  }
  {
  tmp___0 = i915_gem_object_is_purgeable(obj);
  }
  if (tmp___0 != 0) {
    if ((unsigned long )obj->gtt_space == (unsigned long )((struct drm_mm_node *)0)) {
      {
      i915_gem_object_truncate(obj);
      }
    } else {
    }
  } else {
  }
  args->retained = (__u32 )((unsigned int )*((unsigned char *)obj + 225UL) != 2U);
  out:
  {
  drm_gem_object_unreference(& obj->base);
  }
  unlock:
  {
  mutex_unlock(& dev->struct_mutex);
  }
  return (ret);
}
}
struct drm_i915_gem_object *i915_gem_alloc_object(struct drm_device *dev , size_t size )
{ struct drm_i915_private *dev_priv ;
  struct drm_i915_gem_object *obj ;
  struct address_space *mapping ;
  void *tmp ;
  int tmp___0 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = kzalloc(376UL, 208U);
  obj = (struct drm_i915_gem_object *)tmp;
  }
  if ((unsigned long )obj == (unsigned long )((struct drm_i915_gem_object *)0)) {
    return ((struct drm_i915_gem_object *)0);
  } else {
  }
  {
  tmp___0 = drm_gem_object_init(dev, & obj->base, size);
  }
  if (tmp___0 != 0) {
    {
    kfree((void const *)obj);
    }
    return ((struct drm_i915_gem_object *)0);
  } else {
  }
  {
  mapping = (((obj->base.filp)->f_path.dentry)->d_inode)->i_mapping;
  mapping_set_gfp_mask(mapping, 655570U);
  i915_gem_info_add_obj(dev_priv, size);
  obj->base.write_domain = 1U;
  obj->base.read_domains = 1U;
  obj->cache_level = (unsigned char)0;
  obj->base.driver_private = (void *)0;
  obj->fence_reg = (signed char)-1;
  INIT_LIST_HEAD(& obj->mm_list);
  INIT_LIST_HEAD(& obj->gtt_list);
  INIT_LIST_HEAD(& obj->ring_list);
  INIT_LIST_HEAD(& obj->exec_list);
  INIT_LIST_HEAD(& obj->gpu_write_list);
  obj->madv = (unsigned char)0;
  obj->map_and_fenceable = (unsigned char)1;
  }
  return (obj);
}
}
int i915_gem_init_object(struct drm_gem_object *obj )
{
  {
  __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p"),
                       "i" (3602), "i" (12UL));
  ldv_39769: ;
  goto ldv_39769;
  return (0);
}
}
static void i915_gem_free_object_tail(struct drm_i915_gem_object *obj )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  int ret ;
  {
  {
  dev = obj->base.dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ret = i915_gem_object_unbind(obj);
  }
  if (ret == -512) {
    {
    list_move(& obj->mm_list, & dev_priv->mm.deferred_free_list);
    }
    return;
  } else {
  }
  {
  trace_i915_gem_object_destroy(obj);
  }
  if ((unsigned long )obj->base.map_list.map != (unsigned long )((struct drm_local_map *)0)) {
    {
    i915_gem_free_mmap_offset(obj);
    }
  } else {
  }
  {
  drm_gem_object_release(& obj->base);
  i915_gem_info_remove_obj(dev_priv, obj->base.size);
  kfree((void const *)obj->page_cpu_valid);
  kfree((void const *)obj->bit_17);
  kfree((void const *)obj);
  }
  return;
}
}
void i915_gem_free_object(struct drm_gem_object *gem_obj )
{ struct drm_i915_gem_object *obj ;
  struct drm_gem_object const *__mptr ;
  struct drm_device *dev ;
  {
  __mptr = (struct drm_gem_object const *)gem_obj;
  obj = (struct drm_i915_gem_object *)__mptr;
  dev = obj->base.dev;
  goto ldv_39784;
  ldv_39783:
  {
  i915_gem_object_unpin(obj);
  }
  ldv_39784: ;
  if ((int )obj->pin_count > 0) {
    goto ldv_39783;
  } else {
    goto ldv_39785;
  }
  ldv_39785: ;
  if ((unsigned long )obj->phys_obj != (unsigned long )((struct drm_i915_gem_phys_object *)0)) {
    {
    i915_gem_detach_phys_object(dev, obj);
    }
  } else {
  }
  {
  i915_gem_free_object_tail(obj);
  }
  return;
}
}
int i915_gem_idle(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  int ret ;
  int tmp ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  mutex_lock_nested(& dev->struct_mutex, 0U);
  }
  if (dev_priv->mm.suspended != 0) {
    {
    mutex_unlock(& dev->struct_mutex);
    }
    return (0);
  } else {
  }
  {
  ret = i915_gpu_idle(dev);
  }
  if (ret != 0) {
    {
    mutex_unlock(& dev->struct_mutex);
    }
    return (ret);
  } else {
  }
  {
  tmp = drm_core_check_feature(dev, 8192);
  }
  if (tmp == 0) {
    {
    ret = i915_gem_evict_inactive(dev, (bool )0);
    }
    if (ret != 0) {
      {
      mutex_unlock(& dev->struct_mutex);
      }
      return (ret);
    } else {
    }
  } else {
  }
  {
  i915_gem_reset_fences(dev);
  dev_priv->mm.suspended = 1;
  del_timer_sync(& dev_priv->hangcheck_timer);
  i915_kernel_lost_context(dev);
  i915_gem_cleanup_ringbuffer(dev);
  mutex_unlock(& dev->struct_mutex);
  cancel_delayed_work_sync(& dev_priv->mm.retire_work);
  }
  return (0);
}
}
int i915_gem_init_ringbuffer(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  int ret ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ret = intel_init_render_ring_buffer(dev);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 3UL) != 0U) {
    {
    ret = intel_init_bsd_ring_buffer(dev);
    }
    if (ret != 0) {
      goto cleanup_render_ring;
    } else {
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 3UL) != 0U) {
    {
    ret = intel_init_blt_ring_buffer(dev);
    }
    if (ret != 0) {
      goto cleanup_bsd_ring;
    } else {
    }
  } else {
  }
  dev_priv->next_seqno = 1U;
  return (0);
  cleanup_bsd_ring:
  {
  intel_cleanup_ring_buffer((struct intel_ring_buffer *)(& dev_priv->ring) + 1UL);
  }
  cleanup_render_ring:
  {
  intel_cleanup_ring_buffer((struct intel_ring_buffer *)(& dev_priv->ring));
  }
  return (ret);
}
}
void i915_gem_cleanup_ringbuffer(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  int i ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  i = 0;
  goto ldv_39804;
  ldv_39803:
  {
  intel_cleanup_ring_buffer((struct intel_ring_buffer *)(& dev_priv->ring) + (unsigned long )i);
  i = i + 1;
  }
  ldv_39804: ;
  if (i <= 2) {
    goto ldv_39803;
  } else {
    goto ldv_39805;
  }
  ldv_39805: ;
  return;
}
}
int i915_gem_entervt_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv )
{ drm_i915_private_t *dev_priv ;
  int ret ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = drm_core_check_feature(dev, 8192);
  }
  if (tmp != 0) {
    return (0);
  } else {
  }
  {
  tmp___0 = atomic_read((atomic_t const *)(& dev_priv->mm.wedged));
  }
  if (tmp___0 != 0) {
    {
    drm_err("i915_gem_entervt_ioctl", "Reenabling wedged hardware, good luck\n");
    atomic_set(& dev_priv->mm.wedged, 0);
    }
  } else {
  }
  {
  mutex_lock_nested(& dev->struct_mutex, 0U);
  dev_priv->mm.suspended = 0;
  ret = i915_gem_init_ringbuffer(dev);
  }
  if (ret != 0) {
    {
    mutex_unlock(& dev->struct_mutex);
    }
    return (ret);
  } else {
  }
  {
  tmp___1 = list_empty((struct list_head const *)(& dev_priv->mm.active_list));
  tmp___2 = __builtin_expect((long )(tmp___1 == 0), 0L);
  }
  if (tmp___2 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p"),
                         "i" (3762), "i" (12UL));
    ldv_39815: ;
    goto ldv_39815;
  } else {
  }
  {
  tmp___3 = list_empty((struct list_head const *)(& dev_priv->mm.flushing_list));
  tmp___4 = __builtin_expect((long )(tmp___3 == 0), 0L);
  }
  if (tmp___4 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p"),
                         "i" (3763), "i" (12UL));
    ldv_39816: ;
    goto ldv_39816;
  } else {
  }
  {
  tmp___5 = list_empty((struct list_head const *)(& dev_priv->mm.inactive_list));
  tmp___6 = __builtin_expect((long )(tmp___5 == 0), 0L);
  }
  if (tmp___6 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p"),
                         "i" (3764), "i" (12UL));
    ldv_39817: ;
    goto ldv_39817;
  } else {
  }
  i = 0;
  goto ldv_39821;
  ldv_39820:
  {
  tmp___7 = list_empty((struct list_head const *)(& dev_priv->ring[i].active_list));
  tmp___8 = __builtin_expect((long )(tmp___7 == 0), 0L);
  }
  if (tmp___8 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p"),
                         "i" (3766), "i" (12UL));
    ldv_39818: ;
    goto ldv_39818;
  } else {
  }
  {
  tmp___9 = list_empty((struct list_head const *)(& dev_priv->ring[i].request_list));
  tmp___10 = __builtin_expect((long )(tmp___9 == 0), 0L);
  }
  if (tmp___10 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem.c.p"),
                         "i" (3767), "i" (12UL));
    ldv_39819: ;
    goto ldv_39819;
  } else {
  }
  i = i + 1;
  ldv_39821: ;
  if (i <= 2) {
    goto ldv_39820;
  } else {
    goto ldv_39822;
  }
  ldv_39822:
  {
  mutex_unlock(& dev->struct_mutex);
  ret = drm_irq_install(dev);
  }
  if (ret != 0) {
    goto cleanup_ringbuffer;
  } else {
  }
  return (0);
  cleanup_ringbuffer:
  {
  mutex_lock_nested(& dev->struct_mutex, 0U);
  i915_gem_cleanup_ringbuffer(dev);
  dev_priv->mm.suspended = 1;
  mutex_unlock(& dev->struct_mutex);
  }
  return (ret);
}
}
int i915_gem_leavevt_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv )
{ int tmp ;
  int tmp___0 ;
  {
  {
  tmp = drm_core_check_feature(dev, 8192);
  }
  if (tmp != 0) {
    return (0);
  } else {
  }
  {
  drm_irq_uninstall(dev);
  tmp___0 = i915_gem_idle(dev);
  }
  return (tmp___0);
}
}
void i915_gem_lastclose(struct drm_device *dev )
{ int ret ;
  int tmp ;
  {
  {
  tmp = drm_core_check_feature(dev, 8192);
  }
  if (tmp != 0) {
    return;
  } else {
  }
  {
  ret = i915_gem_idle(dev);
  }
  if (ret != 0) {
    {
    drm_err("i915_gem_lastclose", "failed to idle hardware: %d\n", ret);
    }
  } else {
  }
  return;
}
}
static void init_ring_lists(struct intel_ring_buffer *ring )
{
  {
  {
  INIT_LIST_HEAD(& ring->active_list);
  INIT_LIST_HEAD(& ring->request_list);
  INIT_LIST_HEAD(& ring->gpu_write_list);
  }
  return;
}
}
void i915_gem_load(struct drm_device *dev )
{ int i ;
  drm_i915_private_t *dev_priv ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___0 ;
  u32 tmp ;
  u32 tmp___0 ;
  int tmp___1 ;
  struct lock_class_key __key___1 ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  INIT_LIST_HEAD(& dev_priv->mm.active_list);
  INIT_LIST_HEAD(& dev_priv->mm.flushing_list);
  INIT_LIST_HEAD(& dev_priv->mm.inactive_list);
  INIT_LIST_HEAD(& dev_priv->mm.pinned_list);
  INIT_LIST_HEAD(& dev_priv->mm.fence_list);
  INIT_LIST_HEAD(& dev_priv->mm.deferred_free_list);
  INIT_LIST_HEAD(& dev_priv->mm.gtt_list);
  i = 0;
  }
  goto ldv_39843;
  ldv_39842:
  {
  init_ring_lists((struct intel_ring_buffer *)(& dev_priv->ring) + (unsigned long )i);
  i = i + 1;
  }
  ldv_39843: ;
  if (i <= 2) {
    goto ldv_39842;
  } else {
    goto ldv_39844;
  }
  ldv_39844:
  i = 0;
  goto ldv_39846;
  ldv_39845:
  {
  INIT_LIST_HEAD(& dev_priv->fence_regs[i].lru_list);
  i = i + 1;
  }
  ldv_39846: ;
  if (i <= 15) {
    goto ldv_39845;
  } else {
    goto ldv_39847;
  }
  ldv_39847:
  {
  __init_work(& dev_priv->mm.retire_work.work, 0);
  __constr_expr_0.counter = 2097664L;
  dev_priv->mm.retire_work.work.data = __constr_expr_0;
  lockdep_init_map(& dev_priv->mm.retire_work.work.lockdep_map, "(&(&dev_priv->mm.retire_work)->work)",
                   & __key, 0);
  INIT_LIST_HEAD(& dev_priv->mm.retire_work.work.entry);
  dev_priv->mm.retire_work.work.func = & i915_gem_retire_work_handler;
  init_timer_key(& dev_priv->mm.retire_work.timer, "&(&dev_priv->mm.retire_work)->timer",
                 & __key___0);
  init_completion(& dev_priv->error_completion);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 3U) {
    {
    tmp___0 = i915_read32(dev_priv, 8420U);
    tmp = tmp___0;
    }
    if ((tmp & 2048U) == 0U) {
      {
      tmp = 134219776U;
      i915_write32(dev_priv, 8420U, tmp);
      }
    } else {
    }
  } else {
  }
  {
  dev_priv->relative_constants_mode = 0;
  tmp___1 = drm_core_check_feature(dev, 8192);
  }
  if (tmp___1 == 0) {
    dev_priv->fence_reg_start = 3;
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    dev_priv->num_fence_regs = 16;
  } else
  if (dev->pci_device == 10098) {
    dev_priv->num_fence_regs = 16;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    dev_priv->num_fence_regs = 16;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    dev_priv->num_fence_regs = 16;
  } else {
    dev_priv->num_fence_regs = 8;
  }
  i = 0;
  goto ldv_39853;
  ldv_39852:
  {
  i915_gem_clear_fence_reg(dev, (struct drm_i915_fence_reg *)(& dev_priv->fence_regs) + (unsigned long )i);
  i = i + 1;
  }
  ldv_39853: ;
  if (dev_priv->num_fence_regs > i) {
    goto ldv_39852;
  } else {
    goto ldv_39854;
  }
  ldv_39854:
  {
  i915_gem_detect_bit_6_swizzle(dev);
  __init_waitqueue_head(& dev_priv->pending_flip_queue, & __key___1);
  dev_priv->mm.interruptible = (bool )1;
  dev_priv->mm.inactive_shrinker.shrink = & i915_gem_inactive_shrink;
  dev_priv->mm.inactive_shrinker.seeks = 2;
  register_shrinker(& dev_priv->mm.inactive_shrinker);
  }
  return;
}
}
static int i915_gem_init_phys_object(struct drm_device *dev , int id , int size ,
                                     int align )
{ drm_i915_private_t *dev_priv ;
  struct drm_i915_gem_phys_object *phys_obj ;
  int ret ;
  void *tmp ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  if ((unsigned long )dev_priv->mm.phys_objs[id + -1] != (unsigned long )((struct drm_i915_gem_phys_object *)0)) {
    return (0);
  } else
  if (size == 0) {
    return (0);
  } else {
  }
  {
  tmp = kzalloc(32UL, 208U);
  phys_obj = (struct drm_i915_gem_phys_object *)tmp;
  }
  if ((unsigned long )phys_obj == (unsigned long )((struct drm_i915_gem_phys_object *)0)) {
    return (-12);
  } else {
  }
  {
  phys_obj->id = id;
  phys_obj->handle = drm_pci_alloc(dev, (size_t )size, (size_t )align);
  }
  if ((unsigned long )phys_obj->handle == (unsigned long )((drm_dma_handle_t *)0)) {
    ret = -12;
    goto kfree_obj;
  } else {
  }
  {
  set_memory_wc((unsigned long )(phys_obj->handle)->vaddr, (int )((phys_obj->handle)->size / 4096UL));
  dev_priv->mm.phys_objs[id + -1] = phys_obj;
  }
  return (0);
  kfree_obj:
  {
  kfree((void const *)phys_obj);
  }
  return (ret);
}
}
static void i915_gem_free_phys_object(struct drm_device *dev , int id )
{ drm_i915_private_t *dev_priv ;
  struct drm_i915_gem_phys_object *phys_obj ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  if ((unsigned long )dev_priv->mm.phys_objs[id + -1] == (unsigned long )((struct drm_i915_gem_phys_object *)0)) {
    return;
  } else {
  }
  phys_obj = dev_priv->mm.phys_objs[id + -1];
  if ((unsigned long )phys_obj->cur_obj != (unsigned long )((struct drm_i915_gem_object *)0)) {
    {
    i915_gem_detach_phys_object(dev, phys_obj->cur_obj);
    }
  } else {
  }
  {
  set_memory_wb((unsigned long )(phys_obj->handle)->vaddr, (int )((phys_obj->handle)->size / 4096UL));
  drm_pci_free(dev, phys_obj->handle);
  kfree((void const *)phys_obj);
  dev_priv->mm.phys_objs[id + -1] = (struct drm_i915_gem_phys_object *)0;
  }
  return;
}
}
void i915_gem_free_all_phys_object(struct drm_device *dev )
{ int i ;
  {
  i = 1;
  goto ldv_39877;
  ldv_39876:
  {
  i915_gem_free_phys_object(dev, i);
  i = i + 1;
  }
  ldv_39877: ;
  if (i <= 3) {
    goto ldv_39876;
  } else {
    goto ldv_39878;
  }
  ldv_39878: ;
  return;
}
}
void i915_gem_detach_phys_object(struct drm_device *dev , struct drm_i915_gem_object *obj )
{ struct address_space *mapping ;
  char *vaddr ;
  int i ;
  int page_count___0 ;
  struct page *page ;
  struct page *tmp ;
  char *dst ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  long tmp___1 ;
  {
  mapping = (((obj->base.filp)->f_path.dentry)->d_inode)->i_mapping;
  if ((unsigned long )obj->phys_obj == (unsigned long )((struct drm_i915_gem_phys_object *)0)) {
    return;
  } else {
  }
  vaddr = (char *)((obj->phys_obj)->handle)->vaddr;
  page_count___0 = (int )(obj->base.size / 4096UL);
  i = 0;
  goto ldv_39893;
  ldv_39892:
  {
  tmp = shmem_read_mapping_page(mapping, (unsigned long )i);
  page = tmp;
  tmp___1 = IS_ERR((void const *)page);
  }
  if (tmp___1 == 0L) {
    {
    tmp___0 = __kmap_atomic(page);
    dst = (char *)tmp___0;
    __len = 4096UL;
    }
    if (__len > 63UL) {
      {
      __ret = memcpy((void *)dst, (void const *)(vaddr + (unsigned long )i * 4096UL),
                       __len);
      }
    } else {
      {
      __ret = memcpy((void *)dst, (void const *)(vaddr + (unsigned long )i * 4096UL),
                               __len);
      }
    }
    {
    __kunmap_atomic((void *)dst);
    drm_clflush_pages(& page, 1UL);
    set_page_dirty(page);
    mark_page_accessed(page);
    put_page(page);
    }
  } else {
  }
  i = i + 1;
  ldv_39893: ;
  if (i < page_count___0) {
    goto ldv_39892;
  } else {
    goto ldv_39894;
  }
  ldv_39894:
  {
  intel_gtt_chipset_flush();
  (obj->phys_obj)->cur_obj = (struct drm_i915_gem_object *)0;
  obj->phys_obj = (struct drm_i915_gem_phys_object *)0;
  }
  return;
}
}
int i915_gem_attach_phys_object(struct drm_device *dev , struct drm_i915_gem_object *obj ,
                                int id , int align )
{ struct address_space *mapping ;
  drm_i915_private_t *dev_priv ;
  int ret ;
  int page_count___0 ;
  int i ;
  struct page *page ;
  char *dst ;
  char *src ;
  long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  size_t __len ;
  void *__ret ;
  {
  mapping = (((obj->base.filp)->f_path.dentry)->d_inode)->i_mapping;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ret = 0;
  if (id > 3) {
    return (-22);
  } else {
  }
  if ((unsigned long )obj->phys_obj != (unsigned long )((struct drm_i915_gem_phys_object *)0)) {
    if ((obj->phys_obj)->id == id) {
      return (0);
    } else {
    }
    {
    i915_gem_detach_phys_object(dev, obj);
    }
  } else {
  }
  if ((unsigned long )dev_priv->mm.phys_objs[id + -1] == (unsigned long )((struct drm_i915_gem_phys_object *)0)) {
    {
    ret = i915_gem_init_phys_object(dev, id, (int )obj->base.size, align);
    }
    if (ret != 0) {
      {
      drm_err("i915_gem_attach_phys_object", "failed to init phys object %d size: %zu\n",
              id, obj->base.size);
      }
      return (ret);
    } else {
    }
  } else {
  }
  obj->phys_obj = dev_priv->mm.phys_objs[id + -1];
  (obj->phys_obj)->cur_obj = obj;
  page_count___0 = (int )(obj->base.size / 4096UL);
  i = 0;
  goto ldv_39914;
  ldv_39913:
  {
  page = shmem_read_mapping_page(mapping, (unsigned long )i);
  tmp___0 = IS_ERR((void const *)page);
  }
  if (tmp___0 != 0L) {
    {
    tmp = PTR_ERR((void const *)page);
    }
    return ((int )tmp);
  } else {
  }
  {
  tmp___1 = __kmap_atomic(page);
  src = (char *)tmp___1;
  dst = (char *)(((obj->phys_obj)->handle)->vaddr + (unsigned long )i * 4096UL);
  __len = 4096UL;
  }
  if (__len > 63UL) {
    {
    __ret = memcpy((void *)dst, (void const *)src, __len);
    }
  } else {
    {
    __ret = memcpy((void *)dst, (void const *)src, __len);
    }
  }
  {
  __kunmap_atomic((void *)src);
  mark_page_accessed(page);
  put_page(page);
  i = i + 1;
  }
  ldv_39914: ;
  if (i < page_count___0) {
    goto ldv_39913;
  } else {
    goto ldv_39915;
  }
  ldv_39915: ;
  return (0);
}
}
static int i915_gem_phys_pwrite(struct drm_device *dev , struct drm_i915_gem_object *obj ,
                                struct drm_i915_gem_pwrite *args , struct drm_file *file_priv )
{ void *vaddr ;
  char *user_data ;
  unsigned long unwritten ;
  int tmp ;
  {
  {
  vaddr = ((obj->phys_obj)->handle)->vaddr + args->offset;
  user_data = (char *)args->data_ptr;
  tmp = __copy_from_user_inatomic_nocache(vaddr, (void const *)user_data, (unsigned int )args->size);
  }
  if (tmp != 0) {
    {
    mutex_unlock(& dev->struct_mutex);
    unwritten = copy_from_user(vaddr, (void const *)user_data, (unsigned long )args->size);
    mutex_lock_nested(& dev->struct_mutex, 0U);
    }
    if (unwritten != 0UL) {
      return (-14);
    } else {
    }
  } else {
  }
  {
  intel_gtt_chipset_flush();
  }
  return (0);
}
}
void i915_gem_release(struct drm_device *dev , struct drm_file *file )
{ struct drm_i915_file_private *file_priv ;
  struct drm_i915_gem_request *request ;
  struct list_head const *__mptr ;
  int tmp ;
  {
  {
  file_priv = (struct drm_i915_file_private *)file->driver_priv;
  spin_lock(& file_priv->mm.lock);
  }
  goto ldv_39934;
  ldv_39933:
  {
  __mptr = (struct list_head const *)file_priv->mm.request_list.next;
  request = (struct drm_i915_gem_request *)__mptr + 0x0fffffffffffffd0UL;
  list_del(& request->client_list);
  request->file_priv = (struct drm_i915_file_private *)0;
  }
  ldv_39934:
  {
  tmp = list_empty((struct list_head const *)(& file_priv->mm.request_list));
  }
  if (tmp == 0) {
    goto ldv_39933;
  } else {
    goto ldv_39935;
  }
  ldv_39935:
  {
  spin_unlock(& file_priv->mm.lock);
  }
  return;
}
}
static int i915_gpu_is_active(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  int lists_empty ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = list_empty((struct list_head const *)(& dev_priv->mm.flushing_list));
  }
  if (tmp != 0) {
    {
    tmp___0 = list_empty((struct list_head const *)(& dev_priv->mm.active_list));
    }
    if (tmp___0 != 0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  lists_empty = tmp___1;
  return (lists_empty == 0);
}
}
static int i915_gem_inactive_shrink(struct shrinker *shrinker , struct shrink_control *sc )
{ struct drm_i915_private *dev_priv ;
  struct shrinker const *__mptr ;
  struct drm_device *dev ;
  struct drm_i915_gem_object *obj ;
  struct drm_i915_gem_object *next ;
  int nr_to_scan ;
  int cnt ;
  int tmp ;
  struct list_head const *__mptr___0 ;
  struct list_head const *__mptr___1 ;
  struct list_head const *__mptr___2 ;
  struct list_head const *__mptr___3 ;
  int tmp___0 ;
  int tmp___1 ;
  struct list_head const *__mptr___4 ;
  struct list_head const *__mptr___5 ;
  struct list_head const *__mptr___6 ;
  int tmp___2 ;
  struct list_head const *__mptr___7 ;
  int tmp___3 ;
  int tmp___4 ;
  {
  {
  __mptr = (struct shrinker const *)shrinker;
  dev_priv = (struct drm_i915_private *)__mptr + 0x0fffffffffffe668UL;
  dev = dev_priv->dev;
  nr_to_scan = (int )sc->nr_to_scan;
  tmp = mutex_trylock(& dev->struct_mutex);
  }
  if (tmp == 0) {
    return (0);
  } else {
  }
  if (nr_to_scan == 0) {
    cnt = 0;
    __mptr___0 = (struct list_head const *)dev_priv->mm.inactive_list.next;
    obj = (struct drm_i915_gem_object *)__mptr___0 + 0x0fffffffffffff50UL;
    goto ldv_39958;
    ldv_39957:
    cnt = cnt + 1;
    __mptr___1 = (struct list_head const *)obj->mm_list.next;
    obj = (struct drm_i915_gem_object *)__mptr___1 + 0x0fffffffffffff50UL;
    ldv_39958: ;
    if ((unsigned long )(& obj->mm_list) != (unsigned long )(& dev_priv->mm.inactive_list)) {
      goto ldv_39957;
    } else {
      goto ldv_39959;
    }
    ldv_39959:
    {
    mutex_unlock(& dev->struct_mutex);
    }
    return ((cnt / 100) * sysctl_vfs_cache_pressure);
  } else {
  }
  rescan:
  {
  i915_gem_retire_requests(dev);
  __mptr___2 = (struct list_head const *)dev_priv->mm.inactive_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___2 + 0x0fffffffffffff50UL;
  __mptr___3 = (struct list_head const *)obj->mm_list.next;
  next = (struct drm_i915_gem_object *)__mptr___3 + 0x0fffffffffffff50UL;
  }
  goto ldv_39969;
  ldv_39968:
  {
  tmp___1 = i915_gem_object_is_purgeable(obj);
  }
  if (tmp___1 != 0) {
    {
    tmp___0 = i915_gem_object_unbind(obj);
    }
    if (tmp___0 == 0) {
      nr_to_scan = nr_to_scan - 1;
      if (nr_to_scan == 0) {
        goto ldv_39967;
      } else {
      }
    } else {
    }
  } else {
  }
  obj = next;
  __mptr___4 = (struct list_head const *)next->mm_list.next;
  next = (struct drm_i915_gem_object *)__mptr___4 + 0x0fffffffffffff50UL;
  ldv_39969: ;
  if ((unsigned long )(& obj->mm_list) != (unsigned long )(& dev_priv->mm.inactive_list)) {
    goto ldv_39968;
  } else {
    goto ldv_39967;
  }
  ldv_39967:
  cnt = 0;
  __mptr___5 = (struct list_head const *)dev_priv->mm.inactive_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___5 + 0x0fffffffffffff50UL;
  __mptr___6 = (struct list_head const *)obj->mm_list.next;
  next = (struct drm_i915_gem_object *)__mptr___6 + 0x0fffffffffffff50UL;
  goto ldv_39977;
  ldv_39976: ;
  if (nr_to_scan != 0) {
    {
    tmp___2 = i915_gem_object_unbind(obj);
    }
    if (tmp___2 == 0) {
      nr_to_scan = nr_to_scan - 1;
    } else {
      cnt = cnt + 1;
    }
  } else {
    cnt = cnt + 1;
  }
  obj = next;
  __mptr___7 = (struct list_head const *)next->mm_list.next;
  next = (struct drm_i915_gem_object *)__mptr___7 + 0x0fffffffffffff50UL;
  ldv_39977: ;
  if ((unsigned long )(& obj->mm_list) != (unsigned long )(& dev_priv->mm.inactive_list)) {
    goto ldv_39976;
  } else {
    goto ldv_39978;
  }
  ldv_39978: ;
  if (nr_to_scan != 0) {
    {
    tmp___4 = i915_gpu_is_active(dev);
    }
    if (tmp___4 != 0) {
      {
      tmp___3 = i915_gpu_idle(dev);
      }
      if (tmp___3 == 0) {
        goto rescan;
      } else {
      }
    } else {
    }
  } else {
  }
  {
  mutex_unlock(& dev->struct_mutex);
  }
  return ((cnt / 100) * sysctl_vfs_cache_pressure);
}
}
extern void drm_mm_init_scan(struct drm_mm * , unsigned long , unsigned int ) ;
extern void drm_mm_init_scan_with_range(struct drm_mm * , unsigned long , unsigned int ,
                                        unsigned long , unsigned long ) ;
extern int drm_mm_scan_add_block(struct drm_mm_node * ) ;
extern int drm_mm_scan_remove_block(struct drm_mm_node * ) ;
struct tracepoint __tracepoint_i915_gem_evict ;
__inline static void trace_i915_gem_evict(struct drm_device *dev , u32 size , u32 align ,
                                          bool mappable )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_gem_evict.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_gem_evict.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )214);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_35781:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct drm_device * , u32 , u32 , bool ))it_func))(__data,
                                                                                  dev,
                                                                                  size,
                                                                                  align,
                                                                                  (bool )((int )mappable));
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_35781;
      } else {
        goto ldv_35782;
      }
      ldv_35782: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
struct tracepoint __tracepoint_i915_gem_evict_everything ;
__inline static void trace_i915_gem_evict_everything(struct drm_device *dev , bool purgeable )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_gem_evict_everything.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_gem_evict_everything.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )233);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_35823:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct drm_device * , bool ))it_func))(__data, dev, (bool )((int )purgeable));
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_35823;
      } else {
        goto ldv_35824;
      }
      ldv_35824: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
static bool mark_free(struct drm_i915_gem_object *obj , struct list_head *unwind )
{ int tmp ;
  {
  {
  list_add(& obj->exec_list, unwind);
  drm_gem_object_reference(& obj->base);
  tmp = drm_mm_scan_add_block(obj->gtt_space);
  }
  return ((bool )(tmp != 0));
}
}
int i915_gem_evict_something(struct drm_device *dev , int min_size , unsigned int alignment ,
                             bool mappable )
{ drm_i915_private_t *dev_priv ;
  struct list_head eviction_list ;
  struct list_head unwind_list ;
  struct drm_i915_gem_object *obj ;
  int ret ;
  struct drm_mm_node *tmp ;
  struct drm_mm_node *tmp___0 ;
  struct list_head const *__mptr ;
  bool tmp___1 ;
  struct list_head const *__mptr___0 ;
  struct list_head const *__mptr___1 ;
  bool tmp___2 ;
  struct list_head const *__mptr___2 ;
  struct list_head const *__mptr___3 ;
  bool tmp___3 ;
  struct list_head const *__mptr___4 ;
  struct list_head const *__mptr___5 ;
  bool tmp___4 ;
  struct list_head const *__mptr___6 ;
  struct list_head const *__mptr___7 ;
  long tmp___5 ;
  int tmp___6 ;
  struct list_head const *__mptr___8 ;
  int tmp___7 ;
  int tmp___8 ;
  struct list_head const *__mptr___9 ;
  int tmp___9 ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ret = 0;
  i915_gem_retire_requests(dev);
  }
  if ((int )mappable) {
    {
    tmp___0 = drm_mm_search_free_in_range((struct drm_mm const *)(& dev_priv->mm.gtt_space),
                                          (unsigned long )min_size, alignment, 0UL,
                                          dev_priv->mm.gtt_mappable_end, 0);
    }
    if ((unsigned long )tmp___0 != (unsigned long )((struct drm_mm_node *)0)) {
      return (0);
    } else {
      {
      tmp = drm_mm_search_free((struct drm_mm const *)(& dev_priv->mm.gtt_space),
                               (unsigned long )min_size, alignment, 0);
      }
      if ((unsigned long )tmp != (unsigned long )((struct drm_mm_node *)0)) {
        return (0);
      } else {
      }
    }
  } else {
  }
  {
  trace_i915_gem_evict(dev, (u32 )min_size, alignment, (bool )((int )mappable));
  INIT_LIST_HEAD(& unwind_list);
  }
  if ((int )mappable) {
    {
    drm_mm_init_scan_with_range(& dev_priv->mm.gtt_space, (unsigned long )min_size,
                                alignment, 0UL, dev_priv->mm.gtt_mappable_end);
    }
  } else {
    {
    drm_mm_init_scan(& dev_priv->mm.gtt_space, (unsigned long )min_size, alignment);
    }
  }
  __mptr = (struct list_head const *)dev_priv->mm.inactive_list.next;
  obj = (struct drm_i915_gem_object *)__mptr + 0x0fffffffffffff50UL;
  goto ldv_37077;
  ldv_37076:
  {
  tmp___1 = mark_free(obj, & unwind_list);
  }
  if ((int )tmp___1) {
    goto found;
  } else {
  }
  __mptr___0 = (struct list_head const *)obj->mm_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___0 + 0x0fffffffffffff50UL;
  ldv_37077: ;
  if ((unsigned long )(& obj->mm_list) != (unsigned long )(& dev_priv->mm.inactive_list)) {
    goto ldv_37076;
  } else {
    goto ldv_37078;
  }
  ldv_37078:
  __mptr___1 = (struct list_head const *)dev_priv->mm.active_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___1 + 0x0fffffffffffff50UL;
  goto ldv_37085;
  ldv_37084: ;
  if (obj->base.write_domain != 0U) {
    goto ldv_37083;
  } else
  if (*((unsigned int *)obj + 56UL) != 0U) {
    goto ldv_37083;
  } else {
  }
  {
  tmp___2 = mark_free(obj, & unwind_list);
  }
  if ((int )tmp___2) {
    goto found;
  } else {
  }
  ldv_37083:
  __mptr___2 = (struct list_head const *)obj->mm_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___2 + 0x0fffffffffffff50UL;
  ldv_37085: ;
  if ((unsigned long )(& obj->mm_list) != (unsigned long )(& dev_priv->mm.active_list)) {
    goto ldv_37084;
  } else {
    goto ldv_37086;
  }
  ldv_37086:
  __mptr___3 = (struct list_head const *)dev_priv->mm.flushing_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___3 + 0x0fffffffffffff50UL;
  goto ldv_37093;
  ldv_37092: ;
  if (*((unsigned int *)obj + 56UL) != 0U) {
    goto ldv_37091;
  } else {
  }
  {
  tmp___3 = mark_free(obj, & unwind_list);
  }
  if ((int )tmp___3) {
    goto found;
  } else {
  }
  ldv_37091:
  __mptr___4 = (struct list_head const *)obj->mm_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___4 + 0x0fffffffffffff50UL;
  ldv_37093: ;
  if ((unsigned long )(& obj->mm_list) != (unsigned long )(& dev_priv->mm.flushing_list)) {
    goto ldv_37092;
  } else {
    goto ldv_37094;
  }
  ldv_37094:
  __mptr___5 = (struct list_head const *)dev_priv->mm.active_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___5 + 0x0fffffffffffff50UL;
  goto ldv_37101;
  ldv_37100: ;
  if (obj->base.write_domain == 0U) {
    goto ldv_37099;
  } else
  if (*((unsigned int *)obj + 56UL) != 0U) {
    goto ldv_37099;
  } else {
  }
  {
  tmp___4 = mark_free(obj, & unwind_list);
  }
  if ((int )tmp___4) {
    goto found;
  } else {
  }
  ldv_37099:
  __mptr___6 = (struct list_head const *)obj->mm_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___6 + 0x0fffffffffffff50UL;
  ldv_37101: ;
  if ((unsigned long )(& obj->mm_list) != (unsigned long )(& dev_priv->mm.active_list)) {
    goto ldv_37100;
  } else {
    goto ldv_37102;
  }
  ldv_37102: ;
  goto ldv_37107;
  ldv_37106:
  {
  __mptr___7 = (struct list_head const *)unwind_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___7 + 0x0fffffffffffff30UL;
  ret = drm_mm_scan_remove_block(obj->gtt_space);
  tmp___5 = __builtin_expect((long )(ret != 0), 0L);
  }
  if (tmp___5 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem_evict.c.p"),
                         "i" (146), "i" (12UL));
    ldv_37105: ;
    goto ldv_37105;
  } else {
  }
  {
  list_del_init(& obj->exec_list);
  drm_gem_object_unreference(& obj->base);
  }
  ldv_37107:
  {
  tmp___6 = list_empty((struct list_head const *)(& unwind_list));
  }
  if (tmp___6 == 0) {
    goto ldv_37106;
  } else {
    goto ldv_37108;
  }
  ldv_37108: ;
  return (-28);
  found:
  {
  INIT_LIST_HEAD(& eviction_list);
  }
  goto ldv_37111;
  ldv_37112:
  {
  __mptr___8 = (struct list_head const *)unwind_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___8 + 0x0fffffffffffff30UL;
  tmp___7 = drm_mm_scan_remove_block(obj->gtt_space);
  }
  if (tmp___7 != 0) {
    {
    list_move(& obj->exec_list, & eviction_list);
    }
    goto ldv_37111;
  } else {
  }
  {
  list_del_init(& obj->exec_list);
  drm_gem_object_unreference(& obj->base);
  }
  ldv_37111:
  {
  tmp___8 = list_empty((struct list_head const *)(& unwind_list));
  }
  if (tmp___8 == 0) {
    goto ldv_37112;
  } else {
    goto ldv_37113;
  }
  ldv_37113: ;
  goto ldv_37117;
  ldv_37116:
  __mptr___9 = (struct list_head const *)eviction_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___9 + 0x0fffffffffffff30UL;
  if (ret == 0) {
    {
    ret = i915_gem_object_unbind(obj);
    }
  } else {
  }
  {
  list_del_init(& obj->exec_list);
  drm_gem_object_unreference(& obj->base);
  }
  ldv_37117:
  {
  tmp___9 = list_empty((struct list_head const *)(& eviction_list));
  }
  if (tmp___9 == 0) {
    goto ldv_37116;
  } else {
    goto ldv_37118;
  }
  ldv_37118: ;
  return (ret);
}
}
int i915_gem_evict_everything(struct drm_device *dev , bool purgeable_only )
{ drm_i915_private_t *dev_priv ;
  int ret ;
  bool lists_empty ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = list_empty((struct list_head const *)(& dev_priv->mm.inactive_list));
  }
  if (tmp != 0) {
    {
    tmp___0 = list_empty((struct list_head const *)(& dev_priv->mm.flushing_list));
    }
    if (tmp___0 != 0) {
      {
      tmp___1 = list_empty((struct list_head const *)(& dev_priv->mm.active_list));
      }
      if (tmp___1 != 0) {
        tmp___2 = 1;
      } else {
        tmp___2 = 0;
      }
    } else {
      tmp___2 = 0;
    }
  } else {
    tmp___2 = 0;
  }
  lists_empty = (bool )tmp___2;
  if ((int )lists_empty) {
    return (-28);
  } else {
  }
  {
  trace_i915_gem_evict_everything(dev, (bool )((int )purgeable_only));
  ret = i915_gpu_idle(dev);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  tmp___3 = list_empty((struct list_head const *)(& dev_priv->mm.flushing_list));
  tmp___4 = __builtin_expect((long )(tmp___3 == 0), 0L);
  }
  if (tmp___4 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem_evict.c.p"),
                         "i" (209), "i" (12UL));
    ldv_37126: ;
    goto ldv_37126;
  } else {
  }
  {
  tmp___5 = i915_gem_evict_inactive(dev, (bool )((int )purgeable_only));
  }
  return (tmp___5);
}
}
int i915_gem_evict_inactive(struct drm_device *dev , bool purgeable_only )
{ drm_i915_private_t *dev_priv ;
  struct drm_i915_gem_object *obj ;
  struct drm_i915_gem_object *next ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  int ret ;
  int tmp ;
  struct list_head const *__mptr___1 ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  __mptr = (struct list_head const *)dev_priv->mm.inactive_list.next;
  obj = (struct drm_i915_gem_object *)__mptr + 0x0fffffffffffff50UL;
  __mptr___0 = (struct list_head const *)obj->mm_list.next;
  next = (struct drm_i915_gem_object *)__mptr___0 + 0x0fffffffffffff50UL;
  goto ldv_37142;
  ldv_37141: ;
  if (! purgeable_only) {
    goto _L;
  } else
  if ((unsigned int )*((unsigned char *)obj + 225UL) != 0U) {
    _L:
    {
    tmp = i915_gem_object_unbind(obj);
    ret = tmp;
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
  } else {
  }
  obj = next;
  __mptr___1 = (struct list_head const *)next->mm_list.next;
  next = (struct drm_i915_gem_object *)__mptr___1 + 0x0fffffffffffff50UL;
  ldv_37142: ;
  if ((unsigned long )(& obj->mm_list) != (unsigned long )(& dev_priv->mm.inactive_list)) {
    goto ldv_37141;
  } else {
    goto ldv_37143;
  }
  ldv_37143: ;
  return (0);
}
}
__inline static void __list_splice(struct list_head const *list , struct list_head *prev ,
                                   struct list_head *next )
{ struct list_head *first ;
  struct list_head *last ;
  {
  first = (struct list_head *)list->next;
  last = (struct list_head *)list->prev;
  first->prev = prev;
  prev->next = first;
  last->next = next;
  next->prev = last;
  return;
}
}
__inline static void list_splice(struct list_head const *list , struct list_head *head )
{ int tmp ;
  {
  {
  tmp = list_empty(list);
  }
  if (tmp == 0) {
    {
    __list_splice(list, head, head->next);
    }
  } else {
  }
  return;
}
}
__inline static void hlist_add_head(struct hlist_node *n , struct hlist_head *h )
{ struct hlist_node *first ;
  {
  first = h->first;
  n->next = first;
  if ((unsigned long )first != (unsigned long )((struct hlist_node *)0)) {
    first->pprev = & n->next;
  } else {
  }
  h->first = n;
  n->pprev = & h->first;
  return;
}
}
__inline static u32 intel_ring_sync_index(struct intel_ring_buffer *ring , struct intel_ring_buffer *other )
{ int idx ;
  {
  idx = (int )((unsigned int )(((long )other - (long )ring) / 456L) + 4294967295U);
  if (idx < 0) {
    idx = idx + 3;
  } else {
  }
  return ((u32 )idx);
}
}
int intel_ring_sync(struct intel_ring_buffer *ring , struct intel_ring_buffer *to ,
                    u32 seqno ) ;
struct tracepoint __tracepoint_i915_gem_ring_dispatch ;
__inline static void trace_i915_gem_ring_dispatch(struct intel_ring_buffer *ring ,
                                                  u32 seqno )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_gem_ring_dispatch.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_gem_ring_dispatch.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )254);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_36141:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct intel_ring_buffer * , u32 ))it_func))(__data,
                                                                          ring, seqno);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_36141;
      } else {
        goto ldv_36142;
      }
      ldv_36142: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
void intel_mark_busy(struct drm_device *dev , struct drm_i915_gem_object *obj ) ;
static void i915_gem_object_set_to_gpu_domain(struct drm_i915_gem_object *obj , struct intel_ring_buffer *ring ,
                                              struct change_domains *cd )
{ uint32_t invalidate_domains ;
  uint32_t flush_domains ;
  int tmp ;
  {
  invalidate_domains = 0U;
  flush_domains = 0U;
  if (obj->base.pending_write_domain == 0U) {
    obj->base.pending_read_domains = obj->base.pending_read_domains | obj->base.read_domains;
  } else {
  }
  if (obj->base.write_domain != 0U) {
    if (obj->base.write_domain != obj->base.pending_read_domains) {
      flush_domains = obj->base.write_domain | flush_domains;
      invalidate_domains = (obj->base.pending_read_domains & ~ obj->base.write_domain) | invalidate_domains;
    } else
    if ((unsigned long )obj->ring != (unsigned long )ring) {
      flush_domains = obj->base.write_domain | flush_domains;
      invalidate_domains = (obj->base.pending_read_domains & ~ obj->base.write_domain) | invalidate_domains;
    } else
    if ((unsigned int )*((unsigned char *)obj + 226UL) != 0U) {
      if ((unsigned int )*((unsigned char *)obj + 226UL) == 0U) {
        flush_domains = obj->base.write_domain | flush_domains;
        invalidate_domains = (obj->base.pending_read_domains & ~ obj->base.write_domain) | invalidate_domains;
      } else {
      }
    } else {
    }
  } else {
  }
  invalidate_domains = (obj->base.pending_read_domains & ~ obj->base.read_domains) | invalidate_domains;
  if ((int )(flush_domains | invalidate_domains) & 1) {
    {
    i915_gem_clflush_object(obj);
    }
  } else {
  }
  if (obj->base.pending_write_domain != 0U) {
    {
    tmp = atomic_read((atomic_t const *)(& obj->pending_flip));
    cd->flips = cd->flips | (uint32_t )tmp;
    }
  } else {
  }
  if (flush_domains == 0U) {
    if (obj->base.pending_write_domain == 0U) {
      obj->base.pending_write_domain = obj->base.write_domain;
    } else {
    }
  } else {
  }
  cd->invalidate_domains = cd->invalidate_domains | invalidate_domains;
  cd->flush_domains = cd->flush_domains | flush_domains;
  if ((flush_domains & 4294967230U) != 0U) {
    cd->flush_rings = cd->flush_rings | (uint32_t )(obj->ring)->id;
  } else {
  }
  if ((invalidate_domains & 4294967230U) != 0U) {
    cd->flush_rings = cd->flush_rings | (uint32_t )ring->id;
  } else {
  }
  return;
}
}
static struct eb_objects *eb_create(int size )
{ struct eb_objects *eb ;
  int count ;
  void *tmp ;
  {
  count = 256;
  goto ldv_37569;
  ldv_37568:
  count = count >> 1;
  ldv_37569: ;
  if (count > size) {
    goto ldv_37568;
  } else {
    goto ldv_37570;
  }
  ldv_37570:
  {
  tmp = kzalloc(((unsigned long )count + 1UL) * 8UL, 208U);
  eb = (struct eb_objects *)tmp;
  }
  if ((unsigned long )eb == (unsigned long )((struct eb_objects *)0)) {
    return (eb);
  } else {
  }
  eb->and = count + -1;
  return (eb);
}
}
static void eb_reset(struct eb_objects *eb )
{
  {
  {
  memset((void *)(& eb->buckets), 0, (unsigned long )(eb->and + 1) * 8UL);
  }
  return;
}
}
static void eb_add_object(struct eb_objects *eb , struct drm_i915_gem_object *obj )
{
  {
  {
  hlist_add_head(& obj->exec_node, (struct hlist_head *)(& eb->buckets) + (obj->exec_handle & (unsigned long )eb->and));
  }
  return;
}
}
static struct drm_i915_gem_object *eb_get_object(struct eb_objects *eb , unsigned long handle )
{ struct hlist_head *head ;
  struct hlist_node *node ;
  struct drm_i915_gem_object *obj ;
  struct hlist_node const *__mptr ;
  {
  head = (struct hlist_head *)(& eb->buckets) + ((unsigned long )eb->and & handle);
  node = head->first;
  goto ldv_37588;
  ldv_37587:
  __mptr = (struct hlist_node const *)node;
  obj = (struct drm_i915_gem_object *)__mptr + 0x0fffffffffffff00UL;
  if (obj->exec_handle == handle) {
    return (obj);
  } else {
  }
  node = node->next;
  ldv_37588: ;
  if ((unsigned long )node != (unsigned long )((struct hlist_node *)0)) {
    goto ldv_37587;
  } else {
    goto ldv_37589;
  }
  ldv_37589: ;
  return ((struct drm_i915_gem_object *)0);
}
}
static void eb_destroy(struct eb_objects *eb )
{
  {
  {
  kfree((void const *)eb);
  }
  return;
}
}
static int i915_gem_execbuffer_relocate_entry(struct drm_i915_gem_object *obj , struct eb_objects *eb ,
                                              struct drm_i915_gem_relocation_entry *reloc )
{ struct drm_device *dev ;
  struct drm_gem_object *target_obj ;
  uint32_t target_offset ;
  int ret ;
  struct drm_i915_gem_object *tmp ;
  long tmp___0 ;
  struct drm_gem_object const *__mptr ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  uint32_t page_offset___0 ;
  char *vaddr ;
  void *tmp___10 ;
  struct drm_i915_private *dev_priv ;
  uint32_t *reloc_entry ;
  void *reloc_page ;
  struct thread_info *tmp___11 ;
  {
  {
  dev = obj->base.dev;
  ret = -22;
  tmp = eb_get_object(eb, (unsigned long )reloc->target_handle);
  target_obj = & tmp->base;
  tmp___0 = __builtin_expect((long )((unsigned long )target_obj == (unsigned long )((struct drm_gem_object *)0)),
                             0L);
  }
  if (tmp___0 != 0L) {
    return (-2);
  } else {
  }
  {
  __mptr = (struct drm_gem_object const *)target_obj;
  target_offset = ((struct drm_i915_gem_object *)__mptr)->gtt_offset;
  tmp___1 = __builtin_expect((long )(target_offset == 0U), 0L);
  }
  if (tmp___1 != 0L) {
    {
    drm_err("i915_gem_execbuffer_relocate_entry", "No GTT space found for object %d\n",
            reloc->target_handle);
    }
    return (ret);
  } else {
  }
  {
  tmp___2 = __builtin_expect((long )((reloc->write_domain & (reloc->write_domain - 1U)) != 0U),
                             0L);
  }
  if (tmp___2 != 0L) {
    {
    drm_err("i915_gem_execbuffer_relocate_entry", "reloc with multiple write domains: obj %p target %d offset %d read %08x write %08x",
            obj, reloc->target_handle, (int )reloc->offset, reloc->read_domains, reloc->write_domain);
    }
    return (ret);
  } else {
  }
  {
  tmp___3 = __builtin_expect((long )((int )(reloc->write_domain | reloc->read_domains)) & 1L,
                             0L);
  }
  if (tmp___3 != 0L) {
    {
    drm_err("i915_gem_execbuffer_relocate_entry", "reloc with read/write CPU domains: obj %p target %d offset %d read %08x write %08x",
            obj, reloc->target_handle, (int )reloc->offset, reloc->read_domains, reloc->write_domain);
    }
    return (ret);
  } else {
  }
  {
  tmp___4 = __builtin_expect((long )(reloc->write_domain != 0U), 0L);
  }
  if (tmp___4 != 0L) {
    {
    tmp___5 = __builtin_expect((long )(target_obj->pending_write_domain != 0U), 0L);
    }
    if (tmp___5 != 0L) {
      tmp___6 = 1;
    } else {
      tmp___6 = 0;
    }
  } else {
    tmp___6 = 0;
  }
  if (tmp___6 != 0) {
    {
    tmp___7 = __builtin_expect((long )(reloc->write_domain != target_obj->pending_write_domain),
                               0L);
    }
    if (tmp___7 != 0L) {
      {
      drm_err("i915_gem_execbuffer_relocate_entry", "Write domain conflict: obj %p target %d offset %d new %08x old %08x\n",
              obj, reloc->target_handle, (int )reloc->offset, reloc->write_domain,
              target_obj->pending_write_domain);
      }
      return (ret);
    } else {
    }
  } else {
  }
  target_obj->pending_read_domains = target_obj->pending_read_domains | reloc->read_domains;
  target_obj->pending_write_domain = target_obj->pending_write_domain | reloc->write_domain;
  if ((__u64 )target_offset == reloc->presumed_offset) {
    return (0);
  } else {
  }
  {
  tmp___8 = __builtin_expect((long )(reloc->offset > (unsigned long long )(obj->base.size - 4UL)),
                             0L);
  }
  if (tmp___8 != 0L) {
    {
    drm_err("i915_gem_execbuffer_relocate_entry", "Relocation beyond object bounds: obj %p target %d offset %d size %d.\n",
            obj, reloc->target_handle, (int )reloc->offset, (int )obj->base.size);
    }
    return (ret);
  } else {
  }
  {
  tmp___9 = __builtin_expect((long )((reloc->offset & 3ULL) != 0ULL), 0L);
  }
  if (tmp___9 != 0L) {
    {
    drm_err("i915_gem_execbuffer_relocate_entry", "Relocation not 4-byte aligned: obj %p target %d offset %d.\n",
            obj, reloc->target_handle, (int )reloc->offset);
    }
    return (ret);
  } else {
  }
  reloc->delta = reloc->delta + target_offset;
  if (obj->base.write_domain == 1U) {
    {
    page_offset___0 = (uint32_t )reloc->offset & 4095U;
    tmp___10 = __kmap_atomic(*(obj->pages + (reloc->offset >> 12)));
    vaddr = (char *)tmp___10;
    *((uint32_t *)vaddr + (unsigned long )page_offset___0) = reloc->delta;
    __kunmap_atomic((void *)vaddr);
    }
  } else {
    dev_priv = (struct drm_i915_private *)dev->dev_private;
    if ((unsigned int )*((unsigned char *)obj + 224UL) != 0U) {
      {
      tmp___11 = current_thread_info();
      }
      if ((tmp___11->preempt_count & -268435457) != 0) {
        return (-14);
      } else {
      }
    } else {
    }
    {
    ret = i915_gem_object_set_to_gtt_domain(obj, (bool )1);
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
    {
    reloc->offset = reloc->offset + (__u64 )obj->gtt_offset;
    reloc_page = io_mapping_map_atomic_wc(dev_priv->mm.gtt_mapping, (unsigned long )reloc->offset & 0x0ffffffffffff000UL);
    reloc_entry = (uint32_t *)(reloc_page + (reloc->offset & 4095ULL));
    iowrite32(reloc->delta, (void *)reloc_entry);
    io_mapping_unmap_atomic(reloc_page);
    }
  }
  reloc->presumed_offset = (__u64 )target_offset;
  return (0);
}
}
static int i915_gem_execbuffer_relocate_object(struct drm_i915_gem_object *obj , struct eb_objects *eb )
{ struct drm_i915_gem_relocation_entry *user_relocs ;
  struct drm_i915_gem_exec_object2 *entry ;
  int i ;
  int ret ;
  struct drm_i915_gem_relocation_entry reloc ;
  int tmp ;
  int tmp___0 ;
  {
  entry = obj->exec_entry;
  user_relocs = (struct drm_i915_gem_relocation_entry *)entry->relocs_ptr;
  i = 0;
  goto ldv_37620;
  ldv_37619:
  {
  tmp = __copy_from_user_inatomic((void *)(& reloc), (void const *)user_relocs + (unsigned long )i,
                                  32U);
  }
  if (tmp != 0) {
    return (-14);
  } else {
  }
  {
  ret = i915_gem_execbuffer_relocate_entry(obj, eb, & reloc);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  tmp___0 = __copy_from_user_inatomic((void *)(& (user_relocs + (unsigned long )i)->presumed_offset),
                                      (void const *)(& reloc.presumed_offset), 8U);
  }
  if (tmp___0 != 0) {
    return (-14);
  } else {
  }
  i = i + 1;
  ldv_37620: ;
  if ((__u32 )i < entry->relocation_count) {
    goto ldv_37619;
  } else {
    goto ldv_37621;
  }
  ldv_37621: ;
  return (0);
}
}
static int i915_gem_execbuffer_relocate_object_slow(struct drm_i915_gem_object *obj ,
                                                    struct eb_objects *eb , struct drm_i915_gem_relocation_entry *relocs )
{ struct drm_i915_gem_exec_object2 const *entry ;
  int i ;
  int ret ;
  {
  entry = (struct drm_i915_gem_exec_object2 const *)obj->exec_entry;
  i = 0;
  goto ldv_37631;
  ldv_37630:
  {
  ret = i915_gem_execbuffer_relocate_entry(obj, eb, relocs + (unsigned long )i);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  i = i + 1;
  ldv_37631: ;
  if ((unsigned int )i < (unsigned int )entry->relocation_count) {
    goto ldv_37630;
  } else {
    goto ldv_37632;
  }
  ldv_37632: ;
  return (0);
}
}
static int i915_gem_execbuffer_relocate(struct drm_device *dev , struct eb_objects *eb ,
                                        struct list_head *objects )
{ struct drm_i915_gem_object *obj ;
  int ret ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  {
  {
  ret = 0;
  pagefault_disable();
  __mptr = (struct list_head const *)objects->next;
  obj = (struct drm_i915_gem_object *)__mptr + 0x0fffffffffffff30UL;
  }
  goto ldv_37646;
  ldv_37645:
  {
  ret = i915_gem_execbuffer_relocate_object(obj, eb);
  }
  if (ret != 0) {
    goto ldv_37644;
  } else {
  }
  __mptr___0 = (struct list_head const *)obj->exec_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___0 + 0x0fffffffffffff30UL;
  ldv_37646: ;
  if ((unsigned long )(& obj->exec_list) != (unsigned long )objects) {
    goto ldv_37645;
  } else {
    goto ldv_37644;
  }
  ldv_37644:
  {
  pagefault_enable();
  }
  return (ret);
}
}
static int i915_gem_execbuffer_reserve(struct intel_ring_buffer *ring , struct drm_file *file ,
                                       struct list_head *objects )
{ struct drm_i915_gem_object *obj ;
  int ret ;
  int retry ;
  bool has_fenced_gpu_access ;
  struct list_head ordered_objects ;
  struct drm_i915_gem_exec_object2 *entry ;
  bool need_fence ;
  bool need_mappable ;
  struct list_head const *__mptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct list_head const *__mptr___0 ;
  struct drm_i915_gem_exec_object2 *entry___0 ;
  bool need_fence___0 ;
  bool need_mappable___0 ;
  int tmp___2 ;
  int tmp___3 ;
  struct list_head const *__mptr___1 ;
  struct list_head const *__mptr___2 ;
  struct drm_i915_gem_exec_object2 *entry___1 ;
  bool need_fence___1 ;
  int tmp___4 ;
  bool need_mappable___1 ;
  int tmp___5 ;
  struct list_head const *__mptr___3 ;
  struct list_head const *__mptr___4 ;
  struct list_head const *__mptr___5 ;
  struct list_head const *__mptr___6 ;
  struct list_head const *__mptr___7 ;
  {
  {
  has_fenced_gpu_access = (bool )((unsigned int )((unsigned char )(((struct drm_i915_private *)(ring->dev)->dev_private)->info)->gen) <= 3U);
  INIT_LIST_HEAD(& ordered_objects);
  }
  goto ldv_37663;
  ldv_37662:
  __mptr = (struct list_head const *)objects->next;
  obj = (struct drm_i915_gem_object *)__mptr + 0x0fffffffffffff30UL;
  entry = obj->exec_entry;
  if ((int )has_fenced_gpu_access) {
    if ((int )entry->flags & 1) {
      if ((unsigned int )*((unsigned char *)obj + 225UL) != 0U) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  need_fence = (bool )tmp;
  if (entry->relocation_count != 0U) {
    tmp___0 = 1;
  } else
  if ((int )need_fence != 0) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  need_mappable = (bool )tmp___0;
  if ((int )need_mappable) {
    {
    list_move(& obj->exec_list, & ordered_objects);
    }
  } else {
    {
    list_move_tail(& obj->exec_list, & ordered_objects);
    }
  }
  obj->base.pending_read_domains = 0U;
  obj->base.pending_write_domain = 0U;
  ldv_37663:
  {
  tmp___1 = list_empty((struct list_head const *)objects);
  }
  if (tmp___1 == 0) {
    goto ldv_37662;
  } else {
    goto ldv_37664;
  }
  ldv_37664:
  {
  list_splice((struct list_head const *)(& ordered_objects), objects);
  retry = 0;
  }
  ldv_37694:
  ret = 0;
  __mptr___0 = (struct list_head const *)objects->next;
  obj = (struct drm_i915_gem_object *)__mptr___0 + 0x0fffffffffffff30UL;
  goto ldv_37675;
  ldv_37674:
  entry___0 = obj->exec_entry;
  if ((unsigned long )obj->gtt_space == (unsigned long )((struct drm_mm_node *)0)) {
    goto ldv_37672;
  } else {
  }
  if ((int )has_fenced_gpu_access) {
    if ((int )entry___0->flags & 1) {
      if ((unsigned int )*((unsigned char *)obj + 225UL) != 0U) {
        tmp___2 = 1;
      } else {
        tmp___2 = 0;
      }
    } else {
      tmp___2 = 0;
    }
  } else {
    tmp___2 = 0;
  }
  need_fence___0 = (bool )tmp___2;
  if (entry___0->relocation_count != 0U) {
    tmp___3 = 1;
  } else
  if ((int )need_fence___0 != 0) {
    tmp___3 = 1;
  } else {
    tmp___3 = 0;
  }
  need_mappable___0 = (bool )tmp___3;
  if (entry___0->alignment != 0ULL) {
    if (((__u64 )obj->gtt_offset & (entry___0->alignment - 1ULL)) != 0ULL) {
      {
      ret = i915_gem_object_unbind(obj);
      }
    } else {
      goto _L;
    }
  } else
  _L:
  if ((int )need_mappable___0) {
    if ((unsigned int )*((unsigned char *)obj + 226UL) == 0U) {
      {
      ret = i915_gem_object_unbind(obj);
      }
    } else {
      {
      ret = i915_gem_object_pin(obj, (uint32_t )entry___0->alignment, (bool )((int )need_mappable___0));
      }
    }
  } else {
    {
    ret = i915_gem_object_pin(obj, (uint32_t )entry___0->alignment, (bool )((int )need_mappable___0));
    }
  }
  if (ret != 0) {
    goto err;
  } else {
  }
  entry___0 = entry___0 + 1;
  ldv_37672:
  __mptr___1 = (struct list_head const *)obj->exec_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___1 + 0x0fffffffffffff30UL;
  ldv_37675: ;
  if ((unsigned long )(& obj->exec_list) != (unsigned long )objects) {
    goto ldv_37674;
  } else {
    goto ldv_37676;
  }
  ldv_37676:
  __mptr___2 = (struct list_head const *)objects->next;
  obj = (struct drm_i915_gem_object *)__mptr___2 + 0x0fffffffffffff30UL;
  goto ldv_37686;
  ldv_37685:
  entry___1 = obj->exec_entry;
  if ((int )has_fenced_gpu_access) {
    if ((int )entry___1->flags & 1) {
      if ((unsigned int )*((unsigned char *)obj + 225UL) != 0U) {
        tmp___4 = 1;
      } else {
        tmp___4 = 0;
      }
    } else {
      tmp___4 = 0;
    }
  } else {
    tmp___4 = 0;
  }
  need_fence___1 = (bool )tmp___4;
  if ((unsigned long )obj->gtt_space == (unsigned long )((struct drm_mm_node *)0)) {
    if (entry___1->relocation_count != 0U) {
      tmp___5 = 1;
    } else
    if ((int )need_fence___1 != 0) {
      tmp___5 = 1;
    } else {
      tmp___5 = 0;
    }
    {
    need_mappable___1 = (bool )tmp___5;
    ret = i915_gem_object_pin(obj, (uint32_t )entry___1->alignment, (bool )((int )need_mappable___1));
    }
    if (ret != 0) {
      goto ldv_37684;
    } else {
    }
  } else {
  }
  if ((int )has_fenced_gpu_access) {
    if ((int )need_fence___1) {
      {
      ret = i915_gem_object_get_fence(obj, ring);
      }
      if (ret != 0) {
        goto ldv_37684;
      } else {
      }
    } else
    if ((int )entry___1->flags & 1) {
      if ((unsigned int )*((unsigned char *)obj + 225UL) == 0U) {
        {
        ret = i915_gem_object_put_fence(obj);
        }
        if (ret != 0) {
          goto ldv_37684;
        } else {
        }
      } else {
      }
    } else {
    }
    obj->pending_fenced_gpu_access = (unsigned char )need_fence___1;
  } else {
  }
  entry___1->offset = (__u64 )obj->gtt_offset;
  __mptr___3 = (struct list_head const *)obj->exec_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___3 + 0x0fffffffffffff30UL;
  ldv_37686: ;
  if ((unsigned long )(& obj->exec_list) != (unsigned long )objects) {
    goto ldv_37685;
  } else {
    goto ldv_37684;
  }
  ldv_37684:
  __mptr___4 = (struct list_head const *)objects->next;
  obj = (struct drm_i915_gem_object *)__mptr___4 + 0x0fffffffffffff30UL;
  goto ldv_37692;
  ldv_37691: ;
  if ((unsigned long )obj->gtt_space != (unsigned long )((struct drm_mm_node *)0)) {
    {
    i915_gem_object_unpin(obj);
    }
  } else {
  }
  __mptr___5 = (struct list_head const *)obj->exec_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___5 + 0x0fffffffffffff30UL;
  ldv_37692: ;
  if ((unsigned long )(& obj->exec_list) != (unsigned long )objects) {
    goto ldv_37691;
  } else {
    goto ldv_37693;
  }
  ldv_37693: ;
  if (ret != -28) {
    return (ret);
  } else
  if (retry > 1) {
    return (ret);
  } else {
  }
  {
  ret = i915_gem_evict_everything(ring->dev, (bool )(retry == 0));
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  retry = retry + 1;
  goto ldv_37694;
  err:
  __mptr___6 = (struct list_head const *)obj->exec_list.prev;
  obj = (struct drm_i915_gem_object *)__mptr___6 + 0x0fffffffffffff30UL;
  goto ldv_37700;
  ldv_37699: ;
  if ((unsigned long )obj->gtt_space != (unsigned long )((struct drm_mm_node *)0)) {
    {
    i915_gem_object_unpin(obj);
    }
  } else {
  }
  __mptr___7 = (struct list_head const *)obj->exec_list.prev;
  obj = (struct drm_i915_gem_object *)__mptr___7 + 0x0fffffffffffff30UL;
  ldv_37700: ;
  if ((unsigned long )(& obj->exec_list) != (unsigned long )objects) {
    goto ldv_37699;
  } else {
    goto ldv_37701;
  }
  ldv_37701: ;
  return (ret);
}
}
static int i915_gem_execbuffer_relocate_slow(struct drm_device *dev , struct drm_file *file ,
                                             struct intel_ring_buffer *ring , struct list_head *objects ,
                                             struct eb_objects *eb , struct drm_i915_gem_exec_object2 *exec ,
                                             int count )
{ struct drm_i915_gem_relocation_entry *reloc ;
  struct drm_i915_gem_object *obj ;
  int *reloc_offset ;
  int i ;
  int total ;
  int ret ;
  struct list_head const *__mptr ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  struct drm_i915_gem_relocation_entry *user_relocs ;
  unsigned long tmp___2 ;
  struct drm_gem_object const *__mptr___0 ;
  struct drm_gem_object *tmp___3 ;
  struct list_head const *__mptr___1 ;
  int offset ;
  struct list_head const *__mptr___2 ;
  {
  goto ldv_37720;
  ldv_37719:
  {
  __mptr = (struct list_head const *)objects->next;
  obj = (struct drm_i915_gem_object *)__mptr + 0x0fffffffffffff30UL;
  list_del_init(& obj->exec_list);
  drm_gem_object_unreference(& obj->base);
  }
  ldv_37720:
  {
  tmp = list_empty((struct list_head const *)objects);
  }
  if (tmp == 0) {
    goto ldv_37719;
  } else {
    goto ldv_37721;
  }
  ldv_37721:
  {
  mutex_unlock(& dev->struct_mutex);
  total = 0;
  i = 0;
  }
  goto ldv_37723;
  ldv_37722:
  total = (int )((exec + (unsigned long )i)->relocation_count + (__u32 )total);
  i = i + 1;
  ldv_37723: ;
  if (i < count) {
    goto ldv_37722;
  } else {
    goto ldv_37724;
  }
  ldv_37724:
  {
  tmp___0 = drm_malloc_ab((size_t )count, 4UL);
  reloc_offset = (int *)tmp___0;
  tmp___1 = drm_malloc_ab((size_t )total, 32UL);
  reloc = (struct drm_i915_gem_relocation_entry *)tmp___1;
  }
  if ((unsigned long )reloc == (unsigned long )((struct drm_i915_gem_relocation_entry *)0)) {
    {
    drm_free_large((void *)reloc);
    drm_free_large((void *)reloc_offset);
    mutex_lock_nested(& dev->struct_mutex, 0U);
    }
    return (-12);
  } else
  if ((unsigned long )reloc_offset == (unsigned long )((int *)0)) {
    {
    drm_free_large((void *)reloc);
    drm_free_large((void *)reloc_offset);
    mutex_lock_nested(& dev->struct_mutex, 0U);
    }
    return (-12);
  } else {
  }
  total = 0;
  i = 0;
  goto ldv_37728;
  ldv_37727:
  {
  user_relocs = (struct drm_i915_gem_relocation_entry *)(exec + (unsigned long )i)->relocs_ptr;
  tmp___2 = copy_from_user((void *)reloc + (unsigned long )total, (void const *)user_relocs,
                           (unsigned long )(exec + (unsigned long )i)->relocation_count * 32UL);
  }
  if (tmp___2 != 0UL) {
    {
    ret = -14;
    mutex_lock_nested(& dev->struct_mutex, 0U);
    }
    goto err;
  } else {
  }
  *(reloc_offset + (unsigned long )i) = total;
  total = (int )((exec + (unsigned long )i)->relocation_count + (__u32 )total);
  i = i + 1;
  ldv_37728: ;
  if (i < count) {
    goto ldv_37727;
  } else {
    goto ldv_37729;
  }
  ldv_37729:
  {
  ret = i915_mutex_lock_interruptible(dev);
  }
  if (ret != 0) {
    {
    mutex_lock_nested(& dev->struct_mutex, 0U);
    }
    goto err;
  } else {
  }
  {
  eb_reset(eb);
  i = 0;
  }
  goto ldv_37734;
  ldv_37733:
  {
  tmp___3 = drm_gem_object_lookup(dev, file, (exec + (unsigned long )i)->handle);
  __mptr___0 = (struct drm_gem_object const *)tmp___3;
  obj = (struct drm_i915_gem_object *)__mptr___0;
  }
  if ((unsigned long )(& obj->base) == (unsigned long )((struct drm_gem_object *)0)) {
    {
    drm_err("i915_gem_execbuffer_relocate_slow", "Invalid object handle %d at index %d\n",
            (exec + (unsigned long )i)->handle, i);
    ret = -2;
    }
    goto err;
  } else {
  }
  {
  list_add_tail(& obj->exec_list, objects);
  obj->exec_handle = (unsigned long )(exec + (unsigned long )i)->handle;
  obj->exec_entry = exec + (unsigned long )i;
  eb_add_object(eb, obj);
  i = i + 1;
  }
  ldv_37734: ;
  if (i < count) {
    goto ldv_37733;
  } else {
    goto ldv_37735;
  }
  ldv_37735:
  {
  ret = i915_gem_execbuffer_reserve(ring, file, objects);
  }
  if (ret != 0) {
    goto err;
  } else {
  }
  __mptr___1 = (struct list_head const *)objects->next;
  obj = (struct drm_i915_gem_object *)__mptr___1 + 0x0fffffffffffff30UL;
  goto ldv_37742;
  ldv_37741:
  {
  offset = (int )(((long )obj->exec_entry - (long )exec) / 56L);
  ret = i915_gem_execbuffer_relocate_object_slow(obj, eb, reloc + (unsigned long )*(reloc_offset + (unsigned long )offset));
  }
  if (ret != 0) {
    goto err;
  } else {
  }
  __mptr___2 = (struct list_head const *)obj->exec_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___2 + 0x0fffffffffffff30UL;
  ldv_37742: ;
  if ((unsigned long )(& obj->exec_list) != (unsigned long )objects) {
    goto ldv_37741;
  } else {
    goto ldv_37743;
  }
  ldv_37743: ;
  err:
  {
  drm_free_large((void *)reloc);
  drm_free_large((void *)reloc_offset);
  }
  return (ret);
}
}
static int i915_gem_execbuffer_flush(struct drm_device *dev , uint32_t invalidate_domains ,
                                     uint32_t flush_domains , uint32_t flush_rings )
{ drm_i915_private_t *dev_priv ;
  int i ;
  int ret ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  if ((int )flush_domains & 1) {
    {
    intel_gtt_chipset_flush();
    }
  } else {
  }
  if ((flush_domains & 64U) != 0U) {
    __asm__ volatile ("sfence": : : "memory");
  } else {
  }
  if (((flush_domains | invalidate_domains) & 4294967230U) != 0U) {
    i = 0;
    goto ldv_37754;
    ldv_37753: ;
    if (((uint32_t )(1 << i) & flush_rings) != 0U) {
      {
      ret = i915_gem_flush_ring((struct intel_ring_buffer *)(& dev_priv->ring) + (unsigned long )i,
                                invalidate_domains, flush_domains);
      }
      if (ret != 0) {
        return (ret);
      } else {
      }
    } else {
    }
    i = i + 1;
    ldv_37754: ;
    if (i <= 2) {
      goto ldv_37753;
    } else {
      goto ldv_37755;
    }
    ldv_37755: ;
  } else {
  }
  return (0);
}
}
static int i915_gem_execbuffer_sync_rings(struct drm_i915_gem_object *obj , struct intel_ring_buffer *to )
{ struct intel_ring_buffer *from ;
  u32 seqno ;
  int ret ;
  int idx ;
  int tmp ;
  u32 tmp___0 ;
  struct drm_i915_gem_request *request ;
  void *tmp___1 ;
  int tmp___2 ;
  {
  from = obj->ring;
  if ((unsigned long )from == (unsigned long )((struct intel_ring_buffer *)0)) {
    return (0);
  } else
  if ((unsigned long )to == (unsigned long )from) {
    return (0);
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)(obj->base.dev)->dev_private)->info)->gen) <= 5U) {
    {
    tmp = i915_gem_object_wait_rendering(obj);
    }
    return (tmp);
  } else
  if (i915_semaphores == 0U) {
    {
    tmp = i915_gem_object_wait_rendering(obj);
    }
    return (tmp);
  } else {
  }
  {
  tmp___0 = intel_ring_sync_index(from, to);
  idx = (int )tmp___0;
  seqno = obj->last_rendering_seqno;
  }
  if (from->sync_seqno[idx] >= seqno) {
    return (0);
  } else {
  }
  if (from->outstanding_lazy_request == seqno) {
    {
    tmp___1 = kzalloc(64UL, 208U);
    request = (struct drm_i915_gem_request *)tmp___1;
    }
    if ((unsigned long )request == (unsigned long )((struct drm_i915_gem_request *)0)) {
      return (-12);
    } else {
    }
    {
    ret = i915_add_request(from, (struct drm_file *)0, request);
    }
    if (ret != 0) {
      {
      kfree((void const *)request);
      }
      return (ret);
    } else {
    }
    seqno = request->seqno;
  } else {
  }
  {
  from->sync_seqno[idx] = seqno;
  tmp___2 = intel_ring_sync(to, from, seqno - 1U);
  }
  return (tmp___2);
}
}
static int i915_gem_execbuffer_wait_for_flips(struct intel_ring_buffer *ring , u32 flips )
{ u32 plane ;
  u32 flip_mask ;
  int ret ;
  {
  plane = 0U;
  goto ldv_37774;
  ldv_37773: ;
  if (((flips >> (int )plane) & 1U) == 0U) {
    goto ldv_37772;
  } else {
  }
  if (plane != 0U) {
    flip_mask = 64U;
  } else {
    flip_mask = 4U;
  }
  {
  ret = intel_ring_begin(ring, 2);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  intel_ring_emit(ring, flip_mask | 25165824U);
  intel_ring_emit(ring, 0U);
  intel_ring_advance(ring);
  }
  ldv_37772:
  plane = plane + 1U;
  ldv_37774: ;
  if (flips >> (int )plane != 0U) {
    goto ldv_37773;
  } else {
    goto ldv_37775;
  }
  ldv_37775: ;
  return (0);
}
}
static int i915_gem_execbuffer_move_to_gpu(struct intel_ring_buffer *ring , struct list_head *objects )
{ struct drm_i915_gem_object *obj ;
  struct change_domains cd ;
  int ret ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  struct list_head const *__mptr___1 ;
  struct list_head const *__mptr___2 ;
  {
  {
  memset((void *)(& cd), 0, 16UL);
  __mptr = (struct list_head const *)objects->next;
  obj = (struct drm_i915_gem_object *)__mptr + 0x0fffffffffffff30UL;
  }
  goto ldv_37788;
  ldv_37787:
  {
  i915_gem_object_set_to_gpu_domain(obj, ring, & cd);
  __mptr___0 = (struct list_head const *)obj->exec_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___0 + 0x0fffffffffffff30UL;
  }
  ldv_37788: ;
  if ((unsigned long )(& obj->exec_list) != (unsigned long )objects) {
    goto ldv_37787;
  } else {
    goto ldv_37789;
  }
  ldv_37789: ;
  if ((cd.invalidate_domains | cd.flush_domains) != 0U) {
    {
    ret = i915_gem_execbuffer_flush(ring->dev, cd.invalidate_domains, cd.flush_domains,
                                    cd.flush_rings);
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
  } else {
  }
  if (cd.flips != 0U) {
    {
    ret = i915_gem_execbuffer_wait_for_flips(ring, cd.flips);
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
  } else {
  }
  __mptr___1 = (struct list_head const *)objects->next;
  obj = (struct drm_i915_gem_object *)__mptr___1 + 0x0fffffffffffff30UL;
  goto ldv_37795;
  ldv_37794:
  {
  ret = i915_gem_execbuffer_sync_rings(obj, ring);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  __mptr___2 = (struct list_head const *)obj->exec_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___2 + 0x0fffffffffffff30UL;
  ldv_37795: ;
  if ((unsigned long )(& obj->exec_list) != (unsigned long )objects) {
    goto ldv_37794;
  } else {
    goto ldv_37796;
  }
  ldv_37796: ;
  return (0);
}
}
static bool i915_gem_check_execbuffer(struct drm_i915_gem_execbuffer2 *exec )
{
  {
  return ((bool )(((exec->batch_start_offset | exec->batch_len) & 7U) == 0U));
}
}
static int validate_exec_list(struct drm_i915_gem_exec_object2 *exec , int count )
{ int i ;
  char *ptr ;
  int length ;
  unsigned long flag ;
  unsigned long roksum ;
  struct thread_info *tmp ;
  long tmp___0 ;
  unsigned long flag___0 ;
  unsigned long roksum___0 ;
  struct thread_info *tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  {
  i = 0;
  goto ldv_37814;
  ldv_37813:
  ptr = (char *)(exec + (unsigned long )i)->relocs_ptr;
  if ((exec + (unsigned long )i)->relocation_count > 67108863U) {
    return (-22);
  } else {
  }
  {
  length = (int )((exec + (unsigned long )i)->relocation_count * 32U);
  tmp = current_thread_info();
  __asm__ ("add %3,%1 ; sbb %0,%0 ; cmp %1,%4 ; sbb $0,%0": "=&r" (flag), "=r" (roksum): "1" (ptr),
            "g" ((long )length), "rm" (tmp->addr_limit.seg));
  tmp___0 = __builtin_expect((long )(flag == 0UL), 1L);
  }
  if (tmp___0 == 0L) {
    return (-14);
  } else {
  }
  {
  tmp___1 = current_thread_info();
  __asm__ ("add %3,%1 ; sbb %0,%0 ; cmp %1,%4 ; sbb $0,%0": "=&r" (flag___0), "=r" (roksum___0): "1" (ptr),
            "g" ((long )length), "rm" (tmp___1->addr_limit.seg));
  tmp___2 = __builtin_expect((long )(flag___0 == 0UL), 1L);
  }
  if (tmp___2 == 0L) {
    return (-14);
  } else {
  }
  {
  tmp___3 = fault_in_pages_readable((char const *)ptr, length);
  }
  if (tmp___3 != 0) {
    return (-14);
  } else {
  }
  i = i + 1;
  ldv_37814: ;
  if (i < count) {
    goto ldv_37813;
  } else {
    goto ldv_37815;
  }
  ldv_37815: ;
  return (0);
}
}
static void i915_gem_execbuffer_move_to_active(struct list_head *objects , struct intel_ring_buffer *ring ,
                                               u32 seqno )
{ struct drm_i915_gem_object *obj ;
  struct list_head const *__mptr ;
  u32 old_read ;
  u32 old_write ;
  struct list_head const *__mptr___0 ;
  {
  __mptr = (struct list_head const *)objects->next;
  obj = (struct drm_i915_gem_object *)__mptr + 0x0fffffffffffff30UL;
  goto ldv_37829;
  ldv_37828:
  {
  old_read = obj->base.read_domains;
  old_write = obj->base.write_domain;
  obj->base.read_domains = obj->base.pending_read_domains;
  obj->base.write_domain = obj->base.pending_write_domain;
  obj->fenced_gpu_access = obj->pending_fenced_gpu_access;
  i915_gem_object_move_to_active(obj, ring, seqno);
  }
  if (obj->base.write_domain != 0U) {
    {
    obj->dirty = (unsigned char)1;
    obj->pending_gpu_write = (unsigned char)1;
    list_move_tail(& obj->gpu_write_list, & ring->gpu_write_list);
    intel_mark_busy(ring->dev, obj);
    }
  } else {
  }
  {
  trace_i915_gem_object_change_domain(obj, old_read, old_write);
  __mptr___0 = (struct list_head const *)obj->exec_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___0 + 0x0fffffffffffff30UL;
  }
  ldv_37829: ;
  if ((unsigned long )(& obj->exec_list) != (unsigned long )objects) {
    goto ldv_37828;
  } else {
    goto ldv_37830;
  }
  ldv_37830: ;
  return;
}
}
static void i915_gem_execbuffer_retire_commands(struct drm_device *dev , struct drm_file *file ,
                                                struct intel_ring_buffer *ring )
{ struct drm_i915_gem_request *request ;
  u32 invalidate ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  {
  invalidate = 8U;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    invalidate = invalidate | 4U;
  } else {
  }
  {
  tmp = (*(ring->flush))(ring, invalidate, 0U);
  }
  if (tmp != 0) {
    {
    i915_gem_next_request_seqno(ring);
    }
    return;
  } else {
  }
  {
  tmp___0 = kzalloc(64UL, 208U);
  request = (struct drm_i915_gem_request *)tmp___0;
  }
  if ((unsigned long )request == (unsigned long )((struct drm_i915_gem_request *)0)) {
    {
    i915_gem_next_request_seqno(ring);
    kfree((void const *)request);
    }
  } else {
    {
    tmp___1 = i915_add_request(ring, file, request);
    }
    if (tmp___1 != 0) {
      {
      i915_gem_next_request_seqno(ring);
      kfree((void const *)request);
      }
    } else {
    }
  }
  return;
}
}
static int i915_gem_do_execbuffer(struct drm_device *dev , void *data , struct drm_file *file ,
                                  struct drm_i915_gem_execbuffer2 *args , struct drm_i915_gem_exec_object2 *exec )
{ drm_i915_private_t *dev_priv ;
  struct list_head objects ;
  struct eb_objects *eb ;
  struct drm_i915_gem_object *batch_obj ;
  struct drm_clip_rect *cliprects ;
  struct intel_ring_buffer *ring ;
  u32 exec_start ;
  u32 exec_len ;
  u32 seqno ;
  int ret ;
  int mode ;
  int i ;
  bool tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  unsigned long tmp___2 ;
  struct drm_i915_gem_object *obj ;
  struct drm_gem_object const *__mptr ;
  struct drm_gem_object *tmp___3 ;
  int tmp___4 ;
  struct list_head const *__mptr___0 ;
  int tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  struct drm_i915_gem_object *obj___0 ;
  struct list_head const *__mptr___1 ;
  int tmp___8 ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  cliprects = (struct drm_clip_rect *)0;
  tmp = i915_gem_check_execbuffer(args);
  }
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    {
    drm_err("i915_gem_do_execbuffer", "execbuf with invalid offset/length\n");
    }
    return (-22);
  } else {
  }
  {
  ret = validate_exec_list(exec, (int )args->buffer_count);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  if ((int )(args->flags & 7ULL) == 0) {
    goto case_0;
  } else
  if ((int )(args->flags & 7ULL) == 1) {
    goto case_1;
  } else
  if ((int )(args->flags & 7ULL) == 2) {
    goto case_2;
  } else
  if ((int )(args->flags & 7ULL) == 3) {
    goto case_3;
  } else {
    goto switch_default;
    if (0) {
      case_0: ;
      case_1:
      ring = (struct intel_ring_buffer *)(& dev_priv->ring);
      goto ldv_37860;
      case_2: ;
      if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 3UL) == 0U) {
        {
        drm_err("i915_gem_do_execbuffer", "execbuf with invalid ring (BSD)\n");
        }
        return (-22);
      } else {
      }
      ring = (struct intel_ring_buffer *)(& dev_priv->ring) + 1UL;
      goto ldv_37860;
      case_3: ;
      if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 3UL) == 0U) {
        {
        drm_err("i915_gem_do_execbuffer", "execbuf with invalid ring (BLT)\n");
        }
        return (-22);
      } else {
      }
      ring = (struct intel_ring_buffer *)(& dev_priv->ring) + 2UL;
      goto ldv_37860;
      switch_default:
      {
      drm_err("i915_gem_do_execbuffer", "execbuf with unknown ring: %d\n", (int )args->flags & 7);
      }
      return (-22);
    } else {
    }
  }
  ldv_37860:
  mode = (int )args->flags & 192;
  if (mode == 0) {
    goto case_0___0;
  } else
  if (mode == 64) {
    goto case_64;
  } else
  if (mode == 128) {
    goto case_128;
  } else {
    goto switch_default___0;
    if (0) {
      case_0___0: ;
      case_64: ;
      case_128: ;
      if ((unsigned long )((struct intel_ring_buffer *)(& dev_priv->ring)) == (unsigned long )ring) {
        if (dev_priv->relative_constants_mode != mode) {
          if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) <= 3U) {
            return (-22);
          } else {
          }
          if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 5U) {
            if (mode == 128) {
              return (-22);
            } else {
            }
          } else {
          }
          {
          ret = intel_ring_begin(ring, 4);
          }
          if (ret != 0) {
            return (ret);
          } else {
          }
          {
          intel_ring_emit(ring, 0U);
          intel_ring_emit(ring, 285212673U);
          intel_ring_emit(ring, 8384U);
          intel_ring_emit(ring, (u32 )(mode | 12582912));
          intel_ring_advance(ring);
          dev_priv->relative_constants_mode = mode;
          }
        } else {
        }
      } else {
      }
      goto ldv_37867;
      switch_default___0:
      {
      drm_err("i915_gem_do_execbuffer", "execbuf with unknown constants: %d\n", mode);
      }
      return (-22);
    } else {
    }
  }
  ldv_37867: ;
  if (args->buffer_count == 0U) {
    {
    drm_err("i915_gem_do_execbuffer", "execbuf with %d buffers\n", args->buffer_count);
    }
    return (-22);
  } else {
  }
  if (args->num_cliprects != 0U) {
    if ((unsigned long )((struct intel_ring_buffer *)(& dev_priv->ring)) != (unsigned long )ring) {
      {
      drm_err("i915_gem_do_execbuffer", "clip rectangles are only valid with the render ring\n");
      }
      return (-22);
    } else {
    }
    {
    tmp___1 = kmalloc((unsigned long )args->num_cliprects * 8UL, 208U);
    cliprects = (struct drm_clip_rect *)tmp___1;
    }
    if ((unsigned long )cliprects == (unsigned long )((struct drm_clip_rect *)0)) {
      ret = -12;
      goto pre_mutex_err;
    } else {
    }
    {
    tmp___2 = copy_from_user((void *)cliprects, (void const *)args->cliprects_ptr,
                             (unsigned long )args->num_cliprects * 8UL);
    }
    if (tmp___2 != 0UL) {
      ret = -14;
      goto pre_mutex_err;
    } else {
    }
  } else {
  }
  {
  ret = i915_mutex_lock_interruptible(dev);
  }
  if (ret != 0) {
    goto pre_mutex_err;
  } else {
  }
  if (dev_priv->mm.suspended != 0) {
    {
    mutex_unlock(& dev->struct_mutex);
    ret = -16;
    }
    goto pre_mutex_err;
  } else {
  }
  {
  eb = eb_create((int )args->buffer_count);
  }
  if ((unsigned long )eb == (unsigned long )((struct eb_objects *)0)) {
    {
    mutex_unlock(& dev->struct_mutex);
    ret = -12;
    }
    goto pre_mutex_err;
  } else {
  }
  {
  INIT_LIST_HEAD(& objects);
  i = 0;
  }
  goto ldv_37875;
  ldv_37874:
  {
  tmp___3 = drm_gem_object_lookup(dev, file, (exec + (unsigned long )i)->handle);
  __mptr = (struct drm_gem_object const *)tmp___3;
  obj = (struct drm_i915_gem_object *)__mptr;
  }
  if ((unsigned long )(& obj->base) == (unsigned long )((struct drm_gem_object *)0)) {
    {
    drm_err("i915_gem_do_execbuffer", "Invalid object handle %d at index %d\n", (exec + (unsigned long )i)->handle,
            i);
    ret = -2;
    }
    goto err;
  } else {
  }
  {
  tmp___4 = list_empty((struct list_head const *)(& obj->exec_list));
  }
  if (tmp___4 == 0) {
    {
    drm_err("i915_gem_do_execbuffer", "Object %p [handle %d, index %d] appears more than once in object list\n",
            obj, (exec + (unsigned long )i)->handle, i);
    ret = -22;
    }
    goto err;
  } else {
  }
  {
  list_add_tail(& obj->exec_list, & objects);
  obj->exec_handle = (unsigned long )(exec + (unsigned long )i)->handle;
  obj->exec_entry = exec + (unsigned long )i;
  eb_add_object(eb, obj);
  i = i + 1;
  }
  ldv_37875: ;
  if ((__u32 )i < args->buffer_count) {
    goto ldv_37874;
  } else {
    goto ldv_37876;
  }
  ldv_37876:
  {
  __mptr___0 = (struct list_head const *)objects.prev;
  batch_obj = (struct drm_i915_gem_object *)__mptr___0 + 0x0fffffffffffff30UL;
  ret = i915_gem_execbuffer_reserve(ring, file, & objects);
  }
  if (ret != 0) {
    goto err;
  } else {
  }
  {
  ret = i915_gem_execbuffer_relocate(dev, eb, & objects);
  }
  if (ret != 0) {
    if (ret == -14) {
      {
      ret = i915_gem_execbuffer_relocate_slow(dev, file, ring, & objects, eb, exec,
                                              (int )args->buffer_count);
      tmp___5 = mutex_is_locked(& dev->struct_mutex);
      tmp___6 = __builtin_expect((long )(tmp___5 == 0), 0L);
      }
      if (tmp___6 != 0L) {
        __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem_execbuffer.c.p"),
                             "i" (1135), "i" (12UL));
        ldv_37879: ;
        goto ldv_37879;
      } else {
      }
    } else {
    }
    if (ret != 0) {
      goto err;
    } else {
    }
  } else {
  }
  if (batch_obj->base.pending_write_domain != 0U) {
    {
    drm_err("i915_gem_do_execbuffer", "Attempting to use self-modifying batch buffer\n");
    ret = -22;
    }
    goto err;
  } else {
  }
  {
  batch_obj->base.pending_read_domains = batch_obj->base.pending_read_domains | 8U;
  ret = i915_gem_execbuffer_move_to_gpu(ring, & objects);
  }
  if (ret != 0) {
    goto err;
  } else {
  }
  {
  seqno = i915_gem_next_request_seqno(ring);
  i = 0;
  }
  goto ldv_37884;
  ldv_37883: ;
  if (ring->sync_seqno[i] > seqno) {
    {
    ret = i915_gpu_idle(dev);
    }
    if (ret != 0) {
      goto err;
    } else {
    }
    {
    tmp___7 = __builtin_expect((long )(ring->sync_seqno[i] != 0U), 0L);
    }
    if (tmp___7 != 0L) {
      __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem_execbuffer.c.p"),
                           "i" (1164), "i" (12UL));
      ldv_37882: ;
      goto ldv_37882;
    } else {
    }
  } else {
  }
  i = i + 1;
  ldv_37884: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_37883;
  } else {
    goto ldv_37885;
  }
  ldv_37885:
  {
  trace_i915_gem_ring_dispatch(ring, seqno);
  exec_start = batch_obj->gtt_offset + args->batch_start_offset;
  exec_len = args->batch_len;
  }
  if ((unsigned long )cliprects != (unsigned long )((struct drm_clip_rect *)0)) {
    i = 0;
    goto ldv_37887;
    ldv_37886:
    {
    ret = i915_emit_box(dev, cliprects + (unsigned long )i, (int )args->DR1, (int )args->DR4);
    }
    if (ret != 0) {
      goto err;
    } else {
    }
    {
    ret = (*(ring->dispatch_execbuffer))(ring, exec_start, exec_len);
    }
    if (ret != 0) {
      goto err;
    } else {
    }
    i = i + 1;
    ldv_37887: ;
    if ((__u32 )i < args->num_cliprects) {
      goto ldv_37886;
    } else {
      goto ldv_37888;
    }
    ldv_37888: ;
  } else {
    {
    ret = (*(ring->dispatch_execbuffer))(ring, exec_start, exec_len);
    }
    if (ret != 0) {
      goto err;
    } else {
    }
  }
  {
  i915_gem_execbuffer_move_to_active(& objects, ring, seqno);
  i915_gem_execbuffer_retire_commands(dev, file, ring);
  }
  err:
  {
  eb_destroy(eb);
  }
  goto ldv_37893;
  ldv_37892:
  {
  __mptr___1 = (struct list_head const *)objects.next;
  obj___0 = (struct drm_i915_gem_object *)__mptr___1 + 0x0fffffffffffff30UL;
  list_del_init(& obj___0->exec_list);
  drm_gem_object_unreference(& obj___0->base);
  }
  ldv_37893:
  {
  tmp___8 = list_empty((struct list_head const *)(& objects));
  }
  if (tmp___8 == 0) {
    goto ldv_37892;
  } else {
    goto ldv_37894;
  }
  ldv_37894:
  {
  mutex_unlock(& dev->struct_mutex);
  }
  pre_mutex_err:
  {
  kfree((void const *)cliprects);
  }
  return (ret);
}
}
int i915_gem_execbuffer(struct drm_device *dev , void *data , struct drm_file *file )
{ struct drm_i915_gem_execbuffer *args ;
  struct drm_i915_gem_execbuffer2 exec2 ;
  struct drm_i915_gem_exec_object *exec_list ;
  struct drm_i915_gem_exec_object2 *exec2_list ;
  int ret ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  {
  args = (struct drm_i915_gem_execbuffer *)data;
  exec_list = (struct drm_i915_gem_exec_object *)0;
  exec2_list = (struct drm_i915_gem_exec_object2 *)0;
  if (args->buffer_count == 0U) {
    {
    drm_err("i915_gem_execbuffer", "execbuf with %d buffers\n", args->buffer_count);
    }
    return (-22);
  } else {
  }
  {
  tmp = drm_malloc_ab(32UL, (size_t )args->buffer_count);
  exec_list = (struct drm_i915_gem_exec_object *)tmp;
  tmp___0 = drm_malloc_ab(56UL, (size_t )args->buffer_count);
  exec2_list = (struct drm_i915_gem_exec_object2 *)tmp___0;
  }
  if ((unsigned long )exec_list == (unsigned long )((struct drm_i915_gem_exec_object *)0)) {
    {
    drm_err("i915_gem_execbuffer", "Failed to allocate exec list for %d buffers\n",
            args->buffer_count);
    drm_free_large((void *)exec_list);
    drm_free_large((void *)exec2_list);
    }
    return (-12);
  } else
  if ((unsigned long )exec2_list == (unsigned long )((struct drm_i915_gem_exec_object2 *)0)) {
    {
    drm_err("i915_gem_execbuffer", "Failed to allocate exec list for %d buffers\n",
            args->buffer_count);
    drm_free_large((void *)exec_list);
    drm_free_large((void *)exec2_list);
    }
    return (-12);
  } else {
  }
  {
  tmp___1 = copy_from_user((void *)exec_list, (void const *)args->buffers_ptr, (unsigned long )args->buffer_count * 32UL);
  ret = (int )tmp___1;
  }
  if (ret != 0) {
    {
    drm_err("i915_gem_execbuffer", "copy %d exec entries failed %d\n", args->buffer_count,
            ret);
    drm_free_large((void *)exec_list);
    drm_free_large((void *)exec2_list);
    }
    return (-14);
  } else {
  }
  i = 0;
  goto ldv_37909;
  ldv_37908:
  (exec2_list + (unsigned long )i)->handle = (exec_list + (unsigned long )i)->handle;
  (exec2_list + (unsigned long )i)->relocation_count = (exec_list + (unsigned long )i)->relocation_count;
  (exec2_list + (unsigned long )i)->relocs_ptr = (exec_list + (unsigned long )i)->relocs_ptr;
  (exec2_list + (unsigned long )i)->alignment = (exec_list + (unsigned long )i)->alignment;
  (exec2_list + (unsigned long )i)->offset = (exec_list + (unsigned long )i)->offset;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) <= 3U) {
    (exec2_list + (unsigned long )i)->flags = 1ULL;
  } else {
    (exec2_list + (unsigned long )i)->flags = 0ULL;
  }
  i = i + 1;
  ldv_37909: ;
  if ((__u32 )i < args->buffer_count) {
    goto ldv_37908;
  } else {
    goto ldv_37910;
  }
  ldv_37910:
  {
  exec2.buffers_ptr = args->buffers_ptr;
  exec2.buffer_count = args->buffer_count;
  exec2.batch_start_offset = args->batch_start_offset;
  exec2.batch_len = args->batch_len;
  exec2.DR1 = args->DR1;
  exec2.DR4 = args->DR4;
  exec2.num_cliprects = args->num_cliprects;
  exec2.cliprects_ptr = args->cliprects_ptr;
  exec2.flags = 1ULL;
  ret = i915_gem_do_execbuffer(dev, data, file, & exec2, exec2_list);
  }
  if (ret == 0) {
    i = 0;
    goto ldv_37912;
    ldv_37911:
    (exec_list + (unsigned long )i)->offset = (exec2_list + (unsigned long )i)->offset;
    i = i + 1;
    ldv_37912: ;
    if ((__u32 )i < args->buffer_count) {
      goto ldv_37911;
    } else {
      goto ldv_37913;
    }
    ldv_37913:
    {
    ret = copy_to_user((void *)args->buffers_ptr, (void const *)exec_list, args->buffer_count * 32U);
    }
    if (ret != 0) {
      {
      ret = -14;
      drm_err("i915_gem_execbuffer", "failed to copy %d exec entries back to user (%d)\n",
              args->buffer_count, ret);
      }
    } else {
    }
  } else {
  }
  {
  drm_free_large((void *)exec_list);
  drm_free_large((void *)exec2_list);
  }
  return (ret);
}
}
int i915_gem_execbuffer2(struct drm_device *dev , void *data , struct drm_file *file )
{ struct drm_i915_gem_execbuffer2 *args ;
  struct drm_i915_gem_exec_object2 *exec2_list ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  {
  args = (struct drm_i915_gem_execbuffer2 *)data;
  exec2_list = (struct drm_i915_gem_exec_object2 *)0;
  if (args->buffer_count == 0U) {
    {
    drm_err("i915_gem_execbuffer2", "execbuf2 with %d buffers\n", args->buffer_count);
    }
    return (-22);
  } else {
  }
  {
  tmp = kmalloc((unsigned long )args->buffer_count * 56UL, 4816U);
  exec2_list = (struct drm_i915_gem_exec_object2 *)tmp;
  }
  if ((unsigned long )exec2_list == (unsigned long )((struct drm_i915_gem_exec_object2 *)0)) {
    {
    tmp___0 = drm_malloc_ab(56UL, (size_t )args->buffer_count);
    exec2_list = (struct drm_i915_gem_exec_object2 *)tmp___0;
    }
  } else {
  }
  if ((unsigned long )exec2_list == (unsigned long )((struct drm_i915_gem_exec_object2 *)0)) {
    {
    drm_err("i915_gem_execbuffer2", "Failed to allocate exec list for %d buffers\n",
            args->buffer_count);
    }
    return (-12);
  } else {
  }
  {
  tmp___1 = copy_from_user((void *)exec2_list, (void const *)args->buffers_ptr,
                           (unsigned long )args->buffer_count * 56UL);
  ret = (int )tmp___1;
  }
  if (ret != 0) {
    {
    drm_err("i915_gem_execbuffer2", "copy %d exec entries failed %d\n", args->buffer_count,
            ret);
    drm_free_large((void *)exec2_list);
    }
    return (-14);
  } else {
  }
  {
  ret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);
  }
  if (ret == 0) {
    {
    ret = copy_to_user((void *)args->buffers_ptr, (void const *)exec2_list, args->buffer_count * 56U);
    }
    if (ret != 0) {
      {
      ret = -14;
      drm_err("i915_gem_execbuffer2", "failed to copy %d exec entries back to user (%d)\n",
              args->buffer_count, ret);
      }
    } else {
    }
  } else {
  }
  {
  drm_free_large((void *)exec2_list);
  }
  return (ret);
}
}
extern void intel_gtt_unmap_memory(struct scatterlist * , int ) ;
extern int intel_gtt_map_memory(struct page ** , unsigned int , struct scatterlist ** ,
                                int * ) ;
extern void intel_gtt_insert_sg_entries(struct scatterlist * , unsigned int , unsigned int ,
                                        unsigned int ) ;
extern void intel_gtt_insert_pages(unsigned int , unsigned int , struct page ** ,
                                   unsigned int ) ;
static unsigned int cache_level_to_agp_type(struct drm_device *dev , enum i915_cache_level cache_level )
{
  {
  if ((int )((unsigned int )cache_level) == 2) {
    goto case_2;
  } else
  if ((int )((unsigned int )cache_level) == 1) {
    goto case_1;
  } else
  if ((int )((unsigned int )cache_level) == 0) {
    goto case_0;
  } else {
    goto switch_default;
    if (0) {
      case_2: ;
      if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 5U) {
        return (65538U);
      } else {
      }
      case_1: ;
      return (65537U);
      switch_default: ;
      case_0: ;
      return (65536U);
    } else {
    }
  }
}
}
void i915_gem_restore_gtt_mappings(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct drm_i915_gem_object *obj ;
  struct list_head const *__mptr ;
  unsigned int agp_type ;
  unsigned int tmp ;
  long tmp___0 ;
  struct list_head const *__mptr___0 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  intel_gtt_clear_range((unsigned int )(dev_priv->mm.gtt_start / 4096UL), (unsigned int )((dev_priv->mm.gtt_end - dev_priv->mm.gtt_start) / 4096UL));
  __mptr = (struct list_head const *)dev_priv->mm.gtt_list.next;
  obj = (struct drm_i915_gem_object *)__mptr + 0x0fffffffffffff70UL;
  }
  goto ldv_37568;
  ldv_37567:
  {
  tmp = cache_level_to_agp_type(dev, (enum i915_cache_level )obj->cache_level);
  agp_type = tmp;
  i915_gem_clflush_object(obj);
  }
  if ((unsigned int )*((unsigned char *)dev_priv->mm.gtt + 12UL) != 0U) {
    {
    tmp___0 = __builtin_expect((long )((unsigned long )obj->sg_list == (unsigned long )((struct scatterlist *)0)),
                               0L);
    }
    if (tmp___0 != 0L) {
      __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/i915_gem_gtt.c.p"),
                           "i" (75), "i" (12UL));
      ldv_37566: ;
      goto ldv_37566;
    } else {
    }
    {
    intel_gtt_insert_sg_entries(obj->sg_list, (unsigned int )obj->num_sg, (unsigned int )((obj->gtt_space)->start >> 12),
                                agp_type);
    }
  } else {
    {
    intel_gtt_insert_pages((unsigned int )((obj->gtt_space)->start >> 12), (unsigned int )(obj->base.size >> 12),
                           obj->pages, agp_type);
    }
  }
  __mptr___0 = (struct list_head const *)obj->gtt_list.next;
  obj = (struct drm_i915_gem_object *)__mptr___0 + 0x0fffffffffffff70UL;
  ldv_37568: ;
  if ((unsigned long )(& obj->gtt_list) != (unsigned long )(& dev_priv->mm.gtt_list)) {
    goto ldv_37567;
  } else {
    goto ldv_37569;
  }
  ldv_37569:
  {
  intel_gtt_chipset_flush();
  }
  return;
}
}
int i915_gem_gtt_bind_object(struct drm_i915_gem_object *obj )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  unsigned int agp_type ;
  unsigned int tmp ;
  int ret ;
  {
  {
  dev = obj->base.dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = cache_level_to_agp_type(dev, (enum i915_cache_level )obj->cache_level);
  agp_type = tmp;
  }
  if ((unsigned int )*((unsigned char *)dev_priv->mm.gtt + 12UL) != 0U) {
    {
    ret = intel_gtt_map_memory(obj->pages, (unsigned int )(obj->base.size >> 12),
                               & obj->sg_list, & obj->num_sg);
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
    {
    intel_gtt_insert_sg_entries(obj->sg_list, (unsigned int )obj->num_sg, (unsigned int )((obj->gtt_space)->start >> 12),
                                agp_type);
    }
  } else {
    {
    intel_gtt_insert_pages((unsigned int )((obj->gtt_space)->start >> 12), (unsigned int )(obj->base.size >> 12),
                           obj->pages, agp_type);
    }
  }
  return (0);
}
}
void i915_gem_gtt_unbind_object(struct drm_i915_gem_object *obj )
{
  {
  {
  intel_gtt_clear_range((unsigned int )((obj->gtt_space)->start >> 12), (unsigned int )(obj->base.size >> 12));
  }
  if ((unsigned long )obj->sg_list != (unsigned long )((struct scatterlist *)0)) {
    {
    intel_gtt_unmap_memory(obj->sg_list, obj->num_sg);
    obj->sg_list = (struct scatterlist *)0;
    }
  } else {
  }
  return;
}
}
__inline static void __set_bit(int nr , unsigned long volatile *addr )
{
  {
  __asm__ volatile ("bts %1,%0": "+m" (*((long volatile *)addr)): "Ir" (nr): "memory");
  return;
}
}
__inline static void __clear_bit(int nr , unsigned long volatile *addr )
{
  {
  __asm__ volatile ("btr %1,%0": "+m" (*((long volatile *)addr)): "Ir" (nr));
  return;
}
}
__inline static u16 i915_read16___1(struct drm_i915_private *dev_priv , u32 reg )
{ u16 val ;
  {
  val = (u16 )0U;
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        gen6_gt_force_wake_get(dev_priv);
        val = readw((void const volatile *)dev_priv->regs + (unsigned long )reg);
        gen6_gt_force_wake_put(dev_priv);
        }
      } else {
        {
        val = readw((void const volatile *)dev_priv->regs + (unsigned long )reg);
        }
      }
    } else {
      {
      val = readw((void const volatile *)dev_priv->regs + (unsigned long )reg);
      }
    }
  } else {
    {
    val = readw((void const volatile *)dev_priv->regs + (unsigned long )reg);
    }
  }
  {
  trace_i915_reg_rw((bool )0, reg, (u64 )val, 2);
  }
  return (val);
}
}
void i915_gem_detect_bit_6_swizzle(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  uint32_t swizzle_x ;
  uint32_t swizzle_y ;
  uint32_t dcc ;
  u16 tmp ;
  u16 tmp___0 ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  swizzle_x = 5U;
  swizzle_y = 5U;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 4U) {
    swizzle_x = 2U;
    swizzle_y = 1U;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 2U) {
    swizzle_x = 0U;
    swizzle_y = 0U;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    {
    dcc = i915_read32(dev_priv, 66048U);
    }
    if ((int )(dcc & 3U) == 0) {
      goto case_0;
    } else
    if ((int )(dcc & 3U) == 1) {
      goto case_1;
    } else
    if ((int )(dcc & 3U) == 2) {
      goto case_2;
    } else
    if (0) {
      case_0: ;
      case_1:
      swizzle_x = 0U;
      swizzle_y = 0U;
      goto ldv_37065;
      case_2: ;
      if ((dcc & 1024U) != 0U) {
        swizzle_x = 2U;
        swizzle_y = 1U;
      } else
      if ((dcc & 512U) == 0U) {
        swizzle_x = 4U;
        swizzle_y = 3U;
      } else {
        swizzle_x = 7U;
        swizzle_y = 6U;
      }
      goto ldv_37065;
    } else {
    }
    ldv_37065: ;
    if (dcc == 4294967295U) {
      {
      drm_err("i915_gem_detect_bit_6_swizzle", "Couldn\'t read from MCHBAR.  Disabling tiling.\n");
      swizzle_x = 5U;
      swizzle_y = 5U;
      }
    } else {
    }
  } else {
    {
    tmp = i915_read16___1(dev_priv, 66054U);
    tmp___0 = i915_read16___1(dev_priv, 67078U);
    }
    if ((int )tmp != (int )tmp___0) {
      swizzle_x = 0U;
      swizzle_y = 0U;
    } else {
      swizzle_x = 2U;
      swizzle_y = 1U;
    }
  }
  dev_priv->mm.bit_6_swizzle_x = swizzle_x;
  dev_priv->mm.bit_6_swizzle_y = swizzle_y;
  return;
}
}
static bool i915_tiling_ok(struct drm_device *dev , int stride , int size , int tiling_mode )
{ int tile_width ;
  {
  if (tiling_mode == 0) {
    return ((bool )1);
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 2U) {
    tile_width = 128;
  } else
  if (tiling_mode == 2) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 2U) {
      if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) == 0U) {
        if (dev->pci_device != 9618) {
          tile_width = 128;
        } else {
          tile_width = 512;
        }
      } else {
        tile_width = 512;
      }
    } else {
      tile_width = 512;
    }
  } else {
    tile_width = 512;
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    if (stride > 131199) {
      return ((bool )0);
    } else {
      if (stride > 8192) {
        return ((bool )0);
      } else {
      }
      if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 3U) {
        if (size > 268435456) {
          return ((bool )0);
        } else
        if (size > 134217728) {
          return ((bool )0);
        } else {
        }
      } else {
      }
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    if (((tile_width + -1) & stride) != 0) {
      return ((bool )0);
    } else {
    }
    return ((bool )1);
  } else {
  }
  if (stride < tile_width) {
    return ((bool )0);
  } else {
  }
  if (((stride + -1) & stride) != 0) {
    return ((bool )0);
  } else {
  }
  return ((bool )1);
}
}
static bool i915_gem_object_fence_ok(struct drm_i915_gem_object *obj , int tiling_mode )
{ u32 size ;
  {
  if (tiling_mode == 0) {
    return ((bool )1);
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)(obj->base.dev)->dev_private)->info)->gen) > 3U) {
    return ((bool )1);
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)(obj->base.dev)->dev_private)->info)->gen) == 3U) {
    if ((obj->gtt_offset & 4027580415U) != 0U) {
      return ((bool )0);
    } else
    if ((obj->gtt_offset & 4161273855U) != 0U) {
      return ((bool )0);
    } else {
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)(obj->base.dev)->dev_private)->info)->gen) == 3U) {
    size = 1048576U;
  } else {
    size = 524288U;
  }
  goto ldv_37081;
  ldv_37080:
  size = size << 1;
  ldv_37081: ;
  if ((size_t )size < obj->base.size) {
    goto ldv_37080;
  } else {
    goto ldv_37082;
  }
  ldv_37082: ;
  if ((obj->gtt_space)->size != (unsigned long )size) {
    return ((bool )0);
  } else {
  }
  if ((obj->gtt_offset & (size - 1U)) != 0U) {
    return ((bool )0);
  } else {
  }
  return ((bool )1);
}
}
int i915_gem_set_tiling(struct drm_device *dev , void *data , struct drm_file *file )
{ struct drm_i915_gem_set_tiling *args ;
  drm_i915_private_t *dev_priv ;
  struct drm_i915_gem_object *obj ;
  int ret ;
  struct drm_gem_object const *__mptr ;
  struct drm_gem_object *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  u32 unfenced_alignment ;
  uint32_t tmp___4 ;
  {
  {
  args = (struct drm_i915_gem_set_tiling *)data;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ret = 0;
  tmp = drm_gem_object_lookup(dev, file, args->handle);
  __mptr = (struct drm_gem_object const *)tmp;
  obj = (struct drm_i915_gem_object *)__mptr;
  }
  if ((unsigned long )(& obj->base) == (unsigned long )((struct drm_gem_object *)0)) {
    return (-2);
  } else {
  }
  {
  tmp___0 = i915_tiling_ok(dev, (int )args->stride, (int )obj->base.size, (int )args->tiling_mode);
  }
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    {
    drm_gem_object_unreference_unlocked(& obj->base);
    }
    return (-22);
  } else {
  }
  if (*((unsigned int *)obj + 56UL) != 0U) {
    {
    drm_gem_object_unreference_unlocked(& obj->base);
    }
    return (-16);
  } else {
  }
  if (args->tiling_mode == 0U) {
    args->swizzle_mode = 0U;
    args->stride = 0U;
  } else {
    if (args->tiling_mode == 1U) {
      args->swizzle_mode = dev_priv->mm.bit_6_swizzle_x;
    } else {
      args->swizzle_mode = dev_priv->mm.bit_6_swizzle_y;
    }
    if (args->swizzle_mode == 6U) {
      args->swizzle_mode = 1U;
    } else {
    }
    if (args->swizzle_mode == 7U) {
      args->swizzle_mode = 2U;
    } else {
    }
    if (args->swizzle_mode == 5U) {
      args->tiling_mode = 0U;
      args->swizzle_mode = 0U;
      args->stride = 0U;
    } else {
    }
  }
  {
  mutex_lock_nested(& dev->struct_mutex, 0U);
  }
  if (args->tiling_mode != (__u32 )obj->tiling_mode) {
    goto _L;
  } else
  if (args->stride != obj->stride) {
    _L:
    {
    i915_gem_release_mmap(obj);
    }
    if ((unsigned long )obj->gtt_space == (unsigned long )((struct drm_mm_node *)0)) {
      tmp___3 = 1;
    } else
    if ((size_t )obj->gtt_offset + obj->base.size <= dev_priv->mm.gtt_mappable_end) {
      {
      tmp___2 = i915_gem_object_fence_ok(obj, (int )args->tiling_mode);
      }
      if ((int )tmp___2) {
        tmp___3 = 1;
      } else {
        tmp___3 = 0;
      }
    } else {
      tmp___3 = 0;
    }
    obj->map_and_fenceable = (unsigned char )tmp___3;
    if ((unsigned int )*((unsigned char *)obj + 226UL) == 0U) {
      {
      tmp___4 = i915_gem_get_unfenced_gtt_alignment(dev, (uint32_t )obj->base.size,
                                                    (int )args->tiling_mode);
      unfenced_alignment = tmp___4;
      }
      if ((obj->gtt_offset & (unfenced_alignment - 1U)) != 0U) {
        {
        ret = i915_gem_object_unbind(obj);
        }
      } else {
      }
    } else {
    }
    if (ret == 0) {
      obj->tiling_changed = (unsigned char)1;
      obj->tiling_mode = (unsigned char )args->tiling_mode;
      obj->stride = args->stride;
    } else {
    }
  } else {
  }
  {
  args->stride = obj->stride;
  args->tiling_mode = (__u32 )obj->tiling_mode;
  drm_gem_object_unreference(& obj->base);
  mutex_unlock(& dev->struct_mutex);
  }
  return (ret);
}
}
int i915_gem_get_tiling(struct drm_device *dev , void *data , struct drm_file *file )
{ struct drm_i915_gem_get_tiling *args ;
  drm_i915_private_t *dev_priv ;
  struct drm_i915_gem_object *obj ;
  struct drm_gem_object const *__mptr ;
  struct drm_gem_object *tmp ;
  {
  {
  args = (struct drm_i915_gem_get_tiling *)data;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = drm_gem_object_lookup(dev, file, args->handle);
  __mptr = (struct drm_gem_object const *)tmp;
  obj = (struct drm_i915_gem_object *)__mptr;
  }
  if ((unsigned long )(& obj->base) == (unsigned long )((struct drm_gem_object *)0)) {
    return (-2);
  } else {
  }
  {
  mutex_lock_nested(& dev->struct_mutex, 0U);
  args->tiling_mode = (__u32 )obj->tiling_mode;
  }
  if ((int )obj->tiling_mode == 1) {
    goto case_1;
  } else
  if ((int )obj->tiling_mode == 2) {
    goto case_2;
  } else
  if ((int )obj->tiling_mode == 0) {
    goto case_0;
  } else {
    goto switch_default;
    if (0) {
      case_1:
      args->swizzle_mode = dev_priv->mm.bit_6_swizzle_x;
      goto ldv_37106;
      case_2:
      args->swizzle_mode = dev_priv->mm.bit_6_swizzle_y;
      goto ldv_37106;
      case_0:
      args->swizzle_mode = 0U;
      goto ldv_37106;
      switch_default:
      {
      drm_err("i915_gem_get_tiling", "unknown tiling mode\n");
      }
    } else {
    }
  }
  ldv_37106: ;
  if (args->swizzle_mode == 6U) {
    args->swizzle_mode = 1U;
  } else {
  }
  if (args->swizzle_mode == 7U) {
    args->swizzle_mode = 2U;
  } else {
  }
  {
  drm_gem_object_unreference(& obj->base);
  mutex_unlock(& dev->struct_mutex);
  }
  return (0);
}
}
static void i915_gem_swizzle_page(struct page *page )
{ char temp[64U] ;
  char *vaddr ;
  int i ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  {
  {
  tmp = kmap(page);
  vaddr = (char *)tmp;
  i = 0;
  }
  goto ldv_37127;
  ldv_37126:
  __len = 64UL;
  if (__len > 63UL) {
    {
    __ret = memcpy((void *)(& temp), (void const *)vaddr + (unsigned long )i,
                     __len);
    }
  } else {
    {
    __ret = memcpy((void *)(& temp), (void const *)vaddr + (unsigned long )i,
                             __len);
    }
  }
  __len___0 = 64UL;
  if (__len___0 > 63UL) {
    {
    __ret___0 = memcpy((void *)vaddr + (unsigned long )i, (void const *)(vaddr + ((unsigned long )i + 64UL)),
                         __len___0);
    }
  } else {
    {
    __ret___0 = memcpy((void *)vaddr + (unsigned long )i, (void const *)(vaddr + ((unsigned long )i + 64UL)),
                                 __len___0);
    }
  }
  __len___1 = 64UL;
  if (__len___1 > 63UL) {
    {
    __ret___1 = memcpy((void *)(vaddr + ((unsigned long )i + 64UL)), (void const *)(& temp),
                         __len___1);
    }
  } else {
    {
    __ret___1 = memcpy((void *)(vaddr + ((unsigned long )i + 64UL)), (void const *)(& temp),
                                 __len___1);
    }
  }
  i = i + 128;
  ldv_37127: ;
  if ((unsigned int )i <= 4095U) {
    goto ldv_37126;
  } else {
    goto ldv_37128;
  }
  ldv_37128:
  {
  kunmap(page);
  }
  return;
}
}
void i915_gem_object_do_bit_17_swizzle(struct drm_i915_gem_object *obj )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  int page_count___0 ;
  int i ;
  char new_bit_17 ;
  int tmp ;
  {
  dev = obj->base.dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  page_count___0 = (int )(obj->base.size >> 12);
  if (dev_priv->mm.bit_6_swizzle_x != 7U) {
    return;
  } else {
  }
  if ((unsigned long )obj->bit_17 == (unsigned long )((unsigned long *)0)) {
    return;
  } else {
  }
  i = 0;
  goto ldv_37138;
  ldv_37137:
  {
  new_bit_17 = (char )(((unsigned long long )(((long )*(obj->pages + (unsigned long )i) + 24189255811072L) / 56L) << 12) >> 17);
  tmp = variable_test_bit(i, (unsigned long const volatile *)obj->bit_17);
  }
  if ((int )((_Bool )((int )new_bit_17 & 1)) ^ (tmp != 0)) {
    {
    i915_gem_swizzle_page(*(obj->pages + (unsigned long )i));
    set_page_dirty(*(obj->pages + (unsigned long )i));
    }
  } else {
  }
  i = i + 1;
  ldv_37138: ;
  if (i < page_count___0) {
    goto ldv_37137;
  } else {
    goto ldv_37139;
  }
  ldv_37139: ;
  return;
}
}
void i915_gem_object_save_bit_17_swizzle(struct drm_i915_gem_object *obj )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  int page_count___0 ;
  int i ;
  void *tmp ;
  {
  dev = obj->base.dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  page_count___0 = (int )(obj->base.size >> 12);
  if (dev_priv->mm.bit_6_swizzle_x != 7U) {
    return;
  } else {
  }
  if ((unsigned long )obj->bit_17 == (unsigned long )((unsigned long *)0)) {
    {
    tmp = kmalloc((((unsigned long )page_count___0 + 63UL) / 64UL) * 8UL, 208U);
    obj->bit_17 = (unsigned long *)tmp;
    }
    if ((unsigned long )obj->bit_17 == (unsigned long )((unsigned long *)0)) {
      {
      drm_err("i915_gem_object_save_bit_17_swizzle", "Failed to allocate memory for bit 17 record\n");
      }
      return;
    } else {
    }
  } else {
  }
  i = 0;
  goto ldv_37149;
  ldv_37148: ;
  if ((((unsigned long long )(((long )*(obj->pages + (unsigned long )i) + 24189255811072L) / 56L) << 12) & 131072ULL) != 0ULL) {
    {
    __set_bit(i, (unsigned long volatile *)obj->bit_17);
    }
  } else {
    {
    __clear_bit(i, (unsigned long volatile *)obj->bit_17);
    }
  }
  i = i + 1;
  ldv_37149: ;
  if (i < page_count___0) {
    goto ldv_37148;
  } else {
    goto ldv_37150;
  }
  ldv_37150: ;
  return;
}
}
struct tracepoint __tracepoint_i915_ring_wait_begin ;
struct tracepoint __tracepoint_i915_ring_wait_end ;
struct tracepoint __tracepoint_i915_flip_request ;
struct tracepoint __tracepoint_i915_flip_complete ;
static char const __tpstrtab_i915_gem_object_create[23U] =
  { (char const )'i', (char const )'9', (char const )'1', (char const )'5',
        (char const )'_', (char const )'g', (char const )'e', (char const )'m',
        (char const )'_', (char const )'o', (char const )'b', (char const )'j',
        (char const )'e', (char const )'c', (char const )'t', (char const )'_',
        (char const )'c', (char const )'r', (char const )'e', (char const )'a',
        (char const )'t', (char const )'e', (char const )'\000'};
struct tracepoint __tracepoint_i915_gem_object_create = {(char const *)(& __tpstrtab_i915_gem_object_create), {{0}}, (void (*)(void))0,
    (void (*)(void))0, (struct tracepoint_func *)0};
static char const __tpstrtab_i915_gem_object_bind[21U] =
  { (char const )'i', (char const )'9', (char const )'1', (char const )'5',
        (char const )'_', (char const )'g', (char const )'e', (char const )'m',
        (char const )'_', (char const )'o', (char const )'b', (char const )'j',
        (char const )'e', (char const )'c', (char const )'t', (char const )'_',
        (char const )'b', (char const )'i', (char const )'n', (char const )'d',
        (char const )'\000'};
struct tracepoint __tracepoint_i915_gem_object_bind = {(char const *)(& __tpstrtab_i915_gem_object_bind), {{0}}, (void (*)(void))0,
    (void (*)(void))0, (struct tracepoint_func *)0};
static char const __tpstrtab_i915_gem_object_unbind[23U] =
  { (char const )'i', (char const )'9', (char const )'1', (char const )'5',
        (char const )'_', (char const )'g', (char const )'e', (char const )'m',
        (char const )'_', (char const )'o', (char const )'b', (char const )'j',
        (char const )'e', (char const )'c', (char const )'t', (char const )'_',
        (char const )'u', (char const )'n', (char const )'b', (char const )'i',
        (char const )'n', (char const )'d', (char const )'\000'};
struct tracepoint __tracepoint_i915_gem_object_unbind = {(char const *)(& __tpstrtab_i915_gem_object_unbind), {{0}}, (void (*)(void))0,
    (void (*)(void))0, (struct tracepoint_func *)0};
static char const __tpstrtab_i915_gem_object_change_domain[30U] =
  { (char const )'i', (char const )'9', (char const )'1', (char const )'5',
        (char const )'_', (char const )'g', (char const )'e', (char const )'m',
        (char const )'_', (char const )'o', (char const )'b', (char const )'j',
        (char const )'e', (char const )'c', (char const )'t', (char const )'_',
        (char const )'c', (char const )'h', (char const )'a', (char const )'n',
        (char const )'g', (char const )'e', (char const )'_', (char const )'d',
        (char const )'o', (char const )'m', (char const )'a', (char const )'i',
        (char const )'n', (char const )'\000'};
struct tracepoint __tracepoint_i915_gem_object_change_domain = {(char const *)(& __tpstrtab_i915_gem_object_change_domain), {{0}}, (void (*)(void))0,
    (void (*)(void))0, (struct tracepoint_func *)0};
static char const __tpstrtab_i915_gem_object_pwrite[23U] =
  { (char const )'i', (char const )'9', (char const )'1', (char const )'5',
        (char const )'_', (char const )'g', (char const )'e', (char const )'m',
        (char const )'_', (char const )'o', (char const )'b', (char const )'j',
        (char const )'e', (char const )'c', (char const )'t', (char const )'_',
        (char const )'p', (char const )'w', (char const )'r', (char const )'i',
        (char const )'t', (char const )'e', (char const )'\000'};
struct tracepoint __tracepoint_i915_gem_object_pwrite = {(char const *)(& __tpstrtab_i915_gem_object_pwrite), {{0}}, (void (*)(void))0,
    (void (*)(void))0, (struct tracepoint_func *)0};
static char const __tpstrtab_i915_gem_object_pread[22U] =
  { (char const )'i', (char const )'9', (char const )'1', (char const )'5',
        (char const )'_', (char const )'g', (char const )'e', (char const )'m',
        (char const )'_', (char const )'o', (char const )'b', (char const )'j',
        (char const )'e', (char const )'c', (char const )'t', (char const )'_',
        (char const )'p', (char const )'r', (char const )'e', (char const )'a',
        (char const )'d', (char const )'\000'};
struct tracepoint __tracepoint_i915_gem_object_pread = {(char const *)(& __tpstrtab_i915_gem_object_pread), {{0}}, (void (*)(void))0,
    (void (*)(void))0, (struct tracepoint_func *)0};
static char const __tpstrtab_i915_gem_object_fault[22U] =
  { (char const )'i', (char const )'9', (char const )'1', (char const )'5',
        (char const )'_', (char const )'g', (char const )'e', (char const )'m',
        (char const )'_', (char const )'o', (char const )'b', (char const )'j',
        (char const )'e', (char const )'c', (char const )'t', (char const )'_',
        (char const )'f', (char const )'a', (char const )'u', (char const )'l',
        (char const )'t', (char const )'\000'};
struct tracepoint __tracepoint_i915_gem_object_fault = {(char const *)(& __tpstrtab_i915_gem_object_fault), {{0}}, (void (*)(void))0,
    (void (*)(void))0, (struct tracepoint_func *)0};
static char const __tpstrtab_i915_gem_object_clflush[24U] =
  { (char const )'i', (char const )'9', (char const )'1', (char const )'5',
        (char const )'_', (char const )'g', (char const )'e', (char const )'m',
        (char const )'_', (char const )'o', (char const )'b', (char const )'j',
        (char const )'e', (char const )'c', (char const )'t', (char const )'_',
        (char const )'c', (char const )'l', (char const )'f', (char const )'l',
        (char const )'u', (char const )'s', (char const )'h', (char const )'\000'};
struct tracepoint __tracepoint_i915_gem_object_clflush = {(char const *)(& __tpstrtab_i915_gem_object_clflush), {{0}}, (void (*)(void))0,
    (void (*)(void))0, (struct tracepoint_func *)0};
static char const __tpstrtab_i915_gem_object_destroy[24U] =
  { (char const )'i', (char const )'9', (char const )'1', (char const )'5',
        (char const )'_', (char const )'g', (char const )'e', (char const )'m',
        (char const )'_', (char const )'o', (char const )'b', (char const )'j',
        (char const )'e', (char const )'c', (char const )'t', (char const )'_',
        (char const )'d', (char const )'e', (char const )'s', (char const )'t',
        (char const )'r', (char const )'o', (char const )'y', (char const )'\000'};
struct tracepoint __tracepoint_i915_gem_object_destroy = {(char const *)(& __tpstrtab_i915_gem_object_destroy), {{0}}, (void (*)(void))0,
    (void (*)(void))0, (struct tracepoint_func *)0};
static char const __tpstrtab_i915_gem_evict[15U] =
  { (char const )'i', (char const )'9', (char const )'1', (char const )'5',
        (char const )'_', (char const )'g', (char const )'e', (char const )'m',
        (char const )'_', (char const )'e', (char const )'v', (char const )'i',
        (char const )'c', (char const )'t', (char const )'\000'};
struct tracepoint __tracepoint_i915_gem_evict = {(char const *)(& __tpstrtab_i915_gem_evict), {{0}}, (void (*)(void))0, (void (*)(void))0,
    (struct tracepoint_func *)0};
static char const __tpstrtab_i915_gem_evict_everything[26U] =
  { (char const )'i', (char const )'9', (char const )'1', (char const )'5',
        (char const )'_', (char const )'g', (char const )'e', (char const )'m',
        (char const )'_', (char const )'e', (char const )'v', (char const )'i',
        (char const )'c', (char const )'t', (char const )'_', (char const )'e',
        (char const )'v', (char const )'e', (char const )'r', (char const )'y',
        (char const )'t', (char const )'h', (char const )'i', (char const )'n',
        (char const )'g', (char const )'\000'};
struct tracepoint __tracepoint_i915_gem_evict_everything = {(char const *)(& __tpstrtab_i915_gem_evict_everything), {{0}}, (void (*)(void))0,
    (void (*)(void))0, (struct tracepoint_func *)0};
static char const __tpstrtab_i915_gem_ring_dispatch[23U] =
  { (char const )'i', (char const )'9', (char const )'1', (char const )'5',
        (char const )'_', (char const )'g', (char const )'e', (char const )'m',
        (char const )'_', (char const )'r', (char const )'i', (char const )'n',
        (char const )'g', (char const )'_', (char const )'d', (char const )'i',
        (char const )'s', (char const )'p', (char const )'a', (char const )'t',
        (char const )'c', (char const )'h', (char const )'\000'};
struct tracepoint __tracepoint_i915_gem_ring_dispatch = {(char const *)(& __tpstrtab_i915_gem_ring_dispatch), {{0}}, (void (*)(void))0,
    (void (*)(void))0, (struct tracepoint_func *)0};
static char const __tpstrtab_i915_gem_ring_flush[20U] =
  { (char const )'i', (char const )'9', (char const )'1', (char const )'5',
        (char const )'_', (char const )'g', (char const )'e', (char const )'m',
        (char const )'_', (char const )'r', (char const )'i', (char const )'n',
        (char const )'g', (char const )'_', (char const )'f', (char const )'l',
        (char const )'u', (char const )'s', (char const )'h', (char const )'\000'};
struct tracepoint __tracepoint_i915_gem_ring_flush = {(char const *)(& __tpstrtab_i915_gem_ring_flush), {{0}}, (void (*)(void))0,
    (void (*)(void))0, (struct tracepoint_func *)0};
static char const __tpstrtab_i915_gem_request_add[21U] =
  { (char const )'i', (char const )'9', (char const )'1', (char const )'5',
        (char const )'_', (char const )'g', (char const )'e', (char const )'m',
        (char const )'_', (char const )'r', (char const )'e', (char const )'q',
        (char const )'u', (char const )'e', (char const )'s', (char const )'t',
        (char const )'_', (char const )'a', (char const )'d', (char const )'d',
        (char const )'\000'};
struct tracepoint __tracepoint_i915_gem_request_add = {(char const *)(& __tpstrtab_i915_gem_request_add), {{0}}, (void (*)(void))0,
    (void (*)(void))0, (struct tracepoint_func *)0};
static char const __tpstrtab_i915_gem_request_complete[26U] =
  { (char const )'i', (char const )'9', (char const )'1', (char const )'5',
        (char const )'_', (char const )'g', (char const )'e', (char const )'m',
        (char const )'_', (char const )'r', (char const )'e', (char const )'q',
        (char const )'u', (char const )'e', (char const )'s', (char const )'t',
        (char const )'_', (char const )'c', (char const )'o', (char const )'m',
        (char const )'p', (char const )'l', (char const )'e', (char const )'t',
        (char const )'e', (char const )'\000'};
struct tracepoint __tracepoint_i915_gem_request_complete = {(char const *)(& __tpstrtab_i915_gem_request_complete), {{0}}, (void (*)(void))0,
    (void (*)(void))0, (struct tracepoint_func *)0};
static char const __tpstrtab_i915_gem_request_retire[24U] =
  { (char const )'i', (char const )'9', (char const )'1', (char const )'5',
        (char const )'_', (char const )'g', (char const )'e', (char const )'m',
        (char const )'_', (char const )'r', (char const )'e', (char const )'q',
        (char const )'u', (char const )'e', (char const )'s', (char const )'t',
        (char const )'_', (char const )'r', (char const )'e', (char const )'t',
        (char const )'i', (char const )'r', (char const )'e', (char const )'\000'};
struct tracepoint __tracepoint_i915_gem_request_retire = {(char const *)(& __tpstrtab_i915_gem_request_retire), {{0}}, (void (*)(void))0,
    (void (*)(void))0, (struct tracepoint_func *)0};
static char const __tpstrtab_i915_gem_request_wait_begin[28U] =
  { (char const )'i', (char const )'9', (char const )'1', (char const )'5',
        (char const )'_', (char const )'g', (char const )'e', (char const )'m',
        (char const )'_', (char const )'r', (char const )'e', (char const )'q',
        (char const )'u', (char const )'e', (char const )'s', (char const )'t',
        (char const )'_', (char const )'w', (char const )'a', (char const )'i',
        (char const )'t', (char const )'_', (char const )'b', (char const )'e',
        (char const )'g', (char const )'i', (char const )'n', (char const )'\000'};
struct tracepoint __tracepoint_i915_gem_request_wait_begin = {(char const *)(& __tpstrtab_i915_gem_request_wait_begin), {{0}}, (void (*)(void))0,
    (void (*)(void))0, (struct tracepoint_func *)0};
static char const __tpstrtab_i915_gem_request_wait_end[26U] =
  { (char const )'i', (char const )'9', (char const )'1', (char const )'5',
        (char const )'_', (char const )'g', (char const )'e', (char const )'m',
        (char const )'_', (char const )'r', (char const )'e', (char const )'q',
        (char const )'u', (char const )'e', (char const )'s', (char const )'t',
        (char const )'_', (char const )'w', (char const )'a', (char const )'i',
        (char const )'t', (char const )'_', (char const )'e', (char const )'n',
        (char const )'d', (char const )'\000'};
struct tracepoint __tracepoint_i915_gem_request_wait_end = {(char const *)(& __tpstrtab_i915_gem_request_wait_end), {{0}}, (void (*)(void))0,
    (void (*)(void))0, (struct tracepoint_func *)0};
static char const __tpstrtab_i915_ring_wait_begin[21U] =
  { (char const )'i', (char const )'9', (char const )'1', (char const )'5',
        (char const )'_', (char const )'r', (char const )'i', (char const )'n',
        (char const )'g', (char const )'_', (char const )'w', (char const )'a',
        (char const )'i', (char const )'t', (char const )'_', (char const )'b',
        (char const )'e', (char const )'g', (char const )'i', (char const )'n',
        (char const )'\000'};
struct tracepoint __tracepoint_i915_ring_wait_begin = {(char const *)(& __tpstrtab_i915_ring_wait_begin), {{0}}, (void (*)(void))0,
    (void (*)(void))0, (struct tracepoint_func *)0};
static char const __tpstrtab_i915_ring_wait_end[19U] =
  { (char const )'i', (char const )'9', (char const )'1', (char const )'5',
        (char const )'_', (char const )'r', (char const )'i', (char const )'n',
        (char const )'g', (char const )'_', (char const )'w', (char const )'a',
        (char const )'i', (char const )'t', (char const )'_', (char const )'e',
        (char const )'n', (char const )'d', (char const )'\000'};
struct tracepoint __tracepoint_i915_ring_wait_end = {(char const *)(& __tpstrtab_i915_ring_wait_end), {{0}}, (void (*)(void))0, (void (*)(void))0,
    (struct tracepoint_func *)0};
static char const __tpstrtab_i915_flip_request[18U] =
  { (char const )'i', (char const )'9', (char const )'1', (char const )'5',
        (char const )'_', (char const )'f', (char const )'l', (char const )'i',
        (char const )'p', (char const )'_', (char const )'r', (char const )'e',
        (char const )'q', (char const )'u', (char const )'e', (char const )'s',
        (char const )'t', (char const )'\000'};
struct tracepoint __tracepoint_i915_flip_request = {(char const *)(& __tpstrtab_i915_flip_request), {{0}}, (void (*)(void))0, (void (*)(void))0,
    (struct tracepoint_func *)0};
static char const __tpstrtab_i915_flip_complete[19U] =
  { (char const )'i', (char const )'9', (char const )'1', (char const )'5',
        (char const )'_', (char const )'f', (char const )'l', (char const )'i',
        (char const )'p', (char const )'_', (char const )'c', (char const )'o',
        (char const )'m', (char const )'p', (char const )'l', (char const )'e',
        (char const )'t', (char const )'e', (char const )'\000'};
struct tracepoint __tracepoint_i915_flip_complete = {(char const *)(& __tpstrtab_i915_flip_complete), {{0}}, (void (*)(void))0, (void (*)(void))0,
    (struct tracepoint_func *)0};
static char const __tpstrtab_i915_reg_rw[12U] =
  { (char const )'i', (char const )'9', (char const )'1', (char const )'5',
        (char const )'_', (char const )'r', (char const )'e', (char const )'g',
        (char const )'_', (char const )'r', (char const )'w', (char const )'\000'};
struct tracepoint __tracepoint_i915_reg_rw = {(char const *)(& __tpstrtab_i915_reg_rw), {{0}}, (void (*)(void))0, (void (*)(void))0,
    (struct tracepoint_func *)0};
__inline static bool is_power_of_2(unsigned long n )
{ int tmp ;
  {
  if (n != 0UL) {
    if (((n - 1UL) & n) == 0UL) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((bool )tmp);
}
}
__inline static void *ERR_PTR(long error )
{
  {
  return ((void *)error);
}
}
__inline static void atomic_add(int i , atomic_t *v )
{
  {
  __asm__ volatile (".section .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.previous\n671:\n\tlock; addl %1,%0": "+m" (v->counter): "ir" (i));
  return;
}
}
__inline static void atomic_sub(int i , atomic_t *v )
{
  {
  __asm__ volatile (".section .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.previous\n671:\n\tlock; subl %1,%0": "+m" (v->counter): "ir" (i));
  return;
}
}
__inline static s64 timeval_to_ns(struct timeval const *tv )
{
  {
  return ((long long )tv->tv_sec * 1000000000LL + (long long )((long )tv->tv_usec * 1000L));
}
}
extern struct timeval ns_to_timeval(s64 const ) ;
extern int schedule_work(struct work_struct * ) ;
__inline static void outb(unsigned char value , int port )
{
  {
  __asm__ volatile ("outb %b0, %w1": : "a" (value), "Nd" (port));
  return;
}
}
__inline static unsigned char inb(int port )
{ unsigned char value ;
  {
  __asm__ volatile ("inb %w1, %b0": "=a" (value): "Nd" (port));
  return (value);
}
}
extern int vga_get(struct pci_dev * , unsigned int , int ) ;
__inline static int vga_get_uninterruptible(struct pci_dev *pdev , unsigned int rsrc )
{ int tmp ;
  {
  {
  tmp = vga_get(pdev, rsrc, 0);
  }
  return (tmp);
}
}
extern void vga_put(struct pci_dev * , unsigned int ) ;
extern int pci_bus_write_config_word(struct pci_bus * , unsigned int , int , u16 ) ;
__inline static int pci_write_config_word(struct pci_dev *dev , int where , u16 val )
{ int tmp ;
  {
  {
  tmp = pci_bus_write_config_word(dev->bus, dev->devfn, where, (u16 )((int )val));
  }
  return (tmp);
}
}
extern void drm_crtc_init(struct drm_device * , struct drm_crtc * , struct drm_crtc_funcs const * ) ;
extern void drm_crtc_cleanup(struct drm_crtc * ) ;
extern void drm_encoder_cleanup(struct drm_encoder * ) ;
extern char *drm_get_connector_name(struct drm_connector * ) ;
extern void drm_mode_debug_printmodeline(struct drm_display_mode * ) ;
extern void drm_mode_config_init(struct drm_device * ) ;
extern void drm_mode_config_cleanup(struct drm_device * ) ;
extern void drm_mode_set_name(struct drm_display_mode * ) ;
extern void drm_mode_set_crtcinfo(struct drm_display_mode * , int ) ;
extern int drm_framebuffer_init(struct drm_device * , struct drm_framebuffer * , struct drm_framebuffer_funcs const * ) ;
extern void drm_framebuffer_cleanup(struct drm_framebuffer * ) ;
extern char *drm_get_encoder_name(struct drm_encoder * ) ;
extern int drm_mode_connector_attach_encoder(struct drm_connector * , struct drm_encoder * ) ;
extern bool drm_mode_crtc_set_gamma_size(struct drm_crtc * , int ) ;
extern struct drm_mode_object *drm_mode_object_find(struct drm_device * , uint32_t ,
                                                    uint32_t ) ;
extern u32 drm_vblank_count_and_time(struct drm_device * , int , struct timeval * ) ;
extern int drm_vblank_get(struct drm_device * , int ) ;
extern void drm_vblank_put(struct drm_device * , int ) ;
extern void drm_vblank_off(struct drm_device * , int ) ;
extern void drm_vblank_pre_modeset(struct drm_device * , int ) ;
extern void drm_vblank_post_modeset(struct drm_device * , int ) ;
__inline static void trace_i915_flip_request(int plane , struct drm_i915_gem_object *obj )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_flip_request.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_flip_request.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )367);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_36608:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , int , struct drm_i915_gem_object * ))it_func))(__data,
                                                                            plane,
                                                                            obj);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_36608;
      } else {
        goto ldv_36609;
      }
      ldv_36609: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
__inline static void trace_i915_flip_complete(int plane , struct drm_i915_gem_object *obj )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_flip_complete.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_flip_complete.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )385);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_36644:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , int , struct drm_i915_gem_object * ))it_func))(__data,
                                                                            plane,
                                                                            obj);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_36644;
      } else {
        goto ldv_36645;
      }
      ldv_36645: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
__inline static void trace_i915_reg_rw___6(bool write , u32 reg , u64 val , int len )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_reg_rw.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_reg_rw.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )411);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_36684:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , bool , u32 , u64 , int ))it_func))(__data, (bool )((int )write),
                                                                   reg, val, len);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_36684;
      } else {
        goto ldv_36685;
      }
      ldv_36685: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
void intel_unregister_dsm_handler(void) ;
void intel_enable_fbc(struct drm_crtc *crtc , unsigned long interval ) ;
int intel_trans_dp_port_sel(struct drm_crtc *crtc ) ;
__inline static u16 i915_read16___2(struct drm_i915_private *dev_priv , u32 reg )
{ u16 val ;
  {
  val = (u16 )0U;
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        gen6_gt_force_wake_get(dev_priv);
        val = readw((void const volatile *)dev_priv->regs + (unsigned long )reg);
        gen6_gt_force_wake_put(dev_priv);
        }
      } else {
        {
        val = readw((void const volatile *)dev_priv->regs + (unsigned long )reg);
        }
      }
    } else {
      {
      val = readw((void const volatile *)dev_priv->regs + (unsigned long )reg);
      }
    }
  } else {
    {
    val = readw((void const volatile *)dev_priv->regs + (unsigned long )reg);
    }
  }
  {
  trace_i915_reg_rw___6((bool )0, reg, (u64 )val, 2);
  }
  return (val);
}
}
__inline static u32 i915_read32___6(struct drm_i915_private *dev_priv , u32 reg )
{ u32 val ;
  {
  val = 0U;
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        gen6_gt_force_wake_get(dev_priv);
        val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
        gen6_gt_force_wake_put(dev_priv);
        }
      } else {
        {
        val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
        }
      }
    } else {
      {
      val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
      }
    }
  } else {
    {
    val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
    }
  }
  {
  trace_i915_reg_rw___6((bool )0, reg, (u64 )val, 4);
  }
  return (val);
}
}
__inline static void i915_write16___0(struct drm_i915_private *dev_priv , u32 reg ,
                                      u16 val )
{
  {
  {
  trace_i915_reg_rw___6((bool )1, reg, (u64 )val, 2);
  }
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        __gen6_gt_wait_for_fifo(dev_priv);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  writew((unsigned short )((int )val), (void volatile *)dev_priv->regs + (unsigned long )reg);
  }
  return;
}
}
__inline static void i915_write32___4(struct drm_i915_private *dev_priv , u32 reg ,
                                      u32 val )
{
  {
  {
  trace_i915_reg_rw___6((bool )1, reg, (u64 )val, 4);
  }
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        __gen6_gt_wait_for_fifo(dev_priv);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  writel(val, (void volatile *)dev_priv->regs + (unsigned long )reg);
  }
  return;
}
}
extern void drm_helper_disable_unused_functions(struct drm_device * ) ;
extern int drm_crtc_helper_set_config(struct drm_mode_set * ) ;
extern bool drm_crtc_helper_set_mode(struct drm_crtc * , struct drm_display_mode * ,
                                     int , int , struct drm_framebuffer * ) ;
extern int drm_helper_mode_fill_fb_struct(struct drm_framebuffer * , struct drm_mode_fb_cmd * ) ;
__inline static void drm_crtc_helper_add(struct drm_crtc *crtc , struct drm_crtc_helper_funcs const *funcs )
{
  {
  crtc->helper_private = (void *)funcs;
  return;
}
}
extern void drm_kms_helper_poll_fini(struct drm_device * ) ;
__inline static int intel_mode_get_pixel_multiplier(struct drm_display_mode const *mode )
{
  {
  return ((int )mode->private_flags & 15);
}
}
__inline static struct drm_crtc *intel_get_crtc_for_plane(struct drm_device *dev ,
                                                          int plane )
{ struct drm_i915_private *dev_priv ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  return (dev_priv->plane_to_crtc_mapping[plane]);
}
}
void intel_crt_init(struct drm_device *dev ) ;
void intel_hdmi_init(struct drm_device *dev , int sdvox_reg ) ;
bool intel_sdvo_init(struct drm_device *dev , int sdvo_reg ) ;
void intel_dvo_init(struct drm_device *dev ) ;
void intel_tv_init(struct drm_device *dev ) ;
bool intel_lvds_init(struct drm_device *dev ) ;
void intel_dp_init(struct drm_device *dev , int output_reg ) ;
void intel_dp_set_m_n(struct drm_crtc *crtc , struct drm_display_mode *mode , struct drm_display_mode *adjusted_mode ) ;
bool intel_dpd_is_edp(struct drm_device *dev ) ;
void intel_edp_link_config(struct intel_encoder *intel_encoder , int *lane_num , int *link_bw ) ;
bool intel_encoder_is_pch_edp(struct drm_encoder *encoder ) ;
void intel_panel_setup_backlight(struct drm_device *dev ) ;
void intel_crtc_load_lut(struct drm_crtc *crtc ) ;
void intel_encoder_prepare(struct drm_encoder *encoder ) ;
void intel_encoder_commit(struct drm_encoder *encoder ) ;
void intel_encoder_destroy(struct drm_encoder *encoder ) ;
__inline static struct intel_encoder *intel_attached_encoder(struct drm_connector *connector )
{ struct drm_connector const *__mptr ;
  {
  __mptr = (struct drm_connector const *)connector;
  return (((struct intel_connector *)__mptr)->encoder);
}
}
void intel_connector_attach_encoder(struct intel_connector *connector , struct intel_encoder *encoder ) ;
struct drm_encoder *intel_best_encoder(struct drm_connector *connector ) ;
struct drm_display_mode *intel_crtc_mode_get(struct drm_device *dev , struct drm_crtc *crtc ) ;
void intel_wait_for_vblank(struct drm_device *dev , int pipe ) ;
void intel_wait_for_pipe_off(struct drm_device *dev , int pipe ) ;
bool intel_get_load_detect_pipe(struct intel_encoder *intel_encoder , struct drm_connector *connector ,
                                struct drm_display_mode *mode , struct intel_load_detect_pipe *old ) ;
void intel_release_load_detect_pipe(struct intel_encoder *intel_encoder , struct drm_connector *connector ,
                                    struct intel_load_detect_pipe *old ) ;
void intel_crtc_fb_gamma_set(struct drm_crtc *crtc , u16 red , u16 green , u16 blue ,
                             int regno ) ;
void intel_crtc_fb_gamma_get(struct drm_crtc *crtc , u16 *red , u16 *green , u16 *blue ,
                             int regno ) ;
int intel_pin_and_fence_fb_obj(struct drm_device *dev , struct drm_i915_gem_object *obj ,
                               struct intel_ring_buffer *pipelined ) ;
int intel_framebuffer_init(struct drm_device *dev , struct intel_framebuffer *intel_fb ,
                           struct drm_mode_fb_cmd *mode_cmd , struct drm_i915_gem_object *obj ) ;
void intel_setup_overlay(struct drm_device *dev ) ;
int intel_overlay_switch_off(struct intel_overlay *overlay ) ;
void intel_fb_output_poll_changed(struct drm_device *dev ) ;
bool intel_pipe_has_type(struct drm_crtc *crtc , int type ) ;
static void intel_update_watermarks(struct drm_device *dev ) ;
static void intel_increase_pllclock(struct drm_crtc *crtc ) ;
static void intel_crtc_update_cursor(struct drm_crtc *crtc , bool on ) ;
static bool intel_find_best_PLL(intel_limit_t const *limit , struct drm_crtc *crtc ,
                                int target , int refclk , intel_clock_t *best_clock ) ;
static bool intel_g4x_find_best_PLL(intel_limit_t const *limit , struct drm_crtc *crtc ,
                                    int target , int refclk , intel_clock_t *best_clock ) ;
static bool intel_find_pll_g4x_dp(intel_limit_t const *limit , struct drm_crtc *crtc ,
                                  int target , int refclk , intel_clock_t *best_clock ) ;
static bool intel_find_pll_ironlake_dp(intel_limit_t const *limit , struct drm_crtc *crtc ,
                                       int target , int refclk , intel_clock_t *best_clock ) ;
__inline static u32 intel_fdi_link_freq(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 tmp ;
  {
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    dev_priv = (struct drm_i915_private *)dev->dev_private;
    tmp = i915_read32___6(dev_priv, 286720U);
    }
    return ((tmp & 255U) + 2U);
  } else {
    return (27U);
  }
}
}
static struct intel_limit const intel_limits_i8xx_dvo =
     {{25000, 350000}, {930000, 1400000}, {3, 16}, {96, 140}, {18, 26}, {6, 16}, {4,
                                                                                128},
    {2, 33}, {165000, 4, 2}, & intel_find_best_PLL};
static struct intel_limit const intel_limits_i8xx_lvds =
     {{25000, 350000}, {930000, 1400000}, {3, 16}, {96, 140}, {18, 26}, {6, 16}, {4,
                                                                                128},
    {1, 6}, {165000, 14, 7}, & intel_find_best_PLL};
static struct intel_limit const intel_limits_i9xx_sdvo =
     {{20000, 400000}, {1400000, 2800000}, {1, 6}, {70, 120}, {10, 22}, {5, 9}, {5,
                                                                               80},
    {1, 8}, {200000, 10, 5}, & intel_find_best_PLL};
static struct intel_limit const intel_limits_i9xx_lvds =
     {{20000, 400000}, {1400000, 2800000}, {1, 6}, {70, 120}, {10, 22}, {5, 9}, {7,
                                                                               98},
    {1, 8}, {112000, 14, 7}, & intel_find_best_PLL};
static struct intel_limit const intel_limits_g4x_sdvo =
     {{25000, 270000}, {1750000, 3500000}, {1, 4}, {104, 138}, {17, 23}, {5, 11}, {10,
                                                                                 30},
    {1, 3}, {270000, 10, 10}, & intel_g4x_find_best_PLL};
static struct intel_limit const intel_limits_g4x_hdmi =
     {{22000, 400000}, {1750000, 3500000}, {1, 4}, {104, 138}, {16, 23}, {5, 11}, {5,
                                                                                 80},
    {1, 8}, {165000, 10, 5}, & intel_g4x_find_best_PLL};
static struct intel_limit const intel_limits_g4x_single_channel_lvds =
     {{20000, 115000}, {1750000, 3500000}, {1, 3}, {104, 138}, {17, 23}, {5, 11}, {28,
                                                                                 112},
    {2, 8}, {0, 14, 14}, & intel_g4x_find_best_PLL};
static struct intel_limit const intel_limits_g4x_dual_channel_lvds =
     {{80000, 224000}, {1750000, 3500000}, {1, 3}, {104, 138}, {17, 23}, {5, 11}, {14,
                                                                                 42},
    {2, 6}, {0, 7, 7}, & intel_g4x_find_best_PLL};
static struct intel_limit const intel_limits_g4x_display_port =
     {{161670, 227000}, {1750000, 3500000}, {1, 2}, {97, 108}, {16, 18}, {5, 6}, {10,
                                                                                20},
    {1, 2}, {0, 10, 10}, & intel_find_pll_g4x_dp};
static struct intel_limit const intel_limits_pineview_sdvo =
     {{20000, 400000}, {1700000, 3500000}, {3, 6}, {2, 256}, {0, 0}, {0, 254}, {5, 80},
    {1, 8}, {200000, 10, 5}, & intel_find_best_PLL};
static struct intel_limit const intel_limits_pineview_lvds =
     {{20000, 400000}, {1700000, 3500000}, {3, 6}, {2, 256}, {0, 0}, {0, 254}, {7, 112},
    {1, 8}, {112000, 14, 14}, & intel_find_best_PLL};
static struct intel_limit const intel_limits_ironlake_dac =
     {{25000, 350000}, {1760000, 3510000}, {1, 5}, {79, 127}, {12, 22}, {5, 9}, {5,
                                                                               80},
    {1, 8}, {225000, 10, 5}, & intel_g4x_find_best_PLL};
static struct intel_limit const intel_limits_ironlake_single_lvds =
     {{25000, 350000}, {1760000, 3510000}, {1, 3}, {79, 118}, {12, 22}, {5, 9}, {28,
                                                                               112},
    {2, 8}, {225000, 14, 14}, & intel_g4x_find_best_PLL};
static struct intel_limit const intel_limits_ironlake_dual_lvds =
     {{25000, 350000}, {1760000, 3510000}, {1, 3}, {79, 127}, {12, 22}, {5, 9}, {14,
                                                                               56},
    {2, 8}, {225000, 7, 7}, & intel_g4x_find_best_PLL};
static struct intel_limit const intel_limits_ironlake_single_lvds_100m =
     {{25000, 350000}, {1760000, 3510000}, {1, 2}, {79, 126}, {12, 22}, {5, 9}, {28,
                                                                               112},
    {2, 8}, {225000, 14, 14}, & intel_g4x_find_best_PLL};
static struct intel_limit const intel_limits_ironlake_dual_lvds_100m =
     {{25000, 350000}, {1760000, 3510000}, {1, 3}, {79, 126}, {12, 22}, {5, 9}, {14,
                                                                               42},
    {2, 6}, {225000, 7, 7}, & intel_g4x_find_best_PLL};
static struct intel_limit const intel_limits_ironlake_display_port =
     {{25000, 350000}, {1760000, 3510000}, {1, 2}, {81, 90}, {12, 22}, {5, 9}, {10,
                                                                              20},
    {1, 2}, {0, 10, 10}, & intel_find_pll_ironlake_dp};
static intel_limit_t const *intel_ironlake_limit(struct drm_crtc *crtc , int refclk )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  intel_limit_t const *limit ;
  u32 tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  {
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp___2 = intel_pipe_has_type(crtc, 4);
  }
  if ((int )tmp___2) {
    {
    tmp = i915_read32___6(dev_priv, 921984U);
    }
    if ((tmp & 48U) == 48U) {
      if (refclk == 100000) {
        limit = & intel_limits_ironlake_dual_lvds_100m;
      } else {
        limit = & intel_limits_ironlake_dual_lvds;
      }
    } else
    if (refclk == 100000) {
      limit = & intel_limits_ironlake_single_lvds_100m;
    } else {
      limit = & intel_limits_ironlake_single_lvds;
    }
  } else {
    {
    tmp___0 = intel_pipe_has_type(crtc, 7);
    }
    if ((int )tmp___0) {
      limit = & intel_limits_ironlake_display_port;
    } else {
      {
      tmp___1 = intel_pipe_has_type(crtc, 8);
      }
      if ((int )tmp___1) {
        limit = & intel_limits_ironlake_display_port;
      } else {
        limit = & intel_limits_ironlake_dac;
      }
    }
  }
  return (limit);
}
}
static intel_limit_t const *intel_g4x_limit(struct drm_crtc *crtc )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  intel_limit_t const *limit ;
  u32 tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  {
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp___4 = intel_pipe_has_type(crtc, 4);
  }
  if ((int )tmp___4) {
    {
    tmp = i915_read32___6(dev_priv, 397696U);
    }
    if ((tmp & 48U) == 48U) {
      limit = & intel_limits_g4x_dual_channel_lvds;
    } else {
      limit = & intel_limits_g4x_single_channel_lvds;
    }
  } else {
    {
    tmp___2 = intel_pipe_has_type(crtc, 6);
    }
    if ((int )tmp___2) {
      limit = & intel_limits_g4x_hdmi;
    } else {
      {
      tmp___3 = intel_pipe_has_type(crtc, 1);
      }
      if ((int )tmp___3) {
        limit = & intel_limits_g4x_hdmi;
      } else {
        {
        tmp___1 = intel_pipe_has_type(crtc, 3);
        }
        if ((int )tmp___1) {
          limit = & intel_limits_g4x_sdvo;
        } else {
          {
          tmp___0 = intel_pipe_has_type(crtc, 7);
          }
          if ((int )tmp___0) {
            limit = & intel_limits_g4x_display_port;
          } else {
            limit = & intel_limits_i9xx_sdvo;
          }
        }
      }
    }
  }
  return (limit);
}
}
static intel_limit_t const *intel_limit(struct drm_crtc *crtc , int refclk )
{ struct drm_device *dev ;
  intel_limit_t const *limit ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  {
  dev = crtc->dev;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    limit = intel_ironlake_limit(crtc, refclk);
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    limit = intel_ironlake_limit(crtc, refclk);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    limit = intel_ironlake_limit(crtc, refclk);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    {
    limit = intel_g4x_limit(crtc);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    {
    tmp = intel_pipe_has_type(crtc, 4);
    }
    if ((int )tmp) {
      limit = & intel_limits_pineview_lvds;
    } else {
      limit = & intel_limits_pineview_sdvo;
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 2U) {
    {
    tmp___0 = intel_pipe_has_type(crtc, 4);
    }
    if ((int )tmp___0) {
      limit = & intel_limits_i9xx_lvds;
    } else {
      limit = & intel_limits_i9xx_sdvo;
    }
  } else {
    {
    tmp___1 = intel_pipe_has_type(crtc, 4);
    }
    if ((int )tmp___1) {
      limit = & intel_limits_i8xx_lvds;
    } else {
      limit = & intel_limits_i8xx_dvo;
    }
  }
  return (limit);
}
}
static void pineview_clock(int refclk , intel_clock_t *clock )
{
  {
  clock->m = clock->m2 + 2;
  clock->p = clock->p1 * clock->p2;
  clock->vco = (clock->m * refclk) / clock->n;
  clock->dot = clock->vco / clock->p;
  return;
}
}
static void intel_clock(struct drm_device *dev , int refclk , intel_clock_t *clock )
{
  {
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    {
    pineview_clock(refclk, clock);
    }
    return;
  } else {
  }
  clock->m = (clock->m1 * 5 + 10) + (clock->m2 + 2);
  clock->p = clock->p1 * clock->p2;
  clock->vco = (clock->m * refclk) / (clock->n + 2);
  clock->dot = clock->vco / clock->p;
  return;
}
}
bool intel_pipe_has_type(struct drm_crtc *crtc , int type )
{ struct drm_device *dev ;
  struct drm_mode_config *mode_config ;
  struct intel_encoder *encoder ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  {
  dev = crtc->dev;
  mode_config = & dev->mode_config;
  __mptr = (struct list_head const *)mode_config->encoder_list.next;
  encoder = (struct intel_encoder *)__mptr + 0x0ffffffffffffff8UL;
  goto ldv_38120;
  ldv_38119: ;
  if ((unsigned long )encoder->base.crtc == (unsigned long )crtc) {
    if (encoder->type == type) {
      return ((bool )1);
    } else {
    }
  } else {
  }
  __mptr___0 = (struct list_head const *)encoder->base.head.next;
  encoder = (struct intel_encoder *)__mptr___0 + 0x0ffffffffffffff8UL;
  ldv_38120: ;
  if ((unsigned long )(& encoder->base.head) != (unsigned long )(& mode_config->encoder_list)) {
    goto ldv_38119;
  } else {
    goto ldv_38121;
  }
  ldv_38121: ;
  return ((bool )0);
}
}
static bool intel_PLL_is_valid(struct drm_device *dev , intel_limit_t const *limit ,
                               intel_clock_t const *clock )
{
  {
  if ((int )clock->p1 < (int )limit->p1.min) {
    return ((bool )0);
  } else
  if ((int )limit->p1.max < (int )clock->p1) {
    return ((bool )0);
  } else {
  }
  if ((int )clock->p < (int )limit->p.min) {
    return ((bool )0);
  } else
  if ((int )limit->p.max < (int )clock->p) {
    return ((bool )0);
  } else {
  }
  if ((int )clock->m2 < (int )limit->m2.min) {
    return ((bool )0);
  } else
  if ((int )limit->m2.max < (int )clock->m2) {
    return ((bool )0);
  } else {
  }
  if ((int )clock->m1 < (int )limit->m1.min) {
    return ((bool )0);
  } else
  if ((int )limit->m1.max < (int )clock->m1) {
    return ((bool )0);
  } else {
  }
  if ((int )clock->m1 <= (int )clock->m2) {
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) == 0U) {
      return ((bool )0);
    } else {
    }
  } else {
  }
  if ((int )clock->m < (int )limit->m.min) {
    return ((bool )0);
  } else
  if ((int )limit->m.max < (int )clock->m) {
    return ((bool )0);
  } else {
  }
  if ((int )clock->n < (int )limit->n.min) {
    return ((bool )0);
  } else
  if ((int )limit->n.max < (int )clock->n) {
    return ((bool )0);
  } else {
  }
  if ((int )clock->vco < (int )limit->vco.min) {
    return ((bool )0);
  } else
  if ((int )limit->vco.max < (int )clock->vco) {
    return ((bool )0);
  } else {
  }
  if ((int )clock->dot < (int )limit->dot.min) {
    return ((bool )0);
  } else
  if ((int )limit->dot.max < (int )clock->dot) {
    return ((bool )0);
  } else {
  }
  return ((bool )1);
}
}
static bool intel_find_best_PLL(intel_limit_t const *limit , struct drm_crtc *crtc ,
                                int target , int refclk , intel_clock_t *best_clock )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  intel_clock_t clock ;
  int err ;
  u32 tmp ;
  bool tmp___0 ;
  u32 tmp___1 ;
  int this_err ;
  bool tmp___2 ;
  int tmp___3 ;
  long ret ;
  int __x___0 ;
  int tmp___4 ;
  {
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  err = target;
  tmp___0 = intel_pipe_has_type(crtc, 4);
  }
  if ((int )tmp___0) {
    {
    tmp___1 = i915_read32___6(dev_priv, 397696U);
    }
    if (tmp___1 != 0U) {
      {
      tmp = i915_read32___6(dev_priv, 397696U);
      }
      if ((tmp & 48U) == 48U) {
        clock.p2 = (int )limit->p2.p2_fast;
      } else {
        clock.p2 = (int )limit->p2.p2_slow;
      }
    } else {
      goto _L;
    }
  } else
  _L:
  if ((int )limit->p2.dot_limit > target) {
    clock.p2 = (int )limit->p2.p2_slow;
  } else {
    clock.p2 = (int )limit->p2.p2_fast;
  }
  {
  memset((void *)best_clock, 0, 36UL);
  clock.m1 = (int )limit->m1.min;
  }
  goto ldv_38154;
  ldv_38153:
  clock.m2 = (int )limit->m2.min;
  goto ldv_38152;
  ldv_38151: ;
  if (clock.m2 >= clock.m1) {
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) == 0U) {
      goto ldv_38138;
    } else {
    }
  } else {
  }
  clock.n = (int )limit->n.min;
  goto ldv_38149;
  ldv_38148:
  clock.p1 = (int )limit->p1.min;
  goto ldv_38146;
  ldv_38145:
  {
  intel_clock(dev, refclk, & clock);
  tmp___2 = intel_PLL_is_valid(dev, limit, (intel_clock_t const *)(& clock));
  }
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    goto ldv_38140;
  } else {
  }
  __x___0 = clock.dot - target;
  if (__x___0 < 0) {
    tmp___4 = - __x___0;
  } else {
    tmp___4 = __x___0;
  }
  ret = (long )tmp___4;
  this_err = (int )ret;
  if (this_err < err) {
    *best_clock = clock;
    err = this_err;
  } else {
  }
  ldv_38140:
  clock.p1 = clock.p1 + 1;
  ldv_38146: ;
  if (clock.p1 <= (int )limit->p1.max) {
    goto ldv_38145;
  } else {
    goto ldv_38147;
  }
  ldv_38147:
  clock.n = clock.n + 1;
  ldv_38149: ;
  if (clock.n <= (int )limit->n.max) {
    goto ldv_38148;
  } else {
    goto ldv_38150;
  }
  ldv_38150:
  clock.m2 = clock.m2 + 1;
  ldv_38152: ;
  if (clock.m2 <= (int )limit->m2.max) {
    goto ldv_38151;
  } else {
    goto ldv_38138;
  }
  ldv_38138:
  clock.m1 = clock.m1 + 1;
  ldv_38154: ;
  if (clock.m1 <= (int )limit->m1.max) {
    goto ldv_38153;
  } else {
    goto ldv_38155;
  }
  ldv_38155: ;
  return ((bool )(err != target));
}
}
static bool intel_g4x_find_best_PLL(intel_limit_t const *limit , struct drm_crtc *crtc ,
                                    int target , int refclk , intel_clock_t *best_clock )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  intel_clock_t clock ;
  int max_n ;
  bool found ;
  int err_most ;
  int lvds_reg ;
  u32 tmp ;
  bool tmp___0 ;
  int this_err ;
  bool tmp___1 ;
  int tmp___2 ;
  long ret ;
  int __x___0 ;
  int tmp___3 ;
  {
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  err_most = (target >> 8) + (target >> 9);
  found = (bool )0;
  tmp___0 = intel_pipe_has_type(crtc, 4);
  }
  if ((int )tmp___0) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
      lvds_reg = 921984;
    } else
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
      lvds_reg = 921984;
    } else
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
      lvds_reg = 921984;
    } else {
      lvds_reg = 397696;
    }
    {
    tmp = i915_read32___6(dev_priv, (u32 )lvds_reg);
    }
    if ((tmp & 48U) == 48U) {
      clock.p2 = (int )limit->p2.p2_fast;
    } else {
      clock.p2 = (int )limit->p2.p2_slow;
    }
  } else
  if ((int )limit->p2.dot_limit > target) {
    clock.p2 = (int )limit->p2.p2_slow;
  } else {
    clock.p2 = (int )limit->p2.p2_fast;
  }
  {
  memset((void *)best_clock, 0, 36UL);
  max_n = (int )limit->n.max;
  clock.n = (int )limit->n.min;
  }
  goto ldv_38186;
  ldv_38185:
  clock.m1 = (int )limit->m1.max;
  goto ldv_38183;
  ldv_38182:
  clock.m2 = (int )limit->m2.max;
  goto ldv_38180;
  ldv_38179:
  clock.p1 = (int )limit->p1.max;
  goto ldv_38177;
  ldv_38176:
  {
  intel_clock(dev, refclk, & clock);
  tmp___1 = intel_PLL_is_valid(dev, limit, (intel_clock_t const *)(& clock));
  }
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    goto ldv_38171;
  } else {
  }
  __x___0 = clock.dot - target;
  if (__x___0 < 0) {
    tmp___3 = - __x___0;
  } else {
    tmp___3 = __x___0;
  }
  ret = (long )tmp___3;
  this_err = (int )ret;
  if (this_err < err_most) {
    *best_clock = clock;
    err_most = this_err;
    max_n = clock.n;
    found = (bool )1;
  } else {
  }
  ldv_38171:
  clock.p1 = clock.p1 - 1;
  ldv_38177: ;
  if (clock.p1 >= (int )limit->p1.min) {
    goto ldv_38176;
  } else {
    goto ldv_38178;
  }
  ldv_38178:
  clock.m2 = clock.m2 - 1;
  ldv_38180: ;
  if (clock.m2 >= (int )limit->m2.min) {
    goto ldv_38179;
  } else {
    goto ldv_38181;
  }
  ldv_38181:
  clock.m1 = clock.m1 - 1;
  ldv_38183: ;
  if (clock.m1 >= (int )limit->m1.min) {
    goto ldv_38182;
  } else {
    goto ldv_38184;
  }
  ldv_38184:
  clock.n = clock.n + 1;
  ldv_38186: ;
  if (clock.n <= max_n) {
    goto ldv_38185;
  } else {
    goto ldv_38187;
  }
  ldv_38187: ;
  return (found);
}
}
static bool intel_find_pll_ironlake_dp(intel_limit_t const *limit , struct drm_crtc *crtc ,
                                       int target , int refclk , intel_clock_t *best_clock )
{ struct drm_device *dev ;
  intel_clock_t clock ;
  size_t __len ;
  void *__ret ;
  {
  dev = crtc->dev;
  if (target <= 199999) {
    clock.n = 1;
    clock.p1 = 2;
    clock.p2 = 10;
    clock.m1 = 12;
    clock.m2 = 9;
  } else {
    clock.n = 2;
    clock.p1 = 1;
    clock.p2 = 10;
    clock.m1 = 14;
    clock.m2 = 8;
  }
  {
  intel_clock(dev, refclk, & clock);
  __len = 36UL;
  }
  if (__len > 63UL) {
    {
    __ret = memcpy((void *)best_clock, (void const *)(& clock), __len);
    }
  } else {
    {
    __ret = memcpy((void *)best_clock, (void const *)(& clock), __len);
    }
  }
  return ((bool )1);
}
}
static bool intel_find_pll_g4x_dp(intel_limit_t const *limit , struct drm_crtc *crtc ,
                                  int target , int refclk , intel_clock_t *best_clock )
{ intel_clock_t clock ;
  size_t __len ;
  void *__ret ;
  {
  if (target <= 199999) {
    clock.p1 = 2;
    clock.p2 = 10;
    clock.n = 2;
    clock.m1 = 23;
    clock.m2 = 8;
  } else {
    clock.p1 = 1;
    clock.p2 = 10;
    clock.n = 1;
    clock.m1 = 14;
    clock.m2 = 2;
  }
  clock.m = (clock.m1 * 5 + 10) + (clock.m2 + 2);
  clock.p = clock.p1 * clock.p2;
  clock.dot = ((clock.m * 96000) / (clock.n + 2)) / clock.p;
  clock.vco = 0;
  __len = 36UL;
  if (__len > 63UL) {
    {
    __ret = memcpy((void *)best_clock, (void const *)(& clock), __len);
    }
  } else {
    {
    __ret = memcpy((void *)best_clock, (void const *)(& clock), __len);
    }
  }
  return ((bool )1);
}
}
void intel_wait_for_vblank(struct drm_device *dev , int pipe )
{ struct drm_i915_private *dev_priv ;
  int pipestat_reg ;
  u32 tmp ;
  unsigned long timeout__ ;
  unsigned long tmp___0 ;
  int ret__ ;
  struct thread_info *tmp___1 ;
  int pfo_ret__ ;
  int tmp___2 ;
  u32 tmp___3 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  pipestat_reg = pipe * 4096 + 458788;
  tmp = i915_read32___6(dev_priv, (u32 )pipestat_reg);
  i915_write32___4(dev_priv, (u32 )pipestat_reg, tmp | 2U);
  tmp___0 = msecs_to_jiffies((unsigned int const )50U);
  timeout__ = tmp___0 + (unsigned long )jiffies;
  ret__ = 0;
  }
  goto ldv_38235;
  ldv_38234: ;
  if ((long )timeout__ - (long )jiffies < 0L) {
    ret__ = -110;
    goto ldv_38225;
  } else {
  }
  {
  tmp___1 = current_thread_info();
  }
  if ((tmp___1->preempt_count & -268435457) == 0) {
    if (1) {
      goto case_4;
    } else {
      goto switch_default;
      if (0) {
        __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
        goto ldv_38228;
        __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_38228;
        case_4:
        __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_38228;
        __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_38228;
        switch_default:
        {
        __bad_percpu_size();
        }
      } else {
      }
    }
    ldv_38228:
    {
    tmp___2 = atomic_read((atomic_t const *)(& kgdb_active));
    }
    if (pfo_ret__ != tmp___2) {
      {
      msleep(1U);
      }
    } else {
    }
  } else {
  }
  ldv_38235:
  {
  tmp___3 = i915_read32___6(dev_priv, (u32 )pipestat_reg);
  }
  if (((unsigned long )tmp___3 & 2UL) == 0UL) {
    goto ldv_38234;
  } else {
    goto ldv_38225;
  }
  ldv_38225: ;
  if (ret__ != 0) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_wait_for_vblank", "vblank wait timed out\n");
    }
  } else {
  }
  return;
}
}
void intel_wait_for_pipe_off(struct drm_device *dev , int pipe )
{ struct drm_i915_private *dev_priv ;
  int reg ;
  unsigned long timeout__ ;
  unsigned long tmp ;
  int ret__ ;
  struct thread_info *tmp___0 ;
  int pfo_ret__ ;
  int tmp___1 ;
  u32 tmp___2 ;
  u32 last_line ;
  int reg___0 ;
  unsigned long timeout ;
  unsigned long tmp___3 ;
  u32 tmp___4 ;
  unsigned long __ms ;
  unsigned long tmp___5 ;
  u32 tmp___6 ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    {
    reg = pipe * 4096 + 458760;
    tmp = msecs_to_jiffies((unsigned int const )100U);
    timeout__ = tmp + (unsigned long )jiffies;
    ret__ = 0;
    }
    goto ldv_38262;
    ldv_38261: ;
    if ((long )timeout__ - (long )jiffies < 0L) {
      ret__ = -110;
      goto ldv_38252;
    } else {
    }
    {
    tmp___0 = current_thread_info();
    }
    if ((tmp___0->preempt_count & -268435457) == 0) {
      if (1) {
        goto case_4;
      } else {
        goto switch_default;
        if (0) {
          __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
          goto ldv_38255;
          __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
          goto ldv_38255;
          case_4:
          __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
          goto ldv_38255;
          __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
          goto ldv_38255;
          switch_default:
          {
          __bad_percpu_size();
          }
        } else {
        }
      }
      ldv_38255:
      {
      tmp___1 = atomic_read((atomic_t const *)(& kgdb_active));
      }
      if (pfo_ret__ != tmp___1) {
        {
        msleep(1U);
        }
      } else {
      }
    } else {
    }
    ldv_38262:
    {
    tmp___2 = i915_read32___6(dev_priv, (u32 )reg);
    }
    if ((tmp___2 & 1073741824U) != 0U) {
      goto ldv_38261;
    } else {
      goto ldv_38252;
    }
    ldv_38252: ;
    if (ret__ != 0) {
      {
      drm_ut_debug_printk(4U, "drm", "intel_wait_for_pipe_off", "pipe_off wait timed out\n");
      }
    } else {
    }
  } else {
    {
    reg___0 = (pipe + 112) * 4096;
    tmp___3 = msecs_to_jiffies((unsigned int const )100U);
    timeout = tmp___3 + (unsigned long )jiffies;
    }
    ldv_38278:
    {
    tmp___4 = i915_read32___6(dev_priv, (u32 )reg___0);
    last_line = tmp___4 & 4095U;
    }
    if (1) {
      {
      __const_udelay(21475000UL);
      }
    } else {
      __ms = 5UL;
      goto ldv_38270;
      ldv_38269:
      {
      __const_udelay(4295000UL);
      }
      ldv_38270:
      tmp___5 = __ms;
      __ms = __ms - 1UL;
      if (tmp___5 != 0UL) {
        goto ldv_38269;
      } else {
        goto ldv_38271;
      }
      ldv_38271: ;
    }
    {
    tmp___6 = i915_read32___6(dev_priv, (u32 )reg___0);
    }
    if ((tmp___6 & 4095U) != last_line) {
      if ((long )jiffies - (long )timeout < 0L) {
        goto ldv_38278;
      } else {
        goto ldv_38279;
      }
    } else {
      goto ldv_38279;
    }
    ldv_38279: ;
    if ((long )timeout - (long )jiffies < 0L) {
      {
      drm_ut_debug_printk(4U, "drm", "intel_wait_for_pipe_off", "pipe_off wait timed out\n");
      }
    } else {
    }
  }
  return;
}
}
static char const *state_string(bool enabled )
{ char const *tmp ;
  {
  if ((int )enabled) {
    tmp = "on";
  } else {
    tmp = "off";
  }
  return (tmp);
}
}
static void assert_pll(struct drm_i915_private *dev_priv , enum pipe pipe , bool state )
{ int reg ;
  u32 val ;
  bool cur_state ;
  int __ret_warn_on ;
  char const *tmp ;
  char const *tmp___0 ;
  long tmp___1 ;
  {
  {
  reg = (int )(((unsigned int )pipe + 6149U) * 4U);
  val = i915_read32___6(dev_priv, (u32 )reg);
  cur_state = (bool )((int )val < 0);
  __ret_warn_on = (int )cur_state != (int )state;
  tmp___1 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp___1 != 0L) {
    {
    tmp = state_string((bool )((int )cur_state));
    tmp___0 = state_string((bool )((int )state));
    warn_slowpath_fmt("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p",
                      (int const )799, "PLL state assertion failure (expected %s, current %s)\n",
                      tmp___0, tmp);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  return;
}
}
static void assert_pch_pll(struct drm_i915_private *dev_priv , enum pipe pipe , bool state )
{ int reg ;
  u32 val ;
  bool cur_state ;
  int __ret_warn_on ;
  char const *tmp ;
  char const *tmp___0 ;
  long tmp___1 ;
  {
  {
  reg = (int )(((unsigned int )pipe + 202757U) * 4U);
  val = i915_read32___6(dev_priv, (u32 )reg);
  cur_state = (bool )((int )val < 0);
  __ret_warn_on = (int )cur_state != (int )state;
  tmp___1 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp___1 != 0L) {
    {
    tmp = state_string((bool )((int )cur_state));
    tmp___0 = state_string((bool )((int )state));
    warn_slowpath_fmt("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p",
                      (int const )817, "PCH PLL state assertion failure (expected %s, current %s)\n",
                      tmp___0, tmp);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  return;
}
}
static void assert_fdi_tx(struct drm_i915_private *dev_priv , enum pipe pipe , bool state )
{ int reg ;
  u32 val ;
  bool cur_state ;
  int __ret_warn_on ;
  char const *tmp ;
  char const *tmp___0 ;
  long tmp___1 ;
  {
  {
  reg = (int )((unsigned int )pipe * 4096U + 393472U);
  val = i915_read32___6(dev_priv, (u32 )reg);
  cur_state = (bool )((int )val < 0);
  __ret_warn_on = (int )cur_state != (int )state;
  tmp___1 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp___1 != 0L) {
    {
    tmp = state_string((bool )((int )cur_state));
    tmp___0 = state_string((bool )((int )state));
    warn_slowpath_fmt("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p",
                      (int const )834, "FDI TX state assertion failure (expected %s, current %s)\n",
                      tmp___0, tmp);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  return;
}
}
static void assert_fdi_rx(struct drm_i915_private *dev_priv , enum pipe pipe , bool state )
{ int reg ;
  u32 val ;
  bool cur_state ;
  int __ret_warn_on ;
  char const *tmp ;
  char const *tmp___0 ;
  long tmp___1 ;
  {
  {
  reg = (int )((unsigned int )pipe * 4096U + 983052U);
  val = i915_read32___6(dev_priv, (u32 )reg);
  cur_state = (bool )((int )val < 0);
  __ret_warn_on = (int )cur_state != (int )state;
  tmp___1 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp___1 != 0L) {
    {
    tmp = state_string((bool )((int )cur_state));
    tmp___0 = state_string((bool )((int )state));
    warn_slowpath_fmt("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p",
                      (int const )851, "FDI RX state assertion failure (expected %s, current %s)\n",
                      tmp___0, tmp);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  return;
}
}
static void assert_fdi_tx_pll_enabled(struct drm_i915_private *dev_priv , enum pipe pipe )
{ int reg ;
  u32 val ;
  int __ret_warn_on ;
  long tmp ;
  {
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) == 5U) {
    return;
  } else {
  }
  {
  reg = (int )((unsigned int )pipe * 4096U + 393472U);
  val = i915_read32___6(dev_priv, (u32 )reg);
  __ret_warn_on = (val & 16384U) == 0U;
  tmp = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp != 0L) {
    {
    warn_slowpath_fmt("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p",
                      (int const )868, "FDI TX PLL assertion failure, should be active but is disabled\n");
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  return;
}
}
static void assert_fdi_rx_pll_enabled(struct drm_i915_private *dev_priv , enum pipe pipe )
{ int reg ;
  u32 val ;
  int __ret_warn_on ;
  long tmp ;
  {
  {
  reg = (int )((unsigned int )pipe * 4096U + 983052U);
  val = i915_read32___6(dev_priv, (u32 )reg);
  __ret_warn_on = (val & 8192U) == 0U;
  tmp = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp != 0L) {
    {
    warn_slowpath_fmt("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p",
                      (int const )879, "FDI RX PLL assertion failure, should be active but is disabled\n");
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  return;
}
}
static void assert_panel_unlocked(struct drm_i915_private *dev_priv , enum pipe pipe )
{ int pp_reg ;
  int lvds_reg ;
  u32 val ;
  enum pipe panel_pipe ;
  bool locked ;
  u32 tmp ;
  int __ret_warn_on ;
  int tmp___0 ;
  long tmp___1 ;
  {
  panel_pipe = (enum pipe )0;
  locked = locked;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)(dev_priv->dev)->dev_private)->info)->gen) == 5U) {
    pp_reg = 815620;
    lvds_reg = 921984;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)(dev_priv->dev)->dev_private)->info)->gen) == 6U) {
    pp_reg = 815620;
    lvds_reg = 921984;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)(dev_priv->dev)->dev_private)->info + 2UL) != 0U) {
    pp_reg = 815620;
    lvds_reg = 921984;
  } else {
    pp_reg = 397828;
    lvds_reg = 397696;
  }
  {
  val = i915_read32___6(dev_priv, (u32 )pp_reg);
  }
  if ((val & 1U) == 0U) {
    locked = (bool )0;
  } else
  if ((val & 2882338816U) == 2882338816U) {
    locked = (bool )0;
  } else {
  }
  {
  tmp = i915_read32___6(dev_priv, (u32 )lvds_reg);
  }
  if ((tmp & 1073741824U) != 0U) {
    panel_pipe = (enum pipe )1;
  } else {
  }
  if ((unsigned int )panel_pipe == (unsigned int )pipe) {
    if ((int )locked) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  {
  __ret_warn_on = tmp___0;
  tmp___1 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp___1 != 0L) {
    {
    warn_slowpath_fmt("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p",
                      (int const )908, "panel assertion failure, pipe %c regs locked\n",
                      (unsigned int )pipe + 65U);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  return;
}
}
static void assert_pipe(struct drm_i915_private *dev_priv , enum pipe pipe , bool state )
{ int reg ;
  u32 val ;
  bool cur_state ;
  int __ret_warn_on ;
  char const *tmp ;
  char const *tmp___0 ;
  long tmp___1 ;
  {
  {
  reg = (int )((unsigned int )pipe * 4096U + 458760U);
  val = i915_read32___6(dev_priv, (u32 )reg);
  cur_state = (bool )((int )val < 0);
  __ret_warn_on = (int )cur_state != (int )state;
  tmp___1 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp___1 != 0L) {
    {
    tmp = state_string((bool )((int )cur_state));
    tmp___0 = state_string((bool )((int )state));
    warn_slowpath_fmt("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p",
                      (int const )923, "pipe %c assertion failure (expected %s, current %s)\n",
                      (unsigned int )pipe + 65U, tmp___0, tmp);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  return;
}
}
static void assert_plane_enabled(struct drm_i915_private *dev_priv , enum plane plane )
{ int reg ;
  u32 val ;
  int __ret_warn_on ;
  long tmp ;
  {
  {
  reg = (int )((unsigned int )plane * 4096U + 459136U);
  val = i915_read32___6(dev_priv, (u32 )reg);
  __ret_warn_on = (int )val >= 0;
  tmp = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp != 0L) {
    {
    warn_slowpath_fmt("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p",
                      (int const )938, "plane %c assertion failure, should be active but is disabled\n",
                      (unsigned int )plane + 65U);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  return;
}
}
static void assert_planes_disabled(struct drm_i915_private *dev_priv , enum pipe pipe )
{ int reg ;
  int i ;
  u32 val ;
  int cur_pipe ;
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  {
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)(dev_priv->dev)->dev_private)->info)->gen) == 5U) {
    return;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)(dev_priv->dev)->dev_private)->info)->gen) == 6U) {
    return;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)(dev_priv->dev)->dev_private)->info + 2UL) != 0U) {
    return;
  } else {
  }
  i = 0;
  goto ldv_38385;
  ldv_38384:
  {
  reg = i * 4096 + 459136;
  val = i915_read32___6(dev_priv, (u32 )reg);
  cur_pipe = (int )((val & 50331648U) >> 24);
  }
  if ((int )val < 0) {
    if ((unsigned int )cur_pipe == (unsigned int )pipe) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  {
  __ret_warn_on = tmp;
  tmp___0 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp___0 != 0L) {
    {
    warn_slowpath_fmt("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p",
                      (int const )960, "plane %c assertion failure, should be off on pipe %c but is still active\n",
                      i + 65, (unsigned int )pipe + 65U);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on != 0), 0L);
  i = i + 1;
  }
  ldv_38385: ;
  if (i <= 1) {
    goto ldv_38384;
  } else {
    goto ldv_38386;
  }
  ldv_38386: ;
  return;
}
}
static void assert_pch_refclk_enabled(struct drm_i915_private *dev_priv )
{ u32 val ;
  bool enabled ;
  int __ret_warn_on ;
  long tmp ;
  {
  {
  val = i915_read32___6(dev_priv, 811520U);
  enabled = (bool )((val & 8064U) != 0U);
  __ret_warn_on = ! enabled;
  tmp = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp != 0L) {
    {
    warn_slowpath_fmt("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p",
                      (int const )972, "PCH refclk assertion failure, should be active but is disabled\n");
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  return;
}
}
static void assert_transcoder_disabled(struct drm_i915_private *dev_priv , enum pipe pipe )
{ int reg ;
  u32 val ;
  bool enabled ;
  int __ret_warn_on ;
  long tmp ;
  {
  {
  reg = (int )((unsigned int )pipe * 4096U + 983048U);
  val = i915_read32___6(dev_priv, (u32 )reg);
  enabled = (bool )((int )val < 0);
  __ret_warn_on = (int )enabled;
  tmp = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp != 0L) {
    {
    warn_slowpath_fmt("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p",
                      (int const )987, "transcoder assertion failed, should be off on pipe %c but is still active\n",
                      (unsigned int )pipe + 65U);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  return;
}
}
static void assert_pch_dp_disabled(struct drm_i915_private *dev_priv , enum pipe pipe ,
                                   int reg )
{ u32 val ;
  u32 tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  {
  {
  tmp = i915_read32___6(dev_priv, (u32 )reg);
  val = tmp;
  __ret_warn_on = (val & 3221225472U) == (((unsigned int )pipe << 30) | 2147483648U);
  tmp___0 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp___0 != 0L) {
    {
    warn_slowpath_fmt("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p",
                      (int const )996, "PCH DP (0x%08x) enabled on transcoder %c, should be disabled\n",
                      reg, (unsigned int )pipe + 65U);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  return;
}
}
static void assert_pch_hdmi_disabled(struct drm_i915_private *dev_priv , enum pipe pipe ,
                                     int reg )
{ u32 val ;
  u32 tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  {
  {
  tmp = i915_read32___6(dev_priv, (u32 )reg);
  val = tmp;
  __ret_warn_on = (val & 3221225472U) == (((unsigned int )pipe << 30) | 2147483648U);
  tmp___0 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp___0 != 0L) {
    {
    warn_slowpath_fmt("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p",
                      (int const )1005, "PCH DP (0x%08x) enabled on transcoder %c, should be disabled\n",
                      reg, (unsigned int )pipe + 65U);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  return;
}
}
static void assert_pch_ports_disabled(struct drm_i915_private *dev_priv , enum pipe pipe )
{ int reg ;
  u32 val ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;
  {
  {
  assert_pch_dp_disabled(dev_priv, pipe, 934144);
  assert_pch_dp_disabled(dev_priv, pipe, 934400);
  assert_pch_dp_disabled(dev_priv, pipe, 934656);
  reg = 921856;
  val = i915_read32___6(dev_priv, (u32 )reg);
  __ret_warn_on = (val & 3221225472U) == (((unsigned int )pipe << 30) | 2147483648U);
  tmp = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp != 0L) {
    {
    warn_slowpath_fmt("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p",
                      (int const )1022, "PCH VGA enabled on transcoder %c, should be disabled\n",
                      (unsigned int )pipe + 65U);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on != 0), 0L);
  reg = 921984;
  val = i915_read32___6(dev_priv, (u32 )reg);
  __ret_warn_on___0 = (val & 3221225472U) == (((unsigned int )pipe << 30) | 2147483648U);
  tmp___0 = __builtin_expect((long )(__ret_warn_on___0 != 0), 0L);
  }
  if (tmp___0 != 0L) {
    {
    warn_slowpath_fmt("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p",
                      (int const )1028, "PCH LVDS enabled on transcoder %c, should be disabled\n",
                      (unsigned int )pipe + 65U);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on___0 != 0), 0L);
  assert_pch_hdmi_disabled(dev_priv, pipe, 921920);
  assert_pch_hdmi_disabled(dev_priv, pipe, 921936);
  assert_pch_hdmi_disabled(dev_priv, pipe, 921952);
  }
  return;
}
}
static void intel_enable_pll(struct drm_i915_private *dev_priv , enum pipe pipe )
{ int reg ;
  u32 val ;
  long tmp ;
  {
  {
  tmp = __builtin_expect((long )((unsigned int )((unsigned char )(dev_priv->info)->gen) > 4U),
                         0L);
  }
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p"),
                         "i" (1052), "i" (12UL));
    ldv_38435: ;
    goto ldv_38435;
  } else {
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)(dev_priv->dev)->dev_private)->info + 1UL) != 0U) {
    if ((dev_priv->dev)->pci_device != 13687) {
      {
      assert_panel_unlocked(dev_priv, pipe);
      }
    } else {
    }
  } else {
  }
  {
  reg = (int )(((unsigned int )pipe + 6149U) * 4U);
  val = i915_read32___6(dev_priv, (u32 )reg);
  val = val | 2147483648U;
  i915_write32___4(dev_priv, (u32 )reg, val);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  __const_udelay(644250UL);
  i915_write32___4(dev_priv, (u32 )reg, val);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  __const_udelay(644250UL);
  i915_write32___4(dev_priv, (u32 )reg, val);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  __const_udelay(644250UL);
  }
  return;
}
}
static void intel_disable_pll(struct drm_i915_private *dev_priv , enum pipe pipe )
{ int reg ;
  u32 val ;
  {
  if ((unsigned int )pipe == 0U) {
    if ((int )dev_priv->quirks & 1) {
      return;
    } else {
    }
  } else {
  }
  {
  assert_pipe(dev_priv, pipe, (bool )0);
  reg = (int )(((unsigned int )pipe + 6149U) * 4U);
  val = i915_read32___6(dev_priv, (u32 )reg);
  val = val & 2147483647U;
  i915_write32___4(dev_priv, (u32 )reg, val);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  }
  return;
}
}
static void intel_enable_pch_pll(struct drm_i915_private *dev_priv , enum pipe pipe )
{ int reg ;
  u32 val ;
  long tmp ;
  {
  {
  tmp = __builtin_expect((long )((unsigned int )((unsigned char )(dev_priv->info)->gen) <= 4U),
                         0L);
  }
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p"),
                         "i" (1117), "i" (12UL));
    ldv_38448: ;
    goto ldv_38448;
  } else {
  }
  {
  assert_pch_refclk_enabled(dev_priv);
  reg = (int )(((unsigned int )pipe + 202757U) * 4U);
  val = i915_read32___6(dev_priv, (u32 )reg);
  val = val | 2147483648U;
  i915_write32___4(dev_priv, (u32 )reg, val);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  __const_udelay(859000UL);
  }
  return;
}
}
static void intel_disable_pch_pll(struct drm_i915_private *dev_priv , enum pipe pipe )
{ int reg ;
  u32 val ;
  long tmp ;
  {
  {
  tmp = __builtin_expect((long )((unsigned int )((unsigned char )(dev_priv->info)->gen) <= 4U),
                         0L);
  }
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p"),
                         "i" (1137), "i" (12UL));
    ldv_38455: ;
    goto ldv_38455;
  } else {
  }
  {
  assert_transcoder_disabled(dev_priv, pipe);
  reg = (int )(((unsigned int )pipe + 202757U) * 4U);
  val = i915_read32___6(dev_priv, (u32 )reg);
  val = val & 2147483647U;
  i915_write32___4(dev_priv, (u32 )reg, val);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  __const_udelay(859000UL);
  }
  return;
}
}
static void intel_enable_transcoder(struct drm_i915_private *dev_priv , enum pipe pipe )
{ int reg ;
  u32 val ;
  long tmp ;
  u32 tmp___0 ;
  unsigned long timeout__ ;
  unsigned long tmp___1 ;
  int ret__ ;
  struct thread_info *tmp___2 ;
  int pfo_ret__ ;
  int tmp___3 ;
  u32 tmp___4 ;
  {
  {
  tmp = __builtin_expect((long )((unsigned int )((unsigned char )(dev_priv->info)->gen) <= 4U),
                         0L);
  }
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p"),
                         "i" (1157), "i" (12UL));
    ldv_38462: ;
    goto ldv_38462;
  } else {
  }
  {
  assert_pch_pll(dev_priv, pipe, (bool )1);
  assert_fdi_tx(dev_priv, pipe, (bool )1);
  assert_fdi_rx(dev_priv, pipe, (bool )1);
  reg = (int )((unsigned int )pipe * 4096U + 983048U);
  val = i915_read32___6(dev_priv, (u32 )reg);
  val = val & 4294967071U;
  tmp___0 = i915_read32___6(dev_priv, (unsigned int )pipe * 4096U + 458760U);
  val = (tmp___0 & 224U) | val;
  i915_write32___4(dev_priv, (u32 )reg, val | 2147483648U);
  tmp___1 = msecs_to_jiffies((unsigned int const )100U);
  timeout__ = tmp___1 + (unsigned long )jiffies;
  ret__ = 0;
  }
  goto ldv_38481;
  ldv_38480: ;
  if ((long )timeout__ - (long )jiffies < 0L) {
    ret__ = -110;
    goto ldv_38471;
  } else {
  }
  {
  tmp___2 = current_thread_info();
  }
  if ((tmp___2->preempt_count & -268435457) == 0) {
    if (1) {
      goto case_4;
    } else {
      goto switch_default;
      if (0) {
        __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
        goto ldv_38474;
        __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_38474;
        case_4:
        __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_38474;
        __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_38474;
        switch_default:
        {
        __bad_percpu_size();
        }
      } else {
      }
    }
    ldv_38474:
    {
    tmp___3 = atomic_read((atomic_t const *)(& kgdb_active));
    }
    if (pfo_ret__ != tmp___3) {
      {
      msleep(1U);
      }
    } else {
    }
  } else {
  }
  ldv_38481:
  {
  tmp___4 = i915_read32___6(dev_priv, (u32 )reg);
  }
  if ((tmp___4 & 1073741824U) == 0U) {
    goto ldv_38480;
  } else {
    goto ldv_38471;
  }
  ldv_38471: ;
  if (ret__ != 0) {
    {
    drm_err("intel_enable_transcoder", "failed to enable transcoder %d\n", (unsigned int )pipe);
    }
  } else {
  }
  return;
}
}
static void intel_disable_transcoder(struct drm_i915_private *dev_priv , enum pipe pipe )
{ int reg ;
  u32 val ;
  unsigned long timeout__ ;
  unsigned long tmp ;
  int ret__ ;
  struct thread_info *tmp___0 ;
  int pfo_ret__ ;
  int tmp___1 ;
  u32 tmp___2 ;
  {
  {
  assert_fdi_tx(dev_priv, pipe, (bool )0);
  assert_fdi_rx(dev_priv, pipe, (bool )0);
  assert_pch_ports_disabled(dev_priv, pipe);
  reg = (int )((unsigned int )pipe * 4096U + 983048U);
  val = i915_read32___6(dev_priv, (u32 )reg);
  val = val & 2147483647U;
  i915_write32___4(dev_priv, (u32 )reg, val);
  tmp = msecs_to_jiffies((unsigned int const )50U);
  timeout__ = tmp + (unsigned long )jiffies;
  ret__ = 0;
  }
  goto ldv_38508;
  ldv_38507: ;
  if ((long )timeout__ - (long )jiffies < 0L) {
    ret__ = -110;
    goto ldv_38498;
  } else {
  }
  {
  tmp___0 = current_thread_info();
  }
  if ((tmp___0->preempt_count & -268435457) == 0) {
    if (1) {
      goto case_4;
    } else {
      goto switch_default;
      if (0) {
        __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
        goto ldv_38501;
        __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_38501;
        case_4:
        __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_38501;
        __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_38501;
        switch_default:
        {
        __bad_percpu_size();
        }
      } else {
      }
    }
    ldv_38501:
    {
    tmp___1 = atomic_read((atomic_t const *)(& kgdb_active));
    }
    if (pfo_ret__ != tmp___1) {
      {
      msleep(1U);
      }
    } else {
    }
  } else {
  }
  ldv_38508:
  {
  tmp___2 = i915_read32___6(dev_priv, (u32 )reg);
  }
  if ((tmp___2 & 1073741824U) != 0U) {
    goto ldv_38507;
  } else {
    goto ldv_38498;
  }
  ldv_38498: ;
  if (ret__ != 0) {
    {
    drm_err("intel_disable_transcoder", "failed to disable transcoder\n");
    }
  } else {
  }
  return;
}
}
static void intel_enable_pipe(struct drm_i915_private *dev_priv , enum pipe pipe ,
                              bool pch_port )
{ int reg ;
  u32 val ;
  {
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)(dev_priv->dev)->dev_private)->info)->gen) != 5U) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)(dev_priv->dev)->dev_private)->info)->gen) != 6U) {
      if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)(dev_priv->dev)->dev_private)->info + 2UL) == 0U) {
        {
        assert_pll(dev_priv, pipe, (bool )1);
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else
  _L___0:
  if ((int )pch_port) {
    {
    assert_fdi_rx_pll_enabled(dev_priv, pipe);
    assert_fdi_tx_pll_enabled(dev_priv, pipe);
    }
  } else {
  }
  {
  reg = (int )((unsigned int )pipe * 4096U + 458760U);
  val = i915_read32___6(dev_priv, (u32 )reg);
  }
  if ((int )val < 0) {
    return;
  } else {
  }
  {
  i915_write32___4(dev_priv, (u32 )reg, val | 2147483648U);
  intel_wait_for_vblank(dev_priv->dev, (int )pipe);
  }
  return;
}
}
static void intel_disable_pipe(struct drm_i915_private *dev_priv , enum pipe pipe )
{ int reg ;
  u32 val ;
  {
  {
  assert_planes_disabled(dev_priv, pipe);
  }
  if ((unsigned int )pipe == 0U) {
    if ((int )dev_priv->quirks & 1) {
      return;
    } else {
    }
  } else {
  }
  {
  reg = (int )((unsigned int )pipe * 4096U + 458760U);
  val = i915_read32___6(dev_priv, (u32 )reg);
  }
  if ((int )val >= 0) {
    return;
  } else {
  }
  {
  i915_write32___4(dev_priv, (u32 )reg, val & 2147483647U);
  intel_wait_for_pipe_off(dev_priv->dev, (int )pipe);
  }
  return;
}
}
static void intel_enable_plane(struct drm_i915_private *dev_priv , enum plane plane ,
                               enum pipe pipe )
{ int reg ;
  u32 val ;
  {
  {
  assert_pipe(dev_priv, pipe, (bool )1);
  reg = (int )((unsigned int )plane * 4096U + 459136U);
  val = i915_read32___6(dev_priv, (u32 )reg);
  }
  if ((int )val < 0) {
    return;
  } else {
  }
  {
  i915_write32___4(dev_priv, (u32 )reg, val | 2147483648U);
  intel_wait_for_vblank(dev_priv->dev, (int )pipe);
  }
  return;
}
}
static void intel_flush_display_plane(struct drm_i915_private *dev_priv , enum plane plane )
{ u32 reg ;
  u32 tmp ;
  {
  {
  reg = (unsigned int )plane * 4096U + 459140U;
  tmp = i915_read32___6(dev_priv, reg);
  i915_write32___4(dev_priv, reg, tmp);
  }
  return;
}
}
static void intel_disable_plane(struct drm_i915_private *dev_priv , enum plane plane ,
                                enum pipe pipe )
{ int reg ;
  u32 val ;
  {
  {
  reg = (int )((unsigned int )plane * 4096U + 459136U);
  val = i915_read32___6(dev_priv, (u32 )reg);
  }
  if ((int )val >= 0) {
    return;
  } else {
  }
  {
  i915_write32___4(dev_priv, (u32 )reg, val & 2147483647U);
  intel_flush_display_plane(dev_priv, plane);
  intel_wait_for_vblank(dev_priv->dev, (int )pipe);
  }
  return;
}
}
static void disable_pch_dp(struct drm_i915_private *dev_priv , enum pipe pipe , int reg )
{ u32 val ;
  u32 tmp ;
  {
  {
  tmp = i915_read32___6(dev_priv, (u32 )reg);
  val = tmp;
  }
  if ((val & 3221225472U) == (((unsigned int )pipe << 30) | 2147483648U)) {
    {
    i915_write32___4(dev_priv, (u32 )reg, val & 2147483647U);
    }
  } else {
  }
  return;
}
}
static void disable_pch_hdmi(struct drm_i915_private *dev_priv , enum pipe pipe ,
                             int reg )
{ u32 val ;
  u32 tmp ;
  {
  {
  tmp = i915_read32___6(dev_priv, (u32 )reg);
  val = tmp;
  }
  if ((val & 3221225472U) == (((unsigned int )pipe << 30) | 2147483648U)) {
    {
    i915_write32___4(dev_priv, (u32 )reg, val & 2147483647U);
    }
  } else {
  }
  return;
}
}
static void intel_disable_pch_ports(struct drm_i915_private *dev_priv , enum pipe pipe )
{ u32 reg ;
  u32 val ;
  {
  {
  val = i915_read32___6(dev_priv, 815620U);
  i915_write32___4(dev_priv, 815620U, val | 2882338816U);
  disable_pch_dp(dev_priv, pipe, 934144);
  disable_pch_dp(dev_priv, pipe, 934400);
  disable_pch_dp(dev_priv, pipe, 934656);
  reg = 921856U;
  val = i915_read32___6(dev_priv, reg);
  }
  if ((val & 3221225472U) == (((unsigned int )pipe << 30) | 2147483648U)) {
    {
    i915_write32___4(dev_priv, reg, val & 2147483647U);
    }
  } else {
  }
  {
  reg = 921984U;
  val = i915_read32___6(dev_priv, reg);
  }
  if ((val & 3221225472U) == (((unsigned int )pipe << 30) | 2147483648U)) {
    {
    i915_write32___4(dev_priv, reg, val & 2147483647U);
    readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
    __const_udelay(429500UL);
    }
  } else {
  }
  {
  disable_pch_hdmi(dev_priv, pipe, 921920);
  disable_pch_hdmi(dev_priv, pipe, 921936);
  disable_pch_hdmi(dev_priv, pipe, 921952);
  }
  return;
}
}
static void i8xx_enable_fbc(struct drm_crtc *crtc , unsigned long interval )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct drm_framebuffer *fb ;
  struct intel_framebuffer *intel_fb ;
  struct drm_framebuffer const *__mptr ;
  struct drm_i915_gem_object *obj ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr___0 ;
  int plane ;
  int i ;
  u32 fbc_ctl ;
  u32 fbc_ctl2 ;
  u32 tmp ;
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  fb = crtc->fb;
  __mptr = (struct drm_framebuffer const *)fb;
  intel_fb = (struct intel_framebuffer *)__mptr;
  obj = intel_fb->obj;
  __mptr___0 = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr___0;
  if ((unsigned long )fb->pitch == dev_priv->cfb_pitch) {
    if ((int )obj->fence_reg == dev_priv->cfb_fence) {
      if ((unsigned int )intel_crtc->plane == (unsigned int )dev_priv->cfb_plane) {
        {
        tmp = i915_read32___6(dev_priv, 12808U);
        }
        if ((int )tmp < 0) {
          return;
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  i8xx_disable_fbc(dev);
  dev_priv->cfb_pitch = dev_priv->cfb_size / 1536UL;
  }
  if ((unsigned long )fb->pitch < dev_priv->cfb_pitch) {
    dev_priv->cfb_pitch = (unsigned long )fb->pitch;
  } else {
  }
  dev_priv->cfb_pitch = dev_priv->cfb_pitch / 64UL - 1UL;
  dev_priv->cfb_fence = (int )obj->fence_reg;
  dev_priv->cfb_plane = (int )intel_crtc->plane;
  plane = dev_priv->cfb_plane != 0;
  i = 0;
  goto ldv_38580;
  ldv_38579:
  {
  i915_write32___4(dev_priv, (u32 )((i + 3264) * 4), 0U);
  i = i + 1;
  }
  ldv_38580: ;
  if (i <= 48) {
    goto ldv_38579;
  } else {
    goto ldv_38581;
  }
  ldv_38581:
  fbc_ctl2 = (u32 )plane;
  if ((unsigned int )*((unsigned char *)obj + 225UL) != 0U) {
    fbc_ctl2 = fbc_ctl2 | 2U;
  } else {
  }
  {
  i915_write32___4(dev_priv, 12820U, fbc_ctl2);
  i915_write32___4(dev_priv, 12827U, (u32 )crtc->y);
  fbc_ctl = 3221225472U;
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    fbc_ctl = fbc_ctl | 8192U;
  } else {
  }
  fbc_ctl = (((u32 )dev_priv->cfb_pitch & 255U) << 5U) | fbc_ctl;
  fbc_ctl = (((u32 )interval & 12287U) << 16U) | fbc_ctl;
  if ((unsigned int )*((unsigned char *)obj + 225UL) != 0U) {
    fbc_ctl = (u32 )dev_priv->cfb_fence | fbc_ctl;
  } else {
  }
  {
  i915_write32___4(dev_priv, 12808U, fbc_ctl);
  drm_ut_debug_printk(4U, "drm", "i8xx_enable_fbc", "enabled FBC, pitch %ld, yoff %d, plane %d, ",
                      dev_priv->cfb_pitch, crtc->y, dev_priv->cfb_plane);
  }
  return;
}
}
void i8xx_disable_fbc(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 fbc_ctl ;
  unsigned long timeout__ ;
  unsigned long tmp ;
  int ret__ ;
  struct thread_info *tmp___0 ;
  int pfo_ret__ ;
  int tmp___1 ;
  u32 tmp___2 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  fbc_ctl = i915_read32___6(dev_priv, 12808U);
  }
  if ((int )fbc_ctl >= 0) {
    return;
  } else {
  }
  {
  fbc_ctl = fbc_ctl & 2147483647U;
  i915_write32___4(dev_priv, 12808U, fbc_ctl);
  tmp = msecs_to_jiffies((unsigned int const )10U);
  timeout__ = tmp + (unsigned long )jiffies;
  ret__ = 0;
  }
  goto ldv_38606;
  ldv_38605: ;
  if ((long )timeout__ - (long )jiffies < 0L) {
    ret__ = -110;
    goto ldv_38596;
  } else {
  }
  {
  tmp___0 = current_thread_info();
  }
  if ((tmp___0->preempt_count & -268435457) == 0) {
    if (1) {
      goto case_4;
    } else {
      goto switch_default;
      if (0) {
        __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
        goto ldv_38599;
        __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_38599;
        case_4:
        __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_38599;
        __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_38599;
        switch_default:
        {
        __bad_percpu_size();
        }
      } else {
      }
    }
    ldv_38599:
    {
    tmp___1 = atomic_read((atomic_t const *)(& kgdb_active));
    }
    if (pfo_ret__ != tmp___1) {
      {
      msleep(1U);
      }
    } else {
    }
  } else {
  }
  ldv_38606:
  {
  tmp___2 = i915_read32___6(dev_priv, 12816U);
  }
  if ((int )tmp___2 < 0) {
    goto ldv_38605;
  } else {
    goto ldv_38596;
  }
  ldv_38596: ;
  if (ret__ != 0) {
    {
    drm_ut_debug_printk(4U, "drm", "i8xx_disable_fbc", "FBC idle timed out\n");
    }
    return;
  } else {
  }
  {
  drm_ut_debug_printk(4U, "drm", "i8xx_disable_fbc", "disabled FBC\n");
  }
  return;
}
}
static bool i8xx_fbc_enabled(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 tmp ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = i915_read32___6(dev_priv, 12808U);
  }
  return ((bool )((tmp & 2147483648U) != 0U));
}
}
static void g4x_enable_fbc(struct drm_crtc *crtc , unsigned long interval )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct drm_framebuffer *fb ;
  struct intel_framebuffer *intel_fb ;
  struct drm_framebuffer const *__mptr ;
  struct drm_i915_gem_object *obj ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr___0 ;
  int plane ;
  int tmp ;
  unsigned long stall_watermark ;
  u32 dpfc_ctl ;
  u32 tmp___0 ;
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  fb = crtc->fb;
  __mptr = (struct drm_framebuffer const *)fb;
  intel_fb = (struct intel_framebuffer *)__mptr;
  obj = intel_fb->obj;
  __mptr___0 = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr___0;
  if ((unsigned int )intel_crtc->plane == 0U) {
    tmp = 0;
  } else {
    tmp = 1073741824;
  }
  {
  plane = tmp;
  stall_watermark = 200UL;
  dpfc_ctl = i915_read32___6(dev_priv, 12808U);
  }
  if ((int )dpfc_ctl < 0) {
    if (dev_priv->cfb_pitch == dev_priv->cfb_pitch / 64UL - 1UL) {
      if (dev_priv->cfb_fence == (int )obj->fence_reg) {
        if ((unsigned int )dev_priv->cfb_plane == (unsigned int )intel_crtc->plane) {
          if (dev_priv->cfb_y == crtc->y) {
            return;
          } else {
          }
        } else {
        }
      } else {
      }
    } else {
    }
    {
    i915_write32___4(dev_priv, 12808U, dpfc_ctl & 2147483647U);
    intel_wait_for_vblank(dev, (int )intel_crtc->pipe);
    }
  } else {
  }
  dev_priv->cfb_pitch = dev_priv->cfb_pitch / 64UL - 1UL;
  dev_priv->cfb_fence = (int )obj->fence_reg;
  dev_priv->cfb_plane = (int )intel_crtc->plane;
  dev_priv->cfb_y = crtc->y;
  dpfc_ctl = (u32 )(plane | 1024);
  if ((unsigned int )*((unsigned char *)obj + 225UL) != 0U) {
    {
    dpfc_ctl = ((u32 )dev_priv->cfb_fence | dpfc_ctl) | 536870912U;
    i915_write32___4(dev_priv, 12836U, 2147483648U);
    }
  } else {
    {
    i915_write32___4(dev_priv, 12836U, 2147483647U);
    }
  }
  {
  i915_write32___4(dev_priv, 12812U, (((u32 )stall_watermark << 16U) | (u32 )interval) | 134217728U);
  i915_write32___4(dev_priv, 12824U, (u32 )crtc->y);
  tmp___0 = i915_read32___6(dev_priv, 12808U);
  i915_write32___4(dev_priv, 12808U, tmp___0 | 2147483648U);
  drm_ut_debug_printk(4U, "drm", "g4x_enable_fbc", "enabled fbc on plane %d\n", (unsigned int )intel_crtc->plane);
  }
  return;
}
}
void g4x_disable_fbc(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 dpfc_ctl ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  dpfc_ctl = i915_read32___6(dev_priv, 12808U);
  }
  if ((int )dpfc_ctl < 0) {
    {
    dpfc_ctl = dpfc_ctl & 2147483647U;
    i915_write32___4(dev_priv, 12808U, dpfc_ctl);
    drm_ut_debug_printk(4U, "drm", "g4x_disable_fbc", "disabled FBC\n");
    }
  } else {
  }
  return;
}
}
static bool g4x_fbc_enabled(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 tmp ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = i915_read32___6(dev_priv, 12808U);
  }
  return ((bool )((tmp & 2147483648U) != 0U));
}
}
static void sandybridge_blit_fbc_update(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 blt_ecoskpd ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  gen6_gt_force_wake_get(dev_priv);
  blt_ecoskpd = i915_read32___6(dev_priv, 139728U);
  blt_ecoskpd = blt_ecoskpd | 524288U;
  i915_write32___4(dev_priv, 139728U, blt_ecoskpd);
  blt_ecoskpd = blt_ecoskpd | 8U;
  i915_write32___4(dev_priv, 139728U, blt_ecoskpd);
  blt_ecoskpd = blt_ecoskpd & 4294443007U;
  i915_write32___4(dev_priv, 139728U, blt_ecoskpd);
  readl((void const volatile *)dev_priv->regs + 139728U);
  gen6_gt_force_wake_put(dev_priv);
  }
  return;
}
}
static void ironlake_enable_fbc(struct drm_crtc *crtc , unsigned long interval )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct drm_framebuffer *fb ;
  struct intel_framebuffer *intel_fb ;
  struct drm_framebuffer const *__mptr ;
  struct drm_i915_gem_object *obj ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr___0 ;
  int plane ;
  int tmp ;
  unsigned long stall_watermark ;
  u32 dpfc_ctl ;
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  fb = crtc->fb;
  __mptr = (struct drm_framebuffer const *)fb;
  intel_fb = (struct intel_framebuffer *)__mptr;
  obj = intel_fb->obj;
  __mptr___0 = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr___0;
  if ((unsigned int )intel_crtc->plane == 0U) {
    tmp = 0;
  } else {
    tmp = 1073741824;
  }
  {
  plane = tmp;
  stall_watermark = 200UL;
  dpfc_ctl = i915_read32___6(dev_priv, 274952U);
  }
  if ((int )dpfc_ctl < 0) {
    if (dev_priv->cfb_pitch == dev_priv->cfb_pitch / 64UL - 1UL) {
      if (dev_priv->cfb_fence == (int )obj->fence_reg) {
        if ((unsigned int )dev_priv->cfb_plane == (unsigned int )intel_crtc->plane) {
          if (dev_priv->cfb_offset == (unsigned long )obj->gtt_offset) {
            if (dev_priv->cfb_y == crtc->y) {
              return;
            } else {
            }
          } else {
          }
        } else {
        }
      } else {
      }
    } else {
    }
    {
    i915_write32___4(dev_priv, 274952U, dpfc_ctl & 2147483647U);
    intel_wait_for_vblank(dev, (int )intel_crtc->pipe);
    }
  } else {
  }
  dev_priv->cfb_pitch = dev_priv->cfb_pitch / 64UL - 1UL;
  dev_priv->cfb_fence = (int )obj->fence_reg;
  dev_priv->cfb_plane = (int )intel_crtc->plane;
  dev_priv->cfb_offset = (unsigned long )obj->gtt_offset;
  dev_priv->cfb_y = crtc->y;
  dpfc_ctl = dpfc_ctl & 536870656U;
  dpfc_ctl = dpfc_ctl | (u32 )plane;
  if ((unsigned int )*((unsigned char *)obj + 225UL) != 0U) {
    {
    dpfc_ctl = ((u32 )dev_priv->cfb_fence | dpfc_ctl) | 536870912U;
    i915_write32___4(dev_priv, 274980U, 2147483648U);
    }
  } else {
    {
    i915_write32___4(dev_priv, 274980U, 2147483647U);
    }
  }
  {
  i915_write32___4(dev_priv, 274956U, (((u32 )stall_watermark << 16U) | (u32 )interval) | 134217728U);
  i915_write32___4(dev_priv, 274968U, (u32 )crtc->y);
  i915_write32___4(dev_priv, 8488U, obj->gtt_offset | 1U);
  i915_write32___4(dev_priv, 274952U, dpfc_ctl | 2147483648U);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    i915_write32___4(dev_priv, 1048832U, (u32 )(dev_priv->cfb_fence | 536870912));
    i915_write32___4(dev_priv, 1048836U, (u32 )crtc->y);
    sandybridge_blit_fbc_update(dev);
    }
  } else {
  }
  {
  drm_ut_debug_printk(4U, "drm", "ironlake_enable_fbc", "enabled fbc on plane %d\n",
                      (unsigned int )intel_crtc->plane);
  }
  return;
}
}
void ironlake_disable_fbc(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 dpfc_ctl ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  dpfc_ctl = i915_read32___6(dev_priv, 274952U);
  }
  if ((int )dpfc_ctl < 0) {
    {
    dpfc_ctl = dpfc_ctl & 2147483647U;
    i915_write32___4(dev_priv, 274952U, dpfc_ctl);
    drm_ut_debug_printk(4U, "drm", "ironlake_disable_fbc", "disabled FBC\n");
    }
  } else {
  }
  return;
}
}
static bool ironlake_fbc_enabled(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 tmp ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = i915_read32___6(dev_priv, 274952U);
  }
  return ((bool )((tmp & 2147483648U) != 0U));
}
}
bool intel_fbc_enabled(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  bool tmp ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned long )dev_priv->display.fbc_enabled == (unsigned long )((bool (*)(struct drm_device * ))0)) {
    return ((bool )0);
  } else {
  }
  {
  tmp = (*(dev_priv->display.fbc_enabled))(dev);
  }
  return (tmp);
}
}
void intel_enable_fbc(struct drm_crtc *crtc , unsigned long interval )
{ struct drm_i915_private *dev_priv ;
  {
  dev_priv = (struct drm_i915_private *)(crtc->dev)->dev_private;
  if ((unsigned long )dev_priv->display.enable_fbc == (unsigned long )((void (*)(struct drm_crtc * ,
                                                                                 unsigned long ))0)) {
    return;
  } else {
  }
  {
  (*(dev_priv->display.enable_fbc))(crtc, interval);
  }
  return;
}
}
void intel_disable_fbc(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned long )dev_priv->display.disable_fbc == (unsigned long )((void (*)(struct drm_device * ))0)) {
    return;
  } else {
  }
  {
  (*(dev_priv->display.disable_fbc))(dev);
  }
  return;
}
}
static void intel_update_fbc(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct drm_crtc *crtc ;
  struct drm_crtc *tmp_crtc ;
  struct intel_crtc *intel_crtc ;
  struct drm_framebuffer *fb ;
  struct intel_framebuffer *intel_fb ;
  struct drm_i915_gem_object *obj ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  struct drm_crtc const *__mptr___1 ;
  struct drm_framebuffer const *__mptr___2 ;
  int pfo_ret__ ;
  int tmp ;
  bool tmp___0 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  crtc = (struct drm_crtc *)0;
  drm_ut_debug_printk(4U, "drm", "intel_update_fbc", "\n");
  }
  if (i915_powersave == 0U) {
    return;
  } else {
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) == 0U) {
    return;
  } else {
  }
  __mptr = (struct list_head const *)dev->mode_config.crtc_list.next;
  tmp_crtc = (struct drm_crtc *)__mptr + 0x0ffffffffffffff8UL;
  goto ldv_38704;
  ldv_38703: ;
  if ((int )tmp_crtc->enabled) {
    if ((unsigned long )tmp_crtc->fb != (unsigned long )((struct drm_framebuffer *)0)) {
      if ((unsigned long )crtc != (unsigned long )((struct drm_crtc *)0)) {
        {
        drm_ut_debug_printk(4U, "drm", "intel_update_fbc", "more than one pipe active, disabling compression\n");
        dev_priv->no_fbc_reason = (enum no_fbc_reason )6;
        }
        goto out_disable;
      } else {
      }
      crtc = tmp_crtc;
    } else {
    }
  } else {
  }
  __mptr___0 = (struct list_head const *)tmp_crtc->head.next;
  tmp_crtc = (struct drm_crtc *)__mptr___0 + 0x0ffffffffffffff8UL;
  ldv_38704: ;
  if ((unsigned long )(& tmp_crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
    goto ldv_38703;
  } else {
    goto ldv_38705;
  }
  ldv_38705: ;
  if ((unsigned long )crtc == (unsigned long )((struct drm_crtc *)0)) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_update_fbc", "no output, disabling\n");
    dev_priv->no_fbc_reason = (enum no_fbc_reason )0;
    }
    goto out_disable;
  } else
  if ((unsigned long )crtc->fb == (unsigned long )((struct drm_framebuffer *)0)) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_update_fbc", "no output, disabling\n");
    dev_priv->no_fbc_reason = (enum no_fbc_reason )0;
    }
    goto out_disable;
  } else {
  }
  __mptr___1 = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr___1;
  fb = crtc->fb;
  __mptr___2 = (struct drm_framebuffer const *)fb;
  intel_fb = (struct intel_framebuffer *)__mptr___2;
  obj = intel_fb->obj;
  if (i915_enable_fbc == 0U) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_update_fbc", "fbc disabled per module param (default off)\n");
    dev_priv->no_fbc_reason = (enum no_fbc_reason )7;
    }
    goto out_disable;
  } else {
  }
  if ((intel_fb->obj)->base.size > dev_priv->cfb_size) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_update_fbc", "framebuffer too large, disabling compression\n");
    dev_priv->no_fbc_reason = (enum no_fbc_reason )1;
    }
    goto out_disable;
  } else {
  }
  if ((crtc->mode.flags & 16U) != 0U) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_update_fbc", "mode incompatible with compression, disabling\n");
    dev_priv->no_fbc_reason = (enum no_fbc_reason )2;
    }
    goto out_disable;
  } else
  if ((crtc->mode.flags & 32U) != 0U) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_update_fbc", "mode incompatible with compression, disabling\n");
    dev_priv->no_fbc_reason = (enum no_fbc_reason )2;
    }
    goto out_disable;
  } else {
  }
  if (crtc->mode.hdisplay > 2048) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_update_fbc", "mode too large for compression, disabling\n");
    dev_priv->no_fbc_reason = (enum no_fbc_reason )3;
    }
    goto out_disable;
  } else
  if (crtc->mode.vdisplay > 1536) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_update_fbc", "mode too large for compression, disabling\n");
    dev_priv->no_fbc_reason = (enum no_fbc_reason )3;
    }
    goto out_disable;
  } else {
  }
  if (dev->pci_device == 9618) {
    goto _L;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    _L:
    if ((unsigned int )intel_crtc->plane != 0U) {
      {
      drm_ut_debug_printk(4U, "drm", "intel_update_fbc", "plane not 0, disabling compression\n");
      dev_priv->no_fbc_reason = (enum no_fbc_reason )4;
      }
      goto out_disable;
    } else {
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)obj + 225UL) != 4U) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_update_fbc", "framebuffer not tiled, disabling compression\n");
    dev_priv->no_fbc_reason = (enum no_fbc_reason )5;
    }
    goto out_disable;
  } else {
  }
  if (1) {
    goto case_4;
  } else {
    goto switch_default;
    if (0) {
      __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
      goto ldv_38712;
      __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
      goto ldv_38712;
      case_4:
      __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
      goto ldv_38712;
      __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
      goto ldv_38712;
      switch_default:
      {
      __bad_percpu_size();
      }
    } else {
    }
  }
  ldv_38712:
  {
  tmp = atomic_read((atomic_t const *)(& kgdb_active));
  }
  if (pfo_ret__ == tmp) {
    goto out_disable;
  } else {
  }
  {
  intel_enable_fbc(crtc, 500UL);
  }
  return;
  out_disable:
  {
  tmp___0 = intel_fbc_enabled(dev);
  }
  if ((int )tmp___0) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_update_fbc", "unsupported config, disabling FBC\n");
    intel_disable_fbc(dev);
    }
  } else {
  }
  return;
}
}
int intel_pin_and_fence_fb_obj(struct drm_device *dev , struct drm_i915_gem_object *obj ,
                               struct intel_ring_buffer *pipelined )
{ struct drm_i915_private *dev_priv ;
  u32 alignment ;
  int ret ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((int )obj->tiling_mode == 0) {
    goto case_0;
  } else
  if ((int )obj->tiling_mode == 1) {
    goto case_1;
  } else
  if ((int )obj->tiling_mode == 2) {
    goto case_2;
  } else {
    goto switch_default;
    if (0) {
      case_0: ;
      if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
        alignment = 131072U;
      } else
      if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
        alignment = 131072U;
      } else
      if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
        alignment = 4096U;
      } else {
        alignment = 65536U;
      }
      goto ldv_38727;
      case_1:
      alignment = 0U;
      goto ldv_38727;
      case_2:
      {
      drm_err("intel_pin_and_fence_fb_obj", "Y tiled not allowed for scan out buffers\n");
      }
      return (-22);
      switch_default:
      __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p"),
                           "i" (1819), "i" (12UL));
      ldv_38732: ;
      goto ldv_38732;
    } else {
    }
  }
  ldv_38727:
  {
  dev_priv->mm.interruptible = (bool )0;
  ret = i915_gem_object_pin(obj, alignment, (bool )1);
  }
  if (ret != 0) {
    goto err_interruptible;
  } else {
  }
  {
  ret = i915_gem_object_set_to_display_plane(obj, pipelined);
  }
  if (ret != 0) {
    goto err_unpin;
  } else {
  }
  if ((unsigned int )*((unsigned char *)obj + 225UL) != 0U) {
    {
    ret = i915_gem_object_get_fence(obj, pipelined);
    }
    if (ret != 0) {
      goto err_unpin;
    } else {
    }
  } else {
  }
  dev_priv->mm.interruptible = (bool )1;
  return (0);
  err_unpin:
  {
  i915_gem_object_unpin(obj);
  }
  err_interruptible:
  dev_priv->mm.interruptible = (bool )1;
  return (ret);
}
}
static int intel_pipe_set_base_atomic(struct drm_crtc *crtc , struct drm_framebuffer *fb ,
                                      int x , int y , enum mode_set_atomic state )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  struct intel_framebuffer *intel_fb ;
  struct drm_i915_gem_object *obj ;
  int plane ;
  unsigned long Start ;
  unsigned long Offset ;
  u32 dspcntr ;
  u32 reg ;
  struct drm_framebuffer const *__mptr___0 ;
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  plane = (int )intel_crtc->plane;
  if (plane == 0) {
    goto case_0;
  } else
  if (plane == 1) {
    goto case_1;
  } else {
    goto switch_default;
    if (0) {
      case_0: ;
      case_1: ;
      goto ldv_38756;
      switch_default:
      {
      drm_err("intel_pipe_set_base_atomic", "Can\'t update plane %d in SAREA\n", plane);
      }
      return (-22);
    } else {
    }
  }
  ldv_38756:
  {
  __mptr___0 = (struct drm_framebuffer const *)fb;
  intel_fb = (struct intel_framebuffer *)__mptr___0;
  obj = intel_fb->obj;
  reg = (u32 )(plane * 4096 + 459136);
  dspcntr = i915_read32___6(dev_priv, reg);
  dspcntr = dspcntr & 3288334335U;
  }
  if (fb->bits_per_pixel == 8) {
    goto case_8;
  } else
  if (fb->bits_per_pixel == 16) {
    goto case_16;
  } else
  if (fb->bits_per_pixel == 24) {
    goto case_24;
  } else
  if (fb->bits_per_pixel == 32) {
    goto case_32;
  } else {
    goto switch_default___0;
    if (0) {
      case_8:
      dspcntr = dspcntr | 134217728U;
      goto ldv_38762;
      case_16: ;
      if (fb->depth == 15U) {
        dspcntr = dspcntr | 268435456U;
      } else {
        dspcntr = dspcntr | 335544320U;
      }
      goto ldv_38762;
      case_24: ;
      case_32:
      dspcntr = dspcntr | 402653184U;
      goto ldv_38762;
      switch_default___0:
      {
      drm_err("intel_pipe_set_base_atomic", "Unknown color depth\n");
      }
      return (-22);
    } else {
    }
  }
  ldv_38762: ;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    if ((unsigned int )*((unsigned char *)obj + 225UL) != 0U) {
      dspcntr = dspcntr | 1024U;
    } else {
      dspcntr = dspcntr & 4294966271U;
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    dspcntr = dspcntr | 16384U;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    dspcntr = dspcntr | 16384U;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    dspcntr = dspcntr | 16384U;
  } else {
  }
  {
  i915_write32___4(dev_priv, reg, dspcntr);
  Start = (unsigned long )obj->gtt_offset;
  Offset = (unsigned long )(fb->pitch * (unsigned int )y + (unsigned int )((fb->bits_per_pixel / 8) * x));
  drm_ut_debug_printk(4U, "drm", "intel_pipe_set_base_atomic", "Writing base %08lX %08lX %d %d %d\n",
                      Start, Offset, x, y, fb->pitch);
  i915_write32___4(dev_priv, (u32 )(plane * 4096 + 459144), fb->pitch);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    {
    i915_write32___4(dev_priv, (u32 )(plane * 4096 + 459164), (u32 )Start);
    i915_write32___4(dev_priv, (u32 )(plane * 4096 + 459172), (u32 )((y << 16) | x));
    i915_write32___4(dev_priv, (u32 )(plane * 4096 + 459140), (u32 )Offset);
    }
  } else {
    {
    i915_write32___4(dev_priv, (u32 )(plane * 4096 + 459140), (u32 )Start + (u32 )Offset);
    }
  }
  {
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  intel_update_fbc(dev);
  intel_increase_pllclock(crtc);
  }
  return (0);
}
}
static int intel_pipe_set_base(struct drm_crtc *crtc , int x , int y , struct drm_framebuffer *old_fb )
{ struct drm_device *dev ;
  struct drm_i915_master_private *master_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int ret ;
  struct drm_framebuffer const *__mptr___0 ;
  struct drm_i915_private *dev_priv ;
  struct drm_i915_gem_object *obj ;
  struct drm_framebuffer const *__mptr___1 ;
  int tmp ;
  int tmp___0 ;
  wait_queue_t __wait ;
  struct task_struct *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct drm_framebuffer const *__mptr___2 ;
  struct drm_framebuffer const *__mptr___3 ;
  {
  dev = crtc->dev;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  if ((unsigned long )crtc->fb == (unsigned long )((struct drm_framebuffer *)0)) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_pipe_set_base", "No FB bound\n");
    }
    return (0);
  } else {
  }
  if ((int )((unsigned int )intel_crtc->plane) == 0) {
    goto case_0;
  } else
  if ((int )((unsigned int )intel_crtc->plane) == 1) {
    goto case_1;
  } else {
    goto switch_default;
    if (0) {
      case_0: ;
      case_1: ;
      goto ldv_38782;
      switch_default: ;
      return (-22);
    } else {
    }
  }
  ldv_38782:
  {
  mutex_lock_nested(& dev->struct_mutex, 0U);
  __mptr___0 = (struct drm_framebuffer const *)crtc->fb;
  ret = intel_pin_and_fence_fb_obj(dev, ((struct intel_framebuffer *)__mptr___0)->obj,
                                   (struct intel_ring_buffer *)0);
  }
  if (ret != 0) {
    {
    mutex_unlock(& dev->struct_mutex);
    }
    return (ret);
  } else {
  }
  if ((unsigned long )old_fb != (unsigned long )((struct drm_framebuffer *)0)) {
    {
    dev_priv = (struct drm_i915_private *)dev->dev_private;
    __mptr___1 = (struct drm_framebuffer const *)old_fb;
    obj = ((struct intel_framebuffer *)__mptr___1)->obj;
    tmp = atomic_read((atomic_t const *)(& dev_priv->mm.wedged));
    }
    if (tmp != 0) {
      goto ldv_38790;
    } else {
      {
      tmp___0 = atomic_read((atomic_t const *)(& obj->pending_flip));
      }
      if (tmp___0 == 0) {
        goto ldv_38790;
      } else {
      }
    }
    {
    tmp___1 = get_current();
    __wait.flags = 0U;
    __wait.private = (void *)tmp___1;
    __wait.func = & autoremove_wake_function;
    __wait.task_list.next = & __wait.task_list;
    __wait.task_list.prev = & __wait.task_list;
    }
    ldv_38793:
    {
    prepare_to_wait(& dev_priv->pending_flip_queue, & __wait, 2);
    tmp___2 = atomic_read((atomic_t const *)(& dev_priv->mm.wedged));
    }
    if (tmp___2 != 0) {
      goto ldv_38792;
    } else {
      {
      tmp___3 = atomic_read((atomic_t const *)(& obj->pending_flip));
      }
      if (tmp___3 == 0) {
        goto ldv_38792;
      } else {
      }
    }
    {
    schedule();
    }
    goto ldv_38793;
    ldv_38792:
    {
    finish_wait(& dev_priv->pending_flip_queue, & __wait);
    }
    ldv_38790:
    {
    ret = i915_gem_object_flush_gpu(obj);
    }
  } else {
  }
  {
  ret = intel_pipe_set_base_atomic(crtc, crtc->fb, x, y, (enum mode_set_atomic )0);
  }
  if (ret != 0) {
    {
    __mptr___2 = (struct drm_framebuffer const *)crtc->fb;
    i915_gem_object_unpin(((struct intel_framebuffer *)__mptr___2)->obj);
    mutex_unlock(& dev->struct_mutex);
    }
    return (ret);
  } else {
  }
  if ((unsigned long )old_fb != (unsigned long )((struct drm_framebuffer *)0)) {
    {
    intel_wait_for_vblank(dev, (int )intel_crtc->pipe);
    __mptr___3 = (struct drm_framebuffer const *)old_fb;
    i915_gem_object_unpin(((struct intel_framebuffer *)__mptr___3)->obj);
    }
  } else {
  }
  {
  mutex_unlock(& dev->struct_mutex);
  }
  if ((unsigned long )(dev->primary)->master == (unsigned long )((struct drm_master *)0)) {
    return (0);
  } else {
  }
  master_priv = (struct drm_i915_master_private *)((dev->primary)->master)->driver_priv;
  if ((unsigned long )master_priv->sarea_priv == (unsigned long )((struct _drm_i915_sarea *)0)) {
    return (0);
  } else {
  }
  if ((unsigned int )intel_crtc->pipe != 0U) {
    (master_priv->sarea_priv)->pipeB_x = x;
    (master_priv->sarea_priv)->pipeB_y = y;
  } else {
    (master_priv->sarea_priv)->pipeA_x = x;
    (master_priv->sarea_priv)->pipeA_y = y;
  }
  return (0);
}
}
static void ironlake_set_pll_edp(struct drm_crtc *crtc , int clock )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  u32 dpa_ctl ;
  u32 temp ;
  {
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  drm_ut_debug_printk(4U, "drm", "ironlake_set_pll_edp", "eDP PLL enable for clock %d\n",
                      clock);
  dpa_ctl = i915_read32___6(dev_priv, 409600U);
  dpa_ctl = dpa_ctl & 4294770687U;
  }
  if (clock <= 199999) {
    {
    dpa_ctl = dpa_ctl | 65536U;
    temp = i915_read32___6(dev_priv, 286732U);
    temp = temp & 4294901760U;
    i915_write32___4(dev_priv, 286732U, temp | 33060U);
    temp = i915_read32___6(dev_priv, 286736U);
    i915_write32___4(dev_priv, 286736U, temp | 1U);
    temp = i915_read32___6(dev_priv, 286772U);
    i915_write32___4(dev_priv, 286772U, temp | 16777216U);
    }
  } else {
    dpa_ctl = dpa_ctl;
  }
  {
  i915_write32___4(dev_priv, 409600U, dpa_ctl);
  readl((void const volatile *)dev_priv->regs + 409600U);
  __const_udelay(2147500UL);
  }
  return;
}
}
static void intel_fdi_normal_train(struct drm_crtc *crtc )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int pipe ;
  u32 reg ;
  u32 temp ;
  u32 tmp ;
  {
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  pipe = (int )intel_crtc->pipe;
  reg = (u32 )(pipe * 4096 + 393472);
  temp = i915_read32___6(dev_priv, reg);
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    temp = temp & 4294966527U;
    temp = temp | 262912U;
  } else {
    temp = temp & 3489660927U;
    temp = temp | 805568512U;
  }
  {
  i915_write32___4(dev_priv, reg, temp);
  reg = (u32 )(pipe * 4096 + 983052);
  temp = i915_read32___6(dev_priv, reg);
  }
  if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 1U) {
    temp = temp & 4294966527U;
    temp = temp | 768U;
  } else {
    temp = temp & 3489660927U;
    temp = temp | 805306368U;
  }
  {
  i915_write32___4(dev_priv, reg, temp | 64U);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  __const_udelay(4295000UL);
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    tmp = i915_read32___6(dev_priv, reg);
    i915_write32___4(dev_priv, reg, tmp | 201326592U);
    }
  } else {
  }
  return;
}
}
static void ironlake_fdi_link_train(struct drm_crtc *crtc )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int pipe ;
  int plane ;
  u32 reg ;
  u32 temp ;
  u32 tries ;
  {
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  pipe = (int )intel_crtc->pipe;
  plane = (int )intel_crtc->plane;
  assert_pipe(dev_priv, (enum pipe )pipe, (bool )1);
  assert_plane_enabled(dev_priv, (enum plane )plane);
  reg = (u32 )(pipe * 4096 + 983064);
  temp = i915_read32___6(dev_priv, reg);
  temp = temp & 4294966783U;
  temp = temp & 4294967039U;
  i915_write32___4(dev_priv, reg, temp);
  i915_read32___6(dev_priv, reg);
  __const_udelay(644250UL);
  reg = (u32 )(pipe * 4096 + 393472);
  temp = i915_read32___6(dev_priv, reg);
  temp = temp & 4291297279U;
  temp = (u32 )((intel_crtc->fdi_lanes + -1) << 19) | temp;
  temp = temp & 3489660927U;
  temp = temp;
  i915_write32___4(dev_priv, reg, temp | 2147483648U);
  reg = (u32 )(pipe * 4096 + 983052);
  temp = i915_read32___6(dev_priv, reg);
  temp = temp & 3489660927U;
  temp = temp;
  i915_write32___4(dev_priv, reg, temp | 2147483648U);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  __const_udelay(644250UL);
  }
  if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 0U) {
    {
    i915_write32___4(dev_priv, (u32 )((pipe + 198659) * 4), 2U);
    i915_write32___4(dev_priv, (u32 )((pipe + 198659) * 4), 3U);
    }
  } else {
  }
  reg = (u32 )(pipe * 4096 + 983060);
  tries = 0U;
  goto ldv_38834;
  ldv_38833:
  {
  temp = i915_read32___6(dev_priv, reg);
  drm_ut_debug_printk(4U, "drm", "ironlake_fdi_link_train", "FDI_RX_IIR 0x%x\n", temp);
  }
  if ((temp & 256U) != 0U) {
    {
    drm_ut_debug_printk(4U, "drm", "ironlake_fdi_link_train", "FDI train 1 done.\n");
    i915_write32___4(dev_priv, reg, temp | 256U);
    }
    goto ldv_38832;
  } else {
  }
  tries = tries + 1U;
  ldv_38834: ;
  if (tries <= 4U) {
    goto ldv_38833;
  } else {
    goto ldv_38832;
  }
  ldv_38832: ;
  if (tries == 5U) {
    {
    drm_err("ironlake_fdi_link_train", "FDI train 1 fail!\n");
    }
  } else {
  }
  {
  reg = (u32 )(pipe * 4096 + 393472);
  temp = i915_read32___6(dev_priv, reg);
  temp = temp & 3489660927U;
  temp = temp | 268435456U;
  i915_write32___4(dev_priv, reg, temp);
  reg = (u32 )(pipe * 4096 + 983052);
  temp = i915_read32___6(dev_priv, reg);
  temp = temp & 3489660927U;
  temp = temp | 268435456U;
  i915_write32___4(dev_priv, reg, temp);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  __const_udelay(644250UL);
  reg = (u32 )(pipe * 4096 + 983060);
  tries = 0U;
  }
  goto ldv_38837;
  ldv_38836:
  {
  temp = i915_read32___6(dev_priv, reg);
  drm_ut_debug_printk(4U, "drm", "ironlake_fdi_link_train", "FDI_RX_IIR 0x%x\n", temp);
  }
  if ((temp & 512U) != 0U) {
    {
    i915_write32___4(dev_priv, reg, temp | 512U);
    drm_ut_debug_printk(4U, "drm", "ironlake_fdi_link_train", "FDI train 2 done.\n");
    }
    goto ldv_38835;
  } else {
  }
  tries = tries + 1U;
  ldv_38837: ;
  if (tries <= 4U) {
    goto ldv_38836;
  } else {
    goto ldv_38835;
  }
  ldv_38835: ;
  if (tries == 5U) {
    {
    drm_err("ironlake_fdi_link_train", "FDI train 2 fail!\n");
    }
  } else {
  }
  {
  drm_ut_debug_printk(4U, "drm", "ironlake_fdi_link_train", "FDI train done\n");
  }
  return;
}
}
static int const snb_b_fdi_train_param[4U] = { (int const )0, (int const )243269632, (int const )239075328, (int const )234881024};
static void gen6_fdi_link_train(struct drm_crtc *crtc )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int pipe ;
  u32 reg ;
  u32 temp ;
  u32 i ;
  {
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  pipe = (int )intel_crtc->pipe;
  reg = (u32 )(pipe * 4096 + 983064);
  temp = i915_read32___6(dev_priv, reg);
  temp = temp & 4294966783U;
  temp = temp & 4294967039U;
  i915_write32___4(dev_priv, reg, temp);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  __const_udelay(644250UL);
  reg = (u32 )(pipe * 4096 + 393472);
  temp = i915_read32___6(dev_priv, reg);
  temp = temp & 4291297279U;
  temp = (u32 )((intel_crtc->fdi_lanes + -1) << 19) | temp;
  temp = temp & 3489660927U;
  temp = temp;
  temp = temp & 4030726143U;
  temp = temp;
  i915_write32___4(dev_priv, reg, temp | 2147483648U);
  reg = (u32 )(pipe * 4096 + 983052);
  temp = i915_read32___6(dev_priv, reg);
  }
  if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 1U) {
    temp = temp & 4294966527U;
    temp = temp;
  } else {
    temp = temp & 3489660927U;
    temp = temp;
  }
  {
  i915_write32___4(dev_priv, reg, temp | 2147483648U);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  __const_udelay(644250UL);
  i = 0U;
  }
  goto ldv_38854;
  ldv_38853:
  {
  reg = (u32 )(pipe * 4096 + 393472);
  temp = i915_read32___6(dev_priv, reg);
  temp = temp & 4030726143U;
  temp = (u32 )snb_b_fdi_train_param[i] | temp;
  i915_write32___4(dev_priv, reg, temp);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  __const_udelay(2147500UL);
  reg = (u32 )(pipe * 4096 + 983060);
  temp = i915_read32___6(dev_priv, reg);
  drm_ut_debug_printk(4U, "drm", "gen6_fdi_link_train", "FDI_RX_IIR 0x%x\n", temp);
  }
  if ((temp & 256U) != 0U) {
    {
    i915_write32___4(dev_priv, reg, temp | 256U);
    drm_ut_debug_printk(4U, "drm", "gen6_fdi_link_train", "FDI train 1 done.\n");
    }
    goto ldv_38852;
  } else {
  }
  i = i + 1U;
  ldv_38854: ;
  if (i <= 3U) {
    goto ldv_38853;
  } else {
    goto ldv_38852;
  }
  ldv_38852: ;
  if (i == 4U) {
    {
    drm_err("gen6_fdi_link_train", "FDI train 1 fail!\n");
    }
  } else {
  }
  {
  reg = (u32 )(pipe * 4096 + 393472);
  temp = i915_read32___6(dev_priv, reg);
  temp = temp & 3489660927U;
  temp = temp | 268435456U;
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    temp = temp & 4030726143U;
    temp = temp;
  } else {
  }
  {
  i915_write32___4(dev_priv, reg, temp);
  reg = (u32 )(pipe * 4096 + 983052);
  temp = i915_read32___6(dev_priv, reg);
  }
  if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 1U) {
    temp = temp & 4294966527U;
    temp = temp | 256U;
  } else {
    temp = temp & 3489660927U;
    temp = temp | 268435456U;
  }
  {
  i915_write32___4(dev_priv, reg, temp);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  __const_udelay(644250UL);
  i = 0U;
  }
  goto ldv_38857;
  ldv_38856:
  {
  reg = (u32 )(pipe * 4096 + 393472);
  temp = i915_read32___6(dev_priv, reg);
  temp = temp & 4030726143U;
  temp = (u32 )snb_b_fdi_train_param[i] | temp;
  i915_write32___4(dev_priv, reg, temp);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  __const_udelay(2147500UL);
  reg = (u32 )(pipe * 4096 + 983060);
  temp = i915_read32___6(dev_priv, reg);
  drm_ut_debug_printk(4U, "drm", "gen6_fdi_link_train", "FDI_RX_IIR 0x%x\n", temp);
  }
  if ((temp & 512U) != 0U) {
    {
    i915_write32___4(dev_priv, reg, temp | 512U);
    drm_ut_debug_printk(4U, "drm", "gen6_fdi_link_train", "FDI train 2 done.\n");
    }
    goto ldv_38855;
  } else {
  }
  i = i + 1U;
  ldv_38857: ;
  if (i <= 3U) {
    goto ldv_38856;
  } else {
    goto ldv_38855;
  }
  ldv_38855: ;
  if (i == 4U) {
    {
    drm_err("gen6_fdi_link_train", "FDI train 2 fail!\n");
    }
  } else {
  }
  {
  drm_ut_debug_printk(4U, "drm", "gen6_fdi_link_train", "FDI train done.\n");
  }
  return;
}
}
static void ivb_manual_fdi_link_train(struct drm_crtc *crtc )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int pipe ;
  u32 reg ;
  u32 temp ;
  u32 i ;
  u32 tmp ;
  {
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  pipe = (int )intel_crtc->pipe;
  reg = (u32 )(pipe * 4096 + 983064);
  temp = i915_read32___6(dev_priv, reg);
  temp = temp & 4294966783U;
  temp = temp & 4294967039U;
  i915_write32___4(dev_priv, reg, temp);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  __const_udelay(644250UL);
  reg = (u32 )(pipe * 4096 + 393472);
  temp = i915_read32___6(dev_priv, reg);
  temp = temp & 4291297279U;
  temp = (u32 )((intel_crtc->fdi_lanes + -1) << 19) | temp;
  temp = temp & 4294965503U;
  temp = temp;
  temp = temp & 4030726143U;
  temp = temp;
  i915_write32___4(dev_priv, reg, temp | 2147483648U);
  reg = (u32 )(pipe * 4096 + 983052);
  temp = i915_read32___6(dev_priv, reg);
  temp = temp & 4294966271U;
  temp = temp & 4294966527U;
  temp = temp;
  i915_write32___4(dev_priv, reg, temp | 2147483648U);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  __const_udelay(644250UL);
  i = 0U;
  }
  goto ldv_38873;
  ldv_38872:
  {
  reg = (u32 )(pipe * 4096 + 393472);
  temp = i915_read32___6(dev_priv, reg);
  temp = temp & 4030726143U;
  temp = (u32 )snb_b_fdi_train_param[i] | temp;
  i915_write32___4(dev_priv, reg, temp);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  __const_udelay(2147500UL);
  reg = (u32 )(pipe * 4096 + 983060);
  temp = i915_read32___6(dev_priv, reg);
  drm_ut_debug_printk(4U, "drm", "ivb_manual_fdi_link_train", "FDI_RX_IIR 0x%x\n",
                      temp);
  }
  if ((temp & 256U) != 0U) {
    {
    i915_write32___4(dev_priv, reg, temp | 256U);
    drm_ut_debug_printk(4U, "drm", "ivb_manual_fdi_link_train", "FDI train 1 done.\n");
    }
    goto ldv_38871;
  } else {
    {
    tmp = i915_read32___6(dev_priv, reg);
    }
    if ((tmp & 256U) != 0U) {
      {
      i915_write32___4(dev_priv, reg, temp | 256U);
      drm_ut_debug_printk(4U, "drm", "ivb_manual_fdi_link_train", "FDI train 1 done.\n");
      }
      goto ldv_38871;
    } else {
    }
  }
  i = i + 1U;
  ldv_38873: ;
  if (i <= 3U) {
    goto ldv_38872;
  } else {
    goto ldv_38871;
  }
  ldv_38871: ;
  if (i == 4U) {
    {
    drm_err("ivb_manual_fdi_link_train", "FDI train 1 fail!\n");
    }
  } else {
  }
  {
  reg = (u32 )(pipe * 4096 + 393472);
  temp = i915_read32___6(dev_priv, reg);
  temp = temp & 4294966527U;
  temp = temp | 256U;
  temp = temp & 4030726143U;
  temp = temp;
  i915_write32___4(dev_priv, reg, temp);
  reg = (u32 )(pipe * 4096 + 983052);
  temp = i915_read32___6(dev_priv, reg);
  temp = temp & 4294966527U;
  temp = temp | 256U;
  i915_write32___4(dev_priv, reg, temp);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  __const_udelay(644250UL);
  i = 0U;
  }
  goto ldv_38876;
  ldv_38875:
  {
  reg = (u32 )(pipe * 4096 + 393472);
  temp = i915_read32___6(dev_priv, reg);
  temp = temp & 4030726143U;
  temp = (u32 )snb_b_fdi_train_param[i] | temp;
  i915_write32___4(dev_priv, reg, temp);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  __const_udelay(2147500UL);
  reg = (u32 )(pipe * 4096 + 983060);
  temp = i915_read32___6(dev_priv, reg);
  drm_ut_debug_printk(4U, "drm", "ivb_manual_fdi_link_train", "FDI_RX_IIR 0x%x\n",
                      temp);
  }
  if ((temp & 512U) != 0U) {
    {
    i915_write32___4(dev_priv, reg, temp | 512U);
    drm_ut_debug_printk(4U, "drm", "ivb_manual_fdi_link_train", "FDI train 2 done.\n");
    }
    goto ldv_38874;
  } else {
  }
  i = i + 1U;
  ldv_38876: ;
  if (i <= 3U) {
    goto ldv_38875;
  } else {
    goto ldv_38874;
  }
  ldv_38874: ;
  if (i == 4U) {
    {
    drm_err("ivb_manual_fdi_link_train", "FDI train 2 fail!\n");
    }
  } else {
  }
  {
  drm_ut_debug_printk(4U, "drm", "ivb_manual_fdi_link_train", "FDI train done.\n");
  }
  return;
}
}
static void ironlake_fdi_pll_enable(struct drm_crtc *crtc )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int pipe ;
  u32 reg ;
  u32 temp ;
  u32 tmp ;
  u32 tmp___0 ;
  {
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  pipe = (int )intel_crtc->pipe;
  tmp = i915_read32___6(dev_priv, (u32 )(pipe * 4096 + 393264));
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 983088), tmp & 2113929216U);
  reg = (u32 )(pipe * 4096 + 983052);
  temp = i915_read32___6(dev_priv, reg);
  temp = temp & 4290838527U;
  temp = (u32 )((intel_crtc->fdi_lanes + -1) << 19) | temp;
  tmp___0 = i915_read32___6(dev_priv, (u32 )(pipe * 4096 + 458760));
  temp = ((tmp___0 & 224U) << 11) | temp;
  i915_write32___4(dev_priv, reg, temp | 8192U);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  __const_udelay(859000UL);
  temp = i915_read32___6(dev_priv, reg);
  i915_write32___4(dev_priv, reg, temp | 16U);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  __const_udelay(859000UL);
  reg = (u32 )(pipe * 4096 + 393472);
  temp = i915_read32___6(dev_priv, reg);
  }
  if ((temp & 16384U) == 0U) {
    {
    i915_write32___4(dev_priv, reg, temp | 16384U);
    readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
    __const_udelay(429500UL);
    }
  } else {
  }
  return;
}
}
static void ironlake_fdi_disable(struct drm_crtc *crtc )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int pipe ;
  u32 reg ;
  u32 temp ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  {
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  pipe = (int )intel_crtc->pipe;
  reg = (u32 )(pipe * 4096 + 393472);
  temp = i915_read32___6(dev_priv, reg);
  i915_write32___4(dev_priv, reg, temp & 2147483647U);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  reg = (u32 )(pipe * 4096 + 983052);
  temp = i915_read32___6(dev_priv, reg);
  temp = temp & 4294508543U;
  tmp = i915_read32___6(dev_priv, (u32 )(pipe * 4096 + 458760));
  temp = ((tmp & 224U) << 11) | temp;
  i915_write32___4(dev_priv, reg, temp & 2147483647U);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  __const_udelay(429500UL);
  }
  if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 0U) {
    {
    i915_write32___4(dev_priv, (u32 )((pipe + 198659) * 4), 2U);
    tmp___0 = i915_read32___6(dev_priv, (u32 )((pipe + 198659) * 4) & 4294967294U);
    i915_write32___4(dev_priv, (u32 )((pipe + 198659) * 4), tmp___0);
    }
  } else {
  }
  {
  reg = (u32 )(pipe * 4096 + 393472);
  temp = i915_read32___6(dev_priv, reg);
  temp = temp & 3489660927U;
  temp = temp;
  i915_write32___4(dev_priv, reg, temp);
  reg = (u32 )(pipe * 4096 + 983052);
  temp = i915_read32___6(dev_priv, reg);
  }
  if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 1U) {
    temp = temp & 4294966527U;
    temp = temp;
  } else {
    temp = temp & 3489660927U;
    temp = temp;
  }
  {
  temp = temp & 4294508543U;
  tmp___1 = i915_read32___6(dev_priv, (u32 )(pipe * 4096 + 458760));
  temp = ((tmp___1 & 224U) << 11) | temp;
  i915_write32___4(dev_priv, reg, temp);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  __const_udelay(429500UL);
  }
  return;
}
}
static void intel_clear_scanline_wait(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct intel_ring_buffer *ring ;
  u32 tmp ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 2U) {
    return;
  } else {
  }
  {
  ring = (struct intel_ring_buffer *)(& dev_priv->ring);
  tmp = i915_read32___6(dev_priv, ring->mmio_base + 60U);
  }
  if ((tmp & 2048U) != 0U) {
    {
    i915_write32___4(dev_priv, ring->mmio_base + 60U, tmp);
    }
  } else {
  }
  return;
}
}
static void intel_crtc_wait_for_pending_flips(struct drm_crtc *crtc )
{ struct drm_i915_gem_object *obj ;
  struct drm_i915_private *dev_priv ;
  struct drm_framebuffer const *__mptr ;
  int tmp ;
  wait_queue_t __wait ;
  struct task_struct *tmp___0 ;
  int tmp___1 ;
  {
  if ((unsigned long )crtc->fb == (unsigned long )((struct drm_framebuffer *)0)) {
    return;
  } else {
  }
  {
  __mptr = (struct drm_framebuffer const *)crtc->fb;
  obj = ((struct intel_framebuffer *)__mptr)->obj;
  dev_priv = (struct drm_i915_private *)(crtc->dev)->dev_private;
  tmp = atomic_read((atomic_t const *)(& obj->pending_flip));
  }
  if (tmp == 0) {
    goto ldv_38912;
  } else {
  }
  {
  tmp___0 = get_current();
  __wait.flags = 0U;
  __wait.private = (void *)tmp___0;
  __wait.func = & autoremove_wake_function;
  __wait.task_list.next = & __wait.task_list;
  __wait.task_list.prev = & __wait.task_list;
  }
  ldv_38915:
  {
  prepare_to_wait(& dev_priv->pending_flip_queue, & __wait, 2);
  tmp___1 = atomic_read((atomic_t const *)(& obj->pending_flip));
  }
  if (tmp___1 == 0) {
    goto ldv_38914;
  } else {
  }
  {
  schedule();
  }
  goto ldv_38915;
  ldv_38914:
  {
  finish_wait(& dev_priv->pending_flip_queue, & __wait);
  }
  ldv_38912: ;
  return;
}
}
static bool intel_crtc_driving_pch(struct drm_crtc *crtc )
{ struct drm_device *dev ;
  struct drm_mode_config *mode_config ;
  struct intel_encoder *encoder ;
  struct list_head const *__mptr ;
  bool tmp ;
  int tmp___0 ;
  struct list_head const *__mptr___0 ;
  {
  dev = crtc->dev;
  mode_config = & dev->mode_config;
  __mptr = (struct list_head const *)mode_config->encoder_list.next;
  encoder = (struct intel_encoder *)__mptr + 0x0ffffffffffffff8UL;
  goto ldv_38929;
  ldv_38928: ;
  if ((unsigned long )encoder->base.crtc != (unsigned long )crtc) {
    goto ldv_38926;
  } else {
  }
  if (encoder->type == 8) {
    goto case_8;
  } else
  if (0) {
    case_8:
    {
    tmp = intel_encoder_is_pch_edp(& encoder->base);
    }
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      return ((bool )0);
    } else {
    }
    goto ldv_38926;
  } else {
  }
  ldv_38926:
  __mptr___0 = (struct list_head const *)encoder->base.head.next;
  encoder = (struct intel_encoder *)__mptr___0 + 0x0ffffffffffffff8UL;
  ldv_38929: ;
  if ((unsigned long )(& encoder->base.head) != (unsigned long )(& mode_config->encoder_list)) {
    goto ldv_38928;
  } else {
    goto ldv_38930;
  }
  ldv_38930: ;
  return ((bool )1);
}
}
static void ironlake_pch_enable(struct drm_crtc *crtc )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int pipe ;
  u32 reg ;
  u32 temp ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  {
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  pipe = (int )intel_crtc->pipe;
  (*(dev_priv->display.fdi_link_train))(crtc);
  intel_enable_pch_pll(dev_priv, (enum pipe )pipe);
  }
  if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 1U) {
    {
    temp = i915_read32___6(dev_priv, 815104U);
    }
    if (pipe == 0) {
      if ((temp & 8U) == 0U) {
        temp = temp | 8U;
      } else {
        goto _L;
      }
    } else
    _L:
    if (pipe == 1) {
      if ((temp & 128U) == 0U) {
        temp = temp | 144U;
      } else {
      }
    } else {
    }
    {
    i915_write32___4(dev_priv, 815104U, temp);
    }
  } else {
  }
  {
  assert_panel_unlocked(dev_priv, (enum pipe )pipe);
  tmp = i915_read32___6(dev_priv, (u32 )((pipe + 96) * 4096));
  i915_write32___4(dev_priv, (u32 )((pipe + 224) * 4096), tmp);
  tmp___0 = i915_read32___6(dev_priv, (u32 )(pipe * 4096 + 393220));
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 917508), tmp___0);
  tmp___1 = i915_read32___6(dev_priv, (u32 )(pipe * 4096 + 393224));
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 917512), tmp___1);
  tmp___2 = i915_read32___6(dev_priv, (u32 )(pipe * 4096 + 393228));
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 917516), tmp___2);
  tmp___3 = i915_read32___6(dev_priv, (u32 )(pipe * 4096 + 393232));
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 917520), tmp___3);
  tmp___4 = i915_read32___6(dev_priv, (u32 )(pipe * 4096 + 393236));
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 917524), tmp___4);
  intel_fdi_normal_train(crtc);
  }
  if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 1U) {
    {
    tmp___6 = intel_pipe_has_type(crtc, 7);
    }
    if ((int )tmp___6) {
      {
      reg = (u32 )(pipe * 4096 + 918272);
      temp = i915_read32___6(dev_priv, reg);
      temp = temp & 2684352999U;
      temp = temp | 2147745792U;
      temp = temp;
      }
      if ((int )crtc->mode.flags & 1) {
        temp = temp | 8U;
      } else {
      }
      if ((crtc->mode.flags & 4U) != 0U) {
        temp = temp | 16U;
      } else {
      }
      {
      tmp___5 = intel_trans_dp_port_sel(crtc);
      }
      if (tmp___5 == 934144) {
        goto case_934144;
      } else
      if (tmp___5 == 934400) {
        goto case_934400;
      } else
      if (tmp___5 == 934656) {
        goto case_934656;
      } else {
        goto switch_default;
        if (0) {
          case_934144:
          temp = temp;
          goto ldv_38943;
          case_934400:
          temp = temp | 536870912U;
          goto ldv_38943;
          case_934656:
          temp = temp | 1073741824U;
          goto ldv_38943;
          switch_default:
          {
          drm_ut_debug_printk(4U, "drm", "ironlake_pch_enable", "Wrong PCH DP port return. Guess port B\n");
          temp = temp;
          }
          goto ldv_38943;
        } else {
        }
      }
      ldv_38943:
      {
      i915_write32___4(dev_priv, reg, temp);
      }
    } else {
    }
  } else {
  }
  {
  intel_enable_transcoder(dev_priv, (enum pipe )pipe);
  }
  return;
}
}
static void ironlake_crtc_enable(struct drm_crtc *crtc )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int pipe ;
  int plane ;
  u32 temp ;
  bool is_pch_port ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  pipe = (int )intel_crtc->pipe;
  plane = (int )intel_crtc->plane;
  if ((int )intel_crtc->active) {
    return;
  } else {
  }
  {
  intel_crtc->active = (bool )1;
  intel_update_watermarks(dev);
  tmp = intel_pipe_has_type(crtc, 4);
  }
  if ((int )tmp) {
    {
    temp = i915_read32___6(dev_priv, 921984U);
    }
    if ((int )temp >= 0) {
      {
      i915_write32___4(dev_priv, 921984U, temp | 2147483648U);
      }
    } else {
    }
  } else {
  }
  {
  is_pch_port = intel_crtc_driving_pch(crtc);
  }
  if ((int )is_pch_port) {
    {
    ironlake_fdi_pll_enable(crtc);
    }
  } else {
    {
    ironlake_fdi_disable(crtc);
    }
  }
  if (dev_priv->pch_pf_size != 0U) {
    {
    tmp___0 = intel_pipe_has_type(crtc, 4);
    }
    if ((int )tmp___0) {
      {
      i915_write32___4(dev_priv, (u32 )(pipe * 2048 + 426112), 2155872256U);
      i915_write32___4(dev_priv, (u32 )(pipe * 2048 + 426096), dev_priv->pch_pf_pos);
      i915_write32___4(dev_priv, (u32 )(pipe * 2048 + 426100), dev_priv->pch_pf_size);
      }
    } else {
      {
      tmp___1 = intel_pipe_has_type(crtc, 8);
      }
      if ((int )tmp___1) {
        {
        i915_write32___4(dev_priv, (u32 )(pipe * 2048 + 426112), 2155872256U);
        i915_write32___4(dev_priv, (u32 )(pipe * 2048 + 426096), dev_priv->pch_pf_pos);
        i915_write32___4(dev_priv, (u32 )(pipe * 2048 + 426100), dev_priv->pch_pf_size);
        }
      } else {
      }
    }
  } else {
  }
  {
  intel_enable_pipe(dev_priv, (enum pipe )pipe, (bool )((int )is_pch_port));
  intel_enable_plane(dev_priv, (enum plane )plane, (enum pipe )pipe);
  }
  if ((int )is_pch_port) {
    {
    ironlake_pch_enable(crtc);
    }
  } else {
  }
  {
  intel_crtc_load_lut(crtc);
  mutex_lock_nested(& dev->struct_mutex, 0U);
  intel_update_fbc(dev);
  mutex_unlock(& dev->struct_mutex);
  intel_crtc_update_cursor(crtc, (bool )1);
  }
  return;
}
}
static void ironlake_crtc_disable(struct drm_crtc *crtc )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int pipe ;
  int plane ;
  u32 reg ;
  u32 temp ;
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  pipe = (int )intel_crtc->pipe;
  plane = (int )intel_crtc->plane;
  if (! intel_crtc->active) {
    return;
  } else {
  }
  {
  intel_crtc_wait_for_pending_flips(crtc);
  drm_vblank_off(dev, pipe);
  intel_crtc_update_cursor(crtc, (bool )0);
  intel_disable_plane(dev_priv, (enum plane )plane, (enum pipe )pipe);
  }
  if (dev_priv->cfb_plane == plane) {
    if ((unsigned long )dev_priv->display.disable_fbc != (unsigned long )((void (*)(struct drm_device * ))0)) {
      {
      (*(dev_priv->display.disable_fbc))(dev);
      }
    } else {
    }
  } else {
  }
  {
  intel_disable_pipe(dev_priv, (enum pipe )pipe);
  i915_write32___4(dev_priv, (u32 )(pipe * 2048 + 426112), 0U);
  i915_write32___4(dev_priv, (u32 )(pipe * 2048 + 426100), 0U);
  ironlake_fdi_disable(crtc);
  intel_disable_pch_ports(dev_priv, (enum pipe )pipe);
  intel_disable_transcoder(dev_priv, (enum pipe )pipe);
  }
  if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 1U) {
    {
    reg = (u32 )(pipe * 4096 + 918272);
    temp = i915_read32___6(dev_priv, reg);
    temp = temp & 536870911U;
    temp = temp | 1610612736U;
    i915_write32___4(dev_priv, reg, temp);
    temp = i915_read32___6(dev_priv, 815104U);
    }
    if (pipe == 0) {
      goto case_0;
    } else
    if (pipe == 1) {
      goto case_1;
    } else
    if (pipe == 2) {
      goto case_2;
    } else {
      goto switch_default;
      if (0) {
        case_0:
        temp = temp & 4294967287U;
        goto ldv_38973;
        case_1:
        temp = temp & 4294967151U;
        goto ldv_38973;
        case_2:
        temp = temp & 4294964991U;
        goto ldv_38973;
        switch_default:
        __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p"),
                             "i" (2786), "i" (12UL));
        ldv_38977: ;
        goto ldv_38977;
      } else {
      }
    }
    ldv_38973:
    {
    i915_write32___4(dev_priv, 815104U, temp);
    }
  } else {
  }
  {
  intel_disable_pch_pll(dev_priv, (enum pipe )pipe);
  reg = (u32 )(pipe * 4096 + 983052);
  temp = i915_read32___6(dev_priv, reg);
  i915_write32___4(dev_priv, reg, temp & 4294967279U);
  reg = (u32 )(pipe * 4096 + 393472);
  temp = i915_read32___6(dev_priv, reg);
  i915_write32___4(dev_priv, reg, temp & 4294950911U);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  __const_udelay(429500UL);
  reg = (u32 )(pipe * 4096 + 983052);
  temp = i915_read32___6(dev_priv, reg);
  i915_write32___4(dev_priv, reg, temp & 4294959103U);
  readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
  __const_udelay(429500UL);
  intel_crtc->active = (bool )0;
  intel_update_watermarks(dev);
  mutex_lock_nested(& dev->struct_mutex, 0U);
  intel_update_fbc(dev);
  intel_clear_scanline_wait(dev);
  mutex_unlock(& dev->struct_mutex);
  }
  return;
}
}
static void ironlake_crtc_dpms(struct drm_crtc *crtc , int mode )
{ struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int pipe ;
  int plane ;
  {
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  pipe = (int )intel_crtc->pipe;
  plane = (int )intel_crtc->plane;
  if (mode == 0) {
    goto case_0;
  } else
  if (mode == 1) {
    goto case_1;
  } else
  if (mode == 2) {
    goto case_2;
  } else
  if (mode == 3) {
    goto case_3;
  } else
  if (0) {
    case_0: ;
    case_1: ;
    case_2:
    {
    drm_ut_debug_printk(4U, "drm", "ironlake_crtc_dpms", "crtc %d/%d dpms on\n", pipe,
                        plane);
    ironlake_crtc_enable(crtc);
    }
    goto ldv_38991;
    case_3:
    {
    drm_ut_debug_printk(4U, "drm", "ironlake_crtc_dpms", "crtc %d/%d dpms off\n",
                        pipe, plane);
    ironlake_crtc_disable(crtc);
    }
    goto ldv_38991;
  } else {
  }
  ldv_38991: ;
  return;
}
}
static void intel_crtc_dpms_overlay(struct intel_crtc *intel_crtc , bool enable )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  {
  if (! enable) {
    if ((unsigned long )intel_crtc->overlay != (unsigned long )((struct intel_overlay *)0)) {
      {
      dev = intel_crtc->base.dev;
      dev_priv = (struct drm_i915_private *)dev->dev_private;
      mutex_lock_nested(& dev->struct_mutex, 0U);
      dev_priv->mm.interruptible = (bool )0;
      intel_overlay_switch_off(intel_crtc->overlay);
      dev_priv->mm.interruptible = (bool )1;
      mutex_unlock(& dev->struct_mutex);
      }
    } else {
    }
  } else {
  }
  return;
}
}
static void i9xx_crtc_enable(struct drm_crtc *crtc )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int pipe ;
  int plane ;
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  pipe = (int )intel_crtc->pipe;
  plane = (int )intel_crtc->plane;
  if ((int )intel_crtc->active) {
    return;
  } else {
  }
  {
  intel_crtc->active = (bool )1;
  intel_update_watermarks(dev);
  intel_enable_pll(dev_priv, (enum pipe )pipe);
  intel_enable_pipe(dev_priv, (enum pipe )pipe, (bool )0);
  intel_enable_plane(dev_priv, (enum plane )plane, (enum pipe )pipe);
  intel_crtc_load_lut(crtc);
  intel_update_fbc(dev);
  intel_crtc_dpms_overlay(intel_crtc, (bool )1);
  intel_crtc_update_cursor(crtc, (bool )1);
  }
  return;
}
}
static void i9xx_crtc_disable(struct drm_crtc *crtc )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int pipe ;
  int plane ;
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  pipe = (int )intel_crtc->pipe;
  plane = (int )intel_crtc->plane;
  if (! intel_crtc->active) {
    return;
  } else {
  }
  {
  intel_crtc_wait_for_pending_flips(crtc);
  drm_vblank_off(dev, pipe);
  intel_crtc_dpms_overlay(intel_crtc, (bool )0);
  intel_crtc_update_cursor(crtc, (bool )0);
  }
  if (dev_priv->cfb_plane == plane) {
    if ((unsigned long )dev_priv->display.disable_fbc != (unsigned long )((void (*)(struct drm_device * ))0)) {
      {
      (*(dev_priv->display.disable_fbc))(dev);
      }
    } else {
    }
  } else {
  }
  {
  intel_disable_plane(dev_priv, (enum plane )plane, (enum pipe )pipe);
  intel_disable_pipe(dev_priv, (enum pipe )pipe);
  intel_disable_pll(dev_priv, (enum pipe )pipe);
  intel_crtc->active = (bool )0;
  intel_update_fbc(dev);
  intel_update_watermarks(dev);
  intel_clear_scanline_wait(dev);
  }
  return;
}
}
static void i9xx_crtc_dpms(struct drm_crtc *crtc , int mode )
{
  {
  if (mode == 0) {
    goto case_0;
  } else
  if (mode == 1) {
    goto case_1;
  } else
  if (mode == 2) {
    goto case_2;
  } else
  if (mode == 3) {
    goto case_3;
  } else
  if (0) {
    case_0: ;
    case_1: ;
    case_2:
    {
    i9xx_crtc_enable(crtc);
    }
    goto ldv_39026;
    case_3:
    {
    i9xx_crtc_disable(crtc);
    }
    goto ldv_39026;
  } else {
  }
  ldv_39026: ;
  return;
}
}
static void intel_crtc_dpms(struct drm_crtc *crtc , int mode )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct drm_i915_master_private *master_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int pipe ;
  bool enabled ;
  int tmp ;
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  pipe = (int )intel_crtc->pipe;
  if (intel_crtc->dpms_mode == mode) {
    return;
  } else {
  }
  {
  intel_crtc->dpms_mode = mode;
  (*(dev_priv->display.dpms))(crtc, mode);
  }
  if ((unsigned long )(dev->primary)->master == (unsigned long )((struct drm_master *)0)) {
    return;
  } else {
  }
  master_priv = (struct drm_i915_master_private *)((dev->primary)->master)->driver_priv;
  if ((unsigned long )master_priv->sarea_priv == (unsigned long )((struct _drm_i915_sarea *)0)) {
    return;
  } else {
  }
  if ((int )crtc->enabled) {
    if (mode != 3) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  enabled = (bool )tmp;
  if (pipe == 0) {
    goto case_0;
  } else
  if (pipe == 1) {
    goto case_1;
  } else {
    goto switch_default;
    if (0) {
      case_0: ;
      if ((int )enabled) {
        (master_priv->sarea_priv)->pipeA_w = crtc->mode.hdisplay;
      } else {
        (master_priv->sarea_priv)->pipeA_w = 0;
      }
      if ((int )enabled) {
        (master_priv->sarea_priv)->pipeA_h = crtc->mode.vdisplay;
      } else {
        (master_priv->sarea_priv)->pipeA_h = 0;
      }
      goto ldv_39041;
      case_1: ;
      if ((int )enabled) {
        (master_priv->sarea_priv)->pipeB_w = crtc->mode.hdisplay;
      } else {
        (master_priv->sarea_priv)->pipeB_w = 0;
      }
      if ((int )enabled) {
        (master_priv->sarea_priv)->pipeB_h = crtc->mode.vdisplay;
      } else {
        (master_priv->sarea_priv)->pipeB_h = 0;
      }
      goto ldv_39041;
      switch_default:
      {
      drm_err("intel_crtc_dpms", "Can\'t update pipe %c in SAREA\n", pipe + 65);
      }
      goto ldv_39041;
    } else {
    }
  }
  ldv_39041: ;
  return;
}
}
static void intel_crtc_disable(struct drm_crtc *crtc )
{ struct drm_crtc_helper_funcs *crtc_funcs ;
  struct drm_device *dev ;
  struct drm_framebuffer const *__mptr ;
  {
  {
  crtc_funcs = (struct drm_crtc_helper_funcs *)crtc->helper_private;
  dev = crtc->dev;
  (*(crtc_funcs->dpms))(crtc, 3);
  }
  if ((unsigned long )crtc->fb != (unsigned long )((struct drm_framebuffer *)0)) {
    {
    mutex_lock_nested(& dev->struct_mutex, 0U);
    __mptr = (struct drm_framebuffer const *)crtc->fb;
    i915_gem_object_unpin(((struct intel_framebuffer *)__mptr)->obj);
    mutex_unlock(& dev->struct_mutex);
    }
  } else {
  }
  return;
}
}
static void i9xx_crtc_prepare(struct drm_crtc *crtc )
{
  {
  {
  i9xx_crtc_disable(crtc);
  }
  return;
}
}
static void i9xx_crtc_commit(struct drm_crtc *crtc )
{
  {
  {
  i9xx_crtc_enable(crtc);
  }
  return;
}
}
static void ironlake_crtc_prepare(struct drm_crtc *crtc )
{
  {
  {
  ironlake_crtc_disable(crtc);
  }
  return;
}
}
static void ironlake_crtc_commit(struct drm_crtc *crtc )
{
  {
  {
  ironlake_crtc_enable(crtc);
  }
  return;
}
}
void intel_encoder_prepare(struct drm_encoder *encoder )
{ struct drm_encoder_helper_funcs *encoder_funcs ;
  {
  {
  encoder_funcs = (struct drm_encoder_helper_funcs *)encoder->helper_private;
  (*(encoder_funcs->dpms))(encoder, 3);
  }
  return;
}
}
void intel_encoder_commit(struct drm_encoder *encoder )
{ struct drm_encoder_helper_funcs *encoder_funcs ;
  {
  {
  encoder_funcs = (struct drm_encoder_helper_funcs *)encoder->helper_private;
  (*(encoder_funcs->dpms))(encoder, 0);
  }
  return;
}
}
void intel_encoder_destroy(struct drm_encoder *encoder )
{ struct intel_encoder *intel_encoder ;
  struct drm_encoder const *__mptr ;
  {
  {
  __mptr = (struct drm_encoder const *)encoder;
  intel_encoder = (struct intel_encoder *)__mptr;
  drm_encoder_cleanup(encoder);
  kfree((void const *)intel_encoder);
  }
  return;
}
}
static bool intel_crtc_mode_fixup(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                                  struct drm_display_mode *adjusted_mode )
{ struct drm_device *dev ;
  {
  dev = crtc->dev;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    goto _L;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    goto _L;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    _L:
    if (mode->clock * 3 > 10800000) {
      return ((bool )0);
    } else {
    }
  } else {
  }
  if (adjusted_mode->crtc_htotal == 0) {
    {
    drm_mode_set_crtcinfo(adjusted_mode, 0);
    }
  } else {
  }
  return ((bool )1);
}
}
static int i945_get_display_clock_speed(struct drm_device *dev )
{
  {
  return (400000);
}
}
static int i915_get_display_clock_speed(struct drm_device *dev )
{
  {
  return (333000);
}
}
static int i9xx_misc_get_display_clock_speed(struct drm_device *dev )
{
  {
  return (200000);
}
}
static int i915gm_get_display_clock_speed(struct drm_device *dev )
{ u16 gcfgc ;
  {
  {
  gcfgc = (u16 )0U;
  pci_read_config_word(dev->pdev, 240, & gcfgc);
  }
  if (((int )gcfgc & 128) != 0) {
    return (133000);
  } else
  if (((int )gcfgc & 112) == 64) {
    goto case_64;
  } else
  if (((int )gcfgc & 112) == 0) {
    goto case_0;
  } else {
    goto switch_default;
    if (0) {
      case_64: ;
      return (333000);
      switch_default: ;
      case_0: ;
      return (190000);
    } else {
    }
  }
}
}
static int i865_get_display_clock_speed(struct drm_device *dev )
{
  {
  return (266000);
}
}
static int i855_get_display_clock_speed(struct drm_device *dev )
{ u16 hpllcc ;
  {
  hpllcc = (u16 )0U;
  if (((int )hpllcc & 15) == 0) {
    goto case_0;
  } else
  if (((int )hpllcc & 15) == 1) {
    goto case_1;
  } else
  if (((int )hpllcc & 15) == 3) {
    goto case_3;
  } else
  if (((int )hpllcc & 15) == 2) {
    goto case_2;
  } else
  if (0) {
    case_0: ;
    case_1: ;
    return (200000);
    case_3: ;
    return (250000);
    case_2: ;
    return (133000);
  } else {
  }
  return (0);
}
}
static int i830_get_display_clock_speed(struct drm_device *dev )
{
  {
  return (133000);
}
}
static void fdi_reduce_ratio(u32 *num , u32 *den )
{
  {
  goto ldv_39125;
  ldv_39124:
  *num = *num >> 1;
  *den = *den >> 1;
  ldv_39125: ;
  if (*num > 16777215U) {
    goto ldv_39124;
  } else
  if (*den > 16777215U) {
    goto ldv_39124;
  } else {
    goto ldv_39126;
  }
  ldv_39126: ;
  return;
}
}
static void ironlake_compute_m_n(int bits_per_pixel , int nlanes , int pixel_clock ,
                                 int link_clock , struct fdi_m_n *m_n )
{
  {
  {
  m_n->tu = 64U;
  m_n->gmch_m = (u32 )(bits_per_pixel * pixel_clock);
  m_n->gmch_n = (u32 )((link_clock * nlanes) * 8);
  fdi_reduce_ratio(& m_n->gmch_m, & m_n->gmch_n);
  m_n->link_m = (u32 )pixel_clock;
  m_n->link_n = (u32 )link_clock;
  fdi_reduce_ratio(& m_n->link_m, & m_n->link_n);
  }
  return;
}
}
static struct intel_watermark_params const pineview_display_wm = {512UL, 511UL, 63UL, 10UL, 64UL};
static struct intel_watermark_params const pineview_display_hplloff_wm = {512UL, 511UL, 0UL, 10UL, 64UL};
static struct intel_watermark_params const pineview_cursor_wm = {64UL, 63UL, 0UL, 5UL, 64UL};
static struct intel_watermark_params const pineview_cursor_hplloff_wm = {64UL, 63UL, 0UL, 5UL, 64UL};
static struct intel_watermark_params const g4x_wm_info = {127UL, 63UL, 63UL, 2UL, 64UL};
static struct intel_watermark_params const g4x_cursor_wm_info = {64UL, 32UL, 8UL, 2UL, 64UL};
static struct intel_watermark_params const i965_cursor_wm_info = {64UL, 32UL, 8UL, 2UL, 64UL};
static struct intel_watermark_params const i945_wm_info = {127UL, 63UL, 1UL, 2UL, 64UL};
static struct intel_watermark_params const i915_wm_info = {95UL, 63UL, 1UL, 2UL, 64UL};
static struct intel_watermark_params const i855_wm_info = {127UL, 63UL, 1UL, 2UL, 32UL};
static struct intel_watermark_params const i830_wm_info = {95UL, 63UL, 1UL, 2UL, 32UL};
static struct intel_watermark_params const ironlake_display_wm_info = {128UL, 64UL, 8UL, 2UL, 64UL};
static struct intel_watermark_params const ironlake_cursor_wm_info = {32UL, 16UL, 8UL, 2UL, 64UL};
static struct intel_watermark_params const ironlake_display_srwm_info = {512UL, 511UL, 63UL, 2UL, 64UL};
static struct intel_watermark_params const ironlake_cursor_srwm_info = {64UL, 63UL, 8UL, 2UL, 64UL};
static struct intel_watermark_params const sandybridge_display_wm_info = {128UL, 127UL, 8UL, 2UL, 64UL};
static struct intel_watermark_params const sandybridge_cursor_wm_info = {32UL, 31UL, 8UL, 2UL, 64UL};
static struct intel_watermark_params const sandybridge_display_srwm_info = {512UL, 511UL, 63UL, 2UL, 64UL};
static struct intel_watermark_params const sandybridge_cursor_srwm_info = {64UL, 63UL, 8UL, 2UL, 64UL};
static unsigned long intel_calculate_wm(unsigned long clock_in_khz , struct intel_watermark_params const *wm ,
                                        int fifo_size , int pixel_size , unsigned long latency_ns___0 )
{ long entries_required ;
  long wm_size ;
  {
  {
  entries_required = (long )((((clock_in_khz / 1000UL) * (unsigned long )pixel_size) * latency_ns___0) / 1000UL);
  entries_required = (long )((((unsigned long )wm->cacheline_size + (unsigned long )entries_required) - 1UL) / (unsigned long )wm->cacheline_size);
  drm_ut_debug_printk(4U, "drm", "intel_calculate_wm", "FIFO entries required for mode: %ld\n",
                      entries_required);
  wm_size = (long )((unsigned long )fifo_size - ((unsigned long )wm->guard_size + (unsigned long )entries_required));
  drm_ut_debug_printk(4U, "drm", "intel_calculate_wm", "FIFO watermark level: %ld\n",
                      wm_size);
  }
  if ((long )wm->max_wm < wm_size) {
    wm_size = (long )wm->max_wm;
  } else {
  }
  if (wm_size <= 0L) {
    wm_size = (long )wm->default_wm;
  } else {
  }
  return ((unsigned long )wm_size);
}
}
static struct cxsr_latency const cxsr_latency_table[30U] =
  { {1, 0, 800UL, 400UL, 3382UL, 33382UL, 3983UL, 33983UL},
        {1, 0, 800UL, 667UL, 3354UL, 33354UL, 3807UL, 33807UL},
        {1, 0, 800UL, 800UL, 3347UL, 33347UL, 3763UL, 33763UL},
        {1, 1, 800UL, 667UL, 6420UL, 36420UL, 6873UL, 36873UL},
        {1, 1, 800UL, 800UL, 5902UL, 35902UL, 6318UL, 36318UL},
        {1, 0, 667UL, 400UL, 3400UL, 33400UL, 4021UL, 34021UL},
        {1, 0, 667UL, 667UL, 3372UL, 33372UL, 3845UL, 33845UL},
        {1, 0, 667UL, 800UL, 3386UL, 33386UL, 3822UL, 33822UL},
        {1, 1, 667UL, 667UL, 6438UL, 36438UL, 6911UL, 36911UL},
        {1, 1, 667UL, 800UL, 5941UL, 35941UL, 6377UL, 36377UL},
        {1, 0, 400UL, 400UL, 3472UL, 33472UL, 4173UL, 34173UL},
        {1, 0, 400UL, 667UL, 3443UL, 33443UL, 3996UL, 33996UL},
        {1, 0, 400UL, 800UL, 3430UL, 33430UL, 3946UL, 33946UL},
        {1, 1, 400UL, 667UL, 6509UL, 36509UL, 7062UL, 37062UL},
        {1, 1, 400UL, 800UL, 5985UL, 35985UL, 6501UL, 36501UL},
        {0, 0, 800UL, 400UL, 3438UL, 33438UL, 4065UL, 34065UL},
        {0, 0, 800UL, 667UL, 3410UL, 33410UL, 3889UL, 33889UL},
        {0, 0, 800UL, 800UL, 3403UL, 33403UL, 3845UL, 33845UL},
        {0, 1, 800UL, 667UL, 6476UL, 36476UL, 6955UL, 36955UL},
        {0, 1, 800UL, 800UL, 5958UL, 35958UL, 6400UL, 36400UL},
        {0, 0, 667UL, 400UL, 3456UL, 33456UL, 4103UL, 34106UL},
        {0, 0, 667UL, 667UL, 3428UL, 33428UL, 3927UL, 33927UL},
        {0, 0, 667UL, 800UL, 3443UL, 33443UL, 3905UL, 33905UL},
        {0, 1, 667UL, 667UL, 6494UL, 36494UL, 6993UL, 36993UL},
        {0, 1, 667UL, 800UL, 5998UL, 35998UL, 6460UL, 36460UL},
        {0, 0, 400UL, 400UL, 3528UL, 33528UL, 4255UL, 34255UL},
        {0, 0, 400UL, 667UL, 3500UL, 33500UL, 4079UL, 34079UL},
        {0, 0, 400UL, 800UL, 3487UL, 33487UL, 4029UL, 34029UL},
        {0, 1, 400UL, 667UL, 6566UL, 36566UL, 7145UL, 37145UL},
        {0, 1, 400UL, 800UL, 6042UL, 36042UL, 6584UL, 36584UL}};
static struct cxsr_latency const *intel_get_cxsr_latency(int is_desktop , int is_ddr3 ,
                                                           int fsb , int mem )
{ struct cxsr_latency const *latency ;
  int i ;
  {
  if (fsb == 0) {
    return ((struct cxsr_latency const *)0);
  } else
  if (mem == 0) {
    return ((struct cxsr_latency const *)0);
  } else {
  }
  i = 0;
  goto ldv_39190;
  ldv_39189:
  latency = (struct cxsr_latency const *)(& cxsr_latency_table) + (unsigned long )i;
  if ((int )latency->is_desktop == is_desktop) {
    if ((int )latency->is_ddr3 == is_ddr3) {
      if ((unsigned long )fsb == (unsigned long )latency->fsb_freq) {
        if ((unsigned long )mem == (unsigned long )latency->mem_freq) {
          return (latency);
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  i = i + 1;
  ldv_39190: ;
  if ((unsigned int )i <= 29U) {
    goto ldv_39189;
  } else {
    goto ldv_39191;
  }
  ldv_39191:
  {
  drm_ut_debug_printk(4U, "drm", "intel_get_cxsr_latency", "Unknown FSB/MEM found, disable CxSR\n");
  }
  return ((struct cxsr_latency const *)0);
}
}
static void pineview_disable_cxsr(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 tmp ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = i915_read32___6(dev_priv, 458812U);
  i915_write32___4(dev_priv, 458812U, tmp & 3221225471U);
  }
  return;
}
}
static int const latency_ns = (int const )5000;
static int i9xx_get_fifo_size(struct drm_device *dev , int plane )
{ struct drm_i915_private *dev_priv ;
  uint32_t dsparb ;
  u32 tmp ;
  int size ;
  char *tmp___0 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = i915_read32___6(dev_priv, 458800U);
  dsparb = tmp;
  size = (int )dsparb & 127;
  }
  if (plane != 0) {
    size = (int )(((dsparb >> 7) & 127U) - (uint32_t )size);
  } else {
  }
  if (plane != 0) {
    tmp___0 = (char *)"B";
  } else {
    tmp___0 = (char *)"A";
  }
  {
  drm_ut_debug_printk(4U, "drm", "i9xx_get_fifo_size", "FIFO size - (0x%08x) %s: %d\n",
                      dsparb, tmp___0, size);
  }
  return (size);
}
}
static int i85x_get_fifo_size(struct drm_device *dev , int plane )
{ struct drm_i915_private *dev_priv ;
  uint32_t dsparb ;
  u32 tmp ;
  int size ;
  char *tmp___0 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = i915_read32___6(dev_priv, 458800U);
  dsparb = tmp;
  size = (int )dsparb & 511;
  }
  if (plane != 0) {
    size = (int )(((dsparb >> 9) & 511U) - (uint32_t )size);
  } else {
  }
  size = size >> 1;
  if (plane != 0) {
    tmp___0 = (char *)"B";
  } else {
    tmp___0 = (char *)"A";
  }
  {
  drm_ut_debug_printk(4U, "drm", "i85x_get_fifo_size", "FIFO size - (0x%08x) %s: %d\n",
                      dsparb, tmp___0, size);
  }
  return (size);
}
}
static int i845_get_fifo_size(struct drm_device *dev , int plane )
{ struct drm_i915_private *dev_priv ;
  uint32_t dsparb ;
  u32 tmp ;
  int size ;
  char *tmp___0 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = i915_read32___6(dev_priv, 458800U);
  dsparb = tmp;
  size = (int )dsparb & 127;
  size = size >> 2;
  }
  if (plane != 0) {
    tmp___0 = (char *)"B";
  } else {
    tmp___0 = (char *)"A";
  }
  {
  drm_ut_debug_printk(4U, "drm", "i845_get_fifo_size", "FIFO size - (0x%08x) %s: %d\n",
                      dsparb, tmp___0, size);
  }
  return (size);
}
}
static int i830_get_fifo_size(struct drm_device *dev , int plane )
{ struct drm_i915_private *dev_priv ;
  uint32_t dsparb ;
  u32 tmp ;
  int size ;
  char *tmp___0 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = i915_read32___6(dev_priv, 458800U);
  dsparb = tmp;
  size = (int )dsparb & 127;
  size = size >> 1;
  }
  if (plane != 0) {
    tmp___0 = (char *)"B";
  } else {
    tmp___0 = (char *)"A";
  }
  {
  drm_ut_debug_printk(4U, "drm", "i830_get_fifo_size", "FIFO size - (0x%08x) %s: %d\n",
                      dsparb, tmp___0, size);
  }
  return (size);
}
}
static struct drm_crtc *single_enabled_crtc(struct drm_device *dev )
{ struct drm_crtc *crtc ;
  struct drm_crtc *enabled ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  {
  enabled = (struct drm_crtc *)0;
  __mptr = (struct list_head const *)dev->mode_config.crtc_list.next;
  crtc = (struct drm_crtc *)__mptr + 0x0ffffffffffffff8UL;
  goto ldv_39240;
  ldv_39239: ;
  if ((int )crtc->enabled) {
    if ((unsigned long )crtc->fb != (unsigned long )((struct drm_framebuffer *)0)) {
      if ((unsigned long )enabled != (unsigned long )((struct drm_crtc *)0)) {
        return ((struct drm_crtc *)0);
      } else {
      }
      enabled = crtc;
    } else {
    }
  } else {
  }
  __mptr___0 = (struct list_head const *)crtc->head.next;
  crtc = (struct drm_crtc *)__mptr___0 + 0x0ffffffffffffff8UL;
  ldv_39240: ;
  if ((unsigned long )(& crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
    goto ldv_39239;
  } else {
    goto ldv_39241;
  }
  ldv_39241: ;
  return (enabled);
}
}
static void pineview_update_wm(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct drm_crtc *crtc ;
  struct cxsr_latency const *latency ;
  u32 reg ;
  unsigned long wm ;
  int clock ;
  int pixel_size ;
  u32 tmp ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  latency = intel_get_cxsr_latency(dev->pci_device == 40961, (int )dev_priv->is_ddr3,
                                   (int )dev_priv->fsb_freq, (int )dev_priv->mem_freq);
  }
  if ((unsigned long )latency == (unsigned long )((struct cxsr_latency const *)0)) {
    {
    drm_ut_debug_printk(4U, "drm", "pineview_update_wm", "Unknown FSB/MEM found, disable CxSR\n");
    pineview_disable_cxsr(dev);
    }
    return;
  } else {
  }
  {
  crtc = single_enabled_crtc(dev);
  }
  if ((unsigned long )crtc != (unsigned long )((struct drm_crtc *)0)) {
    {
    clock = crtc->mode.clock;
    pixel_size = (crtc->fb)->bits_per_pixel / 8;
    wm = intel_calculate_wm((unsigned long )clock, & pineview_display_wm, (int )pineview_display_wm.fifo_size,
                            pixel_size, (unsigned long )latency->display_sr);
    reg = i915_read32___6(dev_priv, 458804U);
    reg = reg & 8388607U;
    reg = ((u32 )wm << 23U) | reg;
    i915_write32___4(dev_priv, 458804U, reg);
    drm_ut_debug_printk(4U, "drm", "pineview_update_wm", "DSPFW1 register is %x\n",
                        reg);
    wm = intel_calculate_wm((unsigned long )clock, & pineview_cursor_wm, (int )pineview_display_wm.fifo_size,
                            pixel_size, (unsigned long )latency->cursor_sr);
    reg = i915_read32___6(dev_priv, 458812U);
    reg = reg & 3238002687U;
    reg = (((u32 )wm & 63U) << 24U) | reg;
    i915_write32___4(dev_priv, 458812U, reg);
    wm = intel_calculate_wm((unsigned long )clock, & pineview_display_hplloff_wm,
                            (int )pineview_display_hplloff_wm.fifo_size, pixel_size,
                            (unsigned long )latency->display_hpll_disable);
    reg = i915_read32___6(dev_priv, 458812U);
    reg = reg & 4294966784U;
    reg = ((u32 )wm & 511U) | reg;
    i915_write32___4(dev_priv, 458812U, reg);
    wm = intel_calculate_wm((unsigned long )clock, & pineview_cursor_hplloff_wm, (int )pineview_display_hplloff_wm.fifo_size,
                            pixel_size, (unsigned long )latency->cursor_hpll_disable);
    reg = i915_read32___6(dev_priv, 458812U);
    reg = reg & 4290838527U;
    reg = (((u32 )wm & 63U) << 16U) | reg;
    i915_write32___4(dev_priv, 458812U, reg);
    drm_ut_debug_printk(4U, "drm", "pineview_update_wm", "DSPFW3 register is %x\n",
                        reg);
    tmp = i915_read32___6(dev_priv, 458812U);
    i915_write32___4(dev_priv, 458812U, tmp | 1073741824U);
    drm_ut_debug_printk(4U, "drm", "pineview_update_wm", "Self-refresh is enabled\n");
    }
  } else {
    {
    pineview_disable_cxsr(dev);
    drm_ut_debug_printk(4U, "drm", "pineview_update_wm", "Self-refresh is disabled\n");
    }
  }
  return;
}
}
static bool g4x_compute_wm0(struct drm_device *dev , int plane , struct intel_watermark_params const *display ,
                            int display_latency_ns , struct intel_watermark_params const *cursor ,
                            int cursor_latency_ns , int *plane_wm , int *cursor_wm )
{ struct drm_crtc *crtc ;
  int htotal ;
  int hdisplay ;
  int clock ;
  int pixel_size ;
  int line_time_us ;
  int line_count ;
  int entries ;
  int tlb_miss ;
  {
  {
  crtc = intel_get_crtc_for_plane(dev, plane);
  }
  if ((unsigned long )crtc->fb == (unsigned long )((struct drm_framebuffer *)0)) {
    *cursor_wm = (int )cursor->guard_size;
    *plane_wm = (int )display->guard_size;
    return ((bool )0);
  } else
  if (! crtc->enabled) {
    *cursor_wm = (int )cursor->guard_size;
    *plane_wm = (int )display->guard_size;
    return ((bool )0);
  } else {
  }
  htotal = crtc->mode.htotal;
  hdisplay = crtc->mode.hdisplay;
  clock = crtc->mode.clock;
  pixel_size = (crtc->fb)->bits_per_pixel / 8;
  entries = (((clock * pixel_size) / 1000) * display_latency_ns) / 1000;
  tlb_miss = (int )((unsigned int )display->fifo_size * (unsigned int )display->cacheline_size + (unsigned int )(hdisplay * -8));
  if (tlb_miss > 0) {
    entries = entries + tlb_miss;
  } else {
  }
  entries = (int )((((unsigned long )entries + (unsigned long )display->cacheline_size) - 1UL) / (unsigned long )display->cacheline_size);
  *plane_wm = (int )((unsigned int )display->guard_size + (unsigned int )entries);
  if (*plane_wm > (int )display->max_wm) {
    *plane_wm = (int )display->max_wm;
  } else {
  }
  line_time_us = (htotal * 1000) / clock;
  line_count = (cursor_latency_ns / line_time_us + 1000) / 1000;
  entries = (line_count * 64) * pixel_size;
  tlb_miss = (int )((unsigned int )cursor->fifo_size * (unsigned int )cursor->cacheline_size + (unsigned int )(hdisplay * -8));
  if (tlb_miss > 0) {
    entries = entries + tlb_miss;
  } else {
  }
  entries = (int )((((unsigned long )entries + (unsigned long )cursor->cacheline_size) - 1UL) / (unsigned long )cursor->cacheline_size);
  *cursor_wm = (int )((unsigned int )cursor->guard_size + (unsigned int )entries);
  if (*cursor_wm > (int )cursor->max_wm) {
    *cursor_wm = (int )cursor->max_wm;
  } else {
  }
  return ((bool )1);
}
}
static bool g4x_check_srwm(struct drm_device *dev , int display_wm , int cursor_wm ,
                           struct intel_watermark_params const *display , struct intel_watermark_params const *cursor )
{
  {
  {
  drm_ut_debug_printk(4U, "drm", "g4x_check_srwm", "SR watermark: display plane %d, cursor %d\n",
                      display_wm, cursor_wm);
  }
  if ((unsigned long )display_wm > (unsigned long )display->max_wm) {
    {
    drm_ut_debug_printk(4U, "drm", "g4x_check_srwm", "display watermark is too large(%d/%ld), disabling\n",
                        display_wm, display->max_wm);
    }
    return ((bool )0);
  } else {
  }
  if ((unsigned long )cursor_wm > (unsigned long )cursor->max_wm) {
    {
    drm_ut_debug_printk(4U, "drm", "g4x_check_srwm", "cursor watermark is too large(%d/%ld), disabling\n",
                        cursor_wm, cursor->max_wm);
    }
    return ((bool )0);
  } else {
  }
  if (display_wm == 0) {
    if (cursor_wm == 0) {
      {
      drm_ut_debug_printk(4U, "drm", "g4x_check_srwm", "SR latency is 0, disabling\n");
      }
      return ((bool )0);
    } else {
    }
  } else {
  }
  return ((bool )1);
}
}
static bool g4x_compute_srwm(struct drm_device *dev , int plane , int latency_ns___0 ,
                             struct intel_watermark_params const *display , struct intel_watermark_params const *cursor ,
                             int *display_wm , int *cursor_wm )
{ struct drm_crtc *crtc ;
  int hdisplay ;
  int htotal ;
  int pixel_size ;
  int clock ;
  unsigned long line_time_us ;
  int line_count ;
  int line_size ;
  int small ;
  int large ;
  int entries ;
  int tmp ;
  int _min1 ;
  int _min2 ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  if (latency_ns___0 == 0) {
    tmp = 0;
    *cursor_wm = tmp;
    *display_wm = tmp;
    return ((bool )0);
  } else {
  }
  {
  crtc = intel_get_crtc_for_plane(dev, plane);
  hdisplay = crtc->mode.hdisplay;
  htotal = crtc->mode.htotal;
  clock = crtc->mode.clock;
  pixel_size = (crtc->fb)->bits_per_pixel / 8;
  line_time_us = (unsigned long )((htotal * 1000) / clock);
  line_count = (int )(((unsigned long )latency_ns___0 / line_time_us + 1000UL) / 1000UL);
  line_size = hdisplay * pixel_size;
  small = (((clock * pixel_size) / 1000) * latency_ns___0) / 1000;
  large = line_count * line_size;
  _min1 = small;
  _min2 = large;
  }
  if (_min1 < _min2) {
    tmp___0 = _min1;
  } else {
    tmp___0 = _min2;
  }
  {
  entries = (int )((((unsigned long )tmp___0 + (unsigned long )display->cacheline_size) - 1UL) / (unsigned long )display->cacheline_size);
  *display_wm = (int )((unsigned int )display->guard_size + (unsigned int )entries);
  entries = (line_count * pixel_size) * 64;
  entries = (int )((((unsigned long )entries + (unsigned long )cursor->cacheline_size) - 1UL) / (unsigned long )cursor->cacheline_size);
  *cursor_wm = (int )((unsigned int )cursor->guard_size + (unsigned int )entries);
  tmp___1 = g4x_check_srwm(dev, *display_wm, *cursor_wm, display, cursor);
  }
  return (tmp___1);
}
}
static void g4x_update_wm(struct drm_device *dev )
{ int sr_latency_ns ;
  struct drm_i915_private *dev_priv ;
  int planea_wm ;
  int planeb_wm ;
  int cursora_wm ;
  int cursorb_wm ;
  int plane_sr ;
  int cursor_sr ;
  unsigned int enabled ;
  bool tmp ;
  bool tmp___0 ;
  u32 tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  {
  {
  sr_latency_ns = 12000;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  enabled = 0U;
  tmp = g4x_compute_wm0(dev, 0, & g4x_wm_info, (int )latency_ns, & g4x_cursor_wm_info,
                        (int )latency_ns, & planea_wm, & cursora_wm);
  }
  if ((int )tmp) {
    enabled = enabled | 1U;
  } else {
  }
  {
  tmp___0 = g4x_compute_wm0(dev, 1, & g4x_wm_info, (int )latency_ns, & g4x_cursor_wm_info,
                            (int )latency_ns, & planeb_wm, & cursorb_wm);
  }
  if ((int )tmp___0) {
    enabled = enabled | 2U;
  } else {
  }
  {
  cursor_sr = 0;
  plane_sr = cursor_sr;
  tmp___2 = is_power_of_2((unsigned long )enabled);
  }
  if ((int )tmp___2) {
    {
    tmp___3 = ffs((int )enabled);
    tmp___4 = g4x_compute_srwm(dev, tmp___3 + -1, sr_latency_ns, & g4x_wm_info, & g4x_cursor_wm_info,
                               & plane_sr, & cursor_sr);
    }
    if ((int )tmp___4) {
      {
      i915_write32___4(dev_priv, 8416U, 32768U);
      }
    } else {
      {
      tmp___1 = i915_read32___6(dev_priv, 8416U);
      i915_write32___4(dev_priv, 8416U, tmp___1 & 4294934527U);
      }
    }
  } else {
    {
    tmp___1 = i915_read32___6(dev_priv, 8416U);
    i915_write32___4(dev_priv, 8416U, tmp___1 & 4294934527U);
    }
  }
  {
  drm_ut_debug_printk(4U, "drm", "g4x_update_wm", "Setting FIFO watermarks - A: plane=%d, cursor=%d, B: plane=%d, cursor=%d, SR: plane=%d, cursor=%d\n",
                      planea_wm, cursora_wm, planeb_wm, cursorb_wm, plane_sr, cursor_sr);
  i915_write32___4(dev_priv, 458804U, (u32 )((((plane_sr << 23) | (cursorb_wm << 16)) | (planeb_wm << 8)) | planea_wm));
  tmp___5 = i915_read32___6(dev_priv, 458808U);
  i915_write32___4(dev_priv, 458808U, (tmp___5 & 16128U) | (u32 )(cursora_wm << 8));
  tmp___6 = i915_read32___6(dev_priv, 458812U);
  i915_write32___4(dev_priv, 458812U, (tmp___6 & 2147483647U) | (u32 )(cursor_sr << 24));
  }
  return;
}
}
static void i965_update_wm(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct drm_crtc *crtc ;
  int srwm ;
  int cursor_sr ;
  int sr_latency_ns ;
  int clock ;
  int htotal ;
  int hdisplay ;
  int pixel_size ;
  unsigned long line_time_us ;
  int entries ;
  u32 tmp ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  srwm = 1;
  cursor_sr = 16;
  crtc = single_enabled_crtc(dev);
  }
  if ((unsigned long )crtc != (unsigned long )((struct drm_crtc *)0)) {
    sr_latency_ns = 12000;
    clock = crtc->mode.clock;
    htotal = crtc->mode.htotal;
    hdisplay = crtc->mode.hdisplay;
    pixel_size = (crtc->fb)->bits_per_pixel / 8;
    line_time_us = (unsigned long )((htotal * 1000) / clock);
    entries = (int )(((unsigned int )(((unsigned long )sr_latency_ns / line_time_us + 1000UL) / 1000UL) * (unsigned int )((unsigned long )pixel_size)) * (unsigned int )((unsigned long )hdisplay));
    entries = (entries + 63) / 64;
    srwm = 512 - entries;
    if (srwm < 0) {
      srwm = 1;
    } else {
    }
    {
    srwm = srwm & 511;
    drm_ut_debug_printk(4U, "drm", "i965_update_wm", "self-refresh entries: %d, wm: %d\n",
                        entries, srwm);
    entries = (int )(((unsigned int )(((unsigned long )sr_latency_ns / line_time_us + 1000UL) / 1000UL) * (unsigned int )((unsigned long )pixel_size)) * 64U);
    entries = (int )((((unsigned long )entries + (unsigned long )i965_cursor_wm_info.cacheline_size) - 1UL) / (unsigned long )i965_cursor_wm_info.cacheline_size);
    cursor_sr = (int )((unsigned int )i965_cursor_wm_info.fifo_size - ((unsigned int )i965_cursor_wm_info.guard_size + (unsigned int )entries));
    }
    if ((unsigned long )cursor_sr > (unsigned long )i965_cursor_wm_info.max_wm) {
      cursor_sr = (int )i965_cursor_wm_info.max_wm;
    } else {
    }
    {
    drm_ut_debug_printk(4U, "drm", "i965_update_wm", "self-refresh watermark: display plane %d cursor %d\n",
                        srwm, cursor_sr);
    }
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
      {
      i915_write32___4(dev_priv, 8416U, 32768U);
      }
    } else {
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    tmp = i915_read32___6(dev_priv, 8416U);
    i915_write32___4(dev_priv, 8416U, tmp & 4294934527U);
    }
  } else {
  }
  {
  drm_ut_debug_printk(4U, "drm", "i965_update_wm", "Setting FIFO watermarks - A: 8, B: 8, C: 8, SR %d\n",
                      srwm);
  i915_write32___4(dev_priv, 458804U, (u32 )((srwm << 23) | 526344));
  i915_write32___4(dev_priv, 458808U, 2056U);
  i915_write32___4(dev_priv, 458812U, (u32 )(cursor_sr << 24));
  }
  return;
}
}
static void i9xx_update_wm(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct intel_watermark_params const *wm_info ;
  uint32_t fwater_lo ;
  uint32_t fwater_hi ;
  int cwm ;
  int srwm ;
  int fifo_size ;
  int planea_wm ;
  int planeb_wm ;
  struct drm_crtc *crtc ;
  struct drm_crtc *enabled ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  u32 tmp___1 ;
  int sr_latency_ns ;
  int clock ;
  int htotal ;
  int hdisplay ;
  int pixel_size ;
  unsigned long line_time_us ;
  int entries ;
  u32 tmp___2 ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  srwm = 1;
  enabled = (struct drm_crtc *)0;
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    wm_info = & i945_wm_info;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 2U) {
    wm_info = & i915_wm_info;
  } else {
    wm_info = & i855_wm_info;
  }
  {
  fifo_size = (*(dev_priv->display.get_fifo_size))(dev, 0);
  crtc = intel_get_crtc_for_plane(dev, 0);
  }
  if ((int )crtc->enabled) {
    if ((unsigned long )crtc->fb != (unsigned long )((struct drm_framebuffer *)0)) {
      {
      tmp = intel_calculate_wm((unsigned long )crtc->mode.clock, wm_info, fifo_size,
                               (crtc->fb)->bits_per_pixel / 8, (unsigned long )latency_ns);
      planea_wm = (int )tmp;
      enabled = crtc;
      }
    } else {
      planea_wm = (int )((unsigned int )fifo_size - (unsigned int )wm_info->guard_size);
    }
  } else {
    planea_wm = (int )((unsigned int )fifo_size - (unsigned int )wm_info->guard_size);
  }
  {
  fifo_size = (*(dev_priv->display.get_fifo_size))(dev, 1);
  crtc = intel_get_crtc_for_plane(dev, 1);
  }
  if ((int )crtc->enabled) {
    if ((unsigned long )crtc->fb != (unsigned long )((struct drm_framebuffer *)0)) {
      {
      tmp___0 = intel_calculate_wm((unsigned long )crtc->mode.clock, wm_info, fifo_size,
                                   (crtc->fb)->bits_per_pixel / 8, (unsigned long )latency_ns);
      planeb_wm = (int )tmp___0;
      }
      if ((unsigned long )enabled == (unsigned long )((struct drm_crtc *)0)) {
        enabled = crtc;
      } else {
        enabled = (struct drm_crtc *)0;
      }
    } else {
      planeb_wm = (int )((unsigned int )fifo_size - (unsigned int )wm_info->guard_size);
    }
  } else {
    planeb_wm = (int )((unsigned int )fifo_size - (unsigned int )wm_info->guard_size);
  }
  {
  drm_ut_debug_printk(4U, "drm", "i9xx_update_wm", "FIFO watermarks - A: %d, B: %d\n",
                      planea_wm, planeb_wm);
  cwm = 2;
  }
  if (dev->pci_device == 10098) {
    {
    i915_write32___4(dev_priv, 8416U, 2147483648U);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    {
    i915_write32___4(dev_priv, 8416U, 2147483648U);
    }
  } else
  if (dev->pci_device == 9618) {
    {
    tmp___1 = i915_read32___6(dev_priv, 8384U);
    i915_write32___4(dev_priv, 8384U, tmp___1 & 4294963199U);
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 2U) {
    if ((unsigned long )enabled != (unsigned long )((struct drm_crtc *)0)) {
      {
      sr_latency_ns = 6000;
      clock = enabled->mode.clock;
      htotal = enabled->mode.htotal;
      hdisplay = enabled->mode.hdisplay;
      pixel_size = (enabled->fb)->bits_per_pixel / 8;
      line_time_us = (unsigned long )((htotal * 1000) / clock);
      entries = (int )(((unsigned int )(((unsigned long )sr_latency_ns / line_time_us + 1000UL) / 1000UL) * (unsigned int )((unsigned long )pixel_size)) * (unsigned int )((unsigned long )hdisplay));
      entries = (int )((((unsigned long )entries + (unsigned long )wm_info->cacheline_size) - 1UL) / (unsigned long )wm_info->cacheline_size);
      drm_ut_debug_printk(4U, "drm", "i9xx_update_wm", "self-refresh entries: %d\n",
                          entries);
      srwm = (int )((unsigned int )wm_info->fifo_size - (unsigned int )entries);
      }
      if (srwm < 0) {
        srwm = 1;
      } else {
      }
      if (dev->pci_device == 10098) {
        {
        i915_write32___4(dev_priv, 8416U, (u32 )((srwm & 255) | 65536));
        }
      } else
      if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
        {
        i915_write32___4(dev_priv, 8416U, (u32 )((srwm & 255) | 65536));
        }
      } else
      if (dev->pci_device == 9618) {
        {
        i915_write32___4(dev_priv, 8416U, (u32 )srwm & 63U);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  drm_ut_debug_printk(4U, "drm", "i9xx_update_wm", "Setting FIFO watermarks - A: %d, B: %d, C: %d, SR %d\n",
                      planea_wm, planeb_wm, cwm, srwm);
  fwater_lo = (uint32_t )(((planeb_wm & 63) << 16) | (planea_wm & 63));
  fwater_hi = (uint32_t )cwm & 31U;
  fwater_lo = fwater_lo | 16777472U;
  fwater_hi = fwater_hi | 256U;
  i915_write32___4(dev_priv, 8408U, fwater_lo);
  i915_write32___4(dev_priv, 8412U, fwater_hi);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 2U) {
    if ((unsigned long )enabled != (unsigned long )((struct drm_crtc *)0)) {
      if (dev->pci_device == 10098) {
        {
        i915_write32___4(dev_priv, 8416U, 2147516416U);
        }
      } else
      if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
        {
        i915_write32___4(dev_priv, 8416U, 2147516416U);
        }
      } else
      if (dev->pci_device == 9618) {
        {
        tmp___2 = i915_read32___6(dev_priv, 8384U);
        i915_write32___4(dev_priv, 8384U, tmp___2 | 4096U);
        }
      } else {
      }
      {
      drm_ut_debug_printk(4U, "drm", "i9xx_update_wm", "memory self refresh enabled\n");
      }
    } else {
      {
      drm_ut_debug_printk(4U, "drm", "i9xx_update_wm", "memory self refresh disabled\n");
      }
    }
  } else {
  }
  return;
}
}
static void i830_update_wm(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct drm_crtc *crtc ;
  uint32_t fwater_lo ;
  int planea_wm ;
  int tmp ;
  unsigned long tmp___0 ;
  u32 tmp___1 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  crtc = single_enabled_crtc(dev);
  }
  if ((unsigned long )crtc == (unsigned long )((struct drm_crtc *)0)) {
    return;
  } else {
  }
  {
  tmp = (*(dev_priv->display.get_fifo_size))(dev, 0);
  tmp___0 = intel_calculate_wm((unsigned long )crtc->mode.clock, & i830_wm_info, tmp,
                               (crtc->fb)->bits_per_pixel / 8, (unsigned long )latency_ns);
  planea_wm = (int )tmp___0;
  tmp___1 = i915_read32___6(dev_priv, 8408U);
  fwater_lo = tmp___1 & 4294963200U;
  fwater_lo = ((uint32_t )planea_wm | fwater_lo) | 768U;
  drm_ut_debug_printk(4U, "drm", "i830_update_wm", "Setting FIFO watermarks - A: %d\n",
                      planea_wm);
  i915_write32___4(dev_priv, 8408U, fwater_lo);
  }
  return;
}
}
static bool ironlake_check_srwm(struct drm_device *dev , int level , int fbc_wm ,
                                int display_wm , int cursor_wm , struct intel_watermark_params const *display ,
                                struct intel_watermark_params const *cursor )
{ struct drm_i915_private *dev_priv ;
  u32 tmp ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  drm_ut_debug_printk(4U, "drm", "ironlake_check_srwm", "watermark %d: display plane %d, fbc lines %d, cursor %d\n",
                      level, display_wm, fbc_wm, cursor_wm);
  }
  if (fbc_wm > 15) {
    {
    drm_ut_debug_printk(4U, "drm", "ironlake_check_srwm", "fbc watermark(%d) is too large(%d), disabling wm%d+\n",
                        fbc_wm, 15, level);
    tmp = i915_read32___6(dev_priv, 282624U);
    i915_write32___4(dev_priv, 282624U, tmp | 32768U);
    }
    return ((bool )0);
  } else {
  }
  if ((unsigned long )display_wm > (unsigned long )display->max_wm) {
    {
    drm_ut_debug_printk(4U, "drm", "ironlake_check_srwm", "display watermark(%d) is too large(%d), disabling wm%d+\n",
                        display_wm, 511, level);
    }
    return ((bool )0);
  } else {
  }
  if ((unsigned long )cursor_wm > (unsigned long )cursor->max_wm) {
    {
    drm_ut_debug_printk(4U, "drm", "ironlake_check_srwm", "cursor watermark(%d) is too large(%d), disabling wm%d+\n",
                        cursor_wm, 63, level);
    }
    return ((bool )0);
  } else {
  }
  if (fbc_wm == 0) {
    if (display_wm == 0) {
      if (cursor_wm == 0) {
        {
        drm_ut_debug_printk(4U, "drm", "ironlake_check_srwm", "latency %d is 0, disabling wm%d+\n",
                            level, level);
        }
        return ((bool )0);
      } else {
      }
    } else {
    }
  } else {
  }
  return ((bool )1);
}
}
static bool ironlake_compute_srwm(struct drm_device *dev , int level , int plane ,
                                  int latency_ns___0 , struct intel_watermark_params const *display ,
                                  struct intel_watermark_params const *cursor ,
                                  int *fbc_wm , int *display_wm , int *cursor_wm )
{ struct drm_crtc *crtc ;
  unsigned long line_time_us ;
  int hdisplay ;
  int htotal ;
  int pixel_size ;
  int clock ;
  int line_count ;
  int line_size ;
  int small ;
  int large ;
  int entries ;
  int tmp ;
  int tmp___0 ;
  int _min1 ;
  int _min2 ;
  int tmp___1 ;
  bool tmp___2 ;
  {
  if (latency_ns___0 == 0) {
    tmp___0 = 0;
    *cursor_wm = tmp___0;
    tmp = tmp___0;
    *display_wm = tmp;
    *fbc_wm = tmp;
    return ((bool )0);
  } else {
  }
  {
  crtc = intel_get_crtc_for_plane(dev, plane);
  hdisplay = crtc->mode.hdisplay;
  htotal = crtc->mode.htotal;
  clock = crtc->mode.clock;
  pixel_size = (crtc->fb)->bits_per_pixel / 8;
  line_time_us = (unsigned long )((htotal * 1000) / clock);
  line_count = (int )(((unsigned long )latency_ns___0 / line_time_us + 1000UL) / 1000UL);
  line_size = hdisplay * pixel_size;
  small = (((clock * pixel_size) / 1000) * latency_ns___0) / 1000;
  large = line_count * line_size;
  _min1 = small;
  _min2 = large;
  }
  if (_min1 < _min2) {
    tmp___1 = _min1;
  } else {
    tmp___1 = _min2;
  }
  {
  entries = (int )((((unsigned long )tmp___1 + (unsigned long )display->cacheline_size) - 1UL) / (unsigned long )display->cacheline_size);
  *display_wm = (int )((unsigned int )display->guard_size + (unsigned int )entries);
  *fbc_wm = ((*display_wm * 64 + line_size) + -1) / line_size + 2;
  entries = (line_count * pixel_size) * 64;
  entries = (int )((((unsigned long )entries + (unsigned long )cursor->cacheline_size) - 1UL) / (unsigned long )cursor->cacheline_size);
  *cursor_wm = (int )((unsigned int )cursor->guard_size + (unsigned int )entries);
  tmp___2 = ironlake_check_srwm(dev, level, *fbc_wm, *display_wm, *cursor_wm, display,
                                cursor);
  }
  return (tmp___2);
}
}
static void ironlake_update_wm(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  int fbc_wm ;
  int plane_wm ;
  int cursor_wm ;
  unsigned int enabled ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u32 tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  u32 tmp___11 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  enabled = 0U;
  tmp = g4x_compute_wm0(dev, 0, & ironlake_display_wm_info, 700, & ironlake_cursor_wm_info,
                        1300, & plane_wm, & cursor_wm);
  }
  if ((int )tmp) {
    {
    i915_write32___4(dev_priv, 282880U, (u32 )((plane_wm << 16) | cursor_wm));
    drm_ut_debug_printk(4U, "drm", "ironlake_update_wm", "FIFO watermarks For pipe A - plane %d, cursor: %d\n",
                        plane_wm, cursor_wm);
    enabled = enabled | 1U;
    }
  } else {
  }
  {
  tmp___0 = g4x_compute_wm0(dev, 1, & ironlake_display_wm_info, 700, & ironlake_cursor_wm_info,
                            1300, & plane_wm, & cursor_wm);
  }
  if ((int )tmp___0) {
    {
    i915_write32___4(dev_priv, 282884U, (u32 )((plane_wm << 16) | cursor_wm));
    drm_ut_debug_printk(4U, "drm", "ironlake_update_wm", "FIFO watermarks For pipe B - plane %d, cursor: %d\n",
                        plane_wm, cursor_wm);
    enabled = enabled | 2U;
    }
  } else {
  }
  {
  i915_write32___4(dev_priv, 282896U, 0U);
  i915_write32___4(dev_priv, 282892U, 0U);
  i915_write32___4(dev_priv, 282888U, 0U);
  tmp___1 = is_power_of_2((unsigned long )enabled);
  }
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    return;
  } else {
  }
  {
  tmp___3 = ffs((int )enabled);
  enabled = (unsigned int )(tmp___3 + -1);
  tmp___4 = i915_read32___6(dev_priv, 70178U);
  tmp___5 = ironlake_compute_srwm(dev, 1, (int )enabled, (int )((tmp___4 & 63U) * 500U),
                                  & ironlake_display_srwm_info, & ironlake_cursor_srwm_info,
                                  & fbc_wm, & plane_wm, & cursor_wm);
  }
  if (tmp___5) {
    tmp___6 = 0;
  } else {
    tmp___6 = 1;
  }
  if (tmp___6) {
    return;
  } else {
  }
  {
  tmp___7 = i915_read32___6(dev_priv, 70178U);
  i915_write32___4(dev_priv, 282888U, (((((tmp___7 & 63U) << 24) | (u32 )(fbc_wm << 20)) | (u32 )(plane_wm << 8)) | (u32 )cursor_wm) | 2147483648U);
  tmp___8 = i915_read32___6(dev_priv, 70178U);
  tmp___9 = ironlake_compute_srwm(dev, 2, (int )enabled, (int )(((tmp___8 >> 8) & 63U) * 500U),
                                  & ironlake_display_srwm_info, & ironlake_cursor_srwm_info,
                                  & fbc_wm, & plane_wm, & cursor_wm);
  }
  if (tmp___9) {
    tmp___10 = 0;
  } else {
    tmp___10 = 1;
  }
  if (tmp___10) {
    return;
  } else {
  }
  {
  tmp___11 = i915_read32___6(dev_priv, 70178U);
  i915_write32___4(dev_priv, 282892U, ((((((tmp___11 >> 8) & 63U) << 24) | (u32 )(fbc_wm << 20)) | (u32 )(plane_wm << 8)) | (u32 )cursor_wm) | 2147483648U);
  }
  return;
}
}
static void sandybridge_update_wm(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  int latency ;
  u32 tmp ;
  int fbc_wm ;
  int plane_wm ;
  int cursor_wm ;
  unsigned int enabled ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  u32 tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  bool tmp___10 ;
  int tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  bool tmp___14 ;
  int tmp___15 ;
  u32 tmp___16 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = i915_read32___6(dev_priv, 1334544U);
  latency = (int )((tmp & 63U) * 100U);
  enabled = 0U;
  tmp___0 = g4x_compute_wm0(dev, 0, & sandybridge_display_wm_info, latency, & sandybridge_cursor_wm_info,
                            latency, & plane_wm, & cursor_wm);
  }
  if ((int )tmp___0) {
    {
    i915_write32___4(dev_priv, 282880U, (u32 )((plane_wm << 16) | cursor_wm));
    drm_ut_debug_printk(4U, "drm", "sandybridge_update_wm", "FIFO watermarks For pipe A - plane %d, cursor: %d\n",
                        plane_wm, cursor_wm);
    enabled = enabled | 1U;
    }
  } else {
  }
  {
  tmp___1 = g4x_compute_wm0(dev, 1, & sandybridge_display_wm_info, latency, & sandybridge_cursor_wm_info,
                            latency, & plane_wm, & cursor_wm);
  }
  if ((int )tmp___1) {
    {
    i915_write32___4(dev_priv, 282884U, (u32 )((plane_wm << 16) | cursor_wm));
    drm_ut_debug_printk(4U, "drm", "sandybridge_update_wm", "FIFO watermarks For pipe B - plane %d, cursor: %d\n",
                        plane_wm, cursor_wm);
    enabled = enabled | 2U;
    }
  } else {
  }
  {
  i915_write32___4(dev_priv, 282896U, 0U);
  i915_write32___4(dev_priv, 282892U, 0U);
  i915_write32___4(dev_priv, 282888U, 0U);
  tmp___2 = is_power_of_2((unsigned long )enabled);
  }
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    return;
  } else {
  }
  {
  tmp___4 = ffs((int )enabled);
  enabled = (unsigned int )(tmp___4 + -1);
  tmp___5 = i915_read32___6(dev_priv, 1334544U);
  tmp___6 = ironlake_compute_srwm(dev, 1, (int )enabled, (int )(((tmp___5 >> 8) & 63U) * 500U),
                                  & sandybridge_display_srwm_info, & sandybridge_cursor_srwm_info,
                                  & fbc_wm, & plane_wm, & cursor_wm);
  }
  if (tmp___6) {
    tmp___7 = 0;
  } else {
    tmp___7 = 1;
  }
  if (tmp___7) {
    return;
  } else {
  }
  {
  tmp___8 = i915_read32___6(dev_priv, 1334544U);
  i915_write32___4(dev_priv, 282888U, ((((((tmp___8 >> 8) & 63U) << 24) | (u32 )(fbc_wm << 20)) | (u32 )(plane_wm << 8)) | (u32 )cursor_wm) | 2147483648U);
  tmp___9 = i915_read32___6(dev_priv, 1334544U);
  tmp___10 = ironlake_compute_srwm(dev, 2, (int )enabled, (int )(((tmp___9 >> 16) & 63U) * 500U),
                                   & sandybridge_display_srwm_info, & sandybridge_cursor_srwm_info,
                                   & fbc_wm, & plane_wm, & cursor_wm);
  }
  if (tmp___10) {
    tmp___11 = 0;
  } else {
    tmp___11 = 1;
  }
  if (tmp___11) {
    return;
  } else {
  }
  {
  tmp___12 = i915_read32___6(dev_priv, 1334544U);
  i915_write32___4(dev_priv, 282892U, ((((((tmp___12 >> 16) & 63U) << 24) | (u32 )(fbc_wm << 20)) | (u32 )(plane_wm << 8)) | (u32 )cursor_wm) | 2147483648U);
  tmp___13 = i915_read32___6(dev_priv, 1334544U);
  tmp___14 = ironlake_compute_srwm(dev, 3, (int )enabled, (int )(((tmp___13 >> 24) & 63U) * 500U),
                                   & sandybridge_display_srwm_info, & sandybridge_cursor_srwm_info,
                                   & fbc_wm, & plane_wm, & cursor_wm);
  }
  if (tmp___14) {
    tmp___15 = 0;
  } else {
    tmp___15 = 1;
  }
  if (tmp___15) {
    return;
  } else {
  }
  {
  tmp___16 = i915_read32___6(dev_priv, 1334544U);
  i915_write32___4(dev_priv, 282896U, ((((tmp___16 & 1056964608U) | (u32 )(fbc_wm << 20)) | (u32 )(plane_wm << 8)) | (u32 )cursor_wm) | 2147483648U);
  }
  return;
}
}
static void intel_update_watermarks(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned long )dev_priv->display.update_wm != (unsigned long )((void (*)(struct drm_device * ))0)) {
    {
    (*(dev_priv->display.update_wm))(dev);
    }
  } else {
  }
  return;
}
}
__inline static bool intel_panel_use_ssc(struct drm_i915_private *dev_priv )
{ int tmp ;
  {
  if ((unsigned int )*((unsigned char *)dev_priv + 2072UL) != 0U) {
    if (i915_panel_use_ssc != 0U) {
      if ((dev_priv->quirks & 2UL) == 0UL) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((bool )tmp);
}
}
static int i9xx_crtc_mode_set(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                              struct drm_display_mode *adjusted_mode , int x , int y ,
                              struct drm_framebuffer *old_fb )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int pipe ;
  int plane ;
  int refclk ;
  int num_connectors ;
  intel_clock_t clock ;
  intel_clock_t reduced_clock ;
  u32 dpll ;
  u32 fp ;
  u32 fp2 ;
  u32 dspcntr ;
  u32 pipeconf ;
  bool ok ;
  bool has_reduced_clock ;
  bool is_sdvo ;
  bool is_dvo ;
  bool is_crt ;
  bool is_lvds ;
  bool is_tv ;
  bool is_dp ;
  struct drm_mode_config *mode_config ;
  struct intel_encoder *encoder ;
  intel_limit_t const *limit ;
  int ret ;
  u32 temp ;
  u32 lvds_sync ;
  struct list_head const *__mptr___0 ;
  struct list_head const *__mptr___1 ;
  bool tmp ;
  int pixel_multiplier ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char flags[2U] ;
  int tmp___4 ;
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  pipe = (int )intel_crtc->pipe;
  plane = (int )intel_crtc->plane;
  num_connectors = 0;
  fp = 0U;
  fp2 = 0U;
  has_reduced_clock = (bool )0;
  is_sdvo = (bool )0;
  is_dvo = (bool )0;
  is_crt = (bool )0;
  is_lvds = (bool )0;
  is_tv = (bool )0;
  is_dp = (bool )0;
  mode_config = & dev->mode_config;
  lvds_sync = 0U;
  __mptr___0 = (struct list_head const *)mode_config->encoder_list.next;
  encoder = (struct intel_encoder *)__mptr___0 + 0x0ffffffffffffff8UL;
  goto ldv_39475;
  ldv_39474: ;
  if ((unsigned long )encoder->base.crtc != (unsigned long )crtc) {
    goto ldv_39465;
  } else {
  }
  if (encoder->type == 4) {
    goto case_4;
  } else
  if (encoder->type == 3) {
    goto case_3;
  } else
  if (encoder->type == 6) {
    goto case_6;
  } else
  if (encoder->type == 2) {
    goto case_2;
  } else
  if (encoder->type == 5) {
    goto case_5;
  } else
  if (encoder->type == 1) {
    goto case_1;
  } else
  if (encoder->type == 7) {
    goto case_7;
  } else
  if (0) {
    case_4:
    is_lvds = (bool )1;
    goto ldv_39467;
    case_3: ;
    case_6:
    is_sdvo = (bool )1;
    if ((int )encoder->needs_tv_clock) {
      is_tv = (bool )1;
    } else {
    }
    goto ldv_39467;
    case_2:
    is_dvo = (bool )1;
    goto ldv_39467;
    case_5:
    is_tv = (bool )1;
    goto ldv_39467;
    case_1:
    is_crt = (bool )1;
    goto ldv_39467;
    case_7:
    is_dp = (bool )1;
    goto ldv_39467;
  } else {
  }
  ldv_39467:
  num_connectors = num_connectors + 1;
  ldv_39465:
  __mptr___1 = (struct list_head const *)encoder->base.head.next;
  encoder = (struct intel_encoder *)__mptr___1 + 0x0ffffffffffffff8UL;
  ldv_39475: ;
  if ((unsigned long )(& encoder->base.head) != (unsigned long )(& mode_config->encoder_list)) {
    goto ldv_39474;
  } else {
    goto ldv_39476;
  }
  ldv_39476: ;
  if ((int )is_lvds) {
    {
    tmp = intel_panel_use_ssc(dev_priv);
    }
    if ((int )tmp) {
      if (num_connectors <= 1) {
        {
        refclk = dev_priv->lvds_ssc_freq * 1000;
        drm_ut_debug_printk(4U, "drm", "i9xx_crtc_mode_set", "using SSC reference clock of %d MHz\n",
                            refclk / 1000);
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else
  _L___0:
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 2U) {
    refclk = 96000;
  } else {
    refclk = 48000;
  }
  {
  limit = intel_limit(crtc, refclk);
  ok = (*(limit->find_pll))(limit, crtc, adjusted_mode->clock, refclk, & clock);
  }
  if (! ok) {
    {
    drm_err("i9xx_crtc_mode_set", "Couldn\'t find PLL settings for mode!\n");
    }
    return (-22);
  } else {
  }
  {
  intel_crtc_update_cursor(crtc, (bool )1);
  }
  if ((int )is_lvds) {
    if ((int )dev_priv->lvds_downclock_avail) {
      {
      has_reduced_clock = (*(limit->find_pll))(limit, crtc, dev_priv->lvds_downclock,
                                               refclk, & reduced_clock);
      }
      if ((int )has_reduced_clock) {
        if (clock.p != reduced_clock.p) {
          {
          drm_ut_debug_printk(4U, "drm", "i9xx_crtc_mode_set", "Different P is found for LVDS clock/downclock\n");
          has_reduced_clock = (bool )0;
          }
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  if ((int )is_sdvo) {
    if ((int )is_tv) {
      if (adjusted_mode->clock > 99999) {
        if (adjusted_mode->clock <= 140499) {
          clock.p1 = 2;
          clock.p2 = 10;
          clock.n = 3;
          clock.m1 = 16;
          clock.m2 = 8;
        } else {
          goto _L___1;
        }
      } else
      _L___1:
      if (adjusted_mode->clock > 140499) {
        if (adjusted_mode->clock <= 200000) {
          clock.p1 = 1;
          clock.p2 = 10;
          clock.n = 6;
          clock.m1 = 12;
          clock.m2 = 8;
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    fp = (u32 )((((1 << clock.n) << 16) | (clock.m1 << 8)) | clock.m2);
    if ((int )has_reduced_clock) {
      fp2 = (u32 )((((1 << reduced_clock.n) << 16) | (reduced_clock.m1 << 8)) | reduced_clock.m2);
    } else {
    }
  } else {
    fp = (u32 )(((clock.n << 16) | (clock.m1 << 8)) | clock.m2);
    if ((int )has_reduced_clock) {
      fp2 = (u32 )(((reduced_clock.n << 16) | (reduced_clock.m1 << 8)) | reduced_clock.m2);
    } else {
    }
  }
  dpll = 268435456U;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 2U) {
    if ((int )is_lvds) {
      dpll = dpll | 134217728U;
    } else {
      dpll = dpll | 67108864U;
    }
    if ((int )is_sdvo) {
      {
      tmp___0 = intel_mode_get_pixel_multiplier((struct drm_display_mode const *)adjusted_mode);
      pixel_multiplier = tmp___0;
      }
      if (pixel_multiplier > 1) {
        if (dev->pci_device == 10098) {
          dpll = (u32 )((pixel_multiplier + -1) << 4) | dpll;
        } else
        if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
          dpll = (u32 )((pixel_multiplier + -1) << 4) | dpll;
        } else
        if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
          dpll = (u32 )((pixel_multiplier + -1) << 4) | dpll;
        } else {
        }
      } else {
      }
      dpll = dpll | 1073741824U;
    } else {
    }
    if ((int )is_dp) {
      dpll = dpll | 1073741824U;
    } else {
    }
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
      dpll = (u32 )((1 << (clock.p1 + -1)) << 15) | dpll;
    } else {
      dpll = (u32 )((1 << (clock.p1 + -1)) << 16) | dpll;
      if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
        if ((int )has_reduced_clock) {
          dpll = (u32 )(1 << (reduced_clock.p1 + -1)) | dpll;
        } else {
        }
      } else {
      }
    }
    if (clock.p2 == 5) {
      goto case_5___0;
    } else
    if (clock.p2 == 7) {
      goto case_7___0;
    } else
    if (clock.p2 == 10) {
      goto case_10;
    } else
    if (clock.p2 == 14) {
      goto case_14;
    } else
    if (0) {
      case_5___0:
      dpll = dpll | 16777216U;
      goto ldv_39480;
      case_7___0:
      dpll = dpll | 16777216U;
      goto ldv_39480;
      case_10:
      dpll = dpll;
      goto ldv_39480;
      case_14:
      dpll = dpll;
      goto ldv_39480;
    } else {
    }
    ldv_39480: ;
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
      dpll = dpll | 3072U;
    } else {
    }
  } else
  if ((int )is_lvds) {
    dpll = (u32 )((1 << (clock.p1 + -1)) << 16) | dpll;
  } else {
    if (clock.p1 == 2) {
      dpll = dpll | 2097152U;
    } else {
      dpll = (u32 )((clock.p1 + -2) << 16) | dpll;
    }
    if (clock.p2 == 4) {
      dpll = dpll | 8388608U;
    } else {
    }
  }
  if ((int )is_sdvo) {
    if ((int )is_tv) {
      dpll = dpll | 16384U;
    } else {
      goto _L___2;
    }
  } else
  _L___2:
  if ((int )is_tv) {
    dpll = dpll | 3U;
  } else
  if ((int )is_lvds) {
    {
    tmp___1 = intel_panel_use_ssc(dev_priv);
    }
    if ((int )tmp___1) {
      if (num_connectors <= 1) {
        dpll = dpll | 24576U;
      } else {
        dpll = dpll;
      }
    } else {
      dpll = dpll;
    }
  } else {
    dpll = dpll;
  }
  {
  pipeconf = i915_read32___6(dev_priv, (u32 )(pipe * 4096 + 458760));
  dspcntr = 1073741824U;
  }
  if (pipe == 0) {
    dspcntr = dspcntr & 4244635647U;
  } else {
    dspcntr = dspcntr | 16777216U;
  }
  if (pipe == 0) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) <= 3U) {
      {
      tmp___2 = (*(dev_priv->display.get_display_clock_speed))(dev);
      }
      if (mode->clock > (tmp___2 * 9) / 10) {
        pipeconf = pipeconf | 1073741824U;
      } else {
        pipeconf = pipeconf & 3221225471U;
      }
    } else {
    }
  } else {
  }
  dpll = dpll | 2147483648U;
  if (pipe == 0) {
    tmp___3 = 65;
  } else {
    tmp___3 = 66;
  }
  {
  drm_ut_debug_printk(4U, "drm", "i9xx_crtc_mode_set", "Mode for pipe %c:\n", tmp___3);
  drm_mode_debug_printmodeline(mode);
  i915_write32___4(dev_priv, (u32 )((pipe + 3080) * 8), fp);
  i915_write32___4(dev_priv, (u32 )((pipe + 6149) * 4), dpll & 2147483647U);
  readl((void const volatile *)dev_priv->regs + (unsigned long )((pipe + 6149) * 4));
  __const_udelay(644250UL);
  }
  if ((int )is_lvds) {
    {
    temp = i915_read32___6(dev_priv, 397696U);
    temp = temp | 2147484416U;
    }
    if (pipe == 1) {
      temp = temp | 1073741824U;
    } else {
      temp = temp & 3221225471U;
    }
    temp = dev_priv->lvds_border_bits | temp;
    if (clock.p2 == 7) {
      temp = temp | 60U;
    } else {
      temp = temp & 4294967235U;
    }
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
      if ((unsigned int )*((unsigned char *)dev_priv + 2072UL) != 0U) {
        temp = temp | 33554432U;
      } else {
        temp = temp & 4261412863U;
      }
    } else {
    }
    if ((adjusted_mode->flags & 2U) != 0U) {
      lvds_sync = lvds_sync | 1048576U;
    } else {
    }
    if ((adjusted_mode->flags & 8U) != 0U) {
      lvds_sync = lvds_sync | 2097152U;
    } else {
    }
    if ((temp & 3145728U) != lvds_sync) {
      {
      flags[0] = (char )'-';
      flags[1] = (char )'+';
      printk("<6>[drm] Changing LVDS panel from (%chsync, %cvsync) to (%chsync, %cvsync)\n",
             (int )flags[(temp & 1048576U) == 0U], (int )flags[(temp & 2097152U) == 0U],
             (int )flags[(lvds_sync & 1048576U) == 0U], (int )flags[(lvds_sync & 2097152U) == 0U]);
      temp = temp & 4291821567U;
      temp = temp | lvds_sync;
      }
    } else {
    }
    {
    i915_write32___4(dev_priv, 397696U, temp);
    }
  } else {
  }
  if ((int )is_dp) {
    {
    intel_dp_set_m_n(crtc, mode, adjusted_mode);
    }
  } else {
  }
  {
  i915_write32___4(dev_priv, (u32 )((pipe + 6149) * 4), dpll);
  readl((void const volatile *)dev_priv->regs + (unsigned long )((pipe + 6149) * 4));
  __const_udelay(644250UL);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    temp = 0U;
    if ((int )is_sdvo) {
      {
      tmp___4 = intel_mode_get_pixel_multiplier((struct drm_display_mode const *)adjusted_mode);
      temp = (u32 )tmp___4;
      }
      if (temp > 1U) {
        temp = (temp - 1U) << 8;
      } else {
        temp = 0U;
      }
    } else {
    }
    {
    i915_write32___4(dev_priv, (u32 )((pipe + 6151) * 4), temp);
    }
  } else {
    {
    i915_write32___4(dev_priv, (u32 )((pipe + 6149) * 4), dpll);
    }
  }
  intel_crtc->lowfreq_avail = (bool )0;
  if ((int )is_lvds) {
    if ((int )has_reduced_clock) {
      if (i915_powersave != 0U) {
        {
        i915_write32___4(dev_priv, (u32 )(pipe * 8 + 24644), fp2);
        intel_crtc->lowfreq_avail = (bool )1;
        }
        if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
          {
          drm_ut_debug_printk(4U, "drm", "i9xx_crtc_mode_set", "enabling CxSR downclocking\n");
          pipeconf = pipeconf | 65536U;
          }
        } else {
        }
      } else {
        goto _L___4;
      }
    } else {
      goto _L___4;
    }
  } else {
    _L___4:
    {
    i915_write32___4(dev_priv, (u32 )(pipe * 8 + 24644), fp);
    }
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
      {
      drm_ut_debug_printk(4U, "drm", "i9xx_crtc_mode_set", "disabling CxSR downclocking\n");
      pipeconf = pipeconf & 4294901759U;
      }
    } else {
    }
  }
  if ((adjusted_mode->flags & 16U) != 0U) {
    pipeconf = pipeconf | 12582912U;
    adjusted_mode->crtc_vdisplay = adjusted_mode->crtc_vdisplay + -1;
    adjusted_mode->crtc_vtotal = adjusted_mode->crtc_vtotal + -1;
    adjusted_mode->crtc_vblank_start = adjusted_mode->crtc_vblank_start + -1;
    adjusted_mode->crtc_vblank_end = adjusted_mode->crtc_vblank_end + -1;
    adjusted_mode->crtc_vsync_end = adjusted_mode->crtc_vsync_end + -1;
    adjusted_mode->crtc_vsync_start = adjusted_mode->crtc_vsync_start + -1;
  } else {
    pipeconf = pipeconf & 4282384383U;
  }
  {
  i915_write32___4(dev_priv, (u32 )((pipe + 96) * 4096), (u32 )((adjusted_mode->crtc_hdisplay + -1) | ((adjusted_mode->crtc_htotal + -1) << 16)));
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 393220), (u32 )((adjusted_mode->crtc_hblank_start + -1) | ((adjusted_mode->crtc_hblank_end + -1) << 16)));
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 393224), (u32 )((adjusted_mode->crtc_hsync_start + -1) | ((adjusted_mode->crtc_hsync_end + -1) << 16)));
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 393228), (u32 )((adjusted_mode->crtc_vdisplay + -1) | ((adjusted_mode->crtc_vtotal + -1) << 16)));
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 393232), (u32 )((adjusted_mode->crtc_vblank_start + -1) | ((adjusted_mode->crtc_vblank_end + -1) << 16)));
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 393236), (u32 )((adjusted_mode->crtc_vsync_start + -1) | ((adjusted_mode->crtc_vsync_end + -1) << 16)));
  i915_write32___4(dev_priv, (u32 )(plane * 4096 + 459152), (u32 )(((mode->vdisplay + -1) << 16) | (mode->hdisplay + -1)));
  i915_write32___4(dev_priv, (u32 )(plane * 4096 + 459148), 0U);
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 393244), (u32 )(((mode->hdisplay + -1) << 16) | (mode->vdisplay + -1)));
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 458760), pipeconf);
  readl((void const volatile *)dev_priv->regs + (unsigned long )(pipe * 4096 + 458760));
  intel_enable_pipe(dev_priv, (enum pipe )pipe, (bool )0);
  intel_wait_for_vblank(dev, pipe);
  i915_write32___4(dev_priv, (u32 )(plane * 4096 + 459136), dspcntr);
  readl((void const volatile *)dev_priv->regs + (unsigned long )(plane * 4096 + 459136));
  intel_enable_plane(dev_priv, (enum plane )plane, (enum pipe )pipe);
  ret = intel_pipe_set_base(crtc, x, y, old_fb);
  intel_update_watermarks(dev);
  }
  return (ret);
}
}
static int ironlake_crtc_mode_set(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                                  struct drm_display_mode *adjusted_mode , int x ,
                                  int y , struct drm_framebuffer *old_fb )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int pipe ;
  int plane ;
  int refclk ;
  int num_connectors ;
  intel_clock_t clock ;
  intel_clock_t reduced_clock ;
  u32 dpll ;
  u32 fp ;
  u32 fp2 ;
  u32 dspcntr ;
  u32 pipeconf ;
  bool ok ;
  bool has_reduced_clock ;
  bool is_sdvo ;
  bool is_crt ;
  bool is_lvds ;
  bool is_tv ;
  bool is_dp ;
  struct intel_encoder *has_edp_encoder ;
  struct drm_mode_config *mode_config ;
  struct intel_encoder *encoder ;
  intel_limit_t const *limit ;
  int ret ;
  struct fdi_m_n m_n ;
  u32 temp ;
  u32 lvds_sync ;
  int target_clock ;
  int pixel_multiplier ;
  int lane ;
  int link_bw ;
  int bpp ;
  int factor ;
  struct list_head const *__mptr___0 ;
  struct list_head const *__mptr___1 ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  u32 tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  u32 tmp___5 ;
  u32 bps ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  bool tmp___11 ;
  u32 tmp___12 ;
  int pixel_multiplier___0 ;
  int tmp___13 ;
  bool tmp___14 ;
  bool tmp___15 ;
  int tmp___16 ;
  bool tmp___17 ;
  char flags[2U] ;
  bool tmp___18 ;
  bool tmp___19 ;
  bool tmp___20 ;
  int tmp___21 ;
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  pipe = (int )intel_crtc->pipe;
  plane = (int )intel_crtc->plane;
  num_connectors = 0;
  fp = 0U;
  fp2 = 0U;
  has_reduced_clock = (bool )0;
  is_sdvo = (bool )0;
  is_crt = (bool )0;
  is_lvds = (bool )0;
  is_tv = (bool )0;
  is_dp = (bool )0;
  has_edp_encoder = (struct intel_encoder *)0;
  mode_config = & dev->mode_config;
  m_n.tu = 0U;
  m_n.gmch_m = 0U;
  m_n.gmch_n = 0U;
  m_n.link_m = 0U;
  m_n.link_n = 0U;
  lvds_sync = 0U;
  __mptr___0 = (struct list_head const *)mode_config->encoder_list.next;
  encoder = (struct intel_encoder *)__mptr___0 + 0x0ffffffffffffff8UL;
  goto ldv_39544;
  ldv_39543: ;
  if ((unsigned long )encoder->base.crtc != (unsigned long )crtc) {
    goto ldv_39534;
  } else {
  }
  if (encoder->type == 4) {
    goto case_4;
  } else
  if (encoder->type == 3) {
    goto case_3;
  } else
  if (encoder->type == 6) {
    goto case_6;
  } else
  if (encoder->type == 5) {
    goto case_5;
  } else
  if (encoder->type == 1) {
    goto case_1;
  } else
  if (encoder->type == 7) {
    goto case_7;
  } else
  if (encoder->type == 8) {
    goto case_8;
  } else
  if (0) {
    case_4:
    is_lvds = (bool )1;
    goto ldv_39536;
    case_3: ;
    case_6:
    is_sdvo = (bool )1;
    if ((int )encoder->needs_tv_clock) {
      is_tv = (bool )1;
    } else {
    }
    goto ldv_39536;
    case_5:
    is_tv = (bool )1;
    goto ldv_39536;
    case_1:
    is_crt = (bool )1;
    goto ldv_39536;
    case_7:
    is_dp = (bool )1;
    goto ldv_39536;
    case_8:
    has_edp_encoder = encoder;
    goto ldv_39536;
  } else {
  }
  ldv_39536:
  num_connectors = num_connectors + 1;
  ldv_39534:
  __mptr___1 = (struct list_head const *)encoder->base.head.next;
  encoder = (struct intel_encoder *)__mptr___1 + 0x0ffffffffffffff8UL;
  ldv_39544: ;
  if ((unsigned long )(& encoder->base.head) != (unsigned long )(& mode_config->encoder_list)) {
    goto ldv_39543;
  } else {
    goto ldv_39545;
  }
  ldv_39545: ;
  if ((int )is_lvds) {
    {
    tmp___0 = intel_panel_use_ssc(dev_priv);
    }
    if ((int )tmp___0) {
      if (num_connectors <= 1) {
        {
        refclk = dev_priv->lvds_ssc_freq * 1000;
        drm_ut_debug_printk(4U, "drm", "ironlake_crtc_mode_set", "using SSC reference clock of %d MHz\n",
                            refclk / 1000);
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0:
    refclk = 96000;
    if ((unsigned long )has_edp_encoder == (unsigned long )((struct intel_encoder *)0)) {
      refclk = 120000;
    } else {
      {
      tmp = intel_encoder_is_pch_edp(& has_edp_encoder->base);
      }
      if ((int )tmp) {
        refclk = 120000;
      } else {
      }
    }
  }
  {
  limit = intel_limit(crtc, refclk);
  ok = (*(limit->find_pll))(limit, crtc, adjusted_mode->clock, refclk, & clock);
  }
  if (! ok) {
    {
    drm_err("ironlake_crtc_mode_set", "Couldn\'t find PLL settings for mode!\n");
    }
    return (-22);
  } else {
  }
  {
  intel_crtc_update_cursor(crtc, (bool )1);
  }
  if ((int )is_lvds) {
    if ((int )dev_priv->lvds_downclock_avail) {
      {
      has_reduced_clock = (*(limit->find_pll))(limit, crtc, dev_priv->lvds_downclock,
                                               refclk, & reduced_clock);
      }
      if ((int )has_reduced_clock) {
        if (clock.p != reduced_clock.p) {
          {
          drm_ut_debug_printk(4U, "drm", "ironlake_crtc_mode_set", "Different P is found for LVDS clock/downclock\n");
          has_reduced_clock = (bool )0;
          }
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  if ((int )is_sdvo) {
    if ((int )is_tv) {
      if (adjusted_mode->clock > 99999) {
        if (adjusted_mode->clock <= 140499) {
          clock.p1 = 2;
          clock.p2 = 10;
          clock.n = 3;
          clock.m1 = 16;
          clock.m2 = 8;
        } else {
          goto _L___1;
        }
      } else
      _L___1:
      if (adjusted_mode->clock > 140499) {
        if (adjusted_mode->clock <= 200000) {
          clock.p1 = 1;
          clock.p2 = 10;
          clock.n = 6;
          clock.m1 = 12;
          clock.m2 = 8;
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  pixel_multiplier = intel_mode_get_pixel_multiplier((struct drm_display_mode const *)adjusted_mode);
  lane = 0;
  }
  if ((unsigned long )has_edp_encoder != (unsigned long )((struct intel_encoder *)0)) {
    {
    tmp___3 = intel_encoder_is_pch_edp(& has_edp_encoder->base);
    }
    if (tmp___3) {
      tmp___4 = 0;
    } else {
      tmp___4 = 1;
    }
    if (tmp___4) {
      {
      target_clock = mode->clock;
      intel_edp_link_config(has_edp_encoder, & lane, & link_bw);
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2:
    if ((int )is_dp) {
      target_clock = mode->clock;
    } else {
      {
      tmp___1 = intel_encoder_is_pch_edp(& has_edp_encoder->base);
      }
      if ((int )tmp___1) {
        target_clock = mode->clock;
      } else {
        target_clock = adjusted_mode->clock;
      }
    }
    {
    tmp___2 = intel_fdi_link_freq(dev);
    link_bw = (int )((tmp___2 * 100000000U) / 10000U);
    }
  }
  {
  temp = i915_read32___6(dev_priv, (u32 )(pipe * 4096 + 458760));
  temp = temp & 4294967071U;
  }
  if ((int )is_lvds) {
    {
    tmp___5 = i915_read32___6(dev_priv, 921984U);
    }
    if ((tmp___5 & 192U) == 192U) {
      temp = temp;
    } else {
      temp = temp | 64U;
    }
  } else
  if ((unsigned long )has_edp_encoder != (unsigned long )((struct intel_encoder *)0)) {
    if (dev_priv->edp.bpp / 3 == 8) {
      goto case_8___0;
    } else
    if (dev_priv->edp.bpp / 3 == 10) {
      goto case_10;
    } else
    if (dev_priv->edp.bpp / 3 == 6) {
      goto case_6___0;
    } else
    if (dev_priv->edp.bpp / 3 == 12) {
      goto case_12;
    } else
    if (0) {
      case_8___0:
      temp = temp;
      goto ldv_39548;
      case_10:
      temp = temp | 32U;
      goto ldv_39548;
      case_6___0:
      temp = temp | 64U;
      goto ldv_39548;
      case_12:
      temp = temp | 96U;
      goto ldv_39548;
    } else {
    }
    ldv_39548: ;
  } else {
    temp = temp;
  }
  {
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 458760), temp);
  }
  if ((int )(temp & 224U) == 0) {
    goto case_0;
  } else
  if ((int )(temp & 224U) == 32) {
    goto case_32;
  } else
  if ((int )(temp & 224U) == 64) {
    goto case_64;
  } else
  if ((int )(temp & 224U) == 96) {
    goto case_96;
  } else {
    goto switch_default;
    if (0) {
      case_0:
      bpp = 24;
      goto ldv_39553;
      case_32:
      bpp = 30;
      goto ldv_39553;
      case_64:
      bpp = 18;
      goto ldv_39553;
      case_96:
      bpp = 36;
      goto ldv_39553;
      switch_default:
      {
      drm_err("ironlake_crtc_mode_set", "unknown pipe bpc value\n");
      bpp = 24;
      }
    } else {
    }
  }
  ldv_39553: ;
  if (lane == 0) {
    bps = (u32 )(((target_clock * bpp) * 21) / 20);
    lane = (int )(bps / (u32 )(link_bw * 8) + 1U);
  } else {
  }
  intel_crtc->fdi_lanes = lane;
  if (pixel_multiplier > 1) {
    link_bw = link_bw * pixel_multiplier;
  } else {
  }
  {
  ironlake_compute_m_n(bpp, lane, target_clock, link_bw, & m_n);
  temp = i915_read32___6(dev_priv, 811520U);
  temp = temp & 4294965759U;
  temp = temp | 1024U;
  temp = temp & 4294961151U;
  temp = temp | 4096U;
  i915_write32___4(dev_priv, 811520U, temp);
  readl((void const volatile *)dev_priv->regs + 811520U);
  __const_udelay(859000UL);
  }
  if ((unsigned long )has_edp_encoder != (unsigned long )((struct intel_encoder *)0)) {
    {
    tmp___6 = intel_panel_use_ssc(dev_priv);
    }
    if ((int )tmp___6) {
      {
      temp = temp | 2U;
      i915_write32___4(dev_priv, 811520U, temp);
      readl((void const volatile *)dev_priv->regs + 811520U);
      __const_udelay(859000UL);
      }
    } else {
    }
    {
    temp = temp & 4294942719U;
    tmp___9 = intel_encoder_is_pch_edp(& has_edp_encoder->base);
    }
    if (tmp___9) {
      tmp___10 = 0;
    } else {
      tmp___10 = 1;
    }
    if (tmp___10) {
      {
      tmp___7 = intel_panel_use_ssc(dev_priv);
      }
      if ((int )tmp___7) {
        temp = temp | 16384U;
      } else {
        temp = temp | 24576U;
      }
    } else {
      {
      tmp___8 = intel_panel_use_ssc(dev_priv);
      }
      if ((int )tmp___8) {
        {
        drm_err("ironlake_crtc_mode_set", "enabling SSC on PCH\n");
        temp = temp | 256U;
        }
      } else {
      }
    }
    {
    i915_write32___4(dev_priv, 811520U, temp);
    readl((void const volatile *)dev_priv->regs + 811520U);
    __const_udelay(859000UL);
    }
  } else {
  }
  fp = (u32 )(((clock.n << 16) | (clock.m1 << 8)) | clock.m2);
  if ((int )has_reduced_clock) {
    fp2 = (u32 )(((reduced_clock.n << 16) | (reduced_clock.m1 << 8)) | reduced_clock.m2);
  } else {
  }
  factor = 21;
  if ((int )is_lvds) {
    {
    tmp___11 = intel_panel_use_ssc(dev_priv);
    }
    if ((int )tmp___11) {
      if (dev_priv->lvds_ssc_freq == 100) {
        factor = 25;
      } else {
        goto _L___3;
      }
    } else {
      _L___3:
      {
      tmp___12 = i915_read32___6(dev_priv, 921984U);
      }
      if ((tmp___12 & 48U) == 48U) {
        factor = 25;
      } else
      if ((int )is_sdvo) {
        if ((int )is_tv) {
          factor = 20;
        } else {
        }
      } else {
      }
    }
  } else {
  }
  if (clock.m1 < clock.n * factor) {
    fp = fp | 12582912U;
  } else {
  }
  dpll = 0U;
  if ((int )is_lvds) {
    dpll = dpll | 134217728U;
  } else {
    dpll = dpll | 67108864U;
  }
  if ((int )is_sdvo) {
    {
    tmp___13 = intel_mode_get_pixel_multiplier((struct drm_display_mode const *)adjusted_mode);
    pixel_multiplier___0 = tmp___13;
    }
    if (pixel_multiplier___0 > 1) {
      dpll = (u32 )((pixel_multiplier___0 + -1) << 9) | dpll;
    } else {
    }
    dpll = dpll | 1073741824U;
  } else {
  }
  if ((int )is_dp) {
    dpll = dpll | 1073741824U;
  } else {
    {
    tmp___14 = intel_encoder_is_pch_edp(& has_edp_encoder->base);
    }
    if ((int )tmp___14) {
      dpll = dpll | 1073741824U;
    } else {
    }
  }
  dpll = (u32 )((1 << (clock.p1 + -1)) << 16) | dpll;
  dpll = (u32 )(1 << (clock.p1 + -1)) | dpll;
  if (clock.p2 == 5) {
    goto case_5___0;
  } else
  if (clock.p2 == 7) {
    goto case_7___0;
  } else
  if (clock.p2 == 10) {
    goto case_10___0;
  } else
  if (clock.p2 == 14) {
    goto case_14;
  } else
  if (0) {
    case_5___0:
    dpll = dpll | 16777216U;
    goto ldv_39561;
    case_7___0:
    dpll = dpll | 16777216U;
    goto ldv_39561;
    case_10___0:
    dpll = dpll;
    goto ldv_39561;
    case_14:
    dpll = dpll;
    goto ldv_39561;
  } else {
  }
  ldv_39561: ;
  if ((int )is_sdvo) {
    if ((int )is_tv) {
      dpll = dpll | 16384U;
    } else {
      goto _L___4;
    }
  } else
  _L___4:
  if ((int )is_tv) {
    dpll = dpll | 3U;
  } else
  if ((int )is_lvds) {
    {
    tmp___15 = intel_panel_use_ssc(dev_priv);
    }
    if ((int )tmp___15) {
      if (num_connectors <= 1) {
        dpll = dpll | 24576U;
      } else {
        dpll = dpll;
      }
    } else {
      dpll = dpll;
    }
  } else {
    dpll = dpll;
  }
  {
  pipeconf = i915_read32___6(dev_priv, (u32 )(pipe * 4096 + 458760));
  dspcntr = 1073741824U;
  }
  if (pipe == 0) {
    tmp___16 = 65;
  } else {
    tmp___16 = 66;
  }
  {
  drm_ut_debug_printk(4U, "drm", "ironlake_crtc_mode_set", "Mode for pipe %c:\n",
                      tmp___16);
  drm_mode_debug_printmodeline(mode);
  }
  if ((unsigned long )has_edp_encoder == (unsigned long )((struct intel_encoder *)0)) {
    {
    i915_write32___4(dev_priv, (u32 )((pipe + 101384) * 8), fp);
    i915_write32___4(dev_priv, (u32 )((pipe + 202757) * 4), dpll & 2147483647U);
    readl((void const volatile *)dev_priv->regs + (unsigned long )((pipe + 202757) * 4));
    __const_udelay(644250UL);
    }
  } else {
    {
    tmp___17 = intel_encoder_is_pch_edp(& has_edp_encoder->base);
    }
    if ((int )tmp___17) {
      {
      i915_write32___4(dev_priv, (u32 )((pipe + 101384) * 8), fp);
      i915_write32___4(dev_priv, (u32 )((pipe + 202757) * 4), dpll & 2147483647U);
      readl((void const volatile *)dev_priv->regs + (unsigned long )((pipe + 202757) * 4));
      __const_udelay(644250UL);
      }
    } else {
    }
  }
  if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 1U) {
    {
    temp = i915_read32___6(dev_priv, 815104U);
    }
    if (pipe == 0) {
      goto case_0___0;
    } else
    if (pipe == 1) {
      goto case_1___0;
    } else
    if (pipe == 2) {
      goto case_2;
    } else {
      goto switch_default___0;
      if (0) {
        case_0___0:
        temp = temp | 8U;
        goto ldv_39566;
        case_1___0:
        temp = temp | 144U;
        goto ldv_39566;
        case_2:
        temp = temp | 2304U;
        goto ldv_39566;
        switch_default___0:
        __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p"),
                             "i" (5060), "i" (12UL));
        ldv_39570: ;
        goto ldv_39570;
      } else {
      }
    }
    ldv_39566:
    {
    i915_write32___4(dev_priv, 815104U, temp);
    readl((void const volatile *)dev_priv->regs + 815104U);
    __const_udelay(644250UL);
    }
  } else {
  }
  if ((int )is_lvds) {
    {
    temp = i915_read32___6(dev_priv, 921984U);
    temp = temp | 2147484416U;
    }
    if (pipe == 1) {
      if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 1U) {
        temp = temp | 536870912U;
      } else {
        temp = temp | 1073741824U;
      }
    } else
    if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 1U) {
      temp = temp & 2684354559U;
    } else {
      temp = temp & 3221225471U;
    }
    temp = dev_priv->lvds_border_bits | temp;
    if (clock.p2 == 7) {
      temp = temp | 60U;
    } else {
      temp = temp & 4294967235U;
    }
    if ((adjusted_mode->flags & 2U) != 0U) {
      lvds_sync = lvds_sync | 1048576U;
    } else {
    }
    if ((adjusted_mode->flags & 8U) != 0U) {
      lvds_sync = lvds_sync | 2097152U;
    } else {
    }
    if ((temp & 3145728U) != lvds_sync) {
      {
      flags[0] = (char )'-';
      flags[1] = (char )'+';
      printk("<6>[drm] Changing LVDS panel from (%chsync, %cvsync) to (%chsync, %cvsync)\n",
             (int )flags[(temp & 1048576U) == 0U], (int )flags[(temp & 2097152U) == 0U],
             (int )flags[(lvds_sync & 1048576U) == 0U], (int )flags[(lvds_sync & 2097152U) == 0U]);
      temp = temp & 4291821567U;
      temp = temp | lvds_sync;
      }
    } else {
    }
    {
    i915_write32___4(dev_priv, 921984U, temp);
    }
  } else {
  }
  pipeconf = pipeconf & 4294967279U;
  pipeconf = pipeconf & 4294967283U;
  if ((unsigned int )*((unsigned char *)dev_priv + 2072UL) != 0U) {
    if ((int )is_lvds) {
      pipeconf = pipeconf | 16U;
      pipeconf = pipeconf | 4U;
    } else
    if ((unsigned long )has_edp_encoder != (unsigned long )((struct intel_encoder *)0)) {
      pipeconf = pipeconf | 16U;
      pipeconf = pipeconf | 4U;
    } else {
    }
  } else {
  }
  if ((int )is_dp) {
    {
    intel_dp_set_m_n(crtc, mode, adjusted_mode);
    }
  } else {
    {
    tmp___18 = intel_encoder_is_pch_edp(& has_edp_encoder->base);
    }
    if ((int )tmp___18) {
      {
      intel_dp_set_m_n(crtc, mode, adjusted_mode);
      }
    } else {
      {
      i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 917552), 0U);
      i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 917556), 0U);
      i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 917568), 0U);
      i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 917572), 0U);
      }
    }
  }
  if ((unsigned long )has_edp_encoder == (unsigned long )((struct intel_encoder *)0)) {
    {
    i915_write32___4(dev_priv, (u32 )((pipe + 202757) * 4), dpll);
    readl((void const volatile *)dev_priv->regs + (unsigned long )((pipe + 202757) * 4));
    __const_udelay(644250UL);
    i915_write32___4(dev_priv, (u32 )((pipe + 202757) * 4), dpll);
    }
  } else {
    {
    tmp___19 = intel_encoder_is_pch_edp(& has_edp_encoder->base);
    }
    if ((int )tmp___19) {
      {
      i915_write32___4(dev_priv, (u32 )((pipe + 202757) * 4), dpll);
      readl((void const volatile *)dev_priv->regs + (unsigned long )((pipe + 202757) * 4));
      __const_udelay(644250UL);
      i915_write32___4(dev_priv, (u32 )((pipe + 202757) * 4), dpll);
      }
    } else {
    }
  }
  intel_crtc->lowfreq_avail = (bool )0;
  if ((int )is_lvds) {
    if ((int )has_reduced_clock) {
      if (i915_powersave != 0U) {
        {
        i915_write32___4(dev_priv, (u32 )(pipe * 8 + 811076), fp2);
        intel_crtc->lowfreq_avail = (bool )1;
        }
        if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
          {
          drm_ut_debug_printk(4U, "drm", "ironlake_crtc_mode_set", "enabling CxSR downclocking\n");
          pipeconf = pipeconf | 65536U;
          }
        } else {
        }
      } else {
        goto _L___6;
      }
    } else {
      goto _L___6;
    }
  } else {
    _L___6:
    {
    i915_write32___4(dev_priv, (u32 )(pipe * 8 + 811076), fp);
    }
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
      {
      drm_ut_debug_printk(4U, "drm", "ironlake_crtc_mode_set", "disabling CxSR downclocking\n");
      pipeconf = pipeconf & 4294901759U;
      }
    } else {
    }
  }
  if ((adjusted_mode->flags & 16U) != 0U) {
    pipeconf = pipeconf | 12582912U;
    adjusted_mode->crtc_vdisplay = adjusted_mode->crtc_vdisplay + -1;
    adjusted_mode->crtc_vtotal = adjusted_mode->crtc_vtotal + -1;
    adjusted_mode->crtc_vblank_start = adjusted_mode->crtc_vblank_start + -1;
    adjusted_mode->crtc_vblank_end = adjusted_mode->crtc_vblank_end + -1;
    adjusted_mode->crtc_vsync_end = adjusted_mode->crtc_vsync_end + -1;
    adjusted_mode->crtc_vsync_start = adjusted_mode->crtc_vsync_start + -1;
  } else {
    pipeconf = pipeconf & 4282384383U;
  }
  {
  i915_write32___4(dev_priv, (u32 )((pipe + 96) * 4096), (u32 )((adjusted_mode->crtc_hdisplay + -1) | ((adjusted_mode->crtc_htotal + -1) << 16)));
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 393220), (u32 )((adjusted_mode->crtc_hblank_start + -1) | ((adjusted_mode->crtc_hblank_end + -1) << 16)));
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 393224), (u32 )((adjusted_mode->crtc_hsync_start + -1) | ((adjusted_mode->crtc_hsync_end + -1) << 16)));
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 393228), (u32 )((adjusted_mode->crtc_vdisplay + -1) | ((adjusted_mode->crtc_vtotal + -1) << 16)));
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 393232), (u32 )((adjusted_mode->crtc_vblank_start + -1) | ((adjusted_mode->crtc_vblank_end + -1) << 16)));
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 393236), (u32 )((adjusted_mode->crtc_vsync_start + -1) | ((adjusted_mode->crtc_vsync_end + -1) << 16)));
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 393244), (u32 )(((mode->hdisplay + -1) << 16) | (mode->vdisplay + -1)));
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 393264), ((m_n.tu - 1U) << 25) | m_n.gmch_m);
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 393268), m_n.gmch_n);
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 393280), m_n.link_m);
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 393284), m_n.link_n);
  }
  if ((unsigned long )has_edp_encoder != (unsigned long )((struct intel_encoder *)0)) {
    {
    tmp___20 = intel_encoder_is_pch_edp(& has_edp_encoder->base);
    }
    if (tmp___20) {
      tmp___21 = 0;
    } else {
      tmp___21 = 1;
    }
    if (tmp___21) {
      {
      ironlake_set_pll_edp(crtc, adjusted_mode->clock);
      }
    } else {
    }
  } else {
  }
  {
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 458760), pipeconf);
  readl((void const volatile *)dev_priv->regs + (unsigned long )(pipe * 4096 + 458760));
  intel_wait_for_vblank(dev, pipe);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    temp = i915_read32___6(dev_priv, 282624U);
    i915_write32___4(dev_priv, 282624U, temp | 8192U);
    }
  } else {
  }
  {
  i915_write32___4(dev_priv, (u32 )(plane * 4096 + 459136), dspcntr);
  readl((void const volatile *)dev_priv->regs + (unsigned long )(plane * 4096 + 459136));
  ret = intel_pipe_set_base(crtc, x, y, old_fb);
  intel_update_watermarks(dev);
  }
  return (ret);
}
}
static int intel_crtc_mode_set(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                               struct drm_display_mode *adjusted_mode , int x , int y ,
                               struct drm_framebuffer *old_fb )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int pipe ;
  int ret ;
  {
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  pipe = (int )intel_crtc->pipe;
  drm_vblank_pre_modeset(dev, pipe);
  ret = (*(dev_priv->display.crtc_mode_set))(crtc, mode, adjusted_mode, x, y, old_fb);
  drm_vblank_post_modeset(dev, pipe);
  }
  return (ret);
}
}
void intel_crtc_load_lut(struct drm_crtc *crtc )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int palreg ;
  int i ;
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  palreg = (int )(((unsigned int )intel_crtc->pipe + 20U) * 2048U);
  if (! crtc->enabled) {
    return;
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    palreg = (int )(((unsigned int )intel_crtc->pipe + 148U) * 2048U);
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    palreg = (int )(((unsigned int )intel_crtc->pipe + 148U) * 2048U);
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    palreg = (int )(((unsigned int )intel_crtc->pipe + 148U) * 2048U);
  } else {
  }
  i = 0;
  goto ldv_39598;
  ldv_39597:
  {
  i915_write32___4(dev_priv, (u32 )(i * 4 + palreg), (u32 )((((int )intel_crtc->lut_r[i] << 16) | ((int )intel_crtc->lut_g[i] << 8)) | (int )intel_crtc->lut_b[i]));
  i = i + 1;
  }
  ldv_39598: ;
  if (i <= 255) {
    goto ldv_39597;
  } else {
    goto ldv_39599;
  }
  ldv_39599: ;
  return;
}
}
static void i845_update_cursor(struct drm_crtc *crtc , u32 base )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  bool visible ;
  u32 cntl ;
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  visible = (bool )(base != 0U);
  if ((int )intel_crtc->cursor_visible == (int )visible) {
    return;
  } else {
  }
  {
  cntl = i915_read32___6(dev_priv, 458880U);
  }
  if ((int )visible) {
    {
    i915_write32___4(dev_priv, 458884U, base);
    cntl = cntl & 4177526783U;
    cntl = cntl | 3288334336U;
    }
  } else {
    cntl = cntl & 1073741823U;
  }
  {
  i915_write32___4(dev_priv, 458880U, cntl);
  intel_crtc->cursor_visible = visible;
  }
  return;
}
}
static void i9xx_update_cursor(struct drm_crtc *crtc , u32 base )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int pipe ;
  bool visible ;
  uint32_t cntl ;
  u32 tmp ;
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  pipe = (int )intel_crtc->pipe;
  visible = (bool )(base != 0U);
  if ((int )intel_crtc->cursor_visible != (int )visible) {
    {
    tmp = i915_read32___6(dev_priv, (u32 )((pipe + 7170) * 64));
    cntl = tmp;
    }
    if (base != 0U) {
      cntl = cntl & 4026531800U;
      cntl = cntl | 67108903U;
      cntl = (uint32_t )(pipe << 28) | cntl;
    } else {
      cntl = cntl & 4227858392U;
      cntl = cntl;
    }
    {
    i915_write32___4(dev_priv, (u32 )((pipe + 7170) * 64), cntl);
    intel_crtc->cursor_visible = visible;
    }
  } else {
  }
  {
  i915_write32___4(dev_priv, (u32 )(pipe * 64 + 458884), base);
  }
  return;
}
}
static void intel_crtc_update_cursor(struct drm_crtc *crtc , bool on )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int pipe ;
  int x ;
  int y ;
  u32 base ;
  u32 pos ;
  bool visible ;
  struct drm_framebuffer const *__mptr___0 ;
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  pipe = (int )intel_crtc->pipe;
  x = (int )intel_crtc->cursor_x;
  y = (int )intel_crtc->cursor_y;
  pos = 0U;
  if ((int )on) {
    if ((int )crtc->enabled) {
      if ((unsigned long )crtc->fb != (unsigned long )((struct drm_framebuffer *)0)) {
        base = intel_crtc->cursor_addr;
        if ((int )(crtc->fb)->width < x) {
          base = 0U;
        } else {
        }
        if ((int )(crtc->fb)->height < y) {
          base = 0U;
        } else {
        }
      } else {
        base = 0U;
      }
    } else {
      base = 0U;
    }
  } else {
    base = 0U;
  }
  if (x < 0) {
    if ((int )intel_crtc->cursor_width + x < 0) {
      base = 0U;
    } else {
    }
    pos = pos | 32768U;
    x = - x;
  } else {
  }
  pos = pos | (u32 )x;
  if (y < 0) {
    if ((int )intel_crtc->cursor_height + y < 0) {
      base = 0U;
    } else {
    }
    pos = pos | 2147483648U;
    y = - y;
  } else {
  }
  pos = (u32 )(y << 16) | pos;
  visible = (bool )(base != 0U);
  if (! visible) {
    if (! intel_crtc->cursor_visible) {
      return;
    } else {
    }
  } else {
  }
  {
  i915_write32___4(dev_priv, (u32 )(pipe * 64 + 458888), pos);
  }
  if (dev->pci_device == 9570) {
    {
    i845_update_cursor(crtc, base);
    }
  } else
  if (dev->pci_device == 9586) {
    {
    i845_update_cursor(crtc, base);
    }
  } else {
    {
    i9xx_update_cursor(crtc, base);
    }
  }
  if ((int )visible) {
    {
    __mptr___0 = (struct drm_framebuffer const *)crtc->fb;
    intel_mark_busy(dev, ((struct intel_framebuffer *)__mptr___0)->obj);
    }
  } else {
  }
  return;
}
}
static int intel_crtc_cursor_set(struct drm_crtc *crtc , struct drm_file *file , uint32_t handle ,
                                 uint32_t width , uint32_t height )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  struct drm_i915_gem_object *obj ;
  uint32_t addr ;
  int ret ;
  struct drm_gem_object const *__mptr___0 ;
  struct drm_gem_object *tmp ;
  int align ;
  int tmp___0 ;
  int tmp___1 ;
  {
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  drm_ut_debug_printk(4U, "drm", "intel_crtc_cursor_set", "\n");
  }
  if (handle == 0U) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_crtc_cursor_set", "cursor off\n");
    addr = 0U;
    obj = (struct drm_i915_gem_object *)0;
    mutex_lock_nested(& dev->struct_mutex, 0U);
    }
    goto finish;
  } else {
  }
  if (width != 64U) {
    {
    drm_err("intel_crtc_cursor_set", "we currently only support 64x64 cursors\n");
    }
    return (-22);
  } else
  if (height != 64U) {
    {
    drm_err("intel_crtc_cursor_set", "we currently only support 64x64 cursors\n");
    }
    return (-22);
  } else {
  }
  {
  tmp = drm_gem_object_lookup(dev, file, handle);
  __mptr___0 = (struct drm_gem_object const *)tmp;
  obj = (struct drm_i915_gem_object *)__mptr___0;
  }
  if ((unsigned long )(& obj->base) == (unsigned long )((struct drm_gem_object *)0)) {
    return (-2);
  } else {
  }
  if (obj->base.size < (size_t )((width * height) * 4U)) {
    {
    drm_err("intel_crtc_cursor_set", "buffer is to small\n");
    ret = -12;
    }
    goto fail;
  } else {
  }
  {
  mutex_lock_nested(& dev->struct_mutex, 0U);
  }
  if ((unsigned int )*((unsigned char *)dev_priv->info + 2UL) == 0U) {
    if ((unsigned int )*((unsigned char *)obj + 225UL) != 0U) {
      {
      drm_err("intel_crtc_cursor_set", "cursor cannot be tiled\n");
      ret = -22;
      }
      goto fail_locked;
    } else {
    }
    {
    ret = i915_gem_object_pin(obj, 4096U, (bool )1);
    }
    if (ret != 0) {
      {
      drm_err("intel_crtc_cursor_set", "failed to pin cursor bo\n");
      }
      goto fail_locked;
    } else {
    }
    {
    ret = i915_gem_object_set_to_gtt_domain(obj, (bool )0);
    }
    if (ret != 0) {
      {
      drm_err("intel_crtc_cursor_set", "failed to move cursor bo into the GTT\n");
      }
      goto fail_unpin;
    } else {
    }
    {
    ret = i915_gem_object_put_fence(obj);
    }
    if (ret != 0) {
      {
      drm_err("intel_crtc_cursor_set", "failed to move cursor bo into the GTT\n");
      }
      goto fail_unpin;
    } else {
    }
    addr = obj->gtt_offset;
  } else {
    if (dev->pci_device == 13687) {
      tmp___0 = 16384;
    } else {
      tmp___0 = 256;
    }
    align = tmp___0;
    if ((unsigned int )intel_crtc->pipe == 0U) {
      tmp___1 = 1;
    } else {
      tmp___1 = 2;
    }
    {
    ret = i915_gem_attach_phys_object(dev, obj, tmp___1, align);
    }
    if (ret != 0) {
      {
      drm_err("intel_crtc_cursor_set", "failed to attach phys object\n");
      }
      goto fail_locked;
    } else {
    }
    addr = (uint32_t )((obj->phys_obj)->handle)->busaddr;
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 2U) {
    {
    i915_write32___4(dev_priv, 458912U, (height << 12) | width);
    }
  } else {
  }
  finish: ;
  if ((unsigned long )intel_crtc->cursor_bo != (unsigned long )((struct drm_i915_gem_object *)0)) {
    if ((unsigned int )*((unsigned char *)dev_priv->info + 2UL) != 0U) {
      if ((unsigned long )intel_crtc->cursor_bo != (unsigned long )obj) {
        {
        i915_gem_detach_phys_object(dev, intel_crtc->cursor_bo);
        }
      } else {
        {
        i915_gem_object_unpin(intel_crtc->cursor_bo);
        }
      }
    } else {
    }
    {
    drm_gem_object_unreference(& (intel_crtc->cursor_bo)->base);
    }
  } else {
  }
  {
  mutex_unlock(& dev->struct_mutex);
  intel_crtc->cursor_addr = addr;
  intel_crtc->cursor_bo = obj;
  intel_crtc->cursor_width = (int16_t )width;
  intel_crtc->cursor_height = (int16_t )height;
  intel_crtc_update_cursor(crtc, (bool )1);
  }
  return (0);
  fail_unpin:
  {
  i915_gem_object_unpin(obj);
  }
  fail_locked:
  {
  mutex_unlock(& dev->struct_mutex);
  }
  fail:
  {
  drm_gem_object_unreference_unlocked(& obj->base);
  }
  return (ret);
}
}
static int intel_crtc_cursor_move(struct drm_crtc *crtc , int x , int y )
{ struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  {
  {
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  intel_crtc->cursor_x = (int16_t )x;
  intel_crtc->cursor_y = (int16_t )y;
  intel_crtc_update_cursor(crtc, (bool )1);
  }
  return (0);
}
}
void intel_crtc_fb_gamma_set(struct drm_crtc *crtc , u16 red , u16 green , u16 blue ,
                             int regno )
{ struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  {
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  intel_crtc->lut_r[regno] = (u8 )((int )red >> 8);
  intel_crtc->lut_g[regno] = (u8 )((int )green >> 8);
  intel_crtc->lut_b[regno] = (u8 )((int )blue >> 8);
  return;
}
}
void intel_crtc_fb_gamma_get(struct drm_crtc *crtc , u16 *red , u16 *green , u16 *blue ,
                             int regno )
{ struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  {
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  *red = (u16 )((int )((u16 )intel_crtc->lut_r[regno]) << 8U);
  *green = (u16 )((int )((u16 )intel_crtc->lut_g[regno]) << 8U);
  *blue = (u16 )((int )((u16 )intel_crtc->lut_b[regno]) << 8U);
  return;
}
}
static void intel_crtc_gamma_set(struct drm_crtc *crtc , u16 *red , u16 *green , u16 *blue ,
                                 uint32_t start , uint32_t size )
{ int end ;
  unsigned int tmp ;
  int i ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  {
  if (256U < start + size) {
    tmp = 256U;
  } else {
    tmp = start + size;
  }
  end = (int )tmp;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  i = (int )start;
  goto ldv_39705;
  ldv_39704:
  intel_crtc->lut_r[i] = (u8 )((int )*(red + (unsigned long )i) >> 8);
  intel_crtc->lut_g[i] = (u8 )((int )*(green + (unsigned long )i) >> 8);
  intel_crtc->lut_b[i] = (u8 )((int )*(blue + (unsigned long )i) >> 8);
  i = i + 1;
  ldv_39705: ;
  if (i < end) {
    goto ldv_39704;
  } else {
    goto ldv_39706;
  }
  ldv_39706:
  {
  intel_crtc_load_lut(crtc);
  }
  return;
}
}
static struct drm_display_mode load_detect_mode =
     {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'6', (char )'4',
                                                               (char )'0', (char )'x',
                                                               (char )'4', (char )'8',
                                                               (char )'0', (char )'\000'},
    0, (enum drm_mode_status )0, 16, 31500, 640, 664, 704, 832, 0, 480, 489, 491,
    520, 0, 10U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0,
    0, 0, 0};
static struct drm_framebuffer *intel_framebuffer_create(struct drm_device *dev , struct drm_mode_fb_cmd *mode_cmd ,
                                                        struct drm_i915_gem_object *obj )
{ struct intel_framebuffer *intel_fb ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  {
  {
  tmp = kzalloc(96UL, 208U);
  intel_fb = (struct intel_framebuffer *)tmp;
  }
  if ((unsigned long )intel_fb == (unsigned long )((struct intel_framebuffer *)0)) {
    {
    drm_gem_object_unreference_unlocked(& obj->base);
    tmp___0 = ERR_PTR(-12L);
    }
    return ((struct drm_framebuffer *)tmp___0);
  } else {
  }
  {
  ret = intel_framebuffer_init(dev, intel_fb, mode_cmd, obj);
  }
  if (ret != 0) {
    {
    drm_gem_object_unreference_unlocked(& obj->base);
    kfree((void const *)intel_fb);
    tmp___1 = ERR_PTR((long )ret);
    }
    return ((struct drm_framebuffer *)tmp___1);
  } else {
  }
  return (& intel_fb->base);
}
}
static u32 intel_framebuffer_pitch_for_width(int width , int bpp )
{ u32 pitch ;
  {
  pitch = (u32 )((width * bpp + 7) / 8);
  return ((pitch + 63U) & 4294967232U);
}
}
static u32 intel_framebuffer_size_for_mode(struct drm_display_mode *mode , int bpp )
{ u32 pitch ;
  u32 tmp ;
  {
  {
  tmp = intel_framebuffer_pitch_for_width(mode->hdisplay, bpp);
  pitch = tmp;
  }
  return (((u32 )mode->vdisplay * pitch + 4095U) & 4294963200U);
}
}
static struct drm_framebuffer *intel_framebuffer_create_for_mode(struct drm_device *dev ,
                                                                 struct drm_display_mode *mode ,
                                                                 int depth , int bpp )
{ struct drm_i915_gem_object *obj ;
  struct drm_mode_fb_cmd mode_cmd ;
  u32 tmp ;
  void *tmp___0 ;
  struct drm_framebuffer *tmp___1 ;
  {
  {
  tmp = intel_framebuffer_size_for_mode(mode, bpp);
  obj = i915_gem_alloc_object(dev, (size_t )tmp);
  }
  if ((unsigned long )obj == (unsigned long )((struct drm_i915_gem_object *)0)) {
    {
    tmp___0 = ERR_PTR(-12L);
    }
    return ((struct drm_framebuffer *)tmp___0);
  } else {
  }
  {
  mode_cmd.width = (__u32 )mode->hdisplay;
  mode_cmd.height = (__u32 )mode->vdisplay;
  mode_cmd.depth = (__u32 )depth;
  mode_cmd.bpp = (__u32 )bpp;
  mode_cmd.pitch = intel_framebuffer_pitch_for_width((int )mode_cmd.width, bpp);
  tmp___1 = intel_framebuffer_create(dev, & mode_cmd, obj);
  }
  return (tmp___1);
}
}
static struct drm_framebuffer *mode_fits_in_fbdev(struct drm_device *dev , struct drm_display_mode *mode )
{ struct drm_i915_private *dev_priv ;
  struct drm_i915_gem_object *obj ;
  struct drm_framebuffer *fb ;
  u32 tmp ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned long )dev_priv->fbdev == (unsigned long )((struct intel_fbdev *)0)) {
    return ((struct drm_framebuffer *)0);
  } else {
  }
  obj = (dev_priv->fbdev)->ifb.obj;
  if ((unsigned long )obj == (unsigned long )((struct drm_i915_gem_object *)0)) {
    return ((struct drm_framebuffer *)0);
  } else {
  }
  {
  fb = & (dev_priv->fbdev)->ifb.base;
  tmp = intel_framebuffer_pitch_for_width(mode->hdisplay, fb->bits_per_pixel);
  }
  if (fb->pitch < tmp) {
    return ((struct drm_framebuffer *)0);
  } else {
  }
  if (obj->base.size < (size_t )((unsigned int )mode->vdisplay * fb->pitch)) {
    return ((struct drm_framebuffer *)0);
  } else {
  }
  return (fb);
}
}
bool intel_get_load_detect_pipe(struct intel_encoder *intel_encoder , struct drm_connector *connector ,
                                struct drm_display_mode *mode , struct intel_load_detect_pipe *old )
{ struct intel_crtc *intel_crtc ;
  struct drm_crtc *possible_crtc ;
  struct drm_encoder *encoder ;
  struct drm_crtc *crtc ;
  struct drm_device *dev ;
  struct drm_framebuffer *old_fb ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  struct drm_crtc const *__mptr ;
  struct drm_encoder_helper_funcs *encoder_funcs ;
  struct drm_crtc_helper_funcs *crtc_funcs ;
  struct list_head const *__mptr___0 ;
  struct list_head const *__mptr___1 ;
  struct drm_crtc const *__mptr___2 ;
  long tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  {
  {
  encoder = & intel_encoder->base;
  crtc = (struct drm_crtc *)0;
  dev = encoder->dev;
  i = -1;
  tmp = drm_get_encoder_name(encoder);
  tmp___0 = drm_get_connector_name(connector);
  drm_ut_debug_printk(4U, "drm", "intel_get_load_detect_pipe", "[CONNECTOR:%d:%s], [ENCODER:%d:%s]\n",
                      connector->base.id, tmp___0, encoder->base.id, tmp);
  }
  if ((unsigned long )encoder->crtc != (unsigned long )((struct drm_crtc *)0)) {
    crtc = encoder->crtc;
    __mptr = (struct drm_crtc const *)crtc;
    intel_crtc = (struct intel_crtc *)__mptr;
    old->dpms_mode = intel_crtc->dpms_mode;
    old->load_detect_temp = (bool )0;
    if (intel_crtc->dpms_mode != 0) {
      {
      crtc_funcs = (struct drm_crtc_helper_funcs *)crtc->helper_private;
      (*(crtc_funcs->dpms))(crtc, 0);
      encoder_funcs = (struct drm_encoder_helper_funcs *)encoder->helper_private;
      (*(encoder_funcs->dpms))(encoder, 0);
      }
    } else {
    }
    return ((bool )1);
  } else {
  }
  __mptr___0 = (struct list_head const *)dev->mode_config.crtc_list.next;
  possible_crtc = (struct drm_crtc *)__mptr___0 + 0x0ffffffffffffff8UL;
  goto ldv_39765;
  ldv_39764:
  i = i + 1;
  if ((encoder->possible_crtcs & (uint32_t )(1 << i)) == 0U) {
    goto ldv_39762;
  } else {
  }
  if (! possible_crtc->enabled) {
    crtc = possible_crtc;
    goto ldv_39763;
  } else {
  }
  ldv_39762:
  __mptr___1 = (struct list_head const *)possible_crtc->head.next;
  possible_crtc = (struct drm_crtc *)__mptr___1 + 0x0ffffffffffffff8UL;
  ldv_39765: ;
  if ((unsigned long )(& possible_crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
    goto ldv_39764;
  } else {
    goto ldv_39763;
  }
  ldv_39763: ;
  if ((unsigned long )crtc == (unsigned long )((struct drm_crtc *)0)) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_get_load_detect_pipe", "no pipe available for load-detect\n");
    }
    return ((bool )0);
  } else {
  }
  encoder->crtc = crtc;
  connector->encoder = encoder;
  __mptr___2 = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr___2;
  old->dpms_mode = intel_crtc->dpms_mode;
  old->load_detect_temp = (bool )1;
  old->release_fb = (struct drm_framebuffer *)0;
  if ((unsigned long )mode == (unsigned long )((struct drm_display_mode *)0)) {
    mode = & load_detect_mode;
  } else {
  }
  {
  old_fb = crtc->fb;
  crtc->fb = mode_fits_in_fbdev(dev, mode);
  }
  if ((unsigned long )crtc->fb == (unsigned long )((struct drm_framebuffer *)0)) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_get_load_detect_pipe", "creating tmp fb for load-detection\n");
    crtc->fb = intel_framebuffer_create_for_mode(dev, mode, 24, 32);
    old->release_fb = crtc->fb;
    }
  } else {
    {
    drm_ut_debug_printk(4U, "drm", "intel_get_load_detect_pipe", "reusing fbdev for load-detection framebuffer\n");
    }
  }
  {
  tmp___1 = IS_ERR((void const *)crtc->fb);
  }
  if (tmp___1 != 0L) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_get_load_detect_pipe", "failed to allocate framebuffer for load-detection\n");
    crtc->fb = old_fb;
    }
    return ((bool )0);
  } else {
  }
  {
  tmp___2 = drm_crtc_helper_set_mode(crtc, mode, 0, 0, old_fb);
  }
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_get_load_detect_pipe", "failed to set mode on load-detect pipe\n");
    }
    if ((unsigned long )old->release_fb != (unsigned long )((struct drm_framebuffer *)0)) {
      {
      (*(((old->release_fb)->funcs)->destroy))(old->release_fb);
      }
    } else {
    }
    crtc->fb = old_fb;
    return ((bool )0);
  } else {
  }
  {
  intel_wait_for_vblank(dev, (int )intel_crtc->pipe);
  }
  return ((bool )1);
}
}
void intel_release_load_detect_pipe(struct intel_encoder *intel_encoder , struct drm_connector *connector ,
                                    struct intel_load_detect_pipe *old )
{ struct drm_encoder *encoder ;
  struct drm_device *dev ;
  struct drm_crtc *crtc ;
  struct drm_encoder_helper_funcs *encoder_funcs ;
  struct drm_crtc_helper_funcs *crtc_funcs ;
  char *tmp ;
  char *tmp___0 ;
  {
  {
  encoder = & intel_encoder->base;
  dev = encoder->dev;
  crtc = encoder->crtc;
  encoder_funcs = (struct drm_encoder_helper_funcs *)encoder->helper_private;
  crtc_funcs = (struct drm_crtc_helper_funcs *)crtc->helper_private;
  tmp = drm_get_encoder_name(encoder);
  tmp___0 = drm_get_connector_name(connector);
  drm_ut_debug_printk(4U, "drm", "intel_release_load_detect_pipe", "[CONNECTOR:%d:%s], [ENCODER:%d:%s]\n",
                      connector->base.id, tmp___0, encoder->base.id, tmp);
  }
  if ((int )old->load_detect_temp) {
    {
    connector->encoder = (struct drm_encoder *)0;
    drm_helper_disable_unused_functions(dev);
    }
    if ((unsigned long )old->release_fb != (unsigned long )((struct drm_framebuffer *)0)) {
      {
      (*(((old->release_fb)->funcs)->destroy))(old->release_fb);
      }
    } else {
    }
    return;
  } else {
  }
  if (old->dpms_mode != 0) {
    {
    (*(encoder_funcs->dpms))(encoder, old->dpms_mode);
    (*(crtc_funcs->dpms))(crtc, old->dpms_mode);
    }
  } else {
  }
  return;
}
}
static int intel_crtc_clock_get(struct drm_device *dev , struct drm_crtc *crtc )
{ struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int pipe ;
  u32 dpll ;
  u32 tmp ;
  u32 fp ;
  intel_clock_t clock ;
  int tmp___0 ;
  bool is_lvds ;
  u32 tmp___1 ;
  int tmp___2 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  pipe = (int )intel_crtc->pipe;
  tmp = i915_read32___6(dev_priv, (u32 )((pipe + 6149) * 4));
  dpll = tmp;
  }
  if ((dpll & 256U) == 0U) {
    {
    fp = i915_read32___6(dev_priv, (u32 )((pipe + 3080) * 8));
    }
  } else {
    {
    fp = i915_read32___6(dev_priv, (u32 )(pipe * 8 + 24644));
    }
  }
  clock.m1 = (int )((fp & 16128U) >> 8);
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    {
    tmp___0 = ffs((int )((fp & 16711680U) >> 16));
    clock.n = tmp___0 + -1;
    clock.m2 = (int )fp & 255;
    }
  } else {
    clock.n = (int )((fp & 4128768U) >> 16);
    clock.m2 = (int )fp & 63;
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 2U) {
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
      {
      clock.p1 = ffs((int )((dpll & 16744448U) >> 15));
      }
    } else {
      {
      clock.p1 = ffs((int )((dpll & 16711680U) >> 16));
      }
    }
    if ((int )(dpll & 201326592U) == 67108864) {
      goto case_67108864;
    } else
    if ((int )(dpll & 201326592U) == 134217728) {
      goto case_134217728;
    } else {
      goto switch_default;
      if (0) {
        case_67108864: ;
        if ((dpll & 16777216U) != 0U) {
          clock.p2 = 5;
        } else {
          clock.p2 = 10;
        }
        goto ldv_39792;
        case_134217728: ;
        if ((dpll & 16777216U) != 0U) {
          clock.p2 = 7;
        } else {
          clock.p2 = 14;
        }
        goto ldv_39792;
        switch_default:
        {
        drm_ut_debug_printk(4U, "drm", "intel_crtc_clock_get", "Unknown DPLL mode %08x in programmed mode\n",
                            (int )dpll & 201326592);
        }
        return (0);
      } else {
      }
    }
    ldv_39792:
    {
    intel_clock(dev, 96000, & clock);
    }
  } else {
    if (pipe == 1) {
      {
      tmp___1 = i915_read32___6(dev_priv, 397696U);
      }
      if ((int )tmp___1 < 0) {
        tmp___2 = 1;
      } else {
        tmp___2 = 0;
      }
    } else {
      tmp___2 = 0;
    }
    is_lvds = (bool )tmp___2;
    if ((int )is_lvds) {
      {
      clock.p1 = ffs((int )((dpll & 4128768U) >> 16));
      clock.p2 = 14;
      }
      if ((dpll & 24576U) == 24576U) {
        {
        intel_clock(dev, 66000, & clock);
        }
      } else {
        {
        intel_clock(dev, 48000, & clock);
        }
      }
    } else {
      if ((dpll & 2097152U) != 0U) {
        clock.p1 = 2;
      } else {
        clock.p1 = (int )(((dpll & 2031616U) >> 16) + 2U);
      }
      if ((dpll & 8388608U) != 0U) {
        clock.p2 = 4;
      } else {
        clock.p2 = 2;
      }
      {
      intel_clock(dev, 48000, & clock);
      }
    }
  }
  return (clock.dot);
}
}
struct drm_display_mode *intel_crtc_mode_get(struct drm_device *dev , struct drm_crtc *crtc )
{ struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int pipe ;
  struct drm_display_mode *mode ;
  int htot ;
  u32 tmp ;
  int hsync ;
  u32 tmp___0 ;
  int vtot ;
  u32 tmp___1 ;
  int vsync ;
  u32 tmp___2 ;
  void *tmp___3 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  pipe = (int )intel_crtc->pipe;
  tmp = i915_read32___6(dev_priv, (u32 )((pipe + 96) * 4096));
  htot = (int )tmp;
  tmp___0 = i915_read32___6(dev_priv, (u32 )(pipe * 4096 + 393224));
  hsync = (int )tmp___0;
  tmp___1 = i915_read32___6(dev_priv, (u32 )(pipe * 4096 + 393228));
  vtot = (int )tmp___1;
  tmp___2 = i915_read32___6(dev_priv, (u32 )(pipe * 4096 + 393236));
  vsync = (int )tmp___2;
  tmp___3 = kzalloc(224UL, 208U);
  mode = (struct drm_display_mode *)tmp___3;
  }
  if ((unsigned long )mode == (unsigned long )((struct drm_display_mode *)0)) {
    return ((struct drm_display_mode *)0);
  } else {
  }
  {
  mode->clock = intel_crtc_clock_get(dev, crtc);
  mode->hdisplay = (htot & 65535) + 1;
  mode->htotal = (int )(((unsigned int )htot >> 16) + 1U);
  mode->hsync_start = (hsync & 65535) + 1;
  mode->hsync_end = (int )(((unsigned int )hsync >> 16) + 1U);
  mode->vdisplay = (vtot & 65535) + 1;
  mode->vtotal = (int )(((unsigned int )vtot >> 16) + 1U);
  mode->vsync_start = (vsync & 65535) + 1;
  mode->vsync_end = (int )(((unsigned int )vsync >> 16) + 1U);
  drm_mode_set_name(mode);
  drm_mode_set_crtcinfo(mode, 0);
  }
  return (mode);
}
}
static void intel_gpu_idle_timer(unsigned long arg )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  unsigned long tmp ;
  int tmp___0 ;
  {
  {
  dev = (struct drm_device *)arg;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp___0 = list_empty((struct list_head const *)(& dev_priv->mm.active_list));
  }
  if (tmp___0 == 0) {
    {
    tmp = msecs_to_jiffies((unsigned int const )500U);
    mod_timer(& dev_priv->idle_timer, tmp + (unsigned long )jiffies);
    }
    return;
  } else {
  }
  {
  dev_priv->busy = (bool )0;
  queue_work(dev_priv->wq, & dev_priv->idle_work);
  }
  return;
}
}
static void intel_crtc_idle_timer(unsigned long arg )
{ struct intel_crtc *intel_crtc ;
  struct drm_crtc *crtc ;
  drm_i915_private_t *dev_priv ;
  struct intel_framebuffer *intel_fb ;
  struct drm_framebuffer const *__mptr ;
  unsigned long tmp ;
  {
  intel_crtc = (struct intel_crtc *)arg;
  crtc = & intel_crtc->base;
  dev_priv = (drm_i915_private_t *)(crtc->dev)->dev_private;
  __mptr = (struct drm_framebuffer const *)crtc->fb;
  intel_fb = (struct intel_framebuffer *)__mptr;
  if ((unsigned long )intel_fb != (unsigned long )((struct intel_framebuffer *)0)) {
    if ((unsigned int )*((unsigned char *)intel_fb->obj + 224UL) != 0U) {
      {
      tmp = msecs_to_jiffies((unsigned int const )1000U);
      mod_timer(& intel_crtc->idle_timer, tmp + (unsigned long )jiffies);
      }
      return;
    } else {
    }
  } else {
  }
  {
  intel_crtc->busy = (bool )0;
  queue_work(dev_priv->wq, & dev_priv->idle_work);
  }
  return;
}
}
static void intel_increase_pllclock(struct drm_crtc *crtc )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int pipe ;
  int dpll_reg ;
  int dpll ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  unsigned long tmp___3 ;
  {
  dev = crtc->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  pipe = (int )intel_crtc->pipe;
  dpll_reg = (pipe + 6149) * 4;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    return;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    return;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    return;
  } else {
  }
  if (! dev_priv->lvds_downclock_avail) {
    return;
  } else {
  }
  {
  tmp = i915_read32___6(dev_priv, (u32 )dpll_reg);
  dpll = (int )tmp;
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) == 0U) {
    if ((dpll & 256) != 0) {
      {
      drm_ut_debug_printk(2U, "drm", "intel_increase_pllclock", "upclocking LVDS\n");
      tmp___0 = i915_read32___6(dev_priv, 397828U);
      i915_write32___4(dev_priv, 397828U, tmp___0 | 2882338816U);
      dpll = dpll & -257;
      i915_write32___4(dev_priv, (u32 )dpll_reg, (u32 )dpll);
      intel_wait_for_vblank(dev, pipe);
      tmp___1 = i915_read32___6(dev_priv, (u32 )dpll_reg);
      dpll = (int )tmp___1;
      }
      if ((dpll & 256) != 0) {
        {
        drm_ut_debug_printk(2U, "drm", "intel_increase_pllclock", "failed to upclock LVDS!\n");
        }
      } else {
      }
      {
      tmp___2 = i915_read32___6(dev_priv, 397828U);
      i915_write32___4(dev_priv, 397828U, tmp___2 & 3U);
      }
    } else {
    }
  } else {
  }
  {
  tmp___3 = msecs_to_jiffies((unsigned int const )1000U);
  mod_timer(& intel_crtc->idle_timer, tmp___3 + (unsigned long )jiffies);
  }
  return;
}
}
static void intel_decrease_pllclock(struct drm_crtc *crtc )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int pipe ;
  int dpll_reg ;
  int dpll ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  {
  {
  dev = crtc->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  pipe = (int )intel_crtc->pipe;
  dpll_reg = (pipe + 6149) * 4;
  tmp = i915_read32___6(dev_priv, (u32 )dpll_reg);
  dpll = (int )tmp;
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    return;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    return;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    return;
  } else {
  }
  if (! dev_priv->lvds_downclock_avail) {
    return;
  } else {
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) == 0U) {
    if ((int )intel_crtc->lowfreq_avail) {
      {
      drm_ut_debug_printk(2U, "drm", "intel_decrease_pllclock", "downclocking LVDS\n");
      tmp___0 = i915_read32___6(dev_priv, 397828U);
      i915_write32___4(dev_priv, 397828U, tmp___0 | 2882338816U);
      dpll = dpll | 256;
      i915_write32___4(dev_priv, (u32 )dpll_reg, (u32 )dpll);
      intel_wait_for_vblank(dev, pipe);
      tmp___1 = i915_read32___6(dev_priv, (u32 )dpll_reg);
      dpll = (int )tmp___1;
      }
      if ((dpll & 256) == 0) {
        {
        drm_ut_debug_printk(2U, "drm", "intel_decrease_pllclock", "failed to downclock LVDS!\n");
        }
      } else {
      }
      {
      tmp___2 = i915_read32___6(dev_priv, 397828U);
      i915_write32___4(dev_priv, 397828U, tmp___2 & 3U);
      }
    } else {
    }
  } else {
  }
  return;
}
}
static void intel_idle_update(struct work_struct *work )
{ drm_i915_private_t *dev_priv ;
  struct work_struct const *__mptr ;
  struct drm_device *dev ;
  struct drm_crtc *crtc ;
  struct intel_crtc *intel_crtc ;
  struct list_head const *__mptr___0 ;
  struct drm_crtc const *__mptr___1 ;
  struct list_head const *__mptr___2 ;
  {
  __mptr = (struct work_struct const *)work;
  dev_priv = (drm_i915_private_t *)__mptr + 0x0fffffffffffe418UL;
  dev = dev_priv->dev;
  if (i915_powersave == 0U) {
    return;
  } else {
  }
  {
  mutex_lock_nested(& dev->struct_mutex, 0U);
  i915_update_gfx_val(dev_priv);
  __mptr___0 = (struct list_head const *)dev->mode_config.crtc_list.next;
  crtc = (struct drm_crtc *)__mptr___0 + 0x0ffffffffffffff8UL;
  }
  goto ldv_39866;
  ldv_39865: ;
  if ((unsigned long )crtc->fb == (unsigned long )((struct drm_framebuffer *)0)) {
    goto ldv_39862;
  } else {
  }
  __mptr___1 = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr___1;
  if (! intel_crtc->busy) {
    {
    intel_decrease_pllclock(crtc);
    }
  } else {
  }
  ldv_39862:
  __mptr___2 = (struct list_head const *)crtc->head.next;
  crtc = (struct drm_crtc *)__mptr___2 + 0x0ffffffffffffff8UL;
  ldv_39866: ;
  if ((unsigned long )(& crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
    goto ldv_39865;
  } else {
    goto ldv_39867;
  }
  ldv_39867:
  {
  mutex_unlock(& dev->struct_mutex);
  }
  return;
}
}
void intel_mark_busy(struct drm_device *dev , struct drm_i915_gem_object *obj )
{ drm_i915_private_t *dev_priv ;
  struct drm_crtc *crtc ;
  struct intel_framebuffer *intel_fb ;
  struct intel_crtc *intel_crtc ;
  int tmp ;
  unsigned long tmp___0 ;
  struct list_head const *__mptr ;
  struct drm_crtc const *__mptr___0 ;
  struct drm_framebuffer const *__mptr___1 ;
  unsigned long tmp___1 ;
  struct list_head const *__mptr___2 ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  crtc = (struct drm_crtc *)0;
  tmp = drm_core_check_feature(dev, 8192);
  }
  if (tmp == 0) {
    return;
  } else {
  }
  if (! dev_priv->busy) {
    dev_priv->busy = (bool )1;
  } else {
    {
    tmp___0 = msecs_to_jiffies((unsigned int const )500U);
    mod_timer(& dev_priv->idle_timer, tmp___0 + (unsigned long )jiffies);
    }
  }
  __mptr = (struct list_head const *)dev->mode_config.crtc_list.next;
  crtc = (struct drm_crtc *)__mptr + 0x0ffffffffffffff8UL;
  goto ldv_39886;
  ldv_39885: ;
  if ((unsigned long )crtc->fb == (unsigned long )((struct drm_framebuffer *)0)) {
    goto ldv_39880;
  } else {
  }
  __mptr___0 = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr___0;
  __mptr___1 = (struct drm_framebuffer const *)crtc->fb;
  intel_fb = (struct intel_framebuffer *)__mptr___1;
  if ((unsigned long )intel_fb->obj == (unsigned long )obj) {
    if (! intel_crtc->busy) {
      {
      intel_increase_pllclock(crtc);
      intel_crtc->busy = (bool )1;
      }
    } else {
      {
      tmp___1 = msecs_to_jiffies((unsigned int const )1000U);
      mod_timer(& intel_crtc->idle_timer, tmp___1 + (unsigned long )jiffies);
      }
    }
  } else {
  }
  ldv_39880:
  __mptr___2 = (struct list_head const *)crtc->head.next;
  crtc = (struct drm_crtc *)__mptr___2 + 0x0ffffffffffffff8UL;
  ldv_39886: ;
  if ((unsigned long )(& crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
    goto ldv_39885;
  } else {
    goto ldv_39887;
  }
  ldv_39887: ;
  return;
}
}
static void intel_crtc_destroy(struct drm_crtc *crtc )
{ struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  struct drm_device *dev ;
  struct intel_unpin_work *work ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  {
  {
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  dev = crtc->dev;
  tmp = spinlock_check(& dev->event_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  work = intel_crtc->unpin_work;
  intel_crtc->unpin_work = (struct intel_unpin_work *)0;
  spin_unlock_irqrestore(& dev->event_lock, flags);
  }
  if ((unsigned long )work != (unsigned long )((struct intel_unpin_work *)0)) {
    {
    cancel_work_sync(& work->work);
    kfree((void const *)work);
    }
  } else {
  }
  {
  drm_crtc_cleanup(crtc);
  kfree((void const *)intel_crtc);
  }
  return;
}
}
static void intel_unpin_work_fn(struct work_struct *__work )
{ struct intel_unpin_work *work ;
  struct work_struct const *__mptr ;
  {
  {
  __mptr = (struct work_struct const *)__work;
  work = (struct intel_unpin_work *)__mptr;
  mutex_lock_nested(& (work->dev)->struct_mutex, 0U);
  i915_gem_object_unpin(work->old_fb_obj);
  drm_gem_object_unreference(& (work->pending_flip_obj)->base);
  drm_gem_object_unreference(& (work->old_fb_obj)->base);
  mutex_unlock(& (work->dev)->struct_mutex);
  kfree((void const *)work);
  }
  return;
}
}
static void do_intel_finish_page_flip(struct drm_device *dev , struct drm_crtc *crtc )
{ drm_i915_private_t *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  struct intel_unpin_work *work ;
  struct drm_i915_gem_object *obj ;
  struct drm_pending_vblank_event *e ;
  struct timeval tnow ;
  struct timeval tvbl ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  s64 tmp___0 ;
  s64 tmp___1 ;
  s64 tmp___2 ;
  int tmp___3 ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  if ((unsigned long )intel_crtc == (unsigned long )((struct intel_crtc *)0)) {
    return;
  } else {
  }
  {
  do_gettimeofday(& tnow);
  tmp = spinlock_check(& dev->event_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  work = intel_crtc->unpin_work;
  }
  if ((unsigned long )work == (unsigned long )((struct intel_unpin_work *)0)) {
    {
    spin_unlock_irqrestore(& dev->event_lock, flags);
    }
    return;
  } else
  if (work->pending == 0) {
    {
    spin_unlock_irqrestore(& dev->event_lock, flags);
    }
    return;
  } else {
  }
  intel_crtc->unpin_work = (struct intel_unpin_work *)0;
  if ((unsigned long )work->event != (unsigned long )((struct drm_pending_vblank_event *)0)) {
    {
    e = work->event;
    e->event.sequence = drm_vblank_count_and_time(dev, (int )intel_crtc->pipe, & tvbl);
    tmp___1 = timeval_to_ns((struct timeval const *)(& tnow));
    tmp___2 = timeval_to_ns((struct timeval const *)(& tvbl));
    }
    if ((tmp___1 - tmp___2) * 10LL > crtc->framedur_ns * 9LL) {
      {
      e->event.sequence = e->event.sequence + 1U;
      tmp___0 = timeval_to_ns((struct timeval const *)(& tvbl));
      tvbl = ns_to_timeval((s64 const )(tmp___0 + crtc->framedur_ns));
      }
    } else {
    }
    {
    e->event.tv_sec = (__u32 )tvbl.tv_sec;
    e->event.tv_usec = (__u32 )tvbl.tv_usec;
    list_add_tail(& e->base.link, & (e->base.file_priv)->event_list);
    __wake_up(& (e->base.file_priv)->event_wait, 1U, 1, (void *)0);
    }
  } else {
  }
  {
  drm_vblank_put(dev, (int )intel_crtc->pipe);
  spin_unlock_irqrestore(& dev->event_lock, flags);
  obj = work->old_fb_obj;
  __asm__ volatile (".section .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.previous\n671:\n\tlock; andl %0,%1": : "r" (~ (1 << (int )intel_crtc->plane)),
                       "m" (obj->pending_flip.counter): "memory");
  tmp___3 = atomic_read((atomic_t const *)(& obj->pending_flip));
  }
  if (tmp___3 == 0) {
    {
    __wake_up(& dev_priv->pending_flip_queue, 3U, 1, (void *)0);
    }
  } else {
  }
  {
  schedule_work(& work->work);
  trace_i915_flip_complete((int )intel_crtc->plane, work->pending_flip_obj);
  }
  return;
}
}
void intel_finish_page_flip(struct drm_device *dev , int pipe )
{ drm_i915_private_t *dev_priv ;
  struct drm_crtc *crtc ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  crtc = dev_priv->pipe_to_crtc_mapping[pipe];
  do_intel_finish_page_flip(dev, crtc);
  }
  return;
}
}
void intel_finish_page_flip_plane(struct drm_device *dev , int plane )
{ drm_i915_private_t *dev_priv ;
  struct drm_crtc *crtc ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  crtc = dev_priv->plane_to_crtc_mapping[plane];
  do_intel_finish_page_flip(dev, crtc);
  }
  return;
}
}
void intel_prepare_page_flip(struct drm_device *dev , int plane )
{ drm_i915_private_t *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  __mptr = (struct drm_crtc const *)dev_priv->plane_to_crtc_mapping[plane];
  intel_crtc = (struct intel_crtc *)__mptr;
  tmp = spinlock_check(& dev->event_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  }
  if ((unsigned long )intel_crtc->unpin_work != (unsigned long )((struct intel_unpin_work *)0)) {
    (intel_crtc->unpin_work)->pending = (intel_crtc->unpin_work)->pending + 1;
    if ((intel_crtc->unpin_work)->pending > 1) {
      {
      drm_err("intel_prepare_page_flip", "Prepared flip multiple times\n");
      }
    } else {
      {
      drm_ut_debug_printk(2U, "drm", "intel_prepare_page_flip", "preparing flip with no unpin work?\n");
      }
    }
  } else {
  }
  {
  spin_unlock_irqrestore(& dev->event_lock, flags);
  }
  return;
}
}
static int intel_gen2_queue_flip(struct drm_device *dev , struct drm_crtc *crtc ,
                                 struct drm_framebuffer *fb , struct drm_i915_gem_object *obj )
{ struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  unsigned long offset ;
  u32 flip_mask ;
  int ret ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  ret = intel_pin_and_fence_fb_obj(dev, obj, (struct intel_ring_buffer *)(& dev_priv->ring));
  }
  if (ret != 0) {
    goto out;
  } else {
  }
  {
  offset = (unsigned long )((unsigned int )crtc->y * fb->pitch + (unsigned int )((crtc->x * fb->bits_per_pixel) / 8));
  ret = intel_ring_begin((struct intel_ring_buffer *)(& dev_priv->ring), 6);
  }
  if (ret != 0) {
    goto out;
  } else {
  }
  if ((unsigned int )intel_crtc->plane != 0U) {
    flip_mask = 64U;
  } else {
    flip_mask = 4U;
  }
  {
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), flip_mask | 25165824U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 0U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), ((unsigned int )intel_crtc->plane << 20) | 167772162U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), fb->pitch);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), obj->gtt_offset + (u32 )offset);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 0U);
  intel_ring_advance((struct intel_ring_buffer *)(& dev_priv->ring));
  }
  out: ;
  return (ret);
}
}
static int intel_gen3_queue_flip(struct drm_device *dev , struct drm_crtc *crtc ,
                                 struct drm_framebuffer *fb , struct drm_i915_gem_object *obj )
{ struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  unsigned long offset ;
  u32 flip_mask ;
  int ret ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  ret = intel_pin_and_fence_fb_obj(dev, obj, (struct intel_ring_buffer *)(& dev_priv->ring));
  }
  if (ret != 0) {
    goto out;
  } else {
  }
  {
  offset = (unsigned long )((unsigned int )crtc->y * fb->pitch + (unsigned int )((crtc->x * fb->bits_per_pixel) / 8));
  ret = intel_ring_begin((struct intel_ring_buffer *)(& dev_priv->ring), 6);
  }
  if (ret != 0) {
    goto out;
  } else {
  }
  if ((unsigned int )intel_crtc->plane != 0U) {
    flip_mask = 64U;
  } else {
    flip_mask = 4U;
  }
  {
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), flip_mask | 25165824U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 0U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), ((unsigned int )intel_crtc->plane << 20) | 167772161U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), fb->pitch);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), obj->gtt_offset + (u32 )offset);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 0U);
  intel_ring_advance((struct intel_ring_buffer *)(& dev_priv->ring));
  }
  out: ;
  return (ret);
}
}
static int intel_gen4_queue_flip(struct drm_device *dev , struct drm_crtc *crtc ,
                                 struct drm_framebuffer *fb , struct drm_i915_gem_object *obj )
{ struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  uint32_t pf ;
  uint32_t pipesrc ;
  int ret ;
  u32 tmp ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  ret = intel_pin_and_fence_fb_obj(dev, obj, (struct intel_ring_buffer *)(& dev_priv->ring));
  }
  if (ret != 0) {
    goto out;
  } else {
  }
  {
  ret = intel_ring_begin((struct intel_ring_buffer *)(& dev_priv->ring), 4);
  }
  if (ret != 0) {
    goto out;
  } else {
  }
  {
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), ((unsigned int )intel_crtc->plane << 20) | 167772162U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), fb->pitch);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), obj->gtt_offset | (uint32_t )obj->tiling_mode);
  pf = 0U;
  tmp = i915_read32___6(dev_priv, (unsigned int )intel_crtc->pipe * 4096U + 393244U);
  pipesrc = tmp & 268374015U;
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), pf | pipesrc);
  intel_ring_advance((struct intel_ring_buffer *)(& dev_priv->ring));
  }
  out: ;
  return (ret);
}
}
static int intel_gen6_queue_flip(struct drm_device *dev , struct drm_crtc *crtc ,
                                 struct drm_framebuffer *fb , struct drm_i915_gem_object *obj )
{ struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  uint32_t pf ;
  uint32_t pipesrc ;
  int ret ;
  u32 tmp ;
  u32 tmp___0 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  ret = intel_pin_and_fence_fb_obj(dev, obj, (struct intel_ring_buffer *)(& dev_priv->ring));
  }
  if (ret != 0) {
    goto out;
  } else {
  }
  {
  ret = intel_ring_begin((struct intel_ring_buffer *)(& dev_priv->ring), 4);
  }
  if (ret != 0) {
    goto out;
  } else {
  }
  {
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), ((unsigned int )intel_crtc->plane << 20) | 167772162U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), fb->pitch | (unsigned int )obj->tiling_mode);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), obj->gtt_offset);
  tmp = i915_read32___6(dev_priv, (unsigned int )intel_crtc->pipe * 2048U + 426112U);
  pf = tmp & 2147483648U;
  tmp___0 = i915_read32___6(dev_priv, (unsigned int )intel_crtc->pipe * 4096U + 393244U);
  pipesrc = tmp___0 & 268374015U;
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), pf | pipesrc);
  intel_ring_advance((struct intel_ring_buffer *)(& dev_priv->ring));
  }
  out: ;
  return (ret);
}
}
static int intel_gen7_queue_flip(struct drm_device *dev , struct drm_crtc *crtc ,
                                 struct drm_framebuffer *fb , struct drm_i915_gem_object *obj )
{ struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  struct intel_ring_buffer *ring ;
  int ret ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  ring = (struct intel_ring_buffer *)(& dev_priv->ring) + 2UL;
  ret = intel_pin_and_fence_fb_obj(dev, obj, ring);
  }
  if (ret != 0) {
    goto out;
  } else {
  }
  {
  ret = intel_ring_begin(ring, 4);
  }
  if (ret != 0) {
    goto out;
  } else {
  }
  {
  intel_ring_emit(ring, ((unsigned int )intel_crtc->plane << 19) | 167772161U);
  intel_ring_emit(ring, fb->pitch | (unsigned int )obj->tiling_mode);
  intel_ring_emit(ring, obj->gtt_offset);
  intel_ring_emit(ring, 0U);
  intel_ring_advance(ring);
  }
  out: ;
  return (ret);
}
}
static int intel_default_queue_flip(struct drm_device *dev , struct drm_crtc *crtc ,
                                    struct drm_framebuffer *fb , struct drm_i915_gem_object *obj )
{
  {
  return (-19);
}
}
static int intel_crtc_page_flip(struct drm_crtc *crtc , struct drm_framebuffer *fb ,
                                struct drm_pending_vblank_event *event )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_framebuffer *intel_fb ;
  struct drm_i915_gem_object *obj ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  struct intel_unpin_work *work ;
  unsigned long flags ;
  int ret ;
  void *tmp ;
  struct drm_framebuffer const *__mptr___0 ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  raw_spinlock_t *tmp___0 ;
  struct drm_framebuffer const *__mptr___1 ;
  raw_spinlock_t *tmp___1 ;
  {
  {
  dev = crtc->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  tmp = kzalloc(120UL, 208U);
  work = (struct intel_unpin_work *)tmp;
  }
  if ((unsigned long )work == (unsigned long )((struct intel_unpin_work *)0)) {
    return (-12);
  } else {
  }
  {
  work->event = event;
  work->dev = crtc->dev;
  __mptr___0 = (struct drm_framebuffer const *)crtc->fb;
  intel_fb = (struct intel_framebuffer *)__mptr___0;
  work->old_fb_obj = intel_fb->obj;
  __init_work(& work->work, 0);
  __constr_expr_0.counter = 2097664L;
  work->work.data = __constr_expr_0;
  lockdep_init_map(& work->work.lockdep_map, "(&work->work)", & __key, 0);
  INIT_LIST_HEAD(& work->work.entry);
  work->work.func = & intel_unpin_work_fn;
  tmp___0 = spinlock_check(& dev->event_lock);
  flags = _raw_spin_lock_irqsave(tmp___0);
  }
  if ((unsigned long )intel_crtc->unpin_work != (unsigned long )((struct intel_unpin_work *)0)) {
    {
    spin_unlock_irqrestore(& dev->event_lock, flags);
    kfree((void const *)work);
    drm_ut_debug_printk(2U, "drm", "intel_crtc_page_flip", "flip queue: crtc already busy\n");
    }
    return (-16);
  } else {
  }
  {
  intel_crtc->unpin_work = work;
  spin_unlock_irqrestore(& dev->event_lock, flags);
  __mptr___1 = (struct drm_framebuffer const *)fb;
  intel_fb = (struct intel_framebuffer *)__mptr___1;
  obj = intel_fb->obj;
  mutex_lock_nested(& dev->struct_mutex, 0U);
  drm_gem_object_reference(& (work->old_fb_obj)->base);
  drm_gem_object_reference(& obj->base);
  crtc->fb = fb;
  ret = drm_vblank_get(dev, (int )intel_crtc->pipe);
  }
  if (ret != 0) {
    goto cleanup_objs;
  } else {
  }
  {
  work->pending_flip_obj = obj;
  work->enable_stall_check = (bool )1;
  atomic_add(1 << (int )intel_crtc->plane, & (work->old_fb_obj)->pending_flip);
  ret = (*(dev_priv->display.queue_flip))(dev, crtc, fb, obj);
  }
  if (ret != 0) {
    goto cleanup_pending;
  } else {
  }
  {
  mutex_unlock(& dev->struct_mutex);
  trace_i915_flip_request((int )intel_crtc->plane, obj);
  }
  return (0);
  cleanup_pending:
  {
  atomic_sub(1 << (int )intel_crtc->plane, & (work->old_fb_obj)->pending_flip);
  }
  cleanup_objs:
  {
  drm_gem_object_unreference(& (work->old_fb_obj)->base);
  drm_gem_object_unreference(& obj->base);
  mutex_unlock(& dev->struct_mutex);
  tmp___1 = spinlock_check(& dev->event_lock);
  flags = _raw_spin_lock_irqsave(tmp___1);
  intel_crtc->unpin_work = (struct intel_unpin_work *)0;
  spin_unlock_irqrestore(& dev->event_lock, flags);
  kfree((void const *)work);
  }
  return (ret);
}
}
static void intel_sanitize_modesetting(struct drm_device *dev , int pipe , int plane )
{ struct drm_i915_private *dev_priv ;
  u32 reg ;
  u32 val ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    return;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    return;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    return;
  } else {
  }
  {
  reg = (u32 )(plane * 4096 + 459136);
  val = i915_read32___6(dev_priv, reg);
  }
  if ((int )val >= 0) {
    return;
  } else {
  }
  if (((val & 50331648U) != 0U) == pipe) {
    return;
  } else {
  }
  {
  pipe = pipe == 0;
  intel_disable_plane(dev_priv, (enum plane )plane, (enum pipe )pipe);
  intel_disable_pipe(dev_priv, (enum pipe )pipe);
  }
  return;
}
}
static void intel_crtc_reset(struct drm_crtc *crtc )
{ struct drm_device *dev ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  {
  {
  dev = crtc->dev;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  intel_crtc->dpms_mode = -1;
  intel_sanitize_modesetting(dev, (int )intel_crtc->pipe, (int )intel_crtc->plane);
  }
  return;
}
}
static struct drm_crtc_helper_funcs intel_helper_funcs =
     {& intel_crtc_dpms, (void (*)(struct drm_crtc * ))0, (void (*)(struct drm_crtc * ))0,
    & intel_crtc_mode_fixup, & intel_crtc_mode_set, & intel_pipe_set_base, & intel_pipe_set_base_atomic,
    & intel_crtc_load_lut, & intel_crtc_disable};
static struct drm_crtc_funcs const intel_crtc_funcs =
     {(void (*)(struct drm_crtc * ))0, (void (*)(struct drm_crtc * ))0, & intel_crtc_reset,
    & intel_crtc_cursor_set, & intel_crtc_cursor_move, & intel_crtc_gamma_set, & intel_crtc_destroy,
    & drm_crtc_helper_set_config, & intel_crtc_page_flip};
static void intel_crtc_init(struct drm_device *dev , int pipe )
{ drm_i915_private_t *dev_priv ;
  struct intel_crtc *intel_crtc ;
  int i ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  struct lock_class_key __key ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = kzalloc(1560UL, 208U);
  intel_crtc = (struct intel_crtc *)tmp;
  }
  if ((unsigned long )intel_crtc == (unsigned long )((struct intel_crtc *)0)) {
    return;
  } else {
  }
  {
  drm_crtc_init(dev, & intel_crtc->base, & intel_crtc_funcs);
  drm_mode_crtc_set_gamma_size(& intel_crtc->base, 256);
  i = 0;
  }
  goto ldv_40078;
  ldv_40077:
  intel_crtc->lut_r[i] = (u8 )i;
  intel_crtc->lut_g[i] = (u8 )i;
  intel_crtc->lut_b[i] = (u8 )i;
  i = i + 1;
  ldv_40078: ;
  if (i <= 255) {
    goto ldv_40077;
  } else {
    goto ldv_40079;
  }
  ldv_40079:
  intel_crtc->pipe = (enum pipe )pipe;
  intel_crtc->plane = (enum plane )pipe;
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 3U) {
      {
      drm_ut_debug_printk(4U, "drm", "intel_crtc_init", "swapping pipes & planes for FBC\n");
      intel_crtc->plane = (enum plane )(pipe == 0);
      }
    } else {
    }
  } else {
  }
  {
  tmp___0 = __builtin_expect((long )((unsigned int )pipe > 1U), 0L);
  }
  if (tmp___0 != 0L) {
    goto _L;
  } else {
    {
    tmp___1 = __builtin_expect((long )((unsigned long )dev_priv->plane_to_crtc_mapping[(unsigned int )intel_crtc->plane] != (unsigned long )((struct drm_crtc *)0)),
                               0L);
    }
    if (tmp___1 != 0L) {
      _L:
      __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p"),
                           "i" (6649), "i" (12UL));
      ldv_40083: ;
      goto ldv_40083;
    } else {
    }
  }
  {
  dev_priv->plane_to_crtc_mapping[(unsigned int )intel_crtc->plane] = & intel_crtc->base;
  dev_priv->pipe_to_crtc_mapping[(unsigned int )intel_crtc->pipe] = & intel_crtc->base;
  intel_crtc_reset(& intel_crtc->base);
  intel_crtc->active = (bool )1;
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    intel_helper_funcs.prepare = & ironlake_crtc_prepare;
    intel_helper_funcs.commit = & ironlake_crtc_commit;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    intel_helper_funcs.prepare = & ironlake_crtc_prepare;
    intel_helper_funcs.commit = & ironlake_crtc_commit;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    intel_helper_funcs.prepare = & ironlake_crtc_prepare;
    intel_helper_funcs.commit = & ironlake_crtc_commit;
  } else {
    intel_helper_funcs.prepare = & i9xx_crtc_prepare;
    intel_helper_funcs.commit = & i9xx_crtc_commit;
  }
  {
  drm_crtc_helper_add(& intel_crtc->base, (struct drm_crtc_helper_funcs const *)(& intel_helper_funcs));
  intel_crtc->busy = (bool )0;
  setup_timer_key(& intel_crtc->idle_timer, "&intel_crtc->idle_timer", & __key, & intel_crtc_idle_timer,
                  (unsigned long )intel_crtc);
  }
  return;
}
}
int intel_get_pipe_from_crtc_id(struct drm_device *dev , void *data , struct drm_file *file )
{ drm_i915_private_t *dev_priv ;
  struct drm_i915_get_pipe_from_crtc_id *pipe_from_crtc_id ;
  struct drm_mode_object *drmmode_obj ;
  struct intel_crtc *crtc ;
  struct drm_crtc const *__mptr ;
  struct drm_mode_object const *__mptr___0 ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  pipe_from_crtc_id = (struct drm_i915_get_pipe_from_crtc_id *)data;
  if ((unsigned long )dev_priv == (unsigned long )((drm_i915_private_t *)0)) {
    {
    drm_err("intel_get_pipe_from_crtc_id", "called with no initialization\n");
    }
    return (-22);
  } else {
  }
  {
  drmmode_obj = drm_mode_object_find(dev, pipe_from_crtc_id->crtc_id, 3435973836U);
  }
  if ((unsigned long )drmmode_obj == (unsigned long )((struct drm_mode_object *)0)) {
    {
    drm_err("intel_get_pipe_from_crtc_id", "no such CRTC id\n");
    }
    return (-22);
  } else {
  }
  __mptr___0 = (struct drm_mode_object const *)drmmode_obj;
  __mptr = (struct drm_crtc const *)((struct drm_crtc *)__mptr___0 + 0x0fffffffffffffe8UL);
  crtc = (struct intel_crtc *)__mptr;
  pipe_from_crtc_id->pipe = (__u32 )crtc->pipe;
  return (0);
}
}
static int intel_encoder_clones(struct drm_device *dev , int type_mask )
{ struct intel_encoder *encoder ;
  int index_mask ;
  int entry ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  {
  index_mask = 0;
  entry = 0;
  __mptr = (struct list_head const *)dev->mode_config.encoder_list.next;
  encoder = (struct intel_encoder *)__mptr + 0x0ffffffffffffff8UL;
  goto ldv_40111;
  ldv_40110: ;
  if ((encoder->clone_mask & type_mask) != 0) {
    index_mask = (1 << entry) | index_mask;
  } else {
  }
  entry = entry + 1;
  __mptr___0 = (struct list_head const *)encoder->base.head.next;
  encoder = (struct intel_encoder *)__mptr___0 + 0x0ffffffffffffff8UL;
  ldv_40111: ;
  if ((unsigned long )(& encoder->base.head) != (unsigned long )(& dev->mode_config.encoder_list)) {
    goto ldv_40110;
  } else {
    goto ldv_40112;
  }
  ldv_40112: ;
  return (index_mask);
}
}
static bool has_edp_a(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 tmp ;
  u32 tmp___0 ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) == 0U) {
    return ((bool )0);
  } else {
  }
  {
  tmp = i915_read32___6(dev_priv, 409600U);
  }
  if ((tmp & 4U) == 0U) {
    return ((bool )0);
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    tmp___0 = i915_read32___6(dev_priv, 270356U);
    }
    if ((tmp___0 & 16777216U) != 0U) {
      return ((bool )0);
    } else {
    }
  } else {
  }
  return ((bool )1);
}
}
static void intel_setup_outputs(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct intel_encoder *encoder ;
  bool dpd_is_edp ;
  bool has_lvds ;
  bool tmp ;
  u32 tmp___0 ;
  int found ;
  bool tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  bool found___0 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  struct list_head const *__mptr ;
  int tmp___12 ;
  struct list_head const *__mptr___0 ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  dpd_is_edp = (bool )0;
  has_lvds = (bool )0;
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    if (dev->pci_device != 13687) {
      {
      has_lvds = intel_lvds_init(dev);
      }
    } else {
    }
  } else {
  }
  if (! has_lvds) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 5U) {
      if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 6U) {
        if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) == 0U) {
          {
          i915_write32___4(dev_priv, 397872U, 0U);
          }
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    goto _L;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    goto _L;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    _L:
    {
    dpd_is_edp = intel_dpd_is_edp(dev);
    tmp = has_edp_a(dev);
    }
    if ((int )tmp) {
      {
      intel_dp_init(dev, 409600);
      }
    } else {
    }
    if ((int )dpd_is_edp) {
      {
      tmp___0 = i915_read32___6(dev_priv, 934656U);
      }
      if ((tmp___0 & 4U) != 0U) {
        {
        intel_dp_init(dev, 934656);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  intel_crt_init(dev);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    goto _L___2;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    goto _L___2;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    _L___2:
    {
    tmp___3 = i915_read32___6(dev_priv, 921920U);
    }
    if ((tmp___3 & 4U) != 0U) {
      {
      tmp___1 = intel_sdvo_init(dev, 921920);
      found = (int )tmp___1;
      }
      if (found == 0) {
        {
        intel_hdmi_init(dev, 921920);
        }
      } else {
      }
      if (found == 0) {
        {
        tmp___2 = i915_read32___6(dev_priv, 934144U);
        }
        if ((tmp___2 & 4U) != 0U) {
          {
          intel_dp_init(dev, 934144);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    {
    tmp___4 = i915_read32___6(dev_priv, 921936U);
    }
    if ((tmp___4 & 4U) != 0U) {
      {
      intel_hdmi_init(dev, 921936);
      }
    } else {
    }
    {
    tmp___5 = i915_read32___6(dev_priv, 921952U);
    }
    if ((tmp___5 & 4U) != 0U) {
      {
      intel_hdmi_init(dev, 921952);
      }
    } else {
    }
    {
    tmp___6 = i915_read32___6(dev_priv, 934400U);
    }
    if ((tmp___6 & 4U) != 0U) {
      {
      intel_dp_init(dev, 934400);
      }
    } else {
    }
    if (! dpd_is_edp) {
      {
      tmp___7 = i915_read32___6(dev_priv, 934656U);
      }
      if ((tmp___7 & 4U) != 0U) {
        {
        intel_dp_init(dev, 934656);
        }
      } else {
      }
    } else {
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 2U) {
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) == 0U) {
      {
      found___0 = (bool )0;
      tmp___8 = i915_read32___6(dev_priv, 397632U);
      }
      if ((tmp___8 & 4U) != 0U) {
        {
        drm_ut_debug_printk(4U, "drm", "intel_setup_outputs", "probing SDVOB\n");
        found___0 = intel_sdvo_init(dev, 397632);
        }
        if (! found___0) {
          if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
            {
            drm_ut_debug_printk(4U, "drm", "intel_setup_outputs", "probing HDMI on SDVOB\n");
            intel_hdmi_init(dev, 397632);
            }
          } else
          if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
            {
            drm_ut_debug_printk(4U, "drm", "intel_setup_outputs", "probing HDMI on SDVOB\n");
            intel_hdmi_init(dev, 397632);
            }
          } else {
          }
        } else {
        }
        if (! found___0) {
          if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
            {
            drm_ut_debug_printk(4U, "drm", "intel_setup_outputs", "probing DP_B\n");
            intel_dp_init(dev, 409856);
            }
          } else
          if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
            {
            drm_ut_debug_printk(4U, "drm", "intel_setup_outputs", "probing DP_B\n");
            intel_dp_init(dev, 409856);
            }
          } else {
          }
        } else {
        }
      } else {
      }
      {
      tmp___9 = i915_read32___6(dev_priv, 397632U);
      }
      if ((tmp___9 & 4U) != 0U) {
        {
        drm_ut_debug_printk(4U, "drm", "intel_setup_outputs", "probing SDVOC\n");
        found___0 = intel_sdvo_init(dev, 397664);
        }
      } else {
      }
      if (! found___0) {
        {
        tmp___10 = i915_read32___6(dev_priv, 397664U);
        }
        if ((tmp___10 & 4U) != 0U) {
          if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
            {
            drm_ut_debug_printk(4U, "drm", "intel_setup_outputs", "probing HDMI on SDVOC\n");
            intel_hdmi_init(dev, 397664);
            }
          } else
          if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
            {
            drm_ut_debug_printk(4U, "drm", "intel_setup_outputs", "probing HDMI on SDVOC\n");
            intel_hdmi_init(dev, 397664);
            }
          } else {
          }
          if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
            {
            drm_ut_debug_printk(4U, "drm", "intel_setup_outputs", "probing DP_C\n");
            intel_dp_init(dev, 410112);
            }
          } else
          if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
            {
            drm_ut_debug_printk(4U, "drm", "intel_setup_outputs", "probing DP_C\n");
            intel_dp_init(dev, 410112);
            }
          } else {
          }
        } else {
        }
      } else {
      }
      if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
        goto _L___0;
      } else
      if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
        _L___0:
        {
        tmp___11 = i915_read32___6(dev_priv, 410368U);
        }
        if ((tmp___11 & 4U) != 0U) {
          {
          drm_ut_debug_printk(4U, "drm", "intel_setup_outputs", "probing DP_D\n");
          intel_dp_init(dev, 410368);
          }
        } else {
        }
      } else {
      }
    } else {
      goto _L___1;
    }
  } else
  _L___1:
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 2U) {
    {
    intel_dvo_init(dev);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 3UL) != 0U) {
    {
    intel_tv_init(dev);
    }
  } else {
  }
  __mptr = (struct list_head const *)dev->mode_config.encoder_list.next;
  encoder = (struct intel_encoder *)__mptr + 0x0ffffffffffffff8UL;
  goto ldv_40132;
  ldv_40131:
  {
  encoder->base.possible_crtcs = (uint32_t )encoder->crtc_mask;
  tmp___12 = intel_encoder_clones(dev, encoder->clone_mask);
  encoder->base.possible_clones = (uint32_t )tmp___12;
  __mptr___0 = (struct list_head const *)encoder->base.head.next;
  encoder = (struct intel_encoder *)__mptr___0 + 0x0ffffffffffffff8UL;
  }
  ldv_40132: ;
  if ((unsigned long )(& encoder->base.head) != (unsigned long )(& dev->mode_config.encoder_list)) {
    goto ldv_40131;
  } else {
    goto ldv_40133;
  }
  ldv_40133:
  {
  intel_panel_setup_backlight(dev);
  drm_helper_disable_unused_functions(dev);
  }
  return;
}
}
static void intel_user_framebuffer_destroy(struct drm_framebuffer *fb )
{ struct intel_framebuffer *intel_fb ;
  struct drm_framebuffer const *__mptr ;
  {
  {
  __mptr = (struct drm_framebuffer const *)fb;
  intel_fb = (struct intel_framebuffer *)__mptr;
  drm_framebuffer_cleanup(fb);
  drm_gem_object_unreference_unlocked(& (intel_fb->obj)->base);
  kfree((void const *)intel_fb);
  }
  return;
}
}
static int intel_user_framebuffer_create_handle(struct drm_framebuffer *fb , struct drm_file *file ,
                                                unsigned int *handle )
{ struct intel_framebuffer *intel_fb ;
  struct drm_framebuffer const *__mptr ;
  struct drm_i915_gem_object *obj ;
  int tmp ;
  {
  {
  __mptr = (struct drm_framebuffer const *)fb;
  intel_fb = (struct intel_framebuffer *)__mptr;
  obj = intel_fb->obj;
  tmp = drm_gem_handle_create(file, & obj->base, handle);
  }
  return (tmp);
}
}
static struct drm_framebuffer_funcs const intel_fb_funcs = {& intel_user_framebuffer_destroy, & intel_user_framebuffer_create_handle, (int (*)(struct drm_framebuffer * ,
                                                                                       struct drm_file * ,
                                                                                       unsigned int ,
                                                                                       unsigned int ,
                                                                                       struct drm_clip_rect * ,
                                                                                       unsigned int ))0};
int intel_framebuffer_init(struct drm_device *dev , struct intel_framebuffer *intel_fb ,
                           struct drm_mode_fb_cmd *mode_cmd , struct drm_i915_gem_object *obj )
{ int ret ;
  {
  if ((unsigned int )*((unsigned char *)obj + 225UL) == 8U) {
    return (-22);
  } else {
  }
  if ((mode_cmd->pitch & 63U) != 0U) {
    return (-22);
  } else {
  }
  if ((int )mode_cmd->bpp == 8) {
    goto case_8;
  } else
  if ((int )mode_cmd->bpp == 16) {
    goto case_16;
  } else
  if ((int )mode_cmd->bpp == 24) {
    goto case_24;
  } else
  if ((int )mode_cmd->bpp == 32) {
    goto case_32;
  } else {
    goto switch_default;
    if (0) {
      case_8: ;
      case_16: ;
      case_24: ;
      case_32: ;
      goto ldv_40161;
      switch_default: ;
      return (-22);
    } else {
    }
  }
  ldv_40161:
  {
  ret = drm_framebuffer_init(dev, & intel_fb->base, & intel_fb_funcs);
  }
  if (ret != 0) {
    {
    drm_err("intel_framebuffer_init", "framebuffer init failed %d\n", ret);
    }
    return (ret);
  } else {
  }
  {
  drm_helper_mode_fill_fb_struct(& intel_fb->base, mode_cmd);
  intel_fb->obj = obj;
  }
  return (0);
}
}
static struct drm_framebuffer *intel_user_framebuffer_create(struct drm_device *dev ,
                                                             struct drm_file *filp ,
                                                             struct drm_mode_fb_cmd *mode_cmd )
{ struct drm_i915_gem_object *obj ;
  struct drm_gem_object const *__mptr ;
  struct drm_gem_object *tmp ;
  void *tmp___0 ;
  struct drm_framebuffer *tmp___1 ;
  {
  {
  tmp = drm_gem_object_lookup(dev, filp, mode_cmd->handle);
  __mptr = (struct drm_gem_object const *)tmp;
  obj = (struct drm_i915_gem_object *)__mptr;
  }
  if ((unsigned long )(& obj->base) == (unsigned long )((struct drm_gem_object *)0)) {
    {
    tmp___0 = ERR_PTR(-2L);
    }
    return ((struct drm_framebuffer *)tmp___0);
  } else {
  }
  {
  tmp___1 = intel_framebuffer_create(dev, mode_cmd, obj);
  }
  return (tmp___1);
}
}
static struct drm_mode_config_funcs const intel_mode_funcs = {& intel_user_framebuffer_create, & intel_fb_output_poll_changed};
static struct drm_i915_gem_object *intel_alloc_context_page(struct drm_device *dev )
{ struct drm_i915_gem_object *ctx ;
  int ret ;
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  {
  {
  tmp = mutex_is_locked(& dev->struct_mutex);
  __ret_warn_on = tmp == 0;
  tmp___0 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp___0 != 0L) {
    {
    warn_slowpath_null("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p",
                       (int const )6924);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on != 0), 0L);
  ctx = i915_gem_alloc_object(dev, 4096UL);
  }
  if ((unsigned long )ctx == (unsigned long )((struct drm_i915_gem_object *)0)) {
    {
    drm_ut_debug_printk(1U, "drm", "intel_alloc_context_page", "failed to alloc power context, RC6 disabled\n");
    }
    return ((struct drm_i915_gem_object *)0);
  } else {
  }
  {
  ret = i915_gem_object_pin(ctx, 4096U, (bool )1);
  }
  if (ret != 0) {
    {
    drm_err("intel_alloc_context_page", "failed to pin power context: %d\n", ret);
    }
    goto err_unref;
  } else {
  }
  {
  ret = i915_gem_object_set_to_gtt_domain(ctx, (bool )1);
  }
  if (ret != 0) {
    {
    drm_err("intel_alloc_context_page", "failed to set-domain on power context: %d\n",
            ret);
    }
    goto err_unpin;
  } else {
  }
  return (ctx);
  err_unpin:
  {
  i915_gem_object_unpin(ctx);
  }
  err_unref:
  {
  drm_gem_object_unreference(& ctx->base);
  mutex_unlock(& dev->struct_mutex);
  }
  return ((struct drm_i915_gem_object *)0);
}
}
bool ironlake_set_drps(struct drm_device *dev , u8 val )
{ struct drm_i915_private *dev_priv ;
  u16 rgvswctl ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  rgvswctl = i915_read16___2(dev_priv, 70000U);
  }
  if (((int )rgvswctl & 4096) != 0) {
    {
    drm_ut_debug_printk(1U, "drm", "ironlake_set_drps", "gpu busy, RCS change rejected\n");
    }
    return ((bool )0);
  } else {
  }
  {
  rgvswctl = (u16 )((int )((short )((int )val << 8)) | 16512);
  i915_write16___0(dev_priv, 70000U, (u16 )((int )rgvswctl));
  readw((void const volatile *)dev_priv->regs + 70000U);
  rgvswctl = (u16 )((unsigned int )rgvswctl | 4096U);
  i915_write16___0(dev_priv, 70000U, (u16 )((int )rgvswctl));
  }
  return ((bool )1);
}
}
void ironlake_enable_drps(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 rgvmodectl ;
  u32 tmp ;
  u8 fmax ;
  u8 fmin ;
  u8 fstart ;
  u8 vstart ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  unsigned long timeout__ ;
  unsigned long tmp___3 ;
  int ret__ ;
  struct thread_info *tmp___4 ;
  int pfo_ret__ ;
  int tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  unsigned int tmp___10 ;
  u32 tmp___11 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = i915_read32___6(dev_priv, 70032U);
  rgvmodectl = tmp;
  tmp___0 = i915_read32___6(dev_priv, 70164U);
  i915_write16___0(dev_priv, 70164U, (u16 )((int )((unsigned int )((u16 )tmp___0) | 1U)));
  tmp___1 = i915_read32___6(dev_priv, 69633U);
  i915_write16___0(dev_priv, 69633U, (u16 )((int )((unsigned int )((u16 )tmp___1) | 1U)));
  i915_write32___4(dev_priv, 70064U, 100000U);
  i915_write32___4(dev_priv, 70068U, 100000U);
  i915_write32___4(dev_priv, 70044U, 90000U);
  i915_write32___4(dev_priv, 70048U, 80000U);
  i915_write32___4(dev_priv, 70012U, 1U);
  fmax = (u8 )((rgvmodectl & 240U) >> 4);
  fmin = (u8 )((unsigned int )((u8 )rgvmodectl) & 15U);
  fstart = (u8 )((rgvmodectl & 3840U) >> 8);
  tmp___2 = i915_read32___6(dev_priv, (u32 )(((int )fstart + 17476) * 4));
  vstart = (u8 )((tmp___2 & 2130706432U) >> 24);
  dev_priv->fmax = fmax;
  dev_priv->fstart = fstart;
  dev_priv->max_delay = fstart;
  dev_priv->min_delay = fmin;
  dev_priv->cur_delay = fstart;
  drm_ut_debug_printk(2U, "drm", "ironlake_enable_drps", "fmax: %d, fmin: %d, fstart: %d\n",
                      (int )fmax, (int )fmin, (int )fstart);
  i915_write32___4(dev_priv, 70016U, 144U);
  i915_write32___4(dev_priv, 70092U, (u32 )vstart);
  readl((void const volatile *)dev_priv->regs + 70092U);
  rgvmodectl = rgvmodectl | 16384U;
  i915_write32___4(dev_priv, 70032U, rgvmodectl);
  tmp___3 = msecs_to_jiffies((unsigned int const )10U);
  timeout__ = tmp___3 + (unsigned long )jiffies;
  ret__ = 0;
  }
  goto ldv_40218;
  ldv_40217: ;
  if ((long )timeout__ - (long )jiffies < 0L) {
    ret__ = -110;
    goto ldv_40208;
  } else {
  }
  {
  tmp___4 = current_thread_info();
  }
  if ((tmp___4->preempt_count & -268435457) == 0) {
    if (1) {
      goto case_4;
    } else {
      goto switch_default;
      if (0) {
        __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
        goto ldv_40211;
        __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_40211;
        case_4:
        __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_40211;
        __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_40211;
        switch_default:
        {
        __bad_percpu_size();
        }
      } else {
      }
    }
    ldv_40211:
    {
    tmp___5 = atomic_read((atomic_t const *)(& kgdb_active));
    }
    if (pfo_ret__ != tmp___5) {
      {
      msleep(1U);
      }
    } else {
    }
  } else {
  }
  ldv_40218:
  {
  tmp___6 = i915_read32___6(dev_priv, 70000U);
  }
  if ((tmp___6 & 4096U) != 0U) {
    goto ldv_40217;
  } else {
    goto ldv_40208;
  }
  ldv_40208: ;
  if (ret__ != 0) {
    {
    drm_err("ironlake_enable_drps", "stuck trying to change perf mode\n");
    }
  } else {
  }
  {
  msleep(1U);
  ironlake_set_drps(dev, (u8 )((int )fstart));
  tmp___7 = i915_read32___6(dev_priv, 70372U);
  tmp___8 = i915_read32___6(dev_priv, 70376U);
  tmp___9 = i915_read32___6(dev_priv, 70368U);
  dev_priv->last_count1 = (u64 )((tmp___7 + tmp___8) + tmp___9);
  tmp___10 = jiffies_to_msecs((unsigned long const )jiffies);
  dev_priv->last_time1 = (unsigned long )tmp___10;
  tmp___11 = i915_read32___6(dev_priv, 70388U);
  dev_priv->last_count2 = (u64 )tmp___11;
  getrawmonotonic(& dev_priv->last_time2);
  }
  return;
}
}
void ironlake_disable_drps(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u16 rgvswctl ;
  u16 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = i915_read16___2(dev_priv, 70000U);
  rgvswctl = tmp;
  tmp___0 = i915_read32___6(dev_priv, 70016U);
  i915_write32___4(dev_priv, 70016U, tmp___0 & 4294967279U);
  i915_write32___4(dev_priv, 70020U, 16U);
  tmp___1 = i915_read32___6(dev_priv, 278540U);
  i915_write32___4(dev_priv, 278540U, tmp___1 & 4261412863U);
  i915_write32___4(dev_priv, 278536U, 33554432U);
  tmp___2 = i915_read32___6(dev_priv, 278532U);
  i915_write32___4(dev_priv, 278532U, tmp___2 | 33554432U);
  ironlake_set_drps(dev, (u8 )((int )dev_priv->fstart));
  msleep(1U);
  rgvswctl = (u16 )((unsigned int )rgvswctl | 4096U);
  i915_write32___4(dev_priv, 70000U, (u32 )rgvswctl);
  msleep(1U);
  }
  return;
}
}
void gen6_set_rps(struct drm_device *dev , u8 val )
{ struct drm_i915_private *dev_priv ;
  u32 swreq ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  swreq = (u32 )((int )val << 25);
  i915_write32___4(dev_priv, 40968U, swreq);
  }
  return;
}
}
void gen6_disable_rps(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 tmp ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  i915_write32___4(dev_priv, 40968U, 2147483648U);
  i915_write32___4(dev_priv, 41320U, 4294967295U);
  i915_write32___4(dev_priv, 278572U, 0U);
  spin_lock_irq(& dev_priv->rps_lock);
  dev_priv->pm_iir = 0U;
  spin_unlock_irq(& dev_priv->rps_lock);
  tmp = i915_read32___6(dev_priv, 278568U);
  i915_write32___4(dev_priv, 278568U, tmp);
  }
  return;
}
}
static unsigned long intel_pxfreq(u32 vidfreq )
{ unsigned long freq ;
  int div ;
  int post ;
  int pre ;
  {
  div = (int )((vidfreq & 4128768U) >> 16);
  post = (int )((vidfreq & 12288U) >> 12);
  pre = (int )vidfreq & 7;
  if (pre == 0) {
    return (0UL);
  } else {
  }
  freq = (unsigned long )((div * 133333) / (pre << post));
  return (freq);
}
}
void intel_init_emon(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 lcfuse ;
  u8 pxw[16U] ;
  int i ;
  u32 pxvidfreq ;
  u32 tmp ;
  unsigned long freq ;
  unsigned long tmp___0 ;
  unsigned long vid ;
  unsigned long val ;
  u32 val___0 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  i915_write32___4(dev_priv, 71168U, 0U);
  readl((void const volatile *)dev_priv->regs + 71168U);
  i915_write32___4(dev_priv, 70220U, 352587008U);
  i915_write32___4(dev_priv, 70224U, 8323072U);
  i915_write32___4(dev_priv, 70228U, 505544708U);
  i915_write32___4(dev_priv, 70232U, 67108868U);
  i = 0;
  }
  goto ldv_40250;
  ldv_40249:
  {
  i915_write32___4(dev_priv, (u32 )((i + 17559) * 4), 0U);
  i = i + 1;
  }
  ldv_40250: ;
  if (i <= 4) {
    goto ldv_40249;
  } else {
    goto ldv_40251;
  }
  ldv_40251:
  i = 0;
  goto ldv_40253;
  ldv_40252:
  {
  i915_write32___4(dev_priv, (u32 )((i + 17564) * 4), 0U);
  i = i + 1;
  }
  ldv_40253: ;
  if (i <= 2) {
    goto ldv_40252;
  } else {
    goto ldv_40254;
  }
  ldv_40254:
  i = 0;
  goto ldv_40261;
  ldv_40260:
  {
  tmp = i915_read32___6(dev_priv, (u32 )((i + 17476) * 4));
  pxvidfreq = tmp;
  tmp___0 = intel_pxfreq(pxvidfreq);
  freq = tmp___0;
  vid = (unsigned long )((pxvidfreq & 2130706432U) >> 24);
  val = vid * vid;
  val = (freq / 1000UL) * val;
  val = val * 255UL;
  val = val / 14516100UL;
  }
  if (val > 255UL) {
    {
    drm_err("intel_init_emon", "bad pxval: %ld\n", val);
    }
  } else {
  }
  pxw[i] = (u8 )val;
  i = i + 1;
  ldv_40261: ;
  if (i <= 15) {
    goto ldv_40260;
  } else {
    goto ldv_40262;
  }
  ldv_40262:
  pxw[14] = (u8 )0U;
  pxw[15] = (u8 )0U;
  i = 0;
  goto ldv_40265;
  ldv_40264:
  {
  val___0 = (u32 )(((((int )pxw[i * 4] << 24) | ((int )pxw[i * 4 + 1] << 16)) | ((int )pxw[i * 4 + 2] << 8)) | (int )pxw[i * 4 + 3]);
  i915_write32___4(dev_priv, (u32 )((i + 17817) * 4), val___0);
  i = i + 1;
  }
  ldv_40265: ;
  if (i <= 3) {
    goto ldv_40264;
  } else {
    goto ldv_40266;
  }
  ldv_40266:
  {
  i915_write32___4(dev_priv, 71176U, 0U);
  i915_write32___4(dev_priv, 71180U, 0U);
  i915_write32___4(dev_priv, 71184U, 32512U);
  i915_write32___4(dev_priv, 71188U, 14U);
  i915_write32___4(dev_priv, 71192U, 917504U);
  i915_write32___4(dev_priv, 71196U, 1744831232U);
  i915_write32___4(dev_priv, 71200U, 1107296256U);
  i915_write32___4(dev_priv, 71204U, 1310769U);
  i915_write32___4(dev_priv, 71208U, 0U);
  i915_write32___4(dev_priv, 71212U, 0U);
  i = 0;
  }
  goto ldv_40268;
  ldv_40267:
  {
  i915_write32___4(dev_priv, (u32 )((i + 17824) * 4), 0U);
  i = i + 1;
  }
  ldv_40268: ;
  if (i <= 7) {
    goto ldv_40267;
  } else {
    goto ldv_40269;
  }
  ldv_40269:
  {
  i915_write32___4(dev_priv, 71168U, 2147483673U);
  lcfuse = i915_read32___6(dev_priv, 71360U);
  dev_priv->corr = (u8 )lcfuse;
  }
  return;
}
}
void gen6_enable_rps(struct drm_i915_private *dev_priv )
{ u32 rp_state_cap ;
  u32 tmp ;
  u32 gt_perf_status ;
  u32 tmp___0 ;
  u32 pcu_mbox ;
  u32 rc6_mask ;
  int cur_freq ;
  int min_freq ;
  int max_freq ;
  int i ;
  unsigned long timeout__ ;
  unsigned long tmp___1 ;
  int ret__ ;
  struct thread_info *tmp___2 ;
  int pfo_ret__ ;
  int tmp___3 ;
  u32 tmp___4 ;
  unsigned long timeout_____0 ;
  unsigned long tmp___5 ;
  int ret_____0 ;
  struct thread_info *tmp___6 ;
  int pfo_ret_____0 ;
  int tmp___7 ;
  u32 tmp___8 ;
  unsigned long timeout_____1 ;
  unsigned long tmp___9 ;
  int ret_____1 ;
  struct thread_info *tmp___10 ;
  int pfo_ret_____1 ;
  int tmp___11 ;
  u32 tmp___12 ;
  unsigned long timeout_____2 ;
  unsigned long tmp___13 ;
  int ret_____2 ;
  struct thread_info *tmp___14 ;
  int pfo_ret_____2 ;
  int tmp___15 ;
  u32 tmp___16 ;
  int __ret_warn_on ;
  long tmp___17 ;
  {
  {
  tmp = i915_read32___6(dev_priv, 1333656U);
  rp_state_cap = tmp;
  tmp___0 = i915_read32___6(dev_priv, 1333576U);
  gt_perf_status = tmp___0;
  rc6_mask = 0U;
  i915_write32___4(dev_priv, 41108U, 0U);
  mutex_lock_nested(& (dev_priv->dev)->struct_mutex, 0U);
  gen6_gt_force_wake_get(dev_priv);
  i915_write32___4(dev_priv, 41104U, 0U);
  i915_write32___4(dev_priv, 41112U, 65536000U);
  i915_write32___4(dev_priv, 41116U, 2621470U);
  i915_write32___4(dev_priv, 41120U, 30U);
  i915_write32___4(dev_priv, 41128U, 125000U);
  i915_write32___4(dev_priv, 41132U, 25U);
  i = 0;
  }
  goto ldv_40282;
  ldv_40281:
  {
  i915_write32___4(dev_priv, dev_priv->ring[i].mmio_base + 84U, 10U);
  i = i + 1;
  }
  ldv_40282: ;
  if (i <= 2) {
    goto ldv_40281;
  } else {
    goto ldv_40283;
  }
  ldv_40283:
  {
  i915_write32___4(dev_priv, 41136U, 0U);
  i915_write32___4(dev_priv, 41140U, 1000U);
  i915_write32___4(dev_priv, 41144U, 50000U);
  i915_write32___4(dev_priv, 41148U, 100000U);
  i915_write32___4(dev_priv, 41152U, 64000U);
  }
  if (i915_enable_rc6 != 0U) {
    rc6_mask = 393216U;
  } else {
  }
  {
  i915_write32___4(dev_priv, 41104U, rc6_mask | 2281701376U);
  i915_write32___4(dev_priv, 40968U, 335544320U);
  i915_write32___4(dev_priv, 40972U, 402653184U);
  i915_write32___4(dev_priv, 40976U, 1000000U);
  i915_write32___4(dev_priv, 40980U, 302383104U);
  i915_write32___4(dev_priv, 41004U, 10000U);
  i915_write32___4(dev_priv, 41008U, 1000000U);
  i915_write32___4(dev_priv, 41064U, 100000U);
  i915_write32___4(dev_priv, 41068U, 5000000U);
  i915_write32___4(dev_priv, 41072U, 10U);
  i915_write32___4(dev_priv, 40996U, 2961U);
  tmp___1 = msecs_to_jiffies((unsigned int const )500U);
  timeout__ = tmp___1 + (unsigned long )jiffies;
  ret__ = 0;
  }
  goto ldv_40302;
  ldv_40301: ;
  if ((long )timeout__ - (long )jiffies < 0L) {
    ret__ = -110;
    goto ldv_40292;
  } else {
  }
  {
  tmp___2 = current_thread_info();
  }
  if ((tmp___2->preempt_count & -268435457) == 0) {
    if (1) {
      goto case_4;
    } else {
      goto switch_default;
      if (0) {
        __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
        goto ldv_40295;
        __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_40295;
        case_4:
        __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_40295;
        __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_40295;
        switch_default:
        {
        __bad_percpu_size();
        }
      } else {
      }
    }
    ldv_40295:
    {
    tmp___3 = atomic_read((atomic_t const *)(& kgdb_active));
    }
    if (pfo_ret__ != tmp___3) {
      {
      msleep(1U);
      }
    } else {
    }
  } else {
  }
  ldv_40302:
  {
  tmp___4 = i915_read32___6(dev_priv, 1278244U);
  }
  if ((int )tmp___4 < 0) {
    goto ldv_40301;
  } else {
    goto ldv_40292;
  }
  ldv_40292: ;
  if (ret__ != 0) {
    {
    drm_err("gen6_enable_rps", "timeout waiting for pcode mailbox to become idle\n");
    }
  } else {
  }
  {
  i915_write32___4(dev_priv, 1278248U, 0U);
  i915_write32___4(dev_priv, 1278244U, 2147483657U);
  tmp___5 = msecs_to_jiffies((unsigned int const )500U);
  timeout_____0 = tmp___5 + (unsigned long )jiffies;
  ret_____0 = 0;
  }
  goto ldv_40323;
  ldv_40322: ;
  if ((long )timeout_____0 - (long )jiffies < 0L) {
    ret_____0 = -110;
    goto ldv_40313;
  } else {
  }
  {
  tmp___6 = current_thread_info();
  }
  if ((tmp___6->preempt_count & -268435457) == 0) {
    if (1) {
      goto case_4___0;
    } else {
      goto switch_default___0;
      if (0) {
        __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
        goto ldv_40316;
        __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
        goto ldv_40316;
        case_4___0:
        __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
        goto ldv_40316;
        __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
        goto ldv_40316;
        switch_default___0:
        {
        __bad_percpu_size();
        }
      } else {
      }
    }
    ldv_40316:
    {
    tmp___7 = atomic_read((atomic_t const *)(& kgdb_active));
    }
    if (pfo_ret_____0 != tmp___7) {
      {
      msleep(1U);
      }
    } else {
    }
  } else {
  }
  ldv_40323:
  {
  tmp___8 = i915_read32___6(dev_priv, 1278244U);
  }
  if ((int )tmp___8 < 0) {
    goto ldv_40322;
  } else {
    goto ldv_40313;
  }
  ldv_40313: ;
  if (ret_____0 != 0) {
    {
    drm_err("gen6_enable_rps", "timeout waiting for pcode mailbox to finish\n");
    }
  } else {
  }
  {
  min_freq = (int )((rp_state_cap & 16711680U) >> 16);
  max_freq = (int )rp_state_cap & 255;
  cur_freq = (int )((gt_perf_status & 65280U) >> 8);
  tmp___9 = msecs_to_jiffies((unsigned int const )500U);
  timeout_____1 = tmp___9 + (unsigned long )jiffies;
  ret_____1 = 0;
  }
  goto ldv_40343;
  ldv_40342: ;
  if ((long )timeout_____1 - (long )jiffies < 0L) {
    ret_____1 = -110;
    goto ldv_40333;
  } else {
  }
  {
  tmp___10 = current_thread_info();
  }
  if ((tmp___10->preempt_count & -268435457) == 0) {
    if (1) {
      goto case_4___1;
    } else {
      goto switch_default___1;
      if (0) {
        __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
        goto ldv_40336;
        __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
        goto ldv_40336;
        case_4___1:
        __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
        goto ldv_40336;
        __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
        goto ldv_40336;
        switch_default___1:
        {
        __bad_percpu_size();
        }
      } else {
      }
    }
    ldv_40336:
    {
    tmp___11 = atomic_read((atomic_t const *)(& kgdb_active));
    }
    if (pfo_ret_____1 != tmp___11) {
      {
      msleep(1U);
      }
    } else {
    }
  } else {
  }
  ldv_40343:
  {
  tmp___12 = i915_read32___6(dev_priv, 1278244U);
  }
  if ((int )tmp___12 < 0) {
    goto ldv_40342;
  } else {
    goto ldv_40333;
  }
  ldv_40333: ;
  if (ret_____1 != 0) {
    {
    drm_err("gen6_enable_rps", "timeout waiting for pcode mailbox to become idle\n");
    }
  } else {
  }
  {
  i915_write32___4(dev_priv, 1278244U, 12U);
  pcu_mbox = i915_read32___6(dev_priv, 1278248U);
  tmp___13 = msecs_to_jiffies((unsigned int const )500U);
  timeout_____2 = tmp___13 + (unsigned long )jiffies;
  ret_____2 = 0;
  }
  goto ldv_40363;
  ldv_40362: ;
  if ((long )timeout_____2 - (long )jiffies < 0L) {
    ret_____2 = -110;
    goto ldv_40353;
  } else {
  }
  {
  tmp___14 = current_thread_info();
  }
  if ((tmp___14->preempt_count & -268435457) == 0) {
    if (1) {
      goto case_4___2;
    } else {
      goto switch_default___2;
      if (0) {
        __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
        goto ldv_40356;
        __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
        goto ldv_40356;
        case_4___2:
        __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
        goto ldv_40356;
        __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
        goto ldv_40356;
        switch_default___2:
        {
        __bad_percpu_size();
        }
      } else {
      }
    }
    ldv_40356:
    {
    tmp___15 = atomic_read((atomic_t const *)(& kgdb_active));
    }
    if (pfo_ret_____2 != tmp___15) {
      {
      msleep(1U);
      }
    } else {
    }
  } else {
  }
  ldv_40363:
  {
  tmp___16 = i915_read32___6(dev_priv, 1278244U);
  }
  if ((int )tmp___16 < 0) {
    goto ldv_40362;
  } else {
    goto ldv_40353;
  }
  ldv_40353: ;
  if (ret_____2 != 0) {
    {
    drm_err("gen6_enable_rps", "timeout waiting for pcode mailbox to finish\n");
    }
  } else {
  }
  if ((int )pcu_mbox < 0) {
    {
    max_freq = (int )pcu_mbox & 255;
    drm_ut_debug_printk(2U, "drm", "gen6_enable_rps", "overclocking supported, adjusting frequency max to %dMHz\n",
                        pcu_mbox * 50U);
    }
  } else {
  }
  {
  dev_priv->max_delay = (u8 )max_freq;
  dev_priv->min_delay = (u8 )min_freq;
  dev_priv->cur_delay = (u8 )cur_freq;
  i915_write32___4(dev_priv, 278572U, 50331766U);
  spin_lock_irq(& dev_priv->rps_lock);
  __ret_warn_on = dev_priv->pm_iir != 0U;
  tmp___17 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp___17 != 0L) {
    {
    warn_slowpath_null("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_display.c.p",
                       (int const )7285);
    }
  } else {
  }
  {
  __builtin_expect((long )(__ret_warn_on != 0), 0L);
  i915_write32___4(dev_priv, 278564U, 0U);
  spin_unlock_irq(& dev_priv->rps_lock);
  i915_write32___4(dev_priv, 41320U, 0U);
  gen6_gt_force_wake_put(dev_priv);
  mutex_unlock(& (dev_priv->dev)->struct_mutex);
  }
  return;
}
}
static void ironlake_init_clock_gating(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  uint32_t dspclk_gate ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  dspclk_gate = 268435456U;
  dspclk_gate = dspclk_gate | 896U;
  dspclk_gate = dspclk_gate | 32U;
  i915_write32___4(dev_priv, 286752U, 262146U);
  i915_write32___4(dev_priv, 286756U, 2048U);
  i915_write32___4(dev_priv, 270368U, dspclk_gate);
  tmp = i915_read32___6(dev_priv, 270340U);
  i915_write32___4(dev_priv, 270340U, tmp | 6291456U);
  tmp___0 = i915_read32___6(dev_priv, 270368U);
  i915_write32___4(dev_priv, 270368U, tmp___0 | 32U);
  tmp___1 = i915_read32___6(dev_priv, 282624U);
  i915_write32___4(dev_priv, 282624U, tmp___1 | 32768U);
  i915_write32___4(dev_priv, 282896U, 0U);
  i915_write32___4(dev_priv, 282892U, 0U);
  i915_write32___4(dev_priv, 282888U, 0U);
  }
  if (dev->pci_device == 70) {
    {
    tmp___2 = i915_read32___6(dev_priv, 270336U);
    i915_write32___4(dev_priv, 270336U, tmp___2 | 4194304U);
    tmp___3 = i915_read32___6(dev_priv, 270340U);
    i915_write32___4(dev_priv, 270340U, tmp___3 | 4194304U);
    tmp___4 = i915_read32___6(dev_priv, 270368U);
    i915_write32___4(dev_priv, 270368U, tmp___4 | 896U);
    }
  } else {
  }
  {
  tmp___5 = i915_read32___6(dev_priv, 270340U);
  i915_write32___4(dev_priv, 270340U, tmp___5 | 33554432U);
  i915_write32___4(dev_priv, 8332U, 1073758208U);
  }
  return;
}
}
static void gen6_init_clock_gating(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  int pipe ;
  uint32_t dspclk_gate ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  dspclk_gate = 268435456U;
  i915_write32___4(dev_priv, 270368U, dspclk_gate);
  tmp = i915_read32___6(dev_priv, 270340U);
  i915_write32___4(dev_priv, 270340U, tmp | 33554432U);
  i915_write32___4(dev_priv, 282896U, 0U);
  i915_write32___4(dev_priv, 282892U, 0U);
  i915_write32___4(dev_priv, 282888U, 0U);
  tmp___0 = i915_read32___6(dev_priv, 270336U);
  i915_write32___4(dev_priv, 270336U, tmp___0 | 6291456U);
  tmp___1 = i915_read32___6(dev_priv, 270340U);
  i915_write32___4(dev_priv, 270340U, tmp___1 | 6291456U);
  tmp___2 = i915_read32___6(dev_priv, 270368U);
  i915_write32___4(dev_priv, 270368U, tmp___2 | 160U);
  pipe = 0;
  }
  goto ldv_40379;
  ldv_40378:
  {
  tmp___3 = i915_read32___6(dev_priv, (u32 )(pipe * 4096 + 459136));
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 459136), tmp___3 | 16384U);
  pipe = pipe + 1;
  }
  ldv_40379: ;
  if (dev_priv->num_pipe > pipe) {
    goto ldv_40378;
  } else {
    goto ldv_40380;
  }
  ldv_40380: ;
  return;
}
}
static void ivybridge_init_clock_gating(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  int pipe ;
  uint32_t dspclk_gate ;
  u32 tmp ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  dspclk_gate = 268435456U;
  i915_write32___4(dev_priv, 270368U, dspclk_gate);
  i915_write32___4(dev_priv, 282896U, 0U);
  i915_write32___4(dev_priv, 282892U, 0U);
  i915_write32___4(dev_priv, 282888U, 0U);
  i915_write32___4(dev_priv, 270368U, 268435456U);
  pipe = 0;
  }
  goto ldv_40388;
  ldv_40387:
  {
  tmp = i915_read32___6(dev_priv, (u32 )(pipe * 4096 + 459136));
  i915_write32___4(dev_priv, (u32 )(pipe * 4096 + 459136), tmp | 16384U);
  pipe = pipe + 1;
  }
  ldv_40388: ;
  if (dev_priv->num_pipe > pipe) {
    goto ldv_40387;
  } else {
    goto ldv_40389;
  }
  ldv_40389: ;
  return;
}
}
static void g4x_init_clock_gating(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  uint32_t dspclk_gate ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  i915_write32___4(dev_priv, 25092U, 0U);
  i915_write32___4(dev_priv, 25096U, 704U);
  i915_write32___4(dev_priv, 25104U, 0U);
  dspclk_gate = 268435468U;
  }
  if (dev->pci_device == 10818) {
    dspclk_gate = dspclk_gate | 262144U;
  } else {
  }
  {
  i915_write32___4(dev_priv, 25088U, dspclk_gate);
  }
  return;
}
}
static void crestline_init_clock_gating(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  i915_write32___4(dev_priv, 25092U, 536870912U);
  i915_write32___4(dev_priv, 25096U, 0U);
  i915_write32___4(dev_priv, 25088U, 0U);
  i915_write32___4(dev_priv, 25104U, 0U);
  i915_write16___0(dev_priv, 25108U, (u16 )0);
  }
  return;
}
}
static void broadwater_init_clock_gating(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  i915_write32___4(dev_priv, 25092U, 1887502336U);
  i915_write32___4(dev_priv, 25096U, 0U);
  }
  return;
}
}
static void gen3_init_clock_gating(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 dstate ;
  u32 tmp ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = i915_read32___6(dev_priv, 24836U);
  dstate = tmp;
  dstate = dstate | 11U;
  i915_write32___4(dev_priv, 24836U, dstate);
  }
  return;
}
}
static void i85x_init_clock_gating(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  i915_write32___4(dev_priv, 25092U, 1U);
  }
  return;
}
}
static void i830_init_clock_gating(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  i915_write32___4(dev_priv, 25088U, 8U);
  }
  return;
}
}
static void ibx_init_clock_gating(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  i915_write32___4(dev_priv, 794656U, 536870912U);
  }
  return;
}
}
static void cpt_init_clock_gating(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 tmp ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  i915_write32___4(dev_priv, 794656U, 536870912U);
  tmp = i915_read32___6(dev_priv, 794628U);
  i915_write32___4(dev_priv, 794628U, tmp | 1U);
  }
  return;
}
}
static void ironlake_teardown_rc6(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned long )dev_priv->renderctx != (unsigned long )((struct drm_i915_gem_object *)0)) {
    {
    i915_gem_object_unpin(dev_priv->renderctx);
    drm_gem_object_unreference(& (dev_priv->renderctx)->base);
    dev_priv->renderctx = (struct drm_i915_gem_object *)0;
    }
  } else {
  }
  if ((unsigned long )dev_priv->pwrctx != (unsigned long )((struct drm_i915_gem_object *)0)) {
    {
    i915_gem_object_unpin(dev_priv->pwrctx);
    drm_gem_object_unreference(& (dev_priv->pwrctx)->base);
    dev_priv->pwrctx = (struct drm_i915_gem_object *)0;
    }
  } else {
  }
  return;
}
}
static void ironlake_disable_rc6(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 tmp ;
  unsigned long timeout__ ;
  unsigned long tmp___0 ;
  int ret__ ;
  struct thread_info *tmp___1 ;
  int pfo_ret__ ;
  int tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp___5 = i915_read32___6(dev_priv, 8328U);
  }
  if (tmp___5 != 0U) {
    {
    tmp = i915_read32___6(dev_priv, 70072U);
    i915_write32___4(dev_priv, 70072U, tmp | 8388608U);
    tmp___0 = msecs_to_jiffies((unsigned int const )50U);
    timeout__ = tmp___0 + (unsigned long )jiffies;
    ret__ = 0;
    }
    goto ldv_40450;
    ldv_40449: ;
    if ((long )timeout__ - (long )jiffies < 0L) {
      ret__ = -110;
      goto ldv_40440;
    } else {
    }
    {
    tmp___1 = current_thread_info();
    }
    if ((tmp___1->preempt_count & -268435457) == 0) {
      if (1) {
        goto case_4;
      } else {
        goto switch_default;
        if (0) {
          __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
          goto ldv_40443;
          __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
          goto ldv_40443;
          case_4:
          __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
          goto ldv_40443;
          __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
          goto ldv_40443;
          switch_default:
          {
          __bad_percpu_size();
          }
        } else {
        }
      }
      ldv_40443:
      {
      tmp___2 = atomic_read((atomic_t const *)(& kgdb_active));
      }
      if (pfo_ret__ != tmp___2) {
        {
        msleep(1U);
        }
      } else {
      }
    } else {
    }
    ldv_40450:
    {
    tmp___3 = i915_read32___6(dev_priv, 70072U);
    }
    if ((tmp___3 & 7340032U) != 0U) {
      goto ldv_40449;
    } else {
      goto ldv_40440;
    }
    ldv_40440:
    {
    i915_write32___4(dev_priv, 8328U, 0U);
    readl((void const volatile *)dev_priv->regs + 8328U);
    tmp___4 = i915_read32___6(dev_priv, 70072U);
    i915_write32___4(dev_priv, 70072U, tmp___4 & 4286578687U);
    readl((void const volatile *)dev_priv->regs + 70072U);
    }
  } else {
  }
  {
  ironlake_teardown_rc6(dev);
  }
  return;
}
}
static int ironlake_setup_rc6(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned long )dev_priv->renderctx == (unsigned long )((struct drm_i915_gem_object *)0)) {
    {
    dev_priv->renderctx = intel_alloc_context_page(dev);
    }
  } else {
  }
  if ((unsigned long )dev_priv->renderctx == (unsigned long )((struct drm_i915_gem_object *)0)) {
    return (-12);
  } else {
  }
  if ((unsigned long )dev_priv->pwrctx == (unsigned long )((struct drm_i915_gem_object *)0)) {
    {
    dev_priv->pwrctx = intel_alloc_context_page(dev);
    }
  } else {
  }
  if ((unsigned long )dev_priv->pwrctx == (unsigned long )((struct drm_i915_gem_object *)0)) {
    {
    ironlake_teardown_rc6(dev);
    }
    return (-12);
  } else {
  }
  return (0);
}
}
void ironlake_enable_rc6(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  int ret ;
  u32 tmp ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if (i915_enable_rc6 == 0U) {
    return;
  } else {
  }
  {
  mutex_lock_nested(& dev->struct_mutex, 0U);
  ret = ironlake_setup_rc6(dev);
  }
  if (ret != 0) {
    {
    mutex_unlock(& dev->struct_mutex);
    }
    return;
  } else {
  }
  {
  ret = intel_ring_begin((struct intel_ring_buffer *)(& dev_priv->ring), 6);
  }
  if (ret != 0) {
    {
    ironlake_teardown_rc6(dev);
    mutex_unlock(& dev->struct_mutex);
    }
    return;
  } else {
  }
  {
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 92274689U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 201326592U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), (dev_priv->renderctx)->gtt_offset | 269U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 92274688U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 0U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 33554432U);
  intel_ring_advance((struct intel_ring_buffer *)(& dev_priv->ring));
  ret = intel_wait_ring_idle((struct intel_ring_buffer *)(& dev_priv->ring));
  }
  if (ret != 0) {
    {
    drm_err("ironlake_enable_rc6", "failed to enable ironlake power power savings\n");
    ironlake_teardown_rc6(dev);
    mutex_unlock(& dev->struct_mutex);
    }
    return;
  } else {
  }
  {
  i915_write32___4(dev_priv, 8328U, (dev_priv->pwrctx)->gtt_offset | 1U);
  tmp = i915_read32___6(dev_priv, 70072U);
  i915_write32___4(dev_priv, 70072U, tmp & 4286578687U);
  mutex_unlock(& dev->struct_mutex);
  }
  return;
}
}
void intel_init_clock_gating(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  (*(dev_priv->display.init_clock_gating))(dev);
  }
  if ((unsigned long )dev_priv->display.init_pch_clock_gating != (unsigned long )((void (*)(struct drm_device * ))0)) {
    {
    (*(dev_priv->display.init_pch_clock_gating))(dev);
    }
  } else {
  }
  return;
}
}
static void intel_init_display(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  char *tmp___2 ;
  struct cxsr_latency const *tmp___3 ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    dev_priv->display.dpms = & ironlake_crtc_dpms;
    dev_priv->display.crtc_mode_set = & ironlake_crtc_mode_set;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    dev_priv->display.dpms = & ironlake_crtc_dpms;
    dev_priv->display.crtc_mode_set = & ironlake_crtc_mode_set;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    dev_priv->display.dpms = & ironlake_crtc_dpms;
    dev_priv->display.crtc_mode_set = & ironlake_crtc_mode_set;
  } else {
    dev_priv->display.dpms = & i9xx_crtc_dpms;
    dev_priv->display.crtc_mode_set = & i9xx_crtc_mode_set;
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
      dev_priv->display.fbc_enabled = & ironlake_fbc_enabled;
      dev_priv->display.enable_fbc = & ironlake_enable_fbc;
      dev_priv->display.disable_fbc = & ironlake_disable_fbc;
    } else
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
      dev_priv->display.fbc_enabled = & ironlake_fbc_enabled;
      dev_priv->display.enable_fbc = & ironlake_enable_fbc;
      dev_priv->display.disable_fbc = & ironlake_disable_fbc;
    } else
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
      dev_priv->display.fbc_enabled = & ironlake_fbc_enabled;
      dev_priv->display.enable_fbc = & ironlake_enable_fbc;
      dev_priv->display.disable_fbc = & ironlake_disable_fbc;
    } else
    if (dev->pci_device == 10818) {
      dev_priv->display.fbc_enabled = & g4x_fbc_enabled;
      dev_priv->display.enable_fbc = & g4x_enable_fbc;
      dev_priv->display.disable_fbc = & g4x_disable_fbc;
    } else
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
      dev_priv->display.fbc_enabled = & i8xx_fbc_enabled;
      dev_priv->display.enable_fbc = & i8xx_enable_fbc;
      dev_priv->display.disable_fbc = & i8xx_disable_fbc;
    } else {
    }
  } else {
  }
  if (dev->pci_device == 10098) {
    dev_priv->display.get_display_clock_speed = & i945_get_display_clock_speed;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    if (dev->pci_device != 40977) {
      dev_priv->display.get_display_clock_speed = & i945_get_display_clock_speed;
    } else {
      goto _L;
    }
  } else
  _L:
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    dev_priv->display.get_display_clock_speed = & i915_get_display_clock_speed;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    dev_priv->display.get_display_clock_speed = & i9xx_misc_get_display_clock_speed;
  } else
  if (dev->pci_device == 9570) {
    dev_priv->display.get_display_clock_speed = & i9xx_misc_get_display_clock_speed;
  } else
  if (dev->pci_device == 40977) {
    dev_priv->display.get_display_clock_speed = & i9xx_misc_get_display_clock_speed;
  } else
  if (dev->pci_device == 9618) {
    dev_priv->display.get_display_clock_speed = & i915gm_get_display_clock_speed;
  } else
  if (dev->pci_device == 9586) {
    dev_priv->display.get_display_clock_speed = & i865_get_display_clock_speed;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    dev_priv->display.get_display_clock_speed = & i855_get_display_clock_speed;
  } else {
    dev_priv->display.get_display_clock_speed = & i830_get_display_clock_speed;
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    goto _L___0;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    goto _L___0;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    _L___0:
    if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 0U) {
      dev_priv->display.init_pch_clock_gating = & ibx_init_clock_gating;
    } else
    if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 1U) {
      dev_priv->display.init_pch_clock_gating = & cpt_init_clock_gating;
    } else {
    }
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
      {
      tmp = i915_read32___6(dev_priv, 70178U);
      }
      if ((tmp & 63U) != 0U) {
        dev_priv->display.update_wm = & ironlake_update_wm;
      } else {
        {
        drm_ut_debug_printk(4U, "drm", "intel_init_display", "Failed to get proper latency. Disable CxSR\n");
        dev_priv->display.update_wm = (void (*)(struct drm_device * ))0;
        }
      }
      dev_priv->display.fdi_link_train = & ironlake_fdi_link_train;
      dev_priv->display.init_clock_gating = & ironlake_init_clock_gating;
    } else
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
      {
      tmp___0 = i915_read32___6(dev_priv, 1334544U);
      }
      if ((tmp___0 & 63U) != 0U) {
        dev_priv->display.update_wm = & sandybridge_update_wm;
      } else {
        {
        drm_ut_debug_printk(4U, "drm", "intel_init_display", "Failed to read display plane latency. Disable CxSR\n");
        dev_priv->display.update_wm = (void (*)(struct drm_device * ))0;
        }
      }
      dev_priv->display.fdi_link_train = & gen6_fdi_link_train;
      dev_priv->display.init_clock_gating = & gen6_init_clock_gating;
    } else
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
      {
      dev_priv->display.fdi_link_train = & ivb_manual_fdi_link_train;
      tmp___1 = i915_read32___6(dev_priv, 1334544U);
      }
      if ((tmp___1 & 63U) != 0U) {
        dev_priv->display.update_wm = & sandybridge_update_wm;
      } else {
        {
        drm_ut_debug_printk(4U, "drm", "intel_init_display", "Failed to read display plane latency. Disable CxSR\n");
        dev_priv->display.update_wm = (void (*)(struct drm_device * ))0;
        }
      }
      dev_priv->display.init_clock_gating = & ivybridge_init_clock_gating;
    } else {
      dev_priv->display.update_wm = (void (*)(struct drm_device * ))0;
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    {
    tmp___3 = intel_get_cxsr_latency(dev->pci_device == 40961, (int )dev_priv->is_ddr3,
                                     (int )dev_priv->fsb_freq, (int )dev_priv->mem_freq);
    }
    if ((unsigned long )tmp___3 == (unsigned long )((struct cxsr_latency const *)0)) {
      if (dev_priv->is_ddr3 == 1U) {
        tmp___2 = (char *)"3";
      } else {
        tmp___2 = (char *)"2";
      }
      {
      printk("<6>[drm] failed to find known CxSR latency (found ddr%s fsb freq %d, mem freq %d), disabling CxSR\n",
             tmp___2, dev_priv->fsb_freq, dev_priv->mem_freq);
      pineview_disable_cxsr(dev);
      dev_priv->display.update_wm = (void (*)(struct drm_device * ))0;
      }
    } else {
      dev_priv->display.update_wm = & pineview_update_wm;
    }
    dev_priv->display.init_clock_gating = & gen3_init_clock_gating;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    dev_priv->display.update_wm = & g4x_update_wm;
    dev_priv->display.init_clock_gating = & g4x_init_clock_gating;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 4U) {
    dev_priv->display.update_wm = & i965_update_wm;
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
      dev_priv->display.init_clock_gating = & crestline_init_clock_gating;
    } else
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
      dev_priv->display.init_clock_gating = & broadwater_init_clock_gating;
    } else {
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 3U) {
    dev_priv->display.update_wm = & i9xx_update_wm;
    dev_priv->display.get_fifo_size = & i9xx_get_fifo_size;
    dev_priv->display.init_clock_gating = & gen3_init_clock_gating;
  } else
  if (dev->pci_device == 9586) {
    dev_priv->display.update_wm = & i830_update_wm;
    dev_priv->display.init_clock_gating = & i85x_init_clock_gating;
    dev_priv->display.get_fifo_size = & i830_get_fifo_size;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    dev_priv->display.update_wm = & i9xx_update_wm;
    dev_priv->display.get_fifo_size = & i85x_get_fifo_size;
    dev_priv->display.init_clock_gating = & i85x_init_clock_gating;
  } else {
    dev_priv->display.update_wm = & i830_update_wm;
    dev_priv->display.init_clock_gating = & i830_init_clock_gating;
    if (dev->pci_device == 9570) {
      dev_priv->display.get_fifo_size = & i845_get_fifo_size;
    } else {
      dev_priv->display.get_fifo_size = & i830_get_fifo_size;
    }
  }
  dev_priv->display.queue_flip = & intel_default_queue_flip;
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 2) {
    goto case_2;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 3) {
    goto case_3;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 4) {
    goto case_4;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 5) {
    goto case_5;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 6) {
    goto case_6;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 7) {
    goto case_7;
  } else
  if (0) {
    case_2:
    dev_priv->display.queue_flip = & intel_gen2_queue_flip;
    goto ldv_40472;
    case_3:
    dev_priv->display.queue_flip = & intel_gen3_queue_flip;
    goto ldv_40472;
    case_4: ;
    case_5:
    dev_priv->display.queue_flip = & intel_gen4_queue_flip;
    goto ldv_40472;
    case_6:
    dev_priv->display.queue_flip = & intel_gen6_queue_flip;
    goto ldv_40472;
    case_7:
    dev_priv->display.queue_flip = & intel_gen7_queue_flip;
    goto ldv_40472;
  } else {
  }
  ldv_40472: ;
  return;
}
}
static void quirk_pipea_force(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  dev_priv->quirks = dev_priv->quirks | 1UL;
  drm_ut_debug_printk(2U, "drm", "quirk_pipea_force", "applying pipe a force quirk\n");
  }
  return;
}
}
static void quirk_ssc_force_disable(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  dev_priv->quirks = dev_priv->quirks | 2UL;
  return;
}
}
struct intel_quirk intel_quirks[9U] =
  { {10818, 4156, 12523, & quirk_pipea_force},
        {10158, 4156, 13850, & quirk_pipea_force},
        {13687, 4116, 1285, & quirk_pipea_force},
        {9618, 4473, 1, & quirk_pipea_force},
        {13687, 4116, 1299, & quirk_pipea_force},
        {10114, 6058, 8218, & quirk_pipea_force},
        {13698, -1, -1, & quirk_pipea_force},
        {9570, -1, -1, & quirk_pipea_force},
        {70, 6058, 14624, & quirk_ssc_force_disable}};
static void intel_init_quirks(struct drm_device *dev )
{ struct pci_dev *d ;
  int i ;
  struct intel_quirk *q ;
  {
  d = dev->pdev;
  i = 0;
  goto ldv_40503;
  ldv_40502:
  q = (struct intel_quirk *)(& intel_quirks) + (unsigned long )i;
  if ((int )d->device == q->device) {
    if ((int )d->subsystem_vendor == q->subsystem_vendor) {
      goto _L;
    } else
    if (q->subsystem_vendor == -1) {
      _L:
      if ((int )d->subsystem_device == q->subsystem_device) {
        {
        (*(q->hook))(dev);
        }
      } else
      if (q->subsystem_device == -1) {
        {
        (*(q->hook))(dev);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  i = i + 1;
  ldv_40503: ;
  if ((unsigned int )i <= 8U) {
    goto ldv_40502;
  } else {
    goto ldv_40504;
  }
  ldv_40504: ;
  return;
}
}
static void i915_disable_vga(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u8 sr1 ;
  u32 vga_reg ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    vga_reg = 266240U;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    vga_reg = 266240U;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    vga_reg = 266240U;
  } else {
    vga_reg = 463872U;
  }
  {
  vga_get_uninterruptible(dev->pdev, 1U);
  outb((unsigned char)1, 964);
  sr1 = inb(965);
  outb((unsigned char )((int )((unsigned int )sr1 | 32U)), 965);
  vga_put(dev->pdev, 1U);
  __const_udelay(1288500UL);
  i915_write32___4(dev_priv, vga_reg, 2147483648U);
  readl((void const volatile *)dev_priv->regs + (unsigned long )vga_reg);
  }
  return;
}
}
void intel_modeset_init(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  int i ;
  char *tmp ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___0 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  drm_mode_config_init(dev);
  dev->mode_config.min_width = 0;
  dev->mode_config.min_height = 0;
  dev->mode_config.funcs = (struct drm_mode_config_funcs *)(& intel_mode_funcs);
  intel_init_quirks(dev);
  intel_init_display(dev);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 2U) {
    dev->mode_config.max_width = 2048;
    dev->mode_config.max_height = 2048;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 3U) {
    dev->mode_config.max_width = 4096;
    dev->mode_config.max_height = 4096;
  } else {
    dev->mode_config.max_width = 8192;
    dev->mode_config.max_height = 8192;
  }
  dev->mode_config.fb_base = (resource_size_t )(dev->agp)->base;
  if (dev_priv->num_pipe > 1) {
    tmp = (char *)"s";
  } else {
    tmp = (char *)"";
  }
  {
  drm_ut_debug_printk(4U, "drm", "intel_modeset_init", "%d display pipe%s available.\n",
                      dev_priv->num_pipe, tmp);
  i = 0;
  }
  goto ldv_40518;
  ldv_40517:
  {
  intel_crtc_init(dev, i);
  i = i + 1;
  }
  ldv_40518: ;
  if (dev_priv->num_pipe > i) {
    goto ldv_40517;
  } else {
    goto ldv_40519;
  }
  ldv_40519:
  {
  i915_disable_vga(dev);
  intel_setup_outputs(dev);
  intel_init_clock_gating(dev);
  }
  if (dev->pci_device == 70) {
    {
    ironlake_enable_drps(dev);
    intel_init_emon(dev);
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    gen6_enable_rps(dev_priv);
    }
  } else {
  }
  {
  __init_work(& dev_priv->idle_work, 0);
  __constr_expr_0.counter = 2097664L;
  dev_priv->idle_work.data = __constr_expr_0;
  lockdep_init_map(& dev_priv->idle_work.lockdep_map, "(&dev_priv->idle_work)", & __key,
                   0);
  INIT_LIST_HEAD(& dev_priv->idle_work.entry);
  dev_priv->idle_work.func = & intel_idle_update;
  setup_timer_key(& dev_priv->idle_timer, "&dev_priv->idle_timer", & __key___0, & intel_gpu_idle_timer,
                  (unsigned long )dev);
  }
  return;
}
}
void intel_modeset_gem_init(struct drm_device *dev )
{
  {
  if (dev->pci_device == 70) {
    {
    ironlake_enable_rc6(dev);
    }
  } else {
  }
  {
  intel_setup_overlay(dev);
  }
  return;
}
}
void intel_modeset_cleanup(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct drm_crtc *crtc ;
  struct intel_crtc *intel_crtc ;
  struct list_head const *__mptr ;
  struct drm_crtc const *__mptr___0 ;
  struct list_head const *__mptr___1 ;
  struct list_head const *__mptr___2 ;
  struct drm_crtc const *__mptr___3 ;
  struct list_head const *__mptr___4 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  drm_kms_helper_poll_fini(dev);
  mutex_lock_nested(& dev->struct_mutex, 0U);
  intel_unregister_dsm_handler();
  __mptr = (struct list_head const *)dev->mode_config.crtc_list.next;
  crtc = (struct drm_crtc *)__mptr + 0x0ffffffffffffff8UL;
  }
  goto ldv_40540;
  ldv_40539: ;
  if ((unsigned long )crtc->fb == (unsigned long )((struct drm_framebuffer *)0)) {
    goto ldv_40536;
  } else {
  }
  {
  __mptr___0 = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr___0;
  intel_increase_pllclock(crtc);
  }
  ldv_40536:
  __mptr___1 = (struct list_head const *)crtc->head.next;
  crtc = (struct drm_crtc *)__mptr___1 + 0x0ffffffffffffff8UL;
  ldv_40540: ;
  if ((unsigned long )(& crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
    goto ldv_40539;
  } else {
    goto ldv_40541;
  }
  ldv_40541: ;
  if ((unsigned long )dev_priv->display.disable_fbc != (unsigned long )((void (*)(struct drm_device * ))0)) {
    {
    (*(dev_priv->display.disable_fbc))(dev);
    }
  } else {
  }
  if (dev->pci_device == 70) {
    {
    ironlake_disable_drps(dev);
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    gen6_disable_rps(dev);
    }
  } else {
  }
  if (dev->pci_device == 70) {
    {
    ironlake_disable_rc6(dev);
    }
  } else {
  }
  {
  mutex_unlock(& dev->struct_mutex);
  drm_irq_uninstall(dev);
  cancel_work_sync(& dev_priv->hotplug_work);
  __mptr___2 = (struct list_head const *)dev->mode_config.crtc_list.next;
  crtc = (struct drm_crtc *)__mptr___2 + 0x0ffffffffffffff8UL;
  }
  goto ldv_40549;
  ldv_40548:
  {
  __mptr___3 = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr___3;
  del_timer_sync(& intel_crtc->idle_timer);
  __mptr___4 = (struct list_head const *)crtc->head.next;
  crtc = (struct drm_crtc *)__mptr___4 + 0x0ffffffffffffff8UL;
  }
  ldv_40549: ;
  if ((unsigned long )(& crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
    goto ldv_40548;
  } else {
    goto ldv_40550;
  }
  ldv_40550:
  {
  del_timer_sync(& dev_priv->idle_timer);
  cancel_work_sync(& dev_priv->idle_work);
  drm_mode_config_cleanup(dev);
  }
  return;
}
}
struct drm_encoder *intel_best_encoder(struct drm_connector *connector )
{ struct intel_encoder *tmp ;
  {
  {
  tmp = intel_attached_encoder(connector);
  }
  return (& tmp->base);
}
}
void intel_connector_attach_encoder(struct intel_connector *connector , struct intel_encoder *encoder )
{
  {
  {
  connector->encoder = encoder;
  drm_mode_connector_attach_encoder(& connector->base, & encoder->base);
  }
  return;
}
}
int intel_modeset_vga_set_state(struct drm_device *dev , bool state )
{ struct drm_i915_private *dev_priv ;
  u16 gmch_ctrl ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  pci_read_config_word(dev_priv->bridge_dev, 82, & gmch_ctrl);
  }
  if ((int )state) {
    gmch_ctrl = (u16 )((unsigned int )gmch_ctrl & 65533U);
  } else {
    gmch_ctrl = (u16 )((unsigned int )gmch_ctrl | 2U);
  }
  {
  pci_write_config_word(dev_priv->bridge_dev, 82, (u16 )((int )gmch_ctrl));
  }
  return (0);
}
}
struct intel_display_error_state *intel_display_capture_error_state(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  struct intel_display_error_state *error ;
  int i ;
  void *tmp ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = kmalloc(152UL, 32U);
  error = (struct intel_display_error_state *)tmp;
  }
  if ((unsigned long )error == (unsigned long )((struct intel_display_error_state *)0)) {
    return ((struct intel_display_error_state *)0);
  } else {
  }
  i = 0;
  goto ldv_40596;
  ldv_40595:
  {
  error->cursor[i].control = i915_read32___6(dev_priv, (u32 )((i + 7170) * 64));
  error->cursor[i].position = i915_read32___6(dev_priv, (u32 )(i * 64 + 458888));
  error->cursor[i].base = i915_read32___6(dev_priv, (u32 )(i * 64 + 458884));
  error->plane[i].control = i915_read32___6(dev_priv, (u32 )(i * 4096 + 459136));
  error->plane[i].stride = i915_read32___6(dev_priv, (u32 )(i * 4096 + 459144));
  error->plane[i].size = i915_read32___6(dev_priv, (u32 )(i * 4096 + 459152));
  error->plane[i].pos = i915_read32___6(dev_priv, (u32 )(i * 4096 + 459148));
  error->plane[i].addr = i915_read32___6(dev_priv, (u32 )(i * 4096 + 459140));
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    {
    error->plane[i].surface = i915_read32___6(dev_priv, (u32 )(i * 4096 + 459164));
    error->plane[i].tile_offset = i915_read32___6(dev_priv, (u32 )(i * 4096 + 459172));
    }
  } else {
  }
  {
  error->pipe[i].conf = i915_read32___6(dev_priv, (u32 )(i * 4096 + 458760));
  error->pipe[i].source = i915_read32___6(dev_priv, (u32 )(i * 4096 + 393244));
  error->pipe[i].htotal = i915_read32___6(dev_priv, (u32 )((i + 96) * 4096));
  error->pipe[i].hblank = i915_read32___6(dev_priv, (u32 )(i * 4096 + 393220));
  error->pipe[i].hsync = i915_read32___6(dev_priv, (u32 )(i * 4096 + 393224));
  error->pipe[i].vtotal = i915_read32___6(dev_priv, (u32 )(i * 4096 + 393228));
  error->pipe[i].vblank = i915_read32___6(dev_priv, (u32 )(i * 4096 + 393232));
  error->pipe[i].vsync = i915_read32___6(dev_priv, (u32 )(i * 4096 + 393236));
  i = i + 1;
  }
  ldv_40596: ;
  if (i <= 1) {
    goto ldv_40595;
  } else {
    goto ldv_40597;
  }
  ldv_40597: ;
  return (error);
}
}
void intel_display_print_error_state(struct seq_file *m , struct drm_device *dev ,
                                     struct intel_display_error_state *error )
{ int i ;
  {
  i = 0;
  goto ldv_40605;
  ldv_40604:
  {
  seq_printf(m, "Pipe [%d]:\n", i);
  seq_printf(m, "  CONF: %08x\n", error->pipe[i].conf);
  seq_printf(m, "  SRC: %08x\n", error->pipe[i].source);
  seq_printf(m, "  HTOTAL: %08x\n", error->pipe[i].htotal);
  seq_printf(m, "  HBLANK: %08x\n", error->pipe[i].hblank);
  seq_printf(m, "  HSYNC: %08x\n", error->pipe[i].hsync);
  seq_printf(m, "  VTOTAL: %08x\n", error->pipe[i].vtotal);
  seq_printf(m, "  VBLANK: %08x\n", error->pipe[i].vblank);
  seq_printf(m, "  VSYNC: %08x\n", error->pipe[i].vsync);
  seq_printf(m, "Plane [%d]:\n", i);
  seq_printf(m, "  CNTR: %08x\n", error->plane[i].control);
  seq_printf(m, "  STRIDE: %08x\n", error->plane[i].stride);
  seq_printf(m, "  SIZE: %08x\n", error->plane[i].size);
  seq_printf(m, "  POS: %08x\n", error->plane[i].pos);
  seq_printf(m, "  ADDR: %08x\n", error->plane[i].addr);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    {
    seq_printf(m, "  SURF: %08x\n", error->plane[i].surface);
    seq_printf(m, "  TILEOFF: %08x\n", error->plane[i].tile_offset);
    }
  } else {
  }
  {
  seq_printf(m, "Cursor [%d]:\n", i);
  seq_printf(m, "  CNTR: %08x\n", error->cursor[i].control);
  seq_printf(m, "  POS: %08x\n", error->cursor[i].position);
  seq_printf(m, "  BASE: %08x\n", error->cursor[i].base);
  i = i + 1;
  }
  ldv_40605: ;
  if (i <= 1) {
    goto ldv_40604;
  } else {
    goto ldv_40606;
  }
  ldv_40606: ;
  return;
}
}
extern void drm_connector_init(struct drm_device * , struct drm_connector * , struct drm_connector_funcs const * ,
                               int ) ;
extern void drm_connector_cleanup(struct drm_connector * ) ;
extern void drm_encoder_init(struct drm_device * , struct drm_encoder * , struct drm_encoder_funcs const * ,
                             int ) ;
extern struct edid *drm_get_edid(struct drm_connector * , struct i2c_adapter * ) ;
extern int drm_sysfs_connector_add(struct drm_connector * ) ;
extern void drm_sysfs_connector_remove(struct drm_connector * ) ;
extern int drm_helper_probe_single_connector_modes(struct drm_connector * , uint32_t ,
                                                   uint32_t ) ;
extern void drm_helper_connector_dpms(struct drm_connector * , int ) ;
__inline static void drm_encoder_helper_add(struct drm_encoder *encoder , struct drm_encoder_helper_funcs const *funcs )
{
  {
  encoder->helper_private = (void *)funcs;
  return;
}
}
__inline static void drm_connector_helper_add(struct drm_connector *connector , struct drm_connector_helper_funcs const *funcs )
{
  {
  connector->helper_private = (void *)funcs;
  return;
}
}
__inline static void trace_i915_reg_rw___7(bool write , u32 reg , u64 val , int len )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_reg_rw.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_reg_rw.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )411);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_36469:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , bool , u32 , u64 , int ))it_func))(__data, (bool )((int )write),
                                                                   reg, val, len);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_36469;
      } else {
        goto ldv_36470;
      }
      ldv_36470: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
__inline static u8 i915_read8___1(struct drm_i915_private *dev_priv , u32 reg )
{ u8 val ;
  {
  val = (u8 )0U;
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        gen6_gt_force_wake_get(dev_priv);
        val = readb((void const volatile *)dev_priv->regs + (unsigned long )reg);
        gen6_gt_force_wake_put(dev_priv);
        }
      } else {
        {
        val = readb((void const volatile *)dev_priv->regs + (unsigned long )reg);
        }
      }
    } else {
      {
      val = readb((void const volatile *)dev_priv->regs + (unsigned long )reg);
      }
    }
  } else {
    {
    val = readb((void const volatile *)dev_priv->regs + (unsigned long )reg);
    }
  }
  {
  trace_i915_reg_rw___7((bool )0, reg, (u64 )val, 1);
  }
  return (val);
}
}
__inline static u32 i915_read32___7(struct drm_i915_private *dev_priv , u32 reg )
{ u32 val ;
  {
  val = 0U;
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        gen6_gt_force_wake_get(dev_priv);
        val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
        gen6_gt_force_wake_put(dev_priv);
        }
      } else {
        {
        val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
        }
      }
    } else {
      {
      val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
      }
    }
  } else {
    {
    val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
    }
  }
  {
  trace_i915_reg_rw___7((bool )0, reg, (u64 )val, 4);
  }
  return (val);
}
}
__inline static void i915_write32___5(struct drm_i915_private *dev_priv , u32 reg ,
                                      u32 val )
{
  {
  {
  trace_i915_reg_rw___7((bool )1, reg, (u64 )val, 4);
  }
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        __gen6_gt_wait_for_fifo(dev_priv);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  writel(val, (void volatile *)dev_priv->regs + (unsigned long )reg);
  }
  return;
}
}
int intel_ddc_get_modes(struct drm_connector *connector , struct i2c_adapter *adapter ) ;
bool intel_ddc_probe(struct intel_encoder *intel_encoder , int ddc_bus ) ;
static struct intel_crt *intel_attached_crt(struct drm_connector *connector )
{ struct intel_encoder const *__mptr ;
  struct intel_encoder *tmp ;
  {
  {
  tmp = intel_attached_encoder(connector);
  __mptr = (struct intel_encoder const *)tmp;
  }
  return ((struct intel_crt *)__mptr);
}
}
static void intel_crt_dpms(struct drm_encoder *encoder , int mode )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  u32 temp ;
  u32 reg ;
  {
  dev = encoder->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    reg = 921856U;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    reg = 921856U;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    reg = 921856U;
  } else {
    reg = 397568U;
  }
  {
  temp = i915_read32___7(dev_priv, reg);
  temp = temp & 4294964223U;
  temp = temp & 2147483647U;
  }
  if (mode == 0) {
    goto case_0;
  } else
  if (mode == 1) {
    goto case_1;
  } else
  if (mode == 2) {
    goto case_2;
  } else
  if (mode == 3) {
    goto case_3;
  } else
  if (0) {
    case_0:
    temp = temp | 2147483648U;
    goto ldv_37660;
    case_1:
    temp = temp | 2147484672U;
    goto ldv_37660;
    case_2:
    temp = temp | 2147485696U;
    goto ldv_37660;
    case_3:
    temp = temp | 3072U;
    goto ldv_37660;
  } else {
  }
  ldv_37660:
  {
  i915_write32___5(dev_priv, reg, temp);
  }
  return;
}
}
static int intel_crt_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode )
{ struct drm_device *dev ;
  int max_clock ;
  {
  dev = connector->dev;
  max_clock = 0;
  if ((mode->flags & 32U) != 0U) {
    return (8);
  } else {
  }
  if (mode->clock <= 24999) {
    return (16);
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 2U) {
    max_clock = 350000;
  } else {
    max_clock = 400000;
  }
  if (mode->clock > max_clock) {
    return (15);
  } else {
  }
  return (0);
}
}
static bool intel_crt_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                 struct drm_display_mode *adjusted_mode )
{
  {
  return ((bool )1);
}
}
static void intel_crt_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                               struct drm_display_mode *adjusted_mode )
{ struct drm_device *dev ;
  struct drm_crtc *crtc ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  struct drm_i915_private *dev_priv ;
  int dpll_md_reg ;
  u32 adpa ;
  u32 dpll_md ;
  u32 adpa_reg ;
  {
  dev = encoder->dev;
  crtc = encoder->crtc;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  dpll_md_reg = (int )(((unsigned int )intel_crtc->pipe + 6151U) * 4U);
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    adpa_reg = 921856U;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    adpa_reg = 921856U;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    adpa_reg = 921856U;
  } else {
    adpa_reg = 397568U;
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 5U) {
      if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 6U) {
        if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) == 0U) {
          {
          dpll_md = i915_read32___7(dev_priv, (u32 )dpll_md_reg);
          i915_write32___5(dev_priv, (u32 )dpll_md_reg, dpll_md & 4294951167U);
          }
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  adpa = 15990784U;
  if ((int )adjusted_mode->flags & 1) {
    adpa = adpa | 8U;
  } else {
  }
  if ((adjusted_mode->flags & 4U) != 0U) {
    adpa = adpa | 16U;
  } else {
  }
  if ((unsigned int )intel_crtc->pipe == 0U) {
    if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 1U) {
      adpa = adpa;
    } else {
      adpa = adpa;
    }
  } else
  if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 1U) {
    adpa = adpa | 536870912U;
  } else {
    adpa = adpa | 1073741824U;
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 5U) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 6U) {
      if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) == 0U) {
        {
        i915_write32___5(dev_priv, (unsigned int )intel_crtc->pipe * 4096U + 393248U,
                         0U);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  i915_write32___5(dev_priv, adpa_reg, adpa);
  }
  return;
}
}
static bool intel_ironlake_crt_detect_hotplug(struct drm_connector *connector )
{ struct drm_device *dev ;
  struct intel_crt *crt ;
  struct intel_crt *tmp ;
  struct drm_i915_private *dev_priv ;
  u32 adpa ;
  bool ret ;
  bool turn_off_dac ;
  int tmp___0 ;
  u32 save_adpa ;
  unsigned long timeout__ ;
  unsigned long tmp___1 ;
  int ret__ ;
  struct thread_info *tmp___2 ;
  int pfo_ret__ ;
  int tmp___3 ;
  u32 tmp___4 ;
  {
  {
  dev = connector->dev;
  tmp = intel_attached_crt(connector);
  crt = tmp;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  }
  if ((int )crt->force_hotplug_required) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
      tmp___0 = 1;
    } else
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
      tmp___0 = 1;
    } else
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    {
    turn_off_dac = (bool )tmp___0;
    crt->force_hotplug_required = (bool )0;
    adpa = i915_read32___7(dev_priv, 921856U);
    save_adpa = adpa;
    drm_ut_debug_printk(4U, "drm", "intel_ironlake_crt_detect_hotplug", "trigger hotplug detect cycle: adpa=0x%x\n",
                        adpa);
    adpa = adpa | 65536U;
    }
    if ((int )turn_off_dac) {
      adpa = adpa & 2147483647U;
    } else {
    }
    {
    i915_write32___5(dev_priv, 921856U, adpa);
    tmp___1 = msecs_to_jiffies((unsigned int const )1000U);
    timeout__ = tmp___1 + (unsigned long )jiffies;
    ret__ = 0;
    }
    goto ldv_37719;
    ldv_37718: ;
    if ((long )timeout__ - (long )jiffies < 0L) {
      ret__ = -110;
      goto ldv_37709;
    } else {
    }
    {
    tmp___2 = current_thread_info();
    }
    if ((tmp___2->preempt_count & -268435457) == 0) {
      if (1) {
        goto case_4;
      } else {
        goto switch_default;
        if (0) {
          __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
          goto ldv_37712;
          __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
          goto ldv_37712;
          case_4:
          __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
          goto ldv_37712;
          __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
          goto ldv_37712;
          switch_default:
          {
          __bad_percpu_size();
          }
        } else {
        }
      }
      ldv_37712:
      {
      tmp___3 = atomic_read((atomic_t const *)(& kgdb_active));
      }
      if (pfo_ret__ != tmp___3) {
        {
        msleep(1U);
        }
      } else {
      }
    } else {
    }
    ldv_37719:
    {
    tmp___4 = i915_read32___7(dev_priv, 921856U);
    }
    if ((tmp___4 & 65536U) != 0U) {
      goto ldv_37718;
    } else {
      goto ldv_37709;
    }
    ldv_37709: ;
    if (ret__ != 0) {
      {
      drm_ut_debug_printk(4U, "drm", "intel_ironlake_crt_detect_hotplug", "timed out waiting for FORCE_TRIGGER");
      }
    } else {
    }
    if ((int )turn_off_dac) {
      {
      i915_write32___5(dev_priv, 921856U, save_adpa);
      readl((void const volatile *)dev_priv->regs + 921856U);
      }
    } else {
    }
  } else {
  }
  {
  adpa = i915_read32___7(dev_priv, 921856U);
  }
  if ((adpa & 50331648U) != 0U) {
    ret = (bool )1;
  } else {
    ret = (bool )0;
  }
  {
  drm_ut_debug_printk(4U, "drm", "intel_ironlake_crt_detect_hotplug", "ironlake hotplug adpa=0x%x, result %d\n",
                      adpa, (int )ret);
  }
  return (ret);
}
}
static bool intel_crt_detect_hotplug(struct drm_connector *connector )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  u32 hotplug_en ;
  u32 orig ;
  u32 stat ;
  bool ret ;
  int i ;
  int tries ;
  bool tmp ;
  unsigned long timeout__ ;
  unsigned long tmp___0 ;
  int ret__ ;
  struct thread_info *tmp___1 ;
  int pfo_ret__ ;
  int tmp___2 ;
  u32 tmp___3 ;
  {
  dev = connector->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  ret = (bool )0;
  tries = 0;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    tmp = intel_ironlake_crt_detect_hotplug(connector);
    }
    return (tmp);
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    tmp = intel_ironlake_crt_detect_hotplug(connector);
    }
    return (tmp);
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    tmp = intel_ironlake_crt_detect_hotplug(connector);
    }
    return (tmp);
  } else {
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    if (dev->pci_device != 10818) {
      tries = 2;
    } else {
      tries = 1;
    }
  } else {
    tries = 1;
  }
  {
  orig = i915_read32___7(dev_priv, 397584U);
  hotplug_en = orig;
  hotplug_en = hotplug_en | 8U;
  i = 0;
  }
  goto ldv_37754;
  ldv_37753:
  {
  i915_write32___5(dev_priv, 397584U, hotplug_en);
  tmp___0 = msecs_to_jiffies((unsigned int const )1000U);
  timeout__ = tmp___0 + (unsigned long )jiffies;
  ret__ = 0;
  }
  goto ldv_37750;
  ldv_37749: ;
  if ((long )timeout__ - (long )jiffies < 0L) {
    ret__ = -110;
    goto ldv_37740;
  } else {
  }
  {
  tmp___1 = current_thread_info();
  }
  if ((tmp___1->preempt_count & -268435457) == 0) {
    if (1) {
      goto case_4;
    } else {
      goto switch_default;
      if (0) {
        __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
        goto ldv_37743;
        __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_37743;
        case_4:
        __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_37743;
        __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_37743;
        switch_default:
        {
        __bad_percpu_size();
        }
      } else {
      }
    }
    ldv_37743:
    {
    tmp___2 = atomic_read((atomic_t const *)(& kgdb_active));
    }
    if (pfo_ret__ != tmp___2) {
      {
      msleep(1U);
      }
    } else {
    }
  } else {
  }
  ldv_37750:
  {
  tmp___3 = i915_read32___7(dev_priv, 397584U);
  }
  if ((tmp___3 & 8U) != 0U) {
    goto ldv_37749;
  } else {
    goto ldv_37740;
  }
  ldv_37740: ;
  if (ret__ != 0) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_crt_detect_hotplug", "timed out waiting for FORCE_DETECT to go off");
    }
  } else {
  }
  i = i + 1;
  ldv_37754: ;
  if (i < tries) {
    goto ldv_37753;
  } else {
    goto ldv_37755;
  }
  ldv_37755:
  {
  stat = i915_read32___7(dev_priv, 397588U);
  }
  if ((stat & 768U) != 0U) {
    ret = (bool )1;
  } else {
  }
  {
  i915_write32___5(dev_priv, 397588U, 2048U);
  i915_write32___5(dev_priv, 397584U, orig);
  }
  return (ret);
}
}
static bool intel_crt_detect_ddc(struct drm_connector *connector )
{ struct intel_crt *crt ;
  struct intel_crt *tmp ;
  struct drm_i915_private *dev_priv ;
  struct edid *edid ;
  bool is_digital ;
  bool tmp___0 ;
  {
  {
  tmp = intel_attached_crt(connector);
  crt = tmp;
  dev_priv = (struct drm_i915_private *)(crt->base.base.dev)->dev_private;
  }
  if (crt->base.type != 1) {
    return ((bool )0);
  } else {
  }
  {
  tmp___0 = intel_ddc_probe(& crt->base, dev_priv->crt_ddc_pin);
  }
  if ((int )tmp___0) {
    {
    is_digital = (bool )0;
    edid = drm_get_edid(connector, & (dev_priv->gmbus + (unsigned long )dev_priv->crt_ddc_pin)->adapter);
    }
    if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
      {
      is_digital = (bool )(((int )edid->input & 128) != 0);
      connector->display_info.raw_edid = (char *)0;
      kfree((void const *)edid);
      }
    } else {
    }
    if (! is_digital) {
      {
      drm_ut_debug_printk(4U, "drm", "intel_crt_detect_ddc", "CRT detected via DDC:0x50 [EDID]\n");
      }
      return ((bool )1);
    } else {
      {
      drm_ut_debug_printk(4U, "drm", "intel_crt_detect_ddc", "CRT not detected via DDC:0x50 [EDID reports a digital panel]\n");
      }
    }
  } else {
  }
  return ((bool )0);
}
}
static enum drm_connector_status intel_crt_load_detect(struct intel_crt *crt )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  uint32_t pipe ;
  struct drm_crtc const *__mptr ;
  uint32_t save_bclrpat ;
  uint32_t save_vtotal ;
  uint32_t vtotal ;
  uint32_t vactive ;
  uint32_t vsample ;
  uint32_t vblank ;
  uint32_t vblank_start ;
  uint32_t vblank_end ;
  uint32_t dsl ;
  uint32_t bclrpat_reg ;
  uint32_t vtotal_reg ;
  uint32_t vblank_reg ;
  uint32_t vsync_reg ;
  uint32_t pipeconf_reg ;
  uint32_t pipe_dsl_reg ;
  uint8_t st00 ;
  enum drm_connector_status status ;
  uint32_t pipeconf ;
  u32 tmp ;
  bool restore_vblank ;
  int count ;
  int detect ;
  uint32_t vsync ;
  u32 tmp___0 ;
  uint32_t vsync_start ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  {
  {
  dev = crt->base.base.dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crt->base.base.crtc;
  pipe = (uint32_t )((struct intel_crtc *)__mptr)->pipe;
  drm_ut_debug_printk(4U, "drm", "intel_crt_load_detect", "starting load-detect on CRT\n");
  bclrpat_reg = pipe * 4096U + 393248U;
  vtotal_reg = pipe * 4096U + 393228U;
  vblank_reg = pipe * 4096U + 393232U;
  vsync_reg = pipe * 4096U + 393236U;
  pipeconf_reg = pipe * 4096U + 458760U;
  pipe_dsl_reg = (pipe + 112U) * 4096U;
  save_bclrpat = i915_read32___7(dev_priv, bclrpat_reg);
  save_vtotal = i915_read32___7(dev_priv, vtotal_reg);
  vblank = i915_read32___7(dev_priv, vblank_reg);
  vtotal = ((save_vtotal >> 16) & 4095U) + 1U;
  vactive = (save_vtotal & 2047U) + 1U;
  vblank_start = (vblank & 4095U) + 1U;
  vblank_end = ((vblank >> 16) & 4095U) + 1U;
  i915_write32___5(dev_priv, bclrpat_reg, 5242960U);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 2U) {
    {
    tmp = i915_read32___7(dev_priv, pipeconf_reg);
    pipeconf = tmp;
    i915_write32___5(dev_priv, pipeconf_reg, pipeconf | 33554432U);
    readl((void const volatile *)dev_priv->regs + (unsigned long )pipeconf_reg);
    intel_wait_for_vblank(dev, (int )pipe);
    st00 = i915_read8___1(dev_priv, 962U);
    }
    if (((int )st00 & 16) != 0) {
      status = (enum drm_connector_status )1;
    } else {
      status = (enum drm_connector_status )2;
    }
    {
    i915_write32___5(dev_priv, pipeconf_reg, pipeconf);
    }
  } else {
    restore_vblank = (bool )0;
    if (vblank_start <= vactive) {
      if (vblank_end >= vtotal) {
        {
        tmp___0 = i915_read32___7(dev_priv, vsync_reg);
        vsync = tmp___0;
        vsync_start = (vsync & 65535U) + 1U;
        vblank_start = vsync_start;
        i915_write32___5(dev_priv, vblank_reg, (vblank_start - 1U) | ((vblank_end - 1U) << 16));
        restore_vblank = (bool )1;
        }
      } else {
      }
    } else {
    }
    if (vblank_start - vactive >= vtotal - vblank_end) {
      vsample = (vblank_start + vactive) >> 1;
    } else {
      vsample = (vtotal + vblank_end) >> 1;
    }
    goto ldv_37797;
    ldv_37796: ;
    ldv_37797:
    {
    tmp___1 = i915_read32___7(dev_priv, pipe_dsl_reg);
    }
    if (tmp___1 >= vactive) {
      goto ldv_37796;
    } else {
      goto ldv_37798;
    }
    ldv_37798: ;
    goto ldv_37800;
    ldv_37799: ;
    ldv_37800:
    {
    dsl = i915_read32___7(dev_priv, pipe_dsl_reg);
    }
    if (dsl <= vsample) {
      goto ldv_37799;
    } else {
      goto ldv_37801;
    }
    ldv_37801:
    detect = 0;
    count = 0;
    ldv_37802:
    {
    count = count + 1;
    st00 = i915_read8___1(dev_priv, 962U);
    }
    if (((int )st00 & 16) != 0) {
      detect = detect + 1;
    } else {
    }
    {
    tmp___2 = i915_read32___7(dev_priv, pipe_dsl_reg);
    }
    if (tmp___2 == dsl) {
      goto ldv_37802;
    } else {
      goto ldv_37803;
    }
    ldv_37803: ;
    if ((int )restore_vblank) {
      {
      i915_write32___5(dev_priv, vblank_reg, vblank);
      }
    } else {
    }
    if (detect * 4 > count * 3) {
      status = (enum drm_connector_status )1;
    } else {
      status = (enum drm_connector_status )2;
    }
  }
  {
  i915_write32___5(dev_priv, bclrpat_reg, save_bclrpat);
  }
  return (status);
}
}
static enum drm_connector_status intel_crt_detect(struct drm_connector *connector ,
                                                  bool force )
{ struct drm_device *dev ;
  struct intel_crt *crt ;
  struct intel_crt *tmp ;
  struct drm_crtc *crtc ;
  enum drm_connector_status status ;
  bool tmp___0 ;
  bool tmp___1 ;
  struct intel_load_detect_pipe tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  {
  {
  dev = connector->dev;
  tmp = intel_attached_crt(connector);
  crt = tmp;
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    tmp___0 = intel_crt_detect_hotplug(connector);
    }
    if ((int )tmp___0) {
      {
      drm_ut_debug_printk(4U, "drm", "intel_crt_detect", "CRT detected via hotplug\n");
      }
      return ((enum drm_connector_status )1);
    } else {
      {
      drm_ut_debug_printk(4U, "drm", "intel_crt_detect", "CRT not detected via hotplug\n");
      }
      return ((enum drm_connector_status )2);
    }
  } else {
  }
  {
  tmp___1 = intel_crt_detect_ddc(connector);
  }
  if ((int )tmp___1) {
    return ((enum drm_connector_status )1);
  } else {
  }
  if (! force) {
    return (connector->status);
  } else {
  }
  crtc = crt->base.base.crtc;
  if ((unsigned long )crtc != (unsigned long )((struct drm_crtc *)0)) {
    if ((int )crtc->enabled) {
      {
      status = intel_crt_load_detect(crt);
      }
    } else {
      goto _L;
    }
  } else {
    _L:
    {
    tmp___4 = intel_get_load_detect_pipe(& crt->base, connector, (struct drm_display_mode *)0,
                                         & tmp___2);
    }
    if ((int )tmp___4) {
      {
      tmp___3 = intel_crt_detect_ddc(connector);
      }
      if ((int )tmp___3) {
        status = (enum drm_connector_status )1;
      } else {
        {
        status = intel_crt_load_detect(crt);
        }
      }
      {
      intel_release_load_detect_pipe(& crt->base, connector, & tmp___2);
      }
    } else {
      status = (enum drm_connector_status )3;
    }
  }
  return (status);
}
}
static void intel_crt_destroy(struct drm_connector *connector )
{
  {
  {
  drm_sysfs_connector_remove(connector);
  drm_connector_cleanup(connector);
  kfree((void const *)connector);
  }
  return;
}
}
static int intel_crt_get_modes(struct drm_connector *connector )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  int ret ;
  int tmp ;
  {
  {
  dev = connector->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  ret = intel_ddc_get_modes(connector, & (dev_priv->gmbus + (unsigned long )dev_priv->crt_ddc_pin)->adapter);
  }
  if (ret != 0) {
    return (ret);
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) == 0U) {
    return (ret);
  } else {
  }
  {
  tmp = intel_ddc_get_modes(connector, & (dev_priv->gmbus + 5UL)->adapter);
  }
  return (tmp);
}
}
static int intel_crt_set_property(struct drm_connector *connector , struct drm_property *property ,
                                  uint64_t value )
{
  {
  return (0);
}
}
static void intel_crt_reset(struct drm_connector *connector )
{ struct drm_device *dev ;
  struct intel_crt *crt ;
  struct intel_crt *tmp ;
  {
  {
  dev = connector->dev;
  tmp = intel_attached_crt(connector);
  crt = tmp;
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    crt->force_hotplug_required = (bool )1;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    crt->force_hotplug_required = (bool )1;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    crt->force_hotplug_required = (bool )1;
  } else {
  }
  return;
}
}
static struct drm_encoder_helper_funcs const intel_crt_helper_funcs =
     {& intel_crt_dpms, (void (*)(struct drm_encoder * ))0, (void (*)(struct drm_encoder * ))0,
    & intel_crt_mode_fixup, & intel_encoder_prepare, & intel_encoder_commit, & intel_crt_mode_set,
    (struct drm_crtc *(*)(struct drm_encoder * ))0, (enum drm_connector_status (*)(struct drm_encoder * ,
                                                                                   struct drm_connector * ))0,
    (void (*)(struct drm_encoder * ))0};
static struct drm_connector_funcs const intel_crt_connector_funcs =
     {& drm_helper_connector_dpms, (void (*)(struct drm_connector * ))0, (void (*)(struct drm_connector * ))0,
    & intel_crt_reset, & intel_crt_detect, & drm_helper_probe_single_connector_modes,
    & intel_crt_set_property, & intel_crt_destroy, (void (*)(struct drm_connector * ))0};
static struct drm_connector_helper_funcs const intel_crt_connector_helper_funcs = {& intel_crt_get_modes,
    & intel_crt_mode_valid, & intel_best_encoder};
static struct drm_encoder_funcs const intel_crt_enc_funcs = {(void (*)(struct drm_encoder * ))0, & intel_encoder_destroy};
void intel_crt_init(struct drm_device *dev )
{ struct drm_connector *connector ;
  struct intel_crt *crt ;
  struct intel_connector *intel_connector ;
  struct drm_i915_private *dev_priv ;
  void *tmp ;
  void *tmp___0 ;
  u32 adpa ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = kzalloc(104UL, 208U);
  crt = (struct intel_crt *)tmp;
  }
  if ((unsigned long )crt == (unsigned long )((struct intel_crt *)0)) {
    return;
  } else {
  }
  {
  tmp___0 = kzalloc(1576UL, 208U);
  intel_connector = (struct intel_connector *)tmp___0;
  }
  if ((unsigned long )intel_connector == (unsigned long )((struct intel_connector *)0)) {
    {
    kfree((void const *)crt);
    }
    return;
  } else {
  }
  {
  connector = & intel_connector->base;
  drm_connector_init(dev, & intel_connector->base, & intel_crt_connector_funcs, 1);
  drm_encoder_init(dev, & crt->base.base, & intel_crt_enc_funcs, 1);
  intel_connector_attach_encoder(intel_connector, & crt->base);
  crt->base.type = 1;
  crt->base.clone_mask = 832;
  crt->base.crtc_mask = 3;
  connector->interlace_allowed = (bool )1;
  connector->doublescan_allowed = (bool )0;
  drm_encoder_helper_add(& crt->base.base, & intel_crt_helper_funcs);
  drm_connector_helper_add(connector, & intel_crt_connector_helper_funcs);
  drm_sysfs_connector_add(connector);
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    connector->polled = (uint8_t )1U;
  } else {
    connector->polled = (uint8_t )2U;
  }
  crt->force_hotplug_required = (bool )0;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    goto _L;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    goto _L;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    _L:
    {
    adpa = i915_read32___7(dev_priv, 921856U);
    adpa = adpa & 4227923967U;
    adpa = adpa | 15990784U;
    i915_write32___5(dev_priv, 921856U, adpa);
    readl((void const volatile *)dev_priv->regs + 921856U);
    drm_ut_debug_printk(4U, "drm", "intel_crt_init", "pch crt adpa set to 0x%x\n",
                        adpa);
    crt->force_hotplug_required = (bool )1;
    }
  } else {
  }
  dev_priv->hotplug_supported_mask = dev_priv->hotplug_supported_mask | 2048U;
  return;
}
}
extern int acpi_lid_notifier_register(struct notifier_block * ) ;
extern int acpi_lid_notifier_unregister(struct notifier_block * ) ;
extern int acpi_lid_open(void) ;
extern int dmi_check_system(struct dmi_system_id const * ) ;
extern int drm_add_edid_modes(struct drm_connector * , struct edid * ) ;
extern void drm_mode_probed_add(struct drm_connector * , struct drm_display_mode * ) ;
extern struct drm_display_mode *drm_mode_duplicate(struct drm_device * , struct drm_display_mode const * ) ;
extern int drm_mode_connector_update_edid_property(struct drm_connector * , struct edid * ) ;
extern int drm_connector_attach_property(struct drm_connector * , struct drm_property * ,
                                         uint64_t ) ;
extern int drm_mode_create_scaling_mode_property(struct drm_device * ) ;
__inline static void trace_i915_reg_rw___8(bool write , u32 reg , u64 val , int len )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_reg_rw.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_reg_rw.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )411);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_36460:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , bool , u32 , u64 , int ))it_func))(__data, (bool )((int )write),
                                                                   reg, val, len);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_36460;
      } else {
        goto ldv_36461;
      }
      ldv_36461: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
__inline static u32 i915_read32___8(struct drm_i915_private *dev_priv , u32 reg )
{ u32 val ;
  {
  val = 0U;
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        gen6_gt_force_wake_get(dev_priv);
        val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
        gen6_gt_force_wake_put(dev_priv);
        }
      } else {
        {
        val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
        }
      }
    } else {
      {
      val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
      }
    }
  } else {
    {
    val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
    }
  }
  {
  trace_i915_reg_rw___8((bool )0, reg, (u64 )val, 4);
  }
  return (val);
}
}
__inline static void i915_write32___6(struct drm_i915_private *dev_priv , u32 reg ,
                                      u32 val )
{
  {
  {
  trace_i915_reg_rw___8((bool )1, reg, (u64 )val, 4);
  }
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        __gen6_gt_wait_for_fifo(dev_priv);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  writel(val, (void volatile *)dev_priv->regs + (unsigned long )reg);
  }
  return;
}
}
void intel_fixed_panel_mode(struct drm_display_mode *fixed_mode , struct drm_display_mode *adjusted_mode ) ;
void intel_pch_panel_fitting(struct drm_device *dev , int fitting_mode , struct drm_display_mode *mode ,
                             struct drm_display_mode *adjusted_mode ) ;
void intel_panel_enable_backlight(struct drm_device *dev ) ;
void intel_panel_disable_backlight(struct drm_device *dev ) ;
enum drm_connector_status intel_panel_detect(struct drm_device *dev ) ;
static struct intel_lvds *to_intel_lvds(struct drm_encoder *encoder )
{ struct drm_encoder const *__mptr ;
  {
  __mptr = (struct drm_encoder const *)encoder;
  return ((struct intel_lvds *)__mptr);
}
}
static struct intel_lvds *intel_attached_lvds(struct drm_connector *connector )
{ struct intel_encoder const *__mptr ;
  struct intel_encoder *tmp ;
  {
  {
  tmp = intel_attached_encoder(connector);
  __mptr = (struct intel_encoder const *)tmp;
  }
  return ((struct intel_lvds *)__mptr);
}
}
static void intel_lvds_enable(struct intel_lvds *intel_lvds )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  u32 ctl_reg ;
  u32 lvds_reg ;
  u32 tmp ;
  unsigned long timeout__ ;
  unsigned long tmp___0 ;
  int ret__ ;
  struct thread_info *tmp___1 ;
  int pfo_ret__ ;
  int tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  {
  dev = intel_lvds->base.base.dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    ctl_reg = 815620U;
    lvds_reg = 921984U;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    ctl_reg = 815620U;
    lvds_reg = 921984U;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    ctl_reg = 815620U;
    lvds_reg = 921984U;
  } else {
    ctl_reg = 397828U;
    lvds_reg = 397696U;
  }
  {
  tmp = i915_read32___8(dev_priv, lvds_reg);
  i915_write32___6(dev_priv, lvds_reg, tmp | 2147483648U);
  }
  if ((int )intel_lvds->pfit_dirty) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_lvds_enable", "applying panel-fitter: %x, %x\n",
                        intel_lvds->pfit_control, intel_lvds->pfit_pgm_ratios);
    tmp___0 = msecs_to_jiffies((unsigned int const )1000U);
    timeout__ = tmp___0 + (unsigned long )jiffies;
    ret__ = 0;
    }
    goto ldv_40175;
    ldv_40174: ;
    if ((long )timeout__ - (long )jiffies < 0L) {
      ret__ = -110;
      goto ldv_40165;
    } else {
    }
    {
    tmp___1 = current_thread_info();
    }
    if ((tmp___1->preempt_count & -268435457) == 0) {
      if (1) {
        goto case_4;
      } else {
        goto switch_default;
        if (0) {
          __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
          goto ldv_40168;
          __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
          goto ldv_40168;
          case_4:
          __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
          goto ldv_40168;
          __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
          goto ldv_40168;
          switch_default:
          {
          __bad_percpu_size();
          }
        } else {
        }
      }
      ldv_40168:
      {
      tmp___2 = atomic_read((atomic_t const *)(& kgdb_active));
      }
      if (pfo_ret__ != tmp___2) {
        {
        msleep(1U);
        }
      } else {
      }
    } else {
    }
    ldv_40175:
    {
    tmp___3 = i915_read32___8(dev_priv, 397824U);
    }
    if ((int )tmp___3 < 0) {
      goto ldv_40174;
    } else {
      goto ldv_40165;
    }
    ldv_40165: ;
    if (ret__ != 0) {
      {
      drm_err("intel_lvds_enable", "timed out waiting for panel to power off\n");
      }
    } else {
      {
      i915_write32___6(dev_priv, 397876U, intel_lvds->pfit_pgm_ratios);
      i915_write32___6(dev_priv, 397872U, intel_lvds->pfit_control);
      intel_lvds->pfit_dirty = (bool )0;
      }
    }
  } else {
  }
  {
  tmp___4 = i915_read32___8(dev_priv, ctl_reg);
  i915_write32___6(dev_priv, ctl_reg, tmp___4 | 1U);
  readl((void const volatile *)dev_priv->regs + (unsigned long )lvds_reg);
  intel_panel_enable_backlight(dev);
  }
  return;
}
}
static void intel_lvds_disable(struct intel_lvds *intel_lvds )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  u32 ctl_reg ;
  u32 lvds_reg ;
  u32 tmp ;
  unsigned long timeout__ ;
  unsigned long tmp___0 ;
  int ret__ ;
  struct thread_info *tmp___1 ;
  int pfo_ret__ ;
  int tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  {
  dev = intel_lvds->base.base.dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    ctl_reg = 815620U;
    lvds_reg = 921984U;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    ctl_reg = 815620U;
    lvds_reg = 921984U;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    ctl_reg = 815620U;
    lvds_reg = 921984U;
  } else {
    ctl_reg = 397828U;
    lvds_reg = 397696U;
  }
  {
  intel_panel_disable_backlight(dev);
  tmp = i915_read32___8(dev_priv, ctl_reg);
  i915_write32___6(dev_priv, ctl_reg, tmp & 4294967294U);
  }
  if (intel_lvds->pfit_control != 0U) {
    {
    tmp___0 = msecs_to_jiffies((unsigned int const )1000U);
    timeout__ = tmp___0 + (unsigned long )jiffies;
    ret__ = 0;
    }
    goto ldv_40202;
    ldv_40201: ;
    if ((long )timeout__ - (long )jiffies < 0L) {
      ret__ = -110;
      goto ldv_40192;
    } else {
    }
    {
    tmp___1 = current_thread_info();
    }
    if ((tmp___1->preempt_count & -268435457) == 0) {
      if (1) {
        goto case_4;
      } else {
        goto switch_default;
        if (0) {
          __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
          goto ldv_40195;
          __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
          goto ldv_40195;
          case_4:
          __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
          goto ldv_40195;
          __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
          goto ldv_40195;
          switch_default:
          {
          __bad_percpu_size();
          }
        } else {
        }
      }
      ldv_40195:
      {
      tmp___2 = atomic_read((atomic_t const *)(& kgdb_active));
      }
      if (pfo_ret__ != tmp___2) {
        {
        msleep(1U);
        }
      } else {
      }
    } else {
    }
    ldv_40202:
    {
    tmp___3 = i915_read32___8(dev_priv, 397824U);
    }
    if ((int )tmp___3 < 0) {
      goto ldv_40201;
    } else {
      goto ldv_40192;
    }
    ldv_40192: ;
    if (ret__ != 0) {
      {
      drm_err("intel_lvds_disable", "timed out waiting for panel to power off\n");
      }
    } else {
    }
    {
    i915_write32___6(dev_priv, 397872U, 0U);
    intel_lvds->pfit_dirty = (bool )1;
    }
  } else {
  }
  {
  tmp___4 = i915_read32___8(dev_priv, lvds_reg);
  i915_write32___6(dev_priv, lvds_reg, tmp___4 & 2147483647U);
  readl((void const volatile *)dev_priv->regs + (unsigned long )lvds_reg);
  }
  return;
}
}
static void intel_lvds_dpms(struct drm_encoder *encoder , int mode )
{ struct intel_lvds *intel_lvds ;
  struct intel_lvds *tmp ;
  {
  {
  tmp = to_intel_lvds(encoder);
  intel_lvds = tmp;
  }
  if (mode == 0) {
    {
    intel_lvds_enable(intel_lvds);
    }
  } else {
    {
    intel_lvds_disable(intel_lvds);
    }
  }
  return;
}
}
static int intel_lvds_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode )
{ struct intel_lvds *intel_lvds ;
  struct intel_lvds *tmp ;
  struct drm_display_mode *fixed_mode ;
  {
  {
  tmp = intel_attached_lvds(connector);
  intel_lvds = tmp;
  fixed_mode = intel_lvds->fixed_mode;
  }
  if (mode->hdisplay > fixed_mode->hdisplay) {
    return (29);
  } else {
  }
  if (mode->vdisplay > fixed_mode->vdisplay) {
    return (29);
  } else {
  }
  return (0);
}
}
static void centre_horizontally(struct drm_display_mode *mode , int width )
{ u32 border ;
  u32 sync_pos ;
  u32 blank_width ;
  u32 sync_width ;
  {
  sync_width = (u32 )(mode->crtc_hsync_end - mode->crtc_hsync_start);
  blank_width = (u32 )(mode->crtc_hblank_end - mode->crtc_hblank_start);
  sync_pos = ((blank_width - sync_width) + 1U) / 2U;
  border = (u32 )(((mode->hdisplay - width) + 1) / 2);
  border = (border & 1U) + border;
  mode->crtc_hdisplay = width;
  mode->crtc_hblank_start = (int )((u32 )width + border);
  mode->crtc_hblank_end = (int )((u32 )mode->crtc_hblank_start + blank_width);
  mode->crtc_hsync_start = (int )((u32 )mode->crtc_hblank_start + sync_pos);
  mode->crtc_hsync_end = (int )((u32 )mode->crtc_hsync_start + sync_width);
  return;
}
}
static void centre_vertically(struct drm_display_mode *mode , int height )
{ u32 border ;
  u32 sync_pos ;
  u32 blank_width ;
  u32 sync_width ;
  {
  sync_width = (u32 )(mode->crtc_vsync_end - mode->crtc_vsync_start);
  blank_width = (u32 )(mode->crtc_vblank_end - mode->crtc_vblank_start);
  sync_pos = ((blank_width - sync_width) + 1U) / 2U;
  border = (u32 )(((mode->vdisplay - height) + 1) / 2);
  mode->crtc_vdisplay = height;
  mode->crtc_vblank_start = (int )((u32 )height + border);
  mode->crtc_vblank_end = (int )((u32 )mode->crtc_vblank_start + blank_width);
  mode->crtc_vsync_start = (int )((u32 )mode->crtc_vblank_start + sync_pos);
  mode->crtc_vsync_end = (int )((u32 )mode->crtc_vsync_start + sync_width);
  return;
}
}
__inline static u32 panel_fitter_scaling(u32 source , u32 target )
{ u32 ratio ;
  {
  ratio = (source * 4096U) / target;
  return ((ratio * 4096U + 2048U) / 4096U);
}
}
static bool intel_lvds_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                  struct drm_display_mode *adjusted_mode )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  struct intel_lvds *intel_lvds ;
  struct intel_lvds *tmp ;
  struct drm_encoder *tmp_encoder ;
  u32 pfit_control ;
  u32 pfit_pgm_ratios ;
  u32 border ;
  int pipe ;
  struct list_head const *__mptr___0 ;
  struct list_head const *__mptr___1 ;
  u32 scaled_width ;
  u32 scaled_height ;
  u32 scaled_width___0 ;
  u32 scaled_height___0 ;
  u32 bits ;
  u32 tmp___0 ;
  u32 bits___0 ;
  u32 tmp___1 ;
  {
  {
  dev = encoder->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)encoder->crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  tmp = to_intel_lvds(encoder);
  intel_lvds = tmp;
  pfit_control = 0U;
  pfit_pgm_ratios = 0U;
  border = 0U;
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) <= 3U) {
    if ((unsigned int )intel_crtc->pipe == 0U) {
      {
      drm_err("intel_lvds_mode_fixup", "Can\'t support LVDS on pipe A\n");
      }
      return ((bool )0);
    } else {
    }
  } else {
  }
  __mptr___0 = (struct list_head const *)dev->mode_config.encoder_list.next;
  tmp_encoder = (struct drm_encoder *)__mptr___0 + 0x0ffffffffffffff8UL;
  goto ldv_40259;
  ldv_40258: ;
  if ((unsigned long )tmp_encoder != (unsigned long )encoder) {
    if ((unsigned long )tmp_encoder->crtc == (unsigned long )encoder->crtc) {
      {
      drm_err("intel_lvds_mode_fixup", "Can\'t enable LVDS and another encoder on the same pipe\n");
      }
      return ((bool )0);
    } else {
    }
  } else {
  }
  __mptr___1 = (struct list_head const *)tmp_encoder->head.next;
  tmp_encoder = (struct drm_encoder *)__mptr___1 + 0x0ffffffffffffff8UL;
  ldv_40259: ;
  if ((unsigned long )(& tmp_encoder->head) != (unsigned long )(& dev->mode_config.encoder_list)) {
    goto ldv_40258;
  } else {
    goto ldv_40260;
  }
  ldv_40260:
  {
  intel_fixed_panel_mode(intel_lvds->fixed_mode, adjusted_mode);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    intel_pch_panel_fitting(dev, intel_lvds->fitting_mode, mode, adjusted_mode);
    }
    return ((bool )1);
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    intel_pch_panel_fitting(dev, intel_lvds->fitting_mode, mode, adjusted_mode);
    }
    return ((bool )1);
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    intel_pch_panel_fitting(dev, intel_lvds->fitting_mode, mode, adjusted_mode);
    }
    return ((bool )1);
  } else {
  }
  if (adjusted_mode->hdisplay == mode->hdisplay) {
    if (adjusted_mode->vdisplay == mode->vdisplay) {
      goto out;
    } else {
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    pfit_control = ((unsigned int )intel_crtc->pipe << 29) | pfit_control;
  } else {
  }
  pipe = 0;
  goto ldv_40263;
  ldv_40262:
  {
  i915_write32___6(dev_priv, (u32 )(pipe * 4096 + 393248), 0U);
  pipe = pipe + 1;
  }
  ldv_40263: ;
  if (dev_priv->num_pipe > pipe) {
    goto ldv_40262;
  } else {
    goto ldv_40264;
  }
  ldv_40264: ;
  if (intel_lvds->fitting_mode == 2) {
    goto case_2;
  } else
  if (intel_lvds->fitting_mode == 3) {
    goto case_3;
  } else
  if (intel_lvds->fitting_mode == 1) {
    goto case_1;
  } else {
    goto switch_default;
    if (0) {
      case_2:
      {
      centre_horizontally(adjusted_mode, mode->hdisplay);
      centre_vertically(adjusted_mode, mode->vdisplay);
      border = 32768U;
      }
      goto ldv_40266;
      case_3: ;
      if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
        scaled_width = (u32 )(adjusted_mode->hdisplay * mode->vdisplay);
        scaled_height = (u32 )(mode->hdisplay * adjusted_mode->vdisplay);
        if (scaled_width > scaled_height) {
          pfit_control = pfit_control | 2281701376U;
        } else
        if (scaled_width < scaled_height) {
          pfit_control = pfit_control | 2348810240U;
        } else
        if (adjusted_mode->hdisplay != mode->hdisplay) {
          pfit_control = pfit_control | 2147483648U;
        } else {
        }
      } else {
        scaled_width___0 = (u32 )(adjusted_mode->hdisplay * mode->vdisplay);
        scaled_height___0 = (u32 )(mode->hdisplay * adjusted_mode->vdisplay);
        if (scaled_width___0 > scaled_height___0) {
          {
          centre_horizontally(adjusted_mode, (int )(scaled_height___0 / (u32 )mode->vdisplay));
          border = 32768U;
          }
          if (mode->vdisplay != adjusted_mode->vdisplay) {
            {
            tmp___0 = panel_fitter_scaling((u32 )mode->vdisplay, (u32 )adjusted_mode->vdisplay);
            bits = tmp___0;
            pfit_pgm_ratios = ((bits << 4) | (bits << 20)) | pfit_pgm_ratios;
            pfit_control = pfit_control | 2147484736U;
            }
          } else {
          }
        } else
        if (scaled_width___0 < scaled_height___0) {
          {
          centre_vertically(adjusted_mode, (int )(scaled_width___0 / (u32 )mode->hdisplay));
          border = 32768U;
          }
          if (mode->hdisplay != adjusted_mode->hdisplay) {
            {
            tmp___1 = panel_fitter_scaling((u32 )mode->hdisplay, (u32 )adjusted_mode->hdisplay);
            bits___0 = tmp___1;
            pfit_pgm_ratios = ((bits___0 << 4) | (bits___0 << 20)) | pfit_pgm_ratios;
            pfit_control = pfit_control | 2147484736U;
            }
          } else {
          }
        } else {
          pfit_control = pfit_control | 2147485280U;
        }
      }
      goto ldv_40266;
      case_1: ;
      if (mode->vdisplay != adjusted_mode->vdisplay) {
        goto _L;
      } else
      if (mode->hdisplay != adjusted_mode->hdisplay) {
        _L:
        pfit_control = pfit_control | 2147483648U;
        if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
          pfit_control = pfit_control;
        } else {
          pfit_control = pfit_control | 1632U;
        }
      } else {
      }
      goto ldv_40266;
      switch_default: ;
      goto ldv_40266;
    } else {
    }
  }
  ldv_40266: ;
  out: ;
  if ((int )pfit_control >= 0) {
    pfit_control = 0U;
    pfit_pgm_ratios = 0U;
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) <= 3U) {
    if ((unsigned int )*((unsigned char *)dev_priv + 2072UL) != 0U) {
      pfit_control = pfit_control | 8U;
    } else {
    }
  } else {
  }
  if (intel_lvds->pfit_control != pfit_control) {
    intel_lvds->pfit_control = pfit_control;
    intel_lvds->pfit_pgm_ratios = pfit_pgm_ratios;
    intel_lvds->pfit_dirty = (bool )1;
  } else
  if (intel_lvds->pfit_pgm_ratios != pfit_pgm_ratios) {
    intel_lvds->pfit_control = pfit_control;
    intel_lvds->pfit_pgm_ratios = pfit_pgm_ratios;
    intel_lvds->pfit_dirty = (bool )1;
  } else {
  }
  dev_priv->lvds_border_bits = border;
  return ((bool )1);
}
}
static void intel_lvds_prepare(struct drm_encoder *encoder )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_lvds *intel_lvds ;
  struct intel_lvds *tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  {
  {
  dev = encoder->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = to_intel_lvds(encoder);
  intel_lvds = tmp;
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    tmp___0 = i915_read32___8(dev_priv, 815620U);
    i915_write32___6(dev_priv, 815620U, tmp___0 | 2882338816U);
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    tmp___0 = i915_read32___8(dev_priv, 815620U);
    i915_write32___6(dev_priv, 815620U, tmp___0 | 2882338816U);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    tmp___0 = i915_read32___8(dev_priv, 815620U);
    i915_write32___6(dev_priv, 815620U, tmp___0 | 2882338816U);
    }
  } else
  if ((int )intel_lvds->pfit_dirty) {
    {
    tmp___1 = i915_read32___8(dev_priv, 397828U);
    i915_write32___6(dev_priv, 397828U, (tmp___1 & 1412628478U) | 2882338816U);
    }
  } else {
    {
    tmp___2 = i915_read32___8(dev_priv, 397828U);
    i915_write32___6(dev_priv, 397828U, tmp___2 | 2882338816U);
    }
  }
  return;
}
}
static void intel_lvds_commit(struct drm_encoder *encoder )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_lvds *intel_lvds ;
  struct intel_lvds *tmp ;
  u32 val ;
  u32 tmp___0 ;
  u32 val___0 ;
  u32 tmp___1 ;
  {
  {
  dev = encoder->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = to_intel_lvds(encoder);
  intel_lvds = tmp;
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    goto _L;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    goto _L;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    _L:
    {
    tmp___0 = i915_read32___8(dev_priv, 815620U);
    val = tmp___0;
    }
    if ((val & 2882338816U) == 2882338816U) {
      {
      i915_write32___6(dev_priv, 815620U, val & 3U);
      }
    } else {
    }
  } else {
    {
    tmp___1 = i915_read32___8(dev_priv, 397828U);
    val___0 = tmp___1;
    }
    if ((val___0 & 2882338816U) == 2882338816U) {
      {
      i915_write32___6(dev_priv, 397828U, val___0 & 3U);
      }
    } else {
    }
  }
  {
  intel_lvds_enable(intel_lvds);
  }
  return;
}
}
static void intel_lvds_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                struct drm_display_mode *adjusted_mode )
{
  {
  return;
}
}
static enum drm_connector_status intel_lvds_detect(struct drm_connector *connector ,
                                                   bool force )
{ struct drm_device *dev ;
  enum drm_connector_status status ;
  {
  {
  dev = connector->dev;
  status = intel_panel_detect(dev);
  }
  if ((unsigned int )status != 3U) {
    return (status);
  } else {
  }
  return ((enum drm_connector_status )1);
}
}
static int intel_lvds_get_modes(struct drm_connector *connector )
{ struct intel_lvds *intel_lvds ;
  struct intel_lvds *tmp ;
  struct drm_device *dev ;
  struct drm_display_mode *mode ;
  int tmp___0 ;
  {
  {
  tmp = intel_attached_lvds(connector);
  intel_lvds = tmp;
  dev = connector->dev;
  }
  if ((unsigned long )intel_lvds->edid != (unsigned long )((struct edid *)0)) {
    {
    tmp___0 = drm_add_edid_modes(connector, intel_lvds->edid);
    }
    return (tmp___0);
  } else {
  }
  {
  mode = drm_mode_duplicate(dev, (struct drm_display_mode const *)intel_lvds->fixed_mode);
  }
  if ((unsigned long )mode == (unsigned long )((struct drm_display_mode *)0)) {
    return (0);
  } else {
  }
  {
  drm_mode_probed_add(connector, mode);
  }
  return (1);
}
}
static int intel_no_modeset_on_lid_dmi_callback(struct dmi_system_id const *id )
{
  {
  {
  drm_ut_debug_printk(4U, "drm", "intel_no_modeset_on_lid_dmi_callback", "Skipping forced modeset for %s\n",
                      id->ident);
  }
  return (1);
}
}
static struct dmi_system_id const intel_no_modeset_on_lid[2U] = { {& intel_no_modeset_on_lid_dmi_callback, "Toshiba Tecra A11", {{(unsigned char)4,
                                                                     {(char )'T',
                                                                      (char )'O',
                                                                      (char )'S',
                                                                      (char )'H',
                                                                      (char )'I',
                                                                      (char )'B',
                                                                      (char )'A',
                                                                      (char )'\000'}},
                                                                    {(unsigned char)5,
                                                                     {(char )'T',
                                                                      (char )'E',
                                                                      (char )'C',
                                                                      (char )'R',
                                                                      (char )'A',
                                                                      (char )' ',
                                                                      (char )'A',
                                                                      (char )'1',
                                                                      (char )'1',
                                                                      (char )'\000'}},
                                                                    {(unsigned char)0,
                                                                     {(char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0}}, {(unsigned char)0,
                                                                                  {(char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0}}},
      (void *)0},
        {(int (*)(struct dmi_system_id const * ))0, (char const *)0, {{(unsigned char)0,
                                                                        {(char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0}},
                                                                       {(unsigned char)0,
                                                                        {(char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0}},
                                                                       {(unsigned char)0,
                                                                        {(char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0}},
                                                                       {(unsigned char)0,
                                                                        {(char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0}}},
      (void *)0}};
static int intel_lid_notify(struct notifier_block *nb , unsigned long val , void *unused )
{ struct drm_i915_private *dev_priv ;
  struct notifier_block const *__mptr ;
  struct drm_device *dev ;
  struct drm_connector *connector ;
  int tmp ;
  int tmp___0 ;
  {
  __mptr = (struct notifier_block const *)nb;
  dev_priv = (struct drm_i915_private *)__mptr + 0x0ffffffffffff7b8UL;
  dev = dev_priv->dev;
  connector = dev_priv->int_lvds_connector;
  if (dev->switch_power_state != 0) {
    return (1);
  } else {
  }
  if ((unsigned long )connector != (unsigned long )((struct drm_connector *)0)) {
    {
    connector->status = (*((connector->funcs)->detect))(connector, (bool )0);
    }
  } else {
  }
  {
  tmp = dmi_check_system((struct dmi_system_id const *)(& intel_no_modeset_on_lid));
  }
  if (tmp != 0) {
    return (1);
  } else {
  }
  {
  tmp___0 = acpi_lid_open();
  }
  if (tmp___0 == 0) {
    dev_priv->modeset_on_lid = (bool )1;
    return (1);
  } else {
  }
  if (! dev_priv->modeset_on_lid) {
    return (1);
  } else {
  }
  {
  dev_priv->modeset_on_lid = (bool )0;
  mutex_lock_nested(& dev->mode_config.mutex, 0U);
  drm_helper_resume_force_mode(dev);
  mutex_unlock(& dev->mode_config.mutex);
  }
  return (1);
}
}
static void intel_lvds_destroy(struct drm_connector *connector )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  {
  dev = connector->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned long )dev_priv->lid_notifier.notifier_call != (unsigned long )((int (*)(struct notifier_block * ,
                                                                                        unsigned long ,
                                                                                        void * ))0)) {
    {
    acpi_lid_notifier_unregister(& dev_priv->lid_notifier);
    }
  } else {
  }
  {
  drm_sysfs_connector_remove(connector);
  drm_connector_cleanup(connector);
  kfree((void const *)connector);
  }
  return;
}
}
static int intel_lvds_set_property(struct drm_connector *connector , struct drm_property *property ,
                                   uint64_t value )
{ struct intel_lvds *intel_lvds ;
  struct intel_lvds *tmp ;
  struct drm_device *dev ;
  struct drm_crtc *crtc ;
  {
  {
  tmp = intel_attached_lvds(connector);
  intel_lvds = tmp;
  dev = connector->dev;
  }
  if ((unsigned long )dev->mode_config.scaling_mode_property == (unsigned long )property) {
    crtc = intel_lvds->base.base.crtc;
    if (value == 0ULL) {
      {
      drm_ut_debug_printk(4U, "drm", "intel_lvds_set_property", "no scaling not supported\n");
      }
      return (-22);
    } else {
    }
    if ((uint64_t )intel_lvds->fitting_mode == value) {
      return (0);
    } else {
    }
    intel_lvds->fitting_mode = (int )value;
    if ((unsigned long )crtc != (unsigned long )((struct drm_crtc *)0)) {
      if ((int )crtc->enabled) {
        {
        drm_crtc_helper_set_mode(crtc, & crtc->mode, crtc->x, crtc->y, crtc->fb);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  return (0);
}
}
static struct drm_encoder_helper_funcs const intel_lvds_helper_funcs =
     {& intel_lvds_dpms, (void (*)(struct drm_encoder * ))0, (void (*)(struct drm_encoder * ))0,
    & intel_lvds_mode_fixup, & intel_lvds_prepare, & intel_lvds_commit, & intel_lvds_mode_set,
    (struct drm_crtc *(*)(struct drm_encoder * ))0, (enum drm_connector_status (*)(struct drm_encoder * ,
                                                                                   struct drm_connector * ))0,
    (void (*)(struct drm_encoder * ))0};
static struct drm_connector_helper_funcs const intel_lvds_connector_helper_funcs = {& intel_lvds_get_modes,
    & intel_lvds_mode_valid, & intel_best_encoder};
static struct drm_connector_funcs const intel_lvds_connector_funcs =
     {& drm_helper_connector_dpms, (void (*)(struct drm_connector * ))0, (void (*)(struct drm_connector * ))0,
    (void (*)(struct drm_connector * ))0, & intel_lvds_detect, & drm_helper_probe_single_connector_modes,
    & intel_lvds_set_property, & intel_lvds_destroy, (void (*)(struct drm_connector * ))0};
static struct drm_encoder_funcs const intel_lvds_enc_funcs = {(void (*)(struct drm_encoder * ))0, & intel_encoder_destroy};
static int intel_no_lvds_dmi_callback(struct dmi_system_id const *id )
{
  {
  {
  drm_ut_debug_printk(4U, "drm", "intel_no_lvds_dmi_callback", "Skipping LVDS initialization for %s\n",
                      id->ident);
  }
  return (1);
}
}
static struct dmi_system_id const intel_no_lvds[11U] =
  { {& intel_no_lvds_dmi_callback, "Apple Mac Mini (Core series)", {{(unsigned char)4,
                                                                      {(char )'A',
                                                                       (char )'p',
                                                                       (char )'p',
                                                                       (char )'l',
                                                                       (char )'e',
                                                                       (char )'\000'}},
                                                                     {(unsigned char)5,
                                                                      {(char )'M',
                                                                       (char )'a',
                                                                       (char )'c',
                                                                       (char )'m',
                                                                       (char )'i',
                                                                       (char )'n',
                                                                       (char )'i',
                                                                       (char )'1',
                                                                       (char )',',
                                                                       (char )'1',
                                                                       (char )'\000'}},
                                                                     {(unsigned char)0,
                                                                      {(char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0}},
                                                                     {(unsigned char)0,
                                                                      {(char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0}}},
      (void *)0},
        {& intel_no_lvds_dmi_callback, "Apple Mac Mini (Core 2 series)", {{(unsigned char)4,
                                                                        {(char )'A',
                                                                         (char )'p',
                                                                         (char )'p',
                                                                         (char )'l',
                                                                         (char )'e',
                                                                         (char )'\000'}},
                                                                       {(unsigned char)5,
                                                                        {(char )'M',
                                                                         (char )'a',
                                                                         (char )'c',
                                                                         (char )'m',
                                                                         (char )'i',
                                                                         (char )'n',
                                                                         (char )'i',
                                                                         (char )'2',
                                                                         (char )',',
                                                                         (char )'1',
                                                                         (char )'\000'}},
                                                                       {(unsigned char)0,
                                                                        {(char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0}},
                                                                       {(unsigned char)0,
                                                                        {(char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0}}},
      (void *)0},
        {& intel_no_lvds_dmi_callback, "MSI IM-945GSE-A", {{(unsigned char)4, {(char )'M',
                                                                            (char )'S',
                                                                            (char )'I',
                                                                            (char )'\000'}},
                                                        {(unsigned char)5, {(char )'A',
                                                                            (char )'9',
                                                                            (char )'8',
                                                                            (char )'3',
                                                                            (char )'0',
                                                                            (char )'I',
                                                                            (char )'M',
                                                                            (char )'S',
                                                                            (char )'\000'}},
                                                        {(unsigned char)0, {(char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0}},
                                                        {(unsigned char)0, {(char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0}}},
      (void *)0},
        {& intel_no_lvds_dmi_callback, "Dell Studio Hybrid", {{(unsigned char)4, {(char )'D',
                                                                               (char )'e',
                                                                               (char )'l',
                                                                               (char )'l',
                                                                               (char )' ',
                                                                               (char )'I',
                                                                               (char )'n',
                                                                               (char )'c',
                                                                               (char )'.',
                                                                               (char )'\000'}},
                                                           {(unsigned char)5, {(char )'S',
                                                                               (char )'t',
                                                                               (char )'u',
                                                                               (char )'d',
                                                                               (char )'i',
                                                                               (char )'o',
                                                                               (char )' ',
                                                                               (char )'H',
                                                                               (char )'y',
                                                                               (char )'b',
                                                                               (char )'r',
                                                                               (char )'i',
                                                                               (char )'d',
                                                                               (char )' ',
                                                                               (char )'1',
                                                                               (char )'4',
                                                                               (char )'0',
                                                                               (char )'g',
                                                                               (char )'\000'}},
                                                           {(unsigned char)0, {(char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0}},
                                                           {(unsigned char)0, {(char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0}}},
      (void *)0},
        {& intel_no_lvds_dmi_callback, "AOpen Mini PC", {{(unsigned char)4, {(char )'A',
                                                                          (char )'O',
                                                                          (char )'p',
                                                                          (char )'e',
                                                                          (char )'n',
                                                                          (char )'\000'}},
                                                      {(unsigned char)5, {(char )'i',
                                                                          (char )'9',
                                                                          (char )'6',
                                                                          (char )'5',
                                                                          (char )'G',
                                                                          (char )'M',
                                                                          (char )'x',
                                                                          (char )'-',
                                                                          (char )'I',
                                                                          (char )'F',
                                                                          (char )'\000'}},
                                                      {(unsigned char)0, {(char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0}},
                                                      {(unsigned char)0, {(char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0}}},
      (void *)0},
        {& intel_no_lvds_dmi_callback, "AOpen Mini PC MP915", {{(unsigned char)9, {(char )'A',
                                                                                (char )'O',
                                                                                (char )'p',
                                                                                (char )'e',
                                                                                (char )'n',
                                                                                (char )'\000'}},
                                                            {(unsigned char)10, {(char )'i',
                                                                                 (char )'9',
                                                                                 (char )'1',
                                                                                 (char )'5',
                                                                                 (char )'G',
                                                                                 (char )'M',
                                                                                 (char )'x',
                                                                                 (char )'-',
                                                                                 (char )'F',
                                                                                 (char )'\000'}},
                                                            {(unsigned char)0, {(char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0}},
                                                            {(unsigned char)0, {(char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0}}},
      (void *)0},
        {& intel_no_lvds_dmi_callback, "AOpen i915GMm-HFS", {{(unsigned char)9, {(char )'A',
                                                                              (char )'O',
                                                                              (char )'p',
                                                                              (char )'e',
                                                                              (char )'n',
                                                                              (char )'\000'}},
                                                          {(unsigned char)10, {(char )'i',
                                                                               (char )'9',
                                                                               (char )'1',
                                                                               (char )'5',
                                                                               (char )'G',
                                                                               (char )'M',
                                                                               (char )'m',
                                                                               (char )'-',
                                                                               (char )'H',
                                                                               (char )'F',
                                                                               (char )'S',
                                                                               (char )'\000'}},
                                                          {(unsigned char)0, {(char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0}},
                                                          {(unsigned char)0, {(char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0}}},
      (void *)0},
        {& intel_no_lvds_dmi_callback, "Aopen i945GTt-VFA", {{(unsigned char)6, {(char )'A',
                                                                              (char )'O',
                                                                              (char )'0',
                                                                              (char )'0',
                                                                              (char )'0',
                                                                              (char )'0',
                                                                              (char )'1',
                                                                              (char )'J',
                                                                              (char )'W',
                                                                              (char )'\000'}},
                                                          {(unsigned char)0, {(char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0}},
                                                          {(unsigned char)0, {(char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0}},
                                                          {(unsigned char)0, {(char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0}}},
      (void *)0},
        {& intel_no_lvds_dmi_callback, "Clientron U800", {{(unsigned char)4, {(char )'C',
                                                                           (char )'l',
                                                                           (char )'i',
                                                                           (char )'e',
                                                                           (char )'n',
                                                                           (char )'t',
                                                                           (char )'r',
                                                                           (char )'o',
                                                                           (char )'n',
                                                                           (char )'\000'}},
                                                       {(unsigned char)5, {(char )'U',
                                                                           (char )'8',
                                                                           (char )'0',
                                                                           (char )'0',
                                                                           (char )'\000'}},
                                                       {(unsigned char)0, {(char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0}},
                                                       {(unsigned char)0, {(char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0,
                                                                           (char)0}}},
      (void *)0},
        {& intel_no_lvds_dmi_callback, "Asus EeeBox PC EB1007", {{(unsigned char)4, {(char )'A',
                                                                                  (char )'S',
                                                                                  (char )'U',
                                                                                  (char )'S',
                                                                                  (char )'T',
                                                                                  (char )'e',
                                                                                  (char )'K',
                                                                                  (char )' ',
                                                                                  (char )'C',
                                                                                  (char )'o',
                                                                                  (char )'m',
                                                                                  (char )'p',
                                                                                  (char )'u',
                                                                                  (char )'t',
                                                                                  (char )'e',
                                                                                  (char )'r',
                                                                                  (char )' ',
                                                                                  (char )'I',
                                                                                  (char )'N',
                                                                                  (char )'C',
                                                                                  (char )'.',
                                                                                  (char )'\000'}},
                                                              {(unsigned char)5, {(char )'E',
                                                                                  (char )'B',
                                                                                  (char )'1',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'7',
                                                                                  (char )'\000'}},
                                                              {(unsigned char)0, {(char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0}},
                                                              {(unsigned char)0, {(char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0}}},
      (void *)0},
        {(int (*)(struct dmi_system_id const * ))0, (char const *)0, {{(unsigned char)0,
                                                                        {(char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0}},
                                                                       {(unsigned char)0,
                                                                        {(char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0}},
                                                                       {(unsigned char)0,
                                                                        {(char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0}},
                                                                       {(unsigned char)0,
                                                                        {(char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0}}},
      (void *)0}};
static void intel_find_lvds_downclock(struct drm_device *dev , struct drm_display_mode *fixed_mode ,
                                      struct drm_connector *connector )
{ struct drm_i915_private *dev_priv ;
  struct drm_display_mode *scan ;
  int temp_downclock ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  temp_downclock = fixed_mode->clock;
  __mptr = (struct list_head const *)connector->probed_modes.next;
  scan = (struct drm_display_mode *)__mptr;
  goto ldv_40358;
  ldv_40357: ;
  if (scan->hdisplay == fixed_mode->hdisplay) {
    if (scan->hsync_start == fixed_mode->hsync_start) {
      if (scan->hsync_end == fixed_mode->hsync_end) {
        if (scan->htotal == fixed_mode->htotal) {
          if (scan->vdisplay == fixed_mode->vdisplay) {
            if (scan->vsync_start == fixed_mode->vsync_start) {
              if (scan->vsync_end == fixed_mode->vsync_end) {
                if (scan->vtotal == fixed_mode->vtotal) {
                  if (scan->clock < temp_downclock) {
                    temp_downclock = scan->clock;
                  } else {
                  }
                } else {
                }
              } else {
              }
            } else {
            }
          } else {
          }
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  __mptr___0 = (struct list_head const *)scan->head.next;
  scan = (struct drm_display_mode *)__mptr___0;
  ldv_40358: ;
  if ((unsigned long )(& scan->head) != (unsigned long )(& connector->probed_modes)) {
    goto ldv_40357;
  } else {
    goto ldv_40359;
  }
  ldv_40359: ;
  if (fixed_mode->clock > temp_downclock) {
    if (i915_lvds_downclock != 0U) {
      {
      dev_priv->lvds_downclock_avail = (bool )1;
      dev_priv->lvds_downclock = temp_downclock;
      drm_ut_debug_printk(4U, "drm", "intel_find_lvds_downclock", "LVDS downclock is found in EDID. Normal clock %dKhz, downclock %dKhz\n",
                          fixed_mode->clock, temp_downclock);
      }
    } else {
    }
  } else {
  }
  return;
}
}
static bool lvds_is_present_in_vbt(struct drm_device *dev , u8 *i2c_pin )
{ struct drm_i915_private *dev_priv ;
  int i ;
  struct child_device_config *child ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if (dev_priv->child_dev_num == 0) {
    return ((bool )1);
  } else {
  }
  i = 0;
  goto ldv_40370;
  ldv_40369:
  child = dev_priv->child_dev + (unsigned long )i;
  if ((unsigned int )child->device_type != 4130U) {
    if ((unsigned int )child->device_type != 34U) {
      goto ldv_40368;
    } else {
    }
  } else {
  }
  if ((unsigned int )child->i2c_pin != 0U) {
    *i2c_pin = child->i2c_pin;
  } else {
  }
  if ((unsigned int )child->addin_offset != 0U) {
    return ((bool )1);
  } else {
  }
  if ((unsigned long )dev_priv->opregion.vbt != (unsigned long )((void *)0)) {
    return ((bool )1);
  } else {
  }
  ldv_40368:
  i = i + 1;
  ldv_40370: ;
  if (dev_priv->child_dev_num > i) {
    goto ldv_40369;
  } else {
    goto ldv_40371;
  }
  ldv_40371: ;
  return ((bool )0);
}
}
bool intel_lvds_init(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct intel_lvds *intel_lvds ;
  struct intel_encoder *intel_encoder ;
  struct intel_connector *intel_connector ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct drm_display_mode *scan ;
  struct drm_crtc *crtc ;
  u32 lvds ;
  int pipe ;
  u8 pin ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  u32 tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  u32 pwm ;
  u32 tmp___6 ;
  int tmp___7 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = dmi_check_system((struct dmi_system_id const *)(& intel_no_lvds));
  }
  if (tmp != 0) {
    return ((bool )0);
  } else {
  }
  {
  pin = (u8 )3U;
  tmp___0 = lvds_is_present_in_vbt(dev, & pin);
  }
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_lvds_init", "LVDS is not present in VBT\n");
    }
    return ((bool )0);
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    goto _L;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    goto _L;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    _L:
    {
    tmp___2 = i915_read32___8(dev_priv, 921984U);
    }
    if ((tmp___2 & 2U) == 0U) {
      return ((bool )0);
    } else {
    }
    if ((int )dev_priv->edp.support) {
      {
      drm_ut_debug_printk(4U, "drm", "intel_lvds_init", "disable LVDS for eDP support\n");
      }
      return ((bool )0);
    } else {
    }
  } else {
  }
  {
  tmp___3 = kzalloc(128UL, 208U);
  intel_lvds = (struct intel_lvds *)tmp___3;
  }
  if ((unsigned long )intel_lvds == (unsigned long )((struct intel_lvds *)0)) {
    return ((bool )0);
  } else {
  }
  {
  tmp___4 = kzalloc(1576UL, 208U);
  intel_connector = (struct intel_connector *)tmp___4;
  }
  if ((unsigned long )intel_connector == (unsigned long )((struct intel_connector *)0)) {
    {
    kfree((void const *)intel_lvds);
    }
    return ((bool )0);
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 5U) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 6U) {
      if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) == 0U) {
        {
        intel_lvds->pfit_control = i915_read32___8(dev_priv, 397872U);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  intel_encoder = & intel_lvds->base;
  encoder = & intel_encoder->base;
  connector = & intel_connector->base;
  drm_connector_init(dev, & intel_connector->base, & intel_lvds_connector_funcs, 7);
  drm_encoder_init(dev, & intel_encoder->base, & intel_lvds_enc_funcs, 3);
  intel_connector_attach_encoder(intel_connector, intel_encoder);
  intel_encoder->type = 4;
  intel_encoder->clone_mask = 16384;
  intel_encoder->crtc_mask = 2;
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 4U) {
    intel_encoder->crtc_mask = intel_encoder->crtc_mask | 1;
  } else {
  }
  {
  drm_encoder_helper_add(encoder, & intel_lvds_helper_funcs);
  drm_connector_helper_add(connector, & intel_lvds_connector_helper_funcs);
  connector->display_info.subpixel_order = (enum subpixel_order )1;
  connector->interlace_allowed = (bool )0;
  connector->doublescan_allowed = (bool )0;
  drm_mode_create_scaling_mode_property(dev);
  drm_connector_attach_property(& intel_connector->base, dev->mode_config.scaling_mode_property,
                                3ULL);
  intel_lvds->fitting_mode = 3;
  intel_lvds->edid = drm_get_edid(connector, & (dev_priv->gmbus + (unsigned long )pin)->adapter);
  }
  if ((unsigned long )intel_lvds->edid != (unsigned long )((struct edid *)0)) {
    {
    tmp___5 = drm_add_edid_modes(connector, intel_lvds->edid);
    }
    if (tmp___5 != 0) {
      {
      drm_mode_connector_update_edid_property(connector, intel_lvds->edid);
      }
    } else {
      {
      kfree((void const *)intel_lvds->edid);
      intel_lvds->edid = (struct edid *)0;
      }
    }
  } else {
  }
  if ((unsigned long )intel_lvds->edid == (unsigned long )((struct edid *)0)) {
    connector->display_info.min_vfreq = 0U;
    connector->display_info.max_vfreq = 200U;
    connector->display_info.min_hfreq = 0U;
    connector->display_info.max_hfreq = 200U;
  } else {
  }
  __mptr = (struct list_head const *)connector->probed_modes.next;
  scan = (struct drm_display_mode *)__mptr;
  goto ldv_40393;
  ldv_40392: ;
  if ((scan->type & 8) != 0) {
    {
    intel_lvds->fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode const *)scan);
    intel_find_lvds_downclock(dev, intel_lvds->fixed_mode, connector);
    }
    goto out;
  } else {
  }
  __mptr___0 = (struct list_head const *)scan->head.next;
  scan = (struct drm_display_mode *)__mptr___0;
  ldv_40393: ;
  if ((unsigned long )(& scan->head) != (unsigned long )(& connector->probed_modes)) {
    goto ldv_40392;
  } else {
    goto ldv_40394;
  }
  ldv_40394: ;
  if ((unsigned long )dev_priv->lfp_lvds_vbt_mode != (unsigned long )((struct drm_display_mode *)0)) {
    {
    intel_lvds->fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode const *)dev_priv->lfp_lvds_vbt_mode);
    }
    if ((unsigned long )intel_lvds->fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
      (intel_lvds->fixed_mode)->type = (intel_lvds->fixed_mode)->type | 8;
      goto out;
    } else {
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    goto failed;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    goto failed;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    goto failed;
  } else {
  }
  {
  lvds = i915_read32___8(dev_priv, 397696U);
  pipe = (lvds & 1073741824U) != 0U;
  crtc = intel_get_crtc_for_pipe(dev, pipe);
  }
  if ((unsigned long )crtc != (unsigned long )((struct drm_crtc *)0)) {
    if ((int )lvds < 0) {
      {
      intel_lvds->fixed_mode = intel_crtc_mode_get(dev, crtc);
      }
      if ((unsigned long )intel_lvds->fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
        (intel_lvds->fixed_mode)->type = (intel_lvds->fixed_mode)->type | 8;
        goto out;
      } else {
      }
    } else {
    }
  } else {
  }
  if ((unsigned long )intel_lvds->fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
    goto failed;
  } else {
  }
  out: ;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    goto _L___0;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    goto _L___0;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    _L___0:
    {
    tmp___6 = i915_read32___8(dev_priv, 921984U);
    pipe = (tmp___6 & 1073741824U) != 0U;
    pwm = i915_read32___8(dev_priv, 295504U);
    }
    if (pipe == 0) {
      if ((pwm & 536870912U) != 0U) {
        {
        i915_write32___6(dev_priv, 295504U, pwm & 2147483647U);
        }
      } else {
      }
    } else {
    }
    if (pipe != 0) {
      pwm = pwm | 536870912U;
    } else {
      pwm = pwm & 3758096383U;
    }
    {
    i915_write32___6(dev_priv, 295504U, pwm | 2147483648U);
    pwm = i915_read32___8(dev_priv, 819792U);
    pwm = pwm | 2147483648U;
    i915_write32___6(dev_priv, 819792U, pwm);
    }
  } else {
  }
  {
  dev_priv->lid_notifier.notifier_call = & intel_lid_notify;
  tmp___7 = acpi_lid_notifier_register(& dev_priv->lid_notifier);
  }
  if (tmp___7 != 0) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_lvds_init", "lid notifier registration failed\n");
    dev_priv->lid_notifier.notifier_call = (int (*)(struct notifier_block * , unsigned long ,
                                                    void * ))0;
    }
  } else {
  }
  {
  dev_priv->int_lvds_connector = connector;
  drm_sysfs_connector_add(connector);
  }
  return ((bool )1);
  failed:
  {
  drm_ut_debug_printk(4U, "drm", "intel_lvds_init", "No LVDS modes found, disabling.\n");
  drm_connector_cleanup(connector);
  drm_encoder_cleanup(encoder);
  kfree((void const *)intel_lvds);
  kfree((void const *)intel_connector);
  }
  return ((bool )0);
}
}
extern int memcmp(void const * , void const * , size_t ) ;
extern void *pci_map_rom(struct pci_dev * , size_t * ) ;
extern void pci_unmap_rom(struct pci_dev * , void * ) ;
__inline static void trace_i915_reg_rw___9(bool write , u32 reg , u64 val , int len )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_reg_rw.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_reg_rw.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )411);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_36546:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , bool , u32 , u64 , int ))it_func))(__data, (bool )((int )write),
                                                                   reg, val, len);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_36546;
      } else {
        goto ldv_36547;
      }
      ldv_36547: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
__inline static u32 i915_read32___9(struct drm_i915_private *dev_priv , u32 reg )
{ u32 val ;
  {
  val = 0U;
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        gen6_gt_force_wake_get(dev_priv);
        val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
        gen6_gt_force_wake_put(dev_priv);
        }
      } else {
        {
        val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
        }
      }
    } else {
      {
      val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
      }
    }
  } else {
    {
    val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
    }
  }
  {
  trace_i915_reg_rw___9((bool )0, reg, (u64 )val, 4);
  }
  return (val);
}
}
__inline static void i915_write32___7(struct drm_i915_private *dev_priv , u32 reg ,
                                      u32 val )
{
  {
  {
  trace_i915_reg_rw___9((bool )1, reg, (u64 )val, 4);
  }
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        __gen6_gt_wait_for_fifo(dev_priv);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  writel(val, (void volatile *)dev_priv->regs + (unsigned long )reg);
  }
  return;
}
}
static int panel_type ;
static void *find_section(struct bdb_header *bdb , int section_id )
{ u8 *base ;
  int index ;
  u16 total ;
  u16 current_size ;
  u8 current_id ;
  {
  base = (u8 *)bdb;
  index = 0;
  index = (int )bdb->header_size + index;
  total = bdb->bdb_size;
  goto ldv_37077;
  ldv_37076:
  current_id = *(base + (unsigned long )index);
  index = index + 1;
  current_size = *((u16 *)base + (unsigned long )index);
  index = index + 2;
  if ((int )current_id == section_id) {
    return ((void *)base + (unsigned long )index);
  } else {
  }
  index = (int )current_size + index;
  ldv_37077: ;
  if ((int )total > index) {
    goto ldv_37076;
  } else {
    goto ldv_37078;
  }
  ldv_37078: ;
  return ((void *)0);
}
}
static u16 get_blocksize(void *p )
{ u16 *block_ptr ;
  u16 block_size ;
  {
  block_ptr = (u16 *)p + 0x0ffffffffffffffeUL;
  block_size = *block_ptr;
  return (block_size);
}
}
static void fill_detail_timing_data(struct drm_display_mode *panel_fixed_mode , struct lvds_dvo_timing *dvo_timing )
{
  {
  panel_fixed_mode->hdisplay = ((int )dvo_timing->hactive_hi << 8) | (int )dvo_timing->hactive_lo;
  panel_fixed_mode->hsync_start = panel_fixed_mode->hdisplay + (((int )dvo_timing->hsync_off_hi << 8) | (int )dvo_timing->hsync_off_lo);
  panel_fixed_mode->hsync_end = panel_fixed_mode->hsync_start + (int )dvo_timing->hsync_pulse_width;
  panel_fixed_mode->htotal = panel_fixed_mode->hdisplay + (((int )dvo_timing->hblank_hi << 8) | (int )dvo_timing->hblank_lo);
  panel_fixed_mode->vdisplay = ((int )dvo_timing->vactive_hi << 8) | (int )dvo_timing->vactive_lo;
  panel_fixed_mode->vsync_start = panel_fixed_mode->vdisplay + (int )dvo_timing->vsync_off;
  panel_fixed_mode->vsync_end = panel_fixed_mode->vsync_start + (int )dvo_timing->vsync_pulse_width;
  panel_fixed_mode->vtotal = panel_fixed_mode->vdisplay + (((int )dvo_timing->vblank_hi << 8) | (int )dvo_timing->vblank_lo);
  panel_fixed_mode->clock = (int )dvo_timing->clock * 10;
  panel_fixed_mode->type = 8;
  if ((unsigned int )*((unsigned char *)dvo_timing + 17UL) != 0U) {
    panel_fixed_mode->flags = panel_fixed_mode->flags | 1U;
  } else {
    panel_fixed_mode->flags = panel_fixed_mode->flags | 2U;
  }
  if ((unsigned int )*((unsigned char *)dvo_timing + 17UL) != 0U) {
    panel_fixed_mode->flags = panel_fixed_mode->flags | 4U;
  } else {
    panel_fixed_mode->flags = panel_fixed_mode->flags | 8U;
  }
  if (panel_fixed_mode->hsync_end > panel_fixed_mode->htotal) {
    panel_fixed_mode->htotal = panel_fixed_mode->hsync_end + 1;
  } else {
  }
  if (panel_fixed_mode->vsync_end > panel_fixed_mode->vtotal) {
    panel_fixed_mode->vtotal = panel_fixed_mode->vsync_end + 1;
  } else {
  }
  {
  drm_mode_set_name(panel_fixed_mode);
  }
  return;
}
}
static void parse_lfp_panel_data(struct drm_i915_private *dev_priv , struct bdb_header *bdb )
{ struct bdb_lvds_options *lvds_options ;
  struct bdb_lvds_lfp_data *lvds_lfp_data ;
  struct bdb_lvds_lfp_data_ptrs *lvds_lfp_data_ptrs ;
  struct bdb_lvds_lfp_data_entry *entry ;
  struct lvds_dvo_timing *dvo_timing ;
  struct drm_display_mode *panel_fixed_mode ;
  int lfp_data_size ;
  int dvo_timing_offset ;
  int i ;
  int temp_downclock ;
  struct drm_display_mode *temp_mode ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  {
  {
  tmp = find_section(bdb, 40);
  lvds_options = (struct bdb_lvds_options *)tmp;
  }
  if ((unsigned long )lvds_options == (unsigned long )((struct bdb_lvds_options *)0)) {
    return;
  } else {
  }
  dev_priv->lvds_dither = lvds_options->pixel_dither;
  if ((unsigned int )lvds_options->panel_type == 255U) {
    return;
  } else {
  }
  {
  panel_type = (int )lvds_options->panel_type;
  tmp___0 = find_section(bdb, 42);
  lvds_lfp_data = (struct bdb_lvds_lfp_data *)tmp___0;
  }
  if ((unsigned long )lvds_lfp_data == (unsigned long )((struct bdb_lvds_lfp_data *)0)) {
    return;
  } else {
  }
  {
  tmp___1 = find_section(bdb, 41);
  lvds_lfp_data_ptrs = (struct bdb_lvds_lfp_data_ptrs *)tmp___1;
  }
  if ((unsigned long )lvds_lfp_data_ptrs == (unsigned long )((struct bdb_lvds_lfp_data_ptrs *)0)) {
    return;
  } else {
  }
  {
  dev_priv->lvds_vbt = (unsigned char)1;
  lfp_data_size = (int )lvds_lfp_data_ptrs->ptr[1].dvo_timing_offset - (int )lvds_lfp_data_ptrs->ptr[0].dvo_timing_offset;
  entry = (struct bdb_lvds_lfp_data_entry *)(& lvds_lfp_data->data) + (unsigned long )((int )lvds_options->panel_type * lfp_data_size);
  dvo_timing_offset = (int )lvds_lfp_data_ptrs->ptr[0].dvo_timing_offset - (int )lvds_lfp_data_ptrs->ptr[0].fp_timing_offset;
  dvo_timing = (struct lvds_dvo_timing *)entry + (unsigned long )dvo_timing_offset;
  tmp___2 = kzalloc(224UL, 208U);
  panel_fixed_mode = (struct drm_display_mode *)tmp___2;
  }
  if ((unsigned long )panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
    return;
  } else {
  }
  {
  fill_detail_timing_data(panel_fixed_mode, dvo_timing);
  dev_priv->lfp_lvds_vbt_mode = panel_fixed_mode;
  drm_ut_debug_printk(4U, "drm", "parse_lfp_panel_data", "Found panel mode in BIOS VBT tables:\n");
  drm_mode_debug_printmodeline(panel_fixed_mode);
  tmp___3 = kzalloc(224UL, 208U);
  temp_mode = (struct drm_display_mode *)tmp___3;
  temp_downclock = panel_fixed_mode->clock;
  i = 0;
  }
  goto ldv_37105;
  ldv_37104:
  {
  entry = (struct bdb_lvds_lfp_data_entry *)(& lvds_lfp_data->data) + (unsigned long )(lfp_data_size * i);
  dvo_timing = (struct lvds_dvo_timing *)entry + (unsigned long )dvo_timing_offset;
  fill_detail_timing_data(temp_mode, dvo_timing);
  }
  if (temp_mode->hdisplay == panel_fixed_mode->hdisplay) {
    if (temp_mode->hsync_start == panel_fixed_mode->hsync_start) {
      if (temp_mode->hsync_end == panel_fixed_mode->hsync_end) {
        if (temp_mode->htotal == panel_fixed_mode->htotal) {
          if (temp_mode->vdisplay == panel_fixed_mode->vdisplay) {
            if (temp_mode->vsync_start == panel_fixed_mode->vsync_start) {
              if (temp_mode->vsync_end == panel_fixed_mode->vsync_end) {
                if (temp_mode->vtotal == panel_fixed_mode->vtotal) {
                  if (temp_mode->clock < temp_downclock) {
                    temp_downclock = temp_mode->clock;
                  } else {
                  }
                } else {
                }
              } else {
              }
            } else {
            }
          } else {
          }
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  memset((void *)temp_mode, 0, 224UL);
  i = i + 1;
  }
  ldv_37105: ;
  if (i <= 15) {
    goto ldv_37104;
  } else {
    goto ldv_37106;
  }
  ldv_37106:
  {
  kfree((void const *)temp_mode);
  }
  if (panel_fixed_mode->clock > temp_downclock) {
    if (i915_lvds_downclock != 0U) {
      {
      dev_priv->lvds_downclock_avail = (bool )1;
      dev_priv->lvds_downclock = temp_downclock;
      drm_ut_debug_printk(4U, "drm", "parse_lfp_panel_data", "LVDS downclock is found in VBT. Normal Clock %dKHz, downclock %dKHz\n",
                          temp_downclock, panel_fixed_mode->clock);
      }
    } else {
    }
  } else {
  }
  return;
}
}
static void parse_sdvo_panel_data(struct drm_i915_private *dev_priv , struct bdb_header *bdb )
{ struct lvds_dvo_timing *dvo_timing ;
  struct drm_display_mode *panel_fixed_mode ;
  int index ;
  struct bdb_sdvo_lvds_options *sdvo_lvds_options ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  {
  index = i915_vbt_sdvo_panel_type;
  if (index == -1) {
    {
    tmp = find_section(bdb, 22);
    sdvo_lvds_options = (struct bdb_sdvo_lvds_options *)tmp;
    }
    if ((unsigned long )sdvo_lvds_options == (unsigned long )((struct bdb_sdvo_lvds_options *)0)) {
      return;
    } else {
    }
    index = (int )sdvo_lvds_options->panel_type;
  } else {
  }
  {
  tmp___0 = find_section(bdb, 23);
  dvo_timing = (struct lvds_dvo_timing *)tmp___0;
  }
  if ((unsigned long )dvo_timing == (unsigned long )((struct lvds_dvo_timing *)0)) {
    return;
  } else {
  }
  {
  tmp___1 = kzalloc(224UL, 208U);
  panel_fixed_mode = (struct drm_display_mode *)tmp___1;
  }
  if ((unsigned long )panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
    return;
  } else {
  }
  {
  fill_detail_timing_data(panel_fixed_mode, dvo_timing + (unsigned long )index);
  dev_priv->sdvo_lvds_vbt_mode = panel_fixed_mode;
  drm_ut_debug_printk(4U, "drm", "parse_sdvo_panel_data", "Found SDVO panel mode in BIOS VBT tables:\n");
  drm_mode_debug_printmodeline(panel_fixed_mode);
  }
  return;
}
}
static int intel_bios_ssc_frequency(struct drm_device *dev , bool alternate )
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 2) {
    goto case_2;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 3) {
    goto case_3;
  } else
  if ((int )(((struct drm_i915_private *)dev->dev_private)->info)->gen == 4) {
    goto case_4;
  } else {
    goto switch_default;
    if (0) {
      case_2: ;
      if ((int )alternate) {
        tmp = 66;
      } else {
        tmp = 48;
      }
      return (tmp);
      case_3: ;
      case_4: ;
      if ((int )alternate) {
        tmp___0 = 100;
      } else {
        tmp___0 = 96;
      }
      return (tmp___0);
      switch_default: ;
      if ((int )alternate) {
        tmp___1 = 100;
      } else {
        tmp___1 = 120;
      }
      return (tmp___1);
    } else {
    }
  }
}
}
static void parse_general_features(struct drm_i915_private *dev_priv , struct bdb_header *bdb )
{ struct drm_device *dev ;
  struct bdb_general_features *general ;
  void *tmp ;
  {
  {
  dev = dev_priv->dev;
  tmp = find_section(bdb, 1);
  general = (struct bdb_general_features *)tmp;
  }
  if ((unsigned long )general != (unsigned long )((struct bdb_general_features *)0)) {
    {
    dev_priv->int_tv_support = general->int_tv_support;
    dev_priv->int_crt_support = general->int_crt_support;
    dev_priv->lvds_use_ssc = general->enable_ssc;
    dev_priv->lvds_ssc_freq = intel_bios_ssc_frequency(dev, (bool )((unsigned int )*((unsigned char *)general + 1UL) != 0U));
    }
  } else {
  }
  return;
}
}
static void parse_general_definitions(struct drm_i915_private *dev_priv , struct bdb_header *bdb )
{ struct bdb_general_definitions *general ;
  void *tmp ;
  u16 block_size ;
  u16 tmp___0 ;
  int bus_pin ;
  {
  {
  tmp = find_section(bdb, 2);
  general = (struct bdb_general_definitions *)tmp;
  }
  if ((unsigned long )general != (unsigned long )((struct bdb_general_definitions *)0)) {
    {
    tmp___0 = get_blocksize((void *)general);
    block_size = tmp___0;
    }
    if ((unsigned int )block_size > 4U) {
      {
      bus_pin = (int )general->crt_ddc_gmbus_pin;
      drm_ut_debug_printk(4U, "drm", "parse_general_definitions", "crt_ddc_bus_pin: %d\n",
                          bus_pin);
      }
      if (bus_pin > 0) {
        if (bus_pin <= 6) {
          dev_priv->crt_ddc_pin = bus_pin;
        } else {
        }
      } else {
      }
    } else {
      {
      drm_ut_debug_printk(4U, "drm", "parse_general_definitions", "BDB_GD too small (%d). Invalid.\n",
                          (int )block_size);
      }
    }
  } else {
  }
  return;
}
}
static void parse_sdvo_device_mapping(struct drm_i915_private *dev_priv , struct bdb_header *bdb )
{ struct sdvo_device_mapping *p_mapping ;
  struct bdb_general_definitions *p_defs ;
  struct child_device_config *p_child ;
  int i ;
  int child_device_num ;
  int count ;
  u16 block_size ;
  void *tmp ;
  char *tmp___0 ;
  {
  {
  tmp = find_section(bdb, 2);
  p_defs = (struct bdb_general_definitions *)tmp;
  }
  if ((unsigned long )p_defs == (unsigned long )((struct bdb_general_definitions *)0)) {
    {
    drm_ut_debug_printk(4U, "drm", "parse_sdvo_device_mapping", "No general definition block is found, unable to construct sdvo mapping.\n");
    }
    return;
  } else {
  }
  if ((unsigned int )p_defs->child_dev_size != 33U) {
    {
    drm_ut_debug_printk(4U, "drm", "parse_sdvo_device_mapping", "different child size is found. Invalid.\n");
    }
    return;
  } else {
  }
  {
  block_size = get_blocksize((void *)p_defs);
  child_device_num = (int )(((unsigned long )block_size - 5UL) / 33UL);
  count = 0;
  i = 0;
  }
  goto ldv_37152;
  ldv_37151:
  p_child = (struct child_device_config *)(& p_defs->devices) + (unsigned long )i;
  if ((unsigned int )p_child->device_type == 0U) {
    goto ldv_37150;
  } else {
  }
  if ((unsigned int )p_child->slave_addr != 112U) {
    if ((unsigned int )p_child->slave_addr != 114U) {
      goto ldv_37150;
    } else {
    }
  } else {
  }
  if ((unsigned int )p_child->dvo_port != 1U) {
    if ((unsigned int )p_child->dvo_port != 2U) {
      {
      drm_ut_debug_printk(4U, "drm", "parse_sdvo_device_mapping", "Incorrect SDVO port. Skip it \n");
      }
      goto ldv_37150;
    } else {
    }
  } else {
  }
  if ((unsigned int )p_child->dvo_port == 1U) {
    tmp___0 = (char *)"SDVOB";
  } else {
    tmp___0 = (char *)"SDVOC";
  }
  {
  drm_ut_debug_printk(4U, "drm", "parse_sdvo_device_mapping", "the SDVO device with slave addr %2x is found on %s port\n",
                      (int )p_child->slave_addr, tmp___0);
  p_mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings) + ((unsigned long )p_child->dvo_port + 0x0fffffffffffffffUL);
  }
  if ((unsigned int )p_mapping->initialized == 0U) {
    {
    p_mapping->dvo_port = p_child->dvo_port;
    p_mapping->slave_addr = p_child->slave_addr;
    p_mapping->dvo_wiring = p_child->dvo_wiring;
    p_mapping->ddc_pin = p_child->ddc_pin;
    p_mapping->i2c_pin = p_child->i2c_pin;
    p_mapping->i2c_speed = p_child->i2c_speed;
    p_mapping->initialized = (u8 )1U;
    drm_ut_debug_printk(4U, "drm", "parse_sdvo_device_mapping", "SDVO device: dvo=%x, addr=%x, wiring=%d, ddc_pin=%d, i2c_pin=%d, i2c_speed=%d\n",
                        (int )p_mapping->dvo_port, (int )p_mapping->slave_addr, (int )p_mapping->dvo_wiring,
                        (int )p_mapping->ddc_pin, (int )p_mapping->i2c_pin, (int )p_mapping->i2c_speed);
    }
  } else {
    {
    drm_ut_debug_printk(4U, "drm", "parse_sdvo_device_mapping", "Maybe one SDVO port is shared by two SDVO device.\n");
    }
  }
  if ((unsigned int )p_child->slave2_addr != 0U) {
    {
    drm_ut_debug_printk(4U, "drm", "parse_sdvo_device_mapping", "there exists the slave2_addr. Maybe this is a SDVO device with multiple inputs.\n");
    }
  } else {
  }
  count = count + 1;
  ldv_37150:
  i = i + 1;
  ldv_37152: ;
  if (i < child_device_num) {
    goto ldv_37151;
  } else {
    goto ldv_37153;
  }
  ldv_37153: ;
  if (count == 0) {
    {
    drm_ut_debug_printk(4U, "drm", "parse_sdvo_device_mapping", "No SDVO device info is found in VBT\n");
    }
  } else {
  }
  return;
}
}
static void parse_driver_features(struct drm_i915_private *dev_priv , struct bdb_header *bdb )
{ struct drm_device *dev ;
  struct bdb_driver_features *driver___0 ;
  void *tmp ;
  {
  {
  dev = dev_priv->dev;
  tmp = find_section(bdb, 12);
  driver___0 = (struct bdb_driver_features *)tmp;
  }
  if ((unsigned long )driver___0 == (unsigned long )((struct bdb_driver_features *)0)) {
    return;
  } else {
  }
  if (dev->pci_device == 70) {
    if ((unsigned int )*((unsigned char *)driver___0 + 8UL) == 24U) {
      dev_priv->edp.support = (bool )1;
    } else {
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)driver___0 + 7UL) != 0U) {
    dev_priv->render_reclock_avail = (bool )1;
  } else {
  }
  return;
}
}
static void parse_edp(struct drm_i915_private *dev_priv , struct bdb_header *bdb )
{ struct bdb_edp *edp ;
  struct edp_power_seq *edp_pps ;
  struct edp_link_params *edp_link_params ;
  void *tmp ;
  {
  {
  tmp = find_section(bdb, 27);
  edp = (struct bdb_edp *)tmp;
  }
  if ((unsigned long )edp == (unsigned long )((struct bdb_edp *)0)) {
    if ((dev_priv->dev)->pci_device == 70) {
      if ((int )dev_priv->edp.support) {
        {
        drm_ut_debug_printk(4U, "drm", "parse_edp", "No eDP BDB found but eDP panel supported, assume %dbpp panel color depth.\n",
                            dev_priv->edp.bpp);
        }
      } else {
      }
    } else {
    }
    return;
  } else {
  }
  if ((int )((edp->color_depth >> panel_type * 2) & 3U) == 0) {
    goto case_0;
  } else
  if ((int )((edp->color_depth >> panel_type * 2) & 3U) == 1) {
    goto case_1;
  } else
  if ((int )((edp->color_depth >> panel_type * 2) & 3U) == 2) {
    goto case_2;
  } else
  if (0) {
    case_0:
    dev_priv->edp.bpp = 18;
    goto ldv_37169;
    case_1:
    dev_priv->edp.bpp = 24;
    goto ldv_37169;
    case_2:
    dev_priv->edp.bpp = 30;
    goto ldv_37169;
  } else {
  }
  ldv_37169:
  edp_pps = (struct edp_power_seq *)(& edp->power_seqs) + (unsigned long )panel_type;
  edp_link_params = (struct edp_link_params *)(& edp->link_params) + (unsigned long )panel_type;
  dev_priv->edp.pps = *edp_pps;
  if ((unsigned int )*((unsigned char *)edp_link_params + 0UL) != 0U) {
    dev_priv->edp.rate = 10;
  } else {
    dev_priv->edp.rate = 6;
  }
  if ((int )edp_link_params->lanes == 0) {
    goto case_0___0;
  } else
  if ((int )edp_link_params->lanes == 1) {
    goto case_1___0;
  } else
  if ((int )edp_link_params->lanes == 3) {
    goto case_3;
  } else {
    goto switch_default;
    if (0) {
      case_0___0:
      dev_priv->edp.lanes = 1;
      goto ldv_37173;
      case_1___0:
      dev_priv->edp.lanes = 2;
      goto ldv_37173;
      case_3: ;
      switch_default:
      dev_priv->edp.lanes = 4;
      goto ldv_37173;
    } else {
    }
  }
  ldv_37173: ;
  if ((int )edp_link_params->preemphasis == 0) {
    goto case_0___1;
  } else
  if ((int )edp_link_params->preemphasis == 1) {
    goto case_1___1;
  } else
  if ((int )edp_link_params->preemphasis == 2) {
    goto case_2___0;
  } else
  if ((int )edp_link_params->preemphasis == 3) {
    goto case_3___0;
  } else
  if (0) {
    case_0___1:
    dev_priv->edp.preemphasis = 0;
    goto ldv_37178;
    case_1___1:
    dev_priv->edp.preemphasis = 8;
    goto ldv_37178;
    case_2___0:
    dev_priv->edp.preemphasis = 16;
    goto ldv_37178;
    case_3___0:
    dev_priv->edp.preemphasis = 24;
    goto ldv_37178;
  } else {
  }
  ldv_37178: ;
  if ((int )edp_link_params->vswing == 0) {
    goto case_0___2;
  } else
  if ((int )edp_link_params->vswing == 1) {
    goto case_1___2;
  } else
  if ((int )edp_link_params->vswing == 2) {
    goto case_2___1;
  } else
  if ((int )edp_link_params->vswing == 3) {
    goto case_3___1;
  } else
  if (0) {
    case_0___2:
    dev_priv->edp.vswing = 0;
    goto ldv_37183;
    case_1___2:
    dev_priv->edp.vswing = 1;
    goto ldv_37183;
    case_2___1:
    dev_priv->edp.vswing = 2;
    goto ldv_37183;
    case_3___1:
    dev_priv->edp.vswing = 3;
    goto ldv_37183;
  } else {
  }
  ldv_37183: ;
  return;
}
}
static void parse_device_mapping(struct drm_i915_private *dev_priv , struct bdb_header *bdb )
{ struct bdb_general_definitions *p_defs ;
  struct child_device_config *p_child ;
  struct child_device_config *child_dev_ptr ;
  int i ;
  int child_device_num ;
  int count ;
  u16 block_size ;
  void *tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  {
  {
  tmp = find_section(bdb, 2);
  p_defs = (struct bdb_general_definitions *)tmp;
  }
  if ((unsigned long )p_defs == (unsigned long )((struct bdb_general_definitions *)0)) {
    {
    drm_ut_debug_printk(4U, "drm", "parse_device_mapping", "No general definition block is found, no devices defined.\n");
    }
    return;
  } else {
  }
  if ((unsigned int )p_defs->child_dev_size != 33U) {
    {
    drm_ut_debug_printk(4U, "drm", "parse_device_mapping", "different child size is found. Invalid.\n");
    }
    return;
  } else {
  }
  {
  block_size = get_blocksize((void *)p_defs);
  child_device_num = (int )(((unsigned long )block_size - 5UL) / 33UL);
  count = 0;
  i = 0;
  }
  goto ldv_37201;
  ldv_37200:
  p_child = (struct child_device_config *)(& p_defs->devices) + (unsigned long )i;
  if ((unsigned int )p_child->device_type == 0U) {
    goto ldv_37199;
  } else {
  }
  count = count + 1;
  ldv_37199:
  i = i + 1;
  ldv_37201: ;
  if (i < child_device_num) {
    goto ldv_37200;
  } else {
    goto ldv_37202;
  }
  ldv_37202: ;
  if (count == 0) {
    {
    drm_ut_debug_printk(4U, "drm", "parse_device_mapping", "no child dev is parsed from VBT \n");
    }
    return;
  } else {
  }
  {
  tmp___0 = kzalloc((unsigned long )count * 33UL, 208U);
  dev_priv->child_dev = (struct child_device_config *)tmp___0;
  }
  if ((unsigned long )dev_priv->child_dev == (unsigned long )((struct child_device_config *)0)) {
    {
    drm_ut_debug_printk(4U, "drm", "parse_device_mapping", "No memory space for child device\n");
    }
    return;
  } else {
  }
  dev_priv->child_dev_num = count;
  count = 0;
  i = 0;
  goto ldv_37208;
  ldv_37207:
  p_child = (struct child_device_config *)(& p_defs->devices) + (unsigned long )i;
  if ((unsigned int )p_child->device_type == 0U) {
    goto ldv_37203;
  } else {
  }
  child_dev_ptr = dev_priv->child_dev + (unsigned long )count;
  count = count + 1;
  __len = 33UL;
  if (__len > 63UL) {
    {
    __ret = memcpy((void *)child_dev_ptr, (void const *)p_child, __len);
    }
  } else {
    {
    __ret = memcpy((void *)child_dev_ptr, (void const *)p_child, __len);
    }
  }
  ldv_37203:
  i = i + 1;
  ldv_37208: ;
  if (i < child_device_num) {
    goto ldv_37207;
  } else {
    goto ldv_37209;
  }
  ldv_37209: ;
  return;
}
}
static void init_vbt_defaults(struct drm_i915_private *dev_priv )
{ struct drm_device *dev ;
  {
  {
  dev = dev_priv->dev;
  dev_priv->crt_ddc_pin = 2;
  dev_priv->lvds_dither = (unsigned char)1;
  dev_priv->lvds_vbt = (unsigned char)0;
  dev_priv->sdvo_lvds_vbt_mode = (struct drm_display_mode *)0;
  dev_priv->int_tv_support = (unsigned char)1;
  dev_priv->int_crt_support = (unsigned char)1;
  dev_priv->lvds_use_ssc = (unsigned char)1;
  dev_priv->lvds_ssc_freq = intel_bios_ssc_frequency(dev, (bool )1);
  drm_ut_debug_printk(1U, "drm", "init_vbt_defaults", "Set default to SSC at %dMHz\n",
                      dev_priv->lvds_ssc_freq);
  dev_priv->edp.bpp = 18;
  }
  return;
}
}
bool intel_parse_bios(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct pci_dev *pdev ;
  struct bdb_header *bdb ;
  u8 *bios ;
  struct vbt_header *vbt ;
  int tmp ;
  struct vbt_header *vbt___0 ;
  size_t size ;
  int i ;
  void *tmp___0 ;
  int tmp___1 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  pdev = dev->pdev;
  bdb = (struct bdb_header *)0;
  bios = (u8 *)0;
  init_vbt_defaults(dev_priv);
  }
  if ((unsigned long )dev_priv->opregion.vbt != (unsigned long )((void *)0)) {
    {
    vbt = (struct vbt_header *)dev_priv->opregion.vbt;
    tmp = memcmp((void const *)(& vbt->signature), (void const *)"$VBT", 4UL);
    }
    if (tmp == 0) {
      {
      drm_ut_debug_printk(2U, "drm", "intel_parse_bios", "Using VBT from OpRegion: %20s\n",
                          (u8 *)(& vbt->signature));
      bdb = (struct bdb_header *)vbt + (unsigned long )vbt->bdb_offset;
      }
    } else {
      dev_priv->opregion.vbt = (void *)0;
    }
  } else {
  }
  if ((unsigned long )bdb == (unsigned long )((struct bdb_header *)0)) {
    {
    vbt___0 = (struct vbt_header *)0;
    tmp___0 = pci_map_rom(pdev, & size);
    bios = (u8 *)tmp___0;
    }
    if ((unsigned long )bios == (unsigned long )((u8 *)0)) {
      return ((bool )1);
    } else {
    }
    i = 0;
    goto ldv_37229;
    ldv_37228:
    {
    tmp___1 = memcmp((void const *)bios + (unsigned long )i, (void const *)"$VBT",
                     4UL);
    }
    if (tmp___1 == 0) {
      vbt___0 = (struct vbt_header *)bios + (unsigned long )i;
      goto ldv_37227;
    } else {
    }
    i = i + 1;
    ldv_37229: ;
    if ((size_t )(i + 4) < size) {
      goto ldv_37228;
    } else {
      goto ldv_37227;
    }
    ldv_37227: ;
    if ((unsigned long )vbt___0 == (unsigned long )((struct vbt_header *)0)) {
      {
      drm_err("intel_parse_bios", "VBT signature missing\n");
      pci_unmap_rom(pdev, (void *)bios);
      }
      return ((bool )1);
    } else {
    }
    bdb = (struct bdb_header *)(bios + ((unsigned long )i + (unsigned long )vbt___0->bdb_offset));
  } else {
  }
  {
  parse_general_features(dev_priv, bdb);
  parse_general_definitions(dev_priv, bdb);
  parse_lfp_panel_data(dev_priv, bdb);
  parse_sdvo_panel_data(dev_priv, bdb);
  parse_sdvo_device_mapping(dev_priv, bdb);
  parse_device_mapping(dev_priv, bdb);
  parse_driver_features(dev_priv, bdb);
  parse_edp(dev_priv, bdb);
  }
  if ((unsigned long )bios != (unsigned long )((u8 *)0)) {
    {
    pci_unmap_rom(pdev, (void *)bios);
    }
  } else {
  }
  return ((bool )0);
}
}
void intel_setup_bios(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 tmp ;
  u32 tmp___0 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = i915_read32___9(dev_priv, 397832U);
  }
  if (tmp == 0U) {
    {
    tmp___0 = i915_read32___9(dev_priv, 397836U);
    }
    if (tmp___0 == 0U) {
      {
      i915_write32___7(dev_priv, 397832U, 26216400U);
      i915_write32___7(dev_priv, 397836U, 22939600U);
      }
    } else {
    }
  } else {
  }
  return;
}
}
extern char *strncpy(char * , char const * , __kernel_size_t ) ;
extern int i2c_del_adapter(struct i2c_adapter * ) ;
extern int drm_connector_property_set_value(struct drm_connector * , struct drm_property * ,
                                            uint64_t ) ;
extern bool drm_detect_monitor_audio(struct edid * ) ;
__inline static void trace_i915_reg_rw___10(bool write , u32 reg , u64 val , int len )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_reg_rw.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_reg_rw.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )411);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_36374:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , bool , u32 , u64 , int ))it_func))(__data, (bool )((int )write),
                                                                   reg, val, len);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_36374;
      } else {
        goto ldv_36375;
      }
      ldv_36375: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
__inline static u32 i915_read32___10(struct drm_i915_private *dev_priv , u32 reg )
{ u32 val ;
  {
  val = 0U;
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        gen6_gt_force_wake_get(dev_priv);
        val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
        gen6_gt_force_wake_put(dev_priv);
        }
      } else {
        {
        val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
        }
      }
    } else {
      {
      val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
      }
    }
  } else {
    {
    val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
    }
  }
  {
  trace_i915_reg_rw___10((bool )0, reg, (u64 )val, 4);
  }
  return (val);
}
}
__inline static void i915_write32___8(struct drm_i915_private *dev_priv , u32 reg ,
                                      u32 val )
{
  {
  {
  trace_i915_reg_rw___10((bool )1, reg, (u64 )val, 4);
  }
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        __gen6_gt_wait_for_fifo(dev_priv);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  writel(val, (void volatile *)dev_priv->regs + (unsigned long )reg);
  }
  return;
}
}
void intel_attach_force_audio_property(struct drm_connector *connector ) ;
void intel_attach_broadcast_rgb_property(struct drm_connector *connector ) ;
extern int i2c_dp_aux_add_bus(struct i2c_adapter * ) ;
static bool is_edp(struct intel_dp *intel_dp )
{
  {
  return ((bool )(intel_dp->base.type == 8));
}
}
static bool is_pch_edp(struct intel_dp *intel_dp )
{
  {
  return (intel_dp->is_pch_edp);
}
}
static struct intel_dp *enc_to_intel_dp(struct drm_encoder *encoder )
{ struct drm_encoder const *__mptr ;
  {
  __mptr = (struct drm_encoder const *)encoder;
  return ((struct intel_dp *)__mptr);
}
}
static struct intel_dp *intel_attached_dp(struct drm_connector *connector )
{ struct intel_encoder const *__mptr ;
  struct intel_encoder *tmp ;
  {
  {
  tmp = intel_attached_encoder(connector);
  __mptr = (struct intel_encoder const *)tmp;
  }
  return ((struct intel_dp *)__mptr);
}
}
bool intel_encoder_is_pch_edp(struct drm_encoder *encoder )
{ struct intel_dp *intel_dp ;
  bool tmp ;
  {
  if ((unsigned long )encoder == (unsigned long )((struct drm_encoder *)0)) {
    return ((bool )0);
  } else {
  }
  {
  intel_dp = enc_to_intel_dp(encoder);
  tmp = is_pch_edp(intel_dp);
  }
  return (tmp);
}
}
static void intel_dp_start_link_train(struct intel_dp *intel_dp ) ;
static void intel_dp_complete_link_train(struct intel_dp *intel_dp ) ;
static void intel_dp_link_down(struct intel_dp *intel_dp ) ;
void intel_edp_link_config(struct intel_encoder *intel_encoder , int *lane_num , int *link_bw )
{ struct intel_dp *intel_dp ;
  struct intel_encoder const *__mptr ;
  {
  __mptr = (struct intel_encoder const *)intel_encoder;
  intel_dp = (struct intel_dp *)__mptr;
  *lane_num = (int )intel_dp->lane_count;
  if ((unsigned int )intel_dp->link_bw == 6U) {
    *link_bw = 162000;
  } else
  if ((unsigned int )intel_dp->link_bw == 10U) {
    *link_bw = 270000;
  } else {
  }
  return;
}
}
static int intel_dp_max_lane_count(struct intel_dp *intel_dp )
{ int max_lane_count ;
  {
  max_lane_count = 4;
  if ((unsigned int )intel_dp->dpcd[0] > 16U) {
    max_lane_count = (int )intel_dp->dpcd[2] & 31;
    if (max_lane_count == 1) {
      goto case_1;
    } else
    if (max_lane_count == 2) {
      goto case_2;
    } else
    if (max_lane_count == 4) {
      goto case_4;
    } else {
      goto switch_default;
      if (0) {
        case_1: ;
        case_2: ;
        case_4: ;
        goto ldv_37615;
        switch_default:
        max_lane_count = 4;
      } else {
      }
    }
    ldv_37615: ;
  } else {
  }
  return (max_lane_count);
}
}
static int intel_dp_max_link_bw(struct intel_dp *intel_dp )
{ int max_link_bw ;
  {
  max_link_bw = (int )intel_dp->dpcd[1];
  if (max_link_bw == 6) {
    goto case_6;
  } else
  if (max_link_bw == 10) {
    goto case_10;
  } else {
    goto switch_default;
    if (0) {
      case_6: ;
      case_10: ;
      goto ldv_37623;
      switch_default:
      max_link_bw = 6;
      goto ldv_37623;
    } else {
    }
  }
  ldv_37623: ;
  return (max_link_bw);
}
}
static int intel_dp_link_clock(uint8_t link_bw )
{
  {
  if ((unsigned int )link_bw == 10U) {
    return (270000);
  } else {
    return (162000);
  }
}
}
static int intel_dp_link_required(struct drm_device *dev , struct intel_dp *intel_dp ,
                                  int pixel_clock )
{ struct drm_i915_private *dev_priv ;
  bool tmp ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = is_edp(intel_dp);
  }
  if ((int )tmp) {
    return ((dev_priv->edp.bpp * pixel_clock + 7) / 8);
  } else {
    return (pixel_clock * 3);
  }
}
}
static int intel_dp_max_data_rate(int max_link_clock , int max_lanes )
{
  {
  return (((max_link_clock * max_lanes) * 8) / 10);
}
}
static int intel_dp_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode )
{ struct intel_dp *intel_dp ;
  struct intel_dp *tmp ;
  struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  int max_link_clock ;
  int tmp___0 ;
  int tmp___1 ;
  int max_lanes ;
  int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  {
  {
  tmp = intel_attached_dp(connector);
  intel_dp = tmp;
  dev = connector->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp___0 = intel_dp_max_link_bw(intel_dp);
  tmp___1 = intel_dp_link_clock((uint8_t )((int )((uint8_t )tmp___0)));
  max_link_clock = tmp___1;
  tmp___2 = intel_dp_max_lane_count(intel_dp);
  max_lanes = tmp___2;
  tmp___3 = is_edp(intel_dp);
  }
  if ((int )tmp___3) {
    if ((unsigned long )dev_priv->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
      if (mode->hdisplay > (dev_priv->panel_fixed_mode)->hdisplay) {
        return (29);
      } else {
      }
      if (mode->vdisplay > (dev_priv->panel_fixed_mode)->vdisplay) {
        return (29);
      } else {
      }
    } else {
    }
  } else {
  }
  {
  tmp___4 = is_edp(intel_dp);
  }
  if (tmp___4) {
    tmp___5 = 0;
  } else {
    tmp___5 = 1;
  }
  if (tmp___5) {
    {
    tmp___6 = intel_dp_link_required(connector->dev, intel_dp, mode->clock);
    tmp___7 = intel_dp_max_data_rate(max_link_clock, max_lanes);
    }
    if (tmp___6 > tmp___7) {
      return (15);
    } else {
    }
  } else {
  }
  if (mode->clock <= 9999) {
    return (16);
  } else {
  }
  return (0);
}
}
static uint32_t pack_aux(uint8_t *src , int src_bytes )
{ int i ;
  uint32_t v ;
  {
  v = 0U;
  if (src_bytes > 4) {
    src_bytes = 4;
  } else {
  }
  i = 0;
  goto ldv_37654;
  ldv_37653:
  v = ((unsigned int )*(src + (unsigned long )i) << (3 - i) * 8) | v;
  i = i + 1;
  ldv_37654: ;
  if (i < src_bytes) {
    goto ldv_37653;
  } else {
    goto ldv_37655;
  }
  ldv_37655: ;
  return (v);
}
}
static void unpack_aux(uint32_t src , uint8_t *dst , int dst_bytes )
{ int i ;
  {
  if (dst_bytes > 4) {
    dst_bytes = 4;
  } else {
  }
  i = 0;
  goto ldv_37663;
  ldv_37662:
  *(dst + (unsigned long )i) = (uint8_t )(src >> (3 - i) * 8);
  i = i + 1;
  ldv_37663: ;
  if (i < dst_bytes) {
    goto ldv_37662;
  } else {
    goto ldv_37664;
  }
  ldv_37664: ;
  return;
}
}
static int intel_hrawclk(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  uint32_t clkcfg ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  clkcfg = i915_read32___10(dev_priv, 68608U);
  }
  if ((int )(clkcfg & 7U) == 5) {
    goto case_5;
  } else
  if ((int )(clkcfg & 7U) == 1) {
    goto case_1;
  } else
  if ((int )(clkcfg & 7U) == 3) {
    goto case_3;
  } else
  if ((int )(clkcfg & 7U) == 2) {
    goto case_2;
  } else
  if ((int )(clkcfg & 7U) == 6) {
    goto case_6;
  } else
  if ((int )(clkcfg & 7U) == 7) {
    goto case_7;
  } else
  if ((int )(clkcfg & 7U) == 4) {
    goto case_4;
  } else
  if ((int )(clkcfg & 7U) == 0) {
    goto case_0;
  } else {
    goto switch_default;
    if (0) {
      case_5: ;
      return (100);
      case_1: ;
      return (133);
      case_3: ;
      return (166);
      case_2: ;
      return (200);
      case_6: ;
      return (266);
      case_7: ;
      return (333);
      case_4: ;
      case_0: ;
      return (400);
      switch_default: ;
      return (133);
    } else {
    }
  }
}
}
static int intel_dp_aux_ch(struct intel_dp *intel_dp , uint8_t *send , int send_bytes ,
                           uint8_t *recv , int recv_size )
{ uint32_t output_reg ;
  struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  uint32_t ch_ctl ;
  uint32_t ch_data ;
  int i ;
  int recv_bytes ;
  uint32_t status ;
  uint32_t aux_clock_divider ;
  int try ;
  int precharge ;
  int tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  uint32_t tmp___5 ;
  u32 tmp___6 ;
  {
  {
  output_reg = intel_dp->output_reg;
  dev = intel_dp->base.base.dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  ch_ctl = output_reg + 16U;
  ch_data = ch_ctl + 4U;
  tmp___0 = is_edp(intel_dp);
  }
  if ((int )tmp___0) {
    {
    tmp___1 = is_pch_edp(intel_dp);
    }
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    if (tmp___2) {
      if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
        aux_clock_divider = 200U;
      } else {
        aux_clock_divider = 225U;
      }
    } else {
      goto _L;
    }
  } else
  _L:
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    aux_clock_divider = 62U;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    aux_clock_divider = 62U;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    aux_clock_divider = 62U;
  } else {
    {
    tmp = intel_hrawclk(dev);
    aux_clock_divider = (uint32_t )(tmp / 2);
    }
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    precharge = 3;
  } else {
    precharge = 5;
  }
  {
  tmp___4 = i915_read32___10(dev_priv, ch_ctl);
  }
  if ((int )tmp___4 < 0) {
    {
    tmp___3 = i915_read32___10(dev_priv, ch_ctl);
    drm_err("intel_dp_aux_ch", "dp_aux_ch not started status 0x%08x\n", tmp___3);
    }
    return (-16);
  } else {
  }
  try = 0;
  goto ldv_37705;
  ldv_37704:
  i = 0;
  goto ldv_37699;
  ldv_37698:
  {
  tmp___5 = pack_aux(send + (unsigned long )i, send_bytes - i);
  i915_write32___8(dev_priv, ch_data + (uint32_t )i, tmp___5);
  i = i + 4;
  }
  ldv_37699: ;
  if (i < send_bytes) {
    goto ldv_37698;
  } else {
    goto ldv_37700;
  }
  ldv_37700:
  {
  i915_write32___8(dev_priv, ch_ctl, ((uint32_t )(((send_bytes << 20) | (-0x7FFFFFFF-1)) | (precharge << 16)) | aux_clock_divider) | 1375731712U);
  }
  ldv_37702:
  {
  status = i915_read32___10(dev_priv, ch_ctl);
  }
  if ((int )status >= 0) {
    goto ldv_37701;
  } else {
  }
  {
  __const_udelay(429500UL);
  }
  goto ldv_37702;
  ldv_37701:
  {
  i915_write32___8(dev_priv, ch_ctl, status | 1375731712U);
  }
  if ((status & 1073741824U) != 0U) {
    goto ldv_37703;
  } else {
  }
  try = try + 1;
  ldv_37705: ;
  if (try <= 4) {
    goto ldv_37704;
  } else {
    goto ldv_37703;
  }
  ldv_37703: ;
  if ((status & 1073741824U) == 0U) {
    {
    drm_err("intel_dp_aux_ch", "dp_aux_ch not done status 0x%08x\n", status);
    }
    return (-16);
  } else {
  }
  if ((status & 33554432U) != 0U) {
    {
    drm_err("intel_dp_aux_ch", "dp_aux_ch receive error status 0x%08x\n", status);
    }
    return (-5);
  } else {
  }
  if ((status & 268435456U) != 0U) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_dp_aux_ch", "dp_aux_ch timeout status 0x%08x\n",
                        status);
    }
    return (-110);
  } else {
  }
  recv_bytes = (int )((status & 32505856U) >> 20);
  if (recv_bytes > recv_size) {
    recv_bytes = recv_size;
  } else {
  }
  i = 0;
  goto ldv_37707;
  ldv_37706:
  {
  tmp___6 = i915_read32___10(dev_priv, ch_data + (uint32_t )i);
  unpack_aux(tmp___6, recv + (unsigned long )i, recv_bytes - i);
  i = i + 4;
  }
  ldv_37707: ;
  if (i < recv_bytes) {
    goto ldv_37706;
  } else {
    goto ldv_37708;
  }
  ldv_37708: ;
  return (recv_bytes);
}
}
static int intel_dp_aux_native_write(struct intel_dp *intel_dp , uint16_t address ,
                                     uint8_t *send , int send_bytes )
{ int ret ;
  uint8_t msg[20U] ;
  int msg_bytes ;
  uint8_t ack ;
  size_t __len ;
  void *__ret ;
  {
  if (send_bytes > 16) {
    return (-1);
  } else {
  }
  {
  msg[0] = (uint8_t )128U;
  msg[1] = (uint8_t )((int )address >> 8);
  msg[2] = (uint8_t )address;
  msg[3] = (uint8_t )((unsigned int )((uint8_t )send_bytes) + 255U);
  __len = (size_t )send_bytes;
  __ret = memcpy((void *)(& msg) + 4U, (void const *)send, __len);
  msg_bytes = send_bytes + 4;
  }
  ldv_37723:
  {
  ret = intel_dp_aux_ch(intel_dp, (uint8_t *)(& msg), msg_bytes, & ack, 1);
  }
  if (ret < 0) {
    return (ret);
  } else {
  }
  if (((int )ack & 48) == 0) {
    goto ldv_37722;
  } else
  if (((int )ack & 48) == 32) {
    {
    __const_udelay(429500UL);
    }
  } else {
    return (-5);
  }
  goto ldv_37723;
  ldv_37722: ;
  return (send_bytes);
}
}
static int intel_dp_aux_native_write_1(struct intel_dp *intel_dp , uint16_t address ,
                                       uint8_t byte )
{ int tmp ;
  {
  {
  tmp = intel_dp_aux_native_write(intel_dp, (uint16_t )((int )address), & byte, 1);
  }
  return (tmp);
}
}
static int intel_dp_aux_native_read(struct intel_dp *intel_dp , uint16_t address ,
                                    uint8_t *recv , int recv_bytes )
{ uint8_t msg[4U] ;
  int msg_bytes ;
  uint8_t reply[20U] ;
  int reply_bytes ;
  uint8_t ack ;
  int ret ;
  size_t __len ;
  void *__ret ;
  {
  msg[0] = (uint8_t )144U;
  msg[1] = (uint8_t )((int )address >> 8);
  msg[2] = (uint8_t )address;
  msg[3] = (uint8_t )((unsigned int )((uint8_t )recv_bytes) + 255U);
  msg_bytes = 4;
  reply_bytes = recv_bytes + 1;
  ldv_37744:
  {
  ret = intel_dp_aux_ch(intel_dp, (uint8_t *)(& msg), msg_bytes, (uint8_t *)(& reply),
                        reply_bytes);
  }
  if (ret == 0) {
    return (-71);
  } else {
  }
  if (ret < 0) {
    return (ret);
  } else {
  }
  ack = reply[0];
  if (((int )ack & 48) == 0) {
    {
    __len = (size_t )(ret + -1);
    __ret = memcpy((void *)recv, (void const *)(& reply) + 1U, __len);
    }
    return (ret + -1);
  } else
  if (((int )ack & 48) == 32) {
    {
    __const_udelay(429500UL);
    }
  } else {
    return (-5);
  }
  goto ldv_37744;
}
}
static int intel_dp_i2c_aux_ch(struct i2c_adapter *adapter , int mode , uint8_t write_byte ,
                               uint8_t *read_byte )
{ struct i2c_algo_dp_aux_data *algo_data ;
  struct intel_dp *intel_dp ;
  struct i2c_adapter const *__mptr ;
  uint16_t address ;
  uint8_t msg[5U] ;
  uint8_t reply[2U] ;
  unsigned int retry ;
  int msg_bytes ;
  int reply_bytes ;
  int ret ;
  {
  algo_data = (struct i2c_algo_dp_aux_data *)adapter->algo_data;
  __mptr = (struct i2c_adapter const *)adapter;
  intel_dp = (struct intel_dp *)__mptr + 0x0fffffffffffff78UL;
  address = algo_data->address;
  if ((mode & 4) != 0) {
    msg[0] = (uint8_t )16U;
  } else {
    msg[0] = (uint8_t )0U;
  }
  if ((mode & 8) == 0) {
    msg[0] = (uint8_t )((unsigned int )msg[0] | 64U);
  } else {
  }
  msg[1] = (uint8_t )((int )address >> 8);
  msg[2] = (uint8_t )address;
  if (mode == 2) {
    goto case_2;
  } else
  if (mode == 4) {
    goto case_4;
  } else {
    goto switch_default;
    if (0) {
      case_2:
      msg[3] = (uint8_t )0U;
      msg[4] = write_byte;
      msg_bytes = 5;
      reply_bytes = 1;
      goto ldv_37763;
      case_4:
      msg[3] = (uint8_t )0U;
      msg_bytes = 4;
      reply_bytes = 2;
      goto ldv_37763;
      switch_default:
      msg_bytes = 3;
      reply_bytes = 1;
      goto ldv_37763;
    } else {
    }
  }
  ldv_37763:
  retry = 0U;
  goto ldv_37779;
  ldv_37778:
  {
  ret = intel_dp_aux_ch(intel_dp, (uint8_t *)(& msg), msg_bytes, (uint8_t *)(& reply),
                        reply_bytes);
  }
  if (ret < 0) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_dp_i2c_aux_ch", "aux_ch failed %d\n", ret);
    }
    return (ret);
  } else {
  }
  if (((int )reply[0] & 48) == 0) {
    goto case_0;
  } else
  if (((int )reply[0] & 48) == 16) {
    goto case_16;
  } else
  if (((int )reply[0] & 48) == 32) {
    goto case_32;
  } else {
    goto switch_default___0;
    if (0) {
      case_0: ;
      goto ldv_37768;
      case_16:
      {
      drm_ut_debug_printk(4U, "drm", "intel_dp_i2c_aux_ch", "aux_ch native nack\n");
      }
      return (-121);
      case_32:
      {
      __const_udelay(429500UL);
      }
      goto ldv_37771;
      switch_default___0:
      {
      drm_err("intel_dp_i2c_aux_ch", "aux_ch invalid native reply 0x%02x\n", (int )reply[0]);
      }
      return (-121);
    } else {
    }
  }
  ldv_37768: ;
  if (((int )reply[0] & 192) == 0) {
    goto case_0___0;
  } else
  if (((int )reply[0] & 192) == 64) {
    goto case_64;
  } else
  if (((int )reply[0] & 192) == 128) {
    goto case_128;
  } else {
    goto switch_default___1;
    if (0) {
      case_0___0: ;
      if (mode == 4) {
        *read_byte = reply[1];
      } else {
      }
      return (reply_bytes + -1);
      case_64:
      {
      drm_ut_debug_printk(4U, "drm", "intel_dp_i2c_aux_ch", "aux_i2c nack\n");
      }
      return (-121);
      case_128:
      {
      drm_ut_debug_printk(4U, "drm", "intel_dp_i2c_aux_ch", "aux_i2c defer\n");
      __const_udelay(429500UL);
      }
      goto ldv_37776;
      switch_default___1:
      {
      drm_err("intel_dp_i2c_aux_ch", "aux_i2c invalid reply 0x%02x\n", (int )reply[0]);
      }
      return (-121);
    } else {
    }
  }
  ldv_37776: ;
  ldv_37771:
  retry = retry + 1U;
  ldv_37779: ;
  if (retry <= 4U) {
    goto ldv_37778;
  } else {
    goto ldv_37780;
  }
  ldv_37780:
  {
  drm_err("intel_dp_i2c_aux_ch", "too many retries, giving up\n");
  }
  return (-121);
}
}
static int intel_dp_i2c_init(struct intel_dp *intel_dp , struct intel_connector *intel_connector ,
                             char const *name )
{ int tmp ;
  {
  {
  drm_ut_debug_printk(4U, "drm", "intel_dp_i2c_init", "i2c_init %s\n", name);
  intel_dp->algo.running = (bool )0;
  intel_dp->algo.address = (u16 )0U;
  intel_dp->algo.aux_ch = & intel_dp_i2c_aux_ch;
  memset((void *)(& intel_dp->adapter), 0, 1640UL);
  intel_dp->adapter.owner = & __this_module;
  intel_dp->adapter.class = 8U;
  strncpy((char *)(& intel_dp->adapter.name), name, 47UL);
  intel_dp->adapter.name[47UL] = (char)0;
  intel_dp->adapter.algo_data = (void *)(& intel_dp->algo);
  intel_dp->adapter.dev.parent = & intel_connector->base.kdev;
  tmp = i2c_dp_aux_add_bus(& intel_dp->adapter);
  }
  return (tmp);
}
}
static bool intel_dp_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                struct drm_display_mode *adjusted_mode )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_dp *intel_dp ;
  struct intel_dp *tmp ;
  int lane_count ;
  int clock ;
  int max_lane_count ;
  int tmp___0 ;
  int max_clock ;
  int tmp___1 ;
  int bws[2U] ;
  bool tmp___2 ;
  int link_avail ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  {
  {
  dev = encoder->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = enc_to_intel_dp(encoder);
  intel_dp = tmp;
  tmp___0 = intel_dp_max_lane_count(intel_dp);
  max_lane_count = tmp___0;
  tmp___1 = intel_dp_max_link_bw(intel_dp);
  max_clock = tmp___1 == 10;
  bws[0] = 6;
  bws[1] = 10;
  tmp___2 = is_edp(intel_dp);
  }
  if ((int )tmp___2) {
    if ((unsigned long )dev_priv->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
      {
      intel_fixed_panel_mode(dev_priv->panel_fixed_mode, adjusted_mode);
      intel_pch_panel_fitting(dev, 1, mode, adjusted_mode);
      mode->clock = (dev_priv->panel_fixed_mode)->clock;
      }
    } else {
    }
  } else {
  }
  lane_count = 1;
  goto ldv_37806;
  ldv_37805:
  clock = 0;
  goto ldv_37803;
  ldv_37802:
  {
  tmp___3 = intel_dp_link_clock((uint8_t )((int )((uint8_t )bws[clock])));
  tmp___4 = intel_dp_max_data_rate(tmp___3, lane_count);
  link_avail = tmp___4;
  tmp___5 = intel_dp_link_required(encoder->dev, intel_dp, mode->clock);
  }
  if (tmp___5 <= link_avail) {
    {
    intel_dp->link_bw = (uint8_t )bws[clock];
    intel_dp->lane_count = (uint8_t )lane_count;
    adjusted_mode->clock = intel_dp_link_clock((uint8_t )((int )intel_dp->link_bw));
    drm_ut_debug_printk(4U, "drm", "intel_dp_mode_fixup", "Display port link bw %02x lane count %d clock %d\n",
                        (int )intel_dp->link_bw, (int )intel_dp->lane_count, adjusted_mode->clock);
    }
    return ((bool )1);
  } else {
  }
  clock = clock + 1;
  ldv_37803: ;
  if (clock <= max_clock) {
    goto ldv_37802;
  } else {
    goto ldv_37804;
  }
  ldv_37804:
  lane_count = lane_count << 1;
  ldv_37806: ;
  if (lane_count <= max_lane_count) {
    goto ldv_37805;
  } else {
    goto ldv_37807;
  }
  ldv_37807:
  {
  tmp___6 = is_edp(intel_dp);
  }
  if ((int )tmp___6) {
    {
    intel_dp->lane_count = (uint8_t )max_lane_count;
    intel_dp->link_bw = (uint8_t )bws[max_clock];
    adjusted_mode->clock = intel_dp_link_clock((uint8_t )((int )intel_dp->link_bw));
    drm_ut_debug_printk(4U, "drm", "intel_dp_mode_fixup", "Force picking display port link bw %02x lane count %d clock %d\n",
                        (int )intel_dp->link_bw, (int )intel_dp->lane_count, adjusted_mode->clock);
    }
    return ((bool )1);
  } else {
  }
  return ((bool )0);
}
}
static void intel_reduce_ratio(uint32_t *num , uint32_t *den )
{
  {
  goto ldv_37819;
  ldv_37818:
  *num = *num >> 1;
  *den = *den >> 1;
  ldv_37819: ;
  if (*num > 16777215U) {
    goto ldv_37818;
  } else
  if (*den > 16777215U) {
    goto ldv_37818;
  } else {
    goto ldv_37820;
  }
  ldv_37820: ;
  return;
}
}
static void intel_dp_compute_m_n(int bpp , int nlanes , int pixel_clock , int link_clock ,
                                 struct intel_dp_m_n *m_n )
{
  {
  {
  m_n->tu = 64U;
  m_n->gmch_m = (uint32_t )(pixel_clock * bpp >> 3);
  m_n->gmch_n = (uint32_t )(link_clock * nlanes);
  intel_reduce_ratio(& m_n->gmch_m, & m_n->gmch_n);
  m_n->link_m = (uint32_t )pixel_clock;
  m_n->link_n = (uint32_t )link_clock;
  intel_reduce_ratio(& m_n->link_m, & m_n->link_n);
  }
  return;
}
}
void intel_dp_set_m_n(struct drm_crtc *crtc , struct drm_display_mode *mode , struct drm_display_mode *adjusted_mode )
{ struct drm_device *dev ;
  struct drm_mode_config *mode_config ;
  struct drm_encoder *encoder ;
  struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int lane_count ;
  int bpp ;
  struct intel_dp_m_n m_n ;
  int pipe ;
  struct list_head const *__mptr___0 ;
  struct intel_dp *intel_dp ;
  bool tmp ;
  struct list_head const *__mptr___1 ;
  {
  dev = crtc->dev;
  mode_config = & dev->mode_config;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  lane_count = 4;
  bpp = 24;
  pipe = (int )intel_crtc->pipe;
  __mptr___0 = (struct list_head const *)mode_config->encoder_list.next;
  encoder = (struct drm_encoder *)__mptr___0 + 0x0ffffffffffffff8UL;
  goto ldv_37852;
  ldv_37851: ;
  if ((unsigned long )encoder->crtc != (unsigned long )crtc) {
    goto ldv_37849;
  } else {
  }
  {
  intel_dp = enc_to_intel_dp(encoder);
  }
  if (intel_dp->base.type == 7) {
    lane_count = (int )intel_dp->lane_count;
    goto ldv_37850;
  } else {
    {
    tmp = is_edp(intel_dp);
    }
    if ((int )tmp) {
      lane_count = dev_priv->edp.lanes;
      bpp = dev_priv->edp.bpp;
      goto ldv_37850;
    } else {
    }
  }
  ldv_37849:
  __mptr___1 = (struct list_head const *)encoder->head.next;
  encoder = (struct drm_encoder *)__mptr___1 + 0x0ffffffffffffff8UL;
  ldv_37852: ;
  if ((unsigned long )(& encoder->head) != (unsigned long )(& mode_config->encoder_list)) {
    goto ldv_37851;
  } else {
    goto ldv_37850;
  }
  ldv_37850:
  {
  intel_dp_compute_m_n(bpp, lane_count, mode->clock, adjusted_mode->clock, & m_n);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    i915_write32___8(dev_priv, (u32 )(pipe * 4096 + 917552), ((m_n.tu - 1U) << 25) | m_n.gmch_m);
    i915_write32___8(dev_priv, (u32 )(pipe * 4096 + 917556), m_n.gmch_n);
    i915_write32___8(dev_priv, (u32 )(pipe * 4096 + 917568), m_n.link_m);
    i915_write32___8(dev_priv, (u32 )(pipe * 4096 + 917572), m_n.link_n);
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    i915_write32___8(dev_priv, (u32 )(pipe * 4096 + 917552), ((m_n.tu - 1U) << 25) | m_n.gmch_m);
    i915_write32___8(dev_priv, (u32 )(pipe * 4096 + 917556), m_n.gmch_n);
    i915_write32___8(dev_priv, (u32 )(pipe * 4096 + 917568), m_n.link_m);
    i915_write32___8(dev_priv, (u32 )(pipe * 4096 + 917572), m_n.link_n);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    i915_write32___8(dev_priv, (u32 )(pipe * 4096 + 917552), ((m_n.tu - 1U) << 25) | m_n.gmch_m);
    i915_write32___8(dev_priv, (u32 )(pipe * 4096 + 917556), m_n.gmch_n);
    i915_write32___8(dev_priv, (u32 )(pipe * 4096 + 917568), m_n.link_m);
    i915_write32___8(dev_priv, (u32 )(pipe * 4096 + 917572), m_n.link_n);
    }
  } else {
    {
    i915_write32___8(dev_priv, (u32 )(pipe * 4096 + 458832), ((m_n.tu - 1U) << 25) | m_n.gmch_m);
    i915_write32___8(dev_priv, (u32 )(pipe * 4096 + 458836), m_n.gmch_n);
    i915_write32___8(dev_priv, (u32 )(pipe * 4096 + 458848), m_n.link_m);
    i915_write32___8(dev_priv, (u32 )(pipe * 4096 + 458852), m_n.link_n);
    }
  }
  return;
}
}
static void intel_dp_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                              struct drm_display_mode *adjusted_mode )
{ struct drm_device *dev ;
  struct intel_dp *intel_dp ;
  struct intel_dp *tmp ;
  struct drm_crtc *crtc ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  {
  {
  dev = encoder->dev;
  tmp = enc_to_intel_dp(encoder);
  intel_dp = tmp;
  crtc = intel_dp->base.base.crtc;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  intel_dp->DP = 0U;
  intel_dp->DP = intel_dp->DP | intel_dp->color_range;
  }
  if ((int )adjusted_mode->flags & 1) {
    intel_dp->DP = intel_dp->DP | 8U;
  } else {
  }
  if ((adjusted_mode->flags & 4U) != 0U) {
    intel_dp->DP = intel_dp->DP | 16U;
  } else {
  }
  if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 1U) {
    {
    tmp___0 = is_edp(intel_dp);
    }
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1) {
      intel_dp->DP = intel_dp->DP | 768U;
    } else {
      intel_dp->DP = intel_dp->DP | 805306368U;
    }
  } else {
    intel_dp->DP = intel_dp->DP | 805306368U;
  }
  if ((int )intel_dp->lane_count == 1) {
    goto case_1;
  } else
  if ((int )intel_dp->lane_count == 2) {
    goto case_2;
  } else
  if ((int )intel_dp->lane_count == 4) {
    goto case_4;
  } else
  if (0) {
    case_1:
    intel_dp->DP = intel_dp->DP;
    goto ldv_37865;
    case_2:
    intel_dp->DP = intel_dp->DP | 524288U;
    goto ldv_37865;
    case_4:
    intel_dp->DP = intel_dp->DP | 1572864U;
    goto ldv_37865;
  } else {
  }
  ldv_37865: ;
  if ((int )intel_dp->has_audio) {
    intel_dp->DP = intel_dp->DP | 64U;
  } else {
  }
  {
  memset((void *)(& intel_dp->link_configuration), 0, 9UL);
  intel_dp->link_configuration[0] = intel_dp->link_bw;
  intel_dp->link_configuration[1] = intel_dp->lane_count;
  }
  if ((unsigned int )intel_dp->dpcd[0] > 16U) {
    if ((int )((signed char )intel_dp->dpcd[2]) < 0) {
      intel_dp->link_configuration[1] = (uint8_t )((unsigned int )intel_dp->link_configuration[1] | 128U);
      intel_dp->DP = intel_dp->DP | 262144U;
    } else {
    }
  } else {
  }
  if ((unsigned int )intel_crtc->pipe == 1U) {
    if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type != 1U) {
      intel_dp->DP = intel_dp->DP | 1073741824U;
    } else {
    }
  } else {
  }
  {
  tmp___2 = is_edp(intel_dp);
  }
  if ((int )tmp___2) {
    {
    tmp___3 = is_pch_edp(intel_dp);
    }
    if (tmp___3) {
      tmp___4 = 0;
    } else {
      tmp___4 = 1;
    }
    if (tmp___4) {
      intel_dp->DP = intel_dp->DP | 16384U;
      if (adjusted_mode->clock <= 199999) {
        intel_dp->DP = intel_dp->DP | 65536U;
      } else {
        intel_dp->DP = intel_dp->DP;
      }
    } else {
    }
  } else {
  }
  return;
}
}
static void ironlake_edp_panel_vdd_on(struct intel_dp *intel_dp )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  u32 pp ;
  u32 tmp ;
  {
  {
  dev = intel_dp->base.base.dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = i915_read32___10(dev_priv, 815616U);
  }
  if ((int )tmp >= 0) {
    {
    msleep((unsigned int )dev_priv->panel_t3);
    }
  } else {
  }
  {
  pp = i915_read32___10(dev_priv, 815620U);
  pp = pp | 8U;
  i915_write32___8(dev_priv, 815620U, pp);
  readl((void const volatile *)dev_priv->regs + 815620U);
  }
  return;
}
}
static void ironlake_edp_panel_vdd_off(struct intel_dp *intel_dp )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  u32 pp ;
  {
  {
  dev = intel_dp->base.base.dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  pp = i915_read32___10(dev_priv, 815620U);
  pp = pp & 4294967287U;
  i915_write32___8(dev_priv, 815620U, pp);
  readl((void const volatile *)dev_priv->regs + 815620U);
  msleep((unsigned int )dev_priv->panel_t12);
  }
  return;
}
}
static bool ironlake_edp_panel_on(struct intel_dp *intel_dp )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  u32 pp ;
  u32 idle_on_mask ;
  u32 tmp ;
  u32 tmp___0 ;
  unsigned long timeout__ ;
  unsigned long tmp___1 ;
  int ret__ ;
  struct thread_info *tmp___2 ;
  int pfo_ret__ ;
  int tmp___3 ;
  u32 tmp___4 ;
  {
  {
  dev = intel_dp->base.base.dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  idle_on_mask = 2147483656U;
  tmp = i915_read32___10(dev_priv, 815616U);
  }
  if ((int )tmp < 0) {
    return ((bool )1);
  } else {
  }
  {
  pp = i915_read32___10(dev_priv, 815620U);
  pp = pp & 4294967293U;
  i915_write32___8(dev_priv, 815620U, pp);
  readl((void const volatile *)dev_priv->regs + 815620U);
  pp = pp | 2882338817U;
  i915_write32___8(dev_priv, 815620U, pp);
  readl((void const volatile *)dev_priv->regs + 815620U);
  tmp___1 = msecs_to_jiffies((unsigned int const )5000U);
  timeout__ = tmp___1 + (unsigned long )jiffies;
  ret__ = 0;
  }
  goto ldv_37905;
  ldv_37904: ;
  if ((long )timeout__ - (long )jiffies < 0L) {
    ret__ = -110;
    goto ldv_37895;
  } else {
  }
  {
  tmp___2 = current_thread_info();
  }
  if ((tmp___2->preempt_count & -268435457) == 0) {
    if (1) {
      goto case_4;
    } else {
      goto switch_default;
      if (0) {
        __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
        goto ldv_37898;
        __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_37898;
        case_4:
        __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_37898;
        __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_37898;
        switch_default:
        {
        __bad_percpu_size();
        }
      } else {
      }
    }
    ldv_37898:
    {
    tmp___3 = atomic_read((atomic_t const *)(& kgdb_active));
    }
    if (pfo_ret__ != tmp___3) {
      {
      msleep(1U);
      }
    } else {
    }
  } else {
  }
  ldv_37905:
  {
  tmp___4 = i915_read32___10(dev_priv, 815616U);
  }
  if ((tmp___4 & idle_on_mask) != idle_on_mask) {
    goto ldv_37904;
  } else {
    goto ldv_37895;
  }
  ldv_37895: ;
  if (ret__ != 0) {
    {
    tmp___0 = i915_read32___10(dev_priv, 815616U);
    drm_err("ironlake_edp_panel_on", "panel on wait timed out: 0x%08x\n", tmp___0);
    }
  } else {
  }
  {
  pp = pp | 2U;
  i915_write32___8(dev_priv, 815620U, pp);
  readl((void const volatile *)dev_priv->regs + 815620U);
  }
  return ((bool )0);
}
}
static void ironlake_edp_panel_off(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 pp ;
  u32 idle_off_mask ;
  u32 tmp ;
  unsigned long timeout__ ;
  unsigned long tmp___0 ;
  int ret__ ;
  struct thread_info *tmp___1 ;
  int pfo_ret__ ;
  int tmp___2 ;
  u32 tmp___3 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  idle_off_mask = 3087007759U;
  pp = i915_read32___10(dev_priv, 815620U);
  pp = pp & 4294967293U;
  i915_write32___8(dev_priv, 815620U, pp);
  readl((void const volatile *)dev_priv->regs + 815620U);
  pp = pp & 4294967294U;
  i915_write32___8(dev_priv, 815620U, pp);
  readl((void const volatile *)dev_priv->regs + 815620U);
  tmp___0 = msecs_to_jiffies((unsigned int const )5000U);
  timeout__ = tmp___0 + (unsigned long )jiffies;
  ret__ = 0;
  }
  goto ldv_37932;
  ldv_37931: ;
  if ((long )timeout__ - (long )jiffies < 0L) {
    ret__ = -110;
    goto ldv_37922;
  } else {
  }
  {
  tmp___1 = current_thread_info();
  }
  if ((tmp___1->preempt_count & -268435457) == 0) {
    if (1) {
      goto case_4;
    } else {
      goto switch_default;
      if (0) {
        __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
        goto ldv_37925;
        __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_37925;
        case_4:
        __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_37925;
        __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_37925;
        switch_default:
        {
        __bad_percpu_size();
        }
      } else {
      }
    }
    ldv_37925:
    {
    tmp___2 = atomic_read((atomic_t const *)(& kgdb_active));
    }
    if (pfo_ret__ != tmp___2) {
      {
      msleep(1U);
      }
    } else {
    }
  } else {
  }
  ldv_37932:
  {
  tmp___3 = i915_read32___10(dev_priv, 815616U);
  }
  if ((tmp___3 & idle_off_mask) != 0U) {
    goto ldv_37931;
  } else {
    goto ldv_37922;
  }
  ldv_37922: ;
  if (ret__ != 0) {
    {
    tmp = i915_read32___10(dev_priv, 815616U);
    drm_err("ironlake_edp_panel_off", "panel off wait timed out: 0x%08x\n", tmp);
    }
  } else {
  }
  {
  pp = pp | 2U;
  i915_write32___8(dev_priv, 815620U, pp);
  readl((void const volatile *)dev_priv->regs + 815620U);
  }
  return;
}
}
static void ironlake_edp_backlight_on(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 pp ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  drm_ut_debug_printk(4U, "drm", "ironlake_edp_backlight_on", "\n");
  msleep(300U);
  pp = i915_read32___10(dev_priv, 815620U);
  pp = pp | 4U;
  i915_write32___8(dev_priv, 815620U, pp);
  }
  return;
}
}
static void ironlake_edp_backlight_off(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 pp ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  drm_ut_debug_printk(4U, "drm", "ironlake_edp_backlight_off", "\n");
  pp = i915_read32___10(dev_priv, 815620U);
  pp = pp & 4294967291U;
  i915_write32___8(dev_priv, 815620U, pp);
  }
  return;
}
}
static void ironlake_edp_pll_on(struct drm_encoder *encoder )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  u32 dpa_ctl ;
  {
  {
  dev = encoder->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  drm_ut_debug_printk(4U, "drm", "ironlake_edp_pll_on", "\n");
  dpa_ctl = i915_read32___10(dev_priv, 409600U);
  dpa_ctl = dpa_ctl | 16384U;
  i915_write32___8(dev_priv, 409600U, dpa_ctl);
  readl((void const volatile *)dev_priv->regs + 409600U);
  __const_udelay(859000UL);
  }
  return;
}
}
static void ironlake_edp_pll_off(struct drm_encoder *encoder )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  u32 dpa_ctl ;
  {
  {
  dev = encoder->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  dpa_ctl = i915_read32___10(dev_priv, 409600U);
  dpa_ctl = dpa_ctl & 4294950911U;
  i915_write32___8(dev_priv, 409600U, dpa_ctl);
  readl((void const volatile *)dev_priv->regs + 409600U);
  __const_udelay(859000UL);
  }
  return;
}
}
static void intel_dp_sink_dpms(struct intel_dp *intel_dp , int mode )
{ int ret ;
  int i ;
  {
  if ((unsigned int )intel_dp->dpcd[0] <= 16U) {
    return;
  } else {
  }
  if (mode != 0) {
    {
    ret = intel_dp_aux_native_write_1(intel_dp, (uint16_t )1536, (uint8_t )2);
    }
    if (ret != 1) {
      {
      drm_ut_debug_printk(2U, "drm", "intel_dp_sink_dpms", "failed to write sink power state\n");
      }
    } else {
    }
  } else {
    i = 0;
    goto ldv_37969;
    ldv_37968:
    {
    ret = intel_dp_aux_native_write_1(intel_dp, (uint16_t )1536, (uint8_t )1);
    }
    if (ret == 1) {
      goto ldv_37967;
    } else {
    }
    {
    msleep(1U);
    i = i + 1;
    }
    ldv_37969: ;
    if (i <= 2) {
      goto ldv_37968;
    } else {
      goto ldv_37967;
    }
    ldv_37967: ;
  }
  return;
}
}
static void intel_dp_prepare(struct drm_encoder *encoder )
{ struct intel_dp *intel_dp ;
  struct intel_dp *tmp ;
  struct drm_device *dev ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  {
  {
  tmp = enc_to_intel_dp(encoder);
  intel_dp = tmp;
  dev = encoder->dev;
  intel_dp_sink_dpms(intel_dp, 0);
  tmp___2 = is_edp(intel_dp);
  }
  if ((int )tmp___2) {
    {
    ironlake_edp_backlight_off(dev);
    ironlake_edp_panel_off(dev);
    tmp___0 = is_pch_edp(intel_dp);
    }
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1) {
      {
      ironlake_edp_pll_on(encoder);
      }
    } else {
      {
      ironlake_edp_pll_off(encoder);
      }
    }
  } else {
  }
  {
  intel_dp_link_down(intel_dp);
  }
  return;
}
}
static void intel_dp_commit(struct drm_encoder *encoder )
{ struct intel_dp *intel_dp ;
  struct intel_dp *tmp ;
  struct drm_device *dev ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  {
  {
  tmp = enc_to_intel_dp(encoder);
  intel_dp = tmp;
  dev = encoder->dev;
  tmp___0 = is_edp(intel_dp);
  }
  if ((int )tmp___0) {
    {
    ironlake_edp_panel_vdd_on(intel_dp);
    }
  } else {
  }
  {
  intel_dp_start_link_train(intel_dp);
  tmp___1 = is_edp(intel_dp);
  }
  if ((int )tmp___1) {
    {
    ironlake_edp_panel_on(intel_dp);
    ironlake_edp_panel_vdd_off(intel_dp);
    }
  } else {
  }
  {
  intel_dp_complete_link_train(intel_dp);
  tmp___2 = is_edp(intel_dp);
  }
  if ((int )tmp___2) {
    {
    ironlake_edp_backlight_on(dev);
    }
  } else {
  }
  return;
}
}
static void intel_dp_dpms(struct drm_encoder *encoder , int mode )
{ struct intel_dp *intel_dp ;
  struct intel_dp *tmp ;
  struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  uint32_t dp_reg ;
  u32 tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  {
  {
  tmp = enc_to_intel_dp(encoder);
  intel_dp = tmp;
  dev = encoder->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp___0 = i915_read32___10(dev_priv, intel_dp->output_reg);
  dp_reg = tmp___0;
  }
  if (mode != 0) {
    {
    tmp___1 = is_edp(intel_dp);
    }
    if ((int )tmp___1) {
      {
      ironlake_edp_backlight_off(dev);
      }
    } else {
    }
    {
    intel_dp_sink_dpms(intel_dp, mode);
    intel_dp_link_down(intel_dp);
    tmp___2 = is_edp(intel_dp);
    }
    if ((int )tmp___2) {
      {
      ironlake_edp_panel_off(dev);
      }
    } else {
    }
    {
    tmp___3 = is_edp(intel_dp);
    }
    if ((int )tmp___3) {
      {
      tmp___4 = is_pch_edp(intel_dp);
      }
      if (tmp___4) {
        tmp___5 = 0;
      } else {
        tmp___5 = 1;
      }
      if (tmp___5) {
        {
        ironlake_edp_pll_off(encoder);
        }
      } else {
      }
    } else {
    }
  } else {
    {
    tmp___6 = is_edp(intel_dp);
    }
    if ((int )tmp___6) {
      {
      ironlake_edp_panel_vdd_on(intel_dp);
      }
    } else {
    }
    {
    intel_dp_sink_dpms(intel_dp, mode);
    }
    if ((int )dp_reg >= 0) {
      {
      intel_dp_start_link_train(intel_dp);
      tmp___7 = is_edp(intel_dp);
      }
      if ((int )tmp___7) {
        {
        ironlake_edp_panel_on(intel_dp);
        ironlake_edp_panel_vdd_off(intel_dp);
        }
      } else {
      }
      {
      intel_dp_complete_link_train(intel_dp);
      }
    } else {
    }
    {
    tmp___8 = is_edp(intel_dp);
    }
    if ((int )tmp___8) {
      {
      ironlake_edp_backlight_on(dev);
      }
    } else {
    }
  }
  return;
}
}
static bool intel_dp_aux_native_read_retry(struct intel_dp *intel_dp , uint16_t address ,
                                           uint8_t *recv , int recv_bytes )
{ int ret ;
  int i ;
  {
  i = 0;
  goto ldv_37997;
  ldv_37996:
  {
  ret = intel_dp_aux_native_read(intel_dp, (uint16_t )((int )address), recv, recv_bytes);
  }
  if (ret == recv_bytes) {
    return ((bool )1);
  } else {
  }
  {
  msleep(1U);
  i = i + 1;
  }
  ldv_37997: ;
  if (i <= 2) {
    goto ldv_37996;
  } else {
    goto ldv_37998;
  }
  ldv_37998: ;
  return ((bool )0);
}
}
static bool intel_dp_get_link_status(struct intel_dp *intel_dp )
{ bool tmp ;
  {
  {
  tmp = intel_dp_aux_native_read_retry(intel_dp, (uint16_t )514, (uint8_t *)(& intel_dp->link_status),
                                       6);
  }
  return (tmp);
}
}
static uint8_t intel_dp_link_status(uint8_t *link_status , int r )
{
  {
  return (*(link_status + ((unsigned long )r + 0x0ffffffffffffdfeUL)));
}
}
static uint8_t intel_get_adjust_request_voltage(uint8_t *link_status , int lane )
{ int i ;
  int s ;
  int tmp ;
  uint8_t l ;
  uint8_t tmp___0 ;
  {
  i = (lane >> 1) + 518;
  if (lane & 1) {
    tmp = 4;
  } else {
    tmp = 0;
  }
  {
  s = tmp;
  tmp___0 = intel_dp_link_status(link_status, i);
  l = tmp___0;
  }
  return ((uint8_t )((unsigned int )((uint8_t )((int )l >> s)) & 3U));
}
}
static uint8_t intel_get_adjust_request_pre_emphasis(uint8_t *link_status , int lane )
{ int i ;
  int s ;
  int tmp ;
  uint8_t l ;
  uint8_t tmp___0 ;
  {
  i = (lane >> 1) + 518;
  if (lane & 1) {
    tmp = 6;
  } else {
    tmp = 2;
  }
  {
  s = tmp;
  tmp___0 = intel_dp_link_status(link_status, i);
  l = tmp___0;
  }
  return ((uint8_t )(((unsigned int )((uint8_t )((int )l >> s)) & 3U) << 3U));
}
}
static uint8_t intel_dp_pre_emphasis_max(uint8_t voltage_swing )
{
  {
  if (((int )voltage_swing & 3) == 0) {
    goto case_0;
  } else
  if (((int )voltage_swing & 3) == 1) {
    goto case_1;
  } else
  if (((int )voltage_swing & 3) == 2) {
    goto case_2;
  } else
  if (((int )voltage_swing & 3) == 3) {
    goto case_3;
  } else {
    goto switch_default;
    if (0) {
      case_0: ;
      return ((uint8_t )16U);
      case_1: ;
      return ((uint8_t )16U);
      case_2: ;
      return ((uint8_t )8U);
      case_3: ;
      switch_default: ;
      return ((uint8_t )0U);
    } else {
    }
  }
}
}
static void intel_get_adjust_train(struct intel_dp *intel_dp )
{ uint8_t v ;
  uint8_t p ;
  int lane ;
  uint8_t this_v ;
  uint8_t tmp ;
  uint8_t this_p ;
  uint8_t tmp___0 ;
  uint8_t tmp___1 ;
  uint8_t tmp___2 ;
  {
  v = (uint8_t )0U;
  p = (uint8_t )0U;
  lane = 0;
  goto ldv_38037;
  ldv_38036:
  {
  tmp = intel_get_adjust_request_voltage((uint8_t *)(& intel_dp->link_status), lane);
  this_v = tmp;
  tmp___0 = intel_get_adjust_request_pre_emphasis((uint8_t *)(& intel_dp->link_status),
                                                  lane);
  this_p = tmp___0;
  }
  if ((int )this_v > (int )v) {
    v = this_v;
  } else {
  }
  if ((int )this_p > (int )p) {
    p = this_p;
  } else {
  }
  lane = lane + 1;
  ldv_38037: ;
  if ((int )intel_dp->lane_count > lane) {
    goto ldv_38036;
  } else {
    goto ldv_38038;
  }
  ldv_38038: ;
  if ((unsigned int )v > 1U) {
    v = (uint8_t )6U;
  } else {
  }
  {
  tmp___2 = intel_dp_pre_emphasis_max((uint8_t )((int )v));
  }
  if ((int )tmp___2 <= (int )p) {
    {
    tmp___1 = intel_dp_pre_emphasis_max((uint8_t )((int )v));
    p = (uint8_t )((unsigned int )tmp___1 | 32U);
    }
  } else {
  }
  lane = 0;
  goto ldv_38040;
  ldv_38039:
  intel_dp->train_set[lane] = (uint8_t )((int )v | (int )p);
  lane = lane + 1;
  ldv_38040: ;
  if (lane <= 3) {
    goto ldv_38039;
  } else {
    goto ldv_38041;
  }
  ldv_38041: ;
  return;
}
}
static uint32_t intel_dp_signal_levels(uint8_t train_set , int lane_count )
{ uint32_t signal_levels ;
  {
  signal_levels = 0U;
  if (((int )train_set & 3) == 0) {
    goto case_0;
  } else
  if (((int )train_set & 3) == 1) {
    goto case_1;
  } else
  if (((int )train_set & 3) == 2) {
    goto case_2;
  } else
  if (((int )train_set & 3) == 3) {
    goto case_3;
  } else {
    goto switch_default;
    if (0) {
      case_0: ;
      switch_default:
      signal_levels = signal_levels;
      goto ldv_38049;
      case_1:
      signal_levels = signal_levels | 33554432U;
      goto ldv_38049;
      case_2:
      signal_levels = signal_levels | 67108864U;
      goto ldv_38049;
      case_3:
      signal_levels = signal_levels | 100663296U;
      goto ldv_38049;
    } else {
    }
  }
  ldv_38049: ;
  if (((int )train_set & 24) == 0) {
    goto case_0___0;
  } else
  if (((int )train_set & 24) == 8) {
    goto case_8;
  } else
  if (((int )train_set & 24) == 16) {
    goto case_16;
  } else
  if (((int )train_set & 24) == 24) {
    goto case_24;
  } else {
    goto switch_default___0;
    if (0) {
      case_0___0: ;
      switch_default___0:
      signal_levels = signal_levels;
      goto ldv_38055;
      case_8:
      signal_levels = signal_levels | 4194304U;
      goto ldv_38055;
      case_16:
      signal_levels = signal_levels | 8388608U;
      goto ldv_38055;
      case_24:
      signal_levels = signal_levels | 12582912U;
      goto ldv_38055;
    } else {
    }
  }
  ldv_38055: ;
  return (signal_levels);
}
}
static uint32_t intel_gen6_edp_signal_levels(uint8_t train_set )
{ int signal_levels ;
  {
  signal_levels = (int )train_set & 27;
  if (signal_levels == 0) {
    goto case_0;
  } else
  if (signal_levels == 1) {
    goto case_1;
  } else
  if (signal_levels == 8) {
    goto case_8;
  } else
  if (signal_levels == 16) {
    goto case_16;
  } else
  if (signal_levels == 17) {
    goto case_17;
  } else
  if (signal_levels == 9) {
    goto case_9;
  } else
  if (signal_levels == 10) {
    goto case_10;
  } else
  if (signal_levels == 2) {
    goto case_2;
  } else
  if (signal_levels == 3) {
    goto case_3;
  } else {
    goto switch_default;
    if (0) {
      case_0: ;
      case_1: ;
      return (0U);
      case_8: ;
      return (4194304U);
      case_16: ;
      case_17: ;
      return (243269632U);
      case_9: ;
      case_10: ;
      return (239075328U);
      case_2: ;
      case_3: ;
      return (234881024U);
      switch_default:
      {
      drm_ut_debug_printk(4U, "drm", "intel_gen6_edp_signal_levels", "Unsupported voltage swing/pre-emphasis level:0x%x\n",
                          signal_levels);
      }
      return (0U);
    } else {
    }
  }
}
}
static uint8_t intel_get_lane_status(uint8_t *link_status , int lane )
{ int i ;
  int s ;
  uint8_t l ;
  uint8_t tmp ;
  {
  {
  i = (lane >> 1) + 514;
  s = (lane & 1) * 4;
  tmp = intel_dp_link_status(link_status, i);
  l = tmp;
  }
  return ((uint8_t )((unsigned int )((uint8_t )((int )l >> s)) & 15U));
}
}
static bool intel_clock_recovery_ok(uint8_t *link_status , int lane_count )
{ int lane ;
  uint8_t lane_status ;
  {
  lane = 0;
  goto ldv_38088;
  ldv_38087:
  {
  lane_status = intel_get_lane_status(link_status, lane);
  }
  if (((int )lane_status & 1) == 0) {
    return ((bool )0);
  } else {
  }
  lane = lane + 1;
  ldv_38088: ;
  if (lane < lane_count) {
    goto ldv_38087;
  } else {
    goto ldv_38089;
  }
  ldv_38089: ;
  return ((bool )1);
}
}
static bool intel_channel_eq_ok(struct intel_dp *intel_dp )
{ uint8_t lane_align ;
  uint8_t lane_status ;
  int lane ;
  {
  {
  lane_align = intel_dp_link_status((uint8_t *)(& intel_dp->link_status), 516);
  }
  if (((int )lane_align & 1) == 0) {
    return ((bool )0);
  } else {
  }
  lane = 0;
  goto ldv_38097;
  ldv_38096:
  {
  lane_status = intel_get_lane_status((uint8_t *)(& intel_dp->link_status), lane);
  }
  if (((int )lane_status & 7) != 7) {
    return ((bool )0);
  } else {
  }
  lane = lane + 1;
  ldv_38097: ;
  if ((int )intel_dp->lane_count > lane) {
    goto ldv_38096;
  } else {
    goto ldv_38098;
  }
  ldv_38098: ;
  return ((bool )1);
}
}
static bool intel_dp_set_link_train(struct intel_dp *intel_dp , uint32_t dp_reg_value ,
                                    uint8_t dp_train_pat )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  int ret ;
  {
  {
  dev = intel_dp->base.base.dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  i915_write32___8(dev_priv, intel_dp->output_reg, dp_reg_value);
  readl((void const volatile *)dev_priv->regs + (unsigned long )intel_dp->output_reg);
  intel_dp_aux_native_write_1(intel_dp, (uint16_t )258, (uint8_t )((int )dp_train_pat));
  ret = intel_dp_aux_native_write(intel_dp, (uint16_t )259, (uint8_t *)(& intel_dp->train_set),
                                  4);
  }
  if (ret != 4) {
    return ((bool )0);
  } else {
  }
  return ((bool )1);
}
}
static void intel_dp_start_link_train(struct intel_dp *intel_dp )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  int i ;
  uint8_t voltage ;
  bool clock_recovery ;
  int tries ;
  u32 reg ;
  uint32_t DP ;
  bool tmp ;
  int tmp___0 ;
  uint32_t signal_levels ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  bool tmp___8 ;
  {
  {
  dev = intel_dp->base.base.dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)intel_dp->base.base.crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  clock_recovery = (bool )0;
  DP = intel_dp->DP;
  i915_write32___8(dev_priv, intel_dp->output_reg, intel_dp->DP);
  readl((void const volatile *)dev_priv->regs + (unsigned long )intel_dp->output_reg);
  intel_wait_for_vblank(dev, (int )intel_crtc->pipe);
  intel_dp_aux_native_write(intel_dp, (uint16_t )256, (uint8_t *)(& intel_dp->link_configuration),
                            9);
  DP = DP | 2147483648U;
  }
  if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 1U) {
    {
    tmp = is_edp(intel_dp);
    }
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      DP = DP & 4294965503U;
    } else {
      DP = DP & 3489660927U;
    }
  } else {
    DP = DP & 3489660927U;
  }
  {
  memset((void *)(& intel_dp->train_set), 0, 4UL);
  voltage = (uint8_t )255U;
  tries = 0;
  clock_recovery = (bool )0;
  }
  ldv_38126: ;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    tmp___1 = is_edp(intel_dp);
    }
    if ((int )tmp___1) {
      {
      signal_levels = intel_gen6_edp_signal_levels((uint8_t )((int )intel_dp->train_set[0]));
      DP = (DP & 4030726143U) | signal_levels;
      }
    } else {
      {
      signal_levels = intel_dp_signal_levels((uint8_t )((int )intel_dp->train_set[0]),
                                             (int )intel_dp->lane_count);
      DP = (DP & 4030726143U) | signal_levels;
      }
    }
  } else {
    {
    signal_levels = intel_dp_signal_levels((uint8_t )((int )intel_dp->train_set[0]),
                                           (int )intel_dp->lane_count);
    DP = (DP & 4030726143U) | signal_levels;
    }
  }
  if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 1U) {
    {
    tmp___2 = is_edp(intel_dp);
    }
    if (tmp___2) {
      tmp___3 = 0;
    } else {
      tmp___3 = 1;
    }
    if (tmp___3) {
      reg = DP;
    } else {
      reg = DP;
    }
  } else {
    reg = DP;
  }
  {
  tmp___4 = intel_dp_set_link_train(intel_dp, reg, (uint8_t )1);
  }
  if (tmp___4) {
    tmp___5 = 0;
  } else {
    tmp___5 = 1;
  }
  if (tmp___5) {
    goto ldv_38122;
  } else {
  }
  {
  __const_udelay(429500UL);
  tmp___6 = intel_dp_get_link_status(intel_dp);
  }
  if (tmp___6) {
    tmp___7 = 0;
  } else {
    tmp___7 = 1;
  }
  if (tmp___7) {
    goto ldv_38122;
  } else {
  }
  {
  tmp___8 = intel_clock_recovery_ok((uint8_t *)(& intel_dp->link_status), (int )intel_dp->lane_count);
  }
  if ((int )tmp___8) {
    clock_recovery = (bool )1;
    goto ldv_38122;
  } else {
  }
  i = 0;
  goto ldv_38125;
  ldv_38124: ;
  if (((int )intel_dp->train_set[i] & 4) == 0) {
    goto ldv_38123;
  } else {
  }
  i = i + 1;
  ldv_38125: ;
  if ((int )intel_dp->lane_count > i) {
    goto ldv_38124;
  } else {
    goto ldv_38123;
  }
  ldv_38123: ;
  if ((int )intel_dp->lane_count == i) {
    goto ldv_38122;
  } else {
  }
  if (((int )intel_dp->train_set[0] & 3) == (int )voltage) {
    tries = tries + 1;
    if (tries == 5) {
      goto ldv_38122;
    } else {
    }
  } else {
    tries = 0;
  }
  {
  voltage = (uint8_t )((unsigned int )intel_dp->train_set[0] & 3U);
  intel_get_adjust_train(intel_dp);
  }
  goto ldv_38126;
  ldv_38122:
  intel_dp->DP = DP;
  return;
}
}
static void intel_dp_complete_link_train(struct intel_dp *intel_dp )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  bool channel_eq ;
  int tries ;
  int cr_tries ;
  u32 reg ;
  uint32_t DP ;
  uint32_t signal_levels ;
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  {
  dev = intel_dp->base.base.dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  channel_eq = (bool )0;
  DP = intel_dp->DP;
  tries = 0;
  cr_tries = 0;
  channel_eq = (bool )0;
  ldv_38141: ;
  if (cr_tries > 5) {
    {
    drm_err("intel_dp_complete_link_train", "failed to train DP, aborting\n");
    intel_dp_link_down(intel_dp);
    }
    goto ldv_38139;
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    tmp = is_edp(intel_dp);
    }
    if ((int )tmp) {
      {
      signal_levels = intel_gen6_edp_signal_levels((uint8_t )((int )intel_dp->train_set[0]));
      DP = (DP & 4030726143U) | signal_levels;
      }
    } else {
      {
      signal_levels = intel_dp_signal_levels((uint8_t )((int )intel_dp->train_set[0]),
                                             (int )intel_dp->lane_count);
      DP = (DP & 4030726143U) | signal_levels;
      }
    }
  } else {
    {
    signal_levels = intel_dp_signal_levels((uint8_t )((int )intel_dp->train_set[0]),
                                           (int )intel_dp->lane_count);
    DP = (DP & 4030726143U) | signal_levels;
    }
  }
  if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 1U) {
    {
    tmp___0 = is_edp(intel_dp);
    }
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1) {
      reg = DP | 256U;
    } else {
      reg = DP | 268435456U;
    }
  } else {
    reg = DP | 268435456U;
  }
  {
  tmp___2 = intel_dp_set_link_train(intel_dp, reg, (uint8_t )2);
  }
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    goto ldv_38139;
  } else {
  }
  {
  __const_udelay(1718000UL);
  tmp___4 = intel_dp_get_link_status(intel_dp);
  }
  if (tmp___4) {
    tmp___5 = 0;
  } else {
    tmp___5 = 1;
  }
  if (tmp___5) {
    goto ldv_38139;
  } else {
  }
  {
  tmp___6 = intel_clock_recovery_ok((uint8_t *)(& intel_dp->link_status), (int )intel_dp->lane_count);
  }
  if (tmp___6) {
    tmp___7 = 0;
  } else {
    tmp___7 = 1;
  }
  if (tmp___7) {
    {
    intel_dp_start_link_train(intel_dp);
    cr_tries = cr_tries + 1;
    }
    goto ldv_38140;
  } else {
  }
  {
  tmp___8 = intel_channel_eq_ok(intel_dp);
  }
  if ((int )tmp___8) {
    channel_eq = (bool )1;
    goto ldv_38139;
  } else {
  }
  if (tries > 5) {
    {
    intel_dp_link_down(intel_dp);
    intel_dp_start_link_train(intel_dp);
    tries = 0;
    cr_tries = cr_tries + 1;
    }
    goto ldv_38140;
  } else {
  }
  {
  intel_get_adjust_train(intel_dp);
  tries = tries + 1;
  }
  ldv_38140: ;
  goto ldv_38141;
  ldv_38139: ;
  if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 1U) {
    {
    tmp___9 = is_edp(intel_dp);
    }
    if (tmp___9) {
      tmp___10 = 0;
    } else {
      tmp___10 = 1;
    }
    if (tmp___10) {
      reg = DP | 768U;
    } else {
      reg = DP | 805306368U;
    }
  } else {
    reg = DP | 805306368U;
  }
  {
  i915_write32___8(dev_priv, intel_dp->output_reg, reg);
  readl((void const volatile *)dev_priv->regs + (unsigned long )intel_dp->output_reg);
  intel_dp_aux_native_write_1(intel_dp, (uint16_t )258, (uint8_t )0);
  }
  return;
}
}
static void intel_dp_link_down(struct intel_dp *intel_dp )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  uint32_t DP ;
  u32 tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  struct drm_crtc *crtc ;
  struct drm_crtc const *__mptr ;
  u32 tmp___4 ;
  {
  {
  dev = intel_dp->base.base.dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  DP = intel_dp->DP;
  tmp = i915_read32___10(dev_priv, intel_dp->output_reg);
  }
  if ((int )tmp >= 0) {
    return;
  } else {
  }
  {
  drm_ut_debug_printk(4U, "drm", "intel_dp_link_down", "\n");
  tmp___0 = is_edp(intel_dp);
  }
  if ((int )tmp___0) {
    {
    DP = DP & 4294950911U;
    i915_write32___8(dev_priv, intel_dp->output_reg, DP);
    readl((void const volatile *)dev_priv->regs + (unsigned long )intel_dp->output_reg);
    __const_udelay(429500UL);
    }
  } else {
  }
  if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 1U) {
    {
    tmp___1 = is_edp(intel_dp);
    }
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    if (tmp___2) {
      {
      DP = DP & 4294965503U;
      i915_write32___8(dev_priv, intel_dp->output_reg, DP | 512U);
      }
    } else {
      {
      DP = DP & 3489660927U;
      i915_write32___8(dev_priv, intel_dp->output_reg, DP | 536870912U);
      }
    }
  } else {
    {
    DP = DP & 3489660927U;
    i915_write32___8(dev_priv, intel_dp->output_reg, DP | 536870912U);
    }
  }
  {
  readl((void const volatile *)dev_priv->regs + (unsigned long )intel_dp->output_reg);
  msleep(17U);
  tmp___3 = is_edp(intel_dp);
  }
  if ((int )tmp___3) {
    DP = DP | 805306368U;
  } else {
  }
  if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type != 1U) {
    {
    tmp___4 = i915_read32___10(dev_priv, intel_dp->output_reg);
    }
    if ((tmp___4 & 1073741824U) != 0U) {
      {
      crtc = intel_dp->base.base.crtc;
      DP = DP & 3221225471U;
      i915_write32___8(dev_priv, intel_dp->output_reg, DP);
      }
      if ((unsigned long )crtc == (unsigned long )((struct drm_crtc *)0)) {
        {
        readl((void const volatile *)dev_priv->regs + (unsigned long )intel_dp->output_reg);
        msleep(50U);
        }
      } else {
        {
        __mptr = (struct drm_crtc const *)crtc;
        intel_wait_for_vblank(dev, (int )((struct intel_crtc *)__mptr)->pipe);
        }
      }
    } else {
    }
  } else {
  }
  {
  i915_write32___8(dev_priv, intel_dp->output_reg, DP & 2147483647U);
  readl((void const volatile *)dev_priv->regs + (unsigned long )intel_dp->output_reg);
  }
  return;
}
}
static void intel_dp_check_link_status(struct intel_dp *intel_dp )
{ int ret ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  {
  if ((unsigned long )intel_dp->base.base.crtc == (unsigned long )((struct drm_crtc *)0)) {
    return;
  } else {
  }
  {
  tmp = intel_dp_get_link_status(intel_dp);
  }
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    {
    intel_dp_link_down(intel_dp);
    }
    return;
  } else {
  }
  {
  ret = intel_dp_aux_native_read(intel_dp, (uint16_t )0, (uint8_t *)(& intel_dp->dpcd),
                                 4);
  }
  if (ret != 4) {
    {
    intel_dp_link_down(intel_dp);
    }
    return;
  } else {
  }
  {
  tmp___1 = intel_channel_eq_ok(intel_dp);
  }
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    {
    intel_dp_start_link_train(intel_dp);
    intel_dp_complete_link_train(intel_dp);
    }
  } else {
  }
  return;
}
}
static enum drm_connector_status ironlake_dp_detect(struct intel_dp *intel_dp )
{ enum drm_connector_status status ;
  bool ret ;
  bool tmp ;
  {
  {
  tmp = is_edp(intel_dp);
  }
  if ((int )tmp) {
    {
    status = intel_panel_detect(intel_dp->base.base.dev);
    }
    if ((unsigned int )status == 3U) {
      status = (enum drm_connector_status )1;
    } else {
    }
    return (status);
  } else {
  }
  {
  status = (enum drm_connector_status )2;
  ret = intel_dp_aux_native_read_retry(intel_dp, (uint16_t )0, (uint8_t *)(& intel_dp->dpcd),
                                       4);
  }
  if ((int )ret) {
    if ((unsigned int )intel_dp->dpcd[0] != 0U) {
      status = (enum drm_connector_status )1;
    } else {
    }
  } else {
  }
  {
  drm_ut_debug_printk(4U, "drm", "ironlake_dp_detect", "DPCD: %hx%hx%hx%hx\n", (int )intel_dp->dpcd[0],
                      (int )intel_dp->dpcd[1], (int )intel_dp->dpcd[2], (int )intel_dp->dpcd[3]);
  }
  return (status);
}
}
static enum drm_connector_status g4x_dp_detect(struct intel_dp *intel_dp )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  enum drm_connector_status status ;
  uint32_t temp ;
  uint32_t bit ;
  int tmp ;
  {
  dev = intel_dp->base.base.dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((int )intel_dp->output_reg == 409856) {
    goto case_409856;
  } else
  if ((int )intel_dp->output_reg == 410112) {
    goto case_410112;
  } else
  if ((int )intel_dp->output_reg == 410368) {
    goto case_410368;
  } else {
    goto switch_default;
    if (0) {
      case_409856:
      bit = 536870912U;
      goto ldv_38171;
      case_410112:
      bit = 268435456U;
      goto ldv_38171;
      case_410368:
      bit = 134217728U;
      goto ldv_38171;
      switch_default: ;
      return ((enum drm_connector_status )3);
    } else {
    }
  }
  ldv_38171:
  {
  temp = i915_read32___10(dev_priv, 397588U);
  }
  if ((temp & bit) == 0U) {
    return ((enum drm_connector_status )2);
  } else {
  }
  {
  status = (enum drm_connector_status )2;
  tmp = intel_dp_aux_native_read(intel_dp, (uint16_t )0, (uint8_t *)(& intel_dp->dpcd),
                                 4);
  }
  if (tmp == 4) {
    if ((unsigned int )intel_dp->dpcd[0] != 0U) {
      status = (enum drm_connector_status )1;
    } else {
    }
  } else {
  }
  return (status);
}
}
static enum drm_connector_status intel_dp_detect(struct drm_connector *connector ,
                                                 bool force )
{ struct intel_dp *intel_dp ;
  struct intel_dp *tmp ;
  struct drm_device *dev ;
  enum drm_connector_status status ;
  struct edid *edid ;
  {
  {
  tmp = intel_attached_dp(connector);
  intel_dp = tmp;
  dev = intel_dp->base.base.dev;
  edid = (struct edid *)0;
  intel_dp->has_audio = (bool )0;
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    status = ironlake_dp_detect(intel_dp);
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    status = ironlake_dp_detect(intel_dp);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    status = ironlake_dp_detect(intel_dp);
    }
  } else {
    {
    status = g4x_dp_detect(intel_dp);
    }
  }
  if ((unsigned int )status != 1U) {
    return (status);
  } else {
  }
  if (intel_dp->force_audio != 0) {
    intel_dp->has_audio = (bool )(intel_dp->force_audio > 0);
  } else {
    {
    edid = drm_get_edid(connector, & intel_dp->adapter);
    }
    if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
      {
      intel_dp->has_audio = drm_detect_monitor_audio(edid);
      connector->display_info.raw_edid = (char *)0;
      kfree((void const *)edid);
      }
    } else {
    }
  }
  return ((enum drm_connector_status )1);
}
}
static int intel_dp_get_modes(struct drm_connector *connector )
{ struct intel_dp *intel_dp ;
  struct intel_dp *tmp ;
  struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  int ret ;
  struct drm_display_mode *newmode ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  bool tmp___0 ;
  struct drm_display_mode *mode ;
  bool tmp___1 ;
  {
  {
  tmp = intel_attached_dp(connector);
  intel_dp = tmp;
  dev = intel_dp->base.base.dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  ret = intel_ddc_get_modes(connector, & intel_dp->adapter);
  }
  if (ret != 0) {
    {
    tmp___0 = is_edp(intel_dp);
    }
    if ((int )tmp___0) {
      if ((unsigned long )dev_priv->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
        __mptr = (struct list_head const *)connector->probed_modes.next;
        newmode = (struct drm_display_mode *)__mptr;
        goto ldv_38197;
        ldv_38196: ;
        if ((newmode->type & 8) != 0) {
          {
          dev_priv->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode const *)newmode);
          }
          goto ldv_38195;
        } else {
        }
        __mptr___0 = (struct list_head const *)newmode->head.next;
        newmode = (struct drm_display_mode *)__mptr___0;
        ldv_38197: ;
        if ((unsigned long )(& newmode->head) != (unsigned long )(& connector->probed_modes)) {
          goto ldv_38196;
        } else {
          goto ldv_38195;
        }
        ldv_38195: ;
      } else {
      }
    } else {
    }
    return (ret);
  } else {
  }
  {
  tmp___1 = is_edp(intel_dp);
  }
  if ((int )tmp___1) {
    if ((unsigned long )dev_priv->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
      {
      mode = drm_mode_duplicate(dev, (struct drm_display_mode const *)dev_priv->panel_fixed_mode);
      drm_mode_probed_add(connector, mode);
      }
      return (1);
    } else {
    }
  } else {
  }
  return (0);
}
}
static bool intel_dp_detect_audio(struct drm_connector *connector )
{ struct intel_dp *intel_dp ;
  struct intel_dp *tmp ;
  struct edid *edid ;
  bool has_audio ;
  {
  {
  tmp = intel_attached_dp(connector);
  intel_dp = tmp;
  has_audio = (bool )0;
  edid = drm_get_edid(connector, & intel_dp->adapter);
  }
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
    {
    has_audio = drm_detect_monitor_audio(edid);
    connector->display_info.raw_edid = (char *)0;
    kfree((void const *)edid);
    }
  } else {
  }
  return (has_audio);
}
}
static int intel_dp_set_property(struct drm_connector *connector , struct drm_property *property ,
                                 uint64_t val )
{ struct drm_i915_private *dev_priv ;
  struct intel_dp *intel_dp ;
  struct intel_dp *tmp ;
  int ret ;
  int i ;
  bool has_audio ;
  struct drm_crtc *crtc ;
  {
  {
  dev_priv = (struct drm_i915_private *)(connector->dev)->dev_private;
  tmp = intel_attached_dp(connector);
  intel_dp = tmp;
  ret = drm_connector_property_set_value(connector, property, val);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  if ((unsigned long )dev_priv->force_audio_property == (unsigned long )property) {
    i = (int )val;
    if (intel_dp->force_audio == i) {
      return (0);
    } else {
    }
    intel_dp->force_audio = i;
    if (i == 0) {
      {
      has_audio = intel_dp_detect_audio(connector);
      }
    } else {
      has_audio = (bool )(i > 0);
    }
    if ((int )intel_dp->has_audio == (int )has_audio) {
      return (0);
    } else {
    }
    intel_dp->has_audio = has_audio;
    goto done;
  } else {
  }
  if ((unsigned long )dev_priv->broadcast_rgb_property == (unsigned long )property) {
    if ((uint64_t )(intel_dp->color_range != 0U) == val) {
      return (0);
    } else {
    }
    if (val != 0ULL) {
      intel_dp->color_range = 256U;
    } else {
      intel_dp->color_range = 0U;
    }
    goto done;
  } else {
  }
  return (-22);
  done: ;
  if ((unsigned long )intel_dp->base.base.crtc != (unsigned long )((struct drm_crtc *)0)) {
    {
    crtc = intel_dp->base.base.crtc;
    drm_crtc_helper_set_mode(crtc, & crtc->mode, crtc->x, crtc->y, crtc->fb);
    }
  } else {
  }
  return (0);
}
}
static void intel_dp_destroy(struct drm_connector *connector )
{
  {
  {
  drm_sysfs_connector_remove(connector);
  drm_connector_cleanup(connector);
  kfree((void const *)connector);
  }
  return;
}
}
static void intel_dp_encoder_destroy(struct drm_encoder *encoder )
{ struct intel_dp *intel_dp ;
  struct intel_dp *tmp ;
  {
  {
  tmp = enc_to_intel_dp(encoder);
  intel_dp = tmp;
  i2c_del_adapter(& intel_dp->adapter);
  drm_encoder_cleanup(encoder);
  kfree((void const *)intel_dp);
  }
  return;
}
}
static struct drm_encoder_helper_funcs const intel_dp_helper_funcs =
     {& intel_dp_dpms, (void (*)(struct drm_encoder * ))0, (void (*)(struct drm_encoder * ))0,
    & intel_dp_mode_fixup, & intel_dp_prepare, & intel_dp_commit, & intel_dp_mode_set,
    (struct drm_crtc *(*)(struct drm_encoder * ))0, (enum drm_connector_status (*)(struct drm_encoder * ,
                                                                                   struct drm_connector * ))0,
    (void (*)(struct drm_encoder * ))0};
static struct drm_connector_funcs const intel_dp_connector_funcs =
     {& drm_helper_connector_dpms, (void (*)(struct drm_connector * ))0, (void (*)(struct drm_connector * ))0,
    (void (*)(struct drm_connector * ))0, & intel_dp_detect, & drm_helper_probe_single_connector_modes,
    & intel_dp_set_property, & intel_dp_destroy, (void (*)(struct drm_connector * ))0};
static struct drm_connector_helper_funcs const intel_dp_connector_helper_funcs = {& intel_dp_get_modes,
    & intel_dp_mode_valid, & intel_best_encoder};
static struct drm_encoder_funcs const intel_dp_enc_funcs = {(void (*)(struct drm_encoder * ))0, & intel_dp_encoder_destroy};
static void intel_dp_hot_plug(struct intel_encoder *intel_encoder )
{ struct intel_dp *intel_dp ;
  struct intel_encoder const *__mptr ;
  {
  {
  __mptr = (struct intel_encoder const *)intel_encoder;
  intel_dp = (struct intel_dp *)__mptr;
  intel_dp_check_link_status(intel_dp);
  }
  return;
}
}
int intel_trans_dp_port_sel(struct drm_crtc *crtc )
{ struct drm_device *dev ;
  struct drm_mode_config *mode_config ;
  struct drm_encoder *encoder ;
  struct list_head const *__mptr ;
  struct intel_dp *intel_dp ;
  struct list_head const *__mptr___0 ;
  {
  dev = crtc->dev;
  mode_config = & dev->mode_config;
  __mptr = (struct list_head const *)mode_config->encoder_list.next;
  encoder = (struct drm_encoder *)__mptr + 0x0ffffffffffffff8UL;
  goto ldv_38247;
  ldv_38246: ;
  if ((unsigned long )encoder->crtc != (unsigned long )crtc) {
    goto ldv_38245;
  } else {
  }
  {
  intel_dp = enc_to_intel_dp(encoder);
  }
  if (intel_dp->base.type == 7) {
    return ((int )intel_dp->output_reg);
  } else {
  }
  ldv_38245:
  __mptr___0 = (struct list_head const *)encoder->head.next;
  encoder = (struct drm_encoder *)__mptr___0 + 0x0ffffffffffffff8UL;
  ldv_38247: ;
  if ((unsigned long )(& encoder->head) != (unsigned long )(& mode_config->encoder_list)) {
    goto ldv_38246;
  } else {
    goto ldv_38248;
  }
  ldv_38248: ;
  return (-1);
}
}
bool intel_dpd_is_edp(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct child_device_config *p_child ;
  int i ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if (dev_priv->child_dev_num == 0) {
    return ((bool )0);
  } else {
  }
  i = 0;
  goto ldv_38256;
  ldv_38255:
  p_child = dev_priv->child_dev + (unsigned long )i;
  if ((unsigned int )p_child->dvo_port == 9U) {
    if ((unsigned int )p_child->device_type == 30918U) {
      return ((bool )1);
    } else {
    }
  } else {
  }
  i = i + 1;
  ldv_38256: ;
  if (dev_priv->child_dev_num > i) {
    goto ldv_38255;
  } else {
    goto ldv_38257;
  }
  ldv_38257: ;
  return ((bool )0);
}
}
static void intel_dp_add_properties(struct intel_dp *intel_dp , struct drm_connector *connector )
{
  {
  {
  intel_attach_force_audio_property(connector);
  intel_attach_broadcast_rgb_property(connector);
  }
  return;
}
}
void intel_dp_init(struct drm_device *dev , int output_reg )
{ struct drm_i915_private *dev_priv ;
  struct drm_connector *connector ;
  struct intel_dp *intel_dp ;
  struct intel_encoder *intel_encoder ;
  struct intel_connector *intel_connector ;
  char const *name ;
  int type ;
  void *tmp ;
  void *tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  int ret ;
  u32 pp_on ;
  u32 pp_div ;
  bool tmp___4 ;
  bool tmp___5 ;
  u32 temp ;
  u32 tmp___6 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  name = (char const *)0;
  tmp = kzalloc(1808UL, 208U);
  intel_dp = (struct intel_dp *)tmp;
  }
  if ((unsigned long )intel_dp == (unsigned long )((struct intel_dp *)0)) {
    return;
  } else {
  }
  {
  intel_dp->output_reg = (uint32_t )output_reg;
  tmp___0 = kzalloc(1576UL, 208U);
  intel_connector = (struct intel_connector *)tmp___0;
  }
  if ((unsigned long )intel_connector == (unsigned long )((struct intel_connector *)0)) {
    {
    kfree((void const *)intel_dp);
    }
    return;
  } else {
  }
  intel_encoder = & intel_dp->base;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    goto _L;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    goto _L;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    _L:
    if (output_reg == 934656) {
      {
      tmp___1 = intel_dpd_is_edp(dev);
      }
      if ((int )tmp___1) {
        intel_dp->is_pch_edp = (bool )1;
      } else {
      }
    } else {
    }
  } else {
  }
  if (output_reg == 409600) {
    type = 14;
    intel_encoder->type = 8;
  } else {
    {
    tmp___2 = is_pch_edp(intel_dp);
    }
    if ((int )tmp___2) {
      type = 14;
      intel_encoder->type = 8;
    } else {
      type = 10;
      intel_encoder->type = 7;
    }
  }
  {
  connector = & intel_connector->base;
  drm_connector_init(dev, connector, & intel_dp_connector_funcs, type);
  drm_connector_helper_add(connector, & intel_dp_connector_helper_funcs);
  connector->polled = (uint8_t )1U;
  }
  if (output_reg == 409856) {
    intel_encoder->clone_mask = 2048;
  } else
  if (output_reg == 934144) {
    intel_encoder->clone_mask = 2048;
  } else
  if (output_reg == 410112) {
    intel_encoder->clone_mask = 4096;
  } else
  if (output_reg == 934400) {
    intel_encoder->clone_mask = 4096;
  } else
  if (output_reg == 410368) {
    intel_encoder->clone_mask = 8192;
  } else
  if (output_reg == 934656) {
    intel_encoder->clone_mask = 8192;
  } else {
  }
  {
  tmp___3 = is_edp(intel_dp);
  }
  if ((int )tmp___3) {
    intel_encoder->clone_mask = 131072;
  } else {
  }
  {
  intel_encoder->crtc_mask = 3;
  connector->interlace_allowed = (bool )1;
  connector->doublescan_allowed = (bool )0;
  drm_encoder_init(dev, & intel_encoder->base, & intel_dp_enc_funcs, 2);
  drm_encoder_helper_add(& intel_encoder->base, & intel_dp_helper_funcs);
  intel_connector_attach_encoder(intel_connector, intel_encoder);
  drm_sysfs_connector_add(connector);
  }
  if (output_reg == 409600) {
    goto case_409600;
  } else
  if (output_reg == 409856) {
    goto case_409856;
  } else
  if (output_reg == 934144) {
    goto case_934144;
  } else
  if (output_reg == 410112) {
    goto case_410112;
  } else
  if (output_reg == 934400) {
    goto case_934400;
  } else
  if (output_reg == 410368) {
    goto case_410368;
  } else
  if (output_reg == 934656) {
    goto case_934656;
  } else
  if (0) {
    case_409600:
    name = "DPDDC-A";
    goto ldv_38274;
    case_409856: ;
    case_934144:
    dev_priv->hotplug_supported_mask = dev_priv->hotplug_supported_mask | 536870912U;
    name = "DPDDC-B";
    goto ldv_38274;
    case_410112: ;
    case_934400:
    dev_priv->hotplug_supported_mask = dev_priv->hotplug_supported_mask | 268435456U;
    name = "DPDDC-C";
    goto ldv_38274;
    case_410368: ;
    case_934656:
    dev_priv->hotplug_supported_mask = dev_priv->hotplug_supported_mask | 134217728U;
    name = "DPDDC-D";
    goto ldv_38274;
  } else {
  }
  ldv_38274:
  {
  intel_dp_i2c_init(intel_dp, intel_connector, name);
  tmp___4 = is_edp(intel_dp);
  }
  if ((int )tmp___4) {
    {
    pp_on = i915_read32___10(dev_priv, 815624U);
    pp_div = i915_read32___10(dev_priv, 815632U);
    dev_priv->panel_t3 = (int )((pp_on & 536805376U) >> 16);
    dev_priv->panel_t3 = dev_priv->panel_t3 / 10;
    dev_priv->panel_t12 = (int )pp_div & 15;
    dev_priv->panel_t12 = dev_priv->panel_t12 * 100;
    ironlake_edp_panel_vdd_on(intel_dp);
    ret = intel_dp_aux_native_read(intel_dp, (uint16_t )0, (uint8_t *)(& intel_dp->dpcd),
                                   4);
    ironlake_edp_panel_vdd_off(intel_dp);
    }
    if (ret == 4) {
      if ((unsigned int )intel_dp->dpcd[0] > 16U) {
        dev_priv->no_aux_handshake = (bool )(((int )intel_dp->dpcd[3] & 64) != 0);
      } else {
        {
        printk("<6>[drm] failed to retrieve link info, disabling eDP\n");
        intel_dp_encoder_destroy(& intel_dp->base.base);
        intel_dp_destroy(& intel_connector->base);
        }
        return;
      }
    } else {
    }
  } else {
  }
  {
  intel_encoder->hot_plug = & intel_dp_hot_plug;
  tmp___5 = is_edp(intel_dp);
  }
  if ((int )tmp___5) {
    if ((unsigned long )dev_priv->lfp_lvds_vbt_mode != (unsigned long )((struct drm_display_mode *)0)) {
      {
      dev_priv->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode const *)dev_priv->lfp_lvds_vbt_mode);
      }
      if ((unsigned long )dev_priv->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
        (dev_priv->panel_fixed_mode)->type = (dev_priv->panel_fixed_mode)->type | 8;
      } else {
      }
    } else {
    }
  } else {
  }
  {
  intel_dp_add_properties(intel_dp, connector);
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    if (dev->pci_device != 10818) {
      {
      tmp___6 = i915_read32___10(dev_priv, 85352U);
      temp = tmp___6;
      i915_write32___8(dev_priv, 85352U, (temp & 4294967280U) | 13U);
      }
    } else {
    }
  } else {
  }
  return;
}
}
extern bool drm_detect_hdmi_monitor(struct edid * ) ;
__inline static void trace_i915_reg_rw___11(bool write , u32 reg , u64 val , int len )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_reg_rw.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_reg_rw.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )411);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_36349:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , bool , u32 , u64 , int ))it_func))(__data, (bool )((int )write),
                                                                   reg, val, len);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_36349;
      } else {
        goto ldv_36350;
      }
      ldv_36350: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
__inline static u32 i915_read32___11(struct drm_i915_private *dev_priv , u32 reg )
{ u32 val ;
  {
  val = 0U;
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        gen6_gt_force_wake_get(dev_priv);
        val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
        gen6_gt_force_wake_put(dev_priv);
        }
      } else {
        {
        val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
        }
      }
    } else {
      {
      val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
      }
    }
  } else {
    {
    val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
    }
  }
  {
  trace_i915_reg_rw___11((bool )0, reg, (u64 )val, 4);
  }
  return (val);
}
}
__inline static void i915_write32___9(struct drm_i915_private *dev_priv , u32 reg ,
                                      u32 val )
{
  {
  {
  trace_i915_reg_rw___11((bool )1, reg, (u64 )val, 4);
  }
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        __gen6_gt_wait_for_fifo(dev_priv);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  writel(val, (void volatile *)dev_priv->regs + (unsigned long )reg);
  }
  return;
}
}
void intel_dip_infoframe_csum(struct dip_infoframe *avi_if ) ;
static struct intel_hdmi *enc_to_intel_hdmi(struct drm_encoder *encoder )
{ struct drm_encoder const *__mptr ;
  {
  __mptr = (struct drm_encoder const *)encoder;
  return ((struct intel_hdmi *)__mptr);
}
}
static struct intel_hdmi *intel_attached_hdmi(struct drm_connector *connector )
{ struct intel_encoder const *__mptr ;
  struct intel_encoder *tmp ;
  {
  {
  tmp = intel_attached_encoder(connector);
  __mptr = (struct intel_encoder const *)tmp;
  }
  return ((struct intel_hdmi *)__mptr);
}
}
void intel_dip_infoframe_csum(struct dip_infoframe *avi_if )
{ uint8_t *data ;
  uint8_t sum ;
  unsigned int i ;
  {
  data = (uint8_t *)avi_if;
  sum = (uint8_t )0U;
  avi_if->checksum = (uint8_t )0U;
  avi_if->ecc = (uint8_t )0U;
  i = 0U;
  goto ldv_37668;
  ldv_37667:
  sum = (uint8_t )((int )*(data + (unsigned long )i) + (int )sum);
  i = i + 1U;
  ldv_37668: ;
  if (i <= 31U) {
    goto ldv_37667;
  } else {
    goto ldv_37669;
  }
  ldv_37669:
  avi_if->checksum = (uint8_t )(- ((int )sum));
  return;
}
}
static void intel_hdmi_set_avi_infoframe(struct drm_encoder *encoder )
{ struct dip_infoframe avi_if ;
  uint32_t *data ;
  struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_hdmi *intel_hdmi ;
  struct intel_hdmi *tmp ;
  u32 port ;
  unsigned int i ;
  {
  {
  avi_if.type = (uint8_t )130U;
  avi_if.ver = (uint8_t )2U;
  avi_if.len = (uint8_t )13U;
  avi_if.ecc = (unsigned char)0;
  avi_if.checksum = (unsigned char)0;
  avi_if.body.payload[0] = (unsigned char)0;
  avi_if.body.payload[1] = (unsigned char)0;
  avi_if.body.payload[2] = (unsigned char)0;
  avi_if.body.payload[3] = (unsigned char)0;
  avi_if.body.payload[4] = (unsigned char)0;
  avi_if.body.payload[5] = (unsigned char)0;
  avi_if.body.payload[6] = (unsigned char)0;
  avi_if.body.payload[7] = (unsigned char)0;
  avi_if.body.payload[8] = (unsigned char)0;
  avi_if.body.payload[9] = (unsigned char)0;
  avi_if.body.payload[10] = (unsigned char)0;
  avi_if.body.payload[11] = (unsigned char)0;
  avi_if.body.payload[12] = (unsigned char)0;
  avi_if.body.payload[13] = (unsigned char)0;
  avi_if.body.payload[14] = (unsigned char)0;
  avi_if.body.payload[15] = (unsigned char)0;
  avi_if.body.payload[16] = (unsigned char)0;
  avi_if.body.payload[17] = (unsigned char)0;
  avi_if.body.payload[18] = (unsigned char)0;
  avi_if.body.payload[19] = (unsigned char)0;
  avi_if.body.payload[20] = (unsigned char)0;
  avi_if.body.payload[21] = (unsigned char)0;
  avi_if.body.payload[22] = (unsigned char)0;
  avi_if.body.payload[23] = (unsigned char)0;
  avi_if.body.payload[24] = (unsigned char)0;
  avi_if.body.payload[25] = (unsigned char)0;
  avi_if.body.payload[26] = (unsigned char)0;
  data = (uint32_t *)(& avi_if);
  dev = encoder->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = enc_to_intel_hdmi(encoder);
  intel_hdmi = tmp;
  }
  if (! intel_hdmi->has_hdmi_sink) {
    return;
  } else {
  }
  if (intel_hdmi->sdvox_reg == 397632U) {
    port = 536870912U;
  } else
  if (intel_hdmi->sdvox_reg == 397664U) {
    port = 1073741824U;
  } else {
    return;
  }
  {
  i915_write32___9(dev_priv, 397680U, port | 2147549184U);
  intel_dip_infoframe_csum(& avi_if);
  i = 0U;
  }
  goto ldv_37681;
  ldv_37680:
  {
  i915_write32___9(dev_priv, 397688U, *data);
  data = data + 1;
  i = i + 4U;
  }
  ldv_37681: ;
  if (i <= 31U) {
    goto ldv_37680;
  } else {
    goto ldv_37682;
  }
  ldv_37682:
  {
  i915_write32___9(dev_priv, 397680U, port | 2149646336U);
  }
  return;
}
}
static void intel_hdmi_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                struct drm_display_mode *adjusted_mode )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct drm_crtc *crtc ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  struct intel_hdmi *intel_hdmi ;
  struct intel_hdmi *tmp ;
  u32 sdvox ;
  {
  {
  dev = encoder->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  crtc = encoder->crtc;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  tmp = enc_to_intel_hdmi(encoder);
  intel_hdmi = tmp;
  sdvox = 2176U;
  sdvox = intel_hdmi->color_range | sdvox;
  }
  if ((adjusted_mode->flags & 4U) != 0U) {
    sdvox = sdvox | 16U;
  } else {
  }
  if ((int )adjusted_mode->flags & 1) {
    sdvox = sdvox | 8U;
  } else {
  }
  if ((int )intel_hdmi->has_hdmi_sink) {
    if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 1U) {
      sdvox = sdvox | 512U;
    } else {
    }
  } else {
  }
  if ((int )intel_hdmi->has_audio) {
    sdvox = sdvox | 64U;
    sdvox = sdvox | 512U;
  } else {
  }
  if ((unsigned int )intel_crtc->pipe == 1U) {
    if ((unsigned int )((struct drm_i915_private *)dev->dev_private)->pch_type == 1U) {
      sdvox = sdvox | 536870912U;
    } else {
      sdvox = sdvox | 1073741824U;
    }
  } else {
  }
  {
  i915_write32___9(dev_priv, intel_hdmi->sdvox_reg, sdvox);
  readl((void const volatile *)dev_priv->regs + (unsigned long )intel_hdmi->sdvox_reg);
  intel_hdmi_set_avi_infoframe(encoder);
  }
  return;
}
}
static void intel_hdmi_dpms(struct drm_encoder *encoder , int mode )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_hdmi *intel_hdmi ;
  struct intel_hdmi *tmp ;
  u32 temp ;
  {
  {
  dev = encoder->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = enc_to_intel_hdmi(encoder);
  intel_hdmi = tmp;
  temp = i915_read32___11(dev_priv, intel_hdmi->sdvox_reg);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    i915_write32___9(dev_priv, intel_hdmi->sdvox_reg, temp & 2147483647U);
    readl((void const volatile *)dev_priv->regs + (unsigned long )intel_hdmi->sdvox_reg);
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    i915_write32___9(dev_priv, intel_hdmi->sdvox_reg, temp & 2147483647U);
    readl((void const volatile *)dev_priv->regs + (unsigned long )intel_hdmi->sdvox_reg);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    i915_write32___9(dev_priv, intel_hdmi->sdvox_reg, temp & 2147483647U);
    readl((void const volatile *)dev_priv->regs + (unsigned long )intel_hdmi->sdvox_reg);
    }
  } else {
  }
  if (mode != 0) {
    temp = temp & 2147483647U;
  } else {
    temp = temp | 2147483648U;
  }
  {
  i915_write32___9(dev_priv, intel_hdmi->sdvox_reg, temp);
  readl((void const volatile *)dev_priv->regs + (unsigned long )intel_hdmi->sdvox_reg);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    i915_write32___9(dev_priv, intel_hdmi->sdvox_reg, temp);
    readl((void const volatile *)dev_priv->regs + (unsigned long )intel_hdmi->sdvox_reg);
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    i915_write32___9(dev_priv, intel_hdmi->sdvox_reg, temp);
    readl((void const volatile *)dev_priv->regs + (unsigned long )intel_hdmi->sdvox_reg);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    i915_write32___9(dev_priv, intel_hdmi->sdvox_reg, temp);
    readl((void const volatile *)dev_priv->regs + (unsigned long )intel_hdmi->sdvox_reg);
    }
  } else {
  }
  return;
}
}
static int intel_hdmi_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode )
{
  {
  if (mode->clock > 165000) {
    return (15);
  } else {
  }
  if (mode->clock <= 19999) {
    return (16);
  } else {
  }
  if ((mode->flags & 32U) != 0U) {
    return (8);
  } else {
  }
  return (0);
}
}
static bool intel_hdmi_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                  struct drm_display_mode *adjusted_mode )
{
  {
  return ((bool )1);
}
}
static enum drm_connector_status intel_hdmi_detect(struct drm_connector *connector ,
                                                   bool force )
{ struct intel_hdmi *intel_hdmi ;
  struct intel_hdmi *tmp ;
  struct drm_i915_private *dev_priv ;
  struct edid *edid ;
  enum drm_connector_status status ;
  {
  {
  tmp = intel_attached_hdmi(connector);
  intel_hdmi = tmp;
  dev_priv = (struct drm_i915_private *)(connector->dev)->dev_private;
  status = (enum drm_connector_status )2;
  intel_hdmi->has_hdmi_sink = (bool )0;
  intel_hdmi->has_audio = (bool )0;
  edid = drm_get_edid(connector, & (dev_priv->gmbus + (unsigned long )intel_hdmi->ddc_bus)->adapter);
  }
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
    if ((int )((signed char )edid->input) < 0) {
      {
      status = (enum drm_connector_status )1;
      intel_hdmi->has_hdmi_sink = drm_detect_hdmi_monitor(edid);
      intel_hdmi->has_audio = drm_detect_monitor_audio(edid);
      }
    } else {
    }
    {
    connector->display_info.raw_edid = (char *)0;
    kfree((void const *)edid);
    }
  } else {
  }
  if ((unsigned int )status == 1U) {
    if (intel_hdmi->force_audio != 0) {
      intel_hdmi->has_audio = (bool )(intel_hdmi->force_audio > 0);
    } else {
    }
  } else {
  }
  return (status);
}
}
static int intel_hdmi_get_modes(struct drm_connector *connector )
{ struct intel_hdmi *intel_hdmi ;
  struct intel_hdmi *tmp ;
  struct drm_i915_private *dev_priv ;
  int tmp___0 ;
  {
  {
  tmp = intel_attached_hdmi(connector);
  intel_hdmi = tmp;
  dev_priv = (struct drm_i915_private *)(connector->dev)->dev_private;
  tmp___0 = intel_ddc_get_modes(connector, & (dev_priv->gmbus + (unsigned long )intel_hdmi->ddc_bus)->adapter);
  }
  return (tmp___0);
}
}
static bool intel_hdmi_detect_audio(struct drm_connector *connector )
{ struct intel_hdmi *intel_hdmi ;
  struct intel_hdmi *tmp ;
  struct drm_i915_private *dev_priv ;
  struct edid *edid ;
  bool has_audio ;
  {
  {
  tmp = intel_attached_hdmi(connector);
  intel_hdmi = tmp;
  dev_priv = (struct drm_i915_private *)(connector->dev)->dev_private;
  has_audio = (bool )0;
  edid = drm_get_edid(connector, & (dev_priv->gmbus + (unsigned long )intel_hdmi->ddc_bus)->adapter);
  }
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
    if ((int )((signed char )edid->input) < 0) {
      {
      has_audio = drm_detect_monitor_audio(edid);
      }
    } else {
    }
    {
    connector->display_info.raw_edid = (char *)0;
    kfree((void const *)edid);
    }
  } else {
  }
  return (has_audio);
}
}
static int intel_hdmi_set_property(struct drm_connector *connector , struct drm_property *property ,
                                   uint64_t val )
{ struct intel_hdmi *intel_hdmi ;
  struct intel_hdmi *tmp ;
  struct drm_i915_private *dev_priv ;
  int ret ;
  int i ;
  bool has_audio ;
  struct drm_crtc *crtc ;
  {
  {
  tmp = intel_attached_hdmi(connector);
  intel_hdmi = tmp;
  dev_priv = (struct drm_i915_private *)(connector->dev)->dev_private;
  ret = drm_connector_property_set_value(connector, property, val);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  if ((unsigned long )dev_priv->force_audio_property == (unsigned long )property) {
    i = (int )val;
    if (intel_hdmi->force_audio == i) {
      return (0);
    } else {
    }
    intel_hdmi->force_audio = i;
    if (i == 0) {
      {
      has_audio = intel_hdmi_detect_audio(connector);
      }
    } else {
      has_audio = (bool )(i > 0);
    }
    if ((int )intel_hdmi->has_audio == (int )has_audio) {
      return (0);
    } else {
    }
    intel_hdmi->has_audio = has_audio;
    goto done;
  } else {
  }
  if ((unsigned long )dev_priv->broadcast_rgb_property == (unsigned long )property) {
    if ((uint64_t )(intel_hdmi->color_range != 0U) == val) {
      return (0);
    } else {
    }
    if (val != 0ULL) {
      intel_hdmi->color_range = 256U;
    } else {
      intel_hdmi->color_range = 0U;
    }
    goto done;
  } else {
  }
  return (-22);
  done: ;
  if ((unsigned long )intel_hdmi->base.base.crtc != (unsigned long )((struct drm_crtc *)0)) {
    {
    crtc = intel_hdmi->base.base.crtc;
    drm_crtc_helper_set_mode(crtc, & crtc->mode, crtc->x, crtc->y, crtc->fb);
    }
  } else {
  }
  return (0);
}
}
static void intel_hdmi_destroy(struct drm_connector *connector )
{
  {
  {
  drm_sysfs_connector_remove(connector);
  drm_connector_cleanup(connector);
  kfree((void const *)connector);
  }
  return;
}
}
static struct drm_encoder_helper_funcs const intel_hdmi_helper_funcs =
     {& intel_hdmi_dpms, (void (*)(struct drm_encoder * ))0, (void (*)(struct drm_encoder * ))0,
    & intel_hdmi_mode_fixup, & intel_encoder_prepare, & intel_encoder_commit, & intel_hdmi_mode_set,
    (struct drm_crtc *(*)(struct drm_encoder * ))0, (enum drm_connector_status (*)(struct drm_encoder * ,
                                                                                   struct drm_connector * ))0,
    (void (*)(struct drm_encoder * ))0};
static struct drm_connector_funcs const intel_hdmi_connector_funcs =
     {& drm_helper_connector_dpms, (void (*)(struct drm_connector * ))0, (void (*)(struct drm_connector * ))0,
    (void (*)(struct drm_connector * ))0, & intel_hdmi_detect, & drm_helper_probe_single_connector_modes,
    & intel_hdmi_set_property, & intel_hdmi_destroy, (void (*)(struct drm_connector * ))0};
static struct drm_connector_helper_funcs const intel_hdmi_connector_helper_funcs = {& intel_hdmi_get_modes,
    & intel_hdmi_mode_valid, & intel_best_encoder};
static struct drm_encoder_funcs const intel_hdmi_enc_funcs = {(void (*)(struct drm_encoder * ))0, & intel_encoder_destroy};
static void intel_hdmi_add_properties(struct intel_hdmi *intel_hdmi , struct drm_connector *connector )
{
  {
  {
  intel_attach_force_audio_property(connector);
  intel_attach_broadcast_rgb_property(connector);
  }
  return;
}
}
void intel_hdmi_init(struct drm_device *dev , int sdvox_reg )
{ struct drm_i915_private *dev_priv ;
  struct drm_connector *connector ;
  struct intel_encoder *intel_encoder ;
  struct intel_connector *intel_connector ;
  struct intel_hdmi *intel_hdmi ;
  void *tmp ;
  void *tmp___0 ;
  u32 temp ;
  u32 tmp___1 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = kzalloc(120UL, 208U);
  intel_hdmi = (struct intel_hdmi *)tmp;
  }
  if ((unsigned long )intel_hdmi == (unsigned long )((struct intel_hdmi *)0)) {
    return;
  } else {
  }
  {
  tmp___0 = kzalloc(1576UL, 208U);
  intel_connector = (struct intel_connector *)tmp___0;
  }
  if ((unsigned long )intel_connector == (unsigned long )((struct intel_connector *)0)) {
    {
    kfree((void const *)intel_hdmi);
    }
    return;
  } else {
  }
  {
  intel_encoder = & intel_hdmi->base;
  drm_encoder_init(dev, & intel_encoder->base, & intel_hdmi_enc_funcs, 2);
  connector = & intel_connector->base;
  drm_connector_init(dev, connector, & intel_hdmi_connector_funcs, 11);
  drm_connector_helper_add(connector, & intel_hdmi_connector_helper_funcs);
  intel_encoder->type = 6;
  connector->polled = (uint8_t )1U;
  connector->interlace_allowed = (bool )0;
  connector->doublescan_allowed = (bool )0;
  intel_encoder->crtc_mask = 3;
  }
  if (sdvox_reg == 397632) {
    intel_encoder->clone_mask = 2;
    intel_hdmi->ddc_bus = 5;
    dev_priv->hotplug_supported_mask = dev_priv->hotplug_supported_mask | 536870912U;
  } else
  if (sdvox_reg == 397664) {
    intel_encoder->clone_mask = 4;
    intel_hdmi->ddc_bus = 4;
    dev_priv->hotplug_supported_mask = dev_priv->hotplug_supported_mask | 268435456U;
  } else
  if (sdvox_reg == 921920) {
    intel_encoder->clone_mask = 8;
    intel_hdmi->ddc_bus = 5;
    dev_priv->hotplug_supported_mask = dev_priv->hotplug_supported_mask | 536870912U;
  } else
  if (sdvox_reg == 921936) {
    intel_encoder->clone_mask = 16;
    intel_hdmi->ddc_bus = 4;
    dev_priv->hotplug_supported_mask = dev_priv->hotplug_supported_mask | 268435456U;
  } else
  if (sdvox_reg == 921952) {
    intel_encoder->clone_mask = 32;
    intel_hdmi->ddc_bus = 7;
    dev_priv->hotplug_supported_mask = dev_priv->hotplug_supported_mask | 134217728U;
  } else {
  }
  {
  intel_hdmi->sdvox_reg = (u32 )sdvox_reg;
  drm_encoder_helper_add(& intel_encoder->base, & intel_hdmi_helper_funcs);
  intel_hdmi_add_properties(intel_hdmi, connector);
  intel_connector_attach_encoder(intel_connector, intel_encoder);
  drm_sysfs_connector_add(connector);
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    if (dev->pci_device != 10818) {
      {
      tmp___1 = i915_read32___11(dev_priv, 85352U);
      temp = tmp___1;
      i915_write32___9(dev_priv, 85352U, (temp & 4294967280U) | 13U);
      }
    } else {
    }
  } else {
  }
  return;
}
}
int main(void)
{ struct drm_encoder *var_group1 ;
  int var_intel_hdmi_dpms_5_p1 ;
  struct drm_display_mode *var_group2 ;
  struct drm_display_mode *var_intel_hdmi_mode_fixup_7_p2 ;
  struct drm_display_mode *var_intel_hdmi_mode_set_4_p2 ;
  struct drm_connector *var_group3 ;
  bool var_intel_hdmi_detect_8_p1 ;
  struct drm_property *var_group4 ;
  uint64_t var_intel_hdmi_set_property_11_p2 ;
  int tmp ;
  int tmp___0 ;
  {
  {
  LDV_IN_INTERRUPT = 1;
  ldv_initialize();
  }
  goto ldv_37798;
  ldv_37797:
  {
  tmp = __VERIFIER_nondet_int();
  }
  if (tmp == 0) {
    goto case_0;
  } else
  if (tmp == 1) {
    goto case_1;
  } else
  if (tmp == 2) {
    goto case_2;
  } else
  if (tmp == 3) {
    goto case_3;
  } else
  if (tmp == 4) {
    goto case_4;
  } else
  if (tmp == 5) {
    goto case_5;
  } else
  if (tmp == 6) {
    goto case_6;
  } else
  if (tmp == 7) {
    goto case_7;
  } else {
    goto switch_default;
    if (0) {
      case_0:
      {
      intel_hdmi_dpms(var_group1, var_intel_hdmi_dpms_5_p1);
      }
      goto ldv_37788;
      case_1:
      {
      intel_hdmi_mode_fixup(var_group1, var_group2, var_intel_hdmi_mode_fixup_7_p2);
      }
      goto ldv_37788;
      case_2:
      {
      intel_hdmi_mode_set(var_group1, var_group2, var_intel_hdmi_mode_set_4_p2);
      }
      goto ldv_37788;
      case_3:
      {
      intel_hdmi_detect(var_group3, (bool )((int )var_intel_hdmi_detect_8_p1));
      }
      goto ldv_37788;
      case_4:
      {
      intel_hdmi_set_property(var_group3, var_group4, var_intel_hdmi_set_property_11_p2);
      }
      goto ldv_37788;
      case_5:
      {
      intel_hdmi_destroy(var_group3);
      }
      goto ldv_37788;
      case_6:
      {
      intel_hdmi_get_modes(var_group3);
      }
      goto ldv_37788;
      case_7:
      {
      intel_hdmi_mode_valid(var_group3, var_group2);
      }
      goto ldv_37788;
      switch_default: ;
      goto ldv_37788;
    } else {
    }
  }
  ldv_37788: ;
  ldv_37798:
  {
  tmp___0 = __VERIFIER_nondet_int();
  }
  if (tmp___0 != 0) {
    goto ldv_37797;
  } else {
    goto ldv_37799;
  }
  ldv_37799:
  {
  ldv_check_final_state();
  }
  return 0;
}
}
__inline static unsigned int __arch_hweight32(unsigned int w )
{ unsigned int res ;
  {
  res = 0U;
  __asm__ ("661:\n\tcall __sw_hweight32\n662:\n.section .altinstructions,\"a\"\n .balign 8 \n .quad 661b\n .quad 663f\n\t .word (4*32+23)\n\t .byte 662b-661b\n\t .byte 664f-663f\n.previous\n.section .discard,\"aw\",@progbits\n\t .byte 0xff + (664f-663f) - (662b-661b)\n.previous\n.section .altinstr_replacement, \"ax\"\n663:\n\t.byte 0xf3,0x40,0x0f,0xb8,0xc7\n664:\n.previous": "=a" (res): "D" (w));
  return (res);
}
}
__inline static unsigned int __arch_hweight16(unsigned int w )
{ unsigned int tmp ;
  {
  {
  tmp = __arch_hweight32(w & 65535U);
  }
  return (tmp);
}
}
extern int i2c_transfer(struct i2c_adapter * , struct i2c_msg * , int ) ;
extern int i2c_add_adapter(struct i2c_adapter * ) ;
extern void drm_mode_destroy(struct drm_device * , struct drm_display_mode * ) ;
extern struct drm_property *drm_property_create(struct drm_device * , int , char const * ,
                                                int ) ;
extern void drm_property_destroy(struct drm_device * , struct drm_property * ) ;
extern int drm_property_add_enum(struct drm_property * , int , uint64_t , char const * ) ;
void intel_gmbus_set_speed(struct i2c_adapter *adapter , int speed ) ;
void intel_gmbus_force_bit(struct i2c_adapter *adapter , bool force_bit ) ;
__inline static void intel_mode_set_pixel_multiplier(struct drm_display_mode *mode ,
                                                     int multiplier )
{
  {
  mode->clock = mode->clock * multiplier;
  mode->private_flags = mode->private_flags | multiplier;
  return;
}
}
static char const *tv_format_names[19U] =
  { "NTSC_M", "NTSC_J", "NTSC_443", "PAL_B",
        "PAL_D", "PAL_G", "PAL_H", "PAL_I",
        "PAL_M", "PAL_N", "PAL_NC", "PAL_60",
        "SECAM_B", "SECAM_D", "SECAM_G", "SECAM_K",
        "SECAM_K1", "SECAM_L", "SECAM_60"};
static struct intel_sdvo *to_intel_sdvo(struct drm_encoder *encoder )
{ struct drm_encoder const *__mptr ;
  {
  __mptr = (struct drm_encoder const *)encoder;
  return ((struct intel_sdvo *)__mptr);
}
}
static struct intel_sdvo *intel_attached_sdvo(struct drm_connector *connector )
{ struct intel_encoder const *__mptr ;
  struct intel_encoder *tmp ;
  {
  {
  tmp = intel_attached_encoder(connector);
  __mptr = (struct intel_encoder const *)tmp;
  }
  return ((struct intel_sdvo *)__mptr);
}
}
static struct intel_sdvo_connector *to_intel_sdvo_connector(struct drm_connector *connector )
{ struct intel_connector const *__mptr ;
  struct drm_connector const *__mptr___0 ;
  {
  __mptr___0 = (struct drm_connector const *)connector;
  __mptr = (struct intel_connector const *)((struct intel_connector *)__mptr___0);
  return ((struct intel_sdvo_connector *)__mptr);
}
}
static bool intel_sdvo_output_setup(struct intel_sdvo *intel_sdvo , uint16_t flags ) ;
static bool intel_sdvo_tv_create_property(struct intel_sdvo *intel_sdvo , struct intel_sdvo_connector *intel_sdvo_connector ,
                                          int type ) ;
static bool intel_sdvo_create_enhance_property(struct intel_sdvo *intel_sdvo , struct intel_sdvo_connector *intel_sdvo_connector ) ;
static void intel_sdvo_write_sdvox(struct intel_sdvo *intel_sdvo , u32 val )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  u32 bval ;
  u32 cval ;
  int i ;
  {
  dev = intel_sdvo->base.base.dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  bval = val;
  cval = val;
  if (intel_sdvo->sdvo_reg == 921920) {
    {
    i915_write32___9(dev_priv, (u32 )intel_sdvo->sdvo_reg, val);
    i915_read32___11(dev_priv, (u32 )intel_sdvo->sdvo_reg);
    }
    return;
  } else {
  }
  if (intel_sdvo->sdvo_reg == 397632) {
    {
    cval = i915_read32___11(dev_priv, 397664U);
    }
  } else {
    {
    bval = i915_read32___11(dev_priv, 397632U);
    }
  }
  i = 0;
  goto ldv_38028;
  ldv_38027:
  {
  i915_write32___9(dev_priv, 397632U, bval);
  i915_read32___11(dev_priv, 397632U);
  i915_write32___9(dev_priv, 397664U, cval);
  i915_read32___11(dev_priv, 397664U);
  i = i + 1;
  }
  ldv_38028: ;
  if (i <= 1) {
    goto ldv_38027;
  } else {
    goto ldv_38029;
  }
  ldv_38029: ;
  return;
}
}
static bool intel_sdvo_read_byte(struct intel_sdvo *intel_sdvo , u8 addr , u8 *ch )
{ struct i2c_msg msgs[2U] ;
  int ret ;
  {
  {
  msgs[0].addr = (unsigned short )intel_sdvo->slave_addr;
  msgs[0].flags = (__u16 )0U;
  msgs[0].len = (__u16 )1U;
  msgs[0].buf = & addr;
  msgs[1].addr = (unsigned short )intel_sdvo->slave_addr;
  msgs[1].flags = (__u16 )1U;
  msgs[1].len = (__u16 )1U;
  msgs[1].buf = ch;
  ret = i2c_transfer(intel_sdvo->i2c, (struct i2c_msg *)(& msgs), 2);
  }
  if (ret == 2) {
    return ((bool )1);
  } else {
  }
  {
  drm_ut_debug_printk(4U, "drm", "intel_sdvo_read_byte", "i2c transfer returned %d\n",
                      ret);
  }
  return ((bool )0);
}
}
static struct _sdvo_cmd_name const sdvo_cmd_names[107U] =
  { {(u8 )1U, "SDVO_CMD_RESET"},
        {(u8 )2U, "SDVO_CMD_GET_DEVICE_CAPS"},
        {(u8 )134U, "SDVO_CMD_GET_FIRMWARE_REV"},
        {(u8 )3U, "SDVO_CMD_GET_TRAINED_INPUTS"},
        {(u8 )4U, "SDVO_CMD_GET_ACTIVE_OUTPUTS"},
        {(u8 )5U, "SDVO_CMD_SET_ACTIVE_OUTPUTS"},
        {(u8 )6U, "SDVO_CMD_GET_IN_OUT_MAP"},
        {(u8 )7U, "SDVO_CMD_SET_IN_OUT_MAP"},
        {(u8 )11U, "SDVO_CMD_GET_ATTACHED_DISPLAYS"},
        {(u8 )12U, "SDVO_CMD_GET_HOT_PLUG_SUPPORT"},
        {(u8 )13U, "SDVO_CMD_SET_ACTIVE_HOT_PLUG"},
        {(u8 )14U, "SDVO_CMD_GET_ACTIVE_HOT_PLUG"},
        {(u8 )15U, "SDVO_CMD_GET_INTERRUPT_EVENT_SOURCE"},
        {(u8 )16U, "SDVO_CMD_SET_TARGET_INPUT"},
        {(u8 )17U, "SDVO_CMD_SET_TARGET_OUTPUT"},
        {(u8 )18U, "SDVO_CMD_GET_INPUT_TIMINGS_PART1"},
        {(u8 )19U, "SDVO_CMD_GET_INPUT_TIMINGS_PART2"},
        {(u8 )20U, "SDVO_CMD_SET_INPUT_TIMINGS_PART1"},
        {(u8 )21U, "SDVO_CMD_SET_INPUT_TIMINGS_PART2"},
        {(u8 )20U, "SDVO_CMD_SET_INPUT_TIMINGS_PART1"},
        {(u8 )22U, "SDVO_CMD_SET_OUTPUT_TIMINGS_PART1"},
        {(u8 )23U, "SDVO_CMD_SET_OUTPUT_TIMINGS_PART2"},
        {(u8 )24U, "SDVO_CMD_GET_OUTPUT_TIMINGS_PART1"},
        {(u8 )25U, "SDVO_CMD_GET_OUTPUT_TIMINGS_PART2"},
        {(u8 )26U, "SDVO_CMD_CREATE_PREFERRED_INPUT_TIMING"},
        {(u8 )27U, "SDVO_CMD_GET_PREFERRED_INPUT_TIMING_PART1"},
        {(u8 )28U, "SDVO_CMD_GET_PREFERRED_INPUT_TIMING_PART2"},
        {(u8 )29U, "SDVO_CMD_GET_INPUT_PIXEL_CLOCK_RANGE"},
        {(u8 )30U, "SDVO_CMD_GET_OUTPUT_PIXEL_CLOCK_RANGE"},
        {(u8 )31U, "SDVO_CMD_GET_SUPPORTED_CLOCK_RATE_MULTS"},
        {(u8 )32U, "SDVO_CMD_GET_CLOCK_RATE_MULT"},
        {(u8 )33U, "SDVO_CMD_SET_CLOCK_RATE_MULT"},
        {(u8 )39U, "SDVO_CMD_GET_SUPPORTED_TV_FORMATS"},
        {(u8 )40U, "SDVO_CMD_GET_TV_FORMAT"},
        {(u8 )41U, "SDVO_CMD_SET_TV_FORMAT"},
        {(u8 )42U, "SDVO_CMD_GET_SUPPORTED_POWER_STATES"},
        {(u8 )43U, "SDVO_CMD_GET_POWER_STATE"},
        {(u8 )44U, "SDVO_CMD_SET_ENCODER_POWER_STATE"},
        {(u8 )125U, "SDVO_CMD_SET_DISPLAY_POWER_STATE"},
        {(u8 )122U, "SDVO_CMD_SET_CONTROL_BUS_SWITCH"},
        {(u8 )131U, "SDVO_CMD_GET_SDTV_RESOLUTION_SUPPORT"},
        {(u8 )133U, "SDVO_CMD_GET_SCALED_HDTV_RESOLUTION_SUPPORT"},
        {(u8 )132U, "SDVO_CMD_GET_SUPPORTED_ENHANCEMENTS"},
        {(u8 )103U, "SDVO_CMD_GET_MAX_HPOS"},
        {(u8 )104U, "SDVO_CMD_GET_HPOS"},
        {(u8 )105U, "SDVO_CMD_SET_HPOS"},
        {(u8 )106U, "SDVO_CMD_GET_MAX_VPOS"},
        {(u8 )107U, "SDVO_CMD_GET_VPOS"},
        {(u8 )108U, "SDVO_CMD_SET_VPOS"},
        {(u8 )85U, "SDVO_CMD_GET_MAX_SATURATION"},
        {(u8 )86U, "SDVO_CMD_GET_SATURATION"},
        {(u8 )87U, "SDVO_CMD_SET_SATURATION"},
        {(u8 )88U, "SDVO_CMD_GET_MAX_HUE"},
        {(u8 )89U, "SDVO_CMD_GET_HUE"},
        {(u8 )90U, "SDVO_CMD_SET_HUE"},
        {(u8 )94U, "SDVO_CMD_GET_MAX_CONTRAST"},
        {(u8 )95U, "SDVO_CMD_GET_CONTRAST"},
        {(u8 )96U, "SDVO_CMD_SET_CONTRAST"},
        {(u8 )91U, "SDVO_CMD_GET_MAX_BRIGHTNESS"},
        {(u8 )92U, "SDVO_CMD_GET_BRIGHTNESS"},
        {(u8 )93U, "SDVO_CMD_SET_BRIGHTNESS"},
        {(u8 )97U, "SDVO_CMD_GET_MAX_OVERSCAN_H"},
        {(u8 )98U, "SDVO_CMD_GET_OVERSCAN_H"},
        {(u8 )99U, "SDVO_CMD_SET_OVERSCAN_H"},
        {(u8 )100U, "SDVO_CMD_GET_MAX_OVERSCAN_V"},
        {(u8 )101U, "SDVO_CMD_GET_OVERSCAN_V"},
        {(u8 )102U, "SDVO_CMD_SET_OVERSCAN_V"},
        {(u8 )77U, "SDVO_CMD_GET_MAX_FLICKER_FILTER"},
        {(u8 )78U, "SDVO_CMD_GET_FLICKER_FILTER"},
        {(u8 )79U, "SDVO_CMD_SET_FLICKER_FILTER"},
        {(u8 )123U, "SDVO_CMD_GET_MAX_FLICKER_FILTER_ADAPTIVE"},
        {(u8 )80U, "SDVO_CMD_GET_FLICKER_FILTER_ADAPTIVE"},
        {(u8 )81U, "SDVO_CMD_SET_FLICKER_FILTER_ADAPTIVE"},
        {(u8 )82U, "SDVO_CMD_GET_MAX_FLICKER_FILTER_2D"},
        {(u8 )83U, "SDVO_CMD_GET_FLICKER_FILTER_2D"},
        {(u8 )84U, "SDVO_CMD_SET_FLICKER_FILTER_2D"},
        {(u8 )109U, "SDVO_CMD_GET_MAX_SHARPNESS"},
        {(u8 )110U, "SDVO_CMD_GET_SHARPNESS"},
        {(u8 )111U, "SDVO_CMD_SET_SHARPNESS"},
        {(u8 )112U, "SDVO_CMD_GET_DOT_CRAWL"},
        {(u8 )113U, "SDVO_CMD_SET_DOT_CRAWL"},
        {(u8 )116U, "SDVO_CMD_GET_MAX_TV_CHROMA_FILTER"},
        {(u8 )117U, "SDVO_CMD_GET_TV_CHROMA_FILTER"},
        {(u8 )118U, "SDVO_CMD_SET_TV_CHROMA_FILTER"},
        {(u8 )119U, "SDVO_CMD_GET_MAX_TV_LUMA_FILTER"},
        {(u8 )120U, "SDVO_CMD_GET_TV_LUMA_FILTER"},
        {(u8 )121U, "SDVO_CMD_SET_TV_LUMA_FILTER"},
        {(u8 )157U, "SDVO_CMD_GET_SUPP_ENCODE"},
        {(u8 )158U, "SDVO_CMD_GET_ENCODE"},
        {(u8 )159U, "SDVO_CMD_SET_ENCODE"},
        {(u8 )139U, "SDVO_CMD_SET_PIXEL_REPLI"},
        {(u8 )140U, "SDVO_CMD_GET_PIXEL_REPLI"},
        {(u8 )141U, "SDVO_CMD_GET_COLORIMETRY_CAP"},
        {(u8 )142U, "SDVO_CMD_SET_COLORIMETRY"},
        {(u8 )143U, "SDVO_CMD_GET_COLORIMETRY"},
        {(u8 )144U, "SDVO_CMD_GET_AUDIO_ENCRYPT_PREFER"},
        {(u8 )145U, "SDVO_CMD_SET_AUDIO_STAT"},
        {(u8 )146U, "SDVO_CMD_GET_AUDIO_STAT"},
        {(u8 )148U, "SDVO_CMD_GET_HBUF_INDEX"},
        {(u8 )147U, "SDVO_CMD_SET_HBUF_INDEX"},
        {(u8 )149U, "SDVO_CMD_GET_HBUF_INFO"},
        {(u8 )151U, "SDVO_CMD_GET_HBUF_AV_SPLIT"},
        {(u8 )150U, "SDVO_CMD_SET_HBUF_AV_SPLIT"},
        {(u8 )155U, "SDVO_CMD_GET_HBUF_TXRATE"},
        {(u8 )154U, "SDVO_CMD_SET_HBUF_TXRATE"},
        {(u8 )152U, "SDVO_CMD_SET_HBUF_DATA"},
        {(u8 )153U, "SDVO_CMD_GET_HBUF_DATA"}};
static void intel_sdvo_debug_write(struct intel_sdvo *intel_sdvo , u8 cmd , void const *args ,
                                   int args_len )
{ int i ;
  char *tmp ;
  {
  if (intel_sdvo->sdvo_reg == 397632) {
    tmp = (char *)"SDVOB";
  } else
  if (intel_sdvo->sdvo_reg == 921920) {
    tmp = (char *)"SDVOB";
  } else {
    tmp = (char *)"SDVOC";
  }
  {
  drm_ut_debug_printk(4U, "drm", "intel_sdvo_debug_write", "%s: W: %02X ", tmp, (int )cmd);
  i = 0;
  }
  goto ldv_38051;
  ldv_38050:
  {
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "%02X ", (int )*((u8 *)args + (unsigned long )i));
  i = i + 1;
  }
  ldv_38051: ;
  if (i < args_len) {
    goto ldv_38050;
  } else {
    goto ldv_38052;
  }
  ldv_38052: ;
  goto ldv_38054;
  ldv_38053:
  {
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "   ");
  i = i + 1;
  }
  ldv_38054: ;
  if (i <= 7) {
    goto ldv_38053;
  } else {
    goto ldv_38055;
  }
  ldv_38055:
  i = 0;
  goto ldv_38060;
  ldv_38059: ;
  if ((int )((unsigned char )sdvo_cmd_names[i].cmd) == (int )cmd) {
    {
    drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "(%s)", sdvo_cmd_names[i].name);
    }
    goto ldv_38058;
  } else {
  }
  i = i + 1;
  ldv_38060: ;
  if ((unsigned int )i <= 106U) {
    goto ldv_38059;
  } else {
    goto ldv_38058;
  }
  ldv_38058: ;
  if (i == 107) {
    {
    drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "(%02X)", (int )cmd);
    }
  } else {
  }
  {
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "\n");
  }
  return;
}
}
static char const *cmd_status_names[7U] = { "Power on", "Success", "Not supported", "Invalid arg",
        "Pending", "Target not specified", "Scaling not supported"};
static bool intel_sdvo_write_cmd(struct intel_sdvo *intel_sdvo , u8 cmd , void const *args ,
                                 int args_len )
{ u8 *buf ;
  unsigned long __lengthofbuf ;
  void *tmp ;
  u8 status ;
  struct i2c_msg *msgs ;
  unsigned long __lengthofmsgs ;
  void *tmp___0 ;
  int i ;
  int ret ;
  {
  {
  __lengthofbuf = (unsigned long )((long )((args_len + 1) * 2));
  tmp = __builtin_alloca(sizeof(*buf) * __lengthofbuf);
  buf = (u8 *)tmp;
  __lengthofmsgs = (unsigned long )((long )(args_len + 3));
  tmp___0 = __builtin_alloca(sizeof(*msgs) * __lengthofmsgs);
  msgs = (struct i2c_msg *)tmp___0;
  intel_sdvo_debug_write(intel_sdvo, (u8 )((int )cmd), args, args_len);
  i = 0;
  }
  goto ldv_38076;
  ldv_38075:
  (msgs + i)->addr = (__u16 )intel_sdvo->slave_addr;
  (msgs + i)->flags = (__u16 )0U;
  (msgs + i)->len = (__u16 )2U;
  (msgs + i)->buf = (__u8 *)(& buf) + (unsigned long )(i * 2);
  *(buf + i * 2) = (u8 )(7U - (unsigned int )((u8 )i));
  *(buf + (i * 2 + 1)) = *((u8 *)args + (unsigned long )i);
  i = i + 1;
  ldv_38076: ;
  if (i < args_len) {
    goto ldv_38075;
  } else {
    goto ldv_38077;
  }
  ldv_38077:
  {
  (msgs + i)->addr = (__u16 )intel_sdvo->slave_addr;
  (msgs + i)->flags = (__u16 )0U;
  (msgs + i)->len = (__u16 )2U;
  (msgs + i)->buf = (__u8 *)(& buf) + (unsigned long )(i * 2);
  *(buf + i * 2) = (u8 )8U;
  *(buf + (i * 2 + 1)) = cmd;
  status = (u8 )9U;
  (msgs + (i + 1))->addr = (__u16 )intel_sdvo->slave_addr;
  (msgs + (i + 1))->flags = (__u16 )0U;
  (msgs + (i + 1))->len = (__u16 )1U;
  (msgs + (i + 1))->buf = & status;
  (msgs + (i + 2))->addr = (__u16 )intel_sdvo->slave_addr;
  (msgs + (i + 2))->flags = (__u16 )1U;
  (msgs + (i + 2))->len = (__u16 )1U;
  (msgs + (i + 2))->buf = & status;
  ret = i2c_transfer(intel_sdvo->i2c, (struct i2c_msg *)(& msgs), i + 3);
  }
  if (ret < 0) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_sdvo_write_cmd", "I2c transfer returned %d\n",
                        ret);
    }
    return ((bool )0);
  } else {
  }
  if (i + 3 != ret) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_sdvo_write_cmd", "I2c transfer returned %d/%d\n",
                        ret, i + 3);
    }
    return ((bool )0);
  } else {
  }
  return ((bool )1);
}
}
static bool intel_sdvo_read_response(struct intel_sdvo *intel_sdvo , void *response ,
                                     int response_len )
{ u8 retry ;
  u8 status ;
  int i ;
  char *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  u8 tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  {
  retry = (u8 )5U;
  if (intel_sdvo->sdvo_reg == 397632) {
    tmp = (char *)"SDVOB";
  } else
  if (intel_sdvo->sdvo_reg == 921920) {
    tmp = (char *)"SDVOB";
  } else {
    tmp = (char *)"SDVOC";
  }
  {
  drm_ut_debug_printk(4U, "drm", "intel_sdvo_read_response", "%s: R: ", tmp);
  tmp___0 = intel_sdvo_read_byte(intel_sdvo, (u8 )9, & status);
  }
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    goto log_fail;
  } else {
  }
  goto ldv_38090;
  ldv_38089:
  {
  __const_udelay(64425UL);
  tmp___2 = intel_sdvo_read_byte(intel_sdvo, (u8 )9, & status);
  }
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    goto log_fail;
  } else {
  }
  ldv_38090: ;
  if ((unsigned int )status == 4U) {
    tmp___4 = retry;
    retry = (u8 )((int )retry - 1);
    if ((unsigned int )tmp___4 != 0U) {
      goto ldv_38089;
    } else {
      goto ldv_38091;
    }
  } else {
    goto ldv_38091;
  }
  ldv_38091: ;
  if ((unsigned int )status <= 6U) {
    {
    drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "(%s)", cmd_status_names[(int )status]);
    }
  } else {
    {
    drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "(??? %d)", (int )status);
    }
  }
  if ((unsigned int )status != 1U) {
    goto log_fail;
  } else {
  }
  i = 0;
  goto ldv_38093;
  ldv_38092:
  {
  tmp___5 = intel_sdvo_read_byte(intel_sdvo, (u8 )((int )((unsigned int )((u8 )i) + 10U)),
                                 (u8 *)response + (unsigned long )i);
  }
  if (tmp___5) {
    tmp___6 = 0;
  } else {
    tmp___6 = 1;
  }
  if (tmp___6) {
    goto log_fail;
  } else {
  }
  {
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, " %02X", (int )*((u8 *)response + (unsigned long )i));
  i = i + 1;
  }
  ldv_38093: ;
  if (i < response_len) {
    goto ldv_38092;
  } else {
    goto ldv_38094;
  }
  ldv_38094:
  {
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "\n");
  }
  return ((bool )1);
  log_fail:
  {
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "... failed\n");
  }
  return ((bool )0);
}
}
static int intel_sdvo_get_pixel_multiplier(struct drm_display_mode *mode )
{
  {
  if (mode->clock > 99999) {
    return (1);
  } else
  if (mode->clock > 49999) {
    return (2);
  } else {
    return (4);
  }
}
}
static bool intel_sdvo_set_control_bus_switch(struct intel_sdvo *intel_sdvo , u8 ddc_bus )
{ bool tmp ;
  {
  {
  tmp = intel_sdvo_write_cmd(intel_sdvo, (u8 )122, (void const *)(& ddc_bus), 1);
  }
  return (tmp);
}
}
static bool intel_sdvo_set_value(struct intel_sdvo *intel_sdvo , u8 cmd , void const *data ,
                                 int len )
{ bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp = intel_sdvo_write_cmd(intel_sdvo, (u8 )((int )cmd), data, len);
  }
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return ((bool )0);
  } else {
  }
  {
  tmp___1 = intel_sdvo_read_response(intel_sdvo, (void *)0, 0);
  }
  return (tmp___1);
}
}
static bool intel_sdvo_get_value(struct intel_sdvo *intel_sdvo , u8 cmd , void *value ,
                                 int len )
{ bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp = intel_sdvo_write_cmd(intel_sdvo, (u8 )((int )cmd), (void const *)0, 0);
  }
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return ((bool )0);
  } else {
  }
  {
  tmp___1 = intel_sdvo_read_response(intel_sdvo, value, len);
  }
  return (tmp___1);
}
}
static bool intel_sdvo_set_target_input(struct intel_sdvo *intel_sdvo )
{ struct intel_sdvo_set_target_input_args targets ;
  bool tmp ;
  {
  {
  targets.target_1 = (unsigned char)0;
  targets.pad = (unsigned char)0;
  tmp = intel_sdvo_set_value(intel_sdvo, (u8 )16, (void const *)(& targets), 1);
  }
  return (tmp);
}
}
static bool intel_sdvo_get_trained_inputs(struct intel_sdvo *intel_sdvo , bool *input_1 ,
                                          bool *input_2 )
{ struct intel_sdvo_get_trained_inputs_response response ;
  bool tmp ;
  int tmp___0 ;
  {
  {
  tmp = intel_sdvo_get_value(intel_sdvo, (u8 )3, (void *)(& response), 1);
  }
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return ((bool )0);
  } else {
  }
  *input_1 = (bool )((int )response.input0_trained != 0);
  *input_2 = (bool )((int )response.input1_trained != 0);
  return ((bool )1);
}
}
static bool intel_sdvo_set_active_outputs(struct intel_sdvo *intel_sdvo , u16 outputs )
{ bool tmp ;
  {
  {
  tmp = intel_sdvo_set_value(intel_sdvo, (u8 )5, (void const *)(& outputs), 2);
  }
  return (tmp);
}
}
static bool intel_sdvo_get_input_pixel_clock_range(struct intel_sdvo *intel_sdvo ,
                                                   int *clock_min , int *clock_max )
{ struct intel_sdvo_pixel_clock_range clocks ;
  bool tmp ;
  int tmp___0 ;
  {
  {
  tmp = intel_sdvo_get_value(intel_sdvo, (u8 )29, (void *)(& clocks), 4);
  }
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return ((bool )0);
  } else {
  }
  *clock_min = (int )clocks.min * 10;
  *clock_max = (int )clocks.max * 10;
  return ((bool )1);
}
}
static bool intel_sdvo_set_target_output(struct intel_sdvo *intel_sdvo , u16 outputs )
{ bool tmp ;
  {
  {
  tmp = intel_sdvo_set_value(intel_sdvo, (u8 )17, (void const *)(& outputs), 2);
  }
  return (tmp);
}
}
static bool intel_sdvo_set_timing(struct intel_sdvo *intel_sdvo , u8 cmd , struct intel_sdvo_dtd *dtd )
{ bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  {
  {
  tmp = intel_sdvo_set_value(intel_sdvo, (u8 )((int )cmd), (void const *)(& dtd->part1),
                             8);
  }
  if ((int )tmp) {
    {
    tmp___0 = intel_sdvo_set_value(intel_sdvo, (u8 )((int )((unsigned int )cmd + 1U)),
                                   (void const *)(& dtd->part2), 8);
    }
    if ((int )tmp___0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  return ((bool )tmp___1);
}
}
static bool intel_sdvo_set_input_timing(struct intel_sdvo *intel_sdvo , struct intel_sdvo_dtd *dtd )
{ bool tmp ;
  {
  {
  tmp = intel_sdvo_set_timing(intel_sdvo, (u8 )20, dtd);
  }
  return (tmp);
}
}
static bool intel_sdvo_set_output_timing(struct intel_sdvo *intel_sdvo , struct intel_sdvo_dtd *dtd )
{ bool tmp ;
  {
  {
  tmp = intel_sdvo_set_timing(intel_sdvo, (u8 )22, dtd);
  }
  return (tmp);
}
}
static bool intel_sdvo_create_preferred_input_timing(struct intel_sdvo *intel_sdvo ,
                                                     uint16_t clock , uint16_t width ,
                                                     uint16_t height )
{ struct intel_sdvo_preferred_input_timing_args args ;
  bool tmp ;
  {
  {
  memset((void *)(& args), 0, 7UL);
  args.clock = clock;
  args.width = width;
  args.height = height;
  args.interlace = (unsigned char)0;
  }
  if ((int )intel_sdvo->is_lvds) {
    if ((intel_sdvo->sdvo_lvds_fixed_mode)->hdisplay != (int )width) {
      args.scaled = (unsigned char)1;
    } else
    if ((intel_sdvo->sdvo_lvds_fixed_mode)->vdisplay != (int )height) {
      args.scaled = (unsigned char)1;
    } else {
    }
  } else {
  }
  {
  tmp = intel_sdvo_set_value(intel_sdvo, (u8 )26, (void const *)(& args), 7);
  }
  return (tmp);
}
}
static bool intel_sdvo_get_preferred_input_timing(struct intel_sdvo *intel_sdvo ,
                                                  struct intel_sdvo_dtd *dtd )
{ bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  {
  {
  tmp = intel_sdvo_get_value(intel_sdvo, (u8 )27, (void *)(& dtd->part1), 8);
  }
  if ((int )tmp) {
    {
    tmp___0 = intel_sdvo_get_value(intel_sdvo, (u8 )28, (void *)(& dtd->part2), 8);
    }
    if ((int )tmp___0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  return ((bool )tmp___1);
}
}
static bool intel_sdvo_set_clock_rate_mult(struct intel_sdvo *intel_sdvo , u8 val )
{ bool tmp ;
  {
  {
  tmp = intel_sdvo_set_value(intel_sdvo, (u8 )33, (void const *)(& val), 1);
  }
  return (tmp);
}
}
static void intel_sdvo_get_dtd_from_mode(struct intel_sdvo_dtd *dtd , struct drm_display_mode const *mode )
{ uint16_t width ;
  uint16_t height ;
  uint16_t h_blank_len ;
  uint16_t h_sync_len ;
  uint16_t v_blank_len ;
  uint16_t v_sync_len ;
  uint16_t h_sync_offset ;
  uint16_t v_sync_offset ;
  {
  width = (uint16_t )mode->crtc_hdisplay;
  height = (uint16_t )mode->crtc_vdisplay;
  h_blank_len = (uint16_t )((int )((uint16_t )mode->crtc_hblank_end) - (int )((uint16_t )mode->crtc_hblank_start));
  h_sync_len = (uint16_t )((int )((uint16_t )mode->crtc_hsync_end) - (int )((uint16_t )mode->crtc_hsync_start));
  v_blank_len = (uint16_t )((int )((uint16_t )mode->crtc_vblank_end) - (int )((uint16_t )mode->crtc_vblank_start));
  v_sync_len = (uint16_t )((int )((uint16_t )mode->crtc_vsync_end) - (int )((uint16_t )mode->crtc_vsync_start));
  h_sync_offset = (uint16_t )((int )((uint16_t )mode->crtc_hsync_start) - (int )((uint16_t )mode->crtc_hblank_start));
  v_sync_offset = (uint16_t )((int )((uint16_t )mode->crtc_vsync_start) - (int )((uint16_t )mode->crtc_vblank_start));
  dtd->part1.clock = (u16 )((int )mode->clock / 10);
  dtd->part1.h_active = (u8 )width;
  dtd->part1.h_blank = (u8 )h_blank_len;
  dtd->part1.h_high = (u8 )((int )((signed char )(((int )width >> 8) << 4)) | ((int )((signed char )((int )h_blank_len >> 8)) & 15));
  dtd->part1.v_active = (u8 )height;
  dtd->part1.v_blank = (u8 )v_blank_len;
  dtd->part1.v_high = (u8 )((int )((signed char )(((int )height >> 8) << 4)) | ((int )((signed char )((int )v_blank_len >> 8)) & 15));
  dtd->part2.h_sync_off = (u8 )h_sync_offset;
  dtd->part2.h_sync_width = (u8 )h_sync_len;
  dtd->part2.v_sync_off_width = (u8 )((int )((signed char )((int )v_sync_offset << 4)) | ((int )((signed char )v_sync_len) & 15));
  dtd->part2.sync_off_width_high = (u8 )((((int )((signed char )(((int )h_sync_offset & 768) >> 2)) | (int )((signed char )(((int )h_sync_len & 768) >> 4))) | (int )((signed char )(((int )v_sync_offset & 48) >> 2))) | (int )((signed char )(((int )v_sync_len & 48) >> 4)));
  dtd->part2.dtd_flags = (u8 )24U;
  if ((int )mode->flags & 1) {
    dtd->part2.dtd_flags = (u8 )((unsigned int )dtd->part2.dtd_flags | 2U);
  } else {
  }
  if (((unsigned int )mode->flags & 4U) != 0U) {
    dtd->part2.dtd_flags = (u8 )((unsigned int )dtd->part2.dtd_flags | 4U);
  } else {
  }
  dtd->part2.sdvo_flags = (u8 )0U;
  dtd->part2.v_sync_off_high = (u8 )((unsigned int )((u8 )v_sync_offset) & 192U);
  dtd->part2.reserved = (u8 )0U;
  return;
}
}
static void intel_sdvo_get_mode_from_dtd(struct drm_display_mode *mode , struct intel_sdvo_dtd const *dtd )
{
  {
  mode->hdisplay = (int )dtd->part1.h_active;
  mode->hdisplay = mode->hdisplay + ((((int )((unsigned char )dtd->part1.h_high) >> 4) & 15) << 8);
  mode->hsync_start = mode->hdisplay + (int )dtd->part2.h_sync_off;
  mode->hsync_start = mode->hsync_start + (((int )dtd->part2.sync_off_width_high & 192) << 2);
  mode->hsync_end = mode->hsync_start + (int )dtd->part2.h_sync_width;
  mode->hsync_end = mode->hsync_end + (((int )dtd->part2.sync_off_width_high & 48) << 4);
  mode->htotal = mode->hdisplay + (int )dtd->part1.h_blank;
  mode->htotal = mode->htotal + (((int )dtd->part1.h_high & 15) << 8);
  mode->vdisplay = (int )dtd->part1.v_active;
  mode->vdisplay = mode->vdisplay + ((((int )((unsigned char )dtd->part1.v_high) >> 4) & 15) << 8);
  mode->vsync_start = mode->vdisplay;
  mode->vsync_start = mode->vsync_start + (((int )((unsigned char )dtd->part2.v_sync_off_width) >> 4) & 15);
  mode->vsync_start = mode->vsync_start + (((int )dtd->part2.sync_off_width_high & 12) << 2);
  mode->vsync_start = mode->vsync_start + ((int )dtd->part2.v_sync_off_high & 192);
  mode->vsync_end = mode->vsync_start + ((int )dtd->part2.v_sync_off_width & 15);
  mode->vsync_end = mode->vsync_end + (((int )dtd->part2.sync_off_width_high & 3) << 4);
  mode->vtotal = mode->vdisplay + (int )dtd->part1.v_blank;
  mode->vtotal = mode->vtotal + (((int )dtd->part1.v_high & 15) << 8);
  mode->clock = (int )dtd->part1.clock * 10;
  mode->flags = mode->flags & 4294967290U;
  if (((int )dtd->part2.dtd_flags & 2) != 0) {
    mode->flags = mode->flags | 1U;
  } else {
  }
  if (((int )dtd->part2.dtd_flags & 4) != 0) {
    mode->flags = mode->flags | 4U;
  } else {
  }
  return;
}
}
static bool intel_sdvo_check_supp_encode(struct intel_sdvo *intel_sdvo )
{ struct intel_sdvo_encode encode ;
  bool tmp ;
  {
  {
  tmp = intel_sdvo_get_value(intel_sdvo, (u8 )157, (void *)(& encode), 2);
  }
  return (tmp);
}
}
static bool intel_sdvo_set_encode(struct intel_sdvo *intel_sdvo , uint8_t mode )
{ bool tmp ;
  {
  {
  tmp = intel_sdvo_set_value(intel_sdvo, (u8 )159, (void const *)(& mode), 1);
  }
  return (tmp);
}
}
static bool intel_sdvo_set_colorimetry(struct intel_sdvo *intel_sdvo , uint8_t mode )
{ bool tmp ;
  {
  {
  tmp = intel_sdvo_set_value(intel_sdvo, (u8 )142, (void const *)(& mode), 1);
  }
  return (tmp);
}
}
static bool intel_sdvo_set_avi_infoframe(struct intel_sdvo *intel_sdvo )
{ struct dip_infoframe avi_if ;
  uint8_t tx_rate ;
  uint8_t set_buf_index[2U] ;
  uint64_t *data ;
  unsigned int i ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  {
  {
  avi_if.type = (uint8_t )130U;
  avi_if.ver = (uint8_t )2U;
  avi_if.len = (uint8_t )13U;
  avi_if.ecc = (unsigned char)0;
  avi_if.checksum = (unsigned char)0;
  avi_if.body.payload[0] = (unsigned char)0;
  avi_if.body.payload[1] = (unsigned char)0;
  avi_if.body.payload[2] = (unsigned char)0;
  avi_if.body.payload[3] = (unsigned char)0;
  avi_if.body.payload[4] = (unsigned char)0;
  avi_if.body.payload[5] = (unsigned char)0;
  avi_if.body.payload[6] = (unsigned char)0;
  avi_if.body.payload[7] = (unsigned char)0;
  avi_if.body.payload[8] = (unsigned char)0;
  avi_if.body.payload[9] = (unsigned char)0;
  avi_if.body.payload[10] = (unsigned char)0;
  avi_if.body.payload[11] = (unsigned char)0;
  avi_if.body.payload[12] = (unsigned char)0;
  avi_if.body.payload[13] = (unsigned char)0;
  avi_if.body.payload[14] = (unsigned char)0;
  avi_if.body.payload[15] = (unsigned char)0;
  avi_if.body.payload[16] = (unsigned char)0;
  avi_if.body.payload[17] = (unsigned char)0;
  avi_if.body.payload[18] = (unsigned char)0;
  avi_if.body.payload[19] = (unsigned char)0;
  avi_if.body.payload[20] = (unsigned char)0;
  avi_if.body.payload[21] = (unsigned char)0;
  avi_if.body.payload[22] = (unsigned char)0;
  avi_if.body.payload[23] = (unsigned char)0;
  avi_if.body.payload[24] = (unsigned char)0;
  avi_if.body.payload[25] = (unsigned char)0;
  avi_if.body.payload[26] = (unsigned char)0;
  tx_rate = (uint8_t )192U;
  set_buf_index[0] = (uint8_t )1U;
  set_buf_index[1] = (uint8_t )0U;
  data = (uint64_t *)(& avi_if);
  intel_dip_infoframe_csum(& avi_if);
  tmp = intel_sdvo_set_value(intel_sdvo, (u8 )147, (void const *)(& set_buf_index),
                             2);
  }
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return ((bool )0);
  } else {
  }
  i = 0U;
  goto ldv_38213;
  ldv_38212:
  {
  tmp___1 = intel_sdvo_set_value(intel_sdvo, (u8 )152, (void const *)data, 8);
  }
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    return ((bool )0);
  } else {
  }
  data = data + 1;
  i = i + 8U;
  ldv_38213: ;
  if (i <= 31U) {
    goto ldv_38212;
  } else {
    goto ldv_38214;
  }
  ldv_38214:
  {
  tmp___3 = intel_sdvo_set_value(intel_sdvo, (u8 )154, (void const *)(& tx_rate),
                                 1);
  }
  return (tmp___3);
}
}
static bool intel_sdvo_set_tv_format(struct intel_sdvo *intel_sdvo )
{ struct intel_sdvo_tv_format format ;
  uint32_t format_map ;
  size_t __len ;
  unsigned long _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  void *__ret ;
  bool tmp___0 ;
  {
  {
  format_map = (uint32_t )(1 << intel_sdvo->tv_format_index);
  memset((void *)(& format), 0, 6UL);
  _min1 = 6UL;
  _min2 = 4UL;
  }
  if (_min1 < _min2) {
    tmp = _min1;
  } else {
    tmp = _min2;
  }
  {
  __len = tmp;
  __ret = memcpy((void *)(& format), (void const *)(& format_map), __len);
  tmp___0 = intel_sdvo_set_value(intel_sdvo, (u8 )41, (void const *)(& format),
                                 6);
  }
  return (tmp___0);
}
}
static bool intel_sdvo_set_output_timings_from_mode(struct intel_sdvo *intel_sdvo ,
                                                    struct drm_display_mode *mode )
{ struct intel_sdvo_dtd output_dtd ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  {
  {
  tmp = intel_sdvo_set_target_output(intel_sdvo, (u16 )((int )intel_sdvo->attached_output));
  }
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return ((bool )0);
  } else {
  }
  {
  intel_sdvo_get_dtd_from_mode(& output_dtd, (struct drm_display_mode const *)mode);
  tmp___1 = intel_sdvo_set_output_timing(intel_sdvo, & output_dtd);
  }
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    return ((bool )0);
  } else {
  }
  return ((bool )1);
}
}
static bool intel_sdvo_set_input_timings_for_mode(struct intel_sdvo *intel_sdvo ,
                                                  struct drm_display_mode *mode ,
                                                  struct drm_display_mode *adjusted_mode )
{ bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  {
  {
  tmp = intel_sdvo_set_target_input(intel_sdvo);
  }
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return ((bool )0);
  } else {
  }
  {
  tmp___1 = intel_sdvo_create_preferred_input_timing(intel_sdvo, (uint16_t )((int )((uint16_t )(mode->clock / 10))),
                                                     (uint16_t )((int )((uint16_t )mode->hdisplay)),
                                                     (uint16_t )((int )((uint16_t )mode->vdisplay)));
  }
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    return ((bool )0);
  } else {
  }
  {
  tmp___3 = intel_sdvo_get_preferred_input_timing(intel_sdvo, & intel_sdvo->input_dtd);
  }
  if (tmp___3) {
    tmp___4 = 0;
  } else {
    tmp___4 = 1;
  }
  if (tmp___4) {
    return ((bool )0);
  } else {
  }
  {
  intel_sdvo_get_mode_from_dtd(adjusted_mode, (struct intel_sdvo_dtd const *)(& intel_sdvo->input_dtd));
  drm_mode_set_crtcinfo(adjusted_mode, 0);
  }
  return ((bool )1);
}
}
static bool intel_sdvo_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                  struct drm_display_mode *adjusted_mode )
{ struct intel_sdvo *intel_sdvo ;
  struct intel_sdvo *tmp ;
  int multiplier ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  {
  {
  tmp = to_intel_sdvo(encoder);
  intel_sdvo = tmp;
  }
  if ((int )intel_sdvo->is_tv) {
    {
    tmp___0 = intel_sdvo_set_output_timings_from_mode(intel_sdvo, mode);
    }
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1) {
      return ((bool )0);
    } else {
    }
    {
    intel_sdvo_set_input_timings_for_mode(intel_sdvo, mode, adjusted_mode);
    }
  } else
  if ((int )intel_sdvo->is_lvds) {
    {
    tmp___2 = intel_sdvo_set_output_timings_from_mode(intel_sdvo, intel_sdvo->sdvo_lvds_fixed_mode);
    }
    if (tmp___2) {
      tmp___3 = 0;
    } else {
      tmp___3 = 1;
    }
    if (tmp___3) {
      return ((bool )0);
    } else {
    }
    {
    intel_sdvo_set_input_timings_for_mode(intel_sdvo, mode, adjusted_mode);
    }
  } else {
  }
  {
  multiplier = intel_sdvo_get_pixel_multiplier(adjusted_mode);
  intel_mode_set_pixel_multiplier(adjusted_mode, multiplier);
  }
  return ((bool )1);
}
}
static void intel_sdvo_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                struct drm_display_mode *adjusted_mode )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct drm_crtc *crtc ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  struct intel_sdvo *intel_sdvo ;
  struct intel_sdvo *tmp ;
  u32 sdvox ;
  struct intel_sdvo_in_out_map in_out ;
  struct intel_sdvo_dtd input_dtd ;
  int pixel_multiplier ;
  int tmp___0 ;
  int rate ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  {
  {
  dev = encoder->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  crtc = encoder->crtc;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  tmp = to_intel_sdvo(encoder);
  intel_sdvo = tmp;
  tmp___0 = intel_mode_get_pixel_multiplier((struct drm_display_mode const *)adjusted_mode);
  pixel_multiplier = tmp___0;
  }
  if ((unsigned long )mode == (unsigned long )((struct drm_display_mode *)0)) {
    return;
  } else {
  }
  {
  in_out.in0 = intel_sdvo->attached_output;
  in_out.in1 = (u16 )0U;
  intel_sdvo_set_value(intel_sdvo, (u8 )7, (void const *)(& in_out), 4);
  tmp___1 = intel_sdvo_set_target_output(intel_sdvo, (u16 )((int )intel_sdvo->attached_output));
  }
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    return;
  } else {
  }
  if ((int )intel_sdvo->is_tv) {
    input_dtd = intel_sdvo->input_dtd;
  } else
  if ((int )intel_sdvo->is_lvds) {
    input_dtd = intel_sdvo->input_dtd;
  } else {
    {
    tmp___3 = intel_sdvo_set_target_output(intel_sdvo, (u16 )((int )intel_sdvo->attached_output));
    }
    if (tmp___3) {
      tmp___4 = 0;
    } else {
      tmp___4 = 1;
    }
    if (tmp___4) {
      return;
    } else {
    }
    {
    intel_sdvo_get_dtd_from_mode(& input_dtd, (struct drm_display_mode const *)adjusted_mode);
    intel_sdvo_set_output_timing(intel_sdvo, & input_dtd);
    }
  }
  {
  tmp___5 = intel_sdvo_set_target_input(intel_sdvo);
  }
  if (tmp___5) {
    tmp___6 = 0;
  } else {
    tmp___6 = 1;
  }
  if (tmp___6) {
    return;
  } else {
  }
  if ((int )intel_sdvo->has_hdmi_monitor) {
    {
    intel_sdvo_set_encode(intel_sdvo, (uint8_t )1);
    intel_sdvo_set_colorimetry(intel_sdvo, (uint8_t )0);
    intel_sdvo_set_avi_infoframe(intel_sdvo);
    }
  } else {
    {
    intel_sdvo_set_encode(intel_sdvo, (uint8_t )0);
    }
  }
  if ((int )intel_sdvo->is_tv) {
    {
    tmp___7 = intel_sdvo_set_tv_format(intel_sdvo);
    }
    if (tmp___7) {
      tmp___8 = 0;
    } else {
      tmp___8 = 1;
    }
    if (tmp___8) {
      return;
    } else {
    }
  } else {
  }
  {
  intel_sdvo_set_input_timing(intel_sdvo, & input_dtd);
  }
  if (pixel_multiplier == 1) {
    goto case_1;
  } else
  if (pixel_multiplier == 2) {
    goto case_2;
  } else
  if (pixel_multiplier == 4) {
    goto case_4;
  } else {
    goto switch_default;
    if (0) {
      switch_default: ;
      case_1:
      rate = 1;
      goto ldv_38265;
      case_2:
      rate = 2;
      goto ldv_38265;
      case_4:
      rate = 8;
      goto ldv_38265;
    } else {
    }
  }
  ldv_38265:
  {
  tmp___9 = intel_sdvo_set_clock_rate_mult(intel_sdvo, (u8 )((int )((u8 )rate)));
  }
  if (tmp___9) {
    tmp___10 = 0;
  } else {
    tmp___10 = 1;
  }
  if (tmp___10) {
    return;
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    sdvox = 0U;
    if ((int )intel_sdvo->is_hdmi) {
      sdvox = intel_sdvo->color_range | sdvox;
    } else {
    }
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) <= 4U) {
      sdvox = sdvox | 128U;
    } else {
    }
    if ((adjusted_mode->flags & 4U) != 0U) {
      sdvox = sdvox | 16U;
    } else {
    }
    if ((int )adjusted_mode->flags & 1) {
      sdvox = sdvox | 8U;
    } else {
    }
  } else {
    {
    sdvox = i915_read32___11(dev_priv, (u32 )intel_sdvo->sdvo_reg);
    }
    if (intel_sdvo->sdvo_reg == 397632) {
      goto case_397632;
    } else
    if (intel_sdvo->sdvo_reg == 397664) {
      goto case_397664;
    } else
    if (0) {
      case_397632:
      sdvox = sdvox & 67321856U;
      goto ldv_38269;
      case_397664:
      sdvox = sdvox & 67239936U;
      goto ldv_38269;
    } else {
    }
    ldv_38269:
    sdvox = sdvox | 4718720U;
  }
  if ((unsigned int )intel_crtc->pipe == 1U) {
    sdvox = sdvox | 1073741824U;
  } else {
  }
  if ((int )intel_sdvo->has_hdmi_audio) {
    sdvox = sdvox | 64U;
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
  } else
  if (dev->pci_device == 10098) {
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
  } else {
    sdvox = (u32 )((pixel_multiplier + -1) << 23) | sdvox;
  }
  if ((int )((signed char )input_dtd.part2.sdvo_flags) < 0) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) <= 4U) {
      sdvox = sdvox | 536870912U;
    } else {
    }
  } else {
  }
  {
  intel_sdvo_write_sdvox(intel_sdvo, sdvox);
  }
  return;
}
}
static void intel_sdvo_dpms(struct drm_encoder *encoder , int mode )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_sdvo *intel_sdvo ;
  struct intel_sdvo *tmp ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  u32 temp ;
  bool input1 ;
  bool input2 ;
  int i ;
  u8 status ;
  bool tmp___0 ;
  char *tmp___1 ;
  {
  {
  dev = encoder->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = to_intel_sdvo(encoder);
  intel_sdvo = tmp;
  __mptr = (struct drm_crtc const *)encoder->crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  }
  if (mode != 0) {
    {
    intel_sdvo_set_active_outputs(intel_sdvo, (u16 )0);
    }
    if (mode == 3) {
      {
      temp = i915_read32___11(dev_priv, (u32 )intel_sdvo->sdvo_reg);
      }
      if ((int )temp < 0) {
        {
        intel_sdvo_write_sdvox(intel_sdvo, temp & 2147483647U);
        }
      } else {
      }
    } else {
    }
  } else {
    {
    temp = i915_read32___11(dev_priv, (u32 )intel_sdvo->sdvo_reg);
    }
    if ((int )temp >= 0) {
      {
      intel_sdvo_write_sdvox(intel_sdvo, temp | 2147483648U);
      }
    } else {
    }
    i = 0;
    goto ldv_38287;
    ldv_38286:
    {
    intel_wait_for_vblank(dev, (int )intel_crtc->pipe);
    i = i + 1;
    }
    ldv_38287: ;
    if (i <= 1) {
      goto ldv_38286;
    } else {
      goto ldv_38288;
    }
    ldv_38288:
    {
    tmp___0 = intel_sdvo_get_trained_inputs(intel_sdvo, & input1, & input2);
    status = (u8 )tmp___0;
    }
    if ((unsigned int )status == 1U) {
      if (! input1) {
        if (intel_sdvo->sdvo_reg == 397632) {
          tmp___1 = (char *)"SDVOB";
        } else
        if (intel_sdvo->sdvo_reg == 921920) {
          tmp___1 = (char *)"SDVOB";
        } else {
          tmp___1 = (char *)"SDVOC";
        }
        {
        drm_ut_debug_printk(4U, "drm", "intel_sdvo_dpms", "First %s output reported failure to sync\n",
                            tmp___1);
        }
      } else {
      }
    } else {
    }
    {
    intel_sdvo_set_active_outputs(intel_sdvo, (u16 )((int )intel_sdvo->attached_output));
    }
  }
  return;
}
}
static int intel_sdvo_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode )
{ struct intel_sdvo *intel_sdvo ;
  struct intel_sdvo *tmp ;
  {
  {
  tmp = intel_attached_sdvo(connector);
  intel_sdvo = tmp;
  }
  if ((mode->flags & 32U) != 0U) {
    return (8);
  } else {
  }
  if (intel_sdvo->pixel_clock_min > mode->clock) {
    return (16);
  } else {
  }
  if (intel_sdvo->pixel_clock_max < mode->clock) {
    return (15);
  } else {
  }
  if ((int )intel_sdvo->is_lvds) {
    if (mode->hdisplay > (intel_sdvo->sdvo_lvds_fixed_mode)->hdisplay) {
      return (29);
    } else {
    }
    if (mode->vdisplay > (intel_sdvo->sdvo_lvds_fixed_mode)->vdisplay) {
      return (29);
    } else {
    }
  } else {
  }
  return (0);
}
}
static bool intel_sdvo_get_capabilities(struct intel_sdvo *intel_sdvo , struct intel_sdvo_caps *caps )
{ bool tmp ;
  int tmp___0 ;
  {
  {
  tmp = intel_sdvo_get_value(intel_sdvo, (u8 )2, (void *)caps, 8);
  }
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return ((bool )0);
  } else {
  }
  {
  drm_ut_debug_printk(4U, "drm", "intel_sdvo_get_capabilities", "SDVO capabilities:\n  vendor_id: %d\n  device_id: %d\n  device_rev_id: %d\n  sdvo_version_major: %d\n  sdvo_version_minor: %d\n  sdvo_inputs_mask: %d\n  smooth_scaling: %d\n  sharp_scaling: %d\n  up_scaling: %d\n  down_scaling: %d\n  stall_support: %d\n  output_flags: %d\n",
                      (int )caps->vendor_id, (int )caps->device_id, (int )caps->device_rev_id,
                      (int )caps->sdvo_version_major, (int )caps->sdvo_version_minor,
                      (int )caps->sdvo_inputs_mask, (int )caps->smooth_scaling, (int )caps->sharp_scaling,
                      (int )caps->up_scaling, (int )caps->down_scaling, (int )caps->stall_support,
                      (int )caps->output_flags);
  }
  return ((bool )1);
}
}
static bool intel_sdvo_multifunc_encoder(struct intel_sdvo *intel_sdvo )
{ int caps ;
  {
  caps = (int )intel_sdvo->caps.output_flags & 15;
  return ((bool )((- caps & caps) != 0));
}
}
static struct edid *intel_sdvo_get_edid(struct drm_connector *connector )
{ struct intel_sdvo *sdvo ;
  struct intel_sdvo *tmp ;
  struct edid *tmp___0 ;
  {
  {
  tmp = intel_attached_sdvo(connector);
  sdvo = tmp;
  tmp___0 = drm_get_edid(connector, & sdvo->ddc);
  }
  return (tmp___0);
}
}
static struct edid *intel_sdvo_get_analog_edid(struct drm_connector *connector )
{ struct drm_i915_private *dev_priv ;
  struct edid *tmp ;
  {
  {
  dev_priv = (struct drm_i915_private *)(connector->dev)->dev_private;
  tmp = drm_get_edid(connector, & (dev_priv->gmbus + (unsigned long )dev_priv->crt_ddc_pin)->adapter);
  }
  return (tmp);
}
}
enum drm_connector_status intel_sdvo_hdmi_sink_detect(struct drm_connector *connector )
{ struct intel_sdvo *intel_sdvo ;
  struct intel_sdvo *tmp ;
  enum drm_connector_status status ;
  struct edid *edid ;
  u8 ddc ;
  u8 saved_ddc ;
  bool tmp___0 ;
  struct intel_sdvo_connector *intel_sdvo_connector ;
  struct intel_sdvo_connector *tmp___1 ;
  {
  {
  tmp = intel_attached_sdvo(connector);
  intel_sdvo = tmp;
  edid = intel_sdvo_get_edid(connector);
  }
  if ((unsigned long )edid == (unsigned long )((struct edid *)0)) {
    {
    tmp___0 = intel_sdvo_multifunc_encoder(intel_sdvo);
    }
    if ((int )tmp___0) {
      saved_ddc = intel_sdvo->ddc_bus;
      ddc = (u8 )((int )intel_sdvo->ddc_bus >> 1);
      goto ldv_38322;
      ldv_38321:
      {
      intel_sdvo->ddc_bus = ddc;
      edid = intel_sdvo_get_edid(connector);
      }
      if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
        goto ldv_38320;
      } else {
      }
      ddc = (u8 )((int )ddc >> 1);
      ldv_38322: ;
      if ((unsigned int )ddc > 1U) {
        goto ldv_38321;
      } else {
        goto ldv_38320;
      }
      ldv_38320: ;
      if ((unsigned long )edid == (unsigned long )((struct edid *)0)) {
        intel_sdvo->ddc_bus = saved_ddc;
      } else {
      }
    } else {
    }
  } else {
  }
  if ((unsigned long )edid == (unsigned long )((struct edid *)0)) {
    {
    edid = intel_sdvo_get_analog_edid(connector);
    }
  } else {
  }
  status = (enum drm_connector_status )3;
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
    if ((int )((signed char )edid->input) < 0) {
      status = (enum drm_connector_status )1;
      if ((int )intel_sdvo->is_hdmi) {
        {
        intel_sdvo->has_hdmi_monitor = drm_detect_hdmi_monitor(edid);
        intel_sdvo->has_hdmi_audio = drm_detect_monitor_audio(edid);
        }
      } else {
      }
    } else {
      status = (enum drm_connector_status )2;
    }
    {
    connector->display_info.raw_edid = (char *)0;
    kfree((void const *)edid);
    }
  } else {
  }
  if ((unsigned int )status == 1U) {
    {
    tmp___1 = to_intel_sdvo_connector(connector);
    intel_sdvo_connector = tmp___1;
    }
    if (intel_sdvo_connector->force_audio != 0) {
      intel_sdvo->has_hdmi_audio = (bool )(intel_sdvo_connector->force_audio > 0);
    } else {
    }
  } else {
  }
  return (status);
}
}
static enum drm_connector_status intel_sdvo_detect(struct drm_connector *connector ,
                                                   bool force )
{ uint16_t response ;
  struct intel_sdvo *intel_sdvo ;
  struct intel_sdvo *tmp ;
  struct intel_sdvo_connector *intel_sdvo_connector ;
  struct intel_sdvo_connector *tmp___0 ;
  enum drm_connector_status ret ;
  bool tmp___1 ;
  int tmp___2 ;
  unsigned long __ms ;
  unsigned long tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  struct edid *edid ;
  {
  {
  tmp = intel_attached_sdvo(connector);
  intel_sdvo = tmp;
  tmp___0 = to_intel_sdvo_connector(connector);
  intel_sdvo_connector = tmp___0;
  tmp___1 = intel_sdvo_write_cmd(intel_sdvo, (u8 )11, (void const *)0, 0);
  }
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    return ((enum drm_connector_status )3);
  } else {
  }
  if (((int )intel_sdvo->caps.output_flags & 12) != 0) {
    __ms = 30UL;
    goto ldv_38334;
    ldv_38333:
    {
    __const_udelay(4295000UL);
    }
    ldv_38334:
    tmp___3 = __ms;
    __ms = __ms - 1UL;
    if (tmp___3 != 0UL) {
      goto ldv_38333;
    } else {
      goto ldv_38335;
    }
    ldv_38335: ;
  } else {
  }
  {
  tmp___4 = intel_sdvo_read_response(intel_sdvo, (void *)(& response), 2);
  }
  if (tmp___4) {
    tmp___5 = 0;
  } else {
    tmp___5 = 1;
  }
  if (tmp___5) {
    return ((enum drm_connector_status )3);
  } else {
  }
  {
  drm_ut_debug_printk(4U, "drm", "intel_sdvo_detect", "SDVO response %d %d [%x]\n",
                      (int )response & 255, (int )response >> 8, (int )intel_sdvo_connector->output_flag);
  }
  if ((unsigned int )response == 0U) {
    return ((enum drm_connector_status )2);
  } else {
  }
  intel_sdvo->attached_output = response;
  intel_sdvo->has_hdmi_monitor = (bool )0;
  intel_sdvo->has_hdmi_audio = (bool )0;
  if ((unsigned int )((int )intel_sdvo_connector->output_flag & (int )response) == 0U) {
    ret = (enum drm_connector_status )2;
  } else
  if (((int )intel_sdvo_connector->output_flag & 257) != 0) {
    {
    ret = intel_sdvo_hdmi_sink_detect(connector);
    }
  } else {
    {
    edid = intel_sdvo_get_edid(connector);
    }
    if ((unsigned long )edid == (unsigned long )((struct edid *)0)) {
      {
      edid = intel_sdvo_get_analog_edid(connector);
      }
    } else {
    }
    if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
      if ((int )((signed char )edid->input) < 0) {
        ret = (enum drm_connector_status )2;
      } else {
        ret = (enum drm_connector_status )1;
      }
      {
      connector->display_info.raw_edid = (char *)0;
      kfree((void const *)edid);
      }
    } else {
      ret = (enum drm_connector_status )1;
    }
  }
  if ((unsigned int )ret == 1U) {
    intel_sdvo->is_tv = (bool )0;
    intel_sdvo->is_lvds = (bool )0;
    intel_sdvo->base.needs_tv_clock = (bool )0;
    if (((int )response & 12) != 0) {
      intel_sdvo->is_tv = (bool )1;
      intel_sdvo->base.needs_tv_clock = (bool )1;
    } else {
    }
    if (((int )response & 16448) != 0) {
      intel_sdvo->is_lvds = (bool )((unsigned long )intel_sdvo->sdvo_lvds_fixed_mode != (unsigned long )((struct drm_display_mode *)0));
    } else {
    }
  } else {
  }
  return (ret);
}
}
static void intel_sdvo_get_ddc_modes(struct drm_connector *connector )
{ struct edid *edid ;
  struct intel_sdvo_connector *intel_sdvo_connector ;
  struct intel_sdvo_connector *tmp ;
  bool monitor_is_digital ;
  bool connector_is_digital ;
  {
  {
  edid = intel_sdvo_get_edid(connector);
  }
  if ((unsigned long )edid == (unsigned long )((struct edid *)0)) {
    {
    edid = intel_sdvo_get_analog_edid(connector);
    }
  } else {
  }
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
    {
    tmp = to_intel_sdvo_connector(connector);
    intel_sdvo_connector = tmp;
    monitor_is_digital = (bool )((int )((signed char )edid->input) < 0);
    connector_is_digital = (bool )(((int )intel_sdvo_connector->output_flag & 257) != 0);
    }
    if ((int )connector_is_digital == (int )monitor_is_digital) {
      {
      drm_mode_connector_update_edid_property(connector, edid);
      drm_add_edid_modes(connector, edid);
      }
    } else {
    }
    {
    connector->display_info.raw_edid = (char *)0;
    kfree((void const *)edid);
    }
  } else {
  }
  return;
}
}
static struct drm_display_mode const sdvo_tv_modes[19U] =
  { {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'3', (char )'2',
                                                                 (char )'0', (char )'x',
                                                                 (char )'2', (char )'0',
                                                                 (char )'0', (char )'\000'},
      0, (enum drm_mode_status )0, 64, 5815, 320, 321, 384, 416, 0, 200, 201, 232,
      233, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0,
      0, 0, 0},
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'3', (char )'2',
                                                                 (char )'0', (char )'x',
                                                                 (char )'2', (char )'4',
                                                                 (char )'0', (char )'\000'},
      0, (enum drm_mode_status )0, 64, 6814, 320, 321, 384, 416, 0, 240, 241, 272,
      273, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0,
      0, 0, 0},
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'4', (char )'0',
                                                                 (char )'0', (char )'x',
                                                                 (char )'3', (char )'0',
                                                                 (char )'0', (char )'\000'},
      0, (enum drm_mode_status )0, 64, 9910, 400, 401, 464, 496, 0, 300, 301, 332,
      333, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0,
      0, 0, 0},
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'6', (char )'4',
                                                                 (char )'0', (char )'x',
                                                                 (char )'3', (char )'5',
                                                                 (char )'0', (char )'\000'},
      0, (enum drm_mode_status )0, 64, 16913, 640, 641, 704, 736, 0, 350, 351, 382,
      383, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0,
      0, 0, 0},
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'6', (char )'4',
                                                                 (char )'0', (char )'x',
                                                                 (char )'4', (char )'0',
                                                                 (char )'0', (char )'\000'},
      0, (enum drm_mode_status )0, 64, 19121, 640, 641, 704, 736, 0, 400, 401, 432,
      433, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0,
      0, 0, 0},
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'6', (char )'4',
                                                                 (char )'0', (char )'x',
                                                                 (char )'4', (char )'8',
                                                                 (char )'0', (char )'\000'},
      0, (enum drm_mode_status )0, 64, 22654, 640, 641, 704, 736, 0, 480, 481, 512,
      513, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0,
      0, 0, 0},
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'7', (char )'0',
                                                                 (char )'4', (char )'x',
                                                                 (char )'4', (char )'8',
                                                                 (char )'0', (char )'\000'},
      0, (enum drm_mode_status )0, 64, 24624, 704, 705, 768, 800, 0, 480, 481, 512,
      513, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0,
      0, 0, 0},
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'7', (char )'0',
                                                                 (char )'4', (char )'x',
                                                                 (char )'5', (char )'7',
                                                                 (char )'6', (char )'\000'},
      0, (enum drm_mode_status )0, 64, 29232, 704, 705, 768, 800, 0, 576, 577, 608,
      609, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0,
      0, 0, 0},
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'7', (char )'2',
                                                                 (char )'0', (char )'x',
                                                                 (char )'3', (char )'5',
                                                                 (char )'0', (char )'\000'},
      0, (enum drm_mode_status )0, 64, 18751, 720, 721, 784, 816, 0, 350, 351, 382,
      383, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0,
      0, 0, 0},
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'7', (char )'2',
                                                                 (char )'0', (char )'x',
                                                                 (char )'4', (char )'0',
                                                                 (char )'0', (char )'\000'},
      0, (enum drm_mode_status )0, 64, 21199, 720, 721, 784, 816, 0, 400, 401, 432,
      433, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0,
      0, 0, 0},
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'7', (char )'2',
                                                                 (char )'0', (char )'x',
                                                                 (char )'4', (char )'8',
                                                                 (char )'0', (char )'\000'},
      0, (enum drm_mode_status )0, 64, 25116, 720, 721, 784, 816, 0, 480, 481, 512,
      513, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0,
      0, 0, 0},
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'7', (char )'2',
                                                                 (char )'0', (char )'x',
                                                                 (char )'5', (char )'4',
                                                                 (char )'0', (char )'\000'},
      0, (enum drm_mode_status )0, 64, 28054, 720, 721, 784, 816, 0, 540, 541, 572,
      573, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0,
      0, 0, 0},
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'7', (char )'2',
                                                                 (char )'0', (char )'x',
                                                                 (char )'5', (char )'7',
                                                                 (char )'6', (char )'\000'},
      0, (enum drm_mode_status )0, 64, 29816, 720, 721, 784, 816, 0, 576, 577, 608,
      609, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0,
      0, 0, 0},
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'7', (char )'6',
                                                                 (char )'8', (char )'x',
                                                                 (char )'5', (char )'7',
                                                                 (char )'6', (char )'\000'},
      0, (enum drm_mode_status )0, 64, 31570, 768, 769, 832, 864, 0, 576, 577, 608,
      609, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0,
      0, 0, 0},
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'8', (char )'0',
                                                                 (char )'0', (char )'x',
                                                                 (char )'6', (char )'0',
                                                                 (char )'0', (char )'\000'},
      0, (enum drm_mode_status )0, 64, 34030, 800, 801, 864, 896, 0, 600, 601, 632,
      633, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0,
      0, 0, 0},
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'8', (char )'3',
                                                                 (char )'2', (char )'x',
                                                                 (char )'6', (char )'2',
                                                                 (char )'4', (char )'\000'},
      0, (enum drm_mode_status )0, 64, 36581, 832, 833, 896, 928, 0, 624, 625, 656,
      657, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0,
      0, 0, 0},
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'9', (char )'2',
                                                                 (char )'0', (char )'x',
                                                                 (char )'7', (char )'6',
                                                                 (char )'6', (char )'\000'},
      0, (enum drm_mode_status )0, 64, 48707, 920, 921, 984, 1016, 0, 766, 767, 798,
      799, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0,
      0, 0, 0},
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'0',
                                                                 (char )'2', (char )'4',
                                                                 (char )'x', (char )'7',
                                                                 (char )'6', (char )'8',
                                                                 (char )'\000'}, 0,
      (enum drm_mode_status )0, 64, 53827, 1024, 1025, 1088, 1120, 0, 768, 769, 800,
      801, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0,
      0, 0, 0},
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'2',
                                                                 (char )'8', (char )'0',
                                                                 (char )'x', (char )'1',
                                                                 (char )'0', (char )'2',
                                                                 (char )'4', (char )'\000'},
      0, (enum drm_mode_status )0, 64, 87265, 1280, 1281, 1344, 1376, 0, 1024, 1025,
      1056, 1057, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, (int *)0, 0, 0, 0}};
static void intel_sdvo_get_tv_modes(struct drm_connector *connector )
{ struct intel_sdvo *intel_sdvo ;
  struct intel_sdvo *tmp ;
  struct intel_sdvo_sdtv_resolution_request tv_res ;
  uint32_t reply ;
  uint32_t format_map ;
  int i ;
  size_t __len ;
  unsigned long _min1 ;
  unsigned long _min2 ;
  unsigned long tmp___0 ;
  void *__ret ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  struct drm_display_mode *nmode ;
  {
  {
  tmp = intel_attached_sdvo(connector);
  intel_sdvo = tmp;
  reply = 0U;
  format_map = 0U;
  format_map = (uint32_t )(1 << intel_sdvo->tv_format_index);
  _min1 = 4UL;
  _min2 = 3UL;
  }
  if (_min1 < _min2) {
    tmp___0 = _min1;
  } else {
    tmp___0 = _min2;
  }
  {
  __len = tmp___0;
  __ret = memcpy((void *)(& tv_res), (void const *)(& format_map), __len);
  tmp___1 = intel_sdvo_set_target_output(intel_sdvo, (u16 )((int )intel_sdvo->attached_output));
  }
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    return;
  } else {
  }
  {
  tmp___3 = intel_sdvo_write_cmd(intel_sdvo, (u8 )131, (void const *)(& tv_res),
                                 3);
  }
  if (tmp___3) {
    tmp___4 = 0;
  } else {
    tmp___4 = 1;
  }
  if (tmp___4) {
    return;
  } else {
  }
  {
  tmp___5 = intel_sdvo_read_response(intel_sdvo, (void *)(& reply), 3);
  }
  if (tmp___5) {
    tmp___6 = 0;
  } else {
    tmp___6 = 1;
  }
  if (tmp___6) {
    return;
  } else {
  }
  i = 0;
  goto ldv_38367;
  ldv_38366: ;
  if (((uint32_t )(1 << i) & reply) != 0U) {
    {
    nmode = drm_mode_duplicate(connector->dev, (struct drm_display_mode const *)(& sdvo_tv_modes) + (unsigned long )i);
    }
    if ((unsigned long )nmode != (unsigned long )((struct drm_display_mode *)0)) {
      {
      drm_mode_probed_add(connector, nmode);
      }
    } else {
    }
  } else {
  }
  i = i + 1;
  ldv_38367: ;
  if ((unsigned int )i <= 18U) {
    goto ldv_38366;
  } else {
    goto ldv_38368;
  }
  ldv_38368: ;
  return;
}
}
static void intel_sdvo_get_lvds_modes(struct drm_connector *connector )
{ struct intel_sdvo *intel_sdvo ;
  struct intel_sdvo *tmp ;
  struct drm_i915_private *dev_priv ;
  struct drm_display_mode *newmode ;
  int tmp___0 ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  {
  {
  tmp = intel_attached_sdvo(connector);
  intel_sdvo = tmp;
  dev_priv = (struct drm_i915_private *)(connector->dev)->dev_private;
  intel_ddc_get_modes(connector, intel_sdvo->i2c);
  tmp___0 = list_empty((struct list_head const *)(& connector->probed_modes));
  }
  if (tmp___0 == 0) {
    goto end;
  } else {
  }
  if ((unsigned long )dev_priv->sdvo_lvds_vbt_mode != (unsigned long )((struct drm_display_mode *)0)) {
    {
    newmode = drm_mode_duplicate(connector->dev, (struct drm_display_mode const *)dev_priv->sdvo_lvds_vbt_mode);
    }
    if ((unsigned long )newmode != (unsigned long )((struct drm_display_mode *)0)) {
      {
      newmode->type = 72;
      drm_mode_probed_add(connector, newmode);
      }
    } else {
    }
  } else {
  }
  end:
  __mptr = (struct list_head const *)connector->probed_modes.next;
  newmode = (struct drm_display_mode *)__mptr;
  goto ldv_38382;
  ldv_38381: ;
  if ((newmode->type & 8) != 0) {
    {
    intel_sdvo->sdvo_lvds_fixed_mode = drm_mode_duplicate(connector->dev, (struct drm_display_mode const *)newmode);
    drm_mode_set_crtcinfo(intel_sdvo->sdvo_lvds_fixed_mode, 0);
    intel_sdvo->is_lvds = (bool )1;
    }
    goto ldv_38380;
  } else {
  }
  __mptr___0 = (struct list_head const *)newmode->head.next;
  newmode = (struct drm_display_mode *)__mptr___0;
  ldv_38382: ;
  if ((unsigned long )(& newmode->head) != (unsigned long )(& connector->probed_modes)) {
    goto ldv_38381;
  } else {
    goto ldv_38380;
  }
  ldv_38380: ;
  return;
}
}
static int intel_sdvo_get_modes(struct drm_connector *connector )
{ struct intel_sdvo_connector *intel_sdvo_connector ;
  struct intel_sdvo_connector *tmp ;
  int tmp___0 ;
  {
  {
  tmp = to_intel_sdvo_connector(connector);
  intel_sdvo_connector = tmp;
  }
  if (((int )intel_sdvo_connector->output_flag & 12) != 0) {
    {
    intel_sdvo_get_tv_modes(connector);
    }
  } else
  if (((int )intel_sdvo_connector->output_flag & 16448) != 0) {
    {
    intel_sdvo_get_lvds_modes(connector);
    }
  } else {
    {
    intel_sdvo_get_ddc_modes(connector);
    }
  }
  {
  tmp___0 = list_empty((struct list_head const *)(& connector->probed_modes));
  }
  return (tmp___0 == 0);
}
}
static void intel_sdvo_destroy_enhance_property(struct drm_connector *connector )
{ struct intel_sdvo_connector *intel_sdvo_connector ;
  struct intel_sdvo_connector *tmp ;
  struct drm_device *dev ;
  {
  {
  tmp = to_intel_sdvo_connector(connector);
  intel_sdvo_connector = tmp;
  dev = connector->dev;
  }
  if ((unsigned long )intel_sdvo_connector->left != (unsigned long )((struct drm_property *)0)) {
    {
    drm_property_destroy(dev, intel_sdvo_connector->left);
    }
  } else {
  }
  if ((unsigned long )intel_sdvo_connector->right != (unsigned long )((struct drm_property *)0)) {
    {
    drm_property_destroy(dev, intel_sdvo_connector->right);
    }
  } else {
  }
  if ((unsigned long )intel_sdvo_connector->top != (unsigned long )((struct drm_property *)0)) {
    {
    drm_property_destroy(dev, intel_sdvo_connector->top);
    }
  } else {
  }
  if ((unsigned long )intel_sdvo_connector->bottom != (unsigned long )((struct drm_property *)0)) {
    {
    drm_property_destroy(dev, intel_sdvo_connector->bottom);
    }
  } else {
  }
  if ((unsigned long )intel_sdvo_connector->hpos != (unsigned long )((struct drm_property *)0)) {
    {
    drm_property_destroy(dev, intel_sdvo_connector->hpos);
    }
  } else {
  }
  if ((unsigned long )intel_sdvo_connector->vpos != (unsigned long )((struct drm_property *)0)) {
    {
    drm_property_destroy(dev, intel_sdvo_connector->vpos);
    }
  } else {
  }
  if ((unsigned long )intel_sdvo_connector->saturation != (unsigned long )((struct drm_property *)0)) {
    {
    drm_property_destroy(dev, intel_sdvo_connector->saturation);
    }
  } else {
  }
  if ((unsigned long )intel_sdvo_connector->contrast != (unsigned long )((struct drm_property *)0)) {
    {
    drm_property_destroy(dev, intel_sdvo_connector->contrast);
    }
  } else {
  }
  if ((unsigned long )intel_sdvo_connector->hue != (unsigned long )((struct drm_property *)0)) {
    {
    drm_property_destroy(dev, intel_sdvo_connector->hue);
    }
  } else {
  }
  if ((unsigned long )intel_sdvo_connector->sharpness != (unsigned long )((struct drm_property *)0)) {
    {
    drm_property_destroy(dev, intel_sdvo_connector->sharpness);
    }
  } else {
  }
  if ((unsigned long )intel_sdvo_connector->flicker_filter != (unsigned long )((struct drm_property *)0)) {
    {
    drm_property_destroy(dev, intel_sdvo_connector->flicker_filter);
    }
  } else {
  }
  if ((unsigned long )intel_sdvo_connector->flicker_filter_2d != (unsigned long )((struct drm_property *)0)) {
    {
    drm_property_destroy(dev, intel_sdvo_connector->flicker_filter_2d);
    }
  } else {
  }
  if ((unsigned long )intel_sdvo_connector->flicker_filter_adaptive != (unsigned long )((struct drm_property *)0)) {
    {
    drm_property_destroy(dev, intel_sdvo_connector->flicker_filter_adaptive);
    }
  } else {
  }
  if ((unsigned long )intel_sdvo_connector->tv_luma_filter != (unsigned long )((struct drm_property *)0)) {
    {
    drm_property_destroy(dev, intel_sdvo_connector->tv_luma_filter);
    }
  } else {
  }
  if ((unsigned long )intel_sdvo_connector->tv_chroma_filter != (unsigned long )((struct drm_property *)0)) {
    {
    drm_property_destroy(dev, intel_sdvo_connector->tv_chroma_filter);
    }
  } else {
  }
  if ((unsigned long )intel_sdvo_connector->dot_crawl != (unsigned long )((struct drm_property *)0)) {
    {
    drm_property_destroy(dev, intel_sdvo_connector->dot_crawl);
    }
  } else {
  }
  if ((unsigned long )intel_sdvo_connector->brightness != (unsigned long )((struct drm_property *)0)) {
    {
    drm_property_destroy(dev, intel_sdvo_connector->brightness);
    }
  } else {
  }
  return;
}
}
static void intel_sdvo_destroy(struct drm_connector *connector )
{ struct intel_sdvo_connector *intel_sdvo_connector ;
  struct intel_sdvo_connector *tmp ;
  {
  {
  tmp = to_intel_sdvo_connector(connector);
  intel_sdvo_connector = tmp;
  }
  if ((unsigned long )intel_sdvo_connector->tv_format != (unsigned long )((struct drm_property *)0)) {
    {
    drm_property_destroy(connector->dev, intel_sdvo_connector->tv_format);
    }
  } else {
  }
  {
  intel_sdvo_destroy_enhance_property(connector);
  drm_sysfs_connector_remove(connector);
  drm_connector_cleanup(connector);
  kfree((void const *)connector);
  }
  return;
}
}
static bool intel_sdvo_detect_hdmi_audio(struct drm_connector *connector )
{ struct intel_sdvo *intel_sdvo ;
  struct intel_sdvo *tmp ;
  struct edid *edid ;
  bool has_audio ;
  {
  {
  tmp = intel_attached_sdvo(connector);
  intel_sdvo = tmp;
  has_audio = (bool )0;
  }
  if (! intel_sdvo->is_hdmi) {
    return ((bool )0);
  } else {
  }
  {
  edid = intel_sdvo_get_edid(connector);
  }
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
    if ((int )((signed char )edid->input) < 0) {
      {
      has_audio = drm_detect_monitor_audio(edid);
      }
    } else {
    }
  } else {
  }
  return (has_audio);
}
}
static int intel_sdvo_set_property(struct drm_connector *connector , struct drm_property *property ,
                                   uint64_t val )
{ struct intel_sdvo *intel_sdvo ;
  struct intel_sdvo *tmp ;
  struct intel_sdvo_connector *intel_sdvo_connector ;
  struct intel_sdvo_connector *tmp___0 ;
  struct drm_i915_private *dev_priv ;
  uint16_t temp_value ;
  uint8_t cmd ;
  int ret ;
  int i ;
  bool has_audio ;
  bool tmp___1 ;
  int tmp___2 ;
  struct drm_crtc *crtc ;
  {
  {
  tmp = intel_attached_sdvo(connector);
  intel_sdvo = tmp;
  tmp___0 = to_intel_sdvo_connector(connector);
  intel_sdvo_connector = tmp___0;
  dev_priv = (struct drm_i915_private *)(connector->dev)->dev_private;
  ret = drm_connector_property_set_value(connector, property, val);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  if ((unsigned long )dev_priv->force_audio_property == (unsigned long )property) {
    i = (int )val;
    if (intel_sdvo_connector->force_audio == i) {
      return (0);
    } else {
    }
    intel_sdvo_connector->force_audio = i;
    if (i == 0) {
      {
      has_audio = intel_sdvo_detect_hdmi_audio(connector);
      }
    } else {
      has_audio = (bool )(i > 0);
    }
    if ((int )intel_sdvo->has_hdmi_audio == (int )has_audio) {
      return (0);
    } else {
    }
    intel_sdvo->has_hdmi_audio = has_audio;
    goto done;
  } else {
  }
  if ((unsigned long )dev_priv->broadcast_rgb_property == (unsigned long )property) {
    if ((uint64_t )(intel_sdvo->color_range != 0U) == val) {
      return (0);
    } else {
    }
    if (val != 0ULL) {
      intel_sdvo->color_range = 256U;
    } else {
      intel_sdvo->color_range = 0U;
    }
    goto done;
  } else {
  }
  if ((unsigned long )intel_sdvo_connector->tv_format == (unsigned long )property) {
    if (val > 18ULL) {
      return (-22);
    } else {
    }
    if (intel_sdvo->tv_format_index == (int )intel_sdvo_connector->tv_format_supported[val]) {
      return (0);
    } else {
    }
    intel_sdvo->tv_format_index = (int )intel_sdvo_connector->tv_format_supported[val];
    goto done;
  } else
  if (((int )intel_sdvo_connector->output_flag & 16460) != 0) {
    temp_value = (uint16_t )val;
    if ((unsigned long )intel_sdvo_connector->left == (unsigned long )property) {
      {
      drm_connector_property_set_value(connector, intel_sdvo_connector->right, val);
      }
      if (intel_sdvo_connector->left_margin == (u32 )temp_value) {
        return (0);
      } else {
      }
      intel_sdvo_connector->left_margin = (u32 )temp_value;
      intel_sdvo_connector->right_margin = (u32 )temp_value;
      temp_value = (uint16_t )((int )((uint16_t )intel_sdvo_connector->max_hscan) - (int )((uint16_t )intel_sdvo_connector->left_margin));
      cmd = (uint8_t )99U;
      goto set_value;
    } else
    if ((unsigned long )intel_sdvo_connector->right == (unsigned long )property) {
      {
      drm_connector_property_set_value(connector, intel_sdvo_connector->left, val);
      }
      if (intel_sdvo_connector->right_margin == (u32 )temp_value) {
        return (0);
      } else {
      }
      intel_sdvo_connector->left_margin = (u32 )temp_value;
      intel_sdvo_connector->right_margin = (u32 )temp_value;
      temp_value = (uint16_t )((int )((uint16_t )intel_sdvo_connector->max_hscan) - (int )((uint16_t )intel_sdvo_connector->left_margin));
      cmd = (uint8_t )99U;
      goto set_value;
    } else
    if ((unsigned long )intel_sdvo_connector->top == (unsigned long )property) {
      {
      drm_connector_property_set_value(connector, intel_sdvo_connector->bottom, val);
      }
      if (intel_sdvo_connector->top_margin == (u32 )temp_value) {
        return (0);
      } else {
      }
      intel_sdvo_connector->top_margin = (u32 )temp_value;
      intel_sdvo_connector->bottom_margin = (u32 )temp_value;
      temp_value = (uint16_t )((int )((uint16_t )intel_sdvo_connector->max_vscan) - (int )((uint16_t )intel_sdvo_connector->top_margin));
      cmd = (uint8_t )102U;
      goto set_value;
    } else
    if ((unsigned long )intel_sdvo_connector->bottom == (unsigned long )property) {
      {
      drm_connector_property_set_value(connector, intel_sdvo_connector->top, val);
      }
      if (intel_sdvo_connector->bottom_margin == (u32 )temp_value) {
        return (0);
      } else {
      }
      intel_sdvo_connector->top_margin = (u32 )temp_value;
      intel_sdvo_connector->bottom_margin = (u32 )temp_value;
      temp_value = (uint16_t )((int )((uint16_t )intel_sdvo_connector->max_vscan) - (int )((uint16_t )intel_sdvo_connector->top_margin));
      cmd = (uint8_t )102U;
      goto set_value;
    } else {
    }
    if ((unsigned long )intel_sdvo_connector->hpos == (unsigned long )property) {
      if (intel_sdvo_connector->cur_hpos == (u32 )temp_value) {
        return (0);
      } else {
      }
      if (intel_sdvo_connector->max_hpos < (u32 )temp_value) {
        return (-22);
      } else {
      }
      cmd = (uint8_t )105U;
      intel_sdvo_connector->cur_hpos = (u32 )temp_value;
      goto set_value;
    } else {
    }
    if ((unsigned long )intel_sdvo_connector->vpos == (unsigned long )property) {
      if (intel_sdvo_connector->cur_vpos == (u32 )temp_value) {
        return (0);
      } else {
      }
      if (intel_sdvo_connector->max_vpos < (u32 )temp_value) {
        return (-22);
      } else {
      }
      cmd = (uint8_t )108U;
      intel_sdvo_connector->cur_vpos = (u32 )temp_value;
      goto set_value;
    } else {
    }
    if ((unsigned long )intel_sdvo_connector->saturation == (unsigned long )property) {
      if (intel_sdvo_connector->cur_saturation == (u32 )temp_value) {
        return (0);
      } else {
      }
      if (intel_sdvo_connector->max_saturation < (u32 )temp_value) {
        return (-22);
      } else {
      }
      cmd = (uint8_t )87U;
      intel_sdvo_connector->cur_saturation = (u32 )temp_value;
      goto set_value;
    } else {
    }
    if ((unsigned long )intel_sdvo_connector->contrast == (unsigned long )property) {
      if (intel_sdvo_connector->cur_contrast == (u32 )temp_value) {
        return (0);
      } else {
      }
      if (intel_sdvo_connector->max_contrast < (u32 )temp_value) {
        return (-22);
      } else {
      }
      cmd = (uint8_t )96U;
      intel_sdvo_connector->cur_contrast = (u32 )temp_value;
      goto set_value;
    } else {
    }
    if ((unsigned long )intel_sdvo_connector->hue == (unsigned long )property) {
      if (intel_sdvo_connector->cur_hue == (u32 )temp_value) {
        return (0);
      } else {
      }
      if (intel_sdvo_connector->max_hue < (u32 )temp_value) {
        return (-22);
      } else {
      }
      cmd = (uint8_t )90U;
      intel_sdvo_connector->cur_hue = (u32 )temp_value;
      goto set_value;
    } else {
    }
    if ((unsigned long )intel_sdvo_connector->brightness == (unsigned long )property) {
      if (intel_sdvo_connector->cur_brightness == (u32 )temp_value) {
        return (0);
      } else {
      }
      if (intel_sdvo_connector->max_brightness < (u32 )temp_value) {
        return (-22);
      } else {
      }
      cmd = (uint8_t )93U;
      intel_sdvo_connector->cur_brightness = (u32 )temp_value;
      goto set_value;
    } else {
    }
    if ((unsigned long )intel_sdvo_connector->sharpness == (unsigned long )property) {
      if (intel_sdvo_connector->cur_sharpness == (u32 )temp_value) {
        return (0);
      } else {
      }
      if (intel_sdvo_connector->max_sharpness < (u32 )temp_value) {
        return (-22);
      } else {
      }
      cmd = (uint8_t )111U;
      intel_sdvo_connector->cur_sharpness = (u32 )temp_value;
      goto set_value;
    } else {
    }
    if ((unsigned long )intel_sdvo_connector->flicker_filter == (unsigned long )property) {
      if (intel_sdvo_connector->cur_flicker_filter == (u32 )temp_value) {
        return (0);
      } else {
      }
      if (intel_sdvo_connector->max_flicker_filter < (u32 )temp_value) {
        return (-22);
      } else {
      }
      cmd = (uint8_t )79U;
      intel_sdvo_connector->cur_flicker_filter = (u32 )temp_value;
      goto set_value;
    } else {
    }
    if ((unsigned long )intel_sdvo_connector->flicker_filter_2d == (unsigned long )property) {
      if (intel_sdvo_connector->cur_flicker_filter_2d == (u32 )temp_value) {
        return (0);
      } else {
      }
      if (intel_sdvo_connector->max_flicker_filter_2d < (u32 )temp_value) {
        return (-22);
      } else {
      }
      cmd = (uint8_t )84U;
      intel_sdvo_connector->cur_flicker_filter_2d = (u32 )temp_value;
      goto set_value;
    } else {
    }
    if ((unsigned long )intel_sdvo_connector->flicker_filter_adaptive == (unsigned long )property) {
      if (intel_sdvo_connector->cur_flicker_filter_adaptive == (u32 )temp_value) {
        return (0);
      } else {
      }
      if (intel_sdvo_connector->max_flicker_filter_adaptive < (u32 )temp_value) {
        return (-22);
      } else {
      }
      cmd = (uint8_t )81U;
      intel_sdvo_connector->cur_flicker_filter_adaptive = (u32 )temp_value;
      goto set_value;
    } else {
    }
    if ((unsigned long )intel_sdvo_connector->tv_chroma_filter == (unsigned long )property) {
      if (intel_sdvo_connector->cur_tv_chroma_filter == (u32 )temp_value) {
        return (0);
      } else {
      }
      if (intel_sdvo_connector->max_tv_chroma_filter < (u32 )temp_value) {
        return (-22);
      } else {
      }
      cmd = (uint8_t )118U;
      intel_sdvo_connector->cur_tv_chroma_filter = (u32 )temp_value;
      goto set_value;
    } else {
    }
    if ((unsigned long )intel_sdvo_connector->tv_luma_filter == (unsigned long )property) {
      if (intel_sdvo_connector->cur_tv_luma_filter == (u32 )temp_value) {
        return (0);
      } else {
      }
      if (intel_sdvo_connector->max_tv_luma_filter < (u32 )temp_value) {
        return (-22);
      } else {
      }
      cmd = (uint8_t )121U;
      intel_sdvo_connector->cur_tv_luma_filter = (u32 )temp_value;
      goto set_value;
    } else {
    }
    if ((unsigned long )intel_sdvo_connector->dot_crawl == (unsigned long )property) {
      if (intel_sdvo_connector->cur_dot_crawl == (u32 )temp_value) {
        return (0);
      } else {
      }
      if (intel_sdvo_connector->max_dot_crawl < (u32 )temp_value) {
        return (-22);
      } else {
      }
      cmd = (uint8_t )113U;
      intel_sdvo_connector->cur_dot_crawl = (u32 )temp_value;
      goto set_value;
    } else {
    }
  } else {
  }
  return (-22);
  set_value:
  {
  tmp___1 = intel_sdvo_set_value(intel_sdvo, (u8 )((int )cmd), (void const *)(& temp_value),
                                 2);
  }
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    return (-5);
  } else {
  }
  done: ;
  if ((unsigned long )intel_sdvo->base.base.crtc != (unsigned long )((struct drm_crtc *)0)) {
    {
    crtc = intel_sdvo->base.base.crtc;
    drm_crtc_helper_set_mode(crtc, & crtc->mode, crtc->x, crtc->y, crtc->fb);
    }
  } else {
  }
  return (0);
}
}
static struct drm_encoder_helper_funcs const intel_sdvo_helper_funcs =
     {& intel_sdvo_dpms, (void (*)(struct drm_encoder * ))0, (void (*)(struct drm_encoder * ))0,
    & intel_sdvo_mode_fixup, & intel_encoder_prepare, & intel_encoder_commit, & intel_sdvo_mode_set,
    (struct drm_crtc *(*)(struct drm_encoder * ))0, (enum drm_connector_status (*)(struct drm_encoder * ,
                                                                                   struct drm_connector * ))0,
    (void (*)(struct drm_encoder * ))0};
static struct drm_connector_funcs const intel_sdvo_connector_funcs =
     {& drm_helper_connector_dpms, (void (*)(struct drm_connector * ))0, (void (*)(struct drm_connector * ))0,
    (void (*)(struct drm_connector * ))0, & intel_sdvo_detect, & drm_helper_probe_single_connector_modes,
    & intel_sdvo_set_property, & intel_sdvo_destroy, (void (*)(struct drm_connector * ))0};
static struct drm_connector_helper_funcs const intel_sdvo_connector_helper_funcs = {& intel_sdvo_get_modes,
    & intel_sdvo_mode_valid, & intel_best_encoder};
static void intel_sdvo_enc_destroy(struct drm_encoder *encoder )
{ struct intel_sdvo *intel_sdvo ;
  struct intel_sdvo *tmp ;
  {
  {
  tmp = to_intel_sdvo(encoder);
  intel_sdvo = tmp;
  }
  if ((unsigned long )intel_sdvo->sdvo_lvds_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
    {
    drm_mode_destroy(encoder->dev, intel_sdvo->sdvo_lvds_fixed_mode);
    }
  } else {
  }
  {
  i2c_del_adapter(& intel_sdvo->ddc);
  intel_encoder_destroy(encoder);
  }
  return;
}
}
static struct drm_encoder_funcs const intel_sdvo_enc_funcs = {(void (*)(struct drm_encoder * ))0, & intel_sdvo_enc_destroy};
static void intel_sdvo_guess_ddc_bus(struct intel_sdvo *sdvo )
{ uint16_t mask ;
  unsigned int num_bits ;
  {
  mask = (uint16_t )0U;
  if ((int )sdvo->controlled_output == 16384) {
    goto case_16384;
  } else
  if ((int )sdvo->controlled_output == 64) {
    goto case_64;
  } else
  if ((int )sdvo->controlled_output == 256) {
    goto case_256;
  } else
  if ((int )sdvo->controlled_output == 1) {
    goto case_1;
  } else
  if ((int )sdvo->controlled_output == 512) {
    goto case_512;
  } else
  if ((int )sdvo->controlled_output == 2) {
    goto case_2;
  } else
  if (0) {
    case_16384:
    mask = (uint16_t )((unsigned int )mask | 16384U);
    case_64:
    mask = (uint16_t )((unsigned int )mask | 64U);
    case_256:
    mask = (uint16_t )((unsigned int )mask | 256U);
    case_1:
    mask = (uint16_t )((unsigned int )mask | 1U);
    case_512:
    mask = (uint16_t )((unsigned int )mask | 512U);
    case_2:
    mask = (uint16_t )((unsigned int )mask | 2U);
    goto ldv_38437;
  } else {
  }
  ldv_38437:
  {
  mask = (uint16_t )((int )sdvo->caps.output_flags & (int )mask);
  num_bits = __arch_hweight16((unsigned int )mask);
  }
  if (num_bits > 3U) {
    num_bits = 3U;
  } else {
  }
  sdvo->ddc_bus = (uint8_t )(1 << (int )num_bits);
  return;
}
}
static void intel_sdvo_select_ddc_bus(struct drm_i915_private *dev_priv , struct intel_sdvo *sdvo ,
                                      u32 reg )
{ struct sdvo_device_mapping *mapping ;
  {
  if (reg == 397632U) {
    mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings);
  } else
  if (reg == 921920U) {
    mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings);
  } else {
    mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings) + 1UL;
  }
  if ((unsigned int )mapping->initialized != 0U) {
    sdvo->ddc_bus = (uint8_t )(1 << ((int )mapping->ddc_pin >> 4));
  } else {
    {
    intel_sdvo_guess_ddc_bus(sdvo);
    }
  }
  return;
}
}
static void intel_sdvo_select_i2c_bus(struct drm_i915_private *dev_priv , struct intel_sdvo *sdvo ,
                                      u32 reg )
{ struct sdvo_device_mapping *mapping ;
  u8 pin ;
  u8 speed ;
  {
  if (reg == 397632U) {
    mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings);
  } else
  if (reg == 921920U) {
    mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings);
  } else {
    mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings) + 1UL;
  }
  pin = (u8 )5U;
  speed = (u8 )3U;
  if ((unsigned int )mapping->initialized != 0U) {
    pin = mapping->i2c_pin;
    speed = mapping->i2c_speed;
  } else {
  }
  if ((unsigned int )pin <= 7U) {
    {
    sdvo->i2c = & (dev_priv->gmbus + (unsigned long )pin)->adapter;
    intel_gmbus_set_speed(sdvo->i2c, (int )speed);
    intel_gmbus_force_bit(sdvo->i2c, (bool )1);
    }
  } else {
    sdvo->i2c = & (dev_priv->gmbus + 5UL)->adapter;
  }
  return;
}
}
static bool intel_sdvo_is_hdmi_connector(struct intel_sdvo *intel_sdvo , int device )
{ bool tmp ;
  {
  {
  tmp = intel_sdvo_check_supp_encode(intel_sdvo);
  }
  return (tmp);
}
}
static u8 intel_sdvo_get_slave_addr(struct drm_device *dev , int sdvo_reg )
{ struct drm_i915_private *dev_priv ;
  struct sdvo_device_mapping *my_mapping ;
  struct sdvo_device_mapping *other_mapping ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if (sdvo_reg == 397632) {
    my_mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings);
    other_mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings) + 1UL;
  } else
  if (sdvo_reg == 921920) {
    my_mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings);
    other_mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings) + 1UL;
  } else {
    my_mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings) + 1UL;
    other_mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings);
  }
  if ((unsigned int )my_mapping->slave_addr != 0U) {
    return (my_mapping->slave_addr);
  } else {
  }
  if ((unsigned int )other_mapping->slave_addr != 0U) {
    if ((unsigned int )other_mapping->slave_addr == 112U) {
      return ((u8 )114U);
    } else {
      return ((u8 )112U);
    }
  } else {
  }
  if (sdvo_reg == 397632) {
    return ((u8 )112U);
  } else
  if (sdvo_reg == 921920) {
    return ((u8 )112U);
  } else {
    return ((u8 )114U);
  }
}
}
static void intel_sdvo_connector_init(struct intel_sdvo_connector *connector , struct intel_sdvo *encoder )
{
  {
  {
  drm_connector_init(encoder->base.base.dev, & connector->base.base, & intel_sdvo_connector_funcs,
                     connector->base.base.connector_type);
  drm_connector_helper_add(& connector->base.base, & intel_sdvo_connector_helper_funcs);
  connector->base.base.interlace_allowed = (bool )0;
  connector->base.base.doublescan_allowed = (bool )0;
  connector->base.base.display_info.subpixel_order = (enum subpixel_order )1;
  intel_connector_attach_encoder(& connector->base, & encoder->base);
  drm_sysfs_connector_add(& connector->base.base);
  }
  return;
}
}
static void intel_sdvo_add_hdmi_properties(struct intel_sdvo_connector *connector )
{ struct drm_device *dev ;
  {
  {
  dev = connector->base.base.dev;
  intel_attach_force_audio_property(& connector->base.base);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
      {
      intel_attach_broadcast_rgb_property(& connector->base.base);
      }
    } else {
    }
  } else {
  }
  return;
}
}
static bool intel_sdvo_dvi_init(struct intel_sdvo *intel_sdvo , int device )
{ struct drm_encoder *encoder ;
  struct drm_connector *connector ;
  struct intel_connector *intel_connector ;
  struct intel_sdvo_connector *intel_sdvo_connector ;
  void *tmp ;
  bool tmp___0 ;
  {
  {
  encoder = & intel_sdvo->base.base;
  tmp = kzalloc(1880UL, 208U);
  intel_sdvo_connector = (struct intel_sdvo_connector *)tmp;
  }
  if ((unsigned long )intel_sdvo_connector == (unsigned long )((struct intel_sdvo_connector *)0)) {
    return ((bool )0);
  } else {
  }
  if (device == 0) {
    intel_sdvo->controlled_output = (uint16_t )((unsigned int )intel_sdvo->controlled_output | 1U);
    intel_sdvo_connector->output_flag = (uint16_t )1U;
  } else
  if (device == 1) {
    intel_sdvo->controlled_output = (uint16_t )((unsigned int )intel_sdvo->controlled_output | 256U);
    intel_sdvo_connector->output_flag = (uint16_t )256U;
  } else {
  }
  {
  intel_connector = & intel_sdvo_connector->base;
  connector = & intel_connector->base;
  connector->polled = (uint8_t )6U;
  encoder->encoder_type = 2;
  connector->connector_type = 3;
  tmp___0 = intel_sdvo_is_hdmi_connector(intel_sdvo, device);
  }
  if ((int )tmp___0) {
    connector->connector_type = 11;
    intel_sdvo->is_hdmi = (bool )1;
  } else {
  }
  {
  intel_sdvo->base.clone_mask = 576;
  intel_sdvo_connector_init(intel_sdvo_connector, intel_sdvo);
  }
  if ((int )intel_sdvo->is_hdmi) {
    {
    intel_sdvo_add_hdmi_properties(intel_sdvo_connector);
    }
  } else {
  }
  return ((bool )1);
}
}
static bool intel_sdvo_tv_init(struct intel_sdvo *intel_sdvo , int type )
{ struct drm_encoder *encoder ;
  struct drm_connector *connector ;
  struct intel_connector *intel_connector ;
  struct intel_sdvo_connector *intel_sdvo_connector ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  {
  {
  encoder = & intel_sdvo->base.base;
  tmp = kzalloc(1880UL, 208U);
  intel_sdvo_connector = (struct intel_sdvo_connector *)tmp;
  }
  if ((unsigned long )intel_sdvo_connector == (unsigned long )((struct intel_sdvo_connector *)0)) {
    return ((bool )0);
  } else {
  }
  {
  intel_connector = & intel_sdvo_connector->base;
  connector = & intel_connector->base;
  encoder->encoder_type = 4;
  connector->connector_type = 6;
  intel_sdvo->controlled_output = (uint16_t )((int )((short )intel_sdvo->controlled_output) | (int )((short )type));
  intel_sdvo_connector->output_flag = (uint16_t )type;
  intel_sdvo->is_tv = (bool )1;
  intel_sdvo->base.needs_tv_clock = (bool )1;
  intel_sdvo->base.clone_mask = 128;
  intel_sdvo_connector_init(intel_sdvo_connector, intel_sdvo);
  tmp___0 = intel_sdvo_tv_create_property(intel_sdvo, intel_sdvo_connector, type);
  }
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    goto err;
  } else {
  }
  {
  tmp___2 = intel_sdvo_create_enhance_property(intel_sdvo, intel_sdvo_connector);
  }
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    goto err;
  } else {
  }
  return ((bool )1);
  err:
  {
  intel_sdvo_destroy(connector);
  }
  return ((bool )0);
}
}
static bool intel_sdvo_analog_init(struct intel_sdvo *intel_sdvo , int device )
{ struct drm_encoder *encoder ;
  struct drm_connector *connector ;
  struct intel_connector *intel_connector ;
  struct intel_sdvo_connector *intel_sdvo_connector ;
  void *tmp ;
  {
  {
  encoder = & intel_sdvo->base.base;
  tmp = kzalloc(1880UL, 208U);
  intel_sdvo_connector = (struct intel_sdvo_connector *)tmp;
  }
  if ((unsigned long )intel_sdvo_connector == (unsigned long )((struct intel_sdvo_connector *)0)) {
    return ((bool )0);
  } else {
  }
  intel_connector = & intel_sdvo_connector->base;
  connector = & intel_connector->base;
  connector->polled = (uint8_t )2U;
  encoder->encoder_type = 1;
  connector->connector_type = 1;
  if (device == 0) {
    intel_sdvo->controlled_output = (uint16_t )((unsigned int )intel_sdvo->controlled_output | 2U);
    intel_sdvo_connector->output_flag = (uint16_t )2U;
  } else
  if (device == 1) {
    intel_sdvo->controlled_output = (uint16_t )((unsigned int )intel_sdvo->controlled_output | 512U);
    intel_sdvo_connector->output_flag = (uint16_t )512U;
  } else {
  }
  {
  intel_sdvo->base.clone_mask = 576;
  intel_sdvo_connector_init(intel_sdvo_connector, intel_sdvo);
  }
  return ((bool )1);
}
}
static bool intel_sdvo_lvds_init(struct intel_sdvo *intel_sdvo , int device )
{ struct drm_encoder *encoder ;
  struct drm_connector *connector ;
  struct intel_connector *intel_connector ;
  struct intel_sdvo_connector *intel_sdvo_connector ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  {
  {
  encoder = & intel_sdvo->base.base;
  tmp = kzalloc(1880UL, 208U);
  intel_sdvo_connector = (struct intel_sdvo_connector *)tmp;
  }
  if ((unsigned long )intel_sdvo_connector == (unsigned long )((struct intel_sdvo_connector *)0)) {
    return ((bool )0);
  } else {
  }
  intel_connector = & intel_sdvo_connector->base;
  connector = & intel_connector->base;
  encoder->encoder_type = 3;
  connector->connector_type = 7;
  if (device == 0) {
    intel_sdvo->controlled_output = (uint16_t )((unsigned int )intel_sdvo->controlled_output | 64U);
    intel_sdvo_connector->output_flag = (uint16_t )64U;
  } else
  if (device == 1) {
    intel_sdvo->controlled_output = (uint16_t )((unsigned int )intel_sdvo->controlled_output | 16384U);
    intel_sdvo_connector->output_flag = (uint16_t )16384U;
  } else {
  }
  {
  intel_sdvo->base.clone_mask = 768;
  intel_sdvo_connector_init(intel_sdvo_connector, intel_sdvo);
  tmp___0 = intel_sdvo_create_enhance_property(intel_sdvo, intel_sdvo_connector);
  }
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    goto err;
  } else {
  }
  return ((bool )1);
  err:
  {
  intel_sdvo_destroy(connector);
  }
  return ((bool )0);
}
}
static bool intel_sdvo_output_setup(struct intel_sdvo *intel_sdvo , uint16_t flags )
{ bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  bool tmp___13 ;
  int tmp___14 ;
  unsigned char bytes[2U] ;
  size_t __len ;
  void *__ret ;
  char *tmp___15 ;
  {
  intel_sdvo->is_tv = (bool )0;
  intel_sdvo->base.needs_tv_clock = (bool )0;
  intel_sdvo->is_lvds = (bool )0;
  if ((int )flags & 1) {
    {
    tmp = intel_sdvo_dvi_init(intel_sdvo, 0);
    }
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      return ((bool )0);
    } else {
    }
  } else {
  }
  if (((int )flags & 257) == 257) {
    {
    tmp___1 = intel_sdvo_dvi_init(intel_sdvo, 1);
    }
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    if (tmp___2) {
      return ((bool )0);
    } else {
    }
  } else {
  }
  if (((int )flags & 8) != 0) {
    {
    tmp___3 = intel_sdvo_tv_init(intel_sdvo, 8);
    }
    if (tmp___3) {
      tmp___4 = 0;
    } else {
      tmp___4 = 1;
    }
    if (tmp___4) {
      return ((bool )0);
    } else {
    }
  } else {
  }
  if (((int )flags & 4) != 0) {
    {
    tmp___5 = intel_sdvo_tv_init(intel_sdvo, 4);
    }
    if (tmp___5) {
      tmp___6 = 0;
    } else {
      tmp___6 = 1;
    }
    if (tmp___6) {
      return ((bool )0);
    } else {
    }
  } else {
  }
  if (((int )flags & 2) != 0) {
    {
    tmp___7 = intel_sdvo_analog_init(intel_sdvo, 0);
    }
    if (tmp___7) {
      tmp___8 = 0;
    } else {
      tmp___8 = 1;
    }
    if (tmp___8) {
      return ((bool )0);
    } else {
    }
  } else {
  }
  if (((int )flags & 514) == 514) {
    {
    tmp___9 = intel_sdvo_analog_init(intel_sdvo, 1);
    }
    if (tmp___9) {
      tmp___10 = 0;
    } else {
      tmp___10 = 1;
    }
    if (tmp___10) {
      return ((bool )0);
    } else {
    }
  } else {
  }
  if (((int )flags & 64) != 0) {
    {
    tmp___11 = intel_sdvo_lvds_init(intel_sdvo, 0);
    }
    if (tmp___11) {
      tmp___12 = 0;
    } else {
      tmp___12 = 1;
    }
    if (tmp___12) {
      return ((bool )0);
    } else {
    }
  } else {
  }
  if (((int )flags & 16448) == 16448) {
    {
    tmp___13 = intel_sdvo_lvds_init(intel_sdvo, 1);
    }
    if (tmp___13) {
      tmp___14 = 0;
    } else {
      tmp___14 = 1;
    }
    if (tmp___14) {
      return ((bool )0);
    } else {
    }
  } else {
  }
  if (((int )flags & 17231) == 0) {
    intel_sdvo->controlled_output = (uint16_t )0U;
    __len = 2UL;
    if (__len > 63UL) {
      {
      __ret = memcpy((void *)(& bytes), (void const *)(& intel_sdvo->caps.output_flags),
                       __len);
      }
    } else {
      {
      __ret = memcpy((void *)(& bytes), (void const *)(& intel_sdvo->caps.output_flags),
                               __len);
      }
    }
    if (intel_sdvo->sdvo_reg == 397632) {
      tmp___15 = (char *)"SDVOB";
    } else
    if (intel_sdvo->sdvo_reg == 921920) {
      tmp___15 = (char *)"SDVOB";
    } else {
      tmp___15 = (char *)"SDVOC";
    }
    {
    drm_ut_debug_printk(4U, "drm", "intel_sdvo_output_setup", "%s: Unknown SDVO output type (0x%02x%02x)\n",
                        tmp___15, (int )bytes[0], (int )bytes[1]);
    }
    return ((bool )0);
  } else {
  }
  intel_sdvo->base.crtc_mask = 3;
  return ((bool )1);
}
}
static bool intel_sdvo_tv_create_property(struct intel_sdvo *intel_sdvo , struct intel_sdvo_connector *intel_sdvo_connector ,
                                          int type )
{ struct drm_device *dev ;
  struct intel_sdvo_tv_format format ;
  uint32_t format_map ;
  uint32_t i ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  size_t __len ;
  unsigned long _min1 ;
  unsigned long _min2 ;
  unsigned long tmp___3 ;
  void *__ret ;
  int tmp___4 ;
  {
  {
  dev = intel_sdvo->base.base.dev;
  tmp = intel_sdvo_set_target_output(intel_sdvo, (u16 )((int )((u16 )type)));
  }
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return ((bool )0);
  } else {
  }
  {
  tmp___1 = intel_sdvo_get_value(intel_sdvo, (u8 )39, (void *)(& format), 6);
  }
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    return ((bool )0);
  } else {
  }
  _min1 = 4UL;
  _min2 = 6UL;
  if (_min1 < _min2) {
    tmp___3 = _min1;
  } else {
    tmp___3 = _min2;
  }
  {
  __len = tmp___3;
  __ret = memcpy((void *)(& format_map), (void const *)(& format), __len);
  }
  if (format_map == 0U) {
    return ((bool )0);
  } else {
  }
  intel_sdvo_connector->format_supported_num = 0;
  i = 0U;
  goto ldv_38533;
  ldv_38532: ;
  if (((uint32_t )(1 << (int )i) & format_map) != 0U) {
    tmp___4 = intel_sdvo_connector->format_supported_num;
    intel_sdvo_connector->format_supported_num = intel_sdvo_connector->format_supported_num + 1;
    intel_sdvo_connector->tv_format_supported[tmp___4] = (u8 )i;
  } else {
  }
  i = i + 1U;
  ldv_38533: ;
  if (i <= 18U) {
    goto ldv_38532;
  } else {
    goto ldv_38534;
  }
  ldv_38534:
  {
  intel_sdvo_connector->tv_format = drm_property_create(dev, 8, "mode", intel_sdvo_connector->format_supported_num);
  }
  if ((unsigned long )intel_sdvo_connector->tv_format == (unsigned long )((struct drm_property *)0)) {
    return ((bool )0);
  } else {
  }
  i = 0U;
  goto ldv_38536;
  ldv_38535:
  {
  drm_property_add_enum(intel_sdvo_connector->tv_format, (int )i, (uint64_t )i, tv_format_names[(int )intel_sdvo_connector->tv_format_supported[i]]);
  i = i + 1U;
  }
  ldv_38536: ;
  if ((uint32_t )intel_sdvo_connector->format_supported_num > i) {
    goto ldv_38535;
  } else {
    goto ldv_38537;
  }
  ldv_38537:
  {
  intel_sdvo->tv_format_index = (int )intel_sdvo_connector->tv_format_supported[0];
  drm_connector_attach_property(& intel_sdvo_connector->base.base, intel_sdvo_connector->tv_format,
                                0ULL);
  }
  return ((bool )1);
}
}
static bool intel_sdvo_create_enhance_property_tv(struct intel_sdvo *intel_sdvo ,
                                                  struct intel_sdvo_connector *intel_sdvo_connector ,
                                                  struct intel_sdvo_enhancements_reply enhancements )
{ struct drm_device *dev ;
  struct drm_connector *connector ;
  uint16_t response ;
  uint16_t data_value[2U] ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  bool tmp___13 ;
  int tmp___14 ;
  bool tmp___15 ;
  int tmp___16 ;
  bool tmp___17 ;
  int tmp___18 ;
  bool tmp___19 ;
  int tmp___20 ;
  bool tmp___21 ;
  int tmp___22 ;
  bool tmp___23 ;
  int tmp___24 ;
  bool tmp___25 ;
  int tmp___26 ;
  bool tmp___27 ;
  int tmp___28 ;
  bool tmp___29 ;
  int tmp___30 ;
  bool tmp___31 ;
  int tmp___32 ;
  bool tmp___33 ;
  int tmp___34 ;
  bool tmp___35 ;
  int tmp___36 ;
  bool tmp___37 ;
  int tmp___38 ;
  bool tmp___39 ;
  int tmp___40 ;
  bool tmp___41 ;
  int tmp___42 ;
  bool tmp___43 ;
  int tmp___44 ;
  bool tmp___45 ;
  int tmp___46 ;
  bool tmp___47 ;
  int tmp___48 ;
  bool tmp___49 ;
  int tmp___50 ;
  bool tmp___51 ;
  int tmp___52 ;
  bool tmp___53 ;
  int tmp___54 ;
  bool tmp___55 ;
  int tmp___56 ;
  {
  dev = intel_sdvo->base.base.dev;
  connector = & intel_sdvo_connector->base.base;
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
    {
    tmp = intel_sdvo_get_value(intel_sdvo, (u8 )97, (void *)(& data_value), 4);
    }
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      return ((bool )0);
    } else {
    }
    {
    tmp___1 = intel_sdvo_get_value(intel_sdvo, (u8 )98, (void *)(& response), 2);
    }
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    if (tmp___2) {
      return ((bool )0);
    } else {
    }
    {
    intel_sdvo_connector->max_hscan = (u32 )data_value[0];
    intel_sdvo_connector->left_margin = (u32 )((int )data_value[0] - (int )response);
    intel_sdvo_connector->right_margin = intel_sdvo_connector->left_margin;
    intel_sdvo_connector->left = drm_property_create(dev, 2, "left_margin", 2);
    }
    if ((unsigned long )intel_sdvo_connector->left == (unsigned long )((struct drm_property *)0)) {
      return ((bool )0);
    } else {
    }
    {
    *((intel_sdvo_connector->left)->values) = 0ULL;
    *((intel_sdvo_connector->left)->values + 1UL) = (uint64_t )data_value[0];
    drm_connector_attach_property(connector, intel_sdvo_connector->left, (uint64_t )intel_sdvo_connector->left_margin);
    intel_sdvo_connector->right = drm_property_create(dev, 2, "right_margin", 2);
    }
    if ((unsigned long )intel_sdvo_connector->right == (unsigned long )((struct drm_property *)0)) {
      return ((bool )0);
    } else {
    }
    {
    *((intel_sdvo_connector->right)->values) = 0ULL;
    *((intel_sdvo_connector->right)->values + 1UL) = (uint64_t )data_value[0];
    drm_connector_attach_property(connector, intel_sdvo_connector->right, (uint64_t )intel_sdvo_connector->right_margin);
    drm_ut_debug_printk(4U, "drm", "intel_sdvo_create_enhance_property_tv", "h_overscan: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
    {
    tmp___3 = intel_sdvo_get_value(intel_sdvo, (u8 )100, (void *)(& data_value), 4);
    }
    if (tmp___3) {
      tmp___4 = 0;
    } else {
      tmp___4 = 1;
    }
    if (tmp___4) {
      return ((bool )0);
    } else {
    }
    {
    tmp___5 = intel_sdvo_get_value(intel_sdvo, (u8 )101, (void *)(& response), 2);
    }
    if (tmp___5) {
      tmp___6 = 0;
    } else {
      tmp___6 = 1;
    }
    if (tmp___6) {
      return ((bool )0);
    } else {
    }
    {
    intel_sdvo_connector->max_vscan = (u32 )data_value[0];
    intel_sdvo_connector->top_margin = (u32 )((int )data_value[0] - (int )response);
    intel_sdvo_connector->bottom_margin = intel_sdvo_connector->top_margin;
    intel_sdvo_connector->top = drm_property_create(dev, 2, "top_margin", 2);
    }
    if ((unsigned long )intel_sdvo_connector->top == (unsigned long )((struct drm_property *)0)) {
      return ((bool )0);
    } else {
    }
    {
    *((intel_sdvo_connector->top)->values) = 0ULL;
    *((intel_sdvo_connector->top)->values + 1UL) = (uint64_t )data_value[0];
    drm_connector_attach_property(connector, intel_sdvo_connector->top, (uint64_t )intel_sdvo_connector->top_margin);
    intel_sdvo_connector->bottom = drm_property_create(dev, 2, "bottom_margin", 2);
    }
    if ((unsigned long )intel_sdvo_connector->bottom == (unsigned long )((struct drm_property *)0)) {
      return ((bool )0);
    } else {
    }
    {
    *((intel_sdvo_connector->bottom)->values) = 0ULL;
    *((intel_sdvo_connector->bottom)->values + 1UL) = (uint64_t )data_value[0];
    drm_connector_attach_property(connector, intel_sdvo_connector->bottom, (uint64_t )intel_sdvo_connector->bottom_margin);
    drm_ut_debug_printk(4U, "drm", "intel_sdvo_create_enhance_property_tv", "v_overscan: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
    {
    tmp___7 = intel_sdvo_get_value(intel_sdvo, (u8 )103, (void *)(& data_value), 4);
    }
    if (tmp___7) {
      tmp___8 = 0;
    } else {
      tmp___8 = 1;
    }
    if (tmp___8) {
      return ((bool )0);
    } else {
      {
      tmp___9 = intel_sdvo_get_value(intel_sdvo, (u8 )104, (void *)(& response), 2);
      }
      if (tmp___9) {
        tmp___10 = 0;
      } else {
        tmp___10 = 1;
      }
      if (tmp___10) {
        return ((bool )0);
      } else {
      }
    }
    {
    intel_sdvo_connector->max_hpos = (u32 )data_value[0];
    intel_sdvo_connector->cur_hpos = (u32 )response;
    intel_sdvo_connector->hpos = drm_property_create(dev, 2, "hpos", 2);
    }
    if ((unsigned long )intel_sdvo_connector->hpos == (unsigned long )((struct drm_property *)0)) {
      return ((bool )0);
    } else {
    }
    {
    *((intel_sdvo_connector->hpos)->values) = 0ULL;
    *((intel_sdvo_connector->hpos)->values + 1UL) = (uint64_t )data_value[0];
    drm_connector_attach_property(connector, intel_sdvo_connector->hpos, (uint64_t )intel_sdvo_connector->cur_hpos);
    drm_ut_debug_printk(4U, "drm", "intel_sdvo_create_enhance_property_tv", "hpos: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
    {
    tmp___11 = intel_sdvo_get_value(intel_sdvo, (u8 )106, (void *)(& data_value),
                                    4);
    }
    if (tmp___11) {
      tmp___12 = 0;
    } else {
      tmp___12 = 1;
    }
    if (tmp___12) {
      return ((bool )0);
    } else {
      {
      tmp___13 = intel_sdvo_get_value(intel_sdvo, (u8 )107, (void *)(& response),
                                      2);
      }
      if (tmp___13) {
        tmp___14 = 0;
      } else {
        tmp___14 = 1;
      }
      if (tmp___14) {
        return ((bool )0);
      } else {
      }
    }
    {
    intel_sdvo_connector->max_vpos = (u32 )data_value[0];
    intel_sdvo_connector->cur_vpos = (u32 )response;
    intel_sdvo_connector->vpos = drm_property_create(dev, 2, "vpos", 2);
    }
    if ((unsigned long )intel_sdvo_connector->vpos == (unsigned long )((struct drm_property *)0)) {
      return ((bool )0);
    } else {
    }
    {
    *((intel_sdvo_connector->vpos)->values) = 0ULL;
    *((intel_sdvo_connector->vpos)->values + 1UL) = (uint64_t )data_value[0];
    drm_connector_attach_property(connector, intel_sdvo_connector->vpos, (uint64_t )intel_sdvo_connector->cur_vpos);
    drm_ut_debug_printk(4U, "drm", "intel_sdvo_create_enhance_property_tv", "vpos: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
    {
    tmp___15 = intel_sdvo_get_value(intel_sdvo, (u8 )85, (void *)(& data_value), 4);
    }
    if (tmp___15) {
      tmp___16 = 0;
    } else {
      tmp___16 = 1;
    }
    if (tmp___16) {
      return ((bool )0);
    } else {
      {
      tmp___17 = intel_sdvo_get_value(intel_sdvo, (u8 )86, (void *)(& response), 2);
      }
      if (tmp___17) {
        tmp___18 = 0;
      } else {
        tmp___18 = 1;
      }
      if (tmp___18) {
        return ((bool )0);
      } else {
      }
    }
    {
    intel_sdvo_connector->max_saturation = (u32 )data_value[0];
    intel_sdvo_connector->cur_saturation = (u32 )response;
    intel_sdvo_connector->saturation = drm_property_create(dev, 2, "saturation", 2);
    }
    if ((unsigned long )intel_sdvo_connector->saturation == (unsigned long )((struct drm_property *)0)) {
      return ((bool )0);
    } else {
    }
    {
    *((intel_sdvo_connector->saturation)->values) = 0ULL;
    *((intel_sdvo_connector->saturation)->values + 1UL) = (uint64_t )data_value[0];
    drm_connector_attach_property(connector, intel_sdvo_connector->saturation, (uint64_t )intel_sdvo_connector->cur_saturation);
    drm_ut_debug_printk(4U, "drm", "intel_sdvo_create_enhance_property_tv", "saturation: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
    {
    tmp___19 = intel_sdvo_get_value(intel_sdvo, (u8 )94, (void *)(& data_value), 4);
    }
    if (tmp___19) {
      tmp___20 = 0;
    } else {
      tmp___20 = 1;
    }
    if (tmp___20) {
      return ((bool )0);
    } else {
      {
      tmp___21 = intel_sdvo_get_value(intel_sdvo, (u8 )95, (void *)(& response), 2);
      }
      if (tmp___21) {
        tmp___22 = 0;
      } else {
        tmp___22 = 1;
      }
      if (tmp___22) {
        return ((bool )0);
      } else {
      }
    }
    {
    intel_sdvo_connector->max_contrast = (u32 )data_value[0];
    intel_sdvo_connector->cur_contrast = (u32 )response;
    intel_sdvo_connector->contrast = drm_property_create(dev, 2, "contrast", 2);
    }
    if ((unsigned long )intel_sdvo_connector->contrast == (unsigned long )((struct drm_property *)0)) {
      return ((bool )0);
    } else {
    }
    {
    *((intel_sdvo_connector->contrast)->values) = 0ULL;
    *((intel_sdvo_connector->contrast)->values + 1UL) = (uint64_t )data_value[0];
    drm_connector_attach_property(connector, intel_sdvo_connector->contrast, (uint64_t )intel_sdvo_connector->cur_contrast);
    drm_ut_debug_printk(4U, "drm", "intel_sdvo_create_enhance_property_tv", "contrast: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
    {
    tmp___23 = intel_sdvo_get_value(intel_sdvo, (u8 )88, (void *)(& data_value), 4);
    }
    if (tmp___23) {
      tmp___24 = 0;
    } else {
      tmp___24 = 1;
    }
    if (tmp___24) {
      return ((bool )0);
    } else {
      {
      tmp___25 = intel_sdvo_get_value(intel_sdvo, (u8 )89, (void *)(& response), 2);
      }
      if (tmp___25) {
        tmp___26 = 0;
      } else {
        tmp___26 = 1;
      }
      if (tmp___26) {
        return ((bool )0);
      } else {
      }
    }
    {
    intel_sdvo_connector->max_hue = (u32 )data_value[0];
    intel_sdvo_connector->cur_hue = (u32 )response;
    intel_sdvo_connector->hue = drm_property_create(dev, 2, "hue", 2);
    }
    if ((unsigned long )intel_sdvo_connector->hue == (unsigned long )((struct drm_property *)0)) {
      return ((bool )0);
    } else {
    }
    {
    *((intel_sdvo_connector->hue)->values) = 0ULL;
    *((intel_sdvo_connector->hue)->values + 1UL) = (uint64_t )data_value[0];
    drm_connector_attach_property(connector, intel_sdvo_connector->hue, (uint64_t )intel_sdvo_connector->cur_hue);
    drm_ut_debug_printk(4U, "drm", "intel_sdvo_create_enhance_property_tv", "hue: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
    {
    tmp___27 = intel_sdvo_get_value(intel_sdvo, (u8 )109, (void *)(& data_value),
                                    4);
    }
    if (tmp___27) {
      tmp___28 = 0;
    } else {
      tmp___28 = 1;
    }
    if (tmp___28) {
      return ((bool )0);
    } else {
      {
      tmp___29 = intel_sdvo_get_value(intel_sdvo, (u8 )110, (void *)(& response),
                                      2);
      }
      if (tmp___29) {
        tmp___30 = 0;
      } else {
        tmp___30 = 1;
      }
      if (tmp___30) {
        return ((bool )0);
      } else {
      }
    }
    {
    intel_sdvo_connector->max_sharpness = (u32 )data_value[0];
    intel_sdvo_connector->cur_sharpness = (u32 )response;
    intel_sdvo_connector->sharpness = drm_property_create(dev, 2, "sharpness", 2);
    }
    if ((unsigned long )intel_sdvo_connector->sharpness == (unsigned long )((struct drm_property *)0)) {
      return ((bool )0);
    } else {
    }
    {
    *((intel_sdvo_connector->sharpness)->values) = 0ULL;
    *((intel_sdvo_connector->sharpness)->values + 1UL) = (uint64_t )data_value[0];
    drm_connector_attach_property(connector, intel_sdvo_connector->sharpness, (uint64_t )intel_sdvo_connector->cur_sharpness);
    drm_ut_debug_printk(4U, "drm", "intel_sdvo_create_enhance_property_tv", "sharpness: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
    {
    tmp___31 = intel_sdvo_get_value(intel_sdvo, (u8 )91, (void *)(& data_value), 4);
    }
    if (tmp___31) {
      tmp___32 = 0;
    } else {
      tmp___32 = 1;
    }
    if (tmp___32) {
      return ((bool )0);
    } else {
      {
      tmp___33 = intel_sdvo_get_value(intel_sdvo, (u8 )92, (void *)(& response), 2);
      }
      if (tmp___33) {
        tmp___34 = 0;
      } else {
        tmp___34 = 1;
      }
      if (tmp___34) {
        return ((bool )0);
      } else {
      }
    }
    {
    intel_sdvo_connector->max_brightness = (u32 )data_value[0];
    intel_sdvo_connector->cur_brightness = (u32 )response;
    intel_sdvo_connector->brightness = drm_property_create(dev, 2, "brightness", 2);
    }
    if ((unsigned long )intel_sdvo_connector->brightness == (unsigned long )((struct drm_property *)0)) {
      return ((bool )0);
    } else {
    }
    {
    *((intel_sdvo_connector->brightness)->values) = 0ULL;
    *((intel_sdvo_connector->brightness)->values + 1UL) = (uint64_t )data_value[0];
    drm_connector_attach_property(connector, intel_sdvo_connector->brightness, (uint64_t )intel_sdvo_connector->cur_brightness);
    drm_ut_debug_printk(4U, "drm", "intel_sdvo_create_enhance_property_tv", "brightness: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
    {
    tmp___35 = intel_sdvo_get_value(intel_sdvo, (u8 )77, (void *)(& data_value), 4);
    }
    if (tmp___35) {
      tmp___36 = 0;
    } else {
      tmp___36 = 1;
    }
    if (tmp___36) {
      return ((bool )0);
    } else {
      {
      tmp___37 = intel_sdvo_get_value(intel_sdvo, (u8 )78, (void *)(& response), 2);
      }
      if (tmp___37) {
        tmp___38 = 0;
      } else {
        tmp___38 = 1;
      }
      if (tmp___38) {
        return ((bool )0);
      } else {
      }
    }
    {
    intel_sdvo_connector->max_flicker_filter = (u32 )data_value[0];
    intel_sdvo_connector->cur_flicker_filter = (u32 )response;
    intel_sdvo_connector->flicker_filter = drm_property_create(dev, 2, "flicker_filter",
                                                               2);
    }
    if ((unsigned long )intel_sdvo_connector->flicker_filter == (unsigned long )((struct drm_property *)0)) {
      return ((bool )0);
    } else {
    }
    {
    *((intel_sdvo_connector->flicker_filter)->values) = 0ULL;
    *((intel_sdvo_connector->flicker_filter)->values + 1UL) = (uint64_t )data_value[0];
    drm_connector_attach_property(connector, intel_sdvo_connector->flicker_filter,
                                  (uint64_t )intel_sdvo_connector->cur_flicker_filter);
    drm_ut_debug_printk(4U, "drm", "intel_sdvo_create_enhance_property_tv", "flicker_filter: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
    {
    tmp___39 = intel_sdvo_get_value(intel_sdvo, (u8 )123, (void *)(& data_value),
                                    4);
    }
    if (tmp___39) {
      tmp___40 = 0;
    } else {
      tmp___40 = 1;
    }
    if (tmp___40) {
      return ((bool )0);
    } else {
      {
      tmp___41 = intel_sdvo_get_value(intel_sdvo, (u8 )80, (void *)(& response), 2);
      }
      if (tmp___41) {
        tmp___42 = 0;
      } else {
        tmp___42 = 1;
      }
      if (tmp___42) {
        return ((bool )0);
      } else {
      }
    }
    {
    intel_sdvo_connector->max_flicker_filter_adaptive = (u32 )data_value[0];
    intel_sdvo_connector->cur_flicker_filter_adaptive = (u32 )response;
    intel_sdvo_connector->flicker_filter_adaptive = drm_property_create(dev, 2, "flicker_filter_adaptive",
                                                                        2);
    }
    if ((unsigned long )intel_sdvo_connector->flicker_filter_adaptive == (unsigned long )((struct drm_property *)0)) {
      return ((bool )0);
    } else {
    }
    {
    *((intel_sdvo_connector->flicker_filter_adaptive)->values) = 0ULL;
    *((intel_sdvo_connector->flicker_filter_adaptive)->values + 1UL) = (uint64_t )data_value[0];
    drm_connector_attach_property(connector, intel_sdvo_connector->flicker_filter_adaptive,
                                  (uint64_t )intel_sdvo_connector->cur_flicker_filter_adaptive);
    drm_ut_debug_printk(4U, "drm", "intel_sdvo_create_enhance_property_tv", "flicker_filter_adaptive: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
    {
    tmp___43 = intel_sdvo_get_value(intel_sdvo, (u8 )82, (void *)(& data_value), 4);
    }
    if (tmp___43) {
      tmp___44 = 0;
    } else {
      tmp___44 = 1;
    }
    if (tmp___44) {
      return ((bool )0);
    } else {
      {
      tmp___45 = intel_sdvo_get_value(intel_sdvo, (u8 )83, (void *)(& response), 2);
      }
      if (tmp___45) {
        tmp___46 = 0;
      } else {
        tmp___46 = 1;
      }
      if (tmp___46) {
        return ((bool )0);
      } else {
      }
    }
    {
    intel_sdvo_connector->max_flicker_filter_2d = (u32 )data_value[0];
    intel_sdvo_connector->cur_flicker_filter_2d = (u32 )response;
    intel_sdvo_connector->flicker_filter_2d = drm_property_create(dev, 2, "flicker_filter_2d",
                                                                  2);
    }
    if ((unsigned long )intel_sdvo_connector->flicker_filter_2d == (unsigned long )((struct drm_property *)0)) {
      return ((bool )0);
    } else {
    }
    {
    *((intel_sdvo_connector->flicker_filter_2d)->values) = 0ULL;
    *((intel_sdvo_connector->flicker_filter_2d)->values + 1UL) = (uint64_t )data_value[0];
    drm_connector_attach_property(connector, intel_sdvo_connector->flicker_filter_2d,
                                  (uint64_t )intel_sdvo_connector->cur_flicker_filter_2d);
    drm_ut_debug_printk(4U, "drm", "intel_sdvo_create_enhance_property_tv", "flicker_filter_2d: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
    {
    tmp___47 = intel_sdvo_get_value(intel_sdvo, (u8 )116, (void *)(& data_value),
                                    4);
    }
    if (tmp___47) {
      tmp___48 = 0;
    } else {
      tmp___48 = 1;
    }
    if (tmp___48) {
      return ((bool )0);
    } else {
      {
      tmp___49 = intel_sdvo_get_value(intel_sdvo, (u8 )117, (void *)(& response),
                                      2);
      }
      if (tmp___49) {
        tmp___50 = 0;
      } else {
        tmp___50 = 1;
      }
      if (tmp___50) {
        return ((bool )0);
      } else {
      }
    }
    {
    intel_sdvo_connector->max_tv_chroma_filter = (u32 )data_value[0];
    intel_sdvo_connector->cur_tv_chroma_filter = (u32 )response;
    intel_sdvo_connector->tv_chroma_filter = drm_property_create(dev, 2, "tv_chroma_filter",
                                                                 2);
    }
    if ((unsigned long )intel_sdvo_connector->tv_chroma_filter == (unsigned long )((struct drm_property *)0)) {
      return ((bool )0);
    } else {
    }
    {
    *((intel_sdvo_connector->tv_chroma_filter)->values) = 0ULL;
    *((intel_sdvo_connector->tv_chroma_filter)->values + 1UL) = (uint64_t )data_value[0];
    drm_connector_attach_property(connector, intel_sdvo_connector->tv_chroma_filter,
                                  (uint64_t )intel_sdvo_connector->cur_tv_chroma_filter);
    drm_ut_debug_printk(4U, "drm", "intel_sdvo_create_enhance_property_tv", "tv_chroma_filter: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
    {
    tmp___51 = intel_sdvo_get_value(intel_sdvo, (u8 )119, (void *)(& data_value),
                                    4);
    }
    if (tmp___51) {
      tmp___52 = 0;
    } else {
      tmp___52 = 1;
    }
    if (tmp___52) {
      return ((bool )0);
    } else {
      {
      tmp___53 = intel_sdvo_get_value(intel_sdvo, (u8 )120, (void *)(& response),
                                      2);
      }
      if (tmp___53) {
        tmp___54 = 0;
      } else {
        tmp___54 = 1;
      }
      if (tmp___54) {
        return ((bool )0);
      } else {
      }
    }
    {
    intel_sdvo_connector->max_tv_luma_filter = (u32 )data_value[0];
    intel_sdvo_connector->cur_tv_luma_filter = (u32 )response;
    intel_sdvo_connector->tv_luma_filter = drm_property_create(dev, 2, "tv_luma_filter",
                                                               2);
    }
    if ((unsigned long )intel_sdvo_connector->tv_luma_filter == (unsigned long )((struct drm_property *)0)) {
      return ((bool )0);
    } else {
    }
    {
    *((intel_sdvo_connector->tv_luma_filter)->values) = 0ULL;
    *((intel_sdvo_connector->tv_luma_filter)->values + 1UL) = (uint64_t )data_value[0];
    drm_connector_attach_property(connector, intel_sdvo_connector->tv_luma_filter,
                                  (uint64_t )intel_sdvo_connector->cur_tv_luma_filter);
    drm_ut_debug_printk(4U, "drm", "intel_sdvo_create_enhance_property_tv", "tv_luma_filter: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
    {
    tmp___55 = intel_sdvo_get_value(intel_sdvo, (u8 )112, (void *)(& response), 2);
    }
    if (tmp___55) {
      tmp___56 = 0;
    } else {
      tmp___56 = 1;
    }
    if (tmp___56) {
      return ((bool )0);
    } else {
    }
    {
    intel_sdvo_connector->max_dot_crawl = 1U;
    intel_sdvo_connector->cur_dot_crawl = (u32 )response & 1U;
    intel_sdvo_connector->dot_crawl = drm_property_create(dev, 2, "dot_crawl", 2);
    }
    if ((unsigned long )intel_sdvo_connector->dot_crawl == (unsigned long )((struct drm_property *)0)) {
      return ((bool )0);
    } else {
    }
    {
    *((intel_sdvo_connector->dot_crawl)->values) = 0ULL;
    *((intel_sdvo_connector->dot_crawl)->values + 1UL) = 1ULL;
    drm_connector_attach_property(connector, intel_sdvo_connector->dot_crawl, (uint64_t )intel_sdvo_connector->cur_dot_crawl);
    drm_ut_debug_printk(4U, "drm", "intel_sdvo_create_enhance_property_tv", "dot crawl: current %d\n",
                        (int )response);
    }
  } else {
  }
  return ((bool )1);
}
}
static bool intel_sdvo_create_enhance_property_lvds(struct intel_sdvo *intel_sdvo ,
                                                    struct intel_sdvo_connector *intel_sdvo_connector ,
                                                    struct intel_sdvo_enhancements_reply enhancements )
{ struct drm_device *dev ;
  struct drm_connector *connector ;
  uint16_t response ;
  uint16_t data_value[2U] ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  {
  dev = intel_sdvo->base.base.dev;
  connector = & intel_sdvo_connector->base.base;
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
    {
    tmp = intel_sdvo_get_value(intel_sdvo, (u8 )91, (void *)(& data_value), 4);
    }
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      return ((bool )0);
    } else {
      {
      tmp___1 = intel_sdvo_get_value(intel_sdvo, (u8 )92, (void *)(& response), 2);
      }
      if (tmp___1) {
        tmp___2 = 0;
      } else {
        tmp___2 = 1;
      }
      if (tmp___2) {
        return ((bool )0);
      } else {
      }
    }
    {
    intel_sdvo_connector->max_brightness = (u32 )data_value[0];
    intel_sdvo_connector->cur_brightness = (u32 )response;
    intel_sdvo_connector->brightness = drm_property_create(dev, 2, "brightness", 2);
    }
    if ((unsigned long )intel_sdvo_connector->brightness == (unsigned long )((struct drm_property *)0)) {
      return ((bool )0);
    } else {
    }
    {
    *((intel_sdvo_connector->brightness)->values) = 0ULL;
    *((intel_sdvo_connector->brightness)->values + 1UL) = (uint64_t )data_value[0];
    drm_connector_attach_property(connector, intel_sdvo_connector->brightness, (uint64_t )intel_sdvo_connector->cur_brightness);
    drm_ut_debug_printk(4U, "drm", "intel_sdvo_create_enhance_property_lvds", "brightness: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
    }
  } else {
  }
  return ((bool )1);
}
}
static bool intel_sdvo_create_enhance_property(struct intel_sdvo *intel_sdvo , struct intel_sdvo_connector *intel_sdvo_connector )
{ union __anonunion_enhancements_197 enhancements ;
  bool tmp ;
  bool tmp___0 ;
  {
  {
  enhancements.response = (uint16_t )0U;
  intel_sdvo_get_value(intel_sdvo, (u8 )132, (void *)(& enhancements), 2);
  }
  if ((unsigned int )enhancements.response == 0U) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_sdvo_create_enhance_property", "No enhancement is supported\n");
    }
    return ((bool )1);
  } else {
  }
  if (((int )intel_sdvo_connector->output_flag & 12) != 0) {
    {
    tmp = intel_sdvo_create_enhance_property_tv(intel_sdvo, intel_sdvo_connector,
                                                enhancements.reply);
    }
    return (tmp);
  } else
  if (((int )intel_sdvo_connector->output_flag & 16448) != 0) {
    {
    tmp___0 = intel_sdvo_create_enhance_property_lvds(intel_sdvo, intel_sdvo_connector,
                                                      enhancements.reply);
    }
    return (tmp___0);
  } else {
    return ((bool )1);
  }
}
}
static int intel_sdvo_ddc_proxy_xfer(struct i2c_adapter *adapter , struct i2c_msg *msgs ,
                                     int num )
{ struct intel_sdvo *sdvo ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  {
  sdvo = (struct intel_sdvo *)adapter->algo_data;
  tmp = intel_sdvo_set_control_bus_switch(sdvo, (u8 )((int )sdvo->ddc_bus));
  }
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (-5);
  } else {
  }
  {
  tmp___1 = (*(((sdvo->i2c)->algo)->master_xfer))(sdvo->i2c, msgs, num);
  }
  return (tmp___1);
}
}
static u32 intel_sdvo_ddc_proxy_func(struct i2c_adapter *adapter )
{ struct intel_sdvo *sdvo ;
  u32 tmp ;
  {
  {
  sdvo = (struct intel_sdvo *)adapter->algo_data;
  tmp = (*(((sdvo->i2c)->algo)->functionality))(sdvo->i2c);
  }
  return (tmp);
}
}
static struct i2c_algorithm const intel_sdvo_ddc_proxy = {& intel_sdvo_ddc_proxy_xfer, (int (*)(struct i2c_adapter * , u16 , unsigned short ,
                                          char , u8 , int , union i2c_smbus_data * ))0,
    & intel_sdvo_ddc_proxy_func};
static bool intel_sdvo_init_ddc_proxy(struct intel_sdvo *sdvo , struct drm_device *dev )
{ int tmp ;
  {
  {
  sdvo->ddc.owner = & __this_module;
  sdvo->ddc.class = 8U;
  snprintf((char *)(& sdvo->ddc.name), 20UL, "SDVO DDC proxy");
  sdvo->ddc.dev.parent = & (dev->pdev)->dev;
  sdvo->ddc.algo_data = (void *)sdvo;
  sdvo->ddc.algo = & intel_sdvo_ddc_proxy;
  tmp = i2c_add_adapter(& sdvo->ddc);
  }
  return ((bool )(tmp == 0));
}
}
bool intel_sdvo_init(struct drm_device *dev , int sdvo_reg )
{ struct drm_i915_private *dev_priv ;
  struct intel_encoder *intel_encoder ;
  struct intel_sdvo *intel_sdvo ;
  int i ;
  void *tmp ;
  u8 tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  u8 byte ;
  int tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  bool tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = kzalloc(1832UL, 208U);
  intel_sdvo = (struct intel_sdvo *)tmp;
  }
  if ((unsigned long )intel_sdvo == (unsigned long )((struct intel_sdvo *)0)) {
    return ((bool )0);
  } else {
  }
  {
  intel_sdvo->sdvo_reg = sdvo_reg;
  tmp___0 = intel_sdvo_get_slave_addr(dev, sdvo_reg);
  intel_sdvo->slave_addr = (u8 )((int )tmp___0 >> 1);
  intel_sdvo_select_i2c_bus(dev_priv, intel_sdvo, (u32 )sdvo_reg);
  tmp___1 = intel_sdvo_init_ddc_proxy(intel_sdvo, dev);
  }
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    {
    kfree((void const *)intel_sdvo);
    }
    return ((bool )0);
  } else {
  }
  {
  intel_encoder = & intel_sdvo->base;
  intel_encoder->type = 3;
  drm_encoder_init(dev, & intel_encoder->base, & intel_sdvo_enc_funcs, 0);
  i = 0;
  }
  goto ldv_38594;
  ldv_38593:
  {
  tmp___4 = intel_sdvo_read_byte(intel_sdvo, (u8 )((int )((u8 )i)), & byte);
  }
  if (tmp___4) {
    tmp___5 = 0;
  } else {
    tmp___5 = 1;
  }
  if (tmp___5) {
    if (sdvo_reg == 397632) {
      tmp___3 = 66;
    } else
    if (sdvo_reg == 921920) {
      tmp___3 = 66;
    } else {
      tmp___3 = 67;
    }
    {
    drm_ut_debug_printk(4U, "drm", "intel_sdvo_init", "No SDVO device found on SDVO%c\n",
                        tmp___3);
    }
    goto err;
  } else {
  }
  i = i + 1;
  ldv_38594: ;
  if (i <= 63) {
    goto ldv_38593;
  } else {
    goto ldv_38595;
  }
  ldv_38595: ;
  if (sdvo_reg == 397632) {
    dev_priv->hotplug_supported_mask = dev_priv->hotplug_supported_mask | 64U;
  } else
  if (sdvo_reg == 921920) {
    dev_priv->hotplug_supported_mask = dev_priv->hotplug_supported_mask | 64U;
  } else {
    dev_priv->hotplug_supported_mask = dev_priv->hotplug_supported_mask | 128U;
  }
  {
  drm_encoder_helper_add(& intel_encoder->base, & intel_sdvo_helper_funcs);
  tmp___6 = intel_sdvo_get_capabilities(intel_sdvo, & intel_sdvo->caps);
  }
  if (tmp___6) {
    tmp___7 = 0;
  } else {
    tmp___7 = 1;
  }
  if (tmp___7) {
    goto err;
  } else {
  }
  {
  tmp___9 = intel_sdvo_output_setup(intel_sdvo, (uint16_t )((int )intel_sdvo->caps.output_flags));
  }
  if (tmp___9) {
    tmp___10 = 0;
  } else {
    tmp___10 = 1;
  }
  if (tmp___10) {
    if (sdvo_reg == 397632) {
      tmp___8 = 66;
    } else
    if (sdvo_reg == 921920) {
      tmp___8 = 66;
    } else {
      tmp___8 = 67;
    }
    {
    drm_ut_debug_printk(4U, "drm", "intel_sdvo_init", "SDVO output failed to setup on SDVO%c\n",
                        tmp___8);
    }
    goto err;
  } else {
  }
  {
  intel_sdvo_select_ddc_bus(dev_priv, intel_sdvo, (u32 )sdvo_reg);
  tmp___11 = intel_sdvo_set_target_input(intel_sdvo);
  }
  if (tmp___11) {
    tmp___12 = 0;
  } else {
    tmp___12 = 1;
  }
  if (tmp___12) {
    goto err;
  } else {
  }
  {
  tmp___13 = intel_sdvo_get_input_pixel_clock_range(intel_sdvo, & intel_sdvo->pixel_clock_min,
                                                    & intel_sdvo->pixel_clock_max);
  }
  if (tmp___13) {
    tmp___14 = 0;
  } else {
    tmp___14 = 1;
  }
  if (tmp___14) {
    goto err;
  } else {
  }
  if (((int )intel_sdvo->caps.output_flags & 768) != 0) {
    tmp___15 = 89;
  } else {
    tmp___15 = 78;
  }
  if (((int )intel_sdvo->caps.output_flags & 3) != 0) {
    tmp___16 = 89;
  } else {
    tmp___16 = 78;
  }
  if (((int )intel_sdvo->caps.sdvo_inputs_mask & 2) != 0) {
    tmp___17 = 89;
  } else {
    tmp___17 = 78;
  }
  if ((int )intel_sdvo->caps.sdvo_inputs_mask & 1) {
    tmp___18 = 89;
  } else {
    tmp___18 = 78;
  }
  if (intel_sdvo->sdvo_reg == 397632) {
    tmp___19 = (char *)"SDVOB";
  } else
  if (intel_sdvo->sdvo_reg == 921920) {
    tmp___19 = (char *)"SDVOB";
  } else {
    tmp___19 = (char *)"SDVOC";
  }
  {
  drm_ut_debug_printk(4U, "drm", "intel_sdvo_init", "%s device VID/DID: %02X:%02X.%02X, clock range %dMHz - %dMHz, input 1: %c, input 2: %c, output 1: %c, output 2: %c\n",
                      tmp___19, (int )intel_sdvo->caps.vendor_id, (int )intel_sdvo->caps.device_id,
                      (int )intel_sdvo->caps.device_rev_id, intel_sdvo->pixel_clock_min / 1000,
                      intel_sdvo->pixel_clock_max / 1000, tmp___18, tmp___17, tmp___16,
                      tmp___15);
  }
  return ((bool )1);
  err:
  {
  drm_encoder_cleanup(& intel_encoder->base);
  i2c_del_adapter(& intel_sdvo->ddc);
  kfree((void const *)intel_sdvo);
  }
  return ((bool )0);
}
}
bool intel_ddc_probe(struct intel_encoder *intel_encoder , int ddc_bus )
{ struct drm_i915_private *dev_priv ;
  u8 out_buf[2U] ;
  u8 buf[2U] ;
  struct i2c_msg msgs[2U] ;
  int tmp ;
  {
  {
  dev_priv = (struct drm_i915_private *)(intel_encoder->base.dev)->dev_private;
  out_buf[0] = (u8 )0U;
  out_buf[1] = (u8 )0U;
  msgs[0].addr = (__u16 )80U;
  msgs[0].flags = (__u16 )0U;
  msgs[0].len = (__u16 )1U;
  msgs[0].buf = (__u8 *)(& out_buf);
  msgs[1].addr = (__u16 )80U;
  msgs[1].flags = (__u16 )1U;
  msgs[1].len = (__u16 )1U;
  msgs[1].buf = (__u8 *)(& buf);
  tmp = i2c_transfer(& (dev_priv->gmbus + (unsigned long )ddc_bus)->adapter, (struct i2c_msg *)(& msgs),
                     2);
  }
  return ((bool )(tmp == 2));
}
}
int intel_ddc_get_modes(struct drm_connector *connector , struct i2c_adapter *adapter )
{ struct edid *edid ;
  int ret ;
  {
  {
  ret = 0;
  edid = drm_get_edid(connector, adapter);
  }
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
    {
    drm_mode_connector_update_edid_property(connector, edid);
    ret = drm_add_edid_modes(connector, edid);
    connector->display_info.raw_edid = (char *)0;
    kfree((void const *)edid);
    }
  } else {
  }
  return (ret);
}
}
static char const *force_audio_names[3U] = { "off", "auto", "on"};
void intel_attach_force_audio_property(struct drm_connector *connector )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct drm_property *prop ;
  int i ;
  {
  dev = connector->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  prop = dev_priv->force_audio_property;
  if ((unsigned long )prop == (unsigned long )((struct drm_property *)0)) {
    {
    prop = drm_property_create(dev, 8, "audio", 3);
    }
    if ((unsigned long )prop == (unsigned long )((struct drm_property *)0)) {
      return;
    } else {
    }
    i = 0;
    goto ldv_37293;
    ldv_37292:
    {
    drm_property_add_enum(prop, i, (uint64_t )(i + -1), force_audio_names[i]);
    i = i + 1;
    }
    ldv_37293: ;
    if ((unsigned int )i <= 2U) {
      goto ldv_37292;
    } else {
      goto ldv_37294;
    }
    ldv_37294:
    dev_priv->force_audio_property = prop;
  } else {
  }
  {
  drm_connector_attach_property(connector, prop, 0ULL);
  }
  return;
}
}
static char const *broadcast_rgb_names[2U] = { "Full", "Limited 16:235"};
void intel_attach_broadcast_rgb_property(struct drm_connector *connector )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct drm_property *prop ;
  int i ;
  {
  dev = connector->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  prop = dev_priv->broadcast_rgb_property;
  if ((unsigned long )prop == (unsigned long )((struct drm_property *)0)) {
    {
    prop = drm_property_create(dev, 8, "Broadcast RGB", 2);
    }
    if ((unsigned long )prop == (unsigned long )((struct drm_property *)0)) {
      return;
    } else {
    }
    i = 0;
    goto ldv_37308;
    ldv_37307:
    {
    drm_property_add_enum(prop, i, (uint64_t )i, broadcast_rgb_names[i]);
    i = i + 1;
    }
    ldv_37308: ;
    if ((unsigned int )i <= 1U) {
      goto ldv_37307;
    } else {
      goto ldv_37309;
    }
    ldv_37309:
    dev_priv->broadcast_rgb_property = prop;
  } else {
  }
  {
  drm_connector_attach_property(connector, prop, 0ULL);
  }
  return;
}
}
__inline static void trace_i915_reg_rw___13(bool write , u32 reg , u64 val , int len )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_reg_rw.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_reg_rw.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )411);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_36254:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , bool , u32 , u64 , int ))it_func))(__data, (bool )((int )write),
                                                                   reg, val, len);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_36254;
      } else {
        goto ldv_36255;
      }
      ldv_36255: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
__inline static u32 i915_read32___13(struct drm_i915_private *dev_priv , u32 reg )
{ u32 val ;
  {
  val = 0U;
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        gen6_gt_force_wake_get(dev_priv);
        val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
        gen6_gt_force_wake_put(dev_priv);
        }
      } else {
        {
        val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
        }
      }
    } else {
      {
      val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
      }
    }
  } else {
    {
    val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
    }
  }
  {
  trace_i915_reg_rw___13((bool )0, reg, (u64 )val, 4);
  }
  return (val);
}
}
__inline static void i915_write32___11(struct drm_i915_private *dev_priv , u32 reg ,
                                       u32 val )
{
  {
  {
  trace_i915_reg_rw___13((bool )1, reg, (u64 )val, 4);
  }
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        __gen6_gt_wait_for_fifo(dev_priv);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  writel(val, (void volatile *)dev_priv->regs + (unsigned long )reg);
  }
  return;
}
}
u32 intel_panel_get_max_backlight(struct drm_device *dev ) ;
u32 intel_panel_get_backlight(struct drm_device *dev ) ;
void intel_panel_set_backlight(struct drm_device *dev , u32 level ) ;
void intel_fixed_panel_mode(struct drm_display_mode *fixed_mode , struct drm_display_mode *adjusted_mode )
{
  {
  {
  adjusted_mode->hdisplay = fixed_mode->hdisplay;
  adjusted_mode->hsync_start = fixed_mode->hsync_start;
  adjusted_mode->hsync_end = fixed_mode->hsync_end;
  adjusted_mode->htotal = fixed_mode->htotal;
  adjusted_mode->vdisplay = fixed_mode->vdisplay;
  adjusted_mode->vsync_start = fixed_mode->vsync_start;
  adjusted_mode->vsync_end = fixed_mode->vsync_end;
  adjusted_mode->vtotal = fixed_mode->vtotal;
  adjusted_mode->clock = fixed_mode->clock;
  drm_mode_set_crtcinfo(adjusted_mode, 1);
  }
  return;
}
}
void intel_pch_panel_fitting(struct drm_device *dev , int fitting_mode , struct drm_display_mode *mode ,
                             struct drm_display_mode *adjusted_mode )
{ struct drm_i915_private *dev_priv ;
  int x ;
  int y ;
  int width ;
  int height ;
  u32 scaled_width ;
  u32 scaled_height ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  height = 0;
  width = height;
  y = width;
  x = y;
  if (adjusted_mode->hdisplay == mode->hdisplay) {
    if (adjusted_mode->vdisplay == mode->vdisplay) {
      goto done;
    } else {
    }
  } else {
  }
  if (fitting_mode == 2) {
    goto case_2;
  } else
  if (fitting_mode == 3) {
    goto case_3;
  } else
  if (fitting_mode == 1) {
    goto case_1;
  } else {
    goto switch_default;
    if (0) {
      case_2:
      width = mode->hdisplay;
      height = mode->vdisplay;
      x = ((adjusted_mode->hdisplay - width) + 1) / 2;
      y = ((adjusted_mode->vdisplay - height) + 1) / 2;
      goto ldv_37283;
      case_3:
      scaled_width = (u32 )(adjusted_mode->hdisplay * mode->vdisplay);
      scaled_height = (u32 )(mode->hdisplay * adjusted_mode->vdisplay);
      if (scaled_width > scaled_height) {
        width = (int )(scaled_height / (u32 )mode->vdisplay);
        x = ((adjusted_mode->hdisplay - width) + 1) / 2;
        y = 0;
        height = adjusted_mode->vdisplay;
      } else
      if (scaled_width < scaled_height) {
        height = (int )(scaled_width / (u32 )mode->hdisplay);
        y = ((adjusted_mode->vdisplay - height) + 1) / 2;
        x = 0;
        width = adjusted_mode->hdisplay;
      } else {
        y = 0;
        x = y;
        width = adjusted_mode->hdisplay;
        height = adjusted_mode->vdisplay;
      }
      goto ldv_37283;
      switch_default: ;
      case_1:
      y = 0;
      x = y;
      width = adjusted_mode->hdisplay;
      height = adjusted_mode->vdisplay;
      goto ldv_37283;
    } else {
    }
  }
  ldv_37283: ;
  done:
  dev_priv->pch_pf_pos = (u32 )((x << 16) | y);
  dev_priv->pch_pf_size = (u32 )((width << 16) | height);
  return;
}
}
static int is_backlight_combination_mode(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 tmp ;
  u32 tmp___0 ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    {
    tmp = i915_read32___13(dev_priv, 397904U);
    }
    return ((int )tmp & 1073741824);
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 2U) {
    {
    tmp___0 = i915_read32___13(dev_priv, 397908U);
    }
    return ((int )tmp___0 & 65536);
  } else {
  }
  return (0);
}
}
static u32 i915_read_blc_pwm_ctl(struct drm_i915_private *dev_priv )
{ u32 val ;
  {
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)(dev_priv->dev)->dev_private)->info)->gen) == 5U) {
    goto _L;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)(dev_priv->dev)->dev_private)->info)->gen) == 6U) {
    goto _L;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)(dev_priv->dev)->dev_private)->info + 2UL) != 0U) {
    _L:
    {
    val = i915_read32___13(dev_priv, 819796U);
    }
    if (dev_priv->saveBLC_PWM_CTL2 == 0U) {
      dev_priv->saveBLC_PWM_CTL2 = val;
    } else
    if (val == 0U) {
      {
      i915_write32___11(dev_priv, 819796U, dev_priv->saveBLC_PWM_CTL);
      val = dev_priv->saveBLC_PWM_CTL;
      }
    } else {
    }
  } else {
    {
    val = i915_read32___13(dev_priv, 397908U);
    }
    if (dev_priv->saveBLC_PWM_CTL == 0U) {
      {
      dev_priv->saveBLC_PWM_CTL = val;
      dev_priv->saveBLC_PWM_CTL2 = i915_read32___13(dev_priv, 397904U);
      }
    } else
    if (val == 0U) {
      {
      i915_write32___11(dev_priv, 397908U, dev_priv->saveBLC_PWM_CTL);
      i915_write32___11(dev_priv, 397904U, dev_priv->saveBLC_PWM_CTL2);
      val = dev_priv->saveBLC_PWM_CTL;
      }
    } else {
    }
  }
  return (val);
}
}
u32 intel_panel_get_max_backlight(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 max ;
  bool __print_once ;
  int tmp ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  max = i915_read_blc_pwm_ctl(dev_priv);
  }
  if (max == 0U) {
    if (! __print_once) {
      {
      __print_once = (bool )1;
      printk("<4>fixme: max PWM is zero.\n");
      }
    } else {
    }
    return (1U);
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    max = max >> 16;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    max = max >> 16;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    max = max >> 16;
  } else {
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
      max = max >> 17;
    } else {
      max = max >> 16;
      if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) <= 3U) {
        max = max & 4294967294U;
      } else {
      }
    }
    {
    tmp = is_backlight_combination_mode(dev);
    }
    if (tmp != 0) {
      max = max * 255U;
    } else {
    }
  }
  {
  drm_ut_debug_printk(2U, "drm", "intel_panel_get_max_backlight", "max backlight PWM = %d\n",
                      max);
  }
  return (max);
}
}
u32 intel_panel_get_backlight(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 val ;
  u32 tmp ;
  u32 tmp___0 ;
  u8 lbpc ;
  int tmp___1 ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    tmp = i915_read32___13(dev_priv, 295508U);
    val = tmp & 65535U;
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    tmp = i915_read32___13(dev_priv, 295508U);
    val = tmp & 65535U;
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    tmp = i915_read32___13(dev_priv, 295508U);
    val = tmp & 65535U;
    }
  } else {
    {
    tmp___0 = i915_read32___13(dev_priv, 397908U);
    val = tmp___0 & 65535U;
    }
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
      val = val >> 1;
    } else {
    }
    {
    tmp___1 = is_backlight_combination_mode(dev);
    }
    if (tmp___1 != 0) {
      {
      val = val & 4294967294U;
      pci_read_config_byte(dev->pdev, 244, & lbpc);
      val = (u32 )lbpc * val;
      }
    } else {
    }
  }
  {
  drm_ut_debug_printk(2U, "drm", "intel_panel_get_backlight", "get backlight PWM = %d\n",
                      val);
  }
  return (val);
}
}
void intel_panel_set_backlight(struct drm_device *dev , u32 level )
{ struct drm_i915_private *dev_priv ;
  u32 tmp ;
  u32 max ;
  u32 tmp___0 ;
  u8 lbpc ;
  int tmp___1 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  drm_ut_debug_printk(2U, "drm", "intel_panel_set_backlight", "set backlight PWM = %d\n",
                      level);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    return;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    return;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    return;
  } else {
  }
  {
  tmp___1 = is_backlight_combination_mode(dev);
  }
  if (tmp___1 != 0) {
    {
    tmp___0 = intel_panel_get_max_backlight(dev);
    max = tmp___0;
    lbpc = (u8 )((unsigned int )((u8 )((level * 254U) / max)) + 1U);
    level = level / (u32 )lbpc;
    pci_write_config_byte(dev->pdev, 244, (u8 )((int )lbpc));
    }
  } else {
  }
  {
  tmp = i915_read32___13(dev_priv, 397908U);
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    tmp = tmp & 4294901761U;
    level = level << 1;
  } else {
    tmp = tmp & 4294901760U;
  }
  {
  i915_write32___11(dev_priv, 397908U, tmp | level);
  }
  return;
}
}
void intel_panel_disable_backlight(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 tmp ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((int )dev_priv->backlight_enabled) {
    {
    tmp = intel_panel_get_backlight(dev);
    dev_priv->backlight_level = (int )tmp;
    dev_priv->backlight_enabled = (bool )0;
    }
  } else {
  }
  {
  intel_panel_set_backlight(dev, 0U);
  }
  return;
}
}
void intel_panel_enable_backlight(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 tmp ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if (dev_priv->backlight_level == 0) {
    {
    tmp = intel_panel_get_max_backlight(dev);
    dev_priv->backlight_level = (int )tmp;
    }
  } else {
  }
  {
  intel_panel_set_backlight(dev, (u32 )dev_priv->backlight_level);
  dev_priv->backlight_enabled = (bool )1;
  }
  return;
}
}
void intel_panel_setup_backlight(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 tmp ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = intel_panel_get_backlight(dev);
  dev_priv->backlight_level = (int )tmp;
  dev_priv->backlight_enabled = (bool )(dev_priv->backlight_level != 0);
  }
  return;
}
}
enum drm_connector_status intel_panel_detect(struct drm_device *dev )
{ int tmp ;
  {
  if (i915_panel_ignore_lid != 0) {
    if (i915_panel_ignore_lid > 0) {
      tmp = 1;
    } else {
      tmp = 2;
    }
    return ((enum drm_connector_status )tmp);
  } else {
  }
  return ((enum drm_connector_status )3);
}
}
extern unsigned long usecs_to_jiffies(unsigned int const ) ;
extern int i2c_bit_add_bus(struct i2c_adapter * ) ;
__inline static void trace_i915_reg_rw___14(bool write , u32 reg , u64 val , int len )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_reg_rw.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_reg_rw.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )411);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_36276:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , bool , u32 , u64 , int ))it_func))(__data, (bool )((int )write),
                                                                   reg, val, len);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_36276;
      } else {
        goto ldv_36277;
      }
      ldv_36277: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
__inline static u32 i915_read32___14(struct drm_i915_private *dev_priv , u32 reg )
{ u32 val ;
  {
  val = 0U;
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        gen6_gt_force_wake_get(dev_priv);
        val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
        gen6_gt_force_wake_put(dev_priv);
        }
      } else {
        {
        val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
        }
      }
    } else {
      {
      val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
      }
    }
  } else {
    {
    val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
    }
  }
  {
  trace_i915_reg_rw___14((bool )0, reg, (u64 )val, 4);
  }
  return (val);
}
}
__inline static void i915_write32___12(struct drm_i915_private *dev_priv , u32 reg ,
                                       u32 val )
{
  {
  {
  trace_i915_reg_rw___14((bool )1, reg, (u64 )val, 4);
  }
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        __gen6_gt_wait_for_fifo(dev_priv);
        }
      } else {
      }
    } else {
    }
  } else {
  }
  {
  writel(val, (void volatile *)dev_priv->regs + (unsigned long )reg);
  }
  return;
}
}
__inline static struct intel_gmbus *to_intel_gmbus(struct i2c_adapter *i2c )
{ struct i2c_adapter const *__mptr ;
  {
  __mptr = (struct i2c_adapter const *)i2c;
  return ((struct intel_gmbus *)__mptr);
}
}
void intel_i2c_reset(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    i915_write32___12(dev_priv, 807168U, 0U);
    }
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    {
    i915_write32___12(dev_priv, 807168U, 0U);
    }
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
    {
    i915_write32___12(dev_priv, 807168U, 0U);
    }
  } else {
    {
    i915_write32___12(dev_priv, 20736U, 0U);
    }
  }
  return;
}
}
static void intel_i2c_quirk_set(struct drm_i915_private *dev_priv , bool enable )
{ u32 val ;
  {
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)(dev_priv->dev)->dev_private)->info + 1UL) == 0U) {
    return;
  } else {
  }
  {
  val = i915_read32___14(dev_priv, 25088U);
  }
  if ((int )enable) {
    val = val | 16777216U;
  } else {
    val = val & 4278190079U;
  }
  {
  i915_write32___12(dev_priv, 25088U, val);
  }
  return;
}
}
static u32 get_reserved(struct intel_gpio *gpio )
{ struct drm_i915_private *dev_priv ;
  struct drm_device *dev ;
  u32 reserved ;
  unsigned int tmp ;
  {
  dev_priv = gpio->dev_priv;
  dev = dev_priv->dev;
  reserved = 0U;
  if (dev->pci_device != 13687) {
    if (dev->pci_device != 9570) {
      {
      tmp = readl((void const volatile *)dev_priv->regs + (unsigned long )gpio->reg);
      reserved = tmp & 8224U;
      }
    } else {
    }
  } else {
  }
  return (reserved);
}
}
static int get_clock(void *data )
{ struct intel_gpio *gpio ;
  struct drm_i915_private *dev_priv ;
  u32 reserved ;
  u32 tmp ;
  unsigned int tmp___0 ;
  {
  {
  gpio = (struct intel_gpio *)data;
  dev_priv = gpio->dev_priv;
  tmp = get_reserved(gpio);
  reserved = tmp;
  writel(reserved | 1U, (void volatile *)dev_priv->regs + (unsigned long )gpio->reg);
  writel(reserved, (void volatile *)dev_priv->regs + (unsigned long )gpio->reg);
  tmp___0 = readl((void const volatile *)dev_priv->regs + (unsigned long )gpio->reg);
  }
  return ((tmp___0 & 16U) != 0U);
}
}
static int get_data(void *data )
{ struct intel_gpio *gpio ;
  struct drm_i915_private *dev_priv ;
  u32 reserved ;
  u32 tmp ;
  unsigned int tmp___0 ;
  {
  {
  gpio = (struct intel_gpio *)data;
  dev_priv = gpio->dev_priv;
  tmp = get_reserved(gpio);
  reserved = tmp;
  writel(reserved | 256U, (void volatile *)dev_priv->regs + (unsigned long )gpio->reg);
  writel(reserved, (void volatile *)dev_priv->regs + (unsigned long )gpio->reg);
  tmp___0 = readl((void const volatile *)dev_priv->regs + (unsigned long )gpio->reg);
  }
  return ((tmp___0 & 4096U) != 0U);
}
}
static void set_clock(void *data , int state_high )
{ struct intel_gpio *gpio ;
  struct drm_i915_private *dev_priv ;
  u32 reserved ;
  u32 tmp ;
  u32 clock_bits ;
  {
  {
  gpio = (struct intel_gpio *)data;
  dev_priv = gpio->dev_priv;
  tmp = get_reserved(gpio);
  reserved = tmp;
  }
  if (state_high != 0) {
    clock_bits = 1U;
  } else {
    clock_bits = 7U;
  }
  {
  writel(reserved | clock_bits, (void volatile *)dev_priv->regs + (unsigned long )gpio->reg);
  readl((void const volatile *)dev_priv->regs + (unsigned long )gpio->reg);
  }
  return;
}
}
static void set_data(void *data , int state_high )
{ struct intel_gpio *gpio ;
  struct drm_i915_private *dev_priv ;
  u32 reserved ;
  u32 tmp ;
  u32 data_bits ;
  {
  {
  gpio = (struct intel_gpio *)data;
  dev_priv = gpio->dev_priv;
  tmp = get_reserved(gpio);
  reserved = tmp;
  }
  if (state_high != 0) {
    data_bits = 256U;
  } else {
    data_bits = 1792U;
  }
  {
  writel(reserved | data_bits, (void volatile *)dev_priv->regs + (unsigned long )gpio->reg);
  readl((void const volatile *)dev_priv->regs + (unsigned long )gpio->reg);
  }
  return;
}
}
static struct i2c_adapter *intel_gpio_create(struct drm_i915_private *dev_priv , u32 pin )
{ int map_pin_to_reg[8U] ;
  struct intel_gpio *gpio ;
  void *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  {
  map_pin_to_reg[0] = 0;
  map_pin_to_reg[1] = 20500;
  map_pin_to_reg[2] = 20496;
  map_pin_to_reg[3] = 20504;
  map_pin_to_reg[4] = 20508;
  map_pin_to_reg[5] = 20512;
  map_pin_to_reg[6] = 0;
  map_pin_to_reg[7] = 20516;
  if (pin > 7U) {
    return ((struct i2c_adapter *)0);
  } else
  if (map_pin_to_reg[pin] == 0) {
    return ((struct i2c_adapter *)0);
  } else {
  }
  {
  tmp = kzalloc(1720UL, 208U);
  gpio = (struct intel_gpio *)tmp;
  }
  if ((unsigned long )gpio == (unsigned long )((struct intel_gpio *)0)) {
    return ((struct i2c_adapter *)0);
  } else {
  }
  gpio->reg = (u32 )map_pin_to_reg[pin];
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)(dev_priv->dev)->dev_private)->info)->gen) == 5U) {
    gpio->reg = gpio->reg + 786432U;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)(dev_priv->dev)->dev_private)->info)->gen) == 6U) {
    gpio->reg = gpio->reg + 786432U;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)(dev_priv->dev)->dev_private)->info + 2UL) != 0U) {
    gpio->reg = gpio->reg + 786432U;
  } else {
  }
  {
  gpio->dev_priv = dev_priv;
  snprintf((char *)(& gpio->adapter.name), 48UL, "i915 GPIO%c", (int )*("?BACDE?F" + pin));
  gpio->adapter.owner = & __this_module;
  gpio->adapter.algo_data = (void *)(& gpio->algo);
  gpio->adapter.dev.parent = & ((dev_priv->dev)->pdev)->dev;
  gpio->algo.setsda = & set_data;
  gpio->algo.setscl = & set_clock;
  gpio->algo.getsda = & get_data;
  gpio->algo.getscl = & get_clock;
  gpio->algo.udelay = 20;
  tmp___0 = usecs_to_jiffies((unsigned int const )2200U);
  gpio->algo.timeout = (int )tmp___0;
  gpio->algo.data = (void *)gpio;
  tmp___1 = i2c_bit_add_bus(& gpio->adapter);
  }
  if (tmp___1 != 0) {
    goto out_free;
  } else {
  }
  return (& gpio->adapter);
  out_free:
  {
  kfree((void const *)gpio);
  }
  return ((struct i2c_adapter *)0);
}
}
static int intel_i2c_quirk_xfer(struct drm_i915_private *dev_priv , struct i2c_adapter *adapter ,
                                struct i2c_msg *msgs , int num )
{ struct intel_gpio *gpio ;
  struct i2c_adapter const *__mptr ;
  int ret ;
  {
  {
  __mptr = (struct i2c_adapter const *)adapter;
  gpio = (struct intel_gpio *)__mptr;
  intel_i2c_reset(dev_priv->dev);
  intel_i2c_quirk_set(dev_priv, (bool )1);
  set_data((void *)gpio, 1);
  set_clock((void *)gpio, 1);
  __const_udelay(85900UL);
  ret = (*((adapter->algo)->master_xfer))(adapter, msgs, num);
  set_data((void *)gpio, 1);
  set_clock((void *)gpio, 1);
  intel_i2c_quirk_set(dev_priv, (bool )0);
  }
  return (ret);
}
}
static int gmbus_xfer(struct i2c_adapter *adapter , struct i2c_msg *msgs , int num )
{ struct intel_gmbus *bus ;
  struct i2c_adapter const *__mptr ;
  struct drm_i915_private *dev_priv ;
  int i ;
  int reg_offset ;
  int tmp ;
  u16 len ;
  u8 *buf ;
  int tmp___0 ;
  u32 val ;
  u32 loop ;
  unsigned long timeout__ ;
  unsigned long tmp___1 ;
  int ret__ ;
  struct thread_info *tmp___2 ;
  int pfo_ret__ ;
  int tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u8 *tmp___6 ;
  u32 val___0 ;
  u32 loop___0 ;
  u8 *tmp___7 ;
  int tmp___8 ;
  unsigned long timeout_____0 ;
  unsigned long tmp___9 ;
  int ret_____0 ;
  struct thread_info *tmp___10 ;
  int pfo_ret_____0 ;
  int tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u8 *tmp___14 ;
  unsigned long timeout_____1 ;
  unsigned long tmp___15 ;
  int ret_____1 ;
  struct thread_info *tmp___16 ;
  int pfo_ret_____1 ;
  int tmp___17 ;
  u32 tmp___18 ;
  u32 tmp___19 ;
  int tmp___20 ;
  {
  __mptr = (struct i2c_adapter const *)adapter;
  bus = (struct intel_gmbus *)__mptr;
  dev_priv = (struct drm_i915_private *)adapter->algo_data;
  if ((unsigned long )bus->force_bit != (unsigned long )((struct i2c_adapter *)0)) {
    {
    tmp = intel_i2c_quirk_xfer(dev_priv, bus->force_bit, msgs, num);
    }
    return (tmp);
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)(dev_priv->dev)->dev_private)->info)->gen) == 5U) {
    reg_offset = 786432;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)(dev_priv->dev)->dev_private)->info)->gen) == 6U) {
    reg_offset = 786432;
  } else
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)(dev_priv->dev)->dev_private)->info + 2UL) != 0U) {
    reg_offset = 786432;
  } else {
    reg_offset = 0;
  }
  {
  i915_write32___12(dev_priv, (u32 )(reg_offset + 20736), bus->reg0);
  i = 0;
  }
  goto ldv_37733;
  ldv_37732:
  len = (msgs + (unsigned long )i)->len;
  buf = (msgs + (unsigned long )i)->buf;
  if ((int )(msgs + (unsigned long )i)->flags & 1) {
    if (i + 1 == num) {
      tmp___0 = 167772160;
    } else {
      tmp___0 = 33554432;
    }
    {
    i915_write32___12(dev_priv, (u32 )(reg_offset + 20740), (u32 )(((tmp___0 | ((int )len << 16)) | ((int )(msgs + (unsigned long )i)->addr << 1)) | 1073741825));
    readl((void const volatile *)dev_priv->regs + (unsigned long )(reg_offset + 20744));
    }
    ldv_37681:
    {
    loop = 0U;
    tmp___1 = msecs_to_jiffies((unsigned int const )50U);
    timeout__ = tmp___1 + (unsigned long )jiffies;
    ret__ = 0;
    }
    goto ldv_37675;
    ldv_37674: ;
    if ((long )timeout__ - (long )jiffies < 0L) {
      ret__ = -110;
      goto ldv_37665;
    } else {
    }
    {
    tmp___2 = current_thread_info();
    }
    if ((tmp___2->preempt_count & -268435457) == 0) {
      if (1) {
        goto case_4;
      } else {
        goto switch_default;
        if (0) {
          __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
          goto ldv_37668;
          __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
          goto ldv_37668;
          case_4:
          __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
          goto ldv_37668;
          __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
          goto ldv_37668;
          switch_default:
          {
          __bad_percpu_size();
          }
        } else {
        }
      }
      ldv_37668:
      {
      tmp___3 = atomic_read((atomic_t const *)(& kgdb_active));
      }
      if (pfo_ret__ != tmp___3) {
        {
        msleep(1U);
        }
      } else {
      }
    } else {
    }
    ldv_37675:
    {
    tmp___4 = i915_read32___14(dev_priv, (u32 )(reg_offset + 20744));
    }
    if ((tmp___4 & 3072U) == 0U) {
      goto ldv_37674;
    } else {
      goto ldv_37665;
    }
    ldv_37665: ;
    if (ret__ != 0) {
      goto timeout;
    } else {
    }
    {
    tmp___5 = i915_read32___14(dev_priv, (u32 )(reg_offset + 20744));
    }
    if ((tmp___5 & 1024U) != 0U) {
      goto clear_err;
    } else {
    }
    {
    val = i915_read32___14(dev_priv, (u32 )(reg_offset + 20748));
    }
    ldv_37679:
    tmp___6 = buf;
    buf = buf + 1;
    *tmp___6 = (u8 )val;
    val = val >> 8;
    len = (u16 )((int )len - 1);
    if ((unsigned int )len != 0U) {
      loop = loop + 1U;
      if (loop <= 3U) {
        goto ldv_37679;
      } else {
        goto ldv_37680;
      }
    } else {
      goto ldv_37680;
    }
    ldv_37680: ;
    if ((unsigned int )len != 0U) {
      goto ldv_37681;
    } else {
      goto ldv_37682;
    }
    ldv_37682: ;
  } else {
    loop___0 = 0U;
    val___0 = loop___0;
    ldv_37685:
    tmp___7 = buf;
    buf = buf + 1;
    val___0 = (u32 )((int )*tmp___7 << (int )(loop___0 * 8U)) | val___0;
    len = (u16 )((int )len - 1);
    if ((unsigned int )len != 0U) {
      loop___0 = loop___0 + 1U;
      if (loop___0 <= 3U) {
        goto ldv_37685;
      } else {
        goto ldv_37686;
      }
    } else {
      goto ldv_37686;
    }
    ldv_37686:
    {
    i915_write32___12(dev_priv, (u32 )(reg_offset + 20748), val___0);
    }
    if (i + 1 == num) {
      tmp___8 = 134217728;
    } else {
      tmp___8 = 33554432;
    }
    {
    i915_write32___12(dev_priv, (u32 )(reg_offset + 20740), (u32 )(((tmp___8 | ((int )(msgs + (unsigned long )i)->len << 16)) | ((int )(msgs + (unsigned long )i)->addr << 1)) | 1073741824));
    readl((void const volatile *)dev_priv->regs + (unsigned long )(reg_offset + 20744));
    }
    goto ldv_37710;
    ldv_37709:
    {
    tmp___9 = msecs_to_jiffies((unsigned int const )50U);
    timeout_____0 = tmp___9 + (unsigned long )jiffies;
    ret_____0 = 0;
    }
    goto ldv_37705;
    ldv_37704: ;
    if ((long )timeout_____0 - (long )jiffies < 0L) {
      ret_____0 = -110;
      goto ldv_37695;
    } else {
    }
    {
    tmp___10 = current_thread_info();
    }
    if ((tmp___10->preempt_count & -268435457) == 0) {
      if (1) {
        goto case_4___0;
      } else {
        goto switch_default___0;
        if (0) {
          __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
          goto ldv_37698;
          __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
          goto ldv_37698;
          case_4___0:
          __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
          goto ldv_37698;
          __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
          goto ldv_37698;
          switch_default___0:
          {
          __bad_percpu_size();
          }
        } else {
        }
      }
      ldv_37698:
      {
      tmp___11 = atomic_read((atomic_t const *)(& kgdb_active));
      }
      if (pfo_ret_____0 != tmp___11) {
        {
        msleep(1U);
        }
      } else {
      }
    } else {
    }
    ldv_37705:
    {
    tmp___12 = i915_read32___14(dev_priv, (u32 )(reg_offset + 20744));
    }
    if ((tmp___12 & 3072U) == 0U) {
      goto ldv_37704;
    } else {
      goto ldv_37695;
    }
    ldv_37695: ;
    if (ret_____0 != 0) {
      goto timeout;
    } else {
    }
    {
    tmp___13 = i915_read32___14(dev_priv, (u32 )(reg_offset + 20744));
    }
    if ((tmp___13 & 1024U) != 0U) {
      goto clear_err;
    } else {
    }
    loop___0 = 0U;
    val___0 = loop___0;
    ldv_37707:
    tmp___14 = buf;
    buf = buf + 1;
    val___0 = (u32 )((int )*tmp___14 << (int )(loop___0 * 8U)) | val___0;
    len = (u16 )((int )len - 1);
    if ((unsigned int )len != 0U) {
      loop___0 = loop___0 + 1U;
      if (loop___0 <= 3U) {
        goto ldv_37707;
      } else {
        goto ldv_37708;
      }
    } else {
      goto ldv_37708;
    }
    ldv_37708:
    {
    i915_write32___12(dev_priv, (u32 )(reg_offset + 20748), val___0);
    readl((void const volatile *)dev_priv->regs + (unsigned long )(reg_offset + 20744));
    }
    ldv_37710: ;
    if ((unsigned int )len != 0U) {
      goto ldv_37709;
    } else {
      goto ldv_37711;
    }
    ldv_37711: ;
  }
  if (i + 1 < num) {
    {
    tmp___15 = msecs_to_jiffies((unsigned int const )50U);
    timeout_____1 = tmp___15 + (unsigned long )jiffies;
    ret_____1 = 0;
    }
    goto ldv_37730;
    ldv_37729: ;
    if ((long )timeout_____1 - (long )jiffies < 0L) {
      ret_____1 = -110;
      goto ldv_37720;
    } else {
    }
    {
    tmp___16 = current_thread_info();
    }
    if ((tmp___16->preempt_count & -268435457) == 0) {
      if (1) {
        goto case_4___1;
      } else {
        goto switch_default___1;
        if (0) {
          __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
          goto ldv_37723;
          __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
          goto ldv_37723;
          case_4___1:
          __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
          goto ldv_37723;
          __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
          goto ldv_37723;
          switch_default___1:
          {
          __bad_percpu_size();
          }
        } else {
        }
      }
      ldv_37723:
      {
      tmp___17 = atomic_read((atomic_t const *)(& kgdb_active));
      }
      if (pfo_ret_____1 != tmp___17) {
        {
        msleep(1U);
        }
      } else {
      }
    } else {
    }
    ldv_37730:
    {
    tmp___18 = i915_read32___14(dev_priv, (u32 )(reg_offset + 20744));
    }
    if ((tmp___18 & 17408U) == 0U) {
      goto ldv_37729;
    } else {
      goto ldv_37720;
    }
    ldv_37720: ;
    if (ret_____1 != 0) {
      goto timeout;
    } else {
    }
  } else {
  }
  {
  tmp___19 = i915_read32___14(dev_priv, (u32 )(reg_offset + 20744));
  }
  if ((tmp___19 & 1024U) != 0U) {
    goto clear_err;
  } else {
  }
  i = i + 1;
  ldv_37733: ;
  if (i < num) {
    goto ldv_37732;
  } else {
    goto ldv_37734;
  }
  ldv_37734: ;
  goto done;
  clear_err:
  {
  i915_write32___12(dev_priv, (u32 )(reg_offset + 20740), 2147483648U);
  i915_write32___12(dev_priv, (u32 )(reg_offset + 20740), 0U);
  }
  done:
  {
  i915_write32___12(dev_priv, (u32 )(reg_offset + 20736), 0U);
  }
  return (i);
  timeout:
  {
  printk("<6>[drm] GMBUS timed out, falling back to bit banging on pin %d [%s]\n",
         bus->reg0 & 255U, (char *)(& bus->adapter.name));
  i915_write32___12(dev_priv, (u32 )(reg_offset + 20736), 0U);
  bus->force_bit = intel_gpio_create(dev_priv, bus->reg0 & 255U);
  }
  if ((unsigned long )bus->force_bit == (unsigned long )((struct i2c_adapter *)0)) {
    return (-12);
  } else {
  }
  {
  tmp___20 = intel_i2c_quirk_xfer(dev_priv, bus->force_bit, msgs, num);
  }
  return (tmp___20);
}
}
static u32 gmbus_func(struct i2c_adapter *adapter )
{ struct intel_gmbus *bus ;
  struct i2c_adapter const *__mptr ;
  {
  __mptr = (struct i2c_adapter const *)adapter;
  bus = (struct intel_gmbus *)__mptr;
  if ((unsigned long )bus->force_bit != (unsigned long )((struct i2c_adapter *)0)) {
    {
    (*(((bus->force_bit)->algo)->functionality))(bus->force_bit);
    }
  } else {
  }
  return (268402697U);
}
}
static struct i2c_algorithm const gmbus_algorithm = {& gmbus_xfer, (int (*)(struct i2c_adapter * , u16 , unsigned short , char ,
                           u8 , int , union i2c_smbus_data * ))0, & gmbus_func};
int intel_setup_gmbus(struct drm_device *dev )
{ char const *names[8U] ;
  struct drm_i915_private *dev_priv ;
  int ret ;
  int i ;
  void *tmp ;
  struct intel_gmbus *bus ;
  struct intel_gmbus *bus___0 ;
  {
  {
  names[0] = "disabled";
  names[1] = "ssc";
  names[2] = "vga";
  names[3] = "panel";
  names[4] = "dpc";
  names[5] = "dpb";
  names[6] = "reserved";
  names[7] = "dpd";
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = kcalloc(1656UL, 8UL, 208U);
  dev_priv->gmbus = (struct intel_gmbus *)tmp;
  }
  if ((unsigned long )dev_priv->gmbus == (unsigned long )((struct intel_gmbus *)0)) {
    return (-12);
  } else {
  }
  i = 0;
  goto ldv_37753;
  ldv_37752:
  {
  bus = dev_priv->gmbus + (unsigned long )i;
  bus->adapter.owner = & __this_module;
  bus->adapter.class = 8U;
  snprintf((char *)(& bus->adapter.name), 48UL, "i915 gmbus %s", names[i]);
  bus->adapter.dev.parent = & (dev->pdev)->dev;
  bus->adapter.algo_data = (void *)dev_priv;
  bus->adapter.algo = & gmbus_algorithm;
  ret = i2c_add_adapter(& bus->adapter);
  }
  if (ret != 0) {
    goto err;
  } else {
  }
  {
  bus->reg0 = (u32 )i;
  bus->force_bit = intel_gpio_create(dev_priv, (u32 )i);
  i = i + 1;
  }
  ldv_37753: ;
  if (i <= 7) {
    goto ldv_37752;
  } else {
    goto ldv_37754;
  }
  ldv_37754:
  {
  intel_i2c_reset(dev_priv->dev);
  }
  return (0);
  err: ;
  goto ldv_37757;
  ldv_37756:
  {
  bus___0 = dev_priv->gmbus + (unsigned long )i;
  i2c_del_adapter(& bus___0->adapter);
  }
  ldv_37757:
  i = i - 1;
  if (i != 0) {
    goto ldv_37756;
  } else {
    goto ldv_37758;
  }
  ldv_37758:
  {
  kfree((void const *)dev_priv->gmbus);
  dev_priv->gmbus = (struct intel_gmbus *)0;
  }
  return (ret);
}
}
void intel_gmbus_set_speed(struct i2c_adapter *adapter , int speed )
{ struct intel_gmbus *bus ;
  struct intel_gmbus *tmp ;
  {
  {
  tmp = to_intel_gmbus(adapter);
  bus = tmp;
  bus->reg0 = (bus->reg0 & 4294966527U) | (u32 )(speed << 8);
  }
  return;
}
}
void intel_gmbus_force_bit(struct i2c_adapter *adapter , bool force_bit )
{ struct intel_gmbus *bus ;
  struct intel_gmbus *tmp ;
  struct drm_i915_private *dev_priv ;
  {
  {
  tmp = to_intel_gmbus(adapter);
  bus = tmp;
  }
  if ((int )force_bit) {
    if ((unsigned long )bus->force_bit == (unsigned long )((struct i2c_adapter *)0)) {
      {
      dev_priv = (struct drm_i915_private *)adapter->algo_data;
      bus->force_bit = intel_gpio_create(dev_priv, bus->reg0 & 255U);
      }
    } else
    if ((unsigned long )bus->force_bit != (unsigned long )((struct i2c_adapter *)0)) {
      {
      i2c_del_adapter(bus->force_bit);
      kfree((void const *)bus->force_bit);
      bus->force_bit = (struct i2c_adapter *)0;
      }
    } else {
    }
  } else {
  }
  return;
}
}
void intel_teardown_gmbus(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  int i ;
  struct intel_gmbus *bus ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((unsigned long )dev_priv->gmbus == (unsigned long )((struct intel_gmbus *)0)) {
    return;
  } else {
  }
  i = 0;
  goto ldv_37777;
  ldv_37776:
  bus = dev_priv->gmbus + (unsigned long )i;
  if ((unsigned long )bus->force_bit != (unsigned long )((struct i2c_adapter *)0)) {
    {
    i2c_del_adapter(bus->force_bit);
    kfree((void const *)bus->force_bit);
    }
  } else {
  }
  {
  i2c_del_adapter(& bus->adapter);
  i = i + 1;
  }
  ldv_37777: ;
  if (i <= 7) {
    goto ldv_37776;
  } else {
    goto ldv_37778;
  }
  ldv_37778:
  {
  kfree((void const *)dev_priv->gmbus);
  dev_priv->gmbus = (struct intel_gmbus *)0;
  }
  return;
}
}
extern char *strcpy(char * , char const * ) ;
__inline static struct apertures_struct *alloc_apertures(unsigned int max_num )
{ struct apertures_struct *a ;
  void *tmp ;
  {
  {
  tmp = kzalloc((unsigned long )max_num * 16UL + 8UL, 208U);
  a = (struct apertures_struct *)tmp;
  }
  if ((unsigned long )a == (unsigned long )((struct apertures_struct *)0)) {
    return ((struct apertures_struct *)0);
  } else {
  }
  a->count = max_num;
  return (a);
}
}
extern void cfb_fillrect(struct fb_info * , struct fb_fillrect const * ) ;
extern void cfb_copyarea(struct fb_info * , struct fb_copyarea const * ) ;
extern void cfb_imageblit(struct fb_info * , struct fb_image const * ) ;
extern int unregister_framebuffer(struct fb_info * ) ;
extern struct fb_info *framebuffer_alloc(size_t , struct device * ) ;
extern void framebuffer_release(struct fb_info * ) ;
extern int fb_alloc_cmap(struct fb_cmap * , int , int ) ;
extern void fb_dealloc_cmap(struct fb_cmap * ) ;
extern void vga_switcheroo_client_fb_set(struct pci_dev * , struct fb_info * ) ;
extern int drm_fb_helper_init(struct drm_device * , struct drm_fb_helper * , int ,
                              int ) ;
extern void drm_fb_helper_fini(struct drm_fb_helper * ) ;
extern int drm_fb_helper_blank(int , struct fb_info * ) ;
extern int drm_fb_helper_pan_display(struct fb_var_screeninfo * , struct fb_info * ) ;
extern int drm_fb_helper_set_par(struct fb_info * ) ;
extern int drm_fb_helper_check_var(struct fb_var_screeninfo * , struct fb_info * ) ;
extern bool drm_fb_helper_restore_fbdev_mode(struct drm_fb_helper * ) ;
extern void drm_fb_helper_fill_var(struct fb_info * , struct drm_fb_helper * , uint32_t ,
                                   uint32_t ) ;
extern void drm_fb_helper_fill_fix(struct fb_info * , uint32_t , uint32_t ) ;
extern int drm_fb_helper_setcmap(struct fb_cmap * , struct fb_info * ) ;
extern int drm_fb_helper_hotplug_event(struct drm_fb_helper * ) ;
extern bool drm_fb_helper_initial_config(struct drm_fb_helper * , int ) ;
extern int drm_fb_helper_single_add_all_connectors(struct drm_fb_helper * ) ;
extern int drm_fb_helper_debug_enter(struct fb_info * ) ;
extern int drm_fb_helper_debug_leave(struct fb_info * ) ;
static struct fb_ops intelfb_ops =
     {& __this_module, (int (*)(struct fb_info * , int ))0, (int (*)(struct fb_info * ,
                                                                    int ))0, (ssize_t (*)(struct fb_info * ,
                                                                                           char * ,
                                                                                           size_t ,
                                                                                           loff_t * ))0,
    (ssize_t (*)(struct fb_info * , char const * , size_t , loff_t * ))0, & drm_fb_helper_check_var,
    & drm_fb_helper_set_par, (int (*)(unsigned int , unsigned int , unsigned int ,
                                      unsigned int , unsigned int , struct fb_info * ))0,
    & drm_fb_helper_setcmap, & drm_fb_helper_blank, & drm_fb_helper_pan_display, & cfb_fillrect,
    & cfb_copyarea, & cfb_imageblit, (int (*)(struct fb_info * , struct fb_cursor * ))0,
    (void (*)(struct fb_info * , int ))0, (int (*)(struct fb_info * ))0, (int (*)(struct fb_info * ,
                                                                                   unsigned int ,
                                                                                   unsigned long ))0,
    (int (*)(struct fb_info * , unsigned int , unsigned long ))0, (int (*)(struct fb_info * ,
                                                                             struct vm_area_struct * ))0,
    (void (*)(struct fb_info * , struct fb_blit_caps * , struct fb_var_screeninfo * ))0,
    (void (*)(struct fb_info * ))0, & drm_fb_helper_debug_enter, & drm_fb_helper_debug_leave};
static int intelfb_create(struct intel_fbdev *ifbdev , struct drm_fb_helper_surface_size *sizes )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct fb_info *info ;
  struct drm_framebuffer *fb ;
  struct drm_mode_fb_cmd mode_cmd ;
  struct drm_i915_gem_object *obj ;
  struct device *device ;
  int size ;
  int ret ;
  void *tmp ;
  {
  dev = ifbdev->helper.dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  device = & (dev->pdev)->dev;
  if (sizes->surface_bpp == 24U) {
    sizes->surface_bpp = 32U;
  } else {
  }
  {
  mode_cmd.width = sizes->surface_width;
  mode_cmd.height = sizes->surface_height;
  mode_cmd.bpp = sizes->surface_bpp;
  mode_cmd.pitch = (mode_cmd.width * ((mode_cmd.bpp + 7U) / 8U) + 63U) & 4294967232U;
  mode_cmd.depth = sizes->surface_depth;
  size = (int )(mode_cmd.pitch * mode_cmd.height);
  size = (size + 4095) & -4096;
  obj = i915_gem_alloc_object(dev, (size_t )size);
  }
  if ((unsigned long )obj == (unsigned long )((struct drm_i915_gem_object *)0)) {
    {
    drm_err("intelfb_create", "failed to allocate framebuffer\n");
    ret = -12;
    }
    goto out;
  } else {
  }
  {
  mutex_lock_nested(& dev->struct_mutex, 0U);
  ret = intel_pin_and_fence_fb_obj(dev, obj, (struct intel_ring_buffer *)0);
  }
  if (ret != 0) {
    {
    drm_err("intelfb_create", "failed to pin fb: %d\n", ret);
    }
    goto out_unref;
  } else {
  }
  {
  info = framebuffer_alloc(0UL, device);
  }
  if ((unsigned long )info == (unsigned long )((struct fb_info *)0)) {
    ret = -12;
    goto out_unpin;
  } else {
  }
  {
  info->par = (void *)ifbdev;
  ret = intel_framebuffer_init(dev, & ifbdev->ifb, & mode_cmd, obj);
  }
  if (ret != 0) {
    goto out_unpin;
  } else {
  }
  {
  fb = & ifbdev->ifb.base;
  ifbdev->helper.fb = fb;
  ifbdev->helper.fbdev = info;
  strcpy((char *)(& info->fix.id), "inteldrmfb");
  info->flags = 2097153;
  info->fbops = & intelfb_ops;
  ret = fb_alloc_cmap(& info->cmap, 256, 0);
  }
  if (ret != 0) {
    ret = -12;
    goto out_unpin;
  } else {
  }
  {
  info->apertures = alloc_apertures(1U);
  }
  if ((unsigned long )info->apertures == (unsigned long )((struct apertures_struct *)0)) {
    ret = -12;
    goto out_unpin;
  } else {
  }
  {
  (info->apertures)->ranges[0].base = dev->mode_config.fb_base;
  (info->apertures)->ranges[0].size = (resource_size_t )((dev_priv->mm.gtt)->gtt_mappable_entries << 12);
  info->fix.smem_start = (unsigned long )(dev->mode_config.fb_base + (resource_size_t )obj->gtt_offset);
  info->fix.smem_len = (__u32 )size;
  tmp = ioremap_wc((resource_size_t )((dev->agp)->base + (unsigned long )obj->gtt_offset),
                   (unsigned long )size);
  info->screen_base = (char *)tmp;
  }
  if ((unsigned long )info->screen_base == (unsigned long )((char *)0)) {
    ret = -28;
    goto out_unpin;
  } else {
  }
  {
  info->screen_size = (unsigned long )size;
  drm_fb_helper_fill_fix(info, fb->pitch, fb->depth);
  drm_fb_helper_fill_var(info, & ifbdev->helper, sizes->fb_width, sizes->fb_height);
  info->pixmap.size = 65536U;
  info->pixmap.buf_align = 8U;
  info->pixmap.access_align = 32U;
  info->pixmap.flags = 2U;
  info->pixmap.scan_align = 1U;
  drm_ut_debug_printk(4U, "drm", "intelfb_create", "allocated %dx%d fb: 0x%08x, bo %p\n",
                      fb->width, fb->height, obj->gtt_offset, obj);
  mutex_unlock(& dev->struct_mutex);
  vga_switcheroo_client_fb_set(dev->pdev, info);
  }
  return (0);
  out_unpin:
  {
  i915_gem_object_unpin(obj);
  }
  out_unref:
  {
  drm_gem_object_unreference(& obj->base);
  mutex_unlock(& dev->struct_mutex);
  }
  out: ;
  return (ret);
}
}
static int intel_fb_find_or_create_single(struct drm_fb_helper *helper , struct drm_fb_helper_surface_size *sizes )
{ struct intel_fbdev *ifbdev ;
  int new_fb ;
  int ret ;
  {
  ifbdev = (struct intel_fbdev *)helper;
  new_fb = 0;
  if ((unsigned long )helper->fb == (unsigned long )((struct drm_framebuffer *)0)) {
    {
    ret = intelfb_create(ifbdev, sizes);
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
    new_fb = 1;
  } else {
  }
  return (new_fb);
}
}
static struct drm_fb_helper_funcs intel_fb_helper_funcs = {& intel_crtc_fb_gamma_set, & intel_crtc_fb_gamma_get, & intel_fb_find_or_create_single};
static void intel_fbdev_destroy(struct drm_device *dev , struct intel_fbdev *ifbdev )
{ struct fb_info *info ;
  struct intel_framebuffer *ifb ;
  {
  ifb = & ifbdev->ifb;
  if ((unsigned long )ifbdev->helper.fbdev != (unsigned long )((struct fb_info *)0)) {
    {
    info = ifbdev->helper.fbdev;
    unregister_framebuffer(info);
    iounmap((void volatile *)info->screen_base);
    }
    if (info->cmap.len != 0U) {
      {
      fb_dealloc_cmap(& info->cmap);
      }
    } else {
    }
    {
    framebuffer_release(info);
    }
  } else {
  }
  {
  drm_fb_helper_fini(& ifbdev->helper);
  drm_framebuffer_cleanup(& ifb->base);
  }
  if ((unsigned long )ifb->obj != (unsigned long )((struct drm_i915_gem_object *)0)) {
    {
    drm_gem_object_unreference_unlocked(& (ifb->obj)->base);
    ifb->obj = (struct drm_i915_gem_object *)0;
    }
  } else {
  }
  return;
}
}
int intel_fbdev_init(struct drm_device *dev )
{ struct intel_fbdev *ifbdev ;
  drm_i915_private_t *dev_priv ;
  int ret ;
  void *tmp ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = kzalloc(304UL, 208U);
  ifbdev = (struct intel_fbdev *)tmp;
  }
  if ((unsigned long )ifbdev == (unsigned long )((struct intel_fbdev *)0)) {
    return (-12);
  } else {
  }
  {
  dev_priv->fbdev = ifbdev;
  ifbdev->helper.funcs = & intel_fb_helper_funcs;
  ret = drm_fb_helper_init(dev, & ifbdev->helper, dev_priv->num_pipe, 4);
  }
  if (ret != 0) {
    {
    kfree((void const *)ifbdev);
    }
    return (ret);
  } else {
  }
  {
  drm_fb_helper_single_add_all_connectors(& ifbdev->helper);
  drm_fb_helper_initial_config(& ifbdev->helper, 32);
  }
  return (0);
}
}
void intel_fbdev_fini(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  if ((unsigned long )dev_priv->fbdev == (unsigned long )((struct intel_fbdev *)0)) {
    return;
  } else {
  }
  {
  intel_fbdev_destroy(dev, dev_priv->fbdev);
  kfree((void const *)dev_priv->fbdev);
  dev_priv->fbdev = (struct intel_fbdev *)0;
  }
  return;
}
}
void intel_fb_output_poll_changed(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  drm_fb_helper_hotplug_event(& (dev_priv->fbdev)->helper);
  }
  return;
}
}
void intel_fb_restore_mode(struct drm_device *dev )
{ int ret ;
  drm_i915_private_t *dev_priv ;
  bool tmp ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = drm_fb_helper_restore_fbdev_mode(& (dev_priv->fbdev)->helper);
  ret = (int )tmp;
  }
  if (ret != 0) {
    {
    drm_ut_debug_printk(1U, "drm", "intel_fb_restore_mode", "failed to restore crtc mode\n");
    }
  } else {
  }
  return;
}
}
extern int strcmp(char const * , char const * ) ;
extern struct drm_display_mode *drm_mode_create(struct drm_device * ) ;
extern int drm_mode_vrefresh(struct drm_display_mode const * ) ;
extern int drm_mode_create_tv_properties(struct drm_device * , int , char ** ) ;
static u32 const filter_table[206U] =
  { (u32 const )2973773824U, (u32 const )773862656U, (u32 const )889204256U, (u32 const )805351744U,
        (u32 const )899723616U, (u32 const )767569536U, (u32 const )2973774976U, (u32 const )2975870976U,
        (u32 const )782251584U, (u32 const )872426880U, (u32 const )805351712U, (u32 const )920695136U,
        (u32 const )757083888U, (u32 const )2971677568U, (u32 const )2975870976U, (u32 const )791689088U,
        (u32 const )855649472U, (u32 const )805351680U, (u32 const )941666656U, (u32 const )746598224U,
        (u32 const )2969580192U, (u32 const )2975870976U, (u32 const )797980864U, (u32 const )840969248U,
        (u32 const )805351648U, (u32 const )964735328U, (u32 const )734015424U, (u32 const )2967482816U,
        (u32 const )2975870976U, (u32 const )804272672U, (u32 const )828386144U, (u32 const )2954932416U,
        (u32 const )987804000U, (u32 const )721426448U, (u32 const )2965385504U, (u32 const )2973806624U,
        (u32 const )405289888U, (u32 const )817900160U, (u32 const )2954932384U, (u32 const )1012969792U,
        (u32 const )706746424U, (u32 const )2963288192U, (u32 const )2971709472U, (u32 const )406338848U,
        (u32 const )809511360U, (u32 const )2957029504U, (u32 const )1038135552U, (u32 const )694163528U,
        (u32 const )2961190912U, (u32 const )2969612352U, (u32 const )407387840U, (u32 const )2956994816U,
        (u32 const )2957029472U, (u32 const )1065398464U, (u32 const )679483480U, (u32 const )2959126656U,
        (u32 const )2963320928U, (u32 const )408954912U, (u32 const )2963286048U, (u32 const )45152U,
        (u32 const )2973773824U, (u32 const )773862656U, (u32 const )889204256U, (u32 const )805351744U,
        (u32 const )899723616U, (u32 const )767569536U, (u32 const )2973774976U, (u32 const )2975870976U,
        (u32 const )782251584U, (u32 const )872426880U, (u32 const )805351712U, (u32 const )920695136U,
        (u32 const )757083888U, (u32 const )2971677568U, (u32 const )2975870976U, (u32 const )791689088U,
        (u32 const )855649472U, (u32 const )805351680U, (u32 const )941666656U, (u32 const )746598224U,
        (u32 const )2969580192U, (u32 const )2975870976U, (u32 const )797980864U, (u32 const )840969248U,
        (u32 const )805351648U, (u32 const )964735328U, (u32 const )734015424U, (u32 const )2967482816U,
        (u32 const )2975870976U, (u32 const )804272672U, (u32 const )828386144U, (u32 const )2954932416U,
        (u32 const )987804000U, (u32 const )721426448U, (u32 const )2965385504U, (u32 const )2973806624U,
        (u32 const )405289888U, (u32 const )817900160U, (u32 const )2954932384U, (u32 const )1012969792U,
        (u32 const )706746424U, (u32 const )2963288192U, (u32 const )2971709472U, (u32 const )406338848U,
        (u32 const )809511360U, (u32 const )2957029504U, (u32 const )1038135552U, (u32 const )694163528U,
        (u32 const )2961190912U, (u32 const )2969612352U, (u32 const )407387840U, (u32 const )2956994816U,
        (u32 const )2957029472U, (u32 const )1065398464U, (u32 const )679483480U, (u32 const )2959126656U,
        (u32 const )2963320928U, (u32 const )408954912U, (u32 const )2963286048U, (u32 const )45152U,
        (u32 const )910176256U, (u32 const )754986176U, (u32 const )805320256U, (u32 const )754988736U,
        (u32 const )901786816U, (u32 const )926953472U, (u32 const )746597696U, (u32 const )805320000U,
        (u32 const )763377600U, (u32 const )885009472U, (u32 const )943730688U, (u32 const )734014976U,
        (u32 const )805319744U, (u32 const )773863616U, (u32 const )872426368U, (u32 const )964702208U,
        (u32 const )725626432U, (u32 const )805319552U, (u32 const )778058240U, (u32 const )859843328U,
        (u32 const )981479488U, (u32 const )713043616U, (u32 const )809513728U, (u32 const )784350016U,
        (u32 const )847260224U, (u32 const )1006645312U, (u32 const )704655040U, (u32 const )813707840U,
        (u32 const )784350336U, (u32 const )838871488U, (u32 const )1027616896U, (u32 const )692072192U,
        (u32 const )813707712U, (u32 const )790642112U, (u32 const )830482688U, (u32 const )1048588480U,
        (u32 const )679489344U, (u32 const )817901888U, (u32 const )790642496U, (u32 const )826288192U,
        (u32 const )671101184U, (u32 const )671100672U, (u32 const )12544U, (u32 const )910176256U,
        (u32 const )754986176U, (u32 const )805320256U, (u32 const )754988736U, (u32 const )901786816U,
        (u32 const )926953472U, (u32 const )746597696U, (u32 const )805320000U, (u32 const )763377600U,
        (u32 const )885009472U, (u32 const )943730688U, (u32 const )734014976U, (u32 const )805319744U,
        (u32 const )773863616U, (u32 const )872426368U, (u32 const )964702208U, (u32 const )725626432U,
        (u32 const )805319552U, (u32 const )778058240U, (u32 const )859843328U, (u32 const )981479488U,
        (u32 const )713043616U, (u32 const )809513728U, (u32 const )784350016U, (u32 const )847260224U,
        (u32 const )1006645312U, (u32 const )704655040U, (u32 const )813707840U, (u32 const )784350336U,
        (u32 const )838871488U, (u32 const )1027616896U, (u32 const )692072192U, (u32 const )813707712U,
        (u32 const )790642112U, (u32 const )830482688U, (u32 const )1048588480U, (u32 const )679489344U,
        (u32 const )817901888U, (u32 const )790642496U, (u32 const )826288192U, (u32 const )671101184U,
        (u32 const )671100672U, (u32 const )12544U};
static struct color_conversion const ntsc_m_csc_composite =
     {(u16 )818U, (u16 )301U, (u16 )2003U, (u16 )260U, (u16 )1843U, (u16 )1325U, (u16 )1479U,
    (u16 )512U, (u16 )832U, (u16 )780U, (u16 )1744U, (u16 )512U};
static struct video_levels const ntsc_m_levels_composite = {225, 267, 113};
static struct color_conversion const ntsc_m_csc_svideo =
     {(u16 )818U, (u16 )301U, (u16 )2003U, (u16 )307U, (u16 )1898U, (u16 )1380U, (u16 )781U,
    (u16 )512U, (u16 )890U, (u16 )829U, (u16 )1782U, (u16 )512U};
static struct video_levels const ntsc_m_levels_svideo = {266, 316, 133};
static struct color_conversion const ntsc_j_csc_composite =
     {(u16 )818U, (u16 )301U, (u16 )2003U, (u16 )281U, (u16 )1868U, (u16 )1350U, (u16 )1516U,
    (u16 )512U, (u16 )858U, (u16 )802U, (u16 )1761U, (u16 )512U};
static struct video_levels const ntsc_j_levels_composite = {225, 225, 113};
static struct color_conversion const ntsc_j_csc_svideo =
     {(u16 )818U, (u16 )301U, (u16 )2003U, (u16 )332U, (u16 )1928U, (u16 )1409U, (u16 )802U,
    (u16 )512U, (u16 )921U, (u16 )854U, (u16 )1802U, (u16 )512U};
static struct video_levels const ntsc_j_levels_svideo = {266, 266, 133};
static struct color_conversion const pal_csc_composite =
     {(u16 )818U, (u16 )301U, (u16 )2003U, (u16 )275U, (u16 )1861U, (u16 )1343U, (u16 )1505U,
    (u16 )512U, (u16 )851U, (u16 )796U, (u16 )1756U, (u16 )512U};
static struct video_levels const pal_levels_composite = {237, 237, 118};
static struct color_conversion const pal_csc_svideo =
     {(u16 )818U, (u16 )301U, (u16 )2003U, (u16 )325U, (u16 )1920U, (u16 )1401U, (u16 )796U,
    (u16 )512U, (u16 )912U, (u16 )847U, (u16 )1797U, (u16 )512U};
static struct video_levels const pal_levels_svideo = {280, 280, 139};
static struct color_conversion const pal_m_csc_composite =
     {(u16 )818U, (u16 )301U, (u16 )2003U, (u16 )260U, (u16 )1843U, (u16 )1325U, (u16 )1479U,
    (u16 )512U, (u16 )832U, (u16 )780U, (u16 )1744U, (u16 )512U};
static struct video_levels const pal_m_levels_composite = {225, 267, 113};
static struct color_conversion const pal_m_csc_svideo =
     {(u16 )818U, (u16 )301U, (u16 )2003U, (u16 )307U, (u16 )1898U, (u16 )1380U, (u16 )781U,
    (u16 )512U, (u16 )890U, (u16 )829U, (u16 )1782U, (u16 )512U};
static struct video_levels const pal_m_levels_svideo = {266, 316, 133};
static struct color_conversion const pal_n_csc_composite =
     {(u16 )818U, (u16 )301U, (u16 )2003U, (u16 )260U, (u16 )1843U, (u16 )1325U, (u16 )1479U,
    (u16 )512U, (u16 )832U, (u16 )780U, (u16 )1744U, (u16 )512U};
static struct video_levels const pal_n_levels_composite = {225, 267, 118};
static struct color_conversion const pal_n_csc_svideo =
     {(u16 )818U, (u16 )301U, (u16 )2003U, (u16 )307U, (u16 )1898U, (u16 )1380U, (u16 )781U,
    (u16 )512U, (u16 )890U, (u16 )829U, (u16 )1782U, (u16 )512U};
static struct video_levels const pal_n_levels_svideo = {266, 316, 139};
static struct color_conversion const sdtv_csc_yprpb =
     {(u16 )818U, (u16 )301U, (u16 )2003U, (u16 )325U, (u16 )1369U, (u16 )851U, (u16 )256U,
    (u16 )512U, (u16 )256U, (u16 )941U, (u16 )1869U, (u16 )512U};
static struct color_conversion const hdtv_csc_yprpb =
     {(u16 )1459U, (u16 )366U, (u16 )1832U, (u16 )325U, (u16 )2005U, (u16 )907U, (u16 )256U,
    (u16 )512U, (u16 )256U, (u16 )977U, (u16 )1724U, (u16 )512U};
static struct video_levels const component_levels = {279, 279, 0};
static struct tv_mode const tv_modes[15U] =
  { {"NTSC-M", 108000, 29970, 786432U, 64, 836, 124, 857, (bool )0, (bool )0, (bool )0,
      6, 7, 6, (bool )1, 0, 1, 18, 20, 21, 240, (bool )1, 72, 34, 9, 240, 10, 240,
      9, 240, 10, 240, 27456, 0, 135, 20800, 0, 16777216U, (bool )0, & ntsc_m_levels_composite,
      & ntsc_m_levels_svideo, & ntsc_m_csc_composite, & ntsc_m_csc_svideo, (u32 const *)(& filter_table),
      0},
        {"NTSC-443", 108000, 29970, 786432U, 64, 836, 124, 857, (bool )0, (bool )0, (bool )0,
      6, 7, 6, (bool )1, 0, 1, 18, 20, 21, 240, (bool )1, 72, 34, 9, 240, 10, 240,
      9, 240, 10, 240, 27456, 525, 168, 4093, 310, 50331648U, (bool )0, & ntsc_m_levels_composite,
      & ntsc_m_levels_svideo, & ntsc_m_csc_composite, & ntsc_m_csc_svideo, (u32 const *)(& filter_table),
      0},
        {"NTSC-J", 108000, 29970, 786432U, 64, 836, 124, 857, (bool )0, (bool )0, (bool )0,
      6, 7, 6, (bool )1, 0, 1, 18, 20, 21, 240, (bool )1, 72, 34, 9, 240, 10, 240,
      9, 240, 10, 240, 27456, 0, 135, 20800, 0, 16777216U, (bool )0, & ntsc_j_levels_composite,
      & ntsc_j_levels_svideo, & ntsc_j_csc_composite, & ntsc_j_csc_svideo, (u32 const *)(& filter_table),
      0},
        {"PAL-M", 108000, 29970, 786432U, 64, 836, 124, 857, (bool )0, (bool )0, (bool )0,
      6, 7, 6, (bool )1, 0, 1, 18, 20, 21, 240, (bool )1, 72, 34, 9, 240, 10, 240,
      9, 240, 10, 240, 27456, 0, 135, 16704, 0, 33554432U, (bool )1, & pal_m_levels_composite,
      & pal_m_levels_svideo, & pal_m_csc_composite, & pal_m_csc_svideo, (u32 const *)(& filter_table),
      0},
        {"PAL-N", 108000, 25000, 786432U, 64, 844, 128, 863, (bool )0, (bool )0, (bool )0,
      6, 7, 6, (bool )1, 0, 1, 18, 24, 25, 286, (bool )1, 73, 34, 8, 285, 8, 286,
      9, 286, 9, 285, 27648, 625, 135, 23578, 134, 33554432U, (bool )1, & pal_n_levels_composite,
      & pal_n_levels_svideo, & pal_n_csc_composite, & pal_n_csc_svideo, (u32 const *)(& filter_table),
      0},
        {"PAL", 108000, 25000, 786432U, 64, 844, 142, 863, (bool )0, (bool )0, (bool )0,
      5, 6, 5, (bool )1, 0, 1, 15, 24, 25, 286, (bool )1, 73, 32, 8, 285, 8, 286,
      9, 286, 9, 285, 27648, 625, 168, 4122, 67, 33554432U, (bool )1, & pal_levels_composite,
      & pal_levels_svideo, & pal_csc_composite, & pal_csc_svideo, (u32 const *)(& filter_table),
      0},
        {"480p@59.94Hz", 107520, 59940, 0U, 64, 842, 122, 857, (bool )1, (bool )0, (bool )1,
      12, 12, 12, (bool )0, 0, 0, 0, 44, 44, 479, (bool )0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0U, (_Bool)0, (struct video_levels const *)0, (struct video_levels const *)0,
      (struct color_conversion const *)0, (struct color_conversion const *)0,
      (u32 const *)(& filter_table), 0},
        {"480p@60Hz", 107520, 60000, 0U, 64, 842, 122, 856, (bool )1, (bool )0, (bool )1,
      12, 12, 12, (bool )0, 0, 0, 0, 44, 44, 479, (bool )0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0U, (_Bool)0, (struct video_levels const *)0, (struct video_levels const *)0,
      (struct color_conversion const *)0, (struct color_conversion const *)0,
      (u32 const *)(& filter_table), 0},
        {"576p", 107520, 50000, 0U, 64, 859, 139, 863, (bool )1, (bool )0, (bool )1,
      10, 10, 10, (bool )0, 0, 0, 0, 48, 48, 575, (bool )0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0U, (_Bool)0, (struct video_levels const *)0, (struct video_levels const *)0,
      (struct color_conversion const *)0, (struct color_conversion const *)0,
      (u32 const *)(& filter_table), 0},
        {"720p@60Hz", 148800, 60000, 262144U, 80, 1580, 300, 1649, (bool )1, (bool )1,
      (bool )1, 10, 10, 10, (bool )0, 0, 0, 0, 29, 29, 719, (bool )0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0U, (_Bool)0, (struct video_levels const *)0,
      (struct video_levels const *)0, (struct color_conversion const *)0, (struct color_conversion const *)0,
      (u32 const *)(& filter_table), 0},
        {"720p@59.94Hz", 148800, 59940, 262144U, 80, 1580, 300, 1651, (bool )1, (bool )1,
      (bool )1, 10, 10, 10, (bool )0, 0, 0, 0, 29, 29, 719, (bool )0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0U, (_Bool)0, (struct video_levels const *)0,
      (struct video_levels const *)0, (struct color_conversion const *)0, (struct color_conversion const *)0,
      (u32 const *)(& filter_table), 0},
        {"720p@50Hz", 148800, 50000, 262144U, 80, 1580, 300, 1979, (bool )1, (bool )1,
      (bool )1, 10, 10, 10, (bool )0, 0, 0, 0, 29, 29, 719, (bool )0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0U, (_Bool)0, (struct video_levels const *)0,
      (struct video_levels const *)0, (struct color_conversion const *)0, (struct color_conversion const *)0,
      (u32 const *)(& filter_table), 800},
        {"1080i@50Hz", 148800, 25000, 262144U, 88, 2155, 235, 2639, (bool )0, (bool )1,
      (bool )1, 4, 5, 10, (bool )1, 4, 4, 10, 21, 22, 539, (bool )0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0U, (_Bool)0, (struct video_levels const *)0,
      (struct video_levels const *)0, (struct color_conversion const *)0, (struct color_conversion const *)0,
      (u32 const *)(& filter_table), 0},
        {"1080i@60Hz", 148800, 30000, 262144U, 88, 2155, 235, 2199, (bool )0, (bool )1,
      (bool )1, 4, 5, 10, (bool )1, 4, 4, 10, 21, 22, 539, (bool )0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0U, (_Bool)0, (struct video_levels const *)0,
      (struct video_levels const *)0, (struct color_conversion const *)0, (struct color_conversion const *)0,
      (u32 const *)(& filter_table), 0},
        {"1080i@59.94Hz", 148800, 29970, 262144U, 88, 2155, 235, 2201, (bool )0, (bool )1,
      (bool )1, 4, 5, 10, (bool )1, 4, 4, 10, 21, 22, 539, (bool )0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0U, (_Bool)0, (struct video_levels const *)0,
      (struct video_levels const *)0, (struct color_conversion const *)0, (struct color_conversion const *)0,
      (u32 const *)(& filter_table), 0}};
static struct intel_tv *enc_to_intel_tv(struct drm_encoder *encoder )
{ struct drm_encoder const *__mptr ;
  {
  __mptr = (struct drm_encoder const *)encoder;
  return ((struct intel_tv *)__mptr);
}
}
static struct intel_tv *intel_attached_tv(struct drm_connector *connector )
{ struct intel_encoder const *__mptr ;
  struct intel_encoder *tmp ;
  {
  {
  tmp = intel_attached_encoder(connector);
  __mptr = (struct intel_encoder const *)tmp;
  }
  return ((struct intel_tv *)__mptr);
}
}
static void intel_tv_dpms(struct drm_encoder *encoder , int mode )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  u32 tmp ;
  u32 tmp___0 ;
  {
  dev = encoder->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if (mode == 0) {
    goto case_0;
  } else
  if (mode == 1) {
    goto case_1;
  } else
  if (mode == 2) {
    goto case_2;
  } else
  if (mode == 3) {
    goto case_3;
  } else
  if (0) {
    case_0:
    {
    tmp = i915_read32___11(dev_priv, 425984U);
    i915_write32___9(dev_priv, 425984U, tmp | 2147483648U);
    }
    goto ldv_37792;
    case_1: ;
    case_2: ;
    case_3:
    {
    tmp___0 = i915_read32___11(dev_priv, 425984U);
    i915_write32___9(dev_priv, 425984U, tmp___0 & 2147483647U);
    }
    goto ldv_37792;
  } else {
  }
  ldv_37792: ;
  return;
}
}
static struct tv_mode const *intel_tv_mode_lookup(char const *tv_format )
{ int i ;
  struct tv_mode const *tv_mode ;
  int tmp ;
  {
  i = 0;
  goto ldv_37802;
  ldv_37801:
  {
  tv_mode = (struct tv_mode const *)(& tv_modes) + (unsigned long )i;
  tmp = strcmp(tv_format, (char const *)tv_mode->name);
  }
  if (tmp == 0) {
    return (tv_mode);
  } else {
  }
  i = i + 1;
  ldv_37802: ;
  if ((unsigned int )i <= 14U) {
    goto ldv_37801;
  } else {
    goto ldv_37803;
  }
  ldv_37803: ;
  return ((struct tv_mode const *)0);
}
}
static struct tv_mode const *intel_tv_mode_find(struct intel_tv *intel_tv )
{ struct tv_mode const *tmp ;
  {
  {
  tmp = intel_tv_mode_lookup(intel_tv->tv_format);
  }
  return (tmp);
}
}
static enum drm_mode_status intel_tv_mode_valid(struct drm_connector *connector ,
                                                struct drm_display_mode *mode )
{ struct intel_tv *intel_tv ;
  struct intel_tv *tmp ;
  struct tv_mode const *tv_mode ;
  struct tv_mode const *tmp___0 ;
  long ret ;
  int __x___0 ;
  int tmp___2 ;
  int tmp___3 ;
  {
  {
  tmp = intel_attached_tv(connector);
  intel_tv = tmp;
  tmp___0 = intel_tv_mode_find(intel_tv);
  tv_mode = tmp___0;
  }
  if ((unsigned long )tv_mode != (unsigned long )((struct tv_mode const *)0)) {
    {
    tmp___2 = drm_mode_vrefresh((struct drm_display_mode const *)mode);
    __x___0 = (int )tv_mode->refresh + tmp___2 * -1000;
    }
    if (__x___0 < 0) {
      tmp___3 = - __x___0;
    } else {
      tmp___3 = __x___0;
    }
    ret = (long )tmp___3;
    if (ret <= 999L) {
      return ((enum drm_mode_status )0);
    } else {
    }
  } else {
  }
  return ((enum drm_mode_status )17);
}
}
static bool intel_tv_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                struct drm_display_mode *adjusted_mode )
{ struct drm_device *dev ;
  struct drm_mode_config *drm_config ;
  struct intel_tv *intel_tv ;
  struct intel_tv *tmp ;
  struct tv_mode const *tv_mode ;
  struct tv_mode const *tmp___0 ;
  struct drm_encoder *other_encoder ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  {
  {
  dev = encoder->dev;
  drm_config = & dev->mode_config;
  tmp = enc_to_intel_tv(encoder);
  intel_tv = tmp;
  tmp___0 = intel_tv_mode_find(intel_tv);
  tv_mode = tmp___0;
  }
  if ((unsigned long )tv_mode == (unsigned long )((struct tv_mode const *)0)) {
    return ((bool )0);
  } else {
  }
  __mptr = (struct list_head const *)drm_config->encoder_list.next;
  other_encoder = (struct drm_encoder *)__mptr + 0x0ffffffffffffff8UL;
  goto ldv_37832;
  ldv_37831: ;
  if ((unsigned long )other_encoder != (unsigned long )encoder) {
    if ((unsigned long )other_encoder->crtc == (unsigned long )encoder->crtc) {
      return ((bool )0);
    } else {
    }
  } else {
  }
  __mptr___0 = (struct list_head const *)other_encoder->head.next;
  other_encoder = (struct drm_encoder *)__mptr___0 + 0x0ffffffffffffff8UL;
  ldv_37832: ;
  if ((unsigned long )(& other_encoder->head) != (unsigned long )(& drm_config->encoder_list)) {
    goto ldv_37831;
  } else {
    goto ldv_37833;
  }
  ldv_37833:
  adjusted_mode->clock = (int )tv_mode->clock;
  return ((bool )1);
}
}
static void intel_tv_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                              struct drm_display_mode *adjusted_mode )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct drm_crtc *crtc ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  struct intel_tv *intel_tv ;
  struct intel_tv *tmp ;
  struct tv_mode const *tv_mode ;
  struct tv_mode const *tmp___0 ;
  u32 tv_ctl ;
  u32 hctl1 ;
  u32 hctl2 ;
  u32 hctl3 ;
  u32 vctl1 ;
  u32 vctl2 ;
  u32 vctl3 ;
  u32 vctl4 ;
  u32 vctl5 ;
  u32 vctl6 ;
  u32 vctl7 ;
  u32 scctl1 ;
  u32 scctl2 ;
  u32 scctl3 ;
  int i ;
  int j ;
  struct video_levels const *video_levels ;
  struct color_conversion const *color_conversion ;
  bool burst_ena ;
  int pipe ;
  int pipeconf_reg ;
  int dspcntr_reg ;
  int pipeconf ;
  u32 tmp___1 ;
  int dspcntr ;
  u32 tmp___2 ;
  int dspbase_reg ;
  int xpos ;
  int ypos ;
  unsigned int xsize ;
  unsigned int ysize ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  u32 tmp___9 ;
  {
  {
  dev = encoder->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  crtc = encoder->crtc;
  __mptr = (struct drm_crtc const *)crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  tmp = enc_to_intel_tv(encoder);
  intel_tv = tmp;
  tmp___0 = intel_tv_mode_find(intel_tv);
  tv_mode = tmp___0;
  pipe = (int )intel_crtc->pipe;
  }
  if ((unsigned long )tv_mode == (unsigned long )((struct tv_mode const *)0)) {
    return;
  } else {
  }
  {
  tv_ctl = i915_read32___11(dev_priv, 425984U);
  tv_ctl = tv_ctl & 4047U;
  }
  if (intel_tv->type == 0) {
    goto case_0;
  } else
  if (intel_tv->type == 5) {
    goto case_5;
  } else
  if (intel_tv->type == 8) {
    goto case_8;
  } else
  if (intel_tv->type == 6) {
    goto case_6;
  } else {
    goto switch_default;
    if (0) {
      switch_default: ;
      case_0: ;
      case_5:
      tv_ctl = tv_ctl;
      video_levels = (struct video_levels const *)tv_mode->composite_levels;
      color_conversion = (struct color_conversion const *)tv_mode->composite_color;
      burst_ena = (bool )tv_mode->burst_ena;
      goto ldv_37870;
      case_8:
      tv_ctl = tv_ctl | 536870912U;
      video_levels = & component_levels;
      if ((int )tv_mode->burst_ena) {
        color_conversion = & sdtv_csc_yprpb;
      } else {
        color_conversion = & hdtv_csc_yprpb;
      }
      burst_ena = (bool )0;
      goto ldv_37870;
      case_6:
      tv_ctl = tv_ctl | 268435456U;
      video_levels = (struct video_levels const *)tv_mode->svideo_levels;
      color_conversion = (struct color_conversion const *)tv_mode->svideo_color;
      burst_ena = (bool )tv_mode->burst_ena;
      goto ldv_37870;
    } else {
    }
  }
  ldv_37870:
  hctl1 = (u32 )((int )(tv_mode->hsync_end << 16) | (int )tv_mode->htotal);
  hctl2 = (u32 )((int )(tv_mode->hburst_start << 16) | (int )tv_mode->hburst_len);
  if ((int )burst_ena) {
    hctl2 = hctl2 | 2147483648U;
  } else {
  }
  hctl3 = (u32 )((int )tv_mode->hblank_start | (int )(tv_mode->hblank_end << 16));
  vctl1 = (u32 )(((int )(tv_mode->nbr_end << 16) | (int )(tv_mode->vi_end_f1 << 8)) | (int )tv_mode->vi_end_f2);
  vctl2 = (u32 )(((int )(tv_mode->vsync_len << 16) | (int )(tv_mode->vsync_start_f1 << 8)) | (int )tv_mode->vsync_start_f2);
  vctl3 = (u32 )(((int )(tv_mode->veq_len << 16) | (int )(tv_mode->veq_start_f1 << 8)) | (int )tv_mode->veq_start_f2);
  if ((int )tv_mode->veq_ena) {
    vctl3 = vctl3 | 2147483648U;
  } else {
  }
  vctl4 = (u32 )((int )(tv_mode->vburst_start_f1 << 16) | (int )tv_mode->vburst_end_f1);
  vctl5 = (u32 )((int )(tv_mode->vburst_start_f2 << 16) | (int )tv_mode->vburst_end_f2);
  vctl6 = (u32 )((int )(tv_mode->vburst_start_f3 << 16) | (int )tv_mode->vburst_end_f3);
  vctl7 = (u32 )((int )(tv_mode->vburst_start_f4 << 16) | (int )tv_mode->vburst_end_f4);
  if ((unsigned int )intel_crtc->pipe == 1U) {
    tv_ctl = tv_ctl | 1073741824U;
  } else {
  }
  tv_ctl = (u32 )tv_mode->oversample | tv_ctl;
  if ((int )tv_mode->progressive) {
    tv_ctl = tv_ctl | 131072U;
  } else {
  }
  if ((int )tv_mode->trilevel_sync) {
    tv_ctl = tv_ctl | 2097152U;
  } else {
  }
  if ((int )tv_mode->pal_burst) {
    tv_ctl = tv_ctl | 65536U;
  } else {
  }
  scctl1 = 0U;
  if ((int )tv_mode->dda1_inc != 0) {
    scctl1 = scctl1 | 2147483648U;
  } else {
  }
  if ((int )tv_mode->dda2_inc != 0) {
    scctl1 = scctl1 | 1073741824U;
  } else {
  }
  if ((int )tv_mode->dda3_inc != 0) {
    scctl1 = scctl1 | 536870912U;
  } else {
  }
  scctl1 = (u32 )tv_mode->sc_reset | scctl1;
  if ((unsigned long )video_levels != (unsigned long )((struct video_levels const *)0)) {
    scctl1 = (u32 )(video_levels->burst << 16) | scctl1;
  } else {
  }
  scctl1 = (u32 )tv_mode->dda1_inc | scctl1;
  scctl2 = (u32 )((int )(tv_mode->dda2_size << 16) | (int )tv_mode->dda2_inc);
  scctl3 = (u32 )((int )(tv_mode->dda3_size << 16) | (int )tv_mode->dda3_inc);
  if (dev->pci_device <= 10097) {
    tv_ctl = tv_ctl | 3072U;
  } else {
  }
  {
  i915_write32___9(dev_priv, 426032U, hctl1);
  i915_write32___9(dev_priv, 426036U, hctl2);
  i915_write32___9(dev_priv, 426040U, hctl3);
  i915_write32___9(dev_priv, 426044U, vctl1);
  i915_write32___9(dev_priv, 426048U, vctl2);
  i915_write32___9(dev_priv, 426052U, vctl3);
  i915_write32___9(dev_priv, 426056U, vctl4);
  i915_write32___9(dev_priv, 426060U, vctl5);
  i915_write32___9(dev_priv, 426064U, vctl6);
  i915_write32___9(dev_priv, 426068U, vctl7);
  i915_write32___9(dev_priv, 426080U, scctl1);
  i915_write32___9(dev_priv, 426084U, scctl2);
  i915_write32___9(dev_priv, 426088U, scctl3);
  }
  if ((unsigned long )color_conversion != (unsigned long )((struct color_conversion const *)0)) {
    {
    i915_write32___9(dev_priv, 426000U, (u32 )(((int )color_conversion->ry << 16) | (int )color_conversion->gy));
    i915_write32___9(dev_priv, 426004U, (u32 )(((int )color_conversion->by << 16) | (int )color_conversion->ay));
    i915_write32___9(dev_priv, 426008U, (u32 )(((int )color_conversion->ru << 16) | (int )color_conversion->gu));
    i915_write32___9(dev_priv, 426012U, (u32 )(((int )color_conversion->bu << 16) | (int )color_conversion->au));
    i915_write32___9(dev_priv, 426016U, (u32 )(((int )color_conversion->rv << 16) | (int )color_conversion->gv));
    i915_write32___9(dev_priv, 426020U, (u32 )(((int )color_conversion->bv << 16) | (int )color_conversion->av));
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    {
    i915_write32___9(dev_priv, 426024U, 4210688U);
    }
  } else {
    {
    i915_write32___9(dev_priv, 426024U, 6316032U);
    }
  }
  if ((unsigned long )video_levels != (unsigned long )((struct video_levels const *)0)) {
    {
    i915_write32___9(dev_priv, 426028U, (u32 )((int )(video_levels->black << 16) | (int )video_levels->blank));
    }
  } else {
  }
  {
  pipeconf_reg = pipe * 4096 + 458760;
  dspcntr_reg = (int )((unsigned int )intel_crtc->plane * 4096U + 459136U);
  tmp___1 = i915_read32___11(dev_priv, (u32 )pipeconf_reg);
  pipeconf = (int )tmp___1;
  tmp___2 = i915_read32___11(dev_priv, (u32 )dspcntr_reg);
  dspcntr = (int )tmp___2;
  dspbase_reg = (int )((unsigned int )intel_crtc->plane * 4096U + 459140U);
  xpos = 0;
  ypos = 0;
  i915_write32___9(dev_priv, (u32 )dspcntr_reg, (u32 )dspcntr & 2147483647U);
  tmp___3 = i915_read32___11(dev_priv, (u32 )dspbase_reg);
  i915_write32___9(dev_priv, (u32 )dspbase_reg, tmp___3);
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 2U) {
    {
    intel_wait_for_vblank(dev, (int )intel_crtc->pipe);
    }
  } else {
  }
  {
  i915_write32___9(dev_priv, (u32 )pipeconf_reg, (u32 )pipeconf & 2147483647U);
  intel_wait_for_pipe_off(dev, (int )intel_crtc->pipe);
  i915_write32___9(dev_priv, 426112U, 2147483648U);
  xsize = (unsigned int )((int )tv_mode->hblank_start - (int )tv_mode->hblank_end);
  }
  if ((int )tv_mode->progressive) {
    ysize = (unsigned int )((int )tv_mode->nbr_end + 1);
  } else {
    ysize = (unsigned int )((int )tv_mode->nbr_end * 2 + 1);
  }
  {
  xpos = intel_tv->margin[0] + xpos;
  ypos = intel_tv->margin[1] + ypos;
  xsize = xsize - (unsigned int )(intel_tv->margin[0] + intel_tv->margin[2]);
  ysize = ysize - (unsigned int )(intel_tv->margin[1] + intel_tv->margin[3]);
  i915_write32___9(dev_priv, 426096U, (u32 )((xpos << 16) | ypos));
  i915_write32___9(dev_priv, 426100U, (xsize << 16) | ysize);
  i915_write32___9(dev_priv, (u32 )pipeconf_reg, (u32 )pipeconf);
  i915_write32___9(dev_priv, (u32 )dspcntr_reg, (u32 )dspcntr);
  tmp___4 = i915_read32___11(dev_priv, (u32 )dspbase_reg);
  i915_write32___9(dev_priv, (u32 )dspbase_reg, tmp___4);
  j = 0;
  i = 0;
  }
  goto ldv_37883;
  ldv_37882:
  {
  tmp___5 = j;
  j = j + 1;
  i915_write32___9(dev_priv, (u32 )((i << 2) + 426240), (u32 )*(tv_mode->filter_table + (unsigned long )tmp___5));
  i = i + 1;
  }
  ldv_37883: ;
  if (i <= 59) {
    goto ldv_37882;
  } else {
    goto ldv_37884;
  }
  ldv_37884:
  i = 0;
  goto ldv_37886;
  ldv_37885:
  {
  tmp___6 = j;
  j = j + 1;
  i915_write32___9(dev_priv, (u32 )((i << 2) + 426496), (u32 )*(tv_mode->filter_table + (unsigned long )tmp___6));
  i = i + 1;
  }
  ldv_37886: ;
  if (i <= 59) {
    goto ldv_37885;
  } else {
    goto ldv_37887;
  }
  ldv_37887:
  i = 0;
  goto ldv_37889;
  ldv_37888:
  {
  tmp___7 = j;
  j = j + 1;
  i915_write32___9(dev_priv, (u32 )((i << 2) + 426752), (u32 )*(tv_mode->filter_table + (unsigned long )tmp___7));
  i = i + 1;
  }
  ldv_37889: ;
  if (i <= 42) {
    goto ldv_37888;
  } else {
    goto ldv_37890;
  }
  ldv_37890:
  i = 0;
  goto ldv_37892;
  ldv_37891:
  {
  tmp___8 = j;
  j = j + 1;
  i915_write32___9(dev_priv, (u32 )((i << 2) + 427008), (u32 )*(tv_mode->filter_table + (unsigned long )tmp___8));
  i = i + 1;
  }
  ldv_37892: ;
  if (i <= 42) {
    goto ldv_37891;
  } else {
    goto ldv_37893;
  }
  ldv_37893:
  {
  tmp___9 = i915_read32___11(dev_priv, 425988U);
  i915_write32___9(dev_priv, 425988U, tmp___9 & 16776960U);
  i915_write32___9(dev_priv, 425984U, tv_ctl);
  }
  return;
}
}
static struct drm_display_mode const reported_modes[1U] = { {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'N', (char )'T',
                                                                 (char )'S', (char )'C',
                                                                 (char )' ', (char )'4',
                                                                 (char )'8', (char )'0',
                                                                 (char )'i', (char )'\000'},
      0, (enum drm_mode_status )0, 64, 107520, 1280, 1368, 1496, 1712, 0, 1024, 1027,
      1034, 1104, 0, 0U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, (int *)0, 0, 0, 0}};
static int intel_tv_detect_type(struct intel_tv *intel_tv , struct drm_connector *connector )
{ struct drm_encoder *encoder ;
  struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  unsigned long irqflags ;
  u32 tv_ctl ;
  u32 save_tv_ctl ;
  u32 tv_dac ;
  u32 save_tv_dac ;
  int type ;
  raw_spinlock_t *tmp ;
  struct drm_crtc const *__mptr ;
  unsigned long timeout__ ;
  unsigned long tmp___0 ;
  int ret__ ;
  struct thread_info *tmp___1 ;
  int pfo_ret__ ;
  int tmp___2 ;
  raw_spinlock_t *tmp___3 ;
  {
  encoder = & intel_tv->base.base;
  dev = encoder->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((int )connector->polled & 1) {
    {
    tmp = spinlock_check(& dev_priv->irq_lock);
    irqflags = _raw_spin_lock_irqsave(tmp);
    i915_disable_pipestat(dev_priv, 0, 67371008U);
    spin_unlock_irqrestore(& dev_priv->irq_lock, irqflags);
    }
  } else {
  }
  {
  tv_dac = i915_read32___11(dev_priv, 425988U);
  save_tv_dac = tv_dac;
  tv_ctl = i915_read32___11(dev_priv, 425984U);
  save_tv_ctl = tv_ctl;
  tv_ctl = tv_ctl & 2147483640U;
  tv_ctl = tv_ctl | 7U;
  tv_dac = tv_dac & 2415919040U;
  tv_dac = tv_dac | 251658410U;
  i915_write32___9(dev_priv, 425984U, tv_ctl);
  i915_write32___9(dev_priv, 425988U, tv_dac);
  readl((void const volatile *)dev_priv->regs + 425988U);
  __mptr = (struct drm_crtc const *)intel_tv->base.base.crtc;
  intel_wait_for_vblank(intel_tv->base.base.dev, (int )((struct intel_crtc *)__mptr)->pipe);
  type = -1;
  tmp___0 = msecs_to_jiffies((unsigned int const )20U);
  timeout__ = tmp___0 + (unsigned long )jiffies;
  ret__ = 0;
  }
  goto ldv_37931;
  ldv_37930: ;
  if ((long )timeout__ - (long )jiffies < 0L) {
    ret__ = -110;
    goto ldv_37921;
  } else {
  }
  {
  tmp___1 = current_thread_info();
  }
  if ((tmp___1->preempt_count & -268435457) == 0) {
    if (1) {
      goto case_4;
    } else {
      goto switch_default;
      if (0) {
        __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
        goto ldv_37924;
        __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_37924;
        case_4:
        __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_37924;
        __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_37924;
        switch_default:
        {
        __bad_percpu_size();
        }
      } else {
      }
    }
    ldv_37924:
    {
    tmp___2 = atomic_read((atomic_t const *)(& kgdb_active));
    }
    if (pfo_ret__ != tmp___2) {
      {
      msleep(1U);
      }
    } else {
    }
  } else {
  }
  ldv_37931:
  {
  tv_dac = i915_read32___11(dev_priv, 425988U);
  }
  if ((int )tv_dac >= 0) {
    goto ldv_37930;
  } else {
    goto ldv_37921;
  }
  ldv_37921: ;
  if (ret__ == 0) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_tv_detect_type", "TV detected: %x, %x\n",
                        tv_ctl, tv_dac);
    }
    if ((tv_dac & 1879048192U) == 805306368U) {
      {
      drm_ut_debug_printk(4U, "drm", "intel_tv_detect_type", "Detected Composite TV connection\n");
      type = 5;
      }
    } else
    if ((tv_dac & 1610612736U) == 1073741824U) {
      {
      drm_ut_debug_printk(4U, "drm", "intel_tv_detect_type", "Detected S-Video TV connection\n");
      type = 6;
      }
    } else
    if ((tv_dac & 1879048192U) == 0U) {
      {
      drm_ut_debug_printk(4U, "drm", "intel_tv_detect_type", "Detected Component TV connection\n");
      type = 8;
      }
    } else {
      {
      drm_ut_debug_printk(4U, "drm", "intel_tv_detect_type", "Unrecognised TV connection\n");
      }
    }
  } else {
  }
  {
  i915_write32___9(dev_priv, 425988U, save_tv_dac & 4160749567U);
  i915_write32___9(dev_priv, 425984U, save_tv_ctl);
  }
  if ((int )connector->polled & 1) {
    {
    tmp___3 = spinlock_check(& dev_priv->irq_lock);
    irqflags = _raw_spin_lock_irqsave(tmp___3);
    i915_enable_pipestat(dev_priv, 0, 67371008U);
    spin_unlock_irqrestore(& dev_priv->irq_lock, irqflags);
    }
  } else {
  }
  return (type);
}
}
static void intel_tv_find_better_format(struct drm_connector *connector )
{ struct intel_tv *intel_tv ;
  struct intel_tv *tmp ;
  struct tv_mode const *tv_mode ;
  struct tv_mode const *tmp___0 ;
  int i ;
  {
  {
  tmp = intel_attached_tv(connector);
  intel_tv = tmp;
  tmp___0 = intel_tv_mode_find(intel_tv);
  tv_mode = tmp___0;
  }
  if ((intel_tv->type == 8) == (int )tv_mode->component_only) {
    return;
  } else {
  }
  i = 0;
  goto ldv_37945;
  ldv_37944:
  tv_mode = (struct tv_mode const *)(& tv_modes) + (unsigned long )i;
  if ((intel_tv->type == 8) == (int )tv_mode->component_only) {
    goto ldv_37943;
  } else {
  }
  i = i + 1;
  ldv_37945: ;
  if ((unsigned int )i <= 14U) {
    goto ldv_37944;
  } else {
    goto ldv_37943;
  }
  ldv_37943:
  {
  intel_tv->tv_format = (char const *)tv_mode->name;
  drm_connector_property_set_value(connector, (connector->dev)->mode_config.tv_mode_property,
                                   (uint64_t )i);
  }
  return;
}
}
static enum drm_connector_status intel_tv_detect(struct drm_connector *connector ,
                                                 bool force )
{ struct drm_display_mode mode ;
  struct intel_tv *intel_tv ;
  struct intel_tv *tmp ;
  int type ;
  struct intel_load_detect_pipe tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp = intel_attached_tv(connector);
  intel_tv = tmp;
  mode = (struct drm_display_mode )reported_modes[0];
  drm_mode_set_crtcinfo(& mode, 1);
  }
  if ((unsigned long )intel_tv->base.base.crtc != (unsigned long )((struct drm_crtc *)0)) {
    if ((int )(intel_tv->base.base.crtc)->enabled) {
      {
      type = intel_tv_detect_type(intel_tv, connector);
      }
    } else {
      goto _L;
    }
  } else
  _L:
  if ((int )force) {
    {
    tmp___1 = intel_get_load_detect_pipe(& intel_tv->base, connector, & mode, & tmp___0);
    }
    if ((int )tmp___1) {
      {
      type = intel_tv_detect_type(intel_tv, connector);
      intel_release_load_detect_pipe(& intel_tv->base, connector, & tmp___0);
      }
    } else {
      return ((enum drm_connector_status )3);
    }
  } else {
    return (connector->status);
  }
  if (type < 0) {
    return ((enum drm_connector_status )2);
  } else {
  }
  {
  intel_tv->type = type;
  intel_tv_find_better_format(connector);
  }
  return ((enum drm_connector_status )1);
}
}
static struct input_res const input_res_table[7U] = { {"640x480", 640, 480},
        {"800x600", 800, 600},
        {"1024x768", 1024, 768},
        {"1280x1024", 1280, 1024},
        {"848x480", 848, 480},
        {"1280x720", 1280, 720},
        {"1920x1080", 1920, 1080}};
static void intel_tv_chose_preferred_modes(struct drm_connector *connector , struct drm_display_mode *mode_ptr )
{ struct intel_tv *intel_tv ;
  struct intel_tv *tmp ;
  struct tv_mode const *tv_mode ;
  struct tv_mode const *tmp___0 ;
  {
  {
  tmp = intel_attached_tv(connector);
  intel_tv = tmp;
  tmp___0 = intel_tv_mode_find(intel_tv);
  tv_mode = tmp___0;
  }
  if ((int )tv_mode->nbr_end <= 479) {
    if (mode_ptr->vdisplay == 480) {
      mode_ptr->type = mode_ptr->type | 8;
    } else {
      goto _L;
    }
  } else
  _L:
  if ((int )tv_mode->nbr_end > 480) {
    if ((int )tv_mode->progressive) {
      if ((int )tv_mode->nbr_end <= 719) {
        if (mode_ptr->vdisplay == 720) {
          mode_ptr->type = mode_ptr->type | 8;
        } else
        if (mode_ptr->vdisplay == 1080) {
          mode_ptr->type = mode_ptr->type | 8;
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  return;
}
}
static int intel_tv_get_modes(struct drm_connector *connector )
{ struct drm_display_mode *mode_ptr ;
  struct intel_tv *intel_tv ;
  struct intel_tv *tmp ;
  struct tv_mode const *tv_mode ;
  struct tv_mode const *tmp___0 ;
  int j ;
  int count ;
  u64 tmp___1 ;
  struct input_res const *input ;
  unsigned int hactive_s ;
  unsigned int vactive_s ;
  {
  {
  tmp = intel_attached_tv(connector);
  intel_tv = tmp;
  tmp___0 = intel_tv_mode_find(intel_tv);
  tv_mode = tmp___0;
  count = 0;
  j = 0;
  }
  goto ldv_37981;
  ldv_37980:
  input = (struct input_res const *)(& input_res_table) + (unsigned long )j;
  hactive_s = (unsigned int )input->w;
  vactive_s = (unsigned int )input->h;
  if ((int )tv_mode->max_srcw != 0) {
    if ((int )input->w > (int )tv_mode->max_srcw) {
      goto ldv_37979;
    } else {
    }
  } else {
  }
  if ((int )input->w > 1024) {
    if (! ((_Bool )tv_mode->progressive)) {
      if (! ((_Bool )tv_mode->component_only)) {
        goto ldv_37979;
      } else {
      }
    } else {
    }
  } else {
  }
  {
  mode_ptr = drm_mode_create(connector->dev);
  }
  if ((unsigned long )mode_ptr == (unsigned long )((struct drm_display_mode *)0)) {
    goto ldv_37979;
  } else {
  }
  {
  strncpy((char *)(& mode_ptr->name), (char const *)input->name, 32UL);
  mode_ptr->hdisplay = (int )hactive_s;
  mode_ptr->hsync_start = (int )(hactive_s + 1U);
  mode_ptr->hsync_end = (int )(hactive_s + 64U);
  }
  if (mode_ptr->hsync_end <= mode_ptr->hsync_start) {
    mode_ptr->hsync_end = mode_ptr->hsync_start + 1;
  } else {
  }
  mode_ptr->htotal = (int )(hactive_s + 96U);
  mode_ptr->vdisplay = (int )vactive_s;
  mode_ptr->vsync_start = (int )(vactive_s + 1U);
  mode_ptr->vsync_end = (int )(vactive_s + 32U);
  if (mode_ptr->vsync_end <= mode_ptr->vsync_start) {
    mode_ptr->vsync_end = mode_ptr->vsync_start + 1;
  } else {
  }
  {
  mode_ptr->vtotal = (int )(vactive_s + 33U);
  tmp___1 = (unsigned long long )tv_mode->refresh * (unsigned long long )mode_ptr->vtotal;
  tmp___1 = (u64 )mode_ptr->htotal * tmp___1;
  tmp___1 = div_u64(tmp___1, 1000000U);
  mode_ptr->clock = (int )tmp___1;
  mode_ptr->type = 64;
  intel_tv_chose_preferred_modes(connector, mode_ptr);
  drm_mode_probed_add(connector, mode_ptr);
  count = count + 1;
  }
  ldv_37979:
  j = j + 1;
  ldv_37981: ;
  if ((unsigned int )j <= 6U) {
    goto ldv_37980;
  } else {
    goto ldv_37982;
  }
  ldv_37982: ;
  return (count);
}
}
static void intel_tv_destroy(struct drm_connector *connector )
{
  {
  {
  drm_sysfs_connector_remove(connector);
  drm_connector_cleanup(connector);
  kfree((void const *)connector);
  }
  return;
}
}
static int intel_tv_set_property(struct drm_connector *connector , struct drm_property *property ,
                                 uint64_t val )
{ struct drm_device *dev ;
  struct intel_tv *intel_tv ;
  struct intel_tv *tmp ;
  struct drm_crtc *crtc ;
  int ret ;
  bool changed ;
  int tmp___0 ;
  {
  {
  dev = connector->dev;
  tmp = intel_attached_tv(connector);
  intel_tv = tmp;
  crtc = intel_tv->base.base.crtc;
  ret = 0;
  changed = (bool )0;
  ret = drm_connector_property_set_value(connector, property, val);
  }
  if (ret < 0) {
    goto out;
  } else {
  }
  if ((unsigned long )dev->mode_config.tv_left_margin_property == (unsigned long )property) {
    if ((uint64_t )intel_tv->margin[0] != val) {
      intel_tv->margin[0] = (int )val;
      changed = (bool )1;
    } else {
      goto _L___2;
    }
  } else
  _L___2:
  if ((unsigned long )dev->mode_config.tv_right_margin_property == (unsigned long )property) {
    if ((uint64_t )intel_tv->margin[2] != val) {
      intel_tv->margin[2] = (int )val;
      changed = (bool )1;
    } else {
      goto _L___1;
    }
  } else
  _L___1:
  if ((unsigned long )dev->mode_config.tv_top_margin_property == (unsigned long )property) {
    if ((uint64_t )intel_tv->margin[1] != val) {
      intel_tv->margin[1] = (int )val;
      changed = (bool )1;
    } else {
      goto _L___0;
    }
  } else
  _L___0:
  if ((unsigned long )dev->mode_config.tv_bottom_margin_property == (unsigned long )property) {
    if ((uint64_t )intel_tv->margin[3] != val) {
      intel_tv->margin[3] = (int )val;
      changed = (bool )1;
    } else {
      goto _L;
    }
  } else
  _L:
  if ((unsigned long )dev->mode_config.tv_mode_property == (unsigned long )property) {
    if (val > 14ULL) {
      ret = -22;
      goto out;
    } else {
    }
    {
    tmp___0 = strcmp(intel_tv->tv_format, (char const *)tv_modes[val].name);
    }
    if (tmp___0 == 0) {
      goto out;
    } else {
    }
    intel_tv->tv_format = (char const *)tv_modes[val].name;
    changed = (bool )1;
  } else {
    ret = -22;
    goto out;
  }
  if ((int )changed) {
    if ((unsigned long )crtc != (unsigned long )((struct drm_crtc *)0)) {
      {
      drm_crtc_helper_set_mode(crtc, & crtc->mode, crtc->x, crtc->y, crtc->fb);
      }
    } else {
    }
  } else {
  }
  out: ;
  return (ret);
}
}
static struct drm_encoder_helper_funcs const intel_tv_helper_funcs =
     {& intel_tv_dpms, (void (*)(struct drm_encoder * ))0, (void (*)(struct drm_encoder * ))0,
    & intel_tv_mode_fixup, & intel_encoder_prepare, & intel_encoder_commit, & intel_tv_mode_set,
    (struct drm_crtc *(*)(struct drm_encoder * ))0, (enum drm_connector_status (*)(struct drm_encoder * ,
                                                                                   struct drm_connector * ))0,
    (void (*)(struct drm_encoder * ))0};
static struct drm_connector_funcs const intel_tv_connector_funcs =
     {& drm_helper_connector_dpms, (void (*)(struct drm_connector * ))0, (void (*)(struct drm_connector * ))0,
    (void (*)(struct drm_connector * ))0, & intel_tv_detect, & drm_helper_probe_single_connector_modes,
    & intel_tv_set_property, & intel_tv_destroy, (void (*)(struct drm_connector * ))0};
static struct drm_connector_helper_funcs const intel_tv_connector_helper_funcs = {& intel_tv_get_modes,
    (int (*)(struct drm_connector * , struct drm_display_mode * ))(& intel_tv_mode_valid),
    & intel_best_encoder};
static struct drm_encoder_funcs const intel_tv_enc_funcs = {(void (*)(struct drm_encoder * ))0, & intel_encoder_destroy};
static int tv_is_present_in_vbt(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct child_device_config *p_child ;
  int i ;
  int ret ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if (dev_priv->child_dev_num == 0) {
    return (1);
  } else {
  }
  ret = 0;
  i = 0;
  goto ldv_38013;
  ldv_38012:
  p_child = dev_priv->child_dev + (unsigned long )i;
  if ((unsigned int )p_child->device_type != 4105U) {
    if ((unsigned int )p_child->device_type != 9U) {
      goto ldv_38010;
    } else {
    }
  } else {
  }
  if ((unsigned int )p_child->addin_offset != 0U) {
    ret = 1;
    goto ldv_38011;
  } else {
  }
  ldv_38010:
  i = i + 1;
  ldv_38013: ;
  if (dev_priv->child_dev_num > i) {
    goto ldv_38012;
  } else {
    goto ldv_38011;
  }
  ldv_38011: ;
  return (ret);
}
}
void intel_tv_init(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct drm_connector *connector ;
  struct intel_tv *intel_tv ;
  struct intel_encoder *intel_encoder ;
  struct intel_connector *intel_connector ;
  u32 tv_dac_on ;
  u32 tv_dac_off ;
  u32 save_tv_dac ;
  char *tv_format_names___0[15U] ;
  int i ;
  int initial_mode ;
  u32 tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  initial_mode = 0;
  tmp = i915_read32___11(dev_priv, 425984U);
  }
  if ((tmp & 48U) == 32U) {
    return;
  } else {
  }
  {
  tmp___0 = tv_is_present_in_vbt(dev);
  }
  if (tmp___0 == 0) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_tv_init", "Integrated TV is not present.\n");
    }
    return;
  } else {
  }
  if ((unsigned int )*((unsigned char *)dev_priv + 2072UL) == 0U) {
    return;
  } else {
  }
  {
  save_tv_dac = i915_read32___11(dev_priv, 425988U);
  i915_write32___9(dev_priv, 425988U, save_tv_dac | 134217728U);
  tv_dac_on = i915_read32___11(dev_priv, 425988U);
  i915_write32___9(dev_priv, 425988U, save_tv_dac & 4160749567U);
  tv_dac_off = i915_read32___11(dev_priv, 425988U);
  i915_write32___9(dev_priv, 425988U, save_tv_dac);
  }
  if ((tv_dac_on & 134217728U) == 0U) {
    return;
  } else
  if ((tv_dac_off & 134217728U) != 0U) {
    return;
  } else {
  }
  {
  tmp___1 = kzalloc(1064UL, 208U);
  intel_tv = (struct intel_tv *)tmp___1;
  }
  if ((unsigned long )intel_tv == (unsigned long )((struct intel_tv *)0)) {
    return;
  } else {
  }
  {
  tmp___2 = kzalloc(1576UL, 208U);
  intel_connector = (struct intel_connector *)tmp___2;
  }
  if ((unsigned long )intel_connector == (unsigned long )((struct intel_connector *)0)) {
    {
    kfree((void const *)intel_tv);
    }
    return;
  } else {
  }
  {
  intel_encoder = & intel_tv->base;
  connector = & intel_connector->base;
  connector->polled = (uint8_t )2U;
  drm_connector_init(dev, connector, & intel_tv_connector_funcs, 6);
  drm_encoder_init(dev, & intel_encoder->base, & intel_tv_enc_funcs, 4);
  intel_connector_attach_encoder(intel_connector, intel_encoder);
  intel_encoder->type = 5;
  intel_encoder->crtc_mask = 3;
  intel_encoder->clone_mask = 1024;
  intel_encoder->base.possible_crtcs = 3U;
  intel_encoder->base.possible_clones = 32U;
  intel_tv->type = 0;
  intel_tv->margin[0] = 54;
  intel_tv->margin[1] = 36;
  intel_tv->margin[2] = 46;
  intel_tv->margin[3] = 37;
  intel_tv->tv_format = (char const *)tv_modes[initial_mode].name;
  drm_encoder_helper_add(& intel_encoder->base, & intel_tv_helper_funcs);
  drm_connector_helper_add(connector, & intel_tv_connector_helper_funcs);
  connector->interlace_allowed = (bool )0;
  connector->doublescan_allowed = (bool )0;
  i = 0;
  }
  goto ldv_38034;
  ldv_38033:
  tv_format_names___0[i] = (char *)tv_modes[i].name;
  i = i + 1;
  ldv_38034: ;
  if ((unsigned int )i <= 14U) {
    goto ldv_38033;
  } else {
    goto ldv_38035;
  }
  ldv_38035:
  {
  drm_mode_create_tv_properties(dev, 15, (char **)(& tv_format_names___0));
  drm_connector_attach_property(connector, dev->mode_config.tv_mode_property, (uint64_t )initial_mode);
  drm_connector_attach_property(connector, dev->mode_config.tv_left_margin_property,
                                (uint64_t )intel_tv->margin[0]);
  drm_connector_attach_property(connector, dev->mode_config.tv_top_margin_property,
                                (uint64_t )intel_tv->margin[1]);
  drm_connector_attach_property(connector, dev->mode_config.tv_right_margin_property,
                                (uint64_t )intel_tv->margin[2]);
  drm_connector_attach_property(connector, dev->mode_config.tv_bottom_margin_property,
                                (uint64_t )intel_tv->margin[3]);
  drm_sysfs_connector_add(connector);
  }
  return;
}
}
struct intel_dvo_dev_ops sil164_ops ;
struct intel_dvo_dev_ops ch7xxx_ops ;
struct intel_dvo_dev_ops ivch_ops ;
struct intel_dvo_dev_ops tfp410_ops ;
struct intel_dvo_dev_ops ch7017_ops ;
static struct intel_dvo_device const intel_dvo_devices[5U] = { {"sil164", 2, 397664U, 0U, 56, (struct intel_dvo_dev_ops const *)(& sil164_ops),
      (void *)0, (struct i2c_adapter *)0},
        {"ch7xxx", 2, 397664U, 0U, 118, (struct intel_dvo_dev_ops const *)(& ch7xxx_ops),
      (void *)0, (struct i2c_adapter *)0},
        {"ivch", 1, 397600U, 0U, 2, (struct intel_dvo_dev_ops const *)(& ivch_ops),
      (void *)0, (struct i2c_adapter *)0},
        {"tfp410", 2, 397664U, 0U, 56, (struct intel_dvo_dev_ops const *)(& tfp410_ops),
      (void *)0, (struct i2c_adapter *)0},
        {"ch7017", 1, 397664U, 5U, 117, (struct intel_dvo_dev_ops const *)(& ch7017_ops),
      (void *)0, (struct i2c_adapter *)0}};
static struct intel_dvo *enc_to_intel_dvo(struct drm_encoder *encoder )
{ struct drm_encoder const *__mptr ;
  {
  __mptr = (struct drm_encoder const *)encoder;
  return ((struct intel_dvo *)__mptr);
}
}
static struct intel_dvo *intel_attached_dvo(struct drm_connector *connector )
{ struct intel_encoder const *__mptr ;
  struct intel_encoder *tmp ;
  {
  {
  tmp = intel_attached_encoder(connector);
  __mptr = (struct intel_encoder const *)tmp;
  }
  return ((struct intel_dvo *)__mptr);
}
}
static void intel_dvo_dpms(struct drm_encoder *encoder , int mode )
{ struct drm_i915_private *dev_priv ;
  struct intel_dvo *intel_dvo ;
  struct intel_dvo *tmp ;
  u32 dvo_reg ;
  u32 temp ;
  u32 tmp___0 ;
  {
  {
  dev_priv = (struct drm_i915_private *)(encoder->dev)->dev_private;
  tmp = enc_to_intel_dvo(encoder);
  intel_dvo = tmp;
  dvo_reg = intel_dvo->dev.dvo_reg;
  tmp___0 = i915_read32___13(dev_priv, dvo_reg);
  temp = tmp___0;
  }
  if (mode == 0) {
    {
    i915_write32___11(dev_priv, dvo_reg, temp | 2147483648U);
    i915_read32___13(dev_priv, dvo_reg);
    (*((intel_dvo->dev.dev_ops)->dpms))(& intel_dvo->dev, mode);
    }
  } else {
    {
    (*((intel_dvo->dev.dev_ops)->dpms))(& intel_dvo->dev, mode);
    i915_write32___11(dev_priv, dvo_reg, temp & 2147483647U);
    i915_read32___13(dev_priv, dvo_reg);
    }
  }
  return;
}
}
static int intel_dvo_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode )
{ struct intel_dvo *intel_dvo ;
  struct intel_dvo *tmp ;
  int tmp___0 ;
  {
  {
  tmp = intel_attached_dvo(connector);
  intel_dvo = tmp;
  }
  if ((mode->flags & 32U) != 0U) {
    return (8);
  } else {
  }
  if ((unsigned long )intel_dvo->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
    if (mode->hdisplay > (intel_dvo->panel_fixed_mode)->hdisplay) {
      return (29);
    } else {
    }
    if (mode->vdisplay > (intel_dvo->panel_fixed_mode)->vdisplay) {
      return (29);
    } else {
    }
  } else {
  }
  {
  tmp___0 = (*((intel_dvo->dev.dev_ops)->mode_valid))(& intel_dvo->dev, mode);
  }
  return (tmp___0);
}
}
static bool intel_dvo_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                 struct drm_display_mode *adjusted_mode )
{ struct intel_dvo *intel_dvo ;
  struct intel_dvo *tmp ;
  bool tmp___0 ;
  {
  {
  tmp = enc_to_intel_dvo(encoder);
  intel_dvo = tmp;
  }
  if ((unsigned long )intel_dvo->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
    {
    adjusted_mode->hdisplay = (intel_dvo->panel_fixed_mode)->hdisplay;
    adjusted_mode->hsync_start = (intel_dvo->panel_fixed_mode)->hsync_start;
    adjusted_mode->hsync_end = (intel_dvo->panel_fixed_mode)->hsync_end;
    adjusted_mode->htotal = (intel_dvo->panel_fixed_mode)->htotal;
    adjusted_mode->vdisplay = (intel_dvo->panel_fixed_mode)->vdisplay;
    adjusted_mode->vsync_start = (intel_dvo->panel_fixed_mode)->vsync_start;
    adjusted_mode->vsync_end = (intel_dvo->panel_fixed_mode)->vsync_end;
    adjusted_mode->vtotal = (intel_dvo->panel_fixed_mode)->vtotal;
    adjusted_mode->clock = (intel_dvo->panel_fixed_mode)->clock;
    drm_mode_set_crtcinfo(adjusted_mode, 1);
    }
  } else {
  }
  if ((unsigned long )(intel_dvo->dev.dev_ops)->mode_fixup != (unsigned long )((bool (* const )(struct intel_dvo_device * ,
                                                                                                 struct drm_display_mode * ,
                                                                                                 struct drm_display_mode * ))0)) {
    {
    tmp___0 = (*((intel_dvo->dev.dev_ops)->mode_fixup))(& intel_dvo->dev, mode, adjusted_mode);
    }
    return (tmp___0);
  } else {
  }
  return ((bool )1);
}
}
static void intel_dvo_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                               struct drm_display_mode *adjusted_mode )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_crtc *intel_crtc ;
  struct drm_crtc const *__mptr ;
  struct intel_dvo *intel_dvo ;
  struct intel_dvo *tmp ;
  int pipe ;
  u32 dvo_val ;
  u32 dvo_reg ;
  u32 dvo_srcdim_reg ;
  int dpll_reg ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  {
  {
  dev = encoder->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  __mptr = (struct drm_crtc const *)encoder->crtc;
  intel_crtc = (struct intel_crtc *)__mptr;
  tmp = enc_to_intel_dvo(encoder);
  intel_dvo = tmp;
  pipe = (int )intel_crtc->pipe;
  dvo_reg = intel_dvo->dev.dvo_reg;
  dpll_reg = (pipe + 6149) * 4;
  }
  if ((int )dvo_reg == 397600) {
    goto case_397600;
  } else
  if ((int )dvo_reg == 397632) {
    goto case_397632;
  } else
  if ((int )dvo_reg == 397664) {
    goto case_397664;
  } else {
    goto switch_default;
    if (0) {
      case_397600: ;
      switch_default:
      dvo_srcdim_reg = 397604U;
      goto ldv_37647;
      case_397632:
      dvo_srcdim_reg = 397636U;
      goto ldv_37647;
      case_397664:
      dvo_srcdim_reg = 397668U;
      goto ldv_37647;
    } else {
    }
  }
  ldv_37647:
  {
  (*((intel_dvo->dev.dev_ops)->mode_set))(& intel_dvo->dev, mode, adjusted_mode);
  tmp___0 = i915_read32___13(dev_priv, dvo_reg);
  dvo_val = tmp___0 & 117440576U;
  dvo_val = dvo_val | 16516U;
  }
  if (pipe == 1) {
    dvo_val = dvo_val | 1073741824U;
  } else {
  }
  dvo_val = dvo_val | 268435456U;
  if ((int )adjusted_mode->flags & 1) {
    dvo_val = dvo_val | 8U;
  } else {
  }
  if ((adjusted_mode->flags & 4U) != 0U) {
    dvo_val = dvo_val | 16U;
  } else {
  }
  {
  tmp___1 = i915_read32___13(dev_priv, (u32 )dpll_reg);
  i915_write32___11(dev_priv, (u32 )dpll_reg, tmp___1 | 1073741824U);
  i915_write32___11(dev_priv, dvo_srcdim_reg, (u32 )((adjusted_mode->hdisplay << 12) | adjusted_mode->vdisplay));
  i915_write32___11(dev_priv, dvo_reg, dvo_val);
  }
  return;
}
}
static enum drm_connector_status intel_dvo_detect(struct drm_connector *connector ,
                                                  bool force )
{ struct intel_dvo *intel_dvo ;
  struct intel_dvo *tmp ;
  enum drm_connector_status tmp___0 ;
  {
  {
  tmp = intel_attached_dvo(connector);
  intel_dvo = tmp;
  tmp___0 = (*((intel_dvo->dev.dev_ops)->detect))(& intel_dvo->dev);
  }
  return (tmp___0);
}
}
static int intel_dvo_get_modes(struct drm_connector *connector )
{ struct intel_dvo *intel_dvo ;
  struct intel_dvo *tmp ;
  struct drm_i915_private *dev_priv ;
  int tmp___0 ;
  struct drm_display_mode *mode ;
  {
  {
  tmp = intel_attached_dvo(connector);
  intel_dvo = tmp;
  dev_priv = (struct drm_i915_private *)(connector->dev)->dev_private;
  intel_ddc_get_modes(connector, & (dev_priv->gmbus + 4UL)->adapter);
  tmp___0 = list_empty((struct list_head const *)(& connector->probed_modes));
  }
  if (tmp___0 == 0) {
    return (1);
  } else {
  }
  if ((unsigned long )intel_dvo->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
    {
    mode = drm_mode_duplicate(connector->dev, (struct drm_display_mode const *)intel_dvo->panel_fixed_mode);
    }
    if ((unsigned long )mode != (unsigned long )((struct drm_display_mode *)0)) {
      {
      drm_mode_probed_add(connector, mode);
      }
      return (1);
    } else {
    }
  } else {
  }
  return (0);
}
}
static void intel_dvo_destroy(struct drm_connector *connector )
{
  {
  {
  drm_sysfs_connector_remove(connector);
  drm_connector_cleanup(connector);
  kfree((void const *)connector);
  }
  return;
}
}
static struct drm_encoder_helper_funcs const intel_dvo_helper_funcs =
     {& intel_dvo_dpms, (void (*)(struct drm_encoder * ))0, (void (*)(struct drm_encoder * ))0,
    & intel_dvo_mode_fixup, & intel_encoder_prepare, & intel_encoder_commit, & intel_dvo_mode_set,
    (struct drm_crtc *(*)(struct drm_encoder * ))0, (enum drm_connector_status (*)(struct drm_encoder * ,
                                                                                   struct drm_connector * ))0,
    (void (*)(struct drm_encoder * ))0};
static struct drm_connector_funcs const intel_dvo_connector_funcs =
     {& drm_helper_connector_dpms, (void (*)(struct drm_connector * ))0, (void (*)(struct drm_connector * ))0,
    (void (*)(struct drm_connector * ))0, & intel_dvo_detect, & drm_helper_probe_single_connector_modes,
    (int (*)(struct drm_connector * , struct drm_property * , uint64_t ))0, & intel_dvo_destroy,
    (void (*)(struct drm_connector * ))0};
static struct drm_connector_helper_funcs const intel_dvo_connector_helper_funcs = {& intel_dvo_get_modes,
    & intel_dvo_mode_valid, & intel_best_encoder};
static void intel_dvo_enc_destroy(struct drm_encoder *encoder )
{ struct intel_dvo *intel_dvo ;
  struct intel_dvo *tmp ;
  {
  {
  tmp = enc_to_intel_dvo(encoder);
  intel_dvo = tmp;
  }
  if ((unsigned long )(intel_dvo->dev.dev_ops)->destroy != (unsigned long )((void (* const )(struct intel_dvo_device * ))0)) {
    {
    (*((intel_dvo->dev.dev_ops)->destroy))(& intel_dvo->dev);
    }
  } else {
  }
  {
  kfree((void const *)intel_dvo->panel_fixed_mode);
  intel_encoder_destroy(encoder);
  }
  return;
}
}
static struct drm_encoder_funcs const intel_dvo_enc_funcs = {(void (*)(struct drm_encoder * ))0, & intel_dvo_enc_destroy};
static struct drm_display_mode *intel_dvo_get_current_mode(struct drm_connector *connector )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct intel_dvo *intel_dvo ;
  struct intel_dvo *tmp ;
  uint32_t dvo_val ;
  u32 tmp___0 ;
  struct drm_display_mode *mode ;
  struct drm_crtc *crtc ;
  int pipe ;
  {
  {
  dev = connector->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = intel_attached_dvo(connector);
  intel_dvo = tmp;
  tmp___0 = i915_read32___13(dev_priv, intel_dvo->dev.dvo_reg);
  dvo_val = tmp___0;
  mode = (struct drm_display_mode *)0;
  }
  if ((int )dvo_val < 0) {
    {
    pipe = (dvo_val & 1073741824U) != 0U;
    crtc = intel_get_crtc_for_pipe(dev, pipe);
    }
    if ((unsigned long )crtc != (unsigned long )((struct drm_crtc *)0)) {
      {
      mode = intel_crtc_mode_get(dev, crtc);
      }
      if ((unsigned long )mode != (unsigned long )((struct drm_display_mode *)0)) {
        mode->type = mode->type | 8;
        if ((dvo_val & 8U) != 0U) {
          mode->flags = mode->flags | 1U;
        } else {
        }
        if ((dvo_val & 16U) != 0U) {
          mode->flags = mode->flags | 4U;
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  return (mode);
}
}
void intel_dvo_init(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct intel_encoder *intel_encoder ;
  struct intel_dvo *intel_dvo ;
  struct intel_connector *intel_connector ;
  int i ;
  int encoder_type ;
  void *tmp ;
  void *tmp___0 ;
  struct drm_connector *connector ;
  struct intel_dvo_device const *dvo ;
  struct i2c_adapter *i2c ;
  int gpio ;
  bool tmp___1 ;
  int tmp___2 ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  encoder_type = 0;
  tmp = kzalloc(160UL, 208U);
  intel_dvo = (struct intel_dvo *)tmp;
  }
  if ((unsigned long )intel_dvo == (unsigned long )((struct intel_dvo *)0)) {
    return;
  } else {
  }
  {
  tmp___0 = kzalloc(1576UL, 208U);
  intel_connector = (struct intel_connector *)tmp___0;
  }
  if ((unsigned long )intel_connector == (unsigned long )((struct intel_connector *)0)) {
    {
    kfree((void const *)intel_dvo);
    }
    return;
  } else {
  }
  {
  intel_encoder = & intel_dvo->base;
  drm_encoder_init(dev, & intel_encoder->base, & intel_dvo_enc_funcs, encoder_type);
  i = 0;
  }
  goto ldv_37702;
  ldv_37701:
  connector = & intel_connector->base;
  dvo = (struct intel_dvo_device const *)(& intel_dvo_devices) + (unsigned long )i;
  if ((unsigned int )dvo->gpio != 0U) {
    gpio = (int )dvo->gpio;
  } else
  if ((int )dvo->type == 1) {
    gpio = 1;
  } else {
    gpio = 5;
  }
  {
  i2c = & (dev_priv->gmbus + (unsigned long )gpio)->adapter;
  intel_dvo->dev = (struct intel_dvo_device )*dvo;
  tmp___1 = (*((dvo->dev_ops)->init))(& intel_dvo->dev, i2c);
  }
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    goto ldv_37697;
  } else {
  }
  intel_encoder->type = 2;
  intel_encoder->crtc_mask = 3;
  if ((int )dvo->type == 2) {
    goto case_2;
  } else
  if ((int )dvo->type == 1) {
    goto case_1;
  } else
  if (0) {
    case_2:
    {
    intel_encoder->clone_mask = 33280;
    drm_connector_init(dev, connector, & intel_dvo_connector_funcs, 2);
    encoder_type = 2;
    }
    goto ldv_37699;
    case_1:
    {
    intel_encoder->clone_mask = 65536;
    drm_connector_init(dev, connector, & intel_dvo_connector_funcs, 7);
    encoder_type = 3;
    }
    goto ldv_37699;
  } else {
  }
  ldv_37699:
  {
  drm_connector_helper_add(connector, & intel_dvo_connector_helper_funcs);
  connector->display_info.subpixel_order = (enum subpixel_order )1;
  connector->interlace_allowed = (bool )0;
  connector->doublescan_allowed = (bool )0;
  drm_encoder_helper_add(& intel_encoder->base, & intel_dvo_helper_funcs);
  intel_connector_attach_encoder(intel_connector, intel_encoder);
  }
  if ((int )dvo->type == 1) {
    {
    intel_dvo->panel_fixed_mode = intel_dvo_get_current_mode(connector);
    intel_dvo->panel_wants_dither = (bool )1;
    }
  } else {
  }
  {
  drm_sysfs_connector_add(connector);
  }
  return;
  ldv_37697:
  i = i + 1;
  ldv_37702: ;
  if ((unsigned int )i <= 4U) {
    goto ldv_37701;
  } else {
    goto ldv_37703;
  }
  ldv_37703:
  {
  drm_encoder_cleanup(& intel_encoder->base);
  kfree((void const *)intel_dvo);
  kfree((void const *)intel_connector);
  }
  return;
}
}
__inline static void trace_i915_ring_wait_begin(struct intel_ring_buffer *ring )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_ring_wait_begin.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_ring_wait_begin.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )344);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_36114:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct intel_ring_buffer * ))it_func))(__data, ring);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_36114;
      } else {
        goto ldv_36115;
      }
      ldv_36115: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
__inline static void trace_i915_ring_wait_end(struct intel_ring_buffer *ring )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_ring_wait_end.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_ring_wait_end.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )349);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_36145:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct intel_ring_buffer * ))it_func))(__data, ring);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_36145;
      } else {
        goto ldv_36146;
      }
      ldv_36146: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
__inline static int ring_space(struct intel_ring_buffer *ring )
{ int space ;
  {
  space = (int )(((ring->head & 2097148U) - ring->tail) - 8U);
  if (space < 0) {
    space = ring->size + space;
  } else {
  }
  return (space);
}
}
static u32 i915_gem_get_seqno(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  u32 seqno ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  seqno = dev_priv->next_seqno;
  dev_priv->next_seqno = dev_priv->next_seqno + 1U;
  if (dev_priv->next_seqno == 0U) {
    dev_priv->next_seqno = 1U;
  } else {
  }
  return (seqno);
}
}
static int render_ring_flush(struct intel_ring_buffer *ring , u32 invalidate_domains ,
                             u32 flush_domains )
{ struct drm_device *dev ;
  u32 cmd ;
  int ret ;
  {
  dev = ring->dev;
  cmd = 33554436U;
  if (((invalidate_domains | flush_domains) & 2U) != 0U) {
    cmd = cmd & 4294967291U;
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) <= 3U) {
    if ((invalidate_domains & 4U) != 0U) {
      cmd = cmd | 1U;
    } else {
    }
  } else {
  }
  if ((invalidate_domains & 16U) != 0U) {
    cmd = cmd | 2U;
  } else {
  }
  if ((invalidate_domains & 8U) != 0U) {
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
      cmd = cmd | 32U;
    } else
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
      cmd = cmd | 32U;
    } else {
    }
  } else {
  }
  {
  ret = intel_ring_begin(ring, 2);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  intel_ring_emit(ring, cmd);
  intel_ring_emit(ring, 0U);
  intel_ring_advance(ring);
  }
  return (0);
}
}
static void ring_write_tail(struct intel_ring_buffer *ring , u32 value )
{ drm_i915_private_t *dev_priv ;
  {
  {
  dev_priv = (drm_i915_private_t *)(ring->dev)->dev_private;
  i915_write32___11(dev_priv, ring->mmio_base + 48U, value);
  }
  return;
}
}
u32 intel_ring_get_active_head(struct intel_ring_buffer *ring )
{ drm_i915_private_t *dev_priv ;
  u32 acthd_reg ;
  u32 tmp ;
  u32 tmp___0 ;
  {
  dev_priv = (drm_i915_private_t *)(ring->dev)->dev_private;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)(ring->dev)->dev_private)->info)->gen) > 3U) {
    tmp = ring->mmio_base + 116U;
  } else {
    tmp = 8392U;
  }
  {
  acthd_reg = tmp;
  tmp___0 = i915_read32___13(dev_priv, acthd_reg);
  }
  return (tmp___0);
}
}
static int init_ring_common(struct intel_ring_buffer *ring )
{ drm_i915_private_t *dev_priv ;
  struct drm_i915_gem_object *obj ;
  u32 head ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;
  u32 tmp___16 ;
  int tmp___17 ;
  {
  {
  dev_priv = (drm_i915_private_t *)(ring->dev)->dev_private;
  obj = ring->obj;
  i915_write32___11(dev_priv, ring->mmio_base + 60U, 0U);
  i915_write32___11(dev_priv, ring->mmio_base + 52U, 0U);
  (*(ring->write_tail))(ring, 0U);
  i915_write32___11(dev_priv, ring->mmio_base + 56U, obj->gtt_offset);
  tmp = i915_read32___13(dev_priv, ring->mmio_base + 52U);
  head = tmp & 2097148U;
  }
  if (head != 0U) {
    {
    tmp___0 = i915_read32___13(dev_priv, ring->mmio_base + 56U);
    tmp___1 = i915_read32___13(dev_priv, ring->mmio_base + 48U);
    tmp___2 = i915_read32___13(dev_priv, ring->mmio_base + 52U);
    tmp___3 = i915_read32___13(dev_priv, ring->mmio_base + 60U);
    drm_ut_debug_printk(4U, "drm", "init_ring_common", "%s head not reset to zero ctl %08x head %08x tail %08x start %08x\n",
                        ring->name, tmp___3, tmp___2, tmp___1, tmp___0);
    i915_write32___11(dev_priv, ring->mmio_base + 52U, 0U);
    tmp___8 = i915_read32___13(dev_priv, ring->mmio_base + 52U);
    }
    if ((tmp___8 & 2097148U) != 0U) {
      {
      tmp___4 = i915_read32___13(dev_priv, ring->mmio_base + 56U);
      tmp___5 = i915_read32___13(dev_priv, ring->mmio_base + 48U);
      tmp___6 = i915_read32___13(dev_priv, ring->mmio_base + 52U);
      tmp___7 = i915_read32___13(dev_priv, ring->mmio_base + 60U);
      drm_err("init_ring_common", "failed to set %s head to zero ctl %08x head %08x tail %08x start %08x\n",
              ring->name, tmp___7, tmp___6, tmp___5, tmp___4);
      }
    } else {
    }
  } else {
  }
  {
  i915_write32___11(dev_priv, ring->mmio_base + 60U, (((u32 )ring->size - 4096U) & 2093056U) | 3U);
  tmp___13 = i915_read32___13(dev_priv, ring->mmio_base + 60U);
  }
  if ((tmp___13 & 1U) == 0U) {
    goto _L;
  } else {
    {
    tmp___14 = i915_read32___13(dev_priv, ring->mmio_base + 56U);
    }
    if (tmp___14 != obj->gtt_offset) {
      goto _L;
    } else {
      {
      tmp___15 = i915_read32___13(dev_priv, ring->mmio_base + 52U);
      }
      if ((tmp___15 & 2097148U) != 0U) {
        _L:
        {
        tmp___9 = i915_read32___13(dev_priv, ring->mmio_base + 56U);
        tmp___10 = i915_read32___13(dev_priv, ring->mmio_base + 48U);
        tmp___11 = i915_read32___13(dev_priv, ring->mmio_base + 52U);
        tmp___12 = i915_read32___13(dev_priv, ring->mmio_base + 60U);
        drm_err("init_ring_common", "%s initialization failed ctl %08x head %08x tail %08x start %08x\n",
                ring->name, tmp___12, tmp___11, tmp___10, tmp___9);
        }
        return (-5);
      } else {
      }
    }
  }
  {
  tmp___17 = drm_core_check_feature(ring->dev, 8192);
  }
  if (tmp___17 == 0) {
    {
    i915_kernel_lost_context(ring->dev);
    }
  } else {
    {
    ring->head = i915_read32___13(dev_priv, ring->mmio_base + 52U);
    tmp___16 = i915_read32___13(dev_priv, ring->mmio_base + 48U);
    ring->tail = tmp___16 & 2097144U;
    ring->space = ring_space(ring);
    }
  }
  return (0);
}
}
static int init_pipe_control(struct intel_ring_buffer *ring )
{ struct pipe_control *pc ;
  struct drm_i915_gem_object *obj ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  {
  if ((unsigned long )ring->private != (unsigned long )((void *)0)) {
    return (0);
  } else {
  }
  {
  tmp = kmalloc(24UL, 208U);
  pc = (struct pipe_control *)tmp;
  }
  if ((unsigned long )pc == (unsigned long )((struct pipe_control *)0)) {
    return (-12);
  } else {
  }
  {
  obj = i915_gem_alloc_object(ring->dev, 4096UL);
  }
  if ((unsigned long )obj == (unsigned long )((struct drm_i915_gem_object *)0)) {
    {
    drm_err("init_pipe_control", "Failed to allocate seqno page\n");
    ret = -12;
    }
    goto err;
  } else {
  }
  {
  obj->cache_level = (unsigned char)1;
  ret = i915_gem_object_pin(obj, 4096U, (bool )1);
  }
  if (ret != 0) {
    goto err_unref;
  } else {
  }
  {
  pc->gtt_offset = obj->gtt_offset;
  tmp___0 = kmap(*(obj->pages));
  pc->cpu_page = (u32 volatile *)tmp___0;
  }
  if ((unsigned long )pc->cpu_page == (unsigned long )((u32 volatile *)0)) {
    goto err_unpin;
  } else {
  }
  pc->obj = obj;
  ring->private = (void *)pc;
  return (0);
  err_unpin:
  {
  i915_gem_object_unpin(obj);
  }
  err_unref:
  {
  drm_gem_object_unreference(& obj->base);
  }
  err:
  {
  kfree((void const *)pc);
  }
  return (ret);
}
}
static void cleanup_pipe_control(struct intel_ring_buffer *ring )
{ struct pipe_control *pc ;
  struct drm_i915_gem_object *obj ;
  {
  pc = (struct pipe_control *)ring->private;
  if ((unsigned long )ring->private == (unsigned long )((void *)0)) {
    return;
  } else {
  }
  {
  obj = pc->obj;
  kunmap(*(obj->pages));
  i915_gem_object_unpin(obj);
  drm_gem_object_unreference(& obj->base);
  kfree((void const *)pc);
  ring->private = (void *)0;
  }
  return;
}
}
static int init_render_ring(struct intel_ring_buffer *ring )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  int ret ;
  int tmp ;
  int mode ;
  {
  {
  dev = ring->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  tmp = init_ring_common(ring);
  ret = tmp;
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    mode = 4194368;
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
      mode = mode | 134219776;
    } else
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 7U) {
      mode = mode | 134219776;
    } else {
    }
    {
    i915_write32___11(dev_priv, 8348U, (u32 )mode);
    }
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 5U) {
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    {
    ret = init_pipe_control(ring);
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
  } else {
  }
  return (ret);
}
}
static void render_ring_cleanup(struct intel_ring_buffer *ring )
{
  {
  if ((unsigned long )ring->private == (unsigned long )((void *)0)) {
    return;
  } else {
  }
  {
  cleanup_pipe_control(ring);
  }
  return;
}
}
static void update_semaphore(struct intel_ring_buffer *ring , int i , u32 seqno )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  int id ;
  {
  {
  dev = ring->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  id = (int )(((long )ring - (long )(& dev_priv->ring)) / 456L);
  id = (2 - i) + id;
  id = id % 3;
  intel_ring_emit(ring, 186908673U);
  intel_ring_emit(ring, seqno);
  intel_ring_emit(ring, (dev_priv->ring[id].mmio_base + (u32 )(i * 4)) + 64U);
  }
  return;
}
}
static int gen6_add_request(struct intel_ring_buffer *ring , u32 *result )
{ u32 seqno ;
  int ret ;
  {
  {
  ret = intel_ring_begin(ring, 10);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  seqno = i915_gem_get_seqno(ring->dev);
  update_semaphore(ring, 0, seqno);
  update_semaphore(ring, 1, seqno);
  intel_ring_emit(ring, 276824065U);
  intel_ring_emit(ring, 128U);
  intel_ring_emit(ring, seqno);
  intel_ring_emit(ring, 16777216U);
  intel_ring_advance(ring);
  *result = seqno;
  }
  return (0);
}
}
int intel_ring_sync(struct intel_ring_buffer *ring , struct intel_ring_buffer *to ,
                    u32 seqno )
{ int ret ;
  u32 tmp ;
  {
  {
  ret = intel_ring_begin(ring, 4);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  tmp = intel_ring_sync_index(ring, to);
  intel_ring_emit(ring, (tmp << 17) | 185860097U);
  intel_ring_emit(ring, seqno);
  intel_ring_emit(ring, 0U);
  intel_ring_emit(ring, 0U);
  intel_ring_advance(ring);
  }
  return (0);
}
}
static int pc_render_add_request(struct intel_ring_buffer *ring , u32 *result )
{ struct drm_device *dev ;
  u32 seqno ;
  u32 tmp ;
  struct pipe_control *pc ;
  u32 scratch_addr ;
  int ret ;
  {
  {
  dev = ring->dev;
  tmp = i915_gem_get_seqno(dev);
  seqno = tmp;
  pc = (struct pipe_control *)ring->private;
  scratch_addr = pc->gtt_offset + 128U;
  ret = intel_ring_begin(ring, 32);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  intel_ring_emit(ring, 2046841858U);
  intel_ring_emit(ring, pc->gtt_offset | 4U);
  intel_ring_emit(ring, seqno);
  intel_ring_emit(ring, 0U);
  intel_ring_emit(ring, 2046844930U);
  intel_ring_emit(ring, scratch_addr | 4U);
  intel_ring_emit(ring, 0U);
  intel_ring_emit(ring, 0U);
  scratch_addr = scratch_addr + 128U;
  intel_ring_emit(ring, 2046844930U);
  intel_ring_emit(ring, scratch_addr | 4U);
  intel_ring_emit(ring, 0U);
  intel_ring_emit(ring, 0U);
  scratch_addr = scratch_addr + 128U;
  intel_ring_emit(ring, 2046844930U);
  intel_ring_emit(ring, scratch_addr | 4U);
  intel_ring_emit(ring, 0U);
  intel_ring_emit(ring, 0U);
  scratch_addr = scratch_addr + 128U;
  intel_ring_emit(ring, 2046844930U);
  intel_ring_emit(ring, scratch_addr | 4U);
  intel_ring_emit(ring, 0U);
  intel_ring_emit(ring, 0U);
  scratch_addr = scratch_addr + 128U;
  intel_ring_emit(ring, 2046844930U);
  intel_ring_emit(ring, scratch_addr | 4U);
  intel_ring_emit(ring, 0U);
  intel_ring_emit(ring, 0U);
  scratch_addr = scratch_addr + 128U;
  intel_ring_emit(ring, 2046844930U);
  intel_ring_emit(ring, scratch_addr | 4U);
  intel_ring_emit(ring, 0U);
  intel_ring_emit(ring, 0U);
  intel_ring_emit(ring, 2046842114U);
  intel_ring_emit(ring, pc->gtt_offset | 4U);
  intel_ring_emit(ring, seqno);
  intel_ring_emit(ring, 0U);
  intel_ring_advance(ring);
  *result = seqno;
  }
  return (0);
}
}
static int render_ring_add_request(struct intel_ring_buffer *ring , u32 *result )
{ struct drm_device *dev ;
  u32 seqno ;
  u32 tmp ;
  int ret ;
  {
  {
  dev = ring->dev;
  tmp = i915_gem_get_seqno(dev);
  seqno = tmp;
  ret = intel_ring_begin(ring, 4);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  intel_ring_emit(ring, 276824065U);
  intel_ring_emit(ring, 128U);
  intel_ring_emit(ring, seqno);
  intel_ring_emit(ring, 16777216U);
  intel_ring_advance(ring);
  *result = seqno;
  }
  return (0);
}
}
static u32 ring_get_seqno(struct intel_ring_buffer *ring )
{ u32 tmp ;
  {
  {
  tmp = intel_read_status_page(ring, 32);
  }
  return (tmp);
}
}
static u32 pc_render_get_seqno(struct intel_ring_buffer *ring )
{ struct pipe_control *pc ;
  {
  pc = (struct pipe_control *)ring->private;
  return ((u32 )*(pc->cpu_page));
}
}
static void ironlake_enable_irq(drm_i915_private_t *dev_priv , u32 mask )
{
  {
  {
  dev_priv->gt_irq_mask = dev_priv->gt_irq_mask & ~ mask;
  i915_write32___11(dev_priv, 278548U, dev_priv->gt_irq_mask);
  readl((void const volatile *)dev_priv->regs + 278548U);
  }
  return;
}
}
static void ironlake_disable_irq(drm_i915_private_t *dev_priv , u32 mask )
{
  {
  {
  dev_priv->gt_irq_mask = dev_priv->gt_irq_mask | mask;
  i915_write32___11(dev_priv, 278548U, dev_priv->gt_irq_mask);
  readl((void const volatile *)dev_priv->regs + 278548U);
  }
  return;
}
}
static void i915_enable_irq(drm_i915_private_t *dev_priv , u32 mask )
{
  {
  {
  dev_priv->irq_mask = dev_priv->irq_mask & ~ mask;
  i915_write32___11(dev_priv, 8360U, dev_priv->irq_mask);
  readl((void const volatile *)dev_priv->regs + 8360U);
  }
  return;
}
}
static void i915_disable_irq(drm_i915_private_t *dev_priv , u32 mask )
{
  {
  {
  dev_priv->irq_mask = dev_priv->irq_mask | mask;
  i915_write32___11(dev_priv, 8360U, dev_priv->irq_mask);
  readl((void const volatile *)dev_priv->regs + 8360U);
  }
  return;
}
}
static bool render_ring_get_irq(struct intel_ring_buffer *ring )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  u32 tmp ;
  {
  dev = ring->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  if (dev->irq_enabled == 0) {
    return ((bool )0);
  } else {
  }
  {
  spin_lock(& ring->irq_lock);
  tmp = ring->irq_refcount;
  ring->irq_refcount = ring->irq_refcount + 1U;
  }
  if (tmp == 0U) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
      {
      ironlake_enable_irq(dev_priv, 17U);
      }
    } else
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
      {
      ironlake_enable_irq(dev_priv, 17U);
      }
    } else
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
      {
      ironlake_enable_irq(dev_priv, 17U);
      }
    } else {
      {
      i915_enable_irq(dev_priv, 2U);
      }
    }
  } else {
  }
  {
  spin_unlock(& ring->irq_lock);
  }
  return ((bool )1);
}
}
static void render_ring_put_irq(struct intel_ring_buffer *ring )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  {
  {
  dev = ring->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  spin_lock(& ring->irq_lock);
  ring->irq_refcount = ring->irq_refcount - 1U;
  }
  if (ring->irq_refcount == 0U) {
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
      {
      ironlake_disable_irq(dev_priv, 17U);
      }
    } else
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
      {
      ironlake_disable_irq(dev_priv, 17U);
      }
    } else
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) != 0U) {
      {
      ironlake_disable_irq(dev_priv, 17U);
      }
    } else {
      {
      i915_disable_irq(dev_priv, 2U);
      }
    }
  } else {
  }
  {
  spin_unlock(& ring->irq_lock);
  }
  return;
}
}
void intel_ring_setup_status_page(struct intel_ring_buffer *ring )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  u32 mmio ;
  {
  dev = ring->dev;
  dev_priv = (drm_i915_private_t *)(ring->dev)->dev_private;
  mmio = 0U;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 7U) {
    if ((int )((unsigned int )ring->id) == 1) {
      goto case_1;
    } else
    if ((int )((unsigned int )ring->id) == 4) {
      goto case_4;
    } else
    if ((int )((unsigned int )ring->id) == 2) {
      goto case_2;
    } else
    if (0) {
      case_1:
      mmio = 16512U;
      goto ldv_37687;
      case_4:
      mmio = 17024U;
      goto ldv_37687;
      case_2:
      mmio = 16768U;
      goto ldv_37687;
    } else {
    }
    ldv_37687: ;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)(ring->dev)->dev_private)->info)->gen) == 6U) {
    mmio = ring->mmio_base + 8320U;
  } else {
    mmio = ring->mmio_base + 128U;
  }
  {
  i915_write32___11(dev_priv, mmio, ring->status_page.gfx_addr);
  readl((void const volatile *)dev_priv->regs + (unsigned long )mmio);
  }
  return;
}
}
static int bsd_ring_flush(struct intel_ring_buffer *ring , u32 invalidate_domains ,
                          u32 flush_domains )
{ int ret ;
  {
  {
  ret = intel_ring_begin(ring, 2);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  intel_ring_emit(ring, 33554432U);
  intel_ring_emit(ring, 0U);
  intel_ring_advance(ring);
  }
  return (0);
}
}
static int ring_add_request(struct intel_ring_buffer *ring , u32 *result )
{ u32 seqno ;
  int ret ;
  {
  {
  ret = intel_ring_begin(ring, 4);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  seqno = i915_gem_get_seqno(ring->dev);
  intel_ring_emit(ring, 276824065U);
  intel_ring_emit(ring, 128U);
  intel_ring_emit(ring, seqno);
  intel_ring_emit(ring, 16777216U);
  intel_ring_advance(ring);
  *result = seqno;
  }
  return (0);
}
}
static bool gen6_ring_get_irq(struct intel_ring_buffer *ring , u32 gflag , u32 rflag )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  u32 tmp ;
  {
  dev = ring->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  if (dev->irq_enabled == 0) {
    return ((bool )0);
  } else {
  }
  {
  spin_lock(& ring->irq_lock);
  tmp = ring->irq_refcount;
  ring->irq_refcount = ring->irq_refcount + 1U;
  }
  if (tmp == 0U) {
    {
    ring->irq_mask = ring->irq_mask & ~ rflag;
    i915_write32___11(dev_priv, ring->mmio_base + 168U, ring->irq_mask);
    ironlake_enable_irq(dev_priv, gflag);
    }
  } else {
  }
  {
  spin_unlock(& ring->irq_lock);
  }
  return ((bool )1);
}
}
static void gen6_ring_put_irq(struct intel_ring_buffer *ring , u32 gflag , u32 rflag )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  {
  {
  dev = ring->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  spin_lock(& ring->irq_lock);
  ring->irq_refcount = ring->irq_refcount - 1U;
  }
  if (ring->irq_refcount == 0U) {
    {
    ring->irq_mask = ring->irq_mask | rflag;
    i915_write32___11(dev_priv, ring->mmio_base + 168U, ring->irq_mask);
    ironlake_disable_irq(dev_priv, gflag);
    }
  } else {
  }
  {
  spin_unlock(& ring->irq_lock);
  }
  return;
}
}
static bool bsd_ring_get_irq(struct intel_ring_buffer *ring )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  u32 tmp ;
  {
  dev = ring->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  if (dev->irq_enabled == 0) {
    return ((bool )0);
  } else {
  }
  {
  spin_lock(& ring->irq_lock);
  tmp = ring->irq_refcount;
  ring->irq_refcount = ring->irq_refcount + 1U;
  }
  if (tmp == 0U) {
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
      {
      i915_enable_irq(dev_priv, 33554432U);
      }
    } else {
      {
      ironlake_enable_irq(dev_priv, 32U);
      }
    }
  } else {
  }
  {
  spin_unlock(& ring->irq_lock);
  }
  return ((bool )1);
}
}
static void bsd_ring_put_irq(struct intel_ring_buffer *ring )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  {
  {
  dev = ring->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  spin_lock(& ring->irq_lock);
  ring->irq_refcount = ring->irq_refcount - 1U;
  }
  if (ring->irq_refcount == 0U) {
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
      {
      i915_disable_irq(dev_priv, 33554432U);
      }
    } else {
      {
      ironlake_disable_irq(dev_priv, 32U);
      }
    }
  } else {
  }
  {
  spin_unlock(& ring->irq_lock);
  }
  return;
}
}
static int ring_dispatch_execbuffer(struct intel_ring_buffer *ring , u32 offset ,
                                    u32 length )
{ int ret ;
  {
  {
  ret = intel_ring_begin(ring, 2);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  intel_ring_emit(ring, 411042176U);
  intel_ring_emit(ring, offset);
  intel_ring_advance(ring);
  }
  return (0);
}
}
static int render_ring_dispatch_execbuffer(struct intel_ring_buffer *ring , u32 offset ,
                                           u32 len )
{ struct drm_device *dev ;
  int ret ;
  {
  dev = ring->dev;
  if (dev->pci_device == 13687) {
    goto _L;
  } else
  if (dev->pci_device == 9570) {
    _L:
    {
    ret = intel_ring_begin(ring, 4);
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
    {
    intel_ring_emit(ring, 402653185U);
    intel_ring_emit(ring, offset | 1U);
    intel_ring_emit(ring, (offset + len) - 8U);
    intel_ring_emit(ring, 0U);
    }
  } else {
    {
    ret = intel_ring_begin(ring, 2);
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
      {
      intel_ring_emit(ring, 411042176U);
      intel_ring_emit(ring, offset);
      }
    } else {
      {
      intel_ring_emit(ring, 411041920U);
      intel_ring_emit(ring, offset | 1U);
      }
    }
  }
  {
  intel_ring_advance(ring);
  }
  return (0);
}
}
static void cleanup_status_page(struct intel_ring_buffer *ring )
{ drm_i915_private_t *dev_priv ;
  struct drm_i915_gem_object *obj ;
  {
  dev_priv = (drm_i915_private_t *)(ring->dev)->dev_private;
  obj = ring->status_page.obj;
  if ((unsigned long )obj == (unsigned long )((struct drm_i915_gem_object *)0)) {
    return;
  } else {
  }
  {
  kunmap(*(obj->pages));
  i915_gem_object_unpin(obj);
  drm_gem_object_unreference(& obj->base);
  ring->status_page.obj = (struct drm_i915_gem_object *)0;
  memset((void *)(& dev_priv->hws_map), 0, 40UL);
  }
  return;
}
}
static int init_status_page(struct intel_ring_buffer *ring )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  struct drm_i915_gem_object *obj ;
  int ret ;
  void *tmp ;
  {
  {
  dev = ring->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  obj = i915_gem_alloc_object(dev, 4096UL);
  }
  if ((unsigned long )obj == (unsigned long )((struct drm_i915_gem_object *)0)) {
    {
    drm_err("init_status_page", "Failed to allocate status page\n");
    ret = -12;
    }
    goto err;
  } else {
  }
  {
  obj->cache_level = (unsigned char)1;
  ret = i915_gem_object_pin(obj, 4096U, (bool )1);
  }
  if (ret != 0) {
    goto err_unref;
  } else {
  }
  {
  ring->status_page.gfx_addr = obj->gtt_offset;
  tmp = kmap(*(obj->pages));
  ring->status_page.page_addr = (u32 *)tmp;
  }
  if ((unsigned long )ring->status_page.page_addr == (unsigned long )((u32 *)0)) {
    {
    memset((void *)(& dev_priv->hws_map), 0, 40UL);
    }
    goto err_unpin;
  } else {
  }
  {
  ring->status_page.obj = obj;
  memset((void *)ring->status_page.page_addr, 0, 4096UL);
  intel_ring_setup_status_page(ring);
  drm_ut_debug_printk(2U, "drm", "init_status_page", "%s hws offset: 0x%08x\n", ring->name,
                      ring->status_page.gfx_addr);
  }
  return (0);
  err_unpin:
  {
  i915_gem_object_unpin(obj);
  }
  err_unref:
  {
  drm_gem_object_unreference(& obj->base);
  }
  err: ;
  return (ret);
}
}
int intel_init_ring_buffer(struct drm_device *dev , struct intel_ring_buffer *ring )
{ struct drm_i915_gem_object *obj ;
  int ret ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  {
  {
  ring->dev = dev;
  INIT_LIST_HEAD(& ring->active_list);
  INIT_LIST_HEAD(& ring->request_list);
  INIT_LIST_HEAD(& ring->gpu_write_list);
  __init_waitqueue_head(& ring->irq_queue, & __key);
  spinlock_check(& ring->irq_lock);
  __raw_spin_lock_init(& ring->irq_lock.ldv_6060.rlock, "&(&ring->irq_lock)->rlock",
                       & __key___0);
  ring->irq_mask = 4294967295U;
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
    {
    ret = init_status_page(ring);
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
  } else {
  }
  {
  obj = i915_gem_alloc_object(dev, (size_t )ring->size);
  }
  if ((unsigned long )obj == (unsigned long )((struct drm_i915_gem_object *)0)) {
    {
    drm_err("intel_init_ring_buffer", "Failed to allocate ringbuffer\n");
    ret = -12;
    }
    goto err_hws;
  } else {
  }
  {
  ring->obj = obj;
  ret = i915_gem_object_pin(obj, 4096U, (bool )1);
  }
  if (ret != 0) {
    goto err_unref;
  } else {
  }
  {
  ring->map.size = (unsigned long )ring->size;
  ring->map.offset = (resource_size_t )((dev->agp)->base + (unsigned long )obj->gtt_offset);
  ring->map.type = (enum drm_map_type )0;
  ring->map.flags = (enum drm_map_flags )0;
  ring->map.mtrr = 0;
  drm_core_ioremap_wc(& ring->map, dev);
  }
  if ((unsigned long )ring->map.handle == (unsigned long )((void *)0)) {
    {
    drm_err("intel_init_ring_buffer", "Failed to map ringbuffer.\n");
    ret = -22;
    }
    goto err_unpin;
  } else {
  }
  {
  ring->virtual_start = ring->map.handle;
  ret = (*(ring->init))(ring);
  }
  if (ret != 0) {
    goto err_unmap;
  } else {
  }
  ring->effective_size = ring->size;
  if ((ring->dev)->pci_device == 13687) {
    ring->effective_size = ring->effective_size + -128;
  } else {
  }
  return (0);
  err_unmap:
  {
  drm_core_ioremapfree(& ring->map, dev);
  }
  err_unpin:
  {
  i915_gem_object_unpin(obj);
  }
  err_unref:
  {
  drm_gem_object_unreference(& obj->base);
  ring->obj = (struct drm_i915_gem_object *)0;
  }
  err_hws:
  {
  cleanup_status_page(ring);
  }
  return (ret);
}
}
void intel_cleanup_ring_buffer(struct intel_ring_buffer *ring )
{ struct drm_i915_private *dev_priv ;
  int ret ;
  {
  if ((unsigned long )ring->obj == (unsigned long )((struct drm_i915_gem_object *)0)) {
    return;
  } else {
  }
  {
  dev_priv = (struct drm_i915_private *)(ring->dev)->dev_private;
  ret = intel_wait_ring_idle(ring);
  }
  if (ret != 0) {
    {
    drm_err("intel_cleanup_ring_buffer", "failed to quiesce %s whilst cleaning up: %d\n",
            ring->name, ret);
    }
  } else {
  }
  {
  i915_write32___11(dev_priv, ring->mmio_base + 60U, 0U);
  drm_core_ioremapfree(& ring->map, ring->dev);
  i915_gem_object_unpin(ring->obj);
  drm_gem_object_unreference(& (ring->obj)->base);
  ring->obj = (struct drm_i915_gem_object *)0;
  }
  if ((unsigned long )ring->cleanup != (unsigned long )((void (*)(struct intel_ring_buffer * ))0)) {
    {
    (*(ring->cleanup))(ring);
    }
  } else {
  }
  {
  cleanup_status_page(ring);
  }
  return;
}
}
static int intel_wrap_ring_buffer(struct intel_ring_buffer *ring )
{ unsigned int *virt ;
  int rem ;
  int ret ;
  int tmp ;
  unsigned int *tmp___0 ;
  unsigned int *tmp___1 ;
  int tmp___2 ;
  {
  rem = (int )((u32 )ring->size - ring->tail);
  if (ring->space < rem) {
    {
    tmp = intel_wait_ring_buffer(ring, rem);
    ret = tmp;
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
  } else {
  }
  virt = (unsigned int *)ring->virtual_start + (unsigned long )ring->tail;
  rem = rem / 8;
  goto ldv_37781;
  ldv_37780:
  tmp___0 = virt;
  virt = virt + 1;
  *tmp___0 = 0U;
  tmp___1 = virt;
  virt = virt + 1;
  *tmp___1 = 0U;
  ldv_37781:
  tmp___2 = rem;
  rem = rem - 1;
  if (tmp___2 != 0) {
    goto ldv_37780;
  } else {
    goto ldv_37782;
  }
  ldv_37782:
  {
  ring->tail = 0U;
  ring->space = ring_space(ring);
  }
  return (0);
}
}
int intel_wait_ring_buffer(struct intel_ring_buffer *ring , int n )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  unsigned long end ;
  u32 head ;
  struct drm_i915_master_private *master_priv ;
  int tmp ;
  {
  {
  dev = ring->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  head = intel_read_status_page(ring, 4);
  }
  if (ring->head < head) {
    {
    ring->head = head;
    ring->space = ring_space(ring);
    }
    if (ring->space >= n) {
      return (0);
    } else {
    }
  } else {
  }
  {
  trace_i915_ring_wait_begin(ring);
  end = (unsigned long )jiffies + 750UL;
  }
  ldv_37798:
  {
  ring->head = i915_read32___13(dev_priv, ring->mmio_base + 52U);
  ring->space = ring_space(ring);
  }
  if (ring->space >= n) {
    {
    trace_i915_ring_wait_end(ring);
    }
    return (0);
  } else {
  }
  if ((unsigned long )(dev->primary)->master != (unsigned long )((struct drm_master *)0)) {
    master_priv = (struct drm_i915_master_private *)((dev->primary)->master)->driver_priv;
    if ((unsigned long )master_priv->sarea_priv != (unsigned long )((struct _drm_i915_sarea *)0)) {
      (master_priv->sarea_priv)->perf_boxes = (master_priv->sarea_priv)->perf_boxes | 4;
    } else {
    }
  } else {
  }
  {
  msleep(1U);
  tmp = atomic_read((atomic_t const *)(& dev_priv->mm.wedged));
  }
  if (tmp != 0) {
    return (-11);
  } else {
  }
  if ((long )end - (long )jiffies >= 0L) {
    goto ldv_37798;
  } else {
    goto ldv_37799;
  }
  ldv_37799:
  {
  trace_i915_ring_wait_end(ring);
  }
  return (-16);
}
}
int intel_ring_begin(struct intel_ring_buffer *ring , int num_dwords )
{ struct drm_i915_private *dev_priv ;
  int n ;
  int ret ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  {
  {
  dev_priv = (struct drm_i915_private *)(ring->dev)->dev_private;
  n = num_dwords * 4;
  tmp = atomic_read((atomic_t const *)(& dev_priv->mm.wedged));
  tmp___0 = __builtin_expect((long )(tmp != 0), 0L);
  }
  if (tmp___0 != 0L) {
    return (-5);
  } else {
  }
  {
  tmp___2 = __builtin_expect((long )(ring->tail + (u32 )n > (u32 )ring->effective_size),
                             0L);
  }
  if (tmp___2 != 0L) {
    {
    ret = intel_wrap_ring_buffer(ring);
    tmp___1 = __builtin_expect((long )(ret != 0), 0L);
    }
    if (tmp___1 != 0L) {
      return (ret);
    } else {
    }
  } else {
  }
  {
  tmp___4 = __builtin_expect((long )(ring->space < n), 0L);
  }
  if (tmp___4 != 0L) {
    {
    ret = intel_wait_ring_buffer(ring, n);
    tmp___3 = __builtin_expect((long )(ret != 0), 0L);
    }
    if (tmp___3 != 0L) {
      return (ret);
    } else {
    }
  } else {
  }
  ring->space = ring->space - n;
  return (0);
}
}
void intel_ring_advance(struct intel_ring_buffer *ring )
{
  {
  {
  ring->tail = ring->tail & (u32 )(ring->size + -1);
  (*(ring->write_tail))(ring, ring->tail);
  }
  return;
}
}
static struct intel_ring_buffer const render_ring =
     {"render ring", (enum intel_ring_id )1, 8192U, (void *)0, (struct drm_device *)0,
    (struct drm_i915_gem_object *)0, 0U, 0U, 0, 131072, 0, {(u32 *)0, 0U, (struct drm_i915_gem_object *)0},
    {{{{0U}, 0U, 0U, (void *)0, {(struct lock_class_key *)0, {(struct lock_class *)0,
                                                              (struct lock_class *)0},
                                 (char const *)0, 0, 0UL}}}}, 0U, 0U, 0U, 0U, 0U,
    {0U, 0U}, & render_ring_get_irq, & render_ring_put_irq, & init_render_ring, & ring_write_tail,
    & render_ring_flush, & render_ring_add_request, & ring_get_seqno, & render_ring_dispatch_execbuffer,
    & render_ring_cleanup, {(struct list_head *)0, (struct list_head *)0}, {(struct list_head *)0,
                                                                            (struct list_head *)0},
    {(struct list_head *)0, (struct list_head *)0}, 0U, {{{{{0U}, 0U, 0U, (void *)0,
                                                            {(struct lock_class_key *)0,
                                                             {(struct lock_class *)0,
                                                              (struct lock_class *)0},
                                                             (char const *)0, 0,
                                                             0UL}}}}, {(struct list_head *)0,
                                                                       (struct list_head *)0}},
    {0ULL, 0UL, (enum drm_map_type )0, (enum drm_map_flags )0, (void *)0, 0}, (void *)0};
static struct intel_ring_buffer const bsd_ring =
     {"bsd ring", (enum intel_ring_id )2, 16384U, (void *)0, (struct drm_device *)0,
    (struct drm_i915_gem_object *)0, 0U, 0U, 0, 131072, 0, {(u32 *)0, 0U, (struct drm_i915_gem_object *)0},
    {{{{0U}, 0U, 0U, (void *)0, {(struct lock_class_key *)0, {(struct lock_class *)0,
                                                              (struct lock_class *)0},
                                 (char const *)0, 0, 0UL}}}}, 0U, 0U, 0U, 0U, 0U,
    {0U, 0U}, & bsd_ring_get_irq, & bsd_ring_put_irq, & init_ring_common, & ring_write_tail,
    & bsd_ring_flush, & ring_add_request, & ring_get_seqno, & ring_dispatch_execbuffer,
    (void (*)(struct intel_ring_buffer * ))0, {(struct list_head *)0, (struct list_head *)0},
    {(struct list_head *)0, (struct list_head *)0}, {(struct list_head *)0, (struct list_head *)0},
    0U, {{{{{0U}, 0U, 0U, (void *)0, {(struct lock_class_key *)0, {(struct lock_class *)0,
                                                                   (struct lock_class *)0},
                                      (char const *)0, 0, 0UL}}}}, {(struct list_head *)0,
                                                                      (struct list_head *)0}},
    {0ULL, 0UL, (enum drm_map_type )0, (enum drm_map_flags )0, (void *)0, 0}, (void *)0};
static void gen6_bsd_ring_write_tail(struct intel_ring_buffer *ring , u32 value )
{ drm_i915_private_t *dev_priv ;
  unsigned long timeout__ ;
  unsigned long tmp ;
  int ret__ ;
  struct thread_info *tmp___0 ;
  int pfo_ret__ ;
  int tmp___1 ;
  u32 tmp___2 ;
  {
  {
  dev_priv = (drm_i915_private_t *)(ring->dev)->dev_private;
  i915_write32___11(dev_priv, 73808U, 65537U);
  i915_write32___11(dev_priv, 74136U, 0U);
  tmp = msecs_to_jiffies((unsigned int const )50U);
  timeout__ = tmp + (unsigned long )jiffies;
  ret__ = 0;
  }
  goto ldv_37835;
  ldv_37834: ;
  if ((long )timeout__ - (long )jiffies < 0L) {
    ret__ = -110;
    goto ldv_37825;
  } else {
  }
  {
  tmp___0 = current_thread_info();
  }
  if ((tmp___0->preempt_count & -268435457) == 0) {
    if (1) {
      goto case_4;
    } else {
      goto switch_default;
      if (0) {
        __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
        goto ldv_37828;
        __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_37828;
        case_4:
        __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_37828;
        __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
        goto ldv_37828;
        switch_default:
        {
        __bad_percpu_size();
        }
      } else {
      }
    }
    ldv_37828:
    {
    tmp___1 = atomic_read((atomic_t const *)(& kgdb_active));
    }
    if (pfo_ret__ != tmp___1) {
      {
      msleep(1U);
      }
    } else {
    }
  } else {
  }
  ldv_37835:
  {
  tmp___2 = i915_read32___13(dev_priv, 73808U);
  }
  if ((tmp___2 & 8U) != 0U) {
    goto ldv_37834;
  } else {
    goto ldv_37825;
  }
  ldv_37825: ;
  if (ret__ != 0) {
    {
    drm_err("gen6_bsd_ring_write_tail", "timed out waiting for IDLE Indicator\n");
    }
  } else {
  }
  {
  i915_write32___11(dev_priv, ring->mmio_base + 48U, value);
  i915_write32___11(dev_priv, 73808U, 65536U);
  }
  return;
}
}
static int gen6_ring_flush(struct intel_ring_buffer *ring , u32 invalidate , u32 flush )
{ uint32_t cmd ;
  int ret ;
  {
  {
  ret = intel_ring_begin(ring, 4);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  cmd = 318767105U;
  if ((invalidate & 4294967230U) != 0U) {
    cmd = cmd | 262272U;
  } else {
  }
  {
  intel_ring_emit(ring, cmd);
  intel_ring_emit(ring, 0U);
  intel_ring_emit(ring, 0U);
  intel_ring_emit(ring, 0U);
  intel_ring_advance(ring);
  }
  return (0);
}
}
static int gen6_ring_dispatch_execbuffer(struct intel_ring_buffer *ring , u32 offset ,
                                         u32 len )
{ int ret ;
  {
  {
  ret = intel_ring_begin(ring, 2);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  intel_ring_emit(ring, 411042048U);
  intel_ring_emit(ring, offset);
  intel_ring_advance(ring);
  }
  return (0);
}
}
static bool gen6_render_ring_get_irq(struct intel_ring_buffer *ring )
{ bool tmp ;
  {
  {
  tmp = gen6_ring_get_irq(ring, 1U, 1U);
  }
  return (tmp);
}
}
static void gen6_render_ring_put_irq(struct intel_ring_buffer *ring )
{
  {
  return;
}
}
static bool gen6_bsd_ring_get_irq(struct intel_ring_buffer *ring )
{ bool tmp ;
  {
  {
  tmp = gen6_ring_get_irq(ring, 4096U, 4096U);
  }
  return (tmp);
}
}
static void gen6_bsd_ring_put_irq(struct intel_ring_buffer *ring )
{
  {
  return;
}
}
static struct intel_ring_buffer const gen6_bsd_ring =
     {"gen6 bsd ring", (enum intel_ring_id )2, 73728U, (void *)0, (struct drm_device *)0,
    (struct drm_i915_gem_object *)0, 0U, 0U, 0, 131072, 0, {(u32 *)0, 0U, (struct drm_i915_gem_object *)0},
    {{{{0U}, 0U, 0U, (void *)0, {(struct lock_class_key *)0, {(struct lock_class *)0,
                                                              (struct lock_class *)0},
                                 (char const *)0, 0, 0UL}}}}, 0U, 0U, 0U, 0U, 0U,
    {0U, 0U}, & gen6_bsd_ring_get_irq, & gen6_bsd_ring_put_irq, & init_ring_common,
    & gen6_bsd_ring_write_tail, & gen6_ring_flush, & gen6_add_request, & ring_get_seqno,
    & gen6_ring_dispatch_execbuffer, (void (*)(struct intel_ring_buffer * ))0, {(struct list_head *)0,
                                                                                (struct list_head *)0},
    {(struct list_head *)0, (struct list_head *)0}, {(struct list_head *)0, (struct list_head *)0},
    0U, {{{{{0U}, 0U, 0U, (void *)0, {(struct lock_class_key *)0, {(struct lock_class *)0,
                                                                   (struct lock_class *)0},
                                      (char const *)0, 0, 0UL}}}}, {(struct list_head *)0,
                                                                      (struct list_head *)0}},
    {0ULL, 0UL, (enum drm_map_type )0, (enum drm_map_flags )0, (void *)0, 0}, (void *)0};
static bool blt_ring_get_irq(struct intel_ring_buffer *ring )
{ bool tmp ;
  {
  {
  tmp = gen6_ring_get_irq(ring, 4194304U, 4194304U);
  }
  return (tmp);
}
}
static void blt_ring_put_irq(struct intel_ring_buffer *ring )
{
  {
  {
  gen6_ring_put_irq(ring, 4194304U, 4194304U);
  }
  return;
}
}
__inline static struct drm_i915_gem_object *to_blt_workaround(struct intel_ring_buffer *ring )
{
  {
  return ((struct drm_i915_gem_object *)ring->private);
}
}
static int blt_ring_init(struct intel_ring_buffer *ring )
{ struct drm_i915_gem_object *obj ;
  u32 *ptr ;
  int ret ;
  void *tmp ;
  u32 *tmp___0 ;
  u32 *tmp___1 ;
  int tmp___2 ;
  {
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)(ring->dev)->dev_private)->info)->gen) == 6U) {
    if ((unsigned int )((ring->dev)->pdev)->revision <= 7U) {
      {
      obj = i915_gem_alloc_object(ring->dev, 4096UL);
      }
      if ((unsigned long )obj == (unsigned long )((struct drm_i915_gem_object *)0)) {
        return (-12);
      } else {
      }
      {
      ret = i915_gem_object_pin(obj, 4096U, (bool )1);
      }
      if (ret != 0) {
        {
        drm_gem_object_unreference(& obj->base);
        }
        return (ret);
      } else {
      }
      {
      tmp = kmap(*(obj->pages));
      ptr = (u32 *)tmp;
      tmp___0 = ptr;
      ptr = ptr + 1;
      *tmp___0 = 83886080U;
      tmp___1 = ptr;
      ptr = ptr + 1;
      *tmp___1 = 0U;
      kunmap(*(obj->pages));
      ret = i915_gem_object_set_to_gtt_domain(obj, (bool )0);
      }
      if (ret != 0) {
        {
        i915_gem_object_unpin(obj);
        drm_gem_object_unreference(& obj->base);
        }
        return (ret);
      } else {
      }
      ring->private = (void *)obj;
    } else {
    }
  } else {
  }
  {
  tmp___2 = init_ring_common(ring);
  }
  return (tmp___2);
}
}
static int blt_ring_begin(struct intel_ring_buffer *ring , int num_dwords )
{ int ret ;
  int tmp ;
  struct drm_i915_gem_object *tmp___0 ;
  int tmp___1 ;
  {
  if ((unsigned long )ring->private != (unsigned long )((void *)0)) {
    {
    tmp = intel_ring_begin(ring, num_dwords + 2);
    ret = tmp;
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
    {
    intel_ring_emit(ring, 411041792U);
    tmp___0 = to_blt_workaround(ring);
    intel_ring_emit(ring, tmp___0->gtt_offset);
    }
    return (0);
  } else {
    {
    tmp___1 = intel_ring_begin(ring, 4);
    }
    return (tmp___1);
  }
}
}
static int blt_ring_flush(struct intel_ring_buffer *ring , u32 invalidate , u32 flush )
{ uint32_t cmd ;
  int ret ;
  {
  {
  ret = blt_ring_begin(ring, 4);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  cmd = 318767105U;
  if ((invalidate & 2U) != 0U) {
    cmd = cmd | 262144U;
  } else {
  }
  {
  intel_ring_emit(ring, cmd);
  intel_ring_emit(ring, 0U);
  intel_ring_emit(ring, 0U);
  intel_ring_emit(ring, 0U);
  intel_ring_advance(ring);
  }
  return (0);
}
}
static void blt_ring_cleanup(struct intel_ring_buffer *ring )
{
  {
  if ((unsigned long )ring->private == (unsigned long )((void *)0)) {
    return;
  } else {
  }
  {
  i915_gem_object_unpin((struct drm_i915_gem_object *)ring->private);
  drm_gem_object_unreference((struct drm_gem_object *)ring->private);
  ring->private = (void *)0;
  }
  return;
}
}
static struct intel_ring_buffer const gen6_blt_ring =
     {"blt ring", (enum intel_ring_id )4, 139264U, (void *)0, (struct drm_device *)0,
    (struct drm_i915_gem_object *)0, 0U, 0U, 0, 131072, 0, {(u32 *)0, 0U, (struct drm_i915_gem_object *)0},
    {{{{0U}, 0U, 0U, (void *)0, {(struct lock_class_key *)0, {(struct lock_class *)0,
                                                              (struct lock_class *)0},
                                 (char const *)0, 0, 0UL}}}}, 0U, 0U, 0U, 0U, 0U,
    {0U, 0U}, & blt_ring_get_irq, & blt_ring_put_irq, & blt_ring_init, & ring_write_tail,
    & blt_ring_flush, & gen6_add_request, & ring_get_seqno, & gen6_ring_dispatch_execbuffer,
    & blt_ring_cleanup, {(struct list_head *)0, (struct list_head *)0}, {(struct list_head *)0,
                                                                         (struct list_head *)0},
    {(struct list_head *)0, (struct list_head *)0}, 0U, {{{{{0U}, 0U, 0U, (void *)0,
                                                            {(struct lock_class_key *)0,
                                                             {(struct lock_class *)0,
                                                              (struct lock_class *)0},
                                                             (char const *)0, 0,
                                                             0UL}}}}, {(struct list_head *)0,
                                                                       (struct list_head *)0}},
    {0ULL, 0UL, (enum drm_map_type )0, (enum drm_map_flags )0, (void *)0, 0}, (void *)0};
int intel_init_render_ring_buffer(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  struct intel_ring_buffer *ring ;
  int tmp ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ring = (struct intel_ring_buffer *)(& dev_priv->ring);
  *ring = (struct intel_ring_buffer )render_ring;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 5U) {
    ring->add_request = & gen6_add_request;
    ring->irq_get = & gen6_render_ring_get_irq;
    ring->irq_put = & gen6_render_ring_put_irq;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    ring->add_request = & pc_render_add_request;
    ring->get_seqno = & pc_render_get_seqno;
  } else {
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) == 0U) {
    {
    ring->status_page.page_addr = (u32 *)(dev_priv->status_page_dmah)->vaddr;
    memset((void *)ring->status_page.page_addr, 0, 4096UL);
    }
  } else {
  }
  {
  tmp = intel_init_ring_buffer(dev, ring);
  }
  return (tmp);
}
}
int intel_render_ring_init_dri(struct drm_device *dev , u64 start , u32 size )
{ drm_i915_private_t *dev_priv ;
  struct intel_ring_buffer *ring ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ring = (struct intel_ring_buffer *)(& dev_priv->ring);
  *ring = (struct intel_ring_buffer )render_ring;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 5U) {
    ring->add_request = & gen6_add_request;
    ring->irq_get = & gen6_render_ring_get_irq;
    ring->irq_put = & gen6_render_ring_put_irq;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 5U) {
    ring->add_request = & pc_render_add_request;
    ring->get_seqno = & pc_render_get_seqno;
  } else {
  }
  {
  ring->dev = dev;
  INIT_LIST_HEAD(& ring->active_list);
  INIT_LIST_HEAD(& ring->request_list);
  INIT_LIST_HEAD(& ring->gpu_write_list);
  ring->size = (int )size;
  ring->effective_size = ring->size;
  }
  if ((ring->dev)->pci_device == 13687) {
    ring->effective_size = ring->effective_size + -128;
  } else {
  }
  {
  ring->map.offset = start;
  ring->map.size = (unsigned long )size;
  ring->map.type = (enum drm_map_type )0;
  ring->map.flags = (enum drm_map_flags )0;
  ring->map.mtrr = 0;
  drm_core_ioremap_wc(& ring->map, dev);
  }
  if ((unsigned long )ring->map.handle == (unsigned long )((void *)0)) {
    {
    drm_err("intel_render_ring_init_dri", "can not ioremap virtual address for ring buffer\n");
    }
    return (-12);
  } else {
  }
  ring->virtual_start = ring->map.handle;
  return (0);
}
}
int intel_init_bsd_ring_buffer(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  struct intel_ring_buffer *ring ;
  int tmp ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ring = (struct intel_ring_buffer *)(& dev_priv->ring) + 1UL;
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 6U) {
    *ring = (struct intel_ring_buffer )gen6_bsd_ring;
  } else
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 7U) {
    *ring = (struct intel_ring_buffer )gen6_bsd_ring;
  } else {
    *ring = (struct intel_ring_buffer )bsd_ring;
  }
  {
  tmp = intel_init_ring_buffer(dev, ring);
  }
  return (tmp);
}
}
int intel_init_blt_ring_buffer(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  struct intel_ring_buffer *ring ;
  int tmp ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  ring = (struct intel_ring_buffer *)(& dev_priv->ring) + 2UL;
  *ring = (struct intel_ring_buffer )gen6_blt_ring;
  tmp = intel_init_ring_buffer(dev, ring);
  }
  return (tmp);
}
}
static struct overlay_registers *intel_overlay_map_regs(struct intel_overlay *overlay )
{ drm_i915_private_t *dev_priv ;
  struct overlay_registers *regs ;
  void *tmp ;
  {
  dev_priv = (drm_i915_private_t *)(overlay->dev)->dev_private;
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)(overlay->dev)->dev_private)->info + 3UL) != 0U) {
    regs = (struct overlay_registers *)(((overlay->reg_bo)->phys_obj)->handle)->vaddr;
  } else {
    {
    tmp = io_mapping_map_atomic_wc(dev_priv->mm.gtt_mapping, (unsigned long )(overlay->reg_bo)->gtt_offset);
    regs = (struct overlay_registers *)tmp;
    }
  }
  return (regs);
}
}
static void intel_overlay_unmap_regs(struct intel_overlay *overlay , struct overlay_registers *regs )
{
  {
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)(overlay->dev)->dev_private)->info + 3UL) == 0U) {
    {
    io_mapping_unmap_atomic((void *)regs);
    }
  } else {
  }
  return;
}
}
static int intel_overlay_do_wait_request(struct intel_overlay *overlay , struct drm_i915_gem_request *request ,
                                         void (*tail)(struct intel_overlay * ) )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  int ret ;
  long tmp ;
  {
  {
  dev = overlay->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = __builtin_expect((long )(overlay->last_flip_req != 0U), 0L);
  }
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_overlay.c.p"),
                         "i" (229), "i" (12UL));
    ldv_37636: ;
    goto ldv_37636;
  } else {
  }
  {
  ret = i915_add_request((struct intel_ring_buffer *)(& dev_priv->ring), (struct drm_file *)0,
                         request);
  }
  if (ret != 0) {
    {
    kfree((void const *)request);
    }
    return (ret);
  } else {
  }
  {
  overlay->last_flip_req = request->seqno;
  overlay->flip_tail = tail;
  ret = i915_wait_request((struct intel_ring_buffer *)(& dev_priv->ring), overlay->last_flip_req);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  overlay->last_flip_req = 0U;
  return (0);
}
}
static int i830_activate_pipe_a(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  struct intel_crtc *crtc ;
  struct drm_crtc_helper_funcs *crtc_funcs ;
  struct drm_display_mode vesa_640x480 ;
  struct drm_display_mode *mode ;
  struct drm_crtc const *__mptr ;
  u32 tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  vesa_640x480.head.next = (struct list_head *)0;
  vesa_640x480.head.prev = (struct list_head *)0;
  vesa_640x480.base.id = 0U;
  vesa_640x480.base.type = 0U;
  vesa_640x480.name[0] = (char )'6';
  vesa_640x480.name[1] = (char )'4';
  vesa_640x480.name[2] = (char )'0';
  vesa_640x480.name[3] = (char )'x';
  vesa_640x480.name[4] = (char )'4';
  vesa_640x480.name[5] = (char )'8';
  vesa_640x480.name[6] = (char )'0';
  vesa_640x480.name[7] = (char )'\000';
  vesa_640x480.connector_count = 0;
  vesa_640x480.status = (enum drm_mode_status )0;
  vesa_640x480.type = 64;
  vesa_640x480.clock = 25175;
  vesa_640x480.hdisplay = 640;
  vesa_640x480.hsync_start = 656;
  vesa_640x480.hsync_end = 752;
  vesa_640x480.htotal = 800;
  vesa_640x480.hskew = 0;
  vesa_640x480.vdisplay = 480;
  vesa_640x480.vsync_start = 489;
  vesa_640x480.vsync_end = 492;
  vesa_640x480.vtotal = 525;
  vesa_640x480.vscan = 0;
  vesa_640x480.flags = 10U;
  vesa_640x480.width_mm = 0;
  vesa_640x480.height_mm = 0;
  vesa_640x480.clock_index = 0;
  vesa_640x480.synth_clock = 0;
  vesa_640x480.crtc_hdisplay = 0;
  vesa_640x480.crtc_hblank_start = 0;
  vesa_640x480.crtc_hblank_end = 0;
  vesa_640x480.crtc_hsync_start = 0;
  vesa_640x480.crtc_hsync_end = 0;
  vesa_640x480.crtc_htotal = 0;
  vesa_640x480.crtc_hskew = 0;
  vesa_640x480.crtc_vdisplay = 0;
  vesa_640x480.crtc_vblank_start = 0;
  vesa_640x480.crtc_vblank_end = 0;
  vesa_640x480.crtc_vsync_start = 0;
  vesa_640x480.crtc_vsync_end = 0;
  vesa_640x480.crtc_vtotal = 0;
  vesa_640x480.crtc_hadjusted = 0;
  vesa_640x480.crtc_vadjusted = 0;
  vesa_640x480.private_size = 0;
  vesa_640x480.private = (int *)0;
  vesa_640x480.private_flags = 0;
  vesa_640x480.vrefresh = 0;
  vesa_640x480.hsync = 0;
  __mptr = (struct drm_crtc const *)dev_priv->pipe_to_crtc_mapping[0];
  crtc = (struct intel_crtc *)__mptr;
  if (crtc->dpms_mode == 0) {
    return (0);
  } else {
  }
  {
  tmp = i915_read32(dev_priv, 458760U);
  }
  if ((int )tmp < 0) {
    return (0);
  } else {
  }
  crtc_funcs = (struct drm_crtc_helper_funcs *)crtc->base.helper_private;
  if ((unsigned long )crtc_funcs->dpms == (unsigned long )((void (*)(struct drm_crtc * ,
                                                                     int ))0)) {
    return (0);
  } else {
  }
  {
  drm_ut_debug_printk(2U, "drm", "i830_activate_pipe_a", "Enabling pipe A in order to enable overlay\n");
  mode = drm_mode_duplicate(dev, (struct drm_display_mode const *)(& vesa_640x480));
  drm_mode_set_crtcinfo(mode, 1);
  tmp___0 = drm_crtc_helper_set_mode(& crtc->base, mode, crtc->base.x, crtc->base.y,
                                     crtc->base.fb);
  }
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (0);
  } else {
  }
  {
  (*(crtc_funcs->dpms))(& crtc->base, 0);
  }
  return (1);
}
}
static void i830_deactivate_pipe_a(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  struct drm_crtc *crtc ;
  struct drm_crtc_helper_funcs *crtc_funcs ;
  {
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  crtc = dev_priv->pipe_to_crtc_mapping[0];
  crtc_funcs = (struct drm_crtc_helper_funcs *)crtc->helper_private;
  (*(crtc_funcs->dpms))(crtc, 3);
  }
  return;
}
}
static int intel_overlay_on(struct intel_overlay *overlay )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  struct drm_i915_gem_request *request ;
  int pipe_a_quirk ;
  int ret ;
  long tmp ;
  void *tmp___0 ;
  {
  {
  dev = overlay->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  pipe_a_quirk = 0;
  tmp = __builtin_expect((long )(overlay->active != 0), 0L);
  }
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_overlay.c.p"),
                         "i" (302), "i" (12UL));
    ldv_37662: ;
    goto ldv_37662;
  } else {
  }
  overlay->active = 1;
  if (dev->pci_device == 13687) {
    {
    pipe_a_quirk = i830_activate_pipe_a(dev);
    }
    if (pipe_a_quirk < 0) {
      return (pipe_a_quirk);
    } else {
    }
  } else {
  }
  {
  tmp___0 = kzalloc(64UL, 208U);
  request = (struct drm_i915_gem_request *)tmp___0;
  }
  if ((unsigned long )request == (unsigned long )((struct drm_i915_gem_request *)0)) {
    ret = -12;
    goto out;
  } else {
  }
  {
  ret = intel_ring_begin((struct intel_ring_buffer *)(& dev_priv->ring), 4);
  }
  if (ret != 0) {
    {
    kfree((void const *)request);
    }
    goto out;
  } else {
  }
  {
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 144703488U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), overlay->flip_addr | 1U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 25231360U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 0U);
  intel_ring_advance((struct intel_ring_buffer *)(& dev_priv->ring));
  ret = intel_overlay_do_wait_request(overlay, request, (void (*)(struct intel_overlay * ))0);
  }
  out: ;
  if (pipe_a_quirk != 0) {
    {
    i830_deactivate_pipe_a(dev);
    }
  } else {
  }
  return (ret);
}
}
static int intel_overlay_continue(struct intel_overlay *overlay , bool load_polyphase_filter )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  struct drm_i915_gem_request *request ;
  u32 flip_addr ;
  u32 tmp ;
  int ret ;
  long tmp___0 ;
  void *tmp___1 ;
  {
  {
  dev = overlay->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  flip_addr = overlay->flip_addr;
  tmp___0 = __builtin_expect((long )(overlay->active == 0), 0L);
  }
  if (tmp___0 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_overlay.c.p"),
                         "i" (348), "i" (12UL));
    ldv_37674: ;
    goto ldv_37674;
  } else {
  }
  {
  tmp___1 = kzalloc(64UL, 208U);
  request = (struct drm_i915_gem_request *)tmp___1;
  }
  if ((unsigned long )request == (unsigned long )((struct drm_i915_gem_request *)0)) {
    return (-12);
  } else {
  }
  if ((int )load_polyphase_filter) {
    flip_addr = flip_addr | 1U;
  } else {
  }
  {
  tmp = i915_read32(dev_priv, 196616U);
  }
  if ((tmp & 131072U) != 0U) {
    {
    drm_ut_debug_printk(1U, "drm", "intel_overlay_continue", "overlay underrun, DOVSTA: %x\n",
                        tmp);
    }
  } else {
  }
  {
  ret = intel_ring_begin((struct intel_ring_buffer *)(& dev_priv->ring), 2);
  }
  if (ret != 0) {
    {
    kfree((void const *)request);
    }
    return (ret);
  } else {
  }
  {
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 142606336U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), flip_addr);
  intel_ring_advance((struct intel_ring_buffer *)(& dev_priv->ring));
  ret = i915_add_request((struct intel_ring_buffer *)(& dev_priv->ring), (struct drm_file *)0,
                         request);
  }
  if (ret != 0) {
    {
    kfree((void const *)request);
    }
    return (ret);
  } else {
  }
  overlay->last_flip_req = request->seqno;
  return (0);
}
}
static void intel_overlay_release_old_vid_tail(struct intel_overlay *overlay )
{ struct drm_i915_gem_object *obj ;
  {
  {
  obj = overlay->old_vid_bo;
  i915_gem_object_unpin(obj);
  drm_gem_object_unreference(& obj->base);
  overlay->old_vid_bo = (struct drm_i915_gem_object *)0;
  }
  return;
}
}
static void intel_overlay_off_tail(struct intel_overlay *overlay )
{ struct drm_i915_gem_object *obj ;
  long tmp ;
  {
  {
  obj = overlay->vid_bo;
  tmp = __builtin_expect((long )((unsigned long )overlay->vid_bo == (unsigned long )((struct drm_i915_gem_object *)0)),
                         0L);
  }
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_overlay.c.p"),
                         "i" (396), "i" (12UL));
    ldv_37684: ;
    goto ldv_37684;
  } else {
  }
  {
  i915_gem_object_unpin(obj);
  drm_gem_object_unreference(& obj->base);
  overlay->vid_bo = (struct drm_i915_gem_object *)0;
  (overlay->crtc)->overlay = (struct intel_overlay *)0;
  overlay->crtc = (struct intel_crtc *)0;
  overlay->active = 0;
  }
  return;
}
}
static int intel_overlay_off(struct intel_overlay *overlay )
{ struct drm_device *dev ;
  struct drm_i915_private *dev_priv ;
  u32 flip_addr ;
  struct drm_i915_gem_request *request ;
  int ret ;
  long tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  {
  {
  dev = overlay->dev;
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  flip_addr = overlay->flip_addr;
  tmp = __builtin_expect((long )(overlay->active == 0), 0L);
  }
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_overlay.c.p"),
                         "i" (416), "i" (12UL));
    ldv_37693: ;
    goto ldv_37693;
  } else {
  }
  {
  tmp___0 = kzalloc(64UL, 208U);
  request = (struct drm_i915_gem_request *)tmp___0;
  }
  if ((unsigned long )request == (unsigned long )((struct drm_i915_gem_request *)0)) {
    return (-12);
  } else {
  }
  {
  flip_addr = flip_addr | 1U;
  ret = intel_ring_begin((struct intel_ring_buffer *)(& dev_priv->ring), 6);
  }
  if (ret != 0) {
    {
    kfree((void const *)request);
    }
    return (ret);
  } else {
  }
  {
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 142606336U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), flip_addr);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 25231360U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 146800640U);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), flip_addr);
  intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 25231360U);
  intel_ring_advance((struct intel_ring_buffer *)(& dev_priv->ring));
  tmp___1 = intel_overlay_do_wait_request(overlay, request, & intel_overlay_off_tail);
  }
  return (tmp___1);
}
}
static int intel_overlay_recover_from_interrupt(struct intel_overlay *overlay )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  int ret ;
  {
  dev = overlay->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  if (overlay->last_flip_req == 0U) {
    return (0);
  } else {
  }
  {
  ret = i915_wait_request((struct intel_ring_buffer *)(& dev_priv->ring), overlay->last_flip_req);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  if ((unsigned long )overlay->flip_tail != (unsigned long )((void (*)(struct intel_overlay * ))0)) {
    {
    (*(overlay->flip_tail))(overlay);
    }
  } else {
  }
  overlay->last_flip_req = 0U;
  return (0);
}
}
static int intel_overlay_release_old_vid(struct intel_overlay *overlay )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  int ret ;
  struct drm_i915_gem_request *request ;
  void *tmp ;
  u32 tmp___0 ;
  {
  dev = overlay->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  if ((unsigned long )overlay->old_vid_bo == (unsigned long )((struct drm_i915_gem_object *)0)) {
    return (0);
  } else {
  }
  {
  tmp___0 = i915_read32(dev_priv, 8364U);
  }
  if ((tmp___0 & 512U) != 0U) {
    {
    tmp = kzalloc(64UL, 208U);
    request = (struct drm_i915_gem_request *)tmp;
    }
    if ((unsigned long )request == (unsigned long )((struct drm_i915_gem_request *)0)) {
      return (-12);
    } else {
    }
    {
    ret = intel_ring_begin((struct intel_ring_buffer *)(& dev_priv->ring), 2);
    }
    if (ret != 0) {
      {
      kfree((void const *)request);
      }
      return (ret);
    } else {
    }
    {
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 25231360U);
    intel_ring_emit((struct intel_ring_buffer *)(& dev_priv->ring), 0U);
    intel_ring_advance((struct intel_ring_buffer *)(& dev_priv->ring));
    ret = intel_overlay_do_wait_request(overlay, request, & intel_overlay_release_old_vid_tail);
    }
    if (ret != 0) {
      return (ret);
    } else {
    }
  } else {
  }
  {
  intel_overlay_release_old_vid_tail(overlay);
  }
  return (0);
}
}
static int packed_depth_bytes(u32 format )
{
  {
  if ((int )(format & 65280U) == 256) {
    goto case_256;
  } else
  if ((int )(format & 65280U) == 512) {
    goto case_512;
  } else {
    goto switch_default;
    if (0) {
      case_256: ;
      return (4);
      case_512: ;
      switch_default: ;
      return (-22);
    } else {
    }
  }
}
}
static int packed_width_bytes(u32 format , short width )
{
  {
  if ((int )(format & 65280U) == 256) {
    goto case_256;
  } else {
    goto switch_default;
    if (0) {
      case_256: ;
      return ((int )width << 1);
      switch_default: ;
      return (-22);
    } else {
    }
  }
}
}
static int uv_hsubsampling(u32 format )
{
  {
  if ((int )(format & 65280U) == 256) {
    goto case_256;
  } else
  if ((int )(format & 65280U) == 768) {
    goto case_768;
  } else
  if ((int )(format & 65280U) == 512) {
    goto case_512;
  } else
  if ((int )(format & 65280U) == 1024) {
    goto case_1024;
  } else {
    goto switch_default;
    if (0) {
      case_256: ;
      case_768: ;
      return (2);
      case_512: ;
      case_1024: ;
      return (4);
      switch_default: ;
      return (-22);
    } else {
    }
  }
}
}
static int uv_vsubsampling(u32 format )
{
  {
  if ((int )(format & 65280U) == 768) {
    goto case_768;
  } else
  if ((int )(format & 65280U) == 1024) {
    goto case_1024;
  } else
  if ((int )(format & 65280U) == 256) {
    goto case_256;
  } else
  if ((int )(format & 65280U) == 512) {
    goto case_512;
  } else {
    goto switch_default;
    if (0) {
      case_768: ;
      case_1024: ;
      return (2);
      case_256: ;
      case_512: ;
      return (1);
      switch_default: ;
      return (-22);
    } else {
    }
  }
}
}
static u32 calc_swidthsw(struct drm_device *dev , u32 offset , u32 width )
{ u32 mask ;
  u32 shift ;
  u32 ret ;
  {
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 2U) {
    mask = 31U;
    shift = 5U;
  } else {
    mask = 63U;
    shift = 6U;
  }
  ret = (((offset + width) + mask) >> (int )shift) - (offset >> (int )shift);
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 2U) {
    ret = ret << 1;
  } else {
  }
  ret = ret - 1U;
  return (ret << 2);
}
}
static u16 const y_static_hcoeffs[85U] =
  { (u16 const )12288U, (u16 const )46240U, (u16 const )6448U, (u16 const )6432U,
        (u16 const )46240U, (u16 const )12288U, (u16 const )46336U, (u16 const )6608U,
        (u16 const )6272U, (u16 const )46144U, (u16 const )12288U, (u16 const )46400U,
        (u16 const )6792U, (u16 const )12160U, (u16 const )46048U, (u16 const )12288U,
        (u16 const )46464U, (u16 const )6960U, (u16 const )11808U, (u16 const )45952U,
        (u16 const )12288U, (u16 const )46528U, (u16 const )7128U, (u16 const )11456U,
        (u16 const )45856U, (u16 const )12320U, (u16 const )46560U, (u16 const )7264U,
        (u16 const )11136U, (u16 const )45760U, (u16 const )12320U, (u16 const )46560U,
        (u16 const )7416U, (u16 const )10784U, (u16 const )45664U, (u16 const )12320U,
        (u16 const )46560U, (u16 const )7552U, (u16 const )10464U, (u16 const )45568U,
        (u16 const )12320U, (u16 const )46528U, (u16 const )7688U, (u16 const )16192U,
        (u16 const )45504U, (u16 const )12320U, (u16 const )46464U, (u16 const )7800U,
        (u16 const )15584U, (u16 const )45408U, (u16 const )12352U, (u16 const )46368U,
        (u16 const )7896U, (u16 const )15008U, (u16 const )45344U, (u16 const )12352U,
        (u16 const )46240U, (u16 const )7984U, (u16 const )14464U, (u16 const )45280U,
        (u16 const )12352U, (u16 const )46080U, (u16 const )8056U, (u16 const )13952U,
        (u16 const )45216U, (u16 const )12320U, (u16 const )45888U, (u16 const )8120U,
        (u16 const )13472U, (u16 const )45152U, (u16 const )12320U, (u16 const )45632U,
        (u16 const )8160U, (u16 const )13024U, (u16 const )45120U, (u16 const )12320U,
        (u16 const )45376U, (u16 const )8184U, (u16 const )12640U, (u16 const )45088U,
        (u16 const )45056U, (u16 const )12288U, (u16 const )2048U, (u16 const )12288U,
        (u16 const )45056U};
static u16 const uv_static_hcoeffs[51U] =
  { (u16 const )12288U, (u16 const )6144U, (u16 const )6144U, (u16 const )45056U,
        (u16 const )6352U, (u16 const )11872U, (u16 const )45056U, (u16 const )6544U,
        (u16 const )11488U, (u16 const )45088U, (u16 const )6760U, (u16 const )11072U,
        (u16 const )45120U, (u16 const )6944U, (u16 const )10720U, (u16 const )45152U,
        (u16 const )7128U, (u16 const )10368U, (u16 const )45184U, (u16 const )7304U,
        (u16 const )15968U, (u16 const )45216U, (u16 const )7464U, (u16 const )15360U,
        (u16 const )45248U, (u16 const )7608U, (u16 const )14816U, (u16 const )45280U,
        (u16 const )7744U, (u16 const )14304U, (u16 const )45312U, (u16 const )7864U,
        (u16 const )13856U, (u16 const )45312U, (u16 const )7960U, (u16 const )13472U,
        (u16 const )45312U, (u16 const )8040U, (u16 const )13152U, (u16 const )45280U,
        (u16 const )8104U, (u16 const )12864U, (u16 const )45248U, (u16 const )8160U,
        (u16 const )12608U, (u16 const )45152U, (u16 const )8176U, (u16 const )12448U,
        (u16 const )12288U, (u16 const )2048U, (u16 const )12288U};
static void update_polyphase_filter(struct overlay_registers *regs )
{ size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  {
  __len = 170UL;
  if (__len > 63UL) {
    {
    __ret = memcpy((void *)(& regs->Y_HCOEFS), (void const *)(& y_static_hcoeffs),
                     __len);
    }
  } else {
    {
    __ret = memcpy((void *)(& regs->Y_HCOEFS), (void const *)(& y_static_hcoeffs),
                             __len);
    }
  }
  __len___0 = 102UL;
  if (__len___0 > 63UL) {
    {
    __ret___0 = memcpy((void *)(& regs->UV_HCOEFS), (void const *)(& uv_static_hcoeffs),
                         __len___0);
    }
  } else {
    {
    __ret___0 = memcpy((void *)(& regs->UV_HCOEFS), (void const *)(& uv_static_hcoeffs),
                                 __len___0);
    }
  }
  return;
}
}
static bool update_scaling_factors(struct intel_overlay *overlay , struct overlay_registers *regs ,
                                   struct put_image_params *params )
{ u32 xscale ;
  u32 yscale ;
  u32 xscale_UV ;
  u32 yscale_UV ;
  bool scale_changed ;
  int uv_hscale ;
  int tmp ;
  int uv_vscale ;
  int tmp___0 ;
  {
  {
  scale_changed = (bool )0;
  tmp = uv_hsubsampling((u32 )params->format);
  uv_hscale = tmp;
  tmp___0 = uv_vsubsampling((u32 )params->format);
  uv_vscale = tmp___0;
  }
  if ((int )params->dst_w > 1) {
    xscale = (u32 )((((int )params->src_scan_w + -1) << 12) / (int )params->dst_w);
  } else {
    xscale = 4096U;
  }
  if ((int )params->dst_h > 1) {
    yscale = (u32 )((((int )params->src_scan_h + -1) << 12) / (int )params->dst_h);
  } else {
    yscale = 4096U;
  }
  xscale_UV = xscale / (u32 )uv_hscale;
  yscale_UV = yscale / (u32 )uv_vscale;
  xscale = xscale_UV * (u32 )uv_hscale;
  yscale = yscale_UV * (u32 )uv_vscale;
  if (overlay->old_xscale != xscale) {
    scale_changed = (bool )1;
  } else
  if (overlay->old_yscale != yscale) {
    scale_changed = (bool )1;
  } else {
  }
  overlay->old_xscale = xscale;
  overlay->old_yscale = yscale;
  regs->YRGBSCALE = ((yscale << 20) | ((xscale >> 12) << 16)) | ((xscale & 4095U) << 3);
  regs->UVSCALE = ((yscale_UV << 20) | ((xscale_UV >> 12) << 16)) | ((xscale_UV & 4095U) << 3);
  regs->UVSCALEV = ((yscale >> 12) << 16) | (yscale_UV >> 12);
  if ((int )scale_changed) {
    {
    update_polyphase_filter(regs);
    }
  } else {
  }
  return (scale_changed);
}
}
static void update_colorkey(struct intel_overlay *overlay , struct overlay_registers *regs )
{ u32 key ;
  {
  key = overlay->color_key;
  if (((overlay->crtc)->base.fb)->bits_per_pixel == 8) {
    goto case_8;
  } else
  if (((overlay->crtc)->base.fb)->bits_per_pixel == 16) {
    goto case_16;
  } else
  if (((overlay->crtc)->base.fb)->bits_per_pixel == 24) {
    goto case_24;
  } else
  if (((overlay->crtc)->base.fb)->bits_per_pixel == 32) {
    goto case_32;
  } else
  if (0) {
    case_8:
    regs->DCLRKV = 0U;
    regs->DCLRKM = 2164260863U;
    goto ldv_37787;
    case_16: ;
    if (((overlay->crtc)->base.fb)->depth == 15U) {
      regs->DCLRKV = (((key & 31744U) << 9) | ((key & 992U) << 6)) | ((key << 3) & 255U);
      regs->DCLRKM = 2147944199U;
    } else {
      regs->DCLRKV = (((key & 63488U) << 8) | ((key & 2016U) << 5)) | ((key << 3) & 255U);
      regs->DCLRKM = 2147943175U;
    }
    goto ldv_37787;
    case_24: ;
    case_32:
    regs->DCLRKV = key;
    regs->DCLRKM = 2147483648U;
    goto ldv_37787;
  } else {
  }
  ldv_37787: ;
  return;
}
}
static u32 overlay_cmd_reg(struct put_image_params *params )
{ u32 cmd ;
  {
  cmd = 1U;
  if (params->format & 1) {
    if ((params->format & 65280) == 256) {
      goto case_256;
    } else
    if ((params->format & 65280) == 768) {
      goto case_768;
    } else
    if ((params->format & 65280) == 512) {
      goto case_512;
    } else
    if ((params->format & 65280) == 1024) {
      goto case_1024;
    } else
    if (0) {
      case_256:
      cmd = cmd | 13312U;
      goto ldv_37796;
      case_768:
      cmd = cmd | 12288U;
      goto ldv_37796;
      case_512: ;
      case_1024:
      cmd = cmd | 14336U;
      goto ldv_37796;
    } else {
    }
    ldv_37796: ;
  } else {
    if ((params->format & 65280) == 256) {
      goto case_256___0;
    } else
    if ((params->format & 65280) == 512) {
      goto case_512___0;
    } else
    if (0) {
      case_256___0:
      cmd = cmd | 8192U;
      goto ldv_37801;
      case_512___0:
      cmd = cmd | 9216U;
      goto ldv_37801;
    } else {
    }
    ldv_37801: ;
    if ((params->format & 16711680) == 0) {
      goto case_0;
    } else
    if ((params->format & 16711680) == 65536) {
      goto case_65536;
    } else
    if ((params->format & 16711680) == 131072) {
      goto case_131072;
    } else
    if ((params->format & 16711680) == 196608) {
      goto case_196608;
    } else
    if (0) {
      case_0: ;
      goto ldv_37804;
      case_65536:
      cmd = cmd | 16384U;
      goto ldv_37804;
      case_131072:
      cmd = cmd | 32768U;
      goto ldv_37804;
      case_196608:
      cmd = cmd | 49152U;
      goto ldv_37804;
    } else {
    }
    ldv_37804: ;
  }
  return (cmd);
}
}
static int intel_overlay_do_put_image(struct intel_overlay *overlay , struct drm_i915_gem_object *new_bo ,
                                      struct put_image_params *params )
{ int ret ;
  int tmp_width ;
  struct overlay_registers *regs ;
  bool scale_changed ;
  struct drm_device *dev ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  unsigned int tmp___4 ;
  int uv_hscale ;
  int tmp___5 ;
  int uv_vscale ;
  int tmp___6 ;
  u32 tmp_U ;
  u32 tmp_V ;
  u32 __max1 ;
  u32 __max2 ;
  u32 tmp___7 ;
  {
  {
  scale_changed = (bool )0;
  dev = overlay->dev;
  tmp = mutex_is_locked(& dev->struct_mutex);
  tmp___0 = __builtin_expect((long )(tmp == 0), 0L);
  }
  if (tmp___0 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_overlay.c.p"),
                         "i" (775), "i" (12UL));
    ldv_37818: ;
    goto ldv_37818;
  } else {
  }
  {
  tmp___1 = mutex_is_locked(& dev->mode_config.mutex);
  tmp___2 = __builtin_expect((long )(tmp___1 == 0), 0L);
  }
  if (tmp___2 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_overlay.c.p"),
                         "i" (776), "i" (12UL));
    ldv_37819: ;
    goto ldv_37819;
  } else {
  }
  {
  tmp___3 = __builtin_expect((long )((unsigned long )overlay == (unsigned long )((struct intel_overlay *)0)),
                             0L);
  }
  if (tmp___3 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_overlay.c.p"),
                         "i" (777), "i" (12UL));
    ldv_37820: ;
    goto ldv_37820;
  } else {
  }
  {
  ret = intel_overlay_release_old_vid(overlay);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  ret = i915_gem_object_pin(new_bo, 4096U, (bool )1);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  ret = i915_gem_object_set_to_gtt_domain(new_bo, (bool )0);
  }
  if (ret != 0) {
    goto out_unpin;
  } else {
  }
  {
  ret = i915_gem_object_put_fence(new_bo);
  }
  if (ret != 0) {
    goto out_unpin;
  } else {
  }
  if (overlay->active == 0) {
    {
    regs = intel_overlay_map_regs(overlay);
    }
    if ((unsigned long )regs == (unsigned long )((struct overlay_registers *)0)) {
      ret = -12;
      goto out_unpin;
    } else {
    }
    regs->OCONFIG = 8U;
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)(overlay->dev)->dev_private)->info)->gen) == 4U) {
      regs->OCONFIG = regs->OCONFIG | 32U;
    } else {
    }
    if ((unsigned int )(overlay->crtc)->pipe == 0U) {
      tmp___4 = 0U;
    } else {
      tmp___4 = 262144U;
    }
    {
    regs->OCONFIG = regs->OCONFIG | tmp___4;
    intel_overlay_unmap_regs(overlay, regs);
    ret = intel_overlay_on(overlay);
    }
    if (ret != 0) {
      goto out_unpin;
    } else {
    }
  } else {
  }
  {
  regs = intel_overlay_map_regs(overlay);
  }
  if ((unsigned long )regs == (unsigned long )((struct overlay_registers *)0)) {
    ret = -12;
    goto out_unpin;
  } else {
  }
  regs->DWINPOS = (u32 )(((int )params->dst_y << 16) | (int )params->dst_x);
  regs->DWINSZ = (u32 )(((int )params->dst_h << 16) | (int )params->dst_w);
  if ((params->format & 2) != 0) {
    {
    tmp_width = packed_width_bytes((u32 )params->format, (short )((int )params->src_w));
    }
  } else {
    tmp_width = (int )params->src_w;
  }
  {
  regs->SWIDTH = (u32 )params->src_w;
  regs->SWIDTHSW = calc_swidthsw(overlay->dev, (u32 )params->offset_Y, (u32 )tmp_width);
  regs->SHEIGHT = (u32 )params->src_h;
  regs->OBUF_0Y = new_bo->gtt_offset + (uint32_t )params->offset_Y;
  regs->OSTRIDE = (u32 )params->stride_Y;
  }
  if (params->format & 1) {
    {
    tmp___5 = uv_hsubsampling((u32 )params->format);
    uv_hscale = tmp___5;
    tmp___6 = uv_vsubsampling((u32 )params->format);
    uv_vscale = tmp___6;
    regs->SWIDTH = regs->SWIDTH | (u32 )((int )params->src_w / uv_hscale << 16);
    tmp_U = calc_swidthsw(overlay->dev, (u32 )params->offset_U, (u32 )((int )params->src_w / uv_hscale));
    tmp_V = calc_swidthsw(overlay->dev, (u32 )params->offset_V, (u32 )((int )params->src_w / uv_hscale));
    __max1 = tmp_U;
    __max2 = tmp_V;
    }
    if (__max1 > __max2) {
      tmp___7 = __max1;
    } else {
      tmp___7 = __max2;
    }
    regs->SWIDTHSW = regs->SWIDTHSW | (tmp___7 << 16);
    regs->SHEIGHT = regs->SHEIGHT | (u32 )((int )params->src_h / uv_vscale << 16);
    regs->OBUF_0U = new_bo->gtt_offset + (uint32_t )params->offset_U;
    regs->OBUF_0V = new_bo->gtt_offset + (uint32_t )params->offset_V;
    regs->OSTRIDE = regs->OSTRIDE | (u32 )((int )params->stride_UV << 16);
  } else {
  }
  {
  scale_changed = update_scaling_factors(overlay, regs, params);
  update_colorkey(overlay, regs);
  regs->OCMD = overlay_cmd_reg(params);
  intel_overlay_unmap_regs(overlay, regs);
  ret = intel_overlay_continue(overlay, (bool )((int )scale_changed));
  }
  if (ret != 0) {
    goto out_unpin;
  } else {
  }
  overlay->old_vid_bo = overlay->vid_bo;
  overlay->vid_bo = new_bo;
  return (0);
  out_unpin:
  {
  i915_gem_object_unpin(new_bo);
  }
  return (ret);
}
}
int intel_overlay_switch_off(struct intel_overlay *overlay )
{ struct overlay_registers *regs ;
  struct drm_device *dev ;
  int ret ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  {
  {
  dev = overlay->dev;
  tmp = mutex_is_locked(& dev->struct_mutex);
  tmp___0 = __builtin_expect((long )(tmp == 0), 0L);
  }
  if (tmp___0 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_overlay.c.p"),
                         "i" (878), "i" (12UL));
    ldv_37835: ;
    goto ldv_37835;
  } else {
  }
  {
  tmp___1 = mutex_is_locked(& dev->mode_config.mutex);
  tmp___2 = __builtin_expect((long )(tmp___1 == 0), 0L);
  }
  if (tmp___2 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_overlay.c.p"),
                         "i" (879), "i" (12UL));
    ldv_37836: ;
    goto ldv_37836;
  } else {
  }
  {
  ret = intel_overlay_recover_from_interrupt(overlay);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  if (overlay->active == 0) {
    return (0);
  } else {
  }
  {
  ret = intel_overlay_release_old_vid(overlay);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  regs = intel_overlay_map_regs(overlay);
  regs->OCMD = 0U;
  intel_overlay_unmap_regs(overlay, regs);
  ret = intel_overlay_off(overlay);
  }
  if (ret != 0) {
    return (ret);
  } else {
  }
  {
  intel_overlay_off_tail(overlay);
  }
  return (0);
}
}
static int check_overlay_possible_on_crtc(struct intel_overlay *overlay , struct intel_crtc *crtc )
{ drm_i915_private_t *dev_priv ;
  u32 tmp ;
  {
  dev_priv = (drm_i915_private_t *)(overlay->dev)->dev_private;
  if (! crtc->active) {
    return (-22);
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)(overlay->dev)->dev_private)->info)->gen) <= 3U) {
    {
    tmp = i915_read32(dev_priv, (unsigned int )crtc->pipe * 4096U + 458760U);
    }
    if ((tmp & 3221225472U) != 2147483648U) {
      return (-22);
    } else {
    }
  } else {
  }
  return (0);
}
}
static void update_pfit_vscale_ratio(struct intel_overlay *overlay )
{ struct drm_device *dev ;
  drm_i915_private_t *dev_priv ;
  u32 pfit_control ;
  u32 tmp ;
  u32 ratio ;
  u32 tmp___0 ;
  {
  {
  dev = overlay->dev;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  tmp = i915_read32(dev_priv, 397872U);
  pfit_control = tmp;
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) > 3U) {
    {
    tmp___0 = i915_read32(dev_priv, 397876U);
    ratio = tmp___0 >> 16;
    }
  } else {
    if ((pfit_control & 512U) != 0U) {
      {
      ratio = i915_read32(dev_priv, 397880U);
      }
    } else {
      {
      ratio = i915_read32(dev_priv, 397876U);
      }
    }
    ratio = ratio >> 20;
  }
  overlay->pfit_vscale_ratio = ratio;
  return;
}
}
static int check_overlay_dst(struct intel_overlay *overlay , struct drm_intel_overlay_put_image *rec )
{ struct drm_display_mode *mode ;
  {
  mode = & (overlay->crtc)->base.mode;
  if ((int )rec->dst_x < mode->crtc_hdisplay) {
    if ((int )rec->dst_x + (int )rec->dst_width <= mode->crtc_hdisplay) {
      if ((int )rec->dst_y < mode->crtc_vdisplay) {
        if ((int )rec->dst_y + (int )rec->dst_height <= mode->crtc_vdisplay) {
          return (0);
        } else {
          return (-22);
        }
      } else {
        return (-22);
      }
    } else {
      return (-22);
    }
  } else {
    return (-22);
  }
}
}
static int check_overlay_scaling(struct put_image_params *rec )
{ u32 tmp ;
  {
  tmp = (u32 )(((int )rec->src_scan_h << 16) / (int )rec->dst_h >> 16);
  if (tmp > 7U) {
    return (-22);
  } else {
  }
  tmp = (u32 )(((int )rec->src_scan_w << 16) / (int )rec->dst_w >> 16);
  if (tmp > 7U) {
    return (-22);
  } else {
  }
  return (0);
}
}
static int check_overlay_src(struct drm_device *dev , struct drm_intel_overlay_put_image *rec ,
                             struct drm_i915_gem_object *new_bo )
{ int uv_hscale ;
  int tmp ;
  int uv_vscale ;
  int tmp___0 ;
  u32 stride_mask ;
  int depth ;
  u32 tmp___1 ;
  int tmp___2 ;
  {
  {
  tmp = uv_hsubsampling(rec->flags);
  uv_hscale = tmp;
  tmp___0 = uv_vsubsampling(rec->flags);
  uv_vscale = tmp___0;
  }
  if (dev->pci_device == 9570) {
    goto _L;
  } else
  if (dev->pci_device == 13687) {
    _L:
    if ((unsigned int )rec->src_height > 1088U) {
      return (-22);
    } else
    if ((unsigned int )rec->src_width > 1024U) {
      return (-22);
    } else
    if ((unsigned int )rec->src_height > 2046U) {
      return (-22);
    } else
    if ((unsigned int )rec->src_width > 2048U) {
      return (-22);
    } else {
    }
  } else {
  }
  if ((unsigned int )rec->src_height <= 11U) {
    return (-22);
  } else
  if ((unsigned int )rec->src_width <= 19U) {
    return (-22);
  } else {
  }
  if ((int )(rec->flags & 255U) == 3) {
    goto case_3;
  } else
  if ((int )(rec->flags & 255U) == 2) {
    goto case_2;
  } else
  if ((int )(rec->flags & 255U) == 1) {
    goto case_1;
  } else {
    goto switch_default;
    if (0) {
      case_3: ;
      return (-22);
      case_2: ;
      if (uv_vscale != 1) {
        return (-22);
      } else {
      }
      {
      depth = packed_depth_bytes(rec->flags);
      }
      if (depth < 0) {
        return (depth);
      } else {
      }
      rec->stride_UV = (__u16 )0U;
      rec->offset_U = 0U;
      rec->offset_V = 0U;
      if (rec->offset_Y % (__u32 )depth != 0U) {
        return (-22);
      } else {
      }
      goto ldv_37870;
      case_1: ;
      if (uv_vscale < 0) {
        return (-22);
      } else
      if (uv_hscale < 0) {
        return (-22);
      } else {
      }
      goto ldv_37870;
      switch_default: ;
      return (-22);
    } else {
    }
  }
  ldv_37870: ;
  if ((int )rec->src_width % uv_hscale != 0) {
    return (-22);
  } else {
  }
  if (dev->pci_device == 13687) {
    stride_mask = 255U;
  } else
  if (dev->pci_device == 9570) {
    stride_mask = 255U;
  } else {
    stride_mask = 63U;
  }
  if (((u32 )rec->stride_Y & stride_mask) != 0U) {
    return (-22);
  } else
  if (((u32 )rec->stride_UV & stride_mask) != 0U) {
    return (-22);
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 4U) {
    if ((unsigned int )rec->stride_Y <= 511U) {
      return (-22);
    } else {
    }
  } else {
  }
  if ((rec->flags & 255U) == 1U) {
    tmp___1 = 4096U;
  } else {
    tmp___1 = 8192U;
  }
  if ((u32 )rec->stride_Y > tmp___1) {
    return (-22);
  } else
  if ((unsigned int )rec->stride_UV > 2048U) {
    return (-22);
  } else {
  }
  if ((int )(rec->flags & 255U) == 3) {
    goto case_3___0;
  } else
  if ((int )(rec->flags & 255U) == 2) {
    goto case_2___0;
  } else
  if ((int )(rec->flags & 255U) == 1) {
    goto case_1___0;
  } else
  if (0) {
    case_3___0: ;
    case_2___0:
    {
    tmp___2 = packed_width_bytes(rec->flags, (short )((int )((short )rec->src_width)));
    }
    if (tmp___2 > (int )rec->stride_Y) {
      return (-22);
    } else {
    }
    tmp___1 = (u32 )((int )rec->stride_Y * (int )rec->src_height);
    if ((size_t )(rec->offset_Y + tmp___1) > new_bo->base.size) {
      return (-22);
    } else {
    }
    goto ldv_37875;
    case_1___0: ;
    if ((int )rec->src_width > (int )rec->stride_Y) {
      return (-22);
    } else {
    }
    if ((int )rec->src_width / uv_hscale > (int )rec->stride_UV) {
      return (-22);
    } else {
    }
    tmp___1 = (u32 )((int )rec->stride_Y * (int )rec->src_height);
    if ((size_t )(rec->offset_Y + tmp___1) > new_bo->base.size) {
      return (-22);
    } else {
    }
    tmp___1 = (u32 )((int )rec->stride_UV * ((int )rec->src_height / uv_vscale));
    if ((size_t )(rec->offset_U + tmp___1) > new_bo->base.size) {
      return (-22);
    } else
    if ((size_t )(rec->offset_V + tmp___1) > new_bo->base.size) {
      return (-22);
    } else {
    }
    goto ldv_37875;
  } else {
  }
  ldv_37875: ;
  return (0);
}
}
static int intel_panel_fitter_pipe(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  u32 pfit_control ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if (dev->pci_device == 13687) {
    return (-1);
  } else {
  }
  {
  pfit_control = i915_read32(dev_priv, 397872U);
  }
  if ((int )pfit_control >= 0) {
    return (-1);
  } else {
  }
  if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 4U) {
    return ((int )(pfit_control >> 29) & 3);
  } else {
  }
  return (1);
}
}
int intel_overlay_put_image(struct drm_device *dev , void *data , struct drm_file *file_priv )
{ struct drm_intel_overlay_put_image *put_image_rec ;
  drm_i915_private_t *dev_priv ;
  struct intel_overlay *overlay ;
  struct drm_mode_object *drmmode_obj ;
  struct intel_crtc *crtc ;
  struct drm_i915_gem_object *new_bo ;
  struct put_image_params *params ;
  int ret ;
  void *tmp ;
  struct drm_crtc const *__mptr ;
  struct drm_mode_object const *__mptr___0 ;
  struct drm_gem_object const *__mptr___1 ;
  struct drm_gem_object *tmp___0 ;
  struct drm_display_mode *mode ;
  int tmp___1 ;
  {
  put_image_rec = (struct drm_intel_overlay_put_image *)data;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  if ((unsigned long )dev_priv == (unsigned long )((drm_i915_private_t *)0)) {
    {
    drm_err("intel_overlay_put_image", "called with no initialization\n");
    }
    return (-22);
  } else {
  }
  overlay = dev_priv->overlay;
  if ((unsigned long )overlay == (unsigned long )((struct intel_overlay *)0)) {
    {
    drm_ut_debug_printk(1U, "drm", "intel_overlay_put_image", "userspace bug: no overlay\n");
    }
    return (-19);
  } else {
  }
  if ((put_image_rec->flags & 16777216U) == 0U) {
    {
    mutex_lock_nested(& dev->mode_config.mutex, 0U);
    mutex_lock_nested(& dev->struct_mutex, 0U);
    ret = intel_overlay_switch_off(overlay);
    mutex_unlock(& dev->struct_mutex);
    mutex_unlock(& dev->mode_config.mutex);
    }
    return (ret);
  } else {
  }
  {
  tmp = kmalloc(36UL, 208U);
  params = (struct put_image_params *)tmp;
  }
  if ((unsigned long )params == (unsigned long )((struct put_image_params *)0)) {
    return (-12);
  } else {
  }
  {
  drmmode_obj = drm_mode_object_find(dev, put_image_rec->crtc_id, 3435973836U);
  }
  if ((unsigned long )drmmode_obj == (unsigned long )((struct drm_mode_object *)0)) {
    ret = -2;
    goto out_free;
  } else {
  }
  {
  __mptr___0 = (struct drm_mode_object const *)drmmode_obj;
  __mptr = (struct drm_crtc const *)((struct drm_crtc *)__mptr___0 + 0x0fffffffffffffe8UL);
  crtc = (struct intel_crtc *)__mptr;
  tmp___0 = drm_gem_object_lookup(dev, file_priv, put_image_rec->bo_handle);
  __mptr___1 = (struct drm_gem_object const *)tmp___0;
  new_bo = (struct drm_i915_gem_object *)__mptr___1;
  }
  if ((unsigned long )(& new_bo->base) == (unsigned long )((struct drm_gem_object *)0)) {
    ret = -2;
    goto out_free;
  } else {
  }
  {
  mutex_lock_nested(& dev->mode_config.mutex, 0U);
  mutex_lock_nested(& dev->struct_mutex, 0U);
  }
  if ((unsigned int )*((unsigned char *)new_bo + 225UL) != 0U) {
    {
    drm_err("intel_overlay_put_image", "buffer used for overlay image can not be tiled\n");
    ret = -22;
    }
    goto out_unlock;
  } else {
  }
  {
  ret = intel_overlay_recover_from_interrupt(overlay);
  }
  if (ret != 0) {
    goto out_unlock;
  } else {
  }
  if ((unsigned long )overlay->crtc != (unsigned long )crtc) {
    {
    mode = & crtc->base.mode;
    ret = intel_overlay_switch_off(overlay);
    }
    if (ret != 0) {
      goto out_unlock;
    } else {
    }
    {
    ret = check_overlay_possible_on_crtc(overlay, crtc);
    }
    if (ret != 0) {
      goto out_unlock;
    } else {
    }
    overlay->crtc = crtc;
    crtc->overlay = overlay;
    if (mode->hdisplay > 1024) {
      {
      tmp___1 = intel_panel_fitter_pipe(dev);
      }
      if ((unsigned int )tmp___1 == (unsigned int )crtc->pipe) {
        {
        overlay->pfit_active = 1;
        update_pfit_vscale_ratio(overlay);
        }
      } else {
        overlay->pfit_active = 0;
      }
    } else {
      overlay->pfit_active = 0;
    }
  } else {
  }
  {
  ret = check_overlay_dst(overlay, put_image_rec);
  }
  if (ret != 0) {
    goto out_unlock;
  } else {
  }
  if (overlay->pfit_active != 0) {
    params->dst_y = (short )(((unsigned int )put_image_rec->dst_y << 12) / overlay->pfit_vscale_ratio);
    params->dst_h = (short )((unsigned int )((unsigned short )(((unsigned int )put_image_rec->dst_height << 12) / overlay->pfit_vscale_ratio)) + 1U);
  } else {
    params->dst_y = (short )put_image_rec->dst_y;
    params->dst_h = (short )put_image_rec->dst_height;
  }
  params->dst_x = (short )put_image_rec->dst_x;
  params->dst_w = (short )put_image_rec->dst_width;
  params->src_w = (short )put_image_rec->src_width;
  params->src_h = (short )put_image_rec->src_height;
  params->src_scan_w = (short )put_image_rec->src_scan_width;
  params->src_scan_h = (short )put_image_rec->src_scan_height;
  if ((int )params->src_scan_h > (int )params->src_h) {
    ret = -22;
    goto out_unlock;
  } else
  if ((int )params->src_scan_w > (int )params->src_w) {
    ret = -22;
    goto out_unlock;
  } else {
  }
  {
  ret = check_overlay_src(dev, put_image_rec, new_bo);
  }
  if (ret != 0) {
    goto out_unlock;
  } else {
  }
  {
  params->format = (int )put_image_rec->flags & 16777215;
  params->stride_Y = (short )put_image_rec->stride_Y;
  params->stride_UV = (short )put_image_rec->stride_UV;
  params->offset_Y = (int )put_image_rec->offset_Y;
  params->offset_U = (int )put_image_rec->offset_U;
  params->offset_V = (int )put_image_rec->offset_V;
  ret = check_overlay_scaling(params);
  }
  if (ret != 0) {
    goto out_unlock;
  } else {
  }
  {
  ret = intel_overlay_do_put_image(overlay, new_bo, params);
  }
  if (ret != 0) {
    goto out_unlock;
  } else {
  }
  {
  mutex_unlock(& dev->struct_mutex);
  mutex_unlock(& dev->mode_config.mutex);
  kfree((void const *)params);
  }
  return (0);
  out_unlock:
  {
  mutex_unlock(& dev->struct_mutex);
  mutex_unlock(& dev->mode_config.mutex);
  drm_gem_object_unreference_unlocked(& new_bo->base);
  }
  out_free:
  {
  kfree((void const *)params);
  }
  return (ret);
}
}
static void update_reg_attrs(struct intel_overlay *overlay , struct overlay_registers *regs )
{
  {
  regs->OCLRC0 = (overlay->contrast << 18) | (overlay->brightness & 255U);
  regs->OCLRC1 = overlay->saturation;
  return;
}
}
static bool check_gamma_bounds(u32 gamma1 , u32 gamma2 )
{ int i ;
  {
  if ((gamma1 & 4278190080U) != 0U) {
    return ((bool )0);
  } else
  if ((gamma2 & 4278190080U) != 0U) {
    return ((bool )0);
  } else {
  }
  i = 0;
  goto ldv_37915;
  ldv_37914: ;
  if (((gamma1 >> i * 8) & 255U) >= ((gamma2 >> i * 8) & 255U)) {
    return ((bool )0);
  } else {
  }
  i = i + 1;
  ldv_37915: ;
  if (i <= 2) {
    goto ldv_37914;
  } else {
    goto ldv_37916;
  }
  ldv_37916: ;
  return ((bool )1);
}
}
static bool check_gamma5_errata(u32 gamma5 )
{ int i ;
  {
  i = 0;
  goto ldv_37922;
  ldv_37921: ;
  if (((gamma5 >> i * 8) & 255U) == 128U) {
    return ((bool )0);
  } else {
  }
  i = i + 1;
  ldv_37922: ;
  if (i <= 2) {
    goto ldv_37921;
  } else {
    goto ldv_37923;
  }
  ldv_37923: ;
  return ((bool )1);
}
}
static int check_gamma(struct drm_intel_overlay_attrs *attrs )
{ bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  bool tmp___13 ;
  int tmp___14 ;
  {
  {
  tmp = check_gamma_bounds(0U, attrs->gamma0);
  }
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (-22);
  } else {
    {
    tmp___1 = check_gamma_bounds(attrs->gamma0, attrs->gamma1);
    }
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    if (tmp___2) {
      return (-22);
    } else {
      {
      tmp___3 = check_gamma_bounds(attrs->gamma1, attrs->gamma2);
      }
      if (tmp___3) {
        tmp___4 = 0;
      } else {
        tmp___4 = 1;
      }
      if (tmp___4) {
        return (-22);
      } else {
        {
        tmp___5 = check_gamma_bounds(attrs->gamma2, attrs->gamma3);
        }
        if (tmp___5) {
          tmp___6 = 0;
        } else {
          tmp___6 = 1;
        }
        if (tmp___6) {
          return (-22);
        } else {
          {
          tmp___7 = check_gamma_bounds(attrs->gamma3, attrs->gamma4);
          }
          if (tmp___7) {
            tmp___8 = 0;
          } else {
            tmp___8 = 1;
          }
          if (tmp___8) {
            return (-22);
          } else {
            {
            tmp___9 = check_gamma_bounds(attrs->gamma4, attrs->gamma5);
            }
            if (tmp___9) {
              tmp___10 = 0;
            } else {
              tmp___10 = 1;
            }
            if (tmp___10) {
              return (-22);
            } else {
              {
              tmp___11 = check_gamma_bounds(attrs->gamma5, 16777215U);
              }
              if (tmp___11) {
                tmp___12 = 0;
              } else {
                tmp___12 = 1;
              }
              if (tmp___12) {
                return (-22);
              } else {
              }
            }
          }
        }
      }
    }
  }
  {
  tmp___13 = check_gamma5_errata(attrs->gamma5);
  }
  if (tmp___13) {
    tmp___14 = 0;
  } else {
    tmp___14 = 1;
  }
  if (tmp___14) {
    return (-22);
  } else {
  }
  return (0);
}
}
int intel_overlay_attrs(struct drm_device *dev , void *data , struct drm_file *file_priv )
{ struct drm_intel_overlay_attrs *attrs ;
  drm_i915_private_t *dev_priv ;
  struct intel_overlay *overlay ;
  struct overlay_registers *regs ;
  int ret ;
  {
  attrs = (struct drm_intel_overlay_attrs *)data;
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  if ((unsigned long )dev_priv == (unsigned long )((drm_i915_private_t *)0)) {
    {
    drm_err("intel_overlay_attrs", "called with no initialization\n");
    }
    return (-22);
  } else {
  }
  overlay = dev_priv->overlay;
  if ((unsigned long )overlay == (unsigned long )((struct intel_overlay *)0)) {
    {
    drm_ut_debug_printk(1U, "drm", "intel_overlay_attrs", "userspace bug: no overlay\n");
    }
    return (-19);
  } else {
  }
  {
  mutex_lock_nested(& dev->mode_config.mutex, 0U);
  mutex_lock_nested(& dev->struct_mutex, 0U);
  ret = -22;
  }
  if ((attrs->flags & 1U) == 0U) {
    attrs->color_key = overlay->color_key;
    attrs->brightness = (__s32 )overlay->brightness;
    attrs->contrast = overlay->contrast;
    attrs->saturation = overlay->saturation;
    if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) != 2U) {
      {
      attrs->gamma0 = i915_read32(dev_priv, 196644U);
      attrs->gamma1 = i915_read32(dev_priv, 196640U);
      attrs->gamma2 = i915_read32(dev_priv, 196636U);
      attrs->gamma3 = i915_read32(dev_priv, 196632U);
      attrs->gamma4 = i915_read32(dev_priv, 196628U);
      attrs->gamma5 = i915_read32(dev_priv, 196624U);
      }
    } else {
    }
  } else {
    if (attrs->brightness < -128) {
      goto out_unlock;
    } else
    if (attrs->brightness > 127) {
      goto out_unlock;
    } else {
    }
    if (attrs->contrast > 255U) {
      goto out_unlock;
    } else {
    }
    if (attrs->saturation > 1023U) {
      goto out_unlock;
    } else {
    }
    {
    overlay->color_key = attrs->color_key;
    overlay->brightness = (u32 )attrs->brightness;
    overlay->contrast = attrs->contrast;
    overlay->saturation = attrs->saturation;
    regs = intel_overlay_map_regs(overlay);
    }
    if ((unsigned long )regs == (unsigned long )((struct overlay_registers *)0)) {
      ret = -12;
      goto out_unlock;
    } else {
    }
    {
    update_reg_attrs(overlay, regs);
    intel_overlay_unmap_regs(overlay, regs);
    }
    if ((attrs->flags & 2U) != 0U) {
      if ((unsigned int )((unsigned char )(((struct drm_i915_private *)dev->dev_private)->info)->gen) == 2U) {
        goto out_unlock;
      } else {
      }
      if (overlay->active != 0) {
        ret = -16;
        goto out_unlock;
      } else {
      }
      {
      ret = check_gamma(attrs);
      }
      if (ret != 0) {
        goto out_unlock;
      } else {
      }
      {
      i915_write32(dev_priv, 196644U, attrs->gamma0);
      i915_write32(dev_priv, 196640U, attrs->gamma1);
      i915_write32(dev_priv, 196636U, attrs->gamma2);
      i915_write32(dev_priv, 196632U, attrs->gamma3);
      i915_write32(dev_priv, 196628U, attrs->gamma4);
      i915_write32(dev_priv, 196624U, attrs->gamma5);
      }
    } else {
    }
  }
  ret = 0;
  out_unlock:
  {
  mutex_unlock(& dev->struct_mutex);
  mutex_unlock(& dev->mode_config.mutex);
  }
  return (ret);
}
}
void intel_setup_overlay(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  struct intel_overlay *overlay ;
  struct drm_i915_gem_object *reg_bo ;
  struct overlay_registers *regs ;
  int ret ;
  void *tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 2UL) == 0U) {
    return;
  } else {
  }
  {
  tmp = kzalloc(96UL, 208U);
  overlay = (struct intel_overlay *)tmp;
  }
  if ((unsigned long )overlay == (unsigned long )((struct intel_overlay *)0)) {
    return;
  } else {
  }
  {
  mutex_lock_nested(& dev->struct_mutex, 0U);
  __ret_warn_on = (unsigned long )dev_priv->overlay != (unsigned long )((struct intel_overlay *)0);
  tmp___0 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp___0 != 0L) {
    {
    warn_slowpath_null("/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_overlay.c.p",
                       (int const )1421);
    }
  } else {
  }
  {
  tmp___1 = __builtin_expect((long )(__ret_warn_on != 0), 0L);
  }
  if (tmp___1 != 0L) {
    goto out_free;
  } else {
  }
  {
  overlay->dev = dev;
  reg_bo = i915_gem_alloc_object(dev, 4096UL);
  }
  if ((unsigned long )reg_bo == (unsigned long )((struct drm_i915_gem_object *)0)) {
    goto out_free;
  } else {
  }
  overlay->reg_bo = reg_bo;
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 3UL) != 0U) {
    {
    ret = i915_gem_attach_phys_object(dev, reg_bo, 3, 4096);
    }
    if (ret != 0) {
      {
      drm_err("intel_setup_overlay", "failed to attach phys overlay regs\n");
      }
      goto out_free_bo;
    } else {
    }
    overlay->flip_addr = (u32 )((reg_bo->phys_obj)->handle)->busaddr;
  } else {
    {
    ret = i915_gem_object_pin(reg_bo, 4096U, (bool )1);
    }
    if (ret != 0) {
      {
      drm_err("intel_setup_overlay", "failed to pin overlay register bo\n");
      }
      goto out_free_bo;
    } else {
    }
    {
    overlay->flip_addr = reg_bo->gtt_offset;
    ret = i915_gem_object_set_to_gtt_domain(reg_bo, (bool )1);
    }
    if (ret != 0) {
      {
      drm_err("intel_setup_overlay", "failed to move overlay register bo into the GTT\n");
      }
      goto out_unpin_bo;
    } else {
    }
  }
  {
  overlay->color_key = 66046U;
  overlay->brightness = 4294967277U;
  overlay->contrast = 75U;
  overlay->saturation = 146U;
  regs = intel_overlay_map_regs(overlay);
  }
  if ((unsigned long )regs == (unsigned long )((struct overlay_registers *)0)) {
    goto out_unpin_bo;
  } else {
  }
  {
  memset((void *)regs, 0, 1792UL);
  update_polyphase_filter(regs);
  update_reg_attrs(overlay, regs);
  intel_overlay_unmap_regs(overlay, regs);
  dev_priv->overlay = overlay;
  mutex_unlock(& dev->struct_mutex);
  printk("<6>[drm] initialized overlay support\n");
  }
  return;
  out_unpin_bo: ;
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 3UL) == 0U) {
    {
    i915_gem_object_unpin(reg_bo);
    }
  } else {
  }
  out_free_bo:
  {
  drm_gem_object_unreference(& reg_bo->base);
  }
  out_free:
  {
  mutex_unlock(& dev->struct_mutex);
  kfree((void const *)overlay);
  }
  return;
}
}
void intel_cleanup_overlay(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  long tmp ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  if ((unsigned long )dev_priv->overlay == (unsigned long )((struct intel_overlay *)0)) {
    return;
  } else {
  }
  {
  tmp = __builtin_expect((long )((dev_priv->overlay)->active != 0), 0L);
  }
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/anthill/stuff/tacas-comp/work/current--X--drivers/gpu/drm/i915/i915.ko--X--safe-main18linux-3.0.1--X--08_1/linux-3.0.1/csd_deg_dscv/46/dscv_tempdir/dscv/ri/08_1/drivers/gpu/drm/i915/intel_overlay.c.p"),
                         "i" (1497), "i" (12UL));
    ldv_37957: ;
    goto ldv_37957;
  } else {
  }
  {
  drm_gem_object_unreference_unlocked(& ((dev_priv->overlay)->reg_bo)->base);
  kfree((void const *)dev_priv->overlay);
  }
  return;
}
}
static struct overlay_registers *intel_overlay_map_regs_atomic(struct intel_overlay *overlay )
{ drm_i915_private_t *dev_priv ;
  struct overlay_registers *regs ;
  void *tmp ;
  {
  dev_priv = (drm_i915_private_t *)(overlay->dev)->dev_private;
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)(overlay->dev)->dev_private)->info + 3UL) != 0U) {
    regs = (struct overlay_registers *)(((overlay->reg_bo)->phys_obj)->handle)->vaddr;
  } else {
    {
    tmp = io_mapping_map_atomic_wc(dev_priv->mm.gtt_mapping, (unsigned long )(overlay->reg_bo)->gtt_offset);
    regs = (struct overlay_registers *)tmp;
    }
  }
  return (regs);
}
}
static void intel_overlay_unmap_regs_atomic(struct intel_overlay *overlay , struct overlay_registers *regs )
{
  {
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)(overlay->dev)->dev_private)->info + 3UL) == 0U) {
    {
    io_mapping_unmap_atomic((void *)regs);
    }
  } else {
  }
  return;
}
}
struct intel_overlay_error_state *intel_overlay_capture_error_state(struct drm_device *dev )
{ drm_i915_private_t *dev_priv ;
  struct intel_overlay *overlay ;
  struct intel_overlay_error_state *error ;
  struct overlay_registers *regs ;
  void *tmp ;
  {
  dev_priv = (drm_i915_private_t *)dev->dev_private;
  overlay = dev_priv->overlay;
  if ((unsigned long )overlay == (unsigned long )((struct intel_overlay *)0)) {
    return ((struct intel_overlay_error_state *)0);
  } else
  if (overlay->active == 0) {
    return ((struct intel_overlay_error_state *)0);
  } else {
  }
  {
  tmp = kmalloc(1808UL, 32U);
  error = (struct intel_overlay_error_state *)tmp;
  }
  if ((unsigned long )error == (unsigned long )((struct intel_overlay_error_state *)0)) {
    return ((struct intel_overlay_error_state *)0);
  } else {
  }
  {
  error->dovsta = i915_read32(dev_priv, 196616U);
  error->isr = i915_read32(dev_priv, 8364U);
  }
  if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)(overlay->dev)->dev_private)->info + 3UL) != 0U) {
    error->base = (unsigned long )(((overlay->reg_bo)->phys_obj)->handle)->vaddr;
  } else {
    error->base = (unsigned long )(overlay->reg_bo)->gtt_offset;
  }
  {
  regs = intel_overlay_map_regs_atomic(overlay);
  }
  if ((unsigned long )regs == (unsigned long )((struct overlay_registers *)0)) {
    goto err;
  } else {
  }
  {
  memcpy_fromio((void *)(& error->regs), (void const volatile *)regs, 1792UL);
  intel_overlay_unmap_regs_atomic(overlay, regs);
  }
  return (error);
  err:
  {
  kfree((void const *)error);
  }
  return ((struct intel_overlay_error_state *)0);
}
}
void intel_overlay_print_error_state(struct seq_file *m , struct intel_overlay_error_state *error )
{
  {
  {
  seq_printf(m, "Overlay, status: 0x%08x, interrupt: 0x%08x\n", error->dovsta, error->isr);
  seq_printf(m, "  Register file at 0x%08lx:\n", error->base);
  seq_printf(m, "    OBUF_0Y:\t0x%08x\n", error->regs.OBUF_0Y);
  seq_printf(m, "    OBUF_1Y:\t0x%08x\n", error->regs.OBUF_1Y);
  seq_printf(m, "    OBUF_0U:\t0x%08x\n", error->regs.OBUF_0U);
  seq_printf(m, "    OBUF_0V:\t0x%08x\n", error->regs.OBUF_0V);
  seq_printf(m, "    OBUF_1U:\t0x%08x\n", error->regs.OBUF_1U);
  seq_printf(m, "    OBUF_1V:\t0x%08x\n", error->regs.OBUF_1V);
  seq_printf(m, "    OSTRIDE:\t0x%08x\n", error->regs.OSTRIDE);
  seq_printf(m, "    YRGB_VPH:\t0x%08x\n", error->regs.YRGB_VPH);
  seq_printf(m, "    UV_VPH:\t0x%08x\n", error->regs.UV_VPH);
  seq_printf(m, "    HORZ_PH:\t0x%08x\n", error->regs.HORZ_PH);
  seq_printf(m, "    INIT_PHS:\t0x%08x\n", error->regs.INIT_PHS);
  seq_printf(m, "    DWINPOS:\t0x%08x\n", error->regs.DWINPOS);
  seq_printf(m, "    DWINSZ:\t0x%08x\n", error->regs.DWINSZ);
  seq_printf(m, "    SWIDTH:\t0x%08x\n", error->regs.SWIDTH);
  seq_printf(m, "    SWIDTHSW:\t0x%08x\n", error->regs.SWIDTHSW);
  seq_printf(m, "    SHEIGHT:\t0x%08x\n", error->regs.SHEIGHT);
  seq_printf(m, "    YRGBSCALE:\t0x%08x\n", error->regs.YRGBSCALE);
  seq_printf(m, "    UVSCALE:\t0x%08x\n", error->regs.UVSCALE);
  seq_printf(m, "    OCLRC0:\t0x%08x\n", error->regs.OCLRC0);
  seq_printf(m, "    OCLRC1:\t0x%08x\n", error->regs.OCLRC1);
  seq_printf(m, "    DCLRKV:\t0x%08x\n", error->regs.DCLRKV);
  seq_printf(m, "    DCLRKM:\t0x%08x\n", error->regs.DCLRKM);
  seq_printf(m, "    SCLRKVH:\t0x%08x\n", error->regs.SCLRKVH);
  seq_printf(m, "    SCLRKVL:\t0x%08x\n", error->regs.SCLRKVL);
  seq_printf(m, "    SCLRKEN:\t0x%08x\n", error->regs.SCLRKEN);
  seq_printf(m, "    OCONFIG:\t0x%08x\n", error->regs.OCONFIG);
  seq_printf(m, "    OCMD:\t0x%08x\n", error->regs.OCMD);
  seq_printf(m, "    OSTART_0Y:\t0x%08x\n", error->regs.OSTART_0Y);
  seq_printf(m, "    OSTART_1Y:\t0x%08x\n", error->regs.OSTART_1Y);
  seq_printf(m, "    OSTART_0U:\t0x%08x\n", error->regs.OSTART_0U);
  seq_printf(m, "    OSTART_0V:\t0x%08x\n", error->regs.OSTART_0V);
  seq_printf(m, "    OSTART_1U:\t0x%08x\n", error->regs.OSTART_1U);
  seq_printf(m, "    OSTART_1V:\t0x%08x\n", error->regs.OSTART_1V);
  seq_printf(m, "    OTILEOFF_0Y:\t0x%08x\n", error->regs.OTILEOFF_0Y);
  seq_printf(m, "    OTILEOFF_1Y:\t0x%08x\n", error->regs.OTILEOFF_1Y);
  seq_printf(m, "    OTILEOFF_0U:\t0x%08x\n", error->regs.OTILEOFF_0U);
  seq_printf(m, "    OTILEOFF_0V:\t0x%08x\n", error->regs.OTILEOFF_0V);
  seq_printf(m, "    OTILEOFF_1U:\t0x%08x\n", error->regs.OTILEOFF_1U);
  seq_printf(m, "    OTILEOFF_1V:\t0x%08x\n", error->regs.OTILEOFF_1V);
  seq_printf(m, "    FASTHSCALE:\t0x%08x\n", error->regs.FASTHSCALE);
  seq_printf(m, "    UVSCALEV:\t0x%08x\n", error->regs.UVSCALEV);
  }
  return;
}
}
extern void *ioremap_cache(resource_size_t , unsigned long ) ;
extern int dev_printk(char const * , struct device const * , char const * , ...) ;
extern acpi_status acpi_evaluate_integer(acpi_handle , acpi_string , struct acpi_object_list * ,
                                         unsigned long long * ) ;
extern int register_acpi_notifier(struct notifier_block * ) ;
extern int unregister_acpi_notifier(struct notifier_block * ) ;
extern int acpi_bus_get_device(acpi_handle , struct acpi_device ** ) ;
extern long acpi_is_video_device(struct acpi_device * ) ;
__inline static void *acpi_os_ioremap(acpi_physical_address phys , acpi_size size )
{ void *tmp ;
  {
  {
  tmp = ioremap_cache(phys, (unsigned long )size);
  }
  return (tmp);
}
}
__inline static void trace_i915_reg_rw___19(bool write , u32 reg , u64 val , int len )
{ struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  {
  tmp___1 = static_branch(& __tracepoint_i915_reg_rw.key);
  }
  if ((int )tmp___1) {
    {
    rcu_read_lock_sched_notrace();
    _________p1 = (struct tracepoint_func *)*((struct tracepoint_func * volatile *)(& __tracepoint_i915_reg_rw.funcs));
    tmp = debug_lockdep_rcu_enabled();
    }
    if (tmp != 0) {
      if (! __warned) {
        {
        tmp___0 = rcu_read_lock_sched_held();
        }
        if (tmp___0 == 0) {
          {
          __warned = (bool )1;
          lockdep_rcu_dereference("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/gpu/drm/i915/i915_trace.h",
                                  (int const )411);
          }
        } else {
        }
      } else {
      }
    } else {
    }
    it_func_ptr = _________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_38929:
      {
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , bool , u32 , u64 , int ))it_func))(__data, (bool )((int )write),
                                                                   reg, val, len);
      it_func_ptr = it_func_ptr + 1;
      }
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_38929;
      } else {
        goto ldv_38930;
      }
      ldv_38930: ;
    } else {
    }
    {
    rcu_read_lock_sched_notrace();
    }
  } else {
  }
  return;
}
}
__inline static u32 i915_read32___19(struct drm_i915_private *dev_priv , u32 reg )
{ u32 val ;
  {
  val = 0U;
  if ((unsigned int )((unsigned char )(dev_priv->info)->gen) > 5U) {
    if (reg <= 262143U) {
      if (reg != 41356U) {
        {
        gen6_gt_force_wake_get(dev_priv);
        val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
        gen6_gt_force_wake_put(dev_priv);
        }
      } else {
        {
        val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
        }
      }
    } else {
      {
      val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
      }
    }
  } else {
    {
    val = readl((void const volatile *)dev_priv->regs + (unsigned long )reg);
    }
  }
  {
  trace_i915_reg_rw___19((bool )0, reg, (u64 )val, 4);
  }
  return (val);
}
}
static u32 asle_set_backlight(struct drm_device *dev , u32 bclp )
{ struct drm_i915_private *dev_priv ;
  struct opregion_asle *asle ;
  u32 max ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  asle = dev_priv->opregion.asle;
  if ((int )bclp >= 0) {
    return (4096U);
  } else {
  }
  bclp = bclp & 2147483647U;
  if (bclp > 255U) {
    return (4096U);
  } else {
  }
  {
  max = intel_panel_get_max_backlight(dev);
  intel_panel_set_backlight(dev, (bclp * max) / 255U);
  asle->cblv = (bclp * 100U) / 255U | 2147483648U;
  }
  return (0U);
}
}
static u32 asle_set_als_illum(struct drm_device *dev , u32 alsi )
{
  {
  return (0U);
}
}
static u32 asle_set_pwm_freq(struct drm_device *dev , u32 pfmb )
{ struct drm_i915_private *dev_priv ;
  u32 blc_pwm_ctl ;
  u32 tmp ;
  u32 pwm ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  if ((int )pfmb < 0) {
    {
    tmp = i915_read32___19(dev_priv, 397908U);
    blc_pwm_ctl = tmp;
    pwm = pfmb & 2147483136U;
    blc_pwm_ctl = blc_pwm_ctl & 65535U;
    pwm = pwm >> 9;
    }
  } else {
  }
  return (0U);
}
}
static u32 asle_set_pfit(struct drm_device *dev , u32 pfit )
{
  {
  if ((int )pfit >= 0) {
    return (16384U);
  } else {
  }
  return (0U);
}
}
void intel_opregion_asle_intr(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct opregion_asle *asle ;
  u32 asle_stat ;
  u32 asle_req ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  asle = dev_priv->opregion.asle;
  asle_stat = 0U;
  if ((unsigned long )asle == (unsigned long )((struct opregion_asle *)0)) {
    return;
  } else {
  }
  asle_req = asle->aslc & 15U;
  if (asle_req == 0U) {
    {
    drm_ut_debug_printk(2U, "drm", "intel_opregion_asle_intr", "non asle set request??\n");
    }
    return;
  } else {
  }
  if ((int )asle_req & 1) {
    {
    tmp = asle_set_als_illum(dev, asle->alsi);
    asle_stat = tmp | asle_stat;
    }
  } else {
  }
  if ((asle_req & 2U) != 0U) {
    {
    tmp___0 = asle_set_backlight(dev, asle->bclp);
    asle_stat = tmp___0 | asle_stat;
    }
  } else {
  }
  if ((asle_req & 4U) != 0U) {
    {
    tmp___1 = asle_set_pfit(dev, asle->pfit);
    asle_stat = tmp___1 | asle_stat;
    }
  } else {
  }
  if ((asle_req & 8U) != 0U) {
    {
    tmp___2 = asle_set_pwm_freq(dev, asle->pfmb);
    asle_stat = tmp___2 | asle_stat;
    }
  } else {
  }
  asle->aslc = asle_stat;
  return;
}
}
void intel_opregion_gse_intr(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct opregion_asle *asle ;
  u32 asle_stat ;
  u32 asle_req ;
  u32 tmp ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  asle = dev_priv->opregion.asle;
  asle_stat = 0U;
  if ((unsigned long )asle == (unsigned long )((struct opregion_asle *)0)) {
    return;
  } else {
  }
  asle_req = asle->aslc & 15U;
  if (asle_req == 0U) {
    {
    drm_ut_debug_printk(2U, "drm", "intel_opregion_gse_intr", "non asle set request??\n");
    }
    return;
  } else {
  }
  if ((int )asle_req & 1) {
    {
    drm_ut_debug_printk(2U, "drm", "intel_opregion_gse_intr", "Illum is not supported\n");
    asle_stat = asle_stat | 1024U;
    }
  } else {
  }
  if ((asle_req & 2U) != 0U) {
    {
    tmp = asle_set_backlight(dev, asle->bclp);
    asle_stat = tmp | asle_stat;
    }
  } else {
  }
  if ((asle_req & 4U) != 0U) {
    {
    drm_ut_debug_printk(2U, "drm", "intel_opregion_gse_intr", "Pfit is not supported\n");
    asle_stat = asle_stat | 16384U;
    }
  } else {
  }
  if ((asle_req & 8U) != 0U) {
    {
    drm_ut_debug_printk(2U, "drm", "intel_opregion_gse_intr", "PWM freq is not supported\n");
    asle_stat = asle_stat | 65536U;
    }
  } else {
  }
  asle->aslc = asle_stat;
  return;
}
}
void intel_opregion_enable_asle(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct opregion_asle *asle ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  asle = dev_priv->opregion.asle;
  if ((unsigned long )asle != (unsigned long )((struct opregion_asle *)0)) {
    if ((unsigned int )*((unsigned char *)((struct drm_i915_private *)dev->dev_private)->info + 1UL) != 0U) {
      {
      intel_enable_asle(dev);
      }
    } else {
    }
    asle->tche = 15U;
    asle->ardy = 1U;
  } else {
  }
  return;
}
}
static struct intel_opregion *system_opregion ;
static int intel_opregion_video_event(struct notifier_block *nb , unsigned long val ,
                                      void *data )
{ struct opregion_acpi *acpi ;
  {
  if ((unsigned long )system_opregion == (unsigned long )((struct intel_opregion *)0)) {
    return (0);
  } else {
  }
  acpi = system_opregion->acpi;
  acpi->csts = 0U;
  return (1);
}
}
static struct notifier_block intel_opregion_notifier = {& intel_opregion_video_event, (struct notifier_block *)0, 0};
static void intel_didl_outputs(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct intel_opregion *opregion ;
  struct drm_connector *connector ;
  acpi_handle handle ;
  struct acpi_device *acpi_dev ;
  struct acpi_device *acpi_cdev ;
  struct acpi_device *acpi_video_bus ;
  unsigned long long device_id ;
  acpi_status status ;
  int i ;
  int tmp ;
  struct list_head const *__mptr ;
  long tmp___0 ;
  struct list_head const *__mptr___0 ;
  long tmp___1 ;
  struct list_head const *__mptr___1 ;
  struct list_head const *__mptr___2 ;
  struct list_head const *__mptr___3 ;
  int output_type ;
  struct list_head const *__mptr___4 ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  opregion = & dev_priv->opregion;
  acpi_video_bus = (struct acpi_device *)0;
  i = 0;
  handle = (dev->pdev)->dev.archdata.acpi_handle;
  if ((unsigned long )handle == (unsigned long )((acpi_handle )0)) {
    return;
  } else {
    {
    tmp = acpi_bus_get_device(handle, & acpi_dev);
    }
    if (tmp != 0) {
      return;
    } else {
    }
  }
  {
  tmp___1 = acpi_is_video_device(acpi_dev);
  }
  if (tmp___1 != 0L) {
    acpi_video_bus = acpi_dev;
  } else {
    __mptr = (struct list_head const *)acpi_dev->children.next;
    acpi_cdev = (struct acpi_device *)__mptr + 0x0fffffffffffffd8UL;
    goto ldv_40054;
    ldv_40053:
    {
    tmp___0 = acpi_is_video_device(acpi_cdev);
    }
    if (tmp___0 != 0L) {
      acpi_video_bus = acpi_cdev;
      goto ldv_40052;
    } else {
    }
    __mptr___0 = (struct list_head const *)acpi_cdev->node.next;
    acpi_cdev = (struct acpi_device *)__mptr___0 + 0x0fffffffffffffd8UL;
    ldv_40054: ;
    if ((unsigned long )(& acpi_cdev->node) != (unsigned long )(& acpi_dev->children)) {
      goto ldv_40053;
    } else {
      goto ldv_40052;
    }
    ldv_40052: ;
  }
  if ((unsigned long )acpi_video_bus == (unsigned long )((struct acpi_device *)0)) {
    {
    printk("<4>No ACPI video bus found\n");
    }
    return;
  } else {
  }
  __mptr___1 = (struct list_head const *)acpi_video_bus->children.next;
  acpi_cdev = (struct acpi_device *)__mptr___1 + 0x0fffffffffffffd8UL;
  goto ldv_40061;
  ldv_40060: ;
  if (i > 7) {
    {
    dev_printk("<3>", (struct device const *)(& (dev->pdev)->dev), "More than 8 outputs detected\n");
    }
    return;
  } else {
  }
  {
  status = acpi_evaluate_integer(acpi_cdev->handle, (char *)"_ADR", (struct acpi_object_list *)0,
                                 & device_id);
  }
  if (status == 0U) {
    if (device_id == 0ULL) {
      goto blind_set;
    } else {
    }
    (opregion->acpi)->didl[i] = (unsigned int )device_id & 3855U;
    i = i + 1;
  } else {
  }
  __mptr___2 = (struct list_head const *)acpi_cdev->node.next;
  acpi_cdev = (struct acpi_device *)__mptr___2 + 0x0fffffffffffffd8UL;
  ldv_40061: ;
  if ((unsigned long )(& acpi_cdev->node) != (unsigned long )(& acpi_video_bus->children)) {
    goto ldv_40060;
  } else {
    goto ldv_40062;
  }
  ldv_40062: ;
  end: ;
  if (i <= 7) {
    (opregion->acpi)->didl[i] = 0U;
  } else {
  }
  return;
  blind_set:
  i = 0;
  __mptr___3 = (struct list_head const *)dev->mode_config.connector_list.next;
  connector = (struct drm_connector *)__mptr___3 + 0x0ffffffffffffb98UL;
  goto ldv_40083;
  ldv_40082:
  output_type = 0;
  if (i > 7) {
    {
    dev_printk("<3>", (struct device const *)(& (dev->pdev)->dev), "More than 8 outputs detected\n");
    }
    return;
  } else {
  }
  if (connector->connector_type == 1) {
    goto case_1;
  } else
  if (connector->connector_type == 4) {
    goto case_4;
  } else
  if (connector->connector_type == 5) {
    goto case_5;
  } else
  if (connector->connector_type == 6) {
    goto case_6;
  } else
  if (connector->connector_type == 8) {
    goto case_8;
  } else
  if (connector->connector_type == 9) {
    goto case_9;
  } else
  if (connector->connector_type == 2) {
    goto case_2;
  } else
  if (connector->connector_type == 3) {
    goto case_3;
  } else
  if (connector->connector_type == 10) {
    goto case_10;
  } else
  if (connector->connector_type == 11) {
    goto case_11;
  } else
  if (connector->connector_type == 12) {
    goto case_12;
  } else
  if (connector->connector_type == 7) {
    goto case_7;
  } else
  if (0) {
    case_1: ;
    case_4:
    output_type = 256;
    goto ldv_40071;
    case_5: ;
    case_6: ;
    case_8: ;
    case_9:
    output_type = 512;
    goto ldv_40071;
    case_2: ;
    case_3: ;
    case_10: ;
    case_11: ;
    case_12:
    output_type = 768;
    goto ldv_40071;
    case_7:
    output_type = 1024;
    goto ldv_40071;
  } else {
  }
  ldv_40071:
  (opregion->acpi)->didl[i] = (opregion->acpi)->didl[i] | (u32 )((output_type | (-0x7FFFFFFF-1)) | i);
  i = i + 1;
  __mptr___4 = (struct list_head const *)connector->head.next;
  connector = (struct drm_connector *)__mptr___4 + 0x0ffffffffffffb98UL;
  ldv_40083: ;
  if ((unsigned long )(& connector->head) != (unsigned long )(& dev->mode_config.connector_list)) {
    goto ldv_40082;
  } else {
    goto ldv_40084;
  }
  ldv_40084: ;
  goto end;
}
}
void intel_opregion_init(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct intel_opregion *opregion ;
  int tmp ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  opregion = & dev_priv->opregion;
  if ((unsigned long )opregion->header == (unsigned long )((struct opregion_header *)0)) {
    return;
  } else {
  }
  if ((unsigned long )opregion->acpi != (unsigned long )((struct opregion_acpi *)0)) {
    {
    tmp = drm_core_check_feature(dev, 8192);
    }
    if (tmp != 0) {
      {
      intel_didl_outputs(dev);
      }
    } else {
    }
    {
    (opregion->acpi)->csts = 0U;
    (opregion->acpi)->drdy = 1U;
    system_opregion = opregion;
    register_acpi_notifier(& intel_opregion_notifier);
    }
  } else {
  }
  if ((unsigned long )opregion->asle != (unsigned long )((struct opregion_asle *)0)) {
    {
    intel_opregion_enable_asle(dev);
    }
  } else {
  }
  return;
}
}
void intel_opregion_fini(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct intel_opregion *opregion ;
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  opregion = & dev_priv->opregion;
  if ((unsigned long )opregion->header == (unsigned long )((struct opregion_header *)0)) {
    return;
  } else {
  }
  if ((unsigned long )opregion->acpi != (unsigned long )((struct opregion_acpi *)0)) {
    {
    (opregion->acpi)->drdy = 0U;
    system_opregion = (struct intel_opregion *)0;
    unregister_acpi_notifier(& intel_opregion_notifier);
    }
  } else {
  }
  {
  iounmap((void volatile *)opregion->header);
  opregion->header = (struct opregion_header *)0;
  opregion->acpi = (struct opregion_acpi *)0;
  opregion->swsci = (struct opregion_swsci *)0;
  opregion->asle = (struct opregion_asle *)0;
  opregion->vbt = (void *)0;
  }
  return;
}
}
int intel_opregion_setup(struct drm_device *dev )
{ struct drm_i915_private *dev_priv ;
  struct intel_opregion *opregion ;
  void *base ;
  u32 asls ;
  u32 mboxes ;
  int err ;
  int tmp ;
  {
  {
  dev_priv = (struct drm_i915_private *)dev->dev_private;
  opregion = & dev_priv->opregion;
  err = 0;
  pci_read_config_dword(dev->pdev, 252, & asls);
  drm_ut_debug_printk(2U, "drm", "intel_opregion_setup", "graphic opregion physical addr: 0x%x\n",
                      asls);
  }
  if (asls == 0U) {
    {
    drm_ut_debug_printk(2U, "drm", "intel_opregion_setup", "ACPI OpRegion not supported!\n");
    }
    return (-524);
  } else {
  }
  {
  base = acpi_os_ioremap((acpi_physical_address )asls, 8192ULL);
  }
  if ((unsigned long )base == (unsigned long )((void *)0)) {
    return (-12);
  } else {
  }
  {
  tmp = memcmp((void const *)base, (void const *)"IntelGraphicsMem", 16UL);
  }
  if (tmp != 0) {
    {
    drm_ut_debug_printk(2U, "drm", "intel_opregion_setup", "opregion signature mismatch\n");
    err = -22;
    }
    goto err_out;
  } else {
  }
  opregion->header = (struct opregion_header *)base;
  opregion->vbt = base + 1024UL;
  opregion->lid_state = (u32 *)base + 428U;
  mboxes = (opregion->header)->mboxes;
  if ((int )mboxes & 1) {
    {
    drm_ut_debug_printk(2U, "drm", "intel_opregion_setup", "Public ACPI methods supported\n");
    opregion->acpi = (struct opregion_acpi *)base + 256U;
    }
  } else {
  }
  if ((mboxes & 2U) != 0U) {
    {
    drm_ut_debug_printk(2U, "drm", "intel_opregion_setup", "SWSCI supported\n");
    opregion->swsci = (struct opregion_swsci *)base + 512U;
    }
  } else {
  }
  if ((mboxes & 4U) != 0U) {
    {
    drm_ut_debug_printk(2U, "drm", "intel_opregion_setup", "ASLE supported\n");
    opregion->asle = (struct opregion_asle *)base + 768U;
    }
  } else {
  }
  return (0);
  err_out:
  {
  iounmap((void volatile *)base);
  }
  return (err);
}
}
static struct ch7xxx_id_struct ch7xxx_ids[4U] = { {(uint8_t )131U, (char *)"CH7011"},
        {(uint8_t )132U, (char *)"CH7009A"},
        {(uint8_t )133U, (char *)"CH7009B"},
        {(uint8_t )149U, (char *)"CH7301"}};
static char *ch7xxx_get_id(uint8_t vid )
{ int i ;
  {
  i = 0;
  goto ldv_37325;
  ldv_37324: ;
  if ((int )ch7xxx_ids[i].vid == (int )vid) {
    return (ch7xxx_ids[i].name);
  } else {
  }
  i = i + 1;
  ldv_37325: ;
  if ((unsigned int )i <= 3U) {
    goto ldv_37324;
  } else {
    goto ldv_37326;
  }
  ldv_37326: ;
  return ((char *)0);
}
}
static bool ch7xxx_readb(struct intel_dvo_device *dvo , int addr , uint8_t *ch )
{ struct ch7xxx_priv *ch7xxx ;
  struct i2c_adapter *adapter ;
  u8 out_buf[2U] ;
  u8 in_buf[2U] ;
  struct i2c_msg msgs[2U] ;
  int tmp ;
  {
  {
  ch7xxx = (struct ch7xxx_priv *)dvo->dev_priv;
  adapter = dvo->i2c_bus;
  msgs[0].addr = (unsigned short )dvo->slave_addr;
  msgs[0].flags = (__u16 )0U;
  msgs[0].len = (__u16 )1U;
  msgs[0].buf = (__u8 *)(& out_buf);
  msgs[1].addr = (unsigned short )dvo->slave_addr;
  msgs[1].flags = (__u16 )1U;
  msgs[1].len = (__u16 )1U;
  msgs[1].buf = (__u8 *)(& in_buf);
  out_buf[0] = (u8 )addr;
  out_buf[1] = (u8 )0U;
  tmp = i2c_transfer(adapter, (struct i2c_msg *)(& msgs), 2);
  }
  if (tmp == 2) {
    *ch = in_buf[0];
    return ((bool )1);
  } else {
  }
  if (! ch7xxx->quiet) {
    {
    drm_ut_debug_printk(4U, "drm", "ch7xxx_readb", "Unable to read register 0x%02x from %s:%02x.\n",
                        addr, (char *)(& adapter->name), dvo->slave_addr);
    }
  } else {
  }
  return ((bool )0);
}
}
static bool ch7xxx_writeb(struct intel_dvo_device *dvo , int addr , uint8_t ch )
{ struct ch7xxx_priv *ch7xxx ;
  struct i2c_adapter *adapter ;
  uint8_t out_buf[2U] ;
  struct i2c_msg msg ;
  int tmp ;
  {
  {
  ch7xxx = (struct ch7xxx_priv *)dvo->dev_priv;
  adapter = dvo->i2c_bus;
  msg.addr = (unsigned short )dvo->slave_addr;
  msg.flags = (__u16 )0U;
  msg.len = (__u16 )2U;
  msg.buf = (__u8 *)(& out_buf);
  out_buf[0] = (uint8_t )addr;
  out_buf[1] = ch;
  tmp = i2c_transfer(adapter, & msg, 1);
  }
  if (tmp == 1) {
    return ((bool )1);
  } else {
  }
  if (! ch7xxx->quiet) {
    {
    drm_ut_debug_printk(4U, "drm", "ch7xxx_writeb", "Unable to write register 0x%02x to %s:%d.\n",
                        addr, (char *)(& adapter->name), dvo->slave_addr);
    }
  } else {
  }
  return ((bool )0);
}
}
static bool ch7xxx_init(struct intel_dvo_device *dvo , struct i2c_adapter *adapter )
{ struct ch7xxx_priv *ch7xxx ;
  uint8_t vendor ;
  uint8_t device ;
  char *name ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  {
  {
  tmp = kzalloc(1UL, 208U);
  ch7xxx = (struct ch7xxx_priv *)tmp;
  }
  if ((unsigned long )ch7xxx == (unsigned long )((struct ch7xxx_priv *)0)) {
    return ((bool )0);
  } else {
  }
  {
  dvo->i2c_bus = adapter;
  dvo->dev_priv = (void *)ch7xxx;
  ch7xxx->quiet = (bool )1;
  tmp___0 = ch7xxx_readb(dvo, 74, & vendor);
  }
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    goto out;
  } else {
  }
  {
  name = ch7xxx_get_id((uint8_t )((int )vendor));
  }
  if ((unsigned long )name == (unsigned long )((char *)0)) {
    {
    drm_ut_debug_printk(4U, "drm", "ch7xxx_init", "ch7xxx not detected; got 0x%02x from %s slave %d.\n",
                        (int )vendor, (char *)(& adapter->name), dvo->slave_addr);
    }
    goto out;
  } else {
  }
  {
  tmp___2 = ch7xxx_readb(dvo, 75, & device);
  }
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    goto out;
  } else {
  }
  if ((unsigned int )device != 23U) {
    {
    drm_ut_debug_printk(4U, "drm", "ch7xxx_init", "ch7xxx not detected; got 0x%02x from %s slave %d.\n",
                        (int )vendor, (char *)(& adapter->name), dvo->slave_addr);
    }
    goto out;
  } else {
  }
  {
  ch7xxx->quiet = (bool )0;
  drm_ut_debug_printk(4U, "drm", "ch7xxx_init", "Detected %s chipset, vendor/device ID 0x%02x/0x%02x\n",
                      name, (int )vendor, (int )device);
  }
  return ((bool )1);
  out:
  {
  kfree((void const *)ch7xxx);
  }
  return ((bool )0);
}
}
static enum drm_connector_status ch7xxx_detect(struct intel_dvo_device *dvo )
{ uint8_t cdet ;
  uint8_t orig_pm ;
  uint8_t pm ;
  {
  {
  ch7xxx_readb(dvo, 73, & orig_pm);
  pm = orig_pm;
  pm = (uint8_t )((unsigned int )pm & 254U);
  pm = (uint8_t )((unsigned int )pm | 192U);
  ch7xxx_writeb(dvo, 73, (uint8_t )((int )pm));
  ch7xxx_readb(dvo, 32, & cdet);
  ch7xxx_writeb(dvo, 73, (uint8_t )((int )orig_pm));
  }
  if (((int )cdet & 32) != 0) {
    return ((enum drm_connector_status )1);
  } else {
  }
  return ((enum drm_connector_status )2);
}
}
static enum drm_mode_status ch7xxx_mode_valid(struct intel_dvo_device *dvo , struct drm_display_mode *mode )
{
  {
  if (mode->clock > 165000) {
    return ((enum drm_mode_status )15);
  } else {
  }
  return ((enum drm_mode_status )0);
}
}
static void ch7xxx_mode_set(struct intel_dvo_device *dvo , struct drm_display_mode *mode ,
                            struct drm_display_mode *adjusted_mode )
{ uint8_t tvco ;
  uint8_t tpcp ;
  uint8_t tpd ;
  uint8_t tlpf ;
  uint8_t idf ;
  {
  if (mode->clock <= 65000) {
    tvco = (uint8_t )35U;
    tpcp = (uint8_t )8U;
    tpd = (uint8_t )22U;
    tlpf = (uint8_t )96U;
  } else {
    tvco = (uint8_t )45U;
    tpcp = (uint8_t )6U;
    tpd = (uint8_t )38U;
    tlpf = (uint8_t )160U;
  }
  {
  ch7xxx_writeb(dvo, 49, (uint8_t )0);
  ch7xxx_writeb(dvo, 50, (uint8_t )((int )tvco));
  ch7xxx_writeb(dvo, 51, (uint8_t )((int )tpcp));
  ch7xxx_writeb(dvo, 52, (uint8_t )((int )tpd));
  ch7xxx_writeb(dvo, 53, (uint8_t )48);
  ch7xxx_writeb(dvo, 54, (uint8_t )((int )tlpf));
  ch7xxx_writeb(dvo, 55, (uint8_t )0);
  ch7xxx_readb(dvo, 31, & idf);
  idf = (uint8_t )((unsigned int )idf & 231U);
  }
  if ((int )mode->flags & 1) {
    idf = (uint8_t )((unsigned int )idf | 8U);
  } else {
  }
  if ((mode->flags & 4U) != 0U) {
    idf = (uint8_t )((unsigned int )idf | 8U);
  } else {
  }
  {
  ch7xxx_writeb(dvo, 31, (uint8_t )((int )idf));
  }
  return;
}
}
static void ch7xxx_dpms(struct intel_dvo_device *dvo , int mode )
{
  {
  if (mode == 0) {
    {
    ch7xxx_writeb(dvo, 73, (uint8_t )192);
    }
  } else {
    {
    ch7xxx_writeb(dvo, 73, (uint8_t )1);
    }
  }
  return;
}
}
static void ch7xxx_dump_regs(struct intel_dvo_device *dvo )
{ int i ;
  uint8_t val ;
  {
  i = 0;
  goto ldv_37388;
  ldv_37387: ;
  if (((unsigned int )i & 7U) == 0U) {
    {
    drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "\n %02X: ", i);
    }
  } else {
  }
  {
  ch7xxx_readb(dvo, i, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "%02X ", (int )val);
  i = i + 1;
  }
  ldv_37388: ;
  if (i <= 75) {
    goto ldv_37387;
  } else {
    goto ldv_37389;
  }
  ldv_37389: ;
  return;
}
}
static void ch7xxx_destroy(struct intel_dvo_device *dvo )
{ struct ch7xxx_priv *ch7xxx ;
  {
  ch7xxx = (struct ch7xxx_priv *)dvo->dev_priv;
  if ((unsigned long )ch7xxx != (unsigned long )((struct ch7xxx_priv *)0)) {
    {
    kfree((void const *)ch7xxx);
    dvo->dev_priv = (void *)0;
    }
  } else {
  }
  return;
}
}
struct intel_dvo_dev_ops ch7xxx_ops =
     {& ch7xxx_init, (void (*)(struct intel_dvo_device * ))0, & ch7xxx_dpms, (int (*)(struct intel_dvo_device * ,
                                                                                    struct drm_display_mode * ))(& ch7xxx_mode_valid),
    (bool (*)(struct intel_dvo_device * , struct drm_display_mode * , struct drm_display_mode * ))0,
    (void (*)(struct intel_dvo_device * ))0, (void (*)(struct intel_dvo_device * ))0,
    & ch7xxx_mode_set, & ch7xxx_detect, (struct drm_display_mode *(*)(struct intel_dvo_device * ))0,
    & ch7xxx_destroy, & ch7xxx_dump_regs};
static void ch7017_dump_regs(struct intel_dvo_device *dvo ) ;
static void ch7017_dpms(struct intel_dvo_device *dvo , int mode ) ;
static bool ch7017_read(struct intel_dvo_device *dvo , u8 addr , u8 *val )
{ struct i2c_msg msgs[2U] ;
  int tmp ;
  {
  {
  msgs[0].addr = (unsigned short )dvo->slave_addr;
  msgs[0].flags = (__u16 )0U;
  msgs[0].len = (__u16 )1U;
  msgs[0].buf = & addr;
  msgs[1].addr = (unsigned short )dvo->slave_addr;
  msgs[1].flags = (__u16 )1U;
  msgs[1].len = (__u16 )1U;
  msgs[1].buf = val;
  tmp = i2c_transfer(dvo->i2c_bus, (struct i2c_msg *)(& msgs), 2);
  }
  return ((bool )(tmp == 2));
}
}
static bool ch7017_write(struct intel_dvo_device *dvo , u8 addr , u8 val )
{ uint8_t buf[2U] ;
  struct i2c_msg msg ;
  int tmp ;
  {
  {
  buf[0] = addr;
  buf[1] = val;
  msg.addr = (unsigned short )dvo->slave_addr;
  msg.flags = (__u16 )0U;
  msg.len = (__u16 )2U;
  msg.buf = (__u8 *)(& buf);
  tmp = i2c_transfer(dvo->i2c_bus, & msg, 1);
  }
  return ((bool )(tmp == 1));
}
}
static bool ch7017_init(struct intel_dvo_device *dvo , struct i2c_adapter *adapter )
{ struct ch7017_priv *priv ;
  char const *str ;
  u8 val ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  {
  {
  tmp = kzalloc(1UL, 208U);
  priv = (struct ch7017_priv *)tmp;
  }
  if ((unsigned long )priv == (unsigned long )((struct ch7017_priv *)0)) {
    return ((bool )0);
  } else {
  }
  {
  dvo->i2c_bus = adapter;
  dvo->dev_priv = (void *)priv;
  tmp___0 = ch7017_read(dvo, (u8 )75, & val);
  }
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    goto fail;
  } else {
  }
  if ((int )val == 27) {
    goto case_27;
  } else
  if ((int )val == 26) {
    goto case_26;
  } else
  if ((int )val == 25) {
    goto case_25;
  } else {
    goto switch_default;
    if (0) {
      case_27:
      str = "ch7017";
      goto ldv_37341;
      case_26:
      str = "ch7018";
      goto ldv_37341;
      case_25:
      str = "ch7019";
      goto ldv_37341;
      switch_default:
      {
      drm_ut_debug_printk(4U, "drm", "ch7017_init", "ch701x not detected, got %d: from %s slave %d.\n",
                          (int )val, (char *)(& adapter->name), dvo->slave_addr);
      }
      goto fail;
    } else {
    }
  }
  ldv_37341:
  {
  drm_ut_debug_printk(4U, "drm", "ch7017_init", "%s detected on %s, addr %d\n", str,
                      (char *)(& adapter->name), dvo->slave_addr);
  }
  return ((bool )1);
  fail:
  {
  kfree((void const *)priv);
  }
  return ((bool )0);
}
}
static enum drm_connector_status ch7017_detect(struct intel_dvo_device *dvo )
{
  {
  return ((enum drm_connector_status )1);
}
}
static enum drm_mode_status ch7017_mode_valid(struct intel_dvo_device *dvo , struct drm_display_mode *mode )
{
  {
  if (mode->clock > 160000) {
    return ((enum drm_mode_status )15);
  } else {
  }
  return ((enum drm_mode_status )0);
}
}
static void ch7017_mode_set(struct intel_dvo_device *dvo , struct drm_display_mode *mode ,
                            struct drm_display_mode *adjusted_mode )
{ uint8_t lvds_pll_feedback_div ;
  uint8_t lvds_pll_vco_control ;
  uint8_t outputs_enable ;
  uint8_t lvds_control_2 ;
  uint8_t lvds_power_down ;
  uint8_t horizontal_active_pixel_input ;
  uint8_t horizontal_active_pixel_output ;
  uint8_t vertical_active_line_output ;
  uint8_t active_input_line_output ;
  {
  {
  drm_ut_debug_printk(4U, "drm", "ch7017_mode_set", "Registers before mode setting\n");
  ch7017_dump_regs(dvo);
  }
  if (mode->clock <= 99999) {
    outputs_enable = (uint8_t )8U;
    lvds_pll_feedback_div = (uint8_t )173U;
    lvds_pll_vco_control = (uint8_t )163U;
    lvds_control_2 = (uint8_t )32U;
  } else {
    outputs_enable = (uint8_t )11U;
    lvds_pll_feedback_div = (uint8_t )163U;
    lvds_pll_feedback_div = (uint8_t )35U;
    lvds_control_2 = (uint8_t )96U;
    outputs_enable = (uint8_t )((unsigned int )outputs_enable | 16U);
    lvds_pll_vco_control = (uint8_t )173U;
  }
  {
  horizontal_active_pixel_input = (uint8_t )mode->hdisplay;
  vertical_active_line_output = (uint8_t )mode->vdisplay;
  horizontal_active_pixel_output = (uint8_t )mode->hdisplay;
  active_input_line_output = (uint8_t )((int )((signed char )((mode->hdisplay & 1792) >> 8)) | (int )((signed char )(((mode->vdisplay & 1792) >> 8) << 3)));
  lvds_power_down = (uint8_t )((int )((signed char )((mode->hdisplay & 1792) >> 8)) | 8);
  ch7017_dpms(dvo, 3);
  ch7017_write(dvo, (u8 )95, (u8 )((int )horizontal_active_pixel_input));
  ch7017_write(dvo, (u8 )98, (u8 )((int )horizontal_active_pixel_output));
  ch7017_write(dvo, (u8 )97, (u8 )((int )vertical_active_line_output));
  ch7017_write(dvo, (u8 )96, (u8 )((int )active_input_line_output));
  ch7017_write(dvo, (u8 )114, (u8 )((int )lvds_pll_vco_control));
  ch7017_write(dvo, (u8 )113, (u8 )((int )lvds_pll_feedback_div));
  ch7017_write(dvo, (u8 )120, (u8 )((int )lvds_control_2));
  ch7017_write(dvo, (u8 )115, (u8 )((int )outputs_enable));
  ch7017_write(dvo, (u8 )99, (u8 )((int )lvds_power_down));
  drm_ut_debug_printk(4U, "drm", "ch7017_mode_set", "Registers after mode setting\n");
  ch7017_dump_regs(dvo);
  }
  return;
}
}
static void ch7017_dpms(struct intel_dvo_device *dvo , int mode )
{ uint8_t val ;
  {
  {
  ch7017_read(dvo, (u8 )99, & val);
  ch7017_write(dvo, (u8 )73, (u8 )62);
  }
  if (mode == 0) {
    {
    ch7017_write(dvo, (u8 )99, (u8 )((int )val & 191));
    }
  } else {
    {
    ch7017_write(dvo, (u8 )99, (u8 )((int )((unsigned int )val | 64U)));
    }
  }
  {
  msleep(20U);
  }
  return;
}
}
static void ch7017_dump_regs(struct intel_dvo_device *dvo )
{ uint8_t val ;
  {
  {
  ch7017_read(dvo, (u8 )95, & val);
  drm_ut_debug_printk(4U, "drm", "ch7017_dump_regs", "CH7017_HORIZONTAL_ACTIVE_PIXEL_INPUT: %02x\n",
                      (int )val);
  ch7017_read(dvo, (u8 )98, & val);
  drm_ut_debug_printk(4U, "drm", "ch7017_dump_regs", "CH7017_HORIZONTAL_ACTIVE_PIXEL_OUTPUT: %02x\n",
                      (int )val);
  ch7017_read(dvo, (u8 )97, & val);
  drm_ut_debug_printk(4U, "drm", "ch7017_dump_regs", "CH7017_VERTICAL_ACTIVE_LINE_OUTPUT: %02x\n",
                      (int )val);
  ch7017_read(dvo, (u8 )96, & val);
  drm_ut_debug_printk(4U, "drm", "ch7017_dump_regs", "CH7017_ACTIVE_INPUT_LINE_OUTPUT: %02x\n",
                      (int )val);
  ch7017_read(dvo, (u8 )114, & val);
  drm_ut_debug_printk(4U, "drm", "ch7017_dump_regs", "CH7017_LVDS_PLL_VCO_CONTROL: %02x\n",
                      (int )val);
  ch7017_read(dvo, (u8 )113, & val);
  drm_ut_debug_printk(4U, "drm", "ch7017_dump_regs", "CH7017_LVDS_PLL_FEEDBACK_DIV: %02x\n",
                      (int )val);
  ch7017_read(dvo, (u8 )120, & val);
  drm_ut_debug_printk(4U, "drm", "ch7017_dump_regs", "CH7017_LVDS_CONTROL_2: %02x\n",
                      (int )val);
  ch7017_read(dvo, (u8 )115, & val);
  drm_ut_debug_printk(4U, "drm", "ch7017_dump_regs", "CH7017_OUTPUTS_ENABLE: %02x\n",
                      (int )val);
  ch7017_read(dvo, (u8 )99, & val);
  drm_ut_debug_printk(4U, "drm", "ch7017_dump_regs", "CH7017_LVDS_POWER_DOWN: %02x\n",
                      (int )val);
  }
  return;
}
}
static void ch7017_destroy(struct intel_dvo_device *dvo )
{ struct ch7017_priv *priv ;
  {
  priv = (struct ch7017_priv *)dvo->dev_priv;
  if ((unsigned long )priv != (unsigned long )((struct ch7017_priv *)0)) {
    {
    kfree((void const *)priv);
    dvo->dev_priv = (void *)0;
    }
  } else {
  }
  return;
}
}
struct intel_dvo_dev_ops ch7017_ops =
     {& ch7017_init, (void (*)(struct intel_dvo_device * ))0, & ch7017_dpms, (int (*)(struct intel_dvo_device * ,
                                                                                    struct drm_display_mode * ))(& ch7017_mode_valid),
    (bool (*)(struct intel_dvo_device * , struct drm_display_mode * , struct drm_display_mode * ))0,
    (void (*)(struct intel_dvo_device * ))0, (void (*)(struct intel_dvo_device * ))0,
    & ch7017_mode_set, & ch7017_detect, (struct drm_display_mode *(*)(struct intel_dvo_device * ))0,
    & ch7017_destroy, & ch7017_dump_regs};
static void ivch_dump_regs(struct intel_dvo_device *dvo ) ;
static bool ivch_read(struct intel_dvo_device *dvo , int addr , uint16_t *data )
{ struct ivch_priv *priv ;
  struct i2c_adapter *adapter ;
  u8 out_buf[1U] ;
  u8 in_buf[2U] ;
  struct i2c_msg msgs[3U] ;
  int tmp ;
  {
  {
  priv = (struct ivch_priv *)dvo->dev_priv;
  adapter = dvo->i2c_bus;
  msgs[0].addr = (unsigned short )dvo->slave_addr;
  msgs[0].flags = (__u16 )1U;
  msgs[0].len = (__u16 )0U;
  msgs[0].buf = (__u8 *)0;
  msgs[1].addr = (__u16 )0U;
  msgs[1].flags = (__u16 )16384U;
  msgs[1].len = (__u16 )1U;
  msgs[1].buf = (__u8 *)(& out_buf);
  msgs[2].addr = (unsigned short )dvo->slave_addr;
  msgs[2].flags = (__u16 )16385U;
  msgs[2].len = (__u16 )2U;
  msgs[2].buf = (__u8 *)(& in_buf);
  out_buf[0] = (u8 )addr;
  tmp = i2c_transfer(adapter, (struct i2c_msg *)(& msgs), 3);
  }
  if (tmp == 3) {
    *data = (uint16_t )((int )((short )((int )in_buf[1] << 8)) | (int )((short )in_buf[0]));
    return ((bool )1);
  } else {
  }
  if (! priv->quiet) {
    {
    drm_ut_debug_printk(4U, "drm", "ivch_read", "Unable to read register 0x%02x from %s:%02x.\n",
                        addr, (char *)(& adapter->name), dvo->slave_addr);
    }
  } else {
  }
  return ((bool )0);
}
}
static bool ivch_write(struct intel_dvo_device *dvo , int addr , uint16_t data )
{ struct ivch_priv *priv ;
  struct i2c_adapter *adapter ;
  u8 out_buf[3U] ;
  struct i2c_msg msg ;
  int tmp ;
  {
  {
  priv = (struct ivch_priv *)dvo->dev_priv;
  adapter = dvo->i2c_bus;
  msg.addr = (unsigned short )dvo->slave_addr;
  msg.flags = (__u16 )0U;
  msg.len = (__u16 )3U;
  msg.buf = (__u8 *)(& out_buf);
  out_buf[0] = (u8 )addr;
  out_buf[1] = (u8 )data;
  out_buf[2] = (u8 )((int )data >> 8);
  tmp = i2c_transfer(adapter, & msg, 1);
  }
  if (tmp == 1) {
    return ((bool )1);
  } else {
  }
  if (! priv->quiet) {
    {
    drm_ut_debug_printk(4U, "drm", "ivch_write", "Unable to write register 0x%02x to %s:%d.\n",
                        addr, (char *)(& adapter->name), dvo->slave_addr);
    }
  } else {
  }
  return ((bool )0);
}
}
static bool ivch_init(struct intel_dvo_device *dvo , struct i2c_adapter *adapter )
{ struct ivch_priv *priv ;
  uint16_t temp ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  {
  {
  tmp = kzalloc(6UL, 208U);
  priv = (struct ivch_priv *)tmp;
  }
  if ((unsigned long )priv == (unsigned long )((struct ivch_priv *)0)) {
    return ((bool )0);
  } else {
  }
  {
  dvo->i2c_bus = adapter;
  dvo->dev_priv = (void *)priv;
  priv->quiet = (bool )1;
  tmp___0 = ivch_read(dvo, 0, & temp);
  }
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    goto out;
  } else {
  }
  priv->quiet = (bool )0;
  if (((int )temp & 127) != dvo->slave_addr) {
    {
    drm_ut_debug_printk(4U, "drm", "ivch_init", "ivch detect failed due to address mismatch (%d vs %d)\n",
                        (int )temp & 127, dvo->slave_addr);
    }
    goto out;
  } else {
  }
  {
  ivch_read(dvo, 32, & priv->width);
  ivch_read(dvo, 32, & priv->height);
  }
  return ((bool )1);
  out:
  {
  kfree((void const *)priv);
  }
  return ((bool )0);
}
}
static enum drm_connector_status ivch_detect(struct intel_dvo_device *dvo )
{
  {
  return ((enum drm_connector_status )1);
}
}
static enum drm_mode_status ivch_mode_valid(struct intel_dvo_device *dvo , struct drm_display_mode *mode )
{
  {
  if (mode->clock > 112000) {
    return ((enum drm_mode_status )15);
  } else {
  }
  return ((enum drm_mode_status )0);
}
}
static void ivch_dpms(struct intel_dvo_device *dvo , int mode )
{ int i ;
  uint16_t vr01 ;
  uint16_t vr30 ;
  uint16_t backlight ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  {
  {
  tmp = ivch_read(dvo, 1, & vr01);
  }
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {
  }
  if (mode == 0) {
    backlight = (uint16_t )1U;
  } else {
    backlight = (uint16_t )0U;
  }
  {
  ivch_write(dvo, 128, (uint16_t )((int )backlight));
  }
  if (mode == 0) {
    vr01 = (uint16_t )((unsigned int )vr01 | 5U);
  } else {
    vr01 = (uint16_t )((unsigned int )vr01 & 65530U);
  }
  {
  ivch_write(dvo, 1, (uint16_t )((int )vr01));
  i = 0;
  }
  goto ldv_37364;
  ldv_37363:
  {
  tmp___1 = ivch_read(dvo, 48, & vr30);
  }
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    goto ldv_37362;
  } else {
  }
  if (((int )((short )vr30) >= 0) ^ (mode == 0)) {
    goto ldv_37362;
  } else {
  }
  {
  __const_udelay(4295000UL);
  i = i + 1;
  }
  ldv_37364: ;
  if (i <= 99) {
    goto ldv_37363;
  } else {
    goto ldv_37362;
  }
  ldv_37362:
  {
  __const_udelay(68720000UL);
  }
  return;
}
}
static void ivch_mode_set(struct intel_dvo_device *dvo , struct drm_display_mode *mode ,
                          struct drm_display_mode *adjusted_mode )
{ uint16_t vr40 ;
  uint16_t vr01 ;
  uint16_t x_ratio ;
  uint16_t y_ratio ;
  {
  vr40 = (uint16_t )0U;
  vr01 = (uint16_t )0U;
  vr40 = (uint16_t )13312U;
  if (mode->hdisplay != adjusted_mode->hdisplay) {
    goto _L;
  } else
  if (mode->vdisplay != adjusted_mode->vdisplay) {
    _L:
    {
    vr01 = (uint16_t )((unsigned int )vr01 | 8U);
    vr40 = (uint16_t )((unsigned int )vr40 | 256U);
    x_ratio = (uint16_t )(((mode->hdisplay + -1) << 16) / (adjusted_mode->hdisplay + -1) >> 2);
    y_ratio = (uint16_t )(((mode->vdisplay + -1) << 16) / (adjusted_mode->vdisplay + -1) >> 2);
    ivch_write(dvo, 66, (uint16_t )((int )x_ratio));
    ivch_write(dvo, 65, (uint16_t )((int )y_ratio));
    }
  } else {
    vr01 = (uint16_t )((unsigned int )vr01 & 65527U);
    vr40 = (uint16_t )((unsigned int )vr40 & 65279U);
  }
  {
  vr40 = (uint16_t )((unsigned int )vr40 & 65023U);
  ivch_write(dvo, 1, (uint16_t )((int )vr01));
  ivch_write(dvo, 64, (uint16_t )((int )vr40));
  ivch_dump_regs(dvo);
  }
  return;
}
}
static void ivch_dump_regs(struct intel_dvo_device *dvo )
{ uint16_t val ;
  {
  {
  ivch_read(dvo, 0, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "VR00: 0x%04x\n",
                      (int )val);
  ivch_read(dvo, 1, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "VR01: 0x%04x\n",
                      (int )val);
  ivch_read(dvo, 48, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "VR30: 0x%04x\n",
                      (int )val);
  ivch_read(dvo, 64, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "VR40: 0x%04x\n",
                      (int )val);
  ivch_read(dvo, 128, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "VR80: 0x%04x\n",
                      (int )val);
  ivch_read(dvo, 129, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "VR81: 0x%04x\n",
                      (int )val);
  ivch_read(dvo, 130, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "VR82: 0x%04x\n",
                      (int )val);
  ivch_read(dvo, 131, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "VR83: 0x%04x\n",
                      (int )val);
  ivch_read(dvo, 132, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "VR84: 0x%04x\n",
                      (int )val);
  ivch_read(dvo, 133, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "VR85: 0x%04x\n",
                      (int )val);
  ivch_read(dvo, 134, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "VR86: 0x%04x\n",
                      (int )val);
  ivch_read(dvo, 135, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "VR87: 0x%04x\n",
                      (int )val);
  ivch_read(dvo, 136, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "VR88: 0x%04x\n",
                      (int )val);
  ivch_read(dvo, 142, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "VR8E: 0x%04x\n",
                      (int )val);
  ivch_read(dvo, 143, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "VR8F: 0x%04x\n",
                      (int )val);
  }
  return;
}
}
static void ivch_destroy(struct intel_dvo_device *dvo )
{ struct ivch_priv *priv ;
  {
  priv = (struct ivch_priv *)dvo->dev_priv;
  if ((unsigned long )priv != (unsigned long )((struct ivch_priv *)0)) {
    {
    kfree((void const *)priv);
    dvo->dev_priv = (void *)0;
    }
  } else {
  }
  return;
}
}
struct intel_dvo_dev_ops ivch_ops =
     {& ivch_init, (void (*)(struct intel_dvo_device * ))0, & ivch_dpms, (int (*)(struct intel_dvo_device * ,
                                                                                struct drm_display_mode * ))(& ivch_mode_valid),
    (bool (*)(struct intel_dvo_device * , struct drm_display_mode * , struct drm_display_mode * ))0,
    (void (*)(struct intel_dvo_device * ))0, (void (*)(struct intel_dvo_device * ))0,
    & ivch_mode_set, & ivch_detect, (struct drm_display_mode *(*)(struct intel_dvo_device * ))0,
    & ivch_destroy, & ivch_dump_regs};
static bool tfp410_readb(struct intel_dvo_device *dvo , int addr , uint8_t *ch )
{ struct tfp410_priv *tfp ;
  struct i2c_adapter *adapter ;
  u8 out_buf[2U] ;
  u8 in_buf[2U] ;
  struct i2c_msg msgs[2U] ;
  int tmp ;
  {
  {
  tfp = (struct tfp410_priv *)dvo->dev_priv;
  adapter = dvo->i2c_bus;
  msgs[0].addr = (unsigned short )dvo->slave_addr;
  msgs[0].flags = (__u16 )0U;
  msgs[0].len = (__u16 )1U;
  msgs[0].buf = (__u8 *)(& out_buf);
  msgs[1].addr = (unsigned short )dvo->slave_addr;
  msgs[1].flags = (__u16 )1U;
  msgs[1].len = (__u16 )1U;
  msgs[1].buf = (__u8 *)(& in_buf);
  out_buf[0] = (u8 )addr;
  out_buf[1] = (u8 )0U;
  tmp = i2c_transfer(adapter, (struct i2c_msg *)(& msgs), 2);
  }
  if (tmp == 2) {
    *ch = in_buf[0];
    return ((bool )1);
  } else {
  }
  if (! tfp->quiet) {
    {
    drm_ut_debug_printk(4U, "drm", "tfp410_readb", "Unable to read register 0x%02x from %s:%02x.\n",
                        addr, (char *)(& adapter->name), dvo->slave_addr);
    }
  } else {
  }
  return ((bool )0);
}
}
static bool tfp410_writeb(struct intel_dvo_device *dvo , int addr , uint8_t ch )
{ struct tfp410_priv *tfp ;
  struct i2c_adapter *adapter ;
  uint8_t out_buf[2U] ;
  struct i2c_msg msg ;
  int tmp ;
  {
  {
  tfp = (struct tfp410_priv *)dvo->dev_priv;
  adapter = dvo->i2c_bus;
  msg.addr = (unsigned short )dvo->slave_addr;
  msg.flags = (__u16 )0U;
  msg.len = (__u16 )2U;
  msg.buf = (__u8 *)(& out_buf);
  out_buf[0] = (uint8_t )addr;
  out_buf[1] = ch;
  tmp = i2c_transfer(adapter, & msg, 1);
  }
  if (tmp == 1) {
    return ((bool )1);
  } else {
  }
  if (! tfp->quiet) {
    {
    drm_ut_debug_printk(4U, "drm", "tfp410_writeb", "Unable to write register 0x%02x to %s:%d.\n",
                        addr, (char *)(& adapter->name), dvo->slave_addr);
    }
  } else {
  }
  return ((bool )0);
}
}
static int tfp410_getid(struct intel_dvo_device *dvo , int addr )
{ uint8_t ch1 ;
  uint8_t ch2 ;
  bool tmp ;
  bool tmp___0 ;
  {
  {
  tmp = tfp410_readb(dvo, addr, & ch1);
  }
  if ((int )tmp) {
    {
    tmp___0 = tfp410_readb(dvo, addr + 1, & ch2);
    }
    if ((int )tmp___0) {
      return ((((int )ch2 << 8) & 65535) | (int )ch1);
    } else {
    }
  } else {
  }
  return (-1);
}
}
static bool tfp410_init(struct intel_dvo_device *dvo , struct i2c_adapter *adapter )
{ struct tfp410_priv *tfp ;
  int id ;
  void *tmp ;
  {
  {
  tmp = kzalloc(1UL, 208U);
  tfp = (struct tfp410_priv *)tmp;
  }
  if ((unsigned long )tfp == (unsigned long )((struct tfp410_priv *)0)) {
    return ((bool )0);
  } else {
  }
  {
  dvo->i2c_bus = adapter;
  dvo->dev_priv = (void *)tfp;
  tfp->quiet = (bool )1;
  id = tfp410_getid(dvo, 0);
  }
  if (id != 332) {
    {
    drm_ut_debug_printk(4U, "drm", "tfp410_init", "tfp410 not detected got VID %X: from %s Slave %d.\n",
                        id, (char *)(& adapter->name), dvo->slave_addr);
    }
    goto out;
  } else {
  }
  {
  id = tfp410_getid(dvo, 2);
  }
  if (id != 1040) {
    {
    drm_ut_debug_printk(4U, "drm", "tfp410_init", "tfp410 not detected got DID %X: from %s Slave %d.\n",
                        id, (char *)(& adapter->name), dvo->slave_addr);
    }
    goto out;
  } else {
  }
  tfp->quiet = (bool )0;
  return ((bool )1);
  out:
  {
  kfree((void const *)tfp);
  }
  return ((bool )0);
}
}
static enum drm_connector_status tfp410_detect(struct intel_dvo_device *dvo )
{ enum drm_connector_status ret ;
  uint8_t ctl2 ;
  bool tmp ;
  {
  {
  ret = (enum drm_connector_status )2;
  tmp = tfp410_readb(dvo, 9, & ctl2);
  }
  if ((int )tmp) {
    if (((int )ctl2 & 4) != 0) {
      ret = (enum drm_connector_status )1;
    } else {
      ret = (enum drm_connector_status )2;
    }
  } else {
  }
  return (ret);
}
}
static enum drm_mode_status tfp410_mode_valid(struct intel_dvo_device *dvo , struct drm_display_mode *mode )
{
  {
  return ((enum drm_mode_status )0);
}
}
static void tfp410_mode_set(struct intel_dvo_device *dvo , struct drm_display_mode *mode ,
                            struct drm_display_mode *adjusted_mode )
{
  {
  return;
}
}
static void tfp410_dpms(struct intel_dvo_device *dvo , int mode )
{ uint8_t ctl1 ;
  bool tmp ;
  int tmp___0 ;
  {
  {
  tmp = tfp410_readb(dvo, 8, & ctl1);
  }
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {
  }
  if (mode == 0) {
    ctl1 = (uint8_t )((unsigned int )ctl1 | 1U);
  } else {
    ctl1 = (uint8_t )((unsigned int )ctl1 & 254U);
  }
  {
  tfp410_writeb(dvo, 8, (uint8_t )((int )ctl1));
  }
  return;
}
}
static void tfp410_dump_regs(struct intel_dvo_device *dvo )
{ uint8_t val ;
  uint8_t val2 ;
  {
  {
  tfp410_readb(dvo, 4, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "TFP410_REV: 0x%02X\n",
                      (int )val);
  tfp410_readb(dvo, 8, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "TFP410_CTL1: 0x%02X\n",
                      (int )val);
  tfp410_readb(dvo, 9, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "TFP410_CTL2: 0x%02X\n",
                      (int )val);
  tfp410_readb(dvo, 10, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "TFP410_CTL3: 0x%02X\n",
                      (int )val);
  tfp410_readb(dvo, 11, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "TFP410_USERCFG: 0x%02X\n",
                      (int )val);
  tfp410_readb(dvo, 50, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "TFP410_DE_DLY: 0x%02X\n",
                      (int )val);
  tfp410_readb(dvo, 51, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "TFP410_DE_CTL: 0x%02X\n",
                      (int )val);
  tfp410_readb(dvo, 52, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "TFP410_DE_TOP: 0x%02X\n",
                      (int )val);
  tfp410_readb(dvo, 54, & val);
  tfp410_readb(dvo, 55, & val2);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "TFP410_DE_CNT: 0x%02X%02X\n",
                      (int )val2, (int )val);
  tfp410_readb(dvo, 56, & val);
  tfp410_readb(dvo, 57, & val2);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "TFP410_DE_LIN: 0x%02X%02X\n",
                      (int )val2, (int )val);
  tfp410_readb(dvo, 58, & val);
  tfp410_readb(dvo, 59, & val2);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "TFP410_H_RES: 0x%02X%02X\n",
                      (int )val2, (int )val);
  tfp410_readb(dvo, 60, & val);
  tfp410_readb(dvo, 61, & val2);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "TFP410_V_RES: 0x%02X%02X\n",
                      (int )val2, (int )val);
  }
  return;
}
}
static void tfp410_destroy(struct intel_dvo_device *dvo )
{ struct tfp410_priv *tfp ;
  {
  tfp = (struct tfp410_priv *)dvo->dev_priv;
  if ((unsigned long )tfp != (unsigned long )((struct tfp410_priv *)0)) {
    {
    kfree((void const *)tfp);
    dvo->dev_priv = (void *)0;
    }
  } else {
  }
  return;
}
}
struct intel_dvo_dev_ops tfp410_ops =
     {& tfp410_init, (void (*)(struct intel_dvo_device * ))0, & tfp410_dpms, (int (*)(struct intel_dvo_device * ,
                                                                                    struct drm_display_mode * ))(& tfp410_mode_valid),
    (bool (*)(struct intel_dvo_device * , struct drm_display_mode * , struct drm_display_mode * ))0,
    (void (*)(struct intel_dvo_device * ))0, (void (*)(struct intel_dvo_device * ))0,
    & tfp410_mode_set, & tfp410_detect, (struct drm_display_mode *(*)(struct intel_dvo_device * ))0,
    & tfp410_destroy, & tfp410_dump_regs};
static bool sil164_readb(struct intel_dvo_device *dvo , int addr , uint8_t *ch )
{ struct sil164_priv *sil ;
  struct i2c_adapter *adapter ;
  u8 out_buf[2U] ;
  u8 in_buf[2U] ;
  struct i2c_msg msgs[2U] ;
  int tmp ;
  {
  {
  sil = (struct sil164_priv *)dvo->dev_priv;
  adapter = dvo->i2c_bus;
  msgs[0].addr = (unsigned short )dvo->slave_addr;
  msgs[0].flags = (__u16 )0U;
  msgs[0].len = (__u16 )1U;
  msgs[0].buf = (__u8 *)(& out_buf);
  msgs[1].addr = (unsigned short )dvo->slave_addr;
  msgs[1].flags = (__u16 )1U;
  msgs[1].len = (__u16 )1U;
  msgs[1].buf = (__u8 *)(& in_buf);
  out_buf[0] = (u8 )addr;
  out_buf[1] = (u8 )0U;
  tmp = i2c_transfer(adapter, (struct i2c_msg *)(& msgs), 2);
  }
  if (tmp == 2) {
    *ch = in_buf[0];
    return ((bool )1);
  } else {
  }
  if (! sil->quiet) {
    {
    drm_ut_debug_printk(4U, "drm", "sil164_readb", "Unable to read register 0x%02x from %s:%02x.\n",
                        addr, (char *)(& adapter->name), dvo->slave_addr);
    }
  } else {
  }
  return ((bool )0);
}
}
static bool sil164_writeb(struct intel_dvo_device *dvo , int addr , uint8_t ch )
{ struct sil164_priv *sil ;
  struct i2c_adapter *adapter ;
  uint8_t out_buf[2U] ;
  struct i2c_msg msg ;
  int tmp ;
  {
  {
  sil = (struct sil164_priv *)dvo->dev_priv;
  adapter = dvo->i2c_bus;
  msg.addr = (unsigned short )dvo->slave_addr;
  msg.flags = (__u16 )0U;
  msg.len = (__u16 )2U;
  msg.buf = (__u8 *)(& out_buf);
  out_buf[0] = (uint8_t )addr;
  out_buf[1] = ch;
  tmp = i2c_transfer(adapter, & msg, 1);
  }
  if (tmp == 1) {
    return ((bool )1);
  } else {
  }
  if (! sil->quiet) {
    {
    drm_ut_debug_printk(4U, "drm", "sil164_writeb", "Unable to write register 0x%02x to %s:%d.\n",
                        addr, (char *)(& adapter->name), dvo->slave_addr);
    }
  } else {
  }
  return ((bool )0);
}
}
static bool sil164_init(struct intel_dvo_device *dvo , struct i2c_adapter *adapter )
{ struct sil164_priv *sil ;
  unsigned char ch ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  {
  {
  tmp = kzalloc(1UL, 208U);
  sil = (struct sil164_priv *)tmp;
  }
  if ((unsigned long )sil == (unsigned long )((struct sil164_priv *)0)) {
    return ((bool )0);
  } else {
  }
  {
  dvo->i2c_bus = adapter;
  dvo->dev_priv = (void *)sil;
  sil->quiet = (bool )1;
  tmp___0 = sil164_readb(dvo, 0, & ch);
  }
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    goto out;
  } else {
  }
  if ((unsigned int )ch != 1U) {
    {
    drm_ut_debug_printk(4U, "drm", "sil164_init", "sil164 not detected got %d: from %s Slave %d.\n",
                        (int )ch, (char *)(& adapter->name), dvo->slave_addr);
    }
    goto out;
  } else {
  }
  {
  tmp___2 = sil164_readb(dvo, 2, & ch);
  }
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    goto out;
  } else {
  }
  if ((unsigned int )ch != 6U) {
    {
    drm_ut_debug_printk(4U, "drm", "sil164_init", "sil164 not detected got %d: from %s Slave %d.\n",
                        (int )ch, (char *)(& adapter->name), dvo->slave_addr);
    }
    goto out;
  } else {
  }
  {
  sil->quiet = (bool )0;
  drm_ut_debug_printk(4U, "drm", "sil164_init", "init sil164 dvo controller successfully!\n");
  }
  return ((bool )1);
  out:
  {
  kfree((void const *)sil);
  }
  return ((bool )0);
}
}
static enum drm_connector_status sil164_detect(struct intel_dvo_device *dvo )
{ uint8_t reg9 ;
  {
  {
  sil164_readb(dvo, 9, & reg9);
  }
  if (((int )reg9 & 2) != 0) {
    return ((enum drm_connector_status )1);
  } else {
    return ((enum drm_connector_status )2);
  }
}
}
static enum drm_mode_status sil164_mode_valid(struct intel_dvo_device *dvo , struct drm_display_mode *mode )
{
  {
  return ((enum drm_mode_status )0);
}
}
static void sil164_mode_set(struct intel_dvo_device *dvo , struct drm_display_mode *mode ,
                            struct drm_display_mode *adjusted_mode )
{
  {
  return;
}
}
static void sil164_dpms(struct intel_dvo_device *dvo , int mode )
{ int ret ;
  unsigned char ch ;
  bool tmp ;
  {
  {
  tmp = sil164_readb(dvo, 8, & ch);
  ret = (int )tmp;
  }
  if (ret == 0) {
    return;
  } else {
  }
  if (mode == 0) {
    ch = (unsigned char )((unsigned int )ch | 1U);
  } else {
    ch = (unsigned char )((unsigned int )ch & 254U);
  }
  {
  sil164_writeb(dvo, 8, (uint8_t )((int )ch));
  }
  return;
}
}
static void sil164_dump_regs(struct intel_dvo_device *dvo )
{ uint8_t val ;
  {
  {
  sil164_readb(dvo, 6, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "SIL164_FREQ_LO: 0x%02x\n",
                      (int )val);
  sil164_readb(dvo, 7, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "SIL164_FREQ_HI: 0x%02x\n",
                      (int )val);
  sil164_readb(dvo, 8, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "SIL164_REG8: 0x%02x\n",
                      (int )val);
  sil164_readb(dvo, 9, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "SIL164_REG9: 0x%02x\n",
                      (int )val);
  sil164_readb(dvo, 12, & val);
  drm_ut_debug_printk(4U, (char const *)0, (char const *)0, "SIL164_REGC: 0x%02x\n",
                      (int )val);
  }
  return;
}
}
static void sil164_destroy(struct intel_dvo_device *dvo )
{ struct sil164_priv *sil ;
  {
  sil = (struct sil164_priv *)dvo->dev_priv;
  if ((unsigned long )sil != (unsigned long )((struct sil164_priv *)0)) {
    {
    kfree((void const *)sil);
    dvo->dev_priv = (void *)0;
    }
  } else {
  }
  return;
}
}
struct intel_dvo_dev_ops sil164_ops =
     {& sil164_init, (void (*)(struct intel_dvo_device * ))0, & sil164_dpms, (int (*)(struct intel_dvo_device * ,
                                                                                    struct drm_display_mode * ))(& sil164_mode_valid),
    (bool (*)(struct intel_dvo_device * , struct drm_display_mode * , struct drm_display_mode * ))0,
    (void (*)(struct intel_dvo_device * ))0, (void (*)(struct intel_dvo_device * ))0,
    & sil164_mode_set, & sil164_detect, (struct drm_display_mode *(*)(struct intel_dvo_device * ))0,
    & sil164_destroy, & sil164_dump_regs};
extern void *compat_alloc_user_space(unsigned long ) ;
extern long drm_compat_ioctl(struct file * , unsigned int , unsigned long ) ;
static int compat_i915_batchbuffer(struct file *file , unsigned int cmd , unsigned long arg )
{ drm_i915_batchbuffer32_t batchbuffer32 ;
  drm_i915_batchbuffer_t *batchbuffer ;
  unsigned long tmp ;
  void *tmp___0 ;
  unsigned long flag ;
  unsigned long roksum ;
  struct thread_info *tmp___1 ;
  long tmp___2 ;
  int __pu_err ;
  int __pu_err___0 ;
  int __pu_err___1 ;
  int __pu_err___2 ;
  int __pu_err___3 ;
  int __pu_err___4 ;
  long tmp___3 ;
  {
  {
  tmp = copy_from_user((void *)(& batchbuffer32), (void const *)arg, 24UL);
  }
  if (tmp != 0UL) {
    return (-14);
  } else {
  }
  {
  tmp___0 = compat_alloc_user_space(32UL);
  batchbuffer = (drm_i915_batchbuffer_t *)tmp___0;
  tmp___1 = current_thread_info();
  __asm__ ("add %3,%1 ; sbb %0,%0 ; cmp %1,%4 ; sbb $0,%0": "=&r" (flag), "=r" (roksum): "1" (batchbuffer),
            "g" (32L), "rm" (tmp___1->addr_limit.seg));
  tmp___2 = __builtin_expect((long )(flag == 0UL), 1L);
  }
  if (tmp___2 == 0L) {
    return (-14);
  } else {
    __pu_err = 0;
    if (1) {
      goto case_4;
    } else {
      goto switch_default;
      if (0) {
        __asm__ volatile ("1:\tmovb %b1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err): "iq" (batchbuffer32.start),
                             "m" (*((struct __large_struct *)(& batchbuffer->start))),
                             "i" (-14), "0" (__pu_err));
        goto ldv_34780;
        __asm__ volatile ("1:\tmovw %w1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err): "ir" (batchbuffer32.start),
                             "m" (*((struct __large_struct *)(& batchbuffer->start))),
                             "i" (-14), "0" (__pu_err));
        goto ldv_34780;
        case_4:
        __asm__ volatile ("1:\tmovl %k1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err): "ir" (batchbuffer32.start),
                             "m" (*((struct __large_struct *)(& batchbuffer->start))),
                             "i" (-14), "0" (__pu_err));
        goto ldv_34780;
        __asm__ volatile ("1:\tmovq %1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err): "er" (batchbuffer32.start),
                             "m" (*((struct __large_struct *)(& batchbuffer->start))),
                             "i" (-14), "0" (__pu_err));
        goto ldv_34780;
        switch_default:
        {
        __put_user_bad();
        }
      } else {
      }
    }
    ldv_34780: ;
    if (__pu_err != 0) {
      return (-14);
    } else {
      __pu_err___0 = 0;
      if (1) {
        goto case_4___0;
      } else {
        goto switch_default___0;
        if (0) {
          __asm__ volatile ("1:\tmovb %b1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___0): "iq" (batchbuffer32.used),
                               "m" (*((struct __large_struct *)(& batchbuffer->used))),
                               "i" (-14), "0" (__pu_err___0));
          goto ldv_34788;
          __asm__ volatile ("1:\tmovw %w1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___0): "ir" (batchbuffer32.used),
                               "m" (*((struct __large_struct *)(& batchbuffer->used))),
                               "i" (-14), "0" (__pu_err___0));
          goto ldv_34788;
          case_4___0:
          __asm__ volatile ("1:\tmovl %k1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___0): "ir" (batchbuffer32.used),
                               "m" (*((struct __large_struct *)(& batchbuffer->used))),
                               "i" (-14), "0" (__pu_err___0));
          goto ldv_34788;
          __asm__ volatile ("1:\tmovq %1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___0): "er" (batchbuffer32.used),
                               "m" (*((struct __large_struct *)(& batchbuffer->used))),
                               "i" (-14), "0" (__pu_err___0));
          goto ldv_34788;
          switch_default___0:
          {
          __put_user_bad();
          }
        } else {
        }
      }
      ldv_34788: ;
      if (__pu_err___0 != 0) {
        return (-14);
      } else {
        __pu_err___1 = 0;
        if (1) {
          goto case_4___1;
        } else {
          goto switch_default___1;
          if (0) {
            __asm__ volatile ("1:\tmovb %b1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___1): "iq" (batchbuffer32.DR1),
                                 "m" (*((struct __large_struct *)(& batchbuffer->DR1))),
                                 "i" (-14), "0" (__pu_err___1));
            goto ldv_34796;
            __asm__ volatile ("1:\tmovw %w1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___1): "ir" (batchbuffer32.DR1),
                                 "m" (*((struct __large_struct *)(& batchbuffer->DR1))),
                                 "i" (-14), "0" (__pu_err___1));
            goto ldv_34796;
            case_4___1:
            __asm__ volatile ("1:\tmovl %k1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___1): "ir" (batchbuffer32.DR1),
                                 "m" (*((struct __large_struct *)(& batchbuffer->DR1))),
                                 "i" (-14), "0" (__pu_err___1));
            goto ldv_34796;
            __asm__ volatile ("1:\tmovq %1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___1): "er" (batchbuffer32.DR1),
                                 "m" (*((struct __large_struct *)(& batchbuffer->DR1))),
                                 "i" (-14), "0" (__pu_err___1));
            goto ldv_34796;
            switch_default___1:
            {
            __put_user_bad();
            }
          } else {
          }
        }
        ldv_34796: ;
        if (__pu_err___1 != 0) {
          return (-14);
        } else {
          __pu_err___2 = 0;
          if (1) {
            goto case_4___2;
          } else {
            goto switch_default___2;
            if (0) {
              __asm__ volatile ("1:\tmovb %b1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___2): "iq" (batchbuffer32.DR4),
                                   "m" (*((struct __large_struct *)(& batchbuffer->DR4))),
                                   "i" (-14), "0" (__pu_err___2));
              goto ldv_34804;
              __asm__ volatile ("1:\tmovw %w1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___2): "ir" (batchbuffer32.DR4),
                                   "m" (*((struct __large_struct *)(& batchbuffer->DR4))),
                                   "i" (-14), "0" (__pu_err___2));
              goto ldv_34804;
              case_4___2:
              __asm__ volatile ("1:\tmovl %k1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___2): "ir" (batchbuffer32.DR4),
                                   "m" (*((struct __large_struct *)(& batchbuffer->DR4))),
                                   "i" (-14), "0" (__pu_err___2));
              goto ldv_34804;
              __asm__ volatile ("1:\tmovq %1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___2): "er" (batchbuffer32.DR4),
                                   "m" (*((struct __large_struct *)(& batchbuffer->DR4))),
                                   "i" (-14), "0" (__pu_err___2));
              goto ldv_34804;
              switch_default___2:
              {
              __put_user_bad();
              }
            } else {
            }
          }
          ldv_34804: ;
          if (__pu_err___2 != 0) {
            return (-14);
          } else {
            __pu_err___3 = 0;
            if (1) {
              goto case_4___3;
            } else {
              goto switch_default___3;
              if (0) {
                __asm__ volatile ("1:\tmovb %b1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___3): "iq" (batchbuffer32.num_cliprects),
                                     "m" (*((struct __large_struct *)(& batchbuffer->num_cliprects))),
                                     "i" (-14), "0" (__pu_err___3));
                goto ldv_34812;
                __asm__ volatile ("1:\tmovw %w1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___3): "ir" (batchbuffer32.num_cliprects),
                                     "m" (*((struct __large_struct *)(& batchbuffer->num_cliprects))),
                                     "i" (-14), "0" (__pu_err___3));
                goto ldv_34812;
                case_4___3:
                __asm__ volatile ("1:\tmovl %k1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___3): "ir" (batchbuffer32.num_cliprects),
                                     "m" (*((struct __large_struct *)(& batchbuffer->num_cliprects))),
                                     "i" (-14), "0" (__pu_err___3));
                goto ldv_34812;
                __asm__ volatile ("1:\tmovq %1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___3): "er" (batchbuffer32.num_cliprects),
                                     "m" (*((struct __large_struct *)(& batchbuffer->num_cliprects))),
                                     "i" (-14), "0" (__pu_err___3));
                goto ldv_34812;
                switch_default___3:
                {
                __put_user_bad();
                }
              } else {
              }
            }
            ldv_34812: ;
            if (__pu_err___3 != 0) {
              return (-14);
            } else {
              __pu_err___4 = 0;
              if (1) {
                goto case_8___4;
              } else {
                goto switch_default___4;
                if (0) {
                  __asm__ volatile ("1:\tmovb %b1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___4): "iq" ((struct drm_clip_rect *)((unsigned long )batchbuffer32.cliprects)),
                                       "m" (*((struct __large_struct *)(& batchbuffer->cliprects))),
                                       "i" (-14), "0" (__pu_err___4));
                  goto ldv_34820;
                  __asm__ volatile ("1:\tmovw %w1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___4): "ir" ((struct drm_clip_rect *)((unsigned long )batchbuffer32.cliprects)),
                                       "m" (*((struct __large_struct *)(& batchbuffer->cliprects))),
                                       "i" (-14), "0" (__pu_err___4));
                  goto ldv_34820;
                  __asm__ volatile ("1:\tmovl %k1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___4): "ir" ((struct drm_clip_rect *)((unsigned long )batchbuffer32.cliprects)),
                                       "m" (*((struct __large_struct *)(& batchbuffer->cliprects))),
                                       "i" (-14), "0" (__pu_err___4));
                  goto ldv_34820;
                  case_8___4:
                  __asm__ volatile ("1:\tmovq %1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___4): "er" ((struct drm_clip_rect *)((unsigned long )batchbuffer32.cliprects)),
                                       "m" (*((struct __large_struct *)(& batchbuffer->cliprects))),
                                       "i" (-14), "0" (__pu_err___4));
                  goto ldv_34820;
                  switch_default___4:
                  {
                  __put_user_bad();
                  }
                } else {
                }
              }
              ldv_34820: ;
              if (__pu_err___4 != 0) {
                return (-14);
              } else {
              }
            }
          }
        }
      }
    }
  }
  {
  tmp___3 = drm_ioctl(file, 1075864643U, (unsigned long )batchbuffer);
  }
  return ((int )tmp___3);
}
}
static int compat_i915_cmdbuffer(struct file *file , unsigned int cmd , unsigned long arg )
{ drm_i915_cmdbuffer32_t cmdbuffer32 ;
  drm_i915_cmdbuffer_t *cmdbuffer ;
  unsigned long tmp ;
  void *tmp___0 ;
  unsigned long flag ;
  unsigned long roksum ;
  struct thread_info *tmp___1 ;
  long tmp___2 ;
  int __pu_err ;
  int __pu_err___0 ;
  int __pu_err___1 ;
  int __pu_err___2 ;
  int __pu_err___3 ;
  int __pu_err___4 ;
  long tmp___3 ;
  {
  {
  tmp = copy_from_user((void *)(& cmdbuffer32), (void const *)arg, 24UL);
  }
  if (tmp != 0UL) {
    return (-14);
  } else {
  }
  {
  tmp___0 = compat_alloc_user_space(32UL);
  cmdbuffer = (drm_i915_cmdbuffer_t *)tmp___0;
  tmp___1 = current_thread_info();
  __asm__ ("add %3,%1 ; sbb %0,%0 ; cmp %1,%4 ; sbb $0,%0": "=&r" (flag), "=r" (roksum): "1" (cmdbuffer),
            "g" (32L), "rm" (tmp___1->addr_limit.seg));
  tmp___2 = __builtin_expect((long )(flag == 0UL), 1L);
  }
  if (tmp___2 == 0L) {
    return (-14);
  } else {
    __pu_err = 0;
    if (1) {
      goto case_8;
    } else {
      goto switch_default;
      if (0) {
        __asm__ volatile ("1:\tmovb %b1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err): "iq" ((char *)((unsigned long )cmdbuffer32.buf)),
                             "m" (*((struct __large_struct *)(& cmdbuffer->buf))),
                             "i" (-14), "0" (__pu_err));
        goto ldv_34846;
        __asm__ volatile ("1:\tmovw %w1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err): "ir" ((char *)((unsigned long )cmdbuffer32.buf)),
                             "m" (*((struct __large_struct *)(& cmdbuffer->buf))),
                             "i" (-14), "0" (__pu_err));
        goto ldv_34846;
        __asm__ volatile ("1:\tmovl %k1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err): "ir" ((char *)((unsigned long )cmdbuffer32.buf)),
                             "m" (*((struct __large_struct *)(& cmdbuffer->buf))),
                             "i" (-14), "0" (__pu_err));
        goto ldv_34846;
        case_8:
        __asm__ volatile ("1:\tmovq %1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err): "er" ((char *)((unsigned long )cmdbuffer32.buf)),
                             "m" (*((struct __large_struct *)(& cmdbuffer->buf))),
                             "i" (-14), "0" (__pu_err));
        goto ldv_34846;
        switch_default:
        {
        __put_user_bad();
        }
      } else {
      }
    }
    ldv_34846: ;
    if (__pu_err != 0) {
      return (-14);
    } else {
      __pu_err___0 = 0;
      if (1) {
        goto case_4___0;
      } else {
        goto switch_default___0;
        if (0) {
          __asm__ volatile ("1:\tmovb %b1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___0): "iq" (cmdbuffer32.sz),
                               "m" (*((struct __large_struct *)(& cmdbuffer->sz))),
                               "i" (-14), "0" (__pu_err___0));
          goto ldv_34854;
          __asm__ volatile ("1:\tmovw %w1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___0): "ir" (cmdbuffer32.sz),
                               "m" (*((struct __large_struct *)(& cmdbuffer->sz))),
                               "i" (-14), "0" (__pu_err___0));
          goto ldv_34854;
          case_4___0:
          __asm__ volatile ("1:\tmovl %k1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___0): "ir" (cmdbuffer32.sz),
                               "m" (*((struct __large_struct *)(& cmdbuffer->sz))),
                               "i" (-14), "0" (__pu_err___0));
          goto ldv_34854;
          __asm__ volatile ("1:\tmovq %1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___0): "er" (cmdbuffer32.sz),
                               "m" (*((struct __large_struct *)(& cmdbuffer->sz))),
                               "i" (-14), "0" (__pu_err___0));
          goto ldv_34854;
          switch_default___0:
          {
          __put_user_bad();
          }
        } else {
        }
      }
      ldv_34854: ;
      if (__pu_err___0 != 0) {
        return (-14);
      } else {
        __pu_err___1 = 0;
        if (1) {
          goto case_4___1;
        } else {
          goto switch_default___1;
          if (0) {
            __asm__ volatile ("1:\tmovb %b1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___1): "iq" (cmdbuffer32.DR1),
                                 "m" (*((struct __large_struct *)(& cmdbuffer->DR1))),
                                 "i" (-14), "0" (__pu_err___1));
            goto ldv_34862;
            __asm__ volatile ("1:\tmovw %w1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___1): "ir" (cmdbuffer32.DR1),
                                 "m" (*((struct __large_struct *)(& cmdbuffer->DR1))),
                                 "i" (-14), "0" (__pu_err___1));
            goto ldv_34862;
            case_4___1:
            __asm__ volatile ("1:\tmovl %k1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___1): "ir" (cmdbuffer32.DR1),
                                 "m" (*((struct __large_struct *)(& cmdbuffer->DR1))),
                                 "i" (-14), "0" (__pu_err___1));
            goto ldv_34862;
            __asm__ volatile ("1:\tmovq %1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___1): "er" (cmdbuffer32.DR1),
                                 "m" (*((struct __large_struct *)(& cmdbuffer->DR1))),
                                 "i" (-14), "0" (__pu_err___1));
            goto ldv_34862;
            switch_default___1:
            {
            __put_user_bad();
            }
          } else {
          }
        }
        ldv_34862: ;
        if (__pu_err___1 != 0) {
          return (-14);
        } else {
          __pu_err___2 = 0;
          if (1) {
            goto case_4___2;
          } else {
            goto switch_default___2;
            if (0) {
              __asm__ volatile ("1:\tmovb %b1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___2): "iq" (cmdbuffer32.DR4),
                                   "m" (*((struct __large_struct *)(& cmdbuffer->DR4))),
                                   "i" (-14), "0" (__pu_err___2));
              goto ldv_34870;
              __asm__ volatile ("1:\tmovw %w1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___2): "ir" (cmdbuffer32.DR4),
                                   "m" (*((struct __large_struct *)(& cmdbuffer->DR4))),
                                   "i" (-14), "0" (__pu_err___2));
              goto ldv_34870;
              case_4___2:
              __asm__ volatile ("1:\tmovl %k1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___2): "ir" (cmdbuffer32.DR4),
                                   "m" (*((struct __large_struct *)(& cmdbuffer->DR4))),
                                   "i" (-14), "0" (__pu_err___2));
              goto ldv_34870;
              __asm__ volatile ("1:\tmovq %1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___2): "er" (cmdbuffer32.DR4),
                                   "m" (*((struct __large_struct *)(& cmdbuffer->DR4))),
                                   "i" (-14), "0" (__pu_err___2));
              goto ldv_34870;
              switch_default___2:
              {
              __put_user_bad();
              }
            } else {
            }
          }
          ldv_34870: ;
          if (__pu_err___2 != 0) {
            return (-14);
          } else {
            __pu_err___3 = 0;
            if (1) {
              goto case_4___3;
            } else {
              goto switch_default___3;
              if (0) {
                __asm__ volatile ("1:\tmovb %b1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___3): "iq" (cmdbuffer32.num_cliprects),
                                     "m" (*((struct __large_struct *)(& cmdbuffer->num_cliprects))),
                                     "i" (-14), "0" (__pu_err___3));
                goto ldv_34878;
                __asm__ volatile ("1:\tmovw %w1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___3): "ir" (cmdbuffer32.num_cliprects),
                                     "m" (*((struct __large_struct *)(& cmdbuffer->num_cliprects))),
                                     "i" (-14), "0" (__pu_err___3));
                goto ldv_34878;
                case_4___3:
                __asm__ volatile ("1:\tmovl %k1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___3): "ir" (cmdbuffer32.num_cliprects),
                                     "m" (*((struct __large_struct *)(& cmdbuffer->num_cliprects))),
                                     "i" (-14), "0" (__pu_err___3));
                goto ldv_34878;
                __asm__ volatile ("1:\tmovq %1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___3): "er" (cmdbuffer32.num_cliprects),
                                     "m" (*((struct __large_struct *)(& cmdbuffer->num_cliprects))),
                                     "i" (-14), "0" (__pu_err___3));
                goto ldv_34878;
                switch_default___3:
                {
                __put_user_bad();
                }
              } else {
              }
            }
            ldv_34878: ;
            if (__pu_err___3 != 0) {
              return (-14);
            } else {
              __pu_err___4 = 0;
              if (1) {
                goto case_8___4;
              } else {
                goto switch_default___4;
                if (0) {
                  __asm__ volatile ("1:\tmovb %b1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___4): "iq" ((struct drm_clip_rect *)((unsigned long )cmdbuffer32.cliprects)),
                                       "m" (*((struct __large_struct *)(& cmdbuffer->cliprects))),
                                       "i" (-14), "0" (__pu_err___4));
                  goto ldv_34886;
                  __asm__ volatile ("1:\tmovw %w1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___4): "ir" ((struct drm_clip_rect *)((unsigned long )cmdbuffer32.cliprects)),
                                       "m" (*((struct __large_struct *)(& cmdbuffer->cliprects))),
                                       "i" (-14), "0" (__pu_err___4));
                  goto ldv_34886;
                  __asm__ volatile ("1:\tmovl %k1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___4): "ir" ((struct drm_clip_rect *)((unsigned long )cmdbuffer32.cliprects)),
                                       "m" (*((struct __large_struct *)(& cmdbuffer->cliprects))),
                                       "i" (-14), "0" (__pu_err___4));
                  goto ldv_34886;
                  case_8___4:
                  __asm__ volatile ("1:\tmovq %1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___4): "er" ((struct drm_clip_rect *)((unsigned long )cmdbuffer32.cliprects)),
                                       "m" (*((struct __large_struct *)(& cmdbuffer->cliprects))),
                                       "i" (-14), "0" (__pu_err___4));
                  goto ldv_34886;
                  switch_default___4:
                  {
                  __put_user_bad();
                  }
                } else {
                }
              }
              ldv_34886: ;
              if (__pu_err___4 != 0) {
                return (-14);
              } else {
              }
            }
          }
        }
      }
    }
  }
  {
  tmp___3 = drm_ioctl(file, 1075864651U, (unsigned long )cmdbuffer);
  }
  return ((int )tmp___3);
}
}
static int compat_i915_irq_emit(struct file *file , unsigned int cmd , unsigned long arg )
{ drm_i915_irq_emit32_t req32 ;
  drm_i915_irq_emit_t *request ;
  unsigned long tmp ;
  void *tmp___0 ;
  unsigned long flag ;
  unsigned long roksum ;
  struct thread_info *tmp___1 ;
  long tmp___2 ;
  int __pu_err ;
  long tmp___3 ;
  {
  {
  tmp = copy_from_user((void *)(& req32), (void const *)arg, 4UL);
  }
  if (tmp != 0UL) {
    return (-14);
  } else {
  }
  {
  tmp___0 = compat_alloc_user_space(8UL);
  request = (drm_i915_irq_emit_t *)tmp___0;
  tmp___1 = current_thread_info();
  __asm__ ("add %3,%1 ; sbb %0,%0 ; cmp %1,%4 ; sbb $0,%0": "=&r" (flag), "=r" (roksum): "1" (request),
            "g" (8L), "rm" (tmp___1->addr_limit.seg));
  tmp___2 = __builtin_expect((long )(flag == 0UL), 1L);
  }
  if (tmp___2 == 0L) {
    return (-14);
  } else {
    __pu_err = 0;
    if (1) {
      goto case_8;
    } else {
      goto switch_default;
      if (0) {
        __asm__ volatile ("1:\tmovb %b1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err): "iq" ((int *)((unsigned long )req32.irq_seq)),
                             "m" (*((struct __large_struct *)(& request->irq_seq))),
                             "i" (-14), "0" (__pu_err));
        goto ldv_34907;
        __asm__ volatile ("1:\tmovw %w1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err): "ir" ((int *)((unsigned long )req32.irq_seq)),
                             "m" (*((struct __large_struct *)(& request->irq_seq))),
                             "i" (-14), "0" (__pu_err));
        goto ldv_34907;
        __asm__ volatile ("1:\tmovl %k1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err): "ir" ((int *)((unsigned long )req32.irq_seq)),
                             "m" (*((struct __large_struct *)(& request->irq_seq))),
                             "i" (-14), "0" (__pu_err));
        goto ldv_34907;
        case_8:
        __asm__ volatile ("1:\tmovq %1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err): "er" ((int *)((unsigned long )req32.irq_seq)),
                             "m" (*((struct __large_struct *)(& request->irq_seq))),
                             "i" (-14), "0" (__pu_err));
        goto ldv_34907;
        switch_default:
        {
        __put_user_bad();
        }
      } else {
      }
    }
    ldv_34907: ;
    if (__pu_err != 0) {
      return (-14);
    } else {
    }
  }
  {
  tmp___3 = drm_ioctl(file, 3221775428U, (unsigned long )request);
  }
  return ((int )tmp___3);
}
}
static int compat_i915_getparam(struct file *file , unsigned int cmd , unsigned long arg )
{ drm_i915_getparam32_t req32 ;
  drm_i915_getparam_t *request ;
  unsigned long tmp ;
  void *tmp___0 ;
  unsigned long flag ;
  unsigned long roksum ;
  struct thread_info *tmp___1 ;
  long tmp___2 ;
  int __pu_err ;
  int __pu_err___0 ;
  long tmp___3 ;
  {
  {
  tmp = copy_from_user((void *)(& req32), (void const *)arg, 8UL);
  }
  if (tmp != 0UL) {
    return (-14);
  } else {
  }
  {
  tmp___0 = compat_alloc_user_space(16UL);
  request = (drm_i915_getparam_t *)tmp___0;
  tmp___1 = current_thread_info();
  __asm__ ("add %3,%1 ; sbb %0,%0 ; cmp %1,%4 ; sbb $0,%0": "=&r" (flag), "=r" (roksum): "1" (request),
            "g" (16L), "rm" (tmp___1->addr_limit.seg));
  tmp___2 = __builtin_expect((long )(flag == 0UL), 1L);
  }
  if (tmp___2 == 0L) {
    return (-14);
  } else {
    __pu_err = 0;
    if (1) {
      goto case_4;
    } else {
      goto switch_default;
      if (0) {
        __asm__ volatile ("1:\tmovb %b1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err): "iq" (req32.param),
                             "m" (*((struct __large_struct *)(& request->param))),
                             "i" (-14), "0" (__pu_err));
        goto ldv_34929;
        __asm__ volatile ("1:\tmovw %w1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err): "ir" (req32.param),
                             "m" (*((struct __large_struct *)(& request->param))),
                             "i" (-14), "0" (__pu_err));
        goto ldv_34929;
        case_4:
        __asm__ volatile ("1:\tmovl %k1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err): "ir" (req32.param),
                             "m" (*((struct __large_struct *)(& request->param))),
                             "i" (-14), "0" (__pu_err));
        goto ldv_34929;
        __asm__ volatile ("1:\tmovq %1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err): "er" (req32.param),
                             "m" (*((struct __large_struct *)(& request->param))),
                             "i" (-14), "0" (__pu_err));
        goto ldv_34929;
        switch_default:
        {
        __put_user_bad();
        }
      } else {
      }
    }
    ldv_34929: ;
    if (__pu_err != 0) {
      return (-14);
    } else {
      __pu_err___0 = 0;
      if (1) {
        goto case_8___0;
      } else {
        goto switch_default___0;
        if (0) {
          __asm__ volatile ("1:\tmovb %b1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___0): "iq" ((int *)((unsigned long )req32.value)),
                               "m" (*((struct __large_struct *)(& request->value))),
                               "i" (-14), "0" (__pu_err___0));
          goto ldv_34937;
          __asm__ volatile ("1:\tmovw %w1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___0): "ir" ((int *)((unsigned long )req32.value)),
                               "m" (*((struct __large_struct *)(& request->value))),
                               "i" (-14), "0" (__pu_err___0));
          goto ldv_34937;
          __asm__ volatile ("1:\tmovl %k1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___0): "ir" ((int *)((unsigned long )req32.value)),
                               "m" (*((struct __large_struct *)(& request->value))),
                               "i" (-14), "0" (__pu_err___0));
          goto ldv_34937;
          case_8___0:
          __asm__ volatile ("1:\tmovq %1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___0): "er" ((int *)((unsigned long )req32.value)),
                               "m" (*((struct __large_struct *)(& request->value))),
                               "i" (-14), "0" (__pu_err___0));
          goto ldv_34937;
          switch_default___0:
          {
          __put_user_bad();
          }
        } else {
        }
      }
      ldv_34937: ;
      if (__pu_err___0 != 0) {
        return (-14);
      } else {
      }
    }
  }
  {
  tmp___3 = drm_ioctl(file, 3222299718U, (unsigned long )request);
  }
  return ((int )tmp___3);
}
}
static int compat_i915_alloc(struct file *file , unsigned int cmd , unsigned long arg )
{ drm_i915_mem_alloc32_t req32 ;
  drm_i915_mem_alloc_t *request ;
  unsigned long tmp ;
  void *tmp___0 ;
  unsigned long flag ;
  unsigned long roksum ;
  struct thread_info *tmp___1 ;
  long tmp___2 ;
  int __pu_err ;
  int __pu_err___0 ;
  int __pu_err___1 ;
  int __pu_err___2 ;
  long tmp___3 ;
  {
  {
  tmp = copy_from_user((void *)(& req32), (void const *)arg, 16UL);
  }
  if (tmp != 0UL) {
    return (-14);
  } else {
  }
  {
  tmp___0 = compat_alloc_user_space(24UL);
  request = (drm_i915_mem_alloc_t *)tmp___0;
  tmp___1 = current_thread_info();
  __asm__ ("add %3,%1 ; sbb %0,%0 ; cmp %1,%4 ; sbb $0,%0": "=&r" (flag), "=r" (roksum): "1" (request),
            "g" (24L), "rm" (tmp___1->addr_limit.seg));
  tmp___2 = __builtin_expect((long )(flag == 0UL), 1L);
  }
  if (tmp___2 == 0L) {
    return (-14);
  } else {
    __pu_err = 0;
    if (1) {
      goto case_4;
    } else {
      goto switch_default;
      if (0) {
        __asm__ volatile ("1:\tmovb %b1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err): "iq" (req32.region),
                             "m" (*((struct __large_struct *)(& request->region))),
                             "i" (-14), "0" (__pu_err));
        goto ldv_34961;
        __asm__ volatile ("1:\tmovw %w1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err): "ir" (req32.region),
                             "m" (*((struct __large_struct *)(& request->region))),
                             "i" (-14), "0" (__pu_err));
        goto ldv_34961;
        case_4:
        __asm__ volatile ("1:\tmovl %k1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err): "ir" (req32.region),
                             "m" (*((struct __large_struct *)(& request->region))),
                             "i" (-14), "0" (__pu_err));
        goto ldv_34961;
        __asm__ volatile ("1:\tmovq %1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err): "er" (req32.region),
                             "m" (*((struct __large_struct *)(& request->region))),
                             "i" (-14), "0" (__pu_err));
        goto ldv_34961;
        switch_default:
        {
        __put_user_bad();
        }
      } else {
      }
    }
    ldv_34961: ;
    if (__pu_err != 0) {
      return (-14);
    } else {
      __pu_err___0 = 0;
      if (1) {
        goto case_4___0;
      } else {
        goto switch_default___0;
        if (0) {
          __asm__ volatile ("1:\tmovb %b1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___0): "iq" (req32.alignment),
                               "m" (*((struct __large_struct *)(& request->alignment))),
                               "i" (-14), "0" (__pu_err___0));
          goto ldv_34969;
          __asm__ volatile ("1:\tmovw %w1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___0): "ir" (req32.alignment),
                               "m" (*((struct __large_struct *)(& request->alignment))),
                               "i" (-14), "0" (__pu_err___0));
          goto ldv_34969;
          case_4___0:
          __asm__ volatile ("1:\tmovl %k1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___0): "ir" (req32.alignment),
                               "m" (*((struct __large_struct *)(& request->alignment))),
                               "i" (-14), "0" (__pu_err___0));
          goto ldv_34969;
          __asm__ volatile ("1:\tmovq %1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___0): "er" (req32.alignment),
                               "m" (*((struct __large_struct *)(& request->alignment))),
                               "i" (-14), "0" (__pu_err___0));
          goto ldv_34969;
          switch_default___0:
          {
          __put_user_bad();
          }
        } else {
        }
      }
      ldv_34969: ;
      if (__pu_err___0 != 0) {
        return (-14);
      } else {
        __pu_err___1 = 0;
        if (1) {
          goto case_4___1;
        } else {
          goto switch_default___1;
          if (0) {
            __asm__ volatile ("1:\tmovb %b1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___1): "iq" (req32.size),
                                 "m" (*((struct __large_struct *)(& request->size))),
                                 "i" (-14), "0" (__pu_err___1));
            goto ldv_34977;
            __asm__ volatile ("1:\tmovw %w1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___1): "ir" (req32.size),
                                 "m" (*((struct __large_struct *)(& request->size))),
                                 "i" (-14), "0" (__pu_err___1));
            goto ldv_34977;
            case_4___1:
            __asm__ volatile ("1:\tmovl %k1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___1): "ir" (req32.size),
                                 "m" (*((struct __large_struct *)(& request->size))),
                                 "i" (-14), "0" (__pu_err___1));
            goto ldv_34977;
            __asm__ volatile ("1:\tmovq %1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___1): "er" (req32.size),
                                 "m" (*((struct __large_struct *)(& request->size))),
                                 "i" (-14), "0" (__pu_err___1));
            goto ldv_34977;
            switch_default___1:
            {
            __put_user_bad();
            }
          } else {
          }
        }
        ldv_34977: ;
        if (__pu_err___1 != 0) {
          return (-14);
        } else {
          __pu_err___2 = 0;
          if (1) {
            goto case_8___2;
          } else {
            goto switch_default___2;
            if (0) {
              __asm__ volatile ("1:\tmovb %b1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___2): "iq" ((int *)((unsigned long )req32.region_offset)),
                                   "m" (*((struct __large_struct *)(& request->region_offset))),
                                   "i" (-14), "0" (__pu_err___2));
              goto ldv_34985;
              __asm__ volatile ("1:\tmovw %w1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___2): "ir" ((int *)((unsigned long )req32.region_offset)),
                                   "m" (*((struct __large_struct *)(& request->region_offset))),
                                   "i" (-14), "0" (__pu_err___2));
              goto ldv_34985;
              __asm__ volatile ("1:\tmovl %k1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___2): "ir" ((int *)((unsigned long )req32.region_offset)),
                                   "m" (*((struct __large_struct *)(& request->region_offset))),
                                   "i" (-14), "0" (__pu_err___2));
              goto ldv_34985;
              case_8___2:
              __asm__ volatile ("1:\tmovq %1,%2\n2:\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .section __ex_table,\"a\"\n .balign 8 \n .quad 1b,3b\n .previous\n": "=r" (__pu_err___2): "er" ((int *)((unsigned long )req32.region_offset)),
                                   "m" (*((struct __large_struct *)(& request->region_offset))),
                                   "i" (-14), "0" (__pu_err___2));
              goto ldv_34985;
              switch_default___2:
              {
              __put_user_bad();
              }
            } else {
            }
          }
          ldv_34985: ;
          if (__pu_err___2 != 0) {
            return (-14);
          } else {
          }
        }
      }
    }
  }
  {
  tmp___3 = drm_ioctl(file, 3222824008U, (unsigned long )request);
  }
  return ((int )tmp___3);
}
}
drm_ioctl_compat_t *i915_compat_ioctls[12U] =
  { (drm_ioctl_compat_t *)0, (drm_ioctl_compat_t *)0, (drm_ioctl_compat_t *)0, & compat_i915_batchbuffer,
        & compat_i915_irq_emit, (drm_ioctl_compat_t *)0, & compat_i915_getparam, (drm_ioctl_compat_t *)0,
        & compat_i915_alloc, (drm_ioctl_compat_t *)0, (drm_ioctl_compat_t *)0, & compat_i915_cmdbuffer};
long i915_compat_ioctl(struct file *filp , unsigned int cmd , unsigned long arg )
{ unsigned int nr ;
  drm_ioctl_compat_t *fn ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  {
  nr = cmd & 255U;
  fn = (drm_ioctl_compat_t *)0;
  if (nr <= 63U) {
    {
    tmp = drm_compat_ioctl(filp, cmd, arg);
    }
    return (tmp);
  } else {
  }
  if (nr <= 75U) {
    fn = i915_compat_ioctls[nr - 64U];
  } else {
  }
  if ((unsigned long )fn != (unsigned long )((drm_ioctl_compat_t *)0)) {
    {
    ret = (*fn)(filp, cmd, arg);
    }
  } else {
    {
    tmp___0 = drm_ioctl(filp, cmd, arg);
    ret = (int )tmp___0;
    }
  }
  return ((long )ret);
}
}
extern acpi_status acpi_get_name(acpi_handle , u32 , struct acpi_buffer * ) ;
extern acpi_status acpi_get_handle(acpi_handle , acpi_string , acpi_handle ** ) ;
extern acpi_status acpi_evaluate_object(acpi_handle , acpi_string , struct acpi_object_list * ,
                                        struct acpi_buffer * ) ;
static struct intel_dsm_priv intel_dsm_priv ;
static u8 const intel_dsm_guid[16U] =
  { (u8 const )211U, (u8 const )115U, (u8 const )216U, (u8 const )126U,
        (u8 const )208U, (u8 const )194U, (u8 const )79U, (u8 const )78U,
        (u8 const )168U, (u8 const )84U, (u8 const )15U, (u8 const )19U,
        (u8 const )23U, (u8 const )176U, (u8 const )28U, (u8 const )44U};
static int intel_dsm(acpi_handle handle , int func , int arg )
{ struct acpi_buffer output ;
  struct acpi_object_list input ;
  union acpi_object params[4U] ;
  union acpi_object *obj ;
  u32 result ;
  int ret ;
  acpi_status tmp ;
  {
  {
  output.length = 0x0fffffffffffffffULL;
  output.pointer = (void *)0;
  ret = 0;
  input.count = 4U;
  input.pointer = (union acpi_object *)(& params);
  params[0].type = 3U;
  params[0].buffer.length = 16U;
  params[0].buffer.pointer = (u8 *)(& intel_dsm_guid);
  params[1].type = 1U;
  params[1].integer.value = 1ULL;
  params[2].type = 1U;
  params[2].integer.value = (u64 )func;
  params[3].type = 1U;
  params[3].integer.value = (u64 )arg;
  tmp = acpi_evaluate_object(handle, (char *)"_DSM", & input, & output);
  ret = (int )tmp;
  }
  if (ret != 0) {
    {
    drm_ut_debug_printk(2U, "drm", "intel_dsm", "failed to evaluate _DSM: %d\n", ret);
    }
    return (ret);
  } else {
  }
  obj = (union acpi_object *)output.pointer;
  result = 0U;
  if ((int )obj->type == 1) {
    goto case_1;
  } else
  if ((int )obj->type == 3) {
    goto case_3;
  } else {
    goto switch_default;
    if (0) {
      case_1:
      result = (u32 )obj->integer.value;
      goto ldv_36907;
      case_3: ;
      if (obj->buffer.length == 4U) {
        result = (u32 )((((int )*(obj->buffer.pointer) | ((int )*(obj->buffer.pointer + 1UL) << 8)) | ((int )*(obj->buffer.pointer + 2UL) << 16)) | ((int )*(obj->buffer.pointer + 3UL) << 24));
        goto ldv_36907;
      } else {
      }
      switch_default:
      ret = -22;
      goto ldv_36907;
    } else {
    }
  }
  ldv_36907: ;
  if (result == 2147483650U) {
    ret = -19;
  } else {
  }
  {
  kfree((void const *)output.pointer);
  }
  return (ret);
}
}
static char *intel_dsm_port_name(u8 id )
{
  {
  if ((int )id == 0) {
    goto case_0;
  } else
  if ((int )id == 1) {
    goto case_1;
  } else
  if ((int )id == 2) {
    goto case_2;
  } else
  if ((int )id == 3) {
    goto case_3;
  } else
  if ((int )id == 4) {
    goto case_4;
  } else
  if ((int )id == 5) {
    goto case_5;
  } else
  if ((int )id == 6) {
    goto case_6;
  } else
  if ((int )id == 7) {
    goto case_7;
  } else
  if ((int )id == 8) {
    goto case_8;
  } else
  if ((int )id == 9) {
    goto case_9;
  } else
  if ((int )id == 10) {
    goto case_10;
  } else
  if ((int )id == 11) {
    goto case_11;
  } else
  if ((int )id == 12) {
    goto case_12;
  } else
  if ((int )id == 13) {
    goto case_13;
  } else
  if ((int )id == 14) {
    goto case_14;
  } else {
    goto switch_default;
    if (0) {
      case_0: ;
      return ((char *)"Reserved");
      case_1: ;
      return ((char *)"Analog VGA");
      case_2: ;
      return ((char *)"LVDS");
      case_3: ;
      return ((char *)"Reserved");
      case_4: ;
      return ((char *)"HDMI/DVI_B");
      case_5: ;
      return ((char *)"HDMI/DVI_C");
      case_6: ;
      return ((char *)"HDMI/DVI_D");
      case_7: ;
      return ((char *)"DisplayPort_A");
      case_8: ;
      return ((char *)"DisplayPort_B");
      case_9: ;
      return ((char *)"DisplayPort_C");
      case_10: ;
      return ((char *)"DisplayPort_D");
      case_11: ;
      case_12: ;
      case_13: ;
      return ((char *)"Reserved");
      case_14: ;
      return ((char *)"WiDi");
      switch_default: ;
      return ((char *)"bad type");
    } else {
    }
  }
}
}
static char *intel_dsm_mux_type(u8 type )
{
  {
  if ((int )type == 0) {
    goto case_0;
  } else
  if ((int )type == 1) {
    goto case_1;
  } else
  if ((int )type == 2) {
    goto case_2;
  } else
  if ((int )type == 3) {
    goto case_3;
  } else {
    goto switch_default;
    if (0) {
      case_0: ;
      return ((char *)"unknown");
      case_1: ;
      return ((char *)"No MUX, iGPU only");
      case_2: ;
      return ((char *)"No MUX, dGPU only");
      case_3: ;
      return ((char *)"MUXed between iGPU and dGPU");
      switch_default: ;
      return ((char *)"bad type");
    } else {
    }
  }
}
}
static void intel_dsm_platform_mux_info(void)
{ struct acpi_buffer output ;
  struct acpi_object_list input ;
  union acpi_object params[4U] ;
  union acpi_object *pkg ;
  int i ;
  int ret ;
  acpi_status tmp ;
  union acpi_object *connector_count ;
  union acpi_object *obj ;
  union acpi_object *connector_id ;
  union acpi_object *info ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  {
  {
  output.length = 0x0fffffffffffffffULL;
  output.pointer = (void *)0;
  input.count = 4U;
  input.pointer = (union acpi_object *)(& params);
  params[0].type = 3U;
  params[0].buffer.length = 16U;
  params[0].buffer.pointer = (u8 *)(& intel_dsm_guid);
  params[1].type = 1U;
  params[1].integer.value = 1ULL;
  params[2].type = 1U;
  params[2].integer.value = 1ULL;
  params[3].type = 1U;
  params[3].integer.value = 0ULL;
  tmp = acpi_evaluate_object(intel_dsm_priv.dhandle, (char *)"_DSM", & input, & output);
  ret = (int )tmp;
  }
  if (ret != 0) {
    {
    drm_ut_debug_printk(2U, "drm", "intel_dsm_platform_mux_info", "failed to evaluate _DSM: %d\n",
                        ret);
    }
    goto out;
  } else {
  }
  pkg = (union acpi_object *)output.pointer;
  if (pkg->type == 4U) {
    {
    connector_count = pkg->package.elements;
    drm_ut_debug_printk(2U, "drm", "intel_dsm_platform_mux_info", "MUX info connectors: %lld\n",
                        connector_count->integer.value);
    i = 1;
    }
    goto ldv_36953;
    ldv_36952:
    {
    obj = pkg->package.elements + (unsigned long )i;
    connector_id = obj->package.elements;
    info = obj->package.elements + 1UL;
    drm_ut_debug_printk(2U, "drm", "intel_dsm_platform_mux_info", "Connector id: 0x%016llx\n",
                        connector_id->integer.value);
    tmp___0 = intel_dsm_port_name((u8 )((int )*(info->buffer.pointer)));
    drm_ut_debug_printk(2U, "drm", "intel_dsm_platform_mux_info", "  port id: %s\n",
                        tmp___0);
    tmp___1 = intel_dsm_mux_type((u8 )((int )*(info->buffer.pointer + 1UL)));
    drm_ut_debug_printk(2U, "drm", "intel_dsm_platform_mux_info", "  display mux info: %s\n",
                        tmp___1);
    tmp___2 = intel_dsm_mux_type((u8 )((int )*(info->buffer.pointer + 2UL)));
    drm_ut_debug_printk(2U, "drm", "intel_dsm_platform_mux_info", "  aux/dc mux info: %s\n",
                        tmp___2);
    tmp___3 = intel_dsm_mux_type((u8 )((int )*(info->buffer.pointer + 3UL)));
    drm_ut_debug_printk(2U, "drm", "intel_dsm_platform_mux_info", "  hpd mux info: %s\n",
                        tmp___3);
    i = i + 1;
    }
    ldv_36953: ;
    if ((u32 )i < pkg->package.count) {
      goto ldv_36952;
    } else {
      goto ldv_36954;
    }
    ldv_36954: ;
  } else {
    {
    drm_err("intel_dsm_platform_mux_info", "MUX INFO call failed\n");
    }
  }
  out:
  {
  kfree((void const *)output.pointer);
  }
  return;
}
}
static bool intel_dsm_pci_probe(struct pci_dev *pdev )
{ acpi_handle dhandle ;
  acpi_handle intel_handle ;
  acpi_status status ;
  int ret ;
  {
  dhandle = pdev->dev.archdata.acpi_handle;
  if ((unsigned long )dhandle == (unsigned long )((acpi_handle )0)) {
    return ((bool )0);
  } else {
  }
  {
  status = acpi_get_handle(dhandle, (char *)"_DSM", (acpi_handle **)(& intel_handle));
  }
  if (status != 0U) {
    {
    drm_ut_debug_printk(4U, "drm", "intel_dsm_pci_probe", "no _DSM method for intel device\n");
    }
    return ((bool )0);
  } else {
  }
  {
  ret = intel_dsm(dhandle, 0, 0);
  }
  if (ret < 0) {
    {
    drm_err("intel_dsm_pci_probe", "failed to get supported _DSM functions\n");
    }
    return ((bool )0);
  } else {
  }
  {
  intel_dsm_priv.dhandle = dhandle;
  intel_dsm_platform_mux_info();
  }
  return ((bool )1);
}
}
static bool intel_dsm_detect(void)
{ char acpi_method_name[255U] ;
  struct acpi_buffer buffer ;
  struct pci_dev *pdev ;
  bool has_dsm ;
  int vga_count ;
  bool tmp ;
  {
  acpi_method_name[0] = (char)0;
  buffer.length = 255ULL;
  buffer.pointer = (void *)(& acpi_method_name);
  pdev = (struct pci_dev *)0;
  has_dsm = (bool )0;
  vga_count = 0;
  goto ldv_36972;
  ldv_36971:
  {
  vga_count = vga_count + 1;
  tmp = intel_dsm_pci_probe(pdev);
  has_dsm = (bool )(((int )has_dsm | (int )tmp) != 0);
  }
  ldv_36972:
  {
  pdev = pci_get_class(196608U, pdev);
  }
  if ((unsigned long )pdev != (unsigned long )((struct pci_dev *)0)) {
    goto ldv_36971;
  } else {
    goto ldv_36973;
  }
  ldv_36973: ;
  if (vga_count == 2) {
    if ((int )has_dsm) {
      {
      acpi_get_name(intel_dsm_priv.dhandle, 0U, & buffer);
      drm_ut_debug_printk(2U, "drm", "intel_dsm_detect", "VGA switcheroo: detected DSM switching method %s handle\n",
                          (char *)(& acpi_method_name));
      }
      return ((bool )1);
    } else {
    }
  } else {
  }
  return ((bool )0);
}
}
void intel_register_dsm_handler(void)
{ bool tmp ;
  int tmp___0 ;
  {
  {
  tmp = intel_dsm_detect();
  }
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {
  }
  return;
}
}
void intel_unregister_dsm_handler(void)
{
  {
  return;
}
}
void *external_alloc(void);
struct workqueue_struct *__alloc_workqueue_key(const char *arg0, unsigned int arg1, int arg2, struct lock_class_key *arg3, const char *arg4) {
  return (struct workqueue_struct *)external_alloc();
}
void __const_udelay(unsigned long arg0) {
  return;
}
long __VERIFIER_nondet_long(void);
long int __copy_user_nocache(void *arg0, const void *arg1, unsigned int arg2, int arg3) {
  return __VERIFIER_nondet_long();
}
void __init_waitqueue_head(wait_queue_head_t *arg0, struct lock_class_key *arg1) {
  return;
}
void __init_work(struct work_struct *arg0, int arg1) {
  return;
}
void *external_alloc(void);
void *__kmalloc(size_t arg0, gfp_t arg1) {
  return (void *)external_alloc();
}
void __list_add(struct list_head *arg0, struct list_head *arg1, struct list_head *arg2) {
  return;
}
void __list_del_entry(struct list_head *arg0) {
  return;
}
void __might_sleep(const char *arg0, int arg1, int arg2) {
  return;
}
void __raw_spin_lock_init(raw_spinlock_t *arg0, const char *arg1, struct lock_class_key *arg2) {
  return;
}
void *external_alloc(void);
void *__symbol_get(const char *arg0) {
  return (void *)external_alloc();
}
void __symbol_put(const char *arg0) {
  return;
}
void *external_alloc(void);
void *__vmalloc(unsigned long arg0, gfp_t arg1, pgprot_t arg2) {
  return (void *)external_alloc();
}
void __wake_up(wait_queue_head_t *arg0, unsigned int arg1, int arg2, void *arg3) {
  return;
}
unsigned long __VERIFIER_nondet_ulong(void);
unsigned long int _copy_from_user(void *arg0, const void *arg1, unsigned int arg2) {
  return __VERIFIER_nondet_ulong();
}
unsigned long __VERIFIER_nondet_ulong(void);
unsigned long int _copy_to_user(void *arg0, const void *arg1, unsigned int arg2) {
  return __VERIFIER_nondet_ulong();
}
void _raw_spin_lock(raw_spinlock_t *arg0) {
  return;
}
void _raw_spin_lock_irq(raw_spinlock_t *arg0) {
  return;
}
unsigned long __VERIFIER_nondet_ulong(void);
unsigned long int _raw_spin_lock_irqsave(raw_spinlock_t *arg0) {
  return __VERIFIER_nondet_ulong();
}
void _raw_spin_unlock(raw_spinlock_t *arg0) {
  return;
}
void _raw_spin_unlock_irq(raw_spinlock_t *arg0) {
  return;
}
void _raw_spin_unlock_irqrestore(raw_spinlock_t *arg0, unsigned long arg1) {
  return;
}
int __VERIFIER_nondet_int(void);
int acpi_bus_get_device(acpi_handle arg0, struct acpi_device **arg1) {
  return __VERIFIER_nondet_int();
}
unsigned int __VERIFIER_nondet_uint(void);
acpi_status acpi_evaluate_integer(acpi_handle arg0, acpi_string arg1, struct acpi_object_list *arg2, unsigned long long *arg3) {
  return __VERIFIER_nondet_uint();
}
unsigned int __VERIFIER_nondet_uint(void);
acpi_status acpi_evaluate_object(acpi_handle arg0, acpi_string arg1, struct acpi_object_list *arg2, struct acpi_buffer *arg3) {
  return __VERIFIER_nondet_uint();
}
unsigned int __VERIFIER_nondet_uint(void);
acpi_status acpi_get_handle(acpi_handle arg0, acpi_string arg1, acpi_handle **arg2) {
  return __VERIFIER_nondet_uint();
}
unsigned int __VERIFIER_nondet_uint(void);
acpi_status acpi_get_name(acpi_handle arg0, u32 arg1, struct acpi_buffer *arg2) {
  return __VERIFIER_nondet_uint();
}
long __VERIFIER_nondet_long(void);
long int acpi_is_video_device(struct acpi_device *arg0) {
  return __VERIFIER_nondet_long();
}
int __VERIFIER_nondet_int(void);
int acpi_lid_notifier_register(struct notifier_block *arg0) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int acpi_lid_notifier_unregister(struct notifier_block *arg0) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int acpi_lid_open() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int acpi_video_register() {
  return __VERIFIER_nondet_int();
}
void acpi_video_unregister() {
  return;
}
void add_wait_queue(wait_queue_head_t *arg0, wait_queue_t *arg1) {
  return;
}
bool __VERIFIER_nondet_bool(void);
bool cancel_delayed_work_sync(struct delayed_work *arg0) {
  return __VERIFIER_nondet_bool();
}
bool __VERIFIER_nondet_bool(void);
bool cancel_work_sync(struct work_struct *arg0) {
  return __VERIFIER_nondet_bool();
}
void *external_alloc(void);
void *compat_alloc_user_space(unsigned long arg0) {
  return (void *)external_alloc();
}
void complete_all(struct completion *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int debug_lockdep_rcu_enabled() {
  return __VERIFIER_nondet_int();
}
void *external_alloc(void);
struct dentry *debugfs_create_file(const char *arg0, mode_t arg1, struct dentry *arg2, void *arg3, const struct file_operations *arg4) {
  return (struct dentry *)external_alloc();
}
void debugfs_remove(struct dentry *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int del_timer_sync(struct timer_list *arg0) {
  return __VERIFIER_nondet_int();
}
void destroy_workqueue(struct workqueue_struct *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int dev_err(const struct device *arg0, const char *arg1, ...) {
  return __VERIFIER_nondet_int();
}
void *external_alloc(void);
void *dev_get_drvdata(const struct device *arg0) {
  return (void *)external_alloc();
}
int __VERIFIER_nondet_int(void);
int dev_printk(const char *arg0, const struct device *arg1, const char *arg2, ...) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int dma_supported(struct device *arg0, u64 arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int dmi_check_system(const struct dmi_system_id *arg0) {
  return __VERIFIER_nondet_int();
}
void do_gettimeofday(struct timeval *arg0) {
  return;
}
unsigned long __VERIFIER_nondet_ulong(void);
unsigned long int do_mmap_pgoff(struct file *arg0, unsigned long arg1, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5) {
  return __VERIFIER_nondet_ulong();
}
void down_read(struct rw_semaphore *arg0) {
  return;
}
void down_write(struct rw_semaphore *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int drm_add_edid_modes(struct drm_connector *arg0, struct edid *arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *arg0, int arg1, int *arg2, struct timeval *arg3, unsigned int arg4, struct drm_crtc *arg5) {
  return __VERIFIER_nondet_int();
}
void drm_clflush_pages(struct page **arg0, unsigned long arg1) {
  return;
}
long __VERIFIER_nondet_long(void);
long int drm_compat_ioctl(struct file *arg0, unsigned int arg1, unsigned long arg2) {
  return __VERIFIER_nondet_long();
}
int __VERIFIER_nondet_int(void);
int drm_connector_attach_property(struct drm_connector *arg0, struct drm_property *arg1, uint64_t arg2) {
  return __VERIFIER_nondet_int();
}
void drm_connector_cleanup(struct drm_connector *arg0) {
  return;
}
void drm_connector_init(struct drm_device *arg0, struct drm_connector *arg1, const struct drm_connector_funcs *arg2, int arg3) {
  return;
}
int __VERIFIER_nondet_int(void);
int drm_connector_property_set_value(struct drm_connector *arg0, struct drm_property *arg1, uint64_t arg2) {
  return __VERIFIER_nondet_int();
}
void drm_core_ioremap_wc(struct drm_local_map *arg0, struct drm_device *arg1) {
  return;
}
void drm_core_ioremapfree(struct drm_local_map *arg0, struct drm_device *arg1) {
  return;
}
void drm_crtc_cleanup(struct drm_crtc *arg0) {
  return;
}
bool __VERIFIER_nondet_bool(void);
bool drm_crtc_helper_set_mode(struct drm_crtc *arg0, struct drm_display_mode *arg1, int arg2, int arg3, struct drm_framebuffer *arg4) {
  return __VERIFIER_nondet_bool();
}
void drm_crtc_init(struct drm_device *arg0, struct drm_crtc *arg1, const struct drm_crtc_funcs *arg2) {
  return;
}
int __VERIFIER_nondet_int(void);
int drm_debugfs_create_files(struct drm_info_list *arg0, int arg1, struct dentry *arg2, struct drm_minor *arg3) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int drm_debugfs_remove_files(struct drm_info_list *arg0, int arg1, struct drm_minor *arg2) {
  return __VERIFIER_nondet_int();
}
bool __VERIFIER_nondet_bool(void);
bool drm_detect_hdmi_monitor(struct edid *arg0) {
  return __VERIFIER_nondet_bool();
}
bool __VERIFIER_nondet_bool(void);
bool drm_detect_monitor_audio(struct edid *arg0) {
  return __VERIFIER_nondet_bool();
}
void drm_encoder_cleanup(struct drm_encoder *arg0) {
  return;
}
void drm_encoder_init(struct drm_device *arg0, struct drm_encoder *arg1, const struct drm_encoder_funcs *arg2, int arg3) {
  return;
}
int __VERIFIER_nondet_int(void);
int drm_err(const char *arg0, const char *arg1, ...) {
  return __VERIFIER_nondet_int();
}
void drm_fb_helper_fill_fix(struct fb_info *arg0, uint32_t arg1, uint32_t arg2) {
  return;
}
void drm_fb_helper_fill_var(struct fb_info *arg0, struct drm_fb_helper *arg1, uint32_t arg2, uint32_t arg3) {
  return;
}
void drm_fb_helper_fini(struct drm_fb_helper *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int drm_fb_helper_hotplug_event(struct drm_fb_helper *arg0) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int drm_fb_helper_init(struct drm_device *arg0, struct drm_fb_helper *arg1, int arg2, int arg3) {
  return __VERIFIER_nondet_int();
}
bool __VERIFIER_nondet_bool(void);
bool drm_fb_helper_initial_config(struct drm_fb_helper *arg0, int arg1) {
  return __VERIFIER_nondet_bool();
}
bool __VERIFIER_nondet_bool(void);
bool drm_fb_helper_restore_fbdev_mode(struct drm_fb_helper *arg0) {
  return __VERIFIER_nondet_bool();
}
int __VERIFIER_nondet_int(void);
int drm_fb_helper_single_add_all_connectors(struct drm_fb_helper *arg0) {
  return __VERIFIER_nondet_int();
}
void drm_framebuffer_cleanup(struct drm_framebuffer *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int drm_framebuffer_init(struct drm_device *arg0, struct drm_framebuffer *arg1, const struct drm_framebuffer_funcs *arg2) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int drm_gem_handle_create(struct drm_file *arg0, struct drm_gem_object *arg1, u32 *arg2) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int drm_gem_handle_delete(struct drm_file *arg0, u32 arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int drm_gem_object_init(struct drm_device *arg0, struct drm_gem_object *arg1, size_t arg2) {
  return __VERIFIER_nondet_int();
}
void *external_alloc(void);
struct drm_gem_object *drm_gem_object_lookup(struct drm_device *arg0, struct drm_file *arg1, u32 arg2) {
  return (struct drm_gem_object *)external_alloc();
}
void drm_gem_object_release(struct drm_gem_object *arg0) {
  return;
}
void *external_alloc(void);
char *drm_get_connector_name(struct drm_connector *arg0) {
  return (char *)external_alloc();
}
void *external_alloc(void);
struct edid *drm_get_edid(struct drm_connector *arg0, struct i2c_adapter *arg1) {
  return (struct edid *)external_alloc();
}
void *external_alloc(void);
char *drm_get_encoder_name(struct drm_encoder *arg0) {
  return (char *)external_alloc();
}
int __VERIFIER_nondet_int(void);
int drm_get_pci_dev(struct pci_dev *arg0, const struct pci_device_id *arg1, struct drm_driver *arg2) {
  return __VERIFIER_nondet_int();
}
void *external_alloc(void);
struct drm_local_map *drm_getsarea(struct drm_device *arg0) {
  return (struct drm_local_map *)external_alloc();
}
bool __VERIFIER_nondet_bool(void);
bool drm_handle_vblank(struct drm_device *arg0, int arg1) {
  return __VERIFIER_nondet_bool();
}
void drm_helper_disable_unused_functions(struct drm_device *arg0) {
  return;
}
void drm_helper_hpd_irq_event(struct drm_device *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int drm_helper_mode_fill_fb_struct(struct drm_framebuffer *arg0, struct drm_mode_fb_cmd *arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int drm_helper_resume_force_mode(struct drm_device *arg0) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int drm_ht_insert_item(struct drm_open_hash *arg0, struct drm_hash_item *arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int drm_ht_remove_item(struct drm_open_hash *arg0, struct drm_hash_item *arg1) {
  return __VERIFIER_nondet_int();
}
long __VERIFIER_nondet_long(void);
long int drm_ioctl(struct file *arg0, unsigned int arg1, unsigned long arg2) {
  return __VERIFIER_nondet_long();
}
int __VERIFIER_nondet_int(void);
int drm_irq_install(struct drm_device *arg0) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int drm_irq_uninstall(struct drm_device *arg0) {
  return __VERIFIER_nondet_int();
}
void drm_kms_helper_poll_disable(struct drm_device *arg0) {
  return;
}
void drm_kms_helper_poll_enable(struct drm_device *arg0) {
  return;
}
void drm_kms_helper_poll_fini(struct drm_device *arg0) {
  return;
}
void drm_kms_helper_poll_init(struct drm_device *arg0) {
  return;
}
void *external_alloc(void);
struct drm_mm_node *drm_mm_get_block_generic(struct drm_mm_node *arg0, unsigned long arg1, unsigned int arg2, int arg3) {
  return (struct drm_mm_node *)external_alloc();
}
void *external_alloc(void);
struct drm_mm_node *drm_mm_get_block_range_generic(struct drm_mm_node *arg0, unsigned long arg1, unsigned int arg2, unsigned long arg3, unsigned long arg4, int arg5) {
  return (struct drm_mm_node *)external_alloc();
}
int __VERIFIER_nondet_int(void);
int drm_mm_init(struct drm_mm *arg0, unsigned long arg1, unsigned long arg2) {
  return __VERIFIER_nondet_int();
}
void drm_mm_init_scan(struct drm_mm *arg0, unsigned long arg1, unsigned int arg2) {
  return;
}
void drm_mm_init_scan_with_range(struct drm_mm *arg0, unsigned long arg1, unsigned int arg2, unsigned long arg3, unsigned long arg4) {
  return;
}
void drm_mm_put_block(struct drm_mm_node *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int drm_mm_scan_add_block(struct drm_mm_node *arg0) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int drm_mm_scan_remove_block(struct drm_mm_node *arg0) {
  return __VERIFIER_nondet_int();
}
void *external_alloc(void);
struct drm_mm_node *drm_mm_search_free(const struct drm_mm *arg0, unsigned long arg1, unsigned int arg2, int arg3) {
  return (struct drm_mm_node *)external_alloc();
}
void *external_alloc(void);
struct drm_mm_node *drm_mm_search_free_in_range(const struct drm_mm *arg0, unsigned long arg1, unsigned int arg2, unsigned long arg3, unsigned long arg4, int arg5) {
  return (struct drm_mm_node *)external_alloc();
}
void drm_mm_takedown(struct drm_mm *arg0) {
  return;
}
void drm_mode_config_cleanup(struct drm_device *arg0) {
  return;
}
void drm_mode_config_init(struct drm_device *arg0) {
  return;
}
void drm_mode_config_reset(struct drm_device *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int drm_mode_connector_attach_encoder(struct drm_connector *arg0, struct drm_encoder *arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int drm_mode_connector_update_edid_property(struct drm_connector *arg0, struct edid *arg1) {
  return __VERIFIER_nondet_int();
}
void *external_alloc(void);
struct drm_display_mode *drm_mode_create(struct drm_device *arg0) {
  return (struct drm_display_mode *)external_alloc();
}
int __VERIFIER_nondet_int(void);
int drm_mode_create_scaling_mode_property(struct drm_device *arg0) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int drm_mode_create_tv_properties(struct drm_device *arg0, int arg1, char **arg2) {
  return __VERIFIER_nondet_int();
}
bool __VERIFIER_nondet_bool(void);
bool drm_mode_crtc_set_gamma_size(struct drm_crtc *arg0, int arg1) {
  return __VERIFIER_nondet_bool();
}
void drm_mode_debug_printmodeline(struct drm_display_mode *arg0) {
  return;
}
void drm_mode_destroy(struct drm_device *arg0, struct drm_display_mode *arg1) {
  return;
}
void *external_alloc(void);
struct drm_display_mode *drm_mode_duplicate(struct drm_device *arg0, const struct drm_display_mode *arg1) {
  return (struct drm_display_mode *)external_alloc();
}
void *external_alloc(void);
struct drm_mode_object *drm_mode_object_find(struct drm_device *arg0, uint32_t arg1, uint32_t arg2) {
  return (struct drm_mode_object *)external_alloc();
}
void drm_mode_probed_add(struct drm_connector *arg0, struct drm_display_mode *arg1) {
  return;
}
void drm_mode_set_crtcinfo(struct drm_display_mode *arg0, int arg1) {
  return;
}
void drm_mode_set_name(struct drm_display_mode *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int drm_mode_vrefresh(const struct drm_display_mode *arg0) {
  return __VERIFIER_nondet_int();
}
void *external_alloc(void);
drm_dma_handle_t *drm_pci_alloc(struct drm_device *arg0, size_t arg1, size_t arg2) {
  return (drm_dma_handle_t *)external_alloc();
}
void drm_pci_exit(struct drm_driver *arg0, struct pci_driver *arg1) {
  return;
}
void drm_pci_free(struct drm_device *arg0, drm_dma_handle_t *arg1) {
  return;
}
int __VERIFIER_nondet_int(void);
int drm_pci_init(struct drm_driver *arg0, struct pci_driver *arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int drm_property_add_enum(struct drm_property *arg0, int arg1, uint64_t arg2, const char *arg3) {
  return __VERIFIER_nondet_int();
}
void *external_alloc(void);
struct drm_property *drm_property_create(struct drm_device *arg0, int arg1, const char *arg2, int arg3) {
  return (struct drm_property *)external_alloc();
}
void drm_property_destroy(struct drm_device *arg0, struct drm_property *arg1) {
  return;
}
void drm_put_dev(struct drm_device *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int drm_sysfs_connector_add(struct drm_connector *arg0) {
  return __VERIFIER_nondet_int();
}
void drm_sysfs_connector_remove(struct drm_connector *arg0) {
  return;
}
void drm_ut_debug_printk(unsigned int arg0, const char *arg1, const char *arg2, const char *arg3, ...) {
  return;
}
unsigned int __VERIFIER_nondet_uint(void);
u32 drm_vblank_count_and_time(struct drm_device *arg0, int arg1, struct timeval *arg2) {
  return __VERIFIER_nondet_uint();
}
int __VERIFIER_nondet_int(void);
int drm_vblank_get(struct drm_device *arg0, int arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int drm_vblank_init(struct drm_device *arg0, int arg1) {
  return __VERIFIER_nondet_int();
}
void drm_vblank_off(struct drm_device *arg0, int arg1) {
  return;
}
void drm_vblank_post_modeset(struct drm_device *arg0, int arg1) {
  return;
}
void drm_vblank_pre_modeset(struct drm_device *arg0, int arg1) {
  return;
}
void drm_vblank_put(struct drm_device *arg0, int arg1) {
  return;
}
int __VERIFIER_nondet_int(void);
int fb_alloc_cmap(struct fb_cmap *arg0, int arg1, int arg2) {
  return __VERIFIER_nondet_int();
}
void fb_dealloc_cmap(struct fb_cmap *arg0) {
  return;
}
void finish_wait(wait_queue_head_t *arg0, wait_queue_t *arg1) {
  return;
}
void flush_workqueue(struct workqueue_struct *arg0) {
  return;
}
void *external_alloc(void);
struct fb_info *framebuffer_alloc(size_t arg0, struct device *arg1) {
  return (struct fb_info *)external_alloc();
}
void framebuffer_release(struct fb_info *arg0) {
  return;
}
unsigned long __VERIFIER_nondet_ulong(void);
unsigned long int get_seconds() {
  return __VERIFIER_nondet_ulong();
}
int __VERIFIER_nondet_int(void);
int get_user_pages(struct task_struct *arg0, struct mm_struct *arg1, unsigned long arg2, int arg3, int arg4, int arg5, struct page **arg6, struct vm_area_struct **arg7) {
  return __VERIFIER_nondet_int();
}
void getrawmonotonic(struct timespec *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int i2c_add_adapter(struct i2c_adapter *arg0) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int i2c_bit_add_bus(struct i2c_adapter *arg0) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int i2c_del_adapter(struct i2c_adapter *arg0) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int i2c_dp_aux_add_bus(struct i2c_adapter *arg0) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int i2c_transfer(struct i2c_adapter *arg0, struct i2c_msg *arg1, int arg2) {
  return __VERIFIER_nondet_int();
}
void init_timer_key(struct timer_list *arg0, const char *arg1, struct lock_class_key *arg2) {
  return;
}
void intel_gtt_chipset_flush() {
  return;
}
void intel_gtt_clear_range(unsigned int arg0, unsigned int arg1) {
  return;
}
void *external_alloc(void);
const struct intel_gtt *intel_gtt_get() {
  return (const struct intel_gtt *)external_alloc();
}
void intel_gtt_insert_pages(unsigned int arg0, unsigned int arg1, struct page **arg2, unsigned int arg3) {
  return;
}
void intel_gtt_insert_sg_entries(struct scatterlist *arg0, unsigned int arg1, unsigned int arg2, unsigned int arg3) {
  return;
}
int __VERIFIER_nondet_int(void);
int intel_gtt_map_memory(struct page **arg0, unsigned int arg1, struct scatterlist **arg2, int *arg3) {
  return __VERIFIER_nondet_int();
}
void intel_gtt_unmap_memory(struct scatterlist *arg0, int arg1) {
  return;
}
unsigned int __VERIFIER_nondet_uint(void);
unsigned int ioread32(void *arg0) {
  return __VERIFIER_nondet_uint();
}
void *external_alloc(void);
void *ioremap_cache(resource_size_t arg0, unsigned long arg1) {
  return (void *)external_alloc();
}
void *external_alloc(void);
void *ioremap_wc(resource_size_t arg0, unsigned long arg1) {
  return (void *)external_alloc();
}
void iounmap(volatile void *arg0) {
  return;
}
void iowrite32(u32 arg0, void *arg1) {
  return;
}
unsigned int __VERIFIER_nondet_uint(void);
unsigned int jiffies_to_msecs(const unsigned long arg0) {
  return __VERIFIER_nondet_uint();
}
int __VERIFIER_nondet_int(void);
int kobject_uevent_env(struct kobject *arg0, enum kobject_action arg1, char **arg2) {
  return __VERIFIER_nondet_int();
}
void kref_get(struct kref *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int kref_put(struct kref *arg0, void (*arg1)(struct kref *)) {
  return __VERIFIER_nondet_int();
}
void ldv_initialize() {
  return;
}
int __VERIFIER_nondet_int(void);
int ldv_undefined_int() {
  return __VERIFIER_nondet_int();
}
void list_del(struct list_head *arg0) {
  return;
}
void lockdep_init_map(struct lockdep_map *arg0, const char *arg1, struct lock_class_key *arg2, int arg3) {
  return;
}
void lockdep_rcu_dereference(const char *arg0, const int arg1) {
  return;
}
void mark_page_accessed(struct page *arg0) {
  return;
}
void might_fault() {
  return;
}
int __VERIFIER_nondet_int(void);
int mod_timer(struct timer_list *arg0, unsigned long arg1) {
  return __VERIFIER_nondet_int();
}
unsigned long __VERIFIER_nondet_ulong(void);
unsigned long int msecs_to_jiffies(const unsigned int arg0) {
  return __VERIFIER_nondet_ulong();
}
void msleep(unsigned int arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int mtrr_add(unsigned long arg0, unsigned long arg1, unsigned int arg2, bool arg3) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int mtrr_del(int arg0, unsigned long arg1, unsigned long arg2) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int mutex_lock_interruptible_nested(struct mutex *arg0, unsigned int arg1) {
  return __VERIFIER_nondet_int();
}
void mutex_lock_nested(struct mutex *arg0, unsigned int arg1) {
  return;
}
int __VERIFIER_nondet_int(void);
int mutex_trylock(struct mutex *arg0) {
  return __VERIFIER_nondet_int();
}
void mutex_unlock(struct mutex *arg0) {
  return;
}
void *external_alloc(void);
void __VERIFIER_assume(int);
struct timeval ns_to_timeval(const s64 arg0) {
  struct timeval *tmp = (struct timeval*)external_alloc();
  __VERIFIER_assume(tmp != 0);
  return *tmp;
}
int __VERIFIER_nondet_int(void);
int pci_bus_alloc_resource(struct pci_bus *arg0, struct resource *arg1, resource_size_t arg2, resource_size_t arg3, resource_size_t arg4, unsigned int arg5, resource_size_t (*arg6)(void *, const struct resource *, resource_size_t , resource_size_t ), void *arg7) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int pci_bus_read_config_byte(struct pci_bus *arg0, unsigned int arg1, int arg2, u8 *arg3) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int pci_bus_read_config_dword(struct pci_bus *arg0, unsigned int arg1, int arg2, u32 *arg3) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int pci_bus_read_config_word(struct pci_bus *arg0, unsigned int arg1, int arg2, u16 *arg3) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int pci_bus_write_config_byte(struct pci_bus *arg0, unsigned int arg1, int arg2, u8 arg3) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int pci_bus_write_config_dword(struct pci_bus *arg0, unsigned int arg1, int arg2, u32 arg3) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int pci_bus_write_config_word(struct pci_bus *arg0, unsigned int arg1, int arg2, u16 arg3) {
  return __VERIFIER_nondet_int();
}
void pci_dev_put(struct pci_dev *arg0) {
  return;
}
void pci_disable_device(struct pci_dev *arg0) {
  return;
}
void pci_disable_msi(struct pci_dev *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int pci_enable_device(struct pci_dev *arg0) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int pci_enable_msi_block(struct pci_dev *arg0, unsigned int arg1) {
  return __VERIFIER_nondet_int();
}
void *external_alloc(void);
struct pci_dev *pci_get_class(unsigned int arg0, struct pci_dev *arg1) {
  return (struct pci_dev *)external_alloc();
}
void *external_alloc(void);
struct pci_dev *pci_get_domain_bus_and_slot(int arg0, unsigned int arg1, unsigned int arg2) {
  return (struct pci_dev *)external_alloc();
}
void *external_alloc(void);
void *pci_iomap(struct pci_dev *arg0, int arg1, unsigned long arg2) {
  return (void *)external_alloc();
}
void pci_iounmap(struct pci_dev *arg0, void *arg1) {
  return;
}
void *external_alloc(void);
void *pci_map_rom(struct pci_dev *arg0, size_t *arg1) {
  return (void *)external_alloc();
}
int __VERIFIER_nondet_int(void);
int pci_save_state(struct pci_dev *arg0) {
  return __VERIFIER_nondet_int();
}
void pci_set_master(struct pci_dev *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int pci_set_power_state(struct pci_dev *arg0, pci_power_t arg1) {
  return __VERIFIER_nondet_int();
}
void pci_unmap_rom(struct pci_dev *arg0, void *arg1) {
  return;
}
int __VERIFIER_nondet_int(void);
int pnp_range_reserved(resource_size_t arg0, resource_size_t arg1) {
  return __VERIFIER_nondet_int();
}
void prepare_to_wait(wait_queue_head_t *arg0, wait_queue_t *arg1, int arg2) {
  return;
}
int __VERIFIER_nondet_int(void);
int printk(const char *arg0, ...) {
  return __VERIFIER_nondet_int();
}
void put_page(struct page *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int queue_delayed_work(struct workqueue_struct *arg0, struct delayed_work *arg1, unsigned long arg2) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int queue_work(struct workqueue_struct *arg0, struct work_struct *arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int register_acpi_notifier(struct notifier_block *arg0) {
  return __VERIFIER_nondet_int();
}
void register_shrinker(struct shrinker *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int release_resource(struct resource *arg0) {
  return __VERIFIER_nondet_int();
}
void remove_wait_queue(wait_queue_head_t *arg0, wait_queue_t *arg1) {
  return;
}
void schedule() {
  return;
}
long __VERIFIER_nondet_long(void);
long int schedule_timeout(long arg0) {
  return __VERIFIER_nondet_long();
}
int __VERIFIER_nondet_int(void);
int schedule_work(struct work_struct *arg0) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int seq_printf(struct seq_file *arg0, const char *arg1, ...) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int seq_write(struct seq_file *arg0, const void *arg1, size_t arg2) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int set_memory_wb(unsigned long arg0, int arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int set_memory_wc(unsigned long arg0, int arg1) {
  return __VERIFIER_nondet_int();
}
void set_normalized_timespec(struct timespec *arg0, time_t arg1, s64 arg2) {
  return;
}
int __VERIFIER_nondet_int(void);
int set_page_dirty(struct page *arg0) {
  return __VERIFIER_nondet_int();
}
void *external_alloc(void);
struct page *shmem_read_mapping_page_gfp(struct address_space *arg0, unsigned long arg1, gfp_t arg2) {
  return (struct page *)external_alloc();
}
void shmem_truncate_range(struct inode *arg0, loff_t arg1, loff_t arg2) {
  return;
}
long __VERIFIER_nondet_long(void);
ssize_t simple_read_from_buffer(void *arg0, size_t arg1, loff_t *arg2, const void *arg3, size_t arg4) {
  return __VERIFIER_nondet_long();
}
unsigned long __VERIFIER_nondet_ulong(void);
unsigned long int simple_strtoul(const char *arg0, char **arg1, unsigned int arg2) {
  return __VERIFIER_nondet_ulong();
}
void trace_hardirqs_off() {
  return;
}
void trace_hardirqs_on() {
  return;
}
void unmap_mapping_range(struct address_space *arg0, const loff_t arg1, const loff_t arg2, int arg3) {
  return;
}
int __VERIFIER_nondet_int(void);
int unregister_acpi_notifier(struct notifier_block *arg0) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int unregister_framebuffer(struct fb_info *arg0) {
  return __VERIFIER_nondet_int();
}
void unregister_shrinker(struct shrinker *arg0) {
  return;
}
void up_read(struct rw_semaphore *arg0) {
  return;
}
void up_write(struct rw_semaphore *arg0) {
  return;
}
unsigned long __VERIFIER_nondet_ulong(void);
unsigned long int usecs_to_jiffies(const unsigned int arg0) {
  return __VERIFIER_nondet_ulong();
}
void vfree(const void *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int vga_client_register(struct pci_dev *arg0, void *arg1, void (*arg2)(void *, bool ), unsigned int (*arg3)(void *, bool )) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int vga_get(struct pci_dev *arg0, unsigned int arg1, int arg2) {
  return __VERIFIER_nondet_int();
}
void vga_put(struct pci_dev *arg0, unsigned int arg1) {
  return;
}
void vga_switcheroo_client_fb_set(struct pci_dev *arg0, struct fb_info *arg1) {
  return;
}
int __VERIFIER_nondet_int(void);
int vga_switcheroo_process_delayed_switch() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int vga_switcheroo_register_client(struct pci_dev *arg0, void (*arg1)(struct pci_dev *, enum vga_switcheroo_state ), void (*arg2)(struct pci_dev *), bool (*arg3)(struct pci_dev *)) {
  return __VERIFIER_nondet_int();
}
void vga_switcheroo_unregister_client(struct pci_dev *arg0) {
  return;
}
bool __VERIFIER_nondet_bool(void);
bool vgacon_text_force() {
  return __VERIFIER_nondet_bool();
}
int __VERIFIER_nondet_int(void);
int vm_insert_pfn(struct vm_area_struct *arg0, unsigned long arg1, unsigned long arg2) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int wait_for_completion_interruptible(struct completion *arg0) {
  return __VERIFIER_nondet_int();
}
void warn_slowpath_fmt(const char *arg0, const int arg1, const char *arg2, ...) {
  return;
}
void warn_slowpath_null(const char *arg0, const int arg1) {
  return;
}
int __VERIFIER_nondet_int(void);
int default_wake_function(wait_queue_t *arg0, unsigned int arg1, int arg2, void *arg3) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int autoremove_wake_function(wait_queue_t *arg0, unsigned int arg1, int arg2, void * arg3) {
  return __VERIFIER_nondet_int();
}
void *__VERIFIER_nondet_pointer(void);
void *external_alloc(void) {
  return __VERIFIER_nondet_pointer();
}
void free(void *);
void kfree(void const *p) {
  free((void *)p);
}
