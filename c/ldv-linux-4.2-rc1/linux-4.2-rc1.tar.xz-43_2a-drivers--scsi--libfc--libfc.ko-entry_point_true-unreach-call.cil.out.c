extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 33 "include/uapi/linux/types.h"
typedef __u16 __be16;
#line 35 "include/uapi/linux/types.h"
typedef __u32 __be32;
#line 37 "include/uapi/linux/types.h"
typedef __u64 __be64;
#line 40 "include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 229 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 91 "include/linux/types.h"
typedef unsigned int uint;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 152 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 67 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 220 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 361
struct page;
#line 361 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 372
struct file;
#line 385
struct seq_file;
#line 423
struct thread_struct;
#line 425
struct mm_struct;
#line 426
struct task_struct;
#line 427
struct cpumask;
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};
#line 33 "include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;
#line 34 "include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 131 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 54
struct net_device;
#line 420 "include/linux/printk.h"
struct file_operations;
#line 432
struct completion;
#line 555 "./arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct timespec;
#line 103
struct compat_timespec;
#line 104 "include/linux/bug.h"
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 104 "include/linux/bug.h"
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 104
struct pollfd;
#line 104 "include/linux/bug.h"
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 104 "include/linux/bug.h"
union __anonunion____missing_field_name_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};
#line 104 "include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_19 __annonCompField8 ;
};
#line 328 "include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 15 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 652 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 260 "./arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_29 {
   u64 rip ;
   u64 rdp ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_28 {
   struct __anonstruct____missing_field_name_29 __annonCompField12 ;
   struct __anonstruct____missing_field_name_30 __annonCompField13 ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_28 __annonCompField14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_31 __annonCompField15 ;
};
#line 66 "./arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 155 "./arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 161 "./arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};
#line 179 "./arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
};
#line 193 "./arch/x86/include/asm/fpu/types.h"
struct fpu {
   union fpregs_state state ;
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
};
#line 170 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 369
struct perf_event;
#line 370 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct fpu fpu ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 72 "./arch/x86/include/asm/preempt.h"
typedef int pao_T__;
#line 77 "./arch/x86/include/asm/preempt.h"
typedef int pao_T_____0;
#line 33 "include/linux/bottom_half.h"
struct lockdep_map;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 28 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
   unsigned int pin_count ;
};
#line 546 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion____missing_field_name_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_35 __annonCompField17 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_34 __annonCompField18 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_36 rwlock_t;
#line 426 "include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 52 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 404 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 404 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
#line 598 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_46 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_46 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_47 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_47 kgid_t;
#line 139 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 36 "include/linux/stat.h"
struct vm_area_struct;
#line 38 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 95 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_48 {
   unsigned long bits[16U] ;
};
#line 95 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_48 nodemask_t;
#line 13 "include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 39 "include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 177
struct rw_semaphore;
#line 178 "include/linux/mutex.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 172 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 437 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 296 "include/linux/rcupdate.h"
struct notifier_block;
#line 1121 "include/linux/rcupdate.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 238 "include/linux/timer.h"
struct hrtimer;
#line 239
enum hrtimer_restart;
#line 240 "include/linux/timer.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 41 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 838 "include/uapi/linux/sysctl.h"
struct nsproxy;
#line 259 "include/linux/timer.h"
struct workqueue_struct;
#line 260
struct work_struct;
#line 54 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 107 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 141 "include/linux/workqueue.h"
struct execute_work {
   struct work_struct work ;
};
#line 51 "include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 63 "include/linux/notifier.h"
struct blocking_notifier_head {
   struct rw_semaphore rwsem ;
   struct notifier_block *head ;
};
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 336
struct wake_irq;
#line 338 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 615 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
   int (*activate)(struct device * ) ;
   void (*sync)(struct device * ) ;
   void (*dismiss)(struct device * ) ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_115 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_115 mm_context_t;
#line 22 "include/xen/features.h"
struct bio_vec;
#line 1281 "include/linux/mmzone.h"
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 17 "include/linux/smp.h"
struct call_single_data {
   struct llist_node llist ;
   void (*func)(void * ) ;
   void *info ;
   unsigned int flags ;
};
#line 37 "include/linux/kmod.h"
struct cred;
#line 19 "./arch/x86/include/asm/elf.h"
struct inode;
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_148 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_149 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_147 {
   struct __anonstruct____missing_field_name_148 __annonCompField33 ;
   struct __anonstruct____missing_field_name_149 __annonCompField34 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_147 __annonCompField35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134
struct mem_cgroup;
#line 31 "include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_150 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_152 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_156 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_155 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_156 __annonCompField38 ;
   int units ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_154 {
   union __anonunion____missing_field_name_155 __annonCompField39 ;
   atomic_t _count ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_153 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_154 __annonCompField40 ;
   unsigned int active ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_151 {
   union __anonunion____missing_field_name_152 __annonCompField37 ;
   union __anonunion____missing_field_name_153 __annonCompField41 ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_158 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_159 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_157 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_158 __annonCompField43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_159 __annonCompField44 ;
   pgtable_t pmd_huge_pte ;
};
#line 32
struct kmem_cache;
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_160 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_150 __annonCompField36 ;
   struct __anonstruct____missing_field_name_151 __annonCompField42 ;
   union __anonunion____missing_field_name_157 __annonCompField45 ;
   union __anonunion____missing_field_name_160 __annonCompField46 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 266 "include/linux/mm_types.h"
struct __anonstruct_shared_161 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 266
struct anon_vma;
#line 266
struct vm_operations_struct;
#line 266
struct mempolicy;
#line 266 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_161 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 334 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 340 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 353 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 361 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 366
struct kioctx_table;
#line 367
struct linux_binfmt;
#line 367
struct mmu_notifier_mm;
#line 367 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "include/linux/elf.h"
union __anonunion____missing_field_name_166 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 53 "include/linux/elf.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_166 __annonCompField47 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct dentry;
#line 186
struct iattr;
#line 187
struct super_block;
#line 188
struct file_system_type;
#line 189
struct kernfs_open_node;
#line 190
struct kernfs_iattrs;
#line 213
struct kernfs_root;
#line 213 "include/linux/idr.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_node;
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89
struct kernfs_ops;
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 96 "include/linux/kernfs.h"
union __anonunion____missing_field_name_171 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 96 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_171 __annonCompField48 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 138 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 155 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 171 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 188 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 477
struct sock;
#line 478
struct kobject;
#line 479
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 485 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 59 "include/linux/kobject_ns.h"
struct bin_attribute;
#line 60 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 82 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 155 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 509 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct kernel_param;
#line 227 "include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_172 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct module *mod ;
   struct kernel_param_ops  const  *ops ;
   u16 const   perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_172 __annonCompField49 ;
};
#line 83 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 89 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 469 "include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};
#line 211 "include/linux/rbtree_latch.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 47 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 73
struct exception_table_entry;
#line 206
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 213 "include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
#line 220
struct module_sect_attrs;
#line 220
struct module_notes_attrs;
#line 220
struct tracepoint;
#line 220
struct trace_event_call;
#line 220
struct trace_enum_map;
#line 220 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 78 "include/uapi/linux/shm.h"
struct user_struct;
#line 26 "include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_180 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_180 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_182 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_183 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_184 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_185 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_187 {
   void *_lower ;
   void *_upper ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_186 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_187 _addr_bnd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_188 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_189 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_181 {
   int _pad[28U] ;
   struct __anonstruct__kill_182 _kill ;
   struct __anonstruct__timer_183 _timer ;
   struct __anonstruct__rt_184 _rt ;
   struct __anonstruct__sigchld_185 _sigchld ;
   struct __anonstruct__sigfault_186 _sigfault ;
   struct __anonstruct__sigpoll_188 _sigpoll ;
   struct __anonstruct__sigsys_189 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_181 _sifields ;
};
#line 113 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 443
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 450
struct pid_namespace;
#line 450 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 53 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 123 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};
#line 156 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned char in_hrtirq : 1 ;
   unsigned char hres_active : 1 ;
   unsigned char hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 466 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct key_type;
#line 41 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_196 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_197 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct____missing_field_name_199 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_198 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_199 __annonCompField52 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_200 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_202 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_201 {
   union __anonunion_payload_202 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_196 __annonCompField50 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_197 __annonCompField51 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_198 __annonCompField53 ;
   union __anonunion_type_data_200 type_data ;
   union __anonunion____missing_field_name_201 __annonCompField54 ;
};
#line 358
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 90 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 369
struct percpu_ref;
#line 55 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 68 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
#line 27 "include/linux/percpu-rwsem.h"
struct cgroup;
#line 28
struct cgroup_root;
#line 29
struct cgroup_subsys;
#line 30
struct cgroup_taskset;
#line 72 "include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 124 "include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 197 "include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
#line 270 "include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 306 "include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 388 "include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
#line 128 "include/linux/sched.h"
struct futex_pi_state;
#line 129
struct robust_list_head;
#line 130
struct bio_list;
#line 131
struct fs_struct;
#line 132
struct perf_event_context;
#line 133
struct blk_plug;
#line 135
struct nameidata;
#line 188
struct cfs_rq;
#line 189
struct task_group;
#line 477 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 516 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 524 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 531 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 543 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 563 "include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
#line 584 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};
#line 620
struct autogroup;
#line 621
struct tty_struct;
#line 621
struct taskstats;
#line 621
struct tty_audit_buf;
#line 621 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 790 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 833
struct backing_dev_info;
#line 834
struct reclaim_state;
#line 835 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 849 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 897 "include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};
#line 1126
struct io_context;
#line 1160
struct pipe_inode_info;
#line 1161
struct uts_namespace;
#line 1162 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1169 "include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};
#line 1194 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1229 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1261
struct rt_rq;
#line 1261 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1277 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1343 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1769
struct sched_class;
#line 1769
struct files_struct;
#line 1769
struct compat_robust_list_head;
#line 1769
struct numa_group;
#line 1769
struct ftrace_ret_stack;
#line 1769 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char sched_migrated : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned char brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
};
#line 93 "include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
#line 27 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 64 "include/linux/page_ext.h"
struct file_ra_state;
#line 65
struct writeback_control;
#line 66
struct bdi_writeback;
#line 207 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 239 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*pfn_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 1200
struct kvec;
#line 2242 "include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 21 "include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 65 "include/linux/crc32.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 21 "include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
#line 27 "include/linux/uio.h"
union __anonunion____missing_field_name_217 {
   struct iovec  const  *iov ;
   struct kvec  const  *kvec ;
   struct bio_vec  const  *bvec ;
};
#line 27 "include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion____missing_field_name_217 __annonCompField58 ;
   unsigned long nr_segs ;
};
#line 38 "include/linux/socket.h"
struct kiocb;
#line 259 "./include/uapi/linux/if.h"
struct klist_node;
#line 260 "./include/uapi/linux/if.h"
struct klist {
   spinlock_t k_lock ;
   struct list_head k_list ;
   void (*get)(struct klist_node * ) ;
   void (*put)(struct klist_node * ) ;
};
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67
struct path;
#line 68 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 187
struct pinctrl;
#line 188
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 48 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 48 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "./arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct fwnode_handle;
#line 22
struct iommu_ops;
#line 23
struct iommu_group;
#line 61 "include/linux/device.h"
struct device_attribute;
#line 61 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 139
struct device_type;
#line 197
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
} ;
#line 203
struct of_device_id;
#line 203
struct acpi_device_id;
#line 203 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 353
struct class_attribute;
#line 353 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 446 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 514 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 542 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 674 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 683
struct dma_coherent_mem;
#line 683
struct cma;
#line 683 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 829 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 1273 "include/linux/device.h"
struct attribute_container {
   struct list_head node ;
   struct klist containers ;
   struct class *class ;
   struct attribute_group  const  *grp ;
   struct device_attribute **attrs ;
   int (*match)(struct attribute_container * , struct device * ) ;
   unsigned long flags ;
};
#line 71 "include/linux/attribute_container.h"
struct transport_container;
#line 43 "include/linux/transport_class.h"
struct transport_container {
   struct attribute_container ac ;
   struct attribute_group  const  *statistics ;
};
#line 50 "include/linux/genhd.h"
struct hlist_bl_node;
#line 50 "include/linux/genhd.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_232 {
   spinlock_t lock ;
   int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion____missing_field_name_231 {
   struct __anonstruct____missing_field_name_232 __annonCompField59 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_231 __annonCompField60 ;
};
#line 50 "include/linux/lockref.h"
struct vfsmount;
#line 51 "include/linux/lockref.h"
struct __anonstruct____missing_field_name_234 {
   u32 hash ;
   u32 len ;
};
#line 51 "include/linux/lockref.h"
union __anonunion____missing_field_name_233 {
   struct __anonstruct____missing_field_name_234 __annonCompField61 ;
   u64 hash_len ;
};
#line 51 "include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_233 __annonCompField62 ;
   unsigned char const   *name ;
};
#line 90 "include/linux/dcache.h"
struct dentry_operations;
#line 90 "include/linux/dcache.h"
union __anonunion_d_u_235 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
#line 90 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_235 d_u ;
};
#line 142 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
   struct inode *(*d_select_inode)(struct dentry * , unsigned int  ) ;
};
#line 585 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 27 "include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 32 "include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
#line 37 "include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
#line 47 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
#line 58 "include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_239 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "include/linux/radix-tree.h"
union __anonunion____missing_field_name_238 {
   struct __anonstruct____missing_field_name_239 __annonCompField63 ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_238 __annonCompField64 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "./include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 44
struct bio_set;
#line 45
struct bio;
#line 46
struct bio_integrity_payload;
#line 47
struct block_device;
#line 17 "include/linux/blk_types.h"
typedef void bio_end_io_t(struct bio * , int  );
#line 19 "include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 28 "include/linux/blk_types.h"
struct bvec_iter {
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned int bi_idx ;
   unsigned int bi_bvec_done ;
};
#line 40 "include/linux/blk_types.h"
union __anonunion____missing_field_name_242 {
   struct bio_integrity_payload *bi_integrity ;
};
#line 40 "include/linux/blk_types.h"
struct bio {
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
   unsigned long bi_rw ;
   struct bvec_iter bi_iter ;
   unsigned int bi_phys_segments ;
   unsigned int bi_seg_front_size ;
   unsigned int bi_seg_back_size ;
   atomic_t __bi_remaining ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
   struct io_context *bi_ioc ;
   struct cgroup_subsys_state *bi_css ;
   union __anonunion____missing_field_name_242 __annonCompField65 ;
   unsigned short bi_vcnt ;
   unsigned short bi_max_vecs ;
   atomic_t __bi_cnt ;
   struct bio_vec *bi_io_vec ;
   struct bio_set *bi_pool ;
   struct bio_vec bi_inline_vecs[0U] ;
};
#line 60 "include/uapi/linux/fs.h"
struct export_operations;
#line 61
struct hd_geometry;
#line 62
struct poll_table_struct;
#line 63
struct kstatfs;
#line 64
struct swap_info_struct;
#line 74 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 212 "./include/uapi/linux/dqblk_xfs.h"
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "include/linux/projid.h"
struct __anonstruct_kprojid_t_243 {
   projid_t val ;
};
#line 23 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_243 kprojid_t;
#line 166 "include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 66 "include/linux/quota.h"
typedef long long qsize_t;
#line 67 "include/linux/quota.h"
union __anonunion____missing_field_name_244 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 67 "include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_244 __annonCompField66 ;
   enum quota_type type ;
};
#line 184 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 206
struct quota_format_type;
#line 207 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 272 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 299 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 310 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
   int (*get_projid)(struct inode * , kprojid_t * ) ;
};
#line 325 "include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 348 "include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
#line 394 "include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};
#line 405 "include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};
#line 418 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*set_info)(struct super_block * , int  , struct qc_info * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_state)(struct super_block * , struct qc_state * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 432 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 496 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops  const  *ops[3U] ;
};
#line 526 "include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb * , long  , long  ) ;
   void *private ;
   int ki_flags ;
};
#line 365 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 422 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 442
struct request_queue;
#line 443
struct hd_struct;
#line 443
struct gendisk;
#line 443 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 559
struct posix_acl;
#line 560
struct inode_operations;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_247 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_248 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 560
struct file_lock_context;
#line 560
struct cdev;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_249 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};
#line 560 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_247 __annonCompField67 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_248 __annonCompField68 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_249 __annonCompField69 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 806 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 814 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 837 "include/linux/fs.h"
union __anonunion_f_u_250 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 837 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_250 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 922 "include/linux/fs.h"
typedef void *fl_owner_t;
#line 923
struct file_lock;
#line 924 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 930 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t  ) ;
   void (*lm_put_owner)(fl_owner_t  ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
#line 946
struct net;
#line 951
struct nlm_lockowner;
#line 952 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_252 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_251 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_252 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_251 fl_u ;
};
#line 1004 "include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1062 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1240 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1271
struct super_operations;
#line 1271
struct xattr_handler;
#line 1271
struct mtd_info;
#line 1271 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
#line 1510 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1524
struct dir_context;
#line 1549 "include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1555
struct block_device_operations;
#line 1556 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1617 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   char const   *(*follow_link)(struct dentry * , void ** ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct inode * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1671 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
#line 1910 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 80 "include/linux/genhd.h"
struct disk_stats {
   unsigned long sectors[2U] ;
   unsigned long ios[2U] ;
   unsigned long merges[2U] ;
   unsigned long ticks[2U] ;
   unsigned long io_ticks ;
   unsigned long time_in_queue ;
};
#line 89 "include/linux/genhd.h"
struct partition_meta_info {
   char uuid[37U] ;
   u8 volname[64U] ;
};
#line 101 "include/linux/genhd.h"
struct hd_struct {
   sector_t start_sect ;
   sector_t nr_sects ;
   seqcount_t nr_sects_seq ;
   sector_t alignment_offset ;
   unsigned int discard_alignment ;
   struct device __dev ;
   struct kobject *holder_dir ;
   int policy ;
   int partno ;
   struct partition_meta_info *info ;
   int make_it_fail ;
   unsigned long stamp ;
   atomic_t in_flight[2U] ;
   struct disk_stats *dkstats ;
   atomic_t ref ;
   struct callback_head callback_head ;
};
#line 155 "include/linux/genhd.h"
struct disk_part_tbl {
   struct callback_head callback_head ;
   int len ;
   struct hd_struct *last_lookup ;
   struct hd_struct *part[] ;
};
#line 162
struct disk_events;
#line 163
struct timer_rand_state;
#line 163
struct blk_integrity;
#line 163 "include/linux/genhd.h"
struct gendisk {
   int major ;
   int first_minor ;
   int minors ;
   char disk_name[32U] ;
   char *(*devnode)(struct gendisk * , umode_t * ) ;
   unsigned int events ;
   unsigned int async_events ;
   struct disk_part_tbl *part_tbl ;
   struct hd_struct part0 ;
   struct block_device_operations  const  *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct device *driverfs_dev ;
   struct kobject *slave_dir ;
   struct timer_rand_state *random ;
   atomic_t sync_io ;
   struct disk_events *ev ;
   struct blk_integrity *integrity ;
   int node_id ;
};
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 398 "include/linux/irq.h"
struct proc_dir_entry;
#line 72 "include/linux/flex_proportions.h"
struct fprop_local_percpu {
   struct percpu_counter events ;
   unsigned int period ;
   raw_spinlock_t lock ;
};
#line 32 "include/linux/backing-dev-defs.h"
typedef int congested_fn(void * , int  );
#line 41 "include/linux/backing-dev-defs.h"
struct bdi_writeback_congested {
   unsigned long state ;
   atomic_t refcnt ;
   struct backing_dev_info *bdi ;
   int blkcg_id ;
   struct rb_node rb_node ;
};
#line 60 "include/linux/backing-dev-defs.h"
union __anonunion____missing_field_name_261 {
   struct work_struct release_work ;
   struct callback_head rcu ;
};
#line 60 "include/linux/backing-dev-defs.h"
struct bdi_writeback {
   struct backing_dev_info *bdi ;
   unsigned long state ;
   unsigned long last_old_flush ;
   struct list_head b_dirty ;
   struct list_head b_io ;
   struct list_head b_more_io ;
   struct list_head b_dirty_time ;
   spinlock_t list_lock ;
   struct percpu_counter stat[4U] ;
   struct bdi_writeback_congested *congested ;
   unsigned long bw_time_stamp ;
   unsigned long dirtied_stamp ;
   unsigned long written_stamp ;
   unsigned long write_bandwidth ;
   unsigned long avg_write_bandwidth ;
   unsigned long dirty_ratelimit ;
   unsigned long balanced_dirty_ratelimit ;
   struct fprop_local_percpu completions ;
   int dirty_exceeded ;
   spinlock_t work_lock ;
   struct list_head work_list ;
   struct delayed_work dwork ;
   struct percpu_ref refcnt ;
   struct fprop_local_percpu memcg_completions ;
   struct cgroup_subsys_state *memcg_css ;
   struct cgroup_subsys_state *blkcg_css ;
   struct list_head memcg_node ;
   struct list_head blkcg_node ;
   union __anonunion____missing_field_name_261 __annonCompField77 ;
};
#line 132 "include/linux/backing-dev-defs.h"
struct backing_dev_info {
   struct list_head bdi_list ;
   unsigned long ra_pages ;
   unsigned int capabilities ;
   congested_fn *congested_fn ;
   void *congested_data ;
   char *name ;
   unsigned int min_ratio ;
   unsigned int max_ratio ;
   unsigned int max_prop_frac ;
   atomic_long_t tot_write_bandwidth ;
   struct bdi_writeback wb ;
   struct radix_tree_root cgwb_tree ;
   struct rb_root cgwb_congested_tree ;
   atomic_t usage_cnt ;
   wait_queue_head_t wb_waitq ;
   struct device *dev ;
   struct timer_list laptop_mode_wb_timer ;
   struct dentry *debug_dir ;
   struct dentry *debug_stats ;
};
#line 11 "include/linux/mempool.h"
typedef void *mempool_alloc_t(gfp_t  , void * );
#line 12 "include/linux/mempool.h"
typedef void mempool_free_t(void * , void * );
#line 13 "include/linux/mempool.h"
struct mempool_s {
   spinlock_t lock ;
   int min_nr ;
   int curr_nr ;
   void **elements ;
   void *pool_data ;
   mempool_alloc_t *alloc ;
   mempool_free_t *free ;
   wait_queue_head_t wait ;
};
#line 24 "include/linux/mempool.h"
typedef struct mempool_s mempool_t;
#line 78 "include/linux/mempool.h"
union __anonunion____missing_field_name_262 {
   struct list_head q_node ;
   struct kmem_cache *__rcu_icq_cache ;
};
#line 78 "include/linux/mempool.h"
union __anonunion____missing_field_name_263 {
   struct hlist_node ioc_node ;
   struct callback_head __rcu_head ;
};
#line 78 "include/linux/mempool.h"
struct io_cq {
   struct request_queue *q ;
   struct io_context *ioc ;
   union __anonunion____missing_field_name_262 __annonCompField78 ;
   union __anonunion____missing_field_name_263 __annonCompField79 ;
   unsigned int flags ;
};
#line 92 "include/linux/iocontext.h"
struct io_context {
   atomic_long_t refcount ;
   atomic_t active_ref ;
   atomic_t nr_tasks ;
   spinlock_t lock ;
   unsigned short ioprio ;
   int nr_batch_requests ;
   unsigned long last_waited ;
   struct radix_tree_root icq_tree ;
   struct io_cq *icq_hint ;
   struct hlist_head icq_list ;
   struct work_struct release_work ;
};
#line 326 "include/linux/bio.h"
struct bio_integrity_payload {
   struct bio *bip_bio ;
   struct bvec_iter bip_iter ;
   bio_end_io_t *bip_end_io ;
   unsigned short bip_slab ;
   unsigned short bip_vcnt ;
   unsigned short bip_max_vcnt ;
   unsigned short bip_flags ;
   struct work_struct bip_work ;
   struct bio_vec *bip_vec ;
   struct bio_vec bip_inline_vecs[0U] ;
};
#line 541 "include/linux/bio.h"
struct bio_list {
   struct bio *head ;
   struct bio *tail ;
};
#line 662 "include/linux/bio.h"
struct bio_set {
   struct kmem_cache *bio_slab ;
   unsigned int front_pad ;
   mempool_t *bio_pool ;
   mempool_t *bvec_pool ;
   mempool_t *bio_integrity_pool ;
   mempool_t *bvec_integrity_pool ;
   spinlock_t rescue_lock ;
   struct bio_list rescue_list ;
   struct work_struct rescue_work ;
   struct workqueue_struct *rescue_workqueue ;
};
#line 64 "include/uapi/linux/bsg.h"
struct bsg_class_device {
   struct device *class_dev ;
   struct device *parent ;
   int minor ;
   struct request_queue *queue ;
   struct kref ref ;
   void (*release)(struct device * ) ;
};
#line 22 "include/linux/bsg.h"
struct elevator_queue;
#line 23
struct blk_trace;
#line 24
struct request;
#line 26
struct bsg_job;
#line 27
struct blkcg_gq;
#line 28
struct blk_flush_queue;
#line 49 "include/linux/blkdev.h"
typedef void rq_end_io_fn(struct request * , int  );
#line 50 "include/linux/blkdev.h"
struct request_list {
   struct request_queue *q ;
   struct blkcg_gq *blkg ;
   int count[2U] ;
   int starved[2U] ;
   mempool_t *rq_pool ;
   wait_queue_head_t wait[2U] ;
   unsigned int flags ;
};
#line 75 "include/linux/blkdev.h"
union __anonunion____missing_field_name_264 {
   struct call_single_data csd ;
   unsigned long fifo_time ;
};
#line 75
struct blk_mq_ctx;
#line 75 "include/linux/blkdev.h"
union __anonunion____missing_field_name_265 {
   struct hlist_node hash ;
   struct list_head ipi_list ;
};
#line 75 "include/linux/blkdev.h"
union __anonunion____missing_field_name_266 {
   struct rb_node rb_node ;
   void *completion_data ;
};
#line 75 "include/linux/blkdev.h"
struct __anonstruct_elv_268 {
   struct io_cq *icq ;
   void *priv[2U] ;
};
#line 75 "include/linux/blkdev.h"
struct __anonstruct_flush_269 {
   unsigned int seq ;
   struct list_head list ;
   rq_end_io_fn *saved_end_io ;
};
#line 75 "include/linux/blkdev.h"
union __anonunion____missing_field_name_267 {
   struct __anonstruct_elv_268 elv ;
   struct __anonstruct_flush_269 flush ;
};
#line 75 "include/linux/blkdev.h"
struct request {
   struct list_head queuelist ;
   union __anonunion____missing_field_name_264 __annonCompField80 ;
   struct request_queue *q ;
   struct blk_mq_ctx *mq_ctx ;
   u64 cmd_flags ;
   unsigned int cmd_type ;
   unsigned long atomic_flags ;
   int cpu ;
   unsigned int __data_len ;
   sector_t __sector ;
   struct bio *bio ;
   struct bio *biotail ;
   union __anonunion____missing_field_name_265 __annonCompField81 ;
   union __anonunion____missing_field_name_266 __annonCompField82 ;
   union __anonunion____missing_field_name_267 __annonCompField83 ;
   struct gendisk *rq_disk ;
   struct hd_struct *part ;
   unsigned long start_time ;
   struct request_list *rl ;
   unsigned long long start_time_ns ;
   unsigned long long io_start_time_ns ;
   unsigned short nr_phys_segments ;
   unsigned short nr_integrity_segments ;
   unsigned short ioprio ;
   void *special ;
   int tag ;
   int errors ;
   unsigned char __cmd[16U] ;
   unsigned char *cmd ;
   unsigned short cmd_len ;
   unsigned int extra_len ;
   unsigned int sense_len ;
   unsigned int resid_len ;
   void *sense ;
   unsigned long deadline ;
   struct list_head timeout_list ;
   unsigned int timeout ;
   int retries ;
   rq_end_io_fn *end_io ;
   void *end_io_data ;
   struct request *next_rq ;
};
#line 113 "include/linux/hashtable.h"
struct elevator_type;
#line 12 "include/linux/elevator.h"
typedef int elevator_merge_fn(struct request_queue * , struct request ** , struct bio * );
#line 15 "include/linux/elevator.h"
typedef void elevator_merge_req_fn(struct request_queue * , struct request * , struct request * );
#line 17 "include/linux/elevator.h"
typedef void elevator_merged_fn(struct request_queue * , struct request * , int  );
#line 19 "include/linux/elevator.h"
typedef int elevator_allow_merge_fn(struct request_queue * , struct request * , struct bio * );
#line 21 "include/linux/elevator.h"
typedef void elevator_bio_merged_fn(struct request_queue * , struct request * , struct bio * );
#line 24 "include/linux/elevator.h"
typedef int elevator_dispatch_fn(struct request_queue * , int  );
#line 26 "include/linux/elevator.h"
typedef void elevator_add_req_fn(struct request_queue * , struct request * );
#line 27 "include/linux/elevator.h"
typedef struct request *elevator_request_list_fn(struct request_queue * , struct request * );
#line 28 "include/linux/elevator.h"
typedef void elevator_completed_req_fn(struct request_queue * , struct request * );
#line 29 "include/linux/elevator.h"
typedef int elevator_may_queue_fn(struct request_queue * , int  );
#line 31 "include/linux/elevator.h"
typedef void elevator_init_icq_fn(struct io_cq * );
#line 32 "include/linux/elevator.h"
typedef void elevator_exit_icq_fn(struct io_cq * );
#line 33 "include/linux/elevator.h"
typedef int elevator_set_req_fn(struct request_queue * , struct request * , struct bio * ,
                                gfp_t  );
#line 35 "include/linux/elevator.h"
typedef void elevator_put_req_fn(struct request * );
#line 36 "include/linux/elevator.h"
typedef void elevator_activate_req_fn(struct request_queue * , struct request * );
#line 37 "include/linux/elevator.h"
typedef void elevator_deactivate_req_fn(struct request_queue * , struct request * );
#line 39 "include/linux/elevator.h"
typedef int elevator_init_fn(struct request_queue * , struct elevator_type * );
#line 41 "include/linux/elevator.h"
typedef void elevator_exit_fn(struct elevator_queue * );
#line 42 "include/linux/elevator.h"
typedef void elevator_registered_fn(struct request_queue * );
#line 43 "include/linux/elevator.h"
struct elevator_ops {
   elevator_merge_fn *elevator_merge_fn ;
   elevator_merged_fn *elevator_merged_fn ;
   elevator_merge_req_fn *elevator_merge_req_fn ;
   elevator_allow_merge_fn *elevator_allow_merge_fn ;
   elevator_bio_merged_fn *elevator_bio_merged_fn ;
   elevator_dispatch_fn *elevator_dispatch_fn ;
   elevator_add_req_fn *elevator_add_req_fn ;
   elevator_activate_req_fn *elevator_activate_req_fn ;
   elevator_deactivate_req_fn *elevator_deactivate_req_fn ;
   elevator_completed_req_fn *elevator_completed_req_fn ;
   elevator_request_list_fn *elevator_former_req_fn ;
   elevator_request_list_fn *elevator_latter_req_fn ;
   elevator_init_icq_fn *elevator_init_icq_fn ;
   elevator_exit_icq_fn *elevator_exit_icq_fn ;
   elevator_set_req_fn *elevator_set_req_fn ;
   elevator_put_req_fn *elevator_put_req_fn ;
   elevator_may_queue_fn *elevator_may_queue_fn ;
   elevator_init_fn *elevator_init_fn ;
   elevator_exit_fn *elevator_exit_fn ;
   elevator_registered_fn *elevator_registered_fn ;
};
#line 74 "include/linux/elevator.h"
struct elv_fs_entry {
   struct attribute attr ;
   ssize_t (*show)(struct elevator_queue * , char * ) ;
   ssize_t (*store)(struct elevator_queue * , char const   * , size_t  ) ;
};
#line 82 "include/linux/elevator.h"
struct elevator_type {
   struct kmem_cache *icq_cache ;
   struct elevator_ops ops ;
   size_t icq_size ;
   size_t icq_align ;
   struct elv_fs_entry *elevator_attrs ;
   char elevator_name[16U] ;
   struct module *elevator_owner ;
   char icq_cache_name[21U] ;
   struct list_head list ;
};
#line 103 "include/linux/elevator.h"
struct elevator_queue {
   struct elevator_type *type ;
   void *elevator_data ;
   struct kobject kobj ;
   struct mutex sysfs_lock ;
   unsigned char registered : 1 ;
   struct hlist_head hash[64U] ;
};
#line 210 "include/linux/blkdev.h"
typedef void request_fn_proc(struct request_queue * );
#line 211 "include/linux/blkdev.h"
typedef void make_request_fn(struct request_queue * , struct bio * );
#line 212 "include/linux/blkdev.h"
typedef int prep_rq_fn(struct request_queue * , struct request * );
#line 213 "include/linux/blkdev.h"
typedef void unprep_rq_fn(struct request_queue * , struct request * );
#line 214 "include/linux/blkdev.h"
struct bvec_merge_data {
   struct block_device *bi_bdev ;
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned long bi_rw ;
};
#line 222 "include/linux/blkdev.h"
typedef int merge_bvec_fn(struct request_queue * , struct bvec_merge_data * , struct bio_vec * );
#line 224 "include/linux/blkdev.h"
typedef void softirq_done_fn(struct request * );
#line 225 "include/linux/blkdev.h"
typedef int dma_drain_needed_fn(struct request * );
#line 226 "include/linux/blkdev.h"
typedef int lld_busy_fn(struct request_queue * );
#line 227 "include/linux/blkdev.h"
typedef int bsg_job_fn(struct bsg_job * );
#line 228
enum blk_eh_timer_return {
    BLK_EH_NOT_HANDLED = 0,
    BLK_EH_HANDLED = 1,
    BLK_EH_RESET_TIMER = 2
} ;
#line 235 "include/linux/blkdev.h"
typedef enum blk_eh_timer_return rq_timed_out_fn(struct request * );
#line 241 "include/linux/blkdev.h"
struct blk_queue_tag {
   struct request **tag_index ;
   unsigned long *tag_map ;
   int busy ;
   int max_depth ;
   int real_max_depth ;
   atomic_t refcnt ;
   int alloc_policy ;
   int next_tag ;
};
#line 252 "include/linux/blkdev.h"
struct queue_limits {
   unsigned long bounce_pfn ;
   unsigned long seg_boundary_mask ;
   unsigned int max_hw_sectors ;
   unsigned int chunk_sectors ;
   unsigned int max_sectors ;
   unsigned int max_segment_size ;
   unsigned int physical_block_size ;
   unsigned int alignment_offset ;
   unsigned int io_min ;
   unsigned int io_opt ;
   unsigned int max_discard_sectors ;
   unsigned int max_write_same_sectors ;
   unsigned int discard_granularity ;
   unsigned int discard_alignment ;
   unsigned short logical_block_size ;
   unsigned short max_segments ;
   unsigned short max_integrity_segments ;
   unsigned char misaligned ;
   unsigned char discard_misaligned ;
   unsigned char cluster ;
   unsigned char discard_zeroes_data ;
   unsigned char raid_partial_stripes_expensive ;
};
#line 285
struct blk_mq_ops;
#line 285
struct blk_mq_hw_ctx;
#line 285
struct throtl_data;
#line 285
struct blk_mq_tag_set;
#line 285 "include/linux/blkdev.h"
struct request_queue {
   struct list_head queue_head ;
   struct request *last_merge ;
   struct elevator_queue *elevator ;
   int nr_rqs[2U] ;
   int nr_rqs_elvpriv ;
   struct request_list root_rl ;
   request_fn_proc *request_fn ;
   make_request_fn *make_request_fn ;
   prep_rq_fn *prep_rq_fn ;
   unprep_rq_fn *unprep_rq_fn ;
   merge_bvec_fn *merge_bvec_fn ;
   softirq_done_fn *softirq_done_fn ;
   rq_timed_out_fn *rq_timed_out_fn ;
   dma_drain_needed_fn *dma_drain_needed ;
   lld_busy_fn *lld_busy_fn ;
   struct blk_mq_ops *mq_ops ;
   unsigned int *mq_map ;
   struct blk_mq_ctx *queue_ctx ;
   unsigned int nr_queues ;
   struct blk_mq_hw_ctx **queue_hw_ctx ;
   unsigned int nr_hw_queues ;
   sector_t end_sector ;
   struct request *boundary_rq ;
   struct delayed_work delay_work ;
   struct backing_dev_info backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
   int id ;
   gfp_t bounce_gfp ;
   spinlock_t __queue_lock ;
   spinlock_t *queue_lock ;
   struct kobject kobj ;
   struct kobject mq_kobj ;
   struct device *dev ;
   int rpm_status ;
   unsigned int nr_pending ;
   unsigned long nr_requests ;
   unsigned int nr_congestion_on ;
   unsigned int nr_congestion_off ;
   unsigned int nr_batching ;
   unsigned int dma_drain_size ;
   void *dma_drain_buffer ;
   unsigned int dma_pad_mask ;
   unsigned int dma_alignment ;
   struct blk_queue_tag *queue_tags ;
   struct list_head tag_busy_list ;
   unsigned int nr_sorted ;
   unsigned int in_flight[2U] ;
   unsigned int request_fn_active ;
   unsigned int rq_timeout ;
   struct timer_list timeout ;
   struct list_head timeout_list ;
   struct list_head icq_list ;
   unsigned long blkcg_pols[1U] ;
   struct blkcg_gq *root_blkg ;
   struct list_head blkg_list ;
   struct queue_limits limits ;
   unsigned int sg_timeout ;
   unsigned int sg_reserved_size ;
   int node ;
   struct blk_trace *blk_trace ;
   unsigned int flush_flags ;
   unsigned char flush_not_queueable : 1 ;
   struct blk_flush_queue *fq ;
   struct list_head requeue_list ;
   spinlock_t requeue_lock ;
   struct work_struct requeue_work ;
   struct mutex sysfs_lock ;
   int bypass_depth ;
   atomic_t mq_freeze_depth ;
   bsg_job_fn *bsg_job_fn ;
   int bsg_job_size ;
   struct bsg_class_device bsg_dev ;
   struct throtl_data *td ;
   struct callback_head callback_head ;
   wait_queue_head_t mq_freeze_wq ;
   struct percpu_ref mq_usage_counter ;
   struct list_head all_q_node ;
   struct blk_mq_tag_set *tag_set ;
   struct list_head tag_set_list ;
};
#line 1020 "include/linux/blkdev.h"
struct blk_plug {
   struct list_head list ;
   struct list_head mq_list ;
   struct list_head cb_list ;
};
#line 1398 "include/linux/blkdev.h"
struct blk_integrity_iter {
   void *prot_buf ;
   void *data_buf ;
   sector_t seed ;
   unsigned int data_size ;
   unsigned short interval ;
   char const   *disk_name ;
};
#line 1427 "include/linux/blkdev.h"
typedef int integrity_processing_fn(struct blk_integrity_iter * );
#line 1428 "include/linux/blkdev.h"
struct blk_integrity {
   integrity_processing_fn *generate_fn ;
   integrity_processing_fn *verify_fn ;
   unsigned short flags ;
   unsigned short tuple_size ;
   unsigned short interval ;
   unsigned short tag_size ;
   char const   *name ;
   struct kobject kobj ;
};
#line 1482 "include/linux/blkdev.h"
struct block_device_operations {
   int (*open)(struct block_device * , fmode_t  ) ;
   void (*release)(struct gendisk * , fmode_t  ) ;
   int (*rw_page)(struct block_device * , sector_t  , struct page * , int  ) ;
   int (*ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   long (*direct_access)(struct block_device * , sector_t  , void ** , unsigned long * ,
                         long  ) ;
   unsigned int (*check_events)(struct gendisk * , unsigned int  ) ;
   int (*media_changed)(struct gendisk * ) ;
   void (*unlock_native_capacity)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   int (*getgeo)(struct block_device * , struct hd_geometry * ) ;
   void (*swap_slot_free_notify)(struct block_device * , unsigned long  ) ;
   struct module *owner ;
};
#line 1578
struct blk_mq_tags;
#line 1579 "include/linux/blkdev.h"
struct blk_mq_cpu_notifier {
   struct list_head list ;
   void *data ;
   int (*notify)(void * , unsigned long  , unsigned int  ) ;
};
#line 14 "include/linux/blk-mq.h"
struct blk_align_bitmap;
#line 14 "include/linux/blk-mq.h"
struct blk_mq_ctxmap {
   unsigned int size ;
   unsigned int bits_per_word ;
   struct blk_align_bitmap *map ;
};
#line 20 "include/linux/blk-mq.h"
struct __anonstruct____missing_field_name_271 {
   spinlock_t lock ;
   struct list_head dispatch ;
};
#line 20 "include/linux/blk-mq.h"
struct blk_mq_hw_ctx {
   struct __anonstruct____missing_field_name_271 __annonCompField84 ;
   unsigned long state ;
   struct delayed_work run_work ;
   struct delayed_work delay_work ;
   cpumask_var_t cpumask ;
   int next_cpu ;
   int next_cpu_batch ;
   unsigned long flags ;
   struct request_queue *queue ;
   struct blk_flush_queue *fq ;
   void *driver_data ;
   struct blk_mq_ctxmap ctx_map ;
   unsigned int nr_ctx ;
   struct blk_mq_ctx **ctxs ;
   atomic_t wait_index ;
   struct blk_mq_tags *tags ;
   unsigned long queued ;
   unsigned long run ;
   unsigned long dispatched[10U] ;
   unsigned int numa_node ;
   unsigned int queue_num ;
   atomic_t nr_active ;
   struct blk_mq_cpu_notifier cpu_notifier ;
   struct kobject kobj ;
};
#line 63 "include/linux/blk-mq.h"
struct blk_mq_tag_set {
   struct blk_mq_ops *ops ;
   unsigned int nr_hw_queues ;
   unsigned int queue_depth ;
   unsigned int reserved_tags ;
   unsigned int cmd_size ;
   int numa_node ;
   unsigned int timeout ;
   unsigned int flags ;
   void *driver_data ;
   struct blk_mq_tags **tags ;
   struct mutex tag_list_lock ;
   struct list_head tag_list ;
};
#line 80 "include/linux/blk-mq.h"
struct blk_mq_queue_data {
   struct request *rq ;
   struct list_head *list ;
   bool last ;
};
#line 87 "include/linux/blk-mq.h"
typedef int queue_rq_fn(struct blk_mq_hw_ctx * , struct blk_mq_queue_data  const  * );
#line 88 "include/linux/blk-mq.h"
typedef struct blk_mq_hw_ctx *map_queue_fn(struct request_queue * , int const    );
#line 89 "include/linux/blk-mq.h"
typedef enum blk_eh_timer_return timeout_fn(struct request * , bool  );
#line 90 "include/linux/blk-mq.h"
typedef int init_hctx_fn(struct blk_mq_hw_ctx * , void * , unsigned int  );
#line 91 "include/linux/blk-mq.h"
typedef void exit_hctx_fn(struct blk_mq_hw_ctx * , unsigned int  );
#line 92 "include/linux/blk-mq.h"
typedef int init_request_fn(void * , struct request * , unsigned int  , unsigned int  ,
                            unsigned int  );
#line 94 "include/linux/blk-mq.h"
typedef void exit_request_fn(void * , struct request * , unsigned int  , unsigned int  );
#line 100 "include/linux/blk-mq.h"
struct blk_mq_ops {
   queue_rq_fn *queue_rq ;
   map_queue_fn *map_queue ;
   timeout_fn *timeout ;
   softirq_done_fn *complete ;
   init_hctx_fn *init_hctx ;
   exit_hctx_fn *exit_hctx ;
   init_request_fn *init_request ;
   exit_request_fn *exit_request ;
};
#line 190 "include/scsi/scsi_proto.h"
struct scsi_lun {
   __u8 scsi_lun[8U] ;
};
#line 32 "include/scsi/scsi_common.h"
struct scsi_sense_hdr {
   u8 response_code ;
   u8 sense_key ;
   u8 asc ;
   u8 ascq ;
   u8 byte4 ;
   u8 byte5 ;
   u8 byte6 ;
   u8 additional_length ;
};
#line 62
struct scsi_cmnd;
#line 308 "include/scsi/scsi.h"
struct scsi_device;
#line 309
struct scsi_host_cmd_pool;
#line 310
struct scsi_target;
#line 311
struct Scsi_Host;
#line 312
struct scsi_transport_template;
#line 314 "include/scsi/scsi.h"
struct scsi_host_template {
   struct module *module ;
   char const   *name ;
   int (*detect)(struct scsi_host_template * ) ;
   int (*release)(struct Scsi_Host * ) ;
   char const   *(*info)(struct Scsi_Host * ) ;
   int (*ioctl)(struct scsi_device * , int  , void * ) ;
   int (*compat_ioctl)(struct scsi_device * , int  , void * ) ;
   int (*queuecommand)(struct Scsi_Host * , struct scsi_cmnd * ) ;
   int (*eh_abort_handler)(struct scsi_cmnd * ) ;
   int (*eh_device_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_target_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_bus_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_host_reset_handler)(struct scsi_cmnd * ) ;
   int (*slave_alloc)(struct scsi_device * ) ;
   int (*slave_configure)(struct scsi_device * ) ;
   void (*slave_destroy)(struct scsi_device * ) ;
   int (*target_alloc)(struct scsi_target * ) ;
   void (*target_destroy)(struct scsi_target * ) ;
   int (*scan_finished)(struct Scsi_Host * , unsigned long  ) ;
   void (*scan_start)(struct Scsi_Host * ) ;
   int (*change_queue_depth)(struct scsi_device * , int  ) ;
   int (*bios_param)(struct scsi_device * , struct block_device * , sector_t  , int * ) ;
   void (*unlock_native_capacity)(struct scsi_device * ) ;
   int (*show_info)(struct seq_file * , struct Scsi_Host * ) ;
   int (*write_info)(struct Scsi_Host * , char * , int  ) ;
   enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd * ) ;
   int (*host_reset)(struct Scsi_Host * , int  ) ;
   char const   *proc_name ;
   struct proc_dir_entry *proc_dir ;
   int can_queue ;
   int this_id ;
   unsigned short sg_tablesize ;
   unsigned short sg_prot_tablesize ;
   unsigned int max_sectors ;
   unsigned long dma_boundary ;
   short cmd_per_lun ;
   unsigned char present ;
   int tag_alloc_policy ;
   unsigned char use_blk_tags : 1 ;
   unsigned char track_queue_depth : 1 ;
   unsigned char supported_mode : 2 ;
   unsigned char unchecked_isa_dma : 1 ;
   unsigned char use_clustering : 1 ;
   unsigned char emulated : 1 ;
   unsigned char skip_settle_delay : 1 ;
   unsigned char no_write_same : 1 ;
   unsigned char no_async_abort : 1 ;
   unsigned int max_host_blocked ;
   struct device_attribute **shost_attrs ;
   struct device_attribute **sdev_attrs ;
   struct list_head legacy_hosts ;
   u64 vendor_id ;
   unsigned int cmd_size ;
   struct scsi_host_cmd_pool *cmd_pool ;
   bool disable_blk_mq ;
};
#line 507 "include/scsi/scsi_host.h"
enum scsi_host_state {
    SHOST_CREATED = 1,
    SHOST_RUNNING = 2,
    SHOST_CANCEL = 3,
    SHOST_DEL = 4,
    SHOST_RECOVERY = 5,
    SHOST_CANCEL_RECOVERY = 6,
    SHOST_DEL_RECOVERY = 7
} ;
#line 517 "include/scsi/scsi_host.h"
union __anonunion____missing_field_name_272 {
   struct blk_queue_tag *bqt ;
   struct blk_mq_tag_set tag_set ;
};
#line 517 "include/scsi/scsi_host.h"
struct Scsi_Host {
   struct list_head __devices ;
   struct list_head __targets ;
   struct scsi_host_cmd_pool *cmd_pool ;
   spinlock_t free_list_lock ;
   struct list_head free_list ;
   struct list_head starved_list ;
   spinlock_t default_lock ;
   spinlock_t *host_lock ;
   struct mutex scan_mutex ;
   struct list_head eh_cmd_q ;
   struct task_struct *ehandler ;
   struct completion *eh_action ;
   wait_queue_head_t host_wait ;
   struct scsi_host_template *hostt ;
   struct scsi_transport_template *transportt ;
   union __anonunion____missing_field_name_272 __annonCompField85 ;
   atomic_t host_busy ;
   atomic_t host_blocked ;
   unsigned int host_failed ;
   unsigned int host_eh_scheduled ;
   unsigned int host_no ;
   int eh_deadline ;
   unsigned long last_reset ;
   unsigned int max_channel ;
   unsigned int max_id ;
   u64 max_lun ;
   unsigned int unique_id ;
   unsigned short max_cmd_len ;
   int this_id ;
   int can_queue ;
   short cmd_per_lun ;
   unsigned short sg_tablesize ;
   unsigned short sg_prot_tablesize ;
   unsigned int max_sectors ;
   unsigned long dma_boundary ;
   unsigned int nr_hw_queues ;
   unsigned long cmd_serial_number ;
   unsigned char active_mode : 2 ;
   unsigned char unchecked_isa_dma : 1 ;
   unsigned char use_clustering : 1 ;
   unsigned char host_self_blocked : 1 ;
   unsigned char reverse_ordering : 1 ;
   unsigned char tmf_in_progress : 1 ;
   unsigned char async_scan : 1 ;
   unsigned char eh_noresume : 1 ;
   unsigned char no_write_same : 1 ;
   unsigned char use_blk_mq : 1 ;
   unsigned char use_cmd_list : 1 ;
   char work_q_name[20U] ;
   struct workqueue_struct *work_q ;
   struct workqueue_struct *tmf_work_q ;
   unsigned char no_scsi2_lun_in_cdb : 1 ;
   unsigned int max_host_blocked ;
   unsigned int prot_capabilities ;
   unsigned char prot_guard_type ;
   struct request_queue *uspace_req_q ;
   unsigned long base ;
   unsigned long io_port ;
   unsigned char n_io_port ;
   unsigned char dma_channel ;
   unsigned int irq ;
   enum scsi_host_state shost_state ;
   struct device shost_gendev ;
   struct device shost_dev ;
   struct list_head sht_legacy_list ;
   void *shost_data ;
   struct device *dma_dev ;
   unsigned long hostdata[0U] ;
};
#line 25 "include/scsi/scsi_device.h"
enum scsi_device_state {
    SDEV_CREATED = 1,
    SDEV_RUNNING = 2,
    SDEV_CANCEL = 3,
    SDEV_DEL = 4,
    SDEV_QUIESCE = 5,
    SDEV_OFFLINE = 6,
    SDEV_TRANSPORT_OFFLINE = 7,
    SDEV_BLOCK = 8,
    SDEV_CREATED_BLOCK = 9
} ;
#line 71
struct scsi_dh_data;
#line 71 "include/scsi/scsi_device.h"
struct scsi_device {
   struct Scsi_Host *host ;
   struct request_queue *request_queue ;
   struct list_head siblings ;
   struct list_head same_target_siblings ;
   atomic_t device_busy ;
   atomic_t device_blocked ;
   spinlock_t list_lock ;
   struct list_head cmd_list ;
   struct list_head starved_entry ;
   struct scsi_cmnd *current_cmnd ;
   unsigned short queue_depth ;
   unsigned short max_queue_depth ;
   unsigned short last_queue_full_depth ;
   unsigned short last_queue_full_count ;
   unsigned long last_queue_full_time ;
   unsigned long queue_ramp_up_period ;
   unsigned long last_queue_ramp_up ;
   unsigned int id ;
   unsigned int channel ;
   u64 lun ;
   unsigned int manufacturer ;
   unsigned int sector_size ;
   void *hostdata ;
   char type ;
   char scsi_level ;
   char inq_periph_qual ;
   unsigned char inquiry_len ;
   unsigned char *inquiry ;
   char const   *vendor ;
   char const   *model ;
   char const   *rev ;
   int vpd_pg83_len ;
   unsigned char *vpd_pg83 ;
   int vpd_pg80_len ;
   unsigned char *vpd_pg80 ;
   unsigned char current_tag ;
   struct scsi_target *sdev_target ;
   unsigned int sdev_bflags ;
   unsigned int eh_timeout ;
   unsigned char removable : 1 ;
   unsigned char changed : 1 ;
   unsigned char busy : 1 ;
   unsigned char lockable : 1 ;
   unsigned char locked : 1 ;
   unsigned char borken : 1 ;
   unsigned char disconnect : 1 ;
   unsigned char soft_reset : 1 ;
   unsigned char sdtr : 1 ;
   unsigned char wdtr : 1 ;
   unsigned char ppr : 1 ;
   unsigned char tagged_supported : 1 ;
   unsigned char simple_tags : 1 ;
   unsigned char was_reset : 1 ;
   unsigned char expecting_cc_ua : 1 ;
   unsigned char use_10_for_rw : 1 ;
   unsigned char use_10_for_ms : 1 ;
   unsigned char no_report_opcodes : 1 ;
   unsigned char no_write_same : 1 ;
   unsigned char use_16_for_rw : 1 ;
   unsigned char skip_ms_page_8 : 1 ;
   unsigned char skip_ms_page_3f : 1 ;
   unsigned char skip_vpd_pages : 1 ;
   unsigned char try_vpd_pages : 1 ;
   unsigned char use_192_bytes_for_3f : 1 ;
   unsigned char no_start_on_add : 1 ;
   unsigned char allow_restart : 1 ;
   unsigned char manage_start_stop : 1 ;
   unsigned char start_stop_pwr_cond : 1 ;
   unsigned char no_uld_attach : 1 ;
   unsigned char select_no_atn : 1 ;
   unsigned char fix_capacity : 1 ;
   unsigned char guess_capacity : 1 ;
   unsigned char retry_hwerror : 1 ;
   unsigned char last_sector_bug : 1 ;
   unsigned char no_read_disc_info : 1 ;
   unsigned char no_read_capacity_16 : 1 ;
   unsigned char try_rc_10_first : 1 ;
   unsigned char is_visible : 1 ;
   unsigned char wce_default_on : 1 ;
   unsigned char no_dif : 1 ;
   unsigned char broken_fua : 1 ;
   unsigned char lun_in_cdb : 1 ;
   atomic_t disk_events_disable_depth ;
   unsigned long supported_events[1U] ;
   unsigned long pending_events[1U] ;
   struct list_head event_list ;
   struct work_struct event_work ;
   unsigned int max_device_blocked ;
   atomic_t iorequest_cnt ;
   atomic_t iodone_cnt ;
   atomic_t ioerr_cnt ;
   struct device sdev_gendev ;
   struct device sdev_dev ;
   struct execute_work ew ;
   struct work_struct requeue_work ;
   struct scsi_dh_data *scsi_dh_data ;
   enum scsi_device_state sdev_state ;
   unsigned long sdev_data[0U] ;
};
#line 204 "include/scsi/scsi_device.h"
struct scsi_device_handler {
   struct list_head list ;
   struct module *module ;
   char const   *name ;
   int (*check_sense)(struct scsi_device * , struct scsi_sense_hdr * ) ;
   struct scsi_dh_data *(*attach)(struct scsi_device * ) ;
   void (*detach)(struct scsi_device * ) ;
   int (*activate)(struct scsi_device * , void (*)(void * , int  ) , void * ) ;
   int (*prep_fn)(struct scsi_device * , struct request * ) ;
   int (*set_params)(struct scsi_device * , char const   * ) ;
   bool (*match)(struct scsi_device * ) ;
};
#line 219 "include/scsi/scsi_device.h"
struct scsi_dh_data {
   struct scsi_device_handler *scsi_dh ;
   struct scsi_device *sdev ;
   struct kref kref ;
};
#line 249
enum scsi_target_state {
    STARGET_CREATED = 1,
    STARGET_RUNNING = 2,
    STARGET_DEL = 3
} ;
#line 255 "include/scsi/scsi_device.h"
struct scsi_target {
   struct scsi_device *starget_sdev_user ;
   struct list_head siblings ;
   struct list_head devices ;
   struct device dev ;
   struct kref reap_ref ;
   unsigned int channel ;
   unsigned int id ;
   unsigned char create : 1 ;
   unsigned char single_lun : 1 ;
   unsigned char pdt_1f_for_no_lun : 1 ;
   unsigned char no_report_luns : 1 ;
   unsigned char expecting_lun_change : 1 ;
   atomic_t target_busy ;
   atomic_t target_blocked ;
   unsigned int can_queue ;
   unsigned int max_target_blocked ;
   char scsi_level ;
   enum scsi_target_state state ;
   void *hostdata ;
   unsigned long starget_data[0U] ;
};
#line 532 "include/scsi/scsi_device.h"
struct scsi_transport_template {
   struct transport_container host_attrs ;
   struct transport_container target_attrs ;
   struct transport_container device_attrs ;
   int (*user_scan)(struct Scsi_Host * , uint  , uint  , u64  ) ;
   int device_size ;
   int device_private_offset ;
   int target_size ;
   int target_private_offset ;
   int host_size ;
   unsigned char create_work_queue : 1 ;
   void (*eh_strategy_handler)(struct Scsi_Host * ) ;
   enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd * ) ;
   int (*it_nexus_response)(struct Scsi_Host * , u64  , int  ) ;
   int (*tsk_mgmt_response)(struct Scsi_Host * , u64  , u64  , int  ) ;
};
#line 161 "./arch/x86/include/asm/checksum_64.h"
struct in6_addr;
#line 140 "include/net/checksum.h"
struct sk_buff;
#line 187 "include/net/checksum.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 66 "include/linux/netdev_features.h"
union __anonunion_in6_u_275 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};
#line 66 "include/linux/netdev_features.h"
struct in6_addr {
   union __anonunion_in6_u_275 in6_u ;
};
#line 218 "include/net/flow_dissector.h"
struct pipe_buf_operations;
#line 218 "include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations  const  *ops ;
   unsigned int flags ;
   unsigned long private ;
};
#line 27 "include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};
#line 61 "include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*release)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   int (*steal)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*get)(struct pipe_inode_info * , struct pipe_buffer * ) ;
};
#line 87 "include/linux/splice.h"
struct nf_conntrack {
   atomic_t use ;
};
#line 172 "include/linux/skbuff.h"
union __anonunion____missing_field_name_280 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};
#line 172 "include/linux/skbuff.h"
union __anonunion____missing_field_name_281 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};
#line 172 "include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   unsigned char orig_proto ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion____missing_field_name_280 __annonCompField89 ;
   union __anonunion____missing_field_name_281 __annonCompField90 ;
};
#line 403 "include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 404 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_284 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};
#line 404 "include/linux/skbuff.h"
union __anonunion____missing_field_name_283 {
   u64 v64 ;
   struct __anonstruct____missing_field_name_284 __annonCompField91 ;
};
#line 404 "include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion____missing_field_name_283 __annonCompField92 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_287 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};
#line 457 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_286 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion____missing_field_name_287 __annonCompField93 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_285 {
   struct __anonstruct____missing_field_name_286 __annonCompField94 ;
   struct rb_node rbnode ;
};
#line 457
struct sec_path;
#line 457 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_289 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_288 {
   __wsum csum ;
   struct __anonstruct____missing_field_name_289 __annonCompField96 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_290 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_291 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_292 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};
#line 457 "include/linux/skbuff.h"
struct sk_buff {
   union __anonunion____missing_field_name_285 __annonCompField95 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff * ) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   unsigned char cloned : 1 ;
   unsigned char nohdr : 1 ;
   unsigned char fclone : 2 ;
   unsigned char peeked : 1 ;
   unsigned char head_frag : 1 ;
   unsigned char xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   unsigned char pkt_type : 3 ;
   unsigned char pfmemalloc : 1 ;
   unsigned char ignore_df : 1 ;
   unsigned char nfctinfo : 3 ;
   unsigned char nf_trace : 1 ;
   unsigned char ip_summed : 2 ;
   unsigned char ooo_okay : 1 ;
   unsigned char l4_hash : 1 ;
   unsigned char sw_hash : 1 ;
   unsigned char wifi_acked_valid : 1 ;
   unsigned char wifi_acked : 1 ;
   unsigned char no_fcs : 1 ;
   unsigned char encapsulation : 1 ;
   unsigned char encap_hdr_csum : 1 ;
   unsigned char csum_valid : 1 ;
   unsigned char csum_complete_sw : 1 ;
   unsigned char csum_level : 2 ;
   unsigned char csum_bad : 1 ;
   unsigned char ndisc_nodetype : 2 ;
   unsigned char ipvs_property : 1 ;
   unsigned char inner_protocol_type : 1 ;
   unsigned char remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion____missing_field_name_288 __annonCompField97 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion____missing_field_name_290 __annonCompField98 ;
   __u32 secmark ;
   union __anonunion____missing_field_name_291 __annonCompField99 ;
   union __anonunion____missing_field_name_292 __annonCompField100 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 1628 "include/linux/security.h"
struct mnt_namespace;
#line 1629
struct ipc_namespace;
#line 1630 "include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
#line 96 "./include/uapi/scsi/scsi_netlink.h"
enum fc_port_type {
    FC_PORTTYPE_UNKNOWN = 0,
    FC_PORTTYPE_OTHER = 1,
    FC_PORTTYPE_NOTPRESENT = 2,
    FC_PORTTYPE_NPORT = 3,
    FC_PORTTYPE_NLPORT = 4,
    FC_PORTTYPE_LPORT = 5,
    FC_PORTTYPE_PTP = 6,
    FC_PORTTYPE_NPIV = 7
} ;
#line 107
enum fc_port_state {
    FC_PORTSTATE_UNKNOWN = 0,
    FC_PORTSTATE_NOTPRESENT = 1,
    FC_PORTSTATE_ONLINE = 2,
    FC_PORTSTATE_OFFLINE = 3,
    FC_PORTSTATE_BLOCKED = 4,
    FC_PORTSTATE_BYPASSED = 5,
    FC_PORTSTATE_DIAGNOSTICS = 6,
    FC_PORTSTATE_LINKDOWN = 7,
    FC_PORTSTATE_ERROR = 8,
    FC_PORTSTATE_LOOPBACK = 9,
    FC_PORTSTATE_DELETED = 10
} ;
#line 121
enum fc_vport_state {
    FC_VPORT_UNKNOWN = 0,
    FC_VPORT_ACTIVE = 1,
    FC_VPORT_DISABLED = 2,
    FC_VPORT_LINKDOWN = 3,
    FC_VPORT_INITIALIZING = 4,
    FC_VPORT_NO_FABRIC_SUPP = 5,
    FC_VPORT_NO_FABRIC_RSCS = 6,
    FC_VPORT_FABRIC_LOGOUT = 7,
    FC_VPORT_FABRIC_REJ_WWN = 8,
    FC_VPORT_FAILED = 9
} ;
#line 195 "include/scsi/scsi_transport_fc.h"
struct fc_vport {
   enum fc_vport_state vport_state ;
   enum fc_vport_state vport_last_state ;
   u64 node_name ;
   u64 port_name ;
   u32 roles ;
   u32 vport_id ;
   enum fc_port_type vport_type ;
   char symbolic_name[64U] ;
   void *dd_data ;
   struct Scsi_Host *shost ;
   unsigned int channel ;
   u32 number ;
   u8 flags ;
   struct list_head peers ;
   struct device dev ;
   struct work_struct vport_delete_work ;
};
#line 252 "include/scsi/scsi_transport_fc.h"
struct fc_rport_identifiers {
   u64 node_name ;
   u64 port_name ;
   u32 port_id ;
   u32 roles ;
};
#line 294 "include/scsi/scsi_transport_fc.h"
struct fc_rport {
   u32 maxframe_size ;
   u32 supported_classes ;
   u32 dev_loss_tmo ;
   u64 node_name ;
   u64 port_name ;
   u32 port_id ;
   u32 roles ;
   enum fc_port_state port_state ;
   u32 scsi_target_id ;
   u32 fast_io_fail_tmo ;
   void *dd_data ;
   unsigned int channel ;
   u32 number ;
   u8 flags ;
   struct list_head peers ;
   struct device dev ;
   struct delayed_work dev_loss_work ;
   struct work_struct scan_work ;
   struct delayed_work fail_io_work ;
   struct work_struct stgt_delete_work ;
   struct work_struct rport_delete_work ;
   struct request_queue *rqst_q ;
};
#line 394 "include/scsi/scsi_transport_fc.h"
struct fc_host_statistics {
   u64 seconds_since_last_reset ;
   u64 tx_frames ;
   u64 tx_words ;
   u64 rx_frames ;
   u64 rx_words ;
   u64 lip_count ;
   u64 nos_count ;
   u64 error_frames ;
   u64 dumped_frames ;
   u64 link_failure_count ;
   u64 loss_of_sync_count ;
   u64 loss_of_signal_count ;
   u64 prim_seq_protocol_err_count ;
   u64 invalid_tx_word_count ;
   u64 invalid_crc_count ;
   u64 fcp_input_requests ;
   u64 fcp_output_requests ;
   u64 fcp_control_requests ;
   u64 fcp_input_megabytes ;
   u64 fcp_output_megabytes ;
   u64 fcp_packet_alloc_failures ;
   u64 fcp_packet_aborts ;
   u64 fcp_frame_alloc_failures ;
   u64 fc_no_free_exch ;
   u64 fc_no_free_exch_xid ;
   u64 fc_xid_not_found ;
   u64 fc_xid_busy ;
   u64 fc_seq_not_found ;
   u64 fc_non_bls_resp ;
};
#line 317 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fcp_cmnd {
   struct scsi_lun fc_lun ;
   __u8 fc_cmdref ;
   __u8 fc_pri_ta ;
   __u8 fc_tm_flags ;
   __u8 fc_flags ;
   __u8 fc_cdb[16U] ;
   __be32 fc_dl ;
};
#line 87 "./include/uapi/scsi/fc/fc_ns.h"
struct fc_ns_fts {
   __be32 ff_type_map[8U] ;
};
#line 129 "./include/uapi/scsi/fc/fc_ns.h"
struct fc_gpn_ft_resp {
   __u8 fp_flags ;
   __u8 fp_fid[3U] ;
   __be32 fp_resvd ;
   __be64 fp_wwpn ;
};
#line 212 "include/scsi/fc/fc_ms.h"
enum fc_els_cmd {
    ELS_LS_RJT = 1,
    ELS_LS_ACC = 2,
    ELS_PLOGI = 3,
    ELS_FLOGI = 4,
    ELS_LOGO = 5,
    ELS_ABTX = 6,
    ELS_RCS = 7,
    ELS_RES = 8,
    ELS_RSS = 9,
    ELS_RSI = 10,
    ELS_ESTS = 11,
    ELS_ESTC = 12,
    ELS_ADVC = 13,
    ELS_RTV = 14,
    ELS_RLS = 15,
    ELS_ECHO = 16,
    ELS_TEST = 17,
    ELS_RRQ = 18,
    ELS_REC = 19,
    ELS_SRR = 20,
    ELS_PRLI = 32,
    ELS_PRLO = 33,
    ELS_SCN = 34,
    ELS_TPLS = 35,
    ELS_TPRLO = 36,
    ELS_LCLM = 37,
    ELS_GAID = 48,
    ELS_FACT = 49,
    ELS_FDACDT = 50,
    ELS_NACT = 51,
    ELS_NDACT = 52,
    ELS_QOSR = 64,
    ELS_RVCS = 65,
    ELS_PDISC = 80,
    ELS_FDISC = 81,
    ELS_ADISC = 82,
    ELS_RNC = 83,
    ELS_FARP_REQ = 84,
    ELS_FARP_REPL = 85,
    ELS_RPS = 86,
    ELS_RPL = 87,
    ELS_RPBC = 88,
    ELS_FAN = 96,
    ELS_RSCN = 97,
    ELS_SCR = 98,
    ELS_RNFT = 99,
    ELS_CSR = 104,
    ELS_CSU = 105,
    ELS_LINIT = 112,
    ELS_LSTS = 114,
    ELS_RNID = 120,
    ELS_RLIR = 121,
    ELS_LIRR = 122,
    ELS_SRL = 123,
    ELS_SBRP = 124,
    ELS_RPSC = 125,
    ELS_QSA = 126,
    ELS_EVFP = 127,
    ELS_LKA = 128,
    ELS_AUTH_ELS = 144
} ;
#line 181 "./include/uapi/scsi/fc/fc_els.h"
enum fc_els_rjt_reason {
    ELS_RJT_NONE = 0,
    ELS_RJT_INVAL = 1,
    ELS_RJT_LOGIC = 3,
    ELS_RJT_BUSY = 5,
    ELS_RJT_PROT = 7,
    ELS_RJT_UNAB = 9,
    ELS_RJT_UNSUP = 11,
    ELS_RJT_INPROG = 14,
    ELS_RJT_FIP = 32,
    ELS_RJT_VENDOR = 255
} ;
#line 194
enum fc_els_rjt_explan {
    ELS_EXPL_NONE = 0,
    ELS_EXPL_SPP_OPT_ERR = 1,
    ELS_EXPL_SPP_ICTL_ERR = 3,
    ELS_EXPL_AH = 17,
    ELS_EXPL_AH_REQ = 19,
    ELS_EXPL_SID = 21,
    ELS_EXPL_OXID_RXID = 23,
    ELS_EXPL_INPROG = 25,
    ELS_EXPL_PLOGI_REQD = 30,
    ELS_EXPL_INSUF_RES = 41,
    ELS_EXPL_UNAB_DATA = 42,
    ELS_EXPL_UNSUPR = 44,
    ELS_EXPL_INV_LEN = 45,
    ELS_EXPL_NOT_NEIGHBOR = 98
} ;
#line 323 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_spp {
   __u8 spp_type ;
   __u8 spp_type_ext ;
   __u8 spp_flags ;
   __u8 _spp_resvd ;
   __be32 spp_orig_pa ;
   __be32 spp_resp_pa ;
   __be32 spp_params ;
};
#line 555 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_rnid_gen {
   __u8 rnid_vend_id[16U] ;
   __be32 rnid_atype ;
   __be32 rnid_phys_port ;
   __be32 rnid_att_nodes ;
   __u8 rnid_node_mgmt ;
   __u8 rnid_ip_ver ;
   __be16 rnid_prot_port ;
   __be32 rnid_ip_addr[4U] ;
   __u8 rnid_resvd[2U] ;
   __be16 rnid_vend_spec ;
};
#line 647 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_lesb {
   __be32 lesb_link_fail ;
   __be32 lesb_sync_loss ;
   __be32 lesb_sig_loss ;
   __be32 lesb_prim_err ;
   __be32 lesb_inv_word ;
   __be32 lesb_inv_crc ;
};
#line 81 "./include/uapi/scsi/fc/fc_gs.h"
struct scsi_data_buffer {
   struct sg_table table ;
   unsigned int length ;
   int resid ;
};
#line 39 "include/scsi/scsi_cmnd.h"
struct scsi_pointer {
   char *ptr ;
   int this_residual ;
   struct scatterlist *buffer ;
   int buffers_residual ;
   dma_addr_t dma_handle ;
   int volatile   Status ;
   int volatile   Message ;
   int volatile   have_data_in ;
   int volatile   sent_command ;
   int volatile   phase ;
};
#line 55 "include/scsi/scsi_cmnd.h"
struct scsi_cmnd {
   struct scsi_device *device ;
   struct list_head list ;
   struct list_head eh_entry ;
   struct delayed_work abort_work ;
   int eh_eflags ;
   unsigned long serial_number ;
   unsigned long jiffies_at_alloc ;
   int retries ;
   int allowed ;
   unsigned char prot_op ;
   unsigned char prot_type ;
   unsigned char prot_flags ;
   unsigned short cmd_len ;
   enum dma_data_direction sc_data_direction ;
   unsigned char *cmnd ;
   struct scsi_data_buffer sdb ;
   struct scsi_data_buffer *prot_sdb ;
   unsigned int underflow ;
   unsigned int transfersize ;
   struct request *request ;
   unsigned char *sense_buffer ;
   void (*scsi_done)(struct scsi_cmnd * ) ;
   struct scsi_pointer SCp ;
   unsigned char *host_scribble ;
   int result ;
   int flags ;
   unsigned char tag ;
};
#line 351 "include/scsi/scsi_cmnd.h"
struct fc_frame_header {
   __u8 fh_r_ctl ;
   __u8 fh_d_id[3U] ;
   __u8 fh_cs_ctl ;
   __u8 fh_s_id[3U] ;
   __u8 fh_type ;
   __u8 fh_f_ctl[3U] ;
   __u8 fh_seq_id ;
   __u8 fh_df_ctl ;
   __be16 fh_seq_cnt ;
   __be16 fh_ox_id ;
   __be16 fh_rx_id ;
   __be32 fh_parm_offset ;
};
#line 51 "./include/uapi/scsi/fc/fc_fs.h"
enum fc_rctl {
    FC_RCTL_DD_UNCAT = 0,
    FC_RCTL_DD_SOL_DATA = 1,
    FC_RCTL_DD_UNSOL_CTL = 2,
    FC_RCTL_DD_SOL_CTL = 3,
    FC_RCTL_DD_UNSOL_DATA = 4,
    FC_RCTL_DD_DATA_DESC = 5,
    FC_RCTL_DD_UNSOL_CMD = 6,
    FC_RCTL_DD_CMD_STATUS = 7,
    FC_RCTL_ELS_REQ = 34,
    FC_RCTL_ELS_REP = 35,
    FC_RCTL_ELS4_REQ = 50,
    FC_RCTL_ELS4_REP = 51,
    FC_RCTL_VFTH = 80,
    FC_RCTL_IFRH = 81,
    FC_RCTL_ENCH = 82,
    FC_RCTL_BA_NOP = 128,
    FC_RCTL_BA_ABTS = 129,
    FC_RCTL_BA_RMC = 130,
    FC_RCTL_BA_ACC = 132,
    FC_RCTL_BA_RJT = 133,
    FC_RCTL_BA_PRMT = 134,
    FC_RCTL_ACK_1 = 192,
    FC_RCTL_ACK_0 = 193,
    FC_RCTL_P_RJT = 194,
    FC_RCTL_F_RJT = 195,
    FC_RCTL_P_BSY = 196,
    FC_RCTL_F_BSY = 197,
    FC_RCTL_F_BSYL = 198,
    FC_RCTL_LCR = 199,
    FC_RCTL_END = 201
} ;
#line 99
enum fc_fh_type {
    FC_TYPE_BLS = 0,
    FC_TYPE_ELS = 1,
    FC_TYPE_IP = 5,
    FC_TYPE_FCP = 8,
    FC_TYPE_CT = 32,
    FC_TYPE_ILS = 34
} ;
#line 49 "include/scsi/fc_frame.h"
struct fc_frame {
   struct sk_buff skb ;
};
#line 79
struct fc_lport;
#line 79
struct fc_seq;
#line 79
struct fc_fcp_pkt;
#line 79 "include/scsi/fc_frame.h"
struct fcoe_rcv_info {
   struct fc_lport *fr_dev ;
   struct fc_seq *fr_seq ;
   struct fc_fcp_pkt *fr_fsp ;
   u32 fr_crc ;
   u16 fr_max_payload ;
   u8 fr_sof ;
   u8 fr_eof ;
   u8 fr_flags ;
   u8 fr_encaps ;
   u8 granted_mac[6U] ;
};
#line 260
enum fc_lport_state {
    LPORT_ST_DISABLED = 0,
    LPORT_ST_FLOGI = 1,
    LPORT_ST_DNS = 2,
    LPORT_ST_RNN_ID = 3,
    LPORT_ST_RSNN_NN = 4,
    LPORT_ST_RSPN_ID = 5,
    LPORT_ST_RFT_ID = 6,
    LPORT_ST_RFF_ID = 7,
    LPORT_ST_FDMI = 8,
    LPORT_ST_RHBA = 9,
    LPORT_ST_RPA = 10,
    LPORT_ST_DHBA = 11,
    LPORT_ST_DPRT = 12,
    LPORT_ST_SCR = 13,
    LPORT_ST_READY = 14,
    LPORT_ST_LOGO = 15,
    LPORT_ST_RESET = 16
} ;
#line 280
enum fc_disc_event {
    DISC_EV_NONE = 0,
    DISC_EV_SUCCESS = 1,
    DISC_EV_FAILED = 2
} ;
#line 286
enum fc_rport_state {
    RPORT_ST_INIT = 0,
    RPORT_ST_FLOGI = 1,
    RPORT_ST_PLOGI_WAIT = 2,
    RPORT_ST_PLOGI = 3,
    RPORT_ST_PRLI = 4,
    RPORT_ST_RTV = 5,
    RPORT_ST_READY = 6,
    RPORT_ST_ADISC = 7,
    RPORT_ST_DELETE = 8
} ;
#line 126 "include/scsi/libfc.h"
enum fc_rport_event {
    RPORT_EV_NONE = 0,
    RPORT_EV_READY = 1,
    RPORT_EV_FAILED = 2,
    RPORT_EV_STOP = 3,
    RPORT_EV_LOGO = 4
} ;
#line 134
struct fc_rport_priv;
#line 135 "include/scsi/libfc.h"
struct fc_rport_operations {
   void (*event_callback)(struct fc_lport * , struct fc_rport_priv * , enum fc_rport_event  ) ;
};
#line 173 "include/scsi/libfc.h"
struct fc_rport_priv {
   struct fc_lport *local_port ;
   struct fc_rport *rport ;
   struct kref kref ;
   enum fc_rport_state rp_state ;
   struct fc_rport_identifiers ids ;
   u16 flags ;
   u16 max_seq ;
   u16 disc_id ;
   u16 maxframe_size ;
   unsigned int retries ;
   unsigned int major_retries ;
   unsigned int e_d_tov ;
   unsigned int r_a_tov ;
   struct mutex rp_mutex ;
   struct delayed_work retry_work ;
   enum fc_rport_event event ;
   struct fc_rport_operations *ops ;
   struct list_head peers ;
   struct work_struct event_work ;
   u32 supported_classes ;
   u16 prli_count ;
   struct callback_head rcu ;
   u16 sp_features ;
   u8 spp_type ;
   void (*lld_event_callback)(struct fc_lport * , struct fc_rport_priv * , enum fc_rport_event  ) ;
};
#line 223 "include/scsi/libfc.h"
struct fc_stats {
   u64 SecondsSinceLastReset ;
   u64 TxFrames ;
   u64 TxWords ;
   u64 RxFrames ;
   u64 RxWords ;
   u64 ErrorFrames ;
   u64 DumpedFrames ;
   u64 FcpPktAllocFails ;
   u64 FcpPktAborts ;
   u64 FcpFrameAllocFails ;
   u64 LinkFailureCount ;
   u64 LossOfSignalCount ;
   u64 InvalidTxWordCount ;
   u64 InvalidCRCCount ;
   u64 InputRequests ;
   u64 OutputRequests ;
   u64 ControlRequests ;
   u64 InputBytes ;
   u64 OutputBytes ;
   u64 VLinkFailureCount ;
   u64 MissDiscAdvCount ;
};
#line 273 "include/scsi/libfc.h"
struct fc_seq_els_data {
   enum fc_els_rjt_reason reason ;
   enum fc_els_rjt_explan explan ;
};
#line 285 "include/scsi/libfc.h"
struct fc_fcp_pkt {
   spinlock_t scsi_pkt_lock ;
   atomic_t ref_cnt ;
   u32 data_len ;
   struct scsi_cmnd *cmd ;
   struct list_head list ;
   struct fc_lport *lp ;
   u8 state ;
   u8 cdb_status ;
   u8 status_code ;
   u8 scsi_comp_flags ;
   u32 io_status ;
   u32 req_flags ;
   u32 scsi_resid ;
   size_t xfer_len ;
   struct fcp_cmnd cdb_cmd ;
   u32 xfer_contig_end ;
   u16 max_payload ;
   u16 xfer_ddp ;
   struct fc_rport *rport ;
   struct fc_seq *seq_ptr ;
   struct timer_list timer ;
   int wait_for_comp ;
   u32 recov_retry ;
   struct fc_seq *recov_seq ;
   struct completion tm_done ;
};
#line 371 "include/scsi/libfc.h"
struct fc_seq {
   u8 id ;
   u16 ssb_stat ;
   u16 cnt ;
   u32 rec_data ;
};
#line 458 "include/scsi/libfc.h"
struct libfc_function_template {
   int (*frame_send)(struct fc_lport * , struct fc_frame * ) ;
   struct fc_seq *(*elsct_send)(struct fc_lport * , u32  , struct fc_frame * , unsigned int  ,
                                void (*)(struct fc_seq * , struct fc_frame * , void * ) ,
                                void * , u32  ) ;
   struct fc_seq *(*exch_seq_send)(struct fc_lport * , struct fc_frame * , void (*)(struct fc_seq * ,
                                                                                    struct fc_frame * ,
                                                                                    void * ) ,
                                   void (*)(struct fc_seq * , void * ) , void * ,
                                   unsigned int  ) ;
   int (*ddp_setup)(struct fc_lport * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ddp_done)(struct fc_lport * , u16  ) ;
   int (*ddp_target)(struct fc_lport * , u16  , struct scatterlist * , unsigned int  ) ;
   void (*get_lesb)(struct fc_lport * , struct fc_els_lesb * ) ;
   int (*seq_send)(struct fc_lport * , struct fc_seq * , struct fc_frame * ) ;
   void (*seq_els_rsp_send)(struct fc_frame * , enum fc_els_cmd  , struct fc_seq_els_data * ) ;
   int (*seq_exch_abort)(struct fc_seq  const  * , unsigned int  ) ;
   void (*exch_done)(struct fc_seq * ) ;
   struct fc_seq *(*seq_start_next)(struct fc_seq * ) ;
   void (*seq_set_resp)(struct fc_seq * , void (*)(struct fc_seq * , struct fc_frame * ,
                                                   void * ) , void * ) ;
   struct fc_seq *(*seq_assign)(struct fc_lport * , struct fc_frame * ) ;
   void (*seq_release)(struct fc_seq * ) ;
   void (*exch_mgr_reset)(struct fc_lport * , u32  , u32  ) ;
   void (*rport_flush_queue)(void) ;
   void (*lport_recv)(struct fc_lport * , struct fc_frame * ) ;
   int (*lport_reset)(struct fc_lport * ) ;
   void (*lport_set_port_id)(struct fc_lport * , u32  , struct fc_frame * ) ;
   struct fc_rport_priv *(*rport_create)(struct fc_lport * , u32  ) ;
   int (*rport_login)(struct fc_rport_priv * ) ;
   int (*rport_logoff)(struct fc_rport_priv * ) ;
   void (*rport_recv_req)(struct fc_lport * , struct fc_frame * ) ;
   struct fc_rport_priv *(*rport_lookup)(struct fc_lport  const  * , u32  ) ;
   void (*rport_destroy)(struct kref * ) ;
   void (*rport_event_callback)(struct fc_lport * , struct fc_rport_priv * , enum fc_rport_event  ) ;
   int (*fcp_cmd_send)(struct fc_lport * , struct fc_fcp_pkt * , void (*)(struct fc_seq * ,
                                                                          struct fc_frame * ,
                                                                          void * ) ) ;
   void (*fcp_cleanup)(struct fc_lport * ) ;
   void (*fcp_abort_io)(struct fc_lport * ) ;
   void (*disc_recv_req)(struct fc_lport * , struct fc_frame * ) ;
   void (*disc_start)(void (*)(struct fc_lport * , enum fc_disc_event  ) , struct fc_lport * ) ;
   void (*disc_stop)(struct fc_lport * ) ;
   void (*disc_stop_final)(struct fc_lport * ) ;
};
#line 774 "include/scsi/libfc.h"
struct fc_disc {
   unsigned char retry_count ;
   unsigned char pending ;
   unsigned char requested ;
   unsigned short seq_count ;
   unsigned char buf_len ;
   u16 disc_id ;
   struct list_head rports ;
   void *priv ;
   struct mutex disc_mutex ;
   struct fc_gpn_ft_resp partial_buf ;
   struct delayed_work disc_work ;
   void (*disc_callback)(struct fc_lport * , enum fc_disc_event  ) ;
};
#line 818 "include/scsi/libfc.h"
struct fc_lport {
   struct Scsi_Host *host ;
   struct list_head ema_list ;
   struct fc_rport_priv *dns_rdata ;
   struct fc_rport_priv *ms_rdata ;
   struct fc_rport_priv *ptp_rdata ;
   void *scsi_priv ;
   struct fc_disc disc ;
   struct list_head vports ;
   struct fc_vport *vport ;
   struct libfc_function_template tt ;
   u8 link_up ;
   u8 qfull ;
   enum fc_lport_state state ;
   unsigned long boot_time ;
   struct fc_host_statistics host_stats ;
   struct fc_stats *stats ;
   u8 retry_count ;
   u32 port_id ;
   u64 wwpn ;
   u64 wwnn ;
   unsigned int service_params ;
   unsigned int e_d_tov ;
   unsigned int r_a_tov ;
   struct fc_els_rnid_gen rnid_gen ;
   unsigned char sg_supp : 1 ;
   unsigned char seq_offload : 1 ;
   unsigned char crc_offload : 1 ;
   unsigned char lro_enabled : 1 ;
   unsigned char does_npiv : 1 ;
   unsigned char npiv_enabled : 1 ;
   unsigned char point_to_multipoint : 1 ;
   unsigned char fdmi_enabled : 1 ;
   u32 mfs ;
   u8 max_retry_count ;
   u8 max_rport_retry_count ;
   u16 rport_priv_size ;
   u16 link_speed ;
   u16 link_supported_speeds ;
   u16 lro_xid ;
   unsigned int lso_max ;
   struct fc_ns_fts fcts ;
   struct mutex lp_mutex ;
   struct list_head list ;
   struct delayed_work retry_work ;
   void *prov[9U] ;
   struct list_head lport_list ;
};
#line 922 "include/scsi/libfc.h"
struct fc4_prov {
   int (*prli)(struct fc_rport_priv * , u32  , struct fc_els_spp  const  * , struct fc_els_spp * ) ;
   void (*prlo)(struct fc_rport_priv * ) ;
   void (*recv)(struct fc_lport * , struct fc_frame * ) ;
   struct module *module ;
};
#line 9 "include/linux/unaligned/generic.h"
struct proc_ns_operations;
#line 10 "include/linux/unaligned/generic.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations  const  *ops ;
   unsigned int inum ;
};
#line 23 "include/uapi/linux/utsname.h"
struct new_utsname {
   char sysname[65U] ;
   char nodename[65U] ;
   char release[65U] ;
   char version[65U] ;
   char machine[65U] ;
   char domainname[65U] ;
};
#line 22 "include/linux/utsname.h"
struct uts_namespace {
   struct kref kref ;
   struct new_utsname name ;
   struct user_namespace *user_ns ;
   struct ns_common ns ;
};
#line 460 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
typedef bool ldv_func_ret_type___2;
#line 471 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
typedef bool ldv_func_ret_type___3;
#line 482 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
typedef bool ldv_func_ret_type___4;
#line 501 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
typedef bool ldv_func_ret_type___5;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 9 "include/linux/unaligned/generic.h"
struct fc_ct_hdr {
   __u8 ct_rev ;
   __u8 ct_in_id[3U] ;
   __u8 ct_fs_type ;
   __u8 ct_fs_subtype ;
   __u8 ct_options ;
   __u8 _ct_resvd1 ;
   __be16 ct_cmd ;
   __be16 ct_mr_size ;
   __u8 _ct_resvd2 ;
   __u8 ct_reason ;
   __u8 ct_explan ;
   __u8 ct_vendor ;
};
#line 139 "./include/uapi/scsi/fc/fc_ns.h"
struct fc_ns_gid_pn {
   __be64 fn_wwpn ;
};
#line 483 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_rscn {
   __u8 rscn_cmd ;
   __u8 rscn_page_len ;
   __be16 rscn_plen ;
};
#line 492 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_rscn_page {
   __u8 rscn_page_flags ;
   __u8 rscn_fid[3U] ;
};
#line 499
enum fc_els_rscn_ev_qual {
    ELS_EV_QUAL_NONE = 0,
    ELS_EV_QUAL_NS_OBJ = 1,
    ELS_EV_QUAL_PORT_ATTR = 2,
    ELS_EV_QUAL_SERV_OBJ = 3,
    ELS_EV_QUAL_SW_CONFIG = 4,
    ELS_EV_QUAL_REM_OBJ = 5
} ;
#line 508
enum fc_els_rscn_addr_fmt {
    ELS_ADDR_FMT_PORT = 0,
    ELS_ADDR_FMT_AREA = 1,
    ELS_ADDR_FMT_DOM = 2,
    ELS_ADDR_FMT_FAB = 3
} ;
#line 298 "include/scsi/fc_frame.h"
struct fc_disc_port {
   struct fc_lport *lp ;
   struct list_head peers ;
   struct work_struct rport_work ;
   u32 port_id ;
};
#line 72 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
union __anonunion___u_300 {
   struct list_head *__val ;
   char __c[1U] ;
};
#line 72 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
union __anonunion___u_302 {
   struct list_head *__val ;
   char __c[1U] ;
};
#line 292 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
union __anonunion___u_304 {
   struct list_head *__val ;
   char __c[1U] ;
};
#line 292 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
union __anonunion___u_306 {
   struct list_head *__val ;
   char __c[1U] ;
};
#line 612 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
typedef bool ldv_func_ret_type___6;
#line 12 "include/linux/wait.h"
struct __wait_queue;
#line 12 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 15 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 134 "./include/uapi/scsi/scsi_netlink.h"
enum fc_tgtid_binding_type {
    FC_TGTID_BIND_NONE = 0,
    FC_TGTID_BIND_BY_WWPN = 1,
    FC_TGTID_BIND_BY_WWNN = 2,
    FC_TGTID_BIND_BY_ID = 3
} ;
#line 462 "include/scsi/scsi_transport_fc.h"
struct fc_host_attrs {
   u64 node_name ;
   u64 port_name ;
   u64 permanent_port_name ;
   u32 supported_classes ;
   u8 supported_fc4s[32U] ;
   u32 supported_speeds ;
   u32 maxframe_size ;
   u16 max_npiv_vports ;
   char serial_number[80U] ;
   char manufacturer[80U] ;
   char model[256U] ;
   char model_description[256U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char firmware_version[64U] ;
   char optionrom_version[64U] ;
   u32 port_id ;
   enum fc_port_type port_type ;
   enum fc_port_state port_state ;
   u8 active_fc4s[32U] ;
   u32 speed ;
   u64 fabric_name ;
   char symbolic_name[256U] ;
   char system_hostname[256U] ;
   u32 dev_loss_tmo ;
   enum fc_tgtid_binding_type tgtid_bind_type ;
   struct list_head rports ;
   struct list_head rport_bindings ;
   struct list_head vports ;
   u32 next_rport_number ;
   u32 next_target_id ;
   u32 next_vport_number ;
   u16 npiv_vports_inuse ;
   char work_q_name[20U] ;
   struct workqueue_struct *work_q ;
   char devloss_work_q_name[20U] ;
   struct workqueue_struct *devloss_work_q ;
   struct request_queue *rqst_q ;
};
#line 275 "include/scsi/fc/fc_ms.h"
struct fc_els_ls_acc {
   __u8 la_cmd ;
   __u8 la_resv[3U] ;
};
#line 170 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_ls_rjt {
   __u8 er_cmd ;
   __u8 er_resv[4U] ;
   __u8 er_reason ;
   __u8 er_explan ;
   __u8 er_vendor ;
};
#line 347 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_rrq {
   __u8 rrq_cmd ;
   __u8 rrq_zero[3U] ;
   __u8 rrq_resvd ;
   __u8 rrq_s_id[3U] ;
   __be16 rrq_ox_id ;
   __be16 rrq_rx_id ;
};
#line 370 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_rec {
   __u8 rec_cmd ;
   __u8 rec_zero[3U] ;
   __u8 rec_resvd ;
   __u8 rec_s_id[3U] ;
   __be16 rec_ox_id ;
   __be16 rec_rx_id ;
};
#line 382 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_rec_acc {
   __u8 reca_cmd ;
   __u8 reca_zero[3U] ;
   __be16 reca_ox_id ;
   __be16 reca_rx_id ;
   __u8 reca_resvd1 ;
   __u8 reca_ofid[3U] ;
   __u8 reca_resvd2 ;
   __u8 reca_rfid[3U] ;
   __be32 reca_fc4value ;
   __be32 reca_e_stat ;
};
#line 108 "./include/uapi/scsi/fc/fc_fs.h"
struct fc_ba_acc {
   __u8 ba_seq_id_val ;
   __u8 ba_seq_id ;
   __u8 ba_resvd[2U] ;
   __be16 ba_ox_id ;
   __be16 ba_rx_id ;
   __be16 ba_low_seq_cnt ;
   __be16 ba_high_seq_cnt ;
};
#line 256 "./include/uapi/scsi/fc/fc_fs.h"
struct fc_ba_rjt {
   __u8 br_resvd ;
   __u8 br_reason ;
   __u8 br_explan ;
   __u8 br_vendor ;
};
#line 266
enum fc_ba_rjt_reason {
    FC_BA_RJT_NONE = 0,
    FC_BA_RJT_INVL_CMD = 1,
    FC_BA_RJT_LOG_ERR = 3,
    FC_BA_RJT_LOG_BUSY = 5,
    FC_BA_RJT_PROTO_ERR = 7,
    FC_BA_RJT_UNABLE = 9,
    FC_BA_RJT_VENDOR = 255
} ;
#line 276
enum fc_ba_rjt_explan {
    FC_BA_RJT_EXP_NONE = 0,
    FC_BA_RJT_INV_XID = 3,
    FC_BA_RJT_ABT = 5
} ;
#line 299
enum fc_pf_rjt_reason {
    FC_RJT_NONE = 0,
    FC_RJT_INVL_DID = 1,
    FC_RJT_INVL_SID = 2,
    FC_RJT_P_UNAV_T = 3,
    FC_RJT_P_UNAV = 4,
    FC_RJT_CLS_UNSUP = 5,
    FC_RJT_DEL_USAGE = 6,
    FC_RJT_TYPE_UNSUP = 7,
    FC_RJT_LINK_CTL = 8,
    FC_RJT_R_CTL = 9,
    FC_RJT_F_CTL = 10,
    FC_RJT_OX_ID = 11,
    FC_RJT_RX_ID = 12,
    FC_RJT_SEQ_ID = 13,
    FC_RJT_DF_CTL = 14,
    FC_RJT_SEQ_CNT = 15,
    FC_RJT_PARAM = 16,
    FC_RJT_EXCH_ERR = 17,
    FC_RJT_PROTO = 18,
    FC_RJT_LEN = 19,
    FC_RJT_UNEXP_ACK = 20,
    FC_RJT_FAB_CLASS = 21,
    FC_RJT_LOGI_REQ = 22,
    FC_RJT_SEQ_XS = 23,
    FC_RJT_EXCH_EST = 24,
    FC_RJT_FAB_UNAV = 26,
    FC_RJT_VC_ID = 27,
    FC_RJT_CS_CTL = 28,
    FC_RJT_INSUF_RES = 29,
    FC_RJT_INVL_CLS = 31,
    FC_RJT_PREEMT_RJT = 32,
    FC_RJT_PREEMT_DIS = 33,
    FC_RJT_MCAST_ERR = 34,
    FC_RJT_MCAST_ET = 35,
    FC_RJT_PRLI_REQ = 36,
    FC_RJT_INVL_ATT = 37,
    FC_RJT_VENDOR = 255
} ;
#line 53 "include/scsi/fc/fc_encaps.h"
enum fc_sof {
    FC_SOF_F = 40,
    FC_SOF_I4 = 41,
    FC_SOF_I2 = 45,
    FC_SOF_I3 = 46,
    FC_SOF_N4 = 49,
    FC_SOF_N2 = 53,
    FC_SOF_N3 = 54,
    FC_SOF_C4 = 57
} ;
#line 75
enum fc_class {
    FC_CLASS_NONE = 0,
    FC_CLASS_2 = 45,
    FC_CLASS_3 = 46,
    FC_CLASS_4 = 41,
    FC_CLASS_F = 40
} ;
#line 358 "include/scsi/libfc.h"
struct fc_exch_mgr;
#line 359
struct fc_exch_mgr_anchor;
#line 385
struct fc_exch_pool;
#line 385 "include/scsi/libfc.h"
struct fc_exch {
   spinlock_t ex_lock ;
   atomic_t ex_refcnt ;
   enum fc_class class ;
   struct fc_exch_mgr *em ;
   struct fc_exch_pool *pool ;
   struct list_head ex_list ;
   struct fc_lport *lp ;
   u32 esb_stat ;
   u8 state ;
   u8 fh_type ;
   u8 seq_id ;
   u8 encaps ;
   u16 xid ;
   u16 oxid ;
   u16 rxid ;
   u32 oid ;
   u32 sid ;
   u32 did ;
   u32 r_a_tov ;
   u32 f_ctl ;
   struct fc_seq seq ;
   int resp_active ;
   struct task_struct *resp_task ;
   wait_queue_head_t resp_wq ;
   void (*resp)(struct fc_seq * , struct fc_frame * , void * ) ;
   void *arg ;
   void (*destructor)(struct fc_seq * , void * ) ;
   struct delayed_work timeout_work ;
};
#line 44 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
struct fc_exch_pool {
   spinlock_t lock ;
   struct list_head ex_list ;
   u16 next_index ;
   u16 total_exches ;
   u16 left ;
   u16 right ;
};
#line 79 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
struct __anonstruct_stats_304 {
   atomic_t no_free_exch ;
   atomic_t no_free_exch_xid ;
   atomic_t xid_not_found ;
   atomic_t xid_busy ;
   atomic_t seq_not_found ;
   atomic_t non_bls_resp ;
};
#line 79 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
struct fc_exch_mgr {
   struct fc_exch_pool *pool ;
   mempool_t *ep_pool ;
   enum fc_class class ;
   struct kref kref ;
   u16 min_xid ;
   u16 max_xid ;
   u16 pool_max_index ;
   struct __anonstruct_stats_304 stats ;
};
#line 112 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
struct fc_exch_mgr_anchor {
   struct list_head ema_list ;
   struct fc_exch_mgr *mp ;
   bool (*match)(struct fc_frame * ) ;
};
#line 630 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
typedef bool ldv_func_ret_type___7;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 48 "./include/uapi/scsi/fc/fc_gs.h"
enum fc_ct_fs_type {
    FC_FST_ALIAS = 248,
    FC_FST_MGMT = 250,
    FC_FST_TIME = 251,
    FC_FST_DIR = 252
} ;
#line 79 "./include/uapi/scsi/fc/fc_ns.h"
struct fc_ns_fid {
   __u8 fp_flags ;
   __u8 fp_fid[3U] ;
};
#line 119 "./include/uapi/scsi/fc/fc_ns.h"
struct fc_ns_gid_ft {
   __u8 fn_resvd ;
   __u8 fn_domain_id_scope ;
   __u8 fn_area_id_scope ;
   __u8 fn_fc4_type ;
};
#line 170 "./include/uapi/scsi/fc/fc_ns.h"
struct fc_ns_rn_id {
   struct fc_ns_fid fr_fid ;
   __be64 fr_wwn ;
};
#line 179 "./include/uapi/scsi/fc/fc_ns.h"
struct fc_ns_rsnn {
   __be64 fr_wwn ;
   __u8 fr_name_len ;
   char fr_name[] ;
};
#line 188 "./include/uapi/scsi/fc/fc_ns.h"
struct fc_ns_rspn {
   struct fc_ns_fid fr_fid ;
   __u8 fr_name_len ;
   char fr_name[] ;
};
#line 197 "./include/uapi/scsi/fc/fc_ns.h"
struct fc_ns_rff_id {
   struct fc_ns_fid fr_fid ;
   __u8 fr_resvd[2U] ;
   __u8 fr_feat ;
   __u8 fr_type ;
};
#line 211 "./include/uapi/scsi/fc/fc_els.h"
struct __anonstruct_sp_plogi_218 {
   __be16 _sp_tot_seq ;
   __be16 _sp_rel_off ;
};
#line 211 "./include/uapi/scsi/fc/fc_els.h"
struct __anonstruct_sp_flogi_acc_219 {
   __be32 _sp_r_a_tov ;
};
#line 211 "./include/uapi/scsi/fc/fc_els.h"
union __anonunion_sp_u_217 {
   struct __anonstruct_sp_plogi_218 sp_plogi ;
   struct __anonstruct_sp_flogi_acc_219 sp_flogi_acc ;
};
#line 211 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_csp {
   __u8 sp_hi_ver ;
   __u8 sp_lo_ver ;
   __be16 sp_bb_cred ;
   __be16 sp_features ;
   __be16 sp_bb_data ;
   union __anonunion_sp_u_217 sp_u ;
   __be32 sp_e_d_tov ;
};
#line 240 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_cssp {
   __be16 cp_class ;
   __be16 cp_init ;
   __be16 cp_recip ;
   __be16 cp_rdfs ;
   __be16 cp_con_seq ;
   __be16 cp_ee_cred ;
   __u8 cp_resv1 ;
   __u8 cp_open_seq ;
   __u8 _cp_resv2[2U] ;
};
#line 289 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_flogi {
   __u8 fl_cmd ;
   __u8 _fl_resvd[3U] ;
   struct fc_els_csp fl_csp ;
   __be64 fl_wwpn ;
   __be64 fl_wwnn ;
   struct fc_els_cssp fl_cssp[4U] ;
   __u8 fl_vend[16U] ;
};
#line 398 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_prli {
   __u8 prli_cmd ;
   __u8 prli_spp_len ;
   __be16 prli_len ;
};
#line 417 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_adisc {
   __u8 adisc_cmd ;
   __u8 adisc_resv[3U] ;
   __u8 adisc_resv1 ;
   __u8 adisc_hard_addr[3U] ;
   __be64 adisc_wwpn ;
   __be64 adisc_wwnn ;
   __u8 adisc_resv2 ;
   __u8 adisc_port_id[3U] ;
};
#line 431 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_logo {
   __u8 fl_cmd ;
   __u8 fl_zero[3U] ;
   __u8 fl_resvd ;
   __u8 fl_n_port_id[3U] ;
   __be64 fl_n_port_wwn ;
};
#line 442 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_rtv {
   __u8 rtv_cmd ;
   __u8 rtv_zero[3U] ;
};
#line 461 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_scr {
   __u8 scr_cmd ;
   __u8 scr_resv[6U] ;
   __u8 scr_reg_func ;
};
#line 247 "include/scsi/fc/fc_fcp.h"
struct fc_fdmi_hba_identifier {
   __be64 id ;
};
#line 116 "include/scsi/fc/fc_ms.h"
struct fc_fdmi_port_name {
   __be64 portname ;
};
#line 123 "include/scsi/fc/fc_ms.h"
struct fc_fdmi_attr_entry {
   __be16 type ;
   __be16 len ;
   __u8 value[1U] ;
};
#line 133 "include/scsi/fc/fc_ms.h"
struct fs_fdmi_attrs {
   __be32 numattrs ;
   struct fc_fdmi_attr_entry attr[1U] ;
};
#line 141 "include/scsi/fc/fc_ms.h"
struct fc_fdmi_rpl {
   __be32 numport ;
   struct fc_fdmi_port_name port[1U] ;
};
#line 149 "include/scsi/fc/fc_ms.h"
struct fc_fdmi_rhba {
   struct fc_fdmi_hba_identifier hbaid ;
   struct fc_fdmi_rpl port ;
   struct fs_fdmi_attrs hba_attrs ;
};
#line 175 "include/scsi/fc/fc_ms.h"
struct fc_fdmi_rpa {
   struct fc_fdmi_port_name port ;
   struct fs_fdmi_attrs hba_attrs ;
};
#line 183 "include/scsi/fc/fc_ms.h"
struct fc_fdmi_dprt {
   struct fc_fdmi_port_name port ;
};
#line 205 "include/scsi/fc/fc_ms.h"
struct fc_fdmi_dhba {
   struct fc_fdmi_hba_identifier hbaid ;
};
#line 83 "include/linux/utsname.h"
struct fc_ns_rft {
   struct fc_ns_fid fid ;
   struct fc_ns_fts fts ;
};
#line 36 "include/scsi/fc_encode.h"
union __anonunion_payload_299 {
   struct fc_ns_gid_ft gid ;
   struct fc_ns_rn_id rn ;
   struct fc_ns_rft rft ;
   struct fc_ns_rff_id rff ;
   struct fc_ns_fid fid ;
   struct fc_ns_rsnn snn ;
   struct fc_ns_rspn spn ;
   struct fc_fdmi_rhba rhba ;
   struct fc_fdmi_rpa rpa ;
   struct fc_fdmi_dprt dprt ;
   struct fc_fdmi_dhba dhba ;
};
#line 36 "include/scsi/fc_encode.h"
struct fc_ct_req {
   struct fc_ct_hdr hdr ;
   union __anonunion_payload_299 payload ;
};
#line 661 "include/scsi/fc_encode.h"
struct __anonstruct_pp_301 {
   struct fc_els_prli prli ;
   struct fc_els_spp spp ;
};
#line 663 "include/scsi/fc_encode.h"
struct __anonstruct_303 {
   struct fc_els_prli prli ;
   struct fc_els_spp spp ;
};
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 447 "include/scsi/scsi_transport_fc.h"
enum fc_host_event_code {
    FCH_EVT_LIP = 1,
    FCH_EVT_LINKUP = 2,
    FCH_EVT_LINKDOWN = 3,
    FCH_EVT_LIPRESET = 4,
    FCH_EVT_RSCN = 5,
    FCH_EVT_ADAPTER_CHANGE = 259,
    FCH_EVT_PORT_UNKNOWN = 512,
    FCH_EVT_PORT_OFFLINE = 513,
    FCH_EVT_PORT_ONLINE = 514,
    FCH_EVT_PORT_FABRIC = 516,
    FCH_EVT_LINK_UNKNOWN = 1280,
    FCH_EVT_VENDOR_UNIQUE = 65535
} ;
#line 547 "include/scsi/scsi_transport_fc.h"
struct fc_bsg_buffer {
   unsigned int payload_len ;
   int sg_cnt ;
   struct scatterlist *sg_list ;
};
#line 632
struct fc_bsg_request;
#line 632
struct fc_bsg_reply;
#line 632 "include/scsi/scsi_transport_fc.h"
struct fc_bsg_job {
   struct Scsi_Host *shost ;
   struct fc_rport *rport ;
   struct device *dev ;
   struct request *req ;
   spinlock_t job_lock ;
   unsigned int state_flags ;
   unsigned int ref_cnt ;
   void (*job_done)(struct fc_bsg_job * ) ;
   struct fc_bsg_request *request ;
   struct fc_bsg_reply *reply ;
   unsigned int request_len ;
   unsigned int reply_len ;
   struct fc_bsg_buffer request_payload ;
   struct fc_bsg_buffer reply_payload ;
   void *dd_data ;
};
#line 860 "include/scsi/scsi_transport_fc.h"
struct fc_bsg_host_add_rport {
   uint8_t reserved ;
   uint8_t port_id[3U] ;
};
#line 88 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_host_del_rport {
   uint8_t reserved ;
   uint8_t port_id[3U] ;
};
#line 109 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_host_els {
   uint8_t command_code ;
   uint8_t port_id[3U] ;
};
#line 133 "./include/uapi/scsi/scsi_bsg_fc.h"
struct __anonstruct_rjt_data_293 {
   uint8_t action ;
   uint8_t reason_code ;
   uint8_t reason_explanation ;
   uint8_t vendor_unique ;
};
#line 133 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_ctels_reply {
   uint32_t status ;
   struct __anonstruct_rjt_data_293 rjt_data ;
};
#line 178 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_host_ct {
   uint8_t reserved ;
   uint8_t port_id[3U] ;
   uint32_t preamble_word0 ;
   uint32_t preamble_word1 ;
   uint32_t preamble_word2 ;
};
#line 203 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_host_vendor {
   uint64_t vendor_id ;
   uint32_t vendor_cmd[0U] ;
};
#line 226 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_host_vendor_reply {
   uint32_t vendor_rsp[0U] ;
};
#line 233 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_rport_els {
   uint8_t els_code ;
};
#line 252 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_rport_ct {
   uint32_t preamble_word0 ;
   uint32_t preamble_word1 ;
   uint32_t preamble_word2 ;
};
#line 272 "./include/uapi/scsi/scsi_bsg_fc.h"
union __anonunion_rqst_data_294 {
   struct fc_bsg_host_add_rport h_addrport ;
   struct fc_bsg_host_del_rport h_delrport ;
   struct fc_bsg_host_els h_els ;
   struct fc_bsg_host_ct h_ct ;
   struct fc_bsg_host_vendor h_vendor ;
   struct fc_bsg_rport_els r_els ;
   struct fc_bsg_rport_ct r_ct ;
};
#line 272 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_request {
   uint32_t msgcode ;
   union __anonunion_rqst_data_294 rqst_data ;
};
#line 294 "./include/uapi/scsi/scsi_bsg_fc.h"
union __anonunion_reply_data_295 {
   struct fc_bsg_host_vendor_reply vendor_reply ;
   struct fc_bsg_ctels_reply ctels_reply ;
};
#line 294 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_reply {
   uint32_t result ;
   uint32_t reply_payload_rcv_len ;
   union __anonunion_reply_data_295 reply_data ;
};
#line 209 "include/scsi/fc/fc_fcp.h"
enum fc_ns_req {
    FC_NS_GA_NXT = 256,
    FC_NS_GI_A = 257,
    FC_NS_GPN_ID = 274,
    FC_NS_GNN_ID = 275,
    FC_NS_GSPN_ID = 280,
    FC_NS_GID_PN = 289,
    FC_NS_GID_NN = 305,
    FC_NS_GID_FT = 369,
    FC_NS_GPN_FT = 370,
    FC_NS_GID_PT = 417,
    FC_NS_RPN_ID = 530,
    FC_NS_RNN_ID = 531,
    FC_NS_RFT_ID = 535,
    FC_NS_RSPN_ID = 536,
    FC_NS_RFF_ID = 543,
    FC_NS_RSNN_NN = 569
} ;
#line 207 "./include/uapi/scsi/fc/fc_ns.h"
enum fc_fdmi_req {
    FC_FDMI_GRHL = 256,
    FC_FDMI_GHAT = 257,
    FC_FDMI_GRPL = 258,
    FC_FDMI_GPAT = 272,
    FC_FDMI_RHBA = 512,
    FC_FDMI_RHAT = 513,
    FC_FDMI_RPRT = 528,
    FC_FDMI_RPA = 529,
    FC_FDMI_DHBA = 768,
    FC_FDMI_DHAT = 769,
    FC_FDMI_DPRT = 784,
    FC_FDMI_DPA = 785
} ;
#line 515 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_rnid {
   __u8 rnid_cmd ;
   __u8 rnid_resv[3U] ;
   __u8 rnid_fmt ;
   __u8 rnid_resv2[3U] ;
};
#line 535 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_rnid_resp {
   __u8 rnid_cmd ;
   __u8 rnid_resv[3U] ;
   __u8 rnid_fmt ;
   __u8 rnid_cid_len ;
   __u8 rnid_resv2 ;
   __u8 rnid_sid_len ;
};
#line 550 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_rnid_cid {
   __be64 rnid_wwpn ;
   __be64 rnid_wwnn ;
};
#line 140 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
struct fc_bsg_info {
   struct fc_bsg_job *job ;
   struct fc_lport *lport ;
   u16 rsp_code ;
   struct scatterlist *sg ;
   u32 nents ;
   size_t offset ;
};
#line 472 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
struct __anonstruct_rp_305 {
   struct fc_els_rnid_resp rnid ;
   struct fc_els_rnid_cid cid ;
   struct fc_els_rnid_gen gen ;
};
#line 495 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
struct __anonstruct_307 {
   struct fc_els_rnid_resp rnid ;
   struct fc_els_rnid_cid cid ;
   struct fc_els_rnid_gen gen ;
};
#line 972 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
union __anonunion___u_309 {
   struct fc4_prov *__val ;
   char __c[1U] ;
};
#line 692 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
typedef bool ldv_func_ret_type___8;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 336 "./include/uapi/scsi/fc/fc_els.h"
enum fc_els_spp_resp {
    FC_SPP_RESP_ACK = 1,
    FC_SPP_RESP_RES = 2,
    FC_SPP_RESP_INIT = 3,
    FC_SPP_RESP_NO_PA = 4,
    FC_SPP_RESP_CONF = 5,
    FC_SPP_RESP_COND = 6,
    FC_SPP_RESP_MULT = 7,
    FC_SPP_RESP_INVL = 8
} ;
#line 407 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_prlo {
   __u8 prlo_cmd ;
   __u8 prlo_obs ;
   __be16 prlo_len ;
};
#line 450 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_rtv_acc {
   __u8 rtv_cmd ;
   __u8 rtv_zero[3U] ;
   __be32 rtv_r_a_tov ;
   __be32 rtv_e_d_tov ;
   __be32 rtv_toq ;
};
#line 734 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_rls {
   __u8 rls_cmd ;
   __u8 rls_resv[4U] ;
   __u8 rls_port_id[3U] ;
};
#line 743 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_rls_resp {
   __u8 rls_cmd ;
   __u8 rls_resv[3U] ;
   struct fc_els_lesb rls_lesb ;
};
#line 152 "include/scsi/libfc.h"
struct fc_rport_libfc_priv {
   struct fc_lport *local_port ;
   enum fc_rport_state rp_state ;
   u16 flags ;
   unsigned int e_d_tov ;
   unsigned int r_a_tov ;
};
#line 661 "include/scsi/fc_encode.h"
struct __anonstruct_pp_301___0 {
   struct fc_els_prli prli ;
   struct fc_els_spp spp ;
};
#line 663 "include/scsi/fc_encode.h"
struct __anonstruct_303___0 {
   struct fc_els_prli prli ;
   struct fc_els_spp spp ;
};
#line 105 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
union __anonunion___u_305 {
   struct list_head *__val ;
   char __c[1U] ;
};
#line 105 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
union __anonunion___u_307 {
   struct list_head *__val ;
   char __c[1U] ;
};
#line 1000 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
struct __anonstruct_pp_309 {
   struct fc_els_prli prli ;
   struct fc_els_spp spp ;
};
#line 1030 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
struct __anonstruct_311 {
   struct fc_els_prli prli ;
   struct fc_els_spp spp ;
};
#line 1031 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
struct __anonstruct_313 {
   struct fc_els_prli prli ;
   struct fc_els_spp spp ;
};
#line 1095 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
struct __anonstruct_pp_315 {
   struct fc_els_prli prli ;
   struct fc_els_spp spp ;
};
#line 1123 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
struct __anonstruct_317 {
   struct fc_els_prli prli ;
   struct fc_els_spp spp ;
};
#line 1719 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
struct __anonstruct_pp_319 {
   struct fc_els_prli prli ;
   struct fc_els_spp spp ;
};
#line 1733 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
struct __anonstruct_321 {
   struct fc_els_prli prli ;
   struct fc_els_spp spp ;
};
#line 1734 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
struct __anonstruct_323 {
   struct fc_els_prli prli ;
   struct fc_els_spp spp ;
};
#line 1753 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
struct __anonstruct_325 {
   struct fc_els_prli prli ;
   struct fc_els_spp spp ;
};
#line 1754 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
struct __anonstruct_327 {
   struct fc_els_prli prli ;
   struct fc_els_spp spp ;
};
#line 1838 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
struct __anonstruct_pp_329 {
   struct fc_els_prlo prlo ;
   struct fc_els_spp spp ;
};
#line 1849 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
struct __anonstruct_331 {
   struct fc_els_prlo prlo ;
   struct fc_els_spp spp ;
};
#line 1850 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
struct __anonstruct_333 {
   struct fc_els_prlo prlo ;
   struct fc_els_spp spp ;
};
#line 1867 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
struct __anonstruct_335 {
   struct fc_els_prlo prlo ;
   struct fc_els_spp spp ;
};
#line 1868 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
struct __anonstruct_337 {
   struct fc_els_prlo prlo ;
   struct fc_els_spp spp ;
};
#line 247 "include/linux/timer.h"
enum hrtimer_restart;
#line 215 "include/linux/skbuff.h"
struct skb_frag_struct;
#line 215 "include/linux/skbuff.h"
typedef struct skb_frag_struct skb_frag_t;
#line 216 "include/linux/skbuff.h"
struct __anonstruct_page_282 {
   struct page *p ;
};
#line 216 "include/linux/skbuff.h"
struct skb_frag_struct {
   struct __anonstruct_page_282 page ;
   __u32 page_offset ;
   __u32 size ;
};
#line 249 "include/linux/skbuff.h"
struct skb_shared_hwtstamps {
   ktime_t hwtstamp ;
};
#line 319 "include/linux/skbuff.h"
struct skb_shared_info {
   unsigned char nr_frags ;
   __u8 tx_flags ;
   unsigned short gso_size ;
   unsigned short gso_segs ;
   unsigned short gso_type ;
   struct sk_buff *frag_list ;
   struct skb_shared_hwtstamps hwtstamps ;
   u32 tskey ;
   __be32 ip6_frag_id ;
   atomic_t dataref ;
   void *destructor_arg ;
   skb_frag_t frags[17U] ;
};
#line 70 "include/scsi/fc/fc_fcp.h"
struct fcp_txrdy {
   __be32 ft_data_ro ;
   __be32 ft_burst_len ;
   __u8 _ft_resvd[4U] ;
};
#line 112 "include/scsi/fc/fc_fcp.h"
struct fcp_resp {
   __u8 _fr_resvd[8U] ;
   __be16 fr_retry_delay ;
   __u8 fr_flags ;
   __u8 fr_status ;
};
#line 140 "include/scsi/fc/fc_fcp.h"
struct fcp_resp_ext {
   __be32 fr_resid ;
   __be32 fr_sns_len ;
   __be32 fr_rsp_len ;
};
#line 148 "include/scsi/fc/fc_fcp.h"
struct fcp_resp_rsp_info {
   __u8 _fr_resvd[3U] ;
   __u8 rsp_code ;
   __u8 _fr_resvd2[4U] ;
};
#line 179 "include/scsi/fc/fc_fcp.h"
struct fcp_srr {
   __u8 srr_op ;
   __u8 srr_resvd[3U] ;
   __be16 srr_ox_id ;
   __be16 srr_rx_id ;
   __be32 srr_rel_off ;
   __u8 srr_r_ctl ;
   __u8 srr_resvd2[3U] ;
};
#line 46 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
struct fc_fcp_internal {
   mempool_t *scsi_pkt_pool ;
   spinlock_t scsi_queue_lock ;
   struct list_head scsi_pkt_queue ;
   unsigned long last_can_queue_ramp_down_time ;
   unsigned long last_can_queue_ramp_up_time ;
   int max_can_queue ;
};
#line 1799
struct fc_remote_port;
#line 810 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
typedef int ldv_func_ret_type___9;
#line 821 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
typedef int ldv_func_ret_type___10;
#line 832 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
typedef int ldv_func_ret_type___11;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 7 "./arch/x86/include/uapi/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val ) 
{ 


  {
#line 9
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
#line 10
  return (val);
}
}
#line 46 "include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val ) 
{ 


  {
#line 53
  return ((__u16 )((int )((short )((int )val << 8)) | (int )((short )((int )val >> 8))));
}
}
#line 57 "include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val ) 
{ 
  __u32 tmp ;

  {
#line 62
  tmp = __arch_swab32(val);
#line 62
  return (tmp);
}
}
#line 6 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t  ) ;
#line 7
extern void *calloc(size_t  , size_t  ) ;
#line 8
extern void *memset(void * , int  , size_t  ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int  ) ;
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
#line 53
  tmp = calloc(1UL, size);
#line 53
  p = tmp;
#line 54
  __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 55
  return (p);
}
}
#line 58 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
#line 59
  tmp = memset(s, c, n);
#line 59
  return (tmp);
}
}
#line 62 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 63
  tmp = __VERIFIER_nondet_int();
#line 63
  return (tmp);
}
}
#line 66 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 67
  tmp = __VERIFIER_nondet_pointer();
#line 67
  return (tmp);
}
}
#line 70 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 71
  tmp = __VERIFIER_nondet_ulong();
#line 71
  return (tmp);
}
}
#line 22 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 54
  return (exp);
}
}
#line 48 "include/linux/list.h"
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 75 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 77
  __list_add(new, head->prev, head);
#line 78
  return;
}
}
#line 113
extern void list_del(struct list_head * ) ;
#line 87 "./arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 71 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 10 "./arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "./arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3233;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3233;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3233;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3233;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_3233: ;
#line 14
  return (pfo_ret__);
}
}
#line 30 "./arch/x86/include/asm/string_64.h"
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 57
extern void *memset(void * , int  , size_t  ) ;
#line 8 "./arch/x86/include/asm/preempt.h"
extern int __preempt_count ;
#line 70 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add(int val ) 
{ 
  int pao_ID__ ;

  {
#line 72
  pao_ID__ = 0;
#line 72
  switch (4UL) {
  case 1UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (val));
  }
#line 72
  goto ldv_6163;
  case 2UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6163;
  case 4UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6163;
  case 8UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (val));
  }
#line 72
  goto ldv_6163;
  default: 
#line 72
  __bad_percpu_size();
  }
  ldv_6163: ;
#line 74
  return;
}
}
#line 75 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub(int val ) 
{ 
  int pao_ID__ ;

  {
#line 77
  pao_ID__ = 0;
#line 77
  switch (4UL) {
  case 1UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (- val));
  }
#line 77
  goto ldv_6175;
  case 2UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6175;
  case 4UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6175;
  case 8UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (- val));
  }
#line 77
  goto ldv_6175;
  default: 
#line 77
  __bad_percpu_size();
  }
  ldv_6175: ;
#line 79
  return;
}
}
#line 138 "include/linux/mutex.h"
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
#line 174
extern void mutex_unlock(struct mutex * ) ;
#line 218 "include/linux/rcupdate.h"
extern void synchronize_sched(void) ;
#line 278 "include/linux/rcupdate.h"
__inline static void synchronize_rcu(void) 
{ 


  {
#line 280
  synchronize_sched();
#line 281
  return;
}
}
#line 429 "include/linux/workqueue.h"
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
#line 433
bool ldv_queue_work_on_15(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_17(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 439
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
#line 443
bool ldv_queue_delayed_work_on_16(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_19(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 452
extern void flush_workqueue(struct workqueue_struct * ) ;
#line 455
void ldv_flush_workqueue_18(struct workqueue_struct *ldv_func_arg1 ) ;
#line 144 "include/linux/notifier.h"
extern int blocking_notifier_call_chain(struct blocking_notifier_head * , unsigned long  ,
                                        void * ) ;
#line 293 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_25(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 18 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
void ldv_check_alloc_flags(gfp_t flags ) ;
#line 28 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_state_variable_8  ;
#line 29 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct timer_list *ldv_timer_list_7_1  ;
#line 30 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_timer_7_3  ;
#line 31 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct work_struct *ldv_work_struct_3_1  ;
#line 32 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct work_struct *ldv_work_struct_1_3  ;
#line 33 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct work_struct *ldv_work_struct_5_2  ;
#line 34 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_state_variable_0  ;
#line 35 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_state_variable_5  ;
#line 36 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct work_struct *ldv_work_struct_5_3  ;
#line 37 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_work_1_1  ;
#line 38 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_state_variable_12  ;
#line 39 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_work_3_2  ;
#line 40 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct timer_list *ldv_timer_list_7_2  ;
#line 41 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_timer_6_2  ;
#line 42 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_work_3_0  ;
#line 43 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct work_struct *ldv_work_struct_2_3  ;
#line 44 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct work_struct *ldv_work_struct_2_0  ;
#line 45 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct timer_list *ldv_timer_list_6_1  ;
#line 46 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_timer_7_0  ;
#line 47 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct work_struct *ldv_work_struct_4_3  ;
#line 48 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_state_variable_9  ;
#line 49 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_timer_6_0  ;
#line 50 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct work_struct *ldv_work_struct_2_2  ;
#line 51 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct timer_list *ldv_timer_list_8  ;
#line 52 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ref_cnt  ;
#line 53 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_work_3_3  ;
#line 54 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct work_struct *ldv_work_struct_4_0  ;
#line 55 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_state_variable_1  ;
#line 56 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_state_variable_7  ;
#line 57 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_work_5_3  ;
#line 58 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_timer_6_3  ;
#line 59 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct work_struct *ldv_work_struct_3_3  ;
#line 60 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct timer_list *ldv_timer_list_6_3  ;
#line 61 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct timer_list *ldv_timer_list_6_2  ;
#line 62 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct work_struct *ldv_work_struct_1_0  ;
#line 63 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct work_struct *ldv_work_struct_1_1  ;
#line 64 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_state_variable_10  ;
#line 65 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_timer_state_8  =    0;
#line 66 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct timer_list *ldv_timer_list_7_3  ;
#line 67 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_work_1_3  ;
#line 68 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct work_struct *ldv_work_struct_2_1  ;
#line 69 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_work_4_0  ;
#line 70 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct work_struct *ldv_work_struct_3_2  ;
#line 71 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_state_variable_6  ;
#line 72 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_work_4_1  ;
#line 73 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_work_4_3  ;
#line 74 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_work_3_1  ;
#line 75 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_state_variable_2  ;
#line 76 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_work_5_0  ;
#line 77 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_work_2_0  ;
#line 78 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_work_5_1  ;
#line 79 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct work_struct *ldv_work_struct_4_2  ;
#line 80 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct timer_list *ldv_timer_list_6_0  ;
#line 81 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct work_struct *ldv_work_struct_3_0  ;
#line 82 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_work_4_2  ;
#line 83 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_state_variable_11  ;
#line 84 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_timer_7_2  ;
#line 85 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_timer_7_1  ;
#line 86 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_work_1_2  ;
#line 87 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 89 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct timer_list *ldv_timer_list_7_0  ;
#line 90 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct work_struct *ldv_work_struct_5_0  ;
#line 91 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct work_struct *ldv_work_struct_1_2  ;
#line 92 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct work_struct *ldv_work_struct_5_1  ;
#line 93 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_timer_6_1  ;
#line 94 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_work_5_2  ;
#line 95 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_work_2_2  ;
#line 96 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_state_variable_3  ;
#line 97 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct work_struct *ldv_work_struct_4_1  ;
#line 98 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_work_1_0  ;
#line 99 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_work_2_3  ;
#line 100 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_state_variable_4  ;
#line 101 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_work_2_1  ;
#line 103
void work_init_3(void) ;
#line 110
void work_init_2(void) ;
#line 119
void activate_work_3(struct work_struct *work , int state ) ;
#line 120
void work_init_5(void) ;
#line 121
void timer_init_7(void) ;
#line 128
void timer_init_6(void) ;
#line 134
void work_init_4(void) ;
#line 137
void work_init_1(void) ;
#line 144
void call_and_disable_all_3(int state ) ;
#line 924 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 926
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
#line 120 "include/linux/scatterlist.h"
__inline static struct page *sg_page(struct scatterlist *sg ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 123
  tmp = ldv__builtin_expect(sg->sg_magic != 2271560481UL, 0L);
#line 123
  if (tmp != 0L) {
#line 123
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (123), "i" (12UL));
    ldv_23197: ;
#line 123
    goto ldv_23197;
  } else {

  }
#line 124
  tmp___0 = ldv__builtin_expect((long )((int )sg->page_link) & 1L, 0L);
#line 124
  if (tmp___0 != 0L) {
#line 124
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (124), "i" (12UL));
    ldv_23198: ;
#line 124
    goto ldv_23198;
  } else {

  }
#line 126
  return ((struct page *)(sg->page_link & 0xfffffffffffffffcUL));
}
}
#line 250
extern struct scatterlist *sg_next(struct scatterlist * ) ;
#line 11 "include/linux/crc32.h"
extern u32 crc32_le(u32  , unsigned char const   * , size_t  ) ;
#line 7 "include/linux/uaccess.h"
__inline static void pagefault_disabled_inc(void) 
{ 
  struct task_struct *tmp ;

  {
#line 9
  tmp = get_current();
#line 9
  tmp->pagefault_disabled = tmp->pagefault_disabled + 1;
#line 10
  return;
}
}
#line 12 "include/linux/uaccess.h"
__inline static void pagefault_disabled_dec(void) 
{ 
  struct task_struct *tmp ;
  int __ret_warn_on ;
  struct task_struct *tmp___0 ;
  long tmp___1 ;

  {
#line 14
  tmp = get_current();
#line 14
  tmp->pagefault_disabled = tmp->pagefault_disabled - 1;
#line 15
  tmp___0 = get_current();
#line 15
  __ret_warn_on = tmp___0->pagefault_disabled < 0;
#line 15
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 15
  if (tmp___1 != 0L) {
#line 15
    warn_slowpath_null("include/linux/uaccess.h", 15);
  } else {

  }
#line 15
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 17
  return;
}
}
#line 25 "include/linux/uaccess.h"
__inline static void pagefault_disable(void) 
{ 


  {
#line 27
  pagefault_disabled_inc();
#line 32
  __asm__  volatile   ("": : : "memory");
#line 33
  return;
}
}
#line 35 "include/linux/uaccess.h"
__inline static void pagefault_enable(void) 
{ 


  {
#line 41
  __asm__  volatile   ("": : : "memory");
#line 42
  pagefault_disabled_dec();
#line 43
  return;
}
}
#line 66 "include/linux/highmem.h"
__inline static void *kmap_atomic(struct page *page ) 
{ 
  void *tmp ;

  {
#line 68
  __preempt_count_add(1);
#line 68
  __asm__  volatile   ("": : : "memory");
#line 69
  pagefault_disable();
#line 70
  tmp = lowmem_page_address((struct page  const  *)page);
#line 70
  return (tmp);
}
}
#line 74 "include/linux/highmem.h"
__inline static void __kunmap_atomic(void *addr ) 
{ 


  {
#line 76
  pagefault_enable();
#line 77
  __asm__  volatile   ("": : : "memory");
#line 77
  __preempt_count_sub(1);
#line 78
  return;
}
}
#line 849 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_33(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 853
struct sk_buff *ldv_skb_clone_41(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 858
struct sk_buff *ldv_skb_copy_35(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 871
int ldv_pskb_expand_head_31(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 875
int ldv_pskb_expand_head_39(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 879
int ldv_pskb_expand_head_40(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 1692
extern unsigned char *skb_put(struct sk_buff * , unsigned int  ) ;
#line 2148
struct sk_buff *ldv___netdev_alloc_skb_36(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2152
struct sk_buff *ldv___netdev_alloc_skb_37(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2156
struct sk_buff *ldv___netdev_alloc_skb_38(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 43 "include/scsi/fc_frame.h"
__inline static void hton24(u8 *p , u32 v ) 
{ 


  {
#line 45
  *p = (u8 )(v >> 16);
#line 46
  *(p + 1UL) = (u8 )(v >> 8);
#line 47
  *(p + 2UL) = (u8 )v;
#line 48
  return;
}
}
#line 161 "include/scsi/fc_frame.h"
__inline static struct fc_frame_header *__fc_frame_header_get(struct fc_frame  const  *fp ) 
{ 


  {
#line 163
  return ((struct fc_frame_header *)fp->skb.data);
}
}
#line 812 "include/scsi/libfc.h"
struct blocking_notifier_head fc_lport_notifier_head ;
#line 942
int fc_fc4_register_provider(enum fc_fh_type type , struct fc4_prov *prov ) ;
#line 943
void fc_fc4_deregister_provider(enum fc_fh_type type , struct fc4_prov *prov ) ;
#line 1075
void fc_lport_iterate(void (*notify)(struct fc_lport * , void * ) , void *arg ) ;
#line 1122
void fc_fill_reply_hdr(struct fc_frame *fp , struct fc_frame  const  *in_fp , enum fc_rctl r_ctl ,
                       u32 parm_offset ) ;
#line 1124
void fc_fill_hdr(struct fc_frame *fp , struct fc_frame  const  *in_fp , enum fc_rctl r_ctl ,
                 u32 f_ctl , u16 seq_cnt , u32 parm_offset ) ;
#line 32 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/libfc/fc_libfc.h"
unsigned int fc_debug_logging  ;
#line 99
struct fc4_prov *fc_active_prov[9U] ;
#line 100
struct fc4_prov *fc_passive_prov[9U] ;
#line 101
struct mutex fc_prov_mutex ;
#line 103
struct fc4_prov fc_rport_t0_prov ;
#line 104
struct fc4_prov fc_lport_els_prov ;
#line 105
struct fc4_prov fc_rport_fcp_init ;
#line 116
int fc_setup_exch_mgr(void) ;
#line 117
void fc_destroy_exch_mgr(void) ;
#line 118
int fc_setup_rport(void) ;
#line 119
void fc_destroy_rport(void) ;
#line 120
int fc_setup_fcp(void) ;
#line 121
void fc_destroy_fcp(void) ;
#line 127
void fc_fc4_add_lport(struct fc_lport *lport ) ;
#line 128
void fc_fc4_del_lport(struct fc_lport *lport ) ;
#line 129
void fc_fc4_conf_lport_params(struct fc_lport *lport , enum fc_fh_type type ) ;
#line 134
u32 fc_copy_buffer_to_sglist(void *buf , size_t len , struct scatterlist *sg , u32 *nents ,
                             size_t *offset , u32 *crc ) ;
#line 39 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
struct mutex fc_prov_mutex  =    {{1}, {{{{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "fc_prov_mutex.wait_lock",
                                                          0, 0UL}}}}, {& fc_prov_mutex.wait_list,
                                                                       & fc_prov_mutex.wait_list},
    0, (void *)(& fc_prov_mutex), {0, {0, 0}, "fc_prov_mutex", 0, 0UL}};
#line 40 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
static struct list_head fc_local_ports  =    {& fc_local_ports, & fc_local_ports};
#line 41 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
struct blocking_notifier_head fc_lport_notifier_head  =    {{0L, {& fc_lport_notifier_head.rwsem.wait_list, & fc_lport_notifier_head.rwsem.wait_list},
     {{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "(fc_lport_notifier_head).rwsem.wait_lock",
                                                    0, 0UL}}, {{0}}, (struct task_struct *)0,
     {0, {0, 0}, "(fc_lport_notifier_head).rwsem", 0, 0UL}}, (struct notifier_block *)0};
#line 43 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
static char const   __kstrtab_fc_lport_notifier_head[23U]  = 
#line 43
  {      'f',      'c',      '_',      'l', 
        'p',      'o',      'r',      't', 
        '_',      'n',      'o',      't', 
        'i',      'f',      'i',      'e', 
        'r',      '_',      'h',      'e', 
        'a',      'd',      '\000'};
#line 43
struct kernel_symbol  const  __ksymtab_fc_lport_notifier_head ;
#line 43 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
struct kernel_symbol  const  __ksymtab_fc_lport_notifier_head  =    {(unsigned long )(& fc_lport_notifier_head), (char const   *)(& __kstrtab_fc_lport_notifier_head)};
#line 48 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
struct fc4_prov *fc_active_prov[9U]  = 
#line 48
  {      & fc_rport_t0_prov,      0,      0,      0, 
        0,      0,      0,      0, 
        & fc_rport_fcp_init};
#line 56 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
struct fc4_prov *fc_passive_prov[9U]  = {      0,      & fc_lport_els_prov};
#line 63 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
static int libfc_init(void) 
{ 
  int rc ;

  {
#line 65
  rc = 0;
#line 67
  rc = fc_setup_fcp();
#line 68
  if (rc != 0) {
#line 69
    return (rc);
  } else {

  }
#line 71
  rc = fc_setup_exch_mgr();
#line 72
  if (rc != 0) {
#line 73
    goto destroy_pkt_cache;
  } else {

  }
#line 75
  rc = fc_setup_rport();
#line 76
  if (rc != 0) {
#line 77
    goto destroy_em;
  } else {

  }
#line 79
  return (rc);
  destroy_em: 
#line 81
  fc_destroy_exch_mgr();
  destroy_pkt_cache: 
#line 83
  fc_destroy_fcp();
#line 84
  return (rc);
}
}
#line 91 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
static void libfc_exit(void) 
{ 


  {
#line 93
  fc_destroy_fcp();
#line 94
  fc_destroy_exch_mgr();
#line 95
  fc_destroy_rport();
#line 96
  return;
}
}
#line 111 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
u32 fc_copy_buffer_to_sglist(void *buf , size_t len , struct scatterlist *sg , u32 *nents ,
                             size_t *offset , u32 *crc ) 
{ 
  size_t remaining ;
  u32 copy_len ;
  size_t off ;
  size_t sg_bytes ;
  void *page_addr ;
  size_t _min1 ;
  size_t _min2 ;
  size_t _min1___0 ;
  unsigned long _min2___0 ;
  struct page *tmp ;

  {
#line 116
  remaining = len;
#line 117
  copy_len = 0U;
#line 119
  goto ldv_41225;
  ldv_41232: ;
#line 123
  if (*offset >= (size_t )sg->length) {
#line 128
    if (*nents == 0U) {
#line 129
      goto ldv_41224;
    } else {

    }
#line 130
    *nents = *nents - 1U;
#line 131
    *offset = *offset - (size_t )sg->length;
#line 132
    sg = sg_next(sg);
#line 133
    goto ldv_41225;
  } else {

  }
#line 135
  _min1 = remaining;
#line 135
  _min2 = (size_t )sg->length - *offset;
#line 135
  sg_bytes = _min1 < _min2 ? _min1 : _min2;
#line 141
  off = *offset + (size_t )sg->offset;
#line 142
  _min1___0 = sg_bytes;
#line 142
  _min2___0 = 4096UL - (off & 4095UL);
#line 142
  sg_bytes = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 144
  tmp = sg_page(sg);
#line 144
  page_addr = kmap_atomic(tmp + (off >> 12));
#line 145
  if ((unsigned long )crc != (unsigned long )((u32 *)0U)) {
#line 146
    *crc = crc32_le(*crc, (unsigned char const   *)buf, sg_bytes);
  } else {

  }
#line 147
  memcpy(page_addr + (off & 4095UL), (void const   *)buf, sg_bytes);
#line 148
  __kunmap_atomic(page_addr);
#line 149
  buf = buf + sg_bytes;
#line 150
  *offset = *offset + sg_bytes;
#line 151
  remaining = remaining - sg_bytes;
#line 152
  copy_len = (u32 )sg_bytes + copy_len;
  ldv_41225: ;
#line 119
  if (remaining != 0UL && (unsigned long )sg != (unsigned long )((struct scatterlist *)0)) {
#line 121
    goto ldv_41232;
  } else {

  }
  ldv_41224: ;
#line 154
  return (copy_len);
}
}
#line 166 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
void fc_fill_hdr(struct fc_frame *fp , struct fc_frame  const  *in_fp , enum fc_rctl r_ctl ,
                 u32 f_ctl , u16 seq_cnt , u32 parm_offset ) 
{ 
  struct fc_frame_header *fh ;
  struct fc_frame_header *in_fh ;
  struct fc_seq *sp ;
  u32 fill ;
  unsigned char *tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  __u32 tmp___1 ;
  __u16 tmp___2 ;

  {
#line 174
  fh = __fc_frame_header_get((struct fc_frame  const  *)fp);
#line 175
  in_fh = __fc_frame_header_get(in_fp);
#line 177
  if ((f_ctl & 524288U) != 0U) {
#line 178
    fill = - fp->skb.len & 3U;
#line 179
    if (fill != 0U) {
#line 181
      tmp = skb_put(& fp->skb, fill);
#line 181
      memset((void *)tmp, 0, (size_t )fill);
#line 182
      f_ctl = f_ctl | fill;
    } else {

    }
#line 184
    ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_eof = 66U;
  } else {
#line 186
    __ret_warn_on = (fp->skb.len & 3U) != 0U;
#line 186
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 186
    if (tmp___0 != 0L) {
#line 186
      warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c",
                         186);
    } else {

    }
#line 186
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 187
    ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_eof = 65U;
  }
#line 190
  fh->fh_r_ctl = (__u8 )r_ctl;
#line 191
  memcpy((void *)(& fh->fh_d_id), (void const   *)(& in_fh->fh_s_id), 3UL);
#line 192
  memcpy((void *)(& fh->fh_s_id), (void const   *)(& in_fh->fh_d_id), 3UL);
#line 193
  fh->fh_type = in_fh->fh_type;
#line 194
  hton24((u8 *)(& fh->fh_f_ctl), f_ctl);
#line 195
  fh->fh_ox_id = in_fh->fh_ox_id;
#line 196
  fh->fh_rx_id = in_fh->fh_rx_id;
#line 197
  fh->fh_cs_ctl = 0U;
#line 198
  fh->fh_df_ctl = 0U;
#line 199
  tmp___1 = __fswab32(parm_offset);
#line 199
  fh->fh_parm_offset = tmp___1;
#line 201
  sp = ((struct fcoe_rcv_info *)(& in_fp->skb.cb))->fr_seq;
#line 202
  if ((unsigned long )sp != (unsigned long )((struct fc_seq *)0)) {
#line 203
    ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_seq = sp;
#line 204
    fh->fh_seq_id = sp->id;
#line 205
    seq_cnt = sp->cnt;
  } else {
#line 207
    fh->fh_seq_id = 0U;
  }
#line 209
  tmp___2 = __fswab16((int )seq_cnt);
#line 209
  fh->fh_seq_cnt = tmp___2;
#line 210
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_sof = (unsigned int )seq_cnt != 0U ? 54U : 46U;
#line 211
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_encaps = ((struct fcoe_rcv_info *)(& in_fp->skb.cb))->fr_encaps;
#line 212
  return;
}
}
#line 213 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
static char const   __kstrtab_fc_fill_hdr[12U]  = 
#line 213
  {      'f',      'c',      '_',      'f', 
        'i',      'l',      'l',      '_', 
        'h',      'd',      'r',      '\000'};
#line 213
struct kernel_symbol  const  __ksymtab_fc_fill_hdr ;
#line 213 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
struct kernel_symbol  const  __ksymtab_fc_fill_hdr  =    {(unsigned long )(& fc_fill_hdr), (char const   *)(& __kstrtab_fc_fill_hdr)};
#line 222 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
void fc_fill_reply_hdr(struct fc_frame *fp , struct fc_frame  const  *in_fp , enum fc_rctl r_ctl ,
                       u32 parm_offset ) 
{ 
  struct fc_seq *sp ;

  {
#line 227
  sp = ((struct fcoe_rcv_info *)(& in_fp->skb.cb))->fr_seq;
#line 228
  if ((unsigned long )sp != (unsigned long )((struct fc_seq *)0)) {
#line 229
    ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_seq = (*((((struct fcoe_rcv_info *)(& in_fp->skb.cb))->fr_dev)->tt.seq_start_next))(sp);
  } else {

  }
#line 230
  fc_fill_hdr(fp, in_fp, r_ctl, 10027008U, 0, parm_offset);
#line 231
  return;
}
}
#line 232 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
static char const   __kstrtab_fc_fill_reply_hdr[18U]  = 
#line 232
  {      'f',      'c',      '_',      'f', 
        'i',      'l',      'l',      '_', 
        'r',      'e',      'p',      'l', 
        'y',      '_',      'h',      'd', 
        'r',      '\000'};
#line 232
struct kernel_symbol  const  __ksymtab_fc_fill_reply_hdr ;
#line 232 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
struct kernel_symbol  const  __ksymtab_fc_fill_reply_hdr  =    {(unsigned long )(& fc_fill_reply_hdr), (char const   *)(& __kstrtab_fc_fill_reply_hdr)};
#line 241 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
void fc_fc4_conf_lport_params(struct fc_lport *lport , enum fc_fh_type type ) 
{ 
  struct fc4_prov *prov_entry ;
  long tmp ;
  long tmp___0 ;

  {
#line 244
  tmp = ldv__builtin_expect((unsigned int )type > 8U, 0L);
#line 244
  if (tmp != 0L) {
#line 244
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"),
                         "i" (244), "i" (12UL));
    ldv_41281: ;
#line 244
    goto ldv_41281;
  } else {

  }
#line 245
  tmp___0 = ldv__builtin_expect((unsigned long )lport == (unsigned long )((struct fc_lport *)0),
                             0L);
#line 245
  if (tmp___0 != 0L) {
#line 245
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"),
                         "i" (245), "i" (12UL));
    ldv_41282: ;
#line 245
    goto ldv_41282;
  } else {

  }
#line 246
  prov_entry = fc_passive_prov[(unsigned int )type];
#line 247
  if ((unsigned int )type == 8U) {
#line 248
    if ((unsigned long )prov_entry != (unsigned long )((struct fc4_prov *)0) && (unsigned long )prov_entry->recv != (unsigned long )((void (*)(struct fc_lport * ,
                                                                                                                                               struct fc_frame * ))0)) {
#line 249
      lport->service_params = lport->service_params | 16U;
    } else {

    }
  } else {

  }
#line 250
  return;
}
}
#line 253 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
void fc_lport_iterate(void (*notify)(struct fc_lport * , void * ) , void *arg ) 
{ 
  struct fc_lport *lport ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 257
  mutex_lock_nested(& fc_prov_mutex, 0U);
#line 258
  __mptr = (struct list_head  const  *)fc_local_ports.next;
#line 258
  lport = (struct fc_lport *)__mptr + 0xfffffffffffff978UL;
#line 258
  goto ldv_41295;
  ldv_41294: 
#line 259
  (*notify)(lport, arg);
#line 258
  __mptr___0 = (struct list_head  const  *)lport->lport_list.next;
#line 258
  lport = (struct fc_lport *)__mptr___0 + 0xfffffffffffff978UL;
  ldv_41295: ;
#line 258
  if ((unsigned long )(& lport->lport_list) != (unsigned long )(& fc_local_ports)) {
#line 260
    goto ldv_41294;
  } else {

  }
#line 260
  mutex_unlock(& fc_prov_mutex);
#line 261
  return;
}
}
#line 262 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
static char const   __kstrtab_fc_lport_iterate[17U]  = 
#line 262
  {      'f',      'c',      '_',      'l', 
        'p',      'o',      'r',      't', 
        '_',      'i',      't',      'e', 
        'r',      'a',      't',      'e', 
        '\000'};
#line 262
struct kernel_symbol  const  __ksymtab_fc_lport_iterate ;
#line 262 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
struct kernel_symbol  const  __ksymtab_fc_lport_iterate  =    {(unsigned long )(& fc_lport_iterate), (char const   *)(& __kstrtab_fc_lport_iterate)};
#line 271 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
int fc_fc4_register_provider(enum fc_fh_type type , struct fc4_prov *prov ) 
{ 
  struct fc4_prov **prov_entry ;
  int ret ;

  {
#line 274
  ret = 0;
#line 276
  if ((unsigned int )type > 8U) {
#line 277
    return (-22);
  } else {

  }
#line 278
  mutex_lock_nested(& fc_prov_mutex, 0U);
#line 279
  prov_entry = ((unsigned long )prov->recv != (unsigned long )((void (*)(struct fc_lport * ,
                                                                         struct fc_frame * ))0) ? (struct fc4_prov **)(& fc_passive_prov) : (struct fc4_prov **)(& fc_active_prov)) + (unsigned long )type;
#line 280
  if ((unsigned long )*prov_entry != (unsigned long )((struct fc4_prov *)0)) {
#line 281
    ret = -16;
  } else {
#line 283
    *prov_entry = prov;
  }
#line 284
  mutex_unlock(& fc_prov_mutex);
#line 285
  return (ret);
}
}
#line 287 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
static char const   __kstrtab_fc_fc4_register_provider[25U]  = 
#line 287
  {      'f',      'c',      '_',      'f', 
        'c',      '4',      '_',      'r', 
        'e',      'g',      'i',      's', 
        't',      'e',      'r',      '_', 
        'p',      'r',      'o',      'v', 
        'i',      'd',      'e',      'r', 
        '\000'};
#line 287
struct kernel_symbol  const  __ksymtab_fc_fc4_register_provider ;
#line 287 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
struct kernel_symbol  const  __ksymtab_fc_fc4_register_provider  =    {(unsigned long )(& fc_fc4_register_provider), (char const   *)(& __kstrtab_fc_fc4_register_provider)};
#line 294 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
void fc_fc4_deregister_provider(enum fc_fh_type type , struct fc4_prov *prov ) 
{ 
  long tmp ;

  {
#line 296
  tmp = ldv__builtin_expect((unsigned int )type > 8U, 0L);
#line 296
  if (tmp != 0L) {
#line 296
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"),
                         "i" (296), "i" (12UL));
    ldv_41323: ;
#line 296
    goto ldv_41323;
  } else {

  }
#line 297
  mutex_lock_nested(& fc_prov_mutex, 0U);
#line 298
  if ((unsigned long )prov->recv != (unsigned long )((void (*)(struct fc_lport * ,
                                                               struct fc_frame * ))0)) {
#line 299
    fc_passive_prov[(unsigned int )type] = (struct fc4_prov *)0;
  } else {
#line 301
    fc_active_prov[(unsigned int )type] = (struct fc4_prov *)0;
  }
#line 302
  mutex_unlock(& fc_prov_mutex);
#line 303
  synchronize_rcu();
#line 304
  return;
}
}
#line 305 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
static char const   __kstrtab_fc_fc4_deregister_provider[27U]  = 
#line 305
  {      'f',      'c',      '_',      'f', 
        'c',      '4',      '_',      'd', 
        'e',      'r',      'e',      'g', 
        'i',      's',      't',      'e', 
        'r',      '_',      'p',      'r', 
        'o',      'v',      'i',      'd', 
        'e',      'r',      '\000'};
#line 305
struct kernel_symbol  const  __ksymtab_fc_fc4_deregister_provider ;
#line 305 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
struct kernel_symbol  const  __ksymtab_fc_fc4_deregister_provider  =    {(unsigned long )(& fc_fc4_deregister_provider), (char const   *)(& __kstrtab_fc_fc4_deregister_provider)};
#line 311 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
void fc_fc4_add_lport(struct fc_lport *lport ) 
{ 


  {
#line 313
  mutex_lock_nested(& fc_prov_mutex, 0U);
#line 314
  list_add_tail(& lport->lport_list, & fc_local_ports);
#line 315
  blocking_notifier_call_chain(& fc_lport_notifier_head, 0UL, (void *)lport);
#line 317
  mutex_unlock(& fc_prov_mutex);
#line 318
  return;
}
}
#line 324 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.c"
void fc_fc4_del_lport(struct fc_lport *lport ) 
{ 


  {
#line 326
  mutex_lock_nested(& fc_prov_mutex, 0U);
#line 327
  list_del(& lport->lport_list);
#line 328
  blocking_notifier_call_chain(& fc_lport_notifier_head, 1UL, (void *)lport);
#line 330
  mutex_unlock(& fc_prov_mutex);
#line 331
  return;
}
}
#line 152 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_retval_0  ;
#line 153
extern void ldv_initialize(void) ;
#line 154
extern void ldv_check_final_state(void) ;
#line 159
void ldv_main_exported_10(void) ;
#line 160
void ldv_main_exported_9(void) ;
#line 161
void ldv_main_exported_11(void) ;
#line 162
void ldv_main_exported_12(void) ;
#line 167 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int main(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 168
  ldv_initialize();
#line 172
  timer_init_6();
#line 174
  ldv_state_variable_6 = 1;
#line 175
  ldv_state_variable_11 = 0;
#line 177
  work_init_3();
#line 179
  ldv_state_variable_3 = 1;
#line 181
  timer_init_7();
#line 183
  ldv_state_variable_7 = 1;
#line 184
  ldv_state_variable_9 = 0;
#line 185
  ldv_state_variable_12 = 0;
#line 187
  work_init_2();
#line 189
  ldv_state_variable_2 = 1;
#line 191
  ldv_state_variable_8 = 1;
#line 193
  work_init_1();
#line 195
  ldv_state_variable_1 = 1;
#line 197
  work_init_4();
#line 199
  ldv_state_variable_4 = 1;
#line 200
  ref_cnt = 0;
#line 201
  ldv_state_variable_0 = 1;
#line 202
  ldv_state_variable_10 = 0;
#line 204
  work_init_5();
#line 206
  ldv_state_variable_5 = 1;
  ldv_41378: 
#line 208
  tmp = __VERIFIER_nondet_int();
#line 208
  switch (tmp) {
  case 0: ;
#line 215
  goto ldv_41359;
  case 1: ;
#line 219
  if (ldv_state_variable_11 != 0) {
#line 220
    ldv_main_exported_11();
  } else {

  }
#line 223
  goto ldv_41359;
  case 2: ;
#line 230
  goto ldv_41359;
  case 3: ;
#line 237
  goto ldv_41359;
  case 4: ;
#line 241
  if (ldv_state_variable_9 != 0) {
#line 242
    ldv_main_exported_9();
  } else {

  }
#line 245
  goto ldv_41359;
  case 5: ;
#line 249
  if (ldv_state_variable_12 != 0) {
#line 250
    ldv_main_exported_12();
  } else {

  }
#line 253
  goto ldv_41359;
  case 6: ;
#line 260
  goto ldv_41359;
  case 7: ;
#line 267
  goto ldv_41359;
  case 8: ;
#line 274
  goto ldv_41359;
  case 9: ;
#line 281
  goto ldv_41359;
  case 10: ;
#line 285
  if (ldv_state_variable_0 != 0) {
#line 286
    tmp___0 = __VERIFIER_nondet_int();
#line 286
    switch (tmp___0) {
    case 0: ;
#line 289
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
#line 291
      libfc_exit();
#line 292
      ldv_state_variable_0 = 2;
#line 293
      goto ldv_final;
    } else {

    }
#line 296
    goto ldv_41372;
    case 1: ;
#line 299
    if (ldv_state_variable_0 == 1) {
#line 301
      ldv_retval_0 = libfc_init();
#line 303
      if (ldv_retval_0 == 0) {
#line 304
        ldv_state_variable_0 = 3;
#line 305
        ldv_state_variable_12 = 1;
#line 306
        ldv_state_variable_9 = 1;
#line 307
        ldv_state_variable_10 = 1;
#line 308
        ldv_state_variable_11 = 1;
      } else {

      }
#line 310
      if (ldv_retval_0 != 0) {
#line 311
        ldv_state_variable_0 = 2;
#line 312
        goto ldv_final;
      } else {

      }
    } else {

    }
#line 316
    goto ldv_41372;
    default: 
#line 317
    ldv_stop();
    }
    ldv_41372: ;
  } else {

  }
#line 321
  goto ldv_41359;
  case 11: ;
#line 325
  if (ldv_state_variable_10 != 0) {
#line 326
    ldv_main_exported_10();
  } else {

  }
#line 329
  goto ldv_41359;
  case 12: ;
#line 336
  goto ldv_41359;
  default: 
#line 337
  ldv_stop();
  }
  ldv_41359: ;
#line 339
  goto ldv_41378;
  ldv_final: 
#line 341
  ldv_check_final_state();
#line 342
  return 0;
}
}
#line 458 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
bool ldv_queue_work_on_15(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 462
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 462
  ldv_func_res = tmp;
#line 464
  activate_work_3(ldv_func_arg3, 2);
#line 466
  return (ldv_func_res);
}
}
#line 469 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
bool ldv_queue_delayed_work_on_16(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 473
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 473
  ldv_func_res = tmp;
#line 475
  activate_work_3(& ldv_func_arg3->work, 2);
#line 477
  return (ldv_func_res);
}
}
#line 480 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
bool ldv_queue_work_on_17(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  bool tmp ;

  {
#line 484
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 484
  ldv_func_res = tmp;
#line 486
  activate_work_3(ldv_func_arg3, 2);
#line 488
  return (ldv_func_res);
}
}
#line 491 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
void ldv_flush_workqueue_18(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 494
  flush_workqueue(ldv_func_arg1);
#line 496
  call_and_disable_all_3(2);
#line 497
  return;
}
}
#line 499 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
bool ldv_queue_delayed_work_on_19(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
#line 503
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 503
  ldv_func_res = tmp;
#line 505
  activate_work_3(& ldv_func_arg3->work, 2);
#line 507
  return (ldv_func_res);
}
}
#line 545 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
void *ldv_kmem_cache_alloc_25(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 548
  ldv_check_alloc_flags(flags);
#line 549
  tmp = ldv_undef_ptr();
#line 549
  return (tmp);
}
}
#line 587 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_pskb_expand_head_31(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 590
  ldv_check_alloc_flags(flags);
#line 591
  tmp = ldv_undef_ptr();
#line 591
  return ((int )((long )tmp));
}
}
#line 601 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct sk_buff *ldv_skb_clone_33(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 604
  ldv_check_alloc_flags(flags);
#line 605
  tmp = ldv_undef_ptr();
#line 605
  return ((struct sk_buff *)tmp);
}
}
#line 615 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct sk_buff *ldv_skb_copy_35(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 618
  ldv_check_alloc_flags(flags);
#line 619
  tmp = ldv_undef_ptr();
#line 619
  return ((struct sk_buff *)tmp);
}
}
#line 622 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_36(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 625
  ldv_check_alloc_flags(flags);
#line 626
  tmp = ldv_undef_ptr();
#line 626
  return ((struct sk_buff *)tmp);
}
}
#line 629 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_37(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 632
  ldv_check_alloc_flags(flags);
#line 633
  tmp = ldv_undef_ptr();
#line 633
  return ((struct sk_buff *)tmp);
}
}
#line 636 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_38(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 639
  ldv_check_alloc_flags(flags);
#line 640
  tmp = ldv_undef_ptr();
#line 640
  return ((struct sk_buff *)tmp);
}
}
#line 643 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_pskb_expand_head_39(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 646
  ldv_check_alloc_flags(flags);
#line 647
  tmp = ldv_undef_ptr();
#line 647
  return ((int )((long )tmp));
}
}
#line 650 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
int ldv_pskb_expand_head_40(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 653
  ldv_check_alloc_flags(flags);
#line 654
  tmp = ldv_undef_ptr();
#line 654
  return ((int )((long )tmp));
}
}
#line 657 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_libfc.o.c.prepared"
struct sk_buff *ldv_skb_clone_41(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 660
  ldv_check_alloc_flags(flags);
#line 661
  tmp = ldv_undef_ptr();
#line 661
  return ((struct sk_buff *)tmp);
}
}
#line 1 "<compiler builtins>"
#line 1
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 201 "include/linux/compiler.h"
__inline static void __read_once_size(void const volatile   *p , void *res , int size ) 
{ 


  {
#line 203
  switch (size) {
  case 1: 
#line 204
  *((__u8 *)res) = *((__u8 volatile   *)p);
#line 204
  goto ldv_880;
  case 2: 
#line 205
  *((__u16 *)res) = *((__u16 volatile   *)p);
#line 205
  goto ldv_880;
  case 4: 
#line 206
  *((__u32 *)res) = *((__u32 volatile   *)p);
#line 206
  goto ldv_880;
  case 8: 
#line 207
  *((__u64 *)res) = *((__u64 volatile   *)p);
#line 207
  goto ldv_880;
  default: 
#line 209
  __asm__  volatile   ("": : : "memory");
#line 210
  __builtin_memcpy(res, (void const   *)p, (unsigned long )size);
#line 211
  __asm__  volatile   ("": : : "memory");
  }
  ldv_880: ;
#line 214
  return;
}
}
#line 14 "./arch/x86/include/uapi/asm/swab.h"
__inline static __u64 __arch_swab64(__u64 val ) 
{ 


  {
#line 30
  __asm__  ("bswapq %0": "=r" (val): "0" (val));
#line 31
  return (val);
}
}
#line 68 "include/uapi/linux/swab.h"
__inline static __u64 __fswab64(__u64 val ) 
{ 
  __u64 tmp ;

  {
#line 73
  tmp = __arch_swab64(val);
#line 73
  return (tmp);
}
}
#line 180 "include/uapi/linux/swab.h"
__inline static __u64 __swab64p(__u64 const   *p ) 
{ 
  __u64 tmp ;

  {
#line 185
  tmp = __fswab64(*p);
#line 185
  return (tmp);
}
}
#line 71 "include/uapi/linux/byteorder/little_endian.h"
__inline static __u64 __be64_to_cpup(__be64 const   *p ) 
{ 
  __u64 tmp ;

  {
#line 73
  tmp = __swab64p(p);
#line 73
  return (tmp);
}
}
#line 142 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 3 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
bool ldv_is_err(void const   *ptr ) ;
#line 6
long ldv_ptr_err(void const   *ptr ) ;
#line 25 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 32 "include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 15 "./arch/x86/include/asm/cmpxchg.h"
extern void __xadd_wrong_size(void) ;
#line 79 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_sub_and_test(int i , atomic_t *v ) 
{ 
  char c ;

  {
#line 81
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; subl %2, %0; sete %1": "+m" (v->counter),
                       "=qm" (c): "er" (i): "memory");
#line 81
  return ((int )((signed char )c) != 0);
}
}
#line 155 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ 
  int __ret ;

  {
#line 157
  __ret = i;
#line 157
  switch (4UL) {
  case 1UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddb %b0, %1\n": "+q" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5763;
  case 2UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddw %w0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5763;
  case 4UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddl %0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5763;
  case 8UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddq %q0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5763;
  default: 
#line 157
  __xadd_wrong_size();
  }
  ldv_5763: ;
#line 157
  return (__ret + i);
}
}
#line 280 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 119 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 292 "include/linux/jiffies.h"
extern unsigned long __msecs_to_jiffies(unsigned int const    ) ;
#line 354 "include/linux/jiffies.h"
__inline static unsigned long msecs_to_jiffies(unsigned int const   m ) 
{ 
  unsigned long tmp___0 ;

  {
#line 361
  tmp___0 = __msecs_to_jiffies(m);
#line 361
  return (tmp___0);
}
}
#line 461 "include/linux/rcupdate.h"
extern int debug_lockdep_rcu_enabled(void) ;
#line 88 "include/linux/timer.h"
extern void init_timer_key(struct timer_list * , unsigned int  , char const   * ,
                           struct lock_class_key * ) ;
#line 20 "include/linux/workqueue.h"
extern void delayed_work_timer_fn(unsigned long  ) ;
#line 181
extern void __init_work(struct work_struct * , int  ) ;
#line 352
extern struct workqueue_struct *system_wq ;
#line 433
bool ldv_queue_work_on_61(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_63(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_62(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_65(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_64(struct workqueue_struct *ldv_func_arg1 ) ;
#line 468
extern bool cancel_delayed_work_sync(struct delayed_work * ) ;
#line 471
bool ldv_cancel_delayed_work_sync_88(struct delayed_work *ldv_func_arg1 ) ;
#line 483 "include/linux/workqueue.h"
__inline static bool queue_delayed_work(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                        unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 487
  tmp = ldv_queue_delayed_work_on_62(8192, wq, dwork, delay);
#line 487
  return (tmp);
}
}
#line 585 "include/linux/workqueue.h"
__inline static bool schedule_delayed_work(struct delayed_work *dwork , unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 588
  tmp = queue_delayed_work(system_wq, dwork, delay);
#line 588
  return (tmp);
}
}
#line 41 "include/linux/kref.h"
__inline static void kref_get(struct kref *kref ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 47
  tmp = atomic_add_return(1, & kref->refcount);
#line 47
  __ret_warn_once = tmp <= 1;
#line 47
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 47
  if (tmp___2 != 0L) {
#line 47
    __ret_warn_on = ! __warned;
#line 47
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 47
    if (tmp___0 != 0L) {
#line 47
      warn_slowpath_null("include/linux/kref.h", 47);
    } else {

    }
#line 47
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 47
    if (tmp___1 != 0L) {
#line 47
      __warned = 1;
    } else {

    }
  } else {

  }
#line 47
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 49
  return;
}
}
#line 68 "include/linux/kref.h"
__inline static int kref_sub(struct kref *kref , unsigned int count , void (*release)(struct kref * ) ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
#line 71
  __ret_warn_on = (unsigned long )release == (unsigned long )((void (*)(struct kref * ))0);
#line 71
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 71
  if (tmp != 0L) {
#line 71
    warn_slowpath_null("include/linux/kref.h", 71);
  } else {

  }
#line 71
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 73
  tmp___0 = atomic_sub_and_test((int )count, & kref->refcount);
#line 73
  if (tmp___0 != 0) {
#line 74
    (*release)(kref);
#line 75
    return (1);
  } else {

  }
#line 77
  return (0);
}
}
#line 97 "include/linux/kref.h"
__inline static int kref_put(struct kref *kref , void (*release)(struct kref * ) ) 
{ 
  int tmp ;

  {
#line 99
  tmp = kref_sub(kref, 1U, release);
#line 99
  return (tmp);
}
}
#line 143 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 293
void *ldv_kmem_cache_alloc_71(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 585
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 104 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
void call_and_disable_work_1(struct work_struct *work ) ;
#line 114
void call_and_disable_all_1(int state ) ;
#line 123
void activate_work_1(struct work_struct *work , int state ) ;
#line 128
void disable_work_3(struct work_struct *work ) ;
#line 131
void disable_work_1(struct work_struct *work ) ;
#line 137
void invoke_work_1(void) ;
#line 32 "include/linux/unaligned/access_ok.h"
__inline static u64 get_unaligned_be64(void const   *p ) 
{ 
  __u64 tmp ;

  {
#line 34
  tmp = __be64_to_cpup((__be64 const   *)p);
#line 34
  return (tmp);
}
}
#line 772 "include/linux/skbuff.h"
extern void kfree_skb(struct sk_buff * ) ;
#line 849
struct sk_buff *ldv_skb_clone_79(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 853
struct sk_buff *ldv_skb_clone_87(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 858
struct sk_buff *ldv_skb_copy_81(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 871
int ldv_pskb_expand_head_77(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 875
int ldv_pskb_expand_head_85(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 879
int ldv_pskb_expand_head_86(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 1567 "include/linux/skbuff.h"
__inline static bool skb_is_nonlinear(struct sk_buff  const  *skb ) 
{ 


  {
#line 1569
  return ((unsigned int )skb->data_len != 0U);
}
}
#line 2148
struct sk_buff *ldv___netdev_alloc_skb_82(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2152
struct sk_buff *ldv___netdev_alloc_skb_83(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2156
struct sk_buff *ldv___netdev_alloc_skb_84(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 38 "include/scsi/fc_frame.h"
__inline static u32 ntoh24(u8 const   *p ) 
{ 


  {
#line 40
  return ((u32 )((((int )*p << 16) | ((int )*(p + 1UL) << 8)) | (int )*(p + 2UL)));
}
}
#line 121
struct fc_frame *fc_frame_alloc_fill(struct fc_lport *lp , size_t payload_len ) ;
#line 122
struct fc_frame *_fc_frame_alloc(size_t len ) ;
#line 128 "include/scsi/fc_frame.h"
__inline static struct fc_frame *fc_frame_alloc(struct fc_lport *dev , size_t len ) 
{ 
  struct fc_frame *fp ;

  {
#line 136
  if (len != 0UL && (len & 3UL) != 0UL) {
#line 137
    fp = fc_frame_alloc_fill(dev, len);
  } else {
#line 139
    fp = _fc_frame_alloc(len);
  }
#line 140
  return (fp);
}
}
#line 146 "include/scsi/fc_frame.h"
__inline static void fc_frame_free(struct fc_frame *fp ) 
{ 


  {
#line 148
  kfree_skb(& fp->skb);
#line 149
  return;
}
}
#line 151 "include/scsi/fc_frame.h"
__inline static int fc_frame_is_linear(struct fc_frame *fp ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 153
  tmp = skb_is_nonlinear((struct sk_buff  const  *)(& fp->skb));
#line 153
  if (tmp) {
#line 153
    tmp___0 = 0;
  } else {
#line 153
    tmp___0 = 1;
  }
#line 153
  return (tmp___0);
}
}
#line 171 "include/scsi/fc_frame.h"
__inline static struct fc_frame_header *fc_frame_header_get(struct fc_frame  const  *fp ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  struct fc_frame_header *tmp___0 ;

  {
#line 173
  __ret_warn_on = (unsigned int )fp->skb.len <= 23U;
#line 173
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 173
  if (tmp != 0L) {
#line 173
    warn_slowpath_null("include/scsi/fc_frame.h", 173);
  } else {

  }
#line 173
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 174
  tmp___0 = __fc_frame_header_get(fp);
#line 174
  return (tmp___0);
}
}
#line 203 "include/scsi/fc_frame.h"
__inline static void *fc_frame_payload_get(struct fc_frame  const  *fp , size_t len ) 
{ 
  void *pp ;
  struct fc_frame_header *tmp ;

  {
#line 206
  pp = (void *)0;
#line 208
  if ((unsigned long )fp->skb.len >= len + 24UL) {
#line 209
    tmp = fc_frame_header_get(fp);
#line 209
    pp = (void *)tmp + 1U;
  } else {

  }
#line 210
  return (pp);
}
}
#line 218 "include/scsi/fc_frame.h"
__inline static u8 fc_frame_payload_op(struct fc_frame  const  *fp ) 
{ 
  u8 *cp ;
  void *tmp ;

  {
#line 222
  tmp = fc_frame_payload_get(fp, 1UL);
#line 222
  cp = (u8 *)tmp;
#line 223
  if ((unsigned long )cp == (unsigned long )((u8 *)0U)) {
#line 224
    return (0U);
  } else {

  }
#line 225
  return (*cp);
}
}
#line 953 "include/scsi/libfc.h"
__inline static int fc_lport_test_ready(struct fc_lport *lport ) 
{ 


  {
#line 955
  return ((unsigned int )lport->state == 14U);
}
}
#line 1086
void fc_disc_init(struct fc_lport *lport ) ;
#line 1087
void fc_disc_config(struct fc_lport *lport , void *priv ) ;
#line 1089 "include/scsi/libfc.h"
__inline static struct fc_lport *fc_disc_lport(struct fc_disc *disc ) 
{ 
  struct fc_disc  const  *__mptr ;

  {
#line 1091
  __mptr = (struct fc_disc  const  *)disc;
#line 1091
  return ((struct fc_lport *)__mptr + 0xffffffffffffffc8UL);
}
}
#line 50 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
static void fc_disc_gpn_ft_req(struct fc_disc *disc ) ;
#line 51
static void fc_disc_gpn_ft_resp(struct fc_seq *sp , struct fc_frame *fp , void *disc_arg ) ;
#line 52
static void fc_disc_done(struct fc_disc *disc , enum fc_disc_event event ) ;
#line 53
static void fc_disc_timeout(struct work_struct *work ) ;
#line 54
static int fc_disc_single(struct fc_lport *lport , struct fc_disc_port *dp ) ;
#line 55
static void fc_disc_restart(struct fc_disc *disc ) ;
#line 64 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
static void fc_disc_stop_rports(struct fc_disc *disc ) 
{ 
  struct fc_lport *lport ;
  struct fc_rport_priv *rdata ;
  struct list_head *__ptr ;
  struct list_head  const  *__mptr ;
  struct list_head *________p1 ;
  struct list_head *_________p1 ;
  union __anonunion___u_300 __u ;
  int tmp ;
  struct list_head *__ptr___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head *________p1___0 ;
  struct list_head *_________p1___0 ;
  union __anonunion___u_302 __u___0 ;
  int tmp___0 ;

  {
#line 69
  lport = fc_disc_lport(disc);
#line 71
  mutex_lock_nested(& disc->disc_mutex, 0U);
#line 72
  __ptr = disc->rports.next;
#line 72
  __read_once_size((void const volatile   *)(& __ptr), (void *)(& __u.__c), 8);
#line 72
  _________p1 = __u.__val;
#line 72
  ________p1 = _________p1;
#line 72
  tmp = debug_lockdep_rcu_enabled();
#line 72
  __mptr = (struct list_head  const  *)________p1;
#line 72
  rdata = (struct fc_rport_priv *)__mptr + 0xfffffffffffffe28UL;
#line 72
  goto ldv_40936;
  ldv_40935: 
#line 73
  (*(lport->tt.rport_logoff))(rdata);
#line 72
  __ptr___0 = rdata->peers.next;
#line 72
  __read_once_size((void const volatile   *)(& __ptr___0), (void *)(& __u___0.__c),
                   8);
#line 72
  _________p1___0 = __u___0.__val;
#line 72
  ________p1___0 = _________p1___0;
#line 72
  tmp___0 = debug_lockdep_rcu_enabled();
#line 72
  __mptr___0 = (struct list_head  const  *)________p1___0;
#line 72
  rdata = (struct fc_rport_priv *)__mptr___0 + 0xfffffffffffffe28UL;
  ldv_40936: ;
#line 72
  if ((unsigned long )(& rdata->peers) != (unsigned long )(& disc->rports)) {
#line 74
    goto ldv_40935;
  } else {

  }
#line 74
  mutex_unlock(& disc->disc_mutex);
#line 75
  return;
}
}
#line 85 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
static void fc_disc_recv_rscn_req(struct fc_disc *disc , struct fc_frame *fp ) 
{ 
  struct fc_lport *lport ;
  struct fc_els_rscn *rp ;
  struct fc_els_rscn_page *pp ;
  struct fc_seq_els_data rjt_data ;
  unsigned int len ;
  int redisc ;
  enum fc_els_rscn_ev_qual ev_qual ;
  enum fc_els_rscn_addr_fmt fmt ;
  struct list_head disc_ports ;
  struct fc_disc_port *dp ;
  struct fc_disc_port *next ;
  struct fc_lport *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  __u16 tmp___2 ;
  void *tmp___3 ;
  u32 tmp___4 ;
  struct fc_lport *tmp___5 ;
  long tmp___6 ;
  void *tmp___7 ;
  struct fc_lport *tmp___8 ;
  long tmp___9 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct fc_lport *tmp___10 ;
  long tmp___11 ;
  struct fc_lport *tmp___12 ;
  long tmp___13 ;
  struct fc_lport *tmp___14 ;
  long tmp___15 ;

  {
#line 92
  redisc = 0;
#line 95
  disc_ports.next = & disc_ports;
#line 95
  disc_ports.prev = & disc_ports;
#line 98
  lport = fc_disc_lport(disc);
#line 100
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 4U) != 0U, 0L);
#line 100
  if (tmp___0 != 0L) {
#line 100
    tmp = fc_disc_lport(disc);
#line 100
    printk("\016host%u: disc: Received an RSCN event\n", (tmp->host)->host_no);
  } else {

  }
#line 103
  tmp___1 = fc_frame_payload_get((struct fc_frame  const  *)fp, 4UL);
#line 103
  rp = (struct fc_els_rscn *)tmp___1;
#line 104
  if ((unsigned long )rp == (unsigned long )((struct fc_els_rscn *)0)) {
#line 105
    goto reject;
  } else {

  }
#line 107
  if ((unsigned int )rp->rscn_page_len != 4U) {
#line 108
    goto reject;
  } else {

  }
#line 110
  tmp___2 = __fswab16((int )rp->rscn_plen);
#line 110
  len = (unsigned int )tmp___2;
#line 111
  if (len <= 3U) {
#line 112
    goto reject;
  } else {

  }
#line 114
  tmp___3 = fc_frame_payload_get((struct fc_frame  const  *)fp, (size_t )len);
#line 114
  rp = (struct fc_els_rscn *)tmp___3;
#line 115
  if ((unsigned long )rp == (unsigned long )((struct fc_els_rscn *)0)) {
#line 116
    goto reject;
  } else {

  }
#line 118
  len = len - 4U;
#line 119
  if ((len & 3U) != 0U) {
#line 120
    goto reject;
  } else {

  }
#line 122
  pp = (struct fc_els_rscn_page *)rp + 1U;
#line 122
  goto ldv_40961;
  ldv_40960: 
#line 123
  ev_qual = (enum fc_els_rscn_ev_qual )((int )pp->rscn_page_flags >> 2);
#line 124
  ev_qual = (enum fc_els_rscn_ev_qual )((unsigned int )ev_qual & 15U);
#line 125
  fmt = (enum fc_els_rscn_addr_fmt )pp->rscn_page_flags;
#line 126
  fmt = (enum fc_els_rscn_addr_fmt )((unsigned int )fmt & 3U);
#line 131
  switch ((unsigned int )fmt) {
  case 0U: 
#line 133
  tmp___6 = ldv__builtin_expect((fc_debug_logging & 4U) != 0U, 0L);
#line 133
  if (tmp___6 != 0L) {
#line 133
    tmp___4 = ntoh24((u8 const   *)(& pp->rscn_fid));
#line 133
    tmp___5 = fc_disc_lport(disc);
#line 133
    printk("\016host%u: disc: Port address format for port (%6.6x)\n", (tmp___5->host)->host_no,
           tmp___4);
  } else {

  }
#line 135
  tmp___7 = kzalloc(112UL, 208U);
#line 135
  dp = (struct fc_disc_port *)tmp___7;
#line 136
  if ((unsigned long )dp == (unsigned long )((struct fc_disc_port *)0)) {
#line 137
    redisc = 1;
#line 138
    goto ldv_40955;
  } else {

  }
#line 140
  dp->lp = lport;
#line 141
  dp->port_id = ntoh24((u8 const   *)(& pp->rscn_fid));
#line 142
  list_add_tail(& dp->peers, & disc_ports);
#line 143
  goto ldv_40955;
  case 1U: ;
  case 2U: ;
  case 3U: ;
  default: 
#line 148
  tmp___9 = ldv__builtin_expect((fc_debug_logging & 4U) != 0U, 0L);
#line 148
  if (tmp___9 != 0L) {
#line 148
    tmp___8 = fc_disc_lport(disc);
#line 148
    printk("\016host%u: disc: Address format is (%d)\n", (tmp___8->host)->host_no,
           (unsigned int )fmt);
  } else {

  }
#line 149
  redisc = 1;
#line 150
  goto ldv_40955;
  }
  ldv_40955: 
#line 122
  len = len - 4U;
#line 122
  pp = pp + 1;
  ldv_40961: ;
#line 122
  if (len != 0U) {
#line 124
    goto ldv_40960;
  } else {

  }
#line 153
  (*(lport->tt.seq_els_rsp_send))(fp, 2, (struct fc_seq_els_data *)0);
#line 161
  __mptr = (struct list_head  const  *)disc_ports.next;
#line 161
  dp = (struct fc_disc_port *)__mptr + 0xfffffffffffffff8UL;
#line 161
  __mptr___0 = (struct list_head  const  *)dp->peers.next;
#line 161
  next = (struct fc_disc_port *)__mptr___0 + 0xfffffffffffffff8UL;
#line 161
  goto ldv_40970;
  ldv_40969: 
#line 162
  list_del(& dp->peers);
#line 163
  if (redisc == 0) {
#line 164
    redisc = fc_disc_single(lport, dp);
  } else {

  }
#line 165
  kfree((void const   *)dp);
#line 161
  dp = next;
#line 161
  __mptr___1 = (struct list_head  const  *)next->peers.next;
#line 161
  next = (struct fc_disc_port *)__mptr___1 + 0xfffffffffffffff8UL;
  ldv_40970: ;
#line 161
  if ((unsigned long )(& dp->peers) != (unsigned long )(& disc_ports)) {
#line 163
    goto ldv_40969;
  } else {

  }

#line 167
  if (redisc != 0) {
#line 168
    tmp___11 = ldv__builtin_expect((fc_debug_logging & 4U) != 0U, 0L);
#line 168
    if (tmp___11 != 0L) {
#line 168
      tmp___10 = fc_disc_lport(disc);
#line 168
      printk("\016host%u: disc: RSCN received: rediscovering\n", (tmp___10->host)->host_no);
    } else {

    }
#line 169
    fc_disc_restart(disc);
  } else {
#line 171
    tmp___13 = ldv__builtin_expect((fc_debug_logging & 4U) != 0U, 0L);
#line 171
    if (tmp___13 != 0L) {
#line 171
      tmp___12 = fc_disc_lport(disc);
#line 171
      printk("\016host%u: disc: RSCN received: not rediscovering. redisc %d state %d in_prog %d\n",
             (tmp___12->host)->host_no, redisc, (unsigned int )lport->state, (int )disc->pending);
    } else {

    }
  }
#line 175
  fc_frame_free(fp);
#line 176
  return;
  reject: 
#line 178
  tmp___15 = ldv__builtin_expect((fc_debug_logging & 4U) != 0U, 0L);
#line 178
  if (tmp___15 != 0L) {
#line 178
    tmp___14 = fc_disc_lport(disc);
#line 178
    printk("\016host%u: disc: Received a bad RSCN frame\n", (tmp___14->host)->host_no);
  } else {

  }
#line 179
  rjt_data.reason = 3;
#line 180
  rjt_data.explan = 0;
#line 181
  (*(lport->tt.seq_els_rsp_send))(fp, 1, & rjt_data);
#line 182
  fc_frame_free(fp);
#line 183
  return;
}
}
#line 194 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
static void fc_disc_recv_req(struct fc_lport *lport , struct fc_frame *fp ) 
{ 
  u8 op ;
  struct fc_disc *disc ;
  struct fc_lport *tmp ;
  long tmp___0 ;

  {
#line 197
  disc = & lport->disc;
#line 199
  op = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 200
  switch ((int )op) {
  case 97: 
#line 202
  mutex_lock_nested(& disc->disc_mutex, 0U);
#line 203
  fc_disc_recv_rscn_req(disc, fp);
#line 204
  mutex_unlock(& disc->disc_mutex);
#line 205
  goto ldv_40979;
  default: 
#line 207
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 4U) != 0U, 0L);
#line 207
  if (tmp___0 != 0L) {
#line 207
    tmp = fc_disc_lport(disc);
#line 207
    printk("\016host%u: disc: Received an unsupported request, the opcode is (%x)\n",
           (tmp->host)->host_no, (int )op);
  } else {

  }
#line 209
  fc_frame_free(fp);
#line 210
  goto ldv_40979;
  }
  ldv_40979: ;
#line 213
  return;
}
}
#line 221 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
static void fc_disc_restart(struct fc_disc *disc ) 
{ 
  struct fc_lport *tmp ;
  long tmp___0 ;

  {
#line 223
  if ((unsigned long )disc->disc_callback == (unsigned long )((void (*)(struct fc_lport * ,
                                                                        enum fc_disc_event  ))0)) {
#line 224
    return;
  } else {

  }
#line 226
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 4U) != 0U, 0L);
#line 226
  if (tmp___0 != 0L) {
#line 226
    tmp = fc_disc_lport(disc);
#line 226
    printk("\016host%u: disc: Restarting discovery\n", (tmp->host)->host_no);
  } else {

  }
#line 228
  disc->requested = 1U;
#line 229
  if ((unsigned int )disc->pending != 0U) {
#line 230
    return;
  } else {

  }
#line 237
  disc->disc_id = (u16 )((int )((short )((unsigned int )disc->disc_id + 2U)) | 1);
#line 238
  disc->retry_count = 0U;
#line 239
  fc_disc_gpn_ft_req(disc);
#line 240
  return;
}
}
#line 247 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
static void fc_disc_start(void (*disc_callback)(struct fc_lport * , enum fc_disc_event  ) ,
                          struct fc_lport *lport ) 
{ 
  struct fc_disc *disc ;

  {
#line 251
  disc = & lport->disc;
#line 258
  mutex_lock_nested(& disc->disc_mutex, 0U);
#line 259
  disc->disc_callback = disc_callback;
#line 260
  fc_disc_restart(disc);
#line 261
  mutex_unlock(& disc->disc_mutex);
#line 262
  return;
}
}
#line 273 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
static void fc_disc_done(struct fc_disc *disc , enum fc_disc_event event ) 
{ 
  struct fc_lport *lport ;
  struct fc_lport *tmp ;
  struct fc_rport_priv *rdata ;
  struct fc_lport *tmp___0 ;
  long tmp___1 ;
  struct list_head *__ptr ;
  struct list_head  const  *__mptr ;
  struct list_head *________p1 ;
  struct list_head *_________p1 ;
  union __anonunion___u_304 __u ;
  int tmp___2 ;
  struct list_head *__ptr___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head *________p1___0 ;
  struct list_head *_________p1___0 ;
  union __anonunion___u_306 __u___0 ;
  int tmp___3 ;

  {
#line 275
  tmp = fc_disc_lport(disc);
#line 275
  lport = tmp;
#line 278
  tmp___1 = ldv__builtin_expect((fc_debug_logging & 4U) != 0U, 0L);
#line 278
  if (tmp___1 != 0L) {
#line 278
    tmp___0 = fc_disc_lport(disc);
#line 278
    printk("\016host%u: disc: Discovery complete\n", (tmp___0->host)->host_no);
  } else {

  }
#line 280
  disc->pending = 0U;
#line 281
  if ((unsigned int )disc->requested != 0U) {
#line 282
    fc_disc_restart(disc);
#line 283
    return;
  } else {

  }
#line 292
  __ptr = disc->rports.next;
#line 292
  __read_once_size((void const volatile   *)(& __ptr), (void *)(& __u.__c), 8);
#line 292
  _________p1 = __u.__val;
#line 292
  ________p1 = _________p1;
#line 292
  tmp___2 = debug_lockdep_rcu_enabled();
#line 292
  __mptr = (struct list_head  const  *)________p1;
#line 292
  rdata = (struct fc_rport_priv *)__mptr + 0xfffffffffffffe28UL;
#line 292
  goto ldv_41027;
  ldv_41026: ;
#line 293
  if ((unsigned int )rdata->disc_id == 0U) {
#line 294
    goto ldv_41025;
  } else {

  }
#line 295
  if ((int )rdata->disc_id == (int )disc->disc_id) {
#line 296
    (*(lport->tt.rport_login))(rdata);
  } else {
#line 298
    (*(lport->tt.rport_logoff))(rdata);
  }
  ldv_41025: 
#line 292
  __ptr___0 = rdata->peers.next;
#line 292
  __read_once_size((void const volatile   *)(& __ptr___0), (void *)(& __u___0.__c),
                   8);
#line 292
  _________p1___0 = __u___0.__val;
#line 292
  ________p1___0 = _________p1___0;
#line 292
  tmp___3 = debug_lockdep_rcu_enabled();
#line 292
  __mptr___0 = (struct list_head  const  *)________p1___0;
#line 292
  rdata = (struct fc_rport_priv *)__mptr___0 + 0xfffffffffffffe28UL;
  ldv_41027: ;
#line 292
  if ((unsigned long )(& rdata->peers) != (unsigned long )(& disc->rports)) {
#line 294
    goto ldv_41026;
  } else {

  }
#line 301
  mutex_unlock(& disc->disc_mutex);
#line 302
  (*(disc->disc_callback))(lport, event);
#line 303
  mutex_lock_nested(& disc->disc_mutex, 0U);
#line 304
  return;
}
}
#line 311 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
static void fc_disc_error(struct fc_disc *disc , struct fc_frame *fp ) 
{ 
  struct fc_lport *lport ;
  struct fc_lport *tmp ;
  unsigned long delay ;
  long tmp___0 ;
  struct fc_lport *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 313
  tmp = fc_disc_lport(disc);
#line 313
  lport = tmp;
#line 314
  delay = 0UL;
#line 316
  tmp___2 = ldv__builtin_expect((fc_debug_logging & 4U) != 0U, 0L);
#line 316
  if (tmp___2 != 0L) {
#line 316
    tmp___0 = PTR_ERR((void const   *)fp);
#line 316
    tmp___1 = fc_disc_lport(disc);
#line 316
    printk("\016host%u: disc: Error %ld, retries %d/%d\n", (tmp___1->host)->host_no,
           tmp___0, (int )disc->retry_count, 3);
  } else {

  }
#line 320
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 320
    goto _L;
  } else {
#line 320
    tmp___4 = PTR_ERR((void const   *)fp);
#line 320
    if (tmp___4 == -1L) {
      _L: /* CIL Label */ 
#line 325
      if ((unsigned int )disc->retry_count <= 2U) {
#line 327
        if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 328
          delay = msecs_to_jiffies(500U);
        } else {
#line 330
          delay = msecs_to_jiffies(lport->e_d_tov);
#line 333
          if ((unsigned int )disc->retry_count == 0U) {
#line 334
            delay = delay / 4UL;
          } else {

          }
        }
#line 336
        disc->retry_count = (unsigned char )((int )disc->retry_count + 1);
#line 337
        schedule_delayed_work(& disc->disc_work, delay);
      } else {
#line 339
        fc_disc_done(disc, 2);
      }
    } else {
#line 340
      tmp___3 = PTR_ERR((void const   *)fp);
#line 340
      if (tmp___3 == -2L) {
#line 346
        disc->pending = 0U;
      } else {

      }
    }
  }
#line 347
  return;
}
}
#line 357 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
static void fc_disc_gpn_ft_req(struct fc_disc *disc ) 
{ 
  struct fc_frame *fp ;
  struct fc_lport *lport ;
  struct fc_lport *tmp ;
  int __ret_warn_on ;
  int tmp___0 ;
  long tmp___1 ;
  struct fc_seq *tmp___2 ;

  {
#line 360
  tmp = fc_disc_lport(disc);
#line 360
  lport = tmp;
#line 362
  tmp___0 = fc_lport_test_ready(lport);
#line 362
  __ret_warn_on = tmp___0 == 0;
#line 362
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 362
  if (tmp___1 != 0L) {
#line 362
    warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c",
                       362);
  } else {

  }
#line 362
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 364
  disc->pending = 1U;
#line 365
  disc->requested = 0U;
#line 367
  disc->buf_len = 0U;
#line 368
  disc->seq_count = 0U;
#line 369
  fp = fc_frame_alloc(lport, 20UL);
#line 372
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 373
    goto err;
  } else {

  }
#line 375
  tmp___2 = (*(lport->tt.elsct_send))(lport, 0U, fp, 370U, & fc_disc_gpn_ft_resp,
                                      (void *)disc, lport->r_a_tov * 3U);
#line 375
  if ((unsigned long )tmp___2 != (unsigned long )((struct fc_seq *)0)) {
#line 379
    return;
  } else {

  }
  err: 
#line 381
  fc_disc_error(disc, (struct fc_frame *)0);
#line 382
  return;
}
}
#line 392 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
static int fc_disc_gpn_ft_parse(struct fc_disc *disc , void *buf , size_t len ) 
{ 
  struct fc_lport *lport ;
  struct fc_gpn_ft_resp *np ;
  char *bp ;
  size_t plen ;
  size_t tlen ;
  int error ;
  struct fc_rport_identifiers ids ;
  struct fc_rport_priv *rdata ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;
  int __ret_warn_on___1 ;
  long tmp___1 ;
  __u64 tmp___2 ;
  struct fc_lport *tmp___3 ;
  long tmp___4 ;

  {
#line 399
  error = 0;
#line 403
  lport = fc_disc_lport(disc);
#line 404
  disc->seq_count = (unsigned short )((int )disc->seq_count + 1);
#line 409
  bp = (char *)buf;
#line 410
  plen = len;
#line 411
  np = (struct fc_gpn_ft_resp *)bp;
#line 412
  tlen = (size_t )disc->buf_len;
#line 413
  disc->buf_len = 0U;
#line 414
  if (tlen != 0UL) {
#line 415
    __ret_warn_on = tlen > 15UL;
#line 415
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 415
    if (tmp != 0L) {
#line 415
      warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c",
                         415);
    } else {

    }
#line 415
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 416
    plen = 16UL - tlen;
#line 417
    __ret_warn_on___0 = plen == 0UL;
#line 417
    tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 417
    if (tmp___0 != 0L) {
#line 417
      warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c",
                         417);
    } else {

    }
#line 417
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 418
    __ret_warn_on___1 = plen > 15UL;
#line 418
    tmp___1 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
#line 418
    if (tmp___1 != 0L) {
#line 418
      warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c",
                         418);
    } else {

    }
#line 418
    ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
#line 419
    if (plen > len) {
#line 420
      plen = len;
    } else {

    }
#line 421
    np = & disc->partial_buf;
#line 422
    memcpy((void *)np + tlen, (void const   *)bp, plen);
#line 428
    bp = bp + - tlen;
#line 429
    len = len + tlen;
#line 430
    plen = plen + tlen;
#line 431
    disc->buf_len = (unsigned char )plen;
#line 432
    if (plen == 16UL) {
#line 433
      disc->buf_len = 0U;
    } else {

    }
  } else {

  }
#line 443
  goto ldv_41064;
  ldv_41063: 
#line 444
  ids.port_id = ntoh24((u8 const   *)(& np->fp_fid));
#line 445
  tmp___2 = __fswab64(np->fp_wwpn);
#line 445
  ids.port_name = tmp___2;
#line 447
  if (ids.port_id != lport->port_id && ids.port_name != lport->wwpn) {
#line 449
    rdata = (*(lport->tt.rport_create))(lport, ids.port_id);
#line 450
    if ((unsigned long )rdata != (unsigned long )((struct fc_rport_priv *)0)) {
#line 451
      rdata->ids.port_name = ids.port_name;
#line 452
      rdata->disc_id = disc->disc_id;
    } else {
#line 454
      printk("\flibfc: Failed to allocate memory for the newly discovered port (%6.6x)\n",
             ids.port_id);
#line 457
      error = -12;
    }
  } else {

  }
#line 461
  if ((int )((signed char )np->fp_flags) < 0) {
#line 462
    fc_disc_done(disc, 1);
#line 463
    len = 0UL;
#line 464
    goto ldv_41062;
  } else {

  }
#line 466
  len = len - 16UL;
#line 467
  bp = bp + 16UL;
#line 468
  np = (struct fc_gpn_ft_resp *)bp;
#line 469
  plen = len;
  ldv_41064: ;
#line 443
  if (plen > 15UL) {
#line 445
    goto ldv_41063;
  } else {

  }
  ldv_41062: ;
#line 475
  if ((error == 0 && len != 0UL) && len <= 15UL) {
#line 476
    if ((unsigned long )(& disc->partial_buf) != (unsigned long )np) {
#line 477
      tmp___4 = ldv__builtin_expect((fc_debug_logging & 4U) != 0U, 0L);
#line 477
      if (tmp___4 != 0L) {
#line 477
        tmp___3 = fc_disc_lport(disc);
#line 477
        printk("\016host%u: disc: Partial buffer remains for discovery\n", (tmp___3->host)->host_no);
      } else {

      }
#line 479
      memcpy((void *)(& disc->partial_buf), (void const   *)np, len);
    } else {

    }
#line 481
    disc->buf_len = (unsigned char )len;
  } else {

  }
#line 483
  return (error);
}
}
#line 490 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
static void fc_disc_timeout(struct work_struct *work ) 
{ 
  struct fc_disc *disc ;
  struct work_struct  const  *__mptr ;

  {
#line 492
  __mptr = (struct work_struct  const  *)work;
#line 492
  disc = (struct fc_disc *)__mptr + 0xffffffffffffff28UL;
#line 495
  mutex_lock_nested(& disc->disc_mutex, 0U);
#line 496
  fc_disc_gpn_ft_req(disc);
#line 497
  mutex_unlock(& disc->disc_mutex);
#line 498
  return;
}
}
#line 509 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
static void fc_disc_gpn_ft_resp(struct fc_seq *sp , struct fc_frame *fp , void *disc_arg ) 
{ 
  struct fc_disc *disc ;
  struct fc_ct_hdr *cp ;
  struct fc_frame_header *fh ;
  enum fc_disc_event event ;
  unsigned int seq_cnt ;
  unsigned int len ;
  int error ;
  struct fc_lport *tmp ;
  long tmp___0 ;
  bool tmp___1 ;
  int __ret_warn_on ;
  int tmp___2 ;
  long tmp___3 ;
  __u16 tmp___4 ;
  void *tmp___5 ;
  struct fc_lport *tmp___6 ;
  long tmp___7 ;
  struct fc_lport *tmp___8 ;
  long tmp___9 ;
  __u16 tmp___10 ;
  struct fc_lport *tmp___11 ;
  long tmp___12 ;
  __u16 tmp___13 ;
  __u16 tmp___14 ;
  struct fc_lport *tmp___15 ;
  long tmp___16 ;

  {
#line 512
  disc = (struct fc_disc *)disc_arg;
#line 515
  event = 0;
#line 518
  error = 0;
#line 520
  mutex_lock_nested(& disc->disc_mutex, 0U);
#line 521
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 4U) != 0U, 0L);
#line 521
  if (tmp___0 != 0L) {
#line 521
    tmp = fc_disc_lport(disc);
#line 521
    printk("\016host%u: disc: Received a GPN_FT response\n", (tmp->host)->host_no);
  } else {

  }
#line 523
  tmp___1 = IS_ERR((void const   *)fp);
#line 523
  if ((int )tmp___1) {
#line 524
    fc_disc_error(disc, fp);
#line 525
    mutex_unlock(& disc->disc_mutex);
#line 526
    return;
  } else {

  }
#line 529
  tmp___2 = fc_frame_is_linear(fp);
#line 529
  __ret_warn_on = tmp___2 == 0;
#line 529
  tmp___3 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 529
  if (tmp___3 != 0L) {
#line 529
    warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c",
                       529);
  } else {

  }
#line 529
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 530
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 531
  len = fp->skb.len - 24U;
#line 532
  tmp___4 = __fswab16((int )fh->fh_seq_cnt);
#line 532
  seq_cnt = (unsigned int )tmp___4;
#line 533
  if (((unsigned int )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_sof == 46U && seq_cnt == 0U) && (unsigned int )disc->seq_count == 0U) {
#line 534
    tmp___5 = fc_frame_payload_get((struct fc_frame  const  *)fp, 16UL);
#line 534
    cp = (struct fc_ct_hdr *)tmp___5;
#line 535
    if ((unsigned long )cp == (unsigned long )((struct fc_ct_hdr *)0)) {
#line 536
      tmp___7 = ldv__builtin_expect((fc_debug_logging & 4U) != 0U, 0L);
#line 536
      if (tmp___7 != 0L) {
#line 536
        tmp___6 = fc_disc_lport(disc);
#line 536
        printk("\016host%u: disc: GPN_FT response too short, len %d\n", (tmp___6->host)->host_no,
               fp->skb.len);
      } else {

      }
#line 538
      event = 2;
    } else {
#line 539
      tmp___14 = __fswab16((int )cp->ct_cmd);
#line 539
      if ((unsigned int )tmp___14 == 32770U) {
#line 542
        len = len - 16U;
#line 543
        error = fc_disc_gpn_ft_parse(disc, (void *)cp + 1U, (size_t )len);
      } else {
#line 544
        tmp___13 = __fswab16((int )cp->ct_cmd);
#line 544
        if ((unsigned int )tmp___13 == 32769U) {
#line 545
          tmp___9 = ldv__builtin_expect((fc_debug_logging & 4U) != 0U, 0L);
#line 545
          if (tmp___9 != 0L) {
#line 545
            tmp___8 = fc_disc_lport(disc);
#line 545
            printk("\016host%u: disc: GPN_FT rejected reason %x exp %x (check zoning)\n",
                   (tmp___8->host)->host_no, (int )cp->ct_reason, (int )cp->ct_explan);
          } else {

          }
#line 548
          event = 2;
#line 549
          if ((unsigned int )cp->ct_reason == 9U && (unsigned int )cp->ct_explan == 7U) {
#line 551
            event = 1;
          } else {

          }
        } else {
#line 553
          tmp___12 = ldv__builtin_expect((fc_debug_logging & 4U) != 0U, 0L);
#line 553
          if (tmp___12 != 0L) {
#line 553
            tmp___10 = __fswab16((int )cp->ct_cmd);
#line 553
            tmp___11 = fc_disc_lport(disc);
#line 553
            printk("\016host%u: disc: GPN_FT unexpected response code %x\n", (tmp___11->host)->host_no,
                   (int )tmp___10);
          } else {

          }
#line 555
          event = 2;
        }
      }
    }
  } else
#line 557
  if ((unsigned int )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_sof == 54U && (unsigned int )disc->seq_count == seq_cnt) {
#line 558
    error = fc_disc_gpn_ft_parse(disc, (void *)fh + 1U, (size_t )len);
  } else {
#line 560
    tmp___16 = ldv__builtin_expect((fc_debug_logging & 4U) != 0U, 0L);
#line 560
    if (tmp___16 != 0L) {
#line 560
      tmp___15 = fc_disc_lport(disc);
#line 560
      printk("\016host%u: disc: GPN_FT unexpected frame - out of sequence? seq_cnt %x expected %x sof %x eof %x\n",
             (tmp___15->host)->host_no, seq_cnt, (int )disc->seq_count, (int )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_sof,
             (int )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_eof);
    } else {

    }
#line 563
    event = 2;
  }
#line 565
  if (error != 0) {
#line 566
    fc_disc_error(disc, fp);
  } else
#line 567
  if ((unsigned int )event != 0U) {
#line 568
    fc_disc_done(disc, event);
  } else {

  }
#line 569
  fc_frame_free(fp);
#line 570
  mutex_unlock(& disc->disc_mutex);
#line 571
  return;
}
}
#line 581 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
static void fc_disc_gpn_id_resp(struct fc_seq *sp , struct fc_frame *fp , void *rdata_arg ) 
{ 
  struct fc_rport_priv *rdata ;
  struct fc_rport_priv *new_rdata ;
  struct fc_lport *lport ;
  struct fc_disc *disc ;
  struct fc_ct_hdr *cp ;
  struct fc_ns_gid_pn *pn ;
  u64 port_name ;
  long tmp ;
  bool tmp___0 ;
  void *tmp___1 ;
  struct fc_lport *tmp___2 ;
  long tmp___3 ;
  struct fc_lport *tmp___4 ;
  long tmp___5 ;
  __u16 tmp___6 ;
  struct fc_lport *tmp___7 ;
  long tmp___8 ;
  __u16 tmp___9 ;
  __u16 tmp___10 ;

  {
#line 584
  rdata = (struct fc_rport_priv *)rdata_arg;
#line 592
  lport = rdata->local_port;
#line 593
  disc = & lport->disc;
#line 595
  mutex_lock_nested(& disc->disc_mutex, 0U);
#line 596
  tmp = PTR_ERR((void const   *)fp);
#line 596
  if (tmp == -2L) {
#line 597
    goto out;
  } else {

  }
#line 598
  tmp___0 = IS_ERR((void const   *)fp);
#line 598
  if ((int )tmp___0) {
#line 599
    goto redisc;
  } else {

  }
#line 601
  tmp___1 = fc_frame_payload_get((struct fc_frame  const  *)fp, 16UL);
#line 601
  cp = (struct fc_ct_hdr *)tmp___1;
#line 602
  if ((unsigned long )cp == (unsigned long )((struct fc_ct_hdr *)0)) {
#line 603
    goto redisc;
  } else {

  }
#line 604
  tmp___10 = __fswab16((int )cp->ct_cmd);
#line 604
  if ((unsigned int )tmp___10 == 32770U) {
#line 605
    if (fp->skb.len <= 47U) {
#line 607
      goto redisc;
    } else {

    }
#line 608
    pn = (struct fc_ns_gid_pn *)cp + 1U;
#line 609
    port_name = get_unaligned_be64((void const   *)(& pn->fn_wwpn));
#line 610
    if (rdata->ids.port_name == 0xffffffffffffffffULL) {
#line 611
      rdata->ids.port_name = port_name;
    } else
#line 612
    if (rdata->ids.port_name != port_name) {
#line 613
      tmp___3 = ldv__builtin_expect((fc_debug_logging & 4U) != 0U, 0L);
#line 613
      if (tmp___3 != 0L) {
#line 613
        tmp___2 = fc_disc_lport(disc);
#line 613
        printk("\016host%u: disc: GPN_ID accepted.  WWPN changed. Port-id %6.6x wwpn %16.16llx\n",
               (tmp___2->host)->host_no, rdata->ids.port_id, port_name);
      } else {

      }
#line 616
      (*(lport->tt.rport_logoff))(rdata);
#line 618
      new_rdata = (*(lport->tt.rport_create))(lport, rdata->ids.port_id);
#line 620
      if ((unsigned long )new_rdata != (unsigned long )((struct fc_rport_priv *)0)) {
#line 621
        new_rdata->disc_id = disc->disc_id;
#line 622
        (*(lport->tt.rport_login))(new_rdata);
      } else {

      }
#line 624
      goto out;
    } else {

    }
#line 626
    rdata->disc_id = disc->disc_id;
#line 627
    (*(lport->tt.rport_login))(rdata);
  } else {
#line 628
    tmp___9 = __fswab16((int )cp->ct_cmd);
#line 628
    if ((unsigned int )tmp___9 == 32769U) {
#line 629
      tmp___5 = ldv__builtin_expect((fc_debug_logging & 4U) != 0U, 0L);
#line 629
      if (tmp___5 != 0L) {
#line 629
        tmp___4 = fc_disc_lport(disc);
#line 629
        printk("\016host%u: disc: GPN_ID rejected reason %x exp %x\n", (tmp___4->host)->host_no,
               (int )cp->ct_reason, (int )cp->ct_explan);
      } else {

      }
#line 631
      (*(lport->tt.rport_logoff))(rdata);
    } else {
#line 633
      tmp___8 = ldv__builtin_expect((fc_debug_logging & 4U) != 0U, 0L);
#line 633
      if (tmp___8 != 0L) {
#line 633
        tmp___6 = __fswab16((int )cp->ct_cmd);
#line 633
        tmp___7 = fc_disc_lport(disc);
#line 633
        printk("\016host%u: disc: GPN_ID unexpected response code %x\n", (tmp___7->host)->host_no,
               (int )tmp___6);
      } else {

      }
      redisc: 
#line 636
      fc_disc_restart(disc);
    }
  }
  out: 
#line 639
  mutex_unlock(& disc->disc_mutex);
#line 640
  kref_put(& rdata->kref, lport->tt.rport_destroy);
#line 641
  return;
}
}
#line 652 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
static int fc_disc_gpn_id_req(struct fc_lport *lport , struct fc_rport_priv *rdata ) 
{ 
  struct fc_frame *fp ;
  struct fc_seq *tmp ;

  {
#line 657
  fp = fc_frame_alloc(lport, 20UL);
#line 659
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 660
    return (-12);
  } else {

  }
#line 661
  tmp = (*(lport->tt.elsct_send))(lport, rdata->ids.port_id, fp, 274U, & fc_disc_gpn_id_resp,
                                  (void *)rdata, lport->r_a_tov * 3U);
#line 661
  if ((unsigned long )tmp == (unsigned long )((struct fc_seq *)0)) {
#line 664
    return (-12);
  } else {

  }
#line 665
  kref_get(& rdata->kref);
#line 666
  return (0);
}
}
#line 677 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
static int fc_disc_single(struct fc_lport *lport , struct fc_disc_port *dp ) 
{ 
  struct fc_rport_priv *rdata ;
  int tmp ;

  {
#line 681
  rdata = (*(lport->tt.rport_create))(lport, dp->port_id);
#line 682
  if ((unsigned long )rdata == (unsigned long )((struct fc_rport_priv *)0)) {
#line 683
    return (-12);
  } else {

  }
#line 684
  rdata->disc_id = 0U;
#line 685
  tmp = fc_disc_gpn_id_req(lport, rdata);
#line 685
  return (tmp);
}
}
#line 692 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
static void fc_disc_stop(struct fc_lport *lport ) 
{ 
  struct fc_disc *disc ;

  {
#line 694
  disc = & lport->disc;
#line 696
  if ((unsigned int )disc->pending != 0U) {
#line 697
    ldv_cancel_delayed_work_sync_88(& disc->disc_work);
  } else {

  }
#line 698
  fc_disc_stop_rports(disc);
#line 699
  return;
}
}
#line 708 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
static void fc_disc_stop_final(struct fc_lport *lport ) 
{ 


  {
#line 710
  fc_disc_stop(lport);
#line 711
  (*(lport->tt.rport_flush_queue))();
#line 712
  return;
}
}
#line 719 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
void fc_disc_config(struct fc_lport *lport , void *priv ) 
{ 
  struct fc_disc *disc ;

  {
#line 721
  disc = & lport->disc;
#line 723
  if ((unsigned long )lport->tt.disc_start == (unsigned long )((void (*)(void (*)(struct fc_lport * ,
                                                                                  enum fc_disc_event  ) ,
                                                                         struct fc_lport * ))0)) {
#line 724
    lport->tt.disc_start = & fc_disc_start;
  } else {

  }
#line 726
  if ((unsigned long )lport->tt.disc_stop == (unsigned long )((void (*)(struct fc_lport * ))0)) {
#line 727
    lport->tt.disc_stop = & fc_disc_stop;
  } else {

  }
#line 729
  if ((unsigned long )lport->tt.disc_stop_final == (unsigned long )((void (*)(struct fc_lport * ))0)) {
#line 730
    lport->tt.disc_stop_final = & fc_disc_stop_final;
  } else {

  }
#line 732
  if ((unsigned long )lport->tt.disc_recv_req == (unsigned long )((void (*)(struct fc_lport * ,
                                                                            struct fc_frame * ))0)) {
#line 733
    lport->tt.disc_recv_req = & fc_disc_recv_req;
  } else {

  }
#line 735
  disc = & lport->disc;
#line 737
  disc->priv = priv;
#line 738
  return;
}
}
#line 739 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
static char const   __kstrtab_fc_disc_config[15U]  = 
#line 739
  {      'f',      'c',      '_',      'd', 
        'i',      's',      'c',      '_', 
        'c',      'o',      'n',      'f', 
        'i',      'g',      '\000'};
#line 739
struct kernel_symbol  const  __ksymtab_fc_disc_config ;
#line 739 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
struct kernel_symbol  const  __ksymtab_fc_disc_config  =    {(unsigned long )(& fc_disc_config), (char const   *)(& __kstrtab_fc_disc_config)};
#line 745 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
void fc_disc_init(struct fc_lport *lport ) 
{ 
  struct fc_disc *disc ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;

  {
#line 747
  disc = & lport->disc;
#line 749
  __init_work(& disc->disc_work.work, 0);
#line 749
  __constr_expr_0.counter = 137438953408L;
#line 749
  disc->disc_work.work.data = __constr_expr_0;
#line 749
  lockdep_init_map(& disc->disc_work.work.lockdep_map, "(&(&disc->disc_work)->work)",
                   & __key, 0);
#line 749
  INIT_LIST_HEAD(& disc->disc_work.work.entry);
#line 749
  disc->disc_work.work.func = & fc_disc_timeout;
#line 749
  init_timer_key(& disc->disc_work.timer, 2097152U, "(&(&disc->disc_work)->timer)",
                 & __key___0);
#line 749
  disc->disc_work.timer.function = & delayed_work_timer_fn;
#line 749
  disc->disc_work.timer.data = (unsigned long )(& disc->disc_work);
#line 750
  __mutex_init(& disc->disc_mutex, "&disc->disc_mutex", & __key___1);
#line 751
  INIT_LIST_HEAD(& disc->rports);
#line 752
  return;
}
}
#line 753 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
static char const   __kstrtab_fc_disc_init[13U]  = 
#line 753
  {      'f',      'c',      '_',      'd', 
        'i',      's',      'c',      '_', 
        'i',      'n',      'i',      't', 
        '\000'};
#line 753
struct kernel_symbol  const  __ksymtab_fc_disc_init ;
#line 753 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.c"
struct kernel_symbol  const  __ksymtab_fc_disc_init  =    {(unsigned long )(& fc_disc_init), (char const   *)(& __kstrtab_fc_disc_init)};
#line 152 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
void call_and_disable_work_1(struct work_struct *work ) 
{ 


  {
#line 155
  if ((ldv_work_1_0 == 2 || ldv_work_1_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_0) {
#line 157
    fc_disc_timeout(work);
#line 158
    ldv_work_1_0 = 1;
#line 159
    return;
  } else {

  }
#line 161
  if ((ldv_work_1_1 == 2 || ldv_work_1_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_1) {
#line 163
    fc_disc_timeout(work);
#line 164
    ldv_work_1_1 = 1;
#line 165
    return;
  } else {

  }
#line 167
  if ((ldv_work_1_2 == 2 || ldv_work_1_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_2) {
#line 169
    fc_disc_timeout(work);
#line 170
    ldv_work_1_2 = 1;
#line 171
    return;
  } else {

  }
#line 173
  if ((ldv_work_1_3 == 2 || ldv_work_1_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_3) {
#line 175
    fc_disc_timeout(work);
#line 176
    ldv_work_1_3 = 1;
#line 177
    return;
  } else {

  }
#line 179
  return;
}
}
#line 182 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
void call_and_disable_all_1(int state ) 
{ 


  {
#line 184
  if (ldv_work_1_0 == state) {
#line 185
    call_and_disable_work_1(ldv_work_struct_1_0);
  } else {

  }
#line 186
  if (ldv_work_1_1 == state) {
#line 187
    call_and_disable_work_1(ldv_work_struct_1_1);
  } else {

  }
#line 188
  if (ldv_work_1_2 == state) {
#line 189
    call_and_disable_work_1(ldv_work_struct_1_2);
  } else {

  }
#line 190
  if (ldv_work_1_3 == state) {
#line 191
    call_and_disable_work_1(ldv_work_struct_1_3);
  } else {

  }
#line 192
  return;
}
}
#line 195 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
void activate_work_1(struct work_struct *work , int state ) 
{ 


  {
#line 196
  if (ldv_work_1_0 == 0) {
#line 197
    ldv_work_struct_1_0 = work;
#line 198
    ldv_work_1_0 = state;
#line 199
    return;
  } else {

  }
#line 202
  if (ldv_work_1_1 == 0) {
#line 203
    ldv_work_struct_1_1 = work;
#line 204
    ldv_work_1_1 = state;
#line 205
    return;
  } else {

  }
#line 208
  if (ldv_work_1_2 == 0) {
#line 209
    ldv_work_struct_1_2 = work;
#line 210
    ldv_work_1_2 = state;
#line 211
    return;
  } else {

  }
#line 214
  if (ldv_work_1_3 == 0) {
#line 215
    ldv_work_struct_1_3 = work;
#line 216
    ldv_work_1_3 = state;
#line 217
    return;
  } else {

  }
#line 219
  return;
}
}
#line 222 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
void disable_work_1(struct work_struct *work ) 
{ 


  {
#line 224
  if ((ldv_work_1_0 == 3 || ldv_work_1_0 == 2) && (unsigned long )ldv_work_struct_1_0 == (unsigned long )work) {
#line 226
    ldv_work_1_0 = 1;
  } else {

  }
#line 228
  if ((ldv_work_1_1 == 3 || ldv_work_1_1 == 2) && (unsigned long )ldv_work_struct_1_1 == (unsigned long )work) {
#line 230
    ldv_work_1_1 = 1;
  } else {

  }
#line 232
  if ((ldv_work_1_2 == 3 || ldv_work_1_2 == 2) && (unsigned long )ldv_work_struct_1_2 == (unsigned long )work) {
#line 234
    ldv_work_1_2 = 1;
  } else {

  }
#line 236
  if ((ldv_work_1_3 == 3 || ldv_work_1_3 == 2) && (unsigned long )ldv_work_struct_1_3 == (unsigned long )work) {
#line 238
    ldv_work_1_3 = 1;
  } else {

  }
#line 239
  return;
}
}
#line 243 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
void work_init_1(void) 
{ 


  {
#line 244
  ldv_work_1_0 = 0;
#line 245
  ldv_work_1_1 = 0;
#line 246
  ldv_work_1_2 = 0;
#line 247
  ldv_work_1_3 = 0;
#line 248
  return;
}
}
#line 251 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
void invoke_work_1(void) 
{ 
  int tmp ;

  {
#line 253
  tmp = __VERIFIER_nondet_int();
#line 253
  switch (tmp) {
  case 0: ;
#line 255
  if (ldv_work_1_0 == 2 || ldv_work_1_0 == 3) {
#line 256
    ldv_work_1_0 = 4;
#line 257
    fc_disc_timeout(ldv_work_struct_1_0);
#line 258
    ldv_work_1_0 = 1;
  } else {

  }
#line 261
  goto ldv_41168;
  case 1: ;
#line 263
  if (ldv_work_1_1 == 2 || ldv_work_1_1 == 3) {
#line 264
    ldv_work_1_1 = 4;
#line 265
    fc_disc_timeout(ldv_work_struct_1_0);
#line 266
    ldv_work_1_1 = 1;
  } else {

  }
#line 269
  goto ldv_41168;
  case 2: ;
#line 271
  if (ldv_work_1_2 == 2 || ldv_work_1_2 == 3) {
#line 272
    ldv_work_1_2 = 4;
#line 273
    fc_disc_timeout(ldv_work_struct_1_0);
#line 274
    ldv_work_1_2 = 1;
  } else {

  }
#line 277
  goto ldv_41168;
  case 3: ;
#line 279
  if (ldv_work_1_3 == 2 || ldv_work_1_3 == 3) {
#line 280
    ldv_work_1_3 = 4;
#line 281
    fc_disc_timeout(ldv_work_struct_1_0);
#line 282
    ldv_work_1_3 = 1;
  } else {

  }
#line 285
  goto ldv_41168;
  default: 
#line 286
  ldv_stop();
  }
  ldv_41168: ;
#line 288
  return;
}
}
#line 297 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
__inline static long PTR_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
#line 300
  tmp = ldv_ptr_err(ptr);
#line 300
  return (tmp);
}
}
#line 303 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
__inline static bool IS_ERR(void const   *ptr ) 
{ 
  bool tmp ;

  {
#line 306
  tmp = ldv_is_err(ptr);
#line 306
  return (tmp);
}
}
#line 404 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
bool ldv_queue_work_on_61(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 408
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 408
  ldv_func_res = tmp;
#line 410
  activate_work_3(ldv_func_arg3, 2);
#line 412
  return (ldv_func_res);
}
}
#line 415 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
bool ldv_queue_delayed_work_on_62(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 419
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 419
  ldv_func_res = tmp;
#line 421
  activate_work_3(& ldv_func_arg3->work, 2);
#line 423
  return (ldv_func_res);
}
}
#line 426 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
bool ldv_queue_work_on_63(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  bool tmp ;

  {
#line 430
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 430
  ldv_func_res = tmp;
#line 432
  activate_work_3(ldv_func_arg3, 2);
#line 434
  return (ldv_func_res);
}
}
#line 437 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
void ldv_flush_workqueue_64(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 440
  flush_workqueue(ldv_func_arg1);
#line 442
  call_and_disable_all_3(2);
#line 443
  return;
}
}
#line 445 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
bool ldv_queue_delayed_work_on_65(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
#line 449
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 449
  ldv_func_res = tmp;
#line 451
  activate_work_3(& ldv_func_arg3->work, 2);
#line 453
  return (ldv_func_res);
}
}
#line 491 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
void *ldv_kmem_cache_alloc_71(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 494
  ldv_check_alloc_flags(flags);
#line 495
  tmp = ldv_undef_ptr();
#line 495
  return (tmp);
}
}
#line 498 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 501
  ldv_check_alloc_flags(flags);
#line 502
  tmp = ldv_undef_ptr();
#line 502
  return (tmp);
}
}
#line 533 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
int ldv_pskb_expand_head_77(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 536
  ldv_check_alloc_flags(flags);
#line 537
  tmp = ldv_undef_ptr();
#line 537
  return ((int )((long )tmp));
}
}
#line 547 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
struct sk_buff *ldv_skb_clone_79(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 550
  ldv_check_alloc_flags(flags);
#line 551
  tmp = ldv_undef_ptr();
#line 551
  return ((struct sk_buff *)tmp);
}
}
#line 561 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
struct sk_buff *ldv_skb_copy_81(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 564
  ldv_check_alloc_flags(flags);
#line 565
  tmp = ldv_undef_ptr();
#line 565
  return ((struct sk_buff *)tmp);
}
}
#line 568 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_82(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 571
  ldv_check_alloc_flags(flags);
#line 572
  tmp = ldv_undef_ptr();
#line 572
  return ((struct sk_buff *)tmp);
}
}
#line 575 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_83(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 578
  ldv_check_alloc_flags(flags);
#line 579
  tmp = ldv_undef_ptr();
#line 579
  return ((struct sk_buff *)tmp);
}
}
#line 582 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_84(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 585
  ldv_check_alloc_flags(flags);
#line 586
  tmp = ldv_undef_ptr();
#line 586
  return ((struct sk_buff *)tmp);
}
}
#line 589 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
int ldv_pskb_expand_head_85(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 592
  ldv_check_alloc_flags(flags);
#line 593
  tmp = ldv_undef_ptr();
#line 593
  return ((int )((long )tmp));
}
}
#line 596 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
int ldv_pskb_expand_head_86(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 599
  ldv_check_alloc_flags(flags);
#line 600
  tmp = ldv_undef_ptr();
#line 600
  return ((int )((long )tmp));
}
}
#line 603 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
struct sk_buff *ldv_skb_clone_87(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 606
  ldv_check_alloc_flags(flags);
#line 607
  tmp = ldv_undef_ptr();
#line 607
  return ((struct sk_buff *)tmp);
}
}
#line 610 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_disc.o.c.prepared"
bool ldv_cancel_delayed_work_sync_88(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  bool tmp ;

  {
#line 614
  tmp = cancel_delayed_work_sync(ldv_func_arg1);
#line 614
  ldv_func_res = tmp;
#line 616
  disable_work_3(& ldv_func_arg1->work);
#line 618
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 479 "./arch/x86/include/asm/bitops.h"
__inline static int fls64(__u64 x ) 
{ 
  int bitpos ;

  {
#line 481
  bitpos = -1;
#line 487
  __asm__  ("bsrq %1,%q0": "+r" (bitpos): "rm" (x));
#line 490
  return (bitpos + 1);
}
}
#line 14 "include/asm-generic/bitops/find.h"
extern unsigned long find_next_bit(unsigned long const   * , unsigned long  , unsigned long  ) ;
#line 174 "include/linux/bitops.h"
__inline static unsigned int fls_long(unsigned long l ) 
{ 
  int tmp___0 ;

  {
#line 178
  tmp___0 = fls64((__u64 )l);
#line 178
  return ((unsigned int )tmp___0);
}
}
#line 40 "include/linux/log2.h"
__inline static int __ilog2_u64(u64 n ) 
{ 
  int tmp ;

  {
#line 42
  tmp = fls64(n);
#line 42
  return (tmp + -1);
}
}
#line 61 "include/linux/log2.h"
__inline static unsigned long __roundup_pow_of_two(unsigned long n ) 
{ 
  unsigned int tmp ;

  {
#line 63
  tmp = fls_long(n - 1UL);
#line 63
  return (1UL << (int )tmp);
}
}
#line 5 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
void *ldv_err_ptr(long error ) ;
#line 8
void ldv_spin_lock(void) ;
#line 9
void ldv_spin_unlock(void) ;
#line 295 "include/linux/percpu-defs.h"
extern void __bad_size_call_parameter(void) ;
#line 18 "include/asm-generic/percpu.h"
extern unsigned long __per_cpu_offset[8192U] ;
#line 37 "include/linux/cpumask.h"
extern int nr_cpu_ids ;
#line 88
extern struct cpumask  const  * const  cpu_possible_mask ;
#line 114 "include/linux/cpumask.h"
__inline static unsigned int cpumask_check(unsigned int cpu ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 117
  __ret_warn_once = (unsigned int )nr_cpu_ids <= cpu;
#line 117
  tmp___1 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 117
  if (tmp___1 != 0L) {
#line 117
    __ret_warn_on = ! __warned;
#line 117
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 117
    if (tmp != 0L) {
#line 117
      warn_slowpath_null("include/linux/cpumask.h", 117);
    } else {

    }
#line 117
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 117
    if (tmp___0 != 0L) {
#line 117
      __warned = 1;
    } else {

    }
  } else {

  }
#line 117
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 119
  return (cpu);
}
}
#line 184 "include/linux/cpumask.h"
__inline static unsigned int cpumask_next(int n , struct cpumask  const  *srcp ) 
{ 
  unsigned long tmp ;

  {
#line 187
  if (n != -1) {
#line 188
    cpumask_check((unsigned int )n);
  } else {

  }
#line 189
  tmp = find_next_bit((unsigned long const   *)(& srcp->bits), (unsigned long )nr_cpu_ids,
                      (unsigned long )(n + 1));
#line 189
  return ((unsigned int )tmp);
}
}
#line 23 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) ;
#line 32
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 25 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 
  int __var ;

  {
#line 27
  __var = 0;
#line 27
  return ((int )*((int const volatile   *)(& v->counter)));
}
}
#line 37 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 39
  v->counter = i;
#line 40
  return;
}
}
#line 90 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 92
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 94
  return;
}
}
#line 102 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_dec(atomic_t *v ) 
{ 


  {
#line 104
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0": "+m" (v->counter));
#line 106
  return;
}
}
#line 116 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_dec_and_test(atomic_t *v ) 
{ 
  char c ;

  {
#line 118
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0; sete %1": "+m" (v->counter),
                       "=qm" (c): : "memory");
#line 118
  return ((int )((signed char )c) != 0);
}
}
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 30 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock_bh(raw_spinlock_t * ) ;
#line 42
extern void _raw_spin_unlock_bh(raw_spinlock_t * ) ;
#line 299 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 301
  return (& lock->__annonCompField18.rlock);
}
}
#line 319 "include/linux/spinlock.h"
__inline static void ldv_spin_lock_bh_100(spinlock_t *lock ) 
{ 


  {
#line 321
  _raw_spin_lock_bh(& lock->__annonCompField18.rlock);
#line 322
  return;
}
}
#line 319
__inline static void spin_lock_bh(spinlock_t *lock ) ;
#line 368 "include/linux/spinlock.h"
__inline static void ldv_spin_unlock_bh_104(spinlock_t *lock ) 
{ 


  {
#line 370
  _raw_spin_unlock_bh(& lock->__annonCompField18.rlock);
#line 371
  return;
}
}
#line 368
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
#line 72 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 149
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 924
extern void prepare_to_wait(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 927
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 931
extern int autoremove_wake_function(wait_queue_t * , unsigned int  , int  , void * ) ;
#line 361 "include/linux/workqueue.h"
extern struct workqueue_struct *__alloc_workqueue_key(char const   * , unsigned int  ,
                                                      int  , struct lock_class_key * ,
                                                      char const   *  , ...) ;
#line 421
extern void destroy_workqueue(struct workqueue_struct * ) ;
#line 424
void ldv_destroy_workqueue_140(struct workqueue_struct *ldv_func_arg1 ) ;
#line 437
bool ldv_queue_work_on_109(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 441
bool ldv_queue_work_on_111(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 447
bool ldv_queue_delayed_work_on_110(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 451
bool ldv_queue_delayed_work_on_113(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 459
void ldv_flush_workqueue_112(struct workqueue_struct *ldv_func_arg1 ) ;
#line 463
void ldv_flush_workqueue_139(struct workqueue_struct *ldv_func_arg1 ) ;
#line 475
extern bool cancel_delayed_work(struct delayed_work * ) ;
#line 478
bool ldv_cancel_delayed_work_136(struct delayed_work *ldv_func_arg1 ) ;
#line 483
bool ldv_cancel_delayed_work_sync_138(struct delayed_work *ldv_func_arg1 ) ;
#line 483 "include/linux/workqueue.h"
__inline static bool queue_delayed_work___0(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                            unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 487
  tmp = ldv_queue_delayed_work_on_110(8192, wq, dwork, delay);
#line 487
  return (tmp);
}
}
#line 38 "./arch/x86/include/asm/smp.h"
extern int cpu_number ;
#line 127 "include/linux/percpu.h"
extern void *__alloc_percpu(size_t  , size_t  ) ;
#line 128
extern void free_percpu(void * ) ;
#line 32 "include/linux/kref.h"
__inline static void kref_init(struct kref *kref ) 
{ 


  {
#line 34
  atomic_set(& kref->refcount, 1);
#line 35
  return;
}
}
#line 425 "include/linux/sched.h"
extern void schedule(void) ;
#line 116 "include/linux/slab.h"
extern struct kmem_cache *kmem_cache_create(char const   * , size_t  , size_t  , unsigned long  ,
                                            void (*)(void * ) ) ;
#line 119
extern void kmem_cache_destroy(struct kmem_cache * ) ;
#line 293
void *ldv_kmem_cache_alloc_119(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 418
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 585
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 112 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
void call_and_disable_all_2(int state ) ;
#line 115
void activate_work_2(struct work_struct *work , int state ) ;
#line 129
void disable_work_2(struct work_struct *work ) ;
#line 147
void call_and_disable_work_2(struct work_struct *work ) ;
#line 149
void invoke_work_2(void) ;
#line 26 "include/linux/mempool.h"
extern mempool_t *mempool_create(int  , mempool_alloc_t * , mempool_free_t * , void * ) ;
#line 33
extern void mempool_destroy(mempool_t * ) ;
#line 37
void *ldv_mempool_alloc_137(mempool_t *ldv_func_arg1 , gfp_t flags ) ;
#line 39
extern void mempool_free(void * , mempool_t * ) ;
#line 46
extern void *mempool_alloc_slab(gfp_t  , void * ) ;
#line 47
extern void mempool_free_slab(void * , void * ) ;
#line 49 "include/linux/mempool.h"
__inline static mempool_t *mempool_create_slab_pool(int min_nr , struct kmem_cache *kc ) 
{ 
  mempool_t *tmp ;

  {
#line 51
  tmp = mempool_create(min_nr, & mempool_alloc_slab, & mempool_free_slab, (void *)kc);
#line 51
  return (tmp);
}
}
#line 849 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_127(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 853
struct sk_buff *ldv_skb_clone_135(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 858
struct sk_buff *ldv_skb_copy_129(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 871
int ldv_pskb_expand_head_125(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 875
int ldv_pskb_expand_head_133(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 879
int ldv_pskb_expand_head_134(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2061
extern void skb_trim(struct sk_buff * , unsigned int  ) ;
#line 2148
struct sk_buff *ldv___netdev_alloc_skb_130(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2152
struct sk_buff *ldv___netdev_alloc_skb_131(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2156
struct sk_buff *ldv___netdev_alloc_skb_132(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 109 "include/scsi/fc/fc_encaps.h"
__inline static int fc_sof_needs_ack(enum fc_sof sof ) 
{ 


  {
#line 111
  return (~ ((int )sof) & 2);
}
}
#line 117 "include/scsi/fc/fc_encaps.h"
__inline static enum fc_sof fc_sof_normal(enum fc_class class ) 
{ 


  {
#line 119
  return ((enum fc_sof )((unsigned int )((unsigned char )class) + 8U));
}
}
#line 125 "include/scsi/fc/fc_encaps.h"
__inline static enum fc_class fc_sof_class(enum fc_sof sof ) 
{ 


  {
#line 127
  return ((enum fc_class )(((int )sof & 7) | 40));
}
}
#line 133 "include/scsi/fc/fc_encaps.h"
__inline static int fc_sof_is_init(enum fc_sof sof ) 
{ 


  {
#line 135
  return ((unsigned int )sof <= 47U);
}
}
#line 232 "include/scsi/fc_frame.h"
__inline static enum fc_class fc_frame_class(struct fc_frame  const  *fp ) 
{ 
  enum fc_class tmp ;

  {
#line 234
  tmp = fc_sof_class((int )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_sof);
#line 234
  return (tmp);
}
}
#line 370 "include/scsi/libfc.h"
u16 fc_cpu_mask  ;
#line 1072
struct fc_lport *fc_vport_id_lookup(struct fc_lport *n_port , u32 port_id ) ;
#line 1131
int fc_exch_init(struct fc_lport *lport ) ;
#line 1132
void fc_exch_update_stats(struct fc_lport *lport ) ;
#line 1133
struct fc_exch_mgr_anchor *fc_exch_mgr_add(struct fc_lport *lport , struct fc_exch_mgr *mp ,
                                           bool (*match)(struct fc_frame * ) ) ;
#line 1136
void fc_exch_mgr_del(struct fc_exch_mgr_anchor *ema ) ;
#line 1137
int fc_exch_mgr_list_clone(struct fc_lport *src , struct fc_lport *dst ) ;
#line 1138
struct fc_exch_mgr *fc_exch_mgr_alloc(struct fc_lport *lport , enum fc_class class ,
                                      u16 min_xid , u16 max_xid , bool (*match)(struct fc_frame * ) ) ;
#line 1141
void fc_exch_mgr_free(struct fc_lport *lport ) ;
#line 1142
void fc_exch_recv(struct fc_lport *lport , struct fc_frame *fp ) ;
#line 1143
void fc_exch_mgr_reset(struct fc_lport *lport , u32 sid , u32 did ) ;
#line 54 "include/scsi/fc_encode.h"
__inline static void __fc_fill_fc_hdr(struct fc_frame_header *fh , enum fc_rctl r_ctl ,
                                      u32 did , u32 sid , enum fc_fh_type type , u32 f_ctl ,
                                      u32 parm_offset ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  __u32 tmp___0 ;

  {
#line 59
  __ret_warn_on = (unsigned int )r_ctl == 0U;
#line 59
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 59
  if (tmp != 0L) {
#line 59
    warn_slowpath_null("include/scsi/fc_encode.h", 59);
  } else {

  }
#line 59
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 60
  fh->fh_r_ctl = (__u8 )r_ctl;
#line 61
  hton24((u8 *)(& fh->fh_d_id), did);
#line 62
  hton24((u8 *)(& fh->fh_s_id), sid);
#line 63
  fh->fh_type = (__u8 )type;
#line 64
  hton24((u8 *)(& fh->fh_f_ctl), f_ctl);
#line 65
  fh->fh_cs_ctl = 0U;
#line 66
  fh->fh_df_ctl = 0U;
#line 67
  tmp___0 = __fswab32(parm_offset);
#line 67
  fh->fh_parm_offset = tmp___0;
#line 68
  return;
}
}
#line 73 "include/scsi/fc_encode.h"
__inline static void fc_fill_fc_hdr(struct fc_frame *fp , enum fc_rctl r_ctl , u32 did ,
                                    u32 sid , enum fc_fh_type type , u32 f_ctl , u32 parm_offset ) 
{ 
  struct fc_frame_header *fh ;

  {
#line 79
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 80
  __fc_fill_fc_hdr(fh, r_ctl, did, sid, type, f_ctl, parm_offset);
#line 81
  return;
}
}
#line 110 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/libfc/fc_libfc.h"
void fc_fcp_ddp_setup(struct fc_fcp_pkt *fsp , u16 xid ) ;
#line 111
void fc_fcp_ddp_done(struct fc_fcp_pkt *fsp ) ;
#line 40 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static char const   __kstrtab_fc_cpu_mask[12U]  = 
#line 40 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
  {      'f',      'c',      '_',      'c', 
        'p',      'u',      '_',      'm', 
        'a',      's',      'k',      '\000'};
#line 40
struct kernel_symbol  const  __ksymtab_fc_cpu_mask ;
#line 40 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
struct kernel_symbol  const  __ksymtab_fc_cpu_mask  =    {(unsigned long )(& fc_cpu_mask), (char const   *)(& __kstrtab_fc_cpu_mask)};
#line 41 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static u16 fc_cpu_order  ;
#line 42 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static struct kmem_cache *fc_em_cachep  ;
#line 43 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static struct workqueue_struct *fc_exch_workqueue  ;
#line 131
static void fc_exch_rrq(struct fc_exch *ep ) ;
#line 132
static void fc_seq_ls_acc(struct fc_frame *rx_fp ) ;
#line 133
static void fc_seq_ls_rjt(struct fc_frame *rx_fp , enum fc_els_rjt_reason reason ,
                          enum fc_els_rjt_explan explan ) ;
#line 135
static void fc_exch_els_rec(struct fc_frame *rfp ) ;
#line 136
static void fc_exch_els_rrq(struct fc_frame *fp ) ;
#line 220 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static char *fc_exch_rctl_names[202U]  = 
#line 220
  {      (char *)"uncat",      (char *)"sol data",      (char *)"unsol ctl",      (char *)"sol ctl/reply", 
        (char *)"unsol data",      (char *)"data desc",      (char *)"unsol cmd",      (char *)"cmd status", 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      (char *)"ELS req",      (char *)"ELS rep", 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      (char *)"FC-4 ELS req",      (char *)"FC-4 ELS rep", 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        (char *)"BLS NOP",      (char *)"BLS abort",      (char *)"BLS remove connection",      0, 
        (char *)"BLS accept",      (char *)"BLS reject",      (char *)"BLS dedicated connection preempted",      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        (char *)"LC ACK_1",      (char *)"LC ACK_0",      (char *)"LC port reject",      (char *)"LC fabric reject", 
        (char *)"LC port busy",      (char *)"LC fabric busy to data frame",      (char *)"LC fabric busy to link control frame",      (char *)"LC link credit reset", 
        0,      (char *)"LC end"};
#line 231 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
__inline static char const   *fc_exch_name_lookup(unsigned int op , char **table ,
                                                  unsigned int max_index ) 
{ 
  char const   *name ;

  {
#line 234
  name = (char const   *)0;
#line 236
  if (op < max_index) {
#line 237
    name = (char const   *)*(table + (unsigned long )op);
  } else {

  }
#line 238
  if ((unsigned long )name == (unsigned long )((char const   *)0)) {
#line 239
    name = "unknown";
  } else {

  }
#line 240
  return (name);
}
}
#line 247 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static char const   *fc_exch_rctl_name(unsigned int op ) 
{ 
  char const   *tmp ;

  {
#line 249
  tmp = fc_exch_name_lookup(op, (char **)(& fc_exch_rctl_names), 202U);
#line 249
  return (tmp);
}
}
#line 257 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
__inline static void fc_exch_hold(struct fc_exch *ep ) 
{ 


  {
#line 259
  atomic_inc(& ep->ex_refcnt);
#line 260
  return;
}
}
#line 272 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_exch_setup_hdr(struct fc_exch *ep , struct fc_frame *fp , u32 f_ctl ) 
{ 
  struct fc_frame_header *fh ;
  struct fc_frame_header *tmp ;
  u16 fill ;
  enum fc_sof tmp___0 ;
  int tmp___1 ;
  int __ret_warn_on ;
  long tmp___2 ;
  __u16 tmp___3 ;
  __u16 tmp___4 ;
  __u16 tmp___5 ;

  {
#line 275
  tmp = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 275
  fh = tmp;
#line 278
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_sof = (u8 )ep->class;
#line 279
  if ((unsigned int )ep->seq.cnt != 0U) {
#line 280
    tmp___0 = fc_sof_normal(ep->class);
#line 280
    ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_sof = (u8 )tmp___0;
  } else {

  }
#line 282
  if ((f_ctl & 524288U) != 0U) {
#line 283
    ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_eof = 66U;
#line 284
    tmp___1 = fc_sof_needs_ack((int )((enum fc_sof )ep->class));
#line 284
    if (tmp___1 != 0) {
#line 285
      ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_eof = 65U;
    } else {

    }
#line 295
    fill = (unsigned int )((u16 )fp->skb.len) & 3U;
#line 296
    if ((unsigned int )fill != 0U) {
#line 297
      fill = 4U - (unsigned int )fill;
#line 299
      skb_put(& fp->skb, (unsigned int )fill);
#line 300
      hton24((u8 *)(& fh->fh_f_ctl), (u32 )fill | f_ctl);
    } else {

    }
  } else {
#line 303
    __ret_warn_on = (fp->skb.len & 3U) != 0U;
#line 303
    tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 303
    if (tmp___2 != 0L) {
#line 303
      warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c",
                         303);
    } else {

    }
#line 303
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 304
    ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_eof = 65U;
  }
#line 308
  tmp___3 = __fswab16((int )ep->oxid);
#line 308
  fh->fh_ox_id = tmp___3;
#line 309
  tmp___4 = __fswab16((int )ep->rxid);
#line 309
  fh->fh_rx_id = tmp___4;
#line 310
  fh->fh_seq_id = ep->seq.id;
#line 311
  tmp___5 = __fswab16((int )ep->seq.cnt);
#line 311
  fh->fh_seq_cnt = tmp___5;
#line 312
  return;
}
}
#line 321 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_exch_release(struct fc_exch *ep ) 
{ 
  struct fc_exch_mgr *mp ;
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
#line 325
  tmp___0 = atomic_dec_and_test(& ep->ex_refcnt);
#line 325
  if (tmp___0 != 0) {
#line 326
    mp = ep->em;
#line 327
    if ((unsigned long )ep->destructor != (unsigned long )((void (*)(struct fc_seq * ,
                                                                     void * ))0)) {
#line 328
      (*(ep->destructor))(& ep->seq, ep->arg);
    } else {

    }
#line 329
    __ret_warn_on = (ep->esb_stat & 536870912U) == 0U;
#line 329
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 329
    if (tmp != 0L) {
#line 329
      warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c",
                         329);
    } else {

    }
#line 329
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 330
    mempool_free((void *)ep, mp->ep_pool);
  } else {

  }
#line 332
  return;
}
}
#line 338 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
__inline static void fc_exch_timer_cancel(struct fc_exch *ep ) 
{ 
  long tmp ;
  bool tmp___0 ;

  {
#line 340
  tmp___0 = ldv_cancel_delayed_work_136(& ep->timeout_work);
#line 340
  if ((int )tmp___0) {
#line 341
    tmp = ldv__builtin_expect((fc_debug_logging & 64U) != 0U, 0L);
#line 341
    if (tmp != 0L) {
#line 341
      printk("\016host%u: xid %4x: Exchange timer canceled\n", ((ep->lp)->host)->host_no,
             (int )ep->xid);
    } else {

    }
#line 342
    atomic_dec(& ep->ex_refcnt);
  } else {

  }
#line 344
  return;
}
}
#line 355 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
__inline static void fc_exch_timer_set_locked(struct fc_exch *ep , unsigned int timer_msec ) 
{ 
  long tmp ;
  unsigned long tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 358
  if (((int )ep->state & 3) != 0) {
#line 359
    return;
  } else {

  }
#line 361
  tmp = ldv__builtin_expect((fc_debug_logging & 64U) != 0U, 0L);
#line 361
  if (tmp != 0L) {
#line 361
    printk("\016host%u: xid %4x: Exchange timer armed : %d msecs\n", ((ep->lp)->host)->host_no,
           (int )ep->xid, timer_msec);
  } else {

  }
#line 363
  fc_exch_hold(ep);
#line 364
  tmp___0 = msecs_to_jiffies(timer_msec);
#line 364
  tmp___1 = queue_delayed_work___0(fc_exch_workqueue, & ep->timeout_work, tmp___0);
#line 364
  if (tmp___1) {
#line 364
    tmp___2 = 0;
  } else {
#line 364
    tmp___2 = 1;
  }
#line 364
  if (tmp___2) {
#line 366
    fc_exch_release(ep);
  } else {

  }
#line 367
  return;
}
}
#line 374 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_exch_timer_set(struct fc_exch *ep , unsigned int timer_msec ) 
{ 


  {
#line 376
  spin_lock_bh(& ep->ex_lock);
#line 377
  fc_exch_timer_set_locked(ep, timer_msec);
#line 378
  spin_unlock_bh(& ep->ex_lock);
#line 379
  return;
}
}
#line 387 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static int fc_exch_done_locked(struct fc_exch *ep ) 
{ 
  int rc ;

  {
#line 389
  rc = 1;
#line 397
  if ((int )ep->state & 1) {
#line 398
    return (rc);
  } else {

  }
#line 399
  ep->esb_stat = ep->esb_stat | 536870912U;
#line 401
  if ((ep->esb_stat & 67108864U) == 0U) {
#line 402
    ep->state = (u8 )((unsigned int )ep->state | 1U);
#line 403
    fc_exch_timer_cancel(ep);
#line 404
    rc = 0;
  } else {

  }
#line 406
  return (rc);
}
}
#line 418 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
__inline static struct fc_exch *fc_exch_ptr_get(struct fc_exch_pool *pool , u16 index ) 
{ 
  struct fc_exch **exches ;

  {
#line 421
  exches = (struct fc_exch **)pool + 1U;
#line 422
  return (*(exches + (unsigned long )index));
}
}
#line 431 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
__inline static void fc_exch_ptr_set(struct fc_exch_pool *pool , u16 index , struct fc_exch *ep ) 
{ 


  {
#line 434
  *((struct fc_exch **)pool + ((unsigned long )index + 1UL)) = ep;
#line 435
  return;
}
}
#line 441 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_exch_delete(struct fc_exch *ep ) 
{ 
  struct fc_exch_pool *pool ;
  u16 index ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 446
  pool = ep->pool;
#line 447
  spin_lock_bh(& pool->lock);
#line 448
  __ret_warn_on = (unsigned int )pool->total_exches == 0U;
#line 448
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 448
  if (tmp != 0L) {
#line 448
    warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c",
                       448);
  } else {

  }
#line 448
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 449
  pool->total_exches = (u16 )((int )pool->total_exches - 1);
#line 452
  index = (u16 )(((int )ep->xid - (int )(ep->em)->min_xid) >> (int )fc_cpu_order);
#line 453
  if ((unsigned int )pool->left == 65535U) {
#line 454
    pool->left = index;
  } else
#line 455
  if ((unsigned int )pool->right == 65535U) {
#line 456
    pool->right = index;
  } else {
#line 458
    pool->next_index = index;
  }
#line 460
  fc_exch_ptr_set(pool, (int )index, (struct fc_exch *)0);
#line 461
  list_del(& ep->ex_list);
#line 462
  spin_unlock_bh(& pool->lock);
#line 463
  fc_exch_release(ep);
#line 464
  return;
}
}
#line 466 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static int fc_seq_send_locked(struct fc_lport *lport , struct fc_seq *sp , struct fc_frame *fp ) 
{ 
  struct fc_exch *ep ;
  struct fc_frame_header *fh ;
  struct fc_frame_header *tmp ;
  int error ;
  u32 f_ctl ;
  u8 fh_type ;
  struct fc_seq  const  *__mptr ;
  int __ret_warn_on ;
  long tmp___0 ;

  {
#line 470
  tmp = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 470
  fh = tmp;
#line 471
  error = -6;
#line 473
  fh_type = fh->fh_type;
#line 475
  __mptr = (struct fc_seq  const  *)sp;
#line 475
  ep = (struct fc_exch *)__mptr + 0xffffffffffffff64UL;
#line 477
  if ((ep->esb_stat & 805306368U) != 0U) {
#line 478
    fc_frame_free(fp);
#line 479
    goto out;
  } else {

  }
#line 482
  __ret_warn_on = (ep->esb_stat & 1073741824U) == 0U;
#line 482
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 482
  if (tmp___0 != 0L) {
#line 482
    warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c",
                       482);
  } else {

  }
#line 482
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 484
  f_ctl = ntoh24((u8 const   *)(& fh->fh_f_ctl));
#line 485
  fc_exch_setup_hdr(ep, fp, f_ctl);
#line 486
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_encaps = ep->encaps;
#line 493
  if ((unsigned int )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_max_payload != 0U) {
#line 494
    sp->cnt = (int )sp->cnt + (int )((u16 )((((unsigned long )fp->skb.len + (unsigned long )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_max_payload) - 25UL) / (unsigned long )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_max_payload));
  } else {
#line 497
    sp->cnt = (u16 )((int )sp->cnt + 1);
  }
#line 502
  error = (*(lport->tt.frame_send))(lport, fp);
#line 504
  if ((unsigned int )fh_type == 0U) {
#line 505
    goto out;
  } else {

  }
#line 512
  ep->f_ctl = f_ctl & 4292870143U;
#line 513
  if ((f_ctl & 65536U) != 0U) {
#line 514
    ep->esb_stat = ep->esb_stat & 3221225471U;
  } else {

  }
  out: ;
#line 516
  return (error);
}
}
#line 528 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static int fc_seq_send(struct fc_lport *lport , struct fc_seq *sp , struct fc_frame *fp ) 
{ 
  struct fc_exch *ep ;
  int error ;
  struct fc_seq  const  *__mptr ;

  {
#line 533
  __mptr = (struct fc_seq  const  *)sp;
#line 533
  ep = (struct fc_exch *)__mptr + 0xffffffffffffff64UL;
#line 534
  spin_lock_bh(& ep->ex_lock);
#line 535
  error = fc_seq_send_locked(lport, sp, fp);
#line 536
  spin_unlock_bh(& ep->ex_lock);
#line 537
  return (error);
}
}
#line 549 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static struct fc_seq *fc_seq_alloc(struct fc_exch *ep , u8 seq_id ) 
{ 
  struct fc_seq *sp ;

  {
#line 553
  sp = & ep->seq;
#line 554
  sp->ssb_stat = 0U;
#line 555
  sp->cnt = 0U;
#line 556
  sp->id = seq_id;
#line 557
  return (sp);
}
}
#line 565 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static struct fc_seq *fc_seq_start_next_locked(struct fc_seq *sp ) 
{ 
  struct fc_exch *ep ;
  struct fc_seq  const  *__mptr ;
  u8 tmp ;
  long tmp___0 ;

  {
#line 567
  __mptr = (struct fc_seq  const  *)sp;
#line 567
  ep = (struct fc_exch *)__mptr + 0xffffffffffffff64UL;
#line 569
  tmp = ep->seq_id;
#line 569
  ep->seq_id = (u8 )((int )ep->seq_id + 1);
#line 569
  sp = fc_seq_alloc(ep, (int )tmp);
#line 570
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 64U) != 0U, 0L);
#line 570
  if (tmp___0 != 0L) {
#line 570
    printk("\016host%u: xid %4x: f_ctl %6x seq %2x\n", ((ep->lp)->host)->host_no,
           (int )ep->xid, ep->f_ctl, (int )sp->id);
  } else {

  }
#line 572
  return (sp);
}
}
#line 580 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static struct fc_seq *fc_seq_start_next(struct fc_seq *sp ) 
{ 
  struct fc_exch *ep ;
  struct fc_seq  const  *__mptr ;

  {
#line 582
  __mptr = (struct fc_seq  const  *)sp;
#line 582
  ep = (struct fc_exch *)__mptr + 0xffffffffffffff64UL;
#line 584
  spin_lock_bh(& ep->ex_lock);
#line 585
  sp = fc_seq_start_next_locked(sp);
#line 586
  spin_unlock_bh(& ep->ex_lock);
#line 588
  return (sp);
}
}
#line 596 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_seq_set_resp(struct fc_seq *sp , void (*resp)(struct fc_seq * , struct fc_frame * ,
                                                             void * ) , void *arg ) 
{ 
  struct fc_exch *ep ;
  struct fc_seq  const  *__mptr ;
  wait_queue_t wait ;
  struct task_struct *tmp ;
  struct task_struct *tmp___0 ;

  {
#line 601
  __mptr = (struct fc_seq  const  *)sp;
#line 601
  ep = (struct fc_exch *)__mptr + 0xffffffffffffff64UL;
#line 602
  tmp = get_current();
#line 602
  wait.flags = 0U;
#line 602
  wait.private = (void *)tmp;
#line 602
  wait.func = & autoremove_wake_function;
#line 602
  wait.task_list.next = & wait.task_list;
#line 602
  wait.task_list.prev = & wait.task_list;
#line 604
  spin_lock_bh(& ep->ex_lock);
#line 605
  goto ldv_41322;
  ldv_41321: 
#line 606
  prepare_to_wait(& ep->resp_wq, & wait, 2);
#line 607
  spin_unlock_bh(& ep->ex_lock);
#line 609
  schedule();
#line 611
  spin_lock_bh(& ep->ex_lock);
  ldv_41322: ;
#line 605
  if (ep->resp_active != 0) {
#line 605
    tmp___0 = get_current();
#line 605
    if ((unsigned long )ep->resp_task != (unsigned long )tmp___0) {
#line 607
      goto ldv_41321;
    } else {
#line 610
      goto ldv_41323;
    }
  } else {

  }
  ldv_41323: 
#line 613
  finish_wait(& ep->resp_wq, & wait);
#line 614
  ep->resp = resp;
#line 615
  ep->arg = arg;
#line 616
  spin_unlock_bh(& ep->ex_lock);
#line 617
  return;
}
}
#line 628 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static int fc_exch_abort_locked(struct fc_exch *ep , unsigned int timer_msec ) 
{ 
  struct fc_seq *sp ;
  struct fc_frame *fp ;
  int error ;

  {
#line 635
  if ((ep->esb_stat & 805306368U) != 0U || ((int )ep->state & 3) != 0) {
#line 637
    return (-6);
  } else {

  }
#line 642
  sp = fc_seq_start_next_locked(& ep->seq);
#line 643
  if ((unsigned long )sp == (unsigned long )((struct fc_seq *)0)) {
#line 644
    return (-12);
  } else {

  }
#line 646
  if (timer_msec != 0U) {
#line 647
    fc_exch_timer_set_locked(ep, timer_msec);
  } else {

  }
#line 649
  if (ep->sid != 0U) {
#line 653
    fp = fc_frame_alloc(ep->lp, 0UL);
#line 654
    if ((unsigned long )fp != (unsigned long )((struct fc_frame *)0)) {
#line 655
      ep->esb_stat = ep->esb_stat | 1073741824U;
#line 656
      fc_fill_fc_hdr(fp, 129, ep->did, ep->sid, 0, 589824U, 0U);
#line 659
      error = fc_seq_send_locked(ep->lp, sp, fp);
    } else {
#line 661
      error = -105;
    }
  } else {
#line 668
    error = 0;
  }
#line 670
  ep->esb_stat = ep->esb_stat | 268435456U;
#line 671
  return (error);
}
}
#line 683 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static int fc_seq_exch_abort(struct fc_seq  const  *req_sp , unsigned int timer_msec ) 
{ 
  struct fc_exch *ep ;
  int error ;
  struct fc_seq  const  *__mptr ;

  {
#line 689
  __mptr = req_sp;
#line 689
  ep = (struct fc_exch *)__mptr + 0xffffffffffffff64UL;
#line 690
  spin_lock_bh(& ep->ex_lock);
#line 691
  error = fc_exch_abort_locked(ep, timer_msec);
#line 692
  spin_unlock_bh(& ep->ex_lock);
#line 693
  return (error);
}
}
#line 718 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static bool fc_invoke_resp(struct fc_exch *ep , struct fc_seq *sp , struct fc_frame *fp ) 
{ 
  void (*resp)(struct fc_seq * , struct fc_frame * , void * ) ;
  void *arg ;
  bool res ;
  struct task_struct *tmp ;
  struct task_struct *tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 723
  res = 0;
#line 725
  spin_lock_bh(& ep->ex_lock);
#line 726
  ep->resp_active = ep->resp_active + 1;
#line 727
  tmp___0 = get_current();
#line 727
  if ((unsigned long )ep->resp_task != (unsigned long )tmp___0) {
#line 728
    if ((unsigned long )ep->resp_task == (unsigned long )((struct task_struct *)0)) {
#line 728
      tmp = get_current();
#line 728
      ep->resp_task = tmp;
    } else {
#line 728
      ep->resp_task = (struct task_struct *)0;
    }
  } else {

  }
#line 729
  resp = ep->resp;
#line 730
  arg = ep->arg;
#line 731
  spin_unlock_bh(& ep->ex_lock);
#line 733
  if ((unsigned long )resp != (unsigned long )((void (*)(struct fc_seq * , struct fc_frame * ,
                                                         void * ))0)) {
#line 734
    (*resp)(sp, fp, arg);
#line 735
    res = 1;
  } else {
#line 736
    tmp___1 = IS_ERR((void const   *)fp);
#line 736
    if (tmp___1) {
#line 736
      tmp___2 = 0;
    } else {
#line 736
      tmp___2 = 1;
    }
#line 736
    if (tmp___2) {
#line 737
      fc_frame_free(fp);
    } else {

    }
  }
#line 740
  spin_lock_bh(& ep->ex_lock);
#line 741
  ep->resp_active = ep->resp_active - 1;
#line 741
  if (ep->resp_active == 0) {
#line 742
    ep->resp_task = (struct task_struct *)0;
  } else {

  }
#line 743
  spin_unlock_bh(& ep->ex_lock);
#line 745
  if (ep->resp_active == 0) {
#line 746
    __wake_up(& ep->resp_wq, 3U, 1, (void *)0);
  } else {

  }
#line 748
  return (res);
}
}
#line 755 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_exch_timeout(struct work_struct *work ) 
{ 
  struct fc_exch *ep ;
  struct work_struct  const  *__mptr ;
  struct fc_seq *sp ;
  u32 e_stat ;
  int rc ;
  long tmp ;
  void *tmp___0 ;

  {
#line 757
  __mptr = (struct work_struct  const  *)work;
#line 757
  ep = (struct fc_exch *)__mptr + 0xfffffffffffffed8UL;
#line 759
  sp = & ep->seq;
#line 761
  rc = 1;
#line 763
  tmp = ldv__builtin_expect((fc_debug_logging & 64U) != 0U, 0L);
#line 763
  if (tmp != 0L) {
#line 763
    printk("\016host%u: xid %4x: Exchange timed out\n", ((ep->lp)->host)->host_no,
           (int )ep->xid);
  } else {

  }
#line 765
  spin_lock_bh(& ep->ex_lock);
#line 766
  if (((int )ep->state & 3) != 0) {
#line 767
    goto unlock;
  } else {

  }
#line 769
  e_stat = ep->esb_stat;
#line 770
  if ((e_stat & 536870912U) != 0U) {
#line 771
    ep->esb_stat = e_stat & 4227858431U;
#line 772
    spin_unlock_bh(& ep->ex_lock);
#line 773
    if ((e_stat & 67108864U) != 0U) {
#line 774
      fc_exch_rrq(ep);
    } else {

    }
#line 775
    goto done;
  } else {
#line 777
    if ((e_stat & 268435456U) != 0U) {
#line 778
      rc = fc_exch_done_locked(ep);
    } else {

    }
#line 779
    spin_unlock_bh(& ep->ex_lock);
#line 780
    if (rc == 0) {
#line 781
      fc_exch_delete(ep);
    } else {

    }
#line 782
    tmp___0 = ERR_PTR(-1L);
#line 782
    fc_invoke_resp(ep, sp, (struct fc_frame *)tmp___0);
#line 783
    fc_seq_set_resp(sp, (void (*)(struct fc_seq * , struct fc_frame * , void * ))0,
                    ep->arg);
#line 784
    fc_seq_exch_abort((struct fc_seq  const  *)sp, ep->r_a_tov * 2U);
#line 785
    goto done;
  }
  unlock: 
#line 788
  spin_unlock_bh(& ep->ex_lock);
  done: 
#line 793
  fc_exch_release(ep);
#line 794
  return;
}
}
#line 803 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static struct fc_exch *fc_exch_em_alloc(struct fc_lport *lport , struct fc_exch_mgr *mp ) 
{ 
  struct fc_exch *ep ;
  unsigned int cpu ;
  u16 index ;
  struct fc_exch_pool *pool ;
  void *tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  void const   *__vpp_verify___0 ;
  unsigned long __ptr ;
  struct fc_exch *tmp___0 ;
  struct lock_class_key __key ;
  u8 tmp___1 ;
  u16 tmp___2 ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___2 ;

  {
#line 812
  tmp = ldv_mempool_alloc_137(mp->ep_pool, 32U);
#line 812
  ep = (struct fc_exch *)tmp;
#line 813
  if ((unsigned long )ep == (unsigned long )((struct fc_exch *)0)) {
#line 814
    atomic_inc(& mp->stats.no_free_exch);
#line 815
    goto out;
  } else {

  }
#line 817
  memset((void *)ep, 0, 576UL);
#line 819
  __preempt_count_add(1);
#line 819
  __asm__  volatile   ("": : : "memory");
#line 819
  __vpp_verify = (void const   *)0;
#line 819
  switch (4UL) {
  case 1UL: ;
#line 819
  switch (4UL) {
  case 1UL: 
#line 819
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 819
  goto ldv_41375;
  case 2UL: 
#line 819
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 819
  goto ldv_41375;
  case 4UL: 
#line 819
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 819
  goto ldv_41375;
  case 8UL: 
#line 819
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 819
  goto ldv_41375;
  default: 
#line 819
  __bad_percpu_size();
  }
  ldv_41375: 
#line 819
  pscr_ret__ = pfo_ret__;
#line 819
  goto ldv_41381;
  case 2UL: ;
#line 819
  switch (4UL) {
  case 1UL: 
#line 819
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 819
  goto ldv_41385;
  case 2UL: 
#line 819
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 819
  goto ldv_41385;
  case 4UL: 
#line 819
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 819
  goto ldv_41385;
  case 8UL: 
#line 819
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 819
  goto ldv_41385;
  default: 
#line 819
  __bad_percpu_size();
  }
  ldv_41385: 
#line 819
  pscr_ret__ = pfo_ret_____0;
#line 819
  goto ldv_41381;
  case 4UL: ;
#line 819
  switch (4UL) {
  case 1UL: 
#line 819
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 819
  goto ldv_41394;
  case 2UL: 
#line 819
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 819
  goto ldv_41394;
  case 4UL: 
#line 819
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 819
  goto ldv_41394;
  case 8UL: 
#line 819
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 819
  goto ldv_41394;
  default: 
#line 819
  __bad_percpu_size();
  }
  ldv_41394: 
#line 819
  pscr_ret__ = pfo_ret_____1;
#line 819
  goto ldv_41381;
  case 8UL: ;
#line 819
  switch (4UL) {
  case 1UL: 
#line 819
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 819
  goto ldv_41403;
  case 2UL: 
#line 819
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 819
  goto ldv_41403;
  case 4UL: 
#line 819
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 819
  goto ldv_41403;
  case 8UL: 
#line 819
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 819
  goto ldv_41403;
  default: 
#line 819
  __bad_percpu_size();
  }
  ldv_41403: 
#line 819
  pscr_ret__ = pfo_ret_____2;
#line 819
  goto ldv_41381;
  default: 
#line 819
  __bad_size_call_parameter();
#line 819
  goto ldv_41381;
  }
  ldv_41381: 
#line 819
  cpu = (unsigned int )pscr_ret__;
#line 820
  __vpp_verify___0 = (void const   *)0;
#line 820
  __asm__  ("": "=r" (__ptr): "0" (mp->pool));
#line 820
  pool = (struct fc_exch_pool *)(__per_cpu_offset[cpu] + __ptr);
#line 821
  spin_lock_bh(& pool->lock);
#line 822
  __asm__  volatile   ("": : : "memory");
#line 822
  __preempt_count_sub(1);
#line 825
  if ((unsigned int )pool->left != 65535U) {
#line 826
    index = pool->left;
#line 827
    pool->left = 65535U;
#line 828
    goto hit;
  } else {

  }
#line 830
  if ((unsigned int )pool->right != 65535U) {
#line 831
    index = pool->right;
#line 832
    pool->right = 65535U;
#line 833
    goto hit;
  } else {

  }
#line 836
  index = pool->next_index;
#line 838
  goto ldv_41419;
  ldv_41418: 
#line 839
  index = (int )mp->pool_max_index != (int )index ? (unsigned int )index + 1U : 0U;
#line 840
  if ((int )pool->next_index == (int )index) {
#line 841
    goto err;
  } else {

  }
  ldv_41419: 
#line 838
  tmp___0 = fc_exch_ptr_get(pool, (int )index);
#line 838
  if ((unsigned long )tmp___0 != (unsigned long )((struct fc_exch *)0)) {
#line 840
    goto ldv_41418;
  } else {

  }
#line 843
  pool->next_index = (int )mp->pool_max_index != (int )index ? (unsigned int )index + 1U : 0U;
  hit: 
#line 845
  fc_exch_hold(ep);
#line 846
  spinlock_check(& ep->ex_lock);
#line 846
  __raw_spin_lock_init(& ep->ex_lock.__annonCompField18.rlock, "&(&ep->ex_lock)->rlock",
                       & __key);
#line 852
  spin_lock_bh(& ep->ex_lock);
#line 854
  fc_exch_ptr_set(pool, (int )index, ep);
#line 855
  list_add_tail(& ep->ex_list, & pool->ex_list);
#line 856
  tmp___1 = ep->seq_id;
#line 856
  ep->seq_id = (u8 )((int )ep->seq_id + 1);
#line 856
  fc_seq_alloc(ep, (int )tmp___1);
#line 857
  pool->total_exches = (u16 )((int )pool->total_exches + 1);
#line 858
  spin_unlock_bh(& pool->lock);
#line 863
  tmp___2 = ((int )((u16 )((int )index << (int )fc_cpu_order)) | (int )((u16 )cpu)) + (int )mp->min_xid;
#line 863
  ep->xid = tmp___2;
#line 863
  ep->oxid = tmp___2;
#line 864
  ep->em = mp;
#line 865
  ep->pool = pool;
#line 866
  ep->lp = lport;
#line 867
  ep->f_ctl = 2097152U;
#line 868
  ep->rxid = 65535U;
#line 869
  ep->class = mp->class;
#line 870
  ep->resp_active = 0;
#line 871
  __init_waitqueue_head(& ep->resp_wq, "&ep->resp_wq", & __key___0);
#line 872
  __init_work(& ep->timeout_work.work, 0);
#line 872
  __constr_expr_0.counter = 137438953408L;
#line 872
  ep->timeout_work.work.data = __constr_expr_0;
#line 872
  lockdep_init_map(& ep->timeout_work.work.lockdep_map, "(&(&ep->timeout_work)->work)",
                   & __key___1, 0);
#line 872
  INIT_LIST_HEAD(& ep->timeout_work.work.entry);
#line 872
  ep->timeout_work.work.func = & fc_exch_timeout;
#line 872
  init_timer_key(& ep->timeout_work.timer, 2097152U, "(&(&ep->timeout_work)->timer)",
                 & __key___2);
#line 872
  ep->timeout_work.timer.function = & delayed_work_timer_fn;
#line 872
  ep->timeout_work.timer.data = (unsigned long )(& ep->timeout_work);
  out: ;
#line 874
  return (ep);
  err: 
#line 876
  spin_unlock_bh(& pool->lock);
#line 877
  atomic_inc(& mp->stats.no_free_exch_xid);
#line 878
  mempool_free((void *)ep, mp->ep_pool);
#line 879
  return ((struct fc_exch *)0);
}
}
#line 893 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
__inline static struct fc_exch *fc_exch_alloc(struct fc_lport *lport , struct fc_frame *fp ) 
{ 
  struct fc_exch_mgr_anchor *ema ;
  struct list_head  const  *__mptr ;
  struct fc_exch *tmp ;
  bool tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 898
  __mptr = (struct list_head  const  *)lport->ema_list.next;
#line 898
  ema = (struct fc_exch_mgr_anchor *)__mptr;
#line 898
  goto ldv_41436;
  ldv_41435: ;
#line 899
  if ((unsigned long )ema->match == (unsigned long )((bool (*)(struct fc_frame * ))0)) {
#line 900
    tmp = fc_exch_em_alloc(lport, ema->mp);
#line 900
    return (tmp);
  } else {
#line 899
    tmp___0 = (*(ema->match))(fp);
#line 899
    if ((int )tmp___0) {
#line 900
      tmp = fc_exch_em_alloc(lport, ema->mp);
#line 900
      return (tmp);
    } else {

    }
  }
#line 898
  __mptr___0 = (struct list_head  const  *)ema->ema_list.next;
#line 898
  ema = (struct fc_exch_mgr_anchor *)__mptr___0;
  ldv_41436: ;
#line 898
  if ((unsigned long )(& ema->ema_list) != (unsigned long )(& lport->ema_list)) {
#line 900
    goto ldv_41435;
  } else {

  }

#line 901
  return ((struct fc_exch *)0);
}
}
#line 909 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static struct fc_exch *fc_exch_find(struct fc_exch_mgr *mp , u16 xid ) 
{ 
  struct fc_exch_pool *pool ;
  struct fc_exch *ep ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 912
  ep = (struct fc_exch *)0;
#line 914
  if ((int )mp->min_xid <= (int )xid && (int )mp->max_xid >= (int )xid) {
#line 915
    __vpp_verify = (void const   *)0;
#line 915
    __asm__  ("": "=r" (__ptr): "0" (mp->pool));
#line 915
    pool = (struct fc_exch_pool *)(__per_cpu_offset[(int )xid & (int )fc_cpu_mask] + __ptr);
#line 916
    spin_lock_bh(& pool->lock);
#line 917
    ep = fc_exch_ptr_get(pool, (int )((u16 )(((int )xid - (int )mp->min_xid) >> (int )fc_cpu_order)));
#line 918
    if ((unsigned long )ep != (unsigned long )((struct fc_exch *)0)) {
#line 919
      __ret_warn_on = (int )ep->xid != (int )xid;
#line 919
      tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 919
      if (tmp != 0L) {
#line 919
        warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c",
                           919);
      } else {

      }
#line 919
      ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 920
      fc_exch_hold(ep);
    } else {

    }
#line 922
    spin_unlock_bh(& pool->lock);
  } else {

  }
#line 924
  return (ep);
}
}
#line 935 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_exch_done(struct fc_seq *sp ) 
{ 
  struct fc_exch *ep ;
  struct fc_seq  const  *__mptr ;
  int rc ;

  {
#line 937
  __mptr = (struct fc_seq  const  *)sp;
#line 937
  ep = (struct fc_exch *)__mptr + 0xffffffffffffff64UL;
#line 940
  spin_lock_bh(& ep->ex_lock);
#line 941
  rc = fc_exch_done_locked(ep);
#line 942
  spin_unlock_bh(& ep->ex_lock);
#line 944
  fc_seq_set_resp(sp, (void (*)(struct fc_seq * , struct fc_frame * , void * ))0,
                  ep->arg);
#line 945
  if (rc == 0) {
#line 946
    fc_exch_delete(ep);
  } else {

  }
#line 947
  return;
}
}
#line 957 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static struct fc_exch *fc_exch_resp(struct fc_lport *lport , struct fc_exch_mgr *mp ,
                                    struct fc_frame *fp ) 
{ 
  struct fc_exch *ep ;
  struct fc_frame_header *fh ;
  __u16 tmp ;
  u32 tmp___0 ;

  {
#line 964
  ep = fc_exch_alloc(lport, fp);
#line 965
  if ((unsigned long )ep != (unsigned long )((struct fc_exch *)0)) {
#line 966
    ep->class = fc_frame_class((struct fc_frame  const  *)fp);
#line 971
    ep->f_ctl = ep->f_ctl | 8388608U;
#line 972
    ep->f_ctl = ep->f_ctl & 4292870143U;
#line 973
    fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 974
    ep->sid = ntoh24((u8 const   *)(& fh->fh_d_id));
#line 975
    ep->did = ntoh24((u8 const   *)(& fh->fh_s_id));
#line 976
    ep->oid = ep->did;
#line 983
    ep->rxid = ep->xid;
#line 984
    tmp = __fswab16((int )fh->fh_ox_id);
#line 984
    ep->oxid = tmp;
#line 985
    ep->esb_stat = ep->esb_stat | 3221225472U;
#line 986
    tmp___0 = ntoh24((u8 const   *)(& fh->fh_f_ctl));
#line 986
    if ((tmp___0 & 65536U) == 0U) {
#line 987
      ep->esb_stat = ep->esb_stat & 3221225471U;
    } else {

    }
#line 989
    fc_exch_hold(ep);
#line 990
    spin_unlock_bh(& ep->ex_lock);
  } else {

  }
#line 992
  return (ep);
}
}
#line 1005 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static enum fc_pf_rjt_reason fc_seq_lookup_recip(struct fc_lport *lport , struct fc_exch_mgr *mp ,
                                                 struct fc_frame *fp ) 
{ 
  struct fc_frame_header *fh ;
  struct fc_frame_header *tmp ;
  struct fc_exch *ep ;
  struct fc_seq *sp ;
  enum fc_pf_rjt_reason reject ;
  u32 f_ctl ;
  u16 xid ;
  int __ret_warn_on ;
  long tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;
  __u16 tmp___3 ;
  __u16 tmp___4 ;
  u8 tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int __ret_warn_on___0 ;
  struct fc_seq  const  *__mptr ;
  long tmp___8 ;

  {
#line 1009
  tmp = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 1009
  fh = tmp;
#line 1010
  ep = (struct fc_exch *)0;
#line 1011
  sp = (struct fc_seq *)0;
#line 1012
  reject = 0;
#line 1016
  f_ctl = ntoh24((u8 const   *)(& fh->fh_f_ctl));
#line 1017
  __ret_warn_on = (f_ctl & 4194304U) != 0U;
#line 1017
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1017
  if (tmp___0 != 0L) {
#line 1017
    warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c",
                       1017);
  } else {

  }
#line 1017
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1022
  if ((f_ctl & 8388608U) != 0U) {
#line 1023
    tmp___1 = __fswab16((int )fh->fh_ox_id);
#line 1023
    xid = tmp___1;
#line 1024
    ep = fc_exch_find(mp, (int )xid);
#line 1025
    if ((unsigned long )ep == (unsigned long )((struct fc_exch *)0)) {
#line 1026
      atomic_inc(& mp->stats.xid_not_found);
#line 1027
      reject = 11;
#line 1028
      goto out;
    } else {

    }
#line 1030
    if ((unsigned int )ep->rxid == 65535U) {
#line 1031
      tmp___2 = __fswab16((int )fh->fh_rx_id);
#line 1031
      ep->rxid = tmp___2;
    } else {
#line 1032
      tmp___3 = __fswab16((int )fh->fh_rx_id);
#line 1032
      if ((int )ep->rxid != (int )tmp___3) {
#line 1033
        reject = 11;
#line 1034
        goto rel;
      } else {

      }
    }
  } else {
#line 1037
    tmp___4 = __fswab16((int )fh->fh_rx_id);
#line 1037
    xid = tmp___4;
#line 1044
    if ((unsigned int )xid == 0U && (unsigned int )fh->fh_r_ctl == 34U) {
#line 1044
      tmp___5 = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 1044
      if ((unsigned int )tmp___5 == 17U) {
#line 1046
        fh->fh_rx_id = 65535U;
#line 1047
        xid = 65535U;
      } else {

      }
    } else {

    }
#line 1053
    ep = fc_exch_find(mp, (int )xid);
#line 1054
    if ((f_ctl & 2097152U) != 0U) {
#line 1054
      tmp___6 = fc_sof_is_init((int )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_sof);
#line 1054
      if (tmp___6 != 0) {
#line 1055
        if ((unsigned long )ep != (unsigned long )((struct fc_exch *)0)) {
#line 1056
          atomic_inc(& mp->stats.xid_busy);
#line 1057
          reject = 12;
#line 1058
          goto rel;
        } else {

        }
#line 1060
        ep = fc_exch_resp(lport, mp, fp);
#line 1061
        if ((unsigned long )ep == (unsigned long )((struct fc_exch *)0)) {
#line 1062
          reject = 24;
#line 1063
          goto out;
        } else {

        }
#line 1065
        xid = ep->xid;
      } else {
#line 1054
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1066
    if ((unsigned long )ep == (unsigned long )((struct fc_exch *)0)) {
#line 1067
      atomic_inc(& mp->stats.xid_not_found);
#line 1068
      reject = 12;
#line 1069
      goto out;
    } else {

    }
  }
#line 1073
  spin_lock_bh(& ep->ex_lock);
#line 1078
  tmp___7 = fc_sof_is_init((int )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_sof);
#line 1078
  if (tmp___7 != 0) {
#line 1079
    sp = & ep->seq;
#line 1080
    sp->ssb_stat = (u16 )((unsigned int )sp->ssb_stat | 32768U);
#line 1081
    sp->id = fh->fh_seq_id;
  } else {
#line 1083
    sp = & ep->seq;
#line 1084
    if ((int )sp->id != (int )fh->fh_seq_id) {
#line 1085
      atomic_inc(& mp->stats.seq_not_found);
#line 1086
      if ((f_ctl & 524288U) != 0U) {
#line 1101
        sp->ssb_stat = (u16 )((unsigned int )sp->ssb_stat | 32768U);
#line 1102
        sp->id = fh->fh_seq_id;
      } else {
#line 1104
        spin_unlock_bh(& ep->ex_lock);
#line 1107
        reject = 13;
#line 1108
        goto rel;
      }
    } else {

    }
  }
#line 1112
  __mptr = (struct fc_seq  const  *)sp;
#line 1112
  __ret_warn_on___0 = (unsigned long )((struct fc_exch *)__mptr + 0xffffffffffffff64UL) != (unsigned long )ep;
#line 1112
  tmp___8 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 1112
  if (tmp___8 != 0L) {
#line 1112
    warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c",
                       1112);
  } else {

  }
#line 1112
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 1114
  if ((f_ctl & 65536U) != 0U) {
#line 1115
    ep->esb_stat = ep->esb_stat | 1073741824U;
  } else {

  }
#line 1116
  spin_unlock_bh(& ep->ex_lock);
#line 1118
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_seq = sp;
  out: ;
#line 1120
  return (reject);
  rel: 
#line 1122
  fc_exch_done(& ep->seq);
#line 1123
  fc_exch_release(ep);
#line 1124
  return (reject);
}
}
#line 1135 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static struct fc_seq *fc_seq_lookup_orig(struct fc_exch_mgr *mp , struct fc_frame *fp ) 
{ 
  struct fc_frame_header *fh ;
  struct fc_frame_header *tmp ;
  struct fc_exch *ep ;
  struct fc_seq *sp ;
  u32 f_ctl ;
  u16 xid ;
  int __ret_warn_on ;
  long tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;

  {
#line 1138
  tmp = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 1138
  fh = tmp;
#line 1140
  sp = (struct fc_seq *)0;
#line 1144
  f_ctl = ntoh24((u8 const   *)(& fh->fh_f_ctl));
#line 1145
  __ret_warn_on = (f_ctl & 4194304U) == 0U;
#line 1145
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1145
  if (tmp___0 != 0L) {
#line 1145
    warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c",
                       1145);
  } else {

  }
#line 1145
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1146
  tmp___1 = __fswab16((f_ctl & 8388608U) != 0U ? fh->fh_ox_id : fh->fh_rx_id);
#line 1146
  xid = tmp___1;
#line 1147
  ep = fc_exch_find(mp, (int )xid);
#line 1148
  if ((unsigned long )ep == (unsigned long )((struct fc_exch *)0)) {
#line 1149
    return ((struct fc_seq *)0);
  } else {

  }
#line 1150
  if ((int )ep->seq.id == (int )fh->fh_seq_id) {
#line 1154
    sp = & ep->seq;
#line 1155
    if ((f_ctl & 8388608U) != 0U && (unsigned int )ep->rxid == 65535U) {
#line 1157
      tmp___2 = __fswab16((int )fh->fh_rx_id);
#line 1157
      ep->rxid = tmp___2;
    } else {

    }
  } else {

  }
#line 1160
  fc_exch_release(ep);
#line 1161
  return (sp);
}
}
#line 1172 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_exch_set_addr(struct fc_exch *ep , u32 orig_id , u32 resp_id ) 
{ 


  {
#line 1175
  ep->oid = orig_id;
#line 1176
  if ((int )ep->esb_stat < 0) {
#line 1177
    ep->sid = resp_id;
#line 1178
    ep->did = orig_id;
  } else {
#line 1180
    ep->sid = orig_id;
#line 1181
    ep->did = resp_id;
  }
#line 1183
  return;
}
}
#line 1194 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_seq_els_rsp_send(struct fc_frame *fp , enum fc_els_cmd els_cmd , struct fc_seq_els_data *els_data ) 
{ 
  long tmp ;

  {
#line 1197
  switch ((unsigned int )els_cmd) {
  case 1U: 
#line 1199
  fc_seq_ls_rjt(fp, els_data->reason, els_data->explan);
#line 1200
  goto ldv_41505;
  case 2U: 
#line 1202
  fc_seq_ls_acc(fp);
#line 1203
  goto ldv_41505;
  case 18U: 
#line 1205
  fc_exch_els_rrq(fp);
#line 1206
  goto ldv_41505;
  case 19U: 
#line 1208
  fc_exch_els_rec(fp);
#line 1209
  goto ldv_41505;
  default: 
#line 1211
  tmp = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1211
  if (tmp != 0L) {
#line 1211
    printk("\016host%u: lport %6.6x: Invalid ELS CMD:%x\n", ((((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_dev)->host)->host_no,
           (((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_dev)->port_id, (unsigned int )els_cmd);
  } else {

  }
  }
  ldv_41505: ;
#line 1214
  return;
}
}
#line 1222 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_seq_send_last(struct fc_seq *sp , struct fc_frame *fp , enum fc_rctl rctl ,
                             enum fc_fh_type fh_type ) 
{ 
  u32 f_ctl ;
  struct fc_exch *ep ;
  struct fc_seq  const  *__mptr ;

  {
#line 1226
  __mptr = (struct fc_seq  const  *)sp;
#line 1226
  ep = (struct fc_exch *)__mptr + 0xffffffffffffff64UL;
#line 1228
  f_ctl = 1638400U;
#line 1229
  f_ctl = ep->f_ctl | f_ctl;
#line 1230
  fc_fill_fc_hdr(fp, rctl, ep->did, ep->sid, fh_type, f_ctl, 0U);
#line 1231
  fc_seq_send_locked(ep->lp, sp, fp);
#line 1232
  return;
}
}
#line 1241 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_seq_send_ack(struct fc_seq *sp , struct fc_frame  const  *rx_fp ) 
{ 
  struct fc_frame *fp ;
  struct fc_frame_header *rx_fh ;
  struct fc_frame_header *fh ;
  struct fc_exch *ep ;
  struct fc_seq  const  *__mptr ;
  struct fc_lport *lport ;
  unsigned int f_ctl ;
  int tmp ;

  {
#line 1246
  __mptr = (struct fc_seq  const  *)sp;
#line 1246
  ep = (struct fc_exch *)__mptr + 0xffffffffffffff64UL;
#line 1247
  lport = ep->lp;
#line 1253
  tmp = fc_sof_needs_ack((int )((struct fcoe_rcv_info *)(& rx_fp->skb.cb))->fr_sof);
#line 1253
  if (tmp != 0) {
#line 1254
    fp = fc_frame_alloc(lport, 0UL);
#line 1255
    if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1256
      return;
    } else {

    }
#line 1258
    fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 1259
    fh->fh_r_ctl = 192U;
#line 1260
    fh->fh_type = 0U;
#line 1269
    rx_fh = fc_frame_header_get(rx_fp);
#line 1270
    f_ctl = ntoh24((u8 const   *)(& rx_fh->fh_f_ctl));
#line 1271
    f_ctl = f_ctl & 16581376U;
#line 1275
    f_ctl = f_ctl ^ 12582912U;
#line 1276
    hton24((u8 *)(& fh->fh_f_ctl), f_ctl);
#line 1278
    fc_exch_setup_hdr(ep, fp, f_ctl);
#line 1279
    fh->fh_seq_id = rx_fh->fh_seq_id;
#line 1280
    fh->fh_seq_cnt = rx_fh->fh_seq_cnt;
#line 1281
    fh->fh_parm_offset = 16777216U;
#line 1283
    ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_sof = ((struct fcoe_rcv_info *)(& rx_fp->skb.cb))->fr_sof;
#line 1284
    if ((f_ctl & 524288U) != 0U) {
#line 1285
      ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_eof = 66U;
    } else {
#line 1287
      ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_eof = 65U;
    }
#line 1289
    (*(lport->tt.frame_send))(lport, fp);
  } else {

  }
#line 1291
  return;
}
}
#line 1301 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_exch_send_ba_rjt(struct fc_frame *rx_fp , enum fc_ba_rjt_reason reason ,
                                enum fc_ba_rjt_explan explan ) 
{ 
  struct fc_frame *fp ;
  struct fc_frame_header *rx_fh ;
  struct fc_frame_header *fh ;
  struct fc_ba_rjt *rp ;
  struct fc_lport *lport ;
  unsigned int f_ctl ;
  void *tmp ;
  enum fc_class tmp___0 ;
  int tmp___1 ;

  {
#line 1312
  lport = ((struct fcoe_rcv_info *)(& rx_fp->skb.cb))->fr_dev;
#line 1313
  fp = fc_frame_alloc(lport, 4UL);
#line 1314
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1315
    return;
  } else {

  }
#line 1316
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 1317
  rx_fh = fc_frame_header_get((struct fc_frame  const  *)rx_fp);
#line 1319
  memset((void *)fh, 0, 28UL);
#line 1321
  tmp = fc_frame_payload_get((struct fc_frame  const  *)fp, 4UL);
#line 1321
  rp = (struct fc_ba_rjt *)tmp;
#line 1322
  rp->br_reason = (__u8 )reason;
#line 1323
  rp->br_explan = (__u8 )explan;
#line 1328
  memcpy((void *)(& fh->fh_s_id), (void const   *)(& rx_fh->fh_d_id), 3UL);
#line 1329
  memcpy((void *)(& fh->fh_d_id), (void const   *)(& rx_fh->fh_s_id), 3UL);
#line 1330
  fh->fh_ox_id = rx_fh->fh_ox_id;
#line 1331
  fh->fh_rx_id = rx_fh->fh_rx_id;
#line 1332
  fh->fh_seq_cnt = rx_fh->fh_seq_cnt;
#line 1333
  fh->fh_r_ctl = 133U;
#line 1334
  fh->fh_type = 0U;
#line 1344
  f_ctl = ntoh24((u8 const   *)(& rx_fh->fh_f_ctl));
#line 1345
  f_ctl = f_ctl & 12911360U;
#line 1348
  f_ctl = f_ctl ^ 12582912U;
#line 1349
  f_ctl = f_ctl | 1572864U;
#line 1350
  f_ctl = f_ctl & 4292870143U;
#line 1351
  hton24((u8 *)(& fh->fh_f_ctl), f_ctl);
#line 1353
  tmp___0 = fc_sof_class((int )((struct fcoe_rcv_info *)(& rx_fp->skb.cb))->fr_sof);
#line 1353
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_sof = (u8 )tmp___0;
#line 1354
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_eof = 66U;
#line 1355
  tmp___1 = fc_sof_needs_ack((int )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_sof);
#line 1355
  if (tmp___1 != 0) {
#line 1356
    ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_eof = 65U;
  } else {

  }
#line 1358
  (*(lport->tt.frame_send))(lport, fp);
#line 1359
  return;
}
}
#line 1370 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_exch_recv_abts(struct fc_exch *ep , struct fc_frame *rx_fp ) 
{ 
  struct fc_frame *fp ;
  struct fc_ba_acc *ap ;
  struct fc_frame_header *fh ;
  struct fc_seq *sp ;
  void *tmp ;
  __u16 tmp___0 ;

  {
#line 1377
  if ((unsigned long )ep == (unsigned long )((struct fc_exch *)0)) {
#line 1378
    goto reject;
  } else {

  }
#line 1380
  fp = fc_frame_alloc(ep->lp, 12UL);
#line 1381
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1382
    goto free;
  } else {

  }
#line 1384
  spin_lock_bh(& ep->ex_lock);
#line 1385
  if ((ep->esb_stat & 536870912U) != 0U) {
#line 1386
    spin_unlock_bh(& ep->ex_lock);
#line 1388
    fc_frame_free(fp);
#line 1389
    goto reject;
  } else {

  }
#line 1391
  if ((ep->esb_stat & 67108864U) == 0U) {
#line 1392
    ep->esb_stat = ep->esb_stat | 67108864U;
#line 1393
    fc_exch_hold(ep);
  } else {

  }
#line 1395
  fc_exch_timer_set_locked(ep, ep->r_a_tov);
#line 1396
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 1397
  tmp = fc_frame_payload_get((struct fc_frame  const  *)fp, 12UL);
#line 1397
  ap = (struct fc_ba_acc *)tmp;
#line 1398
  memset((void *)ap, 0, 12UL);
#line 1399
  sp = & ep->seq;
#line 1400
  ap->ba_high_seq_cnt = 65535U;
#line 1401
  if ((int )((short )sp->ssb_stat) < 0) {
#line 1402
    ap->ba_seq_id = sp->id;
#line 1403
    ap->ba_seq_id_val = 128U;
#line 1404
    ap->ba_high_seq_cnt = fh->fh_seq_cnt;
#line 1405
    tmp___0 = __fswab16((int )sp->cnt);
#line 1405
    ap->ba_low_seq_cnt = tmp___0;
  } else {

  }
#line 1407
  sp = fc_seq_start_next_locked(sp);
#line 1408
  fc_seq_send_last(sp, fp, 132, 0);
#line 1409
  ep->esb_stat = ep->esb_stat | 268435456U;
#line 1410
  spin_unlock_bh(& ep->ex_lock);
  free: 
#line 1413
  fc_frame_free(rx_fp);
#line 1414
  return;
  reject: 
#line 1417
  fc_exch_send_ba_rjt(rx_fp, 9, 3);
#line 1418
  goto free;
}
}
#line 1430 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static struct fc_seq *fc_seq_assign(struct fc_lport *lport , struct fc_frame *fp ) 
{ 
  struct fc_exch_mgr_anchor *ema ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;
  struct list_head  const  *__mptr ;
  bool tmp___1 ;
  enum fc_pf_rjt_reason tmp___2 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1434
  __ret_warn_on = (unsigned long )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_dev != (unsigned long )lport;
#line 1434
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1434
  if (tmp != 0L) {
#line 1434
    warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c",
                       1434);
  } else {

  }
#line 1434
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1435
  __ret_warn_on___0 = (unsigned long )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_seq != (unsigned long )((struct fc_seq *)0);
#line 1435
  tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 1435
  if (tmp___0 != 0L) {
#line 1435
    warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c",
                       1435);
  } else {

  }
#line 1435
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 1436
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_seq = (struct fc_seq *)0;
#line 1438
  __mptr = (struct list_head  const  *)lport->ema_list.next;
#line 1438
  ema = (struct fc_exch_mgr_anchor *)__mptr;
#line 1438
  goto ldv_41568;
  ldv_41567: ;
#line 1439
  if ((unsigned long )ema->match == (unsigned long )((bool (*)(struct fc_frame * ))0)) {
#line 1439
    goto _L;
  } else {
#line 1439
    tmp___1 = (*(ema->match))(fp);
#line 1439
    if ((int )tmp___1) {
      _L: /* CIL Label */ 
#line 1439
      tmp___2 = fc_seq_lookup_recip(lport, ema->mp, fp);
#line 1439
      if ((unsigned int )tmp___2 == 0U) {
#line 1441
        goto ldv_41566;
      } else {

      }
    } else {

    }
  }
#line 1438
  __mptr___0 = (struct list_head  const  *)ema->ema_list.next;
#line 1438
  ema = (struct fc_exch_mgr_anchor *)__mptr___0;
  ldv_41568: ;
#line 1438
  if ((unsigned long )(& ema->ema_list) != (unsigned long )(& lport->ema_list)) {
#line 1440
    goto ldv_41567;
  } else {

  }
  ldv_41566: ;
#line 1442
  return (((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_seq);
}
}
#line 1449 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_seq_release(struct fc_seq *sp ) 
{ 
  struct fc_seq  const  *__mptr ;

  {
#line 1451
  __mptr = (struct fc_seq  const  *)sp;
#line 1451
  fc_exch_release((struct fc_exch *)__mptr + 0xffffffffffffff64UL);
#line 1453
  return;
}
}
#line 1463 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_exch_recv_req(struct fc_lport *lport , struct fc_exch_mgr *mp , struct fc_frame *fp ) 
{ 
  struct fc_frame_header *fh ;
  struct fc_frame_header *tmp ;
  struct fc_seq *sp ;
  struct fc_exch *ep ;
  enum fc_pf_rjt_reason reject ;
  u32 tmp___0 ;
  long tmp___1 ;
  struct fc_seq  const  *__mptr ;
  bool tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 1466
  tmp = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 1466
  fh = tmp;
#line 1467
  sp = (struct fc_seq *)0;
#line 1468
  ep = (struct fc_exch *)0;
#line 1474
  tmp___0 = ntoh24((u8 const   *)(& fh->fh_d_id));
#line 1474
  lport = fc_vport_id_lookup(lport, tmp___0);
#line 1475
  if ((unsigned long )lport == (unsigned long )((struct fc_lport *)0)) {
#line 1476
    fc_frame_free(fp);
#line 1477
    return;
  } else {

  }
#line 1479
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_dev = lport;
#line 1481
  tmp___1 = ldv__builtin_expect((unsigned long )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_seq != (unsigned long )((struct fc_seq *)0),
                             0L);
#line 1481
  if (tmp___1 != 0L) {
#line 1481
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"),
                         "i" (1481), "i" (12UL));
    ldv_41583: ;
#line 1481
    goto ldv_41583;
  } else {

  }
#line 1487
  if ((unsigned int )fh->fh_rx_id == 65535U) {
#line 1488
    return;
  } else {

  }
#line 1490
  reject = fc_seq_lookup_recip(lport, mp, fp);
#line 1491
  if ((unsigned int )reject == 0U) {
#line 1492
    sp = ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_seq;
#line 1493
    __mptr = (struct fc_seq  const  *)sp;
#line 1493
    ep = (struct fc_exch *)__mptr + 0xffffffffffffff64UL;
#line 1494
    fc_seq_send_ack(sp, (struct fc_frame  const  *)fp);
#line 1495
    ep->encaps = ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_encaps;
#line 1508
    tmp___2 = fc_invoke_resp(ep, sp, fp);
#line 1508
    if (tmp___2) {
#line 1508
      tmp___3 = 0;
    } else {
#line 1508
      tmp___3 = 1;
    }
#line 1508
    if (tmp___3) {
#line 1509
      (*(lport->tt.lport_recv))(lport, fp);
    } else {

    }
#line 1510
    fc_exch_release(ep);
  } else {
#line 1512
    tmp___4 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1512
    if (tmp___4 != 0L) {
#line 1512
      printk("\016host%u: lport %6.6x: exch/seq lookup failed: reject %x\n", (lport->host)->host_no,
             lport->port_id, (unsigned int )reject);
    } else {

    }
#line 1514
    fc_frame_free(fp);
  }
#line 1516
  return;
}
}
#line 1525 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_exch_recv_seq_resp(struct fc_exch_mgr *mp , struct fc_frame *fp ) 
{ 
  struct fc_frame_header *fh ;
  struct fc_frame_header *tmp ;
  struct fc_seq *sp ;
  struct fc_exch *ep ;
  enum fc_sof sof ;
  u32 f_ctl ;
  int rc ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int __ret_warn_on ;
  struct fc_seq  const  *__mptr ;
  long tmp___6 ;

  {
#line 1527
  tmp = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 1527
  fh = tmp;
#line 1534
  tmp___0 = __fswab16((int )fh->fh_ox_id);
#line 1534
  ep = fc_exch_find(mp, (int )tmp___0);
#line 1535
  if ((unsigned long )ep == (unsigned long )((struct fc_exch *)0)) {
#line 1536
    atomic_inc(& mp->stats.xid_not_found);
#line 1537
    goto out;
  } else {

  }
#line 1539
  if ((ep->esb_stat & 536870912U) != 0U) {
#line 1540
    atomic_inc(& mp->stats.xid_not_found);
#line 1541
    goto rel;
  } else {

  }
#line 1543
  if ((unsigned int )ep->rxid == 65535U) {
#line 1544
    tmp___1 = __fswab16((int )fh->fh_rx_id);
#line 1544
    ep->rxid = tmp___1;
  } else {

  }
#line 1545
  if (ep->sid != 0U) {
#line 1545
    tmp___2 = ntoh24((u8 const   *)(& fh->fh_d_id));
#line 1545
    if (ep->sid != tmp___2) {
#line 1546
      atomic_inc(& mp->stats.xid_not_found);
#line 1547
      goto rel;
    } else {

    }
  } else {

  }
#line 1549
  tmp___3 = ntoh24((u8 const   *)(& fh->fh_s_id));
#line 1549
  if (ep->did != tmp___3 && ep->did != 16777214U) {
#line 1551
    atomic_inc(& mp->stats.xid_not_found);
#line 1552
    goto rel;
  } else {

  }
#line 1554
  sof = (enum fc_sof )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_sof;
#line 1555
  sp = & ep->seq;
#line 1556
  tmp___4 = fc_sof_is_init((int )sof);
#line 1556
  if (tmp___4 != 0) {
#line 1557
    sp->ssb_stat = (u16 )((unsigned int )sp->ssb_stat | 32768U);
#line 1558
    sp->id = fh->fh_seq_id;
  } else
#line 1559
  if ((int )sp->id != (int )fh->fh_seq_id) {
#line 1560
    atomic_inc(& mp->stats.seq_not_found);
#line 1561
    goto rel;
  } else {

  }
#line 1564
  f_ctl = ntoh24((u8 const   *)(& fh->fh_f_ctl));
#line 1565
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_seq = sp;
#line 1567
  spin_lock_bh(& ep->ex_lock);
#line 1568
  if ((f_ctl & 65536U) != 0U) {
#line 1569
    ep->esb_stat = ep->esb_stat | 1073741824U;
  } else {

  }
#line 1570
  spin_unlock_bh(& ep->ex_lock);
#line 1572
  tmp___5 = fc_sof_needs_ack((int )sof);
#line 1572
  if (tmp___5 != 0) {
#line 1573
    fc_seq_send_ack(sp, (struct fc_frame  const  *)fp);
  } else {

  }
#line 1575
  if (((unsigned int )fh->fh_type != 8U && (unsigned int )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_eof == 66U) && (f_ctl & 1572864U) == 1572864U) {
#line 1578
    spin_lock_bh(& ep->ex_lock);
#line 1579
    rc = fc_exch_done_locked(ep);
#line 1580
    __mptr = (struct fc_seq  const  *)sp;
#line 1580
    __ret_warn_on = (unsigned long )((struct fc_exch *)__mptr + 0xffffffffffffff64UL) != (unsigned long )ep;
#line 1580
    tmp___6 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1580
    if (tmp___6 != 0L) {
#line 1580
      warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c",
                         1580);
    } else {

    }
#line 1580
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1581
    spin_unlock_bh(& ep->ex_lock);
#line 1582
    if (rc == 0) {
#line 1583
      fc_exch_delete(ep);
    } else {

    }
  } else {

  }
#line 1599
  fc_invoke_resp(ep, sp, fp);
#line 1601
  fc_exch_release(ep);
#line 1602
  return;
  rel: 
#line 1604
  fc_exch_release(ep);
  out: 
#line 1606
  fc_frame_free(fp);
#line 1607
  return;
}
}
#line 1615 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_exch_recv_resp(struct fc_exch_mgr *mp , struct fc_frame *fp ) 
{ 
  struct fc_seq *sp ;

  {
#line 1619
  sp = fc_seq_lookup_orig(mp, fp);
#line 1621
  if ((unsigned long )sp == (unsigned long )((struct fc_seq *)0)) {
#line 1622
    atomic_inc(& mp->stats.xid_not_found);
  } else {
#line 1624
    atomic_inc(& mp->stats.non_bls_resp);
  }
#line 1626
  fc_frame_free(fp);
#line 1627
  return;
}
}
#line 1637 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_exch_abts_resp(struct fc_exch *ep , struct fc_frame *fp ) 
{ 
  struct fc_frame_header *fh ;
  struct fc_ba_acc *ap ;
  struct fc_seq *sp ;
  u16 low ;
  u16 high ;
  int rc ;
  int has_rec ;
  char const   *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  void *tmp___3 ;
  __u16 tmp___4 ;
  __u16 tmp___5 ;
  u32 tmp___6 ;

  {
#line 1644
  rc = 1;
#line 1644
  has_rec = 0;
#line 1646
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 1647
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 64U) != 0U, 0L);
#line 1647
  if (tmp___0 != 0L) {
#line 1647
    tmp = fc_exch_rctl_name((unsigned int )fh->fh_r_ctl);
#line 1647
    printk("\016host%u: xid %4x: exch: BLS rctl %x - %s\n", ((ep->lp)->host)->host_no,
           (int )ep->xid, (int )fh->fh_r_ctl, tmp);
  } else {

  }
#line 1650
  tmp___2 = ldv_cancel_delayed_work_sync_138(& ep->timeout_work);
#line 1650
  if ((int )tmp___2) {
#line 1651
    tmp___1 = ldv__builtin_expect((fc_debug_logging & 64U) != 0U, 0L);
#line 1651
    if (tmp___1 != 0L) {
#line 1651
      printk("\016host%u: xid %4x: Exchange timer canceled due to ABTS response\n",
             ((ep->lp)->host)->host_no, (int )ep->xid);
    } else {

    }
#line 1652
    fc_exch_release(ep);
  } else {

  }
#line 1655
  spin_lock_bh(& ep->ex_lock);
#line 1656
  switch ((int )fh->fh_r_ctl) {
  case 132: 
#line 1658
  tmp___3 = fc_frame_payload_get((struct fc_frame  const  *)fp, 12UL);
#line 1658
  ap = (struct fc_ba_acc *)tmp___3;
#line 1659
  if ((unsigned long )ap == (unsigned long )((struct fc_ba_acc *)0)) {
#line 1660
    goto ldv_41619;
  } else {

  }
#line 1667
  tmp___4 = __fswab16((int )ap->ba_low_seq_cnt);
#line 1667
  low = tmp___4;
#line 1668
  tmp___5 = __fswab16((int )ap->ba_high_seq_cnt);
#line 1668
  high = tmp___5;
#line 1669
  if (((ep->esb_stat & 67108864U) == 0U && ((unsigned int )ap->ba_seq_id_val != 128U || (int )ap->ba_seq_id == (int )ep->seq_id)) && (int )low != (int )high) {
#line 1672
    ep->esb_stat = ep->esb_stat | 67108864U;
#line 1673
    fc_exch_hold(ep);
#line 1674
    has_rec = 1;
  } else {

  }
#line 1676
  goto ldv_41619;
  case 133: ;
#line 1678
  goto ldv_41619;
  default: ;
#line 1680
  goto ldv_41619;
  }
  ldv_41619: 
#line 1686
  sp = & ep->seq;
#line 1690
  if ((unsigned int )ep->fh_type != 8U) {
#line 1690
    tmp___6 = ntoh24((u8 const   *)(& fh->fh_f_ctl));
#line 1690
    if ((tmp___6 & 1048576U) != 0U) {
#line 1692
      rc = fc_exch_done_locked(ep);
    } else {

    }
  } else {

  }
#line 1693
  spin_unlock_bh(& ep->ex_lock);
#line 1695
  fc_exch_hold(ep);
#line 1696
  if (rc == 0) {
#line 1697
    fc_exch_delete(ep);
  } else {

  }
#line 1698
  fc_invoke_resp(ep, sp, fp);
#line 1699
  if (has_rec != 0) {
#line 1700
    fc_exch_timer_set(ep, ep->r_a_tov);
  } else {

  }
#line 1701
  fc_exch_release(ep);
#line 1702
  return;
}
}
#line 1712 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_exch_recv_bls(struct fc_exch_mgr *mp , struct fc_frame *fp ) 
{ 
  struct fc_frame_header *fh ;
  struct fc_exch *ep ;
  u32 f_ctl ;
  __u16 tmp ;
  __u16 tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  long tmp___3 ;

  {
#line 1718
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 1719
  f_ctl = ntoh24((u8 const   *)(& fh->fh_f_ctl));
#line 1720
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_seq = (struct fc_seq *)0;
#line 1722
  if ((f_ctl & 8388608U) != 0U) {
#line 1722
    tmp = __fswab16((int )fh->fh_ox_id);
#line 1722
    tmp___1 = tmp;
  } else {
#line 1722
    tmp___0 = __fswab16((int )fh->fh_rx_id);
#line 1722
    tmp___1 = tmp___0;
  }
#line 1722
  ep = fc_exch_find(mp, tmp___1);
#line 1724
  if ((unsigned long )ep != (unsigned long )((struct fc_exch *)0) && (f_ctl & 65536U) != 0U) {
#line 1725
    spin_lock_bh(& ep->ex_lock);
#line 1726
    ep->esb_stat = ep->esb_stat | 1073741824U;
#line 1727
    spin_unlock_bh(& ep->ex_lock);
  } else {

  }
#line 1729
  if ((f_ctl & 4194304U) != 0U) {
#line 1734
    switch ((int )fh->fh_r_ctl) {
    case 192: ;
    case 193: ;
#line 1737
    goto ldv_41631;
    default: ;
#line 1739
    if ((unsigned long )ep != (unsigned long )((struct fc_exch *)0)) {
#line 1740
      tmp___3 = ldv__builtin_expect((fc_debug_logging & 64U) != 0U, 0L);
#line 1740
      if (tmp___3 != 0L) {
#line 1740
        tmp___2 = fc_exch_rctl_name((unsigned int )fh->fh_r_ctl);
#line 1740
        printk("\016host%u: xid %4x: BLS rctl %x - %s received\n", ((ep->lp)->host)->host_no,
               (int )ep->xid, (int )fh->fh_r_ctl, tmp___2);
      } else {

      }
    } else {

    }
#line 1743
    goto ldv_41631;
    }
    ldv_41631: 
#line 1745
    fc_frame_free(fp);
  } else {
#line 1747
    switch ((int )fh->fh_r_ctl) {
    case 133: ;
    case 132: ;
#line 1750
    if ((unsigned long )ep != (unsigned long )((struct fc_exch *)0)) {
#line 1751
      fc_exch_abts_resp(ep, fp);
    } else {
#line 1753
      fc_frame_free(fp);
    }
#line 1754
    goto ldv_41635;
    case 129: 
#line 1756
    fc_exch_recv_abts(ep, fp);
#line 1757
    goto ldv_41635;
    default: 
#line 1759
    fc_frame_free(fp);
#line 1760
    goto ldv_41635;
    }
    ldv_41635: ;
  }
#line 1763
  if ((unsigned long )ep != (unsigned long )((struct fc_exch *)0)) {
#line 1764
    fc_exch_release(ep);
  } else {

  }
#line 1765
  return;
}
}
#line 1774 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_seq_ls_acc(struct fc_frame *rx_fp ) 
{ 
  struct fc_lport *lport ;
  struct fc_els_ls_acc *acc ;
  struct fc_frame *fp ;
  void *tmp ;

  {
#line 1780
  lport = ((struct fcoe_rcv_info *)(& rx_fp->skb.cb))->fr_dev;
#line 1781
  fp = fc_frame_alloc(lport, 4UL);
#line 1782
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1783
    return;
  } else {

  }
#line 1784
  tmp = fc_frame_payload_get((struct fc_frame  const  *)fp, 4UL);
#line 1784
  acc = (struct fc_els_ls_acc *)tmp;
#line 1785
  memset((void *)acc, 0, 4UL);
#line 1786
  acc->la_cmd = 2U;
#line 1787
  fc_fill_reply_hdr(fp, (struct fc_frame  const  *)rx_fp, 35, 0U);
#line 1788
  (*(lport->tt.frame_send))(lport, fp);
#line 1789
  return;
}
}
#line 1800 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_seq_ls_rjt(struct fc_frame *rx_fp , enum fc_els_rjt_reason reason ,
                          enum fc_els_rjt_explan explan ) 
{ 
  struct fc_lport *lport ;
  struct fc_els_ls_rjt *rjt ;
  struct fc_frame *fp ;
  void *tmp ;

  {
#line 1807
  lport = ((struct fcoe_rcv_info *)(& rx_fp->skb.cb))->fr_dev;
#line 1808
  fp = fc_frame_alloc(lport, 8UL);
#line 1809
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1810
    return;
  } else {

  }
#line 1811
  tmp = fc_frame_payload_get((struct fc_frame  const  *)fp, 8UL);
#line 1811
  rjt = (struct fc_els_ls_rjt *)tmp;
#line 1812
  memset((void *)rjt, 0, 8UL);
#line 1813
  rjt->er_cmd = 1U;
#line 1814
  rjt->er_reason = (__u8 )reason;
#line 1815
  rjt->er_explan = (__u8 )explan;
#line 1816
  fc_fill_reply_hdr(fp, (struct fc_frame  const  *)rx_fp, 35, 0U);
#line 1817
  (*(lport->tt.frame_send))(lport, fp);
#line 1818
  return;
}
}
#line 1826 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_exch_reset(struct fc_exch *ep ) 
{ 
  struct fc_seq *sp ;
  int rc ;
  void *tmp ;

  {
#line 1829
  rc = 1;
#line 1831
  spin_lock_bh(& ep->ex_lock);
#line 1832
  fc_exch_abort_locked(ep, 0U);
#line 1833
  ep->state = (u8 )((unsigned int )ep->state | 2U);
#line 1834
  fc_exch_timer_cancel(ep);
#line 1835
  if ((ep->esb_stat & 67108864U) != 0U) {
#line 1836
    atomic_dec(& ep->ex_refcnt);
  } else {

  }
#line 1837
  ep->esb_stat = ep->esb_stat & 4227858431U;
#line 1838
  sp = & ep->seq;
#line 1839
  rc = fc_exch_done_locked(ep);
#line 1840
  spin_unlock_bh(& ep->ex_lock);
#line 1842
  fc_exch_hold(ep);
#line 1844
  if (rc == 0) {
#line 1845
    fc_exch_delete(ep);
  } else {

  }
#line 1847
  tmp = ERR_PTR(-2L);
#line 1847
  fc_invoke_resp(ep, sp, (struct fc_frame *)tmp);
#line 1848
  fc_seq_set_resp(sp, (void (*)(struct fc_seq * , struct fc_frame * , void * ))0,
                  ep->arg);
#line 1849
  fc_exch_release(ep);
#line 1850
  return;
}
}
#line 1864 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_exch_pool_reset(struct fc_lport *lport , struct fc_exch_pool *pool ,
                               u32 sid , u32 did ) 
{ 
  struct fc_exch *ep ;
  struct fc_exch *next ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 1871
  spin_lock_bh(& pool->lock);
  restart: 
#line 1873
  __mptr = (struct list_head  const  *)pool->ex_list.next;
#line 1873
  ep = (struct fc_exch *)__mptr + 0xffffffffffffffa0UL;
#line 1873
  __mptr___0 = (struct list_head  const  *)ep->ex_list.next;
#line 1873
  next = (struct fc_exch *)__mptr___0 + 0xffffffffffffffa0UL;
#line 1873
  goto ldv_41673;
  ldv_41672: ;
#line 1874
  if (((unsigned long )ep->lp == (unsigned long )lport && (sid == 0U || ep->sid == sid)) && (did == 0U || ep->did == did)) {
#line 1877
    fc_exch_hold(ep);
#line 1878
    spin_unlock_bh(& pool->lock);
#line 1880
    fc_exch_reset(ep);
#line 1882
    fc_exch_release(ep);
#line 1883
    spin_lock_bh(& pool->lock);
#line 1889
    goto restart;
  } else {

  }
#line 1873
  ep = next;
#line 1873
  __mptr___1 = (struct list_head  const  *)next->ex_list.next;
#line 1873
  next = (struct fc_exch *)__mptr___1 + 0xffffffffffffffa0UL;
  ldv_41673: ;
#line 1873
  if ((unsigned long )(& ep->ex_list) != (unsigned long )(& pool->ex_list)) {
#line 1875
    goto ldv_41672;
  } else {

  }
#line 1892
  pool->next_index = 0U;
#line 1893
  pool->left = 65535U;
#line 1894
  pool->right = 65535U;
#line 1895
  spin_unlock_bh(& pool->lock);
#line 1896
  return;
}
}
#line 1909 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
void fc_exch_mgr_reset(struct fc_lport *lport , u32 sid , u32 did ) 
{ 
  struct fc_exch_mgr_anchor *ema ;
  unsigned int cpu ;
  struct list_head  const  *__mptr ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1914
  __mptr = (struct list_head  const  *)lport->ema_list.next;
#line 1914
  ema = (struct fc_exch_mgr_anchor *)__mptr;
#line 1914
  goto ldv_41694;
  ldv_41693: 
#line 1915
  cpu = 4294967295U;
#line 1915
  goto ldv_41691;
  ldv_41690: 
#line 1917
  __vpp_verify = (void const   *)0;
#line 1917
  __asm__  ("": "=r" (__ptr): "0" ((ema->mp)->pool));
#line 1917
  fc_exch_pool_reset(lport, (struct fc_exch_pool *)(__per_cpu_offset[cpu] + __ptr),
                     sid, did);
  ldv_41691: 
#line 1915
  cpu = cpumask_next((int )cpu, cpu_possible_mask);
#line 1915
  if ((unsigned int )nr_cpu_ids > cpu) {
#line 1917
    goto ldv_41690;
  } else {

  }
#line 1914
  __mptr___0 = (struct list_head  const  *)ema->ema_list.next;
#line 1914
  ema = (struct fc_exch_mgr_anchor *)__mptr___0;
  ldv_41694: ;
#line 1914
  if ((unsigned long )(& ema->ema_list) != (unsigned long )(& lport->ema_list)) {
#line 1916
    goto ldv_41693;
  } else {

  }

#line 1921
  return;
}
}
#line 1921 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static char const   __kstrtab_fc_exch_mgr_reset[18U]  = 
#line 1921
  {      'f',      'c',      '_',      'e', 
        'x',      'c',      'h',      '_', 
        'm',      'g',      'r',      '_', 
        'r',      'e',      's',      'e', 
        't',      '\000'};
#line 1921
struct kernel_symbol  const  __ksymtab_fc_exch_mgr_reset ;
#line 1921 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
struct kernel_symbol  const  __ksymtab_fc_exch_mgr_reset  =    {(unsigned long )(& fc_exch_mgr_reset), (char const   *)(& __kstrtab_fc_exch_mgr_reset)};
#line 1930 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static struct fc_exch *fc_exch_lookup(struct fc_lport *lport , u32 xid ) 
{ 
  struct fc_exch_mgr_anchor *ema ;
  struct list_head  const  *__mptr ;
  struct fc_exch *tmp ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1934
  __mptr = (struct list_head  const  *)lport->ema_list.next;
#line 1934
  ema = (struct fc_exch_mgr_anchor *)__mptr;
#line 1934
  goto ldv_41715;
  ldv_41714: ;
#line 1935
  if ((u32 )(ema->mp)->min_xid <= xid && (u32 )(ema->mp)->max_xid >= xid) {
#line 1936
    tmp = fc_exch_find(ema->mp, (int )((u16 )xid));
#line 1936
    return (tmp);
  } else {

  }
#line 1934
  __mptr___0 = (struct list_head  const  *)ema->ema_list.next;
#line 1934
  ema = (struct fc_exch_mgr_anchor *)__mptr___0;
  ldv_41715: ;
#line 1934
  if ((unsigned long )(& ema->ema_list) != (unsigned long )(& lport->ema_list)) {
#line 1936
    goto ldv_41714;
  } else {

  }

#line 1937
  return ((struct fc_exch *)0);
}
}
#line 1946 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_exch_els_rec(struct fc_frame *rfp ) 
{ 
  struct fc_lport *lport ;
  struct fc_frame *fp ;
  struct fc_exch *ep ;
  struct fc_els_rec *rp ;
  struct fc_els_rec_acc *acc ;
  enum fc_els_rjt_reason reason ;
  enum fc_els_rjt_explan explan ;
  u32 sid ;
  u16 rxid ;
  u16 oxid ;
  void *tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  void *tmp___2 ;
  __u16 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;

  {
#line 1953
  reason = 3;
#line 1959
  lport = ((struct fcoe_rcv_info *)(& rfp->skb.cb))->fr_dev;
#line 1960
  tmp = fc_frame_payload_get((struct fc_frame  const  *)rfp, 12UL);
#line 1960
  rp = (struct fc_els_rec *)tmp;
#line 1961
  explan = 45;
#line 1962
  if ((unsigned long )rp == (unsigned long )((struct fc_els_rec *)0)) {
#line 1963
    goto reject;
  } else {

  }
#line 1964
  sid = ntoh24((u8 const   *)(& rp->rec_s_id));
#line 1965
  tmp___0 = __fswab16((int )rp->rec_rx_id);
#line 1965
  rxid = tmp___0;
#line 1966
  tmp___1 = __fswab16((int )rp->rec_ox_id);
#line 1966
  oxid = tmp___1;
#line 1968
  ep = fc_exch_lookup(lport, (u32 )(((struct fc_host_attrs *)(lport->host)->shost_data)->port_id == sid ? oxid : rxid));
#line 1970
  explan = 23;
#line 1971
  if ((unsigned long )ep == (unsigned long )((struct fc_exch *)0)) {
#line 1972
    goto reject;
  } else {

  }
#line 1973
  if (ep->oid != sid || (int )ep->oxid != (int )oxid) {
#line 1974
    goto rel;
  } else {

  }
#line 1975
  if ((unsigned int )rxid != 65535U && (int )ep->rxid != (int )rxid) {
#line 1976
    goto rel;
  } else {

  }
#line 1977
  fp = fc_frame_alloc(lport, 24UL);
#line 1978
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1979
    goto out;
  } else {

  }
#line 1981
  tmp___2 = fc_frame_payload_get((struct fc_frame  const  *)fp, 24UL);
#line 1981
  acc = (struct fc_els_rec_acc *)tmp___2;
#line 1982
  memset((void *)acc, 0, 24UL);
#line 1983
  acc->reca_cmd = 2U;
#line 1984
  acc->reca_ox_id = rp->rec_ox_id;
#line 1985
  memcpy((void *)(& acc->reca_ofid), (void const   *)(& rp->rec_s_id), 3UL);
#line 1986
  tmp___3 = __fswab16((int )ep->rxid);
#line 1986
  acc->reca_rx_id = tmp___3;
#line 1987
  if (ep->sid == ep->oid) {
#line 1988
    hton24((u8 *)(& acc->reca_rfid), ep->did);
  } else {
#line 1990
    hton24((u8 *)(& acc->reca_rfid), ep->sid);
  }
#line 1991
  tmp___4 = __fswab32(ep->seq.rec_data);
#line 1991
  acc->reca_fc4value = tmp___4;
#line 1992
  tmp___5 = __fswab32(ep->esb_stat & 3758096384U);
#line 1992
  acc->reca_e_stat = tmp___5;
#line 1995
  fc_fill_reply_hdr(fp, (struct fc_frame  const  *)rfp, 35, 0U);
#line 1996
  (*(lport->tt.frame_send))(lport, fp);
  out: 
#line 1998
  fc_exch_release(ep);
#line 1999
  return;
  rel: 
#line 2002
  fc_exch_release(ep);
  reject: 
#line 2004
  fc_seq_ls_rjt(rfp, reason, explan);
#line 2005
  return;
}
}
#line 2015 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_exch_rrq_resp(struct fc_seq *sp , struct fc_frame *fp , void *arg ) 
{ 
  struct fc_exch *aborted_ep ;
  unsigned int op ;
  int err ;
  long tmp ;
  long tmp___0 ;
  bool tmp___1 ;
  u8 tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 2017
  aborted_ep = (struct fc_exch *)arg;
#line 2020
  tmp___1 = IS_ERR((void const   *)fp);
#line 2020
  if ((int )tmp___1) {
#line 2021
    tmp = PTR_ERR((void const   *)fp);
#line 2021
    err = (int )tmp;
#line 2023
    if (err == -2 || err == -1) {
#line 2024
      goto cleanup;
    } else {

    }
#line 2025
    tmp___0 = ldv__builtin_expect((fc_debug_logging & 64U) != 0U, 0L);
#line 2025
    if (tmp___0 != 0L) {
#line 2025
      printk("\016host%u: xid %4x: Cannot process RRQ, frame error %d\n", ((aborted_ep->lp)->host)->host_no,
             (int )aborted_ep->xid, err);
    } else {

    }
#line 2027
    return;
  } else {

  }
#line 2030
  tmp___2 = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 2030
  op = (unsigned int )tmp___2;
#line 2031
  fc_frame_free(fp);
#line 2033
  switch (op) {
  case 1U: 
#line 2035
  tmp___3 = ldv__builtin_expect((fc_debug_logging & 64U) != 0U, 0L);
#line 2035
  if (tmp___3 != 0L) {
#line 2035
    printk("\016host%u: xid %4x: LS_RJT for RRQ\n", ((aborted_ep->lp)->host)->host_no,
           (int )aborted_ep->xid);
  } else {

  }
  case 2U: ;
#line 2038
  goto cleanup;
  default: 
#line 2040
  tmp___4 = ldv__builtin_expect((fc_debug_logging & 64U) != 0U, 0L);
#line 2040
  if (tmp___4 != 0L) {
#line 2040
    printk("\016host%u: xid %4x: unexpected response op %x for RRQ\n", ((aborted_ep->lp)->host)->host_no,
           (int )aborted_ep->xid, op);
  } else {

  }
#line 2042
  return;
  }
  cleanup: 
#line 2046
  fc_exch_done(& aborted_ep->seq);
#line 2048
  fc_exch_release(aborted_ep);
#line 2049
  return;
}
}
#line 2071 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static struct fc_seq *fc_exch_seq_send(struct fc_lport *lport , struct fc_frame *fp ,
                                       void (*resp)(struct fc_seq * , struct fc_frame * ,
                                                    void * ) , void (*destructor)(struct fc_seq * ,
                                                                                  void * ) ,
                                       void *arg , u32 timer_msec ) 
{ 
  struct fc_exch *ep ;
  struct fc_seq *sp ;
  struct fc_frame_header *fh ;
  struct fc_fcp_pkt *fsp ;
  int rc ;
  u32 tmp ;
  u32 tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 2081
  sp = (struct fc_seq *)0;
#line 2083
  fsp = (struct fc_fcp_pkt *)0;
#line 2084
  rc = 1;
#line 2086
  ep = fc_exch_alloc(lport, fp);
#line 2087
  if ((unsigned long )ep == (unsigned long )((struct fc_exch *)0)) {
#line 2088
    fc_frame_free(fp);
#line 2089
    return ((struct fc_seq *)0);
  } else {

  }
#line 2091
  ep->esb_stat = ep->esb_stat | 1073741824U;
#line 2092
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 2093
  tmp = ntoh24((u8 const   *)(& fh->fh_d_id));
#line 2093
  tmp___0 = ntoh24((u8 const   *)(& fh->fh_s_id));
#line 2093
  fc_exch_set_addr(ep, tmp___0, tmp);
#line 2094
  ep->resp = resp;
#line 2095
  ep->destructor = destructor;
#line 2096
  ep->arg = arg;
#line 2097
  ep->r_a_tov = 10000U;
#line 2098
  ep->lp = lport;
#line 2099
  sp = & ep->seq;
#line 2101
  ep->fh_type = fh->fh_type;
#line 2102
  ep->f_ctl = ntoh24((u8 const   *)(& fh->fh_f_ctl));
#line 2103
  fc_exch_setup_hdr(ep, fp, ep->f_ctl);
#line 2104
  sp->cnt = (u16 )((int )sp->cnt + 1);
#line 2106
  if ((int )ep->xid <= (int )lport->lro_xid && (unsigned int )fh->fh_r_ctl == 6U) {
#line 2107
    fsp = ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_fsp;
#line 2108
    fc_fcp_ddp_setup(((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_fsp, (int )ep->xid);
  } else {

  }
#line 2111
  tmp___1 = (*(lport->tt.frame_send))(lport, fp);
#line 2111
  tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
#line 2111
  if (tmp___2 != 0L) {
#line 2112
    goto err;
  } else {

  }
#line 2114
  if (timer_msec != 0U) {
#line 2115
    fc_exch_timer_set_locked(ep, timer_msec);
  } else {

  }
#line 2116
  ep->f_ctl = ep->f_ctl & 4292870143U;
#line 2118
  if ((ep->f_ctl & 65536U) != 0U) {
#line 2119
    ep->esb_stat = ep->esb_stat & 3221225471U;
  } else {

  }
#line 2120
  spin_unlock_bh(& ep->ex_lock);
#line 2121
  return (sp);
  err: ;
#line 2123
  if ((unsigned long )fsp != (unsigned long )((struct fc_fcp_pkt *)0)) {
#line 2124
    fc_fcp_ddp_done(fsp);
  } else {

  }
#line 2125
  rc = fc_exch_done_locked(ep);
#line 2126
  spin_unlock_bh(& ep->ex_lock);
#line 2127
  if (rc == 0) {
#line 2128
    fc_exch_delete(ep);
  } else {

  }
#line 2129
  return ((struct fc_seq *)0);
}
}
#line 2139 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_exch_rrq(struct fc_exch *ep ) 
{ 
  struct fc_lport *lport ;
  struct fc_els_rrq *rrq ;
  struct fc_frame *fp ;
  u32 did ;
  void *tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  struct fc_seq *tmp___2 ;

  {
#line 2146
  lport = ep->lp;
#line 2148
  fp = fc_frame_alloc(lport, 12UL);
#line 2149
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 2150
    goto retry;
  } else {

  }
#line 2152
  tmp = fc_frame_payload_get((struct fc_frame  const  *)fp, 12UL);
#line 2152
  rrq = (struct fc_els_rrq *)tmp;
#line 2153
  memset((void *)rrq, 0, 12UL);
#line 2154
  rrq->rrq_cmd = 18U;
#line 2155
  hton24((u8 *)(& rrq->rrq_s_id), ep->sid);
#line 2156
  tmp___0 = __fswab16((int )ep->oxid);
#line 2156
  rrq->rrq_ox_id = tmp___0;
#line 2157
  tmp___1 = __fswab16((int )ep->rxid);
#line 2157
  rrq->rrq_rx_id = tmp___1;
#line 2159
  did = ep->did;
#line 2160
  if ((int )ep->esb_stat < 0) {
#line 2161
    did = ep->sid;
  } else {

  }
#line 2163
  fc_fill_fc_hdr(fp, 34, did, lport->port_id, 1, 2686976U, 0U);
#line 2167
  tmp___2 = fc_exch_seq_send(lport, fp, & fc_exch_rrq_resp, (void (*)(struct fc_seq * ,
                                                                      void * ))0,
                             (void *)ep, lport->e_d_tov);
#line 2167
  if ((unsigned long )tmp___2 != (unsigned long )((struct fc_seq *)0)) {
#line 2169
    return;
  } else {

  }
  retry: 
#line 2172
  spin_lock_bh(& ep->ex_lock);
#line 2173
  if (((int )ep->state & 3) != 0) {
#line 2174
    spin_unlock_bh(& ep->ex_lock);
#line 2176
    fc_exch_release(ep);
#line 2177
    return;
  } else {

  }
#line 2179
  ep->esb_stat = ep->esb_stat | 67108864U;
#line 2180
  fc_exch_timer_set_locked(ep, ep->r_a_tov);
#line 2181
  spin_unlock_bh(& ep->ex_lock);
#line 2182
  return;
}
}
#line 2188 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_exch_els_rrq(struct fc_frame *fp ) 
{ 
  struct fc_lport *lport ;
  struct fc_exch *ep ;
  struct fc_els_rrq *rp ;
  u32 sid ;
  u16 xid ;
  enum fc_els_rjt_explan explan ;
  void *tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;
  __u16 tmp___3 ;

  {
#line 2191
  ep = (struct fc_exch *)0;
#line 2197
  lport = ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_dev;
#line 2198
  tmp = fc_frame_payload_get((struct fc_frame  const  *)fp, 12UL);
#line 2198
  rp = (struct fc_els_rrq *)tmp;
#line 2199
  explan = 45;
#line 2200
  if ((unsigned long )rp == (unsigned long )((struct fc_els_rrq *)0)) {
#line 2201
    goto reject;
  } else {

  }
#line 2206
  sid = ntoh24((u8 const   *)(& rp->rrq_s_id));
#line 2207
  if (((struct fc_host_attrs *)(lport->host)->shost_data)->port_id == sid) {
#line 2207
    tmp___0 = __fswab16((int )rp->rrq_ox_id);
#line 2207
    xid = tmp___0;
  } else {
#line 2207
    tmp___1 = __fswab16((int )rp->rrq_rx_id);
#line 2207
    xid = tmp___1;
  }
#line 2209
  ep = fc_exch_lookup(lport, (u32 )xid);
#line 2210
  explan = 23;
#line 2211
  if ((unsigned long )ep == (unsigned long )((struct fc_exch *)0)) {
#line 2212
    goto reject;
  } else {

  }
#line 2213
  spin_lock_bh(& ep->ex_lock);
#line 2214
  tmp___2 = __fswab16((int )rp->rrq_ox_id);
#line 2214
  if ((int )ep->oxid != (int )tmp___2) {
#line 2215
    goto unlock_reject;
  } else {

  }
#line 2216
  tmp___3 = __fswab16((int )rp->rrq_rx_id);
#line 2216
  if ((int )ep->rxid != (int )tmp___3 && (unsigned int )ep->rxid != 65535U) {
#line 2218
    goto unlock_reject;
  } else {

  }
#line 2219
  explan = 21;
#line 2220
  if (ep->sid != sid) {
#line 2221
    goto unlock_reject;
  } else {

  }
#line 2226
  if ((ep->esb_stat & 67108864U) != 0U) {
#line 2227
    ep->esb_stat = ep->esb_stat & 4227858431U;
#line 2228
    atomic_dec(& ep->ex_refcnt);
  } else {

  }
#line 2230
  if ((ep->esb_stat & 536870912U) != 0U) {
#line 2231
    fc_exch_timer_cancel(ep);
  } else {

  }
#line 2233
  spin_unlock_bh(& ep->ex_lock);
#line 2238
  fc_seq_ls_acc(fp);
#line 2239
  goto out;
  unlock_reject: 
#line 2242
  spin_unlock_bh(& ep->ex_lock);
  reject: 
#line 2244
  fc_seq_ls_rjt(fp, 3, explan);
  out: ;
#line 2246
  if ((unsigned long )ep != (unsigned long )((struct fc_exch *)0)) {
#line 2247
    fc_exch_release(ep);
  } else {

  }
#line 2248
  return;
}
}
#line 2254 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
void fc_exch_update_stats(struct fc_lport *lport ) 
{ 
  struct fc_host_statistics *st ;
  struct fc_exch_mgr_anchor *ema ;
  struct fc_exch_mgr *mp ;
  struct list_head  const  *__mptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 2260
  st = & lport->host_stats;
#line 2262
  __mptr = (struct list_head  const  *)lport->ema_list.next;
#line 2262
  ema = (struct fc_exch_mgr_anchor *)__mptr;
#line 2262
  goto ldv_41795;
  ldv_41794: 
#line 2263
  mp = ema->mp;
#line 2264
  tmp = atomic_read((atomic_t const   *)(& mp->stats.no_free_exch));
#line 2264
  st->fc_no_free_exch = st->fc_no_free_exch + (u64 )tmp;
#line 2265
  tmp___0 = atomic_read((atomic_t const   *)(& mp->stats.no_free_exch_xid));
#line 2265
  st->fc_no_free_exch_xid = st->fc_no_free_exch_xid + (u64 )tmp___0;
#line 2267
  tmp___1 = atomic_read((atomic_t const   *)(& mp->stats.xid_not_found));
#line 2267
  st->fc_xid_not_found = st->fc_xid_not_found + (u64 )tmp___1;
#line 2268
  tmp___2 = atomic_read((atomic_t const   *)(& mp->stats.xid_busy));
#line 2268
  st->fc_xid_busy = st->fc_xid_busy + (u64 )tmp___2;
#line 2269
  tmp___3 = atomic_read((atomic_t const   *)(& mp->stats.seq_not_found));
#line 2269
  st->fc_seq_not_found = st->fc_seq_not_found + (u64 )tmp___3;
#line 2270
  tmp___4 = atomic_read((atomic_t const   *)(& mp->stats.non_bls_resp));
#line 2270
  st->fc_non_bls_resp = st->fc_non_bls_resp + (u64 )tmp___4;
#line 2262
  __mptr___0 = (struct list_head  const  *)ema->ema_list.next;
#line 2262
  ema = (struct fc_exch_mgr_anchor *)__mptr___0;
  ldv_41795: ;
#line 2262
  if ((unsigned long )(& ema->ema_list) != (unsigned long )(& lport->ema_list)) {
#line 2264
    goto ldv_41794;
  } else {

  }

#line 2269
  return;
}
}
#line 2273 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static char const   __kstrtab_fc_exch_update_stats[21U]  = 
#line 2273
  {      'f',      'c',      '_',      'e', 
        'x',      'c',      'h',      '_', 
        'u',      'p',      'd',      'a', 
        't',      'e',      '_',      's', 
        't',      'a',      't',      's', 
        '\000'};
#line 2273
struct kernel_symbol  const  __ksymtab_fc_exch_update_stats ;
#line 2273 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
struct kernel_symbol  const  __ksymtab_fc_exch_update_stats  =    {(unsigned long )(& fc_exch_update_stats), (char const   *)(& __kstrtab_fc_exch_update_stats)};
#line 2281 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
struct fc_exch_mgr_anchor *fc_exch_mgr_add(struct fc_lport *lport , struct fc_exch_mgr *mp ,
                                           bool (*match)(struct fc_frame * ) ) 
{ 
  struct fc_exch_mgr_anchor *ema ;
  void *tmp ;

  {
#line 2287
  tmp = kzalloc(32UL, 32U);
#line 2287
  ema = (struct fc_exch_mgr_anchor *)tmp;
#line 2288
  if ((unsigned long )ema == (unsigned long )((struct fc_exch_mgr_anchor *)0)) {
#line 2289
    return (ema);
  } else {

  }
#line 2291
  ema->mp = mp;
#line 2292
  ema->match = match;
#line 2294
  list_add_tail(& ema->ema_list, & lport->ema_list);
#line 2295
  kref_get(& mp->kref);
#line 2296
  return (ema);
}
}
#line 2298 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static char const   __kstrtab_fc_exch_mgr_add[16U]  = 
#line 2298
  {      'f',      'c',      '_',      'e', 
        'x',      'c',      'h',      '_', 
        'm',      'g',      'r',      '_', 
        'a',      'd',      'd',      '\000'};
#line 2298
struct kernel_symbol  const  __ksymtab_fc_exch_mgr_add ;
#line 2298 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
struct kernel_symbol  const  __ksymtab_fc_exch_mgr_add  =    {(unsigned long )(& fc_exch_mgr_add), (char const   *)(& __kstrtab_fc_exch_mgr_add)};
#line 2304 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static void fc_exch_mgr_destroy(struct kref *kref ) 
{ 
  struct fc_exch_mgr *mp ;
  struct kref  const  *__mptr ;

  {
#line 2306
  __mptr = (struct kref  const  *)kref;
#line 2306
  mp = (struct fc_exch_mgr *)__mptr + 0xffffffffffffffecUL;
#line 2308
  mempool_destroy(mp->ep_pool);
#line 2309
  free_percpu((void *)mp->pool);
#line 2310
  kfree((void const   *)mp);
#line 2311
  return;
}
}
#line 2317 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
void fc_exch_mgr_del(struct fc_exch_mgr_anchor *ema ) 
{ 


  {
#line 2320
  list_del(& ema->ema_list);
#line 2321
  kref_put(& (ema->mp)->kref, & fc_exch_mgr_destroy);
#line 2322
  kfree((void const   *)ema);
#line 2323
  return;
}
}
#line 2324 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static char const   __kstrtab_fc_exch_mgr_del[16U]  = 
#line 2324
  {      'f',      'c',      '_',      'e', 
        'x',      'c',      'h',      '_', 
        'm',      'g',      'r',      '_', 
        'd',      'e',      'l',      '\000'};
#line 2324
struct kernel_symbol  const  __ksymtab_fc_exch_mgr_del ;
#line 2324 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
struct kernel_symbol  const  __ksymtab_fc_exch_mgr_del  =    {(unsigned long )(& fc_exch_mgr_del), (char const   *)(& __kstrtab_fc_exch_mgr_del)};
#line 2331 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
int fc_exch_mgr_list_clone(struct fc_lport *src , struct fc_lport *dst ) 
{ 
  struct fc_exch_mgr_anchor *ema ;
  struct fc_exch_mgr_anchor *tmp ;
  struct list_head  const  *__mptr ;
  struct fc_exch_mgr_anchor *tmp___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;

  {
#line 2335
  __mptr = (struct list_head  const  *)src->ema_list.next;
#line 2335
  ema = (struct fc_exch_mgr_anchor *)__mptr;
#line 2335
  goto ldv_41848;
  ldv_41847: 
#line 2336
  tmp___0 = fc_exch_mgr_add(dst, ema->mp, ema->match);
#line 2336
  if ((unsigned long )tmp___0 == (unsigned long )((struct fc_exch_mgr_anchor *)0)) {
#line 2337
    goto err;
  } else {

  }
#line 2335
  __mptr___0 = (struct list_head  const  *)ema->ema_list.next;
#line 2335
  ema = (struct fc_exch_mgr_anchor *)__mptr___0;
  ldv_41848: ;
#line 2335
  if ((unsigned long )(& ema->ema_list) != (unsigned long )(& src->ema_list)) {
#line 2337
    goto ldv_41847;
  } else {

  }

#line 2339
  return (0);
  err: 
#line 2341
  __mptr___1 = (struct list_head  const  *)dst->ema_list.next;
#line 2341
  ema = (struct fc_exch_mgr_anchor *)__mptr___1;
#line 2341
  __mptr___2 = (struct list_head  const  *)ema->ema_list.next;
#line 2341
  tmp = (struct fc_exch_mgr_anchor *)__mptr___2;
#line 2341
  goto ldv_41857;
  ldv_41856: 
#line 2342
  fc_exch_mgr_del(ema);
#line 2341
  ema = tmp;
#line 2341
  __mptr___3 = (struct list_head  const  *)tmp->ema_list.next;
#line 2341
  tmp = (struct fc_exch_mgr_anchor *)__mptr___3;
  ldv_41857: ;
#line 2341
  if ((unsigned long )(& ema->ema_list) != (unsigned long )(& dst->ema_list)) {
#line 2343
    goto ldv_41856;
  } else {

  }

#line 2343
  return (-12);
}
}
#line 2345 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static char const   __kstrtab_fc_exch_mgr_list_clone[23U]  = 
#line 2345
  {      'f',      'c',      '_',      'e', 
        'x',      'c',      'h',      '_', 
        'm',      'g',      'r',      '_', 
        'l',      'i',      's',      't', 
        '_',      'c',      'l',      'o', 
        'n',      'e',      '\000'};
#line 2345
struct kernel_symbol  const  __ksymtab_fc_exch_mgr_list_clone ;
#line 2345 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
struct kernel_symbol  const  __ksymtab_fc_exch_mgr_list_clone  =    {(unsigned long )(& fc_exch_mgr_list_clone), (char const   *)(& __kstrtab_fc_exch_mgr_list_clone)};
#line 2355 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
struct fc_exch_mgr *fc_exch_mgr_alloc(struct fc_lport *lport , enum fc_class class ,
                                      u16 min_xid , u16 max_xid , bool (*match)(struct fc_frame * ) ) 
{ 
  struct fc_exch_mgr *mp ;
  u16 pool_exch_range ;
  size_t pool_size ;
  unsigned int cpu ;
  struct fc_exch_pool *pool ;
  long tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  struct lock_class_key __key ;
  struct fc_exch_mgr_anchor *tmp___2 ;

  {
#line 2366
  if (((int )max_xid <= (int )min_xid || (unsigned int )max_xid == 65535U) || (unsigned int )((int )min_xid & (int )fc_cpu_mask) != 0U) {
#line 2368
    tmp = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 2368
    if (tmp != 0L) {
#line 2368
      printk("\016host%u: lport %6.6x: Invalid min_xid 0x:%x and max_xid 0x:%x\n",
             (lport->host)->host_no, lport->port_id, (int )min_xid, (int )max_xid);
    } else {

    }
#line 2370
    return ((struct fc_exch_mgr *)0);
  } else {

  }
#line 2376
  tmp___0 = kzalloc(56UL, 32U);
#line 2376
  mp = (struct fc_exch_mgr *)tmp___0;
#line 2377
  if ((unsigned long )mp == (unsigned long )((struct fc_exch_mgr *)0)) {
#line 2378
    return ((struct fc_exch_mgr *)0);
  } else {

  }
#line 2380
  mp->class = class;
#line 2382
  mp->min_xid = min_xid;
#line 2385
  pool_exch_range = 4080U;
#line 2387
  if ((((int )max_xid - (int )min_xid) + 1) / ((int )fc_cpu_mask + 1) > (int )pool_exch_range) {
#line 2388
    mp->max_xid = (unsigned int )((int )((u16 )((int )fc_cpu_mask + 1)) * (int )pool_exch_range + (int )min_xid) + 65535U;
  } else {
#line 2391
    mp->max_xid = max_xid;
#line 2392
    pool_exch_range = (u16 )((((int )mp->max_xid - (int )mp->min_xid) + 1) / ((int )fc_cpu_mask + 1));
  }
#line 2396
  mp->ep_pool = mempool_create_slab_pool(2, fc_em_cachep);
#line 2397
  if ((unsigned long )mp->ep_pool == (unsigned long )((mempool_t *)0)) {
#line 2398
    goto free_mp;
  } else {

  }
#line 2405
  mp->pool_max_index = (unsigned int )pool_exch_range + 65535U;
#line 2410
  pool_size = ((unsigned long )pool_exch_range + 16UL) * 8UL;
#line 2411
  tmp___1 = __alloc_percpu(pool_size, 64UL);
#line 2411
  mp->pool = (struct fc_exch_pool *)tmp___1;
#line 2412
  if ((unsigned long )mp->pool == (unsigned long )((struct fc_exch_pool *)0)) {
#line 2413
    goto free_mempool;
  } else {

  }
#line 2414
  cpu = 4294967295U;
#line 2414
  goto ldv_41888;
  ldv_41887: 
#line 2415
  __vpp_verify = (void const   *)0;
#line 2415
  __asm__  ("": "=r" (__ptr): "0" (mp->pool));
#line 2415
  pool = (struct fc_exch_pool *)(__per_cpu_offset[cpu] + __ptr);
#line 2416
  pool->next_index = 0U;
#line 2417
  pool->left = 65535U;
#line 2418
  pool->right = 65535U;
#line 2419
  spinlock_check(& pool->lock);
#line 2419
  __raw_spin_lock_init(& pool->lock.__annonCompField18.rlock, "&(&pool->lock)->rlock",
                       & __key);
#line 2420
  INIT_LIST_HEAD(& pool->ex_list);
  ldv_41888: 
#line 2414
  cpu = cpumask_next((int )cpu, cpu_possible_mask);
#line 2414
  if ((unsigned int )nr_cpu_ids > cpu) {
#line 2416
    goto ldv_41887;
  } else {

  }
#line 2423
  kref_init(& mp->kref);
#line 2424
  tmp___2 = fc_exch_mgr_add(lport, mp, match);
#line 2424
  if ((unsigned long )tmp___2 == (unsigned long )((struct fc_exch_mgr_anchor *)0)) {
#line 2425
    free_percpu((void *)mp->pool);
#line 2426
    goto free_mempool;
  } else {

  }
#line 2434
  kref_put(& mp->kref, & fc_exch_mgr_destroy);
#line 2435
  return (mp);
  free_mempool: 
#line 2438
  mempool_destroy(mp->ep_pool);
  free_mp: 
#line 2440
  kfree((void const   *)mp);
#line 2441
  return ((struct fc_exch_mgr *)0);
}
}
#line 2443 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static char const   __kstrtab_fc_exch_mgr_alloc[18U]  = 
#line 2443
  {      'f',      'c',      '_',      'e', 
        'x',      'c',      'h',      '_', 
        'm',      'g',      'r',      '_', 
        'a',      'l',      'l',      'o', 
        'c',      '\000'};
#line 2443
struct kernel_symbol  const  __ksymtab_fc_exch_mgr_alloc ;
#line 2443 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
struct kernel_symbol  const  __ksymtab_fc_exch_mgr_alloc  =    {(unsigned long )(& fc_exch_mgr_alloc), (char const   *)(& __kstrtab_fc_exch_mgr_alloc)};
#line 2449 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
void fc_exch_mgr_free(struct fc_lport *lport ) 
{ 
  struct fc_exch_mgr_anchor *ema ;
  struct fc_exch_mgr_anchor *next ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 2453
  ldv_flush_workqueue_139(fc_exch_workqueue);
#line 2454
  __mptr = (struct list_head  const  *)lport->ema_list.next;
#line 2454
  ema = (struct fc_exch_mgr_anchor *)__mptr;
#line 2454
  __mptr___0 = (struct list_head  const  *)ema->ema_list.next;
#line 2454
  next = (struct fc_exch_mgr_anchor *)__mptr___0;
#line 2454
  goto ldv_41913;
  ldv_41912: 
#line 2455
  fc_exch_mgr_del(ema);
#line 2454
  ema = next;
#line 2454
  __mptr___1 = (struct list_head  const  *)next->ema_list.next;
#line 2454
  next = (struct fc_exch_mgr_anchor *)__mptr___1;
  ldv_41913: ;
#line 2454
  if ((unsigned long )(& ema->ema_list) != (unsigned long )(& lport->ema_list)) {
#line 2456
    goto ldv_41912;
  } else {

  }

#line 2461
  return;
}
}
#line 2457 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static char const   __kstrtab_fc_exch_mgr_free[17U]  = 
#line 2457
  {      'f',      'c',      '_',      'e', 
        'x',      'c',      'h',      '_', 
        'm',      'g',      'r',      '_', 
        'f',      'r',      'e',      'e', 
        '\000'};
#line 2457
struct kernel_symbol  const  __ksymtab_fc_exch_mgr_free ;
#line 2457 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
struct kernel_symbol  const  __ksymtab_fc_exch_mgr_free  =    {(unsigned long )(& fc_exch_mgr_free), (char const   *)(& __kstrtab_fc_exch_mgr_free)};
#line 2466 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static struct fc_exch_mgr_anchor *fc_find_ema(u32 f_ctl , struct fc_lport *lport ,
                                              struct fc_frame_header *fh ) 
{ 
  struct fc_exch_mgr_anchor *ema ;
  u16 xid ;
  __u16 tmp ;
  __u16 tmp___0 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 2473
  if ((f_ctl & 8388608U) != 0U) {
#line 2474
    tmp = __fswab16((int )fh->fh_ox_id);
#line 2474
    xid = tmp;
  } else {
#line 2476
    tmp___0 = __fswab16((int )fh->fh_rx_id);
#line 2476
    xid = tmp___0;
#line 2477
    if ((unsigned int )xid == 65535U) {
#line 2478
      __mptr = (struct list_head  const  *)lport->ema_list.prev;
#line 2478
      return ((struct fc_exch_mgr_anchor *)__mptr);
    } else {

    }
  }
#line 2482
  __mptr___0 = (struct list_head  const  *)lport->ema_list.next;
#line 2482
  ema = (struct fc_exch_mgr_anchor *)__mptr___0;
#line 2482
  goto ldv_41936;
  ldv_41935: ;
#line 2483
  if ((int )(ema->mp)->min_xid <= (int )xid && (int )(ema->mp)->max_xid >= (int )xid) {
#line 2485
    return (ema);
  } else {

  }
#line 2482
  __mptr___1 = (struct list_head  const  *)ema->ema_list.next;
#line 2482
  ema = (struct fc_exch_mgr_anchor *)__mptr___1;
  ldv_41936: ;
#line 2482
  if ((unsigned long )(& ema->ema_list) != (unsigned long )(& lport->ema_list)) {
#line 2484
    goto ldv_41935;
  } else {

  }

#line 2487
  return ((struct fc_exch_mgr_anchor *)0);
}
}
#line 2494 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
void fc_exch_recv(struct fc_lport *lport , struct fc_frame *fp ) 
{ 
  struct fc_frame_header *fh ;
  struct fc_frame_header *tmp ;
  struct fc_exch_mgr_anchor *ema ;
  u32 f_ctl ;
  long tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;

  {
#line 2496
  tmp = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 2496
  fh = tmp;
#line 2501
  if ((unsigned long )lport == (unsigned long )((struct fc_lport *)0) || (unsigned int )lport->state == 0U) {
#line 2502
    tmp___0 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 2502
    if (tmp___0 != 0L) {
#line 2502
      printk("\016host%u: lport %6.6x: Receiving frames for an lport that has not been initialized correctly\n",
             (lport->host)->host_no, lport->port_id);
    } else {

    }
#line 2504
    fc_frame_free(fp);
#line 2505
    return;
  } else {

  }
#line 2508
  f_ctl = ntoh24((u8 const   *)(& fh->fh_f_ctl));
#line 2509
  ema = fc_find_ema(f_ctl, lport, fh);
#line 2510
  if ((unsigned long )ema == (unsigned long )((struct fc_exch_mgr_anchor *)0)) {
#line 2511
    tmp___4 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 2511
    if (tmp___4 != 0L) {
#line 2511
      if ((f_ctl & 8388608U) != 0U) {
#line 2511
        tmp___1 = __fswab16((int )fh->fh_ox_id);
#line 2511
        tmp___3 = (int )tmp___1;
      } else {
#line 2511
        tmp___2 = __fswab16((int )fh->fh_rx_id);
#line 2511
        tmp___3 = (int )tmp___2;
      }
#line 2511
      printk("\016host%u: lport %6.6x: Unable to find Exchange Manager Anchor,fc_ctl <0x%x>, xid <0x%x>\n",
             (lport->host)->host_no, lport->port_id, f_ctl, tmp___3);
    } else {

    }
#line 2517
    fc_frame_free(fp);
#line 2518
    return;
  } else {

  }
#line 2524
  switch ((int )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_eof) {
  case 66: ;
#line 2526
  if ((f_ctl & 524288U) != 0U) {
#line 2527
    skb_trim(& fp->skb, fp->skb.len - (f_ctl & 3U));
  } else {

  }
  case 65: ;
#line 2530
  if ((unsigned int )fh->fh_type == 0U) {
#line 2531
    fc_exch_recv_bls(ema->mp, fp);
  } else
#line 2532
  if ((f_ctl & 12582912U) == 8388608U) {
#line 2534
    fc_exch_recv_seq_resp(ema->mp, fp);
  } else
#line 2535
  if ((f_ctl & 4194304U) != 0U) {
#line 2536
    fc_exch_recv_resp(ema->mp, fp);
  } else {
#line 2538
    fc_exch_recv_req(lport, ema->mp, fp);
  }
#line 2539
  goto ldv_41947;
  default: 
#line 2541
  tmp___5 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 2541
  if (tmp___5 != 0L) {
#line 2541
    printk("\016host%u: lport %6.6x: dropping invalid frame (eof %x)", (lport->host)->host_no,
           lport->port_id, (int )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_eof);
  } else {

  }
#line 2543
  fc_frame_free(fp);
  }
  ldv_41947: ;
#line 2546
  return;
}
}
#line 2546 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static char const   __kstrtab_fc_exch_recv[13U]  = 
#line 2546
  {      'f',      'c',      '_',      'e', 
        'x',      'c',      'h',      '_', 
        'r',      'e',      'c',      'v', 
        '\000'};
#line 2546
struct kernel_symbol  const  __ksymtab_fc_exch_recv ;
#line 2546 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
struct kernel_symbol  const  __ksymtab_fc_exch_recv  =    {(unsigned long )(& fc_exch_recv), (char const   *)(& __kstrtab_fc_exch_recv)};
#line 2552 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
int fc_exch_init(struct fc_lport *lport ) 
{ 


  {
#line 2554
  if ((unsigned long )lport->tt.seq_start_next == (unsigned long )((struct fc_seq *(*)(struct fc_seq * ))0)) {
#line 2555
    lport->tt.seq_start_next = & fc_seq_start_next;
  } else {

  }
#line 2557
  if ((unsigned long )lport->tt.seq_set_resp == (unsigned long )((void (*)(struct fc_seq * ,
                                                                           void (*)(struct fc_seq * ,
                                                                                    struct fc_frame * ,
                                                                                    void * ) ,
                                                                           void * ))0)) {
#line 2558
    lport->tt.seq_set_resp = & fc_seq_set_resp;
  } else {

  }
#line 2560
  if ((unsigned long )lport->tt.exch_seq_send == (unsigned long )((struct fc_seq *(*)(struct fc_lport * ,
                                                                                      struct fc_frame * ,
                                                                                      void (*)(struct fc_seq * ,
                                                                                               struct fc_frame * ,
                                                                                               void * ) ,
                                                                                      void (*)(struct fc_seq * ,
                                                                                               void * ) ,
                                                                                      void * ,
                                                                                      unsigned int  ))0)) {
#line 2561
    lport->tt.exch_seq_send = & fc_exch_seq_send;
  } else {

  }
#line 2563
  if ((unsigned long )lport->tt.seq_send == (unsigned long )((int (*)(struct fc_lport * ,
                                                                      struct fc_seq * ,
                                                                      struct fc_frame * ))0)) {
#line 2564
    lport->tt.seq_send = & fc_seq_send;
  } else {

  }
#line 2566
  if ((unsigned long )lport->tt.seq_els_rsp_send == (unsigned long )((void (*)(struct fc_frame * ,
                                                                               enum fc_els_cmd  ,
                                                                               struct fc_seq_els_data * ))0)) {
#line 2567
    lport->tt.seq_els_rsp_send = & fc_seq_els_rsp_send;
  } else {

  }
#line 2569
  if ((unsigned long )lport->tt.exch_done == (unsigned long )((void (*)(struct fc_seq * ))0)) {
#line 2570
    lport->tt.exch_done = & fc_exch_done;
  } else {

  }
#line 2572
  if ((unsigned long )lport->tt.exch_mgr_reset == (unsigned long )((void (*)(struct fc_lport * ,
                                                                             u32  ,
                                                                             u32  ))0)) {
#line 2573
    lport->tt.exch_mgr_reset = & fc_exch_mgr_reset;
  } else {

  }
#line 2575
  if ((unsigned long )lport->tt.seq_exch_abort == (unsigned long )((int (*)(struct fc_seq  const  * ,
                                                                            unsigned int  ))0)) {
#line 2576
    lport->tt.seq_exch_abort = & fc_seq_exch_abort;
  } else {

  }
#line 2578
  if ((unsigned long )lport->tt.seq_assign == (unsigned long )((struct fc_seq *(*)(struct fc_lport * ,
                                                                                   struct fc_frame * ))0)) {
#line 2579
    lport->tt.seq_assign = & fc_seq_assign;
  } else {

  }
#line 2581
  if ((unsigned long )lport->tt.seq_release == (unsigned long )((void (*)(struct fc_seq * ))0)) {
#line 2582
    lport->tt.seq_release = & fc_seq_release;
  } else {

  }
#line 2584
  return (0);
}
}
#line 2586 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
static char const   __kstrtab_fc_exch_init[13U]  = 
#line 2586
  {      'f',      'c',      '_',      'e', 
        'x',      'c',      'h',      '_', 
        'i',      'n',      'i',      't', 
        '\000'};
#line 2586
struct kernel_symbol  const  __ksymtab_fc_exch_init ;
#line 2586 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
struct kernel_symbol  const  __ksymtab_fc_exch_init  =    {(unsigned long )(& fc_exch_init), (char const   *)(& __kstrtab_fc_exch_init)};
#line 2591 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
int fc_setup_exch_mgr(void) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  struct lock_class_key __key ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp___1 ;

  {
#line 2593
  fc_em_cachep = kmem_cache_create("libfc_em", 576UL, 0UL, 8192UL, (void (*)(void * ))0);
#line 2595
  if ((unsigned long )fc_em_cachep == (unsigned long )((struct kmem_cache *)0)) {
#line 2596
    return (-12);
  } else {

  }
#line 2612
  tmp = __roundup_pow_of_two((unsigned long )nr_cpu_ids);
#line 2612
  tmp___0 = __ilog2_u64((u64 )tmp);
#line 2612
  fc_cpu_order = (u16 )tmp___0;
#line 2613
  fc_cpu_mask = (unsigned int )((u16 )(1 << (int )fc_cpu_order)) + 65535U;
#line 2615
  __lock_name = "\"%s\"\"fc_exch_workqueue\"";
#line 2615
  tmp___1 = __alloc_workqueue_key("%s", 131082U, 1, & __key, __lock_name, (char *)"fc_exch_workqueue");
#line 2615
  fc_exch_workqueue = tmp___1;
#line 2616
  if ((unsigned long )fc_exch_workqueue == (unsigned long )((struct workqueue_struct *)0)) {
#line 2617
    goto err;
  } else {

  }
#line 2618
  return (0);
  err: 
#line 2620
  kmem_cache_destroy(fc_em_cachep);
#line 2621
  return (-12);
}
}
#line 2627 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.c"
void fc_destroy_exch_mgr(void) 
{ 


  {
#line 2629
  ldv_destroy_workqueue_140(fc_exch_workqueue);
#line 2630
  kmem_cache_destroy(fc_em_cachep);
#line 2631
  return;
}
}
#line 152 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
void work_init_2(void) 
{ 


  {
#line 153
  ldv_work_2_0 = 0;
#line 154
  ldv_work_2_1 = 0;
#line 155
  ldv_work_2_2 = 0;
#line 156
  ldv_work_2_3 = 0;
#line 157
  return;
}
}
#line 160 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
void call_and_disable_all_2(int state ) 
{ 


  {
#line 162
  if (ldv_work_2_0 == state) {
#line 163
    call_and_disable_work_2(ldv_work_struct_2_0);
  } else {

  }
#line 164
  if (ldv_work_2_1 == state) {
#line 165
    call_and_disable_work_2(ldv_work_struct_2_1);
  } else {

  }
#line 166
  if (ldv_work_2_2 == state) {
#line 167
    call_and_disable_work_2(ldv_work_struct_2_2);
  } else {

  }
#line 168
  if (ldv_work_2_3 == state) {
#line 169
    call_and_disable_work_2(ldv_work_struct_2_3);
  } else {

  }
#line 170
  return;
}
}
#line 173 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
void activate_work_2(struct work_struct *work , int state ) 
{ 


  {
#line 174
  if (ldv_work_2_0 == 0) {
#line 175
    ldv_work_struct_2_0 = work;
#line 176
    ldv_work_2_0 = state;
#line 177
    return;
  } else {

  }
#line 180
  if (ldv_work_2_1 == 0) {
#line 181
    ldv_work_struct_2_1 = work;
#line 182
    ldv_work_2_1 = state;
#line 183
    return;
  } else {

  }
#line 186
  if (ldv_work_2_2 == 0) {
#line 187
    ldv_work_struct_2_2 = work;
#line 188
    ldv_work_2_2 = state;
#line 189
    return;
  } else {

  }
#line 192
  if (ldv_work_2_3 == 0) {
#line 193
    ldv_work_struct_2_3 = work;
#line 194
    ldv_work_2_3 = state;
#line 195
    return;
  } else {

  }
#line 197
  return;
}
}
#line 200 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
void disable_work_2(struct work_struct *work ) 
{ 


  {
#line 202
  if ((ldv_work_2_0 == 3 || ldv_work_2_0 == 2) && (unsigned long )ldv_work_struct_2_0 == (unsigned long )work) {
#line 204
    ldv_work_2_0 = 1;
  } else {

  }
#line 206
  if ((ldv_work_2_1 == 3 || ldv_work_2_1 == 2) && (unsigned long )ldv_work_struct_2_1 == (unsigned long )work) {
#line 208
    ldv_work_2_1 = 1;
  } else {

  }
#line 210
  if ((ldv_work_2_2 == 3 || ldv_work_2_2 == 2) && (unsigned long )ldv_work_struct_2_2 == (unsigned long )work) {
#line 212
    ldv_work_2_2 = 1;
  } else {

  }
#line 214
  if ((ldv_work_2_3 == 3 || ldv_work_2_3 == 2) && (unsigned long )ldv_work_struct_2_3 == (unsigned long )work) {
#line 216
    ldv_work_2_3 = 1;
  } else {

  }
#line 217
  return;
}
}
#line 221 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
void call_and_disable_work_2(struct work_struct *work ) 
{ 


  {
#line 224
  if ((ldv_work_2_0 == 2 || ldv_work_2_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_0) {
#line 226
    fc_exch_timeout(work);
#line 227
    ldv_work_2_0 = 1;
#line 228
    return;
  } else {

  }
#line 230
  if ((ldv_work_2_1 == 2 || ldv_work_2_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_1) {
#line 232
    fc_exch_timeout(work);
#line 233
    ldv_work_2_1 = 1;
#line 234
    return;
  } else {

  }
#line 236
  if ((ldv_work_2_2 == 2 || ldv_work_2_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_2) {
#line 238
    fc_exch_timeout(work);
#line 239
    ldv_work_2_2 = 1;
#line 240
    return;
  } else {

  }
#line 242
  if ((ldv_work_2_3 == 2 || ldv_work_2_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_3) {
#line 244
    fc_exch_timeout(work);
#line 245
    ldv_work_2_3 = 1;
#line 246
    return;
  } else {

  }
#line 248
  return;
}
}
#line 251 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
void invoke_work_2(void) 
{ 
  int tmp ;

  {
#line 253
  tmp = __VERIFIER_nondet_int();
#line 253
  switch (tmp) {
  case 0: ;
#line 255
  if (ldv_work_2_0 == 2 || ldv_work_2_0 == 3) {
#line 256
    ldv_work_2_0 = 4;
#line 257
    fc_exch_timeout(ldv_work_struct_2_0);
#line 258
    ldv_work_2_0 = 1;
  } else {

  }
#line 261
  goto ldv_42001;
  case 1: ;
#line 263
  if (ldv_work_2_1 == 2 || ldv_work_2_1 == 3) {
#line 264
    ldv_work_2_1 = 4;
#line 265
    fc_exch_timeout(ldv_work_struct_2_0);
#line 266
    ldv_work_2_1 = 1;
  } else {

  }
#line 269
  goto ldv_42001;
  case 2: ;
#line 271
  if (ldv_work_2_2 == 2 || ldv_work_2_2 == 3) {
#line 272
    ldv_work_2_2 = 4;
#line 273
    fc_exch_timeout(ldv_work_struct_2_0);
#line 274
    ldv_work_2_2 = 1;
  } else {

  }
#line 277
  goto ldv_42001;
  case 3: ;
#line 279
  if (ldv_work_2_3 == 2 || ldv_work_2_3 == 3) {
#line 280
    ldv_work_2_3 = 4;
#line 281
    fc_exch_timeout(ldv_work_struct_2_0);
#line 282
    ldv_work_2_3 = 1;
  } else {

  }
#line 285
  goto ldv_42001;
  default: 
#line 286
  ldv_stop();
  }
  ldv_42001: ;
#line 288
  return;
}
}
#line 291 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
__inline static void *ERR_PTR(long error ) 
{ 
  void *tmp ;

  {
#line 294
  tmp = ldv_err_ptr(error);
#line 294
  return (tmp);
}
}
#line 323 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
__inline static void spin_lock_bh(spinlock_t *lock ) 
{ 


  {
#line 326
  ldv_spin_lock();
#line 328
  ldv_spin_lock_bh_100(lock);
#line 329
  return;
}
}
#line 358 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
__inline static void spin_unlock_bh(spinlock_t *lock ) 
{ 


  {
#line 361
  ldv_spin_unlock();
#line 363
  ldv_spin_unlock_bh_104(lock);
#line 364
  return;
}
}
#line 404 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
bool ldv_queue_work_on_109(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 408
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 408
  ldv_func_res = tmp;
#line 410
  activate_work_3(ldv_func_arg3, 2);
#line 412
  return (ldv_func_res);
}
}
#line 415 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
bool ldv_queue_delayed_work_on_110(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 419
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 419
  ldv_func_res = tmp;
#line 421
  activate_work_3(& ldv_func_arg3->work, 2);
#line 423
  return (ldv_func_res);
}
}
#line 426 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
bool ldv_queue_work_on_111(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  bool tmp ;

  {
#line 430
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 430
  ldv_func_res = tmp;
#line 432
  activate_work_3(ldv_func_arg3, 2);
#line 434
  return (ldv_func_res);
}
}
#line 437 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
void ldv_flush_workqueue_112(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 440
  flush_workqueue(ldv_func_arg1);
#line 442
  call_and_disable_all_3(2);
#line 443
  return;
}
}
#line 445 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
bool ldv_queue_delayed_work_on_113(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
#line 449
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 449
  ldv_func_res = tmp;
#line 451
  activate_work_3(& ldv_func_arg3->work, 2);
#line 453
  return (ldv_func_res);
}
}
#line 491 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
void *ldv_kmem_cache_alloc_119(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 494
  ldv_check_alloc_flags(flags);
#line 495
  tmp = ldv_undef_ptr();
#line 495
  return (tmp);
}
}
#line 533 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
int ldv_pskb_expand_head_125(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 536
  ldv_check_alloc_flags(flags);
#line 537
  tmp = ldv_undef_ptr();
#line 537
  return ((int )((long )tmp));
}
}
#line 547 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
struct sk_buff *ldv_skb_clone_127(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 550
  ldv_check_alloc_flags(flags);
#line 551
  tmp = ldv_undef_ptr();
#line 551
  return ((struct sk_buff *)tmp);
}
}
#line 561 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
struct sk_buff *ldv_skb_copy_129(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 564
  ldv_check_alloc_flags(flags);
#line 565
  tmp = ldv_undef_ptr();
#line 565
  return ((struct sk_buff *)tmp);
}
}
#line 568 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_130(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 571
  ldv_check_alloc_flags(flags);
#line 572
  tmp = ldv_undef_ptr();
#line 572
  return ((struct sk_buff *)tmp);
}
}
#line 575 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_131(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 578
  ldv_check_alloc_flags(flags);
#line 579
  tmp = ldv_undef_ptr();
#line 579
  return ((struct sk_buff *)tmp);
}
}
#line 582 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_132(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 585
  ldv_check_alloc_flags(flags);
#line 586
  tmp = ldv_undef_ptr();
#line 586
  return ((struct sk_buff *)tmp);
}
}
#line 589 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
int ldv_pskb_expand_head_133(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 592
  ldv_check_alloc_flags(flags);
#line 593
  tmp = ldv_undef_ptr();
#line 593
  return ((int )((long )tmp));
}
}
#line 596 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
int ldv_pskb_expand_head_134(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 599
  ldv_check_alloc_flags(flags);
#line 600
  tmp = ldv_undef_ptr();
#line 600
  return ((int )((long )tmp));
}
}
#line 603 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
struct sk_buff *ldv_skb_clone_135(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 606
  ldv_check_alloc_flags(flags);
#line 607
  tmp = ldv_undef_ptr();
#line 607
  return ((struct sk_buff *)tmp);
}
}
#line 610 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
bool ldv_cancel_delayed_work_136(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  bool tmp ;

  {
#line 614
  tmp = cancel_delayed_work(ldv_func_arg1);
#line 614
  ldv_func_res = tmp;
#line 616
  disable_work_3(& ldv_func_arg1->work);
#line 618
  return (ldv_func_res);
}
}
#line 621 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
void *ldv_mempool_alloc_137(mempool_t *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 624
  ldv_check_alloc_flags(flags);
#line 625
  tmp = ldv_undef_ptr();
#line 625
  return (tmp);
}
}
#line 628 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
bool ldv_cancel_delayed_work_sync_138(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  bool tmp ;

  {
#line 632
  tmp = cancel_delayed_work_sync(ldv_func_arg1);
#line 632
  ldv_func_res = tmp;
#line 634
  disable_work_3(& ldv_func_arg1->work);
#line 636
  return (ldv_func_res);
}
}
#line 639 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
void ldv_flush_workqueue_139(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 642
  flush_workqueue(ldv_func_arg1);
#line 644
  call_and_disable_all_3(2);
#line 645
  return;
}
}
#line 647 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_exch.o.c.prepared"
void ldv_destroy_workqueue_140(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 650
  destroy_workqueue(ldv_func_arg1);
#line 652
  call_and_disable_all_3(2);
#line 653
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 405 "include/linux/kernel.h"
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 64 "./arch/x86/include/asm/string_64.h"
extern size_t strlen(char const   * ) ;
#line 23 "include/linux/string.h"
extern char *strncpy(char * , char const   * , __kernel_size_t  ) ;
#line 80
extern __kernel_size_t strnlen(char const   * , __kernel_size_t  ) ;
#line 32 "include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_164(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_166(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_165(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_168(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_167(struct workqueue_struct *ldv_func_arg1 ) ;
#line 86 "include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 88
  return ((char const   *)kobj->name);
}
}
#line 293 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_174(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 52 "include/linux/unaligned/access_ok.h"
__inline static void put_unaligned_be16(u16 val , void *p ) 
{ 
  __u16 tmp ;

  {
#line 54
  tmp = __fswab16((int )val);
#line 54
  *((__be16 *)p) = tmp;
#line 55
  return;
}
}
#line 57 "include/linux/unaligned/access_ok.h"
__inline static void put_unaligned_be32(u32 val , void *p ) 
{ 
  __u32 tmp ;

  {
#line 59
  tmp = __fswab32(val);
#line 59
  *((__be32 *)p) = tmp;
#line 60
  return;
}
}
#line 62 "include/linux/unaligned/access_ok.h"
__inline static void put_unaligned_be64(u64 val , void *p ) 
{ 
  __u64 tmp ;

  {
#line 64
  tmp = __fswab64(val);
#line 64
  *((__be64 *)p) = tmp;
#line 65
  return;
}
}
#line 832 "include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 835
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 836
    return ((char const   *)dev->init_name);
  } else {

  }
#line 838
  tmp = kobject_name(& dev->kobj);
#line 838
  return (tmp);
}
}
#line 849 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_182(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 853
struct sk_buff *ldv_skb_clone_190(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 858
struct sk_buff *ldv_skb_copy_184(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 871
int ldv_pskb_expand_head_180(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 875
int ldv_pskb_expand_head_188(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 879
int ldv_pskb_expand_head_189(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2148
struct sk_buff *ldv___netdev_alloc_skb_185(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2152
struct sk_buff *ldv___netdev_alloc_skb_186(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2156
struct sk_buff *ldv___netdev_alloc_skb_187(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 1112 "include/scsi/libfc.h"
int fc_elsct_init(struct fc_lport *lport ) ;
#line 1113
struct fc_seq *fc_elsct_send(struct fc_lport *lport , u32 did , struct fc_frame *fp ,
                             unsigned int op , void (*resp)(struct fc_seq * , struct fc_frame * ,
                                                            void * ) , void *arg ,
                             u32 timer_msec ) ;
#line 29 "include/linux/utsname.h"
extern struct uts_namespace init_uts_ns ;
#line 77 "include/linux/utsname.h"
__inline static struct new_utsname *init_utsname(void) 
{ 


  {
#line 79
  return (& init_uts_ns.name);
}
}
#line 88 "include/scsi/fc_encode.h"
__inline static void fc_adisc_fill(struct fc_lport *lport , struct fc_frame *fp ) 
{ 
  struct fc_els_adisc *adisc ;
  void *tmp ;

  {
#line 92
  tmp = fc_frame_payload_get((struct fc_frame  const  *)fp, 28UL);
#line 92
  adisc = (struct fc_els_adisc *)tmp;
#line 93
  memset((void *)adisc, 0, 28UL);
#line 94
  adisc->adisc_cmd = 82U;
#line 95
  put_unaligned_be64(lport->wwpn, (void *)(& adisc->adisc_wwpn));
#line 96
  put_unaligned_be64(lport->wwnn, (void *)(& adisc->adisc_wwnn));
#line 97
  hton24((u8 *)(& adisc->adisc_port_id), lport->port_id);
#line 98
  return;
}
}
#line 104 "include/scsi/fc_encode.h"
__inline static struct fc_ct_req *fc_ct_hdr_fill(struct fc_frame  const  *fp , unsigned int op ,
                                                 size_t req_size , enum fc_ct_fs_type fs_type ,
                                                 u8 subtype ) 
{ 
  struct fc_ct_req *ct ;
  size_t ct_plen ;
  void *tmp ;
  __u16 tmp___0 ;

  {
#line 112
  ct_plen = req_size + 16UL;
#line 113
  tmp = fc_frame_payload_get(fp, ct_plen);
#line 113
  ct = (struct fc_ct_req *)tmp;
#line 114
  memset((void *)ct, 0, ct_plen);
#line 115
  ct->hdr.ct_rev = 1U;
#line 116
  ct->hdr.ct_fs_type = (__u8 )fs_type;
#line 117
  ct->hdr.ct_fs_subtype = subtype;
#line 118
  tmp___0 = __fswab16((int )((unsigned short )op));
#line 118
  ct->hdr.ct_cmd = tmp___0;
#line 119
  return (ct);
}
}
#line 131 "include/scsi/fc_encode.h"
__inline static int fc_ct_ns_fill(struct fc_lport *lport , u32 fc_id , struct fc_frame *fp ,
                                  unsigned int op , enum fc_rctl *r_ctl , enum fc_fh_type *fh_type ) 
{ 
  struct fc_ct_req *ct ;
  size_t len ;

  {
#line 139
  switch (op) {
  case 370U: 
#line 141
  ct = fc_ct_hdr_fill((struct fc_frame  const  *)fp, op, 4UL, 252, 2);
#line 143
  ct->payload.gid.fn_fc4_type = 8U;
#line 144
  goto ldv_40963;
  case 274U: 
#line 147
  ct = fc_ct_hdr_fill((struct fc_frame  const  *)fp, op, 4UL, 252, 2);
#line 149
  ct->payload.gid.fn_fc4_type = 8U;
#line 150
  hton24((u8 *)(& ct->payload.fid.fp_fid), fc_id);
#line 151
  goto ldv_40963;
  case 535U: 
#line 154
  ct = fc_ct_hdr_fill((struct fc_frame  const  *)fp, op, 36UL, 252, 2);
#line 156
  hton24((u8 *)(& ct->payload.rft.fid.fp_fid), lport->port_id);
#line 157
  ct->payload.rft.fts = lport->fcts;
#line 158
  goto ldv_40963;
  case 543U: 
#line 161
  ct = fc_ct_hdr_fill((struct fc_frame  const  *)fp, op, 8UL, 252, 2);
#line 163
  hton24((u8 *)(& ct->payload.rff.fr_fid.fp_fid), lport->port_id);
#line 164
  ct->payload.rff.fr_type = 8U;
#line 165
  if ((lport->service_params & 32U) != 0U) {
#line 166
    ct->payload.rff.fr_feat = 2U;
  } else {

  }
#line 167
  if ((lport->service_params & 16U) != 0U) {
#line 168
    ct->payload.rff.fr_feat = (__u8 )((unsigned int )ct->payload.rff.fr_feat | 1U);
  } else {

  }
#line 169
  goto ldv_40963;
  case 531U: 
#line 172
  ct = fc_ct_hdr_fill((struct fc_frame  const  *)fp, op, 12UL, 252, 2);
#line 174
  hton24((u8 *)(& ct->payload.rn.fr_fid.fp_fid), lport->port_id);
#line 175
  put_unaligned_be64(lport->wwnn, (void *)(& ct->payload.rn.fr_wwn));
#line 176
  goto ldv_40963;
  case 536U: 
#line 179
  len = strnlen((char const   *)(& ((struct fc_host_attrs *)(lport->host)->shost_data)->symbolic_name),
                255UL);
#line 180
  ct = fc_ct_hdr_fill((struct fc_frame  const  *)fp, op, len + 5UL, 252, 2);
#line 182
  hton24((u8 *)(& ct->payload.spn.fr_fid.fp_fid), lport->port_id);
#line 183
  strncpy((char *)(& ct->payload.spn.fr_name), (char const   *)(& ((struct fc_host_attrs *)(lport->host)->shost_data)->symbolic_name),
          len);
#line 185
  ct->payload.spn.fr_name_len = (__u8 )len;
#line 186
  goto ldv_40963;
  case 569U: 
#line 189
  len = strnlen((char const   *)(& ((struct fc_host_attrs *)(lport->host)->shost_data)->symbolic_name),
                255UL);
#line 190
  ct = fc_ct_hdr_fill((struct fc_frame  const  *)fp, op, len + 9UL, 252, 2);
#line 192
  put_unaligned_be64(lport->wwnn, (void *)(& ct->payload.snn.fr_wwn));
#line 193
  strncpy((char *)(& ct->payload.snn.fr_name), (char const   *)(& ((struct fc_host_attrs *)(lport->host)->shost_data)->symbolic_name),
          len);
#line 195
  ct->payload.snn.fr_name_len = (__u8 )len;
#line 196
  goto ldv_40963;
  default: ;
#line 199
  return (-22);
  }
  ldv_40963: 
#line 201
  *r_ctl = 2;
#line 202
  *fh_type = 32;
#line 203
  return (0);
}
}
#line 215 "include/scsi/fc_encode.h"
__inline static int fc_ct_ms_fill(struct fc_lport *lport , u32 fc_id , struct fc_frame *fp ,
                                  unsigned int op , enum fc_rctl *r_ctl , enum fc_fh_type *fh_type ) 
{ 
  struct fc_ct_req *ct ;
  size_t len ;
  struct fc_fdmi_attr_entry *entry ;
  struct fs_fdmi_attrs *hba_attrs ;
  int numattrs ;
  struct new_utsname *tmp ;
  struct new_utsname *tmp___0 ;
  char const   *tmp___1 ;
  __kernel_size_t tmp___2 ;
  char const   *tmp___3 ;
  __kernel_size_t tmp___4 ;
  struct new_utsname *tmp___5 ;
  size_t tmp___6 ;

  {
#line 224
  numattrs = 0;
#line 226
  switch (op) {
  case 512U: 
#line 228
  numattrs = 10;
#line 229
  len = 29UL;
#line 230
  len = len - 5UL;
#line 231
  len = (size_t )(numattrs * 4) + len;
#line 232
  len = len + 8UL;
#line 233
  len = len + 64UL;
#line 234
  len = len + 64UL;
#line 235
  len = len + 256UL;
#line 236
  len = len + 256UL;
#line 237
  len = len + 256UL;
#line 238
  len = len + 256UL;
#line 239
  len = len + 256UL;
#line 240
  len = len + 256UL;
#line 241
  len = len + 256UL;
#line 242
  ct = fc_ct_hdr_fill((struct fc_frame  const  *)fp, op, len, 250, 16);
#line 246
  put_unaligned_be64(lport->wwpn, (void *)(& ct->payload.rhba.hbaid.id));
#line 248
  put_unaligned_be32(1U, (void *)(& ct->payload.rhba.port.numport));
#line 250
  put_unaligned_be64(lport->wwpn, (void *)(& ct->payload.rhba.port.port[0].portname));
#line 254
  put_unaligned_be32((u32 )numattrs, (void *)(& ct->payload.rhba.hba_attrs.numattrs));
#line 256
  hba_attrs = & ct->payload.rhba.hba_attrs;
#line 257
  entry = (struct fc_fdmi_attr_entry *)(& hba_attrs->attr);
#line 259
  len = 4UL;
#line 260
  len = len + 8UL;
#line 261
  put_unaligned_be16(1, (void *)(& entry->type));
#line 263
  put_unaligned_be16((int )((u16 )len), (void *)(& entry->len));
#line 264
  put_unaligned_be64(lport->wwnn, (void *)(& entry->value));
#line 268
  entry = (struct fc_fdmi_attr_entry *)(& entry->value) + 8U;
#line 270
  len = 4UL;
#line 271
  len = len + 64UL;
#line 272
  put_unaligned_be16(2, (void *)(& entry->type));
#line 274
  put_unaligned_be16((int )((u16 )len), (void *)(& entry->len));
#line 275
  strncpy((char *)(& entry->value), (char const   *)(& ((struct fc_host_attrs *)(lport->host)->shost_data)->manufacturer),
          64UL);
#line 280
  entry = (struct fc_fdmi_attr_entry *)(& entry->value) + 64U;
#line 282
  len = 4UL;
#line 283
  len = len + 64UL;
#line 284
  put_unaligned_be16(3, (void *)(& entry->type));
#line 286
  put_unaligned_be16((int )((u16 )len), (void *)(& entry->len));
#line 287
  strncpy((char *)(& entry->value), (char const   *)(& ((struct fc_host_attrs *)(lport->host)->shost_data)->serial_number),
          64UL);
#line 292
  entry = (struct fc_fdmi_attr_entry *)(& entry->value) + 64U;
#line 294
  len = 4UL;
#line 295
  len = len + 256UL;
#line 296
  put_unaligned_be16(4, (void *)(& entry->type));
#line 298
  put_unaligned_be16((int )((u16 )len), (void *)(& entry->len));
#line 299
  strncpy((char *)(& entry->value), (char const   *)(& ((struct fc_host_attrs *)(lport->host)->shost_data)->model),
          256UL);
#line 304
  entry = (struct fc_fdmi_attr_entry *)(& entry->value) + 256U;
#line 306
  len = 4UL;
#line 307
  len = len + 256UL;
#line 308
  put_unaligned_be16(5, (void *)(& entry->type));
#line 310
  put_unaligned_be16((int )((u16 )len), (void *)(& entry->len));
#line 311
  strncpy((char *)(& entry->value), (char const   *)(& ((struct fc_host_attrs *)(lport->host)->shost_data)->model_description),
          256UL);
#line 316
  entry = (struct fc_fdmi_attr_entry *)(& entry->value) + 256U;
#line 318
  len = 4UL;
#line 319
  len = len + 256UL;
#line 320
  put_unaligned_be16(6, (void *)(& entry->type));
#line 322
  put_unaligned_be16((int )((u16 )len), (void *)(& entry->len));
#line 323
  strncpy((char *)(& entry->value), (char const   *)(& ((struct fc_host_attrs *)(lport->host)->shost_data)->hardware_version),
          256UL);
#line 328
  entry = (struct fc_fdmi_attr_entry *)(& entry->value) + 256U;
#line 330
  len = 4UL;
#line 331
  len = len + 256UL;
#line 332
  put_unaligned_be16(7, (void *)(& entry->type));
#line 334
  put_unaligned_be16((int )((u16 )len), (void *)(& entry->len));
#line 335
  strncpy((char *)(& entry->value), (char const   *)(& ((struct fc_host_attrs *)(lport->host)->shost_data)->driver_version),
          256UL);
#line 340
  entry = (struct fc_fdmi_attr_entry *)(& entry->value) + 256U;
#line 342
  len = 4UL;
#line 343
  len = len + 256UL;
#line 344
  put_unaligned_be16(8, (void *)(& entry->type));
#line 346
  put_unaligned_be16((int )((u16 )len), (void *)(& entry->len));
#line 347
  strncpy((char *)(& entry->value), (char const   *)(& ((struct fc_host_attrs *)(lport->host)->shost_data)->optionrom_version),
          256UL);
#line 352
  entry = (struct fc_fdmi_attr_entry *)(& entry->value) + 256U;
#line 354
  len = 4UL;
#line 355
  len = len + 256UL;
#line 356
  put_unaligned_be16(9, (void *)(& entry->type));
#line 358
  put_unaligned_be16((int )((u16 )len), (void *)(& entry->len));
#line 359
  strncpy((char *)(& entry->value), (char const   *)(& ((struct fc_host_attrs *)(lport->host)->shost_data)->firmware_version),
          256UL);
#line 364
  entry = (struct fc_fdmi_attr_entry *)(& entry->value) + 256U;
#line 366
  len = 4UL;
#line 367
  len = len + 256UL;
#line 368
  put_unaligned_be16(10, (void *)(& entry->type));
#line 370
  put_unaligned_be16((int )((u16 )len), (void *)(& entry->len));
#line 371
  tmp = init_utsname();
#line 371
  tmp___0 = init_utsname();
#line 371
  snprintf((char *)(& entry->value), 256UL, "%s v%s", (char *)(& tmp___0->sysname),
           (char *)(& tmp->release));
#line 376
  goto ldv_40985;
  case 529U: 
#line 378
  numattrs = 6;
#line 379
  len = 17UL;
#line 380
  len = len - 5UL;
#line 381
  len = (size_t )(numattrs * 4) + len;
#line 382
  len = len + 32UL;
#line 383
  len = len + 4UL;
#line 384
  len = len + 4UL;
#line 385
  len = len + 4UL;
#line 386
  len = len + 256UL;
#line 387
  len = len + 256UL;
#line 388
  ct = fc_ct_hdr_fill((struct fc_frame  const  *)fp, op, len, 250, 16);
#line 392
  put_unaligned_be64(lport->wwpn, (void *)(& ct->payload.rpa.port.portname));
#line 396
  put_unaligned_be32((u32 )numattrs, (void *)(& ct->payload.rpa.hba_attrs.numattrs));
#line 399
  hba_attrs = & ct->payload.rpa.hba_attrs;
#line 400
  entry = (struct fc_fdmi_attr_entry *)(& hba_attrs->attr);
#line 403
  len = 4UL;
#line 404
  len = len + 32UL;
#line 405
  put_unaligned_be16(1, (void *)(& entry->type));
#line 407
  put_unaligned_be16((int )((u16 )len), (void *)(& entry->len));
#line 408
  memcpy((void *)(& entry->value), (void const   *)(& ((struct fc_host_attrs *)(lport->host)->shost_data)->supported_fc4s),
           32UL);
#line 412
  entry = (struct fc_fdmi_attr_entry *)(& entry->value) + 32U;
#line 414
  len = 4UL;
#line 415
  len = len + 4UL;
#line 416
  put_unaligned_be16(2, (void *)(& entry->type));
#line 418
  put_unaligned_be16((int )((u16 )len), (void *)(& entry->len));
#line 420
  put_unaligned_be32(((struct fc_host_attrs *)(lport->host)->shost_data)->supported_speeds,
                     (void *)(& entry->value));
#line 424
  entry = (struct fc_fdmi_attr_entry *)(& entry->value) + 4U;
#line 426
  len = 4UL;
#line 427
  len = len + 4UL;
#line 428
  put_unaligned_be16(3, (void *)(& entry->type));
#line 430
  put_unaligned_be16((int )((u16 )len), (void *)(& entry->len));
#line 431
  put_unaligned_be32((u32 )lport->link_speed, (void *)(& entry->value));
#line 435
  entry = (struct fc_fdmi_attr_entry *)(& entry->value) + 4U;
#line 437
  len = 4UL;
#line 438
  len = len + 4UL;
#line 439
  put_unaligned_be16(4, (void *)(& entry->type));
#line 441
  put_unaligned_be16((int )((u16 )len), (void *)(& entry->len));
#line 442
  put_unaligned_be32(((struct fc_host_attrs *)(lport->host)->shost_data)->maxframe_size,
                     (void *)(& entry->value));
#line 446
  entry = (struct fc_fdmi_attr_entry *)(& entry->value) + 4U;
#line 448
  len = 4UL;
#line 449
  len = len + 256UL;
#line 450
  put_unaligned_be16(5, (void *)(& entry->type));
#line 452
  put_unaligned_be16((int )((u16 )len), (void *)(& entry->len));
#line 454
  tmp___1 = dev_name((struct device  const  *)(& (lport->host)->shost_gendev));
#line 454
  tmp___2 = strnlen(tmp___1, 256UL);
#line 454
  tmp___3 = dev_name((struct device  const  *)(& (lport->host)->shost_gendev));
#line 454
  strncpy((char *)(& entry->value), tmp___3, tmp___2);
#line 460
  entry = (struct fc_fdmi_attr_entry *)(& entry->value) + 256U;
#line 462
  len = 4UL;
#line 463
  len = len + 256UL;
#line 464
  put_unaligned_be16(6, (void *)(& entry->type));
#line 466
  put_unaligned_be16((int )((u16 )len), (void *)(& entry->len));
#line 467
  tmp___6 = strlen((char const   *)(& ((struct fc_host_attrs *)(lport->host)->shost_data)->system_hostname));
#line 467
  if (tmp___6 != 0UL) {
#line 468
    tmp___4 = strnlen((char const   *)(& ((struct fc_host_attrs *)(lport->host)->shost_data)->system_hostname),
                      256UL);
#line 468
    strncpy((char *)(& entry->value), (char const   *)(& ((struct fc_host_attrs *)(lport->host)->shost_data)->system_hostname),
            tmp___4);
  } else {
#line 473
    tmp___5 = init_utsname();
#line 473
    strncpy((char *)(& entry->value), (char const   *)(& tmp___5->nodename), 256UL);
  }
#line 476
  goto ldv_40985;
  case 784U: 
#line 478
  len = 8UL;
#line 479
  ct = fc_ct_hdr_fill((struct fc_frame  const  *)fp, op, len, 250, 16);
#line 482
  put_unaligned_be64(lport->wwpn, (void *)(& ct->payload.dprt.port.portname));
#line 484
  goto ldv_40985;
  case 768U: 
#line 486
  len = 8UL;
#line 487
  ct = fc_ct_hdr_fill((struct fc_frame  const  *)fp, op, len, 250, 16);
#line 490
  put_unaligned_be64(lport->wwpn, (void *)(& ct->payload.dhba.hbaid.id));
#line 491
  goto ldv_40985;
  default: ;
#line 493
  return (-22);
  }
  ldv_40985: 
#line 495
  *r_ctl = 2;
#line 496
  *fh_type = 32;
#line 497
  return (0);
}
}
#line 509 "include/scsi/fc_encode.h"
__inline static int fc_ct_fill(struct fc_lport *lport , u32 fc_id , struct fc_frame *fp ,
                               unsigned int op , enum fc_rctl *r_ctl , enum fc_fh_type *fh_type ,
                               u32 *did ) 
{ 
  int rc ;

  {
#line 514
  rc = -22;
#line 516
  switch (fc_id) {
  case 16777210U: 
#line 518
  rc = fc_ct_ms_fill(lport, fc_id, fp, op, r_ctl, fh_type);
#line 519
  *did = 16777210U;
#line 520
  goto ldv_41001;
  case 16777212U: ;
  default: 
#line 523
  rc = fc_ct_ns_fill(lport, fc_id, fp, op, r_ctl, fh_type);
#line 524
  *did = 16777212U;
#line 525
  goto ldv_41001;
  }
  ldv_41001: ;
#line 528
  return (rc);
}
}
#line 533 "include/scsi/fc_encode.h"
__inline static void fc_plogi_fill(struct fc_lport *lport , struct fc_frame *fp ,
                                   unsigned int op ) 
{ 
  struct fc_els_flogi *plogi ;
  struct fc_els_csp *csp ;
  struct fc_els_cssp *cp ;
  void *tmp ;
  __u16 tmp___0 ;
  __u32 tmp___1 ;
  __u16 tmp___2 ;

  {
#line 540
  tmp = fc_frame_payload_get((struct fc_frame  const  *)fp, 116UL);
#line 540
  plogi = (struct fc_els_flogi *)tmp;
#line 541
  memset((void *)plogi, 0, 116UL);
#line 542
  plogi->fl_cmd = (unsigned char )op;
#line 543
  put_unaligned_be64(lport->wwpn, (void *)(& plogi->fl_wwpn));
#line 544
  put_unaligned_be64(lport->wwnn, (void *)(& plogi->fl_wwnn));
#line 546
  csp = & plogi->fl_csp;
#line 547
  csp->sp_hi_ver = 32U;
#line 548
  csp->sp_lo_ver = 32U;
#line 549
  csp->sp_bb_cred = 2560U;
#line 550
  tmp___0 = __fswab16((int )((unsigned short )lport->mfs));
#line 550
  csp->sp_bb_data = tmp___0;
#line 551
  cp = (struct fc_els_cssp *)(& plogi->fl_cssp) + 2UL;
#line 552
  cp->cp_class = 136U;
#line 553
  csp->sp_features = 128U;
#line 554
  csp->sp_u.sp_plogi._sp_tot_seq = 65280U;
#line 555
  csp->sp_u.sp_plogi._sp_rel_off = 7936U;
#line 556
  tmp___1 = __fswab32(lport->e_d_tov);
#line 556
  csp->sp_e_d_tov = tmp___1;
#line 558
  tmp___2 = __fswab16((int )((unsigned short )lport->mfs));
#line 558
  cp->cp_rdfs = tmp___2;
#line 559
  cp->cp_con_seq = 65280U;
#line 560
  cp->cp_open_seq = 1U;
#line 561
  return;
}
}
#line 566 "include/scsi/fc_encode.h"
__inline static void fc_flogi_fill(struct fc_lport *lport , struct fc_frame *fp ) 
{ 
  struct fc_els_csp *sp ;
  struct fc_els_cssp *cp ;
  struct fc_els_flogi *flogi ;
  void *tmp ;
  __u16 tmp___0 ;

  {
#line 572
  tmp = fc_frame_payload_get((struct fc_frame  const  *)fp, 116UL);
#line 572
  flogi = (struct fc_els_flogi *)tmp;
#line 573
  memset((void *)flogi, 0, 116UL);
#line 574
  flogi->fl_cmd = 4U;
#line 575
  put_unaligned_be64(lport->wwpn, (void *)(& flogi->fl_wwpn));
#line 576
  put_unaligned_be64(lport->wwnn, (void *)(& flogi->fl_wwnn));
#line 577
  sp = & flogi->fl_csp;
#line 578
  sp->sp_hi_ver = 32U;
#line 579
  sp->sp_lo_ver = 32U;
#line 580
  sp->sp_bb_cred = 2560U;
#line 581
  tmp___0 = __fswab16((int )((unsigned short )lport->mfs));
#line 581
  sp->sp_bb_data = tmp___0;
#line 582
  cp = (struct fc_els_cssp *)(& flogi->fl_cssp) + 2UL;
#line 583
  cp->cp_class = 136U;
#line 584
  if ((unsigned int )*((unsigned char *)lport + 1144UL) != 0U) {
#line 585
    sp->sp_features = 128U;
  } else {

  }
#line 586
  return;
}
}
#line 591 "include/scsi/fc_encode.h"
__inline static void fc_fdisc_fill(struct fc_lport *lport , struct fc_frame *fp ) 
{ 
  struct fc_els_csp *sp ;
  struct fc_els_cssp *cp ;
  struct fc_els_flogi *fdisc ;
  void *tmp ;
  __u16 tmp___0 ;

  {
#line 597
  tmp = fc_frame_payload_get((struct fc_frame  const  *)fp, 116UL);
#line 597
  fdisc = (struct fc_els_flogi *)tmp;
#line 598
  memset((void *)fdisc, 0, 116UL);
#line 599
  fdisc->fl_cmd = 81U;
#line 600
  put_unaligned_be64(lport->wwpn, (void *)(& fdisc->fl_wwpn));
#line 601
  put_unaligned_be64(lport->wwnn, (void *)(& fdisc->fl_wwnn));
#line 602
  sp = & fdisc->fl_csp;
#line 603
  sp->sp_hi_ver = 32U;
#line 604
  sp->sp_lo_ver = 32U;
#line 605
  sp->sp_bb_cred = 2560U;
#line 606
  tmp___0 = __fswab16((int )((unsigned short )lport->mfs));
#line 606
  sp->sp_bb_data = tmp___0;
#line 607
  cp = (struct fc_els_cssp *)(& fdisc->fl_cssp) + 2UL;
#line 608
  cp->cp_class = 136U;
#line 609
  return;
}
}
#line 614 "include/scsi/fc_encode.h"
__inline static void fc_logo_fill(struct fc_lport *lport , struct fc_frame *fp ) 
{ 
  struct fc_els_logo *logo ;
  void *tmp ;
  __u64 tmp___0 ;

  {
#line 618
  tmp = fc_frame_payload_get((struct fc_frame  const  *)fp, 16UL);
#line 618
  logo = (struct fc_els_logo *)tmp;
#line 619
  memset((void *)logo, 0, 16UL);
#line 620
  logo->fl_cmd = 5U;
#line 621
  hton24((u8 *)(& logo->fl_n_port_id), lport->port_id);
#line 622
  tmp___0 = __fswab64(lport->wwpn);
#line 622
  logo->fl_n_port_wwn = tmp___0;
#line 623
  return;
}
}
#line 628 "include/scsi/fc_encode.h"
__inline static void fc_rtv_fill(struct fc_lport *lport , struct fc_frame *fp ) 
{ 
  struct fc_els_rtv *rtv ;
  void *tmp ;

  {
#line 632
  tmp = fc_frame_payload_get((struct fc_frame  const  *)fp, 4UL);
#line 632
  rtv = (struct fc_els_rtv *)tmp;
#line 633
  memset((void *)rtv, 0, 4UL);
#line 634
  rtv->rtv_cmd = 14U;
#line 635
  return;
}
}
#line 640 "include/scsi/fc_encode.h"
__inline static void fc_rec_fill(struct fc_lport *lport , struct fc_frame *fp ) 
{ 
  struct fc_els_rec *rec ;
  struct fc_exch *ep ;
  struct fc_seq  const  *__mptr ;
  void *tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;

  {
#line 643
  __mptr = (struct fc_seq  const  *)((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_seq;
#line 643
  ep = (struct fc_exch *)__mptr + 0xffffffffffffff64UL;
#line 645
  tmp = fc_frame_payload_get((struct fc_frame  const  *)fp, 12UL);
#line 645
  rec = (struct fc_els_rec *)tmp;
#line 646
  memset((void *)rec, 0, 12UL);
#line 647
  rec->rec_cmd = 19U;
#line 648
  hton24((u8 *)(& rec->rec_s_id), lport->port_id);
#line 649
  tmp___0 = __fswab16((int )ep->oxid);
#line 649
  rec->rec_ox_id = tmp___0;
#line 650
  tmp___1 = __fswab16((int )ep->rxid);
#line 650
  rec->rec_rx_id = tmp___1;
#line 651
  return;
}
}
#line 656 "include/scsi/fc_encode.h"
__inline static void fc_prli_fill(struct fc_lport *lport , struct fc_frame *fp ) 
{ 
  struct __anonstruct_pp_301 *pp ;
  void *tmp ;
  __u32 tmp___0 ;

  {
#line 663
  tmp = fc_frame_payload_get((struct fc_frame  const  *)fp, 20UL);
#line 663
  pp = (struct __anonstruct_303 *)tmp;
#line 664
  memset((void *)pp, 0, 20UL);
#line 665
  pp->prli.prli_cmd = 32U;
#line 666
  pp->prli.prli_spp_len = 16U;
#line 667
  pp->prli.prli_len = 5120U;
#line 668
  pp->spp.spp_type = 8U;
#line 669
  pp->spp.spp_flags = 32U;
#line 670
  tmp___0 = __fswab32(lport->service_params);
#line 670
  pp->spp.spp_params = tmp___0;
#line 671
  return;
}
}
#line 676 "include/scsi/fc_encode.h"
__inline static void fc_scr_fill(struct fc_lport *lport , struct fc_frame *fp ) 
{ 
  struct fc_els_scr *scr ;
  void *tmp ;

  {
#line 680
  tmp = fc_frame_payload_get((struct fc_frame  const  *)fp, 8UL);
#line 680
  scr = (struct fc_els_scr *)tmp;
#line 681
  memset((void *)scr, 0, 8UL);
#line 682
  scr->scr_cmd = 98U;
#line 683
  scr->scr_reg_func = 3U;
#line 684
  return;
}
}
#line 689 "include/scsi/fc_encode.h"
__inline static int fc_els_fill(struct fc_lport *lport , u32 did , struct fc_frame *fp ,
                                unsigned int op , enum fc_rctl *r_ctl , enum fc_fh_type *fh_type ) 
{ 


  {
#line 694
  switch (op) {
  case 82U: 
#line 696
  fc_adisc_fill(lport, fp);
#line 697
  goto ldv_41066;
  case 3U: 
#line 700
  fc_plogi_fill(lport, fp, 3U);
#line 701
  goto ldv_41066;
  case 4U: 
#line 704
  fc_flogi_fill(lport, fp);
#line 705
  goto ldv_41066;
  case 81U: 
#line 708
  fc_fdisc_fill(lport, fp);
#line 709
  goto ldv_41066;
  case 5U: 
#line 712
  fc_logo_fill(lport, fp);
#line 713
  goto ldv_41066;
  case 14U: 
#line 716
  fc_rtv_fill(lport, fp);
#line 717
  goto ldv_41066;
  case 19U: 
#line 720
  fc_rec_fill(lport, fp);
#line 721
  goto ldv_41066;
  case 32U: 
#line 724
  fc_prli_fill(lport, fp);
#line 725
  goto ldv_41066;
  case 98U: 
#line 728
  fc_scr_fill(lport, fp);
#line 729
  goto ldv_41066;
  default: ;
#line 732
  return (-22);
  }
  ldv_41066: 
#line 735
  *r_ctl = 34;
#line 736
  *fh_type = 1;
#line 737
  return (0);
}
}
#line 126 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/libfc/fc_libfc.h"
char const   *fc_els_resp_type(struct fc_frame *fp ) ;
#line 43 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_elsct.c"
struct fc_seq *fc_elsct_send(struct fc_lport *lport , u32 did , struct fc_frame *fp ,
                             unsigned int op , void (*resp)(struct fc_seq * , struct fc_frame * ,
                                                            void * ) , void *arg ,
                             u32 timer_msec ) 
{ 
  enum fc_rctl r_ctl ;
  enum fc_fh_type fh_type ;
  int rc ;
  struct fc_seq *tmp ;

  {
#line 55
  if (op != 0U && op <= 144U) {
#line 56
    rc = fc_els_fill(lport, did, fp, op, & r_ctl, & fh_type);
  } else {
#line 59
    rc = fc_ct_fill(lport, did, fp, op, & r_ctl, & fh_type, & did);
  }
#line 62
  if (rc != 0) {
#line 63
    fc_frame_free(fp);
#line 64
    return ((struct fc_seq *)0);
  } else {

  }
#line 67
  fc_fill_fc_hdr(fp, r_ctl, did, lport->port_id, fh_type, 2686976U, 0U);
#line 70
  tmp = (*(lport->tt.exch_seq_send))(lport, fp, resp, (void (*)(struct fc_seq * ,
                                                                void * ))0, arg, timer_msec);
#line 70
  return (tmp);
}
}
#line 72 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_elsct.c"
static char const   __kstrtab_fc_elsct_send[14U]  = 
#line 72
  {      'f',      'c',      '_',      'e', 
        'l',      's',      'c',      't', 
        '_',      's',      'e',      'n', 
        'd',      '\000'};
#line 72
struct kernel_symbol  const  __ksymtab_fc_elsct_send ;
#line 72 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_elsct.c"
struct kernel_symbol  const  __ksymtab_fc_elsct_send  =    {(unsigned long )(& fc_elsct_send), (char const   *)(& __kstrtab_fc_elsct_send)};
#line 78 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_elsct.c"
int fc_elsct_init(struct fc_lport *lport ) 
{ 


  {
#line 80
  if ((unsigned long )lport->tt.elsct_send == (unsigned long )((struct fc_seq *(*)(struct fc_lport * ,
                                                                                   u32  ,
                                                                                   struct fc_frame * ,
                                                                                   unsigned int  ,
                                                                                   void (*)(struct fc_seq * ,
                                                                                            struct fc_frame * ,
                                                                                            void * ) ,
                                                                                   void * ,
                                                                                   u32  ))0)) {
#line 81
    lport->tt.elsct_send = & fc_elsct_send;
  } else {

  }
#line 83
  return (0);
}
}
#line 85 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_elsct.c"
static char const   __kstrtab_fc_elsct_init[14U]  = 
#line 85
  {      'f',      'c',      '_',      'e', 
        'l',      's',      'c',      't', 
        '_',      'i',      'n',      'i', 
        't',      '\000'};
#line 85
struct kernel_symbol  const  __ksymtab_fc_elsct_init ;
#line 85 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_elsct.c"
struct kernel_symbol  const  __ksymtab_fc_elsct_init  =    {(unsigned long )(& fc_elsct_init), (char const   *)(& __kstrtab_fc_elsct_init)};
#line 91 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_elsct.c"
char const   *fc_els_resp_type(struct fc_frame *fp ) 
{ 
  char const   *msg ;
  struct fc_frame_header *fh ;
  struct fc_ct_hdr *ct ;
  long tmp ;
  u8 tmp___0 ;
  void *tmp___1 ;
  __u16 tmp___2 ;
  bool tmp___3 ;

  {
#line 97
  tmp___3 = IS_ERR((void const   *)fp);
#line 97
  if ((int )tmp___3) {
#line 98
    tmp = PTR_ERR((void const   *)fp);
#line 98
    switch (- tmp) {
    case 0L: 
#line 100
    msg = "response no error";
#line 101
    goto ldv_41161;
    case 1L: 
#line 103
    msg = "response timeout";
#line 104
    goto ldv_41161;
    case 2L: 
#line 106
    msg = "response closed";
#line 107
    goto ldv_41161;
    default: 
#line 109
    msg = "response unknown error";
#line 110
    goto ldv_41161;
    }
    ldv_41161: ;
  } else {
#line 113
    fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 114
    switch ((int )fh->fh_type) {
    case 1: 
#line 116
    tmp___0 = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 116
    switch ((int )tmp___0) {
    case 2: 
#line 118
    msg = "accept";
#line 119
    goto ldv_41167;
    case 1: 
#line 121
    msg = "reject";
#line 122
    goto ldv_41167;
    default: 
#line 124
    msg = "response unknown ELS";
#line 125
    goto ldv_41167;
    }
    ldv_41167: ;
#line 127
    goto ldv_41170;
    case 32: 
#line 129
    tmp___1 = fc_frame_payload_get((struct fc_frame  const  *)fp, 16UL);
#line 129
    ct = (struct fc_ct_hdr *)tmp___1;
#line 130
    if ((unsigned long )ct != (unsigned long )((struct fc_ct_hdr *)0)) {
#line 131
      tmp___2 = __fswab16((int )ct->ct_cmd);
#line 131
      switch ((int )tmp___2) {
      case 32770: 
#line 133
      msg = "CT accept";
#line 134
      goto ldv_41173;
      case 32769: 
#line 136
      msg = "CT reject";
#line 137
      goto ldv_41173;
      default: 
#line 139
      msg = "response unknown CT";
#line 140
      goto ldv_41173;
      }
      ldv_41173: ;
    } else {
#line 143
      msg = "short CT response";
    }
#line 145
    goto ldv_41170;
    default: 
#line 147
    msg = "response not ELS or CT";
#line 148
    goto ldv_41170;
    }
    ldv_41170: ;
  }
#line 151
  return (msg);
}
}
#line 264 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_elsct.o.c.prepared"
bool ldv_queue_work_on_164(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 268
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 268
  ldv_func_res = tmp;
#line 270
  activate_work_3(ldv_func_arg3, 2);
#line 272
  return (ldv_func_res);
}
}
#line 275 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_elsct.o.c.prepared"
bool ldv_queue_delayed_work_on_165(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 279
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 279
  ldv_func_res = tmp;
#line 281
  activate_work_3(& ldv_func_arg3->work, 2);
#line 283
  return (ldv_func_res);
}
}
#line 286 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_elsct.o.c.prepared"
bool ldv_queue_work_on_166(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  bool tmp ;

  {
#line 290
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 290
  ldv_func_res = tmp;
#line 292
  activate_work_3(ldv_func_arg3, 2);
#line 294
  return (ldv_func_res);
}
}
#line 297 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_elsct.o.c.prepared"
void ldv_flush_workqueue_167(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 300
  flush_workqueue(ldv_func_arg1);
#line 302
  call_and_disable_all_3(2);
#line 303
  return;
}
}
#line 305 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_elsct.o.c.prepared"
bool ldv_queue_delayed_work_on_168(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
#line 309
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 309
  ldv_func_res = tmp;
#line 311
  activate_work_3(& ldv_func_arg3->work, 2);
#line 313
  return (ldv_func_res);
}
}
#line 351 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_elsct.o.c.prepared"
void *ldv_kmem_cache_alloc_174(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 354
  ldv_check_alloc_flags(flags);
#line 355
  tmp = ldv_undef_ptr();
#line 355
  return (tmp);
}
}
#line 393 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_elsct.o.c.prepared"
int ldv_pskb_expand_head_180(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 396
  ldv_check_alloc_flags(flags);
#line 397
  tmp = ldv_undef_ptr();
#line 397
  return ((int )((long )tmp));
}
}
#line 407 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_elsct.o.c.prepared"
struct sk_buff *ldv_skb_clone_182(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 410
  ldv_check_alloc_flags(flags);
#line 411
  tmp = ldv_undef_ptr();
#line 411
  return ((struct sk_buff *)tmp);
}
}
#line 421 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_elsct.o.c.prepared"
struct sk_buff *ldv_skb_copy_184(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 424
  ldv_check_alloc_flags(flags);
#line 425
  tmp = ldv_undef_ptr();
#line 425
  return ((struct sk_buff *)tmp);
}
}
#line 428 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_elsct.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_185(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 431
  ldv_check_alloc_flags(flags);
#line 432
  tmp = ldv_undef_ptr();
#line 432
  return ((struct sk_buff *)tmp);
}
}
#line 435 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_elsct.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_186(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 438
  ldv_check_alloc_flags(flags);
#line 439
  tmp = ldv_undef_ptr();
#line 439
  return ((struct sk_buff *)tmp);
}
}
#line 442 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_elsct.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_187(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 445
  ldv_check_alloc_flags(flags);
#line 446
  tmp = ldv_undef_ptr();
#line 446
  return ((struct sk_buff *)tmp);
}
}
#line 449 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_elsct.o.c.prepared"
int ldv_pskb_expand_head_188(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 452
  ldv_check_alloc_flags(flags);
#line 453
  tmp = ldv_undef_ptr();
#line 453
  return ((int )((long )tmp));
}
}
#line 456 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_elsct.o.c.prepared"
int ldv_pskb_expand_head_189(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 459
  ldv_check_alloc_flags(flags);
#line 460
  tmp = ldv_undef_ptr();
#line 460
  return ((int )((long )tmp));
}
}
#line 463 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_elsct.o.c.prepared"
struct sk_buff *ldv_skb_clone_190(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 466
  ldv_check_alloc_flags(flags);
#line 467
  tmp = ldv_undef_ptr();
#line 467
  return ((struct sk_buff *)tmp);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_210(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_212(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_211(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_214(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_213(struct workqueue_struct *ldv_func_arg1 ) ;
#line 293 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_220(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 828 "include/linux/skbuff.h"
__inline static struct sk_buff *alloc_skb_fclone(unsigned int size , gfp_t flags ) ;
#line 849
struct sk_buff *ldv_skb_clone_228(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 854
struct sk_buff *ldv_skb_copy_230(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 867
int ldv_pskb_expand_head_226(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 871
int ldv_pskb_expand_head_234(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 875
int ldv_pskb_expand_head_235(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 1793 "include/linux/skbuff.h"
__inline static void skb_reserve(struct sk_buff *skb , int len ) 
{ 


  {
#line 1795
  skb->data = skb->data + (unsigned long )len;
#line 1796
  skb->tail = skb->tail + (sk_buff_data_t )len;
#line 1797
  return;
}
}
#line 2148
struct sk_buff *ldv___netdev_alloc_skb_231(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2152
struct sk_buff *ldv___netdev_alloc_skb_232(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2156
struct sk_buff *ldv___netdev_alloc_skb_233(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 113 "include/scsi/fc_frame.h"
__inline static void fc_frame_init(struct fc_frame *fp ) 
{ 


  {
#line 115
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_dev = (struct fc_lport *)0;
#line 116
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_seq = (struct fc_seq *)0;
#line 117
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_flags = 0U;
#line 118
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_encaps = 0U;
#line 119
  return;
}
}
#line 242
u32 fc_frame_crc_check(struct fc_frame *fp ) ;
#line 34 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.c"
u32 fc_frame_crc_check(struct fc_frame *fp ) 
{ 
  u32 crc ;
  u32 error ;
  u8 const   *bp ;
  unsigned int len ;
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  u32 tmp___1 ;

  {
#line 41
  tmp = fc_frame_is_linear(fp);
#line 41
  __ret_warn_on = tmp == 0;
#line 41
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 41
  if (tmp___0 != 0L) {
#line 41
    warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.c",
                       41);
  } else {

  }
#line 41
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 42
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_flags = (unsigned int )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_flags & 254U;
#line 43
  len = (fp->skb.len + 3U) & 4294967292U;
#line 44
  bp = (u8 const   *)fp->skb.data;
#line 45
  tmp___1 = crc32_le(4294967295U, bp, (size_t )len);
#line 45
  crc = ~ tmp___1;
#line 46
  error = ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_crc ^ crc;
#line 47
  return (error);
}
}
#line 49 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.c"
static char const   __kstrtab_fc_frame_crc_check[19U]  = 
#line 49
  {      'f',      'c',      '_',      'f', 
        'r',      'a',      'm',      'e', 
        '_',      'c',      'r',      'c', 
        '_',      'c',      'h',      'e', 
        'c',      'k',      '\000'};
#line 49
struct kernel_symbol  const  __ksymtab_fc_frame_crc_check ;
#line 49 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.c"
struct kernel_symbol  const  __ksymtab_fc_frame_crc_check  =    {(unsigned long )(& fc_frame_crc_check), (char const   *)(& __kstrtab_fc_frame_crc_check)};
#line 55 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.c"
struct fc_frame *_fc_frame_alloc(size_t len ) 
{ 
  struct fc_frame *fp ;
  struct sk_buff *skb ;
  int __ret_warn_on ;
  long tmp ;
  int _max1 ;
  int _max2 ;
  int _max1___0 ;
  int _max2___0 ;

  {
#line 60
  __ret_warn_on = (len & 3UL) != 0UL;
#line 60
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 60
  if (tmp != 0L) {
#line 60
    warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.c",
                       60);
  } else {

  }
#line 60
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 61
  len = len + 24UL;
#line 63
  _max1 = 32;
#line 63
  _max2 = 64;
#line 63
  skb = alloc_skb_fclone(((unsigned int )(_max1 > _max2 ? _max1 : _max2) + (unsigned int )len) + 40U,
                         32U);
#line 64
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
#line 65
    return ((struct fc_frame *)0);
  } else {

  }
#line 66
  _max1___0 = 32;
#line 66
  _max2___0 = 64;
#line 66
  skb_reserve(skb, (_max1___0 > _max2___0 ? _max1___0 : _max2___0) + 32);
#line 67
  fp = (struct fc_frame *)skb;
#line 68
  fc_frame_init(fp);
#line 69
  skb_put(skb, (unsigned int )len);
#line 70
  return (fp);
}
}
#line 72 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.c"
static char const   __kstrtab__fc_frame_alloc[16U]  = 
#line 72
  {      '_',      'f',      'c',      '_', 
        'f',      'r',      'a',      'm', 
        'e',      '_',      'a',      'l', 
        'l',      'o',      'c',      '\000'};
#line 72
struct kernel_symbol  const  __ksymtab__fc_frame_alloc ;
#line 72 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.c"
struct kernel_symbol  const  __ksymtab__fc_frame_alloc  =    {(unsigned long )(& _fc_frame_alloc), (char const   *)(& __kstrtab__fc_frame_alloc)};
#line 74 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.c"
struct fc_frame *fc_frame_alloc_fill(struct fc_lport *lp , size_t payload_len ) 
{ 
  struct fc_frame *fp ;
  size_t fill ;

  {
#line 79
  fill = payload_len & 3UL;
#line 80
  if (fill != 0UL) {
#line 81
    fill = 4UL - fill;
  } else {

  }
#line 82
  fp = _fc_frame_alloc(payload_len + fill);
#line 83
  if ((unsigned long )fp != (unsigned long )((struct fc_frame *)0)) {
#line 84
    memset((void *)fp->skb.data + payload_len, 0, fill);
#line 86
    skb_trim(& fp->skb, (unsigned int )payload_len + 24U);
  } else {

  }
#line 89
  return (fp);
}
}
#line 91 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.c"
static char const   __kstrtab_fc_frame_alloc_fill[20U]  = 
#line 91
  {      'f',      'c',      '_',      'f', 
        'r',      'a',      'm',      'e', 
        '_',      'a',      'l',      'l', 
        'o',      'c',      '_',      'f', 
        'i',      'l',      'l',      '\000'};
#line 91
struct kernel_symbol  const  __ksymtab_fc_frame_alloc_fill ;
#line 91 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.c"
struct kernel_symbol  const  __ksymtab_fc_frame_alloc_fill  =    {(unsigned long )(& fc_frame_alloc_fill), (char const   *)(& __kstrtab_fc_frame_alloc_fill)};
#line 264 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.o.c.prepared"
bool ldv_queue_work_on_210(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 268
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 268
  ldv_func_res = tmp;
#line 270
  activate_work_3(ldv_func_arg3, 2);
#line 272
  return (ldv_func_res);
}
}
#line 275 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.o.c.prepared"
bool ldv_queue_delayed_work_on_211(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 279
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 279
  ldv_func_res = tmp;
#line 281
  activate_work_3(& ldv_func_arg3->work, 2);
#line 283
  return (ldv_func_res);
}
}
#line 286 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.o.c.prepared"
bool ldv_queue_work_on_212(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  bool tmp ;

  {
#line 290
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 290
  ldv_func_res = tmp;
#line 292
  activate_work_3(ldv_func_arg3, 2);
#line 294
  return (ldv_func_res);
}
}
#line 297 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.o.c.prepared"
void ldv_flush_workqueue_213(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 300
  flush_workqueue(ldv_func_arg1);
#line 302
  call_and_disable_all_3(2);
#line 303
  return;
}
}
#line 305 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.o.c.prepared"
bool ldv_queue_delayed_work_on_214(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
#line 309
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 309
  ldv_func_res = tmp;
#line 311
  activate_work_3(& ldv_func_arg3->work, 2);
#line 313
  return (ldv_func_res);
}
}
#line 351 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.o.c.prepared"
void *ldv_kmem_cache_alloc_220(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 354
  ldv_check_alloc_flags(flags);
#line 355
  tmp = ldv_undef_ptr();
#line 355
  return (tmp);
}
}
#line 386 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.o.c.prepared"
__inline static struct sk_buff *alloc_skb_fclone(unsigned int size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 389
  ldv_check_alloc_flags(flags);
#line 390
  tmp = ldv_undef_ptr();
#line 390
  return ((struct sk_buff *)tmp);
}
}
#line 393 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.o.c.prepared"
int ldv_pskb_expand_head_226(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 396
  ldv_check_alloc_flags(flags);
#line 397
  tmp = ldv_undef_ptr();
#line 397
  return ((int )((long )tmp));
}
}
#line 407 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.o.c.prepared"
struct sk_buff *ldv_skb_clone_228(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 410
  ldv_check_alloc_flags(flags);
#line 411
  tmp = ldv_undef_ptr();
#line 411
  return ((struct sk_buff *)tmp);
}
}
#line 421 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.o.c.prepared"
struct sk_buff *ldv_skb_copy_230(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 424
  ldv_check_alloc_flags(flags);
#line 425
  tmp = ldv_undef_ptr();
#line 425
  return ((struct sk_buff *)tmp);
}
}
#line 428 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_231(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 431
  ldv_check_alloc_flags(flags);
#line 432
  tmp = ldv_undef_ptr();
#line 432
  return ((struct sk_buff *)tmp);
}
}
#line 435 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_232(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 438
  ldv_check_alloc_flags(flags);
#line 439
  tmp = ldv_undef_ptr();
#line 439
  return ((struct sk_buff *)tmp);
}
}
#line 442 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_233(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 445
  ldv_check_alloc_flags(flags);
#line 446
  tmp = ldv_undef_ptr();
#line 446
  return ((struct sk_buff *)tmp);
}
}
#line 449 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.o.c.prepared"
int ldv_pskb_expand_head_234(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 452
  ldv_check_alloc_flags(flags);
#line 453
  tmp = ldv_undef_ptr();
#line 453
  return ((int )((long )tmp));
}
}
#line 456 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_frame.o.c.prepared"
int ldv_pskb_expand_head_235(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 459
  ldv_check_alloc_flags(flags);
#line 460
  tmp = ldv_undef_ptr();
#line 460
  return ((int )((long )tmp));
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 18 "include/linux/math64.h"
__inline static u64 div_u64_rem(u64 dividend , u32 divisor , u32 *remainder ) 
{ 


  {
#line 20
  *remainder = (u32 )(dividend % (u64 )divisor);
#line 21
  return (dividend / (u64 )divisor);
}
}
#line 97 "include/linux/math64.h"
__inline static u64 div_u64(u64 dividend , u32 divisor ) 
{ 
  u32 remainder ;
  u64 tmp ;

  {
#line 100
  tmp = div_u64_rem(dividend, divisor, & remainder);
#line 100
  return (tmp);
}
}
#line 23 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) ;
#line 32
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 333 "include/linux/lockdep.h"
extern void lock_acquire(struct lockdep_map * , unsigned int  , int  , int  , int  ,
                         struct lockdep_map * , unsigned long  ) ;
#line 337
extern void lock_release(struct lockdep_map * , int  , unsigned long  ) ;
#line 545
extern void lockdep_rcu_suspicious(char const   * , int const    , char const   * ) ;
#line 78 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 420
extern void jiffies_to_timespec(unsigned long const    , struct timespec * ) ;
#line 268 "include/linux/rcupdate.h"
__inline static void __rcu_read_lock(void) 
{ 


  {
#line 270
  __preempt_count_add(1);
#line 270
  __asm__  volatile   ("": : : "memory");
#line 271
  return;
}
}
#line 273 "include/linux/rcupdate.h"
__inline static void __rcu_read_unlock(void) 
{ 


  {
#line 275
  __asm__  volatile   ("": : : "memory");
#line 275
  __preempt_count_sub(1);
#line 276
  return;
}
}
#line 104 "include/linux/rcutree.h"
extern bool rcu_is_watching(void) ;
#line 447 "include/linux/rcupdate.h"
__inline static void rcu_lock_acquire(struct lockdep_map *map ) 
{ 


  {
#line 449
  lock_acquire(map, 0U, 0, 2, 0, (struct lockdep_map *)0, 0UL);
#line 450
  return;
}
}
#line 452 "include/linux/rcupdate.h"
__inline static void rcu_lock_release(struct lockdep_map *map ) 
{ 


  {
#line 454
  lock_release(map, 1, 0UL);
#line 455
  return;
}
}
#line 457
extern struct lockdep_map rcu_lock_map ;
#line 463
extern int rcu_read_lock_held(void) ;
#line 843 "include/linux/rcupdate.h"
__inline static void rcu_read_lock(void) 
{ 
  bool __warned ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 845
  __rcu_read_lock();
#line 847
  rcu_lock_acquire(& rcu_lock_map);
#line 848
  tmp = debug_lockdep_rcu_enabled();
#line 848
  if (tmp != 0 && ! __warned) {
#line 848
    tmp___0 = rcu_is_watching();
#line 848
    if (tmp___0) {
#line 848
      tmp___1 = 0;
    } else {
#line 848
      tmp___1 = 1;
    }
#line 848
    if (tmp___1) {
#line 848
      __warned = 1;
#line 848
      lockdep_rcu_suspicious("include/linux/rcupdate.h", 849, "rcu_read_lock() used illegally while idle");
    } else {

    }
  } else {

  }
#line 851
  return;
}
}
#line 897 "include/linux/rcupdate.h"
__inline static void rcu_read_unlock(void) 
{ 
  bool __warned ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 899
  tmp = debug_lockdep_rcu_enabled();
#line 899
  if (tmp != 0 && ! __warned) {
#line 899
    tmp___0 = rcu_is_watching();
#line 899
    if (tmp___0) {
#line 899
      tmp___1 = 0;
    } else {
#line 899
      tmp___1 = 1;
    }
#line 899
    if (tmp___1) {
#line 899
      __warned = 1;
#line 899
      lockdep_rcu_suspicious("include/linux/rcupdate.h", 900, "rcu_read_unlock() used illegally while idle");
    } else {

    }
  } else {

  }
#line 902
  __rcu_read_unlock();
#line 903
  rcu_lock_release(& rcu_lock_map);
#line 904
  return;
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_255(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_257(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_256(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_259(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_258(struct workqueue_struct *ldv_func_arg1 ) ;
#line 471
bool ldv_cancel_delayed_work_sync_282(struct delayed_work *ldv_func_arg1 ) ;
#line 475
bool ldv_cancel_delayed_work_sync_283(struct delayed_work *ldv_func_arg1 ) ;
#line 479
bool ldv_cancel_delayed_work_sync_284(struct delayed_work *ldv_func_arg1 ) ;
#line 483 "include/linux/workqueue.h"
__inline static bool queue_delayed_work___1(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                            unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 487
  tmp = ldv_queue_delayed_work_on_256(8192, wq, dwork, delay);
#line 487
  return (tmp);
}
}
#line 585 "include/linux/workqueue.h"
__inline static bool schedule_delayed_work___0(struct delayed_work *dwork , unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 588
  tmp = queue_delayed_work___1(system_wq, dwork, delay);
#line 588
  return (tmp);
}
}
#line 502 "include/linux/module.h"
extern bool try_module_get(struct module * ) ;
#line 504
extern void module_put(struct module * ) ;
#line 293 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_265(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 585
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 126 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
void call_and_disable_work_3(struct work_struct *work ) ;
#line 135
void invoke_work_3(void) ;
#line 273 "include/linux/scatterlist.h"
extern size_t sg_copy_to_buffer(struct scatterlist * , unsigned int  , void * , size_t  ) ;
#line 754 "include/scsi/scsi_host.h"
__inline static void *shost_priv(struct Scsi_Host *shost ) 
{ 


  {
#line 756
  return ((void *)(& shost->hostdata));
}
}
#line 849 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_273(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 853
struct sk_buff *ldv_skb_clone_281(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 858
struct sk_buff *ldv_skb_copy_275(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 871
int ldv_pskb_expand_head_271(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 875
int ldv_pskb_expand_head_279(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 879
int ldv_pskb_expand_head_280(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2148
struct sk_buff *ldv___netdev_alloc_skb_276(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2152
struct sk_buff *ldv___netdev_alloc_skb_277(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2156
struct sk_buff *ldv___netdev_alloc_skb_278(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 830 "include/scsi/scsi_transport_fc.h"
__inline static void fc_vport_set_state(struct fc_vport *vport , enum fc_vport_state new_state ) 
{ 


  {
#line 832
  if ((unsigned int )new_state != 0U && (unsigned int )new_state != 4U) {
#line 834
    vport->vport_last_state = vport->vport_state;
  } else {

  }
#line 835
  vport->vport_state = new_state;
#line 836
  return;
}
}
#line 847
extern u32 fc_get_event_number(void) ;
#line 848
extern void fc_host_post_event(struct Scsi_Host * , u32  , enum fc_host_event_code  ,
                               u32  ) ;
#line 180 "include/scsi/fc_frame.h"
__inline static u32 fc_frame_sid(struct fc_frame  const  *fp ) 
{ 
  struct fc_frame_header *tmp ;
  u32 tmp___0 ;

  {
#line 182
  tmp = __fc_frame_header_get(fp);
#line 182
  tmp___0 = ntoh24((u8 const   *)(& tmp->fh_s_id));
#line 182
  return (tmp___0);
}
}
#line 188 "include/scsi/fc_frame.h"
__inline static u32 fc_frame_did(struct fc_frame  const  *fp ) 
{ 
  struct fc_frame_header *tmp ;
  u32 tmp___0 ;

  {
#line 190
  tmp = __fc_frame_header_get(fp);
#line 190
  tmp___0 = ntoh24((u8 const   *)(& tmp->fh_d_id));
#line 190
  return (tmp___0);
}
}
#line 983 "include/scsi/libfc.h"
__inline static void fc_lport_state_enter(struct fc_lport *lport , enum fc_lport_state state ) 
{ 


  {
#line 986
  if ((unsigned int )lport->state != (unsigned int )state) {
#line 987
    lport->retry_count = 0U;
  } else {

  }
#line 988
  lport->state = state;
#line 989
  return;
}
}
#line 1058
int fc_lport_init(struct fc_lport *lport ) ;
#line 1059
int fc_lport_destroy(struct fc_lport *lport ) ;
#line 1060
int fc_fabric_logoff(struct fc_lport *lport ) ;
#line 1061
int fc_fabric_login(struct fc_lport *lport ) ;
#line 1062
void __fc_linkup(struct fc_lport *lport ) ;
#line 1063
void fc_linkup(struct fc_lport *lport ) ;
#line 1064
void __fc_linkdown(struct fc_lport *lport ) ;
#line 1065
void fc_linkdown(struct fc_lport *lport ) ;
#line 1067
void fc_vports_linkchange(struct fc_lport *n_port ) ;
#line 1068
int fc_lport_config(struct fc_lport *lport ) ;
#line 1069
int fc_lport_reset(struct fc_lport *lport ) ;
#line 1070
int fc_set_mfs(struct fc_lport *lport , u32 mfs ) ;
#line 1073
int fc_lport_bsg_request(struct fc_bsg_job *job ) ;
#line 1074
void fc_lport_set_local_id(struct fc_lport *lport , u32 port_id ) ;
#line 1120
void fc_lport_flogi_resp(struct fc_seq *sp , struct fc_frame *fp , void *lp_arg ) ;
#line 1121
void fc_lport_logo_resp(struct fc_seq *sp , struct fc_frame *fp , void *lp_arg ) ;
#line 1148
void fc_get_host_speed(struct Scsi_Host *shost ) ;
#line 1149
void fc_get_host_port_state(struct Scsi_Host *shost ) ;
#line 1151
struct fc_host_statistics *fc_get_host_stats(struct Scsi_Host *shost ) ;
#line 110 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_error(struct fc_lport *lport , struct fc_frame *fp ) ;
#line 112
static void fc_lport_enter_reset(struct fc_lport *lport ) ;
#line 113
static void fc_lport_enter_flogi(struct fc_lport *lport ) ;
#line 114
static void fc_lport_enter_dns(struct fc_lport *lport ) ;
#line 115
static void fc_lport_enter_ns(struct fc_lport *lport , enum fc_lport_state state ) ;
#line 116
static void fc_lport_enter_scr(struct fc_lport *lport ) ;
#line 117
static void fc_lport_enter_ready(struct fc_lport *lport ) ;
#line 118
static void fc_lport_enter_logo(struct fc_lport *lport ) ;
#line 119
static void fc_lport_enter_fdmi(struct fc_lport *lport ) ;
#line 120
static void fc_lport_enter_ms(struct fc_lport *lport , enum fc_lport_state state ) ;
#line 122 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static char const   *fc_lport_state_names[17U]  = 
#line 122
  {      "disabled",      "FLOGI",      "dNS",      "RNN_ID", 
        "RSNN_NN",      "RSPN_ID",      "RFT_ID",      "RFF_ID", 
        "FDMI",      "RHBA",      "RPA",      "DHBA", 
        "DPRT",      "SCR",      "Ready",      "LOGO", 
        "reset"};
#line 165 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static int fc_frame_drop(struct fc_lport *lport , struct fc_frame *fp ) 
{ 


  {
#line 167
  fc_frame_free(fp);
#line 168
  return (0);
}
}
#line 180 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_rport_callback(struct fc_lport *lport , struct fc_rport_priv *rdata ,
                                    enum fc_rport_event event ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 184
  tmp = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 184
  if (tmp != 0L) {
#line 184
    printk("\016host%u: lport %6.6x: Received a %d event for port (%6.6x)\n", (lport->host)->host_no,
           lport->port_id, (unsigned int )event, rdata->ids.port_id);
  } else {

  }
#line 187
  mutex_lock_nested(& lport->lp_mutex, 0U);
#line 188
  switch ((unsigned int )event) {
  case 1U: ;
#line 190
  if ((unsigned int )lport->state == 2U) {
#line 191
    lport->dns_rdata = rdata;
#line 192
    fc_lport_enter_ns(lport, 3);
  } else
#line 193
  if ((unsigned int )lport->state == 8U) {
#line 194
    lport->ms_rdata = rdata;
#line 195
    fc_lport_enter_ms(lport, 11);
  } else {
#line 197
    tmp___0 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 197
    if (tmp___0 != 0L) {
#line 197
      printk("\016host%u: lport %6.6x: Received an READY event on port (%6.6x) for the directory server, but the lport is not in the DNS or FDMI state, it\'s in the %d state",
             (lport->host)->host_no, lport->port_id, rdata->ids.port_id, (unsigned int )lport->state);
    } else {

    }
#line 203
    (*(lport->tt.rport_logoff))(rdata);
  }
#line 205
  goto ldv_41197;
  case 4U: ;
  case 2U: ;
  case 3U: ;
#line 209
  if (rdata->ids.port_id == 16777212U) {
#line 210
    lport->dns_rdata = (struct fc_rport_priv *)0;
  } else
#line 211
  if (rdata->ids.port_id == 16777210U) {
#line 212
    lport->ms_rdata = (struct fc_rport_priv *)0;
  } else {

  }
#line 213
  goto ldv_41197;
  case 0U: ;
#line 215
  goto ldv_41197;
  }
  ldv_41197: 
#line 217
  mutex_unlock(& lport->lp_mutex);
#line 218
  return;
}
}
#line 224 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static char const   *fc_lport_state(struct fc_lport *lport ) 
{ 
  char const   *cp ;

  {
#line 228
  cp = fc_lport_state_names[(unsigned int )lport->state];
#line 229
  if ((unsigned long )cp == (unsigned long )((char const   *)0)) {
#line 230
    cp = "unknown";
  } else {

  }
#line 231
  return (cp);
}
}
#line 241 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_ptp_setup(struct fc_lport *lport , u32 remote_fid , u64 remote_wwpn ,
                               u64 remote_wwnn ) 
{ 


  {
#line 245
  mutex_lock_nested(& lport->disc.disc_mutex, 0U);
#line 246
  if ((unsigned long )lport->ptp_rdata != (unsigned long )((struct fc_rport_priv *)0)) {
#line 247
    (*(lport->tt.rport_logoff))(lport->ptp_rdata);
#line 248
    kref_put(& (lport->ptp_rdata)->kref, lport->tt.rport_destroy);
  } else {

  }
#line 250
  lport->ptp_rdata = (*(lport->tt.rport_create))(lport, remote_fid);
#line 251
  kref_get(& (lport->ptp_rdata)->kref);
#line 252
  (lport->ptp_rdata)->ids.port_name = remote_wwpn;
#line 253
  (lport->ptp_rdata)->ids.node_name = remote_wwnn;
#line 254
  mutex_unlock(& lport->disc.disc_mutex);
#line 256
  (*(lport->tt.rport_login))(lport->ptp_rdata);
#line 258
  fc_lport_enter_ready(lport);
#line 259
  return;
}
}
#line 265 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
void fc_get_host_port_state(struct Scsi_Host *shost ) 
{ 
  struct fc_lport *lport ;
  void *tmp ;

  {
#line 267
  tmp = shost_priv(shost);
#line 267
  lport = (struct fc_lport *)tmp;
#line 269
  mutex_lock_nested(& lport->lp_mutex, 0U);
#line 270
  if ((unsigned int )lport->link_up == 0U) {
#line 271
    ((struct fc_host_attrs *)shost->shost_data)->port_state = 7;
  } else {
#line 273
    switch ((unsigned int )lport->state) {
    case 14U: 
#line 275
    ((struct fc_host_attrs *)shost->shost_data)->port_state = 2;
#line 276
    goto ldv_41217;
    default: 
#line 278
    ((struct fc_host_attrs *)shost->shost_data)->port_state = 3;
    }
    ldv_41217: ;
  }
#line 280
  mutex_unlock(& lport->lp_mutex);
#line 281
  return;
}
}
#line 282 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static char const   __kstrtab_fc_get_host_port_state[23U]  = 
#line 282
  {      'f',      'c',      '_',      'g', 
        'e',      't',      '_',      'h', 
        'o',      's',      't',      '_', 
        'p',      'o',      'r',      't', 
        '_',      's',      't',      'a', 
        't',      'e',      '\000'};
#line 282
struct kernel_symbol  const  __ksymtab_fc_get_host_port_state ;
#line 282 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
struct kernel_symbol  const  __ksymtab_fc_get_host_port_state  =    {(unsigned long )(& fc_get_host_port_state), (char const   *)(& __kstrtab_fc_get_host_port_state)};
#line 288 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
void fc_get_host_speed(struct Scsi_Host *shost ) 
{ 
  struct fc_lport *lport ;
  void *tmp ;

  {
#line 290
  tmp = shost_priv(shost);
#line 290
  lport = (struct fc_lport *)tmp;
#line 292
  ((struct fc_host_attrs *)shost->shost_data)->speed = (u32 )lport->link_speed;
#line 293
  return;
}
}
#line 294 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static char const   __kstrtab_fc_get_host_speed[18U]  = 
#line 294
  {      'f',      'c',      '_',      'g', 
        'e',      't',      '_',      'h', 
        'o',      's',      't',      '_', 
        's',      'p',      'e',      'e', 
        'd',      '\000'};
#line 294
struct kernel_symbol  const  __ksymtab_fc_get_host_speed ;
#line 294 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
struct kernel_symbol  const  __ksymtab_fc_get_host_speed  =    {(unsigned long )(& fc_get_host_speed), (char const   *)(& __kstrtab_fc_get_host_speed)};
#line 300 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
struct fc_host_statistics *fc_get_host_stats(struct Scsi_Host *shost ) 
{ 
  struct fc_host_statistics *fc_stats ;
  struct fc_lport *lport ;
  void *tmp ;
  struct timespec v0 ;
  struct timespec v1 ;
  unsigned int cpu ;
  u64 fcp_in_bytes ;
  u64 fcp_out_bytes ;
  struct fc_stats *stats ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;

  {
#line 303
  tmp = shost_priv(shost);
#line 303
  lport = (struct fc_lport *)tmp;
#line 306
  fcp_in_bytes = 0ULL;
#line 307
  fcp_out_bytes = 0ULL;
#line 309
  fc_stats = & lport->host_stats;
#line 310
  memset((void *)fc_stats, 0, 232UL);
#line 312
  jiffies_to_timespec(jiffies, & v0);
#line 313
  jiffies_to_timespec(lport->boot_time, & v1);
#line 314
  fc_stats->seconds_since_last_reset = (u64 )(v0.tv_sec - v1.tv_sec);
#line 316
  cpu = 4294967295U;
#line 316
  goto ldv_41253;
  ldv_41252: 
#line 319
  __vpp_verify = (void const   *)0;
#line 319
  __asm__  ("": "=r" (__ptr): "0" (lport->stats));
#line 319
  stats = (struct fc_stats *)(__per_cpu_offset[cpu] + __ptr);
#line 321
  fc_stats->tx_frames = fc_stats->tx_frames + stats->TxFrames;
#line 322
  fc_stats->tx_words = fc_stats->tx_words + stats->TxWords;
#line 323
  fc_stats->rx_frames = fc_stats->rx_frames + stats->RxFrames;
#line 324
  fc_stats->rx_words = fc_stats->rx_words + stats->RxWords;
#line 325
  fc_stats->error_frames = fc_stats->error_frames + stats->ErrorFrames;
#line 326
  fc_stats->invalid_crc_count = fc_stats->invalid_crc_count + stats->InvalidCRCCount;
#line 327
  fc_stats->fcp_input_requests = fc_stats->fcp_input_requests + stats->InputRequests;
#line 328
  fc_stats->fcp_output_requests = fc_stats->fcp_output_requests + stats->OutputRequests;
#line 329
  fc_stats->fcp_control_requests = fc_stats->fcp_control_requests + stats->ControlRequests;
#line 330
  fcp_in_bytes = stats->InputBytes + fcp_in_bytes;
#line 331
  fcp_out_bytes = stats->OutputBytes + fcp_out_bytes;
#line 332
  fc_stats->fcp_packet_alloc_failures = fc_stats->fcp_packet_alloc_failures + stats->FcpPktAllocFails;
#line 333
  fc_stats->fcp_packet_aborts = fc_stats->fcp_packet_aborts + stats->FcpPktAborts;
#line 334
  fc_stats->fcp_frame_alloc_failures = fc_stats->fcp_frame_alloc_failures + stats->FcpFrameAllocFails;
#line 335
  fc_stats->link_failure_count = fc_stats->link_failure_count + stats->LinkFailureCount;
  ldv_41253: 
#line 316
  cpu = cpumask_next((int )cpu, cpu_possible_mask);
#line 316
  if ((unsigned int )nr_cpu_ids > cpu) {
#line 318
    goto ldv_41252;
  } else {

  }
#line 337
  fc_stats->fcp_input_megabytes = div_u64(fcp_in_bytes, 1000000U);
#line 338
  fc_stats->fcp_output_megabytes = div_u64(fcp_out_bytes, 1000000U);
#line 339
  fc_stats->lip_count = 0xffffffffffffffffULL;
#line 340
  fc_stats->nos_count = 0xffffffffffffffffULL;
#line 341
  fc_stats->loss_of_sync_count = 0xffffffffffffffffULL;
#line 342
  fc_stats->loss_of_signal_count = 0xffffffffffffffffULL;
#line 343
  fc_stats->prim_seq_protocol_err_count = 0xffffffffffffffffULL;
#line 344
  fc_stats->dumped_frames = 0xffffffffffffffffULL;
#line 347
  fc_exch_update_stats(lport);
#line 349
  return (fc_stats);
}
}
#line 351 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static char const   __kstrtab_fc_get_host_stats[18U]  = 
#line 351
  {      'f',      'c',      '_',      'g', 
        'e',      't',      '_',      'h', 
        'o',      's',      't',      '_', 
        's',      't',      'a',      't', 
        's',      '\000'};
#line 351
struct kernel_symbol  const  __ksymtab_fc_get_host_stats ;
#line 351 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
struct kernel_symbol  const  __ksymtab_fc_get_host_stats  =    {(unsigned long )(& fc_get_host_stats), (char const   *)(& __kstrtab_fc_get_host_stats)};
#line 359 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_flogi_fill(struct fc_lport *lport , struct fc_els_flogi *flogi ,
                                unsigned int op ) 
{ 
  struct fc_els_csp *sp ;
  struct fc_els_cssp *cp ;
  __u16 tmp ;
  __u32 tmp___0 ;
  __u16 tmp___1 ;

  {
#line 366
  memset((void *)flogi, 0, 116UL);
#line 367
  flogi->fl_cmd = (unsigned char )op;
#line 368
  put_unaligned_be64(lport->wwpn, (void *)(& flogi->fl_wwpn));
#line 369
  put_unaligned_be64(lport->wwnn, (void *)(& flogi->fl_wwnn));
#line 370
  sp = & flogi->fl_csp;
#line 371
  sp->sp_hi_ver = 32U;
#line 372
  sp->sp_lo_ver = 32U;
#line 373
  sp->sp_bb_cred = 2560U;
#line 374
  tmp = __fswab16((int )((unsigned short )lport->mfs));
#line 374
  sp->sp_bb_data = tmp;
#line 375
  cp = (struct fc_els_cssp *)(& flogi->fl_cssp) + 2UL;
#line 376
  cp->cp_class = 136U;
#line 377
  if (op != 4U) {
#line 378
    sp->sp_features = 128U;
#line 379
    sp->sp_u.sp_plogi._sp_tot_seq = 65280U;
#line 380
    sp->sp_u.sp_plogi._sp_rel_off = 7936U;
#line 381
    tmp___0 = __fswab32(lport->e_d_tov);
#line 381
    sp->sp_e_d_tov = tmp___0;
#line 383
    tmp___1 = __fswab16((int )((unsigned short )lport->mfs));
#line 383
    cp->cp_rdfs = tmp___1;
#line 384
    cp->cp_con_seq = 65280U;
#line 385
    cp->cp_open_seq = 1U;
  } else {

  }
#line 387
  return;
}
}
#line 394 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_add_fc4_type(struct fc_lport *lport , enum fc_fh_type type ) 
{ 
  __be32 *mp ;
  __u32 tmp ;
  __u32 tmp___0 ;

  {
#line 398
  mp = (__be32 *)(& lport->fcts.ff_type_map) + (unsigned long )((unsigned int )type / 32U);
#line 399
  tmp = __fswab32(*mp);
#line 399
  tmp___0 = __fswab32(tmp | (__u32 )(1UL << ((int )type & 31)));
#line 399
  *mp = tmp___0;
#line 400
  return;
}
}
#line 410 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_recv_rlir_req(struct fc_lport *lport , struct fc_frame *fp ) 
{ 
  char const   *tmp ;
  long tmp___0 ;

  {
#line 412
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 412
  if (tmp___0 != 0L) {
#line 412
    tmp = fc_lport_state(lport);
#line 412
    printk("\016host%u: lport %6.6x: Received RLIR request while in state %s\n", (lport->host)->host_no,
           lport->port_id, tmp);
  } else {

  }
#line 415
  (*(lport->tt.seq_els_rsp_send))(fp, 2, (struct fc_seq_els_data *)0);
#line 416
  fc_frame_free(fp);
#line 417
  return;
}
}
#line 427 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_recv_echo_req(struct fc_lport *lport , struct fc_frame *in_fp ) 
{ 
  struct fc_frame *fp ;
  unsigned int len ;
  void *pp ;
  void *dp ;
  char const   *tmp ;
  long tmp___0 ;

  {
#line 435
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 435
  if (tmp___0 != 0L) {
#line 435
    tmp = fc_lport_state(lport);
#line 435
    printk("\016host%u: lport %6.6x: Received ECHO request while in state %s\n", (lport->host)->host_no,
           lport->port_id, tmp);
  } else {

  }
#line 438
  len = in_fp->skb.len - 24U;
#line 439
  pp = fc_frame_payload_get((struct fc_frame  const  *)in_fp, (size_t )len);
#line 441
  if (len <= 3U) {
#line 442
    len = 4U;
  } else {

  }
#line 444
  fp = fc_frame_alloc(lport, (size_t )len);
#line 445
  if ((unsigned long )fp != (unsigned long )((struct fc_frame *)0)) {
#line 446
    dp = fc_frame_payload_get((struct fc_frame  const  *)fp, (size_t )len);
#line 447
    memcpy(dp, (void const   *)pp, (size_t )len);
#line 448
    *((__be32 *)dp) = 2U;
#line 449
    fc_fill_reply_hdr(fp, (struct fc_frame  const  *)in_fp, 35, 0U);
#line 450
    (*(lport->tt.frame_send))(lport, fp);
  } else {

  }
#line 452
  fc_frame_free(in_fp);
#line 453
  return;
}
}
#line 463 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_recv_rnid_req(struct fc_lport *lport , struct fc_frame *in_fp ) 
{ 
  struct fc_frame *fp ;
  struct fc_els_rnid *req ;
  struct __anonstruct_rp_305 *rp ;
  struct fc_seq_els_data rjt_data ;
  u8 fmt ;
  size_t len ;
  char const   *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  __u32 tmp___2 ;
  void *tmp___3 ;
  __u64 tmp___4 ;
  __u64 tmp___5 ;

  {
#line 477
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 477
  if (tmp___0 != 0L) {
#line 477
    tmp = fc_lport_state(lport);
#line 477
    printk("\016host%u: lport %6.6x: Received RNID request while in state %s\n", (lport->host)->host_no,
           lport->port_id, tmp);
  } else {

  }
#line 480
  tmp___1 = fc_frame_payload_get((struct fc_frame  const  *)in_fp, 8UL);
#line 480
  req = (struct fc_els_rnid *)tmp___1;
#line 481
  if ((unsigned long )req == (unsigned long )((struct fc_els_rnid *)0)) {
#line 482
    rjt_data.reason = 3;
#line 483
    rjt_data.explan = 0;
#line 484
    (*(lport->tt.seq_els_rsp_send))(in_fp, 1, & rjt_data);
  } else {
#line 486
    fmt = req->rnid_fmt;
#line 487
    len = 80UL;
#line 488
    if ((unsigned int )fmt != 223U) {
#line 490
      fmt = 0U;
#line 491
      len = len - 52UL;
    } else {
#line 488
      tmp___2 = __fswab32(lport->rnid_gen.rnid_atype);
#line 488
      if (tmp___2 == 0U) {
#line 490
        fmt = 0U;
#line 491
        len = len - 52UL;
      } else {

      }
    }
#line 493
    fp = fc_frame_alloc(lport, len);
#line 494
    if ((unsigned long )fp != (unsigned long )((struct fc_frame *)0)) {
#line 495
      tmp___3 = fc_frame_payload_get((struct fc_frame  const  *)fp, len);
#line 495
      rp = (struct __anonstruct_307 *)tmp___3;
#line 496
      memset((void *)rp, 0, len);
#line 497
      rp->rnid.rnid_cmd = 2U;
#line 498
      rp->rnid.rnid_fmt = fmt;
#line 499
      rp->rnid.rnid_cid_len = 16U;
#line 500
      tmp___4 = __fswab64(lport->wwpn);
#line 500
      rp->cid.rnid_wwpn = tmp___4;
#line 501
      tmp___5 = __fswab64(lport->wwnn);
#line 501
      rp->cid.rnid_wwnn = tmp___5;
#line 502
      if ((unsigned int )fmt == 223U) {
#line 503
        rp->rnid.rnid_sid_len = 52U;
#line 504
        memcpy((void *)(& rp->gen), (void const   *)(& lport->rnid_gen), 52UL);
      } else {

      }
#line 507
      fc_fill_reply_hdr(fp, (struct fc_frame  const  *)in_fp, 35, 0U);
#line 508
      (*(lport->tt.frame_send))(lport, fp);
    } else {

    }
  }
#line 511
  fc_frame_free(in_fp);
#line 512
  return;
}
}
#line 522 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_recv_logo_req(struct fc_lport *lport , struct fc_frame *fp ) 
{ 


  {
#line 524
  (*(lport->tt.seq_els_rsp_send))(fp, 2, (struct fc_seq_els_data *)0);
#line 525
  fc_lport_enter_reset(lport);
#line 526
  fc_frame_free(fp);
#line 527
  return;
}
}
#line 536 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
int fc_fabric_login(struct fc_lport *lport ) 
{ 
  int rc ;

  {
#line 538
  rc = -1;
#line 540
  mutex_lock_nested(& lport->lp_mutex, 0U);
#line 541
  if ((unsigned int )lport->state == 0U || (unsigned int )lport->state == 15U) {
#line 543
    fc_lport_state_enter(lport, 16);
#line 544
    fc_lport_enter_reset(lport);
#line 545
    rc = 0;
  } else {

  }
#line 547
  mutex_unlock(& lport->lp_mutex);
#line 549
  return (rc);
}
}
#line 551 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static char const   __kstrtab_fc_fabric_login[16U]  = 
#line 551
  {      'f',      'c',      '_',      'f', 
        'a',      'b',      'r',      'i', 
        'c',      '_',      'l',      'o', 
        'g',      'i',      'n',      '\000'};
#line 551
struct kernel_symbol  const  __ksymtab_fc_fabric_login ;
#line 551 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
struct kernel_symbol  const  __ksymtab_fc_fabric_login  =    {(unsigned long )(& fc_fabric_login), (char const   *)(& __kstrtab_fc_fabric_login)};
#line 559 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
void __fc_linkup(struct fc_lport *lport ) 
{ 


  {
#line 561
  if ((unsigned int )lport->link_up == 0U) {
#line 562
    lport->link_up = 1U;
#line 564
    if ((unsigned int )lport->state == 16U) {
#line 565
      fc_lport_enter_flogi(lport);
    } else {

    }
  } else {

  }
#line 567
  return;
}
}
#line 573 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
void fc_linkup(struct fc_lport *lport ) 
{ 


  {
#line 575
  printk("\016host%d: libfc: Link up on port (%6.6x)\n", (lport->host)->host_no, lport->port_id);
#line 578
  mutex_lock_nested(& lport->lp_mutex, 0U);
#line 579
  __fc_linkup(lport);
#line 580
  mutex_unlock(& lport->lp_mutex);
#line 581
  return;
}
}
#line 582 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static char const   __kstrtab_fc_linkup[10U]  = 
#line 582
  {      'f',      'c',      '_',      'l', 
        'i',      'n',      'k',      'u', 
        'p',      '\000'};
#line 582
struct kernel_symbol  const  __ksymtab_fc_linkup ;
#line 582 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
struct kernel_symbol  const  __ksymtab_fc_linkup  =    {(unsigned long )(& fc_linkup), (char const   *)(& __kstrtab_fc_linkup)};
#line 590 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
void __fc_linkdown(struct fc_lport *lport ) 
{ 


  {
#line 592
  if ((unsigned int )lport->link_up != 0U) {
#line 593
    lport->link_up = 0U;
#line 594
    fc_lport_enter_reset(lport);
#line 595
    (*(lport->tt.fcp_cleanup))(lport);
  } else {

  }
#line 597
  return;
}
}
#line 603 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
void fc_linkdown(struct fc_lport *lport ) 
{ 


  {
#line 605
  printk("\016host%d: libfc: Link down on port (%6.6x)\n", (lport->host)->host_no,
         lport->port_id);
#line 608
  mutex_lock_nested(& lport->lp_mutex, 0U);
#line 609
  __fc_linkdown(lport);
#line 610
  mutex_unlock(& lport->lp_mutex);
#line 611
  return;
}
}
#line 612 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static char const   __kstrtab_fc_linkdown[12U]  = 
#line 612
  {      'f',      'c',      '_',      'l', 
        'i',      'n',      'k',      'd', 
        'o',      'w',      'n',      '\000'};
#line 612
struct kernel_symbol  const  __ksymtab_fc_linkdown ;
#line 612 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
struct kernel_symbol  const  __ksymtab_fc_linkdown  =    {(unsigned long )(& fc_linkdown), (char const   *)(& __kstrtab_fc_linkdown)};
#line 621 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
int fc_fabric_logoff(struct fc_lport *lport ) 
{ 


  {
#line 623
  (*(lport->tt.disc_stop_final))(lport);
#line 624
  mutex_lock_nested(& lport->lp_mutex, 0U);
#line 625
  if ((unsigned long )lport->dns_rdata != (unsigned long )((struct fc_rport_priv *)0)) {
#line 626
    (*(lport->tt.rport_logoff))(lport->dns_rdata);
  } else {

  }
#line 627
  mutex_unlock(& lport->lp_mutex);
#line 628
  (*(lport->tt.rport_flush_queue))();
#line 629
  mutex_lock_nested(& lport->lp_mutex, 0U);
#line 630
  fc_lport_enter_logo(lport);
#line 631
  mutex_unlock(& lport->lp_mutex);
#line 632
  ldv_cancel_delayed_work_sync_282(& lport->retry_work);
#line 633
  return (0);
}
}
#line 635 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static char const   __kstrtab_fc_fabric_logoff[17U]  = 
#line 635
  {      'f',      'c',      '_',      'f', 
        'a',      'b',      'r',      'i', 
        'c',      '_',      'l',      'o', 
        'g',      'o',      'f',      'f', 
        '\000'};
#line 635
struct kernel_symbol  const  __ksymtab_fc_fabric_logoff ;
#line 635 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
struct kernel_symbol  const  __ksymtab_fc_fabric_logoff  =    {(unsigned long )(& fc_fabric_logoff), (char const   *)(& __kstrtab_fc_fabric_logoff)};
#line 647 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
int fc_lport_destroy(struct fc_lport *lport ) 
{ 


  {
#line 649
  mutex_lock_nested(& lport->lp_mutex, 0U);
#line 650
  lport->state = 0;
#line 651
  lport->link_up = 0U;
#line 652
  lport->tt.frame_send = & fc_frame_drop;
#line 653
  mutex_unlock(& lport->lp_mutex);
#line 655
  (*(lport->tt.fcp_abort_io))(lport);
#line 656
  (*(lport->tt.disc_stop_final))(lport);
#line 657
  (*(lport->tt.exch_mgr_reset))(lport, 0U, 0U);
#line 658
  ldv_cancel_delayed_work_sync_283(& lport->retry_work);
#line 659
  fc_fc4_del_lport(lport);
#line 660
  return (0);
}
}
#line 662 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static char const   __kstrtab_fc_lport_destroy[17U]  = 
#line 662
  {      'f',      'c',      '_',      'l', 
        'p',      'o',      'r',      't', 
        '_',      'd',      'e',      's', 
        't',      'r',      'o',      'y', 
        '\000'};
#line 662
struct kernel_symbol  const  __ksymtab_fc_lport_destroy ;
#line 662 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
struct kernel_symbol  const  __ksymtab_fc_lport_destroy  =    {(unsigned long )(& fc_lport_destroy), (char const   *)(& __kstrtab_fc_lport_destroy)};
#line 669 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
int fc_set_mfs(struct fc_lport *lport , u32 mfs ) 
{ 
  unsigned int old_mfs ;
  int rc ;

  {
#line 672
  rc = -22;
#line 674
  mutex_lock_nested(& lport->lp_mutex, 0U);
#line 676
  old_mfs = lport->mfs;
#line 678
  if (mfs > 279U) {
#line 679
    mfs = mfs & 4294967292U;
#line 680
    if (mfs > 2136U) {
#line 681
      mfs = 2136U;
    } else {

    }
#line 682
    mfs = mfs - 24U;
#line 683
    lport->mfs = mfs;
#line 684
    rc = 0;
  } else {

  }
#line 687
  if (rc == 0 && mfs < old_mfs) {
#line 688
    fc_lport_enter_reset(lport);
  } else {

  }
#line 690
  mutex_unlock(& lport->lp_mutex);
#line 692
  return (rc);
}
}
#line 694 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static char const   __kstrtab_fc_set_mfs[11U]  = 
#line 694
  {      'f',      'c',      '_',      's', 
        'e',      't',      '_',      'm', 
        'f',      's',      '\000'};
#line 694
struct kernel_symbol  const  __ksymtab_fc_set_mfs ;
#line 694 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
struct kernel_symbol  const  __ksymtab_fc_set_mfs  =    {(unsigned long )(& fc_set_mfs), (char const   *)(& __kstrtab_fc_set_mfs)};
#line 701 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_disc_callback(struct fc_lport *lport , enum fc_disc_event event ) 
{ 
  long tmp ;
  int __ret_warn_on ;
  long tmp___0 ;

  {
#line 704
  switch ((unsigned int )event) {
  case 1U: 
#line 706
  tmp = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 706
  if (tmp != 0L) {
#line 706
    printk("\016host%u: lport %6.6x: Discovery succeeded\n", (lport->host)->host_no,
           lport->port_id);
  } else {

  }
#line 707
  goto ldv_41380;
  case 2U: 
#line 709
  printk("\vhost%d: libfc: Discovery failed for port (%6.6x)\n", (lport->host)->host_no,
         lport->port_id);
#line 712
  mutex_lock_nested(& lport->lp_mutex, 0U);
#line 713
  fc_lport_enter_reset(lport);
#line 714
  mutex_unlock(& lport->lp_mutex);
#line 715
  goto ldv_41380;
  case 0U: 
#line 717
  __ret_warn_on = 1;
#line 717
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 717
  if (tmp___0 != 0L) {
#line 717
    warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c",
                       717);
  } else {

  }
#line 717
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 718
  goto ldv_41380;
  }
  ldv_41380: ;
#line 721
  return;
}
}
#line 729 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_enter_ready(struct fc_lport *lport ) 
{ 
  char const   *tmp ;
  long tmp___0 ;

  {
#line 731
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 731
  if (tmp___0 != 0L) {
#line 731
    tmp = fc_lport_state(lport);
#line 731
    printk("\016host%u: lport %6.6x: Entered READY from state %s\n", (lport->host)->host_no,
           lport->port_id, tmp);
  } else {

  }
#line 734
  fc_lport_state_enter(lport, 14);
#line 735
  if ((unsigned long )lport->vport != (unsigned long )((struct fc_vport *)0)) {
#line 736
    fc_vport_set_state(lport->vport, 1);
  } else {

  }
#line 737
  fc_vports_linkchange(lport);
#line 739
  if ((unsigned long )lport->ptp_rdata == (unsigned long )((struct fc_rport_priv *)0)) {
#line 740
    (*(lport->tt.disc_start))(& fc_lport_disc_callback, lport);
  } else {

  }
#line 741
  return;
}
}
#line 752 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_set_port_id(struct fc_lport *lport , u32 port_id , struct fc_frame *fp ) 
{ 


  {
#line 755
  if (port_id != 0U) {
#line 756
    printk("\016host%d: Assigned Port ID %6.6x\n", (lport->host)->host_no, port_id);
  } else {

  }
#line 759
  lport->port_id = port_id;
#line 762
  ((struct fc_host_attrs *)(lport->host)->shost_data)->port_id = port_id;
#line 764
  if ((unsigned long )lport->tt.lport_set_port_id != (unsigned long )((void (*)(struct fc_lport * ,
                                                                                u32  ,
                                                                                struct fc_frame * ))0)) {
#line 765
    (*(lport->tt.lport_set_port_id))(lport, port_id, fp);
  } else {

  }
#line 766
  return;
}
}
#line 777 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
void fc_lport_set_local_id(struct fc_lport *lport , u32 port_id ) 
{ 


  {
#line 779
  mutex_lock_nested(& lport->lp_mutex, 0U);
#line 781
  fc_lport_set_port_id(lport, port_id, (struct fc_frame *)0);
#line 783
  switch ((unsigned int )lport->state) {
  case 16U: ;
  case 1U: ;
#line 786
  if (port_id != 0U) {
#line 787
    fc_lport_enter_ready(lport);
  } else {

  }
#line 788
  goto ldv_41399;
  default: ;
#line 790
  goto ldv_41399;
  }
  ldv_41399: 
#line 792
  mutex_unlock(& lport->lp_mutex);
#line 793
  return;
}
}
#line 794 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static char const   __kstrtab_fc_lport_set_local_id[22U]  = 
#line 794
  {      'f',      'c',      '_',      'l', 
        'p',      'o',      'r',      't', 
        '_',      's',      'e',      't', 
        '_',      'l',      'o',      'c', 
        'a',      'l',      '_',      'i', 
        'd',      '\000'};
#line 794
struct kernel_symbol  const  __ksymtab_fc_lport_set_local_id ;
#line 794 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
struct kernel_symbol  const  __ksymtab_fc_lport_set_local_id  =    {(unsigned long )(& fc_lport_set_local_id), (char const   *)(& __kstrtab_fc_lport_set_local_id)};
#line 808 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_recv_flogi_req(struct fc_lport *lport , struct fc_frame *rx_fp ) 
{ 
  struct fc_frame *fp ;
  struct fc_frame_header *fh ;
  struct fc_els_flogi *flp ;
  struct fc_els_flogi *new_flp ;
  u64 remote_wwpn ;
  u32 remote_fid ;
  u32 local_fid ;
  char const   *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  u64 tmp___4 ;

  {
#line 819
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 819
  if (tmp___0 != 0L) {
#line 819
    tmp = fc_lport_state(lport);
#line 819
    printk("\016host%u: lport %6.6x: Received FLOGI request while in state %s\n",
           (lport->host)->host_no, lport->port_id, tmp);
  } else {

  }
#line 822
  remote_fid = fc_frame_sid((struct fc_frame  const  *)rx_fp);
#line 823
  tmp___1 = fc_frame_payload_get((struct fc_frame  const  *)rx_fp, 116UL);
#line 823
  flp = (struct fc_els_flogi *)tmp___1;
#line 824
  if ((unsigned long )flp == (unsigned long )((struct fc_els_flogi *)0)) {
#line 825
    goto out;
  } else {

  }
#line 826
  remote_wwpn = get_unaligned_be64((void const   *)(& flp->fl_wwpn));
#line 827
  if (lport->wwpn == remote_wwpn) {
#line 828
    printk("\fhost%d: libfc: Received FLOGI from port with same WWPN %16.16llx\n",
           (lport->host)->host_no, remote_wwpn);
#line 831
    goto out;
  } else {

  }
#line 833
  tmp___2 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 833
  if (tmp___2 != 0L) {
#line 833
    printk("\016host%u: lport %6.6x: FLOGI from port WWPN %16.16llx\n", (lport->host)->host_no,
           lport->port_id, remote_wwpn);
  } else {

  }
#line 840
  local_fid = 65793U;
#line 841
  if (lport->wwpn > remote_wwpn) {
#line 842
    local_fid = 65794U;
#line 843
    if (remote_fid == 0U || remote_fid == local_fid) {
#line 844
      remote_fid = 65793U;
    } else {

    }
  } else
#line 845
  if (remote_fid == 0U) {
#line 846
    remote_fid = 65794U;
  } else {

  }
#line 849
  fc_lport_set_port_id(lport, local_fid, rx_fp);
#line 851
  fp = fc_frame_alloc(lport, 116UL);
#line 852
  if ((unsigned long )fp != (unsigned long )((struct fc_frame *)0)) {
#line 853
    tmp___3 = fc_frame_payload_get((struct fc_frame  const  *)fp, 116UL);
#line 853
    new_flp = (struct fc_els_flogi *)tmp___3;
#line 854
    fc_lport_flogi_fill(lport, new_flp, 4U);
#line 855
    new_flp->fl_cmd = 2U;
#line 861
    fc_fill_reply_hdr(fp, (struct fc_frame  const  *)rx_fp, 35, 0U);
#line 862
    fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 863
    hton24((u8 *)(& fh->fh_s_id), local_fid);
#line 864
    hton24((u8 *)(& fh->fh_d_id), remote_fid);
#line 865
    (*(lport->tt.frame_send))(lport, fp);
  } else {
#line 868
    fc_lport_error(lport, fp);
  }
#line 870
  tmp___4 = get_unaligned_be64((void const   *)(& flp->fl_wwnn));
#line 870
  fc_lport_ptp_setup(lport, remote_fid, remote_wwpn, tmp___4);
  out: 
#line 873
  fc_frame_free(rx_fp);
#line 874
  return;
}
}
#line 887 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_recv_els_req(struct fc_lport *lport , struct fc_frame *fp ) 
{ 
  void (*recv)(struct fc_lport * , struct fc_frame * ) ;
  u8 tmp ;
  u32 tmp___0 ;

  {
#line 892
  mutex_lock_nested(& lport->lp_mutex, 0U);
#line 899
  if ((unsigned int )lport->link_up == 0U) {
#line 900
    fc_frame_free(fp);
  } else {
#line 905
    recv = lport->tt.rport_recv_req;
#line 906
    tmp = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 906
    switch ((int )tmp) {
    case 4: ;
#line 908
    if ((unsigned int )*((unsigned char *)lport + 1144UL) == 0U) {
#line 909
      recv = & fc_lport_recv_flogi_req;
    } else {

    }
#line 910
    goto ldv_41429;
    case 5: 
#line 912
    tmp___0 = fc_frame_sid((struct fc_frame  const  *)fp);
#line 912
    if (tmp___0 == 16777214U) {
#line 913
      recv = & fc_lport_recv_logo_req;
    } else {

    }
#line 914
    goto ldv_41429;
    case 97: 
#line 916
    recv = lport->tt.disc_recv_req;
#line 917
    goto ldv_41429;
    case 16: 
#line 919
    recv = & fc_lport_recv_echo_req;
#line 920
    goto ldv_41429;
    case 121: 
#line 922
    recv = & fc_lport_recv_rlir_req;
#line 923
    goto ldv_41429;
    case 120: 
#line 925
    recv = & fc_lport_recv_rnid_req;
#line 926
    goto ldv_41429;
    }
    ldv_41429: 
#line 929
    (*recv)(lport, fp);
  }
#line 931
  mutex_unlock(& lport->lp_mutex);
#line 932
  return;
}
}
#line 934 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static int fc_lport_els_prli(struct fc_rport_priv *rdata , u32 spp_len , struct fc_els_spp  const  *spp_in ,
                             struct fc_els_spp *spp_out ) 
{ 


  {
#line 938
  return (8);
}
}
#line 941 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
struct fc4_prov fc_lport_els_prov  =    {& fc_lport_els_prli, 0, & fc_lport_recv_els_req, 0};
#line 954 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_recv_req(struct fc_lport *lport , struct fc_frame *fp ) 
{ 
  struct fc_frame_header *fh ;
  struct fc_frame_header *tmp ;
  struct fc_seq *sp ;
  struct fc4_prov *prov ;
  struct fc4_prov *________p1 ;
  struct fc4_prov *_________p1 ;
  union __anonunion___u_309 __u ;
  bool __warned ;
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 957
  tmp = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 957
  fh = tmp;
#line 958
  sp = ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_seq;
#line 969
  rcu_read_lock();
#line 970
  if ((unsigned int )fh->fh_type > 8U) {
#line 971
    goto drop;
  } else {

  }
#line 972
  __read_once_size((void const volatile   *)(& fc_passive_prov) + (unsigned long )fh->fh_type,
                   (void *)(& __u.__c), 8);
#line 972
  _________p1 = __u.__val;
#line 972
  ________p1 = _________p1;
#line 972
  tmp___0 = debug_lockdep_rcu_enabled();
#line 972
  if (tmp___0 != 0 && ! __warned) {
#line 972
    tmp___1 = rcu_read_lock_held();
#line 972
    if (tmp___1 == 0) {
#line 972
      __warned = 1;
#line 972
      lockdep_rcu_suspicious("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c",
                             972, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
#line 972
  prov = ________p1;
#line 973
  if ((unsigned long )prov == (unsigned long )((struct fc4_prov *)0)) {
#line 974
    goto drop;
  } else {
#line 973
    tmp___2 = try_module_get(prov->module);
#line 973
    if (tmp___2) {
#line 973
      tmp___3 = 0;
    } else {
#line 973
      tmp___3 = 1;
    }
#line 973
    if (tmp___3) {
#line 974
      goto drop;
    } else {

    }
  }
#line 975
  rcu_read_unlock();
#line 976
  (*(prov->recv))(lport, fp);
#line 977
  module_put(prov->module);
#line 978
  return;
  drop: 
#line 980
  rcu_read_unlock();
#line 981
  tmp___4 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 981
  if (tmp___4 != 0L) {
#line 981
    printk("\016host%u: lport %6.6x: dropping unexpected frame type %x\n", (lport->host)->host_no,
           lport->port_id, (int )fh->fh_type);
  } else {

  }
#line 982
  fc_frame_free(fp);
#line 983
  if ((unsigned long )sp != (unsigned long )((struct fc_seq *)0)) {
#line 984
    (*(lport->tt.exch_done))(sp);
  } else {

  }
#line 985
  return;
}
}
#line 994 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
int fc_lport_reset(struct fc_lport *lport ) 
{ 


  {
#line 996
  ldv_cancel_delayed_work_sync_284(& lport->retry_work);
#line 997
  mutex_lock_nested(& lport->lp_mutex, 0U);
#line 998
  fc_lport_enter_reset(lport);
#line 999
  mutex_unlock(& lport->lp_mutex);
#line 1000
  return (0);
}
}
#line 1002 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static char const   __kstrtab_fc_lport_reset[15U]  = 
#line 1002
  {      'f',      'c',      '_',      'l', 
        'p',      'o',      'r',      't', 
        '_',      'r',      'e',      's', 
        'e',      't',      '\000'};
#line 1002
struct kernel_symbol  const  __ksymtab_fc_lport_reset ;
#line 1002 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
struct kernel_symbol  const  __ksymtab_fc_lport_reset  =    {(unsigned long )(& fc_lport_reset), (char const   *)(& __kstrtab_fc_lport_reset)};
#line 1011 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_reset_locked(struct fc_lport *lport ) 
{ 


  {
#line 1013
  if ((unsigned long )lport->dns_rdata != (unsigned long )((struct fc_rport_priv *)0)) {
#line 1014
    (*(lport->tt.rport_logoff))(lport->dns_rdata);
  } else {

  }
#line 1016
  if ((unsigned long )lport->ptp_rdata != (unsigned long )((struct fc_rport_priv *)0)) {
#line 1017
    (*(lport->tt.rport_logoff))(lport->ptp_rdata);
#line 1018
    kref_put(& (lport->ptp_rdata)->kref, lport->tt.rport_destroy);
#line 1019
    lport->ptp_rdata = (struct fc_rport_priv *)0;
  } else {

  }
#line 1022
  (*(lport->tt.disc_stop))(lport);
#line 1024
  (*(lport->tt.exch_mgr_reset))(lport, 0U, 0U);
#line 1025
  ((struct fc_host_attrs *)(lport->host)->shost_data)->fabric_name = 0ULL;
#line 1027
  if (lport->port_id != 0U && ((unsigned int )*((unsigned char *)lport + 1144UL) == 0U || (unsigned int )lport->link_up == 0U)) {
#line 1028
    fc_lport_set_port_id(lport, 0U, (struct fc_frame *)0);
  } else {

  }
#line 1029
  return;
}
}
#line 1038 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_enter_reset(struct fc_lport *lport ) 
{ 
  char const   *tmp ;
  long tmp___0 ;
  u32 tmp___1 ;

  {
#line 1040
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1040
  if (tmp___0 != 0L) {
#line 1040
    tmp = fc_lport_state(lport);
#line 1040
    printk("\016host%u: lport %6.6x: Entered RESET state from %s state\n", (lport->host)->host_no,
           lport->port_id, tmp);
  } else {

  }
#line 1043
  if ((unsigned int )lport->state == 0U || (unsigned int )lport->state == 15U) {
#line 1044
    return;
  } else {

  }
#line 1046
  if ((unsigned long )lport->vport != (unsigned long )((struct fc_vport *)0)) {
#line 1047
    if ((unsigned int )lport->link_up != 0U) {
#line 1048
      fc_vport_set_state(lport->vport, 4);
    } else {
#line 1050
      fc_vport_set_state(lport->vport, 3);
    }
  } else {

  }
#line 1052
  fc_lport_state_enter(lport, 16);
#line 1053
  tmp___1 = fc_get_event_number();
#line 1053
  fc_host_post_event(lport->host, tmp___1, 4, 0U);
#line 1055
  fc_vports_linkchange(lport);
#line 1056
  fc_lport_reset_locked(lport);
#line 1057
  if ((unsigned int )lport->link_up != 0U) {
#line 1058
    fc_lport_enter_flogi(lport);
  } else {

  }
#line 1059
  return;
}
}
#line 1068 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_enter_disabled(struct fc_lport *lport ) 
{ 
  char const   *tmp ;
  long tmp___0 ;

  {
#line 1070
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1070
  if (tmp___0 != 0L) {
#line 1070
    tmp = fc_lport_state(lport);
#line 1070
    printk("\016host%u: lport %6.6x: Entered disabled state from %s state\n", (lport->host)->host_no,
           lport->port_id, tmp);
  } else {

  }
#line 1073
  fc_lport_state_enter(lport, 0);
#line 1074
  fc_vports_linkchange(lport);
#line 1075
  fc_lport_reset_locked(lport);
#line 1076
  return;
}
}
#line 1087 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_error(struct fc_lport *lport , struct fc_frame *fp ) 
{ 
  unsigned long delay ;
  char const   *tmp ;
  long tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;

  {
#line 1089
  delay = 0UL;
#line 1090
  tmp___4 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1090
  if (tmp___4 != 0L) {
#line 1090
    tmp = fc_lport_state(lport);
#line 1090
    tmp___3 = IS_ERR((void const   *)fp);
#line 1090
    if ((int )tmp___3) {
#line 1090
      tmp___1 = PTR_ERR((void const   *)fp);
#line 1090
      tmp___2 = - tmp___1;
    } else {
#line 1090
      tmp___2 = 0L;
    }
#line 1090
    printk("\016host%u: lport %6.6x: Error %ld in state %s, retries %d\n", (lport->host)->host_no,
           lport->port_id, tmp___2, tmp, (int )lport->retry_count);
  } else {

  }
#line 1094
  tmp___5 = PTR_ERR((void const   *)fp);
#line 1094
  if (tmp___5 == -2L) {
#line 1095
    return;
  } else {

  }
#line 1102
  if ((int )lport->retry_count < (int )lport->max_retry_count) {
#line 1103
    lport->retry_count = (u8 )((int )lport->retry_count + 1);
#line 1104
    if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1105
      delay = msecs_to_jiffies(500U);
    } else {
#line 1107
      delay = msecs_to_jiffies(lport->e_d_tov);
    }
#line 1109
    schedule_delayed_work___0(& lport->retry_work, delay);
  } else {
#line 1111
    fc_lport_enter_reset(lport);
  }
#line 1112
  return;
}
}
#line 1125 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_ns_resp(struct fc_seq *sp , struct fc_frame *fp , void *lp_arg ) 
{ 
  struct fc_lport *lport ;
  struct fc_frame_header *fh ;
  struct fc_ct_hdr *ct ;
  char const   *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  long tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  void *tmp___6 ;
  __u16 tmp___7 ;

  {
#line 1128
  lport = (struct fc_lport *)lp_arg;
#line 1132
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1132
  if (tmp___0 != 0L) {
#line 1132
    tmp = fc_els_resp_type(fp);
#line 1132
    printk("\016host%u: lport %6.6x: Received a ns %s\n", (lport->host)->host_no,
           lport->port_id, tmp);
  } else {

  }
#line 1134
  tmp___1 = ERR_PTR(-2L);
#line 1134
  if ((unsigned long )tmp___1 == (unsigned long )((void *)fp)) {
#line 1135
    return;
  } else {

  }
#line 1137
  mutex_lock_nested(& lport->lp_mutex, 0U);
#line 1139
  if ((unsigned int )lport->state <= 2U || (unsigned int )lport->state > 7U) {
#line 1140
    tmp___3 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1140
    if (tmp___3 != 0L) {
#line 1140
      tmp___2 = fc_lport_state(lport);
#line 1140
      printk("\016host%u: lport %6.6x: Received a name server response, but in state %s\n",
             (lport->host)->host_no, lport->port_id, tmp___2);
    } else {

    }
#line 1142
    tmp___4 = IS_ERR((void const   *)fp);
#line 1142
    if ((int )tmp___4) {
#line 1143
      goto err;
    } else {

    }
#line 1144
    goto out;
  } else {

  }
#line 1147
  tmp___5 = IS_ERR((void const   *)fp);
#line 1147
  if ((int )tmp___5) {
#line 1148
    fc_lport_error(lport, fp);
#line 1149
    goto err;
  } else {

  }
#line 1152
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 1153
  tmp___6 = fc_frame_payload_get((struct fc_frame  const  *)fp, 16UL);
#line 1153
  ct = (struct fc_ct_hdr *)tmp___6;
#line 1155
  if (((((unsigned long )fh != (unsigned long )((struct fc_frame_header *)0) && (unsigned long )ct != (unsigned long )((struct fc_ct_hdr *)0)) && (unsigned int )fh->fh_type == 32U) && (unsigned int )ct->ct_fs_type == 252U) && (unsigned int )ct->ct_fs_subtype == 2U) {
#line 1155
    tmp___7 = __fswab16((int )ct->ct_cmd);
#line 1155
    if ((unsigned int )tmp___7 == 32770U) {
#line 1159
      switch ((unsigned int )lport->state) {
      case 3U: 
#line 1161
      fc_lport_enter_ns(lport, 4);
#line 1162
      goto ldv_41495;
      case 4U: 
#line 1164
      fc_lport_enter_ns(lport, 5);
#line 1165
      goto ldv_41495;
      case 5U: 
#line 1167
      fc_lport_enter_ns(lport, 6);
#line 1168
      goto ldv_41495;
      case 6U: 
#line 1170
      fc_lport_enter_ns(lport, 7);
#line 1171
      goto ldv_41495;
      case 7U: ;
#line 1173
      if ((unsigned int )*((unsigned char *)lport + 1144UL) != 0U) {
#line 1174
        fc_lport_enter_fdmi(lport);
      } else {
#line 1176
        fc_lport_enter_scr(lport);
      }
#line 1177
      goto ldv_41495;
      default: ;
#line 1180
      goto ldv_41495;
      }
      ldv_41495: ;
    } else {
#line 1183
      fc_lport_error(lport, fp);
    }
  } else {
#line 1183
    fc_lport_error(lport, fp);
  }
  out: 
#line 1185
  fc_frame_free(fp);
  err: 
#line 1187
  mutex_unlock(& lport->lp_mutex);
#line 1188
  return;
}
}
#line 1201 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_ms_resp(struct fc_seq *sp , struct fc_frame *fp , void *lp_arg ) 
{ 
  struct fc_lport *lport ;
  struct fc_frame_header *fh ;
  struct fc_ct_hdr *ct ;
  char const   *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  long tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  void *tmp___6 ;
  long tmp___7 ;
  __u16 tmp___8 ;

  {
#line 1204
  lport = (struct fc_lport *)lp_arg;
#line 1208
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1208
  if (tmp___0 != 0L) {
#line 1208
    tmp = fc_els_resp_type(fp);
#line 1208
    printk("\016host%u: lport %6.6x: Received a ms %s\n", (lport->host)->host_no,
           lport->port_id, tmp);
  } else {

  }
#line 1210
  tmp___1 = ERR_PTR(-2L);
#line 1210
  if ((unsigned long )tmp___1 == (unsigned long )((void *)fp)) {
#line 1211
    return;
  } else {

  }
#line 1213
  mutex_lock_nested(& lport->lp_mutex, 0U);
#line 1215
  if ((unsigned int )lport->state <= 8U || (unsigned int )lport->state > 12U) {
#line 1216
    tmp___3 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1216
    if (tmp___3 != 0L) {
#line 1216
      tmp___2 = fc_lport_state(lport);
#line 1216
      printk("\016host%u: lport %6.6x: Received a management server response, but in state %s\n",
             (lport->host)->host_no, lport->port_id, tmp___2);
    } else {

    }
#line 1218
    tmp___4 = IS_ERR((void const   *)fp);
#line 1218
    if ((int )tmp___4) {
#line 1219
      goto err;
    } else {

    }
#line 1220
    goto out;
  } else {

  }
#line 1223
  tmp___5 = IS_ERR((void const   *)fp);
#line 1223
  if ((int )tmp___5) {
#line 1224
    fc_lport_error(lport, fp);
#line 1225
    goto err;
  } else {

  }
#line 1228
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 1229
  tmp___6 = fc_frame_payload_get((struct fc_frame  const  *)fp, 16UL);
#line 1229
  ct = (struct fc_ct_hdr *)tmp___6;
#line 1231
  if (((((unsigned long )fh != (unsigned long )((struct fc_frame_header *)0) && (unsigned long )ct != (unsigned long )((struct fc_ct_hdr *)0)) && (unsigned int )fh->fh_type == 32U) && (unsigned int )ct->ct_fs_type == 250U) && (unsigned int )ct->ct_fs_subtype == 16U) {
#line 1234
    tmp___7 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1234
    if (tmp___7 != 0L) {
#line 1234
      printk("\016host%u: lport %6.6x: Received a management server response, reason=%d explain=%d\n",
             (lport->host)->host_no, lport->port_id, (int )ct->ct_reason, (int )ct->ct_explan);
    } else {

    }
#line 1239
    switch ((unsigned int )lport->state) {
    case 9U: 
#line 1241
    tmp___8 = __fswab16((int )ct->ct_cmd);
#line 1241
    if ((unsigned int )tmp___8 == 32770U) {
#line 1242
      fc_lport_enter_ms(lport, 10);
    } else {
#line 1244
      fc_lport_enter_scr(lport);
    }
#line 1245
    goto ldv_41512;
    case 10U: 
#line 1247
    fc_lport_enter_scr(lport);
#line 1248
    goto ldv_41512;
    case 12U: 
#line 1250
    fc_lport_enter_ms(lport, 9);
#line 1251
    goto ldv_41512;
    case 11U: 
#line 1253
    fc_lport_enter_ms(lport, 12);
#line 1254
    goto ldv_41512;
    default: ;
#line 1257
    goto ldv_41512;
    }
    ldv_41512: ;
  } else {
#line 1261
    fc_lport_error(lport, fp);
  }
  out: 
#line 1264
  fc_frame_free(fp);
  err: 
#line 1266
  mutex_unlock(& lport->lp_mutex);
#line 1267
  return;
}
}
#line 1279 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_scr_resp(struct fc_seq *sp , struct fc_frame *fp , void *lp_arg ) 
{ 
  struct fc_lport *lport ;
  u8 op ;
  char const   *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  long tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;

  {
#line 1282
  lport = (struct fc_lport *)lp_arg;
#line 1285
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1285
  if (tmp___0 != 0L) {
#line 1285
    tmp = fc_els_resp_type(fp);
#line 1285
    printk("\016host%u: lport %6.6x: Received a SCR %s\n", (lport->host)->host_no,
           lport->port_id, tmp);
  } else {

  }
#line 1287
  tmp___1 = ERR_PTR(-2L);
#line 1287
  if ((unsigned long )tmp___1 == (unsigned long )((void *)fp)) {
#line 1288
    return;
  } else {

  }
#line 1290
  mutex_lock_nested(& lport->lp_mutex, 0U);
#line 1292
  if ((unsigned int )lport->state != 13U) {
#line 1293
    tmp___3 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1293
    if (tmp___3 != 0L) {
#line 1293
      tmp___2 = fc_lport_state(lport);
#line 1293
      printk("\016host%u: lport %6.6x: Received a SCR response, but in state %s\n",
             (lport->host)->host_no, lport->port_id, tmp___2);
    } else {

    }
#line 1295
    tmp___4 = IS_ERR((void const   *)fp);
#line 1295
    if ((int )tmp___4) {
#line 1296
      goto err;
    } else {

    }
#line 1297
    goto out;
  } else {

  }
#line 1300
  tmp___5 = IS_ERR((void const   *)fp);
#line 1300
  if ((int )tmp___5) {
#line 1301
    fc_lport_error(lport, fp);
#line 1302
    goto err;
  } else {

  }
#line 1305
  op = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 1306
  if ((unsigned int )op == 2U) {
#line 1307
    fc_lport_enter_ready(lport);
  } else {
#line 1309
    fc_lport_error(lport, fp);
  }
  out: 
#line 1312
  fc_frame_free(fp);
  err: 
#line 1314
  mutex_unlock(& lport->lp_mutex);
#line 1315
  return;
}
}
#line 1324 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_enter_scr(struct fc_lport *lport ) 
{ 
  struct fc_frame *fp ;
  char const   *tmp ;
  long tmp___0 ;
  struct fc_seq *tmp___1 ;

  {
#line 1328
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1328
  if (tmp___0 != 0L) {
#line 1328
    tmp = fc_lport_state(lport);
#line 1328
    printk("\016host%u: lport %6.6x: Entered SCR state from %s state\n", (lport->host)->host_no,
           lport->port_id, tmp);
  } else {

  }
#line 1331
  fc_lport_state_enter(lport, 13);
#line 1333
  fp = fc_frame_alloc(lport, 8UL);
#line 1334
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1335
    fc_lport_error(lport, fp);
#line 1336
    return;
  } else {

  }
#line 1339
  tmp___1 = (*(lport->tt.elsct_send))(lport, 16777213U, fp, 98U, & fc_lport_scr_resp,
                                      (void *)lport, lport->r_a_tov * 2U);
#line 1339
  if ((unsigned long )tmp___1 == (unsigned long )((struct fc_seq *)0)) {
#line 1342
    fc_lport_error(lport, (struct fc_frame *)0);
  } else {

  }
#line 1343
  return;
}
}
#line 1352 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_enter_ns(struct fc_lport *lport , enum fc_lport_state state ) 
{ 
  struct fc_frame *fp ;
  enum fc_ns_req cmd ;
  int size ;
  size_t len ;
  char const   *tmp ;
  long tmp___0 ;
  struct fc_seq *tmp___1 ;

  {
#line 1356
  size = 16;
#line 1359
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1359
  if (tmp___0 != 0L) {
#line 1359
    tmp = fc_lport_state(lport);
#line 1359
    printk("\016host%u: lport %6.6x: Entered %s state from %s state\n", (lport->host)->host_no,
           lport->port_id, fc_lport_state_names[(unsigned int )state], tmp);
  } else {

  }
#line 1363
  fc_lport_state_enter(lport, state);
#line 1365
  switch ((unsigned int )state) {
  case 3U: 
#line 1367
  cmd = 531;
#line 1368
  size = (int )((unsigned int )size + 12U);
#line 1369
  goto ldv_41539;
  case 4U: 
#line 1371
  len = strnlen((char const   *)(& ((struct fc_host_attrs *)(lport->host)->shost_data)->symbolic_name),
                255UL);
#line 1373
  if (len == 0UL) {
#line 1374
    return;
  } else {

  }
#line 1375
  cmd = 569;
#line 1376
  size = (int )(((unsigned int )len + (unsigned int )size) + 9U);
#line 1377
  goto ldv_41539;
  case 5U: 
#line 1379
  len = strnlen((char const   *)(& ((struct fc_host_attrs *)(lport->host)->shost_data)->symbolic_name),
                255UL);
#line 1381
  if (len == 0UL) {
#line 1382
    return;
  } else {

  }
#line 1383
  cmd = 536;
#line 1384
  size = (int )(((unsigned int )len + (unsigned int )size) + 5U);
#line 1385
  goto ldv_41539;
  case 6U: 
#line 1387
  cmd = 535;
#line 1388
  size = (int )((unsigned int )size + 36U);
#line 1389
  goto ldv_41539;
  case 7U: 
#line 1391
  cmd = 543;
#line 1392
  size = (int )((unsigned int )size + 8U);
#line 1393
  goto ldv_41539;
  default: 
#line 1395
  fc_lport_error(lport, (struct fc_frame *)0);
#line 1396
  return;
  }
  ldv_41539: 
#line 1399
  fp = fc_frame_alloc(lport, (size_t )size);
#line 1400
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1401
    fc_lport_error(lport, fp);
#line 1402
    return;
  } else {

  }
#line 1405
  tmp___1 = (*(lport->tt.elsct_send))(lport, 16777212U, fp, (unsigned int )cmd, & fc_lport_ns_resp,
                                      (void *)lport, lport->r_a_tov * 3U);
#line 1405
  if ((unsigned long )tmp___1 == (unsigned long )((struct fc_seq *)0)) {
#line 1408
    fc_lport_error(lport, fp);
  } else {

  }
#line 1409
  return;
}
}
#line 1411 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static struct fc_rport_operations fc_lport_rport_ops  =    {& fc_lport_rport_callback};
#line 1422 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_enter_dns(struct fc_lport *lport ) 
{ 
  struct fc_rport_priv *rdata ;
  char const   *tmp ;
  long tmp___0 ;

  {
#line 1426
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1426
  if (tmp___0 != 0L) {
#line 1426
    tmp = fc_lport_state(lport);
#line 1426
    printk("\016host%u: lport %6.6x: Entered DNS state from %s state\n", (lport->host)->host_no,
           lport->port_id, tmp);
  } else {

  }
#line 1429
  fc_lport_state_enter(lport, 2);
#line 1431
  mutex_lock_nested(& lport->disc.disc_mutex, 0U);
#line 1432
  rdata = (*(lport->tt.rport_create))(lport, 16777212U);
#line 1433
  mutex_unlock(& lport->disc.disc_mutex);
#line 1434
  if ((unsigned long )rdata == (unsigned long )((struct fc_rport_priv *)0)) {
#line 1435
    goto err;
  } else {

  }
#line 1437
  rdata->ops = & fc_lport_rport_ops;
#line 1438
  (*(lport->tt.rport_login))(rdata);
#line 1439
  return;
  err: 
#line 1442
  fc_lport_error(lport, (struct fc_frame *)0);
#line 1443
  return;
}
}
#line 1452 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_enter_ms(struct fc_lport *lport , enum fc_lport_state state ) 
{ 
  struct fc_frame *fp ;
  enum fc_fdmi_req cmd ;
  int size ;
  size_t len ;
  int numattrs ;
  char const   *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  struct fc_seq *tmp___2 ;

  {
#line 1456
  size = 16;
#line 1460
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1460
  if (tmp___0 != 0L) {
#line 1460
    tmp = fc_lport_state(lport);
#line 1460
    printk("\016host%u: lport %6.6x: Entered %s state from %s state\n", (lport->host)->host_no,
           lport->port_id, fc_lport_state_names[(unsigned int )state], tmp);
  } else {

  }
#line 1464
  fc_lport_state_enter(lport, state);
#line 1466
  switch ((unsigned int )state) {
  case 9U: 
#line 1468
  cmd = 512;
#line 1470
  numattrs = 10;
#line 1471
  len = 29UL;
#line 1472
  len = len - 5UL;
#line 1473
  len = (size_t )(numattrs * 4) + len;
#line 1474
  len = len + 8UL;
#line 1475
  len = len + 64UL;
#line 1476
  len = len + 64UL;
#line 1477
  len = len + 256UL;
#line 1478
  len = len + 256UL;
#line 1479
  len = len + 256UL;
#line 1480
  len = len + 256UL;
#line 1481
  len = len + 256UL;
#line 1482
  len = len + 256UL;
#line 1483
  len = len + 256UL;
#line 1485
  size = (int )((unsigned int )len + (unsigned int )size);
#line 1486
  goto ldv_41561;
  case 10U: 
#line 1488
  cmd = 529;
#line 1490
  numattrs = 6;
#line 1491
  len = 17UL;
#line 1492
  len = len - 5UL;
#line 1493
  len = (size_t )(numattrs * 4) + len;
#line 1494
  len = len + 32UL;
#line 1495
  len = len + 4UL;
#line 1496
  len = len + 4UL;
#line 1497
  len = len + 4UL;
#line 1498
  len = len + 256UL;
#line 1499
  len = len + 256UL;
#line 1501
  size = (int )((unsigned int )len + (unsigned int )size);
#line 1502
  goto ldv_41561;
  case 12U: 
#line 1504
  cmd = 784;
#line 1505
  len = 8UL;
#line 1506
  size = (int )((unsigned int )len + (unsigned int )size);
#line 1507
  goto ldv_41561;
  case 11U: 
#line 1509
  cmd = 768;
#line 1510
  len = 8UL;
#line 1511
  size = (int )((unsigned int )len + (unsigned int )size);
#line 1512
  goto ldv_41561;
  default: 
#line 1514
  fc_lport_error(lport, (struct fc_frame *)0);
#line 1515
  return;
  }
  ldv_41561: 
#line 1518
  tmp___1 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1518
  if (tmp___1 != 0L) {
#line 1518
    printk("\016host%u: lport %6.6x: Cmd=0x%x Len %d size %d\n", (lport->host)->host_no,
           lport->port_id, (unsigned int )cmd, (int )len, size);
  } else {

  }
#line 1520
  fp = fc_frame_alloc(lport, (size_t )size);
#line 1521
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1522
    fc_lport_error(lport, fp);
#line 1523
    return;
  } else {

  }
#line 1526
  tmp___2 = (*(lport->tt.elsct_send))(lport, 16777210U, fp, (unsigned int )cmd, & fc_lport_ms_resp,
                                      (void *)lport, lport->r_a_tov * 3U);
#line 1526
  if ((unsigned long )tmp___2 == (unsigned long )((struct fc_seq *)0)) {
#line 1529
    fc_lport_error(lport, fp);
  } else {

  }
#line 1530
  return;
}
}
#line 1539 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_enter_fdmi(struct fc_lport *lport ) 
{ 
  struct fc_rport_priv *rdata ;
  char const   *tmp ;
  long tmp___0 ;

  {
#line 1543
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1543
  if (tmp___0 != 0L) {
#line 1543
    tmp = fc_lport_state(lport);
#line 1543
    printk("\016host%u: lport %6.6x: Entered FDMI state from %s state\n", (lport->host)->host_no,
           lport->port_id, tmp);
  } else {

  }
#line 1546
  fc_lport_state_enter(lport, 8);
#line 1548
  mutex_lock_nested(& lport->disc.disc_mutex, 0U);
#line 1549
  rdata = (*(lport->tt.rport_create))(lport, 16777210U);
#line 1550
  mutex_unlock(& lport->disc.disc_mutex);
#line 1551
  if ((unsigned long )rdata == (unsigned long )((struct fc_rport_priv *)0)) {
#line 1552
    goto err;
  } else {

  }
#line 1554
  rdata->ops = & fc_lport_rport_ops;
#line 1555
  (*(lport->tt.rport_login))(rdata);
#line 1556
  return;
  err: 
#line 1559
  fc_lport_error(lport, (struct fc_frame *)0);
#line 1560
  return;
}
}
#line 1566 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_timeout(struct work_struct *work ) 
{ 
  struct fc_lport *lport ;
  struct work_struct  const  *__mptr ;
  char const   *tmp ;
  long tmp___0 ;

  {
#line 1569
  __mptr = (struct work_struct  const  *)work;
#line 1569
  lport = (struct fc_lport *)__mptr + 0xfffffffffffffaa0UL;
#line 1572
  mutex_lock_nested(& lport->lp_mutex, 0U);
#line 1574
  switch ((unsigned int )lport->state) {
  case 0U: ;
#line 1576
  goto ldv_41578;
  case 14U: ;
#line 1578
  goto ldv_41578;
  case 16U: ;
#line 1580
  goto ldv_41578;
  case 1U: 
#line 1582
  fc_lport_enter_flogi(lport);
#line 1583
  goto ldv_41578;
  case 2U: 
#line 1585
  fc_lport_enter_dns(lport);
#line 1586
  goto ldv_41578;
  case 3U: ;
  case 4U: ;
  case 5U: ;
  case 6U: ;
  case 7U: 
#line 1592
  fc_lport_enter_ns(lport, lport->state);
#line 1593
  goto ldv_41578;
  case 8U: 
#line 1595
  fc_lport_enter_fdmi(lport);
#line 1596
  goto ldv_41578;
  case 9U: ;
  case 10U: ;
  case 11U: ;
  case 12U: 
#line 1601
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1601
  if (tmp___0 != 0L) {
#line 1601
    tmp = fc_lport_state(lport);
#line 1601
    printk("\016host%u: lport %6.6x: Skipping lport state %s to SCR\n", (lport->host)->host_no,
           lport->port_id, tmp);
  } else {

  }
  case 13U: 
#line 1605
  fc_lport_enter_scr(lport);
#line 1606
  goto ldv_41578;
  case 15U: 
#line 1608
  fc_lport_enter_logo(lport);
#line 1609
  goto ldv_41578;
  }
  ldv_41578: 
#line 1612
  mutex_unlock(& lport->lp_mutex);
#line 1613
  return;
}
}
#line 1625 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
void fc_lport_logo_resp(struct fc_seq *sp , struct fc_frame *fp , void *lp_arg ) 
{ 
  struct fc_lport *lport ;
  u8 op ;
  char const   *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  long tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;

  {
#line 1628
  lport = (struct fc_lport *)lp_arg;
#line 1631
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1631
  if (tmp___0 != 0L) {
#line 1631
    tmp = fc_els_resp_type(fp);
#line 1631
    printk("\016host%u: lport %6.6x: Received a LOGO %s\n", (lport->host)->host_no,
           lport->port_id, tmp);
  } else {

  }
#line 1633
  tmp___1 = ERR_PTR(-2L);
#line 1633
  if ((unsigned long )tmp___1 == (unsigned long )((void *)fp)) {
#line 1634
    return;
  } else {

  }
#line 1636
  mutex_lock_nested(& lport->lp_mutex, 0U);
#line 1638
  if ((unsigned int )lport->state != 15U) {
#line 1639
    tmp___3 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1639
    if (tmp___3 != 0L) {
#line 1639
      tmp___2 = fc_lport_state(lport);
#line 1639
      printk("\016host%u: lport %6.6x: Received a LOGO response, but in state %s\n",
             (lport->host)->host_no, lport->port_id, tmp___2);
    } else {

    }
#line 1641
    tmp___4 = IS_ERR((void const   *)fp);
#line 1641
    if ((int )tmp___4) {
#line 1642
      goto err;
    } else {

    }
#line 1643
    goto out;
  } else {

  }
#line 1646
  tmp___5 = IS_ERR((void const   *)fp);
#line 1646
  if ((int )tmp___5) {
#line 1647
    fc_lport_error(lport, fp);
#line 1648
    goto err;
  } else {

  }
#line 1651
  op = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 1652
  if ((unsigned int )op == 2U) {
#line 1653
    fc_lport_enter_disabled(lport);
  } else {
#line 1655
    fc_lport_error(lport, fp);
  }
  out: 
#line 1658
  fc_frame_free(fp);
  err: 
#line 1660
  mutex_unlock(& lport->lp_mutex);
#line 1661
  return;
}
}
#line 1662 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static char const   __kstrtab_fc_lport_logo_resp[19U]  = 
#line 1662
  {      'f',      'c',      '_',      'l', 
        'p',      'o',      'r',      't', 
        '_',      'l',      'o',      'g', 
        'o',      '_',      'r',      'e', 
        's',      'p',      '\000'};
#line 1662
struct kernel_symbol  const  __ksymtab_fc_lport_logo_resp ;
#line 1662 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
struct kernel_symbol  const  __ksymtab_fc_lport_logo_resp  =    {(unsigned long )(& fc_lport_logo_resp), (char const   *)(& __kstrtab_fc_lport_logo_resp)};
#line 1671 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_enter_logo(struct fc_lport *lport ) 
{ 
  struct fc_frame *fp ;
  char const   *tmp ;
  long tmp___0 ;
  struct fc_seq *tmp___1 ;

  {
#line 1676
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1676
  if (tmp___0 != 0L) {
#line 1676
    tmp = fc_lport_state(lport);
#line 1676
    printk("\016host%u: lport %6.6x: Entered LOGO state from %s state\n", (lport->host)->host_no,
           lport->port_id, tmp);
  } else {

  }
#line 1679
  fc_lport_state_enter(lport, 15);
#line 1680
  fc_vports_linkchange(lport);
#line 1682
  fp = fc_frame_alloc(lport, 16UL);
#line 1683
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1684
    fc_lport_error(lport, fp);
#line 1685
    return;
  } else {

  }
#line 1688
  tmp___1 = (*(lport->tt.elsct_send))(lport, 16777214U, fp, 5U, & fc_lport_logo_resp,
                                      (void *)lport, lport->r_a_tov * 2U);
#line 1688
  if ((unsigned long )tmp___1 == (unsigned long )((struct fc_seq *)0)) {
#line 1691
    fc_lport_error(lport, (struct fc_frame *)0);
  } else {

  }
#line 1692
  return;
}
}
#line 1704 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
void fc_lport_flogi_resp(struct fc_seq *sp , struct fc_frame *fp , void *lp_arg ) 
{ 
  struct fc_lport *lport ;
  struct fc_frame_header *fh ;
  struct fc_els_flogi *flp ;
  u32 did ;
  u16 csp_flags ;
  unsigned int r_a_tov ;
  unsigned int e_d_tov ;
  u16 mfs ;
  char const   *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  long tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  long tmp___6 ;
  u8 tmp___7 ;
  void *tmp___8 ;
  long tmp___9 ;
  __u16 tmp___10 ;
  long tmp___11 ;
  __u16 tmp___12 ;
  __u32 tmp___13 ;
  __u32 tmp___14 ;
  u64 tmp___15 ;
  u64 tmp___16 ;
  u32 tmp___17 ;

  {
#line 1707
  lport = (struct fc_lport *)lp_arg;
#line 1716
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1716
  if (tmp___0 != 0L) {
#line 1716
    tmp = fc_els_resp_type(fp);
#line 1716
    printk("\016host%u: lport %6.6x: Received a FLOGI %s\n", (lport->host)->host_no,
           lport->port_id, tmp);
  } else {

  }
#line 1718
  tmp___1 = ERR_PTR(-2L);
#line 1718
  if ((unsigned long )tmp___1 == (unsigned long )((void *)fp)) {
#line 1719
    return;
  } else {

  }
#line 1721
  mutex_lock_nested(& lport->lp_mutex, 0U);
#line 1723
  if ((unsigned int )lport->state != 1U) {
#line 1724
    tmp___3 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1724
    if (tmp___3 != 0L) {
#line 1724
      tmp___2 = fc_lport_state(lport);
#line 1724
      printk("\016host%u: lport %6.6x: Received a FLOGI response, but in state %s\n",
             (lport->host)->host_no, lport->port_id, tmp___2);
    } else {

    }
#line 1726
    tmp___4 = IS_ERR((void const   *)fp);
#line 1726
    if ((int )tmp___4) {
#line 1727
      goto err;
    } else {

    }
#line 1728
    goto out;
  } else {

  }
#line 1731
  tmp___5 = IS_ERR((void const   *)fp);
#line 1731
  if ((int )tmp___5) {
#line 1732
    fc_lport_error(lport, fp);
#line 1733
    goto err;
  } else {

  }
#line 1736
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 1737
  did = fc_frame_did((struct fc_frame  const  *)fp);
#line 1738
  if ((unsigned int )fh->fh_r_ctl != 35U || did == 0U) {
#line 1738
    goto _L;
  } else {
#line 1738
    tmp___7 = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 1738
    if ((unsigned int )tmp___7 != 2U) {
      _L: /* CIL Label */ 
#line 1740
      tmp___6 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1740
      if (tmp___6 != 0L) {
#line 1740
        printk("\016host%u: lport %6.6x: FLOGI not accepted or bad response\n", (lport->host)->host_no,
               lport->port_id);
      } else {

      }
#line 1741
      fc_lport_error(lport, fp);
#line 1742
      goto err;
    } else {

    }
  }
#line 1745
  tmp___8 = fc_frame_payload_get((struct fc_frame  const  *)fp, 116UL);
#line 1745
  flp = (struct fc_els_flogi *)tmp___8;
#line 1746
  if ((unsigned long )flp == (unsigned long )((struct fc_els_flogi *)0)) {
#line 1747
    tmp___9 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1747
    if (tmp___9 != 0L) {
#line 1747
      printk("\016host%u: lport %6.6x: FLOGI bad response\n", (lport->host)->host_no,
             lport->port_id);
    } else {

    }
#line 1748
    fc_lport_error(lport, fp);
#line 1749
    goto err;
  } else {

  }
#line 1752
  tmp___10 = __fswab16((int )flp->fl_csp.sp_bb_data);
#line 1752
  mfs = (unsigned int )tmp___10 & 4095U;
#line 1755
  if ((unsigned int )mfs <= 255U || (unsigned int )mfs > 2112U) {
#line 1756
    tmp___11 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1756
    if (tmp___11 != 0L) {
#line 1756
      printk("\016host%u: lport %6.6x: FLOGI bad mfs:%hu response, lport->mfs:%hu\n",
             (lport->host)->host_no, lport->port_id, (int )mfs, lport->mfs);
    } else {

    }
#line 1758
    fc_lport_error(lport, fp);
#line 1759
    goto err;
  } else {

  }
#line 1762
  if ((u32 )mfs <= lport->mfs) {
#line 1763
    lport->mfs = (u32 )mfs;
#line 1764
    ((struct fc_host_attrs *)(lport->host)->shost_data)->maxframe_size = (u32 )mfs;
  } else {

  }
#line 1767
  tmp___12 = __fswab16((int )flp->fl_csp.sp_features);
#line 1767
  csp_flags = tmp___12;
#line 1768
  tmp___13 = __fswab32(flp->fl_csp.sp_u.sp_flogi_acc._sp_r_a_tov);
#line 1768
  r_a_tov = tmp___13;
#line 1769
  tmp___14 = __fswab32(flp->fl_csp.sp_e_d_tov);
#line 1769
  e_d_tov = tmp___14;
#line 1770
  if (((int )csp_flags & 1024) != 0) {
#line 1771
    e_d_tov = e_d_tov / 1000000U;
  } else {

  }
#line 1773
  lport->npiv_enabled = ((int )csp_flags & 8192) != 0;
#line 1775
  if (((int )csp_flags & 4096) == 0) {
#line 1776
    if (lport->e_d_tov < e_d_tov) {
#line 1777
      lport->e_d_tov = e_d_tov;
    } else {

    }
#line 1778
    lport->r_a_tov = e_d_tov * 2U;
#line 1779
    fc_lport_set_port_id(lport, did, fp);
#line 1780
    printk("\016host%d: libfc: Port (%6.6x) entered point-to-point mode\n", (lport->host)->host_no,
           did);
#line 1784
    tmp___15 = get_unaligned_be64((void const   *)(& flp->fl_wwnn));
#line 1784
    tmp___16 = get_unaligned_be64((void const   *)(& flp->fl_wwpn));
#line 1784
    tmp___17 = fc_frame_sid((struct fc_frame  const  *)fp);
#line 1784
    fc_lport_ptp_setup(lport, tmp___17, tmp___16, tmp___15);
  } else {
#line 1790
    lport->e_d_tov = e_d_tov;
#line 1791
    lport->r_a_tov = r_a_tov;
#line 1792
    ((struct fc_host_attrs *)(lport->host)->shost_data)->fabric_name = get_unaligned_be64((void const   *)(& flp->fl_wwnn));
#line 1794
    fc_lport_set_port_id(lport, did, fp);
#line 1795
    fc_lport_enter_dns(lport);
  }
  out: 
#line 1799
  fc_frame_free(fp);
  err: 
#line 1801
  mutex_unlock(& lport->lp_mutex);
#line 1802
  return;
}
}
#line 1803 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static char const   __kstrtab_fc_lport_flogi_resp[20U]  = 
#line 1803
  {      'f',      'c',      '_',      'l', 
        'p',      'o',      'r',      't', 
        '_',      'f',      'l',      'o', 
        'g',      'i',      '_',      'r', 
        'e',      's',      'p',      '\000'};
#line 1803
struct kernel_symbol  const  __ksymtab_fc_lport_flogi_resp ;
#line 1803 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
struct kernel_symbol  const  __ksymtab_fc_lport_flogi_resp  =    {(unsigned long )(& fc_lport_flogi_resp), (char const   *)(& __kstrtab_fc_lport_flogi_resp)};
#line 1812 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_enter_flogi(struct fc_lport *lport ) 
{ 
  struct fc_frame *fp ;
  char const   *tmp ;
  long tmp___0 ;
  struct fc_seq *tmp___1 ;

  {
#line 1816
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 2U) != 0U, 0L);
#line 1816
  if (tmp___0 != 0L) {
#line 1816
    tmp = fc_lport_state(lport);
#line 1816
    printk("\016host%u: lport %6.6x: Entered FLOGI state from %s state\n", (lport->host)->host_no,
           lport->port_id, tmp);
  } else {

  }
#line 1819
  fc_lport_state_enter(lport, 1);
#line 1821
  if ((unsigned int )*((unsigned char *)lport + 1144UL) != 0U) {
#line 1822
    if (lport->port_id != 0U) {
#line 1823
      fc_lport_enter_ready(lport);
    } else {

    }
#line 1824
    return;
  } else {

  }
#line 1827
  fp = fc_frame_alloc(lport, 116UL);
#line 1828
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1829
    return;
  } else {

  }
#line 1831
  tmp___1 = (*(lport->tt.elsct_send))(lport, 16777214U, fp, (unsigned long )lport->vport != (unsigned long )((struct fc_vport *)0) ? 81U : 4U,
                                      & fc_lport_flogi_resp, (void *)lport, (unsigned long )lport->vport != (unsigned long )((struct fc_vport *)0) ? lport->r_a_tov * 2U : lport->e_d_tov);
#line 1831
  if ((unsigned long )tmp___1 == (unsigned long )((struct fc_seq *)0)) {
#line 1836
    fc_lport_error(lport, (struct fc_frame *)0);
  } else {

  }
#line 1837
  return;
}
}
#line 1843 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
int fc_lport_config(struct fc_lport *lport ) 
{ 
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;

  {
#line 1845
  __init_work(& lport->retry_work.work, 0);
#line 1845
  __constr_expr_0.counter = 137438953408L;
#line 1845
  lport->retry_work.work.data = __constr_expr_0;
#line 1845
  lockdep_init_map(& lport->retry_work.work.lockdep_map, "(&(&lport->retry_work)->work)",
                   & __key, 0);
#line 1845
  INIT_LIST_HEAD(& lport->retry_work.work.entry);
#line 1845
  lport->retry_work.work.func = & fc_lport_timeout;
#line 1845
  init_timer_key(& lport->retry_work.timer, 2097152U, "(&(&lport->retry_work)->timer)",
                 & __key___0);
#line 1845
  lport->retry_work.timer.function = & delayed_work_timer_fn;
#line 1845
  lport->retry_work.timer.data = (unsigned long )(& lport->retry_work);
#line 1846
  __mutex_init(& lport->lp_mutex, "&lport->lp_mutex", & __key___1);
#line 1848
  fc_lport_state_enter(lport, 0);
#line 1850
  fc_lport_add_fc4_type(lport, 8);
#line 1851
  fc_lport_add_fc4_type(lport, 32);
#line 1852
  fc_fc4_conf_lport_params(lport, 8);
#line 1854
  return (0);
}
}
#line 1856 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static char const   __kstrtab_fc_lport_config[16U]  = 
#line 1856
  {      'f',      'c',      '_',      'l', 
        'p',      'o',      'r',      't', 
        '_',      'c',      'o',      'n', 
        'f',      'i',      'g',      '\000'};
#line 1856
struct kernel_symbol  const  __ksymtab_fc_lport_config ;
#line 1856 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
struct kernel_symbol  const  __ksymtab_fc_lport_config  =    {(unsigned long )(& fc_lport_config), (char const   *)(& __kstrtab_fc_lport_config)};
#line 1862 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
int fc_lport_init(struct fc_lport *lport ) 
{ 


  {
#line 1864
  if ((unsigned long )lport->tt.lport_recv == (unsigned long )((void (*)(struct fc_lport * ,
                                                                         struct fc_frame * ))0)) {
#line 1865
    lport->tt.lport_recv = & fc_lport_recv_req;
  } else {

  }
#line 1867
  if ((unsigned long )lport->tt.lport_reset == (unsigned long )((int (*)(struct fc_lport * ))0)) {
#line 1868
    lport->tt.lport_reset = & fc_lport_reset;
  } else {

  }
#line 1870
  ((struct fc_host_attrs *)(lport->host)->shost_data)->port_type = 3;
#line 1871
  ((struct fc_host_attrs *)(lport->host)->shost_data)->node_name = lport->wwnn;
#line 1872
  ((struct fc_host_attrs *)(lport->host)->shost_data)->port_name = lport->wwpn;
#line 1873
  ((struct fc_host_attrs *)(lport->host)->shost_data)->supported_classes = 8U;
#line 1874
  memset((void *)(& ((struct fc_host_attrs *)(lport->host)->shost_data)->supported_fc4s),
           0, 32UL);
#line 1876
  ((struct fc_host_attrs *)(lport->host)->shost_data)->supported_fc4s[2] = 1U;
#line 1877
  ((struct fc_host_attrs *)(lport->host)->shost_data)->supported_fc4s[7] = 1U;
#line 1880
  memset((void *)(& ((struct fc_host_attrs *)(lport->host)->shost_data)->active_fc4s),
           0, 32UL);
#line 1882
  ((struct fc_host_attrs *)(lport->host)->shost_data)->active_fc4s[2] = 1U;
#line 1883
  ((struct fc_host_attrs *)(lport->host)->shost_data)->active_fc4s[7] = 1U;
#line 1884
  ((struct fc_host_attrs *)(lport->host)->shost_data)->maxframe_size = lport->mfs;
#line 1885
  ((struct fc_host_attrs *)(lport->host)->shost_data)->supported_speeds = 0U;
#line 1886
  if ((int )lport->link_supported_speeds & 1) {
#line 1887
    ((struct fc_host_attrs *)(lport->host)->shost_data)->supported_speeds = ((struct fc_host_attrs *)(lport->host)->shost_data)->supported_speeds | 1U;
  } else {

  }
#line 1888
  if (((int )lport->link_supported_speeds & 4) != 0) {
#line 1889
    ((struct fc_host_attrs *)(lport->host)->shost_data)->supported_speeds = ((struct fc_host_attrs *)(lport->host)->shost_data)->supported_speeds | 4U;
  } else {

  }
#line 1890
  fc_fc4_add_lport(lport);
#line 1892
  return (0);
}
}
#line 1894 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static char const   __kstrtab_fc_lport_init[14U]  = 
#line 1894
  {      'f',      'c',      '_',      'l', 
        'p',      'o',      'r',      't', 
        '_',      'i',      'n',      'i', 
        't',      '\000'};
#line 1894
struct kernel_symbol  const  __ksymtab_fc_lport_init ;
#line 1894 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
struct kernel_symbol  const  __ksymtab_fc_lport_init  =    {(unsigned long )(& fc_lport_init), (char const   *)(& __kstrtab_fc_lport_init)};
#line 1902 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static void fc_lport_bsg_resp(struct fc_seq *sp , struct fc_frame *fp , void *info_arg ) 
{ 
  struct fc_bsg_info *info ;
  struct fc_bsg_job *job ;
  struct fc_lport *lport ;
  struct fc_frame_header *fh ;
  size_t len ;
  void *buf ;
  long tmp ;
  bool tmp___0 ;
  unsigned short cmd ;
  __u16 tmp___1 ;
  u8 tmp___2 ;
  int tmp___3 ;
  __u16 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;

  {
#line 1905
  info = (struct fc_bsg_info *)info_arg;
#line 1906
  job = info->job;
#line 1907
  lport = info->lport;
#line 1912
  tmp___0 = IS_ERR((void const   *)fp);
#line 1912
  if ((int )tmp___0) {
#line 1913
    tmp = PTR_ERR((void const   *)fp);
#line 1913
    (job->reply)->result = tmp == -2L ? 4294967193U : 4294967186U;
#line 1915
    job->reply_len = 4U;
#line 1916
    job->state_flags = job->state_flags | 1U;
#line 1917
    (*(job->job_done))(job);
#line 1918
    kfree((void const   *)info);
#line 1919
    return;
  } else {

  }
#line 1922
  mutex_lock_nested(& lport->lp_mutex, 0U);
#line 1923
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 1924
  len = (unsigned long )fp->skb.len - 24UL;
#line 1925
  buf = fc_frame_payload_get((struct fc_frame  const  *)fp, 0UL);
#line 1927
  if ((unsigned int )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_sof == 46U) {
#line 1927
    tmp___4 = __fswab16((int )fh->fh_seq_cnt);
#line 1927
    if ((unsigned int )tmp___4 == 0U) {
#line 1929
      if ((unsigned int )info->rsp_code == 32770U) {
#line 1929
        tmp___1 = __fswab16((int )((struct fc_ct_hdr *)buf)->ct_cmd);
#line 1929
        tmp___3 = tmp___1;
      } else {
#line 1929
        tmp___2 = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 1929
        tmp___3 = (unsigned short )tmp___2;
      }
#line 1929
      cmd = tmp___3;
#line 1934
      (job->reply)->reply_data.ctels_reply.status = (int )info->rsp_code != (int )cmd;
    } else {

    }
  } else {

  }
#line 1939
  tmp___5 = fc_copy_buffer_to_sglist(buf, len, info->sg, & info->nents, & info->offset,
                                     (u32 *)0U);
#line 1939
  (job->reply)->reply_payload_rcv_len = (job->reply)->reply_payload_rcv_len + tmp___5;
#line 1943
  if ((unsigned int )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_eof == 66U) {
#line 1943
    tmp___6 = ntoh24((u8 const   *)(& fh->fh_f_ctl));
#line 1943
    if ((tmp___6 & 1572864U) == 1572864U) {
#line 1946
      if ((job->reply)->reply_payload_rcv_len > job->reply_payload.payload_len) {
#line 1948
        (job->reply)->reply_payload_rcv_len = job->reply_payload.payload_len;
      } else {

      }
#line 1950
      (job->reply)->result = 0U;
#line 1951
      job->state_flags = job->state_flags | 1U;
#line 1952
      (*(job->job_done))(job);
#line 1953
      kfree((void const   *)info);
    } else {

    }
  } else {

  }
#line 1955
  fc_frame_free(fp);
#line 1956
  mutex_unlock(& lport->lp_mutex);
#line 1957
  return;
}
}
#line 1968 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static int fc_lport_els_request(struct fc_bsg_job *job , struct fc_lport *lport ,
                                u32 did , u32 tov ) 
{ 
  struct fc_bsg_info *info ;
  struct fc_frame *fp ;
  struct fc_frame_header *fh ;
  char *pp ;
  int len ;
  void *tmp ;
  void *tmp___0 ;
  struct fc_seq *tmp___1 ;

  {
#line 1978
  fp = fc_frame_alloc(lport, (size_t )job->request_payload.payload_len);
#line 1979
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1980
    return (-12);
  } else {

  }
#line 1982
  len = (int )job->request_payload.payload_len;
#line 1983
  tmp = fc_frame_payload_get((struct fc_frame  const  *)fp, (size_t )len);
#line 1983
  pp = (char *)tmp;
#line 1985
  sg_copy_to_buffer(job->request_payload.sg_list, (unsigned int )job->request_payload.sg_cnt,
                    (void *)pp, (size_t )len);
#line 1989
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 1990
  fh->fh_r_ctl = 34U;
#line 1991
  hton24((u8 *)(& fh->fh_d_id), did);
#line 1992
  hton24((u8 *)(& fh->fh_s_id), lport->port_id);
#line 1993
  fh->fh_type = 1U;
#line 1994
  hton24((u8 *)(& fh->fh_f_ctl), 2686976U);
#line 1995
  fh->fh_cs_ctl = 0U;
#line 1996
  fh->fh_df_ctl = 0U;
#line 1997
  fh->fh_parm_offset = 0U;
#line 1999
  tmp___0 = kzalloc(48UL, 208U);
#line 1999
  info = (struct fc_bsg_info *)tmp___0;
#line 2000
  if ((unsigned long )info == (unsigned long )((struct fc_bsg_info *)0)) {
#line 2001
    fc_frame_free(fp);
#line 2002
    return (-12);
  } else {

  }
#line 2005
  info->job = job;
#line 2006
  info->lport = lport;
#line 2007
  info->rsp_code = 2U;
#line 2008
  info->nents = (u32 )job->reply_payload.sg_cnt;
#line 2009
  info->sg = job->reply_payload.sg_list;
#line 2011
  tmp___1 = (*(lport->tt.exch_seq_send))(lport, fp, & fc_lport_bsg_resp, (void (*)(struct fc_seq * ,
                                                                                   void * ))0,
                                         (void *)info, tov);
#line 2011
  if ((unsigned long )tmp___1 == (unsigned long )((struct fc_seq *)0)) {
#line 2013
    kfree((void const   *)info);
#line 2014
    return (-70);
  } else {

  }
#line 2016
  return (0);
}
}
#line 2029 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static int fc_lport_ct_request(struct fc_bsg_job *job , struct fc_lport *lport , u32 did ,
                               u32 tov ) 
{ 
  struct fc_bsg_info *info ;
  struct fc_frame *fp ;
  struct fc_frame_header *fh ;
  struct fc_ct_req *ct ;
  size_t len ;
  void *tmp ;
  void *tmp___0 ;
  struct fc_seq *tmp___1 ;

  {
#line 2038
  fp = fc_frame_alloc(lport, (unsigned long )job->request_payload.payload_len + 16UL);
#line 2040
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 2041
    return (-12);
  } else {

  }
#line 2043
  len = (size_t )job->request_payload.payload_len;
#line 2044
  tmp = fc_frame_payload_get((struct fc_frame  const  *)fp, len);
#line 2044
  ct = (struct fc_ct_req *)tmp;
#line 2046
  sg_copy_to_buffer(job->request_payload.sg_list, (unsigned int )job->request_payload.sg_cnt,
                    (void *)ct, len);
#line 2050
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 2051
  fh->fh_r_ctl = 2U;
#line 2052
  hton24((u8 *)(& fh->fh_d_id), did);
#line 2053
  hton24((u8 *)(& fh->fh_s_id), lport->port_id);
#line 2054
  fh->fh_type = 32U;
#line 2055
  hton24((u8 *)(& fh->fh_f_ctl), 2686976U);
#line 2056
  fh->fh_cs_ctl = 0U;
#line 2057
  fh->fh_df_ctl = 0U;
#line 2058
  fh->fh_parm_offset = 0U;
#line 2060
  tmp___0 = kzalloc(48UL, 208U);
#line 2060
  info = (struct fc_bsg_info *)tmp___0;
#line 2061
  if ((unsigned long )info == (unsigned long )((struct fc_bsg_info *)0)) {
#line 2062
    fc_frame_free(fp);
#line 2063
    return (-12);
  } else {

  }
#line 2066
  info->job = job;
#line 2067
  info->lport = lport;
#line 2068
  info->rsp_code = 32770U;
#line 2069
  info->nents = (u32 )job->reply_payload.sg_cnt;
#line 2070
  info->sg = job->reply_payload.sg_list;
#line 2072
  tmp___1 = (*(lport->tt.exch_seq_send))(lport, fp, & fc_lport_bsg_resp, (void (*)(struct fc_seq * ,
                                                                                   void * ))0,
                                         (void *)info, tov);
#line 2072
  if ((unsigned long )tmp___1 == (unsigned long )((struct fc_seq *)0)) {
#line 2074
    kfree((void const   *)info);
#line 2075
    return (-70);
  } else {

  }
#line 2077
  return (0);
}
}
#line 2085 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
int fc_lport_bsg_request(struct fc_bsg_job *job ) 
{ 
  struct request *rsp ;
  struct Scsi_Host *shost ;
  struct fc_lport *lport ;
  void *tmp ;
  struct fc_rport *rport ;
  struct fc_rport_priv *rdata ;
  int rc ;
  u32 did ;

  {
#line 2087
  rsp = (job->req)->next_rq;
#line 2088
  shost = job->shost;
#line 2089
  tmp = shost_priv(shost);
#line 2089
  lport = (struct fc_lport *)tmp;
#line 2092
  rc = -22;
#line 2095
  (job->reply)->reply_payload_rcv_len = 0U;
#line 2096
  if ((unsigned long )rsp != (unsigned long )((struct request *)0)) {
#line 2097
    rsp->resid_len = job->reply_payload.payload_len;
  } else {

  }
#line 2099
  mutex_lock_nested(& lport->lp_mutex, 0U);
#line 2101
  switch ((job->request)->msgcode) {
  case 1073741825U: 
#line 2103
  rport = job->rport;
#line 2104
  if ((unsigned long )rport == (unsigned long )((struct fc_rport *)0)) {
#line 2105
    goto ldv_41715;
  } else {

  }
#line 2107
  rdata = (struct fc_rport_priv *)rport->dd_data;
#line 2108
  rc = fc_lport_els_request(job, lport, rport->port_id, rdata->e_d_tov);
#line 2110
  goto ldv_41715;
  case 1073741826U: 
#line 2113
  rport = job->rport;
#line 2114
  if ((unsigned long )rport == (unsigned long )((struct fc_rport *)0)) {
#line 2115
    goto ldv_41715;
  } else {

  }
#line 2117
  rdata = (struct fc_rport_priv *)rport->dd_data;
#line 2118
  rc = fc_lport_ct_request(job, lport, rport->port_id, rdata->e_d_tov);
#line 2120
  goto ldv_41715;
  case 2147483652U: 
#line 2123
  did = ntoh24((u8 const   *)(& (job->request)->rqst_data.h_ct.port_id));
#line 2124
  if (did == 16777212U) {
#line 2125
    rdata = lport->dns_rdata;
  } else {
#line 2127
    rdata = (*(lport->tt.rport_lookup))((struct fc_lport  const  *)lport, did);
  }
#line 2129
  if ((unsigned long )rdata == (unsigned long )((struct fc_rport_priv *)0)) {
#line 2130
    goto ldv_41715;
  } else {

  }
#line 2132
  rc = fc_lport_ct_request(job, lport, did, rdata->e_d_tov);
#line 2133
  goto ldv_41715;
  case 2147483651U: 
#line 2136
  did = ntoh24((u8 const   *)(& (job->request)->rqst_data.h_els.port_id));
#line 2137
  rc = fc_lport_els_request(job, lport, did, lport->e_d_tov);
#line 2138
  goto ldv_41715;
  }
  ldv_41715: 
#line 2141
  mutex_unlock(& lport->lp_mutex);
#line 2142
  return (rc);
}
}
#line 2144 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
static char const   __kstrtab_fc_lport_bsg_request[21U]  = 
#line 2144
  {      'f',      'c',      '_',      'l', 
        'p',      'o',      'r',      't', 
        '_',      'b',      's',      'g', 
        '_',      'r',      'e',      'q', 
        'u',      'e',      's',      't', 
        '\000'};
#line 2144
struct kernel_symbol  const  __ksymtab_fc_lport_bsg_request ;
#line 2144 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.c"
struct kernel_symbol  const  __ksymtab_fc_lport_bsg_request  =    {(unsigned long )(& fc_lport_bsg_request), (char const   *)(& __kstrtab_fc_lport_bsg_request)};
#line 152 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
void work_init_3(void) 
{ 


  {
#line 153
  ldv_work_3_0 = 0;
#line 154
  ldv_work_3_1 = 0;
#line 155
  ldv_work_3_2 = 0;
#line 156
  ldv_work_3_3 = 0;
#line 157
  return;
}
}
#line 160 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
void activate_work_3(struct work_struct *work , int state ) 
{ 


  {
#line 161
  if (ldv_work_3_0 == 0) {
#line 162
    ldv_work_struct_3_0 = work;
#line 163
    ldv_work_3_0 = state;
#line 164
    return;
  } else {

  }
#line 167
  if (ldv_work_3_1 == 0) {
#line 168
    ldv_work_struct_3_1 = work;
#line 169
    ldv_work_3_1 = state;
#line 170
    return;
  } else {

  }
#line 173
  if (ldv_work_3_2 == 0) {
#line 174
    ldv_work_struct_3_2 = work;
#line 175
    ldv_work_3_2 = state;
#line 176
    return;
  } else {

  }
#line 179
  if (ldv_work_3_3 == 0) {
#line 180
    ldv_work_struct_3_3 = work;
#line 181
    ldv_work_3_3 = state;
#line 182
    return;
  } else {

  }
#line 184
  return;
}
}
#line 187 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
void call_and_disable_work_3(struct work_struct *work ) 
{ 


  {
#line 190
  if ((ldv_work_3_0 == 2 || ldv_work_3_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_0) {
#line 192
    fc_lport_timeout(work);
#line 193
    ldv_work_3_0 = 1;
#line 194
    return;
  } else {

  }
#line 196
  if ((ldv_work_3_1 == 2 || ldv_work_3_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_1) {
#line 198
    fc_lport_timeout(work);
#line 199
    ldv_work_3_1 = 1;
#line 200
    return;
  } else {

  }
#line 202
  if ((ldv_work_3_2 == 2 || ldv_work_3_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_2) {
#line 204
    fc_lport_timeout(work);
#line 205
    ldv_work_3_2 = 1;
#line 206
    return;
  } else {

  }
#line 208
  if ((ldv_work_3_3 == 2 || ldv_work_3_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_3) {
#line 210
    fc_lport_timeout(work);
#line 211
    ldv_work_3_3 = 1;
#line 212
    return;
  } else {

  }
#line 214
  return;
}
}
#line 217 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
void disable_work_3(struct work_struct *work ) 
{ 


  {
#line 219
  if ((ldv_work_3_0 == 3 || ldv_work_3_0 == 2) && (unsigned long )ldv_work_struct_3_0 == (unsigned long )work) {
#line 221
    ldv_work_3_0 = 1;
  } else {

  }
#line 223
  if ((ldv_work_3_1 == 3 || ldv_work_3_1 == 2) && (unsigned long )ldv_work_struct_3_1 == (unsigned long )work) {
#line 225
    ldv_work_3_1 = 1;
  } else {

  }
#line 227
  if ((ldv_work_3_2 == 3 || ldv_work_3_2 == 2) && (unsigned long )ldv_work_struct_3_2 == (unsigned long )work) {
#line 229
    ldv_work_3_2 = 1;
  } else {

  }
#line 231
  if ((ldv_work_3_3 == 3 || ldv_work_3_3 == 2) && (unsigned long )ldv_work_struct_3_3 == (unsigned long )work) {
#line 233
    ldv_work_3_3 = 1;
  } else {

  }
#line 234
  return;
}
}
#line 238 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
void invoke_work_3(void) 
{ 
  int tmp ;

  {
#line 240
  tmp = __VERIFIER_nondet_int();
#line 240
  switch (tmp) {
  case 0: ;
#line 242
  if (ldv_work_3_0 == 2 || ldv_work_3_0 == 3) {
#line 243
    ldv_work_3_0 = 4;
#line 244
    fc_lport_timeout(ldv_work_struct_3_0);
#line 245
    ldv_work_3_0 = 1;
  } else {

  }
#line 248
  goto ldv_41747;
  case 1: ;
#line 250
  if (ldv_work_3_1 == 2 || ldv_work_3_1 == 3) {
#line 251
    ldv_work_3_1 = 4;
#line 252
    fc_lport_timeout(ldv_work_struct_3_0);
#line 253
    ldv_work_3_1 = 1;
  } else {

  }
#line 256
  goto ldv_41747;
  case 2: ;
#line 258
  if (ldv_work_3_2 == 2 || ldv_work_3_2 == 3) {
#line 259
    ldv_work_3_2 = 4;
#line 260
    fc_lport_timeout(ldv_work_struct_3_0);
#line 261
    ldv_work_3_2 = 1;
  } else {

  }
#line 264
  goto ldv_41747;
  case 3: ;
#line 266
  if (ldv_work_3_3 == 2 || ldv_work_3_3 == 3) {
#line 267
    ldv_work_3_3 = 4;
#line 268
    fc_lport_timeout(ldv_work_struct_3_0);
#line 269
    ldv_work_3_3 = 1;
  } else {

  }
#line 272
  goto ldv_41747;
  default: 
#line 273
  ldv_stop();
  }
  ldv_41747: ;
#line 275
  return;
}
}
#line 279 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
void call_and_disable_all_3(int state ) 
{ 


  {
#line 281
  if (ldv_work_3_0 == state) {
#line 282
    call_and_disable_work_3(ldv_work_struct_3_0);
  } else {

  }
#line 283
  if (ldv_work_3_1 == state) {
#line 284
    call_and_disable_work_3(ldv_work_struct_3_1);
  } else {

  }
#line 285
  if (ldv_work_3_2 == state) {
#line 286
    call_and_disable_work_3(ldv_work_struct_3_2);
  } else {

  }
#line 287
  if (ldv_work_3_3 == state) {
#line 288
    call_and_disable_work_3(ldv_work_struct_3_3);
  } else {

  }
#line 289
  return;
}
}
#line 292 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
void ldv_main_exported_11(void) 
{ 
  struct fc_rport_priv *ldvarg2 ;
  void *tmp ;
  struct fc_lport *ldvarg0 ;
  void *tmp___0 ;
  enum fc_rport_event ldvarg1 ;
  int tmp___1 ;

  {
#line 293
  tmp = ldv_init_zalloc(608UL);
#line 293
  ldvarg2 = (struct fc_rport_priv *)tmp;
#line 294
  tmp___0 = ldv_init_zalloc(1688UL);
#line 294
  ldvarg0 = (struct fc_lport *)tmp___0;
#line 295
  ldv_memset((void *)(& ldvarg1), 0, 4UL);
#line 297
  tmp___1 = __VERIFIER_nondet_int();
#line 297
  switch (tmp___1) {
  case 0: ;
#line 300
  if (ldv_state_variable_11 == 1) {
#line 302
    fc_lport_rport_callback(ldvarg0, ldvarg2, ldvarg1);
#line 304
    ldv_state_variable_11 = 1;
  } else {

  }
#line 307
  goto ldv_41762;
  default: 
#line 308
  ldv_stop();
  }
  ldv_41762: ;
#line 312
  return;
}
}
#line 315 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
void ldv_main_exported_12(void) 
{ 
  struct fc_els_spp *ldvarg9 ;
  void *tmp ;
  u32 ldvarg12 ;
  struct fc_rport_priv *ldvarg10 ;
  void *tmp___0 ;
  struct fc_lport *ldvarg7 ;
  void *tmp___1 ;
  struct fc_els_spp *ldvarg11 ;
  void *tmp___2 ;
  struct fc_frame *ldvarg8 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
#line 316
  tmp = ldv_init_zalloc(16UL);
#line 316
  ldvarg9 = (struct fc_els_spp *)tmp;
#line 318
  tmp___0 = ldv_init_zalloc(608UL);
#line 318
  ldvarg10 = (struct fc_rport_priv *)tmp___0;
#line 319
  tmp___1 = ldv_init_zalloc(1688UL);
#line 319
  ldvarg7 = (struct fc_lport *)tmp___1;
#line 320
  tmp___2 = ldv_init_zalloc(16UL);
#line 320
  ldvarg11 = (struct fc_els_spp *)tmp___2;
#line 321
  tmp___3 = ldv_init_zalloc(232UL);
#line 321
  ldvarg8 = (struct fc_frame *)tmp___3;
#line 317
  ldv_memset((void *)(& ldvarg12), 0, 4UL);
#line 323
  tmp___4 = __VERIFIER_nondet_int();
#line 323
  switch (tmp___4) {
  case 0: ;
#line 326
  if (ldv_state_variable_12 == 1) {
#line 328
    fc_lport_els_prli(ldvarg10, ldvarg12, (struct fc_els_spp  const  *)ldvarg11, ldvarg9);
#line 330
    ldv_state_variable_12 = 1;
  } else {

  }
#line 333
  goto ldv_41774;
  case 1: ;
#line 336
  if (ldv_state_variable_12 == 1) {
#line 338
    fc_lport_recv_els_req(ldvarg7, ldvarg8);
#line 340
    ldv_state_variable_12 = 1;
  } else {

  }
#line 343
  goto ldv_41774;
  default: 
#line 344
  ldv_stop();
  }
  ldv_41774: ;
#line 348
  return;
}
}
#line 462 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
bool ldv_queue_work_on_255(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 466
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 466
  ldv_func_res = tmp;
#line 468
  activate_work_3(ldv_func_arg3, 2);
#line 470
  return (ldv_func_res);
}
}
#line 473 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
bool ldv_queue_delayed_work_on_256(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 477
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 477
  ldv_func_res = tmp;
#line 479
  activate_work_3(& ldv_func_arg3->work, 2);
#line 481
  return (ldv_func_res);
}
}
#line 484 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
bool ldv_queue_work_on_257(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  bool tmp ;

  {
#line 488
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 488
  ldv_func_res = tmp;
#line 490
  activate_work_3(ldv_func_arg3, 2);
#line 492
  return (ldv_func_res);
}
}
#line 495 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
void ldv_flush_workqueue_258(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 498
  flush_workqueue(ldv_func_arg1);
#line 500
  call_and_disable_all_3(2);
#line 501
  return;
}
}
#line 503 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
bool ldv_queue_delayed_work_on_259(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
#line 507
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 507
  ldv_func_res = tmp;
#line 509
  activate_work_3(& ldv_func_arg3->work, 2);
#line 511
  return (ldv_func_res);
}
}
#line 549 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
void *ldv_kmem_cache_alloc_265(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 552
  ldv_check_alloc_flags(flags);
#line 553
  tmp = ldv_undef_ptr();
#line 553
  return (tmp);
}
}
#line 591 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
int ldv_pskb_expand_head_271(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 594
  ldv_check_alloc_flags(flags);
#line 595
  tmp = ldv_undef_ptr();
#line 595
  return ((int )((long )tmp));
}
}
#line 605 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
struct sk_buff *ldv_skb_clone_273(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 608
  ldv_check_alloc_flags(flags);
#line 609
  tmp = ldv_undef_ptr();
#line 609
  return ((struct sk_buff *)tmp);
}
}
#line 619 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
struct sk_buff *ldv_skb_copy_275(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 622
  ldv_check_alloc_flags(flags);
#line 623
  tmp = ldv_undef_ptr();
#line 623
  return ((struct sk_buff *)tmp);
}
}
#line 626 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_276(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 629
  ldv_check_alloc_flags(flags);
#line 630
  tmp = ldv_undef_ptr();
#line 630
  return ((struct sk_buff *)tmp);
}
}
#line 633 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_277(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 636
  ldv_check_alloc_flags(flags);
#line 637
  tmp = ldv_undef_ptr();
#line 637
  return ((struct sk_buff *)tmp);
}
}
#line 640 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_278(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 643
  ldv_check_alloc_flags(flags);
#line 644
  tmp = ldv_undef_ptr();
#line 644
  return ((struct sk_buff *)tmp);
}
}
#line 647 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
int ldv_pskb_expand_head_279(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 650
  ldv_check_alloc_flags(flags);
#line 651
  tmp = ldv_undef_ptr();
#line 651
  return ((int )((long )tmp));
}
}
#line 654 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
int ldv_pskb_expand_head_280(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 657
  ldv_check_alloc_flags(flags);
#line 658
  tmp = ldv_undef_ptr();
#line 658
  return ((int )((long )tmp));
}
}
#line 661 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
struct sk_buff *ldv_skb_clone_281(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 664
  ldv_check_alloc_flags(flags);
#line 665
  tmp = ldv_undef_ptr();
#line 665
  return ((struct sk_buff *)tmp);
}
}
#line 668 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
bool ldv_cancel_delayed_work_sync_282(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  bool tmp ;

  {
#line 672
  tmp = cancel_delayed_work_sync(ldv_func_arg1);
#line 672
  ldv_func_res = tmp;
#line 674
  disable_work_3(& ldv_func_arg1->work);
#line 676
  return (ldv_func_res);
}
}
#line 679 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
bool ldv_cancel_delayed_work_sync_283(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  bool tmp ;

  {
#line 683
  tmp = cancel_delayed_work_sync(ldv_func_arg1);
#line 683
  ldv_func_res = tmp;
#line 685
  disable_work_3(& ldv_func_arg1->work);
#line 687
  return (ldv_func_res);
}
}
#line 690 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_lport.o.c.prepared"
bool ldv_cancel_delayed_work_sync_284(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  bool tmp ;

  {
#line 694
  tmp = cancel_delayed_work_sync(ldv_func_arg1);
#line 694
  ldv_func_res = tmp;
#line 696
  disable_work_3(& ldv_func_arg1->work);
#line 698
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 112 "include/linux/list.h"
extern void __list_del_entry(struct list_head * ) ;
#line 23 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) ;
#line 32
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 51 "include/linux/rcutree.h"
extern void kfree_call_rcu(struct callback_head * , void (*)(struct callback_head * ) ) ;
#line 424 "include/linux/workqueue.h"
void ldv_destroy_workqueue_336(struct workqueue_struct *ldv_func_arg1 ) ;
#line 437
bool ldv_queue_work_on_307(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 441
bool ldv_queue_work_on_309(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 447
bool ldv_queue_delayed_work_on_308(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 451
bool ldv_queue_delayed_work_on_311(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 459
void ldv_flush_workqueue_310(struct workqueue_struct *ldv_func_arg1 ) ;
#line 463
void ldv_flush_workqueue_335(struct workqueue_struct *ldv_func_arg1 ) ;
#line 479
bool ldv_cancel_delayed_work_sync_334(struct delayed_work *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_307(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 483 "include/linux/workqueue.h"
__inline static bool queue_delayed_work___2(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                            unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 487
  tmp = ldv_queue_delayed_work_on_308(8192, wq, dwork, delay);
#line 487
  return (tmp);
}
}
#line 585 "include/linux/workqueue.h"
__inline static bool schedule_delayed_work___1(struct delayed_work *dwork , unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 588
  tmp = queue_delayed_work___2(system_wq, dwork, delay);
#line 588
  return (tmp);
}
}
#line 58 "include/linux/rculist.h"
extern void __list_add_rcu(struct list_head * , struct list_head * , struct list_head * ) ;
#line 78 "include/linux/rculist.h"
__inline static void list_add_rcu(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 80
  __list_add_rcu(new, head, head->next);
#line 81
  return;
}
}
#line 129 "include/linux/rculist.h"
__inline static void list_del_rcu(struct list_head *entry ) 
{ 


  {
#line 131
  __list_del_entry(entry);
#line 132
  entry->prev = (struct list_head *)-2401263026316508672L;
#line 133
  return;
}
}
#line 293 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_317(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 585
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 101 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
void activate_work_5(struct work_struct *work , int state ) ;
#line 105
void activate_work_4(struct work_struct *work , int state ) ;
#line 107
void call_and_disable_all_5(int state ) ;
#line 122
void call_and_disable_all_4(int state ) ;
#line 124
void invoke_work_5(void) ;
#line 125
void disable_work_5(struct work_struct *work ) ;
#line 130
void disable_work_4(struct work_struct *work ) ;
#line 139
void invoke_work_4(void) ;
#line 140
void call_and_disable_work_5(struct work_struct *work ) ;
#line 144
void call_and_disable_work_4(struct work_struct *work ) ;
#line 849 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_325(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 853
struct sk_buff *ldv_skb_clone_333(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 858
struct sk_buff *ldv_skb_copy_327(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 871
int ldv_pskb_expand_head_323(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 875
int ldv_pskb_expand_head_331(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 879
int ldv_pskb_expand_head_332(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2148
struct sk_buff *ldv___netdev_alloc_skb_328(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2152
struct sk_buff *ldv___netdev_alloc_skb_329(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2156
struct sk_buff *ldv___netdev_alloc_skb_330(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 842 "include/scsi/scsi_transport_fc.h"
extern struct fc_rport *fc_remote_port_add(struct Scsi_Host * , int  , struct fc_rport_identifiers * ) ;
#line 844
extern void fc_remote_port_delete(struct fc_rport * ) ;
#line 1080 "include/scsi/libfc.h"
int fc_rport_init(struct fc_lport *lport ) ;
#line 1081
void fc_rport_terminate_io(struct fc_rport *rport ) ;
#line 1150
void fc_set_rport_loss_tmo(struct fc_rport *rport , u32 timeout ) ;
#line 656 "include/scsi/fc_encode.h"
__inline static void fc_prli_fill___0(struct fc_lport *lport , struct fc_frame *fp ) 
{ 
  struct __anonstruct_pp_301___0 *pp ;
  void *tmp ;
  __u32 tmp___0 ;

  {
#line 663
  tmp = fc_frame_payload_get((struct fc_frame  const  *)fp, 20UL);
#line 663
  pp = (struct __anonstruct_303___0 *)tmp;
#line 664
  memset((void *)pp, 0, 20UL);
#line 665
  pp->prli.prli_cmd = 32U;
#line 666
  pp->prli.prli_spp_len = 16U;
#line 667
  pp->prli.prli_len = 5120U;
#line 668
  pp->spp.spp_type = 8U;
#line 669
  pp->spp.spp_flags = 32U;
#line 670
  tmp___0 = __fswab32(lport->service_params);
#line 670
  pp->spp.spp_params = tmp___0;
#line 671
  return;
}
}
#line 62 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static struct workqueue_struct *rport_event_queue  ;
#line 64
static void fc_rport_enter_flogi(struct fc_rport_priv *rdata ) ;
#line 65
static void fc_rport_enter_plogi(struct fc_rport_priv *rdata ) ;
#line 66
static void fc_rport_enter_prli(struct fc_rport_priv *rdata ) ;
#line 67
static void fc_rport_enter_rtv(struct fc_rport_priv *rdata ) ;
#line 68
static void fc_rport_enter_ready(struct fc_rport_priv *rdata ) ;
#line 69
static void fc_rport_enter_logo(struct fc_rport_priv *rdata ) ;
#line 70
static void fc_rport_enter_adisc(struct fc_rport_priv *rdata ) ;
#line 72
static void fc_rport_recv_plogi_req(struct fc_lport *lport , struct fc_frame *rx_fp ) ;
#line 73
static void fc_rport_recv_prli_req(struct fc_rport_priv *rdata , struct fc_frame *rx_fp ) ;
#line 74
static void fc_rport_recv_prlo_req(struct fc_rport_priv *rdata , struct fc_frame *rx_fp ) ;
#line 75
static void fc_rport_recv_logo_req(struct fc_lport *lport , struct fc_frame *fp ) ;
#line 76
static void fc_rport_timeout(struct work_struct *work ) ;
#line 77
static void fc_rport_error(struct fc_rport_priv *rdata , struct fc_frame *fp ) ;
#line 78
static void fc_rport_error_retry(struct fc_rport_priv *rdata , struct fc_frame *fp ) ;
#line 79
static void fc_rport_work(struct work_struct *work ) ;
#line 81 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static char const   *fc_rport_state_names[9U]  = 
#line 81
  {      "Init",      "FLOGI",      "PLOGI_WAIT",      "PLOGI", 
        "PRLI",      "RTV",      "Ready",      "ADISC", 
        "Delete"};
#line 100 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static struct fc_rport_priv *fc_rport_lookup(struct fc_lport  const  *lport , u32 port_id ) 
{ 
  struct fc_rport_priv *rdata ;
  struct list_head *__ptr ;
  struct list_head  const  *__mptr ;
  struct list_head *________p1 ;
  struct list_head *_________p1 ;
  union __anonunion___u_305 __u ;
  int tmp ;
  struct list_head *__ptr___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head *________p1___0 ;
  struct list_head *_________p1___0 ;
  union __anonunion___u_307 __u___0 ;
  int tmp___0 ;

  {
#line 105
  __ptr = lport->disc.rports.next;
#line 105
  __read_once_size((void const volatile   *)(& __ptr), (void *)(& __u.__c), 8);
#line 105
  _________p1 = __u.__val;
#line 105
  ________p1 = _________p1;
#line 105
  tmp = debug_lockdep_rcu_enabled();
#line 105
  __mptr = (struct list_head  const  *)________p1;
#line 105
  rdata = (struct fc_rport_priv *)__mptr + 0xfffffffffffffe28UL;
#line 105
  goto ldv_41557;
  ldv_41556: ;
#line 106
  if (rdata->ids.port_id == port_id) {
#line 107
    return (rdata);
  } else {

  }
#line 105
  __ptr___0 = rdata->peers.next;
#line 105
  __read_once_size((void const volatile   *)(& __ptr___0), (void *)(& __u___0.__c),
                   8);
#line 105
  _________p1___0 = __u___0.__val;
#line 105
  ________p1___0 = _________p1___0;
#line 105
  tmp___0 = debug_lockdep_rcu_enabled();
#line 105
  __mptr___0 = (struct list_head  const  *)________p1___0;
#line 105
  rdata = (struct fc_rport_priv *)__mptr___0 + 0xfffffffffffffe28UL;
  ldv_41557: ;
#line 105
  if ((unsigned long )((struct list_head  const  *)(& rdata->peers)) != (unsigned long )(& lport->disc.rports)) {
#line 107
    goto ldv_41556;
  } else {

  }

#line 108
  return ((struct fc_rport_priv *)0);
}
}
#line 120 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static struct fc_rport_priv *fc_rport_create(struct fc_lport *lport , u32 port_id ) 
{ 
  struct fc_rport_priv *rdata ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  atomic_long_t __constr_expr_1 ;

  {
#line 125
  rdata = (*(lport->tt.rport_lookup))((struct fc_lport  const  *)lport, port_id);
#line 126
  if ((unsigned long )rdata != (unsigned long )((struct fc_rport_priv *)0)) {
#line 127
    return (rdata);
  } else {

  }
#line 129
  tmp = kzalloc((unsigned long )lport->rport_priv_size + 608UL, 208U);
#line 129
  rdata = (struct fc_rport_priv *)tmp;
#line 130
  if ((unsigned long )rdata == (unsigned long )((struct fc_rport_priv *)0)) {
#line 131
    return ((struct fc_rport_priv *)0);
  } else {

  }
#line 133
  rdata->ids.node_name = 0xffffffffffffffffULL;
#line 134
  rdata->ids.port_name = 0xffffffffffffffffULL;
#line 135
  rdata->ids.port_id = port_id;
#line 136
  rdata->ids.roles = 0U;
#line 138
  kref_init(& rdata->kref);
#line 139
  __mutex_init(& rdata->rp_mutex, "&rdata->rp_mutex", & __key);
#line 140
  rdata->local_port = lport;
#line 141
  rdata->rp_state = 0;
#line 142
  rdata->event = 0;
#line 143
  rdata->flags = 1U;
#line 144
  rdata->e_d_tov = lport->e_d_tov;
#line 145
  rdata->r_a_tov = lport->r_a_tov;
#line 146
  rdata->maxframe_size = 256U;
#line 147
  __init_work(& rdata->retry_work.work, 0);
#line 147
  __constr_expr_0.counter = 137438953408L;
#line 147
  rdata->retry_work.work.data = __constr_expr_0;
#line 147
  lockdep_init_map(& rdata->retry_work.work.lockdep_map, "(&(&rdata->retry_work)->work)",
                   & __key___0, 0);
#line 147
  INIT_LIST_HEAD(& rdata->retry_work.work.entry);
#line 147
  rdata->retry_work.work.func = & fc_rport_timeout;
#line 147
  init_timer_key(& rdata->retry_work.timer, 2097152U, "(&(&rdata->retry_work)->timer)",
                 & __key___1);
#line 147
  rdata->retry_work.timer.function = & delayed_work_timer_fn;
#line 147
  rdata->retry_work.timer.data = (unsigned long )(& rdata->retry_work);
#line 148
  __init_work(& rdata->event_work, 0);
#line 148
  __constr_expr_1.counter = 137438953408L;
#line 148
  rdata->event_work.data = __constr_expr_1;
#line 148
  lockdep_init_map(& rdata->event_work.lockdep_map, "(&rdata->event_work)", & __key___2,
                   0);
#line 148
  INIT_LIST_HEAD(& rdata->event_work.entry);
#line 148
  rdata->event_work.func = & fc_rport_work;
#line 149
  if (port_id != 16777212U) {
#line 150
    rdata->lld_event_callback = lport->tt.rport_event_callback;
#line 151
    list_add_rcu(& rdata->peers, & lport->disc.rports);
  } else {

  }
#line 153
  return (rdata);
}
}
#line 160 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_destroy(struct kref *kref ) 
{ 
  struct fc_rport_priv *rdata ;
  struct kref  const  *__mptr ;

  {
#line 164
  __mptr = (struct kref  const  *)kref;
#line 164
  rdata = (struct fc_rport_priv *)__mptr + 0xfffffffffffffff0UL;
#line 165
  kfree_call_rcu(& rdata->rcu, (void (*)(struct callback_head * ))576);
#line 166
  return;
}
}
#line 172 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static char const   *fc_rport_state(struct fc_rport_priv *rdata ) 
{ 
  char const   *cp ;

  {
#line 176
  cp = fc_rport_state_names[(unsigned int )rdata->rp_state];
#line 177
  if ((unsigned long )cp == (unsigned long )((char const   *)0)) {
#line 178
    cp = "Unknown";
  } else {

  }
#line 179
  return (cp);
}
}
#line 187 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
void fc_set_rport_loss_tmo(struct fc_rport *rport , u32 timeout ) 
{ 


  {
#line 189
  if (timeout != 0U) {
#line 190
    rport->dev_loss_tmo = timeout;
  } else {
#line 192
    rport->dev_loss_tmo = 1U;
  }
#line 193
  return;
}
}
#line 194 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static char const   __kstrtab_fc_set_rport_loss_tmo[22U]  = 
#line 194
  {      'f',      'c',      '_',      's', 
        'e',      't',      '_',      'r', 
        'p',      'o',      'r',      't', 
        '_',      'l',      'o',      's', 
        's',      '_',      't',      'm', 
        'o',      '\000'};
#line 194
struct kernel_symbol  const  __ksymtab_fc_set_rport_loss_tmo ;
#line 194 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
struct kernel_symbol  const  __ksymtab_fc_set_rport_loss_tmo  =    {(unsigned long )(& fc_set_rport_loss_tmo), (char const   *)(& __kstrtab_fc_set_rport_loss_tmo)};
#line 203 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static unsigned int fc_plogi_get_maxframe(struct fc_els_flogi *flp , unsigned int maxval ) 
{ 
  unsigned int mfs ;
  __u16 tmp ;
  __u16 tmp___0 ;

  {
#line 212
  tmp = __fswab16((int )flp->fl_csp.sp_bb_data);
#line 212
  mfs = (unsigned int )tmp & 4095U;
#line 213
  if (mfs > 255U && mfs < maxval) {
#line 214
    maxval = mfs;
  } else {

  }
#line 215
  tmp___0 = __fswab16((int )flp->fl_cssp[2].cp_rdfs);
#line 215
  mfs = (unsigned int )tmp___0;
#line 216
  if (mfs > 255U && mfs < maxval) {
#line 217
    maxval = mfs;
  } else {

  }
#line 218
  return (maxval);
}
}
#line 228 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_state_enter(struct fc_rport_priv *rdata , enum fc_rport_state new ) 
{ 


  {
#line 231
  if ((unsigned int )rdata->rp_state != (unsigned int )new) {
#line 232
    rdata->retries = 0U;
  } else {

  }
#line 233
  rdata->rp_state = new;
#line 234
  return;
}
}
#line 240 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_work(struct work_struct *work ) 
{ 
  u32 port_id ;
  struct fc_rport_priv *rdata ;
  struct work_struct  const  *__mptr ;
  struct fc_rport_libfc_priv *rpriv ;
  enum fc_rport_event event ;
  struct fc_lport *lport ;
  struct fc_rport_operations *rport_ops ;
  struct fc_rport_identifiers ids ;
  struct fc_rport *rport ;
  struct fc4_prov *prov ;
  u8 type ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;

  {
#line 244
  __mptr = (struct work_struct  const  *)work;
#line 244
  rdata = (struct fc_rport_priv *)__mptr + 0xfffffffffffffe18UL;
#line 247
  lport = rdata->local_port;
#line 254
  mutex_lock_nested(& rdata->rp_mutex, 0U);
#line 255
  event = rdata->event;
#line 256
  rport_ops = rdata->ops;
#line 257
  rport = rdata->rport;
#line 259
  tmp = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 259
  if (tmp != 0L) {
#line 259
    printk("\016host%u: rport %6.6x: work event %u\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id, (unsigned int )event);
  } else {

  }
#line 261
  switch ((unsigned int )event) {
  case 1U: 
#line 263
  ids = rdata->ids;
#line 264
  rdata->event = 0;
#line 265
  rdata->major_retries = 0U;
#line 266
  kref_get(& rdata->kref);
#line 267
  mutex_unlock(& rdata->rp_mutex);
#line 269
  if ((unsigned long )rport == (unsigned long )((struct fc_rport *)0)) {
#line 270
    rport = fc_remote_port_add(lport->host, 0, & ids);
  } else {

  }
#line 271
  if ((unsigned long )rport == (unsigned long )((struct fc_rport *)0)) {
#line 272
    tmp___0 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 272
    if (tmp___0 != 0L) {
#line 272
      printk("\016host%u: rport %6.6x: Failed to add the rport\n", ((rdata->local_port)->host)->host_no,
             rdata->ids.port_id);
    } else {

    }
#line 273
    (*(lport->tt.rport_logoff))(rdata);
#line 274
    kref_put(& rdata->kref, lport->tt.rport_destroy);
#line 275
    return;
  } else {

  }
#line 277
  mutex_lock_nested(& rdata->rp_mutex, 0U);
#line 278
  if ((unsigned long )rdata->rport != (unsigned long )((struct fc_rport *)0)) {
#line 279
    tmp___1 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 279
    if (tmp___1 != 0L) {
#line 279
      printk("\016host%u: rport %6.6x: rport already allocated\n", ((rdata->local_port)->host)->host_no,
             rdata->ids.port_id);
    } else {

    }
  } else {

  }
#line 280
  rdata->rport = rport;
#line 281
  rport->maxframe_size = (u32 )rdata->maxframe_size;
#line 282
  rport->supported_classes = rdata->supported_classes;
#line 284
  rpriv = (struct fc_rport_libfc_priv *)rport->dd_data;
#line 285
  rpriv->local_port = lport;
#line 286
  rpriv->rp_state = rdata->rp_state;
#line 287
  rpriv->flags = rdata->flags;
#line 288
  rpriv->e_d_tov = rdata->e_d_tov;
#line 289
  rpriv->r_a_tov = rdata->r_a_tov;
#line 290
  mutex_unlock(& rdata->rp_mutex);
#line 292
  if ((unsigned long )rport_ops != (unsigned long )((struct fc_rport_operations *)0) && (unsigned long )rport_ops->event_callback != (unsigned long )((void (*)(struct fc_lport * ,
                                                                                                                                                                struct fc_rport_priv * ,
                                                                                                                                                                enum fc_rport_event  ))0)) {
#line 293
    tmp___2 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 293
    if (tmp___2 != 0L) {
#line 293
      printk("\016host%u: rport %6.6x: callback ev %d\n", ((rdata->local_port)->host)->host_no,
             rdata->ids.port_id, (unsigned int )event);
    } else {

    }
#line 294
    (*(rport_ops->event_callback))(lport, rdata, event);
  } else {

  }
#line 296
  if ((unsigned long )rdata->lld_event_callback != (unsigned long )((void (*)(struct fc_lport * ,
                                                                              struct fc_rport_priv * ,
                                                                              enum fc_rport_event  ))0)) {
#line 297
    tmp___3 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 297
    if (tmp___3 != 0L) {
#line 297
      printk("\016host%u: rport %6.6x: lld callback ev %d\n", ((rdata->local_port)->host)->host_no,
             rdata->ids.port_id, (unsigned int )event);
    } else {

    }
#line 298
    (*(rdata->lld_event_callback))(lport, rdata, event);
  } else {

  }
#line 300
  kref_put(& rdata->kref, lport->tt.rport_destroy);
#line 301
  goto ldv_41618;
  case 2U: ;
  case 4U: ;
  case 3U: ;
#line 306
  if ((unsigned int )rdata->prli_count != 0U) {
#line 307
    mutex_lock_nested(& fc_prov_mutex, 0U);
#line 308
    type = 1U;
#line 308
    goto ldv_41623;
    ldv_41622: 
#line 309
    prov = fc_passive_prov[(int )type];
#line 310
    if ((unsigned long )prov != (unsigned long )((struct fc4_prov *)0) && (unsigned long )prov->prlo != (unsigned long )((void (*)(struct fc_rport_priv * ))0)) {
#line 311
      (*(prov->prlo))(rdata);
    } else {

    }
#line 308
    type = (u8 )((int )type + 1);
    ldv_41623: ;
#line 308
    if ((unsigned int )type <= 8U) {
#line 310
      goto ldv_41622;
    } else {

    }
#line 313
    mutex_unlock(& fc_prov_mutex);
  } else {

  }
#line 315
  port_id = rdata->ids.port_id;
#line 316
  mutex_unlock(& rdata->rp_mutex);
#line 318
  if ((unsigned long )rport_ops != (unsigned long )((struct fc_rport_operations *)0) && (unsigned long )rport_ops->event_callback != (unsigned long )((void (*)(struct fc_lport * ,
                                                                                                                                                                struct fc_rport_priv * ,
                                                                                                                                                                enum fc_rport_event  ))0)) {
#line 319
    tmp___4 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 319
    if (tmp___4 != 0L) {
#line 319
      printk("\016host%u: rport %6.6x: callback ev %d\n", ((rdata->local_port)->host)->host_no,
             rdata->ids.port_id, (unsigned int )event);
    } else {

    }
#line 320
    (*(rport_ops->event_callback))(lport, rdata, event);
  } else {

  }
#line 322
  if ((unsigned long )rdata->lld_event_callback != (unsigned long )((void (*)(struct fc_lport * ,
                                                                              struct fc_rport_priv * ,
                                                                              enum fc_rport_event  ))0)) {
#line 323
    tmp___5 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 323
    if (tmp___5 != 0L) {
#line 323
      printk("\016host%u: rport %6.6x: lld callback ev %d\n", ((rdata->local_port)->host)->host_no,
             rdata->ids.port_id, (unsigned int )event);
    } else {

    }
#line 324
    (*(rdata->lld_event_callback))(lport, rdata, event);
  } else {

  }
#line 326
  ldv_cancel_delayed_work_sync_334(& rdata->retry_work);
#line 331
  (*(lport->tt.exch_mgr_reset))(lport, 0U, port_id);
#line 332
  (*(lport->tt.exch_mgr_reset))(lport, port_id, 0U);
#line 334
  if ((unsigned long )rport != (unsigned long )((struct fc_rport *)0)) {
#line 335
    rpriv = (struct fc_rport_libfc_priv *)rport->dd_data;
#line 336
    rpriv->rp_state = 8;
#line 337
    mutex_lock_nested(& rdata->rp_mutex, 0U);
#line 338
    rdata->rport = (struct fc_rport *)0;
#line 339
    mutex_unlock(& rdata->rp_mutex);
#line 340
    fc_remote_port_delete(rport);
  } else {

  }
#line 343
  mutex_lock_nested(& lport->disc.disc_mutex, 0U);
#line 344
  mutex_lock_nested(& rdata->rp_mutex, 0U);
#line 345
  if ((unsigned int )rdata->rp_state == 8U) {
#line 346
    if (port_id == 16777212U) {
#line 347
      rdata->event = 0;
#line 348
      mutex_unlock(& rdata->rp_mutex);
#line 349
      kref_put(& rdata->kref, lport->tt.rport_destroy);
    } else
#line 350
    if (((int )rdata->flags & 4) != 0 && rdata->major_retries < (unsigned int )lport->max_rport_retry_count) {
#line 353
      rdata->major_retries = rdata->major_retries + 1U;
#line 354
      rdata->event = 0;
#line 355
      tmp___6 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 355
      if (tmp___6 != 0L) {
#line 355
        printk("\016host%u: rport %6.6x: work restart\n", ((rdata->local_port)->host)->host_no,
               rdata->ids.port_id);
      } else {

      }
#line 356
      fc_rport_enter_flogi(rdata);
#line 357
      mutex_unlock(& rdata->rp_mutex);
    } else {
#line 359
      tmp___7 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 359
      if (tmp___7 != 0L) {
#line 359
        printk("\016host%u: rport %6.6x: work delete\n", ((rdata->local_port)->host)->host_no,
               rdata->ids.port_id);
      } else {

      }
#line 360
      list_del_rcu(& rdata->peers);
#line 361
      mutex_unlock(& rdata->rp_mutex);
#line 362
      kref_put(& rdata->kref, lport->tt.rport_destroy);
    }
  } else {
#line 368
    rdata->event = 0;
#line 369
    if ((unsigned int )rdata->rp_state == 6U) {
#line 370
      fc_rport_enter_ready(rdata);
    } else {

    }
#line 371
    mutex_unlock(& rdata->rp_mutex);
  }
#line 373
  mutex_unlock(& lport->disc.disc_mutex);
#line 374
  goto ldv_41618;
  default: 
#line 377
  mutex_unlock(& rdata->rp_mutex);
#line 378
  goto ldv_41618;
  }
  ldv_41618: ;
#line 381
  return;
}
}
#line 394 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static int fc_rport_login(struct fc_rport_priv *rdata ) 
{ 
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 396
  mutex_lock_nested(& rdata->rp_mutex, 0U);
#line 398
  rdata->flags = (u16 )((unsigned int )rdata->flags | 4U);
#line 399
  switch ((unsigned int )rdata->rp_state) {
  case 6U: 
#line 401
  tmp = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 401
  if (tmp != 0L) {
#line 401
    printk("\016host%u: rport %6.6x: ADISC port\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id);
  } else {

  }
#line 402
  fc_rport_enter_adisc(rdata);
#line 403
  goto ldv_41630;
  case 8U: 
#line 405
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 405
  if (tmp___0 != 0L) {
#line 405
    printk("\016host%u: rport %6.6x: Restart deleted port\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id);
  } else {

  }
#line 406
  goto ldv_41630;
  default: 
#line 408
  tmp___1 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 408
  if (tmp___1 != 0L) {
#line 408
    printk("\016host%u: rport %6.6x: Login to port\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id);
  } else {

  }
#line 409
  fc_rport_enter_flogi(rdata);
#line 410
  goto ldv_41630;
  }
  ldv_41630: 
#line 412
  mutex_unlock(& rdata->rp_mutex);
#line 414
  return (0);
}
}
#line 431 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_enter_delete(struct fc_rport_priv *rdata , enum fc_rport_event event ) 
{ 
  long tmp ;

  {
#line 434
  if ((unsigned int )rdata->rp_state == 8U) {
#line 435
    return;
  } else {

  }
#line 437
  tmp = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 437
  if (tmp != 0L) {
#line 437
    printk("\016host%u: rport %6.6x: Delete port\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id);
  } else {

  }
#line 439
  fc_rport_state_enter(rdata, 8);
#line 441
  if ((unsigned int )rdata->event == 0U) {
#line 442
    queue_work(rport_event_queue, & rdata->event_work);
  } else {

  }
#line 443
  rdata->event = event;
#line 444
  return;
}
}
#line 454 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static int fc_rport_logoff(struct fc_rport_priv *rdata ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 456
  mutex_lock_nested(& rdata->rp_mutex, 0U);
#line 458
  tmp = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 458
  if (tmp != 0L) {
#line 458
    printk("\016host%u: rport %6.6x: Remove port\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id);
  } else {

  }
#line 460
  rdata->flags = (unsigned int )rdata->flags & 65531U;
#line 461
  if ((unsigned int )rdata->rp_state == 8U) {
#line 462
    tmp___0 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 462
    if (tmp___0 != 0L) {
#line 462
      printk("\016host%u: rport %6.6x: Port in Delete state, not removing\n", ((rdata->local_port)->host)->host_no,
             rdata->ids.port_id);
    } else {

    }
#line 463
    goto out;
  } else {

  }
#line 465
  fc_rport_enter_logo(rdata);
#line 471
  fc_rport_enter_delete(rdata, 3);
  out: 
#line 473
  mutex_unlock(& rdata->rp_mutex);
#line 474
  return (0);
}
}
#line 484 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_enter_ready(struct fc_rport_priv *rdata ) 
{ 
  long tmp ;

  {
#line 486
  fc_rport_state_enter(rdata, 6);
#line 488
  tmp = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 488
  if (tmp != 0L) {
#line 488
    printk("\016host%u: rport %6.6x: Port is Ready\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id);
  } else {

  }
#line 490
  if ((unsigned int )rdata->event == 0U) {
#line 491
    queue_work(rport_event_queue, & rdata->event_work);
  } else {

  }
#line 492
  rdata->event = 1;
#line 493
  return;
}
}
#line 503 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_timeout(struct work_struct *work ) 
{ 
  struct fc_rport_priv *rdata ;
  struct work_struct  const  *__mptr ;

  {
#line 506
  __mptr = (struct work_struct  const  *)work;
#line 506
  rdata = (struct fc_rport_priv *)__mptr + 0xffffffffffffff18UL;
#line 508
  mutex_lock_nested(& rdata->rp_mutex, 0U);
#line 510
  switch ((unsigned int )rdata->rp_state) {
  case 1U: 
#line 512
  fc_rport_enter_flogi(rdata);
#line 513
  goto ldv_41651;
  case 3U: 
#line 515
  fc_rport_enter_plogi(rdata);
#line 516
  goto ldv_41651;
  case 4U: 
#line 518
  fc_rport_enter_prli(rdata);
#line 519
  goto ldv_41651;
  case 5U: 
#line 521
  fc_rport_enter_rtv(rdata);
#line 522
  goto ldv_41651;
  case 7U: 
#line 524
  fc_rport_enter_adisc(rdata);
#line 525
  goto ldv_41651;
  case 2U: ;
  case 6U: ;
  case 0U: ;
  case 8U: ;
#line 530
  goto ldv_41651;
  }
  ldv_41651: 
#line 533
  mutex_unlock(& rdata->rp_mutex);
#line 534
  return;
}
}
#line 544 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_error(struct fc_rport_priv *rdata , struct fc_frame *fp ) 
{ 
  char const   *tmp ;
  long tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;
  long tmp___4 ;

  {
#line 546
  tmp___4 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 546
  if (tmp___4 != 0L) {
#line 546
    tmp = fc_rport_state(rdata);
#line 546
    tmp___3 = IS_ERR((void const   *)fp);
#line 546
    if ((int )tmp___3) {
#line 546
      tmp___1 = PTR_ERR((void const   *)fp);
#line 546
      tmp___2 = - tmp___1;
    } else {
#line 546
      tmp___2 = 0L;
    }
#line 546
    printk("\016host%u: rport %6.6x: Error %ld in state %s, retries %d\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id, tmp___2, tmp, rdata->retries);
  } else {

  }
#line 550
  switch ((unsigned int )rdata->rp_state) {
  case 1U: ;
  case 3U: 
#line 553
  rdata->flags = (unsigned int )rdata->flags & 65531U;
#line 554
  fc_rport_enter_delete(rdata, 2);
#line 555
  goto ldv_41666;
  case 5U: 
#line 557
  fc_rport_enter_ready(rdata);
#line 558
  goto ldv_41666;
  case 4U: ;
  case 7U: 
#line 561
  fc_rport_enter_logo(rdata);
#line 562
  goto ldv_41666;
  case 2U: ;
  case 8U: ;
  case 6U: ;
  case 0U: ;
#line 567
  goto ldv_41666;
  }
  ldv_41666: ;
#line 570
  return;
}
}
#line 582 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_error_retry(struct fc_rport_priv *rdata , struct fc_frame *fp ) 
{ 
  unsigned long delay ;
  unsigned long tmp ;
  long tmp___0 ;
  char const   *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 585
  tmp = msecs_to_jiffies(2000U);
#line 585
  delay = tmp;
#line 588
  tmp___0 = PTR_ERR((void const   *)fp);
#line 588
  if (tmp___0 == -2L) {
#line 589
    goto out;
  } else {

  }
#line 591
  if (rdata->retries < (unsigned int )(rdata->local_port)->max_rport_retry_count) {
#line 592
    tmp___3 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 592
    if (tmp___3 != 0L) {
#line 592
      tmp___1 = fc_rport_state(rdata);
#line 592
      tmp___2 = PTR_ERR((void const   *)fp);
#line 592
      printk("\016host%u: rport %6.6x: Error %ld in state %s, retrying\n", ((rdata->local_port)->host)->host_no,
             rdata->ids.port_id, tmp___2, tmp___1);
    } else {

    }
#line 594
    rdata->retries = rdata->retries + 1U;
#line 596
    tmp___4 = PTR_ERR((void const   *)fp);
#line 596
    if (tmp___4 == -1L) {
#line 597
      delay = 0UL;
    } else {

    }
#line 598
    schedule_delayed_work___1(& rdata->retry_work, delay);
#line 599
    return;
  } else {

  }
  out: 
#line 603
  fc_rport_error(rdata, fp);
#line 604
  return;
}
}
#line 616 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static int fc_rport_login_complete(struct fc_rport_priv *rdata , struct fc_frame *fp ) 
{ 
  struct fc_lport *lport ;
  struct fc_els_flogi *flogi ;
  unsigned int e_d_tov ;
  u16 csp_flags ;
  void *tmp ;
  __u16 tmp___0 ;
  long tmp___1 ;
  __u32 tmp___2 ;
  u8 tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 619
  lport = rdata->local_port;
#line 624
  tmp = fc_frame_payload_get((struct fc_frame  const  *)fp, 116UL);
#line 624
  flogi = (struct fc_els_flogi *)tmp;
#line 625
  if ((unsigned long )flogi == (unsigned long )((struct fc_els_flogi *)0)) {
#line 626
    return (-22);
  } else {

  }
#line 628
  tmp___0 = __fswab16((int )flogi->fl_csp.sp_features);
#line 628
  csp_flags = tmp___0;
#line 630
  tmp___3 = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 630
  if ((unsigned int )tmp___3 == 4U) {
#line 631
    if (((int )csp_flags & 4096) != 0) {
#line 632
      tmp___1 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 632
      if (tmp___1 != 0L) {
#line 632
        printk("\016host%u: rport %6.6x: Fabric bit set in FLOGI\n", ((rdata->local_port)->host)->host_no,
               rdata->ids.port_id);
      } else {

      }
#line 633
      return (-22);
    } else {

    }
  } else {
#line 640
    tmp___2 = __fswab32(flogi->fl_csp.sp_e_d_tov);
#line 640
    e_d_tov = tmp___2;
#line 641
    if (((int )csp_flags & 1024) != 0) {
#line 642
      e_d_tov = e_d_tov / 1000000U;
    } else {

    }
#line 643
    if (rdata->e_d_tov < e_d_tov) {
#line 644
      rdata->e_d_tov = e_d_tov;
    } else {

    }
  }
#line 646
  tmp___4 = fc_plogi_get_maxframe(flogi, lport->mfs);
#line 646
  rdata->maxframe_size = (u16 )tmp___4;
#line 647
  return (0);
}
}
#line 656 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_flogi_resp(struct fc_seq *sp , struct fc_frame *fp , void *rp_arg ) 
{ 
  struct fc_rport_priv *rdata ;
  struct fc_lport *lport ;
  struct fc_els_flogi *flogi ;
  unsigned int r_a_tov ;
  char const   *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  long tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  u8 tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  __u32 tmp___9 ;
  long tmp___10 ;

  {
#line 659
  rdata = (struct fc_rport_priv *)rp_arg;
#line 660
  lport = rdata->local_port;
#line 664
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 664
  if (tmp___0 != 0L) {
#line 664
    tmp = fc_els_resp_type(fp);
#line 664
    printk("\016host%u: rport %6.6x: Received a FLOGI %s\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id, tmp);
  } else {

  }
#line 666
  tmp___1 = ERR_PTR(-2L);
#line 666
  if ((unsigned long )tmp___1 == (unsigned long )((void *)fp)) {
#line 667
    goto put;
  } else {

  }
#line 669
  mutex_lock_nested(& rdata->rp_mutex, 0U);
#line 671
  if ((unsigned int )rdata->rp_state != 1U) {
#line 672
    tmp___3 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 672
    if (tmp___3 != 0L) {
#line 672
      tmp___2 = fc_rport_state(rdata);
#line 672
      printk("\016host%u: rport %6.6x: Received a FLOGI response, but in state %s\n",
             ((rdata->local_port)->host)->host_no, rdata->ids.port_id, tmp___2);
    } else {

    }
#line 674
    tmp___4 = IS_ERR((void const   *)fp);
#line 674
    if ((int )tmp___4) {
#line 675
      goto err;
    } else {

    }
#line 676
    goto out;
  } else {

  }
#line 679
  tmp___5 = IS_ERR((void const   *)fp);
#line 679
  if ((int )tmp___5) {
#line 680
    fc_rport_error(rdata, fp);
#line 681
    goto err;
  } else {

  }
#line 684
  tmp___6 = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 684
  if ((unsigned int )tmp___6 != 2U) {
#line 685
    goto bad;
  } else {

  }
#line 686
  tmp___7 = fc_rport_login_complete(rdata, fp);
#line 686
  if (tmp___7 != 0) {
#line 687
    goto bad;
  } else {

  }
#line 689
  tmp___8 = fc_frame_payload_get((struct fc_frame  const  *)fp, 116UL);
#line 689
  flogi = (struct fc_els_flogi *)tmp___8;
#line 690
  if ((unsigned long )flogi == (unsigned long )((struct fc_els_flogi *)0)) {
#line 691
    goto bad;
  } else {

  }
#line 692
  tmp___9 = __fswab32(flogi->fl_csp.sp_u.sp_flogi_acc._sp_r_a_tov);
#line 692
  r_a_tov = tmp___9;
#line 693
  if (rdata->r_a_tov < r_a_tov) {
#line 694
    rdata->r_a_tov = r_a_tov;
  } else {

  }
#line 696
  if (rdata->ids.port_name < lport->wwpn) {
#line 697
    fc_rport_enter_plogi(rdata);
  } else {
#line 699
    fc_rport_state_enter(rdata, 2);
  }
  out: 
#line 701
  fc_frame_free(fp);
  err: 
#line 703
  mutex_unlock(& rdata->rp_mutex);
  put: 
#line 705
  kref_put(& rdata->kref, (rdata->local_port)->tt.rport_destroy);
#line 706
  return;
  bad: 
#line 708
  tmp___10 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 708
  if (tmp___10 != 0L) {
#line 708
    printk("\016host%u: rport %6.6x: Bad FLOGI response\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id);
  } else {

  }
#line 709
  fc_rport_error_retry(rdata, fp);
#line 710
  goto out;
}
}
#line 720 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_enter_flogi(struct fc_rport_priv *rdata ) 
{ 
  struct fc_lport *lport ;
  struct fc_frame *fp ;
  char const   *tmp ;
  long tmp___0 ;
  struct fc_seq *tmp___1 ;

  {
#line 722
  lport = rdata->local_port;
#line 725
  if ((unsigned int )*((unsigned char *)lport + 1144UL) == 0U) {
#line 726
    return;
  } else {

  }
#line 728
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 728
  if (tmp___0 != 0L) {
#line 728
    tmp = fc_rport_state(rdata);
#line 728
    printk("\016host%u: rport %6.6x: Entered FLOGI state from %s state\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id, tmp);
  } else {

  }
#line 731
  fc_rport_state_enter(rdata, 1);
#line 733
  fp = fc_frame_alloc(lport, 116UL);
#line 734
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 735
    return;
  } else {

  }
#line 737
  tmp___1 = (*(lport->tt.elsct_send))(lport, rdata->ids.port_id, fp, 4U, & fc_rport_flogi_resp,
                                      (void *)rdata, lport->r_a_tov * 2U);
#line 737
  if ((unsigned long )tmp___1 == (unsigned long )((struct fc_seq *)0)) {
#line 740
    fc_rport_error_retry(rdata, (struct fc_frame *)0);
  } else {
#line 742
    kref_get(& rdata->kref);
  }
#line 743
  return;
}
}
#line 750 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_recv_flogi_req(struct fc_lport *lport , struct fc_frame *rx_fp ) 
{ 
  struct fc_disc *disc ;
  struct fc_els_flogi *flp ;
  struct fc_rport_priv *rdata ;
  struct fc_frame *fp ;
  struct fc_seq_els_data rjt_data ;
  u32 sid ;
  long tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;

  {
#line 756
  fp = rx_fp;
#line 760
  sid = fc_frame_sid((struct fc_frame  const  *)fp);
#line 762
  tmp = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 762
  if (tmp != 0L) {
#line 762
    printk("\016host%u: rport %6.6x: Received FLOGI request\n", (lport->host)->host_no,
           sid);
  } else {

  }
#line 764
  disc = & lport->disc;
#line 765
  mutex_lock_nested(& disc->disc_mutex, 0U);
#line 767
  if ((unsigned int )*((unsigned char *)lport + 1144UL) == 0U) {
#line 768
    rjt_data.reason = 11;
#line 769
    rjt_data.explan = 0;
#line 770
    goto reject;
  } else {

  }
#line 773
  tmp___0 = fc_frame_payload_get((struct fc_frame  const  *)fp, 116UL);
#line 773
  flp = (struct fc_els_flogi *)tmp___0;
#line 774
  if ((unsigned long )flp == (unsigned long )((struct fc_els_flogi *)0)) {
#line 775
    rjt_data.reason = 3;
#line 776
    rjt_data.explan = 45;
#line 777
    goto reject;
  } else {

  }
#line 780
  rdata = (*(lport->tt.rport_lookup))((struct fc_lport  const  *)lport, sid);
#line 781
  if ((unsigned long )rdata == (unsigned long )((struct fc_rport_priv *)0)) {
#line 782
    rjt_data.reason = 32;
#line 783
    rjt_data.explan = 98;
#line 784
    goto reject;
  } else {

  }
#line 786
  mutex_lock_nested(& rdata->rp_mutex, 0U);
#line 788
  tmp___2 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 788
  if (tmp___2 != 0L) {
#line 788
    tmp___1 = fc_rport_state(rdata);
#line 788
    printk("\016host%u: rport %6.6x: Received FLOGI in %s state\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id, tmp___1);
  } else {

  }
#line 791
  switch ((unsigned int )rdata->rp_state) {
  case 0U: ;
#line 805
  if ((unsigned int )*((unsigned char *)lport + 1144UL) != 0U) {
#line 806
    goto ldv_41718;
  } else {

  }
  case 8U: 
#line 808
  mutex_unlock(& rdata->rp_mutex);
#line 809
  rjt_data.reason = 32;
#line 810
  rjt_data.explan = 98;
#line 811
  goto reject;
  case 1U: ;
  case 2U: ;
  case 3U: ;
#line 815
  goto ldv_41718;
  case 4U: ;
  case 5U: ;
  case 6U: ;
  case 7U: 
#line 824
  fc_rport_enter_delete(rdata, 4);
#line 825
  mutex_unlock(& rdata->rp_mutex);
#line 826
  rjt_data.reason = 5;
#line 827
  rjt_data.explan = 0;
#line 828
  goto reject;
  }
  ldv_41718: 
#line 830
  tmp___3 = fc_rport_login_complete(rdata, fp);
#line 830
  if (tmp___3 != 0) {
#line 831
    mutex_unlock(& rdata->rp_mutex);
#line 832
    rjt_data.reason = 3;
#line 833
    rjt_data.explan = 0;
#line 834
    goto reject;
  } else {

  }
#line 837
  fp = fc_frame_alloc(lport, 116UL);
#line 838
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 839
    goto out;
  } else {

  }
#line 841
  fc_flogi_fill(lport, fp);
#line 842
  tmp___4 = fc_frame_payload_get((struct fc_frame  const  *)fp, 116UL);
#line 842
  flp = (struct fc_els_flogi *)tmp___4;
#line 843
  flp->fl_cmd = 2U;
#line 845
  fc_fill_reply_hdr(fp, (struct fc_frame  const  *)rx_fp, 35, 0U);
#line 846
  (*(lport->tt.frame_send))(lport, fp);
#line 848
  if (rdata->ids.port_name < lport->wwpn) {
#line 849
    fc_rport_enter_plogi(rdata);
  } else {
#line 851
    fc_rport_state_enter(rdata, 2);
  }
  out: 
#line 853
  mutex_unlock(& rdata->rp_mutex);
#line 854
  mutex_unlock(& disc->disc_mutex);
#line 855
  fc_frame_free(rx_fp);
#line 856
  return;
  reject: 
#line 859
  mutex_unlock(& disc->disc_mutex);
#line 860
  (*(lport->tt.seq_els_rsp_send))(rx_fp, 1, & rjt_data);
#line 861
  fc_frame_free(rx_fp);
#line 862
  return;
}
}
#line 874 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_plogi_resp(struct fc_seq *sp , struct fc_frame *fp , void *rdata_arg ) 
{ 
  struct fc_rport_priv *rdata ;
  struct fc_lport *lport ;
  struct fc_els_flogi *plp ;
  u16 csp_seq ;
  u16 cssp_seq ;
  u8 op ;
  char const   *tmp ;
  long tmp___0 ;
  char const   *tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  __u16 tmp___5 ;
  __u16 tmp___6 ;
  __u16 tmp___7 ;
  unsigned int tmp___8 ;
  void *tmp___9 ;

  {
#line 877
  rdata = (struct fc_rport_priv *)rdata_arg;
#line 878
  lport = rdata->local_port;
#line 879
  plp = (struct fc_els_flogi *)0;
#line 884
  mutex_lock_nested(& rdata->rp_mutex, 0U);
#line 886
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 886
  if (tmp___0 != 0L) {
#line 886
    tmp = fc_els_resp_type(fp);
#line 886
    printk("\016host%u: rport %6.6x: Received a PLOGI %s\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id, tmp);
  } else {

  }
#line 888
  if ((unsigned int )rdata->rp_state != 3U) {
#line 889
    tmp___2 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 889
    if (tmp___2 != 0L) {
#line 889
      tmp___1 = fc_rport_state(rdata);
#line 889
      printk("\016host%u: rport %6.6x: Received a PLOGI response, but in state %s\n",
             ((rdata->local_port)->host)->host_no, rdata->ids.port_id, tmp___1);
    } else {

    }
#line 891
    tmp___3 = IS_ERR((void const   *)fp);
#line 891
    if ((int )tmp___3) {
#line 892
      goto err;
    } else {

    }
#line 893
    goto out;
  } else {

  }
#line 896
  tmp___4 = IS_ERR((void const   *)fp);
#line 896
  if ((int )tmp___4) {
#line 897
    fc_rport_error_retry(rdata, fp);
#line 898
    goto err;
  } else {

  }
#line 901
  op = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 902
  if ((unsigned int )op == 2U) {
#line 902
    tmp___9 = fc_frame_payload_get((struct fc_frame  const  *)fp, 116UL);
#line 902
    plp = (struct fc_els_flogi *)tmp___9;
#line 902
    if ((unsigned long )plp != (unsigned long )((struct fc_els_flogi *)0)) {
#line 904
      rdata->ids.port_name = get_unaligned_be64((void const   *)(& plp->fl_wwpn));
#line 905
      rdata->ids.node_name = get_unaligned_be64((void const   *)(& plp->fl_wwnn));
#line 908
      tmp___5 = __fswab16((int )plp->fl_csp.sp_features);
#line 908
      rdata->sp_features = tmp___5;
#line 910
      if ((unsigned int )*((unsigned char *)lport + 1144UL) != 0U) {
#line 911
        fc_rport_login_complete(rdata, fp);
      } else {

      }
#line 912
      tmp___6 = __fswab16((int )plp->fl_csp.sp_u.sp_plogi._sp_tot_seq);
#line 912
      csp_seq = tmp___6;
#line 913
      tmp___7 = __fswab16((int )plp->fl_cssp[2].cp_con_seq);
#line 913
      cssp_seq = tmp___7;
#line 914
      if ((int )cssp_seq < (int )csp_seq) {
#line 915
        csp_seq = cssp_seq;
      } else {

      }
#line 916
      rdata->max_seq = csp_seq;
#line 917
      tmp___8 = fc_plogi_get_maxframe(plp, lport->mfs);
#line 917
      rdata->maxframe_size = (u16 )tmp___8;
#line 918
      fc_rport_enter_prli(rdata);
    } else {
#line 920
      fc_rport_error_retry(rdata, fp);
    }
  } else {
#line 920
    fc_rport_error_retry(rdata, fp);
  }
  out: 
#line 923
  fc_frame_free(fp);
  err: 
#line 925
  mutex_unlock(& rdata->rp_mutex);
#line 926
  kref_put(& rdata->kref, (rdata->local_port)->tt.rport_destroy);
#line 927
  return;
}
}
#line 930 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static bool fc_rport_compatible_roles(struct fc_lport *lport , struct fc_rport_priv *rdata ) 
{ 


  {
#line 932
  if (rdata->ids.roles == 0U) {
#line 933
    return (1);
  } else {

  }
#line 934
  if ((int )rdata->ids.roles & 1 && (lport->service_params & 32U) != 0U) {
#line 936
    return (1);
  } else {

  }
#line 937
  if ((rdata->ids.roles & 2U) != 0U && (lport->service_params & 16U) != 0U) {
#line 939
    return (1);
  } else {

  }
#line 940
  return (0);
}
}
#line 950 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_enter_plogi(struct fc_rport_priv *rdata ) 
{ 
  struct fc_lport *lport ;
  struct fc_frame *fp ;
  long tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  struct fc_seq *tmp___5 ;

  {
#line 952
  lport = rdata->local_port;
#line 955
  tmp___0 = fc_rport_compatible_roles(lport, rdata);
#line 955
  if (tmp___0) {
#line 955
    tmp___1 = 0;
  } else {
#line 955
    tmp___1 = 1;
  }
#line 955
  if (tmp___1) {
#line 956
    tmp = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 956
    if (tmp != 0L) {
#line 956
      printk("\016host%u: rport %6.6x: PLOGI suppressed for incompatible role\n",
             ((rdata->local_port)->host)->host_no, rdata->ids.port_id);
    } else {

    }
#line 957
    fc_rport_state_enter(rdata, 2);
#line 958
    return;
  } else {

  }
#line 961
  tmp___3 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 961
  if (tmp___3 != 0L) {
#line 961
    tmp___2 = fc_rport_state(rdata);
#line 961
    printk("\016host%u: rport %6.6x: Port entered PLOGI state from %s state\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id, tmp___2);
  } else {

  }
#line 964
  fc_rport_state_enter(rdata, 3);
#line 966
  rdata->maxframe_size = 256U;
#line 967
  fp = fc_frame_alloc(lport, 116UL);
#line 968
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 969
    tmp___4 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 969
    if (tmp___4 != 0L) {
#line 969
      printk("\016host%u: rport %6.6x: %s frame alloc failed\n", ((rdata->local_port)->host)->host_no,
             rdata->ids.port_id, "fc_rport_enter_plogi");
    } else {

    }
#line 970
    fc_rport_error_retry(rdata, fp);
#line 971
    return;
  } else {

  }
#line 973
  rdata->e_d_tov = lport->e_d_tov;
#line 975
  tmp___5 = (*(lport->tt.elsct_send))(lport, rdata->ids.port_id, fp, 3U, & fc_rport_plogi_resp,
                                      (void *)rdata, lport->r_a_tov * 2U);
#line 975
  if ((unsigned long )tmp___5 == (unsigned long )((struct fc_seq *)0)) {
#line 978
    fc_rport_error_retry(rdata, (struct fc_frame *)0);
  } else {
#line 980
    kref_get(& rdata->kref);
  }
#line 981
  return;
}
}
#line 993 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_prli_resp(struct fc_seq *sp , struct fc_frame *fp , void *rdata_arg ) 
{ 
  struct fc_rport_priv *rdata ;
  struct __anonstruct_pp_309 *pp ;
  struct fc_els_spp temp_spp ;
  struct fc4_prov *prov ;
  u32 roles ;
  u32 fcp_parm ;
  u8 op ;
  u8 resp_code ;
  char const   *tmp ;
  long tmp___0 ;
  char const   *tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  void *tmp___5 ;
  long tmp___6 ;
  __u32 tmp___7 ;
  long tmp___8 ;

  {
#line 996
  rdata = (struct fc_rport_priv *)rdata_arg;
#line 1003
  roles = 0U;
#line 1004
  fcp_parm = 0U;
#line 1006
  resp_code = 0U;
#line 1008
  mutex_lock_nested(& rdata->rp_mutex, 0U);
#line 1010
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1010
  if (tmp___0 != 0L) {
#line 1010
    tmp = fc_els_resp_type(fp);
#line 1010
    printk("\016host%u: rport %6.6x: Received a PRLI %s\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id, tmp);
  } else {

  }
#line 1012
  if ((unsigned int )rdata->rp_state != 4U) {
#line 1013
    tmp___2 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1013
    if (tmp___2 != 0L) {
#line 1013
      tmp___1 = fc_rport_state(rdata);
#line 1013
      printk("\016host%u: rport %6.6x: Received a PRLI response, but in state %s\n",
             ((rdata->local_port)->host)->host_no, rdata->ids.port_id, tmp___1);
    } else {

    }
#line 1015
    tmp___3 = IS_ERR((void const   *)fp);
#line 1015
    if ((int )tmp___3) {
#line 1016
      goto err;
    } else {

    }
#line 1017
    goto out;
  } else {

  }
#line 1020
  tmp___4 = IS_ERR((void const   *)fp);
#line 1020
  if ((int )tmp___4) {
#line 1021
    fc_rport_error_retry(rdata, fp);
#line 1022
    goto err;
  } else {

  }
#line 1026
  rdata->ids.roles = 0U;
#line 1028
  op = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 1029
  if ((unsigned int )op == 2U) {
#line 1030
    tmp___5 = fc_frame_payload_get((struct fc_frame  const  *)fp, 20UL);
#line 1030
    pp = (struct __anonstruct_311 *)tmp___5;
#line 1031
    if ((unsigned long )pp == (unsigned long )((struct __anonstruct_313 *)0)) {
#line 1032
      goto out;
    } else {

    }
#line 1034
    resp_code = (unsigned int )pp->spp.spp_flags & 15U;
#line 1035
    tmp___6 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1035
    if (tmp___6 != 0L) {
#line 1035
      printk("\016host%u: rport %6.6x: PRLI spp_flags = 0x%x\n", ((rdata->local_port)->host)->host_no,
             rdata->ids.port_id, (int )pp->spp.spp_flags);
    } else {

    }
#line 1037
    rdata->spp_type = pp->spp.spp_type;
#line 1038
    if ((unsigned int )resp_code != 1U) {
#line 1039
      if ((unsigned int )resp_code == 5U) {
#line 1040
        fc_rport_error(rdata, fp);
      } else {
#line 1042
        fc_rport_error_retry(rdata, fp);
      }
#line 1043
      goto out;
    } else {

    }
#line 1045
    if ((unsigned int )pp->prli.prli_spp_len <= 15U) {
#line 1046
      goto out;
    } else {

    }
#line 1048
    tmp___7 = __fswab32(pp->spp.spp_params);
#line 1048
    fcp_parm = tmp___7;
#line 1049
    if ((fcp_parm & 256U) != 0U) {
#line 1050
      rdata->flags = (u16 )((unsigned int )rdata->flags | 2U);
    } else {

    }
#line 1051
    if ((fcp_parm & 128U) != 0U) {
#line 1052
      rdata->flags = (u16 )((unsigned int )rdata->flags | 8U);
    } else {

    }
#line 1054
    prov = fc_passive_prov[8];
#line 1055
    if ((unsigned long )prov != (unsigned long )((struct fc4_prov *)0)) {
#line 1056
      memset((void *)(& temp_spp), 0, 16UL);
#line 1057
      (*(prov->prli))(rdata, (u32 )pp->prli.prli_spp_len, (struct fc_els_spp  const  *)(& pp->spp),
                      & temp_spp);
    } else {

    }
#line 1061
    rdata->supported_classes = 8U;
#line 1062
    if ((fcp_parm & 32U) != 0U) {
#line 1063
      roles = roles | 2U;
    } else {

    }
#line 1064
    if ((fcp_parm & 16U) != 0U) {
#line 1065
      roles = roles | 1U;
    } else {

    }
#line 1067
    rdata->ids.roles = roles;
#line 1068
    fc_rport_enter_rtv(rdata);
  } else {
#line 1071
    tmp___8 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1071
    if (tmp___8 != 0L) {
#line 1071
      printk("\016host%u: rport %6.6x: Bad ELS response for PRLI command\n", ((rdata->local_port)->host)->host_no,
             rdata->ids.port_id);
    } else {

    }
#line 1072
    fc_rport_error_retry(rdata, fp);
  }
  out: 
#line 1076
  fc_frame_free(fp);
  err: 
#line 1078
  mutex_unlock(& rdata->rp_mutex);
#line 1079
  kref_put(& rdata->kref, (rdata->local_port)->tt.rport_destroy);
#line 1080
  return;
}
}
#line 1089 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_enter_prli(struct fc_rport_priv *rdata ) 
{ 
  struct fc_lport *lport ;
  struct __anonstruct_pp_315 *pp ;
  struct fc_frame *fp ;
  struct fc4_prov *prov ;
  char const   *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  struct fc_seq *tmp___2 ;

  {
#line 1091
  lport = rdata->local_port;
#line 1103
  if (rdata->ids.port_id > 16776191U) {
#line 1104
    fc_rport_enter_ready(rdata);
#line 1105
    return;
  } else {

  }
#line 1108
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1108
  if (tmp___0 != 0L) {
#line 1108
    tmp = fc_rport_state(rdata);
#line 1108
    printk("\016host%u: rport %6.6x: Port entered PRLI state from %s state\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id, tmp);
  } else {

  }
#line 1111
  fc_rport_state_enter(rdata, 4);
#line 1113
  fp = fc_frame_alloc(lport, 20UL);
#line 1114
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1115
    fc_rport_error_retry(rdata, fp);
#line 1116
    return;
  } else {

  }
#line 1119
  fc_prli_fill___0(lport, fp);
#line 1121
  prov = fc_passive_prov[8];
#line 1122
  if ((unsigned long )prov != (unsigned long )((struct fc4_prov *)0)) {
#line 1123
    tmp___1 = fc_frame_payload_get((struct fc_frame  const  *)fp, 20UL);
#line 1123
    pp = (struct __anonstruct_317 *)tmp___1;
#line 1124
    (*(prov->prli))(rdata, 16U, (struct fc_els_spp  const  *)0, & pp->spp);
  } else {

  }
#line 1127
  fc_fill_fc_hdr(fp, 34, rdata->ids.port_id, ((struct fc_host_attrs *)(lport->host)->shost_data)->port_id,
                 1, 2686976U, 0U);
#line 1131
  tmp___2 = (*(lport->tt.exch_seq_send))(lport, fp, & fc_rport_prli_resp, (void (*)(struct fc_seq * ,
                                                                                    void * ))0,
                                         (void *)rdata, lport->r_a_tov * 2U);
#line 1131
  if ((unsigned long )tmp___2 == (unsigned long )((struct fc_seq *)0)) {
#line 1133
    fc_rport_error_retry(rdata, (struct fc_frame *)0);
  } else {
#line 1135
    kref_get(& rdata->kref);
  }
#line 1136
  return;
}
}
#line 1150 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_rtv_resp(struct fc_seq *sp , struct fc_frame *fp , void *rdata_arg ) 
{ 
  struct fc_rport_priv *rdata ;
  u8 op ;
  char const   *tmp ;
  long tmp___0 ;
  char const   *tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  struct fc_els_rtv_acc *rtv ;
  u32 toq ;
  u32 tov ;
  void *tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  __u32 tmp___8 ;

  {
#line 1153
  rdata = (struct fc_rport_priv *)rdata_arg;
#line 1156
  mutex_lock_nested(& rdata->rp_mutex, 0U);
#line 1158
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1158
  if (tmp___0 != 0L) {
#line 1158
    tmp = fc_els_resp_type(fp);
#line 1158
    printk("\016host%u: rport %6.6x: Received a RTV %s\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id, tmp);
  } else {

  }
#line 1160
  if ((unsigned int )rdata->rp_state != 5U) {
#line 1161
    tmp___2 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1161
    if (tmp___2 != 0L) {
#line 1161
      tmp___1 = fc_rport_state(rdata);
#line 1161
      printk("\016host%u: rport %6.6x: Received a RTV response, but in state %s\n",
             ((rdata->local_port)->host)->host_no, rdata->ids.port_id, tmp___1);
    } else {

    }
#line 1163
    tmp___3 = IS_ERR((void const   *)fp);
#line 1163
    if ((int )tmp___3) {
#line 1164
      goto err;
    } else {

    }
#line 1165
    goto out;
  } else {

  }
#line 1168
  tmp___4 = IS_ERR((void const   *)fp);
#line 1168
  if ((int )tmp___4) {
#line 1169
    fc_rport_error(rdata, fp);
#line 1170
    goto err;
  } else {

  }
#line 1173
  op = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 1174
  if ((unsigned int )op == 2U) {
#line 1179
    tmp___5 = fc_frame_payload_get((struct fc_frame  const  *)fp, 16UL);
#line 1179
    rtv = (struct fc_els_rtv_acc *)tmp___5;
#line 1180
    if ((unsigned long )rtv != (unsigned long )((struct fc_els_rtv_acc *)0)) {
#line 1181
      tmp___6 = __fswab32(rtv->rtv_toq);
#line 1181
      toq = tmp___6;
#line 1182
      tmp___7 = __fswab32(rtv->rtv_r_a_tov);
#line 1182
      tov = tmp___7;
#line 1183
      if (tov == 0U) {
#line 1184
        tov = 1U;
      } else {

      }
#line 1185
      rdata->r_a_tov = tov;
#line 1186
      tmp___8 = __fswab32(rtv->rtv_e_d_tov);
#line 1186
      tov = tmp___8;
#line 1187
      if ((toq & 67108864U) != 0U) {
#line 1188
        tov = tov / 1000000U;
      } else {

      }
#line 1189
      if (tov == 0U) {
#line 1190
        tov = 1U;
      } else {

      }
#line 1191
      rdata->e_d_tov = tov;
    } else {

    }
  } else {

  }
#line 1195
  fc_rport_enter_ready(rdata);
  out: 
#line 1198
  fc_frame_free(fp);
  err: 
#line 1200
  mutex_unlock(& rdata->rp_mutex);
#line 1201
  kref_put(& rdata->kref, (rdata->local_port)->tt.rport_destroy);
#line 1202
  return;
}
}
#line 1211 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_enter_rtv(struct fc_rport_priv *rdata ) 
{ 
  struct fc_frame *fp ;
  struct fc_lport *lport ;
  char const   *tmp ;
  long tmp___0 ;
  struct fc_seq *tmp___1 ;

  {
#line 1214
  lport = rdata->local_port;
#line 1216
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1216
  if (tmp___0 != 0L) {
#line 1216
    tmp = fc_rport_state(rdata);
#line 1216
    printk("\016host%u: rport %6.6x: Port entered RTV state from %s state\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id, tmp);
  } else {

  }
#line 1219
  fc_rport_state_enter(rdata, 5);
#line 1221
  fp = fc_frame_alloc(lport, 4UL);
#line 1222
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1223
    fc_rport_error_retry(rdata, fp);
#line 1224
    return;
  } else {

  }
#line 1227
  tmp___1 = (*(lport->tt.elsct_send))(lport, rdata->ids.port_id, fp, 14U, & fc_rport_rtv_resp,
                                      (void *)rdata, lport->r_a_tov * 2U);
#line 1227
  if ((unsigned long )tmp___1 == (unsigned long )((struct fc_seq *)0)) {
#line 1230
    fc_rport_error_retry(rdata, (struct fc_frame *)0);
  } else {
#line 1232
    kref_get(& rdata->kref);
  }
#line 1233
  return;
}
}
#line 1241 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_logo_resp(struct fc_seq *sp , struct fc_frame *fp , void *lport_arg ) 
{ 
  struct fc_lport *lport ;
  char const   *tmp ;
  struct fc_seq  const  *__mptr ;
  long tmp___0 ;
  bool tmp___1 ;

  {
#line 1244
  lport = (struct fc_lport *)lport_arg;
#line 1246
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1246
  if (tmp___0 != 0L) {
#line 1246
    tmp = fc_els_resp_type(fp);
#line 1246
    __mptr = (struct fc_seq  const  *)sp;
#line 1246
    printk("\016host%u: rport %6.6x: Received a LOGO %s\n", (lport->host)->host_no,
           ((struct fc_exch *)__mptr + 0xffffffffffffff64UL)->did, tmp);
  } else {

  }
#line 1248
  tmp___1 = IS_ERR((void const   *)fp);
#line 1248
  if ((int )tmp___1) {
#line 1249
    return;
  } else {

  }
#line 1250
  fc_frame_free(fp);
#line 1251
  return;
}
}
#line 1260 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_enter_logo(struct fc_rport_priv *rdata ) 
{ 
  struct fc_lport *lport ;
  struct fc_frame *fp ;
  char const   *tmp ;
  long tmp___0 ;

  {
#line 1262
  lport = rdata->local_port;
#line 1265
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1265
  if (tmp___0 != 0L) {
#line 1265
    tmp = fc_rport_state(rdata);
#line 1265
    printk("\016host%u: rport %6.6x: Port sending LOGO from %s state\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id, tmp);
  } else {

  }
#line 1268
  fp = fc_frame_alloc(lport, 16UL);
#line 1269
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1270
    return;
  } else {

  }
#line 1271
  (*(lport->tt.elsct_send))(lport, rdata->ids.port_id, fp, 5U, & fc_rport_logo_resp,
                            (void *)lport, 0U);
#line 1273
  return;
}
}
#line 1285 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_adisc_resp(struct fc_seq *sp , struct fc_frame *fp , void *rdata_arg ) 
{ 
  struct fc_rport_priv *rdata ;
  struct fc_els_adisc *adisc ;
  u8 op ;
  long tmp ;
  char const   *tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  void *tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  u32 tmp___7 ;
  u64 tmp___8 ;
  u64 tmp___9 ;

  {
#line 1288
  rdata = (struct fc_rport_priv *)rdata_arg;
#line 1292
  mutex_lock_nested(& rdata->rp_mutex, 0U);
#line 1294
  tmp = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1294
  if (tmp != 0L) {
#line 1294
    printk("\016host%u: rport %6.6x: Received a ADISC response\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id);
  } else {

  }
#line 1296
  if ((unsigned int )rdata->rp_state != 7U) {
#line 1297
    tmp___1 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1297
    if (tmp___1 != 0L) {
#line 1297
      tmp___0 = fc_rport_state(rdata);
#line 1297
      printk("\016host%u: rport %6.6x: Received a ADISC resp but in state %s\n", ((rdata->local_port)->host)->host_no,
             rdata->ids.port_id, tmp___0);
    } else {

    }
#line 1299
    tmp___2 = IS_ERR((void const   *)fp);
#line 1299
    if ((int )tmp___2) {
#line 1300
      goto err;
    } else {

    }
#line 1301
    goto out;
  } else {

  }
#line 1304
  tmp___3 = IS_ERR((void const   *)fp);
#line 1304
  if ((int )tmp___3) {
#line 1305
    fc_rport_error(rdata, fp);
#line 1306
    goto err;
  } else {

  }
#line 1314
  op = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 1315
  tmp___4 = fc_frame_payload_get((struct fc_frame  const  *)fp, 28UL);
#line 1315
  adisc = (struct fc_els_adisc *)tmp___4;
#line 1316
  if ((unsigned int )op != 2U || (unsigned long )adisc == (unsigned long )((struct fc_els_adisc *)0)) {
#line 1316
    goto _L;
  } else {
#line 1316
    tmp___7 = ntoh24((u8 const   *)(& adisc->adisc_port_id));
#line 1316
    if (tmp___7 != rdata->ids.port_id) {
#line 1316
      goto _L;
    } else {
#line 1316
      tmp___8 = get_unaligned_be64((void const   *)(& adisc->adisc_wwpn));
#line 1316
      if (tmp___8 != rdata->ids.port_name) {
#line 1316
        goto _L;
      } else {
#line 1316
        tmp___9 = get_unaligned_be64((void const   *)(& adisc->adisc_wwnn));
#line 1316
        if (tmp___9 != rdata->ids.node_name) {
          _L: /* CIL Label */ 
#line 1320
          tmp___5 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1320
          if (tmp___5 != 0L) {
#line 1320
            printk("\016host%u: rport %6.6x: ADISC error or mismatch\n", ((rdata->local_port)->host)->host_no,
                   rdata->ids.port_id);
          } else {

          }
#line 1321
          fc_rport_enter_flogi(rdata);
        } else {
#line 1323
          tmp___6 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1323
          if (tmp___6 != 0L) {
#line 1323
            printk("\016host%u: rport %6.6x: ADISC OK\n", ((rdata->local_port)->host)->host_no,
                   rdata->ids.port_id);
          } else {

          }
#line 1324
          fc_rport_enter_ready(rdata);
        }
      }
    }
  }
  out: 
#line 1327
  fc_frame_free(fp);
  err: 
#line 1329
  mutex_unlock(& rdata->rp_mutex);
#line 1330
  kref_put(& rdata->kref, (rdata->local_port)->tt.rport_destroy);
#line 1331
  return;
}
}
#line 1340 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_enter_adisc(struct fc_rport_priv *rdata ) 
{ 
  struct fc_lport *lport ;
  struct fc_frame *fp ;
  char const   *tmp ;
  long tmp___0 ;
  struct fc_seq *tmp___1 ;

  {
#line 1342
  lport = rdata->local_port;
#line 1345
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1345
  if (tmp___0 != 0L) {
#line 1345
    tmp = fc_rport_state(rdata);
#line 1345
    printk("\016host%u: rport %6.6x: sending ADISC from %s state\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id, tmp);
  } else {

  }
#line 1348
  fc_rport_state_enter(rdata, 7);
#line 1350
  fp = fc_frame_alloc(lport, 28UL);
#line 1351
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1352
    fc_rport_error_retry(rdata, fp);
#line 1353
    return;
  } else {

  }
#line 1355
  tmp___1 = (*(lport->tt.elsct_send))(lport, rdata->ids.port_id, fp, 82U, & fc_rport_adisc_resp,
                                      (void *)rdata, lport->r_a_tov * 2U);
#line 1355
  if ((unsigned long )tmp___1 == (unsigned long )((struct fc_seq *)0)) {
#line 1358
    fc_rport_error_retry(rdata, (struct fc_frame *)0);
  } else {
#line 1360
    kref_get(& rdata->kref);
  }
#line 1361
  return;
}
}
#line 1370 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_recv_adisc_req(struct fc_rport_priv *rdata , struct fc_frame *in_fp ) 
{ 
  struct fc_lport *lport ;
  struct fc_frame *fp ;
  struct fc_els_adisc *adisc ;
  struct fc_seq_els_data rjt_data ;
  long tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1373
  lport = rdata->local_port;
#line 1378
  tmp = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1378
  if (tmp != 0L) {
#line 1378
    printk("\016host%u: rport %6.6x: Received ADISC request\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id);
  } else {

  }
#line 1380
  tmp___0 = fc_frame_payload_get((struct fc_frame  const  *)in_fp, 28UL);
#line 1380
  adisc = (struct fc_els_adisc *)tmp___0;
#line 1381
  if ((unsigned long )adisc == (unsigned long )((struct fc_els_adisc *)0)) {
#line 1382
    rjt_data.reason = 7;
#line 1383
    rjt_data.explan = 45;
#line 1384
    (*(lport->tt.seq_els_rsp_send))(in_fp, 1, & rjt_data);
#line 1385
    goto drop;
  } else {

  }
#line 1388
  fp = fc_frame_alloc(lport, 28UL);
#line 1389
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1390
    goto drop;
  } else {

  }
#line 1391
  fc_adisc_fill(lport, fp);
#line 1392
  tmp___1 = fc_frame_payload_get((struct fc_frame  const  *)fp, 28UL);
#line 1392
  adisc = (struct fc_els_adisc *)tmp___1;
#line 1393
  adisc->adisc_cmd = 2U;
#line 1394
  fc_fill_reply_hdr(fp, (struct fc_frame  const  *)in_fp, 35, 0U);
#line 1395
  (*(lport->tt.frame_send))(lport, fp);
  drop: 
#line 1397
  fc_frame_free(in_fp);
#line 1398
  return;
}
}
#line 1408 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_recv_rls_req(struct fc_rport_priv *rdata , struct fc_frame *rx_fp ) 
{ 
  struct fc_lport *lport ;
  struct fc_frame *fp ;
  struct fc_els_rls *rls ;
  struct fc_els_rls_resp *rsp ;
  struct fc_els_lesb *lesb ;
  struct fc_seq_els_data rjt_data ;
  struct fc_host_statistics *hst ;
  char const   *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  __u32 tmp___8 ;

  {
#line 1412
  lport = rdata->local_port;
#line 1420
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1420
  if (tmp___0 != 0L) {
#line 1420
    tmp = fc_rport_state(rdata);
#line 1420
    printk("\016host%u: rport %6.6x: Received RLS request while in state %s\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id, tmp);
  } else {

  }
#line 1423
  tmp___1 = fc_frame_payload_get((struct fc_frame  const  *)rx_fp, 8UL);
#line 1423
  rls = (struct fc_els_rls *)tmp___1;
#line 1424
  if ((unsigned long )rls == (unsigned long )((struct fc_els_rls *)0)) {
#line 1425
    rjt_data.reason = 7;
#line 1426
    rjt_data.explan = 45;
#line 1427
    goto out_rjt;
  } else {

  }
#line 1430
  fp = fc_frame_alloc(lport, 28UL);
#line 1431
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1432
    rjt_data.reason = 9;
#line 1433
    rjt_data.explan = 41;
#line 1434
    goto out_rjt;
  } else {

  }
#line 1437
  tmp___2 = fc_frame_payload_get((struct fc_frame  const  *)fp, 28UL);
#line 1437
  rsp = (struct fc_els_rls_resp *)tmp___2;
#line 1438
  memset((void *)rsp, 0, 28UL);
#line 1439
  rsp->rls_cmd = 2U;
#line 1440
  lesb = & rsp->rls_lesb;
#line 1441
  if ((unsigned long )lport->tt.get_lesb != (unsigned long )((void (*)(struct fc_lport * ,
                                                                       struct fc_els_lesb * ))0)) {
#line 1443
    (*(lport->tt.get_lesb))(lport, lesb);
  } else {
#line 1445
    fc_get_host_stats(lport->host);
#line 1446
    hst = & lport->host_stats;
#line 1447
    tmp___3 = __fswab32((__u32 )hst->link_failure_count);
#line 1447
    lesb->lesb_link_fail = tmp___3;
#line 1448
    tmp___4 = __fswab32((__u32 )hst->loss_of_sync_count);
#line 1448
    lesb->lesb_sync_loss = tmp___4;
#line 1449
    tmp___5 = __fswab32((__u32 )hst->loss_of_signal_count);
#line 1449
    lesb->lesb_sig_loss = tmp___5;
#line 1450
    tmp___6 = __fswab32((__u32 )hst->prim_seq_protocol_err_count);
#line 1450
    lesb->lesb_prim_err = tmp___6;
#line 1451
    tmp___7 = __fswab32((__u32 )hst->invalid_tx_word_count);
#line 1451
    lesb->lesb_inv_word = tmp___7;
#line 1452
    tmp___8 = __fswab32((__u32 )hst->invalid_crc_count);
#line 1452
    lesb->lesb_inv_crc = tmp___8;
  }
#line 1455
  fc_fill_reply_hdr(fp, (struct fc_frame  const  *)rx_fp, 35, 0U);
#line 1456
  (*(lport->tt.frame_send))(lport, fp);
#line 1457
  goto out;
  out_rjt: 
#line 1460
  (*(lport->tt.seq_els_rsp_send))(rx_fp, 1, & rjt_data);
  out: 
#line 1462
  fc_frame_free(rx_fp);
#line 1463
  return;
}
}
#line 1475 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_recv_els_req(struct fc_lport *lport , struct fc_frame *fp ) 
{ 
  struct fc_rport_priv *rdata ;
  struct fc_seq_els_data els_data ;
  u32 tmp ;
  u8 tmp___0 ;

  {
#line 1480
  mutex_lock_nested(& lport->disc.disc_mutex, 0U);
#line 1481
  tmp = fc_frame_sid((struct fc_frame  const  *)fp);
#line 1481
  rdata = (*(lport->tt.rport_lookup))((struct fc_lport  const  *)lport, tmp);
#line 1482
  if ((unsigned long )rdata == (unsigned long )((struct fc_rport_priv *)0)) {
#line 1483
    mutex_unlock(& lport->disc.disc_mutex);
#line 1484
    goto reject;
  } else {

  }
#line 1486
  mutex_lock_nested(& rdata->rp_mutex, 0U);
#line 1487
  mutex_unlock(& lport->disc.disc_mutex);
#line 1489
  switch ((unsigned int )rdata->rp_state) {
  case 4U: ;
  case 5U: ;
  case 6U: ;
  case 7U: ;
#line 1494
  goto ldv_41857;
  default: 
#line 1496
  mutex_unlock(& rdata->rp_mutex);
#line 1497
  goto reject;
  }
  ldv_41857: 
#line 1500
  tmp___0 = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 1500
  switch ((int )tmp___0) {
  case 32: 
#line 1502
  fc_rport_recv_prli_req(rdata, fp);
#line 1503
  goto ldv_41860;
  case 33: 
#line 1505
  fc_rport_recv_prlo_req(rdata, fp);
#line 1506
  goto ldv_41860;
  case 82: 
#line 1508
  fc_rport_recv_adisc_req(rdata, fp);
#line 1509
  goto ldv_41860;
  case 18: 
#line 1511
  (*(lport->tt.seq_els_rsp_send))(fp, 18, (struct fc_seq_els_data *)0);
#line 1512
  fc_frame_free(fp);
#line 1513
  goto ldv_41860;
  case 19: 
#line 1515
  (*(lport->tt.seq_els_rsp_send))(fp, 19, (struct fc_seq_els_data *)0);
#line 1516
  fc_frame_free(fp);
#line 1517
  goto ldv_41860;
  case 15: 
#line 1519
  fc_rport_recv_rls_req(rdata, fp);
#line 1520
  goto ldv_41860;
  default: 
#line 1522
  fc_frame_free(fp);
#line 1523
  goto ldv_41860;
  }
  ldv_41860: 
#line 1526
  mutex_unlock(& rdata->rp_mutex);
#line 1527
  return;
  reject: 
#line 1530
  els_data.reason = 9;
#line 1531
  els_data.explan = 30;
#line 1532
  (*(lport->tt.seq_els_rsp_send))(fp, 1, & els_data);
#line 1533
  fc_frame_free(fp);
#line 1534
  return;
}
}
#line 1543 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_recv_req(struct fc_lport *lport , struct fc_frame *fp ) 
{ 
  struct fc_seq_els_data els_data ;
  u8 tmp ;

  {
#line 1553
  tmp = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 1553
  switch ((int )tmp) {
  case 4: 
#line 1555
  fc_rport_recv_flogi_req(lport, fp);
#line 1556
  goto ldv_41873;
  case 3: 
#line 1558
  fc_rport_recv_plogi_req(lport, fp);
#line 1559
  goto ldv_41873;
  case 5: 
#line 1561
  fc_rport_recv_logo_req(lport, fp);
#line 1562
  goto ldv_41873;
  case 32: ;
  case 33: ;
  case 82: ;
  case 18: ;
  case 19: ;
  case 15: 
#line 1569
  fc_rport_recv_els_req(lport, fp);
#line 1570
  goto ldv_41873;
  default: 
#line 1572
  els_data.reason = 11;
#line 1573
  els_data.explan = 0;
#line 1574
  (*(lport->tt.seq_els_rsp_send))(fp, 1, & els_data);
#line 1575
  fc_frame_free(fp);
#line 1576
  goto ldv_41873;
  }
  ldv_41873: ;
#line 1579
  return;
}
}
#line 1587 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_recv_plogi_req(struct fc_lport *lport , struct fc_frame *rx_fp ) 
{ 
  struct fc_disc *disc ;
  struct fc_rport_priv *rdata ;
  struct fc_frame *fp ;
  struct fc_els_flogi *pl ;
  struct fc_seq_els_data rjt_data ;
  u32 sid ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  char const   *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;

  {
#line 1592
  fp = rx_fp;
#line 1597
  sid = fc_frame_sid((struct fc_frame  const  *)fp);
#line 1599
  tmp = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1599
  if (tmp != 0L) {
#line 1599
    printk("\016host%u: rport %6.6x: Received PLOGI request\n", (lport->host)->host_no,
           sid);
  } else {

  }
#line 1601
  tmp___0 = fc_frame_payload_get((struct fc_frame  const  *)fp, 116UL);
#line 1601
  pl = (struct fc_els_flogi *)tmp___0;
#line 1602
  if ((unsigned long )pl == (unsigned long )((struct fc_els_flogi *)0)) {
#line 1603
    tmp___1 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1603
    if (tmp___1 != 0L) {
#line 1603
      printk("\016host%u: rport %6.6x: Received PLOGI too short\n", (lport->host)->host_no,
             sid);
    } else {

    }
#line 1604
    rjt_data.reason = 7;
#line 1605
    rjt_data.explan = 45;
#line 1606
    goto reject;
  } else {

  }
#line 1609
  disc = & lport->disc;
#line 1610
  mutex_lock_nested(& disc->disc_mutex, 0U);
#line 1611
  rdata = (*(lport->tt.rport_create))(lport, sid);
#line 1612
  if ((unsigned long )rdata == (unsigned long )((struct fc_rport_priv *)0)) {
#line 1613
    mutex_unlock(& disc->disc_mutex);
#line 1614
    rjt_data.reason = 9;
#line 1615
    rjt_data.explan = 41;
#line 1616
    goto reject;
  } else {

  }
#line 1619
  mutex_lock_nested(& rdata->rp_mutex, 0U);
#line 1620
  mutex_unlock(& disc->disc_mutex);
#line 1622
  rdata->ids.port_name = get_unaligned_be64((void const   *)(& pl->fl_wwpn));
#line 1623
  rdata->ids.node_name = get_unaligned_be64((void const   *)(& pl->fl_wwnn));
#line 1636
  switch ((unsigned int )rdata->rp_state) {
  case 0U: 
#line 1638
  tmp___2 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1638
  if (tmp___2 != 0L) {
#line 1638
    printk("\016host%u: rport %6.6x: Received PLOGI in INIT state\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id);
  } else {

  }
#line 1639
  goto ldv_41895;
  case 2U: 
#line 1641
  tmp___3 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1641
  if (tmp___3 != 0L) {
#line 1641
    printk("\016host%u: rport %6.6x: Received PLOGI in PLOGI_WAIT state\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id);
  } else {

  }
#line 1642
  goto ldv_41895;
  case 3U: 
#line 1644
  tmp___4 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1644
  if (tmp___4 != 0L) {
#line 1644
    printk("\016host%u: rport %6.6x: Received PLOGI in PLOGI state\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id);
  } else {

  }
#line 1645
  if (rdata->ids.port_name < lport->wwpn) {
#line 1646
    mutex_unlock(& rdata->rp_mutex);
#line 1647
    rjt_data.reason = 14;
#line 1648
    rjt_data.explan = 0;
#line 1649
    goto reject;
  } else {

  }
#line 1651
  goto ldv_41895;
  case 4U: ;
  case 5U: ;
  case 6U: ;
  case 7U: 
#line 1656
  tmp___5 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1656
  if (tmp___5 != 0L) {
#line 1656
    printk("\016host%u: rport %6.6x: Received PLOGI in logged-in state %d - ignored for now\n",
           ((rdata->local_port)->host)->host_no, rdata->ids.port_id, (unsigned int )rdata->rp_state);
  } else {

  }
#line 1659
  goto ldv_41895;
  case 1U: ;
  case 8U: 
#line 1662
  tmp___7 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1662
  if (tmp___7 != 0L) {
#line 1662
    tmp___6 = fc_rport_state(rdata);
#line 1662
    printk("\016host%u: rport %6.6x: Received PLOGI in state %s - send busy\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id, tmp___6);
  } else {

  }
#line 1664
  mutex_unlock(& rdata->rp_mutex);
#line 1665
  rjt_data.reason = 5;
#line 1666
  rjt_data.explan = 0;
#line 1667
  goto reject;
  }
  ldv_41895: 
#line 1669
  tmp___9 = fc_rport_compatible_roles(lport, rdata);
#line 1669
  if (tmp___9) {
#line 1669
    tmp___10 = 0;
  } else {
#line 1669
    tmp___10 = 1;
  }
#line 1669
  if (tmp___10) {
#line 1670
    tmp___8 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1670
    if (tmp___8 != 0L) {
#line 1670
      printk("\016host%u: rport %6.6x: Received PLOGI for incompatible role\n", ((rdata->local_port)->host)->host_no,
             rdata->ids.port_id);
    } else {

    }
#line 1671
    mutex_unlock(& rdata->rp_mutex);
#line 1672
    rjt_data.reason = 3;
#line 1673
    rjt_data.explan = 0;
#line 1674
    goto reject;
  } else {

  }
#line 1680
  tmp___11 = fc_plogi_get_maxframe(pl, lport->mfs);
#line 1680
  rdata->maxframe_size = (u16 )tmp___11;
#line 1685
  fp = fc_frame_alloc(lport, 116UL);
#line 1686
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1687
    goto out;
  } else {

  }
#line 1689
  fc_plogi_fill(lport, fp, 2U);
#line 1690
  fc_fill_reply_hdr(fp, (struct fc_frame  const  *)rx_fp, 35, 0U);
#line 1691
  (*(lport->tt.frame_send))(lport, fp);
#line 1692
  fc_rport_enter_prli(rdata);
  out: 
#line 1694
  mutex_unlock(& rdata->rp_mutex);
#line 1695
  fc_frame_free(rx_fp);
#line 1696
  return;
  reject: 
#line 1699
  (*(lport->tt.seq_els_rsp_send))(fp, 1, & rjt_data);
#line 1700
  fc_frame_free(fp);
#line 1701
  return;
}
}
#line 1711 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_recv_prli_req(struct fc_rport_priv *rdata , struct fc_frame *rx_fp ) 
{ 
  struct fc_lport *lport ;
  struct fc_frame *fp ;
  struct __anonstruct_pp_319 *pp ;
  struct fc_els_spp *rspp ;
  struct fc_els_spp *spp ;
  unsigned int len ;
  unsigned int plen ;
  enum fc_els_spp_resp resp ;
  enum fc_els_spp_resp passive ;
  struct fc_seq_els_data rjt_data ;
  struct fc4_prov *prov ;
  char const   *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  __u16 tmp___2 ;
  void *tmp___3 ;
  int __ret_warn_on ;
  long tmp___4 ;
  __u16 tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1714
  lport = rdata->local_port;
#line 1729
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1729
  if (tmp___0 != 0L) {
#line 1729
    tmp = fc_rport_state(rdata);
#line 1729
    printk("\016host%u: rport %6.6x: Received PRLI request while in state %s\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id, tmp);
  } else {

  }
#line 1732
  len = rx_fp->skb.len - 24U;
#line 1733
  tmp___1 = fc_frame_payload_get((struct fc_frame  const  *)rx_fp, 20UL);
#line 1733
  pp = (struct __anonstruct_321 *)tmp___1;
#line 1734
  if ((unsigned long )pp == (unsigned long )((struct __anonstruct_323 *)0)) {
#line 1735
    goto reject_len;
  } else {

  }
#line 1736
  tmp___2 = __fswab16((int )pp->prli.prli_len);
#line 1736
  plen = (unsigned int )tmp___2;
#line 1737
  if (((plen & 3U) != 0U || plen > len) || plen <= 15U) {
#line 1738
    goto reject_len;
  } else {

  }
#line 1739
  if (plen < len) {
#line 1740
    len = plen;
  } else {

  }
#line 1741
  plen = (unsigned int )pp->prli.prli_spp_len;
#line 1742
  if (((((plen & 3U) != 0U || plen <= 15U) || plen > len) || len <= 19U) || plen <= 11U) {
#line 1744
    goto reject_len;
  } else {

  }
#line 1745
  rspp = & pp->spp;
#line 1747
  fp = fc_frame_alloc(lport, (size_t )len);
#line 1748
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1749
    rjt_data.reason = 9;
#line 1750
    rjt_data.explan = 41;
#line 1751
    goto reject;
  } else {

  }
#line 1753
  tmp___3 = fc_frame_payload_get((struct fc_frame  const  *)fp, (size_t )len);
#line 1753
  pp = (struct __anonstruct_325 *)tmp___3;
#line 1754
  __ret_warn_on = (unsigned long )pp == (unsigned long )((struct __anonstruct_327 *)0);
#line 1754
  tmp___4 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1754
  if (tmp___4 != 0L) {
#line 1754
    warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c",
                       1754);
  } else {

  }
#line 1754
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1755
  memset((void *)pp, 0, (size_t )len);
#line 1756
  pp->prli.prli_cmd = 2U;
#line 1757
  pp->prli.prli_spp_len = (__u8 )plen;
#line 1758
  tmp___5 = __fswab16((int )((__u16 )len));
#line 1758
  pp->prli.prli_len = tmp___5;
#line 1759
  len = len - 4U;
#line 1766
  spp = & pp->spp;
#line 1767
  mutex_lock_nested(& fc_prov_mutex, 0U);
#line 1768
  goto ldv_41928;
  ldv_41927: 
#line 1769
  rdata->spp_type = rspp->spp_type;
#line 1770
  spp->spp_type = rspp->spp_type;
#line 1771
  spp->spp_type_ext = rspp->spp_type_ext;
#line 1772
  resp = 0;
#line 1774
  if ((unsigned int )rspp->spp_type <= 8U) {
#line 1775
    prov = fc_active_prov[(int )rspp->spp_type];
#line 1776
    if ((unsigned long )prov != (unsigned long )((struct fc4_prov *)0)) {
#line 1777
      tmp___6 = (*(prov->prli))(rdata, plen, (struct fc_els_spp  const  *)rspp, spp);
#line 1777
      resp = (enum fc_els_spp_resp )tmp___6;
    } else {

    }
#line 1778
    prov = fc_passive_prov[(int )rspp->spp_type];
#line 1779
    if ((unsigned long )prov != (unsigned long )((struct fc4_prov *)0)) {
#line 1780
      tmp___7 = (*(prov->prli))(rdata, plen, (struct fc_els_spp  const  *)rspp, spp);
#line 1780
      passive = (enum fc_els_spp_resp )tmp___7;
#line 1781
      if ((unsigned int )resp == 0U || (unsigned int )passive == 1U) {
#line 1782
        resp = passive;
      } else {

      }
    } else {

    }
  } else {

  }
#line 1785
  if ((unsigned int )resp == 0U) {
#line 1786
    if (((int )spp->spp_flags & 32) != 0) {
#line 1787
      resp = (enum fc_els_spp_resp )((unsigned int )resp | 5U);
    } else {
#line 1789
      resp = (enum fc_els_spp_resp )((unsigned int )resp | 8U);
    }
  } else {

  }
#line 1791
  spp->spp_flags = (int )spp->spp_flags | (int )((__u8 )resp);
#line 1792
  len = len - plen;
#line 1793
  rspp = rspp + (unsigned long )plen;
#line 1794
  spp = spp + (unsigned long )plen;
  ldv_41928: ;
#line 1768
  if (len >= plen) {
#line 1770
    goto ldv_41927;
  } else {

  }
#line 1796
  mutex_unlock(& fc_prov_mutex);
#line 1801
  fc_fill_reply_hdr(fp, (struct fc_frame  const  *)rx_fp, 35, 0U);
#line 1802
  (*(lport->tt.frame_send))(lport, fp);
#line 1804
  switch ((unsigned int )rdata->rp_state) {
  case 4U: 
#line 1806
  fc_rport_enter_ready(rdata);
#line 1807
  goto ldv_41931;
  default: ;
#line 1809
  goto ldv_41931;
  }
  ldv_41931: ;
#line 1811
  goto drop;
  reject_len: 
#line 1814
  rjt_data.reason = 7;
#line 1815
  rjt_data.explan = 45;
  reject: 
#line 1817
  (*(lport->tt.seq_els_rsp_send))(rx_fp, 1, & rjt_data);
  drop: 
#line 1819
  fc_frame_free(rx_fp);
#line 1820
  return;
}
}
#line 1830 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_recv_prlo_req(struct fc_rport_priv *rdata , struct fc_frame *rx_fp ) 
{ 
  struct fc_lport *lport ;
  struct fc_frame *fp ;
  struct __anonstruct_pp_329 *pp ;
  struct fc_els_spp *rspp ;
  struct fc_els_spp *spp ;
  unsigned int len ;
  unsigned int plen ;
  struct fc_seq_els_data rjt_data ;
  char const   *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  __u16 tmp___2 ;
  void *tmp___3 ;
  int __ret_warn_on ;
  long tmp___4 ;
  __u16 tmp___5 ;

  {
#line 1833
  lport = rdata->local_port;
#line 1845
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1845
  if (tmp___0 != 0L) {
#line 1845
    tmp = fc_rport_state(rdata);
#line 1845
    printk("\016host%u: rport %6.6x: Received PRLO request while in state %s\n", ((rdata->local_port)->host)->host_no,
           rdata->ids.port_id, tmp);
  } else {

  }
#line 1848
  len = rx_fp->skb.len - 24U;
#line 1849
  tmp___1 = fc_frame_payload_get((struct fc_frame  const  *)rx_fp, 20UL);
#line 1849
  pp = (struct __anonstruct_331 *)tmp___1;
#line 1850
  if ((unsigned long )pp == (unsigned long )((struct __anonstruct_333 *)0)) {
#line 1851
    goto reject_len;
  } else {

  }
#line 1852
  tmp___2 = __fswab16((int )pp->prlo.prlo_len);
#line 1852
  plen = (unsigned int )tmp___2;
#line 1853
  if (plen != 20U) {
#line 1854
    goto reject_len;
  } else {

  }
#line 1855
  if (plen < len) {
#line 1856
    len = plen;
  } else {

  }
#line 1858
  rspp = & pp->spp;
#line 1860
  fp = fc_frame_alloc(lport, (size_t )len);
#line 1861
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1862
    rjt_data.reason = 9;
#line 1863
    rjt_data.explan = 41;
#line 1864
    goto reject;
  } else {

  }
#line 1867
  tmp___3 = fc_frame_payload_get((struct fc_frame  const  *)fp, (size_t )len);
#line 1867
  pp = (struct __anonstruct_335 *)tmp___3;
#line 1868
  __ret_warn_on = (unsigned long )pp == (unsigned long )((struct __anonstruct_337 *)0);
#line 1868
  tmp___4 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1868
  if (tmp___4 != 0L) {
#line 1868
    warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c",
                       1868);
  } else {

  }
#line 1868
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1869
  memset((void *)pp, 0, (size_t )len);
#line 1870
  pp->prlo.prlo_cmd = 2U;
#line 1871
  pp->prlo.prlo_obs = 16U;
#line 1872
  tmp___5 = __fswab16((int )((__u16 )len));
#line 1872
  pp->prlo.prlo_len = tmp___5;
#line 1873
  spp = & pp->spp;
#line 1874
  spp->spp_type = rspp->spp_type;
#line 1875
  spp->spp_type_ext = rspp->spp_type_ext;
#line 1876
  spp->spp_flags = 1U;
#line 1878
  fc_rport_enter_delete(rdata, 4);
#line 1880
  fc_fill_reply_hdr(fp, (struct fc_frame  const  *)rx_fp, 35, 0U);
#line 1881
  (*(lport->tt.frame_send))(lport, fp);
#line 1882
  goto drop;
  reject_len: 
#line 1885
  rjt_data.reason = 7;
#line 1886
  rjt_data.explan = 45;
  reject: 
#line 1888
  (*(lport->tt.seq_els_rsp_send))(rx_fp, 1, & rjt_data);
  drop: 
#line 1890
  fc_frame_free(rx_fp);
#line 1891
  return;
}
}
#line 1901 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_recv_logo_req(struct fc_lport *lport , struct fc_frame *fp ) 
{ 
  struct fc_rport_priv *rdata ;
  u32 sid ;
  char const   *tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 1906
  (*(lport->tt.seq_els_rsp_send))(fp, 2, (struct fc_seq_els_data *)0);
#line 1908
  sid = fc_frame_sid((struct fc_frame  const  *)fp);
#line 1910
  mutex_lock_nested(& lport->disc.disc_mutex, 0U);
#line 1911
  rdata = (*(lport->tt.rport_lookup))((struct fc_lport  const  *)lport, sid);
#line 1912
  if ((unsigned long )rdata != (unsigned long )((struct fc_rport_priv *)0)) {
#line 1913
    mutex_lock_nested(& rdata->rp_mutex, 0U);
#line 1914
    tmp___0 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1914
    if (tmp___0 != 0L) {
#line 1914
      tmp = fc_rport_state(rdata);
#line 1914
      printk("\016host%u: rport %6.6x: Received LOGO request while in state %s\n",
             ((rdata->local_port)->host)->host_no, rdata->ids.port_id, tmp);
    } else {

    }
#line 1917
    fc_rport_enter_delete(rdata, 4);
#line 1918
    mutex_unlock(& rdata->rp_mutex);
  } else {
#line 1920
    tmp___1 = ldv__builtin_expect((fc_debug_logging & 8U) != 0U, 0L);
#line 1920
    if (tmp___1 != 0L) {
#line 1920
      printk("\016host%u: rport %6.6x: Received LOGO from non-logged-in port\n", (lport->host)->host_no,
             sid);
    } else {

    }
  }
#line 1922
  mutex_unlock(& lport->disc.disc_mutex);
#line 1923
  fc_frame_free(fp);
#line 1924
  return;
}
}
#line 1929 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static void fc_rport_flush_queue(void) 
{ 


  {
#line 1931
  ldv_flush_workqueue_335(rport_event_queue);
#line 1932
  return;
}
}
#line 1938 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
int fc_rport_init(struct fc_lport *lport ) 
{ 


  {
#line 1940
  if ((unsigned long )lport->tt.rport_lookup == (unsigned long )((struct fc_rport_priv *(*)(struct fc_lport  const  * ,
                                                                                            u32  ))0)) {
#line 1941
    lport->tt.rport_lookup = & fc_rport_lookup;
  } else {

  }
#line 1943
  if ((unsigned long )lport->tt.rport_create == (unsigned long )((struct fc_rport_priv *(*)(struct fc_lport * ,
                                                                                            u32  ))0)) {
#line 1944
    lport->tt.rport_create = & fc_rport_create;
  } else {

  }
#line 1946
  if ((unsigned long )lport->tt.rport_login == (unsigned long )((int (*)(struct fc_rport_priv * ))0)) {
#line 1947
    lport->tt.rport_login = & fc_rport_login;
  } else {

  }
#line 1949
  if ((unsigned long )lport->tt.rport_logoff == (unsigned long )((int (*)(struct fc_rport_priv * ))0)) {
#line 1950
    lport->tt.rport_logoff = & fc_rport_logoff;
  } else {

  }
#line 1952
  if ((unsigned long )lport->tt.rport_recv_req == (unsigned long )((void (*)(struct fc_lport * ,
                                                                             struct fc_frame * ))0)) {
#line 1953
    lport->tt.rport_recv_req = & fc_rport_recv_req;
  } else {

  }
#line 1955
  if ((unsigned long )lport->tt.rport_flush_queue == (unsigned long )((void (*)(void))0)) {
#line 1956
    lport->tt.rport_flush_queue = & fc_rport_flush_queue;
  } else {

  }
#line 1958
  if ((unsigned long )lport->tt.rport_destroy == (unsigned long )((void (*)(struct kref * ))0)) {
#line 1959
    lport->tt.rport_destroy = & fc_rport_destroy;
  } else {

  }
#line 1961
  return (0);
}
}
#line 1963 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static char const   __kstrtab_fc_rport_init[14U]  = 
#line 1963
  {      'f',      'c',      '_',      'r', 
        'p',      'o',      'r',      't', 
        '_',      'i',      'n',      'i', 
        't',      '\000'};
#line 1963
struct kernel_symbol  const  __ksymtab_fc_rport_init ;
#line 1963 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
struct kernel_symbol  const  __ksymtab_fc_rport_init  =    {(unsigned long )(& fc_rport_init), (char const   *)(& __kstrtab_fc_rport_init)};
#line 1975 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static int fc_rport_fcp_prli(struct fc_rport_priv *rdata , u32 spp_len , struct fc_els_spp  const  *rspp ,
                             struct fc_els_spp *spp ) 
{ 
  struct fc_lport *lport ;
  u32 fcp_parm ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;

  {
#line 1979
  lport = rdata->local_port;
#line 1982
  tmp = __fswab32(rspp->spp_params);
#line 1982
  fcp_parm = tmp;
#line 1983
  rdata->ids.roles = 0U;
#line 1984
  if ((fcp_parm & 32U) != 0U) {
#line 1985
    rdata->ids.roles = rdata->ids.roles | 2U;
  } else {

  }
#line 1986
  if ((fcp_parm & 16U) != 0U) {
#line 1987
    rdata->ids.roles = rdata->ids.roles | 1U;
  } else {

  }
#line 1988
  if ((fcp_parm & 256U) != 0U) {
#line 1989
    rdata->flags = (u16 )((unsigned int )rdata->flags | 2U);
  } else {

  }
#line 1990
  rdata->supported_classes = 8U;
#line 1992
  if ((lport->service_params & 32U) == 0U) {
#line 1993
    return (0);
  } else {

  }
#line 1995
  spp->spp_flags = (__u8 )((int )((signed char )spp->spp_flags) | ((int )((signed char )rspp->spp_flags) & 32));
#line 2000
  tmp___0 = __fswab32(spp->spp_params);
#line 2000
  fcp_parm = tmp___0;
#line 2001
  tmp___1 = __fswab32(lport->service_params | fcp_parm);
#line 2001
  spp->spp_params = tmp___1;
#line 2002
  return (1);
}
}
#line 2008 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
struct fc4_prov fc_rport_fcp_init  =    {& fc_rport_fcp_prli, 0, 0, 0};
#line 2019 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static int fc_rport_t0_prli(struct fc_rport_priv *rdata , u32 spp_len , struct fc_els_spp  const  *rspp ,
                            struct fc_els_spp *spp ) 
{ 


  {
#line 2023
  if (((int )rspp->spp_flags & 32) != 0) {
#line 2024
    return (8);
  } else {

  }
#line 2025
  return (1);
}
}
#line 2034 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
struct fc4_prov fc_rport_t0_prov  =    {& fc_rport_t0_prli, 0, 0, 0};
#line 2041 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
int fc_setup_rport(void) 
{ 
  struct lock_class_key __key ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp ;

  {
#line 2043
  __lock_name = "\"%s\"\"fc_rport_eq\"";
#line 2043
  tmp = __alloc_workqueue_key("%s", 131082U, 1, & __key, __lock_name, (char *)"fc_rport_eq");
#line 2043
  rport_event_queue = tmp;
#line 2044
  if ((unsigned long )rport_event_queue == (unsigned long )((struct workqueue_struct *)0)) {
#line 2045
    return (-12);
  } else {

  }
#line 2046
  return (0);
}
}
#line 2052 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
void fc_destroy_rport(void) 
{ 


  {
#line 2054
  ldv_destroy_workqueue_336(rport_event_queue);
#line 2055
  return;
}
}
#line 2061 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
void fc_rport_terminate_io(struct fc_rport *rport ) 
{ 
  struct fc_rport_libfc_priv *rpriv ;
  struct fc_lport *lport ;

  {
#line 2063
  rpriv = (struct fc_rport_libfc_priv *)rport->dd_data;
#line 2064
  lport = rpriv->local_port;
#line 2066
  (*(lport->tt.exch_mgr_reset))(lport, 0U, rport->port_id);
#line 2067
  (*(lport->tt.exch_mgr_reset))(lport, rport->port_id, 0U);
#line 2068
  return;
}
}
#line 2069 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
static char const   __kstrtab_fc_rport_terminate_io[22U]  = 
#line 2069
  {      'f',      'c',      '_',      'r', 
        'p',      'o',      'r',      't', 
        '_',      't',      'e',      'r', 
        'm',      'i',      'n',      'a', 
        't',      'e',      '_',      'i', 
        'o',      '\000'};
#line 2069
struct kernel_symbol  const  __ksymtab_fc_rport_terminate_io ;
#line 2069 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.c"
struct kernel_symbol  const  __ksymtab_fc_rport_terminate_io  =    {(unsigned long )(& fc_rport_terminate_io), (char const   *)(& __kstrtab_fc_rport_terminate_io)};
#line 152 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
void activate_work_5(struct work_struct *work , int state ) 
{ 


  {
#line 153
  if (ldv_work_5_0 == 0) {
#line 154
    ldv_work_struct_5_0 = work;
#line 155
    ldv_work_5_0 = state;
#line 156
    return;
  } else {

  }
#line 159
  if (ldv_work_5_1 == 0) {
#line 160
    ldv_work_struct_5_1 = work;
#line 161
    ldv_work_5_1 = state;
#line 162
    return;
  } else {

  }
#line 165
  if (ldv_work_5_2 == 0) {
#line 166
    ldv_work_struct_5_2 = work;
#line 167
    ldv_work_5_2 = state;
#line 168
    return;
  } else {

  }
#line 171
  if (ldv_work_5_3 == 0) {
#line 172
    ldv_work_struct_5_3 = work;
#line 173
    ldv_work_5_3 = state;
#line 174
    return;
  } else {

  }
#line 176
  return;
}
}
#line 179 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
void activate_work_4(struct work_struct *work , int state ) 
{ 


  {
#line 180
  if (ldv_work_4_0 == 0) {
#line 181
    ldv_work_struct_4_0 = work;
#line 182
    ldv_work_4_0 = state;
#line 183
    return;
  } else {

  }
#line 186
  if (ldv_work_4_1 == 0) {
#line 187
    ldv_work_struct_4_1 = work;
#line 188
    ldv_work_4_1 = state;
#line 189
    return;
  } else {

  }
#line 192
  if (ldv_work_4_2 == 0) {
#line 193
    ldv_work_struct_4_2 = work;
#line 194
    ldv_work_4_2 = state;
#line 195
    return;
  } else {

  }
#line 198
  if (ldv_work_4_3 == 0) {
#line 199
    ldv_work_struct_4_3 = work;
#line 200
    ldv_work_4_3 = state;
#line 201
    return;
  } else {

  }
#line 203
  return;
}
}
#line 206 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
void call_and_disable_all_5(int state ) 
{ 


  {
#line 208
  if (ldv_work_5_0 == state) {
#line 209
    call_and_disable_work_5(ldv_work_struct_5_0);
  } else {

  }
#line 210
  if (ldv_work_5_1 == state) {
#line 211
    call_and_disable_work_5(ldv_work_struct_5_1);
  } else {

  }
#line 212
  if (ldv_work_5_2 == state) {
#line 213
    call_and_disable_work_5(ldv_work_struct_5_2);
  } else {

  }
#line 214
  if (ldv_work_5_3 == state) {
#line 215
    call_and_disable_work_5(ldv_work_struct_5_3);
  } else {

  }
#line 216
  return;
}
}
#line 219 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
void work_init_5(void) 
{ 


  {
#line 220
  ldv_work_5_0 = 0;
#line 221
  ldv_work_5_1 = 0;
#line 222
  ldv_work_5_2 = 0;
#line 223
  ldv_work_5_3 = 0;
#line 224
  return;
}
}
#line 227 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
void call_and_disable_all_4(int state ) 
{ 


  {
#line 229
  if (ldv_work_4_0 == state) {
#line 230
    call_and_disable_work_4(ldv_work_struct_4_0);
  } else {

  }
#line 231
  if (ldv_work_4_1 == state) {
#line 232
    call_and_disable_work_4(ldv_work_struct_4_1);
  } else {

  }
#line 233
  if (ldv_work_4_2 == state) {
#line 234
    call_and_disable_work_4(ldv_work_struct_4_2);
  } else {

  }
#line 235
  if (ldv_work_4_3 == state) {
#line 236
    call_and_disable_work_4(ldv_work_struct_4_3);
  } else {

  }
#line 237
  return;
}
}
#line 240 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
void invoke_work_5(void) 
{ 
  int tmp ;

  {
#line 242
  tmp = __VERIFIER_nondet_int();
#line 242
  switch (tmp) {
  case 0: ;
#line 244
  if (ldv_work_5_0 == 2 || ldv_work_5_0 == 3) {
#line 245
    ldv_work_5_0 = 4;
#line 246
    fc_rport_work(ldv_work_struct_5_0);
#line 247
    ldv_work_5_0 = 1;
  } else {

  }
#line 250
  goto ldv_42033;
  case 1: ;
#line 252
  if (ldv_work_5_1 == 2 || ldv_work_5_1 == 3) {
#line 253
    ldv_work_5_1 = 4;
#line 254
    fc_rport_work(ldv_work_struct_5_0);
#line 255
    ldv_work_5_1 = 1;
  } else {

  }
#line 258
  goto ldv_42033;
  case 2: ;
#line 260
  if (ldv_work_5_2 == 2 || ldv_work_5_2 == 3) {
#line 261
    ldv_work_5_2 = 4;
#line 262
    fc_rport_work(ldv_work_struct_5_0);
#line 263
    ldv_work_5_2 = 1;
  } else {

  }
#line 266
  goto ldv_42033;
  case 3: ;
#line 268
  if (ldv_work_5_3 == 2 || ldv_work_5_3 == 3) {
#line 269
    ldv_work_5_3 = 4;
#line 270
    fc_rport_work(ldv_work_struct_5_0);
#line 271
    ldv_work_5_3 = 1;
  } else {

  }
#line 274
  goto ldv_42033;
  default: 
#line 275
  ldv_stop();
  }
  ldv_42033: ;
#line 277
  return;
}
}
#line 281 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
void disable_work_5(struct work_struct *work ) 
{ 


  {
#line 283
  if ((ldv_work_5_0 == 3 || ldv_work_5_0 == 2) && (unsigned long )ldv_work_struct_5_0 == (unsigned long )work) {
#line 285
    ldv_work_5_0 = 1;
  } else {

  }
#line 287
  if ((ldv_work_5_1 == 3 || ldv_work_5_1 == 2) && (unsigned long )ldv_work_struct_5_1 == (unsigned long )work) {
#line 289
    ldv_work_5_1 = 1;
  } else {

  }
#line 291
  if ((ldv_work_5_2 == 3 || ldv_work_5_2 == 2) && (unsigned long )ldv_work_struct_5_2 == (unsigned long )work) {
#line 293
    ldv_work_5_2 = 1;
  } else {

  }
#line 295
  if ((ldv_work_5_3 == 3 || ldv_work_5_3 == 2) && (unsigned long )ldv_work_struct_5_3 == (unsigned long )work) {
#line 297
    ldv_work_5_3 = 1;
  } else {

  }
#line 298
  return;
}
}
#line 302 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
void disable_work_4(struct work_struct *work ) 
{ 


  {
#line 304
  if ((ldv_work_4_0 == 3 || ldv_work_4_0 == 2) && (unsigned long )ldv_work_struct_4_0 == (unsigned long )work) {
#line 306
    ldv_work_4_0 = 1;
  } else {

  }
#line 308
  if ((ldv_work_4_1 == 3 || ldv_work_4_1 == 2) && (unsigned long )ldv_work_struct_4_1 == (unsigned long )work) {
#line 310
    ldv_work_4_1 = 1;
  } else {

  }
#line 312
  if ((ldv_work_4_2 == 3 || ldv_work_4_2 == 2) && (unsigned long )ldv_work_struct_4_2 == (unsigned long )work) {
#line 314
    ldv_work_4_2 = 1;
  } else {

  }
#line 316
  if ((ldv_work_4_3 == 3 || ldv_work_4_3 == 2) && (unsigned long )ldv_work_struct_4_3 == (unsigned long )work) {
#line 318
    ldv_work_4_3 = 1;
  } else {

  }
#line 319
  return;
}
}
#line 323 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
void work_init_4(void) 
{ 


  {
#line 324
  ldv_work_4_0 = 0;
#line 325
  ldv_work_4_1 = 0;
#line 326
  ldv_work_4_2 = 0;
#line 327
  ldv_work_4_3 = 0;
#line 328
  return;
}
}
#line 331 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
void invoke_work_4(void) 
{ 
  int tmp ;

  {
#line 333
  tmp = __VERIFIER_nondet_int();
#line 333
  switch (tmp) {
  case 0: ;
#line 335
  if (ldv_work_4_0 == 2 || ldv_work_4_0 == 3) {
#line 336
    ldv_work_4_0 = 4;
#line 337
    fc_rport_timeout(ldv_work_struct_4_0);
#line 338
    ldv_work_4_0 = 1;
  } else {

  }
#line 341
  goto ldv_42053;
  case 1: ;
#line 343
  if (ldv_work_4_1 == 2 || ldv_work_4_1 == 3) {
#line 344
    ldv_work_4_1 = 4;
#line 345
    fc_rport_timeout(ldv_work_struct_4_0);
#line 346
    ldv_work_4_1 = 1;
  } else {

  }
#line 349
  goto ldv_42053;
  case 2: ;
#line 351
  if (ldv_work_4_2 == 2 || ldv_work_4_2 == 3) {
#line 352
    ldv_work_4_2 = 4;
#line 353
    fc_rport_timeout(ldv_work_struct_4_0);
#line 354
    ldv_work_4_2 = 1;
  } else {

  }
#line 357
  goto ldv_42053;
  case 3: ;
#line 359
  if (ldv_work_4_3 == 2 || ldv_work_4_3 == 3) {
#line 360
    ldv_work_4_3 = 4;
#line 361
    fc_rport_timeout(ldv_work_struct_4_0);
#line 362
    ldv_work_4_3 = 1;
  } else {

  }
#line 365
  goto ldv_42053;
  default: 
#line 366
  ldv_stop();
  }
  ldv_42053: ;
#line 368
  return;
}
}
#line 372 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
void call_and_disable_work_5(struct work_struct *work ) 
{ 


  {
#line 375
  if ((ldv_work_5_0 == 2 || ldv_work_5_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_0) {
#line 377
    fc_rport_work(work);
#line 378
    ldv_work_5_0 = 1;
#line 379
    return;
  } else {

  }
#line 381
  if ((ldv_work_5_1 == 2 || ldv_work_5_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_1) {
#line 383
    fc_rport_work(work);
#line 384
    ldv_work_5_1 = 1;
#line 385
    return;
  } else {

  }
#line 387
  if ((ldv_work_5_2 == 2 || ldv_work_5_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_2) {
#line 389
    fc_rport_work(work);
#line 390
    ldv_work_5_2 = 1;
#line 391
    return;
  } else {

  }
#line 393
  if ((ldv_work_5_3 == 2 || ldv_work_5_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_3) {
#line 395
    fc_rport_work(work);
#line 396
    ldv_work_5_3 = 1;
#line 397
    return;
  } else {

  }
#line 399
  return;
}
}
#line 402 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
void call_and_disable_work_4(struct work_struct *work ) 
{ 


  {
#line 405
  if ((ldv_work_4_0 == 2 || ldv_work_4_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_0) {
#line 407
    fc_rport_timeout(work);
#line 408
    ldv_work_4_0 = 1;
#line 409
    return;
  } else {

  }
#line 411
  if ((ldv_work_4_1 == 2 || ldv_work_4_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_1) {
#line 413
    fc_rport_timeout(work);
#line 414
    ldv_work_4_1 = 1;
#line 415
    return;
  } else {

  }
#line 417
  if ((ldv_work_4_2 == 2 || ldv_work_4_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_2) {
#line 419
    fc_rport_timeout(work);
#line 420
    ldv_work_4_2 = 1;
#line 421
    return;
  } else {

  }
#line 423
  if ((ldv_work_4_3 == 2 || ldv_work_4_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_3) {
#line 425
    fc_rport_timeout(work);
#line 426
    ldv_work_4_3 = 1;
#line 427
    return;
  } else {

  }
#line 429
  return;
}
}
#line 433 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
void ldv_main_exported_10(void) 
{ 
  struct fc_els_spp *ldvarg15 ;
  void *tmp ;
  u32 ldvarg16 ;
  struct fc_els_spp *ldvarg13 ;
  void *tmp___0 ;
  struct fc_rport_priv *ldvarg14 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 434
  tmp = ldv_init_zalloc(16UL);
#line 434
  ldvarg15 = (struct fc_els_spp *)tmp;
#line 436
  tmp___0 = ldv_init_zalloc(16UL);
#line 436
  ldvarg13 = (struct fc_els_spp *)tmp___0;
#line 437
  tmp___1 = ldv_init_zalloc(608UL);
#line 437
  ldvarg14 = (struct fc_rport_priv *)tmp___1;
#line 435
  ldv_memset((void *)(& ldvarg16), 0, 4UL);
#line 439
  tmp___2 = __VERIFIER_nondet_int();
#line 439
  switch (tmp___2) {
  case 0: ;
#line 442
  if (ldv_state_variable_10 == 1) {
#line 444
    fc_rport_fcp_prli(ldvarg14, ldvarg16, (struct fc_els_spp  const  *)ldvarg15, ldvarg13);
#line 446
    ldv_state_variable_10 = 1;
  } else {

  }
#line 449
  goto ldv_42076;
  default: 
#line 450
  ldv_stop();
  }
  ldv_42076: ;
#line 454
  return;
}
}
#line 456 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
void ldv_main_exported_9(void) 
{ 
  u32 ldvarg6 ;
  struct fc_els_spp *ldvarg5 ;
  void *tmp ;
  struct fc_els_spp *ldvarg3 ;
  void *tmp___0 ;
  struct fc_rport_priv *ldvarg4 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 458
  tmp = ldv_init_zalloc(16UL);
#line 458
  ldvarg5 = (struct fc_els_spp *)tmp;
#line 459
  tmp___0 = ldv_init_zalloc(16UL);
#line 459
  ldvarg3 = (struct fc_els_spp *)tmp___0;
#line 460
  tmp___1 = ldv_init_zalloc(608UL);
#line 460
  ldvarg4 = (struct fc_rport_priv *)tmp___1;
#line 457
  ldv_memset((void *)(& ldvarg6), 0, 4UL);
#line 462
  tmp___2 = __VERIFIER_nondet_int();
#line 462
  switch (tmp___2) {
  case 0: ;
#line 465
  if (ldv_state_variable_9 == 1) {
#line 467
    fc_rport_t0_prli(ldvarg4, ldvarg6, (struct fc_els_spp  const  *)ldvarg5, ldvarg3);
#line 469
    ldv_state_variable_9 = 1;
  } else {

  }
#line 472
  goto ldv_42086;
  default: 
#line 473
  ldv_stop();
  }
  ldv_42086: ;
#line 477
  return;
}
}
#line 591 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
bool ldv_queue_work_on_307(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 595
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 595
  ldv_func_res = tmp;
#line 597
  activate_work_3(ldv_func_arg3, 2);
#line 599
  return (ldv_func_res);
}
}
#line 602 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
bool ldv_queue_delayed_work_on_308(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 606
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 606
  ldv_func_res = tmp;
#line 608
  activate_work_3(& ldv_func_arg3->work, 2);
#line 610
  return (ldv_func_res);
}
}
#line 613 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
bool ldv_queue_work_on_309(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  bool tmp ;

  {
#line 617
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 617
  ldv_func_res = tmp;
#line 619
  activate_work_3(ldv_func_arg3, 2);
#line 621
  return (ldv_func_res);
}
}
#line 624 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
void ldv_flush_workqueue_310(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 627
  flush_workqueue(ldv_func_arg1);
#line 629
  call_and_disable_all_3(2);
#line 630
  return;
}
}
#line 632 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
bool ldv_queue_delayed_work_on_311(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
#line 636
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 636
  ldv_func_res = tmp;
#line 638
  activate_work_3(& ldv_func_arg3->work, 2);
#line 640
  return (ldv_func_res);
}
}
#line 678 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
void *ldv_kmem_cache_alloc_317(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 681
  ldv_check_alloc_flags(flags);
#line 682
  tmp = ldv_undef_ptr();
#line 682
  return (tmp);
}
}
#line 720 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
int ldv_pskb_expand_head_323(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 723
  ldv_check_alloc_flags(flags);
#line 724
  tmp = ldv_undef_ptr();
#line 724
  return ((int )((long )tmp));
}
}
#line 734 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
struct sk_buff *ldv_skb_clone_325(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 737
  ldv_check_alloc_flags(flags);
#line 738
  tmp = ldv_undef_ptr();
#line 738
  return ((struct sk_buff *)tmp);
}
}
#line 748 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
struct sk_buff *ldv_skb_copy_327(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 751
  ldv_check_alloc_flags(flags);
#line 752
  tmp = ldv_undef_ptr();
#line 752
  return ((struct sk_buff *)tmp);
}
}
#line 755 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_328(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 758
  ldv_check_alloc_flags(flags);
#line 759
  tmp = ldv_undef_ptr();
#line 759
  return ((struct sk_buff *)tmp);
}
}
#line 762 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_329(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 765
  ldv_check_alloc_flags(flags);
#line 766
  tmp = ldv_undef_ptr();
#line 766
  return ((struct sk_buff *)tmp);
}
}
#line 769 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_330(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 772
  ldv_check_alloc_flags(flags);
#line 773
  tmp = ldv_undef_ptr();
#line 773
  return ((struct sk_buff *)tmp);
}
}
#line 776 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
int ldv_pskb_expand_head_331(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 779
  ldv_check_alloc_flags(flags);
#line 780
  tmp = ldv_undef_ptr();
#line 780
  return ((int )((long )tmp));
}
}
#line 783 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
int ldv_pskb_expand_head_332(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 786
  ldv_check_alloc_flags(flags);
#line 787
  tmp = ldv_undef_ptr();
#line 787
  return ((int )((long )tmp));
}
}
#line 790 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
struct sk_buff *ldv_skb_clone_333(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 793
  ldv_check_alloc_flags(flags);
#line 794
  tmp = ldv_undef_ptr();
#line 794
  return ((struct sk_buff *)tmp);
}
}
#line 797 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
bool ldv_cancel_delayed_work_sync_334(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  bool tmp ;

  {
#line 801
  tmp = cancel_delayed_work_sync(ldv_func_arg1);
#line 801
  ldv_func_res = tmp;
#line 803
  disable_work_3(& ldv_func_arg1->work);
#line 805
  return (ldv_func_res);
}
}
#line 808 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
void ldv_flush_workqueue_335(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 811
  flush_workqueue(ldv_func_arg1);
#line 813
  call_and_disable_all_3(2);
#line 814
  return;
}
}
#line 816 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_rport.o.c.prepared"
void ldv_destroy_workqueue_336(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 819
  destroy_workqueue(ldv_func_arg1);
#line 821
  call_and_disable_all_3(2);
#line 822
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 308 "./arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 310
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
#line 187 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 189
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 32 "include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 45 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 319 "include/linux/spinlock.h"
__inline static void spin_lock_bh(spinlock_t *lock ) ;
#line 368
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
#line 386 "include/linux/spinlock.h"
__inline static void ldv_spin_unlock_irqrestore_356(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 388
  _raw_spin_unlock_irqrestore(& lock->__annonCompField18.rlock, flags);
#line 389
  return;
}
}
#line 386
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
#line 10 "include/linux/mmdebug.h"
extern void dump_page(struct page * , char const   * ) ;
#line 73 "include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ 
  struct lock_class_key __key ;

  {
#line 75
  x->done = 0U;
#line 76
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
#line 78
  return;
}
}
#line 95
extern unsigned long wait_for_completion_timeout(struct completion * , unsigned long  ) ;
#line 106
extern void complete(struct completion * ) ;
#line 284 "include/linux/jiffies.h"
extern unsigned int jiffies_to_msecs(unsigned long const    ) ;
#line 170 "include/linux/timer.h"
extern int mod_timer(struct timer_list * , unsigned long  ) ;
#line 173
int ldv_mod_timer_387(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 229
extern int del_timer_sync(struct timer_list * ) ;
#line 232
int ldv_del_timer_sync_388(struct timer_list *ldv_func_arg1 ) ;
#line 236
int ldv_del_timer_sync_389(struct timer_list *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_359(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_361(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_360(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_363(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_362(struct workqueue_struct *ldv_func_arg1 ) ;
#line 293 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_369(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 585
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 103 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
void activate_suitable_timer_6(struct timer_list *timer , unsigned long data ) ;
#line 106
int reg_timer_7(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 108
void choose_timer_8(struct timer_list *timer ) ;
#line 110
void disable_suitable_timer_7(struct timer_list *timer ) ;
#line 111
int reg_timer_8(struct timer_list *timer ) ;
#line 113
void choose_timer_6(void) ;
#line 116
int reg_timer_6(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 117
void disable_suitable_timer_8(struct timer_list *timer ) ;
#line 121
void ldv_timer_6(int state , struct timer_list *timer ) ;
#line 132
void activate_pending_timer_8(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 134
void ldv_timer_7(int state , struct timer_list *timer ) ;
#line 141
void choose_timer_7(void) ;
#line 142
void disable_suitable_timer_6(struct timer_list *timer ) ;
#line 145
void activate_pending_timer_7(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 146
void activate_pending_timer_6(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 148
void activate_suitable_timer_7(struct timer_list *timer , unsigned long data ) ;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 400 "include/linux/page-flags.h"
__inline static int PageTail(struct page  const  *page ) 
{ 
  int tmp ;

  {
#line 400
  tmp = constant_test_bit(15L, (unsigned long const volatile   *)(& page->flags));
#line 400
  return (tmp);
}
}
#line 440 "include/linux/mm.h"
__inline static struct page *compound_head_by_tail(struct page *tail ) 
{ 
  struct page *head ;
  int tmp ;
  long tmp___0 ;

  {
#line 442
  head = tail->__annonCompField46.first_page;
#line 449
  __asm__  volatile   ("": : : "memory");
#line 450
  tmp = PageTail((struct page  const  *)tail);
#line 450
  tmp___0 = ldv__builtin_expect(tmp != 0, 1L);
#line 450
  if (tmp___0 != 0L) {
#line 451
    return (head);
  } else {

  }
#line 452
  return (tail);
}
}
#line 461 "include/linux/mm.h"
__inline static struct page *compound_head(struct page *page ) 
{ 
  struct page *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 463
  tmp___0 = PageTail((struct page  const  *)page);
#line 463
  tmp___1 = ldv__builtin_expect(tmp___0 != 0, 0L);
#line 463
  if (tmp___1 != 0L) {
#line 464
    tmp = compound_head_by_tail(page);
#line 464
    return (tmp);
  } else {

  }
#line 465
  return (page);
}
}
#line 532
extern bool __get_page_tail(struct page * ) ;
#line 534 "include/linux/mm.h"
__inline static void get_page(struct page *page ) 
{ 
  bool tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 536
  tmp___1 = PageTail((struct page  const  *)page);
#line 536
  tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
#line 536
  if (tmp___2 != 0L) {
#line 537
    tmp = __get_page_tail(page);
#line 537
    tmp___0 = ldv__builtin_expect((long )tmp, 1L);
#line 537
    if (tmp___0 != 0L) {
#line 538
      return;
    } else {

    }
  } else {

  }
#line 543
  tmp___3 = atomic_read((atomic_t const   *)(& page->__annonCompField42.__annonCompField41.__annonCompField40._count));
#line 543
  tmp___4 = ldv__builtin_expect(tmp___3 <= 0, 0L);
#line 543
  if (tmp___4 != 0L) {
#line 543
    dump_page(page, "VM_BUG_ON_PAGE(atomic_read(&page->_count) <= 0)");
#line 543
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/mm.h"),
                         "i" (543), "i" (12UL));
    ldv_21681: ;
#line 543
    goto ldv_21681;
  } else {

  }
#line 544
  atomic_inc(& page->__annonCompField42.__annonCompField41.__annonCompField40._count);
#line 545
  return;
}
}
#line 120 "include/linux/scatterlist.h"
__inline static struct page *sg_page___0(struct scatterlist *sg ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 123
  tmp = ldv__builtin_expect(sg->sg_magic != 2271560481UL, 0L);
#line 123
  if (tmp != 0L) {
#line 123
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (123), "i" (12UL));
    ldv_23237: ;
#line 123
    goto ldv_23237;
  } else {

  }
#line 124
  tmp___0 = ldv__builtin_expect((long )((int )sg->page_link) & 1L, 0L);
#line 124
  if (tmp___0 != 0L) {
#line 124
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (124), "i" (12UL));
    ldv_23238: ;
#line 124
    goto ldv_23238;
  } else {

  }
#line 126
  return ((struct page *)(sg->page_link & 0xfffffffffffffffcUL));
}
}
#line 1075 "include/linux/device.h"
extern void dev_printk(char const   * , struct device  const  * , char const   * 
                       , ...) ;
#line 37 "include/linux/mempool.h"
void *ldv_mempool_alloc_386(mempool_t *ldv_func_arg1 , gfp_t flags ) ;
#line 30 "include/scsi/scsi_common.h"
extern void int_to_scsilun(u64  , struct scsi_lun * ) ;
#line 310 "include/scsi/scsi_device.h"
__inline static struct scsi_target *scsi_target(struct scsi_device *sdev ) 
{ 
  struct device  const  *__mptr ;

  {
#line 312
  __mptr = (struct device  const  *)sdev->sdev_gendev.parent;
#line 312
  return ((struct scsi_target *)__mptr + 0xffffffffffffffd8UL);
}
}
#line 379
extern int scsi_change_queue_depth(struct scsi_device * , int  ) ;
#line 456 "include/scsi/scsi_device.h"
__inline static unsigned int sdev_id(struct scsi_device *sdev ) 
{ 


  {
#line 458
  return (sdev->id);
}
}
#line 171 "include/scsi/scsi_cmnd.h"
__inline static unsigned int scsi_sg_count(struct scsi_cmnd *cmd ) 
{ 


  {
#line 173
  return (cmd->sdb.table.nents);
}
}
#line 176 "include/scsi/scsi_cmnd.h"
__inline static struct scatterlist *scsi_sglist(struct scsi_cmnd *cmd ) 
{ 


  {
#line 178
  return (cmd->sdb.table.sgl);
}
}
#line 181 "include/scsi/scsi_cmnd.h"
__inline static unsigned int scsi_bufflen(struct scsi_cmnd *cmd ) 
{ 


  {
#line 183
  return (cmd->sdb.length);
}
}
#line 235 "include/linux/skbuff.h"
__inline static void skb_frag_size_set(skb_frag_t *frag , unsigned int size ) 
{ 


  {
#line 237
  frag->size = size;
#line 238
  return;
}
}
#line 849
struct sk_buff *ldv_skb_clone_377(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 853
struct sk_buff *ldv_skb_clone_385(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 858
struct sk_buff *ldv_skb_copy_379(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 871
int ldv_pskb_expand_head_375(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 875
int ldv_pskb_expand_head_383(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 879
int ldv_pskb_expand_head_384(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 976 "include/linux/skbuff.h"
__inline static unsigned char *skb_end_pointer(struct sk_buff  const  *skb ) 
{ 


  {
#line 978
  return ((unsigned char *)skb->head + (unsigned long )skb->end);
}
}
#line 1599 "include/linux/skbuff.h"
__inline static void __skb_fill_page_desc(struct sk_buff *skb , int i , struct page *page ,
                                          int off , int size ) 
{ 
  skb_frag_t *frag ;
  unsigned char *tmp ;

  {
#line 1602
  tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1602
  frag = (skb_frag_t *)(& ((struct skb_shared_info *)tmp)->frags) + (unsigned long )i;
#line 1613
  frag->page.p = page;
#line 1614
  frag->page_offset = (__u32 )off;
#line 1615
  skb_frag_size_set(frag, (unsigned int )size);
#line 1617
  page = compound_head(page);
#line 1618
  if ((int )page->__annonCompField42.__annonCompField37.pfmemalloc && (unsigned long )page->__annonCompField36.mapping == (unsigned long )((struct address_space *)0)) {
#line 1619
    skb->pfmemalloc = 1U;
  } else {

  }
#line 1620
  return;
}
}
#line 1636 "include/linux/skbuff.h"
__inline static void skb_fill_page_desc(struct sk_buff *skb , int i , struct page *page ,
                                        int off , int size ) 
{ 
  unsigned char *tmp ;

  {
#line 1639
  __skb_fill_page_desc(skb, i, page, off, size);
#line 1640
  tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1640
  ((struct skb_shared_info *)tmp)->nr_frags = (unsigned int )((unsigned char )i) + 1U;
#line 1641
  return;
}
}
#line 2148
struct sk_buff *ldv___netdev_alloc_skb_380(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2152
struct sk_buff *ldv___netdev_alloc_skb_381(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2156
struct sk_buff *ldv___netdev_alloc_skb_382(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 772 "include/scsi/scsi_transport_fc.h"
__inline static int fc_remote_port_chkready(struct fc_rport *rport ) 
{ 
  int result ;

  {
#line 776
  switch ((unsigned int )rport->port_state) {
  case 2U: ;
#line 778
  if ((int )rport->roles & 1) {
#line 779
    result = 0;
  } else
#line 780
  if ((int )rport->flags & 1) {
#line 781
    result = 786432;
  } else {
#line 783
    result = 65536;
  }
#line 784
  goto ldv_39328;
  case 4U: ;
#line 786
  if (((int )rport->flags & 4) != 0) {
#line 787
    result = 983040;
  } else {
#line 789
    result = 786432;
  }
#line 790
  goto ldv_39328;
  default: 
#line 792
  result = 65536;
#line 793
  goto ldv_39328;
  }
  ldv_39328: ;
#line 795
  return (result);
}
}
#line 846
extern int scsi_is_fc_rport(struct device  const  * ) ;
#line 859
extern int fc_block_scsi_eh(struct scsi_cmnd * ) ;
#line 1097 "include/scsi/libfc.h"
int fc_fcp_init(struct fc_lport *lport ) ;
#line 1098
void fc_fcp_destroy(struct fc_lport *lport ) ;
#line 1103
int fc_queuecommand(struct Scsi_Host *shost , struct scsi_cmnd *sc_cmd ) ;
#line 1104
int fc_eh_abort(struct scsi_cmnd *sc_cmd ) ;
#line 1105
int fc_eh_device_reset(struct scsi_cmnd *sc_cmd ) ;
#line 1106
int fc_eh_host_reset(struct scsi_cmnd *sc_cmd ) ;
#line 1107
int fc_slave_alloc(struct scsi_device *sdev ) ;
#line 45 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static struct kmem_cache *scsi_pkt_cachep  ;
#line 93
static void fc_fcp_recv_data(struct fc_fcp_pkt *fsp , struct fc_frame *fp ) ;
#line 94
static void fc_fcp_recv(struct fc_seq *seq , struct fc_frame *fp , void *arg ) ;
#line 95
static void fc_fcp_resp(struct fc_fcp_pkt *fsp , struct fc_frame *fp ) ;
#line 96
static void fc_fcp_complete_locked(struct fc_fcp_pkt *fsp ) ;
#line 97
static void fc_tm_done(struct fc_seq *seq , struct fc_frame *fp , void *arg ) ;
#line 98
static void fc_fcp_error(struct fc_fcp_pkt *fsp , struct fc_frame *fp ) ;
#line 99
static void fc_fcp_recovery(struct fc_fcp_pkt *fsp , u8 code ) ;
#line 100
static void fc_fcp_timeout(unsigned long data ) ;
#line 101
static void fc_fcp_rec(struct fc_fcp_pkt *fsp ) ;
#line 102
static void fc_fcp_rec_error(struct fc_fcp_pkt *fsp , struct fc_frame *fp ) ;
#line 103
static void fc_fcp_rec_resp(struct fc_seq *seq , struct fc_frame *fp , void *arg ) ;
#line 104
static void fc_io_compl(struct fc_fcp_pkt *fsp ) ;
#line 106
static void fc_fcp_srr(struct fc_fcp_pkt *fsp , enum fc_rctl r_ctl , u32 offset ) ;
#line 107
static void fc_fcp_srr_resp(struct fc_seq *seq , struct fc_frame *fp , void *arg ) ;
#line 108
static void fc_fcp_srr_error(struct fc_fcp_pkt *fsp , struct fc_frame *fp ) ;
#line 146 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static struct fc_fcp_pkt *fc_fcp_pkt_alloc(struct fc_lport *lport , gfp_t gfp ) 
{ 
  struct fc_fcp_internal *si ;
  struct fc_fcp_pkt *fsp ;
  void *tmp ;
  struct lock_class_key __key ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  int pscr_ret__ ;
  void const   *__vpp_verify___0 ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 148
  si = (struct fc_fcp_internal *)lport->scsi_priv;
#line 151
  tmp = ldv_mempool_alloc_386(si->scsi_pkt_pool, gfp);
#line 151
  fsp = (struct fc_fcp_pkt *)tmp;
#line 152
  if ((unsigned long )fsp != (unsigned long )((struct fc_fcp_pkt *)0)) {
#line 153
    memset((void *)fsp, 0, 448UL);
#line 154
    fsp->lp = lport;
#line 155
    fsp->xfer_ddp = 65535U;
#line 156
    atomic_set(& fsp->ref_cnt, 1);
#line 157
    reg_timer_8(& fsp->timer);
#line 158
    fsp->timer.data = (unsigned long )fsp;
#line 159
    INIT_LIST_HEAD(& fsp->list);
#line 160
    spinlock_check(& fsp->scsi_pkt_lock);
#line 160
    __raw_spin_lock_init(& fsp->scsi_pkt_lock.__annonCompField18.rlock, "&(&fsp->scsi_pkt_lock)->rlock",
                         & __key);
  } else {
#line 162
    __vpp_verify = (void const   *)0;
#line 162
    __asm__  ("": "=r" (__ptr): "0" (lport->stats));
#line 162
    __preempt_count_add(1);
#line 162
    __asm__  volatile   ("": : : "memory");
#line 162
    __vpp_verify___0 = (void const   *)0;
#line 162
    switch (4UL) {
    case 1UL: ;
#line 162
    switch (4UL) {
    case 1UL: 
#line 162
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 162
    goto ldv_41311;
    case 2UL: 
#line 162
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 162
    goto ldv_41311;
    case 4UL: 
#line 162
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 162
    goto ldv_41311;
    case 8UL: 
#line 162
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 162
    goto ldv_41311;
    default: 
#line 162
    __bad_percpu_size();
    }
    ldv_41311: 
#line 162
    pscr_ret__ = pfo_ret__;
#line 162
    goto ldv_41317;
    case 2UL: ;
#line 162
    switch (4UL) {
    case 1UL: 
#line 162
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 162
    goto ldv_41321;
    case 2UL: 
#line 162
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 162
    goto ldv_41321;
    case 4UL: 
#line 162
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 162
    goto ldv_41321;
    case 8UL: 
#line 162
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 162
    goto ldv_41321;
    default: 
#line 162
    __bad_percpu_size();
    }
    ldv_41321: 
#line 162
    pscr_ret__ = pfo_ret_____0;
#line 162
    goto ldv_41317;
    case 4UL: ;
#line 162
    switch (4UL) {
    case 1UL: 
#line 162
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 162
    goto ldv_41330;
    case 2UL: 
#line 162
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 162
    goto ldv_41330;
    case 4UL: 
#line 162
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 162
    goto ldv_41330;
    case 8UL: 
#line 162
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 162
    goto ldv_41330;
    default: 
#line 162
    __bad_percpu_size();
    }
    ldv_41330: 
#line 162
    pscr_ret__ = pfo_ret_____1;
#line 162
    goto ldv_41317;
    case 8UL: ;
#line 162
    switch (4UL) {
    case 1UL: 
#line 162
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 162
    goto ldv_41339;
    case 2UL: 
#line 162
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 162
    goto ldv_41339;
    case 4UL: 
#line 162
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 162
    goto ldv_41339;
    case 8UL: 
#line 162
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 162
    goto ldv_41339;
    default: 
#line 162
    __bad_percpu_size();
    }
    ldv_41339: 
#line 162
    pscr_ret__ = pfo_ret_____2;
#line 162
    goto ldv_41317;
    default: 
#line 162
    __bad_size_call_parameter();
#line 162
    goto ldv_41317;
    }
    ldv_41317: 
#line 162
    ((struct fc_stats *)(__per_cpu_offset[pscr_ret__] + __ptr))->FcpPktAllocFails = ((struct fc_stats *)(__per_cpu_offset[pscr_ret__] + __ptr))->FcpPktAllocFails + 1ULL;
#line 163
    __asm__  volatile   ("": : : "memory");
#line 163
    __preempt_count_sub(1);
  }
#line 165
  return (fsp);
}
}
#line 175 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_pkt_release(struct fc_fcp_pkt *fsp ) 
{ 
  struct fc_fcp_internal *si ;
  int tmp ;

  {
#line 177
  tmp = atomic_dec_and_test(& fsp->ref_cnt);
#line 177
  if (tmp != 0) {
#line 178
    si = (struct fc_fcp_internal *)(fsp->lp)->scsi_priv;
#line 180
    mempool_free((void *)fsp, si->scsi_pkt_pool);
  } else {

  }
#line 182
  return;
}
}
#line 188 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_pkt_hold(struct fc_fcp_pkt *fsp ) 
{ 


  {
#line 190
  atomic_inc(& fsp->ref_cnt);
#line 191
  return;
}
}
#line 204 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_pkt_destroy(struct fc_seq *seq , void *fsp ) 
{ 


  {
#line 206
  fc_fcp_pkt_release((struct fc_fcp_pkt *)fsp);
#line 207
  return;
}
}
#line 226 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
__inline static int fc_fcp_lock_pkt(struct fc_fcp_pkt *fsp ) 
{ 


  {
#line 228
  spin_lock_bh(& fsp->scsi_pkt_lock);
#line 229
  if (((int )fsp->state & 32) != 0) {
#line 230
    spin_unlock_bh(& fsp->scsi_pkt_lock);
#line 231
    return (-1);
  } else {

  }
#line 234
  fc_fcp_pkt_hold(fsp);
#line 235
  return (0);
}
}
#line 243 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
__inline static void fc_fcp_unlock_pkt(struct fc_fcp_pkt *fsp ) 
{ 


  {
#line 245
  spin_unlock_bh(& fsp->scsi_pkt_lock);
#line 246
  fc_fcp_pkt_release(fsp);
#line 247
  return;
}
}
#line 254 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_timer_set(struct fc_fcp_pkt *fsp , unsigned long delay ) 
{ 


  {
#line 256
  if (((int )fsp->state & 32) == 0) {
#line 257
    ldv_mod_timer_387(& fsp->timer, (unsigned long )jiffies + delay);
  } else {

  }
#line 258
  return;
}
}
#line 265 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static int fc_fcp_send_abort(struct fc_fcp_pkt *fsp ) 
{ 
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  int pscr_ret__ ;
  void const   *__vpp_verify___0 ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp ;

  {
#line 267
  if ((unsigned long )fsp->seq_ptr == (unsigned long )((struct fc_seq *)0)) {
#line 268
    return (-22);
  } else {

  }
#line 270
  __vpp_verify = (void const   *)0;
#line 270
  __asm__  ("": "=r" (__ptr): "0" ((fsp->lp)->stats));
#line 270
  __preempt_count_add(1);
#line 270
  __asm__  volatile   ("": : : "memory");
#line 270
  __vpp_verify___0 = (void const   *)0;
#line 270
  switch (4UL) {
  case 1UL: ;
#line 270
  switch (4UL) {
  case 1UL: 
#line 270
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 270
  goto ldv_41381;
  case 2UL: 
#line 270
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 270
  goto ldv_41381;
  case 4UL: 
#line 270
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 270
  goto ldv_41381;
  case 8UL: 
#line 270
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 270
  goto ldv_41381;
  default: 
#line 270
  __bad_percpu_size();
  }
  ldv_41381: 
#line 270
  pscr_ret__ = pfo_ret__;
#line 270
  goto ldv_41387;
  case 2UL: ;
#line 270
  switch (4UL) {
  case 1UL: 
#line 270
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 270
  goto ldv_41391;
  case 2UL: 
#line 270
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 270
  goto ldv_41391;
  case 4UL: 
#line 270
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 270
  goto ldv_41391;
  case 8UL: 
#line 270
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 270
  goto ldv_41391;
  default: 
#line 270
  __bad_percpu_size();
  }
  ldv_41391: 
#line 270
  pscr_ret__ = pfo_ret_____0;
#line 270
  goto ldv_41387;
  case 4UL: ;
#line 270
  switch (4UL) {
  case 1UL: 
#line 270
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 270
  goto ldv_41400;
  case 2UL: 
#line 270
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 270
  goto ldv_41400;
  case 4UL: 
#line 270
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 270
  goto ldv_41400;
  case 8UL: 
#line 270
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 270
  goto ldv_41400;
  default: 
#line 270
  __bad_percpu_size();
  }
  ldv_41400: 
#line 270
  pscr_ret__ = pfo_ret_____1;
#line 270
  goto ldv_41387;
  case 8UL: ;
#line 270
  switch (4UL) {
  case 1UL: 
#line 270
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 270
  goto ldv_41409;
  case 2UL: 
#line 270
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 270
  goto ldv_41409;
  case 4UL: 
#line 270
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 270
  goto ldv_41409;
  case 8UL: 
#line 270
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 270
  goto ldv_41409;
  default: 
#line 270
  __bad_percpu_size();
  }
  ldv_41409: 
#line 270
  pscr_ret__ = pfo_ret_____2;
#line 270
  goto ldv_41387;
  default: 
#line 270
  __bad_size_call_parameter();
#line 270
  goto ldv_41387;
  }
  ldv_41387: 
#line 270
  ((struct fc_stats *)(__per_cpu_offset[pscr_ret__] + __ptr))->FcpPktAborts = ((struct fc_stats *)(__per_cpu_offset[pscr_ret__] + __ptr))->FcpPktAborts + 1ULL;
#line 271
  __asm__  volatile   ("": : : "memory");
#line 271
  __preempt_count_sub(1);
#line 273
  fsp->state = (u8 )((unsigned int )fsp->state | 4U);
#line 274
  tmp = (*((fsp->lp)->tt.seq_exch_abort))((struct fc_seq  const  *)fsp->seq_ptr, 0U);
#line 274
  return (tmp);
}
}
#line 286 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_retry_cmd(struct fc_fcp_pkt *fsp ) 
{ 


  {
#line 288
  if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 289
    (*((fsp->lp)->tt.exch_done))(fsp->seq_ptr);
#line 290
    fsp->seq_ptr = (struct fc_seq *)0;
  } else {

  }
#line 293
  fsp->state = (unsigned int )fsp->state & 251U;
#line 294
  fsp->io_status = 0U;
#line 295
  fsp->status_code = 8U;
#line 296
  fc_fcp_complete_locked(fsp);
#line 297
  return;
}
}
#line 304 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
void fc_fcp_ddp_setup(struct fc_fcp_pkt *fsp , u16 xid ) 
{ 
  struct fc_lport *lport ;
  unsigned int tmp ;
  struct scatterlist *tmp___0 ;
  int tmp___1 ;

  {
#line 308
  lport = fsp->lp;
#line 309
  if (((fsp->req_flags & 2U) != 0U && (unsigned int )*((unsigned char *)lport + 1144UL) != 0U) && (unsigned long )lport->tt.ddp_setup != (unsigned long )((int (*)(struct fc_lport * ,
                                                                                                                                                                   u16  ,
                                                                                                                                                                   struct scatterlist * ,
                                                                                                                                                                   unsigned int  ))0)) {
#line 311
    tmp = scsi_sg_count(fsp->cmd);
#line 311
    tmp___0 = scsi_sglist(fsp->cmd);
#line 311
    tmp___1 = (*(lport->tt.ddp_setup))(lport, (int )xid, tmp___0, tmp);
#line 311
    if (tmp___1 != 0) {
#line 313
      fsp->xfer_ddp = xid;
    } else {

    }
  } else {

  }
#line 314
  return;
}
}
#line 322 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
void fc_fcp_ddp_done(struct fc_fcp_pkt *fsp ) 
{ 
  struct fc_lport *lport ;
  int tmp ;

  {
#line 326
  if ((unsigned long )fsp == (unsigned long )((struct fc_fcp_pkt *)0)) {
#line 327
    return;
  } else {

  }
#line 329
  if ((unsigned int )fsp->xfer_ddp == 65535U) {
#line 330
    return;
  } else {

  }
#line 332
  lport = fsp->lp;
#line 333
  if ((unsigned long )lport->tt.ddp_done != (unsigned long )((int (*)(struct fc_lport * ,
                                                                      u16  ))0)) {
#line 334
    tmp = (*(lport->tt.ddp_done))(lport, (int )fsp->xfer_ddp);
#line 334
    fsp->xfer_len = (size_t )tmp;
#line 335
    fsp->xfer_ddp = 65535U;
  } else {

  }
#line 337
  return;
}
}
#line 343 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_can_queue_ramp_up(struct fc_lport *lport ) 
{ 
  struct fc_fcp_internal *si ;
  unsigned long flags ;
  int can_queue ;

  {
#line 345
  si = (struct fc_fcp_internal *)lport->scsi_priv;
#line 349
  ldv_spin_lock();
#line 352
  if (si->last_can_queue_ramp_up_time != 0UL && (long )(((unsigned long )jiffies - si->last_can_queue_ramp_up_time) - 15000UL) < 0L) {
#line 354
    goto unlock;
  } else {

  }
#line 356
  if ((long )(((unsigned long )jiffies - si->last_can_queue_ramp_down_time) - 15000UL) < 0L) {
#line 358
    goto unlock;
  } else {

  }
#line 360
  si->last_can_queue_ramp_up_time = jiffies;
#line 362
  can_queue = (lport->host)->can_queue << 1;
#line 363
  if (si->max_can_queue <= can_queue) {
#line 364
    can_queue = si->max_can_queue;
#line 365
    si->last_can_queue_ramp_down_time = 0UL;
  } else {

  }
#line 367
  (lport->host)->can_queue = can_queue;
#line 368
  dev_printk("\v", (struct device  const  *)(& (lport->host)->shost_gendev), "libfc: increased can_queue to %d.\n",
             can_queue);
  unlock: 
#line 372
  spin_unlock_irqrestore((lport->host)->host_lock, flags);
#line 373
  return;
}
}
#line 385 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_can_queue_ramp_down(struct fc_lport *lport ) 
{ 
  struct fc_fcp_internal *si ;
  unsigned long flags ;
  int can_queue ;

  {
#line 387
  si = (struct fc_fcp_internal *)lport->scsi_priv;
#line 391
  ldv_spin_lock();
#line 394
  if (si->last_can_queue_ramp_down_time != 0UL && (long )(((unsigned long )jiffies - si->last_can_queue_ramp_down_time) - 15000UL) < 0L) {
#line 396
    goto unlock;
  } else {

  }
#line 398
  si->last_can_queue_ramp_down_time = jiffies;
#line 400
  can_queue = (lport->host)->can_queue;
#line 401
  can_queue = can_queue >> 1;
#line 402
  if (can_queue == 0) {
#line 403
    can_queue = 1;
  } else {

  }
#line 404
  (lport->host)->can_queue = can_queue;
#line 405
  dev_printk("\v", (struct device  const  *)(& (lport->host)->shost_gendev), "libfc: Could not allocate frame.\nReducing can_queue to %d.\n",
             can_queue);
  unlock: 
#line 409
  spin_unlock_irqrestore((lport->host)->host_lock, flags);
#line 410
  return;
}
}
#line 420 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
__inline static struct fc_frame *fc_fcp_frame_alloc(struct fc_lport *lport , size_t len ) 
{ 
  struct fc_frame *fp ;
  long tmp ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  int pscr_ret__ ;
  void const   *__vpp_verify___0 ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 425
  fp = fc_frame_alloc(lport, len);
#line 426
  tmp = ldv__builtin_expect((unsigned long )fp != (unsigned long )((struct fc_frame *)0),
                         1L);
#line 426
  if (tmp != 0L) {
#line 427
    return (fp);
  } else {

  }
#line 429
  __vpp_verify = (void const   *)0;
#line 429
  __asm__  ("": "=r" (__ptr): "0" (lport->stats));
#line 429
  __preempt_count_add(1);
#line 429
  __asm__  volatile   ("": : : "memory");
#line 429
  __vpp_verify___0 = (void const   *)0;
#line 429
  switch (4UL) {
  case 1UL: ;
#line 429
  switch (4UL) {
  case 1UL: 
#line 429
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 429
  goto ldv_41476;
  case 2UL: 
#line 429
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 429
  goto ldv_41476;
  case 4UL: 
#line 429
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 429
  goto ldv_41476;
  case 8UL: 
#line 429
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 429
  goto ldv_41476;
  default: 
#line 429
  __bad_percpu_size();
  }
  ldv_41476: 
#line 429
  pscr_ret__ = pfo_ret__;
#line 429
  goto ldv_41482;
  case 2UL: ;
#line 429
  switch (4UL) {
  case 1UL: 
#line 429
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 429
  goto ldv_41486;
  case 2UL: 
#line 429
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 429
  goto ldv_41486;
  case 4UL: 
#line 429
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 429
  goto ldv_41486;
  case 8UL: 
#line 429
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 429
  goto ldv_41486;
  default: 
#line 429
  __bad_percpu_size();
  }
  ldv_41486: 
#line 429
  pscr_ret__ = pfo_ret_____0;
#line 429
  goto ldv_41482;
  case 4UL: ;
#line 429
  switch (4UL) {
  case 1UL: 
#line 429
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 429
  goto ldv_41495;
  case 2UL: 
#line 429
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 429
  goto ldv_41495;
  case 4UL: 
#line 429
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 429
  goto ldv_41495;
  case 8UL: 
#line 429
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 429
  goto ldv_41495;
  default: 
#line 429
  __bad_percpu_size();
  }
  ldv_41495: 
#line 429
  pscr_ret__ = pfo_ret_____1;
#line 429
  goto ldv_41482;
  case 8UL: ;
#line 429
  switch (4UL) {
  case 1UL: 
#line 429
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 429
  goto ldv_41504;
  case 2UL: 
#line 429
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 429
  goto ldv_41504;
  case 4UL: 
#line 429
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 429
  goto ldv_41504;
  case 8UL: 
#line 429
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 429
  goto ldv_41504;
  default: 
#line 429
  __bad_percpu_size();
  }
  ldv_41504: 
#line 429
  pscr_ret__ = pfo_ret_____2;
#line 429
  goto ldv_41482;
  default: 
#line 429
  __bad_size_call_parameter();
#line 429
  goto ldv_41482;
  }
  ldv_41482: 
#line 429
  ((struct fc_stats *)(__per_cpu_offset[pscr_ret__] + __ptr))->FcpFrameAllocFails = ((struct fc_stats *)(__per_cpu_offset[pscr_ret__] + __ptr))->FcpFrameAllocFails + 1ULL;
#line 430
  __asm__  volatile   ("": : : "memory");
#line 430
  __preempt_count_sub(1);
#line 432
  fc_fcp_can_queue_ramp_down(lport);
#line 433
  return ((struct fc_frame *)0);
}
}
#line 441 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_recv_data(struct fc_fcp_pkt *fsp , struct fc_frame *fp ) 
{ 
  struct scsi_cmnd *sc ;
  struct fc_lport *lport ;
  struct fc_stats *stats ;
  struct fc_frame_header *fh ;
  size_t start_offset ;
  size_t offset ;
  u32 crc ;
  u32 copy_len ;
  size_t len ;
  void *buf ;
  struct scatterlist *sg ;
  u32 nents ;
  u8 host_bcode ;
  __u32 tmp ;
  struct fc_exch *_ep ;
  struct fc_seq  const  *__mptr ;
  long tmp___0 ;
  u32 tmp___1 ;
  struct fc_exch *_ep___0 ;
  struct fc_seq  const  *__mptr___0 ;
  long tmp___2 ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  int pscr_ret__ ;
  void const   *__vpp_verify___0 ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  u64 tmp___3 ;
  long tmp___4 ;

  {
#line 443
  sc = fsp->cmd;
#line 444
  lport = fsp->lp;
#line 450
  copy_len = 0U;
#line 455
  host_bcode = 0U;
#line 457
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 458
  tmp = __fswab32(fh->fh_parm_offset);
#line 458
  offset = (size_t )tmp;
#line 459
  start_offset = offset;
#line 460
  len = (unsigned long )fp->skb.len - 24UL;
#line 461
  buf = fc_frame_payload_get((struct fc_frame  const  *)fp, 0UL);
#line 470
  if ((unsigned int )fsp->xfer_ddp != 65535U) {
#line 471
    fc_fcp_ddp_done(fsp);
#line 472
    tmp___0 = ldv__builtin_expect((fc_debug_logging & 16U) != 0U, 0L);
#line 472
    if (tmp___0 != 0L) {
#line 472
      if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 472
        _ep = (struct fc_exch *)0;
#line 472
        __mptr = (struct fc_seq  const  *)fsp->seq_ptr;
#line 472
        _ep = (struct fc_exch *)__mptr + 0xffffffffffffff64UL;
#line 472
        printk("\016host%u: fcp: %6.6x: xid %04x-%04x: DDP I/O in fc_fcp_recv_data set OLD_ERROR\n",
               ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )_ep->oxid,
               (int )_ep->rxid);
      } else {
#line 472
        printk("\016host%u: fcp: %6.6x: DDP I/O in fc_fcp_recv_data set OLD_ERROR\n",
               ((fsp->lp)->host)->host_no, (fsp->rport)->port_id);
      }
    } else {

    }
#line 473
    host_bcode = 8U;
#line 474
    goto err;
  } else {

  }
#line 476
  if (offset + len > (size_t )fsp->data_len) {
#line 478
    if ((int )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_flags & 1) {
#line 478
      tmp___1 = fc_frame_crc_check(fp);
#line 478
      if (tmp___1 != 0U) {
#line 480
        goto crc_err;
      } else {

      }
    } else {

    }
#line 481
    tmp___2 = ldv__builtin_expect((fc_debug_logging & 16U) != 0U, 0L);
#line 481
    if (tmp___2 != 0L) {
#line 481
      if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 481
        _ep___0 = (struct fc_exch *)0;
#line 481
        __mptr___0 = (struct fc_seq  const  *)fsp->seq_ptr;
#line 481
        _ep___0 = (struct fc_exch *)__mptr___0 + 0xffffffffffffff64UL;
#line 481
        printk("\016host%u: fcp: %6.6x: xid %04x-%04x: data received past end. len %zx offset %zx data_len %x\n",
               ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )_ep___0->oxid,
               (int )_ep___0->rxid, len, offset, fsp->data_len);
      } else {
#line 481
        printk("\016host%u: fcp: %6.6x: data received past end. len %zx offset %zx data_len %x\n",
               ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, len, offset, fsp->data_len);
      }
    } else {

    }
#line 485
    host_bcode = 6U;
#line 486
    goto err;
  } else {

  }
#line 488
  if (fsp->xfer_len != offset) {
#line 489
    fsp->state = (u8 )((unsigned int )fsp->state | 16U);
  } else {

  }
#line 491
  sg = scsi_sglist(sc);
#line 492
  nents = scsi_sg_count(sc);
#line 494
  if (((int )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_flags & 1) == 0) {
#line 495
    copy_len = fc_copy_buffer_to_sglist(buf, len, sg, & nents, & offset, (u32 *)0U);
  } else {
#line 498
    crc = crc32_le(4294967295U, (unsigned char const   *)fh, 24UL);
#line 499
    copy_len = fc_copy_buffer_to_sglist(buf, len, sg, & nents, & offset, & crc);
#line 501
    buf = fc_frame_payload_get((struct fc_frame  const  *)fp, 0UL);
#line 502
    if ((len & 3UL) != 0UL) {
#line 503
      crc = crc32_le(crc, (unsigned char const   *)(buf + len), 4UL - (len & 3UL));
    } else {

    }
#line 505
    if (~ crc != ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_crc) {
      crc_err: 
#line 507
      __vpp_verify = (void const   *)0;
#line 507
      __asm__  ("": "=r" (__ptr): "0" (lport->stats));
#line 507
      __preempt_count_add(1);
#line 507
      __asm__  volatile   ("": : : "memory");
#line 507
      __vpp_verify___0 = (void const   *)0;
#line 507
      switch (4UL) {
      case 1UL: ;
#line 507
      switch (4UL) {
      case 1UL: 
#line 507
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 507
      goto ldv_41547;
      case 2UL: 
#line 507
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 507
      goto ldv_41547;
      case 4UL: 
#line 507
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 507
      goto ldv_41547;
      case 8UL: 
#line 507
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 507
      goto ldv_41547;
      default: 
#line 507
      __bad_percpu_size();
      }
      ldv_41547: 
#line 507
      pscr_ret__ = pfo_ret__;
#line 507
      goto ldv_41553;
      case 2UL: ;
#line 507
      switch (4UL) {
      case 1UL: 
#line 507
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 507
      goto ldv_41557;
      case 2UL: 
#line 507
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 507
      goto ldv_41557;
      case 4UL: 
#line 507
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 507
      goto ldv_41557;
      case 8UL: 
#line 507
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 507
      goto ldv_41557;
      default: 
#line 507
      __bad_percpu_size();
      }
      ldv_41557: 
#line 507
      pscr_ret__ = pfo_ret_____0;
#line 507
      goto ldv_41553;
      case 4UL: ;
#line 507
      switch (4UL) {
      case 1UL: 
#line 507
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 507
      goto ldv_41566;
      case 2UL: 
#line 507
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 507
      goto ldv_41566;
      case 4UL: 
#line 507
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 507
      goto ldv_41566;
      case 8UL: 
#line 507
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 507
      goto ldv_41566;
      default: 
#line 507
      __bad_percpu_size();
      }
      ldv_41566: 
#line 507
      pscr_ret__ = pfo_ret_____1;
#line 507
      goto ldv_41553;
      case 8UL: ;
#line 507
      switch (4UL) {
      case 1UL: 
#line 507
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 507
      goto ldv_41575;
      case 2UL: 
#line 507
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 507
      goto ldv_41575;
      case 4UL: 
#line 507
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 507
      goto ldv_41575;
      case 8UL: 
#line 507
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 507
      goto ldv_41575;
      default: 
#line 507
      __bad_percpu_size();
      }
      ldv_41575: 
#line 507
      pscr_ret__ = pfo_ret_____2;
#line 507
      goto ldv_41553;
      default: 
#line 507
      __bad_size_call_parameter();
#line 507
      goto ldv_41553;
      }
      ldv_41553: 
#line 507
      stats = (struct fc_stats *)(__per_cpu_offset[pscr_ret__] + __ptr);
#line 508
      stats->ErrorFrames = stats->ErrorFrames + 1ULL;
#line 510
      tmp___3 = stats->InvalidCRCCount;
#line 510
      stats->InvalidCRCCount = stats->InvalidCRCCount + 1ULL;
#line 510
      if (tmp___3 <= 4ULL) {
#line 511
        printk("\flibfc: CRC error on data frame for port (%6.6x)\n", lport->port_id);
      } else {

      }
#line 514
      __asm__  volatile   ("": : : "memory");
#line 514
      __preempt_count_sub(1);
#line 522
      if (((int )fsp->state & 16) != 0) {
#line 523
        host_bcode = 10U;
#line 524
        goto err;
      } else {

      }
#line 526
      return;
    } else {

    }
  }
#line 530
  if ((size_t )fsp->xfer_contig_end == start_offset) {
#line 531
    fsp->xfer_contig_end = fsp->xfer_contig_end + copy_len;
  } else {

  }
#line 532
  fsp->xfer_len = fsp->xfer_len + (size_t )copy_len;
#line 538
  tmp___4 = ldv__builtin_expect(((int )fsp->state & 2) != 0, 0L);
#line 538
  if (tmp___4 != 0L && fsp->xfer_len == (size_t )(fsp->data_len - fsp->scsi_resid)) {
#line 540
    fc_fcp_complete_locked(fsp);
  } else {

  }
#line 541
  return;
  err: 
#line 543
  fc_fcp_recovery(fsp, (int )host_bcode);
#line 544
  return;
}
}
#line 559 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static int fc_fcp_send_data(struct fc_fcp_pkt *fsp , struct fc_seq *seq , size_t offset ,
                            size_t seq_blen ) 
{ 
  struct fc_exch *ep ;
  struct scsi_cmnd *sc ;
  struct scatterlist *sg ;
  struct fc_frame *fp ;
  struct fc_lport *lport ;
  struct page *page ;
  size_t remaining ;
  size_t t_blen ;
  size_t tlen ;
  size_t sg_bytes ;
  size_t frame_offset ;
  size_t fh_parm_offset ;
  size_t off ;
  int error ;
  void *data ;
  void *page_addr ;
  int using_sg ;
  u32 f_ctl ;
  int __ret_warn_on ;
  long tmp ;
  struct fc_exch *_ep ;
  struct fc_seq  const  *__mptr ;
  long tmp___0 ;
  struct fc_exch *_ep___0 ;
  struct fc_seq  const  *__mptr___0 ;
  long tmp___1 ;
  long tmp___2 ;
  size_t _min1 ;
  unsigned long _min2 ;
  struct fc_exch *_ep___1 ;
  struct fc_seq  const  *__mptr___1 ;
  long tmp___3 ;
  int __ret_warn_on___0 ;
  long tmp___4 ;
  size_t _min1___0 ;
  size_t _min2___0 ;
  struct fc_frame_header *tmp___5 ;
  size_t _min1___1 ;
  size_t _min2___1 ;
  size_t _min1___2 ;
  unsigned long _min2___2 ;
  struct page *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  struct fc_seq  const  *__mptr___2 ;
  int __ret_warn_on___1 ;
  long tmp___9 ;

  {
#line 565
  fp = (struct fc_frame *)0;
#line 566
  lport = fsp->lp;
#line 575
  data = (void *)0;
#line 577
  using_sg = (int )lport->sg_supp;
#line 580
  __ret_warn_on = seq_blen == 0UL;
#line 580
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 580
  if (tmp != 0L) {
#line 580
    warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c",
                       580);
  } else {

  }
#line 580
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 581
  tmp___2 = ldv__builtin_expect(offset + seq_blen > (size_t )fsp->data_len, 0L);
#line 581
  if (tmp___2 != 0L) {
#line 583
    tmp___0 = ldv__builtin_expect((fc_debug_logging & 16U) != 0U, 0L);
#line 583
    if (tmp___0 != 0L) {
#line 583
      if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 583
        _ep = (struct fc_exch *)0;
#line 583
        __mptr = (struct fc_seq  const  *)fsp->seq_ptr;
#line 583
        _ep = (struct fc_exch *)__mptr + 0xffffffffffffff64UL;
#line 583
        printk("\016host%u: fcp: %6.6x: xid %04x-%04x: xfer-ready past end. seq_blen %zx offset %zx\n",
               ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )_ep->oxid,
               (int )_ep->rxid, seq_blen, offset);
      } else {
#line 583
        printk("\016host%u: fcp: %6.6x: xfer-ready past end. seq_blen %zx offset %zx\n",
               ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, seq_blen, offset);
      }
    } else {

    }
#line 585
    fc_fcp_send_abort(fsp);
#line 586
    return (0);
  } else
#line 587
  if (fsp->xfer_len != offset) {
#line 589
    tmp___1 = ldv__builtin_expect((fc_debug_logging & 16U) != 0U, 0L);
#line 589
    if (tmp___1 != 0L) {
#line 589
      if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 589
        _ep___0 = (struct fc_exch *)0;
#line 589
        __mptr___0 = (struct fc_seq  const  *)fsp->seq_ptr;
#line 589
        _ep___0 = (struct fc_exch *)__mptr___0 + 0xffffffffffffff64UL;
#line 589
        printk("\016host%u: fcp: %6.6x: xid %04x-%04x: xfer-ready non-contiguous. seq_blen %zx offset %zx\n",
               ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )_ep___0->oxid,
               (int )_ep___0->rxid, seq_blen, offset);
      } else {
#line 589
        printk("\016host%u: fcp: %6.6x: xfer-ready non-contiguous. seq_blen %zx offset %zx\n",
               ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, seq_blen, offset);
      }
    } else {

    }
  } else {

  }
#line 598
  t_blen = (size_t )fsp->max_payload;
#line 599
  if ((unsigned int )*((unsigned char *)lport + 1144UL) != 0U) {
#line 600
    _min1 = seq_blen;
#line 600
    _min2 = (unsigned long )lport->lso_max;
#line 600
    t_blen = _min1 < _min2 ? _min1 : _min2;
#line 601
    tmp___3 = ldv__builtin_expect((fc_debug_logging & 16U) != 0U, 0L);
#line 601
    if (tmp___3 != 0L) {
#line 601
      if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 601
        _ep___1 = (struct fc_exch *)0;
#line 601
        __mptr___1 = (struct fc_seq  const  *)fsp->seq_ptr;
#line 601
        _ep___1 = (struct fc_exch *)__mptr___1 + 0xffffffffffffff64UL;
#line 601
        printk("\016host%u: fcp: %6.6x: xid %04x-%04x: fsp=%p:lso:blen=%zx lso_max=0x%x t_blen=%zx\n",
               ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )_ep___1->oxid,
               (int )_ep___1->rxid, fsp, seq_blen, lport->lso_max, t_blen);
      } else {
#line 601
        printk("\016host%u: fcp: %6.6x: fsp=%p:lso:blen=%zx lso_max=0x%x t_blen=%zx\n",
               ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, fsp, seq_blen, lport->lso_max,
               t_blen);
      }
    } else {

    }
  } else {

  }
#line 605
  if (t_blen > 512UL) {
#line 606
    t_blen = t_blen & 0xfffffffffffffe00UL;
  } else {

  }
#line 607
  sc = fsp->cmd;
#line 609
  remaining = seq_blen;
#line 610
  frame_offset = offset;
#line 610
  fh_parm_offset = frame_offset;
#line 611
  tlen = 0UL;
#line 612
  seq = (*(lport->tt.seq_start_next))(seq);
#line 613
  f_ctl = 8U;
#line 614
  __ret_warn_on___0 = (unsigned long )seq == (unsigned long )((struct fc_seq *)0);
#line 614
  tmp___4 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 614
  if (tmp___4 != 0L) {
#line 614
    warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c",
                       614);
  } else {

  }
#line 614
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 616
  sg = scsi_sglist(sc);
#line 618
  goto ldv_41626;
  ldv_41640: ;
#line 619
  if ((size_t )sg->length <= offset) {
#line 620
    offset = offset - (size_t )sg->length;
#line 621
    sg = sg_next(sg);
#line 622
    goto ldv_41626;
  } else {

  }
#line 624
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 625
    _min1___0 = t_blen;
#line 625
    _min2___0 = remaining;
#line 625
    tlen = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 632
    if ((tlen & 3UL) != 0UL) {
#line 633
      using_sg = 0;
    } else {

    }
#line 634
    fp = fc_frame_alloc(lport, using_sg == 0 ? tlen : 0UL);
#line 635
    if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 636
      return (-12);
    } else {

    }
#line 638
    tmp___5 = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 638
    data = (void *)tmp___5 + 1U;
#line 639
    fh_parm_offset = frame_offset;
#line 640
    ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_max_payload = fsp->max_payload;
  } else {

  }
#line 643
  off = (size_t )sg->offset + offset;
#line 644
  _min1___1 = tlen;
#line 644
  _min2___1 = (size_t )sg->length - offset;
#line 644
  sg_bytes = _min1___1 < _min2___1 ? _min1___1 : _min2___1;
#line 645
  _min1___2 = sg_bytes;
#line 645
  _min2___2 = 4096UL - (off & 4095UL);
#line 645
  sg_bytes = _min1___2 < _min2___2 ? _min1___2 : _min2___2;
#line 647
  tmp___6 = sg_page___0(sg);
#line 647
  page = tmp___6 + (off >> 12);
#line 648
  if (using_sg != 0) {
#line 649
    get_page(page);
#line 650
    tmp___7 = skb_end_pointer((struct sk_buff  const  *)(& fp->skb));
#line 650
    skb_fill_page_desc(& fp->skb, (int )((struct skb_shared_info *)tmp___7)->nr_frags,
                       page, (int )off & 4095, (int )sg_bytes);
#line 653
    fp->skb.data_len = fp->skb.data_len + (unsigned int )sg_bytes;
#line 654
    fp->skb.len = fp->skb.len + (unsigned int )sg_bytes;
#line 655
    fp->skb.truesize = fp->skb.truesize + 4096U;
  } else {
#line 661
    page_addr = kmap_atomic(page);
#line 662
    memcpy(data, (void const   *)page_addr + (off & 4095UL), sg_bytes);
#line 664
    __kunmap_atomic(page_addr);
#line 665
    data = data + sg_bytes;
  }
#line 667
  offset = offset + sg_bytes;
#line 668
  frame_offset = frame_offset + sg_bytes;
#line 669
  tlen = tlen - sg_bytes;
#line 670
  remaining = remaining - sg_bytes;
#line 672
  tmp___8 = skb_end_pointer((struct sk_buff  const  *)(& fp->skb));
#line 672
  if ((unsigned int )((struct skb_shared_info *)tmp___8)->nr_frags <= 15U && tlen != 0UL) {
#line 674
    goto ldv_41626;
  } else {

  }
#line 680
  if (remaining == 0UL) {
#line 681
    f_ctl = f_ctl | 589824U;
  } else {

  }
#line 683
  __mptr___2 = (struct fc_seq  const  *)seq;
#line 683
  ep = (struct fc_exch *)__mptr___2 + 0xffffffffffffff64UL;
#line 684
  fc_fill_fc_hdr(fp, 1, ep->did, ep->sid, 8, f_ctl, (u32 )fh_parm_offset);
#line 690
  error = (*(lport->tt.seq_send))(lport, seq, fp);
#line 691
  if (error != 0) {
#line 692
    __ret_warn_on___1 = 1;
#line 692
    tmp___9 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
#line 692
    if (tmp___9 != 0L) {
#line 692
      warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c",
                         692);
    } else {

    }
#line 692
    ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
#line 693
    return (error);
  } else {

  }
#line 695
  fp = (struct fc_frame *)0;
  ldv_41626: ;
#line 618
  if (remaining != 0UL && (unsigned long )sg != (unsigned long )((struct scatterlist *)0)) {
#line 620
    goto ldv_41640;
  } else {

  }
#line 697
  fsp->xfer_len = fsp->xfer_len + seq_blen;
#line 698
  return (0);
}
}
#line 706 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_abts_resp(struct fc_fcp_pkt *fsp , struct fc_frame *fp ) 
{ 
  int ba_done ;
  struct fc_ba_rjt *brp ;
  struct fc_frame_header *fh ;
  void *tmp ;

  {
#line 708
  ba_done = 1;
#line 712
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 713
  switch ((int )fh->fh_r_ctl) {
  case 132: ;
#line 715
  goto ldv_41650;
  case 133: 
#line 717
  tmp = fc_frame_payload_get((struct fc_frame  const  *)fp, 4UL);
#line 717
  brp = (struct fc_ba_rjt *)tmp;
#line 718
  if ((unsigned long )brp != (unsigned long )((struct fc_ba_rjt *)0) && (unsigned int )brp->br_reason == 3U) {
#line 719
    goto ldv_41650;
  } else {

  }
  default: 
#line 727
  ba_done = 0;
  }
  ldv_41650: ;
#line 730
  if (ba_done != 0) {
#line 731
    fsp->state = (u8 )((unsigned int )fsp->state | 8U);
#line 732
    fsp->state = (unsigned int )fsp->state & 251U;
#line 734
    if (fsp->wait_for_comp != 0) {
#line 735
      complete(& fsp->tm_done);
    } else {
#line 737
      fc_fcp_complete_locked(fsp);
    }
  } else {

  }
#line 739
  return;
}
}
#line 750 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_recv(struct fc_seq *seq , struct fc_frame *fp , void *arg ) 
{ 
  struct fc_fcp_pkt *fsp ;
  struct fc_lport *lport ;
  struct fc_frame_header *fh ;
  struct fcp_txrdy *dd ;
  u8 r_ctl ;
  int rc ;
  bool tmp ;
  int tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;
  void *tmp___2 ;
  int __ret_warn_on___0 ;
  long tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  int __ret_warn_on___1 ;
  long tmp___6 ;
  int __ret_warn_on___2 ;
  long tmp___7 ;
  struct fc_exch *_ep ;
  struct fc_seq  const  *__mptr ;
  long tmp___8 ;

  {
#line 752
  fsp = (struct fc_fcp_pkt *)arg;
#line 753
  lport = fsp->lp;
#line 757
  rc = 0;
#line 759
  tmp = IS_ERR((void const   *)fp);
#line 759
  if ((int )tmp) {
#line 760
    fc_fcp_error(fsp, fp);
#line 761
    return;
  } else {

  }
#line 764
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 765
  r_ctl = fh->fh_r_ctl;
#line 767
  if ((unsigned int )lport->state != 14U) {
#line 768
    goto out;
  } else {

  }
#line 769
  tmp___0 = fc_fcp_lock_pkt(fsp);
#line 769
  if (tmp___0 != 0) {
#line 770
    goto out;
  } else {

  }
#line 772
  if ((unsigned int )fh->fh_type == 0U) {
#line 773
    fc_fcp_abts_resp(fsp, fp);
#line 774
    goto unlock;
  } else {

  }
#line 777
  if (((int )fsp->state & 12) != 0) {
#line 778
    goto unlock;
  } else {

  }
#line 780
  if ((unsigned int )r_ctl == 5U) {
#line 785
    __ret_warn_on = (int )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_flags & 1;
#line 785
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 785
    if (tmp___1 != 0L) {
#line 785
      warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c",
                         785);
    } else {

    }
#line 785
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 786
    tmp___2 = fc_frame_payload_get((struct fc_frame  const  *)fp, 12UL);
#line 786
    dd = (struct fcp_txrdy *)tmp___2;
#line 787
    __ret_warn_on___0 = (unsigned long )dd == (unsigned long )((struct fcp_txrdy *)0);
#line 787
    tmp___3 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 787
    if (tmp___3 != 0L) {
#line 787
      warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c",
                         787);
    } else {

    }
#line 787
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 789
    tmp___4 = __fswab32(dd->ft_burst_len);
#line 789
    tmp___5 = __fswab32(dd->ft_data_ro);
#line 789
    rc = fc_fcp_send_data(fsp, seq, (unsigned long )tmp___5, (unsigned long )tmp___4);
#line 792
    if (rc == 0) {
#line 793
      seq->rec_data = (u32 )fsp->xfer_len;
    } else {

    }
  } else
#line 794
  if ((unsigned int )r_ctl == 1U) {
#line 799
    __ret_warn_on___1 = fp->skb.len <= 23U;
#line 799
    tmp___6 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
#line 799
    if (tmp___6 != 0L) {
#line 799
      warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c",
                         799);
    } else {

    }
#line 799
    ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
#line 800
    fc_fcp_recv_data(fsp, fp);
#line 801
    seq->rec_data = fsp->xfer_contig_end;
  } else
#line 802
  if ((unsigned int )r_ctl == 7U) {
#line 803
    __ret_warn_on___2 = (int )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_flags & 1;
#line 803
    tmp___7 = ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
#line 803
    if (tmp___7 != 0L) {
#line 803
      warn_slowpath_null("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c",
                         803);
    } else {

    }
#line 803
    ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
#line 805
    fc_fcp_resp(fsp, fp);
  } else {
#line 807
    tmp___8 = ldv__builtin_expect((fc_debug_logging & 16U) != 0U, 0L);
#line 807
    if (tmp___8 != 0L) {
#line 807
      if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 807
        _ep = (struct fc_exch *)0;
#line 807
        __mptr = (struct fc_seq  const  *)fsp->seq_ptr;
#line 807
        _ep = (struct fc_exch *)__mptr + 0xffffffffffffff64UL;
#line 807
        printk("\016host%u: fcp: %6.6x: xid %04x-%04x: unexpected frame.  r_ctl %x\n",
               ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )_ep->oxid,
               (int )_ep->rxid, (int )r_ctl);
      } else {
#line 807
        printk("\016host%u: fcp: %6.6x: unexpected frame.  r_ctl %x\n", ((fsp->lp)->host)->host_no,
               (fsp->rport)->port_id, (int )r_ctl);
      }
    } else {

    }
  }
  unlock: 
#line 810
  fc_fcp_unlock_pkt(fsp);
  out: 
#line 812
  fc_frame_free(fp);
#line 813
  return;
}
}
#line 820 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_resp(struct fc_fcp_pkt *fsp , struct fc_frame *fp ) 
{ 
  struct fc_frame_header *fh ;
  struct fcp_resp *fc_rp ;
  struct fcp_resp_ext *rp_ex ;
  struct fcp_resp_rsp_info *fc_rp_info ;
  u32 plen ;
  u32 expected_len ;
  u32 respl ;
  u32 snsl ;
  u8 flags ;
  long tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  unsigned int tmp___3 ;
  long tmp___4 ;
  struct fc_exch *_ep ;
  struct fc_seq  const  *__mptr ;
  long tmp___5 ;
  long tmp___6 ;
  struct fc_exch *_ep___0 ;
  struct fc_seq  const  *__mptr___0 ;
  long tmp___7 ;

  {
#line 828
  respl = 0U;
#line 829
  snsl = 0U;
#line 830
  flags = 0U;
#line 832
  plen = fp->skb.len;
#line 833
  fh = (struct fc_frame_header *)fp->skb.data;
#line 834
  tmp = ldv__builtin_expect(plen <= 35U, 0L);
#line 834
  if (tmp != 0L) {
#line 835
    goto len_err;
  } else {

  }
#line 836
  plen = plen - 24U;
#line 837
  fc_rp = (struct fcp_resp *)fh + 1U;
#line 838
  fsp->cdb_status = fc_rp->fr_status;
#line 839
  flags = fc_rp->fr_flags;
#line 840
  fsp->scsi_comp_flags = flags;
#line 841
  expected_len = fsp->data_len;
#line 844
  fc_fcp_ddp_done(fsp);
#line 846
  tmp___4 = ldv__builtin_expect((long )(((int )flags & -17) != 0 || (unsigned int )fc_rp->fr_status != 0U),
                             0L);
#line 846
  if (tmp___4 != 0L) {
#line 847
    rp_ex = (struct fcp_resp_ext *)fc_rp + 1U;
#line 848
    if (((int )flags & 3) != 0) {
#line 849
      if (plen <= 23U) {
#line 850
        goto len_err;
      } else {

      }
#line 851
      fc_rp_info = (struct fcp_resp_rsp_info *)rp_ex + 1U;
#line 852
      if ((int )flags & 1) {
#line 853
        tmp___0 = __fswab32(rp_ex->fr_rsp_len);
#line 853
        respl = tmp___0;
#line 854
        if (respl != 4U && respl != 8U) {
#line 856
          goto len_err;
        } else {

        }
#line 857
        if (fsp->wait_for_comp != 0) {
#line 859
          fsp->cdb_status = fc_rp_info->rsp_code;
#line 860
          complete(& fsp->tm_done);
#line 865
          return;
        } else {

        }
      } else {

      }
#line 868
      if (((int )flags & 2) != 0) {
#line 869
        tmp___1 = __fswab32(rp_ex->fr_sns_len);
#line 869
        snsl = tmp___1;
#line 870
        if (snsl > 96U) {
#line 871
          snsl = 96U;
        } else {

        }
#line 872
        memcpy((void *)(fsp->cmd)->sense_buffer, (void const   *)fc_rp_info + (unsigned long )respl,
                 (size_t )snsl);
      } else {

      }
    } else {

    }
#line 876
    if (((int )flags & 12) != 0) {
#line 877
      if (plen <= 15U) {
#line 878
        goto len_err;
      } else {

      }
#line 879
      if (((int )flags & 8) != 0) {
#line 880
        tmp___2 = __fswab32(rp_ex->fr_resid);
#line 880
        fsp->scsi_resid = tmp___2;
#line 889
        if (((int )flags & 2) == 0 && (unsigned int )fc_rp->fr_status == 0U) {
#line 889
          tmp___3 = scsi_bufflen(fsp->cmd);
#line 889
          if (tmp___3 - fsp->scsi_resid < (fsp->cmd)->underflow) {
#line 893
            goto err;
          } else {

          }
        } else {

        }
#line 894
        expected_len = expected_len - fsp->scsi_resid;
      } else {
#line 896
        fsp->status_code = 8U;
      }
    } else {

    }
  } else {

  }
#line 900
  fsp->state = (u8 )((unsigned int )fsp->state | 2U);
#line 905
  tmp___6 = ldv__builtin_expect((long )((unsigned int )fsp->cdb_status == 0U && fsp->xfer_len != (size_t )expected_len),
                             0L);
#line 905
  if (tmp___6 != 0L) {
#line 907
    if (fsp->xfer_len < (size_t )expected_len) {
#line 913
      fc_fcp_timer_set(fsp, 2UL);
#line 914
      return;
    } else {

    }
#line 916
    fsp->status_code = 6U;
#line 917
    tmp___5 = ldv__builtin_expect((fc_debug_logging & 16U) != 0U, 0L);
#line 917
    if (tmp___5 != 0L) {
#line 917
      if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 917
        _ep = (struct fc_exch *)0;
#line 917
        __mptr = (struct fc_seq  const  *)fsp->seq_ptr;
#line 917
        _ep = (struct fc_exch *)__mptr + 0xffffffffffffff64UL;
#line 917
        printk("\016host%u: fcp: %6.6x: xid %04x-%04x: tgt %6.6x xfer len %zx greater than expected, len %x, data len %x\n",
               ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )_ep->oxid,
               (int )_ep->rxid, (fsp->rport)->port_id, fsp->xfer_len, expected_len,
               fsp->data_len);
      } else {
#line 917
        printk("\016host%u: fcp: %6.6x: tgt %6.6x xfer len %zx greater than expected, len %x, data len %x\n",
               ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (fsp->rport)->port_id,
               fsp->xfer_len, expected_len, fsp->data_len);
      }
    } else {

    }
  } else {

  }
#line 922
  fc_fcp_complete_locked(fsp);
#line 923
  return;
  len_err: 
#line 926
  tmp___7 = ldv__builtin_expect((fc_debug_logging & 16U) != 0U, 0L);
#line 926
  if (tmp___7 != 0L) {
#line 926
    if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 926
      _ep___0 = (struct fc_exch *)0;
#line 926
      __mptr___0 = (struct fc_seq  const  *)fsp->seq_ptr;
#line 926
      _ep___0 = (struct fc_exch *)__mptr___0 + 0xffffffffffffff64UL;
#line 926
      printk("\016host%u: fcp: %6.6x: xid %04x-%04x: short FCP response. flags 0x%x len %u respl %u snsl %u\n",
             ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )_ep___0->oxid,
             (int )_ep___0->rxid, (int )flags, fp->skb.len, respl, snsl);
    } else {
#line 926
      printk("\016host%u: fcp: %6.6x: short FCP response. flags 0x%x len %u respl %u snsl %u\n",
             ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )flags, fp->skb.len,
             respl, snsl);
    }
  } else {

  }
  err: 
#line 929
  fsp->status_code = 8U;
#line 930
  fc_fcp_complete_locked(fsp);
#line 931
  return;
}
}
#line 941 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_complete_locked(struct fc_fcp_pkt *fsp ) 
{ 
  struct fc_lport *lport ;
  struct fc_seq *seq ;
  struct fc_exch *ep ;
  u32 f_ctl ;
  struct fc_frame *conf_frame ;
  struct fc_seq *csp ;
  struct fc_seq  const  *__mptr ;
  long tmp ;

  {
#line 943
  lport = fsp->lp;
#line 948
  if (((int )fsp->state & 4) != 0) {
#line 949
    return;
  } else {

  }
#line 951
  if (((int )fsp->state & 8) != 0) {
#line 952
    if ((unsigned int )fsp->status_code == 0U) {
#line 953
      fsp->status_code = 1U;
    } else {

    }
  } else
#line 959
  if ((((unsigned int )fsp->cdb_status == 0U && fsp->xfer_len < (size_t )fsp->data_len) && fsp->io_status == 0U) && (((int )fsp->scsi_comp_flags & 8) == 0 || fsp->xfer_len < (size_t )(fsp->data_len - fsp->scsi_resid))) {
#line 963
    fsp->status_code = 7U;
  } else {

  }
#line 966
  seq = fsp->seq_ptr;
#line 967
  if ((unsigned long )seq != (unsigned long )((struct fc_seq *)0)) {
#line 968
    fsp->seq_ptr = (struct fc_seq *)0;
#line 969
    tmp = ldv__builtin_expect(((int )fsp->scsi_comp_flags & 16) != 0, 0L);
#line 969
    if (tmp != 0L) {
#line 973
      csp = (*(lport->tt.seq_start_next))(seq);
#line 974
      conf_frame = fc_fcp_frame_alloc(fsp->lp, 0UL);
#line 975
      if ((unsigned long )conf_frame != (unsigned long )((struct fc_frame *)0)) {
#line 976
        f_ctl = 65536U;
#line 977
        f_ctl = f_ctl | 1572864U;
#line 978
        __mptr = (struct fc_seq  const  *)seq;
#line 978
        ep = (struct fc_exch *)__mptr + 0xffffffffffffff64UL;
#line 979
        fc_fill_fc_hdr(conf_frame, 3, ep->did, ep->sid, 8, f_ctl, 0U);
#line 982
        (*(lport->tt.seq_send))(lport, csp, conf_frame);
      } else {

      }
    } else {

    }
#line 985
    (*(lport->tt.exch_done))(seq);
  } else {

  }
#line 992
  if ((unsigned long )fsp->cmd != (unsigned long )((struct scsi_cmnd *)0)) {
#line 993
    fc_io_compl(fsp);
  } else {

  }
#line 994
  return;
}
}
#line 1001 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_cleanup_cmd(struct fc_fcp_pkt *fsp , int error ) 
{ 
  struct fc_lport *lport ;

  {
#line 1003
  lport = fsp->lp;
#line 1005
  if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 1006
    (*(lport->tt.exch_done))(fsp->seq_ptr);
#line 1007
    fsp->seq_ptr = (struct fc_seq *)0;
  } else {

  }
#line 1009
  fsp->status_code = (u8 )error;
#line 1010
  return;
}
}
#line 1021 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_cleanup_each_cmd(struct fc_lport *lport , unsigned int id , unsigned int lun ,
                                    int error ) 
{ 
  struct fc_fcp_internal *si ;
  struct fc_fcp_pkt *fsp ;
  struct scsi_cmnd *sc_cmd ;
  unsigned long flags ;
  struct list_head  const  *__mptr ;
  unsigned int tmp ;
  int tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1024
  si = (struct fc_fcp_internal *)lport->scsi_priv;
#line 1029
  ldv_spin_lock();
  restart: 
#line 1031
  __mptr = (struct list_head  const  *)si->scsi_pkt_queue.next;
#line 1031
  fsp = (struct fc_fcp_pkt *)__mptr + 0xffffffffffffffa8UL;
#line 1031
  goto ldv_41731;
  ldv_41730: 
#line 1032
  sc_cmd = fsp->cmd;
#line 1033
  if (id != 4294967295U) {
#line 1033
    tmp = sdev_id(sc_cmd->device);
#line 1033
    if (tmp != id) {
#line 1034
      goto ldv_41729;
    } else {

    }
  } else {

  }
#line 1036
  if (lun != 4294967295U && (sc_cmd->device)->lun != (u64 )lun) {
#line 1037
    goto ldv_41729;
  } else {

  }
#line 1039
  fc_fcp_pkt_hold(fsp);
#line 1040
  spin_unlock_irqrestore(& si->scsi_queue_lock, flags);
#line 1042
  tmp___0 = fc_fcp_lock_pkt(fsp);
#line 1042
  if (tmp___0 == 0) {
#line 1043
    fc_fcp_cleanup_cmd(fsp, error);
#line 1044
    fc_io_compl(fsp);
#line 1045
    fc_fcp_unlock_pkt(fsp);
  } else {

  }
#line 1048
  fc_fcp_pkt_release(fsp);
#line 1049
  ldv_spin_lock();
#line 1054
  goto restart;
  ldv_41729: 
#line 1031
  __mptr___0 = (struct list_head  const  *)fsp->list.next;
#line 1031
  fsp = (struct fc_fcp_pkt *)__mptr___0 + 0xffffffffffffffa8UL;
  ldv_41731: ;
#line 1031
  if ((unsigned long )(& fsp->list) != (unsigned long )(& si->scsi_pkt_queue)) {
#line 1033
    goto ldv_41730;
  } else {

  }
#line 1056
  spin_unlock_irqrestore(& si->scsi_queue_lock, flags);
#line 1057
  return;
}
}
#line 1063 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_abort_io(struct fc_lport *lport ) 
{ 


  {
#line 1065
  fc_fcp_cleanup_each_cmd(lport, 4294967295U, 4294967295U, 9);
#line 1066
  return;
}
}
#line 1076 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static int fc_fcp_pkt_send(struct fc_lport *lport , struct fc_fcp_pkt *fsp ) 
{ 
  struct fc_fcp_internal *si ;
  unsigned long flags ;
  int rc ;
  __u32 tmp ;
  long tmp___0 ;

  {
#line 1078
  si = (struct fc_fcp_internal *)lport->scsi_priv;
#line 1082
  (fsp->cmd)->SCp.ptr = (char *)fsp;
#line 1083
  tmp = __fswab32(fsp->data_len);
#line 1083
  fsp->cdb_cmd.fc_dl = tmp;
#line 1084
  fsp->cdb_cmd.fc_flags = (unsigned int )((__u8 )fsp->req_flags) & 3U;
#line 1086
  int_to_scsilun(((fsp->cmd)->device)->lun, & fsp->cdb_cmd.fc_lun);
#line 1087
  memcpy((void *)(& fsp->cdb_cmd.fc_cdb), (void const   *)(fsp->cmd)->cmnd, (size_t )(fsp->cmd)->cmd_len);
#line 1089
  ldv_spin_lock();
#line 1090
  list_add_tail(& fsp->list, & si->scsi_pkt_queue);
#line 1091
  spin_unlock_irqrestore(& si->scsi_queue_lock, flags);
#line 1092
  rc = (*(lport->tt.fcp_cmd_send))(lport, fsp, & fc_fcp_recv);
#line 1093
  tmp___0 = ldv__builtin_expect(rc != 0, 0L);
#line 1093
  if (tmp___0 != 0L) {
#line 1094
    ldv_spin_lock();
#line 1095
    (fsp->cmd)->SCp.ptr = (char *)0;
#line 1096
    list_del(& fsp->list);
#line 1097
    spin_unlock_irqrestore(& si->scsi_queue_lock, flags);
  } else {

  }
#line 1100
  return (rc);
}
}
#line 1109 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
__inline static unsigned int get_fsp_rec_tov(struct fc_fcp_pkt *fsp ) 
{ 
  struct fc_rport_libfc_priv *rpriv ;
  unsigned long tmp ;

  {
#line 1111
  rpriv = (struct fc_rport_libfc_priv *)(fsp->rport)->dd_data;
#line 1113
  tmp = msecs_to_jiffies(rpriv->e_d_tov);
#line 1113
  return ((unsigned int )tmp + 250U);
}
}
#line 1122 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static int fc_fcp_cmd_send(struct fc_lport *lport , struct fc_fcp_pkt *fsp , void (*resp)(struct fc_seq * ,
                                                                                          struct fc_frame * ,
                                                                                          void * ) ) 
{ 
  struct fc_frame *fp ;
  struct fc_seq *seq ;
  struct fc_rport *rport ;
  struct fc_rport_libfc_priv *rpriv ;
  size_t len ;
  int rc ;
  int tmp ;
  void *tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 1131
  len = 32UL;
#line 1132
  rc = 0;
#line 1134
  tmp = fc_fcp_lock_pkt(fsp);
#line 1134
  if (tmp != 0) {
#line 1135
    return (0);
  } else {

  }
#line 1137
  fp = fc_fcp_frame_alloc(lport, 32UL);
#line 1138
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1139
    rc = -1;
#line 1140
    goto unlock;
  } else {

  }
#line 1143
  tmp___0 = fc_frame_payload_get((struct fc_frame  const  *)fp, len);
#line 1143
  memcpy(tmp___0, (void const   *)(& fsp->cdb_cmd), len);
#line 1144
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_fsp = fsp;
#line 1145
  rport = fsp->rport;
#line 1146
  fsp->max_payload = (u16 )rport->maxframe_size;
#line 1147
  rpriv = (struct fc_rport_libfc_priv *)rport->dd_data;
#line 1149
  fc_fill_fc_hdr(fp, 6, rport->port_id, (rpriv->local_port)->port_id, 8, 2686976U,
                 0U);
#line 1153
  seq = (*(lport->tt.exch_seq_send))(lport, fp, resp, & fc_fcp_pkt_destroy, (void *)fsp,
                                     0U);
#line 1155
  if ((unsigned long )seq == (unsigned long )((struct fc_seq *)0)) {
#line 1156
    rc = -1;
#line 1157
    goto unlock;
  } else {

  }
#line 1159
  fsp->seq_ptr = seq;
#line 1160
  fc_fcp_pkt_hold(fsp);
#line 1162
  reg_timer_6(& fsp->timer, & fc_fcp_timeout, (unsigned long )fsp);
#line 1163
  if ((int )rpriv->flags & 1) {
#line 1164
    tmp___1 = get_fsp_rec_tov(fsp);
#line 1164
    fc_fcp_timer_set(fsp, (unsigned long )tmp___1);
  } else {

  }
  unlock: 
#line 1167
  fc_fcp_unlock_pkt(fsp);
#line 1168
  return (rc);
}
}
#line 1176 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_error(struct fc_fcp_pkt *fsp , struct fc_frame *fp ) 
{ 
  int error ;
  long tmp ;
  int tmp___0 ;

  {
#line 1178
  tmp = PTR_ERR((void const   *)fp);
#line 1178
  error = (int )tmp;
#line 1180
  tmp___0 = fc_fcp_lock_pkt(fsp);
#line 1180
  if (tmp___0 != 0) {
#line 1181
    return;
  } else {

  }
#line 1183
  if (error == -2) {
#line 1184
    fc_fcp_retry_cmd(fsp);
#line 1185
    goto unlock;
  } else {

  }
#line 1192
  fsp->state = (unsigned int )fsp->state & 251U;
#line 1193
  fsp->status_code = 3U;
#line 1194
  fc_fcp_complete_locked(fsp);
  unlock: 
#line 1196
  fc_fcp_unlock_pkt(fsp);
#line 1197
  return;
}
}
#line 1205 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static int fc_fcp_pkt_abort(struct fc_fcp_pkt *fsp ) 
{ 
  int rc ;
  unsigned long ticks_left ;
  int tmp ;
  struct fc_exch *_ep ;
  struct fc_seq  const  *__mptr ;
  long tmp___0 ;
  struct fc_exch *_ep___0 ;
  struct fc_seq  const  *__mptr___0 ;
  long tmp___1 ;

  {
#line 1207
  rc = 8195;
#line 1210
  tmp = fc_fcp_send_abort(fsp);
#line 1210
  if (tmp != 0) {
#line 1211
    return (8195);
  } else {

  }
#line 1213
  init_completion(& fsp->tm_done);
#line 1214
  fsp->wait_for_comp = 1;
#line 1216
  spin_unlock_bh(& fsp->scsi_pkt_lock);
#line 1217
  ticks_left = wait_for_completion_timeout(& fsp->tm_done, 2500UL);
#line 1219
  spin_lock_bh(& fsp->scsi_pkt_lock);
#line 1220
  fsp->wait_for_comp = 0;
#line 1222
  if (ticks_left == 0UL) {
#line 1223
    tmp___0 = ldv__builtin_expect((fc_debug_logging & 16U) != 0U, 0L);
#line 1223
    if (tmp___0 != 0L) {
#line 1223
      if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 1223
        _ep = (struct fc_exch *)0;
#line 1223
        __mptr = (struct fc_seq  const  *)fsp->seq_ptr;
#line 1223
        _ep = (struct fc_exch *)__mptr + 0xffffffffffffff64UL;
#line 1223
        printk("\016host%u: fcp: %6.6x: xid %04x-%04x: target abort cmd  failed\n",
               ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )_ep->oxid,
               (int )_ep->rxid);
      } else {
#line 1223
        printk("\016host%u: fcp: %6.6x: target abort cmd  failed\n", ((fsp->lp)->host)->host_no,
               (fsp->rport)->port_id);
      }
    } else {

    }
  } else
#line 1224
  if (((int )fsp->state & 8) != 0) {
#line 1225
    tmp___1 = ldv__builtin_expect((fc_debug_logging & 16U) != 0U, 0L);
#line 1225
    if (tmp___1 != 0L) {
#line 1225
      if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 1225
        _ep___0 = (struct fc_exch *)0;
#line 1225
        __mptr___0 = (struct fc_seq  const  *)fsp->seq_ptr;
#line 1225
        _ep___0 = (struct fc_exch *)__mptr___0 + 0xffffffffffffff64UL;
#line 1225
        printk("\016host%u: fcp: %6.6x: xid %04x-%04x: target abort cmd  passed\n",
               ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )_ep___0->oxid,
               (int )_ep___0->rxid);
      } else {
#line 1225
        printk("\016host%u: fcp: %6.6x: target abort cmd  passed\n", ((fsp->lp)->host)->host_no,
               (fsp->rport)->port_id);
      }
    } else {

    }
#line 1226
    rc = 8194;
#line 1227
    fc_fcp_complete_locked(fsp);
  } else {

  }
#line 1230
  return (rc);
}
}
#line 1237 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_lun_reset_send(unsigned long data ) 
{ 
  struct fc_fcp_pkt *fsp ;
  struct fc_lport *lport ;
  u32 tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
#line 1239
  fsp = (struct fc_fcp_pkt *)data;
#line 1240
  lport = fsp->lp;
#line 1242
  tmp___2 = (*(lport->tt.fcp_cmd_send))(lport, fsp, & fc_tm_done);
#line 1242
  if (tmp___2 != 0) {
#line 1243
    tmp = fsp->recov_retry;
#line 1243
    fsp->recov_retry = fsp->recov_retry + 1U;
#line 1243
    if (tmp > 2U) {
#line 1244
      return;
    } else {

    }
#line 1245
    tmp___0 = fc_fcp_lock_pkt(fsp);
#line 1245
    if (tmp___0 != 0) {
#line 1246
      return;
    } else {

    }
#line 1247
    reg_timer_6(& fsp->timer, & fc_lun_reset_send, (unsigned long )fsp);
#line 1248
    tmp___1 = get_fsp_rec_tov(fsp);
#line 1248
    fc_fcp_timer_set(fsp, (unsigned long )tmp___1);
#line 1249
    fc_fcp_unlock_pkt(fsp);
  } else {

  }
#line 1251
  return;
}
}
#line 1261 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static int fc_lun_reset(struct fc_lport *lport , struct fc_fcp_pkt *fsp , unsigned int id ,
                        unsigned int lun ) 
{ 
  int rc ;
  __u32 tmp ;
  unsigned long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 1266
  tmp = __fswab32(fsp->data_len);
#line 1266
  fsp->cdb_cmd.fc_dl = tmp;
#line 1267
  fsp->cdb_cmd.fc_tm_flags = 16U;
#line 1268
  int_to_scsilun((u64 )lun, & fsp->cdb_cmd.fc_lun);
#line 1270
  fsp->wait_for_comp = 1;
#line 1271
  init_completion(& fsp->tm_done);
#line 1273
  fc_lun_reset_send((unsigned long )fsp);
#line 1279
  tmp___0 = wait_for_completion_timeout(& fsp->tm_done, 2500UL);
#line 1279
  rc = (int )tmp___0;
#line 1281
  spin_lock_bh(& fsp->scsi_pkt_lock);
#line 1282
  fsp->state = (u8 )((unsigned int )fsp->state | 32U);
#line 1283
  spin_unlock_bh(& fsp->scsi_pkt_lock);
#line 1285
  ldv_del_timer_sync_388(& fsp->timer);
#line 1287
  spin_lock_bh(& fsp->scsi_pkt_lock);
#line 1288
  if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 1289
    (*(lport->tt.exch_done))(fsp->seq_ptr);
#line 1290
    fsp->seq_ptr = (struct fc_seq *)0;
  } else {

  }
#line 1292
  fsp->wait_for_comp = 0;
#line 1293
  spin_unlock_bh(& fsp->scsi_pkt_lock);
#line 1295
  if (rc == 0) {
#line 1296
    tmp___1 = ldv__builtin_expect((fc_debug_logging & 128U) != 0U, 0L);
#line 1296
    if (tmp___1 != 0L) {
#line 1296
      printk("\016host%u: scsi: lun reset failed\n", (lport->host)->host_no);
    } else {

    }
#line 1297
    return (8195);
  } else {

  }
#line 1301
  if ((unsigned int )fsp->cdb_status != 0U) {
#line 1302
    return (8195);
  } else {

  }
#line 1304
  tmp___2 = ldv__builtin_expect((fc_debug_logging & 128U) != 0U, 0L);
#line 1304
  if (tmp___2 != 0L) {
#line 1304
    printk("\016host%u: scsi: lun reset to lun %u completed\n", (lport->host)->host_no,
           lun);
  } else {

  }
#line 1305
  fc_fcp_cleanup_each_cmd(lport, id, lun, 1);
#line 1306
  return (8194);
}
}
#line 1315 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_tm_done(struct fc_seq *seq , struct fc_frame *fp , void *arg ) 
{ 
  struct fc_fcp_pkt *fsp ;
  struct fc_frame_header *fh ;
  bool tmp ;
  int tmp___0 ;

  {
#line 1317
  fsp = (struct fc_fcp_pkt *)arg;
#line 1320
  tmp = IS_ERR((void const   *)fp);
#line 1320
  if ((int )tmp) {
#line 1327
    return;
  } else {

  }
#line 1330
  tmp___0 = fc_fcp_lock_pkt(fsp);
#line 1330
  if (tmp___0 != 0) {
#line 1331
    goto out;
  } else {

  }
#line 1336
  if ((unsigned long )fsp->seq_ptr == (unsigned long )((struct fc_seq *)0) || fsp->wait_for_comp == 0) {
#line 1337
    goto out_unlock;
  } else {

  }
#line 1339
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 1340
  if ((unsigned int )fh->fh_type != 0U) {
#line 1341
    fc_fcp_resp(fsp, fp);
  } else {

  }
#line 1342
  fsp->seq_ptr = (struct fc_seq *)0;
#line 1343
  (*((fsp->lp)->tt.exch_done))(seq);
  out_unlock: 
#line 1345
  fc_fcp_unlock_pkt(fsp);
  out: 
#line 1347
  fc_frame_free(fp);
#line 1348
  return;
}
}
#line 1354 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_cleanup(struct fc_lport *lport ) 
{ 


  {
#line 1356
  fc_fcp_cleanup_each_cmd(lport, 4294967295U, 4294967295U, 8);
#line 1357
  return;
}
}
#line 1370 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_timeout(unsigned long data ) 
{ 
  struct fc_fcp_pkt *fsp ;
  struct fc_rport *rport ;
  struct fc_rport_libfc_priv *rpriv ;
  int tmp ;

  {
#line 1372
  fsp = (struct fc_fcp_pkt *)data;
#line 1373
  rport = fsp->rport;
#line 1374
  rpriv = (struct fc_rport_libfc_priv *)rport->dd_data;
#line 1376
  tmp = fc_fcp_lock_pkt(fsp);
#line 1376
  if (tmp != 0) {
#line 1377
    return;
  } else {

  }
#line 1379
  if ((unsigned int )fsp->cdb_cmd.fc_tm_flags != 0U) {
#line 1380
    goto unlock;
  } else {

  }
#line 1382
  fsp->state = (u8 )((unsigned int )fsp->state | 64U);
#line 1384
  if ((int )rpriv->flags & 1) {
#line 1385
    fc_fcp_rec(fsp);
  } else
#line 1386
  if (((int )fsp->state & 2) != 0) {
#line 1387
    fc_fcp_complete_locked(fsp);
  } else {
#line 1389
    fc_fcp_recovery(fsp, 11);
  }
#line 1390
  fsp->state = (unsigned int )fsp->state & 191U;
  unlock: 
#line 1392
  fc_fcp_unlock_pkt(fsp);
#line 1393
  return;
}
}
#line 1399 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_rec(struct fc_fcp_pkt *fsp ) 
{ 
  struct fc_lport *lport ;
  struct fc_frame *fp ;
  struct fc_rport *rport ;
  struct fc_rport_libfc_priv *rpriv ;
  struct fc_seq *tmp ;
  unsigned int tmp___0 ;
  u32 tmp___1 ;

  {
#line 1406
  lport = fsp->lp;
#line 1407
  rport = fsp->rport;
#line 1408
  rpriv = (struct fc_rport_libfc_priv *)rport->dd_data;
#line 1409
  if ((unsigned long )fsp->seq_ptr == (unsigned long )((struct fc_seq *)0) || (unsigned int )rpriv->rp_state != 6U) {
#line 1410
    fsp->status_code = 9U;
#line 1411
    fsp->io_status = 0U;
#line 1412
    fc_fcp_complete_locked(fsp);
#line 1413
    return;
  } else {

  }
#line 1416
  fp = fc_fcp_frame_alloc(lport, 12UL);
#line 1417
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1418
    goto retry;
  } else {

  }
#line 1420
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_seq = fsp->seq_ptr;
#line 1421
  fc_fill_fc_hdr(fp, 34, rport->port_id, (rpriv->local_port)->port_id, 1, 2686976U,
                 0U);
#line 1424
  tmp = (*(lport->tt.elsct_send))(lport, rport->port_id, fp, 19U, & fc_fcp_rec_resp,
                                  (void *)fsp, lport->r_a_tov * 2U);
#line 1424
  if ((unsigned long )tmp != (unsigned long )((struct fc_seq *)0)) {
#line 1427
    fc_fcp_pkt_hold(fsp);
#line 1428
    return;
  } else {

  }
  retry: 
#line 1431
  tmp___1 = fsp->recov_retry;
#line 1431
  fsp->recov_retry = fsp->recov_retry + 1U;
#line 1431
  if (tmp___1 <= 2U) {
#line 1432
    tmp___0 = get_fsp_rec_tov(fsp);
#line 1432
    fc_fcp_timer_set(fsp, (unsigned long )tmp___0);
  } else {
#line 1434
    fc_fcp_recovery(fsp, 11);
  }
#line 1435
  return;
}
}
#line 1448 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_rec_resp(struct fc_seq *seq , struct fc_frame *fp , void *arg ) 
{ 
  struct fc_fcp_pkt *fsp ;
  struct fc_els_rec_acc *recp ;
  struct fc_els_ls_rjt *rjt ;
  u32 e_stat ;
  u8 opcode ;
  u32 offset ;
  enum dma_data_direction data_dir ;
  enum fc_rctl r_ctl ;
  struct fc_rport_libfc_priv *rpriv ;
  bool tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  struct fc_exch *_ep ;
  struct fc_seq  const  *__mptr ;
  long tmp___2 ;
  struct fc_exch *_ep___0 ;
  struct fc_seq  const  *__mptr___0 ;
  long tmp___3 ;
  void *tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  unsigned int tmp___7 ;

  {
#line 1450
  fsp = (struct fc_fcp_pkt *)arg;
#line 1460
  tmp = IS_ERR((void const   *)fp);
#line 1460
  if ((int )tmp) {
#line 1461
    fc_fcp_rec_error(fsp, fp);
#line 1462
    return;
  } else {

  }
#line 1465
  tmp___0 = fc_fcp_lock_pkt(fsp);
#line 1465
  if (tmp___0 != 0) {
#line 1466
    goto out;
  } else {

  }
#line 1468
  fsp->recov_retry = 0U;
#line 1469
  opcode = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 1470
  if ((unsigned int )opcode == 1U) {
#line 1471
    tmp___1 = fc_frame_payload_get((struct fc_frame  const  *)fp, 8UL);
#line 1471
    rjt = (struct fc_els_ls_rjt *)tmp___1;
#line 1472
    switch ((int )rjt->er_reason) {
    default: 
#line 1474
    tmp___2 = ldv__builtin_expect((fc_debug_logging & 16U) != 0U, 0L);
#line 1474
    if (tmp___2 != 0L) {
#line 1474
      if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 1474
        _ep = (struct fc_exch *)0;
#line 1474
        __mptr = (struct fc_seq  const  *)fsp->seq_ptr;
#line 1474
        _ep = (struct fc_exch *)__mptr + 0xffffffffffffff64UL;
#line 1474
        printk("\016host%u: fcp: %6.6x: xid %04x-%04x: device %x unexpected REC reject reason %d expl %d\n",
               ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )_ep->oxid,
               (int )_ep->rxid, (fsp->rport)->port_id, (int )rjt->er_reason, (int )rjt->er_explan);
      } else {
#line 1474
        printk("\016host%u: fcp: %6.6x: device %x unexpected REC reject reason %d expl %d\n",
               ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (fsp->rport)->port_id,
               (int )rjt->er_reason, (int )rjt->er_explan);
      }
    } else {

    }
    case 11: 
#line 1480
    tmp___3 = ldv__builtin_expect((fc_debug_logging & 16U) != 0U, 0L);
#line 1480
    if (tmp___3 != 0L) {
#line 1480
      if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 1480
        _ep___0 = (struct fc_exch *)0;
#line 1480
        __mptr___0 = (struct fc_seq  const  *)fsp->seq_ptr;
#line 1480
        _ep___0 = (struct fc_exch *)__mptr___0 + 0xffffffffffffff64UL;
#line 1480
        printk("\016host%u: fcp: %6.6x: xid %04x-%04x: device does not support REC\n",
               ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )_ep___0->oxid,
               (int )_ep___0->rxid);
      } else {
#line 1480
        printk("\016host%u: fcp: %6.6x: device does not support REC\n", ((fsp->lp)->host)->host_no,
               (fsp->rport)->port_id);
      }
    } else {

    }
#line 1481
    rpriv = (struct fc_rport_libfc_priv *)(fsp->rport)->dd_data;
#line 1487
    rpriv->flags = (unsigned int )rpriv->flags & 65534U;
#line 1488
    goto ldv_41841;
    case 3: ;
    case 9: ;
#line 1497
    if ((unsigned int )rjt->er_explan == 23U && fsp->xfer_len == 0UL) {
#line 1499
      fc_fcp_retry_cmd(fsp);
#line 1500
      goto ldv_41841;
    } else {

    }
#line 1502
    fc_fcp_recovery(fsp, 8);
#line 1503
    goto ldv_41841;
    }
    ldv_41841: ;
  } else
#line 1505
  if ((unsigned int )opcode == 2U) {
#line 1506
    if (((int )fsp->state & 8) != 0) {
#line 1507
      goto unlock_out;
    } else {

    }
#line 1509
    data_dir = (fsp->cmd)->sc_data_direction;
#line 1510
    tmp___4 = fc_frame_payload_get((struct fc_frame  const  *)fp, 24UL);
#line 1510
    recp = (struct fc_els_rec_acc *)tmp___4;
#line 1511
    tmp___5 = __fswab32(recp->reca_fc4value);
#line 1511
    offset = tmp___5;
#line 1512
    tmp___6 = __fswab32(recp->reca_e_stat);
#line 1512
    e_stat = tmp___6;
#line 1514
    if ((e_stat & 536870912U) != 0U) {
#line 1530
      if ((unsigned int )data_dir == 1U) {
#line 1531
        r_ctl = 7;
      } else
#line 1532
      if (fsp->xfer_contig_end == offset) {
#line 1533
        r_ctl = 7;
      } else {
#line 1535
        offset = fsp->xfer_contig_end;
#line 1536
        r_ctl = 1;
      }
#line 1538
      fc_fcp_srr(fsp, r_ctl, offset);
    } else
#line 1539
    if ((e_stat & 1073741824U) != 0U) {
#line 1544
      tmp___7 = get_fsp_rec_tov(fsp);
#line 1544
      fc_fcp_timer_set(fsp, (unsigned long )tmp___7);
    } else {
#line 1562
      r_ctl = 1;
#line 1563
      if ((unsigned int )data_dir == 1U) {
#line 1564
        r_ctl = 7;
#line 1565
        if (fsp->data_len > offset) {
#line 1566
          r_ctl = 5;
        } else {

        }
      } else
#line 1567
      if (fsp->xfer_contig_end == offset) {
#line 1568
        r_ctl = 7;
      } else
#line 1569
      if (fsp->xfer_contig_end < offset) {
#line 1570
        offset = fsp->xfer_contig_end;
      } else {

      }
#line 1572
      fc_fcp_srr(fsp, r_ctl, offset);
    }
  } else {

  }
  unlock_out: 
#line 1576
  fc_fcp_unlock_pkt(fsp);
  out: 
#line 1578
  fc_fcp_pkt_release(fsp);
#line 1579
  fc_frame_free(fp);
#line 1580
  return;
}
}
#line 1587 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_rec_error(struct fc_fcp_pkt *fsp , struct fc_frame *fp ) 
{ 
  int error ;
  long tmp ;
  int tmp___0 ;
  struct fc_exch *_ep ;
  struct fc_seq  const  *__mptr ;
  long tmp___1 ;
  struct fc_exch *_ep___0 ;
  struct fc_seq  const  *__mptr___0 ;
  long tmp___2 ;
  u32 tmp___3 ;

  {
#line 1589
  tmp = PTR_ERR((void const   *)fp);
#line 1589
  error = (int )tmp;
#line 1591
  tmp___0 = fc_fcp_lock_pkt(fsp);
#line 1591
  if (tmp___0 != 0) {
#line 1592
    goto out;
  } else {

  }
#line 1594
  switch (error) {
  case -2: 
#line 1596
  fc_fcp_retry_cmd(fsp);
#line 1597
  goto ldv_41852;
  default: 
#line 1600
  tmp___1 = ldv__builtin_expect((fc_debug_logging & 16U) != 0U, 0L);
#line 1600
  if (tmp___1 != 0L) {
#line 1600
    if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 1600
      _ep = (struct fc_exch *)0;
#line 1600
      __mptr = (struct fc_seq  const  *)fsp->seq_ptr;
#line 1600
      _ep = (struct fc_exch *)__mptr + 0xffffffffffffff64UL;
#line 1600
      printk("\016host%u: fcp: %6.6x: xid %04x-%04x: REC %p fid %6.6x error unexpected error %d\n",
             ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )_ep->oxid, (int )_ep->rxid,
             fsp, (fsp->rport)->port_id, error);
    } else {
#line 1600
      printk("\016host%u: fcp: %6.6x: REC %p fid %6.6x error unexpected error %d\n",
             ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, fsp, (fsp->rport)->port_id,
             error);
    }
  } else {

  }
#line 1602
  fsp->status_code = 3U;
  case -1: 
#line 1610
  tmp___2 = ldv__builtin_expect((fc_debug_logging & 16U) != 0U, 0L);
#line 1610
  if (tmp___2 != 0L) {
#line 1610
    if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 1610
      _ep___0 = (struct fc_exch *)0;
#line 1610
      __mptr___0 = (struct fc_seq  const  *)fsp->seq_ptr;
#line 1610
      _ep___0 = (struct fc_exch *)__mptr___0 + 0xffffffffffffff64UL;
#line 1610
      printk("\016host%u: fcp: %6.6x: xid %04x-%04x: REC fid %6.6x error error %d retry %d/%d\n",
             ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )_ep___0->oxid,
             (int )_ep___0->rxid, (fsp->rport)->port_id, error, fsp->recov_retry,
             3);
    } else {
#line 1610
      printk("\016host%u: fcp: %6.6x: REC fid %6.6x error error %d retry %d/%d\n",
             ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (fsp->rport)->port_id,
             error, fsp->recov_retry, 3);
    }
  } else {

  }
#line 1613
  tmp___3 = fsp->recov_retry;
#line 1613
  fsp->recov_retry = fsp->recov_retry + 1U;
#line 1613
  if (tmp___3 <= 2U) {
#line 1614
    fc_fcp_rec(fsp);
  } else {
#line 1616
    fc_fcp_recovery(fsp, 8);
  }
#line 1617
  goto ldv_41852;
  }
  ldv_41852: 
#line 1619
  fc_fcp_unlock_pkt(fsp);
  out: 
#line 1621
  fc_fcp_pkt_release(fsp);
#line 1622
  return;
}
}
#line 1628 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_recovery(struct fc_fcp_pkt *fsp , u8 code ) 
{ 


  {
#line 1630
  fsp->status_code = code;
#line 1631
  fsp->cdb_status = 0U;
#line 1632
  fsp->io_status = 0U;
#line 1637
  fc_fcp_send_abort(fsp);
#line 1638
  return;
}
}
#line 1647 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_srr(struct fc_fcp_pkt *fsp , enum fc_rctl r_ctl , u32 offset ) 
{ 
  struct fc_lport *lport ;
  struct fc_rport *rport ;
  struct fc_rport_libfc_priv *rpriv ;
  struct fc_exch *ep ;
  struct fc_seq  const  *__mptr ;
  struct fc_seq *seq ;
  struct fcp_srr *srr ;
  struct fc_frame *fp ;
  unsigned int rec_tov ;
  void *tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  __u32 tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 1649
  lport = fsp->lp;
#line 1652
  __mptr = (struct fc_seq  const  *)fsp->seq_ptr;
#line 1652
  ep = (struct fc_exch *)__mptr + 0xffffffffffffff64UL;
#line 1658
  rport = fsp->rport;
#line 1659
  rpriv = (struct fc_rport_libfc_priv *)rport->dd_data;
#line 1661
  if (((int )rpriv->flags & 2) == 0 || (unsigned int )rpriv->rp_state != 6U) {
#line 1663
    goto retry;
  } else {

  }
#line 1664
  fp = fc_fcp_frame_alloc(lport, 16UL);
#line 1665
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 1666
    goto retry;
  } else {

  }
#line 1668
  tmp = fc_frame_payload_get((struct fc_frame  const  *)fp, 16UL);
#line 1668
  srr = (struct fcp_srr *)tmp;
#line 1669
  memset((void *)srr, 0, 16UL);
#line 1670
  srr->srr_op = 20U;
#line 1671
  tmp___0 = __fswab16((int )ep->oxid);
#line 1671
  srr->srr_ox_id = tmp___0;
#line 1672
  tmp___1 = __fswab16((int )ep->rxid);
#line 1672
  srr->srr_rx_id = tmp___1;
#line 1673
  srr->srr_r_ctl = (__u8 )r_ctl;
#line 1674
  tmp___2 = __fswab32(offset);
#line 1674
  srr->srr_rel_off = tmp___2;
#line 1676
  fc_fill_fc_hdr(fp, 50, rport->port_id, (rpriv->local_port)->port_id, 8, 2686976U,
                 0U);
#line 1680
  rec_tov = get_fsp_rec_tov(fsp);
#line 1681
  tmp___3 = jiffies_to_msecs((unsigned long const   )rec_tov);
#line 1681
  seq = (*(lport->tt.exch_seq_send))(lport, fp, & fc_fcp_srr_resp, & fc_fcp_pkt_destroy,
                                     (void *)fsp, tmp___3);
#line 1684
  if ((unsigned long )seq == (unsigned long )((struct fc_seq *)0)) {
#line 1685
    goto retry;
  } else {

  }
#line 1687
  fsp->recov_seq = seq;
#line 1688
  fsp->xfer_len = (size_t )offset;
#line 1689
  fsp->xfer_contig_end = offset;
#line 1690
  fsp->state = (unsigned int )fsp->state & 253U;
#line 1691
  fc_fcp_pkt_hold(fsp);
#line 1692
  return;
  retry: 
#line 1694
  fc_fcp_retry_cmd(fsp);
#line 1695
  return;
}
}
#line 1703 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_srr_resp(struct fc_seq *seq , struct fc_frame *fp , void *arg ) 
{ 
  struct fc_fcp_pkt *fsp ;
  struct fc_frame_header *fh ;
  bool tmp ;
  int tmp___0 ;
  u8 tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 1705
  fsp = (struct fc_fcp_pkt *)arg;
#line 1708
  tmp = IS_ERR((void const   *)fp);
#line 1708
  if ((int )tmp) {
#line 1709
    fc_fcp_srr_error(fsp, fp);
#line 1710
    return;
  } else {

  }
#line 1713
  tmp___0 = fc_fcp_lock_pkt(fsp);
#line 1713
  if (tmp___0 != 0) {
#line 1714
    goto out;
  } else {

  }
#line 1716
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 1724
  if ((unsigned int )fh->fh_type == 0U) {
#line 1725
    fc_fcp_unlock_pkt(fsp);
#line 1726
    return;
  } else {

  }
#line 1729
  tmp___1 = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 1729
  switch ((int )tmp___1) {
  case 2: 
#line 1731
  fsp->recov_retry = 0U;
#line 1732
  tmp___2 = get_fsp_rec_tov(fsp);
#line 1732
  fc_fcp_timer_set(fsp, (unsigned long )tmp___2);
#line 1733
  goto ldv_41890;
  case 1: ;
  default: 
#line 1736
  fc_fcp_recovery(fsp, 8);
#line 1737
  goto ldv_41890;
  }
  ldv_41890: 
#line 1739
  fc_fcp_unlock_pkt(fsp);
  out: 
#line 1741
  (*((fsp->lp)->tt.exch_done))(seq);
#line 1742
  fc_frame_free(fp);
#line 1743
  return;
}
}
#line 1750 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_fcp_srr_error(struct fc_fcp_pkt *fsp , struct fc_frame *fp ) 
{ 
  int tmp ;
  long tmp___0 ;
  u32 tmp___1 ;

  {
#line 1752
  tmp = fc_fcp_lock_pkt(fsp);
#line 1752
  if (tmp != 0) {
#line 1753
    goto out;
  } else {

  }
#line 1754
  tmp___0 = PTR_ERR((void const   *)fp);
#line 1754
  switch (tmp___0) {
  case -1L: 
#line 1756
  tmp___1 = fsp->recov_retry;
#line 1756
  fsp->recov_retry = fsp->recov_retry + 1U;
#line 1756
  if (tmp___1 <= 2U) {
#line 1757
    fc_fcp_rec(fsp);
  } else {
#line 1759
    fc_fcp_recovery(fsp, 11);
  }
#line 1760
  goto ldv_41899;
  case -2L: ;
  default: 
#line 1764
  fc_fcp_retry_cmd(fsp);
#line 1765
  goto ldv_41899;
  }
  ldv_41899: 
#line 1767
  fc_fcp_unlock_pkt(fsp);
  out: 
#line 1769
  (*((fsp->lp)->tt.exch_done))(fsp->recov_seq);
#line 1770
  return;
}
}
#line 1776 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
__inline static int fc_fcp_lport_queue_ready(struct fc_lport *lport ) 
{ 


  {
#line 1779
  return (((unsigned int )lport->state == 14U && (unsigned int )lport->link_up != 0U) && (unsigned int )lport->qfull == 0U);
}
}
#line 1790 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
int fc_queuecommand(struct Scsi_Host *shost , struct scsi_cmnd *sc_cmd ) 
{ 
  struct fc_lport *lport ;
  void *tmp ;
  struct fc_rport *rport ;
  struct device  const  *__mptr ;
  struct scsi_target *tmp___2 ;
  struct fc_rport *tmp___3 ;
  struct scsi_target *tmp___4 ;
  int tmp___5 ;
  struct fc_fcp_pkt *fsp ;
  struct fc_rport_libfc_priv *rpriv ;
  int rval ;
  int rc ;
  struct fc_stats *stats ;
  int tmp___6 ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  int pscr_ret__ ;
  void const   *__vpp_verify___0 ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 1792
  tmp = shost_priv(shost);
#line 1792
  lport = (struct fc_lport *)tmp;
#line 1793
  tmp___4 = scsi_target(sc_cmd->device);
#line 1793
  tmp___5 = scsi_is_fc_rport((struct device  const  *)tmp___4->dev.parent);
#line 1793
  if (tmp___5 != 0) {
#line 1793
    tmp___2 = scsi_target(sc_cmd->device);
#line 1793
    __mptr = (struct device  const  *)tmp___2->dev.parent;
#line 1793
    tmp___3 = (struct fc_rport *)__mptr + 0xffffffffffffffa0UL;
  } else {
#line 1793
    tmp___3 = (struct fc_rport *)0;
  }
#line 1793
  rport = tmp___3;
#line 1797
  rc = 0;
#line 1800
  rval = fc_remote_port_chkready(rport);
#line 1801
  if (rval != 0) {
#line 1802
    sc_cmd->result = rval;
#line 1803
    (*(sc_cmd->scsi_done))(sc_cmd);
#line 1804
    return (0);
  } else {

  }
#line 1807
  if ((unsigned long )*((struct fc_remote_port **)rport->dd_data) == (unsigned long )((struct fc_remote_port *)0)) {
#line 1812
    sc_cmd->result = 786432;
#line 1813
    (*(sc_cmd->scsi_done))(sc_cmd);
#line 1814
    goto out;
  } else {

  }
#line 1817
  rpriv = (struct fc_rport_libfc_priv *)rport->dd_data;
#line 1819
  tmp___6 = fc_fcp_lport_queue_ready(lport);
#line 1819
  if (tmp___6 == 0) {
#line 1820
    if ((unsigned int )lport->qfull != 0U) {
#line 1821
      fc_fcp_can_queue_ramp_down(lport);
    } else {

    }
#line 1822
    rc = 4181;
#line 1823
    goto out;
  } else {

  }
#line 1826
  fsp = fc_fcp_pkt_alloc(lport, 32U);
#line 1827
  if ((unsigned long )fsp == (unsigned long )((struct fc_fcp_pkt *)0)) {
#line 1828
    rc = 4181;
#line 1829
    goto out;
  } else {

  }
#line 1835
  fsp->cmd = sc_cmd;
#line 1836
  fsp->rport = rport;
#line 1841
  fsp->data_len = scsi_bufflen(sc_cmd);
#line 1842
  fsp->xfer_len = 0UL;
#line 1847
  __vpp_verify = (void const   *)0;
#line 1847
  __asm__  ("": "=r" (__ptr): "0" (lport->stats));
#line 1847
  __preempt_count_add(1);
#line 1847
  __asm__  volatile   ("": : : "memory");
#line 1847
  __vpp_verify___0 = (void const   *)0;
#line 1847
  switch (4UL) {
  case 1UL: ;
#line 1847
  switch (4UL) {
  case 1UL: 
#line 1847
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 1847
  goto ldv_41927;
  case 2UL: 
#line 1847
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1847
  goto ldv_41927;
  case 4UL: 
#line 1847
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1847
  goto ldv_41927;
  case 8UL: 
#line 1847
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1847
  goto ldv_41927;
  default: 
#line 1847
  __bad_percpu_size();
  }
  ldv_41927: 
#line 1847
  pscr_ret__ = pfo_ret__;
#line 1847
  goto ldv_41933;
  case 2UL: ;
#line 1847
  switch (4UL) {
  case 1UL: 
#line 1847
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 1847
  goto ldv_41937;
  case 2UL: 
#line 1847
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1847
  goto ldv_41937;
  case 4UL: 
#line 1847
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1847
  goto ldv_41937;
  case 8UL: 
#line 1847
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1847
  goto ldv_41937;
  default: 
#line 1847
  __bad_percpu_size();
  }
  ldv_41937: 
#line 1847
  pscr_ret__ = pfo_ret_____0;
#line 1847
  goto ldv_41933;
  case 4UL: ;
#line 1847
  switch (4UL) {
  case 1UL: 
#line 1847
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 1847
  goto ldv_41946;
  case 2UL: 
#line 1847
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1847
  goto ldv_41946;
  case 4UL: 
#line 1847
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1847
  goto ldv_41946;
  case 8UL: 
#line 1847
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1847
  goto ldv_41946;
  default: 
#line 1847
  __bad_percpu_size();
  }
  ldv_41946: 
#line 1847
  pscr_ret__ = pfo_ret_____1;
#line 1847
  goto ldv_41933;
  case 8UL: ;
#line 1847
  switch (4UL) {
  case 1UL: 
#line 1847
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 1847
  goto ldv_41955;
  case 2UL: 
#line 1847
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1847
  goto ldv_41955;
  case 4UL: 
#line 1847
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1847
  goto ldv_41955;
  case 8UL: 
#line 1847
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1847
  goto ldv_41955;
  default: 
#line 1847
  __bad_percpu_size();
  }
  ldv_41955: 
#line 1847
  pscr_ret__ = pfo_ret_____2;
#line 1847
  goto ldv_41933;
  default: 
#line 1847
  __bad_size_call_parameter();
#line 1847
  goto ldv_41933;
  }
  ldv_41933: 
#line 1847
  stats = (struct fc_stats *)(__per_cpu_offset[pscr_ret__] + __ptr);
#line 1848
  if ((unsigned int )sc_cmd->sc_data_direction == 2U) {
#line 1849
    fsp->req_flags = 2U;
#line 1850
    stats->InputRequests = stats->InputRequests + 1ULL;
#line 1851
    stats->InputBytes = stats->InputBytes + (u64 )fsp->data_len;
  } else
#line 1852
  if ((unsigned int )sc_cmd->sc_data_direction == 1U) {
#line 1853
    fsp->req_flags = 1U;
#line 1854
    stats->OutputRequests = stats->OutputRequests + 1ULL;
#line 1855
    stats->OutputBytes = stats->OutputBytes + (u64 )fsp->data_len;
  } else {
#line 1857
    fsp->req_flags = 0U;
#line 1858
    stats->ControlRequests = stats->ControlRequests + 1ULL;
  }
#line 1860
  __asm__  volatile   ("": : : "memory");
#line 1860
  __preempt_count_sub(1);
#line 1867
  rval = fc_fcp_pkt_send(lport, fsp);
#line 1868
  if (rval != 0) {
#line 1869
    fsp->state = 0U;
#line 1870
    fc_fcp_pkt_release(fsp);
#line 1871
    rc = 4181;
  } else {

  }
  out: ;
#line 1874
  return (rc);
}
}
#line 1876 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static char const   __kstrtab_fc_queuecommand[16U]  = 
#line 1876
  {      'f',      'c',      '_',      'q', 
        'u',      'e',      'u',      'e', 
        'c',      'o',      'm',      'm', 
        'a',      'n',      'd',      '\000'};
#line 1876
struct kernel_symbol  const  __ksymtab_fc_queuecommand ;
#line 1876 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
struct kernel_symbol  const  __ksymtab_fc_queuecommand  =    {(unsigned long )(& fc_queuecommand), (char const   *)(& __kstrtab_fc_queuecommand)};
#line 1885 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static void fc_io_compl(struct fc_fcp_pkt *fsp ) 
{ 
  struct fc_fcp_internal *si ;
  struct scsi_cmnd *sc_cmd ;
  struct fc_lport *lport ;
  unsigned long flags ;
  struct fc_exch *_ep ;
  struct fc_seq  const  *__mptr ;
  long tmp ;
  struct fc_exch *_ep___0 ;
  struct fc_seq  const  *__mptr___0 ;
  long tmp___0 ;
  struct fc_exch *_ep___1 ;
  struct fc_seq  const  *__mptr___1 ;
  long tmp___1 ;
  struct fc_exch *_ep___2 ;
  struct fc_seq  const  *__mptr___2 ;
  long tmp___2 ;
  struct fc_exch *_ep___3 ;
  struct fc_seq  const  *__mptr___3 ;
  long tmp___3 ;
  struct fc_exch *_ep___4 ;
  struct fc_seq  const  *__mptr___4 ;
  long tmp___4 ;
  struct fc_exch *_ep___5 ;
  struct fc_seq  const  *__mptr___5 ;
  long tmp___5 ;
  struct fc_exch *_ep___6 ;
  struct fc_seq  const  *__mptr___6 ;
  long tmp___6 ;
  struct fc_exch *_ep___7 ;
  struct fc_seq  const  *__mptr___7 ;
  long tmp___7 ;
  struct fc_exch *_ep___8 ;
  struct fc_seq  const  *__mptr___8 ;
  long tmp___8 ;

  {
#line 1893
  fc_fcp_ddp_done(fsp);
#line 1895
  fsp->state = (u8 )((unsigned int )fsp->state | 32U);
#line 1896
  if (((int )fsp->state & 64) == 0) {
#line 1897
    spin_unlock_bh(& fsp->scsi_pkt_lock);
#line 1898
    ldv_del_timer_sync_389(& fsp->timer);
#line 1899
    spin_lock_bh(& fsp->scsi_pkt_lock);
  } else {

  }
#line 1902
  lport = fsp->lp;
#line 1903
  si = (struct fc_fcp_internal *)lport->scsi_priv;
#line 1909
  if (si->last_can_queue_ramp_down_time != 0UL) {
#line 1910
    fc_fcp_can_queue_ramp_up(lport);
  } else {

  }
#line 1912
  sc_cmd = fsp->cmd;
#line 1913
  sc_cmd->SCp.Status = (int volatile   )fsp->cdb_status;
#line 1914
  switch ((int )fsp->status_code) {
  case 0: ;
#line 1916
  if ((unsigned int )fsp->cdb_status == 0U) {
#line 1920
    sc_cmd->result = 0;
#line 1921
    if (fsp->scsi_resid != 0U) {
#line 1922
      sc_cmd->SCp.buffers_residual = (int )fsp->scsi_resid;
    } else {

    }
  } else {
#line 1928
    sc_cmd->result = (int )fsp->cdb_status;
  }
#line 1930
  goto ldv_41982;
  case 8: 
#line 1932
  tmp = ldv__builtin_expect((fc_debug_logging & 16U) != 0U, 0L);
#line 1932
  if (tmp != 0L) {
#line 1932
    if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 1932
      _ep = (struct fc_exch *)0;
#line 1932
      __mptr = (struct fc_seq  const  *)fsp->seq_ptr;
#line 1932
      _ep = (struct fc_exch *)__mptr + 0xffffffffffffff64UL;
#line 1932
      printk("\016host%u: fcp: %6.6x: xid %04x-%04x: Returning DID_ERROR to scsi-ml due to FC_ERROR\n",
             ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )_ep->oxid, (int )_ep->rxid);
    } else {
#line 1932
      printk("\016host%u: fcp: %6.6x: Returning DID_ERROR to scsi-ml due to FC_ERROR\n",
             ((fsp->lp)->host)->host_no, (fsp->rport)->port_id);
    }
  } else {

  }
#line 1934
  sc_cmd->result = 458752;
#line 1935
  goto ldv_41982;
  case 7: ;
#line 1937
  if ((unsigned int )fsp->cdb_status == 0U && (fsp->req_flags & 2U) == 0U) {
#line 1942
    if (((int )fsp->state & 2) != 0) {
#line 1943
      sc_cmd->result = 0;
    } else {
#line 1945
      tmp___0 = ldv__builtin_expect((fc_debug_logging & 16U) != 0U, 0L);
#line 1945
      if (tmp___0 != 0L) {
#line 1945
        if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 1945
          _ep___0 = (struct fc_exch *)0;
#line 1945
          __mptr___0 = (struct fc_seq  const  *)fsp->seq_ptr;
#line 1945
          _ep___0 = (struct fc_exch *)__mptr___0 + 0xffffffffffffff64UL;
#line 1945
          printk("\016host%u: fcp: %6.6x: xid %04x-%04x: Returning DID_ERROR to scsi-ml due to FC_DATA_UNDRUN (trans)\n",
                 ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )_ep___0->oxid,
                 (int )_ep___0->rxid);
        } else {
#line 1945
          printk("\016host%u: fcp: %6.6x: Returning DID_ERROR to scsi-ml due to FC_DATA_UNDRUN (trans)\n",
                 ((fsp->lp)->host)->host_no, (fsp->rport)->port_id);
        }
      } else {

      }
#line 1947
      sc_cmd->result = 458752;
    }
  } else {
#line 1953
    tmp___1 = ldv__builtin_expect((fc_debug_logging & 16U) != 0U, 0L);
#line 1953
    if (tmp___1 != 0L) {
#line 1953
      if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 1953
        _ep___1 = (struct fc_exch *)0;
#line 1953
        __mptr___1 = (struct fc_seq  const  *)fsp->seq_ptr;
#line 1953
        _ep___1 = (struct fc_exch *)__mptr___1 + 0xffffffffffffff64UL;
#line 1953
        printk("\016host%u: fcp: %6.6x: xid %04x-%04x: Returning DID_ERROR to scsi-ml due to FC_DATA_UNDRUN (scsi)\n",
               ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )_ep___1->oxid,
               (int )_ep___1->rxid);
      } else {
#line 1953
        printk("\016host%u: fcp: %6.6x: Returning DID_ERROR to scsi-ml due to FC_DATA_UNDRUN (scsi)\n",
               ((fsp->lp)->host)->host_no, (fsp->rport)->port_id);
      }
    } else {

    }
#line 1955
    sc_cmd->SCp.buffers_residual = (int )fsp->scsi_resid;
#line 1956
    sc_cmd->result = (int )fsp->cdb_status | 458752;
  }
#line 1958
  goto ldv_41982;
  case 6: 
#line 1963
  tmp___2 = ldv__builtin_expect((fc_debug_logging & 16U) != 0U, 0L);
#line 1963
  if (tmp___2 != 0L) {
#line 1963
    if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 1963
      _ep___2 = (struct fc_exch *)0;
#line 1963
      __mptr___2 = (struct fc_seq  const  *)fsp->seq_ptr;
#line 1963
      _ep___2 = (struct fc_exch *)__mptr___2 + 0xffffffffffffff64UL;
#line 1963
      printk("\016host%u: fcp: %6.6x: xid %04x-%04x: Returning DID_ERROR to scsi-ml due to FC_DATA_OVRRUN\n",
             ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )_ep___2->oxid,
             (int )_ep___2->rxid);
    } else {
#line 1963
      printk("\016host%u: fcp: %6.6x: Returning DID_ERROR to scsi-ml due to FC_DATA_OVRRUN\n",
             ((fsp->lp)->host)->host_no, (fsp->rport)->port_id);
    }
  } else {

  }
#line 1965
  sc_cmd->result = (int )fsp->cdb_status | 458752;
#line 1966
  goto ldv_41982;
  case 1: 
#line 1968
  tmp___3 = ldv__builtin_expect((fc_debug_logging & 16U) != 0U, 0L);
#line 1968
  if (tmp___3 != 0L) {
#line 1968
    if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 1968
      _ep___3 = (struct fc_exch *)0;
#line 1968
      __mptr___3 = (struct fc_seq  const  *)fsp->seq_ptr;
#line 1968
      _ep___3 = (struct fc_exch *)__mptr___3 + 0xffffffffffffff64UL;
#line 1968
      printk("\016host%u: fcp: %6.6x: xid %04x-%04x: Returning DID_ERROR to scsi-ml due to FC_CMD_ABORTED\n",
             ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )_ep___3->oxid,
             (int )_ep___3->rxid);
    } else {
#line 1968
      printk("\016host%u: fcp: %6.6x: Returning DID_ERROR to scsi-ml due to FC_CMD_ABORTED\n",
             ((fsp->lp)->host)->host_no, (fsp->rport)->port_id);
    }
  } else {

  }
#line 1970
  sc_cmd->result = (int )(fsp->io_status | 458752U);
#line 1971
  goto ldv_41982;
  case 2: 
#line 1973
  tmp___4 = ldv__builtin_expect((fc_debug_logging & 16U) != 0U, 0L);
#line 1973
  if (tmp___4 != 0L) {
#line 1973
    if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 1973
      _ep___4 = (struct fc_exch *)0;
#line 1973
      __mptr___4 = (struct fc_seq  const  *)fsp->seq_ptr;
#line 1973
      _ep___4 = (struct fc_exch *)__mptr___4 + 0xffffffffffffff64UL;
#line 1973
      printk("\016host%u: fcp: %6.6x: xid %04x-%04x: Returning DID_RESET to scsi-ml due to FC_CMD_RESET\n",
             ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )_ep___4->oxid,
             (int )_ep___4->rxid);
    } else {
#line 1973
      printk("\016host%u: fcp: %6.6x: Returning DID_RESET to scsi-ml due to FC_CMD_RESET\n",
             ((fsp->lp)->host)->host_no, (fsp->rport)->port_id);
    }
  } else {

  }
#line 1975
  sc_cmd->result = 524288;
#line 1976
  goto ldv_41982;
  case 9: 
#line 1978
  tmp___5 = ldv__builtin_expect((fc_debug_logging & 16U) != 0U, 0L);
#line 1978
  if (tmp___5 != 0L) {
#line 1978
    if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 1978
      _ep___5 = (struct fc_exch *)0;
#line 1978
      __mptr___5 = (struct fc_seq  const  *)fsp->seq_ptr;
#line 1978
      _ep___5 = (struct fc_exch *)__mptr___5 + 0xffffffffffffff64UL;
#line 1978
      printk("\016host%u: fcp: %6.6x: xid %04x-%04x: Returning DID_NO_CONNECT to scsi-ml due to FC_HRD_ERROR\n",
             ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )_ep___5->oxid,
             (int )_ep___5->rxid);
    } else {
#line 1978
      printk("\016host%u: fcp: %6.6x: Returning DID_NO_CONNECT to scsi-ml due to FC_HRD_ERROR\n",
             ((fsp->lp)->host)->host_no, (fsp->rport)->port_id);
    }
  } else {

  }
#line 1980
  sc_cmd->result = 65536;
#line 1981
  goto ldv_41982;
  case 10: 
#line 1983
  tmp___6 = ldv__builtin_expect((fc_debug_logging & 16U) != 0U, 0L);
#line 1983
  if (tmp___6 != 0L) {
#line 1983
    if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 1983
      _ep___6 = (struct fc_exch *)0;
#line 1983
      __mptr___6 = (struct fc_seq  const  *)fsp->seq_ptr;
#line 1983
      _ep___6 = (struct fc_exch *)__mptr___6 + 0xffffffffffffff64UL;
#line 1983
      printk("\016host%u: fcp: %6.6x: xid %04x-%04x: Returning DID_PARITY to scsi-ml due to FC_CRC_ERROR\n",
             ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )_ep___6->oxid,
             (int )_ep___6->rxid);
    } else {
#line 1983
      printk("\016host%u: fcp: %6.6x: Returning DID_PARITY to scsi-ml due to FC_CRC_ERROR\n",
             ((fsp->lp)->host)->host_no, (fsp->rport)->port_id);
    }
  } else {

  }
#line 1985
  sc_cmd->result = 393216;
#line 1986
  goto ldv_41982;
  case 11: 
#line 1988
  tmp___7 = ldv__builtin_expect((fc_debug_logging & 16U) != 0U, 0L);
#line 1988
  if (tmp___7 != 0L) {
#line 1988
    if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 1988
      _ep___7 = (struct fc_exch *)0;
#line 1988
      __mptr___7 = (struct fc_seq  const  *)fsp->seq_ptr;
#line 1988
      _ep___7 = (struct fc_exch *)__mptr___7 + 0xffffffffffffff64UL;
#line 1988
      printk("\016host%u: fcp: %6.6x: xid %04x-%04x: Returning DID_BUS_BUSY to scsi-ml due to FC_TIMED_OUT\n",
             ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )_ep___7->oxid,
             (int )_ep___7->rxid);
    } else {
#line 1988
      printk("\016host%u: fcp: %6.6x: Returning DID_BUS_BUSY to scsi-ml due to FC_TIMED_OUT\n",
             ((fsp->lp)->host)->host_no, (fsp->rport)->port_id);
    }
  } else {

  }
#line 1990
  sc_cmd->result = (int )(fsp->io_status | 131072U);
#line 1991
  goto ldv_41982;
  default: 
#line 1993
  tmp___8 = ldv__builtin_expect((fc_debug_logging & 16U) != 0U, 0L);
#line 1993
  if (tmp___8 != 0L) {
#line 1993
    if ((unsigned long )fsp->seq_ptr != (unsigned long )((struct fc_seq *)0)) {
#line 1993
      _ep___8 = (struct fc_exch *)0;
#line 1993
      __mptr___8 = (struct fc_seq  const  *)fsp->seq_ptr;
#line 1993
      _ep___8 = (struct fc_exch *)__mptr___8 + 0xffffffffffffff64UL;
#line 1993
      printk("\016host%u: fcp: %6.6x: xid %04x-%04x: Returning DID_ERROR to scsi-ml due to unknown error\n",
             ((fsp->lp)->host)->host_no, (fsp->rport)->port_id, (int )_ep___8->oxid,
             (int )_ep___8->rxid);
    } else {
#line 1993
      printk("\016host%u: fcp: %6.6x: Returning DID_ERROR to scsi-ml due to unknown error\n",
             ((fsp->lp)->host)->host_no, (fsp->rport)->port_id);
    }
  } else {

  }
#line 1995
  sc_cmd->result = 458752;
#line 1996
  goto ldv_41982;
  }
  ldv_41982: ;
#line 1999
  if ((unsigned int )lport->state != 14U && (unsigned int )fsp->status_code != 0U) {
#line 2000
    sc_cmd->result = 917504;
  } else {

  }
#line 2002
  ldv_spin_lock();
#line 2003
  list_del(& fsp->list);
#line 2004
  sc_cmd->SCp.ptr = (char *)0;
#line 2005
  spin_unlock_irqrestore(& si->scsi_queue_lock, flags);
#line 2006
  (*(sc_cmd->scsi_done))(sc_cmd);
#line 2009
  fc_fcp_pkt_release(fsp);
#line 2010
  return;
}
}
#line 2019 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
int fc_eh_abort(struct scsi_cmnd *sc_cmd ) 
{ 
  struct fc_fcp_pkt *fsp ;
  struct fc_lport *lport ;
  struct fc_fcp_internal *si ;
  int rc ;
  unsigned long flags ;
  int rval ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2024
  rc = 8195;
#line 2028
  rval = fc_block_scsi_eh(sc_cmd);
#line 2029
  if (rval != 0) {
#line 2030
    return (rval);
  } else {

  }
#line 2032
  tmp = shost_priv((sc_cmd->device)->host);
#line 2032
  lport = (struct fc_lport *)tmp;
#line 2033
  if ((unsigned int )lport->state != 14U) {
#line 2034
    return (rc);
  } else
#line 2035
  if ((unsigned int )lport->link_up == 0U) {
#line 2036
    return (rc);
  } else {

  }
#line 2038
  si = (struct fc_fcp_internal *)lport->scsi_priv;
#line 2039
  ldv_spin_lock();
#line 2040
  fsp = (struct fc_fcp_pkt *)sc_cmd->SCp.ptr;
#line 2041
  if ((unsigned long )fsp == (unsigned long )((struct fc_fcp_pkt *)0)) {
#line 2043
    spin_unlock_irqrestore(& si->scsi_queue_lock, flags);
#line 2044
    return (8194);
  } else {

  }
#line 2047
  fc_fcp_pkt_hold(fsp);
#line 2048
  spin_unlock_irqrestore(& si->scsi_queue_lock, flags);
#line 2050
  tmp___0 = fc_fcp_lock_pkt(fsp);
#line 2050
  if (tmp___0 != 0) {
#line 2052
    rc = 8194;
#line 2053
    goto release_pkt;
  } else {

  }
#line 2056
  rc = fc_fcp_pkt_abort(fsp);
#line 2057
  fc_fcp_unlock_pkt(fsp);
  release_pkt: 
#line 2060
  fc_fcp_pkt_release(fsp);
#line 2061
  return (rc);
}
}
#line 2063 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static char const   __kstrtab_fc_eh_abort[12U]  = 
#line 2063
  {      'f',      'c',      '_',      'e', 
        'h',      '_',      'a',      'b', 
        'o',      'r',      't',      '\000'};
#line 2063
struct kernel_symbol  const  __ksymtab_fc_eh_abort ;
#line 2063 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
struct kernel_symbol  const  __ksymtab_fc_eh_abort  =    {(unsigned long )(& fc_eh_abort), (char const   *)(& __kstrtab_fc_eh_abort)};
#line 2072 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
int fc_eh_device_reset(struct scsi_cmnd *sc_cmd ) 
{ 
  struct fc_lport *lport ;
  struct fc_fcp_pkt *fsp ;
  struct fc_rport *rport ;
  struct device  const  *__mptr ;
  struct scsi_target *tmp___1 ;
  struct fc_rport *tmp___2 ;
  struct scsi_target *tmp___3 ;
  int tmp___4 ;
  int rc ;
  int rval ;
  void *tmp___5 ;
  long tmp___6 ;
  unsigned int tmp___7 ;

  {
#line 2076
  tmp___3 = scsi_target(sc_cmd->device);
#line 2076
  tmp___4 = scsi_is_fc_rport((struct device  const  *)tmp___3->dev.parent);
#line 2076
  if (tmp___4 != 0) {
#line 2076
    tmp___1 = scsi_target(sc_cmd->device);
#line 2076
    __mptr = (struct device  const  *)tmp___1->dev.parent;
#line 2076
    tmp___2 = (struct fc_rport *)__mptr + 0xffffffffffffffa0UL;
  } else {
#line 2076
    tmp___2 = (struct fc_rport *)0;
  }
#line 2076
  rport = tmp___2;
#line 2077
  rc = 8195;
#line 2080
  rval = fc_block_scsi_eh(sc_cmd);
#line 2081
  if (rval != 0) {
#line 2082
    return (rval);
  } else {

  }
#line 2084
  tmp___5 = shost_priv((sc_cmd->device)->host);
#line 2084
  lport = (struct fc_lport *)tmp___5;
#line 2086
  if ((unsigned int )lport->state != 14U) {
#line 2087
    return (rc);
  } else {

  }
#line 2089
  tmp___6 = ldv__builtin_expect((fc_debug_logging & 128U) != 0U, 0L);
#line 2089
  if (tmp___6 != 0L) {
#line 2089
    printk("\016host%u: scsi: Resetting rport (%6.6x)\n", (lport->host)->host_no,
           rport->port_id);
  } else {

  }
#line 2091
  fsp = fc_fcp_pkt_alloc(lport, 16U);
#line 2092
  if ((unsigned long )fsp == (unsigned long )((struct fc_fcp_pkt *)0)) {
#line 2093
    printk("\flibfc: could not allocate scsi_pkt\n");
#line 2094
    goto out;
  } else {

  }
#line 2102
  fsp->rport = rport;
#line 2107
  tmp___7 = sdev_id(sc_cmd->device);
#line 2107
  rc = fc_lun_reset(lport, fsp, tmp___7, (unsigned int )(sc_cmd->device)->lun);
#line 2108
  fsp->state = 0U;
#line 2109
  fc_fcp_pkt_release(fsp);
  out: ;
#line 2112
  return (rc);
}
}
#line 2114 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static char const   __kstrtab_fc_eh_device_reset[19U]  = 
#line 2114
  {      'f',      'c',      '_',      'e', 
        'h',      '_',      'd',      'e', 
        'v',      'i',      'c',      'e', 
        '_',      'r',      'e',      's', 
        'e',      't',      '\000'};
#line 2114
struct kernel_symbol  const  __ksymtab_fc_eh_device_reset ;
#line 2114 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
struct kernel_symbol  const  __ksymtab_fc_eh_device_reset  =    {(unsigned long )(& fc_eh_device_reset), (char const   *)(& __kstrtab_fc_eh_device_reset)};
#line 2120 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
int fc_eh_host_reset(struct scsi_cmnd *sc_cmd ) 
{ 
  struct Scsi_Host *shost ;
  struct fc_lport *lport ;
  void *tmp ;
  unsigned long wait_tmo ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2122
  shost = (sc_cmd->device)->host;
#line 2123
  tmp = shost_priv(shost);
#line 2123
  lport = (struct fc_lport *)tmp;
#line 2126
  tmp___0 = ldv__builtin_expect((fc_debug_logging & 128U) != 0U, 0L);
#line 2126
  if (tmp___0 != 0L) {
#line 2126
    printk("\016host%u: scsi: Resetting host\n", (lport->host)->host_no);
  } else {

  }
#line 2128
  fc_block_scsi_eh(sc_cmd);
#line 2130
  (*(lport->tt.lport_reset))(lport);
#line 2131
  wait_tmo = (unsigned long )jiffies + 7500UL;
#line 2132
  goto ldv_42070;
  ldv_42069: 
#line 2134
  msleep(1000U);
  ldv_42070: 
#line 2132
  tmp___1 = fc_fcp_lport_queue_ready(lport);
#line 2132
  if (tmp___1 == 0 && (long )((unsigned long )jiffies - wait_tmo) < 0L) {
#line 2134
    goto ldv_42069;
  } else {

  }
#line 2136
  tmp___2 = fc_fcp_lport_queue_ready(lport);
#line 2136
  if (tmp___2 != 0) {
#line 2137
    dev_printk("\016", (struct device  const  *)(& shost->shost_gendev), "libfc: Host reset succeeded on port (%6.6x)\n",
               lport->port_id);
#line 2139
    return (8194);
  } else {
#line 2141
    dev_printk("\016", (struct device  const  *)(& shost->shost_gendev), "libfc: Host reset failed, port (%6.6x) is not ready.\n",
               lport->port_id);
#line 2144
    return (8195);
  }
}
}
#line 2147 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static char const   __kstrtab_fc_eh_host_reset[17U]  = 
#line 2147
  {      'f',      'c',      '_',      'e', 
        'h',      '_',      'h',      'o', 
        's',      't',      '_',      'r', 
        'e',      's',      'e',      't', 
        '\000'};
#line 2147
struct kernel_symbol  const  __ksymtab_fc_eh_host_reset ;
#line 2147 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
struct kernel_symbol  const  __ksymtab_fc_eh_host_reset  =    {(unsigned long )(& fc_eh_host_reset), (char const   *)(& __kstrtab_fc_eh_host_reset)};
#line 2156 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
int fc_slave_alloc(struct scsi_device *sdev ) 
{ 
  struct fc_rport *rport ;
  struct device  const  *__mptr ;
  struct scsi_target *tmp___1 ;
  struct fc_rport *tmp___2 ;
  struct scsi_target *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 2158
  tmp___3 = scsi_target(sdev);
#line 2158
  tmp___4 = scsi_is_fc_rport((struct device  const  *)tmp___3->dev.parent);
#line 2158
  if (tmp___4 != 0) {
#line 2158
    tmp___1 = scsi_target(sdev);
#line 2158
    __mptr = (struct device  const  *)tmp___1->dev.parent;
#line 2158
    tmp___2 = (struct fc_rport *)__mptr + 0xffffffffffffffa0UL;
  } else {
#line 2158
    tmp___2 = (struct fc_rport *)0;
  }
#line 2158
  rport = tmp___2;
#line 2160
  if ((unsigned long )rport == (unsigned long )((struct fc_rport *)0)) {
#line 2161
    return (-6);
  } else {
#line 2160
    tmp___5 = fc_remote_port_chkready(rport);
#line 2160
    if (tmp___5 != 0) {
#line 2161
      return (-6);
    } else {

    }
  }
#line 2163
  scsi_change_queue_depth(sdev, 32);
#line 2164
  return (0);
}
}
#line 2166 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static char const   __kstrtab_fc_slave_alloc[15U]  = 
#line 2166
  {      'f',      'c',      '_',      's', 
        'l',      'a',      'v',      'e', 
        '_',      'a',      'l',      'l', 
        'o',      'c',      '\000'};
#line 2166
struct kernel_symbol  const  __ksymtab_fc_slave_alloc ;
#line 2166 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
struct kernel_symbol  const  __ksymtab_fc_slave_alloc  =    {(unsigned long )(& fc_slave_alloc), (char const   *)(& __kstrtab_fc_slave_alloc)};
#line 2172 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
void fc_fcp_destroy(struct fc_lport *lport ) 
{ 
  struct fc_fcp_internal *si ;
  int tmp ;

  {
#line 2174
  si = (struct fc_fcp_internal *)lport->scsi_priv;
#line 2176
  tmp = list_empty((struct list_head  const  *)(& si->scsi_pkt_queue));
#line 2176
  if (tmp == 0) {
#line 2177
    printk("\vlibfc: Leaked SCSI packets when destroying port (%6.6x)\n", lport->port_id);
  } else {

  }
#line 2180
  mempool_destroy(si->scsi_pkt_pool);
#line 2181
  kfree((void const   *)si);
#line 2182
  lport->scsi_priv = (void *)0;
#line 2183
  return;
}
}
#line 2184 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static char const   __kstrtab_fc_fcp_destroy[15U]  = 
#line 2184
  {      'f',      'c',      '_',      'f', 
        'c',      'p',      '_',      'd', 
        'e',      's',      't',      'r', 
        'o',      'y',      '\000'};
#line 2184
struct kernel_symbol  const  __ksymtab_fc_fcp_destroy ;
#line 2184 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
struct kernel_symbol  const  __ksymtab_fc_fcp_destroy  =    {(unsigned long )(& fc_fcp_destroy), (char const   *)(& __kstrtab_fc_fcp_destroy)};
#line 2186 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
int fc_setup_fcp(void) 
{ 
  int rc ;

  {
#line 2188
  rc = 0;
#line 2190
  scsi_pkt_cachep = kmem_cache_create("libfc_fcp_pkt", 448UL, 0UL, 8192UL, (void (*)(void * ))0);
#line 2193
  if ((unsigned long )scsi_pkt_cachep == (unsigned long )((struct kmem_cache *)0)) {
#line 2194
    printk("\vlibfc: Unable to allocate SRB cache, module load failed!");
#line 2196
    rc = -12;
  } else {

  }
#line 2199
  return (rc);
}
}
#line 2202 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
void fc_destroy_fcp(void) 
{ 


  {
#line 2204
  if ((unsigned long )scsi_pkt_cachep != (unsigned long )((struct kmem_cache *)0)) {
#line 2205
    kmem_cache_destroy(scsi_pkt_cachep);
  } else {

  }
#line 2206
  return;
}
}
#line 2212 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
int fc_fcp_init(struct fc_lport *lport ) 
{ 
  int rc ;
  struct fc_fcp_internal *si ;
  void *tmp ;
  struct lock_class_key __key ;

  {
#line 2217
  if ((unsigned long )lport->tt.fcp_cmd_send == (unsigned long )((int (*)(struct fc_lport * ,
                                                                          struct fc_fcp_pkt * ,
                                                                          void (*)(struct fc_seq * ,
                                                                                   struct fc_frame * ,
                                                                                   void * ) ))0)) {
#line 2218
    lport->tt.fcp_cmd_send = & fc_fcp_cmd_send;
  } else {

  }
#line 2220
  if ((unsigned long )lport->tt.fcp_cleanup == (unsigned long )((void (*)(struct fc_lport * ))0)) {
#line 2221
    lport->tt.fcp_cleanup = & fc_fcp_cleanup;
  } else {

  }
#line 2223
  if ((unsigned long )lport->tt.fcp_abort_io == (unsigned long )((void (*)(struct fc_lport * ))0)) {
#line 2224
    lport->tt.fcp_abort_io = & fc_fcp_abort_io;
  } else {

  }
#line 2226
  tmp = kzalloc(120UL, 208U);
#line 2226
  si = (struct fc_fcp_internal *)tmp;
#line 2227
  if ((unsigned long )si == (unsigned long )((struct fc_fcp_internal *)0)) {
#line 2228
    return (-12);
  } else {

  }
#line 2229
  lport->scsi_priv = (void *)si;
#line 2230
  si->max_can_queue = (lport->host)->can_queue;
#line 2231
  INIT_LIST_HEAD(& si->scsi_pkt_queue);
#line 2232
  spinlock_check(& si->scsi_queue_lock);
#line 2232
  __raw_spin_lock_init(& si->scsi_queue_lock.__annonCompField18.rlock, "&(&si->scsi_queue_lock)->rlock",
                       & __key);
#line 2234
  si->scsi_pkt_pool = mempool_create_slab_pool(2, scsi_pkt_cachep);
#line 2235
  if ((unsigned long )si->scsi_pkt_pool == (unsigned long )((mempool_t *)0)) {
#line 2236
    rc = -12;
#line 2237
    goto free_internal;
  } else {

  }
#line 2239
  return (0);
  free_internal: 
#line 2242
  kfree((void const   *)si);
#line 2243
  return (rc);
}
}
#line 2245 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
static char const   __kstrtab_fc_fcp_init[12U]  = 
#line 2245
  {      'f',      'c',      '_',      'f', 
        'c',      'p',      '_',      'i', 
        'n',      'i',      't',      '\000'};
#line 2245
struct kernel_symbol  const  __ksymtab_fc_fcp_init ;
#line 2245 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.c"
struct kernel_symbol  const  __ksymtab_fc_fcp_init  =    {(unsigned long )(& fc_fcp_init), (char const   *)(& __kstrtab_fc_fcp_init)};
#line 152 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
void activate_suitable_timer_6(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 153
  if (ldv_timer_6_0 == 0 || ldv_timer_6_0 == 2) {
#line 154
    ldv_timer_list_6_0 = timer;
#line 155
    ldv_timer_list_6_0->data = data;
#line 156
    ldv_timer_6_0 = 1;
#line 157
    return;
  } else {

  }
#line 159
  if (ldv_timer_6_1 == 0 || ldv_timer_6_1 == 2) {
#line 160
    ldv_timer_list_6_1 = timer;
#line 161
    ldv_timer_list_6_1->data = data;
#line 162
    ldv_timer_6_1 = 1;
#line 163
    return;
  } else {

  }
#line 165
  if (ldv_timer_6_2 == 0 || ldv_timer_6_2 == 2) {
#line 166
    ldv_timer_list_6_2 = timer;
#line 167
    ldv_timer_list_6_2->data = data;
#line 168
    ldv_timer_6_2 = 1;
#line 169
    return;
  } else {

  }
#line 171
  if (ldv_timer_6_3 == 0 || ldv_timer_6_3 == 2) {
#line 172
    ldv_timer_list_6_3 = timer;
#line 173
    ldv_timer_list_6_3->data = data;
#line 174
    ldv_timer_6_3 = 1;
#line 175
    return;
  } else {

  }
#line 177
  return;
}
}
#line 181 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
int reg_timer_7(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 182
  if ((unsigned long )function == (unsigned long )(& fc_lun_reset_send)) {
#line 183
    activate_suitable_timer_7(timer, data);
  } else {

  }
#line 184
  return (0);
}
}
#line 188 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
void choose_timer_8(struct timer_list *timer ) 
{ 


  {
#line 189
  LDV_IN_INTERRUPT = 2;
#line 190
  (*(timer->function))(timer->data);
#line 191
  LDV_IN_INTERRUPT = 1;
#line 192
  ldv_timer_state_8 = 2;
#line 193
  return;
}
}
#line 196 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
void disable_suitable_timer_7(struct timer_list *timer ) 
{ 


  {
#line 197
  if (ldv_timer_7_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_7_0) {
#line 198
    ldv_timer_7_0 = 0;
#line 199
    return;
  } else {

  }
#line 201
  if (ldv_timer_7_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_7_1) {
#line 202
    ldv_timer_7_1 = 0;
#line 203
    return;
  } else {

  }
#line 205
  if (ldv_timer_7_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_7_2) {
#line 206
    ldv_timer_7_2 = 0;
#line 207
    return;
  } else {

  }
#line 209
  if (ldv_timer_7_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_7_3) {
#line 210
    ldv_timer_7_3 = 0;
#line 211
    return;
  } else {

  }
#line 213
  return;
}
}
#line 217 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
int reg_timer_8(struct timer_list *timer ) 
{ 


  {
#line 218
  ldv_timer_list_8 = timer;
#line 219
  ldv_timer_state_8 = 1;
#line 220
  return (0);
}
}
#line 223 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
void choose_timer_6(void) 
{ 
  int tmp ;

  {
#line 224
  tmp = __VERIFIER_nondet_int();
#line 224
  switch (tmp) {
  case 0: ;
#line 226
  if (ldv_timer_6_0 == 1) {
#line 227
    ldv_timer_6_0 = 2;
#line 228
    ldv_timer_6(ldv_timer_6_0, ldv_timer_list_6_0);
  } else {

  }
#line 231
  goto ldv_42147;
  case 1: ;
#line 233
  if (ldv_timer_6_1 == 1) {
#line 234
    ldv_timer_6_1 = 2;
#line 235
    ldv_timer_6(ldv_timer_6_1, ldv_timer_list_6_1);
  } else {

  }
#line 238
  goto ldv_42147;
  case 2: ;
#line 240
  if (ldv_timer_6_2 == 1) {
#line 241
    ldv_timer_6_2 = 2;
#line 242
    ldv_timer_6(ldv_timer_6_2, ldv_timer_list_6_2);
  } else {

  }
#line 245
  goto ldv_42147;
  case 3: ;
#line 247
  if (ldv_timer_6_3 == 1) {
#line 248
    ldv_timer_6_3 = 2;
#line 249
    ldv_timer_6(ldv_timer_6_3, ldv_timer_list_6_3);
  } else {

  }
#line 252
  goto ldv_42147;
  default: 
#line 253
  ldv_stop();
  }
  ldv_42147: ;
#line 255
  return;
}
}
#line 259 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
int reg_timer_6(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 260
  if ((unsigned long )function == (unsigned long )(& fc_fcp_timeout)) {
#line 261
    activate_suitable_timer_6(timer, data);
  } else {

  }
#line 262
  return (0);
}
}
#line 266 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
void disable_suitable_timer_8(struct timer_list *timer ) 
{ 


  {
#line 267
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_8) {
#line 268
    ldv_timer_state_8 = 0;
#line 269
    return;
  } else {

  }
#line 271
  return;
}
}
#line 274 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
void timer_init_7(void) 
{ 


  {
#line 275
  ldv_timer_7_0 = 0;
#line 276
  ldv_timer_7_1 = 0;
#line 277
  ldv_timer_7_2 = 0;
#line 278
  ldv_timer_7_3 = 0;
#line 279
  return;
}
}
#line 282 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
void ldv_timer_6(int state , struct timer_list *timer ) 
{ 


  {
#line 283
  LDV_IN_INTERRUPT = 2;
#line 284
  fc_fcp_timeout(timer->data);
#line 285
  LDV_IN_INTERRUPT = 1;
#line 286
  return;
}
}
#line 289 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
void timer_init_6(void) 
{ 


  {
#line 290
  ldv_timer_6_0 = 0;
#line 291
  ldv_timer_6_1 = 0;
#line 292
  ldv_timer_6_2 = 0;
#line 293
  ldv_timer_6_3 = 0;
#line 294
  return;
}
}
#line 297 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
void activate_pending_timer_8(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 297
  if ((unsigned long )ldv_timer_list_8 == (unsigned long )timer) {
#line 298
    if (ldv_timer_state_8 == 2 || pending_flag != 0) {
#line 299
      ldv_timer_list_8 = timer;
#line 300
      ldv_timer_list_8->data = data;
#line 301
      ldv_timer_state_8 = 1;
    } else {

    }
#line 303
    return;
  } else {

  }
#line 305
  reg_timer_8(timer);
#line 306
  ldv_timer_list_8->data = data;
#line 307
  return;
}
}
#line 310 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
void ldv_timer_7(int state , struct timer_list *timer ) 
{ 


  {
#line 311
  LDV_IN_INTERRUPT = 2;
#line 312
  fc_lun_reset_send(timer->data);
#line 313
  LDV_IN_INTERRUPT = 1;
#line 314
  return;
}
}
#line 317 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
void choose_timer_7(void) 
{ 
  int tmp ;

  {
#line 318
  tmp = __VERIFIER_nondet_int();
#line 318
  switch (tmp) {
  case 0: ;
#line 320
  if (ldv_timer_7_0 == 1) {
#line 321
    ldv_timer_7_0 = 2;
#line 322
    ldv_timer_7(ldv_timer_7_0, ldv_timer_list_7_0);
  } else {

  }
#line 325
  goto ldv_42184;
  case 1: ;
#line 327
  if (ldv_timer_7_1 == 1) {
#line 328
    ldv_timer_7_1 = 2;
#line 329
    ldv_timer_7(ldv_timer_7_1, ldv_timer_list_7_1);
  } else {

  }
#line 332
  goto ldv_42184;
  case 2: ;
#line 334
  if (ldv_timer_7_2 == 1) {
#line 335
    ldv_timer_7_2 = 2;
#line 336
    ldv_timer_7(ldv_timer_7_2, ldv_timer_list_7_2);
  } else {

  }
#line 339
  goto ldv_42184;
  case 3: ;
#line 341
  if (ldv_timer_7_3 == 1) {
#line 342
    ldv_timer_7_3 = 2;
#line 343
    ldv_timer_7(ldv_timer_7_3, ldv_timer_list_7_3);
  } else {

  }
#line 346
  goto ldv_42184;
  default: 
#line 347
  ldv_stop();
  }
  ldv_42184: ;
#line 349
  return;
}
}
#line 353 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
void disable_suitable_timer_6(struct timer_list *timer ) 
{ 


  {
#line 354
  if (ldv_timer_6_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_0) {
#line 355
    ldv_timer_6_0 = 0;
#line 356
    return;
  } else {

  }
#line 358
  if (ldv_timer_6_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_1) {
#line 359
    ldv_timer_6_1 = 0;
#line 360
    return;
  } else {

  }
#line 362
  if (ldv_timer_6_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_2) {
#line 363
    ldv_timer_6_2 = 0;
#line 364
    return;
  } else {

  }
#line 366
  if (ldv_timer_6_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_3) {
#line 367
    ldv_timer_6_3 = 0;
#line 368
    return;
  } else {

  }
#line 370
  return;
}
}
#line 374 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
void activate_pending_timer_7(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 375
  if ((unsigned long )ldv_timer_list_7_0 == (unsigned long )timer) {
#line 376
    if (ldv_timer_7_0 == 2 || pending_flag != 0) {
#line 377
      ldv_timer_list_7_0 = timer;
#line 378
      ldv_timer_list_7_0->data = data;
#line 379
      ldv_timer_7_0 = 1;
    } else {

    }
#line 381
    return;
  } else {

  }
#line 384
  if ((unsigned long )ldv_timer_list_7_1 == (unsigned long )timer) {
#line 385
    if (ldv_timer_7_1 == 2 || pending_flag != 0) {
#line 386
      ldv_timer_list_7_1 = timer;
#line 387
      ldv_timer_list_7_1->data = data;
#line 388
      ldv_timer_7_1 = 1;
    } else {

    }
#line 390
    return;
  } else {

  }
#line 393
  if ((unsigned long )ldv_timer_list_7_2 == (unsigned long )timer) {
#line 394
    if (ldv_timer_7_2 == 2 || pending_flag != 0) {
#line 395
      ldv_timer_list_7_2 = timer;
#line 396
      ldv_timer_list_7_2->data = data;
#line 397
      ldv_timer_7_2 = 1;
    } else {

    }
#line 399
    return;
  } else {

  }
#line 402
  if ((unsigned long )ldv_timer_list_7_3 == (unsigned long )timer) {
#line 403
    if (ldv_timer_7_3 == 2 || pending_flag != 0) {
#line 404
      ldv_timer_list_7_3 = timer;
#line 405
      ldv_timer_list_7_3->data = data;
#line 406
      ldv_timer_7_3 = 1;
    } else {

    }
#line 408
    return;
  } else {

  }
#line 410
  activate_suitable_timer_7(timer, data);
#line 411
  return;
}
}
#line 414 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
void activate_pending_timer_6(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 415
  if ((unsigned long )ldv_timer_list_6_0 == (unsigned long )timer) {
#line 416
    if (ldv_timer_6_0 == 2 || pending_flag != 0) {
#line 417
      ldv_timer_list_6_0 = timer;
#line 418
      ldv_timer_list_6_0->data = data;
#line 419
      ldv_timer_6_0 = 1;
    } else {

    }
#line 421
    return;
  } else {

  }
#line 424
  if ((unsigned long )ldv_timer_list_6_1 == (unsigned long )timer) {
#line 425
    if (ldv_timer_6_1 == 2 || pending_flag != 0) {
#line 426
      ldv_timer_list_6_1 = timer;
#line 427
      ldv_timer_list_6_1->data = data;
#line 428
      ldv_timer_6_1 = 1;
    } else {

    }
#line 430
    return;
  } else {

  }
#line 433
  if ((unsigned long )ldv_timer_list_6_2 == (unsigned long )timer) {
#line 434
    if (ldv_timer_6_2 == 2 || pending_flag != 0) {
#line 435
      ldv_timer_list_6_2 = timer;
#line 436
      ldv_timer_list_6_2->data = data;
#line 437
      ldv_timer_6_2 = 1;
    } else {

    }
#line 439
    return;
  } else {

  }
#line 442
  if ((unsigned long )ldv_timer_list_6_3 == (unsigned long )timer) {
#line 443
    if (ldv_timer_6_3 == 2 || pending_flag != 0) {
#line 444
      ldv_timer_list_6_3 = timer;
#line 445
      ldv_timer_list_6_3->data = data;
#line 446
      ldv_timer_6_3 = 1;
    } else {

    }
#line 448
    return;
  } else {

  }
#line 450
  activate_suitable_timer_6(timer, data);
#line 451
  return;
}
}
#line 454 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
void activate_suitable_timer_7(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 455
  if (ldv_timer_7_0 == 0 || ldv_timer_7_0 == 2) {
#line 456
    ldv_timer_list_7_0 = timer;
#line 457
    ldv_timer_list_7_0->data = data;
#line 458
    ldv_timer_7_0 = 1;
#line 459
    return;
  } else {

  }
#line 461
  if (ldv_timer_7_1 == 0 || ldv_timer_7_1 == 2) {
#line 462
    ldv_timer_list_7_1 = timer;
#line 463
    ldv_timer_list_7_1->data = data;
#line 464
    ldv_timer_7_1 = 1;
#line 465
    return;
  } else {

  }
#line 467
  if (ldv_timer_7_2 == 0 || ldv_timer_7_2 == 2) {
#line 468
    ldv_timer_list_7_2 = timer;
#line 469
    ldv_timer_list_7_2->data = data;
#line 470
    ldv_timer_7_2 = 1;
#line 471
    return;
  } else {

  }
#line 473
  if (ldv_timer_7_3 == 0 || ldv_timer_7_3 == 2) {
#line 474
    ldv_timer_list_7_3 = timer;
#line 475
    ldv_timer_list_7_3->data = data;
#line 476
    ldv_timer_7_3 = 1;
#line 477
    return;
  } else {

  }
#line 479
  return;
}
}
#line 565 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 568
  ldv_spin_unlock();
#line 570
  ldv_spin_unlock_irqrestore_356(lock, flags);
#line 571
  return;
}
}
#line 595 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
bool ldv_queue_work_on_359(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 599
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 599
  ldv_func_res = tmp;
#line 601
  activate_work_3(ldv_func_arg3, 2);
#line 603
  return (ldv_func_res);
}
}
#line 606 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
bool ldv_queue_delayed_work_on_360(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 610
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 610
  ldv_func_res = tmp;
#line 612
  activate_work_3(& ldv_func_arg3->work, 2);
#line 614
  return (ldv_func_res);
}
}
#line 617 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
bool ldv_queue_work_on_361(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  bool tmp ;

  {
#line 621
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 621
  ldv_func_res = tmp;
#line 623
  activate_work_3(ldv_func_arg3, 2);
#line 625
  return (ldv_func_res);
}
}
#line 628 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
void ldv_flush_workqueue_362(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 631
  flush_workqueue(ldv_func_arg1);
#line 633
  call_and_disable_all_3(2);
#line 634
  return;
}
}
#line 636 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
bool ldv_queue_delayed_work_on_363(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
#line 640
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 640
  ldv_func_res = tmp;
#line 642
  activate_work_3(& ldv_func_arg3->work, 2);
#line 644
  return (ldv_func_res);
}
}
#line 682 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
void *ldv_kmem_cache_alloc_369(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 685
  ldv_check_alloc_flags(flags);
#line 686
  tmp = ldv_undef_ptr();
#line 686
  return (tmp);
}
}
#line 724 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
int ldv_pskb_expand_head_375(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 727
  ldv_check_alloc_flags(flags);
#line 728
  tmp = ldv_undef_ptr();
#line 728
  return ((int )((long )tmp));
}
}
#line 738 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
struct sk_buff *ldv_skb_clone_377(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 741
  ldv_check_alloc_flags(flags);
#line 742
  tmp = ldv_undef_ptr();
#line 742
  return ((struct sk_buff *)tmp);
}
}
#line 752 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
struct sk_buff *ldv_skb_copy_379(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 755
  ldv_check_alloc_flags(flags);
#line 756
  tmp = ldv_undef_ptr();
#line 756
  return ((struct sk_buff *)tmp);
}
}
#line 759 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_380(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 762
  ldv_check_alloc_flags(flags);
#line 763
  tmp = ldv_undef_ptr();
#line 763
  return ((struct sk_buff *)tmp);
}
}
#line 766 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_381(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 769
  ldv_check_alloc_flags(flags);
#line 770
  tmp = ldv_undef_ptr();
#line 770
  return ((struct sk_buff *)tmp);
}
}
#line 773 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_382(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 776
  ldv_check_alloc_flags(flags);
#line 777
  tmp = ldv_undef_ptr();
#line 777
  return ((struct sk_buff *)tmp);
}
}
#line 780 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
int ldv_pskb_expand_head_383(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 783
  ldv_check_alloc_flags(flags);
#line 784
  tmp = ldv_undef_ptr();
#line 784
  return ((int )((long )tmp));
}
}
#line 787 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
int ldv_pskb_expand_head_384(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 790
  ldv_check_alloc_flags(flags);
#line 791
  tmp = ldv_undef_ptr();
#line 791
  return ((int )((long )tmp));
}
}
#line 794 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
struct sk_buff *ldv_skb_clone_385(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 797
  ldv_check_alloc_flags(flags);
#line 798
  tmp = ldv_undef_ptr();
#line 798
  return ((struct sk_buff *)tmp);
}
}
#line 801 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
void *ldv_mempool_alloc_386(mempool_t *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 804
  ldv_check_alloc_flags(flags);
#line 805
  tmp = ldv_undef_ptr();
#line 805
  return (tmp);
}
}
#line 808 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
int ldv_mod_timer_387(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
#line 812
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 812
  ldv_func_res = tmp;
#line 814
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 816
  return (ldv_func_res);
}
}
#line 819 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
int ldv_del_timer_sync_388(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;

  {
#line 823
  tmp = del_timer_sync(ldv_func_arg1);
#line 823
  ldv_func_res = tmp;
#line 825
  disable_suitable_timer_6(ldv_func_arg1);
#line 827
  return (ldv_func_res);
}
}
#line 830 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_fcp.o.c.prepared"
int ldv_del_timer_sync_389(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
#line 834
  tmp = del_timer_sync(ldv_func_arg1);
#line 834
  ldv_func_res = tmp;
#line 836
  disable_suitable_timer_6(ldv_func_arg1);
#line 838
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_412(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_414(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_413(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_416(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_415(struct workqueue_struct *ldv_func_arg1 ) ;
#line 293 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_422(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 789 "include/scsi/scsi_host.h"
extern struct Scsi_Host *scsi_host_alloc(struct scsi_host_template * , int  ) ;
#line 849 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_430(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 853
struct sk_buff *ldv_skb_clone_438(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 858
struct sk_buff *ldv_skb_copy_432(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 871
int ldv_pskb_expand_head_428(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 875
int ldv_pskb_expand_head_436(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 879
int ldv_pskb_expand_head_437(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2148
struct sk_buff *ldv___netdev_alloc_skb_433(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2152
struct sk_buff *ldv___netdev_alloc_skb_434(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2156
struct sk_buff *ldv___netdev_alloc_skb_435(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 1030 "include/scsi/libfc.h"
__inline static struct fc_lport *libfc_host_alloc(struct scsi_host_template *sht ,
                                                  int priv_size ) 
{ 
  struct fc_lport *lport ;
  struct Scsi_Host *shost ;
  void *tmp ;

  {
#line 1035
  shost = scsi_host_alloc(sht, (int )((unsigned int )priv_size + 1688U));
#line 1036
  if ((unsigned long )shost == (unsigned long )((struct Scsi_Host *)0)) {
#line 1037
    return ((struct fc_lport *)0);
  } else {

  }
#line 1038
  tmp = shost_priv(shost);
#line 1038
  lport = (struct fc_lport *)tmp;
#line 1039
  lport->host = shost;
#line 1040
  INIT_LIST_HEAD(& lport->ema_list);
#line 1041
  INIT_LIST_HEAD(& lport->vports);
#line 1042
  return (lport);
}
}
#line 1066
void fc_vport_setlink(struct fc_lport *vn_port ) ;
#line 1071
struct fc_lport *libfc_vport_create(struct fc_vport *vport , int privsize ) ;
#line 33 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.c"
struct fc_lport *libfc_vport_create(struct fc_vport *vport , int privsize ) 
{ 
  struct Scsi_Host *shost ;
  struct fc_lport *n_port ;
  void *tmp ;
  struct fc_lport *vn_port ;

  {
#line 35
  shost = vport->shost;
#line 36
  tmp = shost_priv(shost);
#line 36
  n_port = (struct fc_lport *)tmp;
#line 39
  vn_port = libfc_host_alloc(shost->hostt, privsize);
#line 40
  if ((unsigned long )vn_port == (unsigned long )((struct fc_lport *)0)) {
#line 41
    return (vn_port);
  } else {

  }
#line 43
  vn_port->vport = vport;
#line 44
  vport->dd_data = (void *)vn_port;
#line 46
  mutex_lock_nested(& n_port->lp_mutex, 0U);
#line 47
  list_add_tail(& vn_port->list, & n_port->vports);
#line 48
  mutex_unlock(& n_port->lp_mutex);
#line 50
  return (vn_port);
}
}
#line 52 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.c"
static char const   __kstrtab_libfc_vport_create[19U]  = 
#line 52
  {      'l',      'i',      'b',      'f', 
        'c',      '_',      'v',      'p', 
        'o',      'r',      't',      '_', 
        'c',      'r',      'e',      'a', 
        't',      'e',      '\000'};
#line 52
struct kernel_symbol  const  __ksymtab_libfc_vport_create ;
#line 52 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.c"
struct kernel_symbol  const  __ksymtab_libfc_vport_create  =    {(unsigned long )(& libfc_vport_create), (char const   *)(& __kstrtab_libfc_vport_create)};
#line 61 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.c"
struct fc_lport *fc_vport_id_lookup(struct fc_lport *n_port , u32 port_id ) 
{ 
  struct fc_lport *lport ;
  struct fc_lport *vn_port ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 63
  lport = (struct fc_lport *)0;
#line 66
  if (n_port->port_id == port_id) {
#line 67
    return (n_port);
  } else {

  }
#line 69
  if (port_id == 16777214U) {
#line 70
    return (n_port);
  } else {

  }
#line 72
  mutex_lock_nested(& n_port->lp_mutex, 0U);
#line 73
  __mptr = (struct list_head  const  *)n_port->vports.next;
#line 73
  vn_port = (struct fc_lport *)__mptr + 0xfffffffffffffab0UL;
#line 73
  goto ldv_40825;
  ldv_40824: ;
#line 74
  if (vn_port->port_id == port_id) {
#line 75
    lport = vn_port;
#line 76
    goto ldv_40823;
  } else {

  }
#line 73
  __mptr___0 = (struct list_head  const  *)vn_port->list.next;
#line 73
  vn_port = (struct fc_lport *)__mptr___0 + 0xfffffffffffffab0UL;
  ldv_40825: ;
#line 73
  if ((unsigned long )(& vn_port->list) != (unsigned long )(& n_port->vports)) {
#line 75
    goto ldv_40824;
  } else {

  }
  ldv_40823: 
#line 79
  mutex_unlock(& n_port->lp_mutex);
#line 81
  return (lport);
}
}
#line 83 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.c"
static char const   __kstrtab_fc_vport_id_lookup[19U]  = 
#line 83
  {      'f',      'c',      '_',      'v', 
        'p',      'o',      'r',      't', 
        '_',      'i',      'd',      '_', 
        'l',      'o',      'o',      'k', 
        'u',      'p',      '\000'};
#line 83
struct kernel_symbol  const  __ksymtab_fc_vport_id_lookup ;
#line 83 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.c"
struct kernel_symbol  const  __ksymtab_fc_vport_id_lookup  =    {(unsigned long )(& fc_vport_id_lookup), (char const   *)(& __kstrtab_fc_vport_id_lookup)};
#line 103 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.c"
static void __fc_vport_setlink(struct fc_lport *n_port , struct fc_lport *vn_port ) 
{ 
  struct fc_vport *vport ;

  {
#line 106
  vport = vn_port->vport;
#line 108
  if ((unsigned int )vn_port->state == 0U) {
#line 109
    return;
  } else {

  }
#line 111
  if ((unsigned int )n_port->state == 14U) {
#line 112
    if ((unsigned int )*((unsigned char *)n_port + 1144UL) != 0U) {
#line 113
      fc_vport_set_state(vport, 4);
#line 114
      __fc_linkup(vn_port);
    } else {
#line 116
      fc_vport_set_state(vport, 5);
#line 117
      __fc_linkdown(vn_port);
    }
  } else {
#line 120
    fc_vport_set_state(vport, 3);
#line 121
    __fc_linkdown(vn_port);
  }
#line 123
  return;
}
}
#line 129 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.c"
void fc_vport_setlink(struct fc_lport *vn_port ) 
{ 
  struct fc_vport *vport ;
  struct Scsi_Host *shost ;
  struct fc_lport *n_port ;
  void *tmp ;

  {
#line 131
  vport = vn_port->vport;
#line 132
  shost = vport->shost;
#line 133
  tmp = shost_priv(shost);
#line 133
  n_port = (struct fc_lport *)tmp;
#line 135
  mutex_lock_nested(& n_port->lp_mutex, 0U);
#line 136
  mutex_lock_nested(& vn_port->lp_mutex, 1U);
#line 137
  __fc_vport_setlink(n_port, vn_port);
#line 138
  mutex_unlock(& vn_port->lp_mutex);
#line 139
  mutex_unlock(& n_port->lp_mutex);
#line 140
  return;
}
}
#line 141 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.c"
static char const   __kstrtab_fc_vport_setlink[17U]  = 
#line 141
  {      'f',      'c',      '_',      'v', 
        'p',      'o',      'r',      't', 
        '_',      's',      'e',      't', 
        'l',      'i',      'n',      'k', 
        '\000'};
#line 141
struct kernel_symbol  const  __ksymtab_fc_vport_setlink ;
#line 141 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.c"
struct kernel_symbol  const  __ksymtab_fc_vport_setlink  =    {(unsigned long )(& fc_vport_setlink), (char const   *)(& __kstrtab_fc_vport_setlink)};
#line 149 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.c"
void fc_vports_linkchange(struct fc_lport *n_port ) 
{ 
  struct fc_lport *vn_port ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 153
  __mptr = (struct list_head  const  *)n_port->vports.next;
#line 153
  vn_port = (struct fc_lport *)__mptr + 0xfffffffffffffab0UL;
#line 153
  goto ldv_40864;
  ldv_40863: 
#line 154
  mutex_lock_nested(& vn_port->lp_mutex, 1U);
#line 155
  __fc_vport_setlink(n_port, vn_port);
#line 156
  mutex_unlock(& vn_port->lp_mutex);
#line 153
  __mptr___0 = (struct list_head  const  *)vn_port->list.next;
#line 153
  vn_port = (struct fc_lport *)__mptr___0 + 0xfffffffffffffab0UL;
  ldv_40864: ;
#line 153
  if ((unsigned long )(& vn_port->list) != (unsigned long )(& n_port->vports)) {
#line 155
    goto ldv_40863;
  } else {

  }

#line 160
  return;
}
}
#line 264 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.o.c.prepared"
bool ldv_queue_work_on_412(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 268
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 268
  ldv_func_res = tmp;
#line 270
  activate_work_3(ldv_func_arg3, 2);
#line 272
  return (ldv_func_res);
}
}
#line 275 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.o.c.prepared"
bool ldv_queue_delayed_work_on_413(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 279
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 279
  ldv_func_res = tmp;
#line 281
  activate_work_3(& ldv_func_arg3->work, 2);
#line 283
  return (ldv_func_res);
}
}
#line 286 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.o.c.prepared"
bool ldv_queue_work_on_414(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  bool tmp ;

  {
#line 290
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 290
  ldv_func_res = tmp;
#line 292
  activate_work_3(ldv_func_arg3, 2);
#line 294
  return (ldv_func_res);
}
}
#line 297 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.o.c.prepared"
void ldv_flush_workqueue_415(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 300
  flush_workqueue(ldv_func_arg1);
#line 302
  call_and_disable_all_3(2);
#line 303
  return;
}
}
#line 305 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.o.c.prepared"
bool ldv_queue_delayed_work_on_416(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
#line 309
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 309
  ldv_func_res = tmp;
#line 311
  activate_work_3(& ldv_func_arg3->work, 2);
#line 313
  return (ldv_func_res);
}
}
#line 351 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.o.c.prepared"
void *ldv_kmem_cache_alloc_422(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 354
  ldv_check_alloc_flags(flags);
#line 355
  tmp = ldv_undef_ptr();
#line 355
  return (tmp);
}
}
#line 393 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.o.c.prepared"
int ldv_pskb_expand_head_428(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 396
  ldv_check_alloc_flags(flags);
#line 397
  tmp = ldv_undef_ptr();
#line 397
  return ((int )((long )tmp));
}
}
#line 407 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.o.c.prepared"
struct sk_buff *ldv_skb_clone_430(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 410
  ldv_check_alloc_flags(flags);
#line 411
  tmp = ldv_undef_ptr();
#line 411
  return ((struct sk_buff *)tmp);
}
}
#line 421 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.o.c.prepared"
struct sk_buff *ldv_skb_copy_432(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 424
  ldv_check_alloc_flags(flags);
#line 425
  tmp = ldv_undef_ptr();
#line 425
  return ((struct sk_buff *)tmp);
}
}
#line 428 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_433(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 431
  ldv_check_alloc_flags(flags);
#line 432
  tmp = ldv_undef_ptr();
#line 432
  return ((struct sk_buff *)tmp);
}
}
#line 435 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_434(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 438
  ldv_check_alloc_flags(flags);
#line 439
  tmp = ldv_undef_ptr();
#line 439
  return ((struct sk_buff *)tmp);
}
}
#line 442 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_435(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 445
  ldv_check_alloc_flags(flags);
#line 446
  tmp = ldv_undef_ptr();
#line 446
  return ((struct sk_buff *)tmp);
}
}
#line 449 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.o.c.prepared"
int ldv_pskb_expand_head_436(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 452
  ldv_check_alloc_flags(flags);
#line 453
  tmp = ldv_undef_ptr();
#line 453
  return ((int )((long )tmp));
}
}
#line 456 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.o.c.prepared"
int ldv_pskb_expand_head_437(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 459
  ldv_check_alloc_flags(flags);
#line 460
  tmp = ldv_undef_ptr();
#line 460
  return ((int )((long )tmp));
}
}
#line 463 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/dscv/ri/43_2a/drivers/scsi/libfc/fc_npiv.o.c.prepared"
struct sk_buff *ldv_skb_clone_438(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 466
  ldv_check_alloc_flags(flags);
#line 467
  tmp = ldv_undef_ptr();
#line 467
  return ((struct sk_buff *)tmp);
}
}
#line 12 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 7 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err(void const   *ptr ) 
{ 


  {
#line 10
  return ((unsigned long )ptr > 2012UL);
}
}
#line 14 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 17
  return ((void *)(2012L - error));
}
}
#line 21 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 24
  return ((long )(2012UL - (unsigned long )ptr));
}
}
#line 28 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 31
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 31
    tmp___0 = 1;
  } else {
#line 31
    tmp = ldv_is_err(ptr);
#line 31
    if ((int )tmp) {
#line 31
      tmp___0 = 1;
    } else {
#line 31
      tmp___0 = 0;
    }
  }
#line 31
  return ((bool )tmp___0);
}
}
#line 20 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
int ldv_spin  =    0;
#line 24 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_check_alloc_flags(gfp_t flags ) 
{ 


  {
#line 27
  if (ldv_spin != 0 && (flags & 16U) != 0U) {
#line 27
    ldv_error();
  } else {

  }
#line 31
  return;
}
}
#line 30
extern struct page *ldv_some_page(void) ;
#line 33 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
struct page *ldv_check_alloc_flags_and_return_some_page(gfp_t flags ) 
{ 
  struct page *tmp ;

  {
#line 36
  if (ldv_spin != 0 && (flags & 16U) != 0U) {
#line 36
    ldv_error();
  } else {

  }
#line 38
  tmp = ldv_some_page();
#line 38
  return (tmp);
}
}
#line 42 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_check_alloc_nonatomic(void) 
{ 


  {
#line 45
  if (ldv_spin != 0) {
#line 45
    ldv_error();
  } else {

  }
#line 49
  return;
}
}
#line 49 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_spin_lock(void) 
{ 


  {
#line 52
  ldv_spin = 1;
#line 53
  return;
}
}
#line 56 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_spin_unlock(void) 
{ 


  {
#line 59
  ldv_spin = 0;
#line 60
  return;
}
}
#line 63 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3238/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
int ldv_spin_trylock(void) 
{ 
  int is_lock ;

  {
#line 68
  is_lock = ldv_undef_int();
#line 70
  if (is_lock != 0) {
#line 73
    return (0);
  } else {
#line 78
    ldv_spin = 1;
#line 80
    return (1);
  }
}
}
