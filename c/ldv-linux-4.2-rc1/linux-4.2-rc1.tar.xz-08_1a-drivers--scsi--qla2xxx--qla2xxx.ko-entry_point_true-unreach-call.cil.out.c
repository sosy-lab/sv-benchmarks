extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 32 "include/uapi/linux/types.h"
typedef __u16 __le16;
#line 33 "include/uapi/linux/types.h"
typedef __u16 __be16;
#line 34 "include/uapi/linux/types.h"
typedef __u32 __le32;
#line 35 "include/uapi/linux/types.h"
typedef __u32 __be32;
#line 40 "include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 229 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 91 "include/linux/types.h"
typedef unsigned int uint;
#line 92 "include/linux/types.h"
typedef unsigned long ulong;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 107 "include/linux/types.h"
typedef __u16 uint16_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 152 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 162 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 167 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 67 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 220 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 361
struct page;
#line 361 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 372
struct file;
#line 385
struct seq_file;
#line 423
struct thread_struct;
#line 425
struct mm_struct;
#line 426
struct task_struct;
#line 427
struct cpumask;
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};
#line 33 "include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;
#line 34 "include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 131 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 54
struct net_device;
#line 420 "include/linux/printk.h"
struct file_operations;
#line 432
struct completion;
#line 555 "./arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct timespec;
#line 103
struct compat_timespec;
#line 104 "include/linux/bug.h"
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 104 "include/linux/bug.h"
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 104
struct pollfd;
#line 104 "include/linux/bug.h"
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 104 "include/linux/bug.h"
union __anonunion____missing_field_name_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};
#line 104 "include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_19 __annonCompField8 ;
};
#line 328 "include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 15 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 652 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 260 "./arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_29 {
   u64 rip ;
   u64 rdp ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_28 {
   struct __anonstruct____missing_field_name_29 __annonCompField12 ;
   struct __anonstruct____missing_field_name_30 __annonCompField13 ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_28 __annonCompField14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_31 __annonCompField15 ;
};
#line 66 "./arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 155 "./arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 161 "./arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};
#line 179 "./arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
};
#line 193 "./arch/x86/include/asm/fpu/types.h"
struct fpu {
   union fpregs_state state ;
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
};
#line 170 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 369
struct perf_event;
#line 370 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct fpu fpu ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 33 "include/linux/bottom_half.h"
struct lockdep_map;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 28 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
   unsigned int pin_count ;
};
#line 546 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion____missing_field_name_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_35 __annonCompField17 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_34 __annonCompField18 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_36 rwlock_t;
#line 426 "include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 52 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 404 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 404 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
#line 598 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_46 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_46 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_47 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_47 kgid_t;
#line 139 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 36 "include/linux/stat.h"
struct vm_area_struct;
#line 38 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 95 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_48 {
   unsigned long bits[16U] ;
};
#line 95 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_48 nodemask_t;
#line 13 "include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 39 "include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 177
struct rw_semaphore;
#line 178 "include/linux/mutex.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 172 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 437 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 296 "include/linux/rcupdate.h"
struct notifier_block;
#line 1121 "include/linux/rcupdate.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 242 "include/linux/timer.h"
struct hrtimer;
#line 243
enum hrtimer_restart;
#line 244 "include/linux/timer.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 41 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 837 "include/uapi/linux/sysctl.h"
struct ctl_table;
#line 838
struct nsproxy;
#line 839
struct ctl_table_root;
#line 840
struct ctl_table_header;
#line 841
struct ctl_dir;
#line 37 "include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
#line 57 "include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 96 "include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 117 "include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 122 "include/linux/sysctl.h"
struct __anonstruct____missing_field_name_50 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 122 "include/linux/sysctl.h"
union __anonunion____missing_field_name_49 {
   struct __anonstruct____missing_field_name_50 __annonCompField19 ;
   struct callback_head rcu ;
};
#line 122
struct ctl_table_set;
#line 122 "include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion____missing_field_name_49 __annonCompField20 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 143 "include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 149 "include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 154 "include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
#line 259 "include/linux/timer.h"
struct workqueue_struct;
#line 260
struct work_struct;
#line 54 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 107 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 141 "include/linux/workqueue.h"
struct execute_work {
   struct work_struct work ;
};
#line 51 "include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 64 "./arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 172 "./arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 336
struct wake_irq;
#line 338 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 615 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
   int (*activate)(struct device * ) ;
   void (*sync)(struct device * ) ;
   void (*dismiss)(struct device * ) ;
};
#line 133 "./arch/x86/include/asm/topology.h"
struct pci_bus;
#line 24 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_115 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_115 mm_context_t;
#line 22 "include/xen/features.h"
struct bio_vec;
#line 1281 "include/linux/mmzone.h"
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 17 "include/linux/smp.h"
struct call_single_data {
   struct llist_node llist ;
   void (*func)(void * ) ;
   void *info ;
   unsigned int flags ;
};
#line 37 "include/linux/kmod.h"
struct cred;
#line 19 "./arch/x86/include/asm/elf.h"
struct inode;
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_148 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_149 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_147 {
   struct __anonstruct____missing_field_name_148 __annonCompField33 ;
   struct __anonstruct____missing_field_name_149 __annonCompField34 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_147 __annonCompField35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134
struct mem_cgroup;
#line 31 "include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_150 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_152 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_156 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_155 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_156 __annonCompField38 ;
   int units ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_154 {
   union __anonunion____missing_field_name_155 __annonCompField39 ;
   atomic_t _count ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_153 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_154 __annonCompField40 ;
   unsigned int active ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_151 {
   union __anonunion____missing_field_name_152 __annonCompField37 ;
   union __anonunion____missing_field_name_153 __annonCompField41 ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_158 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_159 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_157 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_158 __annonCompField43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_159 __annonCompField44 ;
   pgtable_t pmd_huge_pte ;
};
#line 32
struct kmem_cache;
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_160 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_150 __annonCompField36 ;
   struct __anonstruct____missing_field_name_151 __annonCompField42 ;
   union __anonunion____missing_field_name_157 __annonCompField45 ;
   union __anonunion____missing_field_name_160 __annonCompField46 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 266 "include/linux/mm_types.h"
struct __anonstruct_shared_161 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 266
struct anon_vma;
#line 266
struct vm_operations_struct;
#line 266
struct mempolicy;
#line 266 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_161 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 334 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 340 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 353 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 361 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 366
struct kioctx_table;
#line 367
struct linux_binfmt;
#line 367
struct mmu_notifier_mm;
#line 367 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "include/linux/elf.h"
union __anonunion____missing_field_name_166 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 53 "include/linux/elf.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_166 __annonCompField47 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct dentry;
#line 186
struct iattr;
#line 187
struct super_block;
#line 188
struct file_system_type;
#line 189
struct kernfs_open_node;
#line 190
struct kernfs_iattrs;
#line 213
struct kernfs_root;
#line 213 "include/linux/idr.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_node;
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89
struct kernfs_ops;
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 96 "include/linux/kernfs.h"
union __anonunion____missing_field_name_171 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 96 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_171 __annonCompField48 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 138 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 155 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 171 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 188 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 477
struct sock;
#line 478
struct kobject;
#line 479
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 485 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 59 "include/linux/kobject_ns.h"
struct bin_attribute;
#line 60 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 82 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 155 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 509 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 42 "include/linux/kobject.h"
enum kobject_action {
    KOBJ_ADD = 0,
    KOBJ_REMOVE = 1,
    KOBJ_CHANGE = 2,
    KOBJ_MOVE = 3,
    KOBJ_ONLINE = 4,
    KOBJ_OFFLINE = 5,
    KOBJ_MAX = 6
} ;
#line 52
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct kernel_param;
#line 227 "include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_172 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct module *mod ;
   struct kernel_param_ops  const  *ops ;
   u16 const   perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_172 __annonCompField49 ;
};
#line 83 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 89 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 469 "include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};
#line 211 "include/linux/rbtree_latch.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 47 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 73
struct exception_table_entry;
#line 206
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 213 "include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
#line 220
struct module_sect_attrs;
#line 220
struct module_notes_attrs;
#line 220
struct tracepoint;
#line 220
struct trace_event_call;
#line 220
struct trace_enum_map;
#line 220 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 78 "include/uapi/linux/shm.h"
struct user_struct;
#line 26 "include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_180 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_180 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_182 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_183 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_184 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_185 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_187 {
   void *_lower ;
   void *_upper ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_186 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_187 _addr_bnd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_188 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_189 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_181 {
   int _pad[28U] ;
   struct __anonstruct__kill_182 _kill ;
   struct __anonstruct__timer_183 _timer ;
   struct __anonstruct__rt_184 _rt ;
   struct __anonstruct__sigchld_185 _sigchld ;
   struct __anonstruct__sigfault_186 _sigfault ;
   struct __anonstruct__sigpoll_188 _sigpoll ;
   struct __anonstruct__sigsys_189 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_181 _sifields ;
};
#line 113 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 443
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 450
struct pid_namespace;
#line 450 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 53 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 123 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};
#line 156 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned char in_hrtirq : 1 ;
   unsigned char hres_active : 1 ;
   unsigned char hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 466 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct key_type;
#line 41 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_196 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_197 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct____missing_field_name_199 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_198 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_199 __annonCompField52 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_200 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_202 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_201 {
   union __anonunion_payload_202 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_196 __annonCompField50 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_197 __annonCompField51 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_198 __annonCompField53 ;
   union __anonunion_type_data_200 type_data ;
   union __anonunion____missing_field_name_201 __annonCompField54 ;
};
#line 358
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 90 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 369
struct percpu_ref;
#line 55 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 68 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
#line 27 "include/linux/percpu-rwsem.h"
struct cgroup;
#line 28
struct cgroup_root;
#line 29
struct cgroup_subsys;
#line 30
struct cgroup_taskset;
#line 72 "include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 124 "include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 197 "include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
#line 270 "include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 306 "include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 388 "include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
#line 128 "include/linux/sched.h"
struct futex_pi_state;
#line 129
struct robust_list_head;
#line 130
struct bio_list;
#line 131
struct fs_struct;
#line 132
struct perf_event_context;
#line 133
struct blk_plug;
#line 135
struct nameidata;
#line 188
struct cfs_rq;
#line 189
struct task_group;
#line 477 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 516 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 524 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 531 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 543 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 563 "include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
#line 584 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};
#line 620
struct autogroup;
#line 621
struct tty_struct;
#line 621
struct taskstats;
#line 621
struct tty_audit_buf;
#line 621 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 790 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 833
struct backing_dev_info;
#line 834
struct reclaim_state;
#line 835 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 849 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 897 "include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};
#line 1126
struct io_context;
#line 1160
struct pipe_inode_info;
#line 1161
struct uts_namespace;
#line 1162 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1169 "include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};
#line 1194 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1229 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1261
struct rt_rq;
#line 1261 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1277 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1343 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1769
struct sched_class;
#line 1769
struct files_struct;
#line 1769
struct compat_robust_list_head;
#line 1769
struct numa_group;
#line 1769
struct ftrace_ret_stack;
#line 1769 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char sched_migrated : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned char brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
};
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_qla_host;
#line 29
struct fc_port;
#line 31
struct device_attribute;
#line 61
struct fc_rport;
#line 66
struct scsi_target;
#line 69
struct Scsi_Host;
#line 93
struct fc_vport;
#line 100
struct qla_hw_data;
#line 145
struct scsi_device;
#line 163
struct fc_bsg_job;
#line 252
struct scsi_cmnd;
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 14 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 650
struct klist_node;
#line 651 "include/linux/mod_devicetable.h"
struct klist {
   spinlock_t k_lock ;
   struct list_head k_list ;
   void (*get)(struct klist_node * ) ;
   void (*put)(struct klist_node * ) ;
};
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67
struct path;
#line 68 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 187
struct pinctrl;
#line 188
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 48 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 48 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "./arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct fwnode_handle;
#line 22
struct iommu_ops;
#line 23
struct iommu_group;
#line 61 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 139
struct device_type;
#line 197
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
} ;
#line 203 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 353
struct class_attribute;
#line 353 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 446 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 514 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 542 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 674 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 683
struct dma_coherent_mem;
#line 683
struct cma;
#line 683 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 829 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 70 "include/linux/resource_ext.h"
struct hotplug_slot;
#line 70 "include/linux/resource_ext.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 110 "include/linux/pci.h"
typedef int pci_power_t;
#line 137 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 138
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 163 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 190 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 247
struct pcie_link_state;
#line 248
struct pci_vpd;
#line 249
struct pci_sriov;
#line 250
struct pci_ats;
#line 251
struct proc_dir_entry;
#line 251
struct pci_driver;
#line 251 "include/linux/pci.h"
union __anonunion____missing_field_name_220 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 251 "include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned char ignore_hotplug : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char no_64bit_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   unsigned char irq_managed : 1 ;
   unsigned char has_secondary_link : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group  const  **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion____missing_field_name_220 __annonCompField58 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};
#line 440
struct pci_ops;
#line 440
struct msi_controller;
#line 440 "include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
#line 563 "include/linux/pci.h"
struct pci_ops {
   void *(*map_bus)(struct pci_bus * , unsigned int  , int  ) ;
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 591 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 605 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 615 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*reset_notify)(struct pci_dev * , bool  ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 648 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 93 "include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
#line 27 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 64 "include/linux/page_ext.h"
struct file_ra_state;
#line 65
struct writeback_control;
#line 66
struct bdi_writeback;
#line 207 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 239 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*pfn_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 1200
struct kvec;
#line 2242 "include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 21 "include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 19 "include/linux/dmapool.h"
struct dma_pool;
#line 1338 "include/linux/pci.h"
struct acpi_device;
#line 1338 "include/linux/pci.h"
struct pci_sysdata {
   int domain ;
   int node ;
   struct acpi_device *companion ;
   void *iommu ;
};
#line 34 "./arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 11 "include/linux/mempool.h"
typedef void *mempool_alloc_t(gfp_t  , void * );
#line 12 "include/linux/mempool.h"
typedef void mempool_free_t(void * , void * );
#line 13 "include/linux/mempool.h"
struct mempool_s {
   spinlock_t lock ;
   int min_nr ;
   int curr_nr ;
   void **elements ;
   void *pool_data ;
   mempool_alloc_t *alloc ;
   mempool_free_t *free ;
   wait_queue_head_t wait ;
};
#line 24 "include/linux/mempool.h"
typedef struct mempool_s mempool_t;
#line 74
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 465 "include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
#line 672 "include/linux/interrupt.h"
struct firmware {
   size_t size ;
   u8 const   *data ;
   struct page **pages ;
   void *priv ;
};
#line 190 "include/scsi/scsi_proto.h"
struct scsi_lun {
   __u8 scsi_lun[8U] ;
};
#line 32 "include/scsi/scsi_common.h"
struct scsi_sense_hdr {
   u8 response_code ;
   u8 sense_key ;
   u8 asc ;
   u8 ascq ;
   u8 byte4 ;
   u8 byte5 ;
   u8 byte6 ;
   u8 additional_length ;
};
#line 50 "include/linux/genhd.h"
struct hlist_bl_node;
#line 50 "include/linux/genhd.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_232 {
   spinlock_t lock ;
   int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion____missing_field_name_231 {
   struct __anonstruct____missing_field_name_232 __annonCompField66 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_231 __annonCompField67 ;
};
#line 50 "include/linux/lockref.h"
struct vfsmount;
#line 51 "include/linux/lockref.h"
struct __anonstruct____missing_field_name_234 {
   u32 hash ;
   u32 len ;
};
#line 51 "include/linux/lockref.h"
union __anonunion____missing_field_name_233 {
   struct __anonstruct____missing_field_name_234 __annonCompField68 ;
   u64 hash_len ;
};
#line 51 "include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_233 __annonCompField69 ;
   unsigned char const   *name ;
};
#line 90 "include/linux/dcache.h"
struct dentry_operations;
#line 90 "include/linux/dcache.h"
union __anonunion_d_u_235 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
#line 90 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_235 d_u ;
};
#line 142 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
   struct inode *(*d_select_inode)(struct dentry * , unsigned int  ) ;
};
#line 585 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 27 "include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 32 "include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
#line 37 "include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
#line 47 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
#line 58 "include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_239 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "include/linux/radix-tree.h"
union __anonunion____missing_field_name_238 {
   struct __anonstruct____missing_field_name_239 __annonCompField70 ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_238 __annonCompField71 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 428 "include/linux/radix-tree.h"
struct semaphore {
   raw_spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "./include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 44
struct bio_set;
#line 45
struct bio;
#line 46
struct bio_integrity_payload;
#line 47
struct block_device;
#line 17 "include/linux/blk_types.h"
typedef void bio_end_io_t(struct bio * , int  );
#line 19 "include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 28 "include/linux/blk_types.h"
struct bvec_iter {
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned int bi_idx ;
   unsigned int bi_bvec_done ;
};
#line 40 "include/linux/blk_types.h"
union __anonunion____missing_field_name_242 {
   struct bio_integrity_payload *bi_integrity ;
};
#line 40 "include/linux/blk_types.h"
struct bio {
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
   unsigned long bi_rw ;
   struct bvec_iter bi_iter ;
   unsigned int bi_phys_segments ;
   unsigned int bi_seg_front_size ;
   unsigned int bi_seg_back_size ;
   atomic_t __bi_remaining ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
   struct io_context *bi_ioc ;
   struct cgroup_subsys_state *bi_css ;
   union __anonunion____missing_field_name_242 __annonCompField72 ;
   unsigned short bi_vcnt ;
   unsigned short bi_max_vecs ;
   atomic_t __bi_cnt ;
   struct bio_vec *bi_io_vec ;
   struct bio_set *bi_pool ;
   struct bio_vec bi_inline_vecs[0U] ;
};
#line 60 "include/uapi/linux/fs.h"
struct export_operations;
#line 61
struct hd_geometry;
#line 62
struct iovec;
#line 63
struct kiocb;
#line 64
struct poll_table_struct;
#line 65
struct kstatfs;
#line 66
struct swap_info_struct;
#line 67
struct iov_iter;
#line 74 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 212 "./include/uapi/linux/dqblk_xfs.h"
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "include/linux/projid.h"
struct __anonstruct_kprojid_t_243 {
   projid_t val ;
};
#line 23 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_243 kprojid_t;
#line 166 "include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 66 "include/linux/quota.h"
typedef long long qsize_t;
#line 67 "include/linux/quota.h"
union __anonunion____missing_field_name_244 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 67 "include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_244 __annonCompField73 ;
   enum quota_type type ;
};
#line 184 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 206
struct quota_format_type;
#line 207 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 272 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 299 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 310 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
   int (*get_projid)(struct inode * , kprojid_t * ) ;
};
#line 325 "include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 348 "include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
#line 394 "include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};
#line 405 "include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};
#line 418 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*set_info)(struct super_block * , int  , struct qc_info * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_state)(struct super_block * , struct qc_state * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 432 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 496 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops  const  *ops[3U] ;
};
#line 526 "include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb * , long  , long  ) ;
   void *private ;
   int ki_flags ;
};
#line 365 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 422 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 442
struct request_queue;
#line 443
struct hd_struct;
#line 443
struct gendisk;
#line 443 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 559
struct posix_acl;
#line 560
struct inode_operations;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_247 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_248 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 560
struct file_lock_context;
#line 560
struct cdev;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_249 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};
#line 560 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_247 __annonCompField74 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_248 __annonCompField75 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_249 __annonCompField76 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 806 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 814 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 837 "include/linux/fs.h"
union __anonunion_f_u_250 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 837 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_250 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 922 "include/linux/fs.h"
typedef void *fl_owner_t;
#line 923
struct file_lock;
#line 924 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 930 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t  ) ;
   void (*lm_put_owner)(fl_owner_t  ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
#line 946
struct net;
#line 951
struct nlm_lockowner;
#line 952 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_252 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_251 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_252 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_251 fl_u ;
};
#line 1004 "include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1062 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1240 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1271
struct super_operations;
#line 1271
struct xattr_handler;
#line 1271
struct mtd_info;
#line 1271 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
#line 1510 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1524
struct dir_context;
#line 1549 "include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1555
struct block_device_operations;
#line 1556 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1617 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   char const   *(*follow_link)(struct dentry * , void ** ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct inode * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1671 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
#line 1910 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 80 "include/linux/genhd.h"
struct disk_stats {
   unsigned long sectors[2U] ;
   unsigned long ios[2U] ;
   unsigned long merges[2U] ;
   unsigned long ticks[2U] ;
   unsigned long io_ticks ;
   unsigned long time_in_queue ;
};
#line 89 "include/linux/genhd.h"
struct partition_meta_info {
   char uuid[37U] ;
   u8 volname[64U] ;
};
#line 101 "include/linux/genhd.h"
struct hd_struct {
   sector_t start_sect ;
   sector_t nr_sects ;
   seqcount_t nr_sects_seq ;
   sector_t alignment_offset ;
   unsigned int discard_alignment ;
   struct device __dev ;
   struct kobject *holder_dir ;
   int policy ;
   int partno ;
   struct partition_meta_info *info ;
   int make_it_fail ;
   unsigned long stamp ;
   atomic_t in_flight[2U] ;
   struct disk_stats *dkstats ;
   atomic_t ref ;
   struct callback_head callback_head ;
};
#line 155 "include/linux/genhd.h"
struct disk_part_tbl {
   struct callback_head callback_head ;
   int len ;
   struct hd_struct *last_lookup ;
   struct hd_struct *part[] ;
};
#line 162
struct disk_events;
#line 163
struct timer_rand_state;
#line 163
struct blk_integrity;
#line 163 "include/linux/genhd.h"
struct gendisk {
   int major ;
   int first_minor ;
   int minors ;
   char disk_name[32U] ;
   char *(*devnode)(struct gendisk * , umode_t * ) ;
   unsigned int events ;
   unsigned int async_events ;
   struct disk_part_tbl *part_tbl ;
   struct hd_struct part0 ;
   struct block_device_operations  const  *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct device *driverfs_dev ;
   struct kobject *slave_dir ;
   struct timer_rand_state *random ;
   atomic_t sync_io ;
   struct disk_events *ev ;
   struct blk_integrity *integrity ;
   int node_id ;
};
#line 72 "include/linux/flex_proportions.h"
struct fprop_local_percpu {
   struct percpu_counter events ;
   unsigned int period ;
   raw_spinlock_t lock ;
};
#line 32 "include/linux/backing-dev-defs.h"
typedef int congested_fn(void * , int  );
#line 41 "include/linux/backing-dev-defs.h"
struct bdi_writeback_congested {
   unsigned long state ;
   atomic_t refcnt ;
   struct backing_dev_info *bdi ;
   int blkcg_id ;
   struct rb_node rb_node ;
};
#line 60 "include/linux/backing-dev-defs.h"
union __anonunion____missing_field_name_253 {
   struct work_struct release_work ;
   struct callback_head rcu ;
};
#line 60 "include/linux/backing-dev-defs.h"
struct bdi_writeback {
   struct backing_dev_info *bdi ;
   unsigned long state ;
   unsigned long last_old_flush ;
   struct list_head b_dirty ;
   struct list_head b_io ;
   struct list_head b_more_io ;
   struct list_head b_dirty_time ;
   spinlock_t list_lock ;
   struct percpu_counter stat[4U] ;
   struct bdi_writeback_congested *congested ;
   unsigned long bw_time_stamp ;
   unsigned long dirtied_stamp ;
   unsigned long written_stamp ;
   unsigned long write_bandwidth ;
   unsigned long avg_write_bandwidth ;
   unsigned long dirty_ratelimit ;
   unsigned long balanced_dirty_ratelimit ;
   struct fprop_local_percpu completions ;
   int dirty_exceeded ;
   spinlock_t work_lock ;
   struct list_head work_list ;
   struct delayed_work dwork ;
   struct percpu_ref refcnt ;
   struct fprop_local_percpu memcg_completions ;
   struct cgroup_subsys_state *memcg_css ;
   struct cgroup_subsys_state *blkcg_css ;
   struct list_head memcg_node ;
   struct list_head blkcg_node ;
   union __anonunion____missing_field_name_253 __annonCompField77 ;
};
#line 132 "include/linux/backing-dev-defs.h"
struct backing_dev_info {
   struct list_head bdi_list ;
   unsigned long ra_pages ;
   unsigned int capabilities ;
   congested_fn *congested_fn ;
   void *congested_data ;
   char *name ;
   unsigned int min_ratio ;
   unsigned int max_ratio ;
   unsigned int max_prop_frac ;
   atomic_long_t tot_write_bandwidth ;
   struct bdi_writeback wb ;
   struct radix_tree_root cgwb_tree ;
   struct rb_root cgwb_congested_tree ;
   atomic_t usage_cnt ;
   wait_queue_head_t wb_waitq ;
   struct device *dev ;
   struct timer_list laptop_mode_wb_timer ;
   struct dentry *debug_dir ;
   struct dentry *debug_stats ;
};
#line 237 "include/linux/backing-dev-defs.h"
union __anonunion____missing_field_name_254 {
   struct list_head q_node ;
   struct kmem_cache *__rcu_icq_cache ;
};
#line 237 "include/linux/backing-dev-defs.h"
union __anonunion____missing_field_name_255 {
   struct hlist_node ioc_node ;
   struct callback_head __rcu_head ;
};
#line 237 "include/linux/backing-dev-defs.h"
struct io_cq {
   struct request_queue *q ;
   struct io_context *ioc ;
   union __anonunion____missing_field_name_254 __annonCompField78 ;
   union __anonunion____missing_field_name_255 __annonCompField79 ;
   unsigned int flags ;
};
#line 92 "include/linux/iocontext.h"
struct io_context {
   atomic_long_t refcount ;
   atomic_t active_ref ;
   atomic_t nr_tasks ;
   spinlock_t lock ;
   unsigned short ioprio ;
   int nr_batch_requests ;
   unsigned long last_waited ;
   struct radix_tree_root icq_tree ;
   struct io_cq *icq_hint ;
   struct hlist_head icq_list ;
   struct work_struct release_work ;
};
#line 326 "include/linux/bio.h"
struct bio_integrity_payload {
   struct bio *bip_bio ;
   struct bvec_iter bip_iter ;
   bio_end_io_t *bip_end_io ;
   unsigned short bip_slab ;
   unsigned short bip_vcnt ;
   unsigned short bip_max_vcnt ;
   unsigned short bip_flags ;
   struct work_struct bip_work ;
   struct bio_vec *bip_vec ;
   struct bio_vec bip_inline_vecs[0U] ;
};
#line 541 "include/linux/bio.h"
struct bio_list {
   struct bio *head ;
   struct bio *tail ;
};
#line 662 "include/linux/bio.h"
struct bio_set {
   struct kmem_cache *bio_slab ;
   unsigned int front_pad ;
   mempool_t *bio_pool ;
   mempool_t *bvec_pool ;
   mempool_t *bio_integrity_pool ;
   mempool_t *bvec_integrity_pool ;
   spinlock_t rescue_lock ;
   struct bio_list rescue_list ;
   struct work_struct rescue_work ;
   struct workqueue_struct *rescue_workqueue ;
};
#line 64 "include/uapi/linux/bsg.h"
struct bsg_class_device {
   struct device *class_dev ;
   struct device *parent ;
   int minor ;
   struct request_queue *queue ;
   struct kref ref ;
   void (*release)(struct device * ) ;
};
#line 22 "include/linux/bsg.h"
struct elevator_queue;
#line 23
struct blk_trace;
#line 24
struct request;
#line 26
struct bsg_job;
#line 27
struct blkcg_gq;
#line 28
struct blk_flush_queue;
#line 49 "include/linux/blkdev.h"
typedef void rq_end_io_fn(struct request * , int  );
#line 50 "include/linux/blkdev.h"
struct request_list {
   struct request_queue *q ;
   struct blkcg_gq *blkg ;
   int count[2U] ;
   int starved[2U] ;
   mempool_t *rq_pool ;
   wait_queue_head_t wait[2U] ;
   unsigned int flags ;
};
#line 75 "include/linux/blkdev.h"
union __anonunion____missing_field_name_256 {
   struct call_single_data csd ;
   unsigned long fifo_time ;
};
#line 75
struct blk_mq_ctx;
#line 75 "include/linux/blkdev.h"
union __anonunion____missing_field_name_257 {
   struct hlist_node hash ;
   struct list_head ipi_list ;
};
#line 75 "include/linux/blkdev.h"
union __anonunion____missing_field_name_258 {
   struct rb_node rb_node ;
   void *completion_data ;
};
#line 75 "include/linux/blkdev.h"
struct __anonstruct_elv_260 {
   struct io_cq *icq ;
   void *priv[2U] ;
};
#line 75 "include/linux/blkdev.h"
struct __anonstruct_flush_261 {
   unsigned int seq ;
   struct list_head list ;
   rq_end_io_fn *saved_end_io ;
};
#line 75 "include/linux/blkdev.h"
union __anonunion____missing_field_name_259 {
   struct __anonstruct_elv_260 elv ;
   struct __anonstruct_flush_261 flush ;
};
#line 75 "include/linux/blkdev.h"
struct request {
   struct list_head queuelist ;
   union __anonunion____missing_field_name_256 __annonCompField80 ;
   struct request_queue *q ;
   struct blk_mq_ctx *mq_ctx ;
   u64 cmd_flags ;
   unsigned int cmd_type ;
   unsigned long atomic_flags ;
   int cpu ;
   unsigned int __data_len ;
   sector_t __sector ;
   struct bio *bio ;
   struct bio *biotail ;
   union __anonunion____missing_field_name_257 __annonCompField81 ;
   union __anonunion____missing_field_name_258 __annonCompField82 ;
   union __anonunion____missing_field_name_259 __annonCompField83 ;
   struct gendisk *rq_disk ;
   struct hd_struct *part ;
   unsigned long start_time ;
   struct request_list *rl ;
   unsigned long long start_time_ns ;
   unsigned long long io_start_time_ns ;
   unsigned short nr_phys_segments ;
   unsigned short nr_integrity_segments ;
   unsigned short ioprio ;
   void *special ;
   int tag ;
   int errors ;
   unsigned char __cmd[16U] ;
   unsigned char *cmd ;
   unsigned short cmd_len ;
   unsigned int extra_len ;
   unsigned int sense_len ;
   unsigned int resid_len ;
   void *sense ;
   unsigned long deadline ;
   struct list_head timeout_list ;
   unsigned int timeout ;
   int retries ;
   rq_end_io_fn *end_io ;
   void *end_io_data ;
   struct request *next_rq ;
};
#line 113 "include/linux/hashtable.h"
struct elevator_type;
#line 12 "include/linux/elevator.h"
typedef int elevator_merge_fn(struct request_queue * , struct request ** , struct bio * );
#line 15 "include/linux/elevator.h"
typedef void elevator_merge_req_fn(struct request_queue * , struct request * , struct request * );
#line 17 "include/linux/elevator.h"
typedef void elevator_merged_fn(struct request_queue * , struct request * , int  );
#line 19 "include/linux/elevator.h"
typedef int elevator_allow_merge_fn(struct request_queue * , struct request * , struct bio * );
#line 21 "include/linux/elevator.h"
typedef void elevator_bio_merged_fn(struct request_queue * , struct request * , struct bio * );
#line 24 "include/linux/elevator.h"
typedef int elevator_dispatch_fn(struct request_queue * , int  );
#line 26 "include/linux/elevator.h"
typedef void elevator_add_req_fn(struct request_queue * , struct request * );
#line 27 "include/linux/elevator.h"
typedef struct request *elevator_request_list_fn(struct request_queue * , struct request * );
#line 28 "include/linux/elevator.h"
typedef void elevator_completed_req_fn(struct request_queue * , struct request * );
#line 29 "include/linux/elevator.h"
typedef int elevator_may_queue_fn(struct request_queue * , int  );
#line 31 "include/linux/elevator.h"
typedef void elevator_init_icq_fn(struct io_cq * );
#line 32 "include/linux/elevator.h"
typedef void elevator_exit_icq_fn(struct io_cq * );
#line 33 "include/linux/elevator.h"
typedef int elevator_set_req_fn(struct request_queue * , struct request * , struct bio * ,
                                gfp_t  );
#line 35 "include/linux/elevator.h"
typedef void elevator_put_req_fn(struct request * );
#line 36 "include/linux/elevator.h"
typedef void elevator_activate_req_fn(struct request_queue * , struct request * );
#line 37 "include/linux/elevator.h"
typedef void elevator_deactivate_req_fn(struct request_queue * , struct request * );
#line 39 "include/linux/elevator.h"
typedef int elevator_init_fn(struct request_queue * , struct elevator_type * );
#line 41 "include/linux/elevator.h"
typedef void elevator_exit_fn(struct elevator_queue * );
#line 42 "include/linux/elevator.h"
typedef void elevator_registered_fn(struct request_queue * );
#line 43 "include/linux/elevator.h"
struct elevator_ops {
   elevator_merge_fn *elevator_merge_fn ;
   elevator_merged_fn *elevator_merged_fn ;
   elevator_merge_req_fn *elevator_merge_req_fn ;
   elevator_allow_merge_fn *elevator_allow_merge_fn ;
   elevator_bio_merged_fn *elevator_bio_merged_fn ;
   elevator_dispatch_fn *elevator_dispatch_fn ;
   elevator_add_req_fn *elevator_add_req_fn ;
   elevator_activate_req_fn *elevator_activate_req_fn ;
   elevator_deactivate_req_fn *elevator_deactivate_req_fn ;
   elevator_completed_req_fn *elevator_completed_req_fn ;
   elevator_request_list_fn *elevator_former_req_fn ;
   elevator_request_list_fn *elevator_latter_req_fn ;
   elevator_init_icq_fn *elevator_init_icq_fn ;
   elevator_exit_icq_fn *elevator_exit_icq_fn ;
   elevator_set_req_fn *elevator_set_req_fn ;
   elevator_put_req_fn *elevator_put_req_fn ;
   elevator_may_queue_fn *elevator_may_queue_fn ;
   elevator_init_fn *elevator_init_fn ;
   elevator_exit_fn *elevator_exit_fn ;
   elevator_registered_fn *elevator_registered_fn ;
};
#line 74 "include/linux/elevator.h"
struct elv_fs_entry {
   struct attribute attr ;
   ssize_t (*show)(struct elevator_queue * , char * ) ;
   ssize_t (*store)(struct elevator_queue * , char const   * , size_t  ) ;
};
#line 82 "include/linux/elevator.h"
struct elevator_type {
   struct kmem_cache *icq_cache ;
   struct elevator_ops ops ;
   size_t icq_size ;
   size_t icq_align ;
   struct elv_fs_entry *elevator_attrs ;
   char elevator_name[16U] ;
   struct module *elevator_owner ;
   char icq_cache_name[21U] ;
   struct list_head list ;
};
#line 103 "include/linux/elevator.h"
struct elevator_queue {
   struct elevator_type *type ;
   void *elevator_data ;
   struct kobject kobj ;
   struct mutex sysfs_lock ;
   unsigned char registered : 1 ;
   struct hlist_head hash[64U] ;
};
#line 210 "include/linux/blkdev.h"
typedef void request_fn_proc(struct request_queue * );
#line 211 "include/linux/blkdev.h"
typedef void make_request_fn(struct request_queue * , struct bio * );
#line 212 "include/linux/blkdev.h"
typedef int prep_rq_fn(struct request_queue * , struct request * );
#line 213 "include/linux/blkdev.h"
typedef void unprep_rq_fn(struct request_queue * , struct request * );
#line 214 "include/linux/blkdev.h"
struct bvec_merge_data {
   struct block_device *bi_bdev ;
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned long bi_rw ;
};
#line 222 "include/linux/blkdev.h"
typedef int merge_bvec_fn(struct request_queue * , struct bvec_merge_data * , struct bio_vec * );
#line 224 "include/linux/blkdev.h"
typedef void softirq_done_fn(struct request * );
#line 225 "include/linux/blkdev.h"
typedef int dma_drain_needed_fn(struct request * );
#line 226 "include/linux/blkdev.h"
typedef int lld_busy_fn(struct request_queue * );
#line 227 "include/linux/blkdev.h"
typedef int bsg_job_fn(struct bsg_job * );
#line 228
enum blk_eh_timer_return {
    BLK_EH_NOT_HANDLED = 0,
    BLK_EH_HANDLED = 1,
    BLK_EH_RESET_TIMER = 2
} ;
#line 235 "include/linux/blkdev.h"
typedef enum blk_eh_timer_return rq_timed_out_fn(struct request * );
#line 241 "include/linux/blkdev.h"
struct blk_queue_tag {
   struct request **tag_index ;
   unsigned long *tag_map ;
   int busy ;
   int max_depth ;
   int real_max_depth ;
   atomic_t refcnt ;
   int alloc_policy ;
   int next_tag ;
};
#line 252 "include/linux/blkdev.h"
struct queue_limits {
   unsigned long bounce_pfn ;
   unsigned long seg_boundary_mask ;
   unsigned int max_hw_sectors ;
   unsigned int chunk_sectors ;
   unsigned int max_sectors ;
   unsigned int max_segment_size ;
   unsigned int physical_block_size ;
   unsigned int alignment_offset ;
   unsigned int io_min ;
   unsigned int io_opt ;
   unsigned int max_discard_sectors ;
   unsigned int max_write_same_sectors ;
   unsigned int discard_granularity ;
   unsigned int discard_alignment ;
   unsigned short logical_block_size ;
   unsigned short max_segments ;
   unsigned short max_integrity_segments ;
   unsigned char misaligned ;
   unsigned char discard_misaligned ;
   unsigned char cluster ;
   unsigned char discard_zeroes_data ;
   unsigned char raid_partial_stripes_expensive ;
};
#line 285
struct blk_mq_ops;
#line 285
struct blk_mq_hw_ctx;
#line 285
struct throtl_data;
#line 285
struct blk_mq_tag_set;
#line 285 "include/linux/blkdev.h"
struct request_queue {
   struct list_head queue_head ;
   struct request *last_merge ;
   struct elevator_queue *elevator ;
   int nr_rqs[2U] ;
   int nr_rqs_elvpriv ;
   struct request_list root_rl ;
   request_fn_proc *request_fn ;
   make_request_fn *make_request_fn ;
   prep_rq_fn *prep_rq_fn ;
   unprep_rq_fn *unprep_rq_fn ;
   merge_bvec_fn *merge_bvec_fn ;
   softirq_done_fn *softirq_done_fn ;
   rq_timed_out_fn *rq_timed_out_fn ;
   dma_drain_needed_fn *dma_drain_needed ;
   lld_busy_fn *lld_busy_fn ;
   struct blk_mq_ops *mq_ops ;
   unsigned int *mq_map ;
   struct blk_mq_ctx *queue_ctx ;
   unsigned int nr_queues ;
   struct blk_mq_hw_ctx **queue_hw_ctx ;
   unsigned int nr_hw_queues ;
   sector_t end_sector ;
   struct request *boundary_rq ;
   struct delayed_work delay_work ;
   struct backing_dev_info backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
   int id ;
   gfp_t bounce_gfp ;
   spinlock_t __queue_lock ;
   spinlock_t *queue_lock ;
   struct kobject kobj ;
   struct kobject mq_kobj ;
   struct device *dev ;
   int rpm_status ;
   unsigned int nr_pending ;
   unsigned long nr_requests ;
   unsigned int nr_congestion_on ;
   unsigned int nr_congestion_off ;
   unsigned int nr_batching ;
   unsigned int dma_drain_size ;
   void *dma_drain_buffer ;
   unsigned int dma_pad_mask ;
   unsigned int dma_alignment ;
   struct blk_queue_tag *queue_tags ;
   struct list_head tag_busy_list ;
   unsigned int nr_sorted ;
   unsigned int in_flight[2U] ;
   unsigned int request_fn_active ;
   unsigned int rq_timeout ;
   struct timer_list timeout ;
   struct list_head timeout_list ;
   struct list_head icq_list ;
   unsigned long blkcg_pols[1U] ;
   struct blkcg_gq *root_blkg ;
   struct list_head blkg_list ;
   struct queue_limits limits ;
   unsigned int sg_timeout ;
   unsigned int sg_reserved_size ;
   int node ;
   struct blk_trace *blk_trace ;
   unsigned int flush_flags ;
   unsigned char flush_not_queueable : 1 ;
   struct blk_flush_queue *fq ;
   struct list_head requeue_list ;
   spinlock_t requeue_lock ;
   struct work_struct requeue_work ;
   struct mutex sysfs_lock ;
   int bypass_depth ;
   atomic_t mq_freeze_depth ;
   bsg_job_fn *bsg_job_fn ;
   int bsg_job_size ;
   struct bsg_class_device bsg_dev ;
   struct throtl_data *td ;
   struct callback_head callback_head ;
   wait_queue_head_t mq_freeze_wq ;
   struct percpu_ref mq_usage_counter ;
   struct list_head all_q_node ;
   struct blk_mq_tag_set *tag_set ;
   struct list_head tag_set_list ;
};
#line 1020 "include/linux/blkdev.h"
struct blk_plug {
   struct list_head list ;
   struct list_head mq_list ;
   struct list_head cb_list ;
};
#line 1398 "include/linux/blkdev.h"
struct blk_integrity_iter {
   void *prot_buf ;
   void *data_buf ;
   sector_t seed ;
   unsigned int data_size ;
   unsigned short interval ;
   char const   *disk_name ;
};
#line 1427 "include/linux/blkdev.h"
typedef int integrity_processing_fn(struct blk_integrity_iter * );
#line 1428 "include/linux/blkdev.h"
struct blk_integrity {
   integrity_processing_fn *generate_fn ;
   integrity_processing_fn *verify_fn ;
   unsigned short flags ;
   unsigned short tuple_size ;
   unsigned short interval ;
   unsigned short tag_size ;
   char const   *name ;
   struct kobject kobj ;
};
#line 1482 "include/linux/blkdev.h"
struct block_device_operations {
   int (*open)(struct block_device * , fmode_t  ) ;
   void (*release)(struct gendisk * , fmode_t  ) ;
   int (*rw_page)(struct block_device * , sector_t  , struct page * , int  ) ;
   int (*ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   long (*direct_access)(struct block_device * , sector_t  , void ** , unsigned long * ,
                         long  ) ;
   unsigned int (*check_events)(struct gendisk * , unsigned int  ) ;
   int (*media_changed)(struct gendisk * ) ;
   void (*unlock_native_capacity)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   int (*getgeo)(struct block_device * , struct hd_geometry * ) ;
   void (*swap_slot_free_notify)(struct block_device * , unsigned long  ) ;
   struct module *owner ;
};
#line 1578
struct blk_mq_tags;
#line 1579 "include/linux/blkdev.h"
struct blk_mq_cpu_notifier {
   struct list_head list ;
   void *data ;
   int (*notify)(void * , unsigned long  , unsigned int  ) ;
};
#line 14 "include/linux/blk-mq.h"
struct blk_align_bitmap;
#line 14 "include/linux/blk-mq.h"
struct blk_mq_ctxmap {
   unsigned int size ;
   unsigned int bits_per_word ;
   struct blk_align_bitmap *map ;
};
#line 20 "include/linux/blk-mq.h"
struct __anonstruct____missing_field_name_263 {
   spinlock_t lock ;
   struct list_head dispatch ;
};
#line 20 "include/linux/blk-mq.h"
struct blk_mq_hw_ctx {
   struct __anonstruct____missing_field_name_263 __annonCompField84 ;
   unsigned long state ;
   struct delayed_work run_work ;
   struct delayed_work delay_work ;
   cpumask_var_t cpumask ;
   int next_cpu ;
   int next_cpu_batch ;
   unsigned long flags ;
   struct request_queue *queue ;
   struct blk_flush_queue *fq ;
   void *driver_data ;
   struct blk_mq_ctxmap ctx_map ;
   unsigned int nr_ctx ;
   struct blk_mq_ctx **ctxs ;
   atomic_t wait_index ;
   struct blk_mq_tags *tags ;
   unsigned long queued ;
   unsigned long run ;
   unsigned long dispatched[10U] ;
   unsigned int numa_node ;
   unsigned int queue_num ;
   atomic_t nr_active ;
   struct blk_mq_cpu_notifier cpu_notifier ;
   struct kobject kobj ;
};
#line 63 "include/linux/blk-mq.h"
struct blk_mq_tag_set {
   struct blk_mq_ops *ops ;
   unsigned int nr_hw_queues ;
   unsigned int queue_depth ;
   unsigned int reserved_tags ;
   unsigned int cmd_size ;
   int numa_node ;
   unsigned int timeout ;
   unsigned int flags ;
   void *driver_data ;
   struct blk_mq_tags **tags ;
   struct mutex tag_list_lock ;
   struct list_head tag_list ;
};
#line 80 "include/linux/blk-mq.h"
struct blk_mq_queue_data {
   struct request *rq ;
   struct list_head *list ;
   bool last ;
};
#line 87 "include/linux/blk-mq.h"
typedef int queue_rq_fn(struct blk_mq_hw_ctx * , struct blk_mq_queue_data  const  * );
#line 88 "include/linux/blk-mq.h"
typedef struct blk_mq_hw_ctx *map_queue_fn(struct request_queue * , int const    );
#line 89 "include/linux/blk-mq.h"
typedef enum blk_eh_timer_return timeout_fn(struct request * , bool  );
#line 90 "include/linux/blk-mq.h"
typedef int init_hctx_fn(struct blk_mq_hw_ctx * , void * , unsigned int  );
#line 91 "include/linux/blk-mq.h"
typedef void exit_hctx_fn(struct blk_mq_hw_ctx * , unsigned int  );
#line 92 "include/linux/blk-mq.h"
typedef int init_request_fn(void * , struct request * , unsigned int  , unsigned int  ,
                            unsigned int  );
#line 94 "include/linux/blk-mq.h"
typedef void exit_request_fn(void * , struct request * , unsigned int  , unsigned int  );
#line 100 "include/linux/blk-mq.h"
struct blk_mq_ops {
   queue_rq_fn *queue_rq ;
   map_queue_fn *map_queue ;
   timeout_fn *timeout ;
   softirq_done_fn *complete ;
   init_hctx_fn *init_hctx ;
   exit_hctx_fn *exit_hctx ;
   init_request_fn *init_request ;
   exit_request_fn *exit_request ;
};
#line 247
struct scsi_host_cmd_pool;
#line 248
struct scsi_transport_template;
#line 250 "include/linux/blk-mq.h"
struct scsi_host_template {
   struct module *module ;
   char const   *name ;
   int (*detect)(struct scsi_host_template * ) ;
   int (*release)(struct Scsi_Host * ) ;
   char const   *(*info)(struct Scsi_Host * ) ;
   int (*ioctl)(struct scsi_device * , int  , void * ) ;
   int (*compat_ioctl)(struct scsi_device * , int  , void * ) ;
   int (*queuecommand)(struct Scsi_Host * , struct scsi_cmnd * ) ;
   int (*eh_abort_handler)(struct scsi_cmnd * ) ;
   int (*eh_device_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_target_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_bus_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_host_reset_handler)(struct scsi_cmnd * ) ;
   int (*slave_alloc)(struct scsi_device * ) ;
   int (*slave_configure)(struct scsi_device * ) ;
   void (*slave_destroy)(struct scsi_device * ) ;
   int (*target_alloc)(struct scsi_target * ) ;
   void (*target_destroy)(struct scsi_target * ) ;
   int (*scan_finished)(struct Scsi_Host * , unsigned long  ) ;
   void (*scan_start)(struct Scsi_Host * ) ;
   int (*change_queue_depth)(struct scsi_device * , int  ) ;
   int (*bios_param)(struct scsi_device * , struct block_device * , sector_t  , int * ) ;
   void (*unlock_native_capacity)(struct scsi_device * ) ;
   int (*show_info)(struct seq_file * , struct Scsi_Host * ) ;
   int (*write_info)(struct Scsi_Host * , char * , int  ) ;
   enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd * ) ;
   int (*host_reset)(struct Scsi_Host * , int  ) ;
   char const   *proc_name ;
   struct proc_dir_entry *proc_dir ;
   int can_queue ;
   int this_id ;
   unsigned short sg_tablesize ;
   unsigned short sg_prot_tablesize ;
   unsigned int max_sectors ;
   unsigned long dma_boundary ;
   short cmd_per_lun ;
   unsigned char present ;
   int tag_alloc_policy ;
   unsigned char use_blk_tags : 1 ;
   unsigned char track_queue_depth : 1 ;
   unsigned char supported_mode : 2 ;
   unsigned char unchecked_isa_dma : 1 ;
   unsigned char use_clustering : 1 ;
   unsigned char emulated : 1 ;
   unsigned char skip_settle_delay : 1 ;
   unsigned char no_write_same : 1 ;
   unsigned char no_async_abort : 1 ;
   unsigned int max_host_blocked ;
   struct device_attribute **shost_attrs ;
   struct device_attribute **sdev_attrs ;
   struct list_head legacy_hosts ;
   u64 vendor_id ;
   unsigned int cmd_size ;
   struct scsi_host_cmd_pool *cmd_pool ;
   bool disable_blk_mq ;
};
#line 507 "include/scsi/scsi_host.h"
enum scsi_host_state {
    SHOST_CREATED = 1,
    SHOST_RUNNING = 2,
    SHOST_CANCEL = 3,
    SHOST_DEL = 4,
    SHOST_RECOVERY = 5,
    SHOST_CANCEL_RECOVERY = 6,
    SHOST_DEL_RECOVERY = 7
} ;
#line 517 "include/scsi/scsi_host.h"
union __anonunion____missing_field_name_264 {
   struct blk_queue_tag *bqt ;
   struct blk_mq_tag_set tag_set ;
};
#line 517 "include/scsi/scsi_host.h"
struct Scsi_Host {
   struct list_head __devices ;
   struct list_head __targets ;
   struct scsi_host_cmd_pool *cmd_pool ;
   spinlock_t free_list_lock ;
   struct list_head free_list ;
   struct list_head starved_list ;
   spinlock_t default_lock ;
   spinlock_t *host_lock ;
   struct mutex scan_mutex ;
   struct list_head eh_cmd_q ;
   struct task_struct *ehandler ;
   struct completion *eh_action ;
   wait_queue_head_t host_wait ;
   struct scsi_host_template *hostt ;
   struct scsi_transport_template *transportt ;
   union __anonunion____missing_field_name_264 __annonCompField85 ;
   atomic_t host_busy ;
   atomic_t host_blocked ;
   unsigned int host_failed ;
   unsigned int host_eh_scheduled ;
   unsigned int host_no ;
   int eh_deadline ;
   unsigned long last_reset ;
   unsigned int max_channel ;
   unsigned int max_id ;
   u64 max_lun ;
   unsigned int unique_id ;
   unsigned short max_cmd_len ;
   int this_id ;
   int can_queue ;
   short cmd_per_lun ;
   unsigned short sg_tablesize ;
   unsigned short sg_prot_tablesize ;
   unsigned int max_sectors ;
   unsigned long dma_boundary ;
   unsigned int nr_hw_queues ;
   unsigned long cmd_serial_number ;
   unsigned char active_mode : 2 ;
   unsigned char unchecked_isa_dma : 1 ;
   unsigned char use_clustering : 1 ;
   unsigned char host_self_blocked : 1 ;
   unsigned char reverse_ordering : 1 ;
   unsigned char tmf_in_progress : 1 ;
   unsigned char async_scan : 1 ;
   unsigned char eh_noresume : 1 ;
   unsigned char no_write_same : 1 ;
   unsigned char use_blk_mq : 1 ;
   unsigned char use_cmd_list : 1 ;
   char work_q_name[20U] ;
   struct workqueue_struct *work_q ;
   struct workqueue_struct *tmf_work_q ;
   unsigned char no_scsi2_lun_in_cdb : 1 ;
   unsigned int max_host_blocked ;
   unsigned int prot_capabilities ;
   unsigned char prot_guard_type ;
   struct request_queue *uspace_req_q ;
   unsigned long base ;
   unsigned long io_port ;
   unsigned char n_io_port ;
   unsigned char dma_channel ;
   unsigned int irq ;
   enum scsi_host_state shost_state ;
   struct device shost_gendev ;
   struct device shost_dev ;
   struct list_head sht_legacy_list ;
   void *shost_data ;
   struct device *dma_dev ;
   unsigned long hostdata[0U] ;
};
#line 25 "include/scsi/scsi_device.h"
enum scsi_device_state {
    SDEV_CREATED = 1,
    SDEV_RUNNING = 2,
    SDEV_CANCEL = 3,
    SDEV_DEL = 4,
    SDEV_QUIESCE = 5,
    SDEV_OFFLINE = 6,
    SDEV_TRANSPORT_OFFLINE = 7,
    SDEV_BLOCK = 8,
    SDEV_CREATED_BLOCK = 9
} ;
#line 71
struct scsi_dh_data;
#line 71 "include/scsi/scsi_device.h"
struct scsi_device {
   struct Scsi_Host *host ;
   struct request_queue *request_queue ;
   struct list_head siblings ;
   struct list_head same_target_siblings ;
   atomic_t device_busy ;
   atomic_t device_blocked ;
   spinlock_t list_lock ;
   struct list_head cmd_list ;
   struct list_head starved_entry ;
   struct scsi_cmnd *current_cmnd ;
   unsigned short queue_depth ;
   unsigned short max_queue_depth ;
   unsigned short last_queue_full_depth ;
   unsigned short last_queue_full_count ;
   unsigned long last_queue_full_time ;
   unsigned long queue_ramp_up_period ;
   unsigned long last_queue_ramp_up ;
   unsigned int id ;
   unsigned int channel ;
   u64 lun ;
   unsigned int manufacturer ;
   unsigned int sector_size ;
   void *hostdata ;
   char type ;
   char scsi_level ;
   char inq_periph_qual ;
   unsigned char inquiry_len ;
   unsigned char *inquiry ;
   char const   *vendor ;
   char const   *model ;
   char const   *rev ;
   int vpd_pg83_len ;
   unsigned char *vpd_pg83 ;
   int vpd_pg80_len ;
   unsigned char *vpd_pg80 ;
   unsigned char current_tag ;
   struct scsi_target *sdev_target ;
   unsigned int sdev_bflags ;
   unsigned int eh_timeout ;
   unsigned char removable : 1 ;
   unsigned char changed : 1 ;
   unsigned char busy : 1 ;
   unsigned char lockable : 1 ;
   unsigned char locked : 1 ;
   unsigned char borken : 1 ;
   unsigned char disconnect : 1 ;
   unsigned char soft_reset : 1 ;
   unsigned char sdtr : 1 ;
   unsigned char wdtr : 1 ;
   unsigned char ppr : 1 ;
   unsigned char tagged_supported : 1 ;
   unsigned char simple_tags : 1 ;
   unsigned char was_reset : 1 ;
   unsigned char expecting_cc_ua : 1 ;
   unsigned char use_10_for_rw : 1 ;
   unsigned char use_10_for_ms : 1 ;
   unsigned char no_report_opcodes : 1 ;
   unsigned char no_write_same : 1 ;
   unsigned char use_16_for_rw : 1 ;
   unsigned char skip_ms_page_8 : 1 ;
   unsigned char skip_ms_page_3f : 1 ;
   unsigned char skip_vpd_pages : 1 ;
   unsigned char try_vpd_pages : 1 ;
   unsigned char use_192_bytes_for_3f : 1 ;
   unsigned char no_start_on_add : 1 ;
   unsigned char allow_restart : 1 ;
   unsigned char manage_start_stop : 1 ;
   unsigned char start_stop_pwr_cond : 1 ;
   unsigned char no_uld_attach : 1 ;
   unsigned char select_no_atn : 1 ;
   unsigned char fix_capacity : 1 ;
   unsigned char guess_capacity : 1 ;
   unsigned char retry_hwerror : 1 ;
   unsigned char last_sector_bug : 1 ;
   unsigned char no_read_disc_info : 1 ;
   unsigned char no_read_capacity_16 : 1 ;
   unsigned char try_rc_10_first : 1 ;
   unsigned char is_visible : 1 ;
   unsigned char wce_default_on : 1 ;
   unsigned char no_dif : 1 ;
   unsigned char broken_fua : 1 ;
   unsigned char lun_in_cdb : 1 ;
   atomic_t disk_events_disable_depth ;
   unsigned long supported_events[1U] ;
   unsigned long pending_events[1U] ;
   struct list_head event_list ;
   struct work_struct event_work ;
   unsigned int max_device_blocked ;
   atomic_t iorequest_cnt ;
   atomic_t iodone_cnt ;
   atomic_t ioerr_cnt ;
   struct device sdev_gendev ;
   struct device sdev_dev ;
   struct execute_work ew ;
   struct work_struct requeue_work ;
   struct scsi_dh_data *scsi_dh_data ;
   enum scsi_device_state sdev_state ;
   unsigned long sdev_data[0U] ;
};
#line 204 "include/scsi/scsi_device.h"
struct scsi_device_handler {
   struct list_head list ;
   struct module *module ;
   char const   *name ;
   int (*check_sense)(struct scsi_device * , struct scsi_sense_hdr * ) ;
   struct scsi_dh_data *(*attach)(struct scsi_device * ) ;
   void (*detach)(struct scsi_device * ) ;
   int (*activate)(struct scsi_device * , void (*)(void * , int  ) , void * ) ;
   int (*prep_fn)(struct scsi_device * , struct request * ) ;
   int (*set_params)(struct scsi_device * , char const   * ) ;
   bool (*match)(struct scsi_device * ) ;
};
#line 219 "include/scsi/scsi_device.h"
struct scsi_dh_data {
   struct scsi_device_handler *scsi_dh ;
   struct scsi_device *sdev ;
   struct kref kref ;
};
#line 249
enum scsi_target_state {
    STARGET_CREATED = 1,
    STARGET_RUNNING = 2,
    STARGET_DEL = 3
} ;
#line 255 "include/scsi/scsi_device.h"
struct scsi_target {
   struct scsi_device *starget_sdev_user ;
   struct list_head siblings ;
   struct list_head devices ;
   struct device dev ;
   struct kref reap_ref ;
   unsigned int channel ;
   unsigned int id ;
   unsigned char create : 1 ;
   unsigned char single_lun : 1 ;
   unsigned char pdt_1f_for_no_lun : 1 ;
   unsigned char no_report_luns : 1 ;
   unsigned char expecting_lun_change : 1 ;
   atomic_t target_busy ;
   atomic_t target_blocked ;
   unsigned int can_queue ;
   unsigned int max_target_blocked ;
   char scsi_level ;
   enum scsi_target_state state ;
   void *hostdata ;
   unsigned long starget_data[0U] ;
};
#line 533 "include/scsi/scsi_device.h"
struct scsi_data_buffer {
   struct sg_table table ;
   unsigned int length ;
   int resid ;
};
#line 39 "include/scsi/scsi_cmnd.h"
struct scsi_pointer {
   char *ptr ;
   int this_residual ;
   struct scatterlist *buffer ;
   int buffers_residual ;
   dma_addr_t dma_handle ;
   int volatile   Status ;
   int volatile   Message ;
   int volatile   have_data_in ;
   int volatile   sent_command ;
   int volatile   phase ;
};
#line 55 "include/scsi/scsi_cmnd.h"
struct scsi_cmnd {
   struct scsi_device *device ;
   struct list_head list ;
   struct list_head eh_entry ;
   struct delayed_work abort_work ;
   int eh_eflags ;
   unsigned long serial_number ;
   unsigned long jiffies_at_alloc ;
   int retries ;
   int allowed ;
   unsigned char prot_op ;
   unsigned char prot_type ;
   unsigned char prot_flags ;
   unsigned short cmd_len ;
   enum dma_data_direction sc_data_direction ;
   unsigned char *cmnd ;
   struct scsi_data_buffer sdb ;
   struct scsi_data_buffer *prot_sdb ;
   unsigned int underflow ;
   unsigned int transfersize ;
   struct request *request ;
   unsigned char *sense_buffer ;
   void (*scsi_done)(struct scsi_cmnd * ) ;
   struct scsi_pointer SCp ;
   unsigned char *host_scribble ;
   int result ;
   int flags ;
   unsigned char tag ;
};
#line 351 "include/scsi/scsi_cmnd.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 21 "include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
#line 27 "include/linux/uio.h"
union __anonunion____missing_field_name_267 {
   struct iovec  const  *iov ;
   struct kvec  const  *kvec ;
   struct bio_vec  const  *bvec ;
};
#line 27 "include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion____missing_field_name_267 __annonCompField86 ;
   unsigned long nr_segs ;
};
#line 11 "include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 23 "include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 24 "include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 38 "include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iov_iter msg_iter ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
   struct kiocb *msg_iocb ;
};
#line 123 "include/linux/random.h"
enum ldv_27959 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
} ;
#line 53 "include/uapi/linux/net.h"
typedef enum ldv_27959 socket_state;
#line 70 "include/uapi/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};
#line 93 "include/linux/net.h"
struct proto_ops;
#line 93 "include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops  const  *ops ;
};
#line 119 "include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket * ) ;
   int (*bind)(struct socket * , struct sockaddr * , int  ) ;
   int (*connect)(struct socket * , struct sockaddr * , int  , int  ) ;
   int (*socketpair)(struct socket * , struct socket * ) ;
   int (*accept)(struct socket * , struct socket * , int  ) ;
   int (*getname)(struct socket * , struct sockaddr * , int * , int  ) ;
   unsigned int (*poll)(struct file * , struct socket * , struct poll_table_struct * ) ;
   int (*ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*listen)(struct socket * , int  ) ;
   int (*shutdown)(struct socket * , int  ) ;
   int (*setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*compat_setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*compat_getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*sendmsg)(struct socket * , struct msghdr * , size_t  ) ;
   int (*recvmsg)(struct socket * , struct msghdr * , size_t  , int  ) ;
   int (*mmap)(struct file * , struct socket * , struct vm_area_struct * ) ;
   ssize_t (*sendpage)(struct socket * , struct page * , int  , size_t  , int  ) ;
   ssize_t (*splice_read)(struct socket * , loff_t * , struct pipe_inode_info * ,
                          size_t  , unsigned int  ) ;
   int (*set_peek_off)(struct sock * , int  ) ;
};
#line 161 "./arch/x86/include/asm/checksum_64.h"
struct in6_addr;
#line 140 "include/net/checksum.h"
struct sk_buff;
#line 15 "include/linux/netdev_features.h"
typedef u64 netdev_features_t;
#line 66 "include/linux/netdev_features.h"
union __anonunion_in6_u_268 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};
#line 66 "include/linux/netdev_features.h"
struct in6_addr {
   union __anonunion_in6_u_268 in6_u ;
};
#line 46 "include/linux/in6.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
#line 218 "include/net/flow_dissector.h"
struct pipe_buf_operations;
#line 218 "include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations  const  *ops ;
   unsigned int flags ;
   unsigned long private ;
};
#line 27 "include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};
#line 61 "include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*release)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   int (*steal)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*get)(struct pipe_inode_info * , struct pipe_buffer * ) ;
};
#line 86 "include/linux/splice.h"
struct napi_struct;
#line 87 "include/linux/splice.h"
struct nf_conntrack {
   atomic_t use ;
};
#line 172 "include/linux/skbuff.h"
union __anonunion____missing_field_name_273 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};
#line 172 "include/linux/skbuff.h"
union __anonunion____missing_field_name_274 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};
#line 172 "include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   unsigned char orig_proto ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion____missing_field_name_273 __annonCompField90 ;
   union __anonunion____missing_field_name_274 __annonCompField91 ;
};
#line 189 "include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 403 "include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 404 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_277 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};
#line 404 "include/linux/skbuff.h"
union __anonunion____missing_field_name_276 {
   u64 v64 ;
   struct __anonstruct____missing_field_name_277 __annonCompField92 ;
};
#line 404 "include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion____missing_field_name_276 __annonCompField93 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_280 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};
#line 457 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_279 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion____missing_field_name_280 __annonCompField94 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_278 {
   struct __anonstruct____missing_field_name_279 __annonCompField95 ;
   struct rb_node rbnode ;
};
#line 457
struct sec_path;
#line 457 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_282 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_281 {
   __wsum csum ;
   struct __anonstruct____missing_field_name_282 __annonCompField97 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_283 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_284 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_285 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};
#line 457 "include/linux/skbuff.h"
struct sk_buff {
   union __anonunion____missing_field_name_278 __annonCompField96 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff * ) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   unsigned char cloned : 1 ;
   unsigned char nohdr : 1 ;
   unsigned char fclone : 2 ;
   unsigned char peeked : 1 ;
   unsigned char head_frag : 1 ;
   unsigned char xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   unsigned char pkt_type : 3 ;
   unsigned char pfmemalloc : 1 ;
   unsigned char ignore_df : 1 ;
   unsigned char nfctinfo : 3 ;
   unsigned char nf_trace : 1 ;
   unsigned char ip_summed : 2 ;
   unsigned char ooo_okay : 1 ;
   unsigned char l4_hash : 1 ;
   unsigned char sw_hash : 1 ;
   unsigned char wifi_acked_valid : 1 ;
   unsigned char wifi_acked : 1 ;
   unsigned char no_fcs : 1 ;
   unsigned char encapsulation : 1 ;
   unsigned char encap_hdr_csum : 1 ;
   unsigned char csum_valid : 1 ;
   unsigned char csum_complete_sw : 1 ;
   unsigned char csum_level : 2 ;
   unsigned char csum_bad : 1 ;
   unsigned char ndisc_nodetype : 2 ;
   unsigned char ipvs_property : 1 ;
   unsigned char inner_protocol_type : 1 ;
   unsigned char remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion____missing_field_name_281 __annonCompField98 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion____missing_field_name_283 __annonCompField99 ;
   __u32 secmark ;
   union __anonunion____missing_field_name_284 __annonCompField100 ;
   union __anonunion____missing_field_name_285 __annonCompField101 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 718
struct dst_entry;
#line 767
struct rtable;
#line 99 "include/linux/security.h"
struct xfrm_policy;
#line 100
struct xfrm_state;
#line 114
struct request_sock;
#line 1628
struct mnt_namespace;
#line 1629
struct ipc_namespace;
#line 1630 "include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
#line 41 "include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 147 "include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
#line 106 "include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr  const  *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};
#line 96 "./include/uapi/scsi/scsi_netlink.h"
enum fc_port_type {
    FC_PORTTYPE_UNKNOWN = 0,
    FC_PORTTYPE_OTHER = 1,
    FC_PORTTYPE_NOTPRESENT = 2,
    FC_PORTTYPE_NPORT = 3,
    FC_PORTTYPE_NLPORT = 4,
    FC_PORTTYPE_LPORT = 5,
    FC_PORTTYPE_PTP = 6,
    FC_PORTTYPE_NPIV = 7
} ;
#line 107
enum fc_port_state {
    FC_PORTSTATE_UNKNOWN = 0,
    FC_PORTSTATE_NOTPRESENT = 1,
    FC_PORTSTATE_ONLINE = 2,
    FC_PORTSTATE_OFFLINE = 3,
    FC_PORTSTATE_BLOCKED = 4,
    FC_PORTSTATE_BYPASSED = 5,
    FC_PORTSTATE_DIAGNOSTICS = 6,
    FC_PORTSTATE_LINKDOWN = 7,
    FC_PORTSTATE_ERROR = 8,
    FC_PORTSTATE_LOOPBACK = 9,
    FC_PORTSTATE_DELETED = 10
} ;
#line 121
enum fc_vport_state {
    FC_VPORT_UNKNOWN = 0,
    FC_VPORT_ACTIVE = 1,
    FC_VPORT_DISABLED = 2,
    FC_VPORT_LINKDOWN = 3,
    FC_VPORT_INITIALIZING = 4,
    FC_VPORT_NO_FABRIC_SUPP = 5,
    FC_VPORT_NO_FABRIC_RSCS = 6,
    FC_VPORT_FABRIC_LOGOUT = 7,
    FC_VPORT_FABRIC_REJ_WWN = 8,
    FC_VPORT_FAILED = 9
} ;
#line 195 "include/scsi/scsi_transport_fc.h"
struct fc_vport {
   enum fc_vport_state vport_state ;
   enum fc_vport_state vport_last_state ;
   u64 node_name ;
   u64 port_name ;
   u32 roles ;
   u32 vport_id ;
   enum fc_port_type vport_type ;
   char symbolic_name[64U] ;
   void *dd_data ;
   struct Scsi_Host *shost ;
   unsigned int channel ;
   u32 number ;
   u8 flags ;
   struct list_head peers ;
   struct device dev ;
   struct work_struct vport_delete_work ;
};
#line 294 "include/scsi/scsi_transport_fc.h"
struct fc_rport {
   u32 maxframe_size ;
   u32 supported_classes ;
   u32 dev_loss_tmo ;
   u64 node_name ;
   u64 port_name ;
   u32 port_id ;
   u32 roles ;
   enum fc_port_state port_state ;
   u32 scsi_target_id ;
   u32 fast_io_fail_tmo ;
   void *dd_data ;
   unsigned int channel ;
   u32 number ;
   u8 flags ;
   struct list_head peers ;
   struct device dev ;
   struct delayed_work dev_loss_work ;
   struct work_struct scan_work ;
   struct delayed_work fail_io_work ;
   struct work_struct stgt_delete_work ;
   struct work_struct rport_delete_work ;
   struct request_queue *rqst_q ;
};
#line 394 "include/scsi/scsi_transport_fc.h"
struct fc_host_statistics {
   u64 seconds_since_last_reset ;
   u64 tx_frames ;
   u64 tx_words ;
   u64 rx_frames ;
   u64 rx_words ;
   u64 lip_count ;
   u64 nos_count ;
   u64 error_frames ;
   u64 dumped_frames ;
   u64 link_failure_count ;
   u64 loss_of_sync_count ;
   u64 loss_of_signal_count ;
   u64 prim_seq_protocol_err_count ;
   u64 invalid_tx_word_count ;
   u64 invalid_crc_count ;
   u64 fcp_input_requests ;
   u64 fcp_output_requests ;
   u64 fcp_control_requests ;
   u64 fcp_input_megabytes ;
   u64 fcp_output_megabytes ;
   u64 fcp_packet_alloc_failures ;
   u64 fcp_packet_aborts ;
   u64 fcp_frame_alloc_failures ;
   u64 fc_no_free_exch ;
   u64 fc_no_free_exch_xid ;
   u64 fc_xid_not_found ;
   u64 fc_xid_busy ;
   u64 fc_seq_not_found ;
   u64 fc_non_bls_resp ;
};
#line 447
enum fc_host_event_code {
    FCH_EVT_LIP = 1,
    FCH_EVT_LINKUP = 2,
    FCH_EVT_LINKDOWN = 3,
    FCH_EVT_LIPRESET = 4,
    FCH_EVT_RSCN = 5,
    FCH_EVT_ADAPTER_CHANGE = 259,
    FCH_EVT_PORT_UNKNOWN = 512,
    FCH_EVT_PORT_OFFLINE = 513,
    FCH_EVT_PORT_ONLINE = 514,
    FCH_EVT_PORT_FABRIC = 516,
    FCH_EVT_LINK_UNKNOWN = 1280,
    FCH_EVT_VENDOR_UNIQUE = 65535
} ;
#line 547 "include/scsi/scsi_transport_fc.h"
struct fc_bsg_buffer {
   unsigned int payload_len ;
   int sg_cnt ;
   struct scatterlist *sg_list ;
};
#line 632
struct fc_bsg_request;
#line 632
struct fc_bsg_reply;
#line 632 "include/scsi/scsi_transport_fc.h"
struct fc_bsg_job {
   struct Scsi_Host *shost ;
   struct fc_rport *rport ;
   struct device *dev ;
   struct request *req ;
   spinlock_t job_lock ;
   unsigned int state_flags ;
   unsigned int ref_cnt ;
   void (*job_done)(struct fc_bsg_job * ) ;
   struct fc_bsg_request *request ;
   struct fc_bsg_reply *reply ;
   unsigned int request_len ;
   unsigned int reply_len ;
   struct fc_bsg_buffer request_payload ;
   struct fc_bsg_buffer reply_payload ;
   void *dd_data ;
};
#line 666 "include/scsi/scsi_transport_fc.h"
struct fc_function_template {
   void (*get_rport_dev_loss_tmo)(struct fc_rport * ) ;
   void (*set_rport_dev_loss_tmo)(struct fc_rport * , u32  ) ;
   void (*get_starget_node_name)(struct scsi_target * ) ;
   void (*get_starget_port_name)(struct scsi_target * ) ;
   void (*get_starget_port_id)(struct scsi_target * ) ;
   void (*get_host_port_id)(struct Scsi_Host * ) ;
   void (*get_host_port_type)(struct Scsi_Host * ) ;
   void (*get_host_port_state)(struct Scsi_Host * ) ;
   void (*get_host_active_fc4s)(struct Scsi_Host * ) ;
   void (*get_host_speed)(struct Scsi_Host * ) ;
   void (*get_host_fabric_name)(struct Scsi_Host * ) ;
   void (*get_host_symbolic_name)(struct Scsi_Host * ) ;
   void (*set_host_system_hostname)(struct Scsi_Host * ) ;
   struct fc_host_statistics *(*get_fc_host_stats)(struct Scsi_Host * ) ;
   void (*reset_fc_host_stats)(struct Scsi_Host * ) ;
   int (*issue_fc_host_lip)(struct Scsi_Host * ) ;
   void (*dev_loss_tmo_callbk)(struct fc_rport * ) ;
   void (*terminate_rport_io)(struct fc_rport * ) ;
   void (*set_vport_symbolic_name)(struct fc_vport * ) ;
   int (*vport_create)(struct fc_vport * , bool  ) ;
   int (*vport_disable)(struct fc_vport * , bool  ) ;
   int (*vport_delete)(struct fc_vport * ) ;
   int (*tsk_mgmt_response)(struct Scsi_Host * , u64  , u64  , int  ) ;
   int (*it_nexus_response)(struct Scsi_Host * , u64  , int  ) ;
   int (*bsg_request)(struct fc_bsg_job * ) ;
   int (*bsg_timeout)(struct fc_bsg_job * ) ;
   u32 dd_fcrport_size ;
   u32 dd_fcvport_size ;
   u32 dd_bsg_size ;
   unsigned char show_rport_maxframe_size : 1 ;
   unsigned char show_rport_supported_classes : 1 ;
   unsigned char show_rport_dev_loss_tmo : 1 ;
   unsigned char show_starget_node_name : 1 ;
   unsigned char show_starget_port_name : 1 ;
   unsigned char show_starget_port_id : 1 ;
   unsigned char show_host_node_name : 1 ;
   unsigned char show_host_port_name : 1 ;
   unsigned char show_host_permanent_port_name : 1 ;
   unsigned char show_host_supported_classes : 1 ;
   unsigned char show_host_supported_fc4s : 1 ;
   unsigned char show_host_supported_speeds : 1 ;
   unsigned char show_host_maxframe_size : 1 ;
   unsigned char show_host_serial_number : 1 ;
   unsigned char show_host_manufacturer : 1 ;
   unsigned char show_host_model : 1 ;
   unsigned char show_host_model_description : 1 ;
   unsigned char show_host_hardware_version : 1 ;
   unsigned char show_host_driver_version : 1 ;
   unsigned char show_host_firmware_version : 1 ;
   unsigned char show_host_optionrom_version : 1 ;
   unsigned char show_host_port_id : 1 ;
   unsigned char show_host_port_type : 1 ;
   unsigned char show_host_port_state : 1 ;
   unsigned char show_host_active_fc4s : 1 ;
   unsigned char show_host_speed : 1 ;
   unsigned char show_host_fabric_name : 1 ;
   unsigned char show_host_symbolic_name : 1 ;
   unsigned char show_host_system_hostname : 1 ;
   unsigned char disable_target_scan : 1 ;
};
#line 860 "include/scsi/scsi_transport_fc.h"
struct fc_bsg_host_add_rport {
   uint8_t reserved ;
   uint8_t port_id[3U] ;
};
#line 88 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_host_del_rport {
   uint8_t reserved ;
   uint8_t port_id[3U] ;
};
#line 109 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_host_els {
   uint8_t command_code ;
   uint8_t port_id[3U] ;
};
#line 133 "./include/uapi/scsi/scsi_bsg_fc.h"
struct __anonstruct_rjt_data_286 {
   uint8_t action ;
   uint8_t reason_code ;
   uint8_t reason_explanation ;
   uint8_t vendor_unique ;
};
#line 133 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_ctels_reply {
   uint32_t status ;
   struct __anonstruct_rjt_data_286 rjt_data ;
};
#line 178 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_host_ct {
   uint8_t reserved ;
   uint8_t port_id[3U] ;
   uint32_t preamble_word0 ;
   uint32_t preamble_word1 ;
   uint32_t preamble_word2 ;
};
#line 203 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_host_vendor {
   uint64_t vendor_id ;
   uint32_t vendor_cmd[0U] ;
};
#line 226 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_host_vendor_reply {
   uint32_t vendor_rsp[0U] ;
};
#line 233 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_rport_els {
   uint8_t els_code ;
};
#line 252 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_rport_ct {
   uint32_t preamble_word0 ;
   uint32_t preamble_word1 ;
   uint32_t preamble_word2 ;
};
#line 272 "./include/uapi/scsi/scsi_bsg_fc.h"
union __anonunion_rqst_data_287 {
   struct fc_bsg_host_add_rport h_addrport ;
   struct fc_bsg_host_del_rport h_delrport ;
   struct fc_bsg_host_els h_els ;
   struct fc_bsg_host_ct h_ct ;
   struct fc_bsg_host_vendor h_vendor ;
   struct fc_bsg_rport_els r_els ;
   struct fc_bsg_rport_ct r_ct ;
};
#line 272 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_request {
   uint32_t msgcode ;
   union __anonunion_rqst_data_287 rqst_data ;
};
#line 294 "./include/uapi/scsi/scsi_bsg_fc.h"
union __anonunion_reply_data_288 {
   struct fc_bsg_host_vendor_reply vendor_reply ;
   struct fc_bsg_ctels_reply ctels_reply ;
};
#line 294 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_reply {
   uint32_t result ;
   uint32_t reply_payload_rcv_len ;
   union __anonunion_reply_data_288 reply_data ;
};
#line 610 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla82xx_legacy_intr_set {
   uint32_t int_vec_bit ;
   uint32_t tgt_status_reg ;
   uint32_t tgt_mask_reg ;
   uint32_t pci_int_reg ;
};
#line 812 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct device_reg_82xx {
   uint32_t req_q_out[64U] ;
   uint32_t rsp_q_in[64U] ;
   uint32_t rsp_q_out[64U] ;
   uint16_t mailbox_in[32U] ;
   uint16_t unused_1[32U] ;
   uint32_t hint ;
   uint16_t unused_2[62U] ;
   uint16_t mailbox_out[32U] ;
   uint32_t unused_3[48U] ;
   uint32_t host_status ;
   uint32_t host_int ;
};
#line 862 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct fcp_cmnd {
   struct scsi_lun lun ;
   uint8_t crn ;
   uint8_t task_attribute ;
   uint8_t task_management ;
   uint8_t additional_cdb_len ;
   uint8_t cdb[260U] ;
};
#line 872 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct dsd_dma {
   struct list_head list ;
   dma_addr_t dsd_list_dma ;
   void *dsd_addr ;
};
#line 878 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct ct6_dsd {
   uint16_t fcp_cmnd_len ;
   dma_addr_t fcp_cmnd_dma ;
   struct fcp_cmnd *fcp_cmnd ;
   int dsd_use_cnt ;
   struct list_head dsd_list ;
};
#line 1186 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla8044_reset_template_hdr {
   uint16_t version ;
   uint16_t signature ;
   uint16_t size ;
   uint16_t entries ;
   uint16_t hdr_size ;
   uint16_t checksum ;
   uint16_t init_seq_offset ;
   uint16_t start_seq_offset ;
};
#line 270 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_reset_template {
   int seq_index ;
   int seq_error ;
   int array_index ;
   uint32_t array[16U] ;
   uint8_t *buff ;
   uint8_t *stop_offset ;
   uint8_t *start_offset ;
   uint8_t *init_offset ;
   struct qla8044_reset_template_hdr *hdr ;
   uint8_t seq_end ;
   uint8_t template_end ;
};
#line 891 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct device_reg_24xx {
   uint32_t flash_addr ;
   uint32_t flash_data ;
   uint32_t ctrl_status ;
   uint32_t ictrl ;
   uint32_t istatus ;
   uint32_t unused_1[2U] ;
   uint32_t req_q_in ;
   uint32_t req_q_out ;
   uint32_t rsp_q_in ;
   uint32_t rsp_q_out ;
   uint32_t preq_q_in ;
   uint32_t preq_q_out ;
   uint32_t unused_2[2U] ;
   uint32_t atio_q_in ;
   uint32_t atio_q_out ;
   uint32_t host_status ;
   uint32_t hccr ;
   uint32_t gpiod ;
   uint32_t gpioe ;
   uint32_t iobase_addr ;
   uint32_t unused_3[10U] ;
   uint16_t mailbox0 ;
   uint16_t mailbox1 ;
   uint16_t mailbox2 ;
   uint16_t mailbox3 ;
   uint16_t mailbox4 ;
   uint16_t mailbox5 ;
   uint16_t mailbox6 ;
   uint16_t mailbox7 ;
   uint16_t mailbox8 ;
   uint16_t mailbox9 ;
   uint16_t mailbox10 ;
   uint16_t mailbox11 ;
   uint16_t mailbox12 ;
   uint16_t mailbox13 ;
   uint16_t mailbox14 ;
   uint16_t mailbox15 ;
   uint16_t mailbox16 ;
   uint16_t mailbox17 ;
   uint16_t mailbox18 ;
   uint16_t mailbox19 ;
   uint16_t mailbox20 ;
   uint16_t mailbox21 ;
   uint16_t mailbox22 ;
   uint16_t mailbox23 ;
   uint16_t mailbox24 ;
   uint16_t mailbox25 ;
   uint16_t mailbox26 ;
   uint16_t mailbox27 ;
   uint16_t mailbox28 ;
   uint16_t mailbox29 ;
   uint16_t mailbox30 ;
   uint16_t mailbox31 ;
   uint32_t iobase_window ;
   uint32_t iobase_c4 ;
   uint32_t iobase_c8 ;
   uint32_t unused_4_1[6U] ;
   uint32_t iobase_q ;
   uint32_t unused_5[2U] ;
   uint32_t iobase_select ;
   uint32_t unused_6[2U] ;
   uint32_t iobase_sdata ;
};
#line 1412 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct qla_npiv_entry {
   uint16_t flags ;
   uint16_t vf_id ;
   uint8_t q_qos ;
   uint8_t f_qos ;
   uint16_t unused1 ;
   uint8_t port_name[8U] ;
   uint8_t node_name[8U] ;
};
#line 1864 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct ex_init_cb_81xx {
   uint16_t ex_version ;
   uint8_t prio_fcf_matching_flags ;
   uint8_t reserved_1[3U] ;
   uint16_t pri_fcf_vlan_id ;
   uint8_t pri_fcf_fabric_name[8U] ;
   uint16_t reserved_2[7U] ;
   uint8_t spma_mac_addr[6U] ;
   uint16_t reserved_3[14U] ;
};
#line 1875 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct qla_fcp_prio_entry {
   uint16_t flags ;
   uint8_t tag ;
   uint8_t reserved ;
   uint32_t src_pid ;
   uint32_t dst_pid ;
   uint16_t lun_beg ;
   uint16_t lun_end ;
   uint8_t src_wwpn[8U] ;
   uint8_t dst_wwpn[8U] ;
};
#line 1910 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct qla_fcp_prio_cfg {
   uint8_t signature[4U] ;
   uint16_t version ;
   uint16_t length ;
   uint16_t checksum ;
   uint16_t num_entries ;
   uint16_t size_of_entry ;
   uint8_t attributes ;
   uint8_t reserved ;
   struct qla_fcp_prio_entry entry[1U] ;
};
#line 1926
struct req_que;
#line 287 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct srb_cmd {
   struct scsi_cmnd *cmd ;
   uint32_t request_sense_length ;
   uint32_t fw_sense_length ;
   uint8_t *request_sense_ptr ;
   void *ctx ;
};
#line 298 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_logio_312 {
   uint16_t flags ;
   uint16_t data[2U] ;
};
#line 298 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_tmf_313 {
   uint64_t lun ;
   uint32_t flags ;
   uint32_t data ;
   struct completion comp ;
   __le16 comp_status ;
};
#line 298 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_fxiocb_314 {
   uint8_t flags ;
   uint32_t req_len ;
   uint32_t rsp_len ;
   void *req_addr ;
   void *rsp_addr ;
   dma_addr_t req_dma_handle ;
   dma_addr_t rsp_dma_handle ;
   __le32 adapter_id ;
   __le32 adapter_id_hi ;
   __le16 req_func_type ;
   __le32 req_data ;
   __le32 req_data_extra ;
   __le32 result ;
   __le32 seq_number ;
   __le16 fw_flags ;
   struct completion fxiocb_comp ;
   __le32 reserved_0 ;
   uint8_t reserved_1 ;
};
#line 298 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_abt_315 {
   uint32_t cmd_hndl ;
   __le16 comp_status ;
   struct completion comp ;
};
#line 298 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_u_311 {
   struct __anonstruct_logio_312 logio ;
   struct __anonstruct_tmf_313 tmf ;
   struct __anonstruct_fxiocb_314 fxiocb ;
   struct __anonstruct_abt_315 abt ;
};
#line 298 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct srb_iocb {
   union __anonunion_u_311 u ;
   struct timer_list timer ;
   void (*timeout)(void * ) ;
};
#line 370 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_u_316 {
   struct srb_iocb iocb_cmd ;
   struct fc_bsg_job *bsg_job ;
   struct srb_cmd scmd ;
};
#line 370 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct srb {
   atomic_t ref_count ;
   struct fc_port *fcport ;
   uint32_t handle ;
   uint16_t flags ;
   uint16_t type ;
   char *name ;
   int iocbs ;
   union __anonunion_u_316 u ;
   void (*done)(void * , void * , int  ) ;
   void (*free)(void * , void * ) ;
};
#line 401 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct srb srb_t;
#line 429 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_isp2100_318 {
   uint16_t mailbox0 ;
   uint16_t mailbox1 ;
   uint16_t mailbox2 ;
   uint16_t mailbox3 ;
   uint16_t mailbox4 ;
   uint16_t mailbox5 ;
   uint16_t mailbox6 ;
   uint16_t mailbox7 ;
   uint16_t unused_2[59U] ;
};
#line 429 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_isp2300_319 {
   uint16_t req_q_in ;
   uint16_t req_q_out ;
   uint16_t rsp_q_in ;
   uint16_t rsp_q_out ;
   uint32_t host_status ;
   uint16_t host_semaphore ;
   uint16_t unused_3[17U] ;
   uint16_t mailbox0 ;
   uint16_t mailbox1 ;
   uint16_t mailbox2 ;
   uint16_t mailbox3 ;
   uint16_t mailbox4 ;
   uint16_t mailbox5 ;
   uint16_t mailbox6 ;
   uint16_t mailbox7 ;
   uint16_t mailbox8 ;
   uint16_t mailbox9 ;
   uint16_t mailbox10 ;
   uint16_t mailbox11 ;
   uint16_t mailbox12 ;
   uint16_t mailbox13 ;
   uint16_t mailbox14 ;
   uint16_t mailbox15 ;
   uint16_t mailbox16 ;
   uint16_t mailbox17 ;
   uint16_t mailbox18 ;
   uint16_t mailbox19 ;
   uint16_t mailbox20 ;
   uint16_t mailbox21 ;
   uint16_t mailbox22 ;
   uint16_t mailbox23 ;
   uint16_t mailbox24 ;
   uint16_t mailbox25 ;
   uint16_t mailbox26 ;
   uint16_t mailbox27 ;
   uint16_t mailbox28 ;
   uint16_t mailbox29 ;
   uint16_t mailbox30 ;
   uint16_t mailbox31 ;
   uint16_t fb_cmd ;
   uint16_t unused_4[10U] ;
};
#line 429 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_u_317 {
   struct __anonstruct_isp2100_318 isp2100 ;
   struct __anonstruct_isp2300_319 isp2300 ;
};
#line 429 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_isp2200_321 {
   uint16_t unused_10[8U] ;
   uint16_t mailbox8 ;
   uint16_t mailbox9 ;
   uint16_t mailbox10 ;
   uint16_t mailbox11 ;
   uint16_t mailbox12 ;
   uint16_t mailbox13 ;
   uint16_t mailbox14 ;
   uint16_t mailbox15 ;
   uint16_t mailbox16 ;
   uint16_t mailbox17 ;
   uint16_t mailbox18 ;
   uint16_t mailbox19 ;
   uint16_t mailbox20 ;
   uint16_t mailbox21 ;
   uint16_t mailbox22 ;
   uint16_t mailbox23 ;
};
#line 429 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_u_end_320 {
   struct __anonstruct_isp2200_321 isp2200 ;
};
#line 429 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct device_reg_2xxx {
   uint16_t flash_address ;
   uint16_t flash_data ;
   uint16_t unused_1[1U] ;
   uint16_t ctrl_status ;
   uint16_t ictrl ;
   uint16_t istatus ;
   uint16_t semaphore ;
   uint16_t nvram ;
   union __anonunion_u_317 u ;
   uint16_t fpm_diag_config ;
   uint16_t unused_5[4U] ;
   uint16_t risc_hw ;
   uint16_t unused_5_1 ;
   uint16_t pcr ;
   uint16_t unused_6[5U] ;
   uint16_t mctr ;
   uint16_t unused_7[3U] ;
   uint16_t fb_cmd_2100 ;
   uint16_t unused_8[3U] ;
   uint16_t hccr ;
   uint16_t unused_9[5U] ;
   uint16_t gpiod ;
   uint16_t gpioe ;
   union __anonunion_u_end_320 u_end ;
};
#line 584 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct device_reg_25xxmq {
   uint32_t req_q_in ;
   uint32_t req_q_out ;
   uint32_t rsp_q_in ;
   uint32_t rsp_q_out ;
   uint32_t atio_q_in ;
   uint32_t atio_q_out ;
};
#line 593 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct device_reg_fx00 {
   uint32_t mailbox0 ;
   uint32_t mailbox1 ;
   uint32_t mailbox2 ;
   uint32_t mailbox3 ;
   uint32_t mailbox4 ;
   uint32_t mailbox5 ;
   uint32_t mailbox6 ;
   uint32_t mailbox7 ;
   uint32_t mailbox8 ;
   uint32_t mailbox9 ;
   uint32_t mailbox10 ;
   uint32_t mailbox11 ;
   uint32_t mailbox12 ;
   uint32_t mailbox13 ;
   uint32_t mailbox14 ;
   uint32_t mailbox15 ;
   uint32_t mailbox16 ;
   uint32_t mailbox17 ;
   uint32_t mailbox18 ;
   uint32_t mailbox19 ;
   uint32_t mailbox20 ;
   uint32_t mailbox21 ;
   uint32_t mailbox22 ;
   uint32_t mailbox23 ;
   uint32_t mailbox24 ;
   uint32_t mailbox25 ;
   uint32_t mailbox26 ;
   uint32_t mailbox27 ;
   uint32_t mailbox28 ;
   uint32_t mailbox29 ;
   uint32_t mailbox30 ;
   uint32_t mailbox31 ;
   uint32_t aenmailbox0 ;
   uint32_t aenmailbox1 ;
   uint32_t aenmailbox2 ;
   uint32_t aenmailbox3 ;
   uint32_t aenmailbox4 ;
   uint32_t aenmailbox5 ;
   uint32_t aenmailbox6 ;
   uint32_t aenmailbox7 ;
   uint32_t req_q_in ;
   uint32_t req_q_out ;
   uint32_t rsp_q_in ;
   uint32_t rsp_q_out ;
   uint32_t initval0 ;
   uint32_t initval1 ;
   uint32_t initval2 ;
   uint32_t initval3 ;
   uint32_t initval4 ;
   uint32_t initval5 ;
   uint32_t initval6 ;
   uint32_t initval7 ;
   uint32_t fwheartbeat ;
   uint32_t pseudoaen ;
};
#line 663 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_device_reg_t_322 {
   struct device_reg_2xxx isp ;
   struct device_reg_24xx isp24 ;
   struct device_reg_25xxmq isp25mq ;
   struct device_reg_82xx isp82 ;
   struct device_reg_fx00 ispfx00 ;
};
#line 663 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef union __anonunion_device_reg_t_322 device_reg_t;
#line 716 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_mbx_cmd_t_323 {
   uint32_t out_mb ;
   uint32_t in_mb ;
   uint16_t mb[32U] ;
   long buf_size ;
   void *bufp ;
   uint32_t tov ;
   uint8_t flags ;
};
#line 716 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_mbx_cmd_t_323 mbx_cmd_t;
#line 714 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct mbx_cmd_32 {
   uint32_t out_mb ;
   uint32_t in_mb ;
   uint32_t mb[32U] ;
   long buf_size ;
   void *bufp ;
   uint32_t tov ;
   uint8_t flags ;
};
#line 1214 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_init_cb_t_325 {
   uint8_t version ;
   uint8_t reserved_1 ;
   uint8_t firmware_options[2U] ;
   uint16_t frame_payload_size ;
   uint16_t max_iocb_allocation ;
   uint16_t execution_throttle ;
   uint8_t retry_count ;
   uint8_t retry_delay ;
   uint8_t port_name[8U] ;
   uint16_t hard_address ;
   uint8_t inquiry_data ;
   uint8_t login_timeout ;
   uint8_t node_name[8U] ;
   uint16_t request_q_outpointer ;
   uint16_t response_q_inpointer ;
   uint16_t request_q_length ;
   uint16_t response_q_length ;
   uint32_t request_q_address[2U] ;
   uint32_t response_q_address[2U] ;
   uint16_t lun_enables ;
   uint8_t command_resource_count ;
   uint8_t immediate_notify_resource_count ;
   uint16_t timeout ;
   uint8_t reserved_2[2U] ;
   uint8_t add_firmware_options[2U] ;
   uint8_t response_accumulation_timer ;
   uint8_t interrupt_delay_timer ;
   uint8_t special_options[2U] ;
   uint8_t reserved_3[26U] ;
};
#line 1214 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_init_cb_t_325 init_cb_t;
#line 1504 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_response_t_327 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint8_t data[52U] ;
   uint32_t signature ;
};
#line 1504 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_response_t_327 response_t;
#line 1504 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct atio {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t data[58U] ;
   uint32_t signature ;
};
#line 1523 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_id_329 {
   uint8_t reserved ;
   uint8_t standard ;
};
#line 1523 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_target_id_t_328 {
   uint16_t extended ;
   struct __anonstruct_id_329 id ;
};
#line 1523 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef union __anonunion_target_id_t_328 target_id_t;
#line 1562 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_cmd_entry_t_330 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   target_id_t target ;
   uint16_t lun ;
   uint16_t control_flags ;
   uint16_t reserved_1 ;
   uint16_t timeout ;
   uint16_t dseg_count ;
   uint8_t scsi_cdb[16U] ;
   uint32_t byte_count ;
   uint32_t dseg_0_address ;
   uint32_t dseg_0_length ;
   uint32_t dseg_1_address ;
   uint32_t dseg_1_length ;
   uint32_t dseg_2_address ;
   uint32_t dseg_2_length ;
};
#line 1562 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_cmd_entry_t_330 cmd_entry_t;
#line 1586 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_request_t_332 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   target_id_t target ;
   uint16_t lun ;
   uint16_t control_flags ;
   uint16_t reserved_1 ;
   uint16_t timeout ;
   uint16_t dseg_count ;
   uint8_t scsi_cdb[16U] ;
   uint32_t byte_count ;
   uint32_t dseg_0_address[2U] ;
   uint32_t dseg_0_length ;
   uint32_t dseg_1_address[2U] ;
   uint32_t dseg_1_length ;
};
#line 1586 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_request_t_332 request_t;
#line 1634 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_nobundling_336 {
   uint32_t reserved_1 ;
   uint16_t reserved_2 ;
   uint16_t reserved_3 ;
   uint32_t reserved_4 ;
   uint32_t data_address[2U] ;
   uint32_t data_length ;
   uint32_t reserved_5[2U] ;
   uint32_t reserved_6 ;
};
#line 1634 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_bundling_337 {
   __le32 dif_byte_count ;
   uint16_t reserved_1 ;
   __le16 dseg_count ;
   uint32_t reserved_2 ;
   uint32_t data_address[2U] ;
   uint32_t data_length ;
   uint32_t dif_address[2U] ;
   uint32_t dif_length ;
};
#line 1634 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_u_335 {
   struct __anonstruct_nobundling_336 nobundling ;
   struct __anonstruct_bundling_337 bundling ;
};
#line 1634 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct crc_context {
   uint32_t handle ;
   __le32 ref_tag ;
   __le16 app_tag ;
   uint8_t ref_tag_mask[4U] ;
   uint8_t app_tag_mask[2U] ;
   __le16 guard_seed ;
   __le16 prot_opts ;
   __le16 blk_size ;
   uint16_t runt_blk_guard ;
   __le32 byte_count ;
   union __anonunion_u_335 u ;
   struct fcp_cmnd fcp_cmnd ;
   dma_addr_t crc_ctx_dma ;
   struct list_head dsd_list ;
};
#line 1886 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_ms_iocb_entry_t_343 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t handle_count ;
   uint8_t entry_status ;
   uint32_t handle1 ;
   target_id_t loop_id ;
   uint16_t status ;
   uint16_t control_flags ;
   uint16_t reserved2 ;
   uint16_t timeout ;
   uint16_t cmd_dsd_count ;
   uint16_t total_dsd_count ;
   uint8_t type ;
   uint8_t r_ctl ;
   uint16_t rx_id ;
   uint16_t reserved3 ;
   uint32_t handle2 ;
   uint32_t rsp_bytecount ;
   uint32_t req_bytecount ;
   uint32_t dseg_req_address[2U] ;
   uint32_t dseg_req_length ;
   uint32_t dseg_rsp_address[2U] ;
   uint32_t dseg_rsp_length ;
};
#line 1886 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_ms_iocb_entry_t_343 ms_iocb_entry_t;
#line 1957 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_b_345 {
   uint8_t al_pa ;
   uint8_t area ;
   uint8_t domain ;
   uint8_t rsvd_1 ;
};
#line 1957 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_port_id_t_344 {
   unsigned int b24 : 24 ;
   struct __anonstruct_b_345 b ;
};
#line 1957 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef union __anonunion_port_id_t_344 port_id_t;
#line 1971
enum ldv_30574 {
    FCT_UNKNOWN = 0,
    FCT_RSCN = 1,
    FCT_SWITCH = 2,
    FCT_BROADCAST = 3,
    FCT_INITIATOR = 4,
    FCT_TARGET = 5
} ;
#line 1987 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef enum ldv_30574 fc_port_type_t;
#line 1988 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct fc_port {
   struct list_head list ;
   struct scsi_qla_host *vha ;
   uint8_t node_name[8U] ;
   uint8_t port_name[8U] ;
   port_id_t d_id ;
   uint16_t loop_id ;
   uint16_t old_loop_id ;
   uint16_t tgt_id ;
   uint16_t old_tgt_id ;
   uint8_t fcp_prio ;
   uint8_t fabric_port_name[8U] ;
   uint16_t fp_speed ;
   fc_port_type_t port_type ;
   atomic_t state ;
   uint32_t flags ;
   int login_retry ;
   struct fc_rport *rport ;
   struct fc_rport *drport ;
   u32 supported_classes ;
   uint8_t fc4_type ;
   uint8_t scan_state ;
   unsigned long last_queue_full ;
   unsigned long last_ramp_up ;
   uint16_t port_id ;
   unsigned long retry_delay_timestamp ;
};
#line 2029 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct fc_port fc_port_t;
#line 446 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct mr_data_fx00 {
   uint8_t symbolic_name[64U] ;
   uint8_t serial_num[32U] ;
   uint8_t hw_version[16U] ;
   uint8_t fw_version[16U] ;
   uint8_t uboot_version[16U] ;
   uint8_t fru_serial_num[32U] ;
   fc_port_t fcport ;
   uint8_t fw_hbt_en ;
   uint8_t fw_hbt_cnt ;
   uint8_t fw_hbt_miss_cnt ;
   uint32_t old_fw_hbt_cnt ;
   uint16_t fw_reset_timer_tick ;
   uint8_t fw_reset_timer_exp ;
   uint16_t fw_critemp_timer_tick ;
   uint32_t old_aenmbx0_state ;
   uint32_t critical_temperature ;
   bool extended_io_enabled ;
   bool host_info_resend ;
   uint8_t hinfo_resend_timer_tick ;
};
#line 2048 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_a_347 {
   uint8_t node_name[8U] ;
   uint8_t manufacturer[64U] ;
   uint8_t serial_num[32U] ;
   uint8_t model[17U] ;
   uint8_t model_desc[80U] ;
   uint8_t hw_version[32U] ;
   uint8_t driver_version[32U] ;
   uint8_t orom_version[16U] ;
   uint8_t fw_version[32U] ;
   uint8_t os_version[128U] ;
   uint32_t max_ct_len ;
};
#line 2048 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct ct_fdmi_hba_attr {
   uint16_t type ;
   uint16_t len ;
   union __anonunion_a_347 a ;
};
#line 2176 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct ct_fdmi_hba_attributes {
   uint32_t count ;
   struct ct_fdmi_hba_attr entry[9U] ;
};
#line 2181 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_a_348 {
   uint8_t node_name[8U] ;
   uint8_t manufacturer[64U] ;
   uint8_t serial_num[32U] ;
   uint8_t model[17U] ;
   uint8_t model_desc[80U] ;
   uint8_t hw_version[16U] ;
   uint8_t driver_version[32U] ;
   uint8_t orom_version[16U] ;
   uint8_t fw_version[32U] ;
   uint8_t os_version[128U] ;
   uint32_t max_ct_len ;
   uint8_t sym_name[256U] ;
   uint32_t vendor_id ;
   uint32_t num_ports ;
   uint8_t fabric_name[8U] ;
   uint8_t bios_name[32U] ;
   uint8_t vendor_indentifer[8U] ;
};
#line 2181 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct ct_fdmiv2_hba_attr {
   uint16_t type ;
   uint16_t len ;
   union __anonunion_a_348 a ;
};
#line 2205 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct ct_fdmiv2_hba_attributes {
   uint32_t count ;
   struct ct_fdmiv2_hba_attr entry[17U] ;
};
#line 2210 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_a_349 {
   uint8_t fc4_types[32U] ;
   uint32_t sup_speed ;
   uint32_t cur_speed ;
   uint32_t max_frame_size ;
   uint8_t os_dev_name[32U] ;
   uint8_t host_name[256U] ;
   uint8_t node_name[8U] ;
   uint8_t port_name[8U] ;
   uint8_t port_sym_name[128U] ;
   uint32_t port_type ;
   uint32_t port_supported_cos ;
   uint8_t fabric_name[8U] ;
   uint8_t port_fc4_type[32U] ;
   uint32_t port_state ;
   uint32_t num_ports ;
   uint32_t port_id ;
};
#line 2210 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct ct_fdmiv2_port_attr {
   uint16_t type ;
   uint16_t len ;
   union __anonunion_a_349 a ;
};
#line 2268 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct ct_fdmiv2_port_attributes {
   uint32_t count ;
   struct ct_fdmiv2_port_attr entry[16U] ;
};
#line 2276 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_a_350 {
   uint8_t fc4_types[32U] ;
   uint32_t sup_speed ;
   uint32_t cur_speed ;
   uint32_t max_frame_size ;
   uint8_t os_dev_name[32U] ;
   uint8_t host_name[256U] ;
};
#line 2276 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct ct_fdmi_port_attr {
   uint16_t type ;
   uint16_t len ;
   union __anonunion_a_350 a ;
};
#line 2289 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct ct_fdmi_port_attributes {
   uint32_t count ;
   struct ct_fdmi_port_attr entry[6U] ;
};
#line 2294 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct ct_cmd_hdr {
   uint8_t revision ;
   uint8_t in_id[3U] ;
   uint8_t gs_type ;
   uint8_t gs_subtype ;
   uint8_t options ;
   uint8_t reserved ;
};
#line 2327 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_port_id_352 {
   uint8_t reserved ;
   uint8_t port_id[3U] ;
};
#line 2327 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_gid_pt_353 {
   uint8_t port_type ;
   uint8_t domain ;
   uint8_t area ;
   uint8_t reserved ;
};
#line 2327 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_rft_id_354 {
   uint8_t reserved ;
   uint8_t port_id[3U] ;
   uint8_t fc4_types[32U] ;
};
#line 2327 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_rff_id_355 {
   uint8_t reserved ;
   uint8_t port_id[3U] ;
   uint16_t reserved2 ;
   uint8_t fc4_feature ;
   uint8_t fc4_type ;
};
#line 2327 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_rnn_id_356 {
   uint8_t reserved ;
   uint8_t port_id[3U] ;
   uint8_t node_name[8U] ;
};
#line 2327 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_rsnn_nn_357 {
   uint8_t node_name[8U] ;
   uint8_t name_len ;
   uint8_t sym_node_name[255U] ;
};
#line 2327 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_ghat_358 {
   uint8_t hba_indentifier[8U] ;
};
#line 2327 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_rhba_359 {
   uint8_t hba_identifier[8U] ;
   uint32_t entry_count ;
   uint8_t port_name[8U] ;
   struct ct_fdmi_hba_attributes attrs ;
};
#line 2327 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_rhba2_360 {
   uint8_t hba_identifier[8U] ;
   uint32_t entry_count ;
   uint8_t port_name[8U] ;
   struct ct_fdmiv2_hba_attributes attrs ;
};
#line 2327 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_rhat_361 {
   uint8_t hba_identifier[8U] ;
   struct ct_fdmi_hba_attributes attrs ;
};
#line 2327 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_rpa_362 {
   uint8_t port_name[8U] ;
   struct ct_fdmi_port_attributes attrs ;
};
#line 2327 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_rpa2_363 {
   uint8_t port_name[8U] ;
   struct ct_fdmiv2_port_attributes attrs ;
};
#line 2327 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_dhba_364 {
   uint8_t port_name[8U] ;
};
#line 2327 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_dhat_365 {
   uint8_t port_name[8U] ;
};
#line 2327 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_dprt_366 {
   uint8_t port_name[8U] ;
};
#line 2327 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_dpa_367 {
   uint8_t port_name[8U] ;
};
#line 2327 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_gpsc_368 {
   uint8_t port_name[8U] ;
};
#line 2327 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_gff_id_369 {
   uint8_t reserved ;
   uint8_t port_name[3U] ;
};
#line 2327 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_req_351 {
   struct __anonstruct_port_id_352 port_id ;
   struct __anonstruct_gid_pt_353 gid_pt ;
   struct __anonstruct_rft_id_354 rft_id ;
   struct __anonstruct_rff_id_355 rff_id ;
   struct __anonstruct_rnn_id_356 rnn_id ;
   struct __anonstruct_rsnn_nn_357 rsnn_nn ;
   struct __anonstruct_ghat_358 ghat ;
   struct __anonstruct_rhba_359 rhba ;
   struct __anonstruct_rhba2_360 rhba2 ;
   struct __anonstruct_rhat_361 rhat ;
   struct __anonstruct_rpa_362 rpa ;
   struct __anonstruct_rpa2_363 rpa2 ;
   struct __anonstruct_dhba_364 dhba ;
   struct __anonstruct_dhat_365 dhat ;
   struct __anonstruct_dprt_366 dprt ;
   struct __anonstruct_dpa_367 dpa ;
   struct __anonstruct_gpsc_368 gpsc ;
   struct __anonstruct_gff_id_369 gff_id ;
};
#line 2327 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct ct_sns_req {
   struct ct_cmd_hdr header ;
   uint16_t command ;
   uint16_t max_rsp_size ;
   uint8_t fragment_id ;
   uint8_t reserved[3U] ;
   union __anonunion_req_351 req ;
};
#line 2435 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct ct_rsp_hdr {
   struct ct_cmd_hdr header ;
   uint16_t response ;
   uint16_t residual ;
   uint8_t fragment_id ;
   uint8_t reason_code ;
   uint8_t explanation_code ;
   uint8_t vendor_unique ;
};
#line 2446 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct ct_sns_gid_pt_data {
   uint8_t control_byte ;
   uint8_t port_id[3U] ;
};
#line 2451 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_ga_nxt_371 {
   uint8_t port_type ;
   uint8_t port_id[3U] ;
   uint8_t port_name[8U] ;
   uint8_t sym_port_name_len ;
   uint8_t sym_port_name[255U] ;
   uint8_t node_name[8U] ;
   uint8_t sym_node_name_len ;
   uint8_t sym_node_name[255U] ;
   uint8_t init_proc_assoc[8U] ;
   uint8_t node_ip_addr[16U] ;
   uint8_t class_of_service[4U] ;
   uint8_t fc4_types[32U] ;
   uint8_t ip_address[16U] ;
   uint8_t fabric_port_name[8U] ;
   uint8_t reserved ;
   uint8_t hard_address[3U] ;
};
#line 2451 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_gid_pt_372 {
   struct ct_sns_gid_pt_data entries[2048U] ;
};
#line 2451 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_gpn_id_373 {
   uint8_t port_name[8U] ;
};
#line 2451 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_gnn_id_374 {
   uint8_t node_name[8U] ;
};
#line 2451 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_gft_id_375 {
   uint8_t fc4_types[32U] ;
};
#line 2451 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_ghat_376 {
   uint32_t entry_count ;
   uint8_t port_name[8U] ;
   struct ct_fdmi_hba_attributes attrs ;
};
#line 2451 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_gfpn_id_377 {
   uint8_t port_name[8U] ;
};
#line 2451 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_gpsc_378 {
   uint16_t speeds ;
   uint16_t speed ;
};
#line 2451 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_gff_id_379 {
   uint8_t fc4_features[128U] ;
};
#line 2451 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_rsp_370 {
   struct __anonstruct_ga_nxt_371 ga_nxt ;
   struct __anonstruct_gid_pt_372 gid_pt ;
   struct __anonstruct_gpn_id_373 gpn_id ;
   struct __anonstruct_gnn_id_374 gnn_id ;
   struct __anonstruct_gft_id_375 gft_id ;
   struct __anonstruct_ghat_376 ghat ;
   struct __anonstruct_gfpn_id_377 gfpn_id ;
   struct __anonstruct_gpsc_378 gpsc ;
   struct __anonstruct_gff_id_379 gff_id ;
};
#line 2451 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct ct_sns_rsp {
   struct ct_rsp_hdr header ;
   union __anonunion_rsp_370 rsp ;
};
#line 2514 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_p_380 {
   struct ct_sns_req req ;
   struct ct_sns_rsp rsp ;
};
#line 2514 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct ct_sns_pkt {
   union __anonunion_p_380 p ;
};
#line 2521 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_cmd_382 {
   uint16_t buffer_length ;
   uint16_t reserved_1 ;
   uint32_t buffer_address[2U] ;
   uint16_t subcommand_length ;
   uint16_t reserved_2 ;
   uint16_t subcommand ;
   uint16_t size ;
   uint32_t reserved_3 ;
   uint8_t param[36U] ;
};
#line 2521 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_p_381 {
   struct __anonstruct_cmd_382 cmd ;
   uint8_t rft_data[16U] ;
   uint8_t rnn_data[16U] ;
   uint8_t gan_data[636U] ;
   uint8_t gid_data[2064U] ;
   uint8_t gpn_data[24U] ;
   uint8_t gnn_data[24U] ;
};
#line 2521 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct sns_cmd_pkt {
   union __anonunion_p_381 p ;
};
#line 2575 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct fw_blob {
   char *name ;
   uint32_t segs[4U] ;
   struct firmware  const  *fw ;
};
#line 2581 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct gid_list_info {
   uint8_t al_pa ;
   uint8_t area ;
   uint8_t domain ;
   uint8_t loop_id_2100 ;
   uint16_t loop_id ;
   uint16_t reserved_1 ;
};
#line 2610
struct rsp_que;
#line 2611 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct isp_operations {
   int (*pci_config)(struct scsi_qla_host * ) ;
   void (*reset_chip)(struct scsi_qla_host * ) ;
   int (*chip_diag)(struct scsi_qla_host * ) ;
   void (*config_rings)(struct scsi_qla_host * ) ;
   void (*reset_adapter)(struct scsi_qla_host * ) ;
   int (*nvram_config)(struct scsi_qla_host * ) ;
   void (*update_fw_options)(struct scsi_qla_host * ) ;
   int (*load_risc)(struct scsi_qla_host * , uint32_t * ) ;
   char *(*pci_info_str)(struct scsi_qla_host * , char * ) ;
   char *(*fw_version_str)(struct scsi_qla_host * , char * , size_t  ) ;
   irqreturn_t (*intr_handler)(int  , void * ) ;
   void (*enable_intrs)(struct qla_hw_data * ) ;
   void (*disable_intrs)(struct qla_hw_data * ) ;
   int (*abort_command)(srb_t * ) ;
   int (*target_reset)(struct fc_port * , uint64_t  , int  ) ;
   int (*lun_reset)(struct fc_port * , uint64_t  , int  ) ;
   int (*fabric_login)(struct scsi_qla_host * , uint16_t  , uint8_t  , uint8_t  ,
                       uint8_t  , uint16_t * , uint8_t  ) ;
   int (*fabric_logout)(struct scsi_qla_host * , uint16_t  , uint8_t  , uint8_t  ,
                        uint8_t  ) ;
   uint16_t (*calc_req_entries)(uint16_t  ) ;
   void (*build_iocbs)(srb_t * , cmd_entry_t * , uint16_t  ) ;
   void *(*prep_ms_iocb)(struct scsi_qla_host * , uint32_t  , uint32_t  ) ;
   void *(*prep_ms_fdmi_iocb)(struct scsi_qla_host * , uint32_t  , uint32_t  ) ;
   uint8_t *(*read_nvram)(struct scsi_qla_host * , uint8_t * , uint32_t  , uint32_t  ) ;
   int (*write_nvram)(struct scsi_qla_host * , uint8_t * , uint32_t  , uint32_t  ) ;
   void (*fw_dump)(struct scsi_qla_host * , int  ) ;
   int (*beacon_on)(struct scsi_qla_host * ) ;
   int (*beacon_off)(struct scsi_qla_host * ) ;
   void (*beacon_blink)(struct scsi_qla_host * ) ;
   uint8_t *(*read_optrom)(struct scsi_qla_host * , uint8_t * , uint32_t  , uint32_t  ) ;
   int (*write_optrom)(struct scsi_qla_host * , uint8_t * , uint32_t  , uint32_t  ) ;
   int (*get_flash_version)(struct scsi_qla_host * , void * ) ;
   int (*start_scsi)(srb_t * ) ;
   int (*abort_isp)(struct scsi_qla_host * ) ;
   int (*iospace_config)(struct qla_hw_data * ) ;
   int (*initialize_adapter)(struct scsi_qla_host * ) ;
};
#line 2679 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct qla_msix_entry {
   int have_irq ;
   uint32_t vector ;
   uint16_t entry ;
   struct rsp_que *rsp ;
};
#line 2702
enum qla_work_type {
    QLA_EVT_AEN = 0,
    QLA_EVT_IDC_ACK = 1,
    QLA_EVT_ASYNC_LOGIN = 2,
    QLA_EVT_ASYNC_LOGIN_DONE = 3,
    QLA_EVT_ASYNC_LOGOUT = 4,
    QLA_EVT_ASYNC_LOGOUT_DONE = 5,
    QLA_EVT_ASYNC_ADISC = 6,
    QLA_EVT_ASYNC_ADISC_DONE = 7,
    QLA_EVT_UEVENT = 8,
    QLA_EVT_AENFX = 9
} ;
#line 2715 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_aen_384 {
   enum fc_host_event_code code ;
   u32 data ;
};
#line 2715 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_idc_ack_385 {
   uint16_t mb[7U] ;
};
#line 2715 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_logio_386 {
   struct fc_port *fcport ;
   u16 data[2U] ;
};
#line 2715 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_uevent_387 {
   u32 code ;
};
#line 2715 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_aenfx_388 {
   uint32_t evtcode ;
   uint32_t mbx[8U] ;
   uint32_t count ;
};
#line 2715 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_iosb_389 {
   srb_t *sp ;
};
#line 2715 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_u_383 {
   struct __anonstruct_aen_384 aen ;
   struct __anonstruct_idc_ack_385 idc_ack ;
   struct __anonstruct_logio_386 logio ;
   struct __anonstruct_uevent_387 uevent ;
   struct __anonstruct_aenfx_388 aenfx ;
   struct __anonstruct_iosb_389 iosb ;
};
#line 2715 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct qla_work_evt {
   struct list_head list ;
   enum qla_work_type type ;
   u32 flags ;
   union __anonunion_u_383 u ;
};
#line 2754 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct qla_chip_state_84xx {
   struct list_head list ;
   struct kref kref ;
   void *bus ;
   spinlock_t access_lock ;
   struct mutex fw_update_mutex ;
   uint32_t fw_update ;
   uint32_t op_fw_version ;
   uint32_t op_fw_size ;
   uint32_t op_fw_seq_size ;
   uint32_t diag_fw_version ;
   uint32_t gold_fw_version ;
};
#line 2769 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct qla_statistics {
   uint32_t total_isp_aborts ;
   uint64_t input_bytes ;
   uint64_t output_bytes ;
   uint64_t input_requests ;
   uint64_t output_requests ;
   uint32_t control_requests ;
   uint64_t jiffies_at_last_reset ;
   uint32_t stat_max_pend_cmds ;
   uint32_t stat_max_qfull_cmds_alloc ;
   uint32_t stat_max_qfull_cmds_dropped ;
};
#line 2783 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct bidi_statistics {
   unsigned long long io_count ;
   unsigned long long transfer_bytes ;
};
#line 2788 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct rsp_que {
   dma_addr_t dma ;
   response_t *ring ;
   response_t *ring_ptr ;
   uint32_t *rsp_q_in ;
   uint32_t *rsp_q_out ;
   uint16_t ring_index ;
   uint16_t out_ptr ;
   uint16_t *in_ptr ;
   uint16_t length ;
   uint16_t options ;
   uint16_t rid ;
   uint16_t id ;
   uint16_t vp_idx ;
   struct qla_hw_data *hw ;
   struct qla_msix_entry *msix ;
   struct req_que *req ;
   srb_t *status_srb ;
   struct work_struct q_work ;
   dma_addr_t dma_fx00 ;
   response_t *ring_fx00 ;
   uint16_t length_fx00 ;
   uint8_t rsp_pkt[64U] ;
};
#line 2830 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct req_que {
   dma_addr_t dma ;
   request_t *ring ;
   request_t *ring_ptr ;
   uint32_t *req_q_in ;
   uint32_t *req_q_out ;
   uint16_t ring_index ;
   uint16_t in_ptr ;
   uint16_t *out_ptr ;
   uint16_t cnt ;
   uint16_t length ;
   uint16_t options ;
   uint16_t rid ;
   uint16_t id ;
   uint16_t qos ;
   uint16_t vp_idx ;
   struct rsp_que *rsp ;
   srb_t **outstanding_cmds ;
   uint32_t current_outstanding_cmd ;
   uint16_t num_outstanding_cmds ;
   int max_q_depth ;
   dma_addr_t dma_fx00 ;
   request_t *ring_fx00 ;
   uint16_t length_fx00 ;
   uint8_t req_pkt[64U] ;
};
#line 2859 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct qlfc_fw {
   void *fw_buf ;
   dma_addr_t fw_dma ;
   uint32_t len ;
};
#line 2866
struct qla_tgt;
#line 2866 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct scsi_qlt_host {
   void *target_lport_ptr ;
   struct mutex tgt_mutex ;
   struct mutex tgt_host_action_mutex ;
   struct qla_tgt *qla_tgt ;
};
#line 2873
struct qla_tgt_func_tmpl;
#line 2873
struct qla_tgt_cmd;
#line 2873
struct qla_tgt_vp_map;
#line 2873 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct qlt_hw_data {
   unsigned char enable_class_2 : 1 ;
   unsigned char enable_explicit_conf : 1 ;
   unsigned char ini_mode_force_reverse : 1 ;
   unsigned char node_name_set : 1 ;
   dma_addr_t atio_dma ;
   struct atio *atio_ring ;
   struct atio *atio_ring_ptr ;
   uint16_t atio_ring_index ;
   uint16_t atio_q_length ;
   uint32_t *atio_q_in ;
   uint32_t *atio_q_out ;
   struct qla_tgt_func_tmpl *tgt_ops ;
   struct qla_tgt_cmd *cmds[1024U] ;
   uint16_t current_handle ;
   struct qla_tgt_vp_map *tgt_vp_map ;
   int saved_set ;
   uint16_t saved_exchange_count ;
   uint32_t saved_firmware_options_1 ;
   uint32_t saved_firmware_options_2 ;
   uint32_t saved_firmware_options_3 ;
   uint8_t saved_firmware_options[2U] ;
   uint8_t saved_add_firmware_options[2U] ;
   uint8_t tgt_node_name[8U] ;
   struct list_head q_full_list ;
   uint32_t num_pend_cmds ;
   uint32_t num_qfull_cmds_alloc ;
   uint32_t num_qfull_cmds_dropped ;
   spinlock_t q_full_lock ;
   uint32_t leak_exchg_thresh_hold ;
};
#line 2912 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_flags_390 {
   unsigned char mbox_int : 1 ;
   unsigned char mbox_busy : 1 ;
   unsigned char disable_risc_code_load : 1 ;
   unsigned char enable_64bit_addressing : 1 ;
   unsigned char enable_lip_reset : 1 ;
   unsigned char enable_target_reset : 1 ;
   unsigned char enable_lip_full_login : 1 ;
   unsigned char enable_led_scheme : 1 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char disable_serdes : 1 ;
   unsigned char gpsc_supported : 1 ;
   unsigned char npiv_supported : 1 ;
   unsigned char pci_channel_io_perm_failure : 1 ;
   unsigned char fce_enabled : 1 ;
   unsigned char fac_supported : 1 ;
   unsigned char chip_reset_done : 1 ;
   unsigned char running_gold_fw : 1 ;
   unsigned char eeh_busy : 1 ;
   unsigned char cpu_affinity_enabled : 1 ;
   unsigned char disable_msix_handshake : 1 ;
   unsigned char fcp_prio_enabled : 1 ;
   unsigned char isp82xx_fw_hung : 1 ;
   unsigned char nic_core_hung : 1 ;
   unsigned char quiesce_owner : 1 ;
   unsigned char nic_core_reset_hdlr_active : 1 ;
   unsigned char nic_core_reset_owner : 1 ;
   unsigned char isp82xx_no_md_cap : 1 ;
   unsigned char host_shutting_down : 1 ;
   unsigned char idc_compl_status : 1 ;
   unsigned char mr_reset_hdlr_active : 1 ;
   unsigned char mr_intr_valid : 1 ;
   unsigned char fawwpn_enabled : 1 ;
};
#line 2912
struct qla2xxx_fw_dump;
#line 2912 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct qla_hw_data {
   struct pci_dev *pdev ;
   mempool_t *srb_mempool ;
   struct __anonstruct_flags_390  volatile  flags ;
   spinlock_t hardware_lock ;
   int bars ;
   int mem_only ;
   device_reg_t *iobase ;
   resource_size_t pio_address ;
   dma_addr_t bar0_hdl ;
   void *cregbase ;
   dma_addr_t bar2_hdl ;
   uint32_t rqstq_intr_code ;
   uint32_t mbx_intr_code ;
   uint32_t req_que_len ;
   uint32_t rsp_que_len ;
   uint32_t req_que_off ;
   uint32_t rsp_que_off ;
   device_reg_t *mqiobase ;
   device_reg_t *msixbase ;
   uint16_t msix_count ;
   uint8_t mqenable ;
   struct req_que **req_q_map ;
   struct rsp_que **rsp_q_map ;
   unsigned long req_qid_map[4U] ;
   unsigned long rsp_qid_map[4U] ;
   uint8_t max_req_queues ;
   uint8_t max_rsp_queues ;
   struct qla_npiv_entry *npiv_info ;
   uint16_t nvram_npiv_size ;
   uint16_t switch_cap ;
   uint8_t port_no ;
   uint8_t loop_down_abort_time ;
   atomic_t loop_down_timer ;
   uint8_t link_down_timeout ;
   uint16_t max_loop_id ;
   uint16_t max_fibre_devices ;
   uint16_t fb_rev ;
   uint16_t min_external_loopid ;
   uint16_t link_data_rate ;
   uint8_t current_topology ;
   uint8_t prev_topology ;
   uint8_t operating_mode ;
   uint8_t interrupts_on ;
   uint32_t isp_abort_cnt ;
   uint32_t device_type ;
   uint8_t serial0 ;
   uint8_t serial1 ;
   uint8_t serial2 ;
   uint16_t nvram_size ;
   uint16_t nvram_base ;
   void *nvram ;
   uint16_t vpd_size ;
   uint16_t vpd_base ;
   void *vpd ;
   uint16_t loop_reset_delay ;
   uint8_t retry_count ;
   uint8_t login_timeout ;
   uint16_t r_a_tov ;
   int port_down_retry_count ;
   uint8_t mbx_count ;
   uint8_t aen_mbx_count ;
   uint32_t login_retry_count ;
   ms_iocb_entry_t *ms_iocb ;
   dma_addr_t ms_iocb_dma ;
   struct ct_sns_pkt *ct_sns ;
   dma_addr_t ct_sns_dma ;
   struct sns_cmd_pkt *sns_cmd ;
   dma_addr_t sns_cmd_dma ;
   void *sfp_data ;
   dma_addr_t sfp_data_dma ;
   void *xgmac_data ;
   dma_addr_t xgmac_data_dma ;
   void *dcbx_tlv ;
   dma_addr_t dcbx_tlv_dma ;
   struct task_struct *dpc_thread ;
   uint8_t dpc_active ;
   dma_addr_t gid_list_dma ;
   struct gid_list_info *gid_list ;
   int gid_list_info_size ;
   struct dma_pool *s_dma_pool ;
   dma_addr_t init_cb_dma ;
   init_cb_t *init_cb ;
   int init_cb_size ;
   dma_addr_t ex_init_cb_dma ;
   struct ex_init_cb_81xx *ex_init_cb ;
   void *async_pd ;
   dma_addr_t async_pd_dma ;
   void *swl ;
   uint16_t mailbox_out[32U] ;
   uint32_t mailbox_out32[32U] ;
   uint32_t aenmb[8U] ;
   mbx_cmd_t *mcp ;
   struct mbx_cmd_32 *mcp32 ;
   unsigned long mbx_cmd_flags ;
   struct mutex vport_lock ;
   spinlock_t vport_slock ;
   struct completion mbx_cmd_comp ;
   struct completion mbx_intr_comp ;
   struct completion dcbx_comp ;
   struct completion lb_portup_comp ;
   int notify_dcbx_comp ;
   int notify_lb_portup_comp ;
   struct mutex selflogin_lock ;
   uint16_t fw_major_version ;
   uint16_t fw_minor_version ;
   uint16_t fw_subminor_version ;
   uint16_t fw_attributes ;
   uint16_t fw_attributes_h ;
   uint16_t fw_attributes_ext[2U] ;
   uint32_t fw_memory_size ;
   uint32_t fw_transfer_size ;
   uint32_t fw_srisc_address ;
   uint16_t fw_xcb_count ;
   uint16_t fw_iocb_count ;
   uint32_t fw_shared_ram_start ;
   uint32_t fw_shared_ram_end ;
   uint16_t fw_options[16U] ;
   uint8_t fw_seriallink_options[4U] ;
   uint16_t fw_seriallink_options24[4U] ;
   uint8_t mpi_version[3U] ;
   uint32_t mpi_capabilities ;
   uint8_t phy_version[3U] ;
   void *fw_dump_template ;
   uint32_t fw_dump_template_len ;
   struct qla2xxx_fw_dump *fw_dump ;
   uint32_t fw_dump_len ;
   int fw_dumped ;
   unsigned long fw_dump_cap_flags ;
   int fw_dump_reading ;
   int prev_minidump_failed ;
   dma_addr_t eft_dma ;
   void *eft ;
   dma_addr_t mctp_dump_dma ;
   void *mctp_dump ;
   int mctp_dumped ;
   int mctp_dump_reading ;
   uint32_t chain_offset ;
   struct dentry *dfs_dir ;
   struct dentry *dfs_fce ;
   dma_addr_t fce_dma ;
   void *fce ;
   uint32_t fce_bufs ;
   uint16_t fce_mb[8U] ;
   uint64_t fce_wr ;
   uint64_t fce_rd ;
   struct mutex fce_mutex ;
   uint32_t pci_attr ;
   uint16_t chip_revision ;
   uint16_t product_id[4U] ;
   uint8_t model_number[17U] ;
   char model_desc[80U] ;
   uint8_t adapter_id[17U] ;
   char *optrom_buffer ;
   uint32_t optrom_size ;
   int optrom_state ;
   uint32_t optrom_region_start ;
   uint32_t optrom_region_size ;
   struct mutex optrom_mutex ;
   uint8_t bios_revision[2U] ;
   uint8_t efi_revision[2U] ;
   uint8_t fcode_revision[16U] ;
   uint32_t fw_revision[4U] ;
   uint32_t gold_fw_version[4U] ;
   uint32_t flash_conf_off ;
   uint32_t flash_data_off ;
   uint32_t nvram_conf_off ;
   uint32_t nvram_data_off ;
   uint32_t fdt_wrt_disable ;
   uint32_t fdt_wrt_enable ;
   uint32_t fdt_erase_cmd ;
   uint32_t fdt_block_size ;
   uint32_t fdt_unprotect_sec_cmd ;
   uint32_t fdt_protect_sec_cmd ;
   uint32_t fdt_wrt_sts_reg_cmd ;
   uint32_t flt_region_flt ;
   uint32_t flt_region_fdt ;
   uint32_t flt_region_boot ;
   uint32_t flt_region_fw ;
   uint32_t flt_region_vpd_nvram ;
   uint32_t flt_region_vpd ;
   uint32_t flt_region_nvram ;
   uint32_t flt_region_npiv_conf ;
   uint32_t flt_region_gold_fw ;
   uint32_t flt_region_fcp_prio ;
   uint32_t flt_region_bootload ;
   uint16_t beacon_blink_led ;
   uint8_t beacon_color_state ;
   uint16_t zio_mode ;
   uint16_t zio_timer ;
   struct qla_msix_entry *msix_entries ;
   struct list_head vp_list ;
   unsigned long vp_idx_map[4U] ;
   uint16_t num_vhosts ;
   uint16_t num_vsans ;
   uint16_t max_npiv_vports ;
   int cur_vport_count ;
   struct qla_chip_state_84xx *cs84xx ;
   struct qla_statistics qla_stats ;
   struct isp_operations *isp_ops ;
   struct workqueue_struct *wq ;
   struct qlfc_fw fw_buf ;
   struct qla_fcp_prio_cfg *fcp_prio_cfg ;
   struct dma_pool *dl_dma_pool ;
   struct dma_pool *fcp_cmnd_dma_pool ;
   mempool_t *ctx_mempool ;
   unsigned long nx_pcibase ;
   uint8_t *nxdb_rd_ptr ;
   unsigned long nxdb_wr_ptr ;
   uint32_t crb_win ;
   uint32_t curr_window ;
   uint32_t ddr_mn_window ;
   unsigned long mn_win_crb ;
   unsigned long ms_win_crb ;
   int qdr_sn_window ;
   uint32_t fcoe_dev_init_timeout ;
   uint32_t fcoe_reset_timeout ;
   rwlock_t hw_lock ;
   uint16_t portnum ;
   int link_width ;
   struct fw_blob *hablob ;
   struct qla82xx_legacy_intr_set nx_legacy_intr ;
   uint16_t gbl_dsd_inuse ;
   uint16_t gbl_dsd_avail ;
   struct list_head gbl_dsd_list ;
   uint8_t fw_type ;
   __le32 file_prd_off ;
   uint32_t md_template_size ;
   void *md_tmplt_hdr ;
   dma_addr_t md_tmplt_hdr_dma ;
   void *md_dump ;
   uint32_t md_dump_size ;
   void *loop_id_map ;
   uint32_t idc_audit_ts ;
   uint32_t idc_extend_tmo ;
   struct workqueue_struct *dpc_lp_wq ;
   struct work_struct idc_aen ;
   struct workqueue_struct *dpc_hp_wq ;
   struct work_struct nic_core_reset ;
   struct work_struct idc_state_handler ;
   struct work_struct nic_core_unrecoverable ;
   struct work_struct board_disable ;
   struct mr_data_fx00 mr ;
   uint32_t chip_reset ;
   struct qlt_hw_data tgt ;
   int allow_cna_fw_dump ;
};
#line 3475 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_flags_391 {
   unsigned char init_done : 1 ;
   unsigned char online : 1 ;
   unsigned char reset_active : 1 ;
   unsigned char management_server_logged_in : 1 ;
   unsigned char process_response_queue : 1 ;
   unsigned char difdix_supported : 1 ;
   unsigned char delete_progress : 1 ;
   unsigned char fw_tgt_reported : 1 ;
};
#line 3475 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct scsi_qla_host {
   struct list_head list ;
   struct list_head vp_fcports ;
   struct list_head work_list ;
   spinlock_t work_lock ;
   struct Scsi_Host *host ;
   unsigned long host_no ;
   uint8_t host_str[16U] ;
   struct __anonstruct_flags_391  volatile  flags ;
   atomic_t loop_state ;
   unsigned long dpc_flags ;
   unsigned long pci_flags ;
   uint32_t device_flags ;
   uint16_t loop_id ;
   uint16_t self_login_loop_id ;
   fc_port_t bidir_fcport ;
   port_id_t d_id ;
   uint8_t marker_needed ;
   uint16_t mgmt_svr_loop_id ;
   uint8_t loop_down_abort_time ;
   atomic_t loop_down_timer ;
   uint8_t link_down_timeout ;
   uint32_t timer_active ;
   struct timer_list timer ;
   uint8_t node_name[8U] ;
   uint8_t port_name[8U] ;
   uint8_t fabric_node_name[8U] ;
   uint16_t fcoe_vlan_id ;
   uint16_t fcoe_fcf_idx ;
   uint8_t fcoe_vn_port_mac[6U] ;
   uint32_t vp_abort_cnt ;
   struct fc_vport *fc_vport ;
   uint16_t vp_idx ;
   unsigned long vp_flags ;
   atomic_t vp_state ;
   uint16_t vp_err_state ;
   uint16_t vp_prev_err_state ;
   struct qla_hw_data *hw ;
   struct scsi_qlt_host vha_tgt ;
   struct req_que *req ;
   int fw_heartbeat_counter ;
   int seconds_since_last_heartbeat ;
   struct fc_host_statistics fc_host_stat ;
   struct qla_statistics qla_stats ;
   struct bidi_statistics bidi_stats ;
   atomic_t vref_count ;
   struct qla8044_reset_template reset_tmplt ;
};
#line 3618 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct scsi_qla_host scsi_qla_host_t;
#line 3619 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct qla_tgt_vp_map {
   uint8_t idx ;
   scsi_qla_host_t *vha ;
};
#line 3628
enum nexus_wait_type {
    WAIT_HOST = 0,
    WAIT_TARGET = 1,
    WAIT_LUN = 2
} ;
#line 769 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
struct qla2300_fw_dump {
   uint16_t hccr ;
   uint16_t pbiu_reg[8U] ;
   uint16_t risc_host_reg[8U] ;
   uint16_t mailbox_reg[32U] ;
   uint16_t resp_dma_reg[32U] ;
   uint16_t dma_reg[48U] ;
   uint16_t risc_hdw_reg[16U] ;
   uint16_t risc_gp0_reg[16U] ;
   uint16_t risc_gp1_reg[16U] ;
   uint16_t risc_gp2_reg[16U] ;
   uint16_t risc_gp3_reg[16U] ;
   uint16_t risc_gp4_reg[16U] ;
   uint16_t risc_gp5_reg[16U] ;
   uint16_t risc_gp6_reg[16U] ;
   uint16_t risc_gp7_reg[16U] ;
   uint16_t frame_buf_hdw_reg[64U] ;
   uint16_t fpm_b0_reg[64U] ;
   uint16_t fpm_b1_reg[64U] ;
   uint16_t risc_ram[63488U] ;
   uint16_t stack_ram[4096U] ;
   uint16_t data_ram[1U] ;
};
#line 37 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
struct qla2100_fw_dump {
   uint16_t hccr ;
   uint16_t pbiu_reg[8U] ;
   uint16_t mailbox_reg[32U] ;
   uint16_t dma_reg[48U] ;
   uint16_t risc_hdw_reg[16U] ;
   uint16_t risc_gp0_reg[16U] ;
   uint16_t risc_gp1_reg[16U] ;
   uint16_t risc_gp2_reg[16U] ;
   uint16_t risc_gp3_reg[16U] ;
   uint16_t risc_gp4_reg[16U] ;
   uint16_t risc_gp5_reg[16U] ;
   uint16_t risc_gp6_reg[16U] ;
   uint16_t risc_gp7_reg[16U] ;
   uint16_t frame_buf_hdw_reg[16U] ;
   uint16_t fpm_b0_reg[64U] ;
   uint16_t fpm_b1_reg[64U] ;
   uint16_t risc_ram[61440U] ;
};
#line 57 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
struct qla24xx_fw_dump {
   uint32_t host_status ;
   uint32_t host_reg[32U] ;
   uint32_t shadow_reg[7U] ;
   uint16_t mailbox_reg[32U] ;
   uint32_t xseq_gp_reg[128U] ;
   uint32_t xseq_0_reg[16U] ;
   uint32_t xseq_1_reg[16U] ;
   uint32_t rseq_gp_reg[128U] ;
   uint32_t rseq_0_reg[16U] ;
   uint32_t rseq_1_reg[16U] ;
   uint32_t rseq_2_reg[16U] ;
   uint32_t cmd_dma_reg[16U] ;
   uint32_t req0_dma_reg[15U] ;
   uint32_t resp0_dma_reg[15U] ;
   uint32_t req1_dma_reg[15U] ;
   uint32_t xmt0_dma_reg[32U] ;
   uint32_t xmt1_dma_reg[32U] ;
   uint32_t xmt2_dma_reg[32U] ;
   uint32_t xmt3_dma_reg[32U] ;
   uint32_t xmt4_dma_reg[32U] ;
   uint32_t xmt_data_dma_reg[16U] ;
   uint32_t rcvt0_data_dma_reg[32U] ;
   uint32_t rcvt1_data_dma_reg[32U] ;
   uint32_t risc_gp_reg[128U] ;
   uint32_t lmc_reg[112U] ;
   uint32_t fpm_hdw_reg[192U] ;
   uint32_t fb_hdw_reg[176U] ;
   uint32_t code_ram[8192U] ;
   uint32_t ext_mem[1U] ;
};
#line 89 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
struct qla25xx_fw_dump {
   uint32_t host_status ;
   uint32_t host_risc_reg[32U] ;
   uint32_t pcie_regs[4U] ;
   uint32_t host_reg[32U] ;
   uint32_t shadow_reg[11U] ;
   uint32_t risc_io_reg ;
   uint16_t mailbox_reg[32U] ;
   uint32_t xseq_gp_reg[128U] ;
   uint32_t xseq_0_reg[48U] ;
   uint32_t xseq_1_reg[16U] ;
   uint32_t rseq_gp_reg[128U] ;
   uint32_t rseq_0_reg[32U] ;
   uint32_t rseq_1_reg[16U] ;
   uint32_t rseq_2_reg[16U] ;
   uint32_t aseq_gp_reg[128U] ;
   uint32_t aseq_0_reg[32U] ;
   uint32_t aseq_1_reg[16U] ;
   uint32_t aseq_2_reg[16U] ;
   uint32_t cmd_dma_reg[16U] ;
   uint32_t req0_dma_reg[15U] ;
   uint32_t resp0_dma_reg[15U] ;
   uint32_t req1_dma_reg[15U] ;
   uint32_t xmt0_dma_reg[32U] ;
   uint32_t xmt1_dma_reg[32U] ;
   uint32_t xmt2_dma_reg[32U] ;
   uint32_t xmt3_dma_reg[32U] ;
   uint32_t xmt4_dma_reg[32U] ;
   uint32_t xmt_data_dma_reg[16U] ;
   uint32_t rcvt0_data_dma_reg[32U] ;
   uint32_t rcvt1_data_dma_reg[32U] ;
   uint32_t risc_gp_reg[128U] ;
   uint32_t lmc_reg[128U] ;
   uint32_t fpm_hdw_reg[192U] ;
   uint32_t fb_hdw_reg[192U] ;
   uint32_t code_ram[8192U] ;
   uint32_t ext_mem[1U] ;
};
#line 128 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
struct qla81xx_fw_dump {
   uint32_t host_status ;
   uint32_t host_risc_reg[32U] ;
   uint32_t pcie_regs[4U] ;
   uint32_t host_reg[32U] ;
   uint32_t shadow_reg[11U] ;
   uint32_t risc_io_reg ;
   uint16_t mailbox_reg[32U] ;
   uint32_t xseq_gp_reg[128U] ;
   uint32_t xseq_0_reg[48U] ;
   uint32_t xseq_1_reg[16U] ;
   uint32_t rseq_gp_reg[128U] ;
   uint32_t rseq_0_reg[32U] ;
   uint32_t rseq_1_reg[16U] ;
   uint32_t rseq_2_reg[16U] ;
   uint32_t aseq_gp_reg[128U] ;
   uint32_t aseq_0_reg[32U] ;
   uint32_t aseq_1_reg[16U] ;
   uint32_t aseq_2_reg[16U] ;
   uint32_t cmd_dma_reg[16U] ;
   uint32_t req0_dma_reg[15U] ;
   uint32_t resp0_dma_reg[15U] ;
   uint32_t req1_dma_reg[15U] ;
   uint32_t xmt0_dma_reg[32U] ;
   uint32_t xmt1_dma_reg[32U] ;
   uint32_t xmt2_dma_reg[32U] ;
   uint32_t xmt3_dma_reg[32U] ;
   uint32_t xmt4_dma_reg[32U] ;
   uint32_t xmt_data_dma_reg[16U] ;
   uint32_t rcvt0_data_dma_reg[32U] ;
   uint32_t rcvt1_data_dma_reg[32U] ;
   uint32_t risc_gp_reg[128U] ;
   uint32_t lmc_reg[128U] ;
   uint32_t fpm_hdw_reg[224U] ;
   uint32_t fb_hdw_reg[208U] ;
   uint32_t code_ram[8192U] ;
   uint32_t ext_mem[1U] ;
};
#line 167 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
struct qla83xx_fw_dump {
   uint32_t host_status ;
   uint32_t host_risc_reg[48U] ;
   uint32_t pcie_regs[4U] ;
   uint32_t host_reg[32U] ;
   uint32_t shadow_reg[11U] ;
   uint32_t risc_io_reg ;
   uint16_t mailbox_reg[32U] ;
   uint32_t xseq_gp_reg[256U] ;
   uint32_t xseq_0_reg[48U] ;
   uint32_t xseq_1_reg[16U] ;
   uint32_t xseq_2_reg[16U] ;
   uint32_t rseq_gp_reg[256U] ;
   uint32_t rseq_0_reg[32U] ;
   uint32_t rseq_1_reg[16U] ;
   uint32_t rseq_2_reg[16U] ;
   uint32_t rseq_3_reg[16U] ;
   uint32_t aseq_gp_reg[256U] ;
   uint32_t aseq_0_reg[32U] ;
   uint32_t aseq_1_reg[16U] ;
   uint32_t aseq_2_reg[16U] ;
   uint32_t aseq_3_reg[16U] ;
   uint32_t cmd_dma_reg[64U] ;
   uint32_t req0_dma_reg[15U] ;
   uint32_t resp0_dma_reg[15U] ;
   uint32_t req1_dma_reg[15U] ;
   uint32_t xmt0_dma_reg[32U] ;
   uint32_t xmt1_dma_reg[32U] ;
   uint32_t xmt2_dma_reg[32U] ;
   uint32_t xmt3_dma_reg[32U] ;
   uint32_t xmt4_dma_reg[32U] ;
   uint32_t xmt_data_dma_reg[16U] ;
   uint32_t rcvt0_data_dma_reg[32U] ;
   uint32_t rcvt1_data_dma_reg[32U] ;
   uint32_t risc_gp_reg[128U] ;
   uint32_t lmc_reg[128U] ;
   uint32_t fpm_hdw_reg[256U] ;
   uint32_t rq0_array_reg[256U] ;
   uint32_t rq1_array_reg[256U] ;
   uint32_t rp0_array_reg[256U] ;
   uint32_t rp1_array_reg[256U] ;
   uint32_t queue_control_reg[16U] ;
   uint32_t fb_hdw_reg[432U] ;
   uint32_t at0_array_reg[128U] ;
   uint32_t code_ram[9216U] ;
   uint32_t ext_mem[1U] ;
};
#line 256 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
union __anonunion_isp_392 {
   struct qla2100_fw_dump isp21 ;
   struct qla2300_fw_dump isp23 ;
   struct qla24xx_fw_dump isp24 ;
   struct qla25xx_fw_dump isp25 ;
   struct qla81xx_fw_dump isp81 ;
   struct qla83xx_fw_dump isp83 ;
};
#line 256 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
struct qla2xxx_fw_dump {
   uint8_t signature[4U] ;
   uint32_t version ;
   uint32_t fw_major_version ;
   uint32_t fw_minor_version ;
   uint32_t fw_subminor_version ;
   uint32_t fw_attributes ;
   uint32_t vendor ;
   uint32_t device ;
   uint32_t subsystem_vendor ;
   uint32_t subsystem_device ;
   uint32_t fixed_size ;
   uint32_t mem_size ;
   uint32_t req_q_size ;
   uint32_t rsp_q_size ;
   uint32_t eft_size ;
   uint32_t eft_addr_l ;
   uint32_t eft_addr_h ;
   uint32_t header_size ;
   union __anonunion_isp_392 isp ;
};
#line 359 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
struct __anonstruct_isp2x_394 {
   uint32_t sys_define_2 ;
   target_id_t target ;
   uint16_t lun ;
   uint8_t target_id ;
   uint8_t reserved_1 ;
   uint16_t status_modifier ;
   uint16_t status ;
   uint16_t task_flags ;
   uint16_t seq_id ;
   uint16_t srr_rx_id ;
   uint32_t srr_rel_offs ;
   uint16_t srr_ui ;
   uint16_t srr_ox_id ;
   uint8_t reserved_2[28U] ;
};
#line 359 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
struct __anonstruct_isp24_395 {
   uint32_t reserved ;
   uint16_t nport_handle ;
   uint16_t reserved_2 ;
   uint16_t flags ;
   uint16_t srr_rx_id ;
   uint16_t status ;
   uint8_t status_subcode ;
   uint8_t fw_handle ;
   uint32_t exchange_address ;
   uint32_t srr_rel_offs ;
   uint16_t srr_ui ;
   uint16_t srr_ox_id ;
   uint8_t reserved_4[19U] ;
   uint8_t vp_index ;
   uint32_t reserved_5 ;
   uint8_t port_id[3U] ;
   uint8_t reserved_6 ;
};
#line 359 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
union __anonunion_u_393 {
   struct __anonstruct_isp2x_394 isp2x ;
   struct __anonstruct_isp24_395 isp24 ;
};
#line 359 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
struct imm_ntfy_from_isp {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   union __anonunion_u_393 u ;
   uint16_t reserved_7 ;
   uint16_t ox_id ;
};
#line 282 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct fcp_hdr {
   uint8_t r_ctl ;
   uint8_t d_id[3U] ;
   uint8_t cs_ctl ;
   uint8_t s_id[3U] ;
   uint8_t type ;
   uint8_t f_ctl[3U] ;
   uint8_t seq_id ;
   uint8_t df_ctl ;
   uint16_t seq_cnt ;
   __be16 ox_id ;
   uint16_t rx_id ;
   uint32_t parameter ;
};
#line 323 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct fcp_hdr_le {
   uint8_t d_id[3U] ;
   uint8_t r_ctl ;
   uint8_t s_id[3U] ;
   uint8_t cs_ctl ;
   uint8_t f_ctl[3U] ;
   uint8_t type ;
   uint16_t seq_cnt ;
   uint8_t df_ctl ;
   uint8_t seq_id ;
   uint16_t rx_id ;
   uint16_t ox_id ;
   uint32_t parameter ;
};
#line 338 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct atio7_fcp_cmnd {
   uint64_t lun ;
   uint8_t cmnd_ref ;
   unsigned char task_attr : 3 ;
   unsigned char reserved : 5 ;
   uint8_t task_mgmt_flags ;
   unsigned char wrdata : 1 ;
   unsigned char rddata : 1 ;
   unsigned char add_cdb_len : 6 ;
   uint8_t cdb[16U] ;
   uint8_t add_cdb[4U] ;
};
#line 371 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct __anonstruct_isp2x_400 {
   uint16_t entry_hdr ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t sys_define_2 ;
   target_id_t target ;
   uint16_t rx_id ;
   uint16_t flags ;
   uint16_t status ;
   uint8_t command_ref ;
   uint8_t task_codes ;
   uint8_t task_flags ;
   uint8_t execution_codes ;
   uint8_t cdb[16U] ;
   uint32_t data_length ;
   uint16_t lun ;
   uint8_t initiator_port_name[8U] ;
   uint16_t reserved_32[6U] ;
   uint16_t ox_id ;
};
#line 371 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct __anonstruct_isp24_401 {
   uint16_t entry_hdr ;
   uint8_t fcp_cmnd_len_low ;
   unsigned char fcp_cmnd_len_high : 4 ;
   unsigned char attr : 4 ;
   uint32_t exchange_addr ;
   struct fcp_hdr fcp_hdr ;
   struct atio7_fcp_cmnd fcp_cmnd ;
};
#line 371 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct __anonstruct_raw_402 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t data[58U] ;
   uint32_t signature ;
};
#line 371 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
union __anonunion_u_399 {
   struct __anonstruct_isp2x_400 isp2x ;
   struct __anonstruct_isp24_401 isp24 ;
   struct __anonstruct_raw_402 raw ;
};
#line 371 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct atio_from_isp {
   union __anonunion_u_399 u ;
};
#line 579 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct abts_recv_from_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint8_t reserved_1[6U] ;
   uint16_t nport_handle ;
   uint8_t reserved_2[2U] ;
   uint8_t vp_index ;
   unsigned char reserved_3 : 4 ;
   unsigned char sof_type : 4 ;
   uint32_t exchange_address ;
   struct fcp_hdr_le fcp_hdr_le ;
   uint8_t reserved_4[16U] ;
   uint32_t exchange_addr_to_abort ;
};
#line 690
struct qla_tgt_mgmt_cmd;
#line 691
struct qla_tgt_sess;
#line 692 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct qla_tgt_func_tmpl {
   int (*handle_cmd)(struct scsi_qla_host * , struct qla_tgt_cmd * , unsigned char * ,
                     uint32_t  , int  , int  , int  ) ;
   void (*handle_data)(struct qla_tgt_cmd * ) ;
   void (*handle_dif_err)(struct qla_tgt_cmd * ) ;
   int (*handle_tmr)(struct qla_tgt_mgmt_cmd * , uint32_t  , uint8_t  , uint32_t  ) ;
   void (*free_cmd)(struct qla_tgt_cmd * ) ;
   void (*free_mcmd)(struct qla_tgt_mgmt_cmd * ) ;
   void (*free_session)(struct qla_tgt_sess * ) ;
   int (*check_initiator_node_acl)(struct scsi_qla_host * , unsigned char * , void * ,
                                   uint8_t * , uint16_t  ) ;
   void (*update_sess)(struct qla_tgt_sess * , port_id_t  , uint16_t  , bool  ) ;
   struct qla_tgt_sess *(*find_sess_by_loop_id)(struct scsi_qla_host * , uint16_t const    ) ;
   struct qla_tgt_sess *(*find_sess_by_s_id)(struct scsi_qla_host * , uint8_t const   * ) ;
   void (*clear_nacl_from_fcport_map)(struct qla_tgt_sess * ) ;
   void (*put_sess)(struct qla_tgt_sess * ) ;
   void (*shutdown_sess)(struct qla_tgt_sess * ) ;
};
#line 104 "include/linux/in.h"
struct configfs_item_operations;
#line 105
struct configfs_group_operations;
#line 106
struct configfs_attribute;
#line 107
struct configfs_subsystem;
#line 108
struct config_group;
#line 108
struct config_item_type;
#line 108 "include/linux/in.h"
struct config_item {
   char *ci_name ;
   char ci_namebuf[20U] ;
   struct kref ci_kref ;
   struct list_head ci_entry ;
   struct config_item *ci_parent ;
   struct config_group *ci_group ;
   struct config_item_type *ci_type ;
   struct dentry *ci_dentry ;
};
#line 80 "include/linux/configfs.h"
struct config_item_type {
   struct module *ct_owner ;
   struct configfs_item_operations *ct_item_ops ;
   struct configfs_group_operations *ct_group_ops ;
   struct configfs_attribute **ct_attrs ;
};
#line 87 "include/linux/configfs.h"
struct config_group {
   struct config_item cg_item ;
   struct list_head cg_children ;
   struct configfs_subsystem *cg_subsys ;
   struct config_group **default_groups ;
};
#line 120 "include/linux/configfs.h"
struct configfs_attribute {
   char const   *ca_name ;
   struct module *ca_owner ;
   umode_t ca_mode ;
};
#line 128 "include/linux/configfs.h"
struct configfs_item_operations {
   void (*release)(struct config_item * ) ;
   ssize_t (*show_attribute)(struct config_item * , struct configfs_attribute * ,
                             char * ) ;
   ssize_t (*store_attribute)(struct config_item * , struct configfs_attribute * ,
                              char const   * , size_t  ) ;
   int (*allow_link)(struct config_item * , struct config_item * ) ;
   int (*drop_link)(struct config_item * , struct config_item * ) ;
};
#line 230 "include/linux/configfs.h"
struct configfs_group_operations {
   struct config_item *(*make_item)(struct config_group * , char const   * ) ;
   struct config_group *(*make_group)(struct config_group * , char const   * ) ;
   int (*commit_item)(struct config_item * ) ;
   void (*disconnect_notify)(struct config_group * , struct config_item * ) ;
   void (*drop_item)(struct config_group * , struct config_item * ) ;
};
#line 238 "include/linux/configfs.h"
struct configfs_subsystem {
   struct config_group su_group ;
   struct mutex su_mutex ;
};
#line 258
struct percpu_ida_cpu;
#line 259 "include/linux/configfs.h"
struct __anonstruct____missing_field_name_407 {
   spinlock_t lock ;
   unsigned int cpu_last_stolen ;
   wait_queue_head_t wait ;
   unsigned int nr_free ;
   unsigned int *freelist ;
};
#line 259 "include/linux/configfs.h"
struct percpu_ida {
   unsigned int nr_tags ;
   unsigned int percpu_max_size ;
   unsigned int percpu_batch_size ;
   struct percpu_ida_cpu *tag_cpu ;
   cpumask_t cpus_have_tags ;
   struct __anonstruct____missing_field_name_407 __annonCompField102 ;
};
#line 82 "include/linux/percpu_ida.h"
struct hlist_nulls_node;
#line 82 "include/linux/percpu_ida.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 23 "include/linux/list_nulls.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 1182 "include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_409 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_409 sync_serial_settings;
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_410 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_410 te1_settings;
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_411 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_411 raw_hdlc_proto;
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_412 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_412 fr_proto;
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_413 {
   unsigned int dlci ;
};
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_413 fr_proto_pvc;
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_414 {
   unsigned int dlci ;
   char master[16U] ;
};
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_414 fr_proto_pvc_info;
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_415 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_415 cisco_proto;
#line 117 "./include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 177 "./include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_416 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 177 "./include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_416 ifs_ifsu ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_417 {
   char ifrn_name[16U] ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifru_418 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 195 "./include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_417 ifr_ifrn ;
   union __anonunion_ifr_ifru_418 ifr_ifru ;
};
#line 18 "./arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;
#line 39 "./arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "./arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 45 "./arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};
#line 276 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 280 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 34 "include/linux/if_ether.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
#line 125 "include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 189 "include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
#line 233 "include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};
#line 245 "include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 267 "include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 293 "include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
#line 322 "include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
#line 339 "include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 438 "include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 475 "include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
#line 503 "include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 605 "include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
#line 637 "include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
#line 679 "include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 712 "include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 728 "include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 748 "include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
#line 759 "include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
#line 778 "include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 828 "include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
#line 999 "include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
#line 1007 "include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 1083 "include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
#line 44 "include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
#line 99 "include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32  , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_key_size)(struct net_device * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh)(struct net_device * , u32 * , u8 * , u8 * ) ;
   int (*set_rxfh)(struct net_device * , u32 const   * , u8 const   * , u8 const    ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*get_tunable)(struct net_device * , struct ethtool_tunable  const  * , void * ) ;
   int (*set_tunable)(struct net_device * , struct ethtool_tunable  const  * , void const   * ) ;
};
#line 235 "include/net/flow.h"
struct prot_inuse;
#line 236 "include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
#line 38 "include/net/snmp.h"
struct u64_stats_sync {

};
#line 146 "include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};
#line 61 "include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};
#line 67 "include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
#line 72 "include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
#line 79 "include/net/snmp.h"
struct icmpv6_mib_device {
   atomic_long_t mibs[6U] ;
};
#line 83 "include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
#line 89 "include/net/snmp.h"
struct icmpv6msg_mib_device {
   atomic_long_t mibs[512U] ;
};
#line 93 "include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};
#line 100 "include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};
#line 106 "include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[115U] ;
};
#line 112 "include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
#line 118 "include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};
#line 26 "include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 12 "include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
#line 14 "include/net/netns/packet.h"
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
#line 179 "include/net/inet_frag.h"
struct ipv4_devconf;
#line 180
struct fib_rules_ops;
#line 181
struct fib_table;
#line 182 "include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};
#line 24 "include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};
#line 29
struct inet_peer_base;
#line 29
struct xt_table;
#line 29 "include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};
#line 113
struct neighbour;
#line 113 "include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32  ) ;
   unsigned int (*default_advmss)(struct dst_entry  const  * ) ;
   unsigned int (*mtu)(struct dst_entry  const  * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long  ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int  ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32  ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry  const  * , struct sk_buff * ,
                                     void const   * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
#line 72 "include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
};
#line 39 "include/net/netns/ipv6.h"
struct ipv6_devconf;
#line 39
struct rt6_info;
#line 39
struct rt6_statistics;
#line 39
struct fib6_table;
#line 39 "include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};
#line 85 "include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
#line 91 "include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};
#line 14 "include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};
#line 20
struct sctp_mib;
#line 21 "include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
#line 134 "include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 79 "include/uapi/linux/netfilter.h"
struct nf_logger;
#line 80 "include/uapi/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger  const  *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
#line 17 "include/net/netns/netfilter.h"
struct ebt_table;
#line 18 "include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};
#line 32 "include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};
#line 25 "include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 30 "include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};
#line 44 "include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
#line 49 "include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 54 "include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
#line 65 "include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
};
#line 73
struct ip_conntrack_stat;
#line 73
struct nf_ct_event_notifier;
#line 73
struct nf_exp_event_notifier;
#line 73 "include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};
#line 115
struct nft_af_info;
#line 116 "include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
   u8 gencursor ;
};
#line 508 "./include/uapi/linux/xfrm.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};
#line 16 "include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};
#line 25 "include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};
#line 21 "include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};
#line 30 "include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};
#line 88
struct mpls_route;
#line 89 "include/net/netns/xfrm.h"
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};
#line 16 "include/net/netns/mpls.h"
struct proc_ns_operations;
#line 17 "include/net/netns/mpls.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations  const  *ops ;
   unsigned int inum ;
};
#line 11 "include/linux/ns_common.h"
struct net_generic;
#line 12
struct netns_ipvs;
#line 13 "include/linux/ns_common.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};
#line 241 "include/net/net_namespace.h"
struct __anonstruct_possible_net_t_442 {
   struct net *net ;
};
#line 241 "include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_442 possible_net_t;
#line 376
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
} ;
#line 383 "include/net/net_namespace.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};
#line 32 "include/linux/of.h"
typedef u32 phandle;
#line 34 "include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};
#line 44 "include/linux/of.h"
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char const   *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};
#line 338 "include/linux/mii.h"
enum ldv_34518 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_MII = 1,
    PHY_INTERFACE_MODE_GMII = 2,
    PHY_INTERFACE_MODE_SGMII = 3,
    PHY_INTERFACE_MODE_TBI = 4,
    PHY_INTERFACE_MODE_REVMII = 5,
    PHY_INTERFACE_MODE_RMII = 6,
    PHY_INTERFACE_MODE_RGMII = 7,
    PHY_INTERFACE_MODE_RGMII_ID = 8,
    PHY_INTERFACE_MODE_RGMII_RXID = 9,
    PHY_INTERFACE_MODE_RGMII_TXID = 10,
    PHY_INTERFACE_MODE_RTBI = 11,
    PHY_INTERFACE_MODE_SMII = 12,
    PHY_INTERFACE_MODE_XGMII = 13,
    PHY_INTERFACE_MODE_MOCA = 14,
    PHY_INTERFACE_MODE_QSGMII = 15,
    PHY_INTERFACE_MODE_MAX = 16
} ;
#line 80 "include/linux/phy.h"
typedef enum ldv_34518 phy_interface_t;
#line 126
enum ldv_34570 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
} ;
#line 133
struct phy_device;
#line 133 "include/linux/phy.h"
struct mii_bus {
   char const   *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus * , int  , int  ) ;
   int (*write)(struct mii_bus * , int  , int  , u16  ) ;
   int (*reset)(struct mii_bus * ) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_34570 state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};
#line 214
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
} ;
#line 229 "include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};
#line 323
struct phy_driver;
#line 323 "include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device * ) ;
};
#line 429 "include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const   *driver_data ;
   int (*soft_reset)(struct phy_device * ) ;
   int (*config_init)(struct phy_device * ) ;
   int (*probe)(struct phy_device * ) ;
   int (*suspend)(struct phy_device * ) ;
   int (*resume)(struct phy_device * ) ;
   int (*config_aneg)(struct phy_device * ) ;
   int (*aneg_done)(struct phy_device * ) ;
   int (*read_status)(struct phy_device * ) ;
   int (*ack_interrupt)(struct phy_device * ) ;
   int (*config_intr)(struct phy_device * ) ;
   int (*did_interrupt)(struct phy_device * ) ;
   void (*remove)(struct phy_device * ) ;
   int (*match_phy_device)(struct phy_device * ) ;
   int (*ts_info)(struct phy_device * , struct ethtool_ts_info * ) ;
   int (*hwtstamp)(struct phy_device * , struct ifreq * ) ;
   bool (*rxtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   void (*txtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   int (*set_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*get_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*link_change_notify)(struct phy_device * ) ;
   int (*read_mmd_indirect)(struct phy_device * , int  , int  , int  ) ;
   void (*write_mmd_indirect)(struct phy_device * , int  , int  , int  , u32  ) ;
   int (*module_info)(struct phy_device * , struct ethtool_modinfo * ) ;
   int (*module_eeprom)(struct phy_device * , struct ethtool_eeprom * , u8 * ) ;
   struct device_driver driver ;
};
#line 803 "include/linux/phy.h"
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};
#line 25 "include/linux/phy_fixed.h"
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
} ;
#line 33 "include/linux/phy_fixed.h"
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};
#line 68 "include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};
#line 84
struct packet_type;
#line 85
struct dsa_switch;
#line 85 "include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
#line 123
struct dsa_switch_driver;
#line 123 "include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
#line 194 "include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device * , int  ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   u32 (*get_phy_flags)(struct dsa_switch * , int  ) ;
   int (*phy_read)(struct dsa_switch * , int  , int  ) ;
   int (*phy_write)(struct dsa_switch * , int  , int  , u16  ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*adjust_link)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*fixed_link_update)(struct dsa_switch * , int  , struct fixed_phy_status * ) ;
   void (*get_strings)(struct dsa_switch * , int  , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int  , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
   void (*get_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*suspend)(struct dsa_switch * ) ;
   int (*resume)(struct dsa_switch * ) ;
   int (*port_enable)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*port_disable)(struct dsa_switch * , int  , struct phy_device * ) ;
   int (*set_eee)(struct dsa_switch * , int  , struct phy_device * , struct ethtool_eee * ) ;
   int (*get_eee)(struct dsa_switch * , int  , struct ethtool_eee * ) ;
   int (*get_temp)(struct dsa_switch * , int * ) ;
   int (*get_temp_limit)(struct dsa_switch * , int * ) ;
   int (*set_temp_limit)(struct dsa_switch * , int  ) ;
   int (*get_temp_alarm)(struct dsa_switch * , bool * ) ;
   int (*get_eeprom_len)(struct dsa_switch * ) ;
   int (*get_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_regs_len)(struct dsa_switch * , int  ) ;
   void (*get_regs)(struct dsa_switch * , int  , struct ethtool_regs * , void * ) ;
   int (*port_join_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_leave_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_stp_update)(struct dsa_switch * , int  , u8  ) ;
   int (*fdb_add)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_del)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_getnext)(struct dsa_switch * , int  , unsigned char * , bool * ) ;
};
#line 320 "include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
#line 69 "./include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
#line 87 "./include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};
#line 132 "./include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};
#line 144 "./include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
#line 164 "./include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
#line 187 "./include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
#line 202 "./include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
#line 236 "./include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
#line 40 "include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_setqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_getqcnstats)(struct net_device * , struct ieee_qcn_stats * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   int (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   int (*getapp)(struct net_device * , u8  , u16  ) ;
   u8 (*getfeatcfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int  , u8  ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8  ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
#line 105 "include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 515 "include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
#line 41 "include/net/netprio_cgroup.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
#line 39 "include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
#line 643 "include/uapi/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};
#line 16 "include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};
#line 118 "include/uapi/linux/if_bonding.h"
struct netpoll_info;
#line 119
struct wireless_dev;
#line 120
struct wpan_dev;
#line 121
struct mpls_dev;
#line 65 "include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
#line 110 "include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 129 "include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 190
struct neigh_parms;
#line 211 "include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 216 "include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
#line 245 "include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short  , void const   * ,
                 void const   * , unsigned int  ) ;
   int (*parse)(struct sk_buff  const  * , unsigned char * ) ;
   int (*cache)(struct neighbour  const  * , struct hh_cache * , __be16  ) ;
   void (*cache_update)(struct hh_cache * , struct net_device  const  * , unsigned char const   * ) ;
};
#line 295 "include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct * , int  ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
#line 340
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
#line 388 "include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;
#line 389 "include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
#line 537
struct Qdisc;
#line 537 "include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
};
#line 607 "include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
#line 619 "include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
#line 631 "include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
#line 683 "include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
#line 706 "include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
#line 719 "include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
#line 730 "include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
#line 741 "include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
#line 757 "include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
#line 770 "include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * , void * , u16 (*)(struct net_device * ,
                                                                                     struct sk_buff * ) ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int  ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int  ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int  ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16  , u16  ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16  , u16  ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_busy_poll)(struct napi_struct * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int  , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int  , u16  , u8  ) ;
   int (*ndo_set_vf_rate)(struct net_device * , int  , int  , int  ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int  , bool  ) ;
   int (*ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_link_state)(struct net_device * , int  , int  ) ;
   int (*ndo_get_vf_stats)(struct net_device * , int  , struct ifla_vf_stats * ) ;
   int (*ndo_set_vf_port)(struct net_device * , int  , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int  , struct sk_buff * ) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device * , int  , bool  ) ;
   int (*ndo_setup_tc)(struct net_device * , u8  ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16  ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16  , struct scatterlist * ,
                              unsigned int  ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int  ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff  const  * , u16  ,
                            u32  ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  , u16  ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       struct net_device * , int  ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32  , u32  , struct net_device * ,
                             u32  , int  ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_change_carrier)(struct net_device * , bool  ) ;
   int (*ndo_get_phys_port_id)(struct net_device * , struct netdev_phys_item_id * ) ;
   int (*ndo_get_phys_port_name)(struct net_device * , char * , size_t  ) ;
   void (*ndo_add_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void (*ndo_del_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void *(*ndo_dfwd_add_station)(struct net_device * , struct net_device * ) ;
   void (*ndo_dfwd_del_station)(struct net_device * , void * ) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff * , struct net_device * , void * ) ;
   int (*ndo_get_lock_subclass)(struct net_device * ) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff * , struct net_device * ,
                                           netdev_features_t  ) ;
   int (*ndo_set_tx_maxrate)(struct net_device * , int  , u32  ) ;
   int (*ndo_get_iflink)(struct net_device  const  * ) ;
};
#line 1257 "include/linux/netdevice.h"
struct __anonstruct_adj_list_452 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1257 "include/linux/netdevice.h"
struct __anonstruct_all_adj_list_453 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1257
struct iw_handler_def;
#line 1257
struct iw_public_data;
#line 1257
struct switchdev_ops;
#line 1257
struct vlan_info;
#line 1257
struct tipc_bearer;
#line 1257
struct in_device;
#line 1257
struct dn_dev;
#line 1257
struct inet6_dev;
#line 1257
struct tcf_proto;
#line 1257
struct cpu_rmap;
#line 1257
struct pcpu_lstats;
#line 1257
struct pcpu_sw_netstats;
#line 1257
struct pcpu_dstats;
#line 1257
struct pcpu_vstats;
#line 1257 "include/linux/netdevice.h"
union __anonunion____missing_field_name_454 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
#line 1257
struct garp_port;
#line 1257
struct mrp_port;
#line 1257
struct rtnl_link_ops;
#line 1257 "include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_452 adj_list ;
   struct __anonstruct_all_adj_list_453 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct switchdev_ops  const  *switchdev_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   unsigned char reg_state ;
   bool dismantle ;
   unsigned short rtnl_link_state ;
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion____missing_field_name_454 __annonCompField105 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[4U] ;
   struct attribute_group  const  *sysfs_rx_queue_group ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops  const  *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};
#line 1978 "include/linux/netdevice.h"
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   bool (*id_match)(struct packet_type * , struct sock * ) ;
   void *af_packet_priv ;
   struct list_head list ;
};
#line 2025 "include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};
#line 3835 "include/linux/netdevice.h"
struct page_counter {
   atomic_long_t count ;
   unsigned long limit ;
   struct page_counter *parent ;
   unsigned long watermark ;
   unsigned long failcnt ;
};
#line 580 "include/linux/memcontrol.h"
struct sock_filter {
   __u16 code ;
   __u8 jt ;
   __u8 jf ;
   __u32 k ;
};
#line 49 "include/uapi/linux/filter.h"
struct bpf_insn {
   __u8 code ;
   unsigned char dst_reg : 4 ;
   unsigned char src_reg : 4 ;
   __s16 off ;
   __s32 imm ;
};
#line 81 "include/uapi/linux/bpf.h"
enum bpf_prog_type {
    BPF_PROG_TYPE_UNSPEC = 0,
    BPF_PROG_TYPE_SOCKET_FILTER = 1,
    BPF_PROG_TYPE_KPROBE = 2,
    BPF_PROG_TYPE_SCHED_CLS = 3,
    BPF_PROG_TYPE_SCHED_ACT = 4
} ;
#line 273
struct bpf_prog_aux;
#line 314 "include/linux/filter.h"
struct sock_fprog_kern {
   u16 len ;
   struct sock_filter *filter ;
};
#line 325 "include/linux/filter.h"
union __anonunion____missing_field_name_465 {
   struct sock_filter insns[0U] ;
   struct bpf_insn insnsi[0U] ;
};
#line 325 "include/linux/filter.h"
struct bpf_prog {
   u16 pages ;
   bool jited ;
   bool gpl_compatible ;
   u32 len ;
   enum bpf_prog_type type ;
   struct bpf_prog_aux *aux ;
   struct sock_fprog_kern *orig_prog ;
   unsigned int (*bpf_func)(struct sk_buff  const  * , struct bpf_insn  const  * ) ;
   union __anonunion____missing_field_name_465 __annonCompField110 ;
};
#line 342 "include/linux/filter.h"
struct sk_filter {
   atomic_t refcnt ;
   struct callback_head rcu ;
   struct bpf_prog *prog ;
};
#line 101 "include/linux/rculist_nulls.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 32 "include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 136 "include/linux/rtnetlink.h"
struct nla_policy {
   u16 type ;
   u16 len ;
};
#line 25 "include/net/rtnetlink.h"
struct rtnl_link_ops {
   struct list_head list ;
   char const   *kind ;
   size_t priv_size ;
   void (*setup)(struct net_device * ) ;
   int maxtype ;
   struct nla_policy  const  *policy ;
   int (*validate)(struct nlattr ** , struct nlattr ** ) ;
   int (*newlink)(struct net * , struct net_device * , struct nlattr ** , struct nlattr ** ) ;
   int (*changelink)(struct net_device * , struct nlattr ** , struct nlattr ** ) ;
   void (*dellink)(struct net_device * , struct list_head * ) ;
   size_t (*get_size)(struct net_device  const  * ) ;
   int (*fill_info)(struct sk_buff * , struct net_device  const  * ) ;
   size_t (*get_xstats_size)(struct net_device  const  * ) ;
   int (*fill_xstats)(struct sk_buff * , struct net_device  const  * ) ;
   unsigned int (*get_num_tx_queues)(void) ;
   unsigned int (*get_num_rx_queues)(void) ;
   int slave_maxtype ;
   struct nla_policy  const  *slave_policy ;
   int (*slave_validate)(struct nlattr ** , struct nlattr ** ) ;
   int (*slave_changelink)(struct net_device * , struct net_device * , struct nlattr ** ,
                           struct nlattr ** ) ;
   size_t (*get_slave_size)(struct net_device  const  * , struct net_device  const  * ) ;
   int (*fill_slave_info)(struct sk_buff * , struct net_device  const  * , struct net_device  const  * ) ;
   struct net *(*get_link_net)(struct net_device  const  * ) ;
};
#line 171
struct neigh_table;
#line 171 "include/net/rtnetlink.h"
struct neigh_parms {
   possible_net_t net ;
   struct net_device *dev ;
   struct list_head list ;
   int (*neigh_setup)(struct neighbour * ) ;
   void (*neigh_cleanup)(struct neighbour * ) ;
   struct neigh_table *tbl ;
   void *sysctl_table ;
   int dead ;
   atomic_t refcnt ;
   struct callback_head callback_head ;
   int reachable_time ;
   int data[13U] ;
   unsigned long data_state[1U] ;
};
#line 110 "include/net/neighbour.h"
struct neigh_statistics {
   unsigned long allocs ;
   unsigned long destroys ;
   unsigned long hash_grows ;
   unsigned long res_failed ;
   unsigned long lookups ;
   unsigned long hits ;
   unsigned long rcv_probes_mcast ;
   unsigned long rcv_probes_ucast ;
   unsigned long periodic_gc_runs ;
   unsigned long forced_gc_runs ;
   unsigned long unres_discards ;
};
#line 129
struct neigh_ops;
#line 129 "include/net/neighbour.h"
struct neighbour {
   struct neighbour *next ;
   struct neigh_table *tbl ;
   struct neigh_parms *parms ;
   unsigned long confirmed ;
   unsigned long updated ;
   rwlock_t lock ;
   atomic_t refcnt ;
   struct sk_buff_head arp_queue ;
   unsigned int arp_queue_len_bytes ;
   struct timer_list timer ;
   unsigned long used ;
   atomic_t probes ;
   __u8 flags ;
   __u8 nud_state ;
   __u8 type ;
   __u8 dead ;
   seqlock_t ha_lock ;
   unsigned char ha[32U] ;
   struct hh_cache hh ;
   int (*output)(struct neighbour * , struct sk_buff * ) ;
   struct neigh_ops  const  *ops ;
   struct callback_head rcu ;
   struct net_device *dev ;
   u8 primary_key[0U] ;
};
#line 158 "include/net/neighbour.h"
struct neigh_ops {
   int family ;
   void (*solicit)(struct neighbour * , struct sk_buff * ) ;
   void (*error_report)(struct neighbour * , struct sk_buff * ) ;
   int (*output)(struct neighbour * , struct sk_buff * ) ;
   int (*connected_output)(struct neighbour * , struct sk_buff * ) ;
};
#line 166 "include/net/neighbour.h"
struct pneigh_entry {
   struct pneigh_entry *next ;
   possible_net_t net ;
   struct net_device *dev ;
   u8 flags ;
   u8 key[0U] ;
};
#line 174 "include/net/neighbour.h"
struct neigh_hash_table {
   struct neighbour **hash_buckets ;
   unsigned int hash_shift ;
   __u32 hash_rnd[4U] ;
   struct callback_head rcu ;
};
#line 187 "include/net/neighbour.h"
struct neigh_table {
   int family ;
   int entry_size ;
   int key_len ;
   __be16 protocol ;
   __u32 (*hash)(void const   * , struct net_device  const  * , __u32 * ) ;
   bool (*key_eq)(struct neighbour  const  * , void const   * ) ;
   int (*constructor)(struct neighbour * ) ;
   int (*pconstructor)(struct pneigh_entry * ) ;
   void (*pdestructor)(struct pneigh_entry * ) ;
   void (*proxy_redo)(struct sk_buff * ) ;
   char *id ;
   struct neigh_parms parms ;
   struct list_head parms_list ;
   int gc_interval ;
   int gc_thresh1 ;
   int gc_thresh2 ;
   int gc_thresh3 ;
   unsigned long last_flush ;
   struct delayed_work gc_work ;
   struct timer_list proxy_timer ;
   struct sk_buff_head proxy_queue ;
   atomic_t entries ;
   rwlock_t lock ;
   unsigned long last_rand ;
   struct neigh_statistics *stats ;
   struct neigh_hash_table *nht ;
   struct pneigh_entry **phash_buckets ;
};
#line 519
struct dn_route;
#line 519 "include/net/neighbour.h"
union __anonunion____missing_field_name_476 {
   struct dst_entry *next ;
   struct rtable *rt_next ;
   struct rt6_info *rt6_next ;
   struct dn_route *dn_next ;
};
#line 519 "include/net/neighbour.h"
struct dst_entry {
   struct callback_head callback_head ;
   struct dst_entry *child ;
   struct net_device *dev ;
   struct dst_ops *ops ;
   unsigned long _metrics ;
   unsigned long expires ;
   struct dst_entry *path ;
   struct dst_entry *from ;
   struct xfrm_state *xfrm ;
   int (*input)(struct sk_buff * ) ;
   int (*output)(struct sock * , struct sk_buff * ) ;
   unsigned short flags ;
   unsigned short pending_confirm ;
   short error ;
   short obsolete ;
   unsigned short header_len ;
   unsigned short trailer_len ;
   __u32 tclassid ;
   long __pad_to_align_refcnt[2U] ;
   atomic_t __refcnt ;
   int __use ;
   unsigned long lastuse ;
   union __anonunion____missing_field_name_476 __annonCompField111 ;
};
#line 124 "include/net/sock.h"
struct __anonstruct_socket_lock_t_477 {
   spinlock_t slock ;
   int owned ;
   wait_queue_head_t wq ;
   struct lockdep_map dep_map ;
};
#line 124 "include/net/sock.h"
typedef struct __anonstruct_socket_lock_t_477 socket_lock_t;
#line 124
struct proto;
#line 130 "include/net/sock.h"
typedef __u32 __portpair;
#line 131 "include/net/sock.h"
typedef __u64 __addrpair;
#line 132 "include/net/sock.h"
struct __anonstruct____missing_field_name_479 {
   __be32 skc_daddr ;
   __be32 skc_rcv_saddr ;
};
#line 132 "include/net/sock.h"
union __anonunion____missing_field_name_478 {
   __addrpair skc_addrpair ;
   struct __anonstruct____missing_field_name_479 __annonCompField112 ;
};
#line 132 "include/net/sock.h"
union __anonunion____missing_field_name_480 {
   unsigned int skc_hash ;
   __u16 skc_u16hashes[2U] ;
};
#line 132 "include/net/sock.h"
struct __anonstruct____missing_field_name_482 {
   __be16 skc_dport ;
   __u16 skc_num ;
};
#line 132 "include/net/sock.h"
union __anonunion____missing_field_name_481 {
   __portpair skc_portpair ;
   struct __anonstruct____missing_field_name_482 __annonCompField115 ;
};
#line 132 "include/net/sock.h"
union __anonunion____missing_field_name_483 {
   struct hlist_node skc_bind_node ;
   struct hlist_nulls_node skc_portaddr_node ;
};
#line 132 "include/net/sock.h"
union __anonunion____missing_field_name_484 {
   struct hlist_node skc_node ;
   struct hlist_nulls_node skc_nulls_node ;
};
#line 132 "include/net/sock.h"
struct sock_common {
   union __anonunion____missing_field_name_478 __annonCompField113 ;
   union __anonunion____missing_field_name_480 __annonCompField114 ;
   union __anonunion____missing_field_name_481 __annonCompField116 ;
   unsigned short skc_family ;
   unsigned char volatile   skc_state ;
   unsigned char skc_reuse : 4 ;
   unsigned char skc_reuseport : 1 ;
   unsigned char skc_ipv6only : 1 ;
   unsigned char skc_net_refcnt : 1 ;
   int skc_bound_dev_if ;
   union __anonunion____missing_field_name_483 __annonCompField117 ;
   struct proto *skc_prot ;
   possible_net_t skc_net ;
   struct in6_addr skc_v6_daddr ;
   struct in6_addr skc_v6_rcv_saddr ;
   atomic64_t skc_cookie ;
   int skc_dontcopy_begin[0U] ;
   union __anonunion____missing_field_name_484 __annonCompField118 ;
   int skc_tx_queue_mapping ;
   atomic_t skc_refcnt ;
   int skc_dontcopy_end[0U] ;
};
#line 219
struct cg_proto;
#line 220 "include/net/sock.h"
struct __anonstruct_sk_backlog_485 {
   atomic_t rmem_alloc ;
   int len ;
   struct sk_buff *head ;
   struct sk_buff *tail ;
};
#line 220 "include/net/sock.h"
struct sock {
   struct sock_common __sk_common ;
   socket_lock_t sk_lock ;
   struct sk_buff_head sk_receive_queue ;
   struct __anonstruct_sk_backlog_485 sk_backlog ;
   int sk_forward_alloc ;
   __u32 sk_rxhash ;
   u16 sk_incoming_cpu ;
   __u32 sk_txhash ;
   unsigned int sk_napi_id ;
   unsigned int sk_ll_usec ;
   atomic_t sk_drops ;
   int sk_rcvbuf ;
   struct sk_filter *sk_filter ;
   struct socket_wq *sk_wq ;
   struct xfrm_policy *sk_policy[2U] ;
   unsigned long sk_flags ;
   struct dst_entry *sk_rx_dst ;
   struct dst_entry *sk_dst_cache ;
   spinlock_t sk_dst_lock ;
   atomic_t sk_wmem_alloc ;
   atomic_t sk_omem_alloc ;
   int sk_sndbuf ;
   struct sk_buff_head sk_write_queue ;
   unsigned char sk_shutdown : 2 ;
   unsigned char sk_no_check_tx : 1 ;
   unsigned char sk_no_check_rx : 1 ;
   unsigned char sk_userlocks : 4 ;
   unsigned char sk_protocol ;
   unsigned short sk_type ;
   int sk_wmem_queued ;
   gfp_t sk_allocation ;
   u32 sk_pacing_rate ;
   u32 sk_max_pacing_rate ;
   netdev_features_t sk_route_caps ;
   netdev_features_t sk_route_nocaps ;
   int sk_gso_type ;
   unsigned int sk_gso_max_size ;
   u16 sk_gso_max_segs ;
   int sk_rcvlowat ;
   unsigned long sk_lingertime ;
   struct sk_buff_head sk_error_queue ;
   struct proto *sk_prot_creator ;
   rwlock_t sk_callback_lock ;
   int sk_err ;
   int sk_err_soft ;
   u32 sk_ack_backlog ;
   u32 sk_max_ack_backlog ;
   __u32 sk_priority ;
   __u32 sk_cgrp_prioidx ;
   struct pid *sk_peer_pid ;
   struct cred  const  *sk_peer_cred ;
   long sk_rcvtimeo ;
   long sk_sndtimeo ;
   struct timer_list sk_timer ;
   ktime_t sk_stamp ;
   u16 sk_tsflags ;
   u32 sk_tskey ;
   struct socket *sk_socket ;
   void *sk_user_data ;
   struct page_frag sk_frag ;
   struct sk_buff *sk_send_head ;
   __s32 sk_peek_off ;
   int sk_write_pending ;
   void *sk_security ;
   __u32 sk_mark ;
   u32 sk_classid ;
   struct cg_proto *sk_cgrp ;
   void (*sk_state_change)(struct sock * ) ;
   void (*sk_data_ready)(struct sock * ) ;
   void (*sk_write_space)(struct sock * ) ;
   void (*sk_error_report)(struct sock * ) ;
   int (*sk_backlog_rcv)(struct sock * , struct sk_buff * ) ;
   void (*sk_destruct)(struct sock * ) ;
};
#line 906
struct request_sock_ops;
#line 907
struct timewait_sock_ops;
#line 908
struct inet_hashinfo;
#line 909
struct raw_hashinfo;
#line 923
struct udp_table;
#line 923 "include/net/sock.h"
union __anonunion_h_488 {
   struct inet_hashinfo *hashinfo ;
   struct udp_table *udp_table ;
   struct raw_hashinfo *raw_hash ;
};
#line 923 "include/net/sock.h"
struct proto {
   void (*close)(struct sock * , long  ) ;
   int (*connect)(struct sock * , struct sockaddr * , int  ) ;
   int (*disconnect)(struct sock * , int  ) ;
   struct sock *(*accept)(struct sock * , int  , int * ) ;
   int (*ioctl)(struct sock * , int  , unsigned long  ) ;
   int (*init)(struct sock * ) ;
   void (*destroy)(struct sock * ) ;
   void (*shutdown)(struct sock * , int  ) ;
   int (*setsockopt)(struct sock * , int  , int  , char * , unsigned int  ) ;
   int (*getsockopt)(struct sock * , int  , int  , char * , int * ) ;
   int (*compat_setsockopt)(struct sock * , int  , int  , char * , unsigned int  ) ;
   int (*compat_getsockopt)(struct sock * , int  , int  , char * , int * ) ;
   int (*compat_ioctl)(struct sock * , unsigned int  , unsigned long  ) ;
   int (*sendmsg)(struct sock * , struct msghdr * , size_t  ) ;
   int (*recvmsg)(struct sock * , struct msghdr * , size_t  , int  , int  , int * ) ;
   int (*sendpage)(struct sock * , struct page * , int  , size_t  , int  ) ;
   int (*bind)(struct sock * , struct sockaddr * , int  ) ;
   int (*backlog_rcv)(struct sock * , struct sk_buff * ) ;
   void (*release_cb)(struct sock * ) ;
   void (*hash)(struct sock * ) ;
   void (*unhash)(struct sock * ) ;
   void (*rehash)(struct sock * ) ;
   int (*get_port)(struct sock * , unsigned short  ) ;
   void (*clear_sk)(struct sock * , int  ) ;
   unsigned int inuse_idx ;
   bool (*stream_memory_free)(struct sock  const  * ) ;
   void (*enter_memory_pressure)(struct sock * ) ;
   atomic_long_t *memory_allocated ;
   struct percpu_counter *sockets_allocated ;
   int *memory_pressure ;
   long *sysctl_mem ;
   int *sysctl_wmem ;
   int *sysctl_rmem ;
   int max_header ;
   bool no_autobind ;
   struct kmem_cache *slab ;
   unsigned int obj_size ;
   int slab_flags ;
   struct percpu_counter *orphan_count ;
   struct request_sock_ops *rsk_prot ;
   struct timewait_sock_ops *twsk_prot ;
   union __anonunion_h_488 h ;
   struct module *owner ;
   char name[32U] ;
   struct list_head node ;
   int (*init_cgroup)(struct mem_cgroup * , struct cgroup_subsys * ) ;
   void (*destroy_cgroup)(struct mem_cgroup * ) ;
   struct cg_proto *(*proto_cgroup)(struct mem_cgroup * ) ;
};
#line 1046 "include/net/sock.h"
struct cg_proto {
   struct page_counter memory_allocated ;
   struct percpu_counter sockets_allocated ;
   int memory_pressure ;
   long sysctl_mem[3U] ;
   unsigned long flags ;
   struct mem_cgroup *memcg ;
};
#line 174 "include/linux/jhash.h"
struct request_sock_ops {
   int family ;
   int obj_size ;
   struct kmem_cache *slab ;
   char *slab_name ;
   int (*rtx_syn_ack)(struct sock * , struct request_sock * ) ;
   void (*send_ack)(struct sock * , struct sk_buff * , struct request_sock * ) ;
   void (*send_reset)(struct sock * , struct sk_buff * ) ;
   void (*destructor)(struct request_sock * ) ;
   void (*syn_ack_timeout)(struct request_sock  const  * ) ;
};
#line 46 "include/net/request_sock.h"
struct request_sock {
   struct sock_common __req_common ;
   struct request_sock *dl_next ;
   struct sock *rsk_listener ;
   u16 mss ;
   u8 num_retrans ;
   unsigned char cookie_ts : 1 ;
   unsigned char num_timeout : 7 ;
   u32 window_clamp ;
   u32 rcv_wnd ;
   u32 ts_recent ;
   struct timer_list rsk_timer ;
   struct request_sock_ops  const  *rsk_ops ;
   struct sock *sk ;
   u32 *saved_syn ;
   u32 secid ;
   u32 peer_secid ;
};
#line 330 "include/net/inet_connection_sock.h"
struct timewait_sock_ops {
   struct kmem_cache *twsk_slab ;
   char *twsk_slab_name ;
   unsigned int twsk_obj_size ;
   int (*twsk_unique)(struct sock * , struct sock * , void * ) ;
   void (*twsk_destructor)(struct sock * ) ;
};
#line 174 "include/uapi/linux/ipv6.h"
struct ipv6_stable_secret {
   bool initialized ;
   struct in6_addr secret ;
};
#line 60 "include/linux/ipv6.h"
struct ipv6_devconf {
   __s32 forwarding ;
   __s32 hop_limit ;
   __s32 mtu6 ;
   __s32 accept_ra ;
   __s32 accept_redirects ;
   __s32 autoconf ;
   __s32 dad_transmits ;
   __s32 rtr_solicits ;
   __s32 rtr_solicit_interval ;
   __s32 rtr_solicit_delay ;
   __s32 force_mld_version ;
   __s32 mldv1_unsolicited_report_interval ;
   __s32 mldv2_unsolicited_report_interval ;
   __s32 use_tempaddr ;
   __s32 temp_valid_lft ;
   __s32 temp_prefered_lft ;
   __s32 regen_max_retry ;
   __s32 max_desync_factor ;
   __s32 max_addresses ;
   __s32 accept_ra_defrtr ;
   __s32 accept_ra_pinfo ;
   __s32 accept_ra_rtr_pref ;
   __s32 rtr_probe_interval ;
   __s32 accept_ra_rt_info_max_plen ;
   __s32 proxy_ndp ;
   __s32 accept_source_route ;
   __s32 accept_ra_from_local ;
   __s32 optimistic_dad ;
   __s32 use_optimistic ;
   __s32 mc_forwarding ;
   __s32 disable_ipv6 ;
   __s32 accept_dad ;
   __s32 force_tllao ;
   __s32 ndisc_notify ;
   __s32 suppress_frag_ndisc ;
   __s32 accept_ra_mtu ;
   struct ipv6_stable_secret stable_secret ;
   void *sysctl ;
};
#line 100 "include/net/if_inet6.h"
struct ip6_sf_list {
   struct ip6_sf_list *sf_next ;
   struct in6_addr sf_addr ;
   unsigned long sf_count[2U] ;
   unsigned char sf_gsresp ;
   unsigned char sf_oldin ;
   unsigned char sf_crcount ;
};
#line 109 "include/net/if_inet6.h"
struct ifmcaddr6 {
   struct in6_addr mca_addr ;
   struct inet6_dev *idev ;
   struct ifmcaddr6 *next ;
   struct ip6_sf_list *mca_sources ;
   struct ip6_sf_list *mca_tomb ;
   unsigned int mca_sfmode ;
   unsigned char mca_crcount ;
   unsigned long mca_sfcount[2U] ;
   struct timer_list mca_timer ;
   unsigned int mca_flags ;
   int mca_users ;
   atomic_t mca_refcnt ;
   spinlock_t mca_lock ;
   unsigned long mca_cstamp ;
   unsigned long mca_tstamp ;
};
#line 141 "include/net/if_inet6.h"
struct ifacaddr6 {
   struct in6_addr aca_addr ;
   struct inet6_dev *aca_idev ;
   struct rt6_info *aca_rt ;
   struct ifacaddr6 *aca_next ;
   int aca_users ;
   atomic_t aca_refcnt ;
   unsigned long aca_cstamp ;
   unsigned long aca_tstamp ;
};
#line 152 "include/net/if_inet6.h"
struct ipv6_devstat {
   struct proc_dir_entry *proc_dir_entry ;
   struct ipstats_mib *ipv6 ;
   struct icmpv6_mib_device *icmpv6dev ;
   struct icmpv6msg_mib_device *icmpv6msgdev ;
};
#line 163 "include/net/if_inet6.h"
struct inet6_dev {
   struct net_device *dev ;
   struct list_head addr_list ;
   struct ifmcaddr6 *mc_list ;
   struct ifmcaddr6 *mc_tomb ;
   spinlock_t mc_lock ;
   unsigned char mc_qrv ;
   unsigned char mc_gq_running ;
   unsigned char mc_ifc_count ;
   unsigned char mc_dad_count ;
   unsigned long mc_v1_seen ;
   unsigned long mc_qi ;
   unsigned long mc_qri ;
   unsigned long mc_maxdelay ;
   struct timer_list mc_gq_timer ;
   struct timer_list mc_ifc_timer ;
   struct timer_list mc_dad_timer ;
   struct ifacaddr6 *ac_list ;
   rwlock_t lock ;
   atomic_t refcnt ;
   __u32 if_flags ;
   int dead ;
   u8 rndid[8U] ;
   struct timer_list regen_timer ;
   struct list_head tempaddr_list ;
   struct in6_addr token ;
   struct neigh_parms *nd_parms ;
   struct ipv6_devconf cnf ;
   struct ipv6_devstat stats ;
   struct timer_list rs_timer ;
   __u8 rs_probes ;
   __u8 addr_gen_mode ;
   unsigned long tstamp ;
   struct callback_head rcu ;
};
#line 971 "include/net/ipv6.h"
union __anonunion____missing_field_name_510 {
   __be32 a4 ;
   __be32 a6[4U] ;
   struct in6_addr in6 ;
};
#line 971 "include/net/ipv6.h"
struct inetpeer_addr_base {
   union __anonunion____missing_field_name_510 __annonCompField120 ;
};
#line 25 "include/net/inetpeer.h"
struct inetpeer_addr {
   struct inetpeer_addr_base addr ;
   __u16 family ;
};
#line 30 "include/net/inetpeer.h"
union __anonunion____missing_field_name_511 {
   struct list_head gc_list ;
   struct callback_head gc_rcu ;
};
#line 30 "include/net/inetpeer.h"
struct __anonstruct____missing_field_name_513 {
   atomic_t rid ;
};
#line 30 "include/net/inetpeer.h"
union __anonunion____missing_field_name_512 {
   struct __anonstruct____missing_field_name_513 __annonCompField122 ;
   struct callback_head rcu ;
   struct inet_peer *gc_next ;
};
#line 30 "include/net/inetpeer.h"
struct inet_peer {
   struct inet_peer *avl_left ;
   struct inet_peer *avl_right ;
   struct inetpeer_addr daddr ;
   __u32 avl_height ;
   u32 metrics[16U] ;
   u32 rate_tokens ;
   unsigned long rate_last ;
   union __anonunion____missing_field_name_511 __annonCompField121 ;
   union __anonunion____missing_field_name_512 __annonCompField123 ;
   __u32 dtime ;
   atomic_t refcnt ;
};
#line 61 "include/net/inetpeer.h"
struct inet_peer_base {
   struct inet_peer *root ;
   seqlock_t lock ;
   int total ;
};
#line 50 "./include/uapi/linux/route.h"
struct uncached_list;
#line 51 "./include/uapi/linux/route.h"
struct rtable {
   struct dst_entry dst ;
   int rt_genid ;
   unsigned int rt_flags ;
   __u16 rt_type ;
   __u8 rt_is_input ;
   __u8 rt_uses_gateway ;
   int rt_iif ;
   __be32 rt_gateway ;
   u32 rt_pmtu ;
   struct list_head rt_uncached ;
   struct uncached_list *rt_uncached_list ;
};
#line 317 "include/net/route.h"
struct inet_ehash_bucket {
   struct hlist_nulls_head chain ;
};
#line 92 "include/net/inet_hashtables.h"
struct inet_bind_hashbucket {
   spinlock_t lock ;
   struct hlist_head chain ;
};
#line 100 "include/net/inet_hashtables.h"
struct inet_listen_hashbucket {
   spinlock_t lock ;
   struct hlist_nulls_head head ;
};
#line 112 "include/net/inet_hashtables.h"
struct inet_hashinfo {
   struct inet_ehash_bucket *ehash ;
   spinlock_t *ehash_locks ;
   unsigned int ehash_mask ;
   unsigned int ehash_locks_mask ;
   struct inet_bind_hashbucket *bhash ;
   unsigned int bhash_size ;
   struct kmem_cache *bind_bucket_cachep ;
   struct inet_listen_hashbucket listening_hash[32U] ;
};
#line 1764 "include/net/tcp.h"
enum transport_state_table {
    TRANSPORT_NO_STATE = 0,
    TRANSPORT_NEW_CMD = 1,
    TRANSPORT_WRITE_PENDING = 3,
    TRANSPORT_PROCESSING = 5,
    TRANSPORT_COMPLETE = 6,
    TRANSPORT_ISTATE_PROCESSING = 11,
    TRANSPORT_COMPLETE_QF_WP = 18,
    TRANSPORT_COMPLETE_QF_OK = 19
} ;
#line 152 "include/target/target_core_base.h"
typedef unsigned int sense_reason_t;
#line 219
struct se_cmd;
#line 234
struct se_device;
#line 234
struct t10_alua_tg_pt_gp;
#line 234 "include/target/target_core_base.h"
struct t10_alua {
   u16 alua_tg_pt_gps_counter ;
   u32 alua_tg_pt_gps_count ;
   spinlock_t lba_map_lock ;
   u32 lba_map_segment_size ;
   u32 lba_map_segment_multiplier ;
   struct list_head lba_map_list ;
   spinlock_t tg_pt_gps_lock ;
   struct se_device *t10_dev ;
   struct t10_alua_tg_pt_gp *default_tg_pt_gp ;
   struct config_group alua_tg_pt_gps_group ;
   struct list_head tg_pt_gps_list ;
};
#line 252 "include/target/target_core_base.h"
struct t10_alua_lu_gp {
   u16 lu_gp_id ;
   int lu_gp_valid_id ;
   u32 lu_gp_members ;
   atomic_t lu_gp_ref_cnt ;
   spinlock_t lu_gp_lock ;
   struct config_group lu_gp_group ;
   struct list_head lu_gp_node ;
   struct list_head lu_gp_mem_list ;
};
#line 263 "include/target/target_core_base.h"
struct t10_alua_lu_gp_member {
   bool lu_gp_assoc ;
   atomic_t lu_gp_mem_ref_cnt ;
   spinlock_t lu_gp_mem_lock ;
   struct t10_alua_lu_gp *lu_gp ;
   struct se_device *lu_gp_mem_dev ;
   struct list_head lu_gp_mem_list ;
};
#line 272
struct se_lun;
#line 272
struct se_node_acl;
#line 272 "include/target/target_core_base.h"
struct t10_alua_tg_pt_gp {
   u16 tg_pt_gp_id ;
   int tg_pt_gp_valid_id ;
   int tg_pt_gp_alua_supported_states ;
   int tg_pt_gp_alua_pending_state ;
   int tg_pt_gp_alua_previous_state ;
   int tg_pt_gp_alua_access_status ;
   int tg_pt_gp_alua_access_type ;
   int tg_pt_gp_nonop_delay_msecs ;
   int tg_pt_gp_trans_delay_msecs ;
   int tg_pt_gp_implicit_trans_secs ;
   int tg_pt_gp_pref ;
   int tg_pt_gp_write_metadata ;
   u32 tg_pt_gp_members ;
   atomic_t tg_pt_gp_alua_access_state ;
   atomic_t tg_pt_gp_ref_cnt ;
   spinlock_t tg_pt_gp_lock ;
   struct mutex tg_pt_gp_md_mutex ;
   struct se_device *tg_pt_gp_dev ;
   struct config_group tg_pt_gp_group ;
   struct list_head tg_pt_gp_list ;
   struct list_head tg_pt_gp_lun_list ;
   struct se_lun *tg_pt_gp_alua_lun ;
   struct se_node_acl *tg_pt_gp_alua_nacl ;
   struct delayed_work tg_pt_gp_transition_work ;
   struct completion *tg_pt_gp_transition_complete ;
};
#line 310 "include/target/target_core_base.h"
struct t10_wwn {
   char vendor[8U] ;
   char model[16U] ;
   char revision[4U] ;
   char unit_serial[254U] ;
   spinlock_t t10_vpd_lock ;
   struct se_device *t10_dev ;
   struct config_group t10_wwn_group ;
   struct list_head t10_vpd_list ;
};
#line 321
struct se_dev_entry;
#line 321 "include/target/target_core_base.h"
struct t10_pr_registration {
   char pr_reg_isid[16U] ;
   unsigned char pr_iport[256U] ;
   unsigned char pr_tport[256U] ;
   u16 pr_aptpl_rpti ;
   u16 pr_reg_tpgt ;
   int pr_reg_all_tg_pt ;
   int pr_reg_aptpl ;
   int pr_res_holder ;
   int pr_res_type ;
   int pr_res_scope ;
   bool isid_present_at_reg ;
   u64 pr_res_mapped_lun ;
   u64 pr_aptpl_target_lun ;
   u16 tg_pt_sep_rtpi ;
   u32 pr_res_generation ;
   u64 pr_reg_bin_isid ;
   u64 pr_res_key ;
   atomic_t pr_res_holders ;
   struct se_node_acl *pr_reg_nacl ;
   struct se_dev_entry *pr_reg_deve ;
   struct list_head pr_reg_list ;
   struct list_head pr_reg_abort_list ;
   struct list_head pr_reg_aptpl_list ;
   struct list_head pr_reg_atp_list ;
   struct list_head pr_reg_atp_mem_list ;
};
#line 361 "include/target/target_core_base.h"
struct t10_reservation {
   int pr_all_tg_pt ;
   int pr_aptpl_active ;
   u32 pr_generation ;
   spinlock_t registration_lock ;
   spinlock_t aptpl_reg_lock ;
   struct se_node_acl *pr_res_holder ;
   struct list_head registration_list ;
   struct list_head aptpl_reg_list ;
};
#line 386 "include/target/target_core_base.h"
struct se_tmr_req {
   u8 function ;
   u8 response ;
   int call_transport ;
   u64 ref_task_tag ;
   void *fabric_tmr_ptr ;
   struct se_cmd *task_cmd ;
   struct se_device *tmr_dev ;
   struct se_lun *tmr_lun ;
   struct list_head tmr_list ;
};
#line 401
enum target_prot_op {
    TARGET_PROT_NORMAL = 0,
    TARGET_PROT_DIN_INSERT = 1,
    TARGET_PROT_DOUT_INSERT = 2,
    TARGET_PROT_DIN_STRIP = 4,
    TARGET_PROT_DOUT_STRIP = 8,
    TARGET_PROT_DIN_PASS = 16,
    TARGET_PROT_DOUT_PASS = 32
} ;
#line 411
enum target_prot_type {
    TARGET_DIF_TYPE0_PROT = 0,
    TARGET_DIF_TYPE1_PROT = 1,
    TARGET_DIF_TYPE2_PROT = 2,
    TARGET_DIF_TYPE3_PROT = 3
} ;
#line 434
struct se_session;
#line 434
struct target_core_fabric_ops;
#line 434 "include/target/target_core_base.h"
struct se_cmd {
   u8 scsi_status ;
   u8 scsi_asc ;
   u8 scsi_ascq ;
   u16 scsi_sense_length ;
   u64 tag ;
   int alua_nonop_delay ;
   enum dma_data_direction data_direction ;
   int sam_task_attr ;
   unsigned int map_tag ;
   enum transport_state_table t_state ;
   unsigned char cmd_wait_set : 1 ;
   unsigned char unknown_data_length : 1 ;
   u32 se_cmd_flags ;
   u32 se_ordered_id ;
   u32 data_length ;
   u32 residual_count ;
   u64 orig_fe_lun ;
   u64 pr_res_key ;
   void *sense_buffer ;
   struct list_head se_delayed_node ;
   struct list_head se_qf_node ;
   struct se_device *se_dev ;
   struct se_lun *se_lun ;
   struct se_session *se_sess ;
   struct se_tmr_req *se_tmr_req ;
   struct list_head se_cmd_list ;
   struct completion cmd_wait_comp ;
   struct kref cmd_kref ;
   struct target_core_fabric_ops  const  *se_tfo ;
   sense_reason_t (*execute_cmd)(struct se_cmd * ) ;
   sense_reason_t (*transport_complete_callback)(struct se_cmd * , bool  ) ;
   void *protocol_data ;
   unsigned char *t_task_cdb ;
   unsigned char __t_task_cdb[32U] ;
   unsigned long long t_task_lba ;
   unsigned int t_task_nolb ;
   unsigned int transport_state ;
   spinlock_t t_state_lock ;
   struct completion t_transport_stop_comp ;
   struct work_struct work ;
   struct scatterlist *t_data_sg ;
   struct scatterlist *t_data_sg_orig ;
   unsigned int t_data_nents ;
   unsigned int t_data_nents_orig ;
   void *t_data_vmap ;
   struct scatterlist *t_bidi_data_sg ;
   unsigned int t_bidi_data_nents ;
   struct list_head state_list ;
   bool state_active ;
   struct completion task_stop_comp ;
   void *priv ;
   int lun_ref_active ;
   enum target_prot_op prot_op ;
   enum target_prot_type prot_type ;
   u8 prot_checks ;
   u32 prot_length ;
   u32 reftag_seed ;
   struct scatterlist *t_prot_sg ;
   unsigned int t_prot_nents ;
   sense_reason_t pi_err ;
   sector_t bad_sector ;
   bool prot_pto ;
};
#line 542
struct se_portal_group;
#line 542 "include/target/target_core_base.h"
struct se_node_acl {
   char initiatorname[224U] ;
   bool dynamic_node_acl ;
   bool acl_stop ;
   u32 queue_depth ;
   u32 acl_index ;
   enum target_prot_type saved_prot_type ;
   char acl_tag[64U] ;
   atomic_t acl_pr_ref_count ;
   struct hlist_head lun_entry_hlist ;
   struct se_session *nacl_sess ;
   struct se_portal_group *se_tpg ;
   struct mutex lun_entry_mutex ;
   spinlock_t nacl_sess_lock ;
   struct config_group acl_group ;
   struct config_group acl_attrib_group ;
   struct config_group acl_auth_group ;
   struct config_group acl_param_group ;
   struct config_group acl_fabric_stat_group ;
   struct config_group *acl_default_groups[5U] ;
   struct list_head acl_list ;
   struct list_head acl_sess_list ;
   struct completion acl_free_comp ;
   struct kref acl_kref ;
};
#line 571 "include/target/target_core_base.h"
struct se_session {
   unsigned char sess_tearing_down : 1 ;
   u64 sess_bin_isid ;
   enum target_prot_op sup_prot_ops ;
   enum target_prot_type sess_prot_type ;
   struct se_node_acl *se_node_acl ;
   struct se_portal_group *se_tpg ;
   void *fabric_sess_ptr ;
   struct list_head sess_list ;
   struct list_head sess_acl_list ;
   struct list_head sess_cmd_list ;
   struct list_head sess_wait_list ;
   spinlock_t sess_cmd_lock ;
   struct kref sess_kref ;
   void *sess_cmd_map ;
   struct percpu_ida sess_tag_pool ;
};
#line 590 "include/target/target_core_base.h"
struct se_ml_stat_grps {
   struct config_group stat_group ;
   struct config_group scsi_auth_intr_group ;
   struct config_group scsi_att_intr_port_group ;
};
#line 599 "include/target/target_core_base.h"
struct se_lun_acl {
   char initiatorname[224U] ;
   u64 mapped_lun ;
   struct se_node_acl *se_lun_nacl ;
   struct se_lun *se_lun ;
   struct config_group se_lun_group ;
   struct se_ml_stat_grps ml_stat_grps ;
};
#line 608 "include/target/target_core_base.h"
struct se_dev_entry {
   u64 mapped_lun ;
   u64 pr_res_key ;
   u64 creation_time ;
   u32 lun_flags ;
   u32 attach_count ;
   atomic_long_t total_cmds ;
   atomic_long_t read_bytes ;
   atomic_long_t write_bytes ;
   atomic_t ua_count ;
   struct kref pr_kref ;
   struct completion pr_comp ;
   struct se_lun_acl *se_lun_acl ;
   spinlock_t ua_lock ;
   struct se_lun *se_lun ;
   unsigned long deve_flags ;
   struct list_head alua_port_list ;
   struct list_head lun_link ;
   struct list_head ua_list ;
   struct hlist_node link ;
   struct callback_head callback_head ;
};
#line 634 "include/target/target_core_base.h"
struct se_dev_attrib {
   int emulate_model_alias ;
   int emulate_dpo ;
   int emulate_fua_write ;
   int emulate_fua_read ;
   int emulate_write_cache ;
   int emulate_ua_intlck_ctrl ;
   int emulate_tas ;
   int emulate_tpu ;
   int emulate_tpws ;
   int emulate_caw ;
   int emulate_3pc ;
   int pi_prot_format ;
   enum target_prot_type pi_prot_type ;
   enum target_prot_type hw_pi_prot_type ;
   int enforce_pr_isids ;
   int force_pr_aptpl ;
   int is_nonrot ;
   int emulate_rest_reord ;
   u32 hw_block_size ;
   u32 block_size ;
   u32 hw_max_sectors ;
   u32 optimal_sectors ;
   u32 hw_queue_depth ;
   u32 queue_depth ;
   u32 max_unmap_lba_count ;
   u32 max_unmap_block_desc_count ;
   u32 unmap_granularity ;
   u32 unmap_granularity_alignment ;
   u32 max_write_same_len ;
   u32 max_bytes_per_io ;
   struct se_device *da_dev ;
   struct config_group da_group ;
};
#line 669 "include/target/target_core_base.h"
struct se_port_stat_grps {
   struct config_group stat_group ;
   struct config_group scsi_port_group ;
   struct config_group scsi_tgt_port_group ;
   struct config_group scsi_transport_group ;
};
#line 676 "include/target/target_core_base.h"
struct scsi_port_stats {
   atomic_long_t cmd_pdus ;
   atomic_long_t tx_data_octets ;
   atomic_long_t rx_data_octets ;
};
#line 682 "include/target/target_core_base.h"
struct se_lun {
   u64 unpacked_lun ;
   u32 lun_link_magic ;
   u32 lun_access ;
   u32 lun_flags ;
   u32 lun_index ;
   u16 lun_rtpi ;
   atomic_t lun_acl_count ;
   struct se_device *lun_se_dev ;
   struct list_head lun_deve_list ;
   spinlock_t lun_deve_lock ;
   int lun_tg_pt_secondary_stat ;
   int lun_tg_pt_secondary_write_md ;
   atomic_t lun_tg_pt_secondary_offline ;
   struct mutex lun_tg_pt_md_mutex ;
   struct list_head lun_tg_pt_gp_link ;
   struct t10_alua_tg_pt_gp *lun_tg_pt_gp ;
   spinlock_t lun_tg_pt_gp_lock ;
   struct se_portal_group *lun_tpg ;
   struct scsi_port_stats lun_stats ;
   struct config_group lun_group ;
   struct se_port_stat_grps port_stat_grps ;
   struct completion lun_ref_comp ;
   struct percpu_ref lun_ref ;
   struct list_head lun_dev_link ;
   struct hlist_node link ;
   struct callback_head callback_head ;
};
#line 720 "include/target/target_core_base.h"
struct se_dev_stat_grps {
   struct config_group stat_group ;
   struct config_group scsi_dev_group ;
   struct config_group scsi_tgt_dev_group ;
   struct config_group scsi_lu_group ;
};
#line 727
struct se_hba;
#line 727
struct target_backend_ops;
#line 727 "include/target/target_core_base.h"
struct se_device {
   u32 dev_link_magic ;
   u16 dev_rpti_counter ;
   u32 dev_cur_ordered_id ;
   u32 dev_flags ;
   u32 queue_depth ;
   u64 dev_res_bin_isid ;
   u32 dev_index ;
   u64 creation_time ;
   atomic_long_t num_resets ;
   atomic_long_t num_cmds ;
   atomic_long_t read_bytes ;
   atomic_long_t write_bytes ;
   atomic_t simple_cmds ;
   atomic_t dev_ordered_id ;
   atomic_t dev_ordered_sync ;
   atomic_t dev_qf_count ;
   u32 export_count ;
   spinlock_t delayed_cmd_lock ;
   spinlock_t execute_task_lock ;
   spinlock_t dev_reservation_lock ;
   unsigned int dev_reservation_flags ;
   spinlock_t se_port_lock ;
   spinlock_t se_tmr_lock ;
   spinlock_t qf_cmd_lock ;
   struct semaphore caw_sem ;
   struct se_node_acl *dev_reserved_node_acl ;
   struct t10_alua_lu_gp_member *dev_alua_lu_gp_mem ;
   struct t10_pr_registration *dev_pr_res_holder ;
   struct list_head dev_sep_list ;
   struct list_head dev_tmr_list ;
   struct workqueue_struct *tmr_wq ;
   struct work_struct qf_work_queue ;
   struct list_head delayed_cmd_list ;
   struct list_head state_list ;
   struct list_head qf_cmd_list ;
   struct list_head g_dev_node ;
   struct se_hba *se_hba ;
   struct t10_wwn t10_wwn ;
   struct t10_alua t10_alua ;
   struct t10_reservation t10_pr ;
   struct se_dev_attrib dev_attrib ;
   struct config_group dev_group ;
   struct config_group dev_pr_group ;
   struct se_dev_stat_grps dev_stat_grps ;
   unsigned char dev_alias[512U] ;
   unsigned char udev_path[512U] ;
   struct target_backend_ops  const  *transport ;
   struct list_head dev_list ;
   struct se_lun xcopy_lun ;
   int prot_length ;
   u32 hba_index ;
   struct callback_head callback_head ;
};
#line 809
struct target_backend;
#line 809 "include/target/target_core_base.h"
struct se_hba {
   u16 hba_tpgt ;
   u32 hba_id ;
   u32 hba_flags ;
   u32 dev_count ;
   u32 hba_index ;
   void *hba_ptr ;
   struct list_head hba_node ;
   spinlock_t device_lock ;
   struct config_group hba_group ;
   struct mutex hba_access_mutex ;
   struct target_backend *backend ;
};
#line 831
struct se_wwn;
#line 831 "include/target/target_core_base.h"
struct se_portal_group {
   int proto_id ;
   u32 num_node_acls ;
   atomic_t tpg_pr_ref_count ;
   struct mutex acl_node_mutex ;
   spinlock_t session_lock ;
   struct mutex tpg_lun_mutex ;
   struct list_head se_tpg_node ;
   struct list_head acl_node_list ;
   struct hlist_head tpg_lun_hlist ;
   struct se_lun *tpg_virt_lun0 ;
   struct list_head tpg_sess_list ;
   struct target_core_fabric_ops  const  *se_tpg_tfo ;
   struct se_wwn *se_tpg_wwn ;
   struct config_group tpg_group ;
   struct config_group *tpg_default_groups[7U] ;
   struct config_group tpg_lun_group ;
   struct config_group tpg_np_group ;
   struct config_group tpg_acl_group ;
   struct config_group tpg_attrib_group ;
   struct config_group tpg_auth_group ;
   struct config_group tpg_param_group ;
};
#line 867
struct target_fabric_configfs;
#line 867 "include/target/target_core_base.h"
struct se_wwn {
   struct target_fabric_configfs *wwn_tf ;
   struct config_group wwn_group ;
   struct config_group *wwn_default_groups[2U] ;
   struct config_group fabric_stat_group ;
};
#line 816 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct qla_tgt {
   struct scsi_qla_host *vha ;
   struct qla_hw_data *ha ;
   int irq_cmd_count ;
   int datasegs_per_cmd ;
   int datasegs_per_cont ;
   int sg_tablesize ;
   unsigned char tgt_enable_64bit_addr : 1 ;
   unsigned char link_reinit_iocb_pending : 1 ;
   int tgt_stop ;
   int tgt_stopped ;
   int sess_count ;
   struct list_head sess_list ;
   struct list_head del_sess_list ;
   struct delayed_work sess_del_work ;
   spinlock_t sess_work_lock ;
   struct list_head sess_works_list ;
   struct work_struct sess_work ;
   struct imm_ntfy_from_isp link_reinit_iocb ;
   wait_queue_head_t waitQ ;
   int notify_ack_expected ;
   int abts_resp_expected ;
   int modify_lun_expected ;
   int ctio_srr_id ;
   int imm_srr_id ;
   spinlock_t srr_lock ;
   struct list_head srr_ctio_list ;
   struct list_head srr_imm_list ;
   struct work_struct srr_work ;
   atomic_t tgt_global_resets_count ;
   struct list_head tgt_list_entry ;
};
#line 878 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct qla_tgt_sess {
   uint16_t loop_id ;
   port_id_t s_id ;
   unsigned char conf_compl_supported : 1 ;
   unsigned char deleted : 1 ;
   unsigned char local : 1 ;
   struct se_session *se_sess ;
   struct scsi_qla_host *vha ;
   struct qla_tgt *tgt ;
   struct list_head sess_list_entry ;
   unsigned long expires ;
   struct list_head del_list_entry ;
   uint8_t port_name[8U] ;
   struct work_struct free_work ;
};
#line 901 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct qla_tgt_cmd {
   struct se_cmd se_cmd ;
   struct qla_tgt_sess *sess ;
   int state ;
   struct work_struct free_work ;
   struct work_struct work ;
   unsigned char sense_buffer[96U] ;
   unsigned char conf_compl_supported : 1 ;
   unsigned char sg_mapped : 1 ;
   unsigned char free_sg : 1 ;
   unsigned char aborted : 1 ;
   unsigned char write_data_transferred : 1 ;
   unsigned char ctx_dsd_alloced : 1 ;
   unsigned char q_full : 1 ;
   unsigned char term_exchg : 1 ;
   unsigned char cmd_sent_to_fw : 1 ;
   unsigned char cmd_in_wq : 1 ;
   struct scatterlist *sg ;
   int sg_cnt ;
   int bufflen ;
   int offset ;
   uint32_t unpacked_lun ;
   enum dma_data_direction dma_data_direction ;
   uint32_t reset_count ;
   uint16_t loop_id ;
   struct qla_tgt *tgt ;
   struct scsi_qla_host *vha ;
   struct list_head cmd_list ;
   struct atio_from_isp atio ;
   struct scatterlist *prot_sg ;
   uint32_t prot_sg_cnt ;
   uint32_t blk_sz ;
   struct crc_context *ctx ;
   uint64_t jiffies_at_alloc ;
   uint64_t jiffies_at_free ;
   uint32_t cmd_flags ;
};
#line 981 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
union __anonunion_orig_iocb_519 {
   struct atio_from_isp atio ;
   struct imm_ntfy_from_isp imm_ntfy ;
   struct abts_recv_from_24xx abts ;
};
#line 981 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct qla_tgt_mgmt_cmd {
   uint8_t tmr_func ;
   uint8_t fc_tm_rsp ;
   struct qla_tgt_sess *sess ;
   struct se_cmd se_cmd ;
   struct work_struct free_work ;
   unsigned int flags ;
   uint32_t reset_count ;
   union __anonunion_orig_iocb_519 orig_iocb ;
};
#line 19 "include/scsi/scsicam.h"
struct attribute_container {
   struct list_head node ;
   struct klist containers ;
   struct class *class ;
   struct attribute_group  const  *grp ;
   struct device_attribute **attrs ;
   int (*match)(struct attribute_container * , struct device * ) ;
   unsigned long flags ;
};
#line 71 "include/linux/attribute_container.h"
struct transport_container;
#line 43 "include/linux/transport_class.h"
struct transport_container {
   struct attribute_container ac ;
   struct attribute_group  const  *statistics ;
};
#line 100 "include/linux/transport_class.h"
struct scsi_transport_template {
   struct transport_container host_attrs ;
   struct transport_container target_attrs ;
   struct transport_container device_attrs ;
   int (*user_scan)(struct Scsi_Host * , uint  , uint  , u64  ) ;
   int device_size ;
   int device_private_offset ;
   int target_size ;
   int target_private_offset ;
   int host_size ;
   unsigned char create_work_queue : 1 ;
   void (*eh_strategy_handler)(struct Scsi_Host * ) ;
   enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd * ) ;
   int (*it_nexus_response)(struct Scsi_Host * , u64  , int  ) ;
   int (*tsk_mgmt_response)(struct Scsi_Host * , u64  , u64  , int  ) ;
};
#line 8540 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
typedef bool ldv_func_ret_type;
#line 8551 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
typedef bool ldv_func_ret_type___0;
#line 8562 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
typedef bool ldv_func_ret_type___1;
#line 8581 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
typedef bool ldv_func_ret_type___2;
#line 8592 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
typedef int ldv_func_ret_type___3;
#line 8606 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
typedef int ldv_func_ret_type___4;
#line 8617 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
typedef int ldv_func_ret_type___5;
#line 8660 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
typedef bool ldv_func_ret_type___6;
#line 8679 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
typedef bool ldv_func_ret_type___7;
#line 8690 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
typedef bool ldv_func_ret_type___8;
#line 8701 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
typedef bool ldv_func_ret_type___9;
#line 8720 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
typedef bool ldv_func_ret_type___10;
#line 8739 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
typedef struct Scsi_Host *ldv_func_ret_type___11;
#line 8761 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
typedef int ldv_func_ret_type___12;
#line 8774 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
typedef int ldv_func_ret_type___13;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 252 "include/scsi/scsi_transport_fc.h"
struct fc_rport_identifiers {
   u64 node_name ;
   u64 port_name ;
   u32 port_id ;
   u32 roles ;
};
#line 84 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct nvram_24xx {
   uint8_t id[4U] ;
   uint16_t nvram_version ;
   uint16_t reserved_0 ;
   uint16_t version ;
   uint16_t reserved_1 ;
   __le16 frame_payload_size ;
   uint16_t execution_throttle ;
   uint16_t exchange_count ;
   uint16_t hard_address ;
   uint8_t port_name[8U] ;
   uint8_t node_name[8U] ;
   uint16_t login_retry_count ;
   uint16_t link_down_on_nos ;
   uint16_t interrupt_delay_timer ;
   uint16_t login_timeout ;
   uint32_t firmware_options_1 ;
   uint32_t firmware_options_2 ;
   uint32_t firmware_options_3 ;
   uint16_t seriallink_options[4U] ;
   uint16_t reserved_2[16U] ;
   uint16_t reserved_3[16U] ;
   uint16_t reserved_4[16U] ;
   uint16_t reserved_5[16U] ;
   uint16_t reserved_6[16U] ;
   uint16_t reserved_7[16U] ;
   uint32_t host_p ;
   uint8_t alternate_port_name[8U] ;
   uint8_t alternate_node_name[8U] ;
   uint8_t boot_port_name[8U] ;
   uint16_t boot_lun_number ;
   uint16_t reserved_8 ;
   uint8_t alt1_boot_port_name[8U] ;
   uint16_t alt1_boot_lun_number ;
   uint16_t reserved_9 ;
   uint8_t alt2_boot_port_name[8U] ;
   uint16_t alt2_boot_lun_number ;
   uint16_t reserved_10 ;
   uint8_t alt3_boot_port_name[8U] ;
   uint16_t alt3_boot_lun_number ;
   uint16_t reserved_11 ;
   uint32_t efi_parameters ;
   uint8_t reset_delay ;
   uint8_t reserved_12 ;
   uint16_t reserved_13 ;
   uint16_t boot_id_number ;
   uint16_t reserved_14 ;
   uint16_t max_luns_per_target ;
   uint16_t reserved_15 ;
   uint16_t port_down_retry_count ;
   uint16_t link_down_timeout ;
   uint16_t fcode_parameter ;
   uint16_t reserved_16[3U] ;
   uint8_t prev_drv_ver_major ;
   uint8_t prev_drv_ver_submajob ;
   uint8_t prev_drv_ver_minor ;
   uint8_t prev_drv_ver_subminor ;
   uint16_t prev_bios_ver_major ;
   uint16_t prev_bios_ver_minor ;
   uint16_t prev_efi_ver_major ;
   uint16_t prev_efi_ver_minor ;
   uint16_t prev_fw_ver_major ;
   uint8_t prev_fw_ver_minor ;
   uint8_t prev_fw_ver_subminor ;
   uint16_t reserved_17[8U] ;
   uint16_t reserved_18[16U] ;
   uint16_t reserved_19[16U] ;
   uint16_t reserved_20[16U] ;
   uint8_t model_name[16U] ;
   uint16_t reserved_21[2U] ;
   uint16_t pcie_table_sig ;
   uint16_t pcie_table_offset ;
   uint16_t subsystem_vendor_id ;
   uint16_t subsystem_device_id ;
   uint32_t checksum ;
};
#line 265 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct init_cb_24xx {
   uint16_t version ;
   uint16_t reserved_1 ;
   uint16_t frame_payload_size ;
   uint16_t execution_throttle ;
   uint16_t exchange_count ;
   uint16_t hard_address ;
   uint8_t port_name[8U] ;
   uint8_t node_name[8U] ;
   uint16_t response_q_inpointer ;
   uint16_t request_q_outpointer ;
   uint16_t login_retry_count ;
   uint16_t prio_request_q_outpointer ;
   uint16_t response_q_length ;
   uint16_t request_q_length ;
   uint16_t link_down_on_nos ;
   uint16_t prio_request_q_length ;
   uint32_t request_q_address[2U] ;
   uint32_t response_q_address[2U] ;
   uint32_t prio_request_q_address[2U] ;
   uint16_t msix ;
   uint16_t msix_atio ;
   uint8_t reserved_2[4U] ;
   uint16_t atio_q_inpointer ;
   uint16_t atio_q_length ;
   uint32_t atio_q_address[2U] ;
   uint16_t interrupt_delay_timer ;
   uint16_t login_timeout ;
   uint32_t firmware_options_1 ;
   uint32_t firmware_options_2 ;
   uint32_t firmware_options_3 ;
   uint16_t qos ;
   uint16_t rid ;
   uint8_t reserved_3[20U] ;
};
#line 1099 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct mid_conf_entry_24xx {
   uint16_t reserved_1 ;
   uint8_t options ;
   uint8_t hard_address ;
   uint8_t port_name[8U] ;
   uint8_t node_name[8U] ;
};
#line 1159 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct mid_init_cb_24xx {
   struct init_cb_24xx init_cb ;
   uint16_t count ;
   uint16_t options ;
   struct mid_conf_entry_24xx entries[256U] ;
};
#line 1545 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct nvram_81xx {
   uint8_t id[4U] ;
   uint16_t nvram_version ;
   uint16_t reserved_0 ;
   uint16_t version ;
   uint16_t reserved_1 ;
   uint16_t frame_payload_size ;
   uint16_t execution_throttle ;
   uint16_t exchange_count ;
   uint16_t reserved_2 ;
   uint8_t port_name[8U] ;
   uint8_t node_name[8U] ;
   uint16_t login_retry_count ;
   uint16_t reserved_3 ;
   uint16_t interrupt_delay_timer ;
   uint16_t login_timeout ;
   uint32_t firmware_options_1 ;
   uint32_t firmware_options_2 ;
   uint32_t firmware_options_3 ;
   uint16_t reserved_4[4U] ;
   uint8_t enode_mac[6U] ;
   uint16_t reserved_5[5U] ;
   uint16_t reserved_6[24U] ;
   uint16_t ex_version ;
   uint8_t prio_fcf_matching_flags ;
   uint8_t reserved_6_1[3U] ;
   uint16_t pri_fcf_vlan_id ;
   uint8_t pri_fcf_fabric_name[8U] ;
   uint16_t reserved_6_2[7U] ;
   uint8_t spma_mac_addr[6U] ;
   uint16_t reserved_6_3[14U] ;
   uint16_t reserved_7[32U] ;
   uint32_t host_p ;
   uint8_t alternate_port_name[8U] ;
   uint8_t alternate_node_name[8U] ;
   uint8_t boot_port_name[8U] ;
   uint16_t boot_lun_number ;
   uint16_t reserved_8 ;
   uint8_t alt1_boot_port_name[8U] ;
   uint16_t alt1_boot_lun_number ;
   uint16_t reserved_9 ;
   uint8_t alt2_boot_port_name[8U] ;
   uint16_t alt2_boot_lun_number ;
   uint16_t reserved_10 ;
   uint8_t alt3_boot_port_name[8U] ;
   uint16_t alt3_boot_lun_number ;
   uint16_t reserved_11 ;
   uint32_t efi_parameters ;
   uint8_t reset_delay ;
   uint8_t reserved_12 ;
   uint16_t reserved_13 ;
   uint16_t boot_id_number ;
   uint16_t reserved_14 ;
   uint16_t max_luns_per_target ;
   uint16_t reserved_15 ;
   uint16_t port_down_retry_count ;
   uint16_t link_down_timeout ;
   uint16_t fcode_parameter ;
   uint16_t reserved_16[3U] ;
   uint8_t reserved_17[4U] ;
   uint16_t reserved_18[5U] ;
   uint8_t reserved_19[2U] ;
   uint16_t reserved_20[8U] ;
   uint8_t reserved_21[16U] ;
   uint16_t reserved_22[3U] ;
   uint8_t enhanced_features ;
   uint8_t reserved_23 ;
   uint16_t reserved_24[4U] ;
   uint16_t reserved_25[32U] ;
   uint8_t model_name[16U] ;
   uint16_t feature_mask_l ;
   uint16_t feature_mask_h ;
   uint16_t reserved_26[2U] ;
   uint16_t subsystem_vendor_id ;
   uint16_t subsystem_device_id ;
   uint32_t checksum ;
};
#line 1751 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct init_cb_81xx {
   uint16_t version ;
   uint16_t reserved_1 ;
   uint16_t frame_payload_size ;
   uint16_t execution_throttle ;
   uint16_t exchange_count ;
   uint16_t reserved_2 ;
   uint8_t port_name[8U] ;
   uint8_t node_name[8U] ;
   uint16_t response_q_inpointer ;
   uint16_t request_q_outpointer ;
   uint16_t login_retry_count ;
   uint16_t prio_request_q_outpointer ;
   uint16_t response_q_length ;
   uint16_t request_q_length ;
   uint16_t reserved_3 ;
   uint16_t prio_request_q_length ;
   uint32_t request_q_address[2U] ;
   uint32_t response_q_address[2U] ;
   uint32_t prio_request_q_address[2U] ;
   uint8_t reserved_4[8U] ;
   uint16_t atio_q_inpointer ;
   uint16_t atio_q_length ;
   uint32_t atio_q_address[2U] ;
   uint16_t interrupt_delay_timer ;
   uint16_t login_timeout ;
   uint32_t firmware_options_1 ;
   uint32_t firmware_options_2 ;
   uint32_t firmware_options_3 ;
   uint8_t reserved_5[8U] ;
   uint8_t enode_mac[6U] ;
   uint8_t reserved_6[10U] ;
};
#line 1490 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_nvram_t_326 {
   uint8_t id[4U] ;
   uint8_t nvram_version ;
   uint8_t reserved_0 ;
   uint8_t parameter_block_version ;
   uint8_t reserved_1 ;
   uint8_t firmware_options[2U] ;
   uint16_t frame_payload_size ;
   uint16_t max_iocb_allocation ;
   uint16_t execution_throttle ;
   uint8_t retry_count ;
   uint8_t retry_delay ;
   uint8_t port_name[8U] ;
   uint16_t hard_address ;
   uint8_t inquiry_data ;
   uint8_t login_timeout ;
   uint8_t node_name[8U] ;
   uint8_t add_firmware_options[2U] ;
   uint8_t response_accumulation_timer ;
   uint8_t interrupt_delay_timer ;
   uint8_t special_options[2U] ;
   uint8_t reserved_2[22U] ;
   uint8_t seriallink_options[4U] ;
   uint8_t host_p[2U] ;
   uint8_t boot_node_name[8U] ;
   uint8_t boot_lun_number ;
   uint8_t reset_delay ;
   uint8_t port_down_retry_count ;
   uint8_t boot_id_number ;
   uint16_t max_luns_per_target ;
   uint8_t fcode_boot_port_name[8U] ;
   uint8_t alternate_port_name[8U] ;
   uint8_t alternate_node_name[8U] ;
   uint8_t efi_parameters ;
   uint8_t link_down_timeout ;
   uint8_t adapter_id[16U] ;
   uint8_t alt1_boot_node_name[8U] ;
   uint16_t alt1_boot_lun_number ;
   uint8_t alt2_boot_node_name[8U] ;
   uint16_t alt2_boot_lun_number ;
   uint8_t alt3_boot_node_name[8U] ;
   uint16_t alt3_boot_lun_number ;
   uint8_t alt4_boot_node_name[8U] ;
   uint16_t alt4_boot_lun_number ;
   uint8_t alt5_boot_node_name[8U] ;
   uint16_t alt5_boot_lun_number ;
   uint8_t alt6_boot_node_name[8U] ;
   uint16_t alt6_boot_lun_number ;
   uint8_t alt7_boot_node_name[8U] ;
   uint16_t alt7_boot_lun_number ;
   uint8_t reserved_3[2U] ;
   uint8_t model_number[16U] ;
   uint8_t oem_specific[16U] ;
   uint8_t adapter_features[2U] ;
   uint8_t reserved_4[16U] ;
   uint16_t subsystem_vendor_id_2200 ;
   uint16_t subsystem_device_id_2200 ;
   uint8_t reserved_5 ;
   uint8_t checksum ;
};
#line 1490 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_nvram_t_326 nvram_t;
#line 1970 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_sw_info_t_346 {
   port_id_t d_id ;
   uint8_t node_name[8U] ;
   uint8_t port_name[8U] ;
   uint8_t fabric_port_name[8U] ;
   uint16_t fp_speed ;
   uint8_t fc4_type ;
};
#line 1970 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_sw_info_t_346 sw_info_t;
#line 428 "./arch/x86/include/asm/pgtable_types.h"
struct paravirt_callee_save {
   void *func ;
};
#line 197 "./arch/x86/include/asm/paravirt_types.h"
struct pv_irq_ops {
   struct paravirt_callee_save save_fl ;
   struct paravirt_callee_save restore_fl ;
   struct paravirt_callee_save irq_disable ;
   struct paravirt_callee_save irq_enable ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
   void (*adjust_exception_frame)(void) ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 134 "./include/uapi/scsi/scsi_netlink.h"
enum fc_tgtid_binding_type {
    FC_TGTID_BIND_NONE = 0,
    FC_TGTID_BIND_BY_WWPN = 1,
    FC_TGTID_BIND_BY_WWNN = 2,
    FC_TGTID_BIND_BY_ID = 3
} ;
#line 462 "include/scsi/scsi_transport_fc.h"
struct fc_host_attrs {
   u64 node_name ;
   u64 port_name ;
   u64 permanent_port_name ;
   u32 supported_classes ;
   u8 supported_fc4s[32U] ;
   u32 supported_speeds ;
   u32 maxframe_size ;
   u16 max_npiv_vports ;
   char serial_number[80U] ;
   char manufacturer[80U] ;
   char model[256U] ;
   char model_description[256U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char firmware_version[64U] ;
   char optionrom_version[64U] ;
   u32 port_id ;
   enum fc_port_type port_type ;
   enum fc_port_state port_state ;
   u8 active_fc4s[32U] ;
   u32 speed ;
   u64 fabric_name ;
   char symbolic_name[256U] ;
   char system_hostname[256U] ;
   u32 dev_loss_tmo ;
   enum fc_tgtid_binding_type tgtid_bind_type ;
   struct list_head rports ;
   struct list_head rport_bindings ;
   struct list_head vports ;
   u32 next_rport_number ;
   u32 next_target_id ;
   u32 next_vport_number ;
   u16 npiv_vports_inuse ;
   char work_q_name[20U] ;
   struct workqueue_struct *work_q ;
   char devloss_work_q_name[20U] ;
   struct workqueue_struct *devloss_work_q ;
   struct request_queue *rqst_q ;
};
#line 598 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct port_database_24xx {
   uint16_t flags ;
   uint8_t current_login_state ;
   uint8_t last_login_state ;
   uint8_t hard_address[3U] ;
   uint8_t reserved_1 ;
   uint8_t port_id[3U] ;
   uint8_t sequence_id ;
   uint16_t port_timer ;
   uint16_t nport_handle ;
   uint16_t receive_data_size ;
   uint16_t reserved_2 ;
   uint8_t prli_svc_param_word_0[2U] ;
   uint8_t prli_svc_param_word_3[2U] ;
   uint8_t port_name[8U] ;
   uint8_t node_name[8U] ;
   uint8_t reserved_3[24U] ;
};
#line 546 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct sts_entry_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t comp_status ;
   uint16_t ox_id ;
   uint32_t residual_len ;
   uint16_t reserved_1 ;
   uint16_t state_flags ;
   uint16_t retry_delay ;
   uint16_t scsi_status ;
   uint32_t rsp_residual_count ;
   uint32_t sense_len ;
   uint32_t rsp_data_len ;
   uint8_t data[28U] ;
};
#line 768 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct logio_entry_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t comp_status ;
   uint16_t nport_handle ;
   uint16_t control_flags ;
   uint8_t vp_index ;
   uint8_t reserved_1 ;
   uint8_t port_id[3U] ;
   uint8_t rsp_size ;
   uint32_t io_parameter[11U] ;
};
#line 814 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct tsk_mgmt_entry {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t handle_count ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t nport_handle ;
   uint16_t reserved_1 ;
   uint16_t delay ;
   uint16_t timeout ;
   struct scsi_lun lun ;
   uint32_t control_flags ;
   uint8_t reserved_2[20U] ;
   uint8_t port_id[3U] ;
   uint8_t vp_index ;
   uint8_t reserved_3[12U] ;
};
#line 865 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct abort_entry_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t handle_count ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t nport_handle ;
   uint16_t options ;
   uint32_t handle_to_abort ;
   uint16_t req_que_no ;
   uint8_t reserved_1[30U] ;
   uint8_t port_id[3U] ;
   uint8_t vp_index ;
   uint8_t reserved_2[12U] ;
};
#line 1185 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct vp_ctrl_entry_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t vp_idx_failed ;
   uint16_t comp_status ;
   uint16_t command ;
   uint16_t vp_count ;
   uint8_t vp_idx_map[16U] ;
   uint16_t flags ;
   uint16_t id ;
   uint16_t reserved_4 ;
   uint16_t hopct ;
   uint8_t reserved_5[24U] ;
};
#line 1221 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct vp_config_entry_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t handle_count ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t flags ;
   uint16_t comp_status ;
   uint8_t command ;
   uint8_t vp_count ;
   uint8_t vp_index1 ;
   uint8_t vp_index2 ;
   uint8_t options_idx1 ;
   uint8_t hard_address_idx1 ;
   uint16_t reserved_vp1 ;
   uint8_t port_name_idx1[8U] ;
   uint8_t node_name_idx1[8U] ;
   uint8_t options_idx2 ;
   uint8_t hard_address_idx2 ;
   uint16_t reserved_vp2 ;
   uint8_t port_name_idx2[8U] ;
   uint8_t node_name_idx2[8U] ;
   uint16_t id ;
   uint16_t reserved_4 ;
   uint16_t hopct ;
   uint8_t reserved_5[2U] ;
};
#line 1271 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct vp_rpt_id_entry_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t vp_count ;
   uint16_t vp_idx ;
   uint8_t port_id[3U] ;
   uint8_t format ;
   uint8_t vp_idx_map[16U] ;
   uint8_t reserved_4[32U] ;
};
#line 1422 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct verify_chip_entry_84xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_defined ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t options ;
   uint16_t reserved_1 ;
   uint16_t data_seg_cnt ;
   uint16_t reserved_2[3U] ;
   uint32_t fw_ver ;
   uint32_t exchange_address ;
   uint32_t reserved_3[3U] ;
   uint32_t fw_size ;
   uint32_t fw_seq_size ;
   uint32_t relative_offset ;
   uint32_t dseg_address[2U] ;
   uint32_t dseg_length ;
};
#line 1472 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct verify_chip_rsp_84xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_defined ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t comp_status ;
   uint16_t failure_code ;
   uint16_t reserved_1[4U] ;
   uint32_t fw_ver ;
   uint32_t exchange_address ;
   uint32_t reserved_2[6U] ;
};
#line 402 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct msg_echo_lb {
   dma_addr_t send_dma ;
   dma_addr_t rcv_dma ;
   uint16_t req_sg_cnt ;
   uint16_t rsp_sg_cnt ;
   uint16_t options ;
   uint32_t transfer_size ;
   uint32_t iteration_count ;
};
#line 1091 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_port_database_t_324 {
   uint8_t options ;
   uint8_t control ;
   uint8_t master_state ;
   uint8_t slave_state ;
   uint8_t reserved[2U] ;
   uint8_t hard_address ;
   uint8_t reserved_1 ;
   uint8_t port_id[4U] ;
   uint8_t node_name[8U] ;
   uint8_t port_name[8U] ;
   uint16_t execution_throttle ;
   uint16_t execution_count ;
   uint8_t reset_count ;
   uint8_t reserved_2 ;
   uint16_t resource_allocation ;
   uint16_t current_allocation ;
   uint16_t queue_head ;
   uint16_t queue_tail ;
   uint16_t transmit_execution_list_next ;
   uint16_t transmit_execution_list_previous ;
   uint16_t common_features ;
   uint16_t total_concurrent_sequences ;
   uint16_t RO_by_information_category ;
   uint8_t recipient ;
   uint8_t initiator ;
   uint16_t receive_data_size ;
   uint16_t concurrent_sequences ;
   uint16_t open_sequences_per_exchange ;
   uint16_t lun_abort_flags ;
   uint16_t lun_stop_flags ;
   uint16_t stop_queue_head ;
   uint16_t stop_queue_tail ;
   uint16_t port_retry_timer ;
   uint16_t next_sequence_id ;
   uint16_t frame_count ;
   uint16_t PRLI_payload_length ;
   uint8_t prli_svc_param_word_0[2U] ;
   uint8_t prli_svc_param_word_3[2U] ;
   uint16_t loop_id ;
   uint16_t extended_lun_info_list_pointer ;
   uint16_t extended_lun_stop_list_pointer ;
};
#line 1091 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_port_database_t_324 port_database_t;
#line 1215 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct link_statistics {
   uint32_t link_fail_cnt ;
   uint32_t loss_sync_cnt ;
   uint32_t loss_sig_cnt ;
   uint32_t prim_seq_err_cnt ;
   uint32_t inval_xmit_word_cnt ;
   uint32_t inval_crc_cnt ;
   uint32_t lip_cnt ;
   uint32_t unused1[26U] ;
   uint32_t tx_frames ;
   uint32_t rx_frames ;
   uint32_t discarded_frames ;
   uint32_t dropped_frames ;
   uint32_t unused2[1U] ;
   uint32_t nos_rcvd ;
};
#line 1725 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_sts_entry_t_338 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t scsi_status ;
   uint16_t comp_status ;
   uint16_t state_flags ;
   uint16_t status_flags ;
   uint16_t rsp_info_len ;
   uint16_t req_sense_length ;
   uint32_t residual_length ;
   uint8_t rsp_info[8U] ;
   uint8_t req_sense_data[32U] ;
};
#line 1725 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_sts_entry_t_338 sts_entry_t;
#line 888 "include/target/target_core_base.h"
struct qla_port_24xx_data {
   uint8_t port_name[8U] ;
   uint16_t loop_id ;
   uint16_t reserved ;
};
#line 2692 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
union __anonunion_p_520 {
   struct tsk_mgmt_entry tsk ;
   struct sts_entry_24xx sts ;
};
#line 2692 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
struct tsk_mgmt_cmd {
   union __anonunion_p_520 p ;
};
#line 3679 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
union __anonunion_p_521 {
   struct verify_chip_entry_84xx req ;
   struct verify_chip_rsp_84xx rsp ;
};
#line 3679 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
struct cs84xx_mgmt_cmd {
   union __anonunion_p_521 p ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 384 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct cmd_bidir {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t nport_handle ;
   uint16_t timeout ;
   uint16_t wr_dseg_count ;
   uint16_t rd_dseg_count ;
   struct scsi_lun lun ;
   uint16_t control_flags ;
   uint16_t fcp_cmnd_dseg_len ;
   uint32_t fcp_cmnd_dseg_address[2U] ;
   uint16_t reserved[2U] ;
   uint32_t rd_byte_count ;
   uint32_t wr_byte_count ;
   uint8_t port_id[3U] ;
   uint8_t vp_index ;
   uint32_t fcp_data_dseg_address[2U] ;
   uint16_t fcp_data_dseg_len ;
};
#line 425 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct cmd_type_6 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t nport_handle ;
   uint16_t timeout ;
   uint16_t dseg_count ;
   uint16_t fcp_rsp_dsd_len ;
   struct scsi_lun lun ;
   uint16_t control_flags ;
   uint16_t fcp_cmnd_dseg_len ;
   uint32_t fcp_cmnd_dseg_address[2U] ;
   uint32_t fcp_rsp_dseg_address[2U] ;
   uint32_t byte_count ;
   uint8_t port_id[3U] ;
   uint8_t vp_index ;
   uint32_t fcp_data_dseg_address[2U] ;
   uint32_t fcp_data_dseg_len ;
};
#line 463 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct cmd_type_7 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t nport_handle ;
   uint16_t timeout ;
   uint16_t dseg_count ;
   uint16_t reserved_1 ;
   struct scsi_lun lun ;
   uint16_t task_mgmt_flags ;
   uint8_t task ;
   uint8_t crn ;
   uint8_t fcp_cdb[16U] ;
   uint32_t byte_count ;
   uint8_t port_id[3U] ;
   uint8_t vp_index ;
   uint32_t dseg_0_address[2U] ;
   uint32_t dseg_0_len ;
};
#line 510 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct cmd_type_crc_2 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t nport_handle ;
   uint16_t timeout ;
   uint16_t dseg_count ;
   uint16_t fcp_rsp_dseg_len ;
   struct scsi_lun lun ;
   uint16_t control_flags ;
   uint16_t fcp_cmnd_dseg_len ;
   uint32_t fcp_cmnd_dseg_address[2U] ;
   uint32_t fcp_rsp_dseg_address[2U] ;
   uint32_t byte_count ;
   uint8_t port_id[3U] ;
   uint8_t vp_index ;
   uint32_t crc_context_address[2U] ;
   uint16_t crc_context_len ;
   uint16_t reserved_1 ;
};
#line 580 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct mrk_entry_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t handle_count ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t nport_handle ;
   uint8_t modifier ;
   uint8_t reserved_1 ;
   uint8_t reserved_2 ;
   uint8_t vp_index ;
   uint16_t reserved_3 ;
   uint8_t lun[8U] ;
   uint8_t reserved_4[40U] ;
};
#line 631 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct ct_entry_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t comp_status ;
   uint16_t nport_handle ;
   uint16_t cmd_dsd_count ;
   uint8_t vp_index ;
   uint8_t reserved_1 ;
   uint16_t timeout ;
   uint16_t reserved_2 ;
   uint16_t rsp_dsd_count ;
   uint8_t reserved_3[10U] ;
   uint32_t rsp_byte_count ;
   uint32_t cmd_byte_count ;
   uint32_t dseg_0_address[2U] ;
   uint32_t dseg_0_len ;
   uint32_t dseg_1_address[2U] ;
   uint32_t dseg_1_len ;
};
#line 668 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct els_entry_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t reserved_1 ;
   uint16_t nport_handle ;
   uint16_t tx_dsd_count ;
   uint8_t vp_index ;
   uint8_t sof_type ;
   uint32_t rx_xchg_address ;
   uint16_t rx_dsd_count ;
   uint8_t opcode ;
   uint8_t reserved_2 ;
   uint8_t port_id[3U] ;
   uint8_t reserved_3 ;
   uint16_t reserved_4 ;
   uint16_t control_flags ;
   uint32_t rx_byte_count ;
   uint32_t tx_byte_count ;
   uint32_t tx_address[2U] ;
   uint32_t tx_len ;
   uint32_t rx_address[2U] ;
   uint32_t rx_len ;
};
#line 1612 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_cont_entry_t_333 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t reserved ;
   uint32_t dseg_0_address ;
   uint32_t dseg_0_length ;
   uint32_t dseg_1_address ;
   uint32_t dseg_1_length ;
   uint32_t dseg_2_address ;
   uint32_t dseg_2_length ;
   uint32_t dseg_3_address ;
   uint32_t dseg_3_length ;
   uint32_t dseg_4_address ;
   uint32_t dseg_4_length ;
   uint32_t dseg_5_address ;
   uint32_t dseg_5_length ;
   uint32_t dseg_6_address ;
   uint32_t dseg_6_length ;
};
#line 1612 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_cont_entry_t_333 cont_entry_t;
#line 1633 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_cont_a64_entry_t_334 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t dseg_0_address[2U] ;
   uint32_t dseg_0_length ;
   uint32_t dseg_1_address[2U] ;
   uint32_t dseg_1_length ;
   uint32_t dseg_2_address[2U] ;
   uint32_t dseg_2_length ;
   uint32_t dseg_3_address[2U] ;
   uint32_t dseg_3_length ;
   uint32_t dseg_4_address[2U] ;
   uint32_t dseg_4_length ;
};
#line 1633 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_cont_a64_entry_t_334 cont_a64_entry_t;
#line 1856 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_mrk_entry_t_342 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t handle_count ;
   uint8_t entry_status ;
   uint32_t sys_define_2 ;
   target_id_t target ;
   uint8_t modifier ;
   uint8_t reserved_1 ;
   uint16_t sequence_number ;
   uint16_t lun ;
   uint8_t reserved_2[48U] ;
};
#line 1856 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_mrk_entry_t_342 mrk_entry_t;
#line 1887 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct mbx_entry {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define1 ;
   uint8_t entry_status ;
   uint32_t handle ;
   target_id_t loop_id ;
   uint16_t status ;
   uint16_t state_flags ;
   uint16_t status_flags ;
   uint32_t sys_define2[2U] ;
   uint16_t mb0 ;
   uint16_t mb1 ;
   uint16_t mb2 ;
   uint16_t mb3 ;
   uint16_t mb6 ;
   uint16_t mb7 ;
   uint16_t mb9 ;
   uint16_t mb10 ;
   uint32_t reserved_2[2U] ;
   uint8_t node_name[8U] ;
   uint8_t port_name[8U] ;
};
#line 90 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct tsk_mgmt_entry_fx00 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   __le32 handle ;
   uint32_t reserved_0 ;
   __le16 tgt_id ;
   uint16_t reserved_1 ;
   uint16_t reserved_3 ;
   uint16_t reserved_4 ;
   struct scsi_lun lun ;
   __le32 control_flags ;
   uint8_t reserved_2[32U] ;
};
#line 114 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct abort_iocb_entry_fx00 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   __le32 handle ;
   __le32 reserved_0 ;
   __le16 tgt_id_sts ;
   __le16 options ;
   __le32 abort_handle ;
   __le32 reserved_2 ;
   __le16 req_que_no ;
   uint8_t reserved_1[38U] ;
};
#line 158 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct fxdisc_entry_fx00 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   __le32 handle ;
   __le32 reserved_0 ;
   __le16 func_num ;
   __le16 req_xfrcnt ;
   __le16 req_dsdcnt ;
   __le16 rsp_xfrcnt ;
   __le16 rsp_dsdcnt ;
   uint8_t flags ;
   uint8_t reserved_1 ;
   __le32 dseg_rq_address[2U] ;
   __le32 dseg_rq_len ;
   __le32 dseg_rsp_address[2U] ;
   __le32 dseg_rsp_len ;
   __le32 dataword ;
   __le32 adapid ;
   __le32 adapid_hi ;
   __le32 dataword_extra ;
};
#line 757 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
struct fw_dif_context {
   uint32_t ref_tag ;
   uint16_t app_tag ;
   uint8_t ref_tag_mask[4U] ;
   uint8_t app_tag_mask[2U] ;
};
#line 859 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
struct qla2_sgx {
   dma_addr_t dma_addr ;
   uint32_t dma_len ;
   uint32_t tot_bytes ;
   struct scatterlist *cur_sg ;
   uint32_t bytes_consumed ;
   uint32_t num_bytes ;
   uint32_t tot_partial ;
   uint32_t num_sg ;
   srb_t *sp ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 35 "include/linux/dmapool.h"
struct msix_entry {
   u32 vector ;
   u16 entry ;
};
#line 720 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct els_sts_entry_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t comp_status ;
   uint16_t nport_handle ;
   uint16_t reserved_1 ;
   uint8_t vp_index ;
   uint8_t sof_type ;
   uint32_t rx_xchg_address ;
   uint16_t reserved_2 ;
   uint8_t opcode ;
   uint8_t reserved_3 ;
   uint8_t port_id[3U] ;
   uint8_t reserved_4 ;
   uint16_t reserved_5 ;
   uint16_t control_flags ;
   uint32_t total_byte_count ;
   uint32_t error_subcode_1 ;
   uint32_t error_subcode_2 ;
};
#line 1927 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct sd_dif_tuple {
   __be16 guard_tag ;
   __be16 app_tag ;
   __be32 ref_tag ;
};
#line 1806 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_sts_cont_entry_t_339 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint8_t data[60U] ;
};
#line 1806 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_sts_cont_entry_t_339 sts_cont_entry_t;
#line 1819 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_sts21_entry_t_340 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t handle_count ;
   uint8_t entry_status ;
   uint32_t handle[15U] ;
};
#line 1819 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_sts21_entry_t_340 sts21_entry_t;
#line 1832 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_sts22_entry_t_341 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t handle_count ;
   uint8_t entry_status ;
   uint16_t handle[30U] ;
};
#line 1832 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_sts22_entry_t_341 sts22_entry_t;
#line 2916 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
struct qla_init_msix_entry {
   char const   *name ;
   irqreturn_t (*handler)(int  , void * ) ;
};
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
typedef bool ldv_func_ret_type___14;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 23 "include/uapi/linux/utsname.h"
struct new_utsname {
   char sysname[65U] ;
   char nodename[65U] ;
   char release[65U] ;
   char version[65U] ;
   char machine[65U] ;
   char domainname[65U] ;
};
#line 22 "include/linux/utsname.h"
struct uts_namespace {
   struct kref kref ;
   struct new_utsname name ;
   struct user_namespace *user_ns ;
   struct ns_common ns ;
};
#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.o.c"
struct va_list;
#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.o.c"

#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 63 "include/linux/printk.h"
struct va_format {
   char const   *fmt ;
   va_list *va ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 215 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
struct qla2xxx_fce_chain {
   uint32_t type ;
   uint32_t chain_size ;
   uint32_t size ;
   uint32_t addr_l ;
   uint32_t addr_h ;
   uint32_t eregs[8U] ;
};
#line 234 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
struct qla2xxx_mq_chain {
   uint32_t type ;
   uint32_t chain_size ;
   uint32_t count ;
   uint32_t qregs[128U] ;
};
#line 242 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
struct qla2xxx_mqueue_header {
   uint32_t queue ;
   uint32_t number ;
   uint32_t size ;
};
#line 251 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
struct qla2xxx_mqueue_chain {
   uint32_t type ;
   uint32_t chain_size ;
};
#line 516 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
struct __anonstruct_aq_521 {
   int length ;
   void *ring ;
};
#line 516 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
struct __anonstruct_aqp_522 {
   int length ;
   void *ring ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 141 "./include/uapi/scsi/scsi_netlink.h"
struct fc_vport_identifiers {
   u64 node_name ;
   u64 port_name ;
   u32 roles ;
   bool disable ;
   enum fc_port_type vport_type ;
   char symbolic_name[64U] ;
};
#line 1318 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct qla_fdt_layout {
   uint8_t sig[4U] ;
   uint16_t version ;
   uint16_t len ;
   uint16_t checksum ;
   uint8_t unused1[2U] ;
   uint8_t model[16U] ;
   uint16_t man_id ;
   uint16_t id ;
   uint8_t flags ;
   uint8_t erase_cmd ;
   uint8_t alt_erase_cmd ;
   uint8_t wrt_enable_cmd ;
   uint8_t wrt_enable_bits ;
   uint8_t wrt_sts_reg_cmd ;
   uint8_t unprotect_sec_cmd ;
   uint8_t read_man_id_cmd ;
   uint32_t block_size ;
   uint32_t alt_block_size ;
   uint32_t flash_size ;
   uint32_t wrt_enable_data ;
   uint8_t read_id_addr_len ;
   uint8_t wrt_disable_bits ;
   uint8_t read_dev_id_len ;
   uint8_t chip_erase_cmd ;
   uint16_t read_timeout ;
   uint8_t protect_sec_cmd ;
   uint8_t unused2[65U] ;
};
#line 1352 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct qla_flt_location {
   uint8_t sig[4U] ;
   uint16_t start_lo ;
   uint16_t start_hi ;
   uint8_t version ;
   uint8_t unused[5U] ;
   uint16_t checksum ;
};
#line 1363 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct qla_flt_header {
   uint16_t version ;
   uint16_t length ;
   uint16_t checksum ;
   uint16_t unused ;
};
#line 1370 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct qla_flt_region {
   uint32_t code ;
   uint32_t size ;
   uint32_t start ;
   uint32_t end ;
};
#line 1402 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct qla_npiv_header {
   uint8_t sig[2U] ;
   uint16_t version ;
   uint16_t entries ;
   uint16_t unused[4U] ;
   uint16_t checksum ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 362 "include/scsi/scsi_transport_fc.h"
struct fc_starget_attrs {
   u64 node_name ;
   u64 port_name ;
   u32 port_id ;
};
#line 927 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
struct sysfs_entry {
   char *name ;
   struct bin_attribute *attr ;
   int is4GBp_only ;
};
#line 243 "include/linux/timer.h"
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 317 "./include/uapi/scsi/scsi_bsg_fc.h"
struct __anonstruct_mem_290 {
   uint32_t start_addr ;
};
#line 317 "./include/uapi/scsi/scsi_bsg_fc.h"
struct __anonstruct_config_291 {
   uint32_t id ;
   uint32_t param0 ;
   uint32_t param1 ;
};
#line 317 "./include/uapi/scsi/scsi_bsg_fc.h"
struct __anonstruct_info_292 {
   uint32_t type ;
   uint32_t context ;
};
#line 317 "./include/uapi/scsi/scsi_bsg_fc.h"
union __anonunion_u_289 {
   struct __anonstruct_mem_290 mem ;
   struct __anonstruct_config_291 config ;
   struct __anonstruct_info_292 info ;
};
#line 317 "./include/uapi/scsi/scsi_bsg_fc.h"
struct qla84_mgmt_param {
   union __anonunion_u_289 u ;
};
#line 137 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct qla84_msg_mgmt {
   uint16_t cmd ;
   uint16_t rsrvd ;
   struct qla84_mgmt_param mgmtp ;
   uint32_t len ;
   uint8_t payload[0U] ;
};
#line 149 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct qla_bsg_a84_mgmt {
   struct qla84_msg_mgmt mgmt ;
};
#line 153 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct qla_scsi_addr {
   uint16_t bus ;
   uint16_t target ;
};
#line 158 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
union __anonunion_dest_addr_293 {
   uint8_t wwnn[8U] ;
   uint8_t wwpn[8U] ;
   uint8_t id[4U] ;
   struct qla_scsi_addr scsi_addr ;
};
#line 158 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct qla_ext_dest_addr {
   union __anonunion_dest_addr_293 dest_addr ;
   uint16_t dest_type ;
   uint16_t lun ;
   uint16_t padding[2U] ;
};
#line 171 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct qla_port_param {
   struct qla_ext_dest_addr fc_scsi_addr ;
   uint16_t mode ;
   uint16_t speed ;
};
#line 177 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct qla_field_address {
   uint16_t offset ;
   uint16_t device ;
   uint16_t option ;
};
#line 188 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct qla_field_info {
   uint8_t version[36U] ;
};
#line 192 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct qla_image_version {
   struct qla_field_address field_address ;
   struct qla_field_info field_info ;
};
#line 197 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct qla_image_version_list {
   uint32_t count ;
   struct qla_image_version version[0U] ;
};
#line 202 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct qla_status_reg {
   struct qla_field_address field_address ;
   uint8_t status_reg ;
   uint8_t reserved[7U] ;
};
#line 208 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct qla_i2c_access {
   uint16_t device ;
   uint16_t offset ;
   uint16_t option ;
   uint16_t length ;
   uint8_t buffer[64U] ;
};
#line 216 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct qla_serdes_reg {
   uint16_t cmd ;
   uint16_t addr ;
   uint16_t val ;
};
#line 228 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct qla_serdes_reg_ex {
   uint16_t cmd ;
   uint32_t addr ;
   uint32_t val ;
};
#line 1498 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct access_chip_84xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_defined ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t options ;
   uint16_t reserved1 ;
   uint16_t dseg_count ;
   uint16_t reserved2[3U] ;
   uint32_t parameter1 ;
   uint32_t parameter2 ;
   uint32_t parameter3 ;
   uint32_t reserved3[3U] ;
   uint32_t total_byte_cnt ;
   uint32_t reserved4 ;
   uint32_t dseg_address[2U] ;
   uint32_t dseg_length ;
};
#line 318 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct qla_mt_iocb_rqst_fx00 {
   __le32 reserved_0 ;
   __le16 func_type ;
   uint8_t flags ;
   uint8_t reserved_1 ;
   __le32 dataword ;
   __le32 adapid ;
   __le32 adapid_hi ;
   __le32 dataword_extra ;
   __le16 req_len ;
   __le16 reserved_2 ;
   __le16 rsp_len ;
   __le16 reserved_3 ;
};
#line 36 "include/uapi/linux/types.h"
typedef __u64 __le64;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 38 "include/linux/pinctrl/devinfo.h"
struct ratelimit_state {
   raw_spinlock_t lock ;
   int interval ;
   int burst ;
   int printed ;
   int missed ;
   unsigned long begin ;
};
#line 234 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct crb_128M_2M_sub_block_map {
   unsigned int valid ;
   unsigned int start_128M ;
   unsigned int end_128M ;
   unsigned int start_2M ;
};
#line 601 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct crb_128M_2M_block_map {
   struct crb_128M_2M_sub_block_map sub_block[16U] ;
};
#line 605 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct crb_addr_pair {
   long addr ;
   long data ;
};
#line 724 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla82xx_uri_table_desc {
   uint32_t findex ;
   uint32_t num_entries ;
   uint32_t entry_size ;
   uint32_t reserved[5U] ;
};
#line 806 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla82xx_uri_data_desc {
   uint32_t findex ;
   uint32_t size ;
   uint32_t reserved[5U] ;
};
#line 888 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla82xx_md_template_hdr {
   uint32_t entry_type ;
   uint32_t first_entry_offset ;
   uint32_t size_of_template ;
   uint32_t capture_debug_level ;
   uint32_t num_of_entries ;
   uint32_t version ;
   uint32_t driver_timestamp ;
   uint32_t template_checksum ;
   uint32_t driver_capture_mask ;
   uint32_t driver_info[3U] ;
   uint32_t saved_state_array[16U] ;
   uint32_t capture_size_array[8U] ;
   uint32_t markers_array[8U] ;
   uint32_t num_of_free_entries ;
   uint32_t free_entry_offset ;
   uint32_t total_table_size ;
   uint32_t bkup_table_offset ;
};
#line 1018 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct __anonstruct_d_ctrl_294 {
   uint8_t entry_capture_mask ;
   uint8_t entry_code ;
   uint8_t driver_code ;
   uint8_t driver_flags ;
};
#line 1018 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla82xx_md_entry_hdr {
   uint32_t entry_type ;
   uint32_t entry_size ;
   uint32_t entry_capture_size ;
   struct __anonstruct_d_ctrl_294 d_ctrl ;
};
#line 1037 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
typedef struct qla82xx_md_entry_hdr qla82xx_md_entry_hdr_t;
#line 1038 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct __anonstruct_crb_strd_295 {
   uint8_t addr_stride ;
   uint8_t state_index_a ;
   uint16_t poll_timeout ;
};
#line 1038 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct __anonstruct_crb_ctrl_296 {
   uint8_t opcode ;
   uint8_t state_index_v ;
   uint8_t shl ;
   uint8_t shr ;
};
#line 1038 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla82xx_md_entry_crb {
   qla82xx_md_entry_hdr_t h ;
   uint32_t addr ;
   struct __anonstruct_crb_strd_295 crb_strd ;
   uint32_t data_size ;
   uint32_t op_count ;
   struct __anonstruct_crb_ctrl_296 crb_ctrl ;
   uint32_t value_1 ;
   uint32_t value_2 ;
   uint32_t value_3 ;
};
#line 1065 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct __anonstruct_addr_ctrl_297 {
   uint16_t tag_value_stride ;
   uint16_t init_tag_value ;
};
#line 1065 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct __anonstruct_cache_ctrl_298 {
   uint16_t write_value ;
   uint8_t poll_mask ;
   uint8_t poll_wait ;
};
#line 1065 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct __anonstruct_read_ctrl_299 {
   uint8_t read_addr_stride ;
   uint8_t read_addr_cnt ;
   uint16_t rsvd_1 ;
};
#line 1065 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla82xx_md_entry_cache {
   qla82xx_md_entry_hdr_t h ;
   uint32_t tag_reg_addr ;
   struct __anonstruct_addr_ctrl_297 addr_ctrl ;
   uint32_t data_size ;
   uint32_t op_count ;
   uint32_t control_addr ;
   struct __anonstruct_cache_ctrl_298 cache_ctrl ;
   uint32_t read_addr ;
   struct __anonstruct_read_ctrl_299 read_ctrl ;
};
#line 1095 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla82xx_md_entry_rdocm {
   qla82xx_md_entry_hdr_t h ;
   uint32_t rsvd_0 ;
   uint32_t rsvd_1 ;
   uint32_t data_size ;
   uint32_t op_count ;
   uint32_t rsvd_2 ;
   uint32_t rsvd_3 ;
   uint32_t read_addr ;
   uint32_t read_addr_stride ;
   uint32_t read_addr_cntrl ;
};
#line 1113 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla82xx_md_entry_rdmem {
   qla82xx_md_entry_hdr_t h ;
   uint32_t rsvd[6U] ;
   uint32_t read_addr ;
   uint32_t read_data_size ;
};
#line 1123 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla82xx_md_entry_rdrom {
   qla82xx_md_entry_hdr_t h ;
   uint32_t rsvd[6U] ;
   uint32_t read_addr ;
   uint32_t read_data_size ;
};
#line 1133 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla82xx_md_entry_mux {
   qla82xx_md_entry_hdr_t h ;
   uint32_t select_addr ;
   uint32_t rsvd_0 ;
   uint32_t data_size ;
   uint32_t op_count ;
   uint32_t select_value ;
   uint32_t select_value_stride ;
   uint32_t read_addr ;
   uint32_t rsvd_1 ;
};
#line 1147 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct __anonstruct_q_strd_300 {
   uint16_t queue_id_stride ;
   uint16_t rsvd_0 ;
};
#line 1147 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct __anonstruct_rd_strd_301 {
   uint8_t read_addr_stride ;
   uint8_t read_addr_cnt ;
   uint16_t rsvd_3 ;
};
#line 1147 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla82xx_md_entry_queue {
   qla82xx_md_entry_hdr_t h ;
   uint32_t select_addr ;
   struct __anonstruct_q_strd_300 q_strd ;
   uint32_t data_size ;
   uint32_t op_count ;
   uint32_t rsvd_1 ;
   uint32_t rsvd_2 ;
   uint32_t read_addr ;
   struct __anonstruct_rd_strd_301 rd_strd ;
};
#line 1133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
struct crb_addr_pair___0 {
   long addr ;
   long data ;
};
#line 40 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 13 "include/uapi/linux/time.h"
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 2030 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct cmd_type_7_fx00 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint8_t reserved_0 ;
   uint8_t port_path_ctrl ;
   uint16_t reserved_1 ;
   __le16 tgt_idx ;
   uint16_t timeout ;
   __le16 dseg_count ;
   uint8_t scsi_rsp_dsd_len ;
   uint8_t reserved_2 ;
   struct scsi_lun lun ;
   uint8_t cntrl_flags ;
   uint8_t task_mgmt_flags ;
   uint8_t task ;
   uint8_t crn ;
   uint8_t fcp_cdb[16U] ;
   __le32 byte_count ;
   uint32_t dseg_0_address[2U] ;
   uint32_t dseg_0_len ;
};
#line 52 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct sts_entry_fx00 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint32_t reserved_3 ;
   __le16 comp_status ;
   uint16_t reserved_0 ;
   __le32 residual_len ;
   uint16_t reserved_1 ;
   uint16_t state_flags ;
   uint16_t reserved_2 ;
   __le16 scsi_status ;
   uint32_t sense_len ;
   uint8_t data[32U] ;
};
#line 77 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct multi_sts_entry_fx00 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t handle_count ;
   uint8_t entry_status ;
   __le32 handles[15U] ;
};
#line 135 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct ioctl_iocb_entry_fx00 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint32_t reserved_0 ;
   uint16_t comp_func_num ;
   __le16 fw_iotcl_flags ;
   __le32 dataword_r ;
   uint32_t adapid ;
   uint32_t dataword_r_extra ;
   __le32 seq_no ;
   uint8_t reserved_2[20U] ;
   uint32_t residuallen ;
   __le32 status ;
};
#line 189 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct qlafx00_tgt_node_info {
   uint8_t tgt_node_wwpn[8U] ;
   uint8_t tgt_node_wwnn[8U] ;
   uint32_t tgt_node_state ;
   uint8_t reserved[128U] ;
   uint32_t reserved_1[8U] ;
   uint64_t reserved_2[4U] ;
};
#line 198 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct port_info_data {
   uint8_t port_state ;
   uint8_t port_type ;
   uint16_t port_identifier ;
   uint32_t up_port_state ;
   uint8_t fw_ver_num[32U] ;
   uint8_t portal_attrib ;
   uint16_t host_option ;
   uint8_t reset_delay ;
   uint8_t pdwn_retry_cnt ;
   uint16_t max_luns2tgt ;
   uint8_t risc_ver ;
   uint8_t pconn_option ;
   uint16_t risc_option ;
   uint16_t max_frame_len ;
   uint16_t max_iocb_alloc ;
   uint16_t exec_throttle ;
   uint8_t retry_cnt ;
   uint8_t retry_delay ;
   uint8_t port_name[8U] ;
   uint8_t port_id[3U] ;
   uint8_t link_status ;
   uint8_t plink_rate ;
   uint32_t link_config ;
   uint16_t adap_haddr ;
   uint8_t tgt_disc ;
   uint8_t log_tout ;
   uint8_t node_name[8U] ;
   uint16_t erisc_opt1 ;
   uint8_t resp_acc_tmr ;
   uint8_t intr_del_tmr ;
   uint8_t erisc_opt2 ;
   uint8_t alt_port_name[8U] ;
   uint8_t alt_node_name[8U] ;
   uint8_t link_down_tout ;
   uint8_t conn_type ;
   uint8_t fc_fw_mode ;
   uint32_t uiReserved[48U] ;
};
#line 247 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct host_system_info {
   uint32_t os_type ;
   char sysname[128U] ;
   char nodename[64U] ;
   char release[64U] ;
   char version[64U] ;
   char machine[64U] ;
   char domainname[64U] ;
   char hostdriver[64U] ;
   uint32_t reserved[64U] ;
};
#line 271 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct register_host_info {
   struct host_system_info hsi ;
   uint64_t utc ;
   uint32_t reserved[64U] ;
};
#line 277 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct config_info_data {
   uint8_t model_num[16U] ;
   uint8_t model_description[80U] ;
   uint8_t reserved0[160U] ;
   uint8_t symbolic_name[64U] ;
   uint8_t serial_num[32U] ;
   uint8_t hw_version[16U] ;
   uint8_t fw_version[16U] ;
   uint8_t uboot_version[16U] ;
   uint8_t fru_serial_num[32U] ;
   uint8_t fc_port_count ;
   uint8_t iscsi_port_count ;
   uint8_t reserved1[2U] ;
   uint8_t mode ;
   uint8_t log_level ;
   uint8_t reserved2[2U] ;
   uint32_t log_size ;
   uint8_t tgt_pres_mode ;
   uint8_t iqn_flags ;
   uint8_t lun_mapping ;
   uint64_t adapter_id ;
   uint32_t cluster_key_len ;
   uint8_t cluster_key[16U] ;
   uint64_t cluster_master_id ;
   uint64_t cluster_slave_id ;
   uint8_t cluster_flags ;
   uint32_t enabled_capabilities ;
   uint32_t nominal_temp_value ;
};
#line 425 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct qla_mt_iocb_rsp_fx00 {
   uint32_t reserved_1 ;
   uint16_t func_type ;
   __le16 ioctl_flags ;
   __le32 ioctl_data ;
   uint32_t adapid ;
   uint32_t adapid_hi ;
   uint32_t reserved_2 ;
   __le32 seq_number ;
   uint8_t reserved_3[20U] ;
   int32_t res_count ;
   __le32 status ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 231 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_reset_entry_hdr {
   uint16_t cmd ;
   uint16_t size ;
   uint16_t count ;
   uint16_t delay ;
};
#line 239 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_poll {
   uint32_t test_mask ;
   uint32_t test_value ;
};
#line 245 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_rmw {
   uint32_t test_mask ;
   uint32_t xor_value ;
   uint32_t or_value ;
   uint8_t shl ;
   uint8_t shr ;
   uint8_t index_a ;
   uint8_t rsvd ;
};
#line 256 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_entry {
   uint32_t arg1 ;
   uint32_t arg2 ;
};
#line 262 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_quad_entry {
   uint32_t dr_addr ;
   uint32_t dr_value ;
   uint32_t ar_addr ;
   uint32_t ar_value ;
};
#line 284 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct __anonstruct_d_ctrl_302 {
   uint8_t entry_capture_mask ;
   uint8_t entry_code ;
   uint8_t driver_code ;
   uint8_t driver_flags ;
};
#line 284 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_hdr {
   uint32_t entry_type ;
   uint32_t entry_size ;
   uint32_t entry_capture_size ;
   struct __anonstruct_d_ctrl_302 d_ctrl ;
};
#line 299 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct __anonstruct_crb_strd_303 {
   uint8_t addr_stride ;
   uint8_t state_index_a ;
   uint16_t poll_timeout ;
};
#line 299 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct __anonstruct_crb_ctrl_304 {
   uint8_t opcode ;
   uint8_t state_index_v ;
   uint8_t shl ;
   uint8_t shr ;
};
#line 299 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_crb {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t addr ;
   struct __anonstruct_crb_strd_303 crb_strd ;
   uint32_t data_size ;
   uint32_t op_count ;
   struct __anonstruct_crb_ctrl_304 crb_ctrl ;
   uint32_t value_1 ;
   uint32_t value_2 ;
   uint32_t value_3 ;
};
#line 323 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct __anonstruct_addr_ctrl_305 {
   uint16_t tag_value_stride ;
   uint16_t init_tag_value ;
};
#line 323 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct __anonstruct_cache_ctrl_306 {
   uint16_t write_value ;
   uint8_t poll_mask ;
   uint8_t poll_wait ;
};
#line 323 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct __anonstruct_read_ctrl_307 {
   uint8_t read_addr_stride ;
   uint8_t read_addr_cnt ;
   uint16_t rsvd_1 ;
};
#line 323 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_cache {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t tag_reg_addr ;
   struct __anonstruct_addr_ctrl_305 addr_ctrl ;
   uint32_t data_size ;
   uint32_t op_count ;
   uint32_t control_addr ;
   struct __anonstruct_cache_ctrl_306 cache_ctrl ;
   uint32_t read_addr ;
   struct __anonstruct_read_ctrl_307 read_ctrl ;
};
#line 346 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_rdocm {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t rsvd_0 ;
   uint32_t rsvd_1 ;
   uint32_t data_size ;
   uint32_t op_count ;
   uint32_t rsvd_2 ;
   uint32_t rsvd_3 ;
   uint32_t read_addr ;
   uint32_t read_addr_stride ;
};
#line 359 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_rdmem {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t rsvd[6U] ;
   uint32_t read_addr ;
   uint32_t read_data_size ;
};
#line 367 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_rdmem_pex_dma {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t desc_card_addr ;
   uint16_t dma_desc_cmd ;
   uint8_t rsvd[2U] ;
   uint32_t start_dma_cmd ;
   uint8_t rsvd2[12U] ;
   uint32_t read_addr ;
   uint32_t read_data_size ;
};
#line 379 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_rdrom {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t rsvd[6U] ;
   uint32_t read_addr ;
   uint32_t read_data_size ;
};
#line 387 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_mux {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t select_addr ;
   uint32_t rsvd_0 ;
   uint32_t data_size ;
   uint32_t op_count ;
   uint32_t select_value ;
   uint32_t select_value_stride ;
   uint32_t read_addr ;
   uint32_t rsvd_1 ;
};
#line 400 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct __anonstruct_q_strd_308 {
   uint16_t queue_id_stride ;
   uint16_t rsvd_0 ;
};
#line 400 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct __anonstruct_rd_strd_309 {
   uint8_t read_addr_stride ;
   uint8_t read_addr_cnt ;
   uint16_t rsvd_3 ;
};
#line 400 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_queue {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t select_addr ;
   struct __anonstruct_q_strd_308 q_strd ;
   uint32_t data_size ;
   uint32_t op_count ;
   uint32_t rsvd_1 ;
   uint32_t rsvd_2 ;
   uint32_t read_addr ;
   struct __anonstruct_rd_strd_309 rd_strd ;
};
#line 420 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_pollrd {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t select_addr ;
   uint32_t read_addr ;
   uint32_t select_value ;
   uint16_t select_value_stride ;
   uint16_t op_count ;
   uint32_t poll_wait ;
   uint32_t poll_mask ;
   uint32_t data_size ;
   uint32_t rsvd_1 ;
};
#line 434 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_rddfe {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t addr_1 ;
   uint32_t value ;
   uint8_t stride ;
   uint8_t stride2 ;
   uint16_t count ;
   uint32_t poll ;
   uint32_t mask ;
   uint32_t modify_mask ;
   uint32_t data_size ;
   uint32_t rsvd ;
};
#line 448 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_rdmdio {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t addr_1 ;
   uint32_t addr_2 ;
   uint32_t value_1 ;
   uint8_t stride_1 ;
   uint8_t stride_2 ;
   uint16_t count ;
   uint32_t poll ;
   uint32_t mask ;
   uint32_t value_2 ;
   uint32_t data_size ;
};
#line 464 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_pollwr {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t addr_1 ;
   uint32_t addr_2 ;
   uint32_t value_1 ;
   uint32_t value_2 ;
   uint32_t poll ;
   uint32_t mask ;
   uint32_t data_size ;
   uint32_t rsvd ;
};
#line 477 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_rdmux2 {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t select_addr_1 ;
   uint32_t select_addr_2 ;
   uint32_t select_value_1 ;
   uint32_t select_value_2 ;
   uint32_t op_count ;
   uint32_t select_value_mask ;
   uint32_t read_addr ;
   uint8_t select_value_stride ;
   uint8_t data_size ;
   uint8_t rsvd[2U] ;
};
#line 493 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_pollrdmwr {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t addr_1 ;
   uint32_t addr_2 ;
   uint32_t value_1 ;
   uint32_t value_2 ;
   uint32_t poll_wait ;
   uint32_t poll_mask ;
   uint32_t modify_mask ;
   uint32_t data_size ;
};
#line 537 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_template_hdr {
   uint32_t entry_type ;
   uint32_t first_entry_offset ;
   uint32_t size_of_template ;
   uint32_t capture_debug_level ;
   uint32_t num_of_entries ;
   uint32_t version ;
   uint32_t driver_timestamp ;
   uint32_t checksum ;
   uint32_t driver_capture_mask ;
   uint32_t driver_info_word2 ;
   uint32_t driver_info_word3 ;
   uint32_t driver_info_word4 ;
   uint32_t saved_state_array[16U] ;
   uint32_t capture_size_array[8U] ;
   uint32_t ocm_window_reg[16U] ;
};
#line 587 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct __anonstruct_cmd_310 {
   uint32_t read_data_size ;
   uint8_t rsvd[2U] ;
   uint16_t dma_desc_cmd ;
};
#line 587 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_pex_dma_descriptor {
   struct __anonstruct_cmd_310 cmd ;
   uint64_t src_addr ;
   uint64_t dma_bus_addr ;
   uint8_t rsvd[24U] ;
};
#line 37 "include/uapi/linux/types.h"
typedef __u64 __be64;
#line 234 "include/linux/printk.h"
struct _ddebug {
   char const   *modname ;
   char const   *function ;
   char const   *filename ;
   char const   *format ;
   unsigned int lineno : 18 ;
   unsigned char flags ;
};
#line 12 "include/linux/wait.h"
struct __wait_queue;
#line 12 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 15 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 826 "include/target/target_core_base.h"
struct se_tpg_np {
   struct se_portal_group *tpg_np_parent ;
   struct config_group tpg_np_group ;
};
#line 888 "include/target/target_core_base.h"
struct target_core_fabric_ops {
   struct module *module ;
   char const   *name ;
   size_t node_acl_size ;
   char *(*get_fabric_name)(void) ;
   char *(*tpg_get_wwn)(struct se_portal_group * ) ;
   u16 (*tpg_get_tag)(struct se_portal_group * ) ;
   u32 (*tpg_get_default_depth)(struct se_portal_group * ) ;
   int (*tpg_check_demo_mode)(struct se_portal_group * ) ;
   int (*tpg_check_demo_mode_cache)(struct se_portal_group * ) ;
   int (*tpg_check_demo_mode_write_protect)(struct se_portal_group * ) ;
   int (*tpg_check_prod_mode_write_protect)(struct se_portal_group * ) ;
   int (*tpg_check_demo_mode_login_only)(struct se_portal_group * ) ;
   int (*tpg_check_prot_fabric_only)(struct se_portal_group * ) ;
   u32 (*tpg_get_inst_index)(struct se_portal_group * ) ;
   int (*check_stop_free)(struct se_cmd * ) ;
   void (*release_cmd)(struct se_cmd * ) ;
   int (*shutdown_session)(struct se_session * ) ;
   void (*close_session)(struct se_session * ) ;
   u32 (*sess_get_index)(struct se_session * ) ;
   u32 (*sess_get_initiator_sid)(struct se_session * , unsigned char * , u32  ) ;
   int (*write_pending)(struct se_cmd * ) ;
   int (*write_pending_status)(struct se_cmd * ) ;
   void (*set_default_node_attributes)(struct se_node_acl * ) ;
   int (*get_cmd_state)(struct se_cmd * ) ;
   int (*queue_data_in)(struct se_cmd * ) ;
   int (*queue_status)(struct se_cmd * ) ;
   void (*queue_tm_rsp)(struct se_cmd * ) ;
   void (*aborted_task)(struct se_cmd * ) ;
   struct se_wwn *(*fabric_make_wwn)(struct target_fabric_configfs * , struct config_group * ,
                                     char const   * ) ;
   void (*fabric_drop_wwn)(struct se_wwn * ) ;
   struct se_portal_group *(*fabric_make_tpg)(struct se_wwn * , struct config_group * ,
                                              char const   * ) ;
   void (*fabric_drop_tpg)(struct se_portal_group * ) ;
   int (*fabric_post_link)(struct se_portal_group * , struct se_lun * ) ;
   void (*fabric_pre_unlink)(struct se_portal_group * , struct se_lun * ) ;
   struct se_tpg_np *(*fabric_make_np)(struct se_portal_group * , struct config_group * ,
                                       char const   * ) ;
   void (*fabric_drop_np)(struct se_tpg_np * ) ;
   int (*fabric_init_nodeacl)(struct se_node_acl * , char const   * ) ;
   void (*fabric_cleanup_nodeacl)(struct se_node_acl * ) ;
   struct configfs_attribute **tfc_discovery_attrs ;
   struct configfs_attribute **tfc_wwn_attrs ;
   struct configfs_attribute **tfc_tpg_base_attrs ;
   struct configfs_attribute **tfc_tpg_np_base_attrs ;
   struct configfs_attribute **tfc_tpg_attrib_attrs ;
   struct configfs_attribute **tfc_tpg_auth_attrs ;
   struct configfs_attribute **tfc_tpg_param_attrs ;
   struct configfs_attribute **tfc_tpg_nacl_base_attrs ;
   struct configfs_attribute **tfc_tpg_nacl_attrib_attrs ;
   struct configfs_attribute **tfc_tpg_nacl_auth_attrs ;
   struct configfs_attribute **tfc_tpg_nacl_param_attrs ;
};
#line 180 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct __anonstruct_isp2x_508 {
   uint32_t sys_define_2 ;
   target_id_t target ;
   uint8_t target_id ;
   uint8_t reserved_1 ;
   uint16_t flags ;
   uint16_t resp_code ;
   uint16_t status ;
   uint16_t task_flags ;
   uint16_t seq_id ;
   uint16_t srr_rx_id ;
   uint32_t srr_rel_offs ;
   uint16_t srr_ui ;
   uint16_t srr_flags ;
   uint16_t srr_reject_code ;
   uint8_t srr_reject_vendor_uniq ;
   uint8_t srr_reject_code_expl ;
   uint8_t reserved_2[24U] ;
};
#line 180 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct __anonstruct_isp24_509 {
   uint32_t handle ;
   uint16_t nport_handle ;
   uint16_t reserved_1 ;
   uint16_t flags ;
   uint16_t srr_rx_id ;
   uint16_t status ;
   uint8_t status_subcode ;
   uint8_t fw_handle ;
   uint32_t exchange_address ;
   uint32_t srr_rel_offs ;
   uint16_t srr_ui ;
   uint16_t srr_flags ;
   uint8_t reserved_4[19U] ;
   uint8_t vp_index ;
   uint8_t srr_reject_vendor_uniq ;
   uint8_t srr_reject_code_expl ;
   uint8_t srr_reject_code ;
   uint8_t reserved_5[5U] ;
};
#line 180 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
union __anonunion_u_507 {
   struct __anonstruct_isp2x_508 isp2x ;
   struct __anonstruct_isp24_509 isp24 ;
};
#line 180 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct nack_to_isp {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   union __anonunion_u_507 u ;
   uint8_t reserved[2U] ;
   uint16_t ox_id ;
};
#line 237 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct ctio_to_2xxx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   target_id_t target ;
   uint16_t rx_id ;
   uint16_t flags ;
   uint16_t status ;
   uint16_t timeout ;
   uint16_t dseg_count ;
   uint32_t relative_offset ;
   uint32_t residual ;
   uint16_t reserved_1[3U] ;
   uint16_t scsi_status ;
   uint32_t transfer_length ;
   uint32_t dseg_0_address ;
   uint32_t dseg_0_length ;
   uint32_t dseg_1_address ;
   uint32_t dseg_1_length ;
   uint32_t dseg_2_address ;
   uint32_t dseg_2_length ;
};
#line 418 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct __anonstruct_status0_515 {
   uint16_t reserved1 ;
   __le16 flags ;
   uint32_t residual ;
   __le16 ox_id ;
   uint16_t scsi_status ;
   uint32_t relative_offset ;
   uint32_t reserved2 ;
   uint32_t transfer_length ;
   uint32_t reserved3 ;
   uint32_t dseg_0_address[2U] ;
   uint32_t dseg_0_length ;
};
#line 418 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct __anonstruct_status1_516 {
   uint16_t sense_length ;
   uint16_t flags ;
   uint32_t residual ;
   __le16 ox_id ;
   uint16_t scsi_status ;
   uint16_t response_len ;
   uint16_t reserved ;
   uint8_t sense_data[24U] ;
};
#line 418 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
union __anonunion_u_514 {
   struct __anonstruct_status0_515 status0 ;
   struct __anonstruct_status1_516 status1 ;
};
#line 418 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct ctio7_to_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t nport_handle ;
   uint16_t timeout ;
   uint16_t dseg_count ;
   uint8_t vp_index ;
   uint8_t add_flags ;
   uint8_t initiator_id[3U] ;
   uint8_t reserved ;
   uint32_t exchange_addr ;
   union __anonunion_u_514 u ;
};
#line 469 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct ctio7_from_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t status ;
   uint16_t timeout ;
   uint16_t dseg_count ;
   uint8_t vp_index ;
   uint8_t reserved1[5U] ;
   uint32_t exchange_address ;
   uint16_t reserved2 ;
   uint16_t flags ;
   uint32_t residual ;
   uint16_t ox_id ;
   uint16_t reserved3 ;
   uint32_t relative_offset ;
   uint8_t reserved4[24U] ;
};
#line 494 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct ctio_crc2_to_fw {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t nport_handle ;
   __le16 timeout ;
   uint16_t dseg_count ;
   uint8_t vp_index ;
   uint8_t add_flags ;
   uint8_t initiator_id[3U] ;
   uint8_t reserved1 ;
   uint32_t exchange_addr ;
   uint16_t reserved2 ;
   __le16 flags ;
   uint32_t residual ;
   __le16 ox_id ;
   uint16_t scsi_status ;
   __le32 relative_offset ;
   uint32_t reserved5 ;
   __le32 transfer_length ;
   uint32_t reserved6 ;
   __le32 crc_context_address[2U] ;
   uint16_t crc_context_len ;
   uint16_t reserved_1 ;
};
#line 553 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct ctio_crc_from_fw {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t status ;
   uint16_t timeout ;
   uint16_t dseg_count ;
   uint32_t reserved1 ;
   uint16_t state_flags ;
   uint32_t exchange_address ;
   uint16_t reserved2 ;
   uint16_t flags ;
   uint32_t resid_xfer_length ;
   uint16_t ox_id ;
   uint8_t reserved3[12U] ;
   uint16_t runt_guard ;
   uint8_t actual_dif[8U] ;
   uint8_t expected_dif[8U] ;
};
#line 608 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct ba_acc_le {
   uint16_t reserved ;
   uint8_t seq_id_last ;
   uint8_t seq_id_valid ;
   uint16_t rx_id ;
   uint16_t ox_id ;
   uint16_t high_seq_cnt ;
   uint16_t low_seq_cnt ;
};
#line 622 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct ba_rjt_le {
   uint8_t vendor_uniq ;
   uint8_t reason_expl ;
   uint8_t reason_code ;
   uint8_t reserved ;
};
#line 631 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
union __anonunion_payload_517 {
   struct ba_acc_le ba_acct ;
   struct ba_rjt_le ba_rjt ;
};
#line 631 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct abts_resp_to_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t reserved_1 ;
   uint16_t nport_handle ;
   uint16_t control_flags ;
   uint8_t vp_index ;
   unsigned char reserved_3 : 4 ;
   unsigned char sof_type : 4 ;
   uint32_t exchange_address ;
   struct fcp_hdr_le fcp_hdr_le ;
   union __anonunion_payload_517 payload ;
   uint32_t reserved_4 ;
   uint32_t exchange_addr_to_abort ;
};
#line 660 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct abts_resp_from_24xx_fw {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t compl_status ;
   uint16_t nport_handle ;
   uint16_t reserved_1 ;
   uint8_t reserved_2 ;
   unsigned char reserved_3 : 4 ;
   unsigned char sof_type : 4 ;
   uint32_t exchange_address ;
   struct fcp_hdr_le fcp_hdr_le ;
   uint8_t reserved_4[8U] ;
   uint32_t error_subcode1 ;
   uint32_t error_subcode2 ;
   uint32_t exchange_addr_to_abort ;
};
#line 872 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct qla_tgt_sess_op {
   struct scsi_qla_host *vha ;
   struct atio_from_isp atio ;
   struct work_struct work ;
};
#line 967 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
union __anonunion____missing_field_name_518 {
   struct abts_recv_from_24xx abts ;
   struct imm_ntfy_from_isp tm_iocb ;
   struct atio_from_isp tm_iocb2 ;
};
#line 967 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct qla_tgt_sess_work_param {
   struct list_head sess_works_list_entry ;
   int type ;
   union __anonunion____missing_field_name_518 __annonCompField127 ;
};
#line 997 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct qla_tgt_prm {
   struct qla_tgt_cmd *cmd ;
   struct qla_tgt *tgt ;
   void *pkt ;
   struct scatterlist *sg ;
   unsigned char *sense_buffer ;
   int seg_cnt ;
   int req_cnt ;
   uint16_t rq_result ;
   uint16_t scsi_status ;
   int sense_buffer_len ;
   int residual ;
   int add_status_pkt ;
   struct scatterlist *prot_sg ;
   uint16_t prot_seg_cnt ;
   uint16_t tot_dsds ;
};
#line 1016 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct qla_tgt_srr_imm {
   struct list_head srr_list_entry ;
   int srr_id ;
   struct imm_ntfy_from_isp imm_ntfy ;
};
#line 1022 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct qla_tgt_srr_ctio {
   struct list_head srr_list_entry ;
   int srr_id ;
   struct qla_tgt_cmd *cmd ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 289 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
struct qla27xx_fwdt_template {
   uint32_t template_type ;
   uint32_t entry_offset ;
   uint32_t template_size ;
   uint32_t reserved_1 ;
   uint32_t entry_count ;
   uint32_t template_version ;
   uint32_t capture_timestamp ;
   uint32_t template_checksum ;
   uint32_t reserved_2 ;
   uint32_t driver_info[3U] ;
   uint32_t saved_state[16U] ;
   uint32_t reserved_3[8U] ;
   uint32_t firmware_version[5U] ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
struct __anonstruct_hdr_520 {
   uint32_t entry_type ;
   uint32_t entry_size ;
   uint32_t reserved_1 ;
   uint8_t capture_flags ;
   uint8_t reserved_2[2U] ;
   uint8_t driver_flags ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
struct __anonstruct_t0_522 {

};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
struct __anonstruct_t255_523 {

};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
struct __anonstruct_t256_524 {
   uint32_t base_addr ;
   uint8_t reg_width ;
   uint16_t reg_count ;
   uint8_t pci_offset ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
struct __anonstruct_t257_525 {
   uint32_t base_addr ;
   uint32_t write_data ;
   uint8_t pci_offset ;
   uint8_t reserved[3U] ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
struct __anonstruct_t258_526 {
   uint32_t base_addr ;
   uint8_t reg_width ;
   uint16_t reg_count ;
   uint8_t pci_offset ;
   uint8_t banksel_offset ;
   uint8_t reserved[3U] ;
   uint32_t bank ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
struct __anonstruct_t259_527 {
   uint32_t base_addr ;
   uint32_t write_data ;
   uint8_t reserved[2U] ;
   uint8_t pci_offset ;
   uint8_t banksel_offset ;
   uint32_t bank ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
struct __anonstruct_t260_528 {
   uint8_t pci_offset ;
   uint8_t reserved[3U] ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
struct __anonstruct_t261_529 {
   uint8_t pci_offset ;
   uint8_t reserved[3U] ;
   uint32_t write_data ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
struct __anonstruct_t262_530 {
   uint8_t ram_area ;
   uint8_t reserved[3U] ;
   uint32_t start_addr ;
   uint32_t end_addr ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
struct __anonstruct_t263_531 {
   uint32_t num_queues ;
   uint8_t queue_type ;
   uint8_t reserved[3U] ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
struct __anonstruct_t264_532 {
   uint32_t fce_trace_size ;
   uint64_t write_pointer ;
   uint64_t base_pointer ;
   uint32_t fce_enable_mb0 ;
   uint32_t fce_enable_mb2 ;
   uint32_t fce_enable_mb3 ;
   uint32_t fce_enable_mb4 ;
   uint32_t fce_enable_mb5 ;
   uint32_t fce_enable_mb6 ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
struct __anonstruct_t265_533 {

};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
struct __anonstruct_t266_534 {

};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
struct __anonstruct_t267_535 {
   uint8_t pci_offset ;
   uint8_t reserved[3U] ;
   uint32_t data ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
struct __anonstruct_t268_536 {
   uint8_t buf_type ;
   uint8_t reserved[3U] ;
   uint32_t buf_size ;
   uint64_t start_addr ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
struct __anonstruct_t269_537 {
   uint32_t scratch_size ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
struct __anonstruct_t270_538 {
   uint32_t addr ;
   uint32_t count ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
struct __anonstruct_t271_539 {
   uint32_t addr ;
   uint32_t data ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
struct __anonstruct_t272_540 {
   uint32_t addr ;
   uint32_t count ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
struct __anonstruct_t273_541 {
   uint32_t addr ;
   uint32_t count ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
struct __anonstruct_t274_542 {
   uint32_t num_queues ;
   uint8_t queue_type ;
   uint8_t reserved[3U] ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
struct __anonstruct_t275_543 {
   uint32_t length ;
   uint8_t buffer[] ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
union __anonunion____missing_field_name_521 {
   struct __anonstruct_t0_522 t0 ;
   struct __anonstruct_t255_523 t255 ;
   struct __anonstruct_t256_524 t256 ;
   struct __anonstruct_t257_525 t257 ;
   struct __anonstruct_t258_526 t258 ;
   struct __anonstruct_t259_527 t259 ;
   struct __anonstruct_t260_528 t260 ;
   struct __anonstruct_t261_529 t261 ;
   struct __anonstruct_t262_530 t262 ;
   struct __anonstruct_t263_531 t263 ;
   struct __anonstruct_t264_532 t264 ;
   struct __anonstruct_t265_533 t265 ;
   struct __anonstruct_t266_534 t266 ;
   struct __anonstruct_t267_535 t267 ;
   struct __anonstruct_t268_536 t268 ;
   struct __anonstruct_t269_537 t269 ;
   struct __anonstruct_t270_538 t270 ;
   struct __anonstruct_t271_539 t271 ;
   struct __anonstruct_t272_540 t272 ;
   struct __anonstruct_t273_541 t273 ;
   struct __anonstruct_t274_542 t274 ;
   struct __anonstruct_t275_543 t275 ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_tmpl.h"
struct qla27xx_fwdt_entry {
   struct __anonstruct_hdr_520 hdr ;
   union __anonunion____missing_field_name_521 __annonCompField128 ;
};
#line 707 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
struct qla27xx_fwdt_entry_call {
   uint type ;
   int (*call)(struct scsi_qla_host * , struct qla27xx_fwdt_entry * , void * , ulong * ) ;
};
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 72 "./arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 80
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 82
  return;
}
}
#line 110 "./arch/x86/include/asm/bitops.h"
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 117
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 119
  return;
}
}
#line 204 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 206
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 206
  return ((int )((signed char )c) != 0);
}
}
#line 250 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_clear_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 252
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 252
  return ((int )((signed char )c) != 0);
}
}
#line 308 "./arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 310
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
#line 402 "include/linux/kernel.h"
extern int sprintf(char * , char const   *  , ...) ;
#line 405
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 3 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
bool ldv_is_err(void const   *ptr ) ;
#line 6
long ldv_ptr_err(void const   *ptr ) ;
#line 25 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 48
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 75 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 77
  __list_add(new, head->prev, head);
#line 78
  return;
}
}
#line 112
extern void __list_del_entry(struct list_head * ) ;
#line 113
extern void list_del(struct list_head * ) ;
#line 143 "include/linux/list.h"
__inline static void list_del_init(struct list_head *entry ) 
{ 


  {
#line 145
  __list_del_entry(entry);
#line 146
  INIT_LIST_HEAD(entry);
#line 147
  return;
}
}
#line 187 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 189
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 274 "include/linux/list.h"
__inline static void __list_splice(struct list_head  const  *list , struct list_head *prev ,
                                   struct list_head *next ) 
{ 
  struct list_head *first ;
  struct list_head *last ;

  {
#line 278
  first = list->next;
#line 279
  last = list->prev;
#line 281
  first->prev = prev;
#line 282
  prev->next = first;
#line 284
  last->next = next;
#line 285
  next->prev = last;
#line 286
  return;
}
}
#line 293 "include/linux/list.h"
__inline static void list_splice(struct list_head  const  *list , struct list_head *head ) 
{ 
  int tmp ;

  {
#line 296
  tmp = list_empty(list);
#line 296
  if (tmp == 0) {
#line 297
    __list_splice(list, head, head->next);
  } else {

  }
#line 298
  return;
}
}
#line 319 "include/linux/list.h"
__inline static void list_splice_init(struct list_head *list , struct list_head *head ) 
{ 
  int tmp ;

  {
#line 322
  tmp = list_empty((struct list_head  const  *)list);
#line 322
  if (tmp == 0) {
#line 323
    __list_splice((struct list_head  const  *)list, head, head->next);
#line 324
    INIT_LIST_HEAD(list);
  } else {

  }
#line 326
  return;
}
}
#line 87 "./arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 10 "./arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "./arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3129;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3129;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3129;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3129;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_3129: ;
#line 14
  return (pfo_ret__);
}
}
#line 30 "./arch/x86/include/asm/string_64.h"
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 57
extern void *memset(void * , int  , size_t  ) ;
#line 65
extern char *strcpy(char * , char const   * ) ;
#line 66
extern char *strcat(char * , char const   * ) ;
#line 112 "include/linux/bitmap.h"
extern int __bitmap_weight(unsigned long const   * , unsigned int  ) ;
#line 298 "include/linux/bitmap.h"
__inline static int bitmap_weight(unsigned long const   *src , unsigned int nbits ) 
{ 
  int tmp___0 ;

  {
#line 302
  tmp___0 = __bitmap_weight(src, nbits);
#line 302
  return (tmp___0);
}
}
#line 37 "include/linux/cpumask.h"
extern int nr_cpu_ids ;
#line 89
extern struct cpumask  const  * const  cpu_online_mask ;
#line 474 "include/linux/cpumask.h"
__inline static unsigned int cpumask_weight(struct cpumask  const  *srcp ) 
{ 
  int tmp ;

  {
#line 476
  tmp = bitmap_weight((unsigned long const   *)(& srcp->bits), (unsigned int )nr_cpu_ids);
#line 476
  return ((unsigned int )tmp);
}
}
#line 32 "include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 561 "./arch/x86/include/asm/processor.h"
__inline static void rep_nop(void) 
{ 


  {
#line 563
  __asm__  volatile   ("rep; nop": : : "memory");
#line 564
  return;
}
}
#line 566 "./arch/x86/include/asm/processor.h"
__inline static void cpu_relax(void) 
{ 


  {
#line 568
  rep_nop();
#line 569
  return;
}
}
#line 11 "./arch/x86/include/asm/cmpxchg.h"
extern void __xchg_wrong_size(void) ;
#line 25 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 
  int __var ;

  {
#line 27
  __var = 0;
#line 27
  return ((int )*((int const volatile   *)(& v->counter)));
}
}
#line 37 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 39
  v->counter = i;
#line 40
  return;
}
}
#line 90 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 92
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 94
  return;
}
}
#line 102 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_dec(atomic_t *v ) 
{ 


  {
#line 104
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0": "+m" (v->counter));
#line 106
  return;
}
}
#line 116 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_dec_and_test(atomic_t *v ) 
{ 
  char c ;

  {
#line 118
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0; sete %1": "+m" (v->counter),
                       "=qm" (c): : "memory");
#line 118
  return ((int )((signed char )c) != 0);
}
}
#line 8 "./arch/x86/include/asm/preempt.h"
extern int __preempt_count ;
#line 20 "./arch/x86/include/asm/preempt.h"
__inline static int preempt_count(void) 
{ 
  int pfo_ret__ ;

  {
#line 22
  switch (4UL) {
  case 1UL: 
#line 22
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6002;
  case 2UL: 
#line 22
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6002;
  case 4UL: 
#line 22
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6002;
  case 8UL: 
#line 22
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6002;
  default: 
#line 22
  __bad_percpu_size();
  }
  ldv_6002: ;
#line 22
  return (pfo_ret__ & 2147483647);
}
}
#line 280 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 34 "include/linux/spinlock_api_smp.h"
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
#line 45
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 299 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 301
  return (& lock->__annonCompField18.rlock);
}
}
#line 370 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 372
  _raw_spin_unlock_irqrestore(& lock->__annonCompField18.rlock, flags);
#line 373
  return;
}
}
#line 72 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 119 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 138
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
#line 174
extern void mutex_unlock(struct mutex * ) ;
#line 73 "include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ 
  struct lock_class_key __key ;

  {
#line 75
  x->done = 0U;
#line 76
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
#line 78
  return;
}
}
#line 106
extern void complete(struct completion * ) ;
#line 78 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 170 "include/linux/timer.h"
extern int mod_timer(struct timer_list * , unsigned long  ) ;
#line 173
int ldv_mod_timer_11(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 224
extern void add_timer(struct timer_list * ) ;
#line 229
extern int del_timer_sync(struct timer_list * ) ;
#line 232
int ldv_del_timer_sync_12(struct timer_list *ldv_func_arg1 ) ;
#line 181 "include/linux/workqueue.h"
extern void __init_work(struct work_struct * , int  ) ;
#line 361
extern struct workqueue_struct *__alloc_workqueue_key(char const   * , unsigned int  ,
                                                      int  , struct lock_class_key * ,
                                                      char const   *  , ...) ;
#line 421
extern void destroy_workqueue(struct workqueue_struct * ) ;
#line 424
void ldv_destroy_workqueue_13(struct workqueue_struct *ldv_func_arg1 ) ;
#line 428
void ldv_destroy_workqueue_16(struct workqueue_struct *ldv_func_arg1 ) ;
#line 432
void ldv_destroy_workqueue_18(struct workqueue_struct *ldv_func_arg1 ) ;
#line 436
void ldv_destroy_workqueue_22(struct workqueue_struct *ldv_func_arg1 ) ;
#line 445
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
#line 449
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 453
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 455
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
#line 459
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 463
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 468
extern void flush_workqueue(struct workqueue_struct * ) ;
#line 471
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) ;
#line 475
void ldv_flush_workqueue_14(struct workqueue_struct *ldv_func_arg1 ) ;
#line 479
void ldv_flush_workqueue_15(struct workqueue_struct *ldv_func_arg1 ) ;
#line 488
extern bool cancel_work_sync(struct work_struct * ) ;
#line 491
bool ldv_cancel_work_sync_17(struct work_struct *ldv_func_arg1 ) ;
#line 495
bool ldv_cancel_work_sync_19(struct work_struct *ldv_func_arg1 ) ;
#line 499
bool ldv_cancel_work_sync_20(struct work_struct *ldv_func_arg1 ) ;
#line 503
bool ldv_cancel_work_sync_21(struct work_struct *ldv_func_arg1 ) ;
#line 507
bool ldv_cancel_work_sync_23(struct work_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_5(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 57 "./arch/x86/include/asm/io.h"
__inline static unsigned short readw(void const volatile   *addr ) 
{ 
  unsigned short ret ;

  {
#line 57
  __asm__  volatile   ("movw %1,%0": "=r" (ret): "m" (*((unsigned short volatile   *)addr)): "memory");
#line 57
  return (ret);
}
}
#line 58 "./arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile   *addr ) 
{ 
  unsigned int ret ;

  {
#line 58
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)): "memory");
#line 58
  return (ret);
}
}
#line 65 "./arch/x86/include/asm/io.h"
__inline static void writew(unsigned short val , void volatile   *addr ) 
{ 


  {
#line 65
  __asm__  volatile   ("movw %0,%1": : "r" (val), "m" (*((unsigned short volatile   *)addr)): "memory");
#line 66
  return;
}
}
#line 66 "./arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 


  {
#line 66
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
#line 67
  return;
}
}
#line 181
extern void *ioremap_nocache(resource_size_t  , unsigned long  ) ;
#line 190 "./arch/x86/include/asm/io.h"
__inline static void *ioremap(resource_size_t offset , unsigned long size ) 
{ 
  void *tmp ;

  {
#line 192
  tmp = ioremap_nocache(offset, size);
#line 192
  return (tmp);
}
}
#line 195
extern void iounmap(void volatile   * ) ;
#line 86 "include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 88
  return ((char const   *)kobj->name);
}
}
#line 215
extern int kobject_uevent_env(struct kobject * , enum kobject_action  , char ** ) ;
#line 425 "include/linux/sched.h"
extern void schedule(void) ;
#line 2322
extern void set_user_nice(struct task_struct * , long  ) ;
#line 2410
extern int wake_up_process(struct task_struct * ) ;
#line 116 "include/linux/slab.h"
extern struct kmem_cache *kmem_cache_create(char const   * , size_t  , size_t  , unsigned long  ,
                                            void (*)(void * ) ) ;
#line 119
extern void kmem_cache_destroy(struct kmem_cache * ) ;
#line 143
extern void kfree(void const   * ) ;
#line 289
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 418 "include/linux/slab.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 435
  tmp___2 = __kmalloc(size, flags);
#line 435
  return (tmp___2);
}
}
#line 581 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 583
  tmp = kmalloc(size, flags | 32768U);
#line 583
  return (tmp);
}
}
#line 6 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t  ) ;
#line 7
extern void *calloc(size_t  , size_t  ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int  ) ;
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
#line 53
  tmp = calloc(1UL, size);
#line 53
  p = tmp;
#line 54
  __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 55
  return (p);
}
}
#line 58 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
#line 59
  tmp = memset(s, c, n);
#line 59
  return (tmp);
}
}
#line 62 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 63
  tmp = __VERIFIER_nondet_int();
#line 63
  return (tmp);
}
}
#line 66 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 67
  tmp = __VERIFIER_nondet_pointer();
#line 67
  return (tmp);
}
}
#line 70 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 71
  tmp = __VERIFIER_nondet_ulong();
#line 71
  return (tmp);
}
}
#line 22 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 54
  return (exp);
}
}
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct kobject *sysfs_fw_dump_attr_group0  ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_22  =    0;
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_9_2  ;
#line 23 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_47  ;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_20  ;
#line 25 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_3_1  ;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_qla_host *qla2300_isp_ops_group0  ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_12_3  ;
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_26  ;
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_port *qla24xx_isp_ops_group2  ;
#line 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_1_1  ;
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct device_attribute *dev_attr_beacon_group0  ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_qla_host *qla81xx_isp_ops_group0  ;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_9_3  ;
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_29  ;
#line 35 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_54  ;
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_14  ;
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct kobject *sysfs_fw_dump_template_attr_group0  ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_37  ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_17  ;
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_51  ;
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_10_1  ;
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_qla_host *qlafx00_isp_ops_group0  ;
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_7_2  ;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_66  ;
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_19  ;
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_18  ;
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_4_3  ;
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_27  ;
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_9  ;
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_7_1  ;
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_2_2  ;
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_42  ;
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_83  ;
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_3_3  ;
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_11_0  ;
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_4_0  ;
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_7  ;
#line 58 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_port *qla83xx_isp_ops_group2  ;
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_55  ;
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_port *qla27xx_isp_ops_group2  ;
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_rport *qla2xxx_transport_vport_functions_group2  ;
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_1_3  ;
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_2_1  ;
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_4_0  ;
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_3_2  ;
#line 66 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_target *qla2xxx_transport_vport_functions_group1  ;
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_80  ;
#line 68 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_12_3  ;
#line 69 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct Scsi_Host *qla2xxx_transport_vport_functions_group0  ;
#line 70 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_7_2  ;
#line 71 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_64  ;
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct pci_dev *qla2xxx_pci_driver_group1  ;
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_26  ;
#line 74 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_28  ;
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_7_0  ;
#line 76 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_20  ;
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_17  ;
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_6_0  ;
#line 80 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_port *qla8044_isp_ops_group2  ;
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_18  =    0;
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_8_3  ;
#line 83 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_58  ;
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct bin_attribute *sysfs_fw_dump_attr_group2  ;
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_5_2  ;
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_7_1  ;
#line 87 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_78  ;
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_76  ;
#line 89 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_31  ;
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_6_2  ;
#line 91 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_68  ;
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_2_1  ;
#line 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_vport *qla2xxx_transport_functions_group2  ;
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_8  ;
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_46  ;
#line 96 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_15  ;
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_1_3  ;
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_8_0  ;
#line 99 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_75  ;
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct qla_hw_data *qla8044_isp_ops_group1  ;
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_74  ;
#line 102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct file *sysfs_fw_dump_template_attr_group1  ;
#line 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_21  ;
#line 104 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_33  ;
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_8_0  ;
#line 106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_port *qla25xx_isp_ops_group2  ;
#line 107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_69  ;
#line 108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct qla_hw_data *qla81xx_isp_ops_group1  ;
#line 109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_21  ;
#line 110 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_3_0  ;
#line 111 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_11_1  ;
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_10_0  ;
#line 113 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_88  ;
#line 114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_65  ;
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_12_2  ;
#line 116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct qla_hw_data *qla82xx_isp_ops_group1  ;
#line 117 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct kobject *sysfs_optrom_attr_group0  ;
#line 118 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_70  ;
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct qla_hw_data *qlafx00_isp_ops_group1  ;
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_62  ;
#line 121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_41  ;
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_5_3  ;
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_40  ;
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_17  =    0;
#line 125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_19  ;
#line 126 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_6_1  ;
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct device *dev_attr_zio_group1  ;
#line 128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct device *dev_attr_zio_timer_group1  ;
#line 129 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_1_0  ;
#line 130 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_10  ;
#line 131 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_7_0  ;
#line 132 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_12_0  ;
#line 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_4_1  ;
#line 134 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct kobject *sysfs_vpd_attr_group0  ;
#line 135 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct inode *dfs_fce_ops_group1  ;
#line 136 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_63  ;
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_10_1  ;
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_7_3  ;
#line 139 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct kobject *sysfs_nvram_attr_group0  ;
#line 140 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_2  ;
#line 141 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_25  ;
#line 142 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_29  =    0;
#line 143 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_2_0  ;
#line 144 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct file *sysfs_optrom_attr_group1  ;
#line 145 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_device *qla2xxx_driver_template_group2  ;
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_10_0  ;
#line 147 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct pci_dev *qla2xxx_err_handler_group0  ;
#line 148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_4_2  ;
#line 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_11  ;
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_1_2  ;
#line 151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_79  ;
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_27  ;
#line 153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_18  ;
#line 154 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_5_0  ;
#line 155 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct device *dev_attr_beacon_group1  ;
#line 156 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_9_1  ;
#line 157 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_13  ;
#line 158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_2_2  ;
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_30  =    0;
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_32  ;
#line 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_11_3  ;
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct qla_hw_data *qla25xx_isp_ops_group1  ;
#line 163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_bsg_job *qla2xxx_transport_vport_functions_group3  ;
#line 164 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_11_2  ;
#line 165 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int pci_counter  ;
#line 166 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_qla_host *qla24xx_isp_ops_group0  ;
#line 167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_30  ;
#line 168 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_8_1  ;
#line 169 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_0  ;
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_81  ;
#line 171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_45  ;
#line 172 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_23  =    0;
#line 173 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct qla_hw_data *qla2100_isp_ops_group1  ;
#line 174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_12  ;
#line 175 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_22  ;
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_87  ;
#line 177 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_16  =    0;
#line 178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_22  ;
#line 179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_16  ;
#line 180 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_port *qla2300_isp_ops_group2  ;
#line 181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_73  ;
#line 182 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_28  =    0;
#line 183 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_29  ;
#line 184 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_24  ;
#line 185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_port *qlafx00_isp_ops_group2  ;
#line 186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct Scsi_Host *qla2xxx_transport_functions_group0  ;
#line 187 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct device *dev_attr_allow_cna_fw_dump_group1  ;
#line 188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_8_1  ;
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_2_0  ;
#line 190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_61  ;
#line 191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_6_0  ;
#line 192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_9_0  ;
#line 193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_qla_host *qla82xx_isp_ops_group0  ;
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_6_1  ;
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ref_cnt  ;
#line 196 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_10_3  ;
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_8_3  ;
#line 198 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_qla_host *qla27xx_isp_ops_group0  ;
#line 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_3_3  ;
#line 200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_23  ;
#line 201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_72  ;
#line 202 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_1_1  ;
#line 203 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_59  ;
#line 204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct file *sysfs_vpd_attr_group1  ;
#line 205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_6  ;
#line 206 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_26  =    0;
#line 207 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_5_0  ;
#line 208 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_50  ;
#line 209 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_4_2  ;
#line 210 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_84  ;
#line 211 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_86  ;
#line 212 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_44  ;
#line 213 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_38  ;
#line 214 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_39  ;
#line 215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_5_1  ;
#line 216 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_56  ;
#line 217 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_3  ;
#line 218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct file *sysfs_nvram_attr_group1  ;
#line 219 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_28  ;
#line 220 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_12_1  ;
#line 221 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_52  ;
#line 222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_11_0  ;
#line 223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_rport *qla2xxx_transport_functions_group3  ;
#line 224 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_1_0  ;
#line 225 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_11_2  ;
#line 226 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct file *apidev_fops_group2  ;
#line 227 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_4  ;
#line 228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_9_0  ;
#line 229 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_9_3  ;
#line 230 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_10_2  ;
#line 231 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct device_attribute *dev_attr_allow_cna_fw_dump_group0  ;
#line 232 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct device_attribute *dev_attr_zio_timer_group0  ;
#line 233 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_60  ;
#line 234 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_36  ;
#line 235 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_9_2  ;
#line 236 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct qla_hw_data *qla83xx_isp_ops_group1  ;
#line 237 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_6_3  ;
#line 238 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_48  ;
#line 239 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_5_2  ;
#line 240 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_23  ;
#line 241 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_9_1  ;
#line 242 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_5  ;
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_5_3  ;
#line 244 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_25  ;
#line 245 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct qla_hw_data *qla2300_isp_ops_group1  ;
#line 246 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_13  ;
#line 247 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_19  =    0;
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_24  =    0;
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct qla_hw_data *qla27xx_isp_ops_group1  ;
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_port *qla81xx_isp_ops_group2  ;
#line 251 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_3_2  ;
#line 252 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_cmnd *qla2xxx_driver_template_group0  ;
#line 253 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_qla_host *qla2100_isp_ops_group0  ;
#line 254 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct qla_hw_data *qla24xx_isp_ops_group1  ;
#line 255 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_port *qla82xx_isp_ops_group2  ;
#line 256 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_qla_host *qla25xx_isp_ops_group0  ;
#line 257 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_82  ;
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_2_3  ;
#line 259 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_14  =    0;
#line 260 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct bin_attribute *sysfs_optrom_attr_group2  ;
#line 261 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_11_1  ;
#line 262 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_15  ;
#line 263 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct device_attribute *dev_attr_zio_group0  ;
#line 264 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_49  ;
#line 265 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_27  =    0;
#line 266 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_24  ;
#line 267 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_7_3  ;
#line 268 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_12_0  ;
#line 269 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct file *dfs_fce_ops_group2  ;
#line 270 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_1  ;
#line 271 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct Scsi_Host *qla2xxx_driver_template_group1  ;
#line 272 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_21  =    0;
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_85  ;
#line 274 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_25  =    0;
#line 275 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_12_1  ;
#line 276 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_qla_host *qla83xx_isp_ops_group0  ;
#line 277 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_14  ;
#line 278 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_71  ;
#line 279 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_6_2  ;
#line 280 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_10_2  ;
#line 281 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_target *qla2xxx_transport_functions_group1  ;
#line 282 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_port *qla2100_isp_ops_group2  ;
#line 283 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_77  ;
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct file *sysfs_fw_dump_attr_group1  ;
#line 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_8_2  ;
#line 286 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_30  ;
#line 287 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_4_3  ;
#line 288 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_3_1  ;
#line 289 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_16  ;
#line 290 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_12_2  ;
#line 291 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_43  ;
#line 292 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_5_1  ;
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct bin_attribute *sysfs_vpd_attr_group2  ;
#line 294 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_57  ;
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_6_3  ;
#line 296 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct bin_attribute *sysfs_nvram_attr_group2  ;
#line 297 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_3_0  ;
#line 298 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_20  =    0;
#line 299 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_bsg_job *qla2xxx_transport_functions_group4  ;
#line 300 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_67  ;
#line 301 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_53  ;
#line 303 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_15  =    0;
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_1_2  ;
#line 305 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_13  =    0;
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_8_2  ;
#line 307 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_4_1  ;
#line 308 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_34  ;
#line 309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct bin_attribute *sysfs_fw_dump_template_attr_group2  ;
#line 310 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_2_3  ;
#line 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_work_10_3  ;
#line 312 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void *apidev_fops_group1  ;
#line 313 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_qla_host *qla8044_isp_ops_group0  ;
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_35  ;
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct work_struct *ldv_work_struct_11_3  ;
#line 316
void activate_work_5(struct work_struct *work , int state ) ;
#line 317
void choose_timer_13(struct timer_list *timer ) ;
#line 318
void ldv_initialize_isp_operations_85(void) ;
#line 320
void ldv_initialize_isp_operations_78(void) ;
#line 324
void work_init_9(void) ;
#line 325
void work_init_5(void) ;
#line 329
void call_and_disable_all_4(int state ) ;
#line 332
void activate_work_1(struct work_struct *work , int state ) ;
#line 334
void ldv_initialize_isp_operations_81(void) ;
#line 335
int reg_timer_21(struct timer_list *timer ) ;
#line 336
void call_and_disable_work_3(struct work_struct *work ) ;
#line 340
void disable_work_7(struct work_struct *work ) ;
#line 341
void disable_work_3(struct work_struct *work ) ;
#line 343
void ldv_initialize_isp_operations_82(void) ;
#line 344
void work_init_1(void) ;
#line 347
void disable_suitable_timer_21(struct timer_list *timer ) ;
#line 349
void invoke_work_4(void) ;
#line 350
void ldv_initialize_device_attribute_53(void) ;
#line 354
void ldv_initialize_bin_attribute_69(void) ;
#line 357
void activate_pending_timer_13(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 364
void work_init_8(void) ;
#line 365
void ldv_initialize_fc_function_template_32(void) ;
#line 366
void ldv_pci_driver_76(void) ;
#line 367
void activate_work_2(struct work_struct *work , int state ) ;
#line 372
void ldv_file_operations_31(void) ;
#line 373
void work_init_10(void) ;
#line 374
void invoke_work_5(void) ;
#line 375
void ldv_initialize_scsi_host_template_88(void) ;
#line 377
void ldv_initialize_isp_operations_79(void) ;
#line 378
void ldv_initialize_isp_operations_83(void) ;
#line 382
void disable_work_4(struct work_struct *work ) ;
#line 383
void work_init_4(void) ;
#line 387
void invoke_work_1(void) ;
#line 391
void ldv_initialize_device_attribute_54(void) ;
#line 392
void call_and_disable_all_3(int state ) ;
#line 393
void activate_pending_timer_14(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 394
void call_and_disable_work_4(struct work_struct *work ) ;
#line 395
void ldv_initialize_bin_attribute_71(void) ;
#line 397
void ldv_initialize_fc_function_template_33(void) ;
#line 398
void work_init_3(void) ;
#line 399
void call_and_disable_all_7(int state ) ;
#line 401
void call_and_disable_work_1(struct work_struct *work ) ;
#line 403
void disable_suitable_timer_13(struct timer_list *timer ) ;
#line 404
void ldv_initialize_bin_attribute_73(void) ;
#line 407
void work_init_11(void) ;
#line 408
void ldv_file_operations_75(void) ;
#line 409
void ldv_initialize_bin_attribute_72(void) ;
#line 413
void call_and_disable_all_2(int state ) ;
#line 416
void activate_work_3(struct work_struct *work , int state ) ;
#line 422
void work_init_7(void) ;
#line 423
void ldv_initialize_isp_operations_87(void) ;
#line 427
void disable_work_5(struct work_struct *work ) ;
#line 431
void disable_work_1(struct work_struct *work ) ;
#line 433
void ldv_initialize_isp_operations_80(void) ;
#line 437
void call_and_disable_work_5(struct work_struct *work ) ;
#line 440
int reg_timer_14(struct timer_list *timer ) ;
#line 442
void invoke_work_2(void) ;
#line 444
void ldv_initialize_device_attribute_55(void) ;
#line 445
void ldv_initialize_pci_error_handlers_77(void) ;
#line 446
void activate_work_4(struct work_struct *work , int state ) ;
#line 447
void ldv_initialize_isp_operations_84(void) ;
#line 448
void call_and_disable_all_5(int state ) ;
#line 450
void work_init_2(void) ;
#line 453
void disable_suitable_timer_14(struct timer_list *timer ) ;
#line 454
void call_and_disable_all_1(int state ) ;
#line 457
void ldv_initialize_bin_attribute_74(void) ;
#line 459
void work_init_6(void) ;
#line 460
void work_init_12(void) ;
#line 466
void ldv_initialize_isp_operations_86(void) ;
#line 469
void activate_pending_timer_21(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 470
void activate_work_7(struct work_struct *work , int state ) ;
#line 473
void disable_work_2(struct work_struct *work ) ;
#line 476
void ldv_initialize_device_attribute_34(void) ;
#line 477
void invoke_work_3(void) ;
#line 478
int reg_timer_13(struct timer_list *timer ) ;
#line 480
void choose_timer_14(struct timer_list *timer ) ;
#line 486
void call_and_disable_work_2(struct work_struct *work ) ;
#line 832 "include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 835
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 836
    return ((char const   *)dev->init_name);
  } else {

  }
#line 838
  tmp = kobject_name(& dev->kobj);
#line 838
  return (tmp);
}
}
#line 863 "include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 865
  return ((void *)dev->driver_data);
}
}
#line 868 "include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
#line 870
  dev->driver_data = data;
#line 871
  return;
}
}
#line 399 "include/linux/pci.h"
__inline static int pci_channel_offline(struct pci_dev *pdev ) 
{ 


  {
#line 401
  return (pdev->error_state != 1U);
}
}
#line 812
extern void pci_dev_put(struct pci_dev * ) ;
#line 847
extern struct pci_dev *pci_get_domain_bus_and_slot(int  , unsigned int  , unsigned int  ) ;
#line 857
extern int pci_bus_read_config_byte(struct pci_bus * , unsigned int  , int  , u8 * ) ;
#line 859
extern int pci_bus_read_config_word(struct pci_bus * , unsigned int  , int  , u16 * ) ;
#line 881 "include/linux/pci.h"
__inline static int pci_read_config_byte(struct pci_dev  const  *dev , int where ,
                                         u8 *val ) 
{ 
  int tmp ;

  {
#line 883
  tmp = pci_bus_read_config_byte(dev->bus, dev->devfn, where, val);
#line 883
  return (tmp);
}
}
#line 885 "include/linux/pci.h"
__inline static int pci_read_config_word(struct pci_dev  const  *dev , int where ,
                                         u16 *val ) 
{ 
  int tmp ;

  {
#line 887
  tmp = pci_bus_read_config_word(dev->bus, dev->devfn, where, val);
#line 887
  return (tmp);
}
}
#line 909
extern int pcie_capability_read_dword(struct pci_dev * , int  , u32 * ) ;
#line 949
extern int pci_enable_device(struct pci_dev * ) ;
#line 951
extern int pci_enable_device_mem(struct pci_dev * ) ;
#line 966
extern void pci_disable_device(struct pci_dev * ) ;
#line 1011
extern int pci_select_bars(struct pci_dev * , unsigned long  ) ;
#line 1024
extern int pci_save_state(struct pci_dev * ) ;
#line 1025
extern void pci_restore_state(struct pci_dev * ) ;
#line 1098
extern int pci_request_selected_regions(struct pci_dev * , int  , char const   * ) ;
#line 1100
extern void pci_release_selected_regions(struct pci_dev * , int  ) ;
#line 1140
extern int __pci_register_driver(struct pci_driver * , struct module * , char const   * ) ;
#line 1144
int ldv___pci_register_driver_28(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                 char const   *ldv_func_arg3 ) ;
#line 1153
extern void pci_unregister_driver(struct pci_driver * ) ;
#line 1156
void ldv_pci_unregister_driver_30(struct pci_driver *ldv_func_arg1 ) ;
#line 19 "include/linux/dmapool.h"
extern struct dma_pool *dma_pool_create(char const   * , struct device * , size_t  ,
                                        size_t  , size_t  ) ;
#line 22
extern void dma_pool_destroy(struct dma_pool * ) ;
#line 24
extern void *dma_pool_alloc(struct dma_pool * , gfp_t  , dma_addr_t * ) ;
#line 27
extern void dma_pool_free(struct dma_pool * , void * , dma_addr_t  ) ;
#line 32 "./arch/x86/include/asm/pci.h"
__inline static int pci_domain_nr(struct pci_bus *bus ) 
{ 
  struct pci_sysdata *sd ;

  {
#line 34
  sd = (struct pci_sysdata *)bus->sysdata;
#line 35
  return (sd->domain);
}
}
#line 73 "include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction ) 
{ 


  {
#line 75
  return ((dma_direction == 0 || dma_direction == 1) || dma_direction == 2);
}
}
#line 50 "include/linux/dma-debug.h"
extern void debug_dma_unmap_sg(struct device * , struct scatterlist * , int  , int  ) ;
#line 30 "./arch/x86/include/asm/dma-mapping.h"
extern struct dma_map_ops *dma_ops ;
#line 32 "./arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 
  long tmp ;

  {
#line 37
  tmp = ldv__builtin_expect((unsigned long )dev == (unsigned long )((struct device *)0),
                         0L);
#line 37
  if (tmp != 0L || (unsigned long )dev->archdata.dma_ops == (unsigned long )((struct dma_map_ops *)0)) {
#line 38
    return (dma_ops);
  } else {
#line 40
    return (dev->archdata.dma_ops);
  }
}
}
#line 64 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_sg_attrs(struct device *dev , struct scatterlist *sg ,
                                        int nents , enum dma_data_direction dir ,
                                        struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 68
  tmp = get_dma_ops(dev);
#line 68
  ops = tmp;
#line 70
  tmp___0 = valid_dma_direction((int )dir);
#line 70
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 70
  if (tmp___1 != 0L) {
#line 70
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (70), "i" (12UL));
    ldv_27049: ;
#line 70
    goto ldv_27049;
  } else {

  }
#line 71
  debug_dma_unmap_sg(dev, sg, nents, (int )dir);
#line 72
  if ((unsigned long )ops->unmap_sg != (unsigned long )((void (*)(struct device * ,
                                                                  struct scatterlist * ,
                                                                  int  , enum dma_data_direction  ,
                                                                  struct dma_attrs * ))0)) {
#line 73
    (*(ops->unmap_sg))(dev, sg, nents, dir, attrs);
  } else {

  }
#line 74
  return;
}
}
#line 60 "./arch/x86/include/asm/dma-mapping.h"
extern int dma_supported(struct device * , u64  ) ;
#line 61
extern int dma_set_mask(struct device * , u64  ) ;
#line 131
extern void *dma_alloc_attrs(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
#line 136
extern void dma_free_attrs(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
#line 101 "include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev , u64 mask ) 
{ 
  int tmp ;

  {
#line 103
  tmp = dma_supported(dev, mask);
#line 103
  if (tmp == 0) {
#line 104
    return (-5);
  } else {

  }
#line 105
  dev->coherent_dma_mask = mask;
#line 106
  return (0);
}
}
#line 134
extern u64 dma_get_required_mask(struct device * ) ;
#line 118 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_consistent_dma_mask(struct pci_dev *dev , u64 mask ) 
{ 
  int tmp ;

  {
#line 120
  tmp = dma_set_coherent_mask(& dev->dev, mask);
#line 120
  return (tmp);
}
}
#line 1468 "include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
#line 1470
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
#line 1470
  return (tmp);
}
}
#line 1473 "include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 


  {
#line 1475
  dev_set_drvdata(& pdev->dev, data);
#line 1476
  return;
}
}
#line 1481 "include/linux/pci.h"
__inline static char const   *pci_name(struct pci_dev  const  *pdev ) 
{ 
  char const   *tmp ;

  {
#line 1483
  tmp = dev_name(& pdev->dev);
#line 1483
  return (tmp);
}
}
#line 1715 "include/linux/pci.h"
__inline static int pci_pcie_cap(struct pci_dev *dev ) 
{ 


  {
#line 1717
  return ((int )dev->pcie_cap);
}
}
#line 1726 "include/linux/pci.h"
__inline static bool pci_is_pcie(struct pci_dev *dev ) 
{ 
  int tmp ;

  {
#line 1728
  tmp = pci_pcie_cap(dev);
#line 1728
  return (tmp != 0);
}
}
#line 26 "include/linux/mempool.h"
extern mempool_t *mempool_create(int  , mempool_alloc_t * , mempool_free_t * , void * ) ;
#line 33
extern void mempool_destroy(mempool_t * ) ;
#line 34
extern void *mempool_alloc(mempool_t * , gfp_t  ) ;
#line 35
extern void mempool_free(void * , mempool_t * ) ;
#line 42
extern void *mempool_alloc_slab(gfp_t  , void * ) ;
#line 43
extern void mempool_free_slab(void * , void * ) ;
#line 45 "include/linux/mempool.h"
__inline static mempool_t *mempool_create_slab_pool(int min_nr , struct kmem_cache *kc ) 
{ 
  mempool_t *tmp ;

  {
#line 47
  tmp = mempool_create(min_nr, & mempool_alloc_slab, & mempool_free_slab, (void *)kc);
#line 47
  return (tmp);
}
}
#line 42 "include/linux/firmware.h"
extern int request_firmware(struct firmware  const  ** , char const   * , struct device * ) ;
#line 51
extern void release_firmware(struct firmware  const  * ) ;
#line 42 "include/linux/aer.h"
extern int pci_enable_pcie_error_reporting(struct pci_dev * ) ;
#line 43
extern int pci_disable_pcie_error_reporting(struct pci_dev * ) ;
#line 44
extern int pci_cleanup_aer_uncorrect_error_status(struct pci_dev * ) ;
#line 2330 "include/linux/fs.h"
extern int __register_chrdev(unsigned int  , unsigned int  , unsigned int  , char const   * ,
                             struct file_operations  const  * ) ;
#line 2333
extern void __unregister_chrdev(unsigned int  , unsigned int  , unsigned int  , char const   * ) ;
#line 2338 "include/linux/fs.h"
__inline static int register_chrdev(unsigned int major , char const   *name , struct file_operations  const  *fops ) 
{ 
  int tmp ;

  {
#line 2341
  tmp = __register_chrdev(major, 0U, 256U, name, fops);
#line 2341
  return (tmp);
}
}
#line 2347
__inline static int ldv_register_chrdev_27(unsigned int major , char const   *name ,
                                           struct file_operations  const  *fops ) ;
#line 2348 "include/linux/fs.h"
__inline static void unregister_chrdev(unsigned int major , char const   *name ) 
{ 


  {
#line 2350
  __unregister_chrdev(major, 0U, 256U, name);
#line 2351
  return;
}
}
#line 2362
__inline static void ldv_unregister_chrdev_29(unsigned int major , char const   *name ) ;
#line 2648
extern loff_t noop_llseek(struct file * , loff_t  , int  ) ;
#line 993 "include/linux/blkdev.h"
extern void blk_queue_update_dma_alignment(struct request_queue * , int  ) ;
#line 754 "include/scsi/scsi_host.h"
__inline static void *shost_priv(struct Scsi_Host *shost ) 
{ 


  {
#line 756
  return ((void *)(& shost->hostdata));
}
}
#line 789
extern struct Scsi_Host *scsi_host_alloc(struct scsi_host_template * , int  ) ;
#line 792
struct Scsi_Host *ldv_scsi_host_alloc_25(struct scsi_host_template *sht , int privsize ) ;
#line 794
extern int scsi_add_host_with_dma(struct Scsi_Host * , struct device * , struct device * ) ;
#line 799
int ldv_scsi_add_host_with_dma_10(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 801
extern void scsi_scan_host(struct Scsi_Host * ) ;
#line 803
extern void scsi_remove_host(struct Scsi_Host * ) ;
#line 806
void ldv_scsi_remove_host_24(struct Scsi_Host *shost ) ;
#line 810
void ldv_scsi_remove_host_26(struct Scsi_Host *shost ) ;
#line 812
extern struct Scsi_Host *scsi_host_get(struct Scsi_Host * ) ;
#line 813
extern void scsi_host_put(struct Scsi_Host * ) ;
#line 818 "include/scsi/scsi_host.h"
__inline static int scsi_add_host(struct Scsi_Host *host , struct device *dev ) 
{ 
  int tmp ;

  {
#line 821
  tmp = ldv_scsi_add_host_with_dma_10(host, dev, dev);
#line 821
  return (tmp);
}
}
#line 863 "include/scsi/scsi_host.h"
__inline static void scsi_host_set_prot(struct Scsi_Host *shost , unsigned int mask ) 
{ 


  {
#line 865
  shost->prot_capabilities = mask;
#line 866
  return;
}
}
#line 921 "include/scsi/scsi_host.h"
__inline static void scsi_host_set_guard(struct Scsi_Host *shost , unsigned char type ) 
{ 


  {
#line 923
  shost->prot_guard_type = type;
#line 924
  return;
}
}
#line 310 "include/scsi/scsi_device.h"
__inline static struct scsi_target *scsi_target(struct scsi_device *sdev ) 
{ 
  struct device  const  *__mptr ;

  {
#line 312
  __mptr = (struct device  const  *)sdev->sdev_gendev.parent;
#line 312
  return ((struct scsi_target *)__mptr + 0xffffffffffffffd8UL);
}
}
#line 379
extern int scsi_change_queue_depth(struct scsi_device * , int  ) ;
#line 169 "include/scsi/scsi_cmnd.h"
extern void scsi_dma_unmap(struct scsi_cmnd * ) ;
#line 256 "include/scsi/scsi_cmnd.h"
__inline static unsigned char scsi_get_prot_op(struct scsi_cmnd *scmd ) 
{ 


  {
#line 258
  return (scmd->prot_op);
}
}
#line 308 "include/scsi/scsi_cmnd.h"
__inline static unsigned int scsi_prot_sg_count(struct scsi_cmnd *cmd ) 
{ 


  {
#line 310
  return ((unsigned long )cmd->prot_sdb != (unsigned long )((struct scsi_data_buffer *)0) ? (cmd->prot_sdb)->table.nents : 0U);
}
}
#line 313 "include/scsi/scsi_cmnd.h"
__inline static struct scatterlist *scsi_prot_sglist(struct scsi_cmnd *cmd ) 
{ 


  {
#line 315
  return ((unsigned long )cmd->prot_sdb != (unsigned long )((struct scsi_data_buffer *)0) ? (cmd->prot_sdb)->table.sgl : (struct scatterlist *)0);
}
}
#line 772 "include/scsi/scsi_transport_fc.h"
__inline static int fc_remote_port_chkready(struct fc_rport *rport ) 
{ 
  int result ;

  {
#line 776
  switch ((unsigned int )rport->port_state) {
  case 2U: ;
#line 778
  if ((int )rport->roles & 1) {
#line 779
    result = 0;
  } else
#line 780
  if ((int )rport->flags & 1) {
#line 781
    result = 786432;
  } else {
#line 783
    result = 65536;
  }
#line 784
  goto ldv_41580;
  case 4U: ;
#line 786
  if (((int )rport->flags & 4) != 0) {
#line 787
    result = 983040;
  } else {
#line 789
    result = 786432;
  }
#line 790
  goto ldv_41580;
  default: 
#line 792
  result = 65536;
#line 793
  goto ldv_41580;
  }
  ldv_41580: ;
#line 795
  return (result);
}
}
#line 838
extern struct scsi_transport_template *fc_attach_transport(struct fc_function_template * ) ;
#line 840
extern void fc_release_transport(struct scsi_transport_template * ) ;
#line 841
extern void fc_remove_host(struct Scsi_Host * ) ;
#line 844
extern void fc_remote_port_delete(struct fc_rport * ) ;
#line 846
extern int scsi_is_fc_rport(struct device  const  * ) ;
#line 847
extern u32 fc_get_event_number(void) ;
#line 848
extern void fc_host_post_event(struct Scsi_Host * , u32  , enum fc_host_event_code  ,
                               u32  ) ;
#line 858
extern int fc_vport_terminate(struct fc_vport * ) ;
#line 859
extern int fc_block_scsi_eh(struct scsi_cmnd * ) ;
#line 2041 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
static char const   * const  port_state_str[5U]  = {      "Unknown",      "UNCONFIGURED",      "DEAD",      "LOST", 
        "ONLINE"};
#line 15 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int qla2x00_initialize_adapter(scsi_qla_host_t *vha ) ;
#line 17
int qla2100_pci_config(struct scsi_qla_host *vha ) ;
#line 18
int qla2300_pci_config(struct scsi_qla_host *vha ) ;
#line 19
int qla24xx_pci_config(scsi_qla_host_t *vha ) ;
#line 20
int qla25xx_pci_config(scsi_qla_host_t *vha ) ;
#line 21
void qla2x00_reset_chip(struct scsi_qla_host *vha ) ;
#line 22
void qla24xx_reset_chip(struct scsi_qla_host *vha ) ;
#line 23
int qla2x00_chip_diag(struct scsi_qla_host *vha ) ;
#line 24
int qla24xx_chip_diag(struct scsi_qla_host *vha ) ;
#line 25
void qla2x00_config_rings(struct scsi_qla_host *vha ) ;
#line 26
void qla24xx_config_rings(struct scsi_qla_host *vha ) ;
#line 27
void qla2x00_reset_adapter(struct scsi_qla_host *vha ) ;
#line 28
void qla24xx_reset_adapter(struct scsi_qla_host *vha ) ;
#line 29
int qla2x00_nvram_config(struct scsi_qla_host *vha ) ;
#line 30
int qla24xx_nvram_config(struct scsi_qla_host *vha ) ;
#line 31
int qla81xx_nvram_config(struct scsi_qla_host *vha ) ;
#line 32
void qla2x00_update_fw_options(struct scsi_qla_host *vha ) ;
#line 33
void qla24xx_update_fw_options(scsi_qla_host_t *vha ) ;
#line 34
void qla81xx_update_fw_options(scsi_qla_host_t *vha ) ;
#line 35
int qla2x00_load_risc(struct scsi_qla_host *vha , uint32_t *srisc_addr ) ;
#line 36
int qla24xx_load_risc(scsi_qla_host_t *vha , uint32_t *srisc_addr ) ;
#line 37
int qla81xx_load_risc(scsi_qla_host_t *vha , uint32_t *srisc_addr ) ;
#line 39
int qla2x00_perform_loop_resync(scsi_qla_host_t *ha ) ;
#line 40
int qla2x00_loop_resync(scsi_qla_host_t *vha ) ;
#line 42
int qla2x00_find_new_loop_id(scsi_qla_host_t *vha , fc_port_t *dev ) ;
#line 44
int qla2x00_fabric_login(scsi_qla_host_t *vha , fc_port_t *fcport , uint16_t *next_loopid ) ;
#line 45
int qla2x00_local_device_login(scsi_qla_host_t *vha , fc_port_t *fcport ) ;
#line 47
void qla2x00_update_fcports(scsi_qla_host_t *base_vha ) ;
#line 49
int qla2x00_abort_isp(scsi_qla_host_t *vha ) ;
#line 50
void qla2x00_abort_isp_cleanup(scsi_qla_host_t *vha ) ;
#line 51
void qla2x00_quiesce_io(scsi_qla_host_t *vha ) ;
#line 53
void qla2x00_update_fcport(scsi_qla_host_t *vha , fc_port_t *fcport ) ;
#line 56
void qla2x00_try_to_stop_firmware(scsi_qla_host_t *vha ) ;
#line 60
void qla84xx_put_chip(struct scsi_qla_host *vha ) ;
#line 62
int qla2x00_async_login(struct scsi_qla_host *vha , fc_port_t *fcport , uint16_t *data ) ;
#line 64
int qla2x00_async_logout(struct scsi_qla_host *vha , fc_port_t *fcport ) ;
#line 65
int qla2x00_async_adisc(struct scsi_qla_host *vha , fc_port_t *fcport , uint16_t *data ) ;
#line 68
void qla2x00_async_login_done(struct scsi_qla_host *vha , fc_port_t *fcport , uint16_t *data ) ;
#line 70
void qla2x00_async_logout_done(struct scsi_qla_host *vha , fc_port_t *fcport , uint16_t *data ) ;
#line 72
void qla2x00_async_adisc_done(struct scsi_qla_host *vha , fc_port_t *fcport , uint16_t *data ) ;
#line 81
int __qla83xx_set_idc_control(scsi_qla_host_t *vha , uint32_t idc_control ) ;
#line 82
int __qla83xx_get_idc_control(scsi_qla_host_t *vha , uint32_t *idc_control ) ;
#line 83
void qla83xx_idc_audit(scsi_qla_host_t *vha , int audit_type ) ;
#line 84
int qla83xx_nic_core_reset(scsi_qla_host_t *vha ) ;
#line 85
void qla83xx_reset_ownership(scsi_qla_host_t *vha ) ;
#line 86
int qla2xxx_mctp_dump(scsi_qla_host_t *vha ) ;
#line 95 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
char qla2x00_version_str[40U]  ;
#line 97
int ql2xlogintimeout ;
#line 98 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int qlport_down_retry  ;
#line 99 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int ql2xplogiabsentdevice  ;
#line 100
int ql2xloginretrycount ;
#line 101
int ql2xfdmienable ;
#line 102
int ql2xallocfwdump ;
#line 103 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int ql2xextended_error_logging  ;
#line 104
int ql2xiidmaenable ;
#line 105
int ql2xmaxqueues ;
#line 106 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int ql2xmultique_tag  ;
#line 107 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int ql2xfwloadbin  ;
#line 108 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int ql2xetsenable  ;
#line 109
int ql2xshiftctondsd ;
#line 110
int ql2xdbwr ;
#line 111 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int ql2xasynctmfenable  ;
#line 112 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int ql2xgffidenable  ;
#line 113
int ql2xenabledif ;
#line 114
int ql2xenablehba_err_chk ;
#line 115
int ql2xtargetreset ;
#line 116 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int ql2xdontresethba  ;
#line 117
uint64_t ql2xmaxlun ;
#line 118
int ql2xmdcapmask ;
#line 119
int ql2xmdenable ;
#line 121
int qla2x00_loop_reset(scsi_qla_host_t *vha ) ;
#line 122
void qla2x00_abort_all_cmds(scsi_qla_host_t *vha , int res ) ;
#line 123
int qla2x00_post_aen_work(struct scsi_qla_host *vha , enum fc_host_event_code code ,
                          u32 data ) ;
#line 125
int qla2x00_post_idc_ack_work(struct scsi_qla_host *vha , uint16_t *mb ) ;
#line 126
int qla2x00_post_async_login_work(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                  uint16_t *data ) ;
#line 128
int qla2x00_post_async_login_done_work(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                       uint16_t *data ) ;
#line 130
int qla2x00_post_async_logout_work(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                   uint16_t *data ) ;
#line 132
int qla2x00_post_async_logout_done_work(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                        uint16_t *data ) ;
#line 134
int qla2x00_post_async_adisc_work(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                  uint16_t *data ) ;
#line 136
int qla2x00_post_async_adisc_done_work(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                       uint16_t *data ) ;
#line 141
struct scsi_qla_host *qla2x00_create_host(struct scsi_host_template *sht , struct qla_hw_data *ha ) ;
#line 144
void qla2x00_relogin(struct scsi_qla_host *vha ) ;
#line 145
void qla2x00_do_work(struct scsi_qla_host *vha ) ;
#line 146
void qla2x00_free_fcports(struct scsi_qla_host *vha ) ;
#line 148
void qla83xx_schedule_work(scsi_qla_host_t *base_vha , int work_code ) ;
#line 149
void qla83xx_service_idc_aen(struct work_struct *work ) ;
#line 150
void qla83xx_nic_core_unrecoverable_work(struct work_struct *work ) ;
#line 151
void qla83xx_idc_state_handler_work(struct work_struct *work ) ;
#line 152
void qla83xx_nic_core_reset_work(struct work_struct *work ) ;
#line 154
void qla83xx_idc_lock(scsi_qla_host_t *base_vha , uint16_t requester_id ) ;
#line 155
void qla83xx_idc_unlock(scsi_qla_host_t *base_vha , uint16_t requester_id ) ;
#line 156
int qla83xx_idc_state_handler(scsi_qla_host_t *base_vha ) ;
#line 157
int qla83xx_set_drv_presence(scsi_qla_host_t *vha ) ;
#line 158
int __qla83xx_set_drv_presence(scsi_qla_host_t *vha ) ;
#line 159
int qla83xx_clear_drv_presence(scsi_qla_host_t *vha ) ;
#line 160
int __qla83xx_clear_drv_presence(scsi_qla_host_t *vha ) ;
#line 161
int qla2x00_post_uevent_work(struct scsi_qla_host *vha , u32 code ) ;
#line 164
void qla2x00_disable_board_on_pci_error(struct work_struct *work ) ;
#line 169
struct scsi_host_template qla2xxx_driver_template ;
#line 170
struct scsi_transport_template *qla2xxx_transport_vport_template ;
#line 171
void qla2x00_timer(scsi_qla_host_t *vha ) ;
#line 172
__inline void qla2x00_start_timer(scsi_qla_host_t *vha , void *func , unsigned long interval ) ;
#line 178
int qla2x00_send_change_request(scsi_qla_host_t *vha , uint16_t format , uint16_t vp_idx ) ;
#line 183
void qla2x00_do_dpc_all_vps(scsi_qla_host_t *vha ) ;
#line 187
void qla2x00_sp_free_dma(void *vha , void *ptr ) ;
#line 190
void qla2x00_mark_device_lost(scsi_qla_host_t *vha , fc_port_t *fcport , int do_login ,
                              int defer ) ;
#line 191
void qla2x00_mark_all_devices_lost(scsi_qla_host_t *vha , int defer ) ;
#line 193
struct fw_blob *qla2x00_request_firmware(scsi_qla_host_t *vha ) ;
#line 195
int qla2x00_wait_for_hba_online(scsi_qla_host_t *vha ) ;
#line 196
int qla2x00_wait_for_chip_reset(scsi_qla_host_t *vha ) ;
#line 199
void qla2xxx_wake_dpc(struct scsi_qla_host *vha ) ;
#line 203
int qla2x00_vp_abort_isp(scsi_qla_host_t *vha ) ;
#line 209
uint16_t qla2x00_calc_iocbs_32(uint16_t dsds ) ;
#line 210
uint16_t qla2x00_calc_iocbs_64(uint16_t dsds ) ;
#line 211
void qla2x00_build_scsi_iocbs_32(srb_t *sp , cmd_entry_t *cmd_pkt , uint16_t tot_dsds ) ;
#line 212
void qla2x00_build_scsi_iocbs_64(srb_t *sp , cmd_entry_t *cmd_pkt , uint16_t tot_dsds ) ;
#line 213
int qla2x00_start_scsi(srb_t *sp ) ;
#line 214
int qla24xx_start_scsi(srb_t *sp ) ;
#line 218
int qla24xx_dif_start_scsi(srb_t *sp ) ;
#line 263
int qla2x00_abort_command(srb_t *sp ) ;
#line 266
int qla2x00_abort_target(struct fc_port *fcport , uint64_t l , int tag ) ;
#line 269
int qla2x00_lun_reset(struct fc_port *fcport , uint64_t l , int tag ) ;
#line 285
int qla2x00_get_port_database(scsi_qla_host_t *vha , fc_port_t *fcport , uint8_t opt ) ;
#line 297
int qla2x00_lip_reset(scsi_qla_host_t *vha ) ;
#line 303
int qla2x00_login_fabric(scsi_qla_host_t *vha , uint16_t loop_id , uint8_t domain ,
                         uint8_t area , uint8_t al_pa , uint16_t *mb , uint8_t opt ) ;
#line 306
int qla24xx_login_fabric(scsi_qla_host_t *vha , uint16_t loop_id , uint8_t domain ,
                         uint8_t area , uint8_t al_pa , uint16_t *mb , uint8_t opt ) ;
#line 314
int qla2x00_fabric_logout(scsi_qla_host_t *vha , uint16_t loop_id , uint8_t domain ,
                          uint8_t area , uint8_t al_pa ) ;
#line 317
int qla24xx_fabric_logout(scsi_qla_host_t *vha , uint16_t loop_id , uint8_t domain ,
                          uint8_t area , uint8_t al_pa ) ;
#line 320
int qla2x00_full_login_lip(scsi_qla_host_t *vha ) ;
#line 340
int qla24xx_abort_command(srb_t *sp ) ;
#line 341
int qla24xx_async_abort_command(srb_t *sp ) ;
#line 343
int qla24xx_abort_target(struct fc_port *fcport , uint64_t l , int tag ) ;
#line 345
int qla24xx_lun_reset(struct fc_port *fcport , uint64_t l , int tag ) ;
#line 347
int qla2x00_eh_wait_for_pending_commands(scsi_qla_host_t *vha , unsigned int t , uint64_t l ,
                                         enum nexus_wait_type type ) ;
#line 371
int qla2x00_disable_eft_trace(scsi_qla_host_t *vha ) ;
#line 378
int qla2x00_disable_fce_trace(scsi_qla_host_t *vha , uint64_t *wr , uint64_t *rd ) ;
#line 399
int qla81xx_idc_ack(scsi_qla_host_t *vha , uint16_t *mb ) ;
#line 442
irqreturn_t qla2100_intr_handler(int irq , void *dev_id ) ;
#line 443
irqreturn_t qla2300_intr_handler(int irq , void *dev_id ) ;
#line 444
irqreturn_t qla24xx_intr_handler(int irq , void *dev_id ) ;
#line 448
int qla2x00_request_irqs(struct qla_hw_data *ha , struct rsp_que *rsp ) ;
#line 449
void qla2x00_free_irqs(scsi_qla_host_t *vha ) ;
#line 466
uint8_t *qla2x00_read_nvram_data(scsi_qla_host_t *vha , uint8_t *buf , uint32_t naddr ,
                                 uint32_t bytes ) ;
#line 468
uint8_t *qla24xx_read_nvram_data(scsi_qla_host_t *vha , uint8_t *buf , uint32_t naddr ,
                                 uint32_t bytes ) ;
#line 470
int qla2x00_write_nvram_data(scsi_qla_host_t *vha , uint8_t *buf , uint32_t naddr ,
                             uint32_t bytes ) ;
#line 472
int qla24xx_write_nvram_data(scsi_qla_host_t *vha , uint8_t *buf , uint32_t naddr ,
                             uint32_t bytes ) ;
#line 474
uint8_t *qla25xx_read_nvram_data(scsi_qla_host_t *vha , uint8_t *buf , uint32_t naddr ,
                                 uint32_t bytes ) ;
#line 476
int qla25xx_write_nvram_data(scsi_qla_host_t *vha , uint8_t *buf , uint32_t naddr ,
                             uint32_t bytes ) ;
#line 480
bool qla2x00_check_reg16_for_disconnect(scsi_qla_host_t *vha , uint16_t reg ) ;
#line 482
int qla2x00_beacon_on(struct scsi_qla_host *vha ) ;
#line 483
int qla2x00_beacon_off(struct scsi_qla_host *vha ) ;
#line 484
void qla2x00_beacon_blink(struct scsi_qla_host *vha ) ;
#line 485
int qla24xx_beacon_on(struct scsi_qla_host *vha ) ;
#line 486
int qla24xx_beacon_off(struct scsi_qla_host *vha ) ;
#line 487
void qla24xx_beacon_blink(struct scsi_qla_host *vha ) ;
#line 488
void qla83xx_beacon_blink(struct scsi_qla_host *vha ) ;
#line 489
int qla82xx_beacon_on(struct scsi_qla_host *vha ) ;
#line 490
int qla82xx_beacon_off(struct scsi_qla_host *vha ) ;
#line 491
int qla83xx_wr_reg(scsi_qla_host_t *vha , uint32_t reg , uint32_t data ) ;
#line 492
int qla83xx_rd_reg(scsi_qla_host_t *vha , uint32_t reg , uint32_t *data ) ;
#line 493
int qla83xx_restart_nic_firmware(scsi_qla_host_t *vha ) ;
#line 494
int qla83xx_access_control(scsi_qla_host_t *vha , uint16_t options , uint32_t start_addr ,
                           uint32_t end_addr , uint16_t *sector_size ) ;
#line 497
uint8_t *qla2x00_read_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                                  uint32_t length ) ;
#line 499
int qla2x00_write_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                              uint32_t length ) ;
#line 501
uint8_t *qla24xx_read_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                                  uint32_t length ) ;
#line 503
int qla24xx_write_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                              uint32_t length ) ;
#line 505
uint8_t *qla25xx_read_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                                  uint32_t length ) ;
#line 507
uint8_t *qla8044_read_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                                  uint32_t length ) ;
#line 509
void qla8044_watchdog(struct scsi_qla_host *vha ) ;
#line 511
int qla2x00_get_flash_version(scsi_qla_host_t *vha , void *mbuf ) ;
#line 512
int qla24xx_get_flash_version(scsi_qla_host_t *vha , void *mbuf ) ;
#line 513
int qla82xx_get_flash_version(scsi_qla_host_t *vha , void *mbuf ) ;
#line 518
void qla2xxx_flash_npiv_conf(scsi_qla_host_t *vha ) ;
#line 524
void qla2100_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) ;
#line 525
void qla2300_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) ;
#line 526
void qla24xx_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) ;
#line 527
void qla25xx_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) ;
#line 528
void qla81xx_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) ;
#line 529
void qla82xx_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) ;
#line 530
void qla8044_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) ;
#line 532
void qla27xx_fwdump(scsi_qla_host_t *vha , int hardware_locked ) ;
#line 550
void *qla2x00_prep_ms_iocb(scsi_qla_host_t *vha , uint32_t req_size , uint32_t rsp_size ) ;
#line 551
void *qla24xx_prep_ms_iocb(scsi_qla_host_t *vha , uint32_t req_size , uint32_t rsp_size ) ;
#line 561
void *qla2x00_prep_ms_fdmi_iocb(scsi_qla_host_t *vha , uint32_t req_size , uint32_t rsp_size ) ;
#line 562
void *qla24xx_prep_ms_fdmi_iocb(scsi_qla_host_t *vha , uint32_t req_size , uint32_t rsp_size ) ;
#line 572
struct device_attribute *qla2x00_host_attrs[32U] ;
#line 574
struct fc_function_template qla2xxx_transport_functions ;
#line 575
struct fc_function_template qla2xxx_transport_vport_functions ;
#line 576
void qla2x00_alloc_sysfs_attr(scsi_qla_host_t *vha ) ;
#line 577
void qla2x00_free_sysfs_attr(scsi_qla_host_t *vha , bool stop_beacon ) ;
#line 578
void qla2x00_init_host_attr(scsi_qla_host_t *vha ) ;
#line 590
int qla2x00_dfs_setup(scsi_qla_host_t *vha ) ;
#line 591
int qla2x00_dfs_remove(scsi_qla_host_t *vha ) ;
#line 597
int qla25xx_create_req_que(struct qla_hw_data *ha , uint16_t options , uint8_t vp_idx ,
                           uint16_t rid , int rsp_que , uint8_t qos ) ;
#line 599
int qla25xx_create_rsp_que(struct qla_hw_data *ha , uint16_t options , uint8_t vp_idx ,
                           uint16_t rid , int req ) ;
#line 603
int qla25xx_delete_queues(struct scsi_qla_host *vha ) ;
#line 612
int qlafx00_pci_config(struct scsi_qla_host *vha ) ;
#line 613
int qlafx00_initialize_adapter(struct scsi_qla_host *vha ) ;
#line 614
void qlafx00_soft_reset(scsi_qla_host_t *vha ) ;
#line 615
int qlafx00_chip_diag(scsi_qla_host_t *vha ) ;
#line 616
void qlafx00_config_rings(struct scsi_qla_host *vha ) ;
#line 617
char *qlafx00_pci_info_str(struct scsi_qla_host *vha , char *str ) ;
#line 618
char *qlafx00_fw_version_str(struct scsi_qla_host *vha , char *str , size_t size ) ;
#line 619
irqreturn_t qlafx00_intr_handler(int irq , void *dev_id ) ;
#line 620
void qlafx00_enable_intrs(struct qla_hw_data *ha ) ;
#line 621
void qlafx00_disable_intrs(struct qla_hw_data *ha ) ;
#line 622
int qlafx00_abort_target(fc_port_t *fcport , uint64_t l , int tag ) ;
#line 623
int qlafx00_lun_reset(fc_port_t *fcport , uint64_t l , int tag ) ;
#line 624
int qlafx00_start_scsi(srb_t *sp ) ;
#line 625
int qlafx00_abort_isp(scsi_qla_host_t *vha ) ;
#line 626
int qlafx00_iospace_config(struct qla_hw_data *ha ) ;
#line 628
int qlafx00_driver_shutdown(scsi_qla_host_t *vha , int tmo ) ;
#line 631
int qlafx00_reset_initialize(scsi_qla_host_t *vha ) ;
#line 632
int qlafx00_fx_disc(scsi_qla_host_t *vha , fc_port_t *fcport , uint16_t fx_type ) ;
#line 633
int qlafx00_process_aen(struct scsi_qla_host *vha , struct qla_work_evt *evt ) ;
#line 634
int qlafx00_post_aenfx_work(struct scsi_qla_host *vha , uint32_t evtcode , uint32_t *data ,
                            int cnt ) ;
#line 644
void qlafx00_timer_routine(scsi_qla_host_t *vha ) ;
#line 645
int qlafx00_rescan_isp(scsi_qla_host_t *vha ) ;
#line 646
int qlafx00_loop_reset(scsi_qla_host_t *vha ) ;
#line 651
int qla82xx_pci_config(struct scsi_qla_host *vha ) ;
#line 654
int qla82xx_iospace_config(struct qla_hw_data *ha ) ;
#line 657
void qla82xx_reset_chip(struct scsi_qla_host *vha ) ;
#line 658
void qla82xx_config_rings(struct scsi_qla_host *vha ) ;
#line 659
void qla82xx_watchdog(scsi_qla_host_t *vha ) ;
#line 660
int qla82xx_start_firmware(scsi_qla_host_t *vha ) ;
#line 663
int qla82xx_load_risc(scsi_qla_host_t *vha , uint32_t *srisc_addr ) ;
#line 664
uint8_t *qla82xx_read_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                                  uint32_t length ) ;
#line 666
int qla82xx_write_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                              uint32_t length ) ;
#line 670
int qla82xx_abort_isp(scsi_qla_host_t *vha ) ;
#line 671
int qla82xx_restart_isp(scsi_qla_host_t *vha ) ;
#line 674
int qla82xx_start_scsi(srb_t *sp ) ;
#line 682
irqreturn_t qla82xx_intr_handler(int irq , void *dev_id ) ;
#line 686
void qla82xx_enable_intrs(struct qla_hw_data *ha ) ;
#line 687
void qla82xx_disable_intrs(struct qla_hw_data *ha ) ;
#line 689
void qla82xx_init_flags(struct qla_hw_data *ha ) ;
#line 692
void qla82xx_set_drv_active(scsi_qla_host_t *vha ) ;
#line 693
int qla82xx_wr_32(struct qla_hw_data *ha , ulong off , u32 data ) ;
#line 694
int qla82xx_rd_32(struct qla_hw_data *ha , ulong off ) ;
#line 699
void qla82xx_clear_drv_active(struct qla_hw_data *ha ) ;
#line 701
int qla82xx_idc_lock(struct qla_hw_data *ha ) ;
#line 702
void qla82xx_idc_unlock(struct qla_hw_data *ha ) ;
#line 703
int qla82xx_device_state_handler(scsi_qla_host_t *vha ) ;
#line 704
void qla8xxx_dev_failed_handler(scsi_qla_host_t *vha ) ;
#line 705
void qla82xx_clear_qsnt_ready(scsi_qla_host_t *vha ) ;
#line 712
int qla82xx_fcoe_ctx_reset(scsi_qla_host_t *vha ) ;
#line 719
void qla82xx_clear_pending_mbx(scsi_qla_host_t *vha ) ;
#line 733
void qla83xx_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) ;
#line 739
void qla82xx_md_free(scsi_qla_host_t *vha ) ;
#line 746
int qla8044_idc_lock(struct qla_hw_data *ha ) ;
#line 747
void qla8044_idc_unlock(struct qla_hw_data *ha ) ;
#line 753
void qla8044_wr_direct(struct scsi_qla_host *vha , uint32_t const   crb_reg , uint32_t const   value ) ;
#line 755
int qla8044_device_state_handler(struct scsi_qla_host *vha ) ;
#line 756
void qla8044_clear_qsnt_ready(struct scsi_qla_host *vha ) ;
#line 757
void qla8044_clear_drv_active(struct qla_hw_data *ha ) ;
#line 761
int qla8044_write_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                              uint32_t length ) ;
#line 763
irqreturn_t qla8044_intr_handler(int irq , void *dev_id ) ;
#line 765
int qla8044_abort_isp(scsi_qla_host_t *vha ) ;
#line 768
void qlt_host_reset_handler(struct qla_hw_data *ha ) ;
#line 310 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
int ql_errlev ;
#line 313
void ql_dbg(uint32_t level , scsi_qla_host_t *vha , int32_t id , char const   *fmt 
            , ...) ;
#line 315
void ql_dbg_pci(uint32_t level , struct pci_dev *pdev , int32_t id , char const   *fmt 
                , ...) ;
#line 318
void ql_log(uint32_t level , scsi_qla_host_t *vha , int32_t id , char const   *fmt 
            , ...) ;
#line 320
void ql_log_pci(uint32_t level , struct pci_dev *pdev , int32_t id , char const   *fmt 
                , ...) ;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 1039 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
int qlt_add_target(struct qla_hw_data *ha , struct scsi_qla_host *base_vha ) ;
#line 1040
int qlt_remove_target(struct qla_hw_data *ha , struct scsi_qla_host *vha ) ;
#line 1046
void qlt_fc_port_deleted(struct scsi_qla_host *vha , fc_port_t *fcport ) ;
#line 1047
int qlt_init(void) ;
#line 1048
void qlt_exit(void) ;
#line 1063 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
__inline static bool qla_ini_mode_enabled(struct scsi_qla_host *ha ) 
{ 


  {
#line 1065
  return (((int )(ha->host)->active_mode & 1) != 0);
}
}
#line 1104
void qlt_probe_one_stage1(struct scsi_qla_host *base_vha , struct qla_hw_data *ha ) ;
#line 1105
int qlt_mem_alloc(struct qla_hw_data *ha ) ;
#line 1106
void qlt_mem_free(struct qla_hw_data *ha ) ;
#line 1110
void qlt_83xx_iospace_config(struct qla_hw_data *ha ) ;
#line 95 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_set_reserved_loop_ids(struct qla_hw_data *ha ) 
{ 
  int i ;

  {
#line 99
  if ((ha->device_type & 134217728U) != 0U) {
#line 100
    return;
  } else {

  }
#line 102
  i = 0;
#line 102
  goto ldv_65776;
  ldv_65775: 
#line 103
  set_bit((long )i, (unsigned long volatile   *)ha->loop_id_map);
#line 102
  i = i + 1;
  ldv_65776: ;
#line 102
  if (i <= 128) {
#line 104
    goto ldv_65775;
  } else {

  }
#line 104
  set_bit(254L, (unsigned long volatile   *)ha->loop_id_map);
#line 105
  set_bit(255L, (unsigned long volatile   *)ha->loop_id_map);
#line 106
  return;
}
}
#line 109 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static int qla2x00_is_reserved_id(scsi_qla_host_t *vha , uint16_t loop_id ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 111
  ha = vha->hw;
#line 112
  if ((ha->device_type & 134217728U) != 0U) {
#line 113
    return ((unsigned int )loop_id > 2031U);
  } else {

  }
#line 115
  return ((((int )ha->max_loop_id < (int )loop_id && (unsigned int )loop_id <= 128U) || (unsigned int )loop_id == 254U) || (unsigned int )loop_id == 255U);
}
}
#line 120 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_clear_loop_id(fc_port_t *fcport ) 
{ 
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 121
  ha = (fcport->vha)->hw;
#line 123
  if ((unsigned int )fcport->loop_id == 4096U) {
#line 125
    return;
  } else {
#line 123
    tmp = qla2x00_is_reserved_id(fcport->vha, (int )fcport->loop_id);
#line 123
    if (tmp != 0) {
#line 125
      return;
    } else {

    }
  }
#line 127
  clear_bit((long )fcport->loop_id, (unsigned long volatile   *)ha->loop_id_map);
#line 128
  fcport->loop_id = 4096U;
#line 129
  return;
}
}
#line 132 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_clean_dsd_pool(struct qla_hw_data *ha , srb_t *sp , struct qla_tgt_cmd *tc ) 
{ 
  struct dsd_dma *dsd_ptr ;
  struct dsd_dma *tdsd_ptr ;
  struct crc_context *ctx ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 138
  if ((unsigned long )sp != (unsigned long )((srb_t *)0)) {
#line 139
    ctx = (struct crc_context *)sp->u.scmd.ctx;
  } else
#line 140
  if ((unsigned long )tc != (unsigned long )((struct qla_tgt_cmd *)0)) {
#line 141
    ctx = tc->ctx;
  } else {
#line 143
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"),
                         "i" (143), "i" (12UL));
    ldv_65795: ;
#line 143
    goto ldv_65795;
#line 144
    return;
  }
#line 148
  __mptr = (struct list_head  const  *)ctx->dsd_list.next;
#line 148
  dsd_ptr = (struct dsd_dma *)__mptr;
#line 148
  __mptr___0 = (struct list_head  const  *)dsd_ptr->list.next;
#line 148
  tdsd_ptr = (struct dsd_dma *)__mptr___0;
#line 148
  goto ldv_65803;
  ldv_65802: 
#line 150
  dma_pool_free(ha->dl_dma_pool, dsd_ptr->dsd_addr, dsd_ptr->dsd_list_dma);
#line 152
  list_del(& dsd_ptr->list);
#line 153
  kfree((void const   *)dsd_ptr);
#line 148
  dsd_ptr = tdsd_ptr;
#line 148
  __mptr___1 = (struct list_head  const  *)tdsd_ptr->list.next;
#line 148
  tdsd_ptr = (struct dsd_dma *)__mptr___1;
  ldv_65803: ;
#line 148
  if ((unsigned long )(& dsd_ptr->list) != (unsigned long )(& ctx->dsd_list)) {
#line 150
    goto ldv_65802;
  } else {

  }
#line 155
  INIT_LIST_HEAD(& ctx->dsd_list);
#line 156
  return;
}
}
#line 159 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_set_fcport_state(fc_port_t *fcport , int state ) 
{ 
  int old_state ;

  {
#line 163
  old_state = atomic_read((atomic_t const   *)(& fcport->state));
#line 164
  atomic_set(& fcport->state, state);
#line 167
  if (old_state != 0 && old_state != state) {
#line 168
    ql_dbg(268435456U, fcport->vha, 8317, "FCPort state transitioned from %s to %s - portid=%02x%02x%02x.\n",
           port_state_str[old_state], port_state_str[state], (int )fcport->d_id.b.domain,
           (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
  } else {

  }
#line 174
  return;
}
}
#line 206 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static int qla2x00_reset_active(scsi_qla_host_t *vha ) 
{ 
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 208
  tmp = pci_get_drvdata((vha->hw)->pdev);
#line 208
  base_vha = (scsi_qla_host_t *)tmp;
#line 211
  tmp___0 = constant_test_bit(2L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 211
  if (tmp___0 != 0) {
#line 211
    tmp___5 = 1;
  } else {
#line 211
    tmp___1 = constant_test_bit(3L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 211
    if (tmp___1 != 0) {
#line 211
      tmp___5 = 1;
    } else {
#line 211
      tmp___2 = constant_test_bit(10L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 211
      if (tmp___2 != 0) {
#line 211
        tmp___5 = 1;
      } else {
#line 211
        tmp___3 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 211
        if (tmp___3 != 0) {
#line 211
          tmp___5 = 1;
        } else {
#line 211
          tmp___4 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 211
          if (tmp___4 != 0) {
#line 211
            tmp___5 = 1;
          } else {
#line 211
            tmp___5 = 0;
          }
        }
      }
    }
  }
#line 211
  return (tmp___5);
}
}
#line 219 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static srb_t *qla2x00_get_sp(scsi_qla_host_t *vha , fc_port_t *fcport , gfp_t flag ) 
{ 
  srb_t *sp ;
  struct qla_hw_data *ha ;
  uint8_t bail ;
  long tmp ;
  void *tmp___0 ;

  {
#line 221
  sp = (srb_t *)0;
#line 222
  ha = vha->hw;
#line 225
  atomic_inc(& vha->vref_count);
#line 225
  __asm__  volatile   ("mfence": : : "memory");
#line 225
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 225
    atomic_dec(& vha->vref_count);
#line 225
    bail = 1U;
  } else {
#line 225
    bail = 0U;
  }
#line 226
  tmp = ldv__builtin_expect((unsigned int )bail != 0U, 0L);
#line 226
  if (tmp != 0L) {
#line 227
    return ((srb_t *)0);
  } else {

  }
#line 229
  tmp___0 = mempool_alloc(ha->srb_mempool, flag);
#line 229
  sp = (srb_t *)tmp___0;
#line 230
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 231
    goto done;
  } else {

  }
#line 233
  memset((void *)sp, 0, 376UL);
#line 234
  sp->fcport = fcport;
#line 235
  sp->iocbs = 1;
  done: ;
#line 237
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 238
    atomic_dec(& vha->vref_count);
  } else {

  }
#line 239
  return (sp);
}
}
#line 243 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_rel_sp(scsi_qla_host_t *vha , srb_t *sp ) 
{ 


  {
#line 245
  mempool_free((void *)sp, (vha->hw)->srb_mempool);
#line 246
  atomic_dec(& vha->vref_count);
#line 247
  return;
}
}
#line 264 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static int qla2x00_gid_list_size(struct qla_hw_data *ha ) 
{ 


  {
#line 266
  if ((ha->device_type & 131072U) != 0U) {
#line 267
    return (128);
  } else {
#line 269
    return ((int )((unsigned int )ha->max_fibre_devices * 8U));
  }
}
}
#line 83 "include/linux/vmalloc.h"
extern void vfree(void const   * ) ;
#line 8 "include/linux/kthread.h"
extern struct task_struct *kthread_create_on_node(int (*)(void * ) , void * , int  ,
                                                  char const   *  , ...) ;
#line 41
extern int kthread_stop(struct task_struct * ) ;
#line 42
extern bool kthread_should_stop(void) ;
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int apidev_major  ;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static struct kmem_cache *srb_cachep  ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static struct kmem_cache *ctx_cachep  ;
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int ql_errlev  =    3;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int ql2xenableclass2  ;
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int ql2xlogintimeout  =    20;
#line 69 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int ql2xloginretrycount  =    0;
#line 74 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int ql2xallocfwdump  =    1;
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int ql2xshiftctondsd  =    6;
#line 107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int ql2xfdmienable  =    1;
#line 114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int ql2xmaxqdepth  =    32;
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int ql2xenabledif  =    2;
#line 129 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int ql2xenablehba_err_chk  =    2;
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int ql2xiidmaenable  =    1;
#line 144 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int ql2xmaxqueues  =    1;
#line 173 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int ql2xdbwr  =    1;
#line 180 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int ql2xtargetreset  =    1;
#line 205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
uint64_t ql2xmaxlun  =    65535ULL;
#line 211 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int ql2xmdcapmask  =    31;
#line 217 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int ql2xmdenable  =    1;
#line 227
static int qla2xxx_slave_configure(struct scsi_device *sdev ) ;
#line 228
static int qla2xxx_slave_alloc(struct scsi_device *sdev ) ;
#line 229
static int qla2xxx_scan_finished(struct Scsi_Host *shost , unsigned long time ) ;
#line 230
static void qla2xxx_scan_start(struct Scsi_Host *shost ) ;
#line 231
static void qla2xxx_slave_destroy(struct scsi_device *sdev ) ;
#line 232
static int qla2xxx_queuecommand(struct Scsi_Host *host , struct scsi_cmnd *cmd ) ;
#line 233
static int qla2xxx_eh_abort(struct scsi_cmnd *cmd ) ;
#line 234
static int qla2xxx_eh_device_reset(struct scsi_cmnd *cmd ) ;
#line 235
static int qla2xxx_eh_target_reset(struct scsi_cmnd *cmd ) ;
#line 236
static int qla2xxx_eh_bus_reset(struct scsi_cmnd *cmd ) ;
#line 237
static int qla2xxx_eh_host_reset(struct scsi_cmnd *cmd ) ;
#line 239
static void qla2x00_clear_drv_active(struct qla_hw_data *ha ) ;
#line 240
static void qla2x00_free_device(scsi_qla_host_t *vha ) ;
#line 241
static void qla83xx_disable_laser(scsi_qla_host_t *vha ) ;
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
struct scsi_host_template qla2xxx_driver_template  = 
#line 243
     {& __this_module, "qla2xxx", 0, 0, 0, 0, 0, & qla2xxx_queuecommand, & qla2xxx_eh_abort,
    & qla2xxx_eh_device_reset, & qla2xxx_eh_target_reset, & qla2xxx_eh_bus_reset,
    & qla2xxx_eh_host_reset, & qla2xxx_slave_alloc, & qla2xxx_slave_configure, & qla2xxx_slave_destroy,
    0, 0, & qla2xxx_scan_finished, & qla2xxx_scan_start, & scsi_change_queue_depth,
    0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 128U, (unsigned short)0, 65535U, 0UL, 3, (unsigned char)0,
    0, 1U, 1U, 1U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, 0U, (struct device_attribute **)(& qla2x00_host_attrs), 0, {0,
                                                                                  0},
    0ULL, 0U, 0, (_Bool)0};
#line 274 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static struct scsi_transport_template *qla2xxx_transport_template  =    (struct scsi_transport_template *)0;
#line 275 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
struct scsi_transport_template *qla2xxx_transport_vport_template  =    (struct scsi_transport_template *)0;
#line 283 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
__inline void qla2x00_start_timer(scsi_qla_host_t *vha , void *func , unsigned long interval ) 
{ 


  {
#line 285
  reg_timer_21(& vha->timer);
#line 286
  vha->timer.expires = interval * 250UL + (unsigned long )jiffies;
#line 287
  vha->timer.data = (unsigned long )vha;
#line 288
  vha->timer.function = (void (*)(unsigned long  ))func;
#line 289
  add_timer(& vha->timer);
#line 290
  vha->timer_active = 1U;
#line 291
  return;
}
}
#line 294 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
__inline static void qla2x00_restart_timer(scsi_qla_host_t *vha , unsigned long interval ) 
{ 


  {
#line 297
  if ((vha->device_flags & 32U) != 0U) {
#line 298
    ql_dbg(16777216U, vha, 24589, "Device in a failed state, returning.\n");
#line 300
    return;
  } else {

  }
#line 303
  ldv_mod_timer_11(& vha->timer, interval * 250UL + (unsigned long )jiffies);
#line 304
  return;
}
}
#line 307 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
__inline static void qla2x00_stop_timer(scsi_qla_host_t *vha ) 
{ 


  {
#line 309
  ldv_del_timer_sync_12(& vha->timer);
#line 310
  vha->timer_active = 0U;
#line 311
  return;
}
}
#line 313
static int qla2x00_do_dpc(void *data ) ;
#line 315
static void qla2x00_rst_aen(scsi_qla_host_t *vha ) ;
#line 317
static int qla2x00_mem_alloc(struct qla_hw_data *ha , uint16_t req_len , uint16_t rsp_len ,
                             struct req_que **req , struct rsp_que **rsp ) ;
#line 319
static void qla2x00_free_fw_dump(struct qla_hw_data *ha ) ;
#line 320
static void qla2x00_mem_free(struct qla_hw_data *ha ) ;
#line 323 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int qla2x00_alloc_queues(struct qla_hw_data *ha , struct req_que *req , struct rsp_que *rsp ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 326
  tmp = pci_get_drvdata(ha->pdev);
#line 326
  vha = (scsi_qla_host_t *)tmp;
#line 327
  tmp___0 = kzalloc((unsigned long )ha->max_req_queues * 8UL, 208U);
#line 327
  ha->req_q_map = (struct req_que **)tmp___0;
#line 329
  if ((unsigned long )ha->req_q_map == (unsigned long )((struct req_que **)0)) {
#line 330
    ql_log(0U, vha, 59, "Unable to allocate memory for request queue ptrs.\n");
#line 332
    goto fail_req_map;
  } else {

  }
#line 335
  tmp___1 = kzalloc((unsigned long )ha->max_rsp_queues * 8UL, 208U);
#line 335
  ha->rsp_q_map = (struct rsp_que **)tmp___1;
#line 337
  if ((unsigned long )ha->rsp_q_map == (unsigned long )((struct rsp_que **)0)) {
#line 338
    ql_log(0U, vha, 60, "Unable to allocate memory for response queue ptrs.\n");
#line 340
    goto fail_rsp_map;
  } else {

  }
#line 346
  *(ha->rsp_q_map) = rsp;
#line 347
  *(ha->req_q_map) = req;
#line 348
  set_bit(0L, (unsigned long volatile   *)(& ha->rsp_qid_map));
#line 349
  set_bit(0L, (unsigned long volatile   *)(& ha->req_qid_map));
#line 350
  return (1);
  fail_rsp_map: 
#line 353
  kfree((void const   *)ha->req_q_map);
#line 354
  ha->req_q_map = (struct req_que **)0;
  fail_req_map: ;
#line 356
  return (-12);
}
}
#line 359 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla2x00_free_req_que(struct qla_hw_data *ha , struct req_que *req ) 
{ 


  {
#line 361
  if ((ha->device_type & 131072U) != 0U) {
#line 362
    if ((unsigned long )req != (unsigned long )((struct req_que *)0) && (unsigned long )req->ring_fx00 != (unsigned long )((request_t *)0)) {
#line 363
      dma_free_attrs(& (ha->pdev)->dev, (unsigned long )((int )req->length_fx00 + 1) * 64UL,
                     (void *)req->ring_fx00, req->dma_fx00, (struct dma_attrs *)0);
    } else {

    }
  } else
#line 366
  if ((unsigned long )req != (unsigned long )((struct req_que *)0) && (unsigned long )req->ring != (unsigned long )((request_t *)0)) {
#line 367
    dma_free_attrs(& (ha->pdev)->dev, (unsigned long )((int )req->length + 1) * 64UL,
                   (void *)req->ring, req->dma, (struct dma_attrs *)0);
  } else {

  }
#line 371
  if ((unsigned long )req != (unsigned long )((struct req_que *)0)) {
#line 372
    kfree((void const   *)req->outstanding_cmds);
  } else {

  }
#line 374
  kfree((void const   *)req);
#line 375
  req = (struct req_que *)0;
#line 376
  return;
}
}
#line 378 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla2x00_free_rsp_que(struct qla_hw_data *ha , struct rsp_que *rsp ) 
{ 


  {
#line 380
  if ((ha->device_type & 131072U) != 0U) {
#line 381
    if ((unsigned long )rsp != (unsigned long )((struct rsp_que *)0) && (unsigned long )rsp->ring != (unsigned long )((response_t *)0)) {
#line 382
      dma_free_attrs(& (ha->pdev)->dev, (unsigned long )((int )rsp->length_fx00 + 1) * 64UL,
                     (void *)rsp->ring_fx00, rsp->dma_fx00, (struct dma_attrs *)0);
    } else {

    }
  } else
#line 385
  if ((unsigned long )rsp != (unsigned long )((struct rsp_que *)0) && (unsigned long )rsp->ring != (unsigned long )((response_t *)0)) {
#line 386
    dma_free_attrs(& (ha->pdev)->dev, (unsigned long )((int )rsp->length + 1) * 64UL,
                   (void *)rsp->ring, rsp->dma, (struct dma_attrs *)0);
  } else {

  }
#line 390
  kfree((void const   *)rsp);
#line 391
  rsp = (struct rsp_que *)0;
#line 392
  return;
}
}
#line 394 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla2x00_free_queues(struct qla_hw_data *ha ) 
{ 
  struct req_que *req ;
  struct rsp_que *rsp ;
  int cnt ;

  {
#line 400
  cnt = 0;
#line 400
  goto ldv_66851;
  ldv_66850: 
#line 401
  req = *(ha->req_q_map + (unsigned long )cnt);
#line 402
  qla2x00_free_req_que(ha, req);
#line 400
  cnt = cnt + 1;
  ldv_66851: ;
#line 400
  if ((int )ha->max_req_queues > cnt) {
#line 402
    goto ldv_66850;
  } else {

  }
#line 404
  kfree((void const   *)ha->req_q_map);
#line 405
  ha->req_q_map = (struct req_que **)0;
#line 407
  cnt = 0;
#line 407
  goto ldv_66854;
  ldv_66853: 
#line 408
  rsp = *(ha->rsp_q_map + (unsigned long )cnt);
#line 409
  qla2x00_free_rsp_que(ha, rsp);
#line 407
  cnt = cnt + 1;
  ldv_66854: ;
#line 407
  if ((int )ha->max_rsp_queues > cnt) {
#line 409
    goto ldv_66853;
  } else {

  }
#line 411
  kfree((void const   *)ha->rsp_q_map);
#line 412
  ha->rsp_q_map = (struct rsp_que **)0;
#line 413
  return;
}
}
#line 415 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int qla25xx_setup_mode(struct scsi_qla_host *vha ) 
{ 
  uint16_t options ;
  int ques ;
  int req ;
  int ret ;
  struct qla_hw_data *ha ;
  struct lock_class_key __key ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp ;
  uint8_t tmp___0 ;

  {
#line 417
  options = 0U;
#line 419
  ha = vha->hw;
#line 421
  if (((int )ha->fw_attributes & 64) == 0) {
#line 422
    ql_log(1U, vha, 216, "Firmware is not multi-queue capable.\n");
#line 424
    goto fail;
  } else {

  }
#line 426
  if (ql2xmultique_tag != 0) {
#line 428
    options = (uint16_t )((unsigned int )options | 128U);
#line 429
    req = qla25xx_create_req_que(ha, (int )options, 0, 0, -1, 5);
#line 431
    if (req == 0) {
#line 432
      ql_log(1U, vha, 224, "Failed to create request queue.\n");
#line 434
      goto fail;
    } else {

    }
#line 436
    __lock_name = "\"qla2xxx_wq\"";
#line 436
    tmp = __alloc_workqueue_key("qla2xxx_wq", 8U, 1, & __key, __lock_name);
#line 436
    ha->wq = tmp;
#line 437
    vha->req = *(ha->req_q_map + (unsigned long )req);
#line 438
    options = (uint16_t )((unsigned int )options | 2U);
#line 439
    ques = 1;
#line 439
    goto ldv_66870;
    ldv_66869: 
#line 440
    ret = qla25xx_create_rsp_que(ha, (int )options, 0, 0, req);
#line 441
    if (ret == 0) {
#line 442
      ql_log(1U, vha, 232, "Failed to create response queue.\n");
#line 444
      goto fail2;
    } else {

    }
#line 439
    ques = ques + 1;
    ldv_66870: ;
#line 439
    if ((int )ha->max_rsp_queues > ques) {
#line 441
      goto ldv_66869;
    } else {

    }
#line 447
    ha->flags.cpu_affinity_enabled = 1U;
#line 448
    ql_dbg(1048576U, vha, 49159, "CPU affinity mode enabled, no. of response queues:%d no. of request queues:%d.\n",
           (int )ha->max_rsp_queues, (int )ha->max_req_queues);
#line 452
    ql_dbg(1073741824U, vha, 233, "CPU affinity mode enabled, no. of response queues:%d no. of request queues:%d.\n",
           (int )ha->max_rsp_queues, (int )ha->max_req_queues);
  } else {

  }
#line 457
  return (0);
  fail2: 
#line 459
  qla25xx_delete_queues(vha);
#line 460
  ldv_destroy_workqueue_13(ha->wq);
#line 461
  ha->wq = (struct workqueue_struct *)0;
#line 462
  vha->req = *(ha->req_q_map);
  fail: 
#line 464
  ha->mqenable = 0U;
#line 465
  kfree((void const   *)ha->req_q_map);
#line 466
  kfree((void const   *)ha->rsp_q_map);
#line 467
  tmp___0 = 1U;
#line 467
  ha->max_rsp_queues = tmp___0;
#line 467
  ha->max_req_queues = tmp___0;
#line 468
  return (1);
}
}
#line 472 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static char *qla2x00_pci_info_str(struct scsi_qla_host *vha , char *str ) 
{ 
  struct qla_hw_data *ha ;
  char *pci_bus_modes[4U] ;
  uint16_t pci_bus ;

  {
#line 474
  ha = vha->hw;
#line 475
  pci_bus_modes[0] = (char *)"33";
#line 475
  pci_bus_modes[1] = (char *)"66";
#line 475
  pci_bus_modes[2] = (char *)"100";
#line 475
  pci_bus_modes[3] = (char *)"133";
#line 480
  strcpy(str, "PCI");
#line 481
  pci_bus = (uint16_t )((ha->pci_attr & 1536U) >> 9);
#line 482
  if ((unsigned int )pci_bus != 0U) {
#line 483
    strcat(str, "-X (");
#line 484
    strcat(str, (char const   *)pci_bus_modes[(int )pci_bus]);
  } else {
#line 486
    pci_bus = (uint16_t )((ha->pci_attr & 256U) >> 8);
#line 487
    strcat(str, " (");
#line 488
    strcat(str, (char const   *)pci_bus_modes[(int )pci_bus]);
  }
#line 490
  strcat(str, " MHz)");
#line 492
  return (str);
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static char *qla24xx_pci_info_str(struct scsi_qla_host *vha , char *str ) 
{ 
  char *pci_bus_modes[4U] ;
  struct qla_hw_data *ha ;
  uint32_t pci_bus ;
  char lwstr[6U] ;
  uint32_t lstat ;
  uint32_t lspeed ;
  uint32_t lwidth ;
  bool tmp ;

  {
#line 498
  pci_bus_modes[0] = (char *)"33";
#line 498
  pci_bus_modes[1] = (char *)"66";
#line 498
  pci_bus_modes[2] = (char *)"100";
#line 498
  pci_bus_modes[3] = (char *)"133";
#line 499
  ha = vha->hw;
#line 502
  tmp = pci_is_pcie(ha->pdev);
#line 502
  if ((int )tmp) {
#line 506
    pcie_capability_read_dword(ha->pdev, 12, & lstat);
#line 507
    lspeed = lstat & 15U;
#line 508
    lwidth = (lstat & 1008U) >> 4;
#line 510
    strcpy(str, "PCIe (");
#line 511
    switch (lspeed) {
    case 1U: 
#line 513
    strcat(str, "2.5GT/s ");
#line 514
    goto ldv_66891;
    case 2U: 
#line 516
    strcat(str, "5.0GT/s ");
#line 517
    goto ldv_66891;
    case 3U: 
#line 519
    strcat(str, "8.0GT/s ");
#line 520
    goto ldv_66891;
    default: 
#line 522
    strcat(str, "<unknown> ");
#line 523
    goto ldv_66891;
    }
    ldv_66891: 
#line 525
    snprintf((char *)(& lwstr), 6UL, "x%d)", lwidth);
#line 526
    strcat(str, (char const   *)(& lwstr));
#line 528
    return (str);
  } else {

  }
#line 531
  strcpy(str, "PCI");
#line 532
  pci_bus = (ha->pci_attr & 3840U) >> 8;
#line 533
  if (pci_bus == 0U || pci_bus == 8U) {
#line 534
    strcat(str, " (");
#line 535
    strcat(str, (char const   *)pci_bus_modes[pci_bus >> 3]);
  } else {
#line 537
    strcat(str, "-X ");
#line 538
    if ((pci_bus & 4U) != 0U) {
#line 539
      strcat(str, "Mode 2");
    } else {
#line 541
      strcat(str, "Mode 1");
    }
#line 542
    strcat(str, " (");
#line 543
    strcat(str, (char const   *)pci_bus_modes[pci_bus & 4294967291U]);
  }
#line 545
  strcat(str, " MHz)");
#line 547
  return (str);
}
}
#line 551 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static char *qla2x00_fw_version_str(struct scsi_qla_host *vha , char *str , size_t size ) 
{ 
  char un_str[10U] ;
  struct qla_hw_data *ha ;

  {
#line 554
  ha = vha->hw;
#line 556
  snprintf(str, size, "%d.%02d.%02d ", (int )ha->fw_major_version, (int )ha->fw_minor_version,
           (int )ha->fw_subminor_version);
#line 559
  if (((int )ha->fw_attributes & 512) != 0) {
#line 560
    strcat(str, "FLX");
#line 561
    return (str);
  } else {

  }
#line 564
  switch ((int )ha->fw_attributes & 255) {
  case 7: 
#line 566
  strcat(str, "EF");
#line 567
  goto ldv_66903;
  case 23: 
#line 569
  strcat(str, "TP");
#line 570
  goto ldv_66903;
  case 55: 
#line 572
  strcat(str, "IP");
#line 573
  goto ldv_66903;
  case 119: 
#line 575
  strcat(str, "VI");
#line 576
  goto ldv_66903;
  default: 
#line 578
  sprintf((char *)(& un_str), "(%x)", (int )ha->fw_attributes);
#line 579
  strcat(str, (char const   *)(& un_str));
#line 580
  goto ldv_66903;
  }
  ldv_66903: ;
#line 582
  if (((int )ha->fw_attributes & 256) != 0) {
#line 583
    strcat(str, "X");
  } else {

  }
#line 585
  return (str);
}
}
#line 589 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static char *qla24xx_fw_version_str(struct scsi_qla_host *vha , char *str , size_t size ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 591
  ha = vha->hw;
#line 593
  snprintf(str, size, "%d.%02d.%02d (%x)", (int )ha->fw_major_version, (int )ha->fw_minor_version,
           (int )ha->fw_subminor_version, (int )ha->fw_attributes);
#line 595
  return (str);
}
}
#line 599 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
void qla2x00_sp_free_dma(void *vha , void *ptr ) 
{ 
  srb_t *sp ;
  struct scsi_cmnd *cmd ;
  struct qla_hw_data *ha ;
  void *ctx ;
  unsigned int tmp ;
  struct scatterlist *tmp___0 ;
  struct ct6_dsd *ctx1 ;

  {
#line 601
  sp = (srb_t *)ptr;
#line 602
  cmd = sp->u.scmd.cmd;
#line 603
  ha = ((sp->fcport)->vha)->hw;
#line 604
  ctx = sp->u.scmd.ctx;
#line 606
  if ((int )sp->flags & 1) {
#line 607
    scsi_dma_unmap(cmd);
#line 608
    sp->flags = (unsigned int )sp->flags & 65534U;
  } else {

  }
#line 611
  if (((int )sp->flags & 16) != 0) {
#line 612
    tmp = scsi_prot_sg_count(cmd);
#line 612
    tmp___0 = scsi_prot_sglist(cmd);
#line 612
    dma_unmap_sg_attrs(& (ha->pdev)->dev, tmp___0, (int )tmp, cmd->sc_data_direction,
                       (struct dma_attrs *)0);
#line 614
    sp->flags = (unsigned int )sp->flags & 65519U;
  } else {

  }
#line 617
  if (((int )sp->flags & 32) != 0) {
#line 619
    qla2x00_clean_dsd_pool(ha, sp, (struct qla_tgt_cmd *)0);
#line 620
    sp->flags = (unsigned int )sp->flags & 65503U;
  } else {

  }
#line 623
  if (((int )sp->flags & 4) != 0) {
#line 624
    dma_pool_free(ha->dl_dma_pool, ctx, ((struct crc_context *)ctx)->crc_ctx_dma);
#line 626
    sp->flags = (unsigned int )sp->flags & 65531U;
  } else {

  }
#line 629
  if (((int )sp->flags & 4096) != 0) {
#line 630
    ctx1 = (struct ct6_dsd *)ctx;
#line 632
    dma_pool_free(ha->fcp_cmnd_dma_pool, (void *)ctx1->fcp_cmnd, ctx1->fcp_cmnd_dma);
#line 634
    list_splice((struct list_head  const  *)(& ctx1->dsd_list), & ha->gbl_dsd_list);
#line 635
    ha->gbl_dsd_inuse = (int )ha->gbl_dsd_inuse - (int )((uint16_t )ctx1->dsd_use_cnt);
#line 636
    ha->gbl_dsd_avail = (int )ha->gbl_dsd_avail + (int )((uint16_t )ctx1->dsd_use_cnt);
#line 637
    mempool_free((void *)ctx1, ha->ctx_mempool);
#line 638
    ctx1 = (struct ct6_dsd *)0;
  } else {

  }
#line 641
  cmd->SCp.ptr = (char *)0;
#line 642
  qla2x00_rel_sp((sp->fcport)->vha, sp);
#line 643
  return;
}
}
#line 646 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla2x00_sp_compl(void *data , void *ptr , int res ) 
{ 
  struct qla_hw_data *ha ;
  srb_t *sp ;
  struct scsi_cmnd *cmd ;
  int tmp ;
  int tmp___0 ;

  {
#line 648
  ha = (struct qla_hw_data *)data;
#line 649
  sp = (srb_t *)ptr;
#line 650
  cmd = sp->u.scmd.cmd;
#line 652
  cmd->result = res;
#line 654
  tmp = atomic_read((atomic_t const   *)(& sp->ref_count));
#line 654
  if (tmp == 0) {
#line 655
    ql_dbg(134217728U, (sp->fcport)->vha, 12309, "SP reference-count to ZERO -- sp=%p cmd=%p.\n",
           sp, sp->u.scmd.cmd);
#line 658
    if ((ql2xextended_error_logging & 134217728) != 0) {
#line 659
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"),
                           "i" (659), "i" (12UL));
      ldv_66931: ;
#line 659
      goto ldv_66931;
    } else {

    }
#line 660
    return;
  } else {

  }
#line 662
  tmp___0 = atomic_dec_and_test(& sp->ref_count);
#line 662
  if (tmp___0 == 0) {
#line 663
    return;
  } else {

  }
#line 665
  qla2x00_sp_free_dma((void *)ha, (void *)sp);
#line 666
  (*(cmd->scsi_done))(cmd);
#line 667
  return;
}
}
#line 673 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int qla2xxx_queuecommand(struct Scsi_Host *host , struct scsi_cmnd *cmd ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  fc_port_t *fcport ;
  struct fc_rport *rport ;
  struct device  const  *__mptr ;
  struct scsi_target *tmp___2 ;
  struct fc_rport *tmp___3 ;
  struct scsi_target *tmp___4 ;
  int tmp___5 ;
  struct qla_hw_data *ha ;
  struct scsi_qla_host *base_vha ;
  void *tmp___6 ;
  srb_t *sp ;
  int rval ;
  unsigned char tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 675
  tmp = shost_priv(host);
#line 675
  vha = (scsi_qla_host_t *)tmp;
#line 676
  fcport = (fc_port_t *)(cmd->device)->hostdata;
#line 677
  tmp___4 = scsi_target(cmd->device);
#line 677
  tmp___5 = scsi_is_fc_rport((struct device  const  *)tmp___4->dev.parent);
#line 677
  if (tmp___5 != 0) {
#line 677
    tmp___2 = scsi_target(cmd->device);
#line 677
    __mptr = (struct device  const  *)tmp___2->dev.parent;
#line 677
    tmp___3 = (struct fc_rport *)__mptr + 0xffffffffffffffa0UL;
  } else {
#line 677
    tmp___3 = (struct fc_rport *)0;
  }
#line 677
  rport = tmp___3;
#line 678
  ha = vha->hw;
#line 679
  tmp___6 = pci_get_drvdata(ha->pdev);
#line 679
  base_vha = (struct scsi_qla_host *)tmp___6;
#line 683
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 684
    if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 685
      ql_dbg(2097152U, vha, 36880, "PCI Channel IO permanent failure, exiting cmd=%p.\n",
             cmd);
#line 688
      cmd->result = 65536;
    } else {
#line 690
      ql_dbg(2097152U, vha, 36881, "EEH_Busy, Requeuing the cmd=%p.\n", cmd);
#line 692
      cmd->result = 851968;
    }
#line 694
    goto qc24_fail_command;
  } else {

  }
#line 697
  rval = fc_remote_port_chkready(rport);
#line 698
  if (rval != 0) {
#line 699
    cmd->result = rval;
#line 700
    ql_dbg(134250496U, vha, 12291, "fc_remote_port_chkready failed for cmd=%p, rval=0x%x.\n",
           cmd, rval);
#line 703
    goto qc24_fail_command;
  } else {

  }
#line 706
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 706
    tmp___7 = scsi_get_prot_op(cmd);
#line 706
    if ((unsigned int )tmp___7 != 0U) {
#line 708
      ql_dbg(134217728U, vha, 12292, "DIF Cap not reg, fail DIF capable cmd\'s:%p.\n",
             cmd);
#line 711
      cmd->result = 65536;
#line 712
      goto qc24_fail_command;
    } else {

    }
  } else {

  }
#line 715
  if ((unsigned long )fcport == (unsigned long )((fc_port_t *)0)) {
#line 716
    cmd->result = 65536;
#line 717
    goto qc24_fail_command;
  } else {

  }
#line 720
  tmp___12 = atomic_read((atomic_t const   *)(& fcport->state));
#line 720
  if (tmp___12 != 4) {
#line 721
    tmp___10 = atomic_read((atomic_t const   *)(& fcport->state));
#line 721
    if (tmp___10 == 2) {
#line 723
      tmp___8 = atomic_read((atomic_t const   *)(& base_vha->loop_state));
#line 723
      tmp___9 = atomic_read((atomic_t const   *)(& fcport->state));
#line 723
      ql_dbg(134217728U, vha, 12293, "Returning DNC, fcport_state=%d loop_state=%d.\n",
             tmp___9, tmp___8);
#line 727
      cmd->result = 65536;
#line 728
      goto qc24_fail_command;
    } else {
#line 721
      tmp___11 = atomic_read((atomic_t const   *)(& base_vha->loop_state));
#line 721
      if (tmp___11 == 6) {
#line 723
        tmp___8 = atomic_read((atomic_t const   *)(& base_vha->loop_state));
#line 723
        tmp___9 = atomic_read((atomic_t const   *)(& fcport->state));
#line 723
        ql_dbg(134217728U, vha, 12293, "Returning DNC, fcport_state=%d loop_state=%d.\n",
               tmp___9, tmp___8);
#line 727
        cmd->result = 65536;
#line 728
        goto qc24_fail_command;
      } else {

      }
    }
#line 730
    goto qc24_target_busy;
  } else {

  }
#line 737
  if (fcport->retry_delay_timestamp == 0UL) {

  } else
#line 739
  if ((long )(fcport->retry_delay_timestamp - (unsigned long )jiffies) < 0L) {
#line 740
    fcport->retry_delay_timestamp = 0UL;
  } else {
#line 742
    goto qc24_target_busy;
  }
#line 744
  sp = qla2x00_get_sp(vha, fcport, 32U);
#line 745
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 746
    goto qc24_host_busy;
  } else {

  }
#line 748
  sp->u.scmd.cmd = cmd;
#line 749
  sp->type = 8U;
#line 750
  atomic_set(& sp->ref_count, 1);
#line 751
  cmd->SCp.ptr = (char *)sp;
#line 752
  sp->free = & qla2x00_sp_free_dma;
#line 753
  sp->done = & qla2x00_sp_compl;
#line 755
  rval = (*((ha->isp_ops)->start_scsi))(sp);
#line 756
  if (rval != 0) {
#line 757
    ql_dbg(134250496U, vha, 12307, "Start scsi failed rval=%d for cmd=%p.\n", rval,
           cmd);
#line 759
    goto qc24_host_busy_free_sp;
  } else {

  }
#line 762
  return (0);
  qc24_host_busy_free_sp: 
#line 765
  qla2x00_sp_free_dma((void *)ha, (void *)sp);
  qc24_host_busy: ;
#line 768
  return (4181);
  qc24_target_busy: ;
#line 771
  return (4184);
  qc24_fail_command: 
#line 774
  (*(cmd->scsi_done))(cmd);
#line 776
  return (0);
}
}
#line 792 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int qla2x00_eh_wait_on_command(struct scsi_cmnd *cmd ) 
{ 
  unsigned long wait_iter ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int ret ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 796
  wait_iter = 2UL;
#line 797
  tmp = shost_priv((cmd->device)->host);
#line 797
  vha = (scsi_qla_host_t *)tmp;
#line 798
  ha = vha->hw;
#line 799
  ret = 0;
#line 801
  tmp___0 = pci_channel_offline(ha->pdev);
#line 801
  tmp___1 = ldv__builtin_expect(tmp___0 != 0, 0L);
#line 801
  if (tmp___1 != 0L || *((unsigned long *)ha + 2UL) != 0UL) {
#line 802
    ql_dbg(4194304U, vha, 32773, "Return:eh_wait.\n");
#line 804
    return (ret);
  } else {

  }
#line 807
  goto ldv_66963;
  ldv_66962: 
#line 808
  msleep(1000U);
  ldv_66963: ;
#line 807
  if ((unsigned long )cmd->SCp.ptr != (unsigned long )((char *)0)) {
#line 807
    tmp___2 = wait_iter;
#line 807
    wait_iter = wait_iter - 1UL;
#line 807
    if (tmp___2 != 0UL) {
#line 809
      goto ldv_66962;
    } else {
#line 812
      goto ldv_66964;
    }
  } else {

  }
  ldv_66964: ;
#line 810
  if ((unsigned long )cmd->SCp.ptr != (unsigned long )((char *)0)) {
#line 811
    ret = 258;
  } else {

  }
#line 813
  return (ret);
}
}
#line 834 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int qla2x00_wait_for_hba_online(scsi_qla_host_t *vha ) 
{ 
  int return_status ;
  unsigned long wait_online ;
  struct qla_hw_data *ha ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 838
  ha = vha->hw;
#line 839
  tmp = pci_get_drvdata(ha->pdev);
#line 839
  base_vha = (scsi_qla_host_t *)tmp;
#line 841
  wait_online = (unsigned long )jiffies + 75000UL;
#line 842
  goto ldv_66979;
  ldv_66978: 
#line 847
  msleep(1000U);
  ldv_66979: 
#line 842
  tmp___0 = constant_test_bit(2L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 845
  if (tmp___0 != 0) {
#line 845
    goto _L;
  } else {
#line 842
    tmp___1 = constant_test_bit(3L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 845
    if (tmp___1 != 0) {
#line 845
      goto _L;
    } else {
#line 842
      tmp___2 = constant_test_bit(10L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 845
      if (tmp___2 != 0) {
#line 845
        goto _L;
      } else
#line 845
      if ((unsigned int )ha->dpc_active != 0U) {
        _L: /* CIL Label */ 
#line 845
        if ((long )((unsigned long )jiffies - wait_online) < 0L) {
#line 847
          goto ldv_66978;
        } else {
#line 850
          goto ldv_66980;
        }
      } else {
#line 850
        goto ldv_66980;
      }
    }
  }
  ldv_66980: ;
#line 849
  if (*((unsigned long *)base_vha + 19UL) != 0UL) {
#line 850
    return_status = 0;
  } else {
#line 852
    return_status = 258;
  }
#line 854
  return (return_status);
}
}
#line 870 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla2x00_wait_for_hba_ready(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 872
  ha = vha->hw;
#line 874
  goto ldv_66986;
  ldv_66985: 
#line 878
  msleep(1000U);
  ldv_66986: 
#line 874
  tmp = qla2x00_reset_active(vha);
#line 874
  if ((tmp != 0 || (unsigned int )ha->dpc_active != 0U) || *((unsigned long *)ha + 2UL) != 0UL) {
#line 878
    goto ldv_66985;
  } else {
#line 874
    tmp___0 = constant_test_bit(23L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 874
    if (tmp___0 != 0) {
#line 878
      goto ldv_66985;
    } else {
#line 874
      tmp___1 = constant_test_bit(24L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 874
      if (tmp___1 != 0) {
#line 878
        goto ldv_66985;
      } else {
#line 881
        goto ldv_66987;
      }
    }
  }
  ldv_66987: ;
#line 883
  return;
}
}
#line 882 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int qla2x00_wait_for_chip_reset(scsi_qla_host_t *vha ) 
{ 
  int return_status ;
  unsigned long wait_reset ;
  struct qla_hw_data *ha ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 886
  ha = vha->hw;
#line 887
  tmp = pci_get_drvdata(ha->pdev);
#line 887
  base_vha = (scsi_qla_host_t *)tmp;
#line 889
  wait_reset = (unsigned long )jiffies + 75000UL;
#line 890
  goto ldv_67003;
  ldv_67002: 
#line 895
  msleep(1000U);
#line 897
  tmp___0 = constant_test_bit(2L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 897
  if (tmp___0 == 0 && *((unsigned long *)ha + 2UL) != 0UL) {
#line 899
    goto ldv_67001;
  } else {

  }
  ldv_67003: 
#line 890
  tmp___1 = constant_test_bit(2L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 893
  if (tmp___1 != 0) {
#line 893
    goto _L;
  } else {
#line 890
    tmp___2 = constant_test_bit(3L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 893
    if (tmp___2 != 0) {
#line 893
      goto _L;
    } else {
#line 890
      tmp___3 = constant_test_bit(10L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 893
      if (tmp___3 != 0) {
#line 893
        goto _L;
      } else
#line 893
      if ((unsigned int )ha->dpc_active != 0U) {
        _L: /* CIL Label */ 
#line 893
        if ((long )((unsigned long )jiffies - wait_reset) < 0L) {
#line 895
          goto ldv_67002;
        } else {
#line 898
          goto ldv_67001;
        }
      } else {
#line 898
        goto ldv_67001;
      }
    }
  }
  ldv_67001: ;
#line 901
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 902
    return_status = 0;
  } else {
#line 904
    return_status = 258;
  }
#line 906
  return (return_status);
}
}
#line 910 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void sp_get(struct srb *sp ) 
{ 


  {
#line 912
  atomic_inc(& sp->ref_count);
#line 913
  return;
}
}
#line 931 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int qla2xxx_eh_abort(struct scsi_cmnd *cmd ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  srb_t *sp ;
  int ret ;
  unsigned int id ;
  uint64_t lun ;
  unsigned long flags ;
  int rval ;
  int wait ;
  struct qla_hw_data *ha ;
  raw_spinlock_t *tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  int tmp___2 ;

  {
#line 933
  tmp = shost_priv((cmd->device)->host);
#line 933
  vha = (scsi_qla_host_t *)tmp;
#line 939
  wait = 0;
#line 940
  ha = vha->hw;
#line 942
  if ((unsigned long )cmd->SCp.ptr == (unsigned long )((char *)0)) {
#line 943
    return (8194);
  } else {

  }
#line 945
  ret = fc_block_scsi_eh(cmd);
#line 946
  if (ret != 0) {
#line 947
    return (ret);
  } else {

  }
#line 948
  ret = 8194;
#line 950
  id = (cmd->device)->id;
#line 951
  lun = (cmd->device)->lun;
#line 953
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 953
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 954
  sp = (srb_t *)cmd->SCp.ptr;
#line 955
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 956
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 957
    return (8194);
  } else {

  }
#line 960
  ql_dbg(4194304U, vha, 32770, "Aborting from RISC nexus=%ld:%d:%llu sp=%p cmd=%p\n",
         vha->host_no, id, lun, sp, cmd);
#line 965
  sp_get(sp);
#line 967
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 968
  rval = (*((ha->isp_ops)->abort_command))(sp);
#line 969
  if (rval != 0) {
#line 970
    if (rval == 257) {
#line 975
      atomic_dec(& sp->ref_count);
#line 976
      ret = 8194;
    } else {
#line 978
      ret = 8195;
    }
#line 980
    ql_dbg(4194304U, vha, 32771, "Abort command mbx failed cmd=%p, rval=%x.\n", cmd,
           rval);
  } else {
#line 983
    ql_dbg(4194304U, vha, 32772, "Abort command mbx success cmd=%p.\n", cmd);
#line 985
    wait = 1;
  }
#line 988
  tmp___1 = spinlock_check(& ha->hardware_lock);
#line 988
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 993
  if (rval == 257) {
#line 994
    *((vha->req)->outstanding_cmds + (unsigned long )sp->handle) = (srb_t *)0;
  } else {

  }
#line 995
  (*(sp->done))((void *)ha, (void *)sp, 0);
#line 996
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 999
  if (ret == 8195 && (unsigned long )cmd->SCp.ptr == (unsigned long )((char *)0)) {
#line 1000
    ret = 8194;
  } else {

  }
#line 1003
  if (wait != 0) {
#line 1004
    tmp___2 = qla2x00_eh_wait_on_command(cmd);
#line 1004
    if (tmp___2 != 0) {
#line 1005
      ql_log(1U, vha, 32774, "Abort handler timed out cmd=%p.\n", cmd);
#line 1007
      ret = 8195;
    } else {

    }
  } else {

  }
#line 1011
  ql_log(2U, vha, 32796, "Abort command issued nexus=%ld:%d:%llu --  %d %x.\n", vha->host_no,
         id, lun, wait, ret);
#line 1015
  return (ret);
}
}
#line 1019 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int qla2x00_eh_wait_for_pending_commands(scsi_qla_host_t *vha , unsigned int t , uint64_t l ,
                                         enum nexus_wait_type type ) 
{ 
  int cnt ;
  int match ;
  int status ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  srb_t *sp ;
  struct scsi_cmnd *cmd ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 1024
  ha = vha->hw;
#line 1029
  status = 0;
#line 1031
  tmp = spinlock_check(& ha->hardware_lock);
#line 1031
  flags = _raw_spin_lock_irqsave(tmp);
#line 1032
  req = vha->req;
#line 1033
  cnt = 1;
#line 1033
  goto ldv_67051;
  ldv_67050: 
#line 1035
  sp = *(req->outstanding_cmds + (unsigned long )cnt);
#line 1036
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 1037
    goto ldv_67042;
  } else {

  }
#line 1038
  if ((unsigned int )sp->type != 8U) {
#line 1039
    goto ldv_67042;
  } else {

  }
#line 1040
  if ((int )vha->vp_idx != (int )((sp->fcport)->vha)->vp_idx) {
#line 1041
    goto ldv_67042;
  } else {

  }
#line 1042
  match = 0;
#line 1043
  cmd = sp->u.scmd.cmd;
#line 1044
  switch ((unsigned int )type) {
  case 0U: 
#line 1046
  match = 1;
#line 1047
  goto ldv_67044;
  case 1U: 
#line 1049
  match = (cmd->device)->id == t;
#line 1050
  goto ldv_67044;
  case 2U: 
#line 1052
  match = (cmd->device)->id == t && (cmd->device)->lun == l;
#line 1054
  goto ldv_67044;
  }
  ldv_67044: ;
#line 1056
  if (match == 0) {
#line 1057
    goto ldv_67042;
  } else {

  }
#line 1059
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1060
  status = qla2x00_eh_wait_on_command(cmd);
#line 1061
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 1061
  flags = _raw_spin_lock_irqsave(tmp___0);
  ldv_67042: 
#line 1034
  cnt = cnt + 1;
  ldv_67051: ;
#line 1033
  if (status == 0 && (int )req->num_outstanding_cmds > cnt) {
#line 1036
    goto ldv_67050;
  } else {

  }
#line 1063
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1065
  return (status);
}
}
#line 1068 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static char *reset_errors[4U]  = {      (char *)"HBA not online",      (char *)"HBA not ready",      (char *)"Task management failed",      (char *)"Waiting for command completions"};
#line 1076 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int __qla2xxx_eh_generic_reset(char *name , enum nexus_wait_type type , struct scsi_cmnd *cmd ,
                                      int (*do_reset)(struct fc_port * , uint64_t  ,
                                                      int  ) ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  fc_port_t *fcport ;
  int err ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1079
  tmp = shost_priv((cmd->device)->host);
#line 1079
  vha = (scsi_qla_host_t *)tmp;
#line 1080
  fcport = (fc_port_t *)(cmd->device)->hostdata;
#line 1083
  if ((unsigned long )fcport == (unsigned long )((fc_port_t *)0)) {
#line 1084
    return (8195);
  } else {

  }
#line 1087
  err = fc_block_scsi_eh(cmd);
#line 1088
  if (err != 0) {
#line 1089
    return (err);
  } else {

  }
#line 1091
  ql_log(2U, vha, 32777, "%s RESET ISSUED nexus=%ld:%d:%llu cmd=%p.\n", name, vha->host_no,
         (cmd->device)->id, (cmd->device)->lun, cmd);
#line 1095
  err = 0;
#line 1096
  tmp___0 = qla2x00_wait_for_hba_online(vha);
#line 1096
  if (tmp___0 != 0) {
#line 1097
    ql_log(1U, vha, 32778, "Wait for hba online failed for cmd=%p.\n", cmd);
#line 1099
    goto eh_reset_failed;
  } else {

  }
#line 1101
  err = 2;
#line 1102
  tmp___1 = (*do_reset)(fcport, (cmd->device)->lun, (cmd->request)->cpu + 1);
#line 1102
  if (tmp___1 != 0) {
#line 1104
    ql_log(1U, vha, 32780, "do_reset failed for cmd=%p.\n", cmd);
#line 1106
    goto eh_reset_failed;
  } else {

  }
#line 1108
  err = 3;
#line 1109
  tmp___2 = qla2x00_eh_wait_for_pending_commands(vha, (cmd->device)->id, (cmd->device)->lun,
                                                 type);
#line 1109
  if (tmp___2 != 0) {
#line 1111
    ql_log(1U, vha, 32781, "wait for pending cmds failed for cmd=%p.\n", cmd);
#line 1113
    goto eh_reset_failed;
  } else {

  }
#line 1116
  ql_log(2U, vha, 32782, "%s RESET SUCCEEDED nexus:%ld:%d:%llu cmd=%p.\n", name, vha->host_no,
         (cmd->device)->id, (cmd->device)->lun, cmd);
#line 1120
  return (8194);
  eh_reset_failed: 
#line 1123
  ql_log(2U, vha, 32783, "%s RESET FAILED: %s nexus=%ld:%d:%llu cmd=%p.\n", name,
         reset_errors[err], vha->host_no, (cmd->device)->id, (cmd->device)->lun, cmd);
#line 1127
  return (8195);
}
}
#line 1131 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int qla2xxx_eh_device_reset(struct scsi_cmnd *cmd ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int tmp___0 ;

  {
#line 1133
  tmp = shost_priv((cmd->device)->host);
#line 1133
  vha = (scsi_qla_host_t *)tmp;
#line 1134
  ha = vha->hw;
#line 1136
  tmp___0 = __qla2xxx_eh_generic_reset((char *)"DEVICE", 2, cmd, (ha->isp_ops)->lun_reset);
#line 1136
  return (tmp___0);
}
}
#line 1141 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int qla2xxx_eh_target_reset(struct scsi_cmnd *cmd ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int tmp___0 ;

  {
#line 1143
  tmp = shost_priv((cmd->device)->host);
#line 1143
  vha = (scsi_qla_host_t *)tmp;
#line 1144
  ha = vha->hw;
#line 1146
  tmp___0 = __qla2xxx_eh_generic_reset((char *)"TARGET", 1, cmd, (ha->isp_ops)->target_reset);
#line 1146
  return (tmp___0);
}
}
#line 1166 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int qla2xxx_eh_bus_reset(struct scsi_cmnd *cmd ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  fc_port_t *fcport ;
  int ret ;
  unsigned int id ;
  uint64_t lun ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1168
  tmp = shost_priv((cmd->device)->host);
#line 1168
  vha = (scsi_qla_host_t *)tmp;
#line 1169
  fcport = (fc_port_t *)(cmd->device)->hostdata;
#line 1170
  ret = 8195;
#line 1174
  id = (cmd->device)->id;
#line 1175
  lun = (cmd->device)->lun;
#line 1177
  if ((unsigned long )fcport == (unsigned long )((fc_port_t *)0)) {
#line 1178
    return (ret);
  } else {

  }
#line 1181
  ret = fc_block_scsi_eh(cmd);
#line 1182
  if (ret != 0) {
#line 1183
    return (ret);
  } else {

  }
#line 1184
  ret = 8195;
#line 1186
  ql_log(2U, vha, 32786, "BUS RESET ISSUED nexus=%ld:%d:%llu.\n", vha->host_no, id,
         lun);
#line 1189
  tmp___0 = qla2x00_wait_for_hba_online(vha);
#line 1189
  if (tmp___0 != 0) {
#line 1190
    ql_log(0U, vha, 32787, "Wait for hba online failed board disabled.\n");
#line 1192
    goto eh_bus_reset_done;
  } else {

  }
#line 1195
  tmp___1 = qla2x00_loop_reset(vha);
#line 1195
  if (tmp___1 == 0) {
#line 1196
    ret = 8194;
  } else {

  }
#line 1198
  if (ret == 8195) {
#line 1199
    goto eh_bus_reset_done;
  } else {

  }
#line 1202
  tmp___2 = qla2x00_eh_wait_for_pending_commands(vha, 0U, 0ULL, 0);
#line 1202
  if (tmp___2 != 0) {
#line 1204
    ql_log(1U, vha, 32788, "Wait for pending commands failed.\n");
#line 1206
    ret = 8195;
  } else {

  }
  eh_bus_reset_done: 
#line 1210
  ql_log(1U, vha, 32811, "BUS RESET %s nexus=%ld:%d:%llu.\n", ret == 8195 ? (char *)"FAILED" : (char *)"SUCCEEDED",
         vha->host_no, id, lun);
#line 1214
  return (ret);
}
}
#line 1233 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int qla2xxx_eh_host_reset(struct scsi_cmnd *cmd ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int ret ;
  unsigned int id ;
  uint64_t lun ;
  scsi_qla_host_t *base_vha ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1235
  tmp = shost_priv((cmd->device)->host);
#line 1235
  vha = (scsi_qla_host_t *)tmp;
#line 1236
  ha = vha->hw;
#line 1237
  ret = 8195;
#line 1240
  tmp___0 = pci_get_drvdata(ha->pdev);
#line 1240
  base_vha = (scsi_qla_host_t *)tmp___0;
#line 1242
  id = (cmd->device)->id;
#line 1243
  lun = (cmd->device)->lun;
#line 1245
  ql_log(2U, vha, 32792, "ADAPTER RESET ISSUED nexus=%ld:%d:%llu.\n", vha->host_no,
         id, lun);
#line 1252
  tmp___1 = qla2x00_reset_active(vha);
#line 1252
  if (tmp___1 != 0 || ha->optrom_state != 0) {
#line 1253
    goto eh_host_reset_lock;
  } else {

  }
#line 1255
  if ((unsigned long )vha != (unsigned long )base_vha) {
#line 1256
    tmp___2 = qla2x00_vp_abort_isp(vha);
#line 1256
    if (tmp___2 != 0) {
#line 1257
      goto eh_host_reset_lock;
    } else {

    }
  } else {
#line 1259
    if (((vha->hw)->device_type & 16384U) != 0U || ((vha->hw)->device_type & 262144U) != 0U) {
#line 1260
      tmp___3 = qla82xx_fcoe_ctx_reset(vha);
#line 1260
      if (tmp___3 == 0) {
#line 1262
        ret = 8194;
#line 1263
        goto eh_host_reset_lock;
      } else {

      }
    } else {

    }
#line 1267
    if ((unsigned long )ha->wq != (unsigned long )((struct workqueue_struct *)0)) {
#line 1268
      ldv_flush_workqueue_14(ha->wq);
    } else {

    }
#line 1270
    set_bit(3L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 1271
    tmp___5 = (*((ha->isp_ops)->abort_isp))(base_vha);
#line 1271
    if (tmp___5 != 0) {
#line 1272
      clear_bit(3L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 1274
      set_bit(2L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 1276
      tmp___4 = qla2x00_wait_for_hba_online(vha);
#line 1276
      if (tmp___4 != 0) {
#line 1277
        ql_log(1U, vha, 32810, "wait for hba online failed.\n");
#line 1279
        goto eh_host_reset_lock;
      } else {

      }
    } else {

    }
#line 1282
    clear_bit(3L, (unsigned long volatile   *)(& base_vha->dpc_flags));
  }
#line 1286
  tmp___6 = qla2x00_eh_wait_for_pending_commands(vha, 0U, 0ULL, 0);
#line 1286
  if (tmp___6 == 0) {
#line 1288
    ret = 8194;
  } else {

  }
  eh_host_reset_lock: 
#line 1291
  ql_log(2U, vha, 32791, "ADAPTER RESET %s nexus=%ld:%d:%llu.\n", ret == 8195 ? (char *)"FAILED" : (char *)"SUCCEEDED",
         vha->host_no, id, lun);
#line 1295
  return (ret);
}
}
#line 1309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int qla2x00_loop_reset(scsi_qla_host_t *vha ) 
{ 
  int ret ;
  struct fc_port *fcport ;
  struct qla_hw_data *ha ;
  int tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1313
  ha = vha->hw;
#line 1315
  if ((ha->device_type & 131072U) != 0U) {
#line 1316
    tmp = qlafx00_loop_reset(vha);
#line 1316
    return (tmp);
  } else {

  }
#line 1319
  if (ql2xtargetreset == 1 && *((unsigned long *)ha + 2UL) != 0UL) {
#line 1320
    __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 1320
    fcport = (struct fc_port *)__mptr;
#line 1320
    goto ldv_67108;
    ldv_67107: ;
#line 1321
    if ((unsigned int )fcport->port_type != 5U) {
#line 1322
      goto ldv_67106;
    } else {

    }
#line 1324
    ret = (*((ha->isp_ops)->target_reset))(fcport, 0ULL, 0);
#line 1325
    if (ret != 0) {
#line 1326
      ql_dbg(4194304U, vha, 32812, "Bus Reset failed: Reset=%d d_id=%x.\n", ret, (int )fcport->d_id.b24);
    } else {

    }
    ldv_67106: 
#line 1320
    __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 1320
    fcport = (struct fc_port *)__mptr___0;
    ldv_67108: ;
#line 1320
    if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 1322
      goto ldv_67107;
    } else {

    }

  } else {

  }
#line 1334
  if (*((unsigned long *)ha + 2UL) != 0UL && ((((ha->device_type & 8192U) == 0U && (ha->device_type & 16384U) == 0U) && (ha->device_type & 65536U) == 0U) && (ha->device_type & 262144U) == 0U)) {
#line 1335
    atomic_set(& vha->loop_state, 2);
#line 1336
    atomic_set(& vha->loop_down_timer, 255);
#line 1337
    qla2x00_mark_all_devices_lost(vha, 0);
#line 1338
    ret = qla2x00_full_login_lip(vha);
#line 1339
    if (ret != 0) {
#line 1340
      ql_dbg(4194304U, vha, 32813, "full_login_lip=%d.\n", ret);
    } else {

    }
  } else {

  }
#line 1345
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1346
    ret = qla2x00_lip_reset(vha);
#line 1347
    if (ret != 0) {
#line 1348
      ql_dbg(4194304U, vha, 32814, "lip_reset failed (%d).\n", ret);
    } else {

    }
  } else {

  }
#line 1353
  vha->marker_needed = 1U;
#line 1355
  return (0);
}
}
#line 1359 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
void qla2x00_abort_all_cmds(scsi_qla_host_t *vha , int res ) 
{ 
  int que ;
  int cnt ;
  unsigned long flags ;
  srb_t *sp ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  raw_spinlock_t *tmp ;

  {
#line 1364
  ha = vha->hw;
#line 1367
  qlt_host_reset_handler(ha);
#line 1369
  tmp = spinlock_check(& ha->hardware_lock);
#line 1369
  flags = _raw_spin_lock_irqsave(tmp);
#line 1370
  que = 0;
#line 1370
  goto ldv_67128;
  ldv_67127: 
#line 1371
  req = *(ha->req_q_map + (unsigned long )que);
#line 1372
  if ((unsigned long )req == (unsigned long )((struct req_que *)0)) {
#line 1373
    goto ldv_67123;
  } else {

  }
#line 1374
  if ((unsigned long )req->outstanding_cmds == (unsigned long )((srb_t **)0)) {
#line 1375
    goto ldv_67123;
  } else {

  }
#line 1376
  cnt = 1;
#line 1376
  goto ldv_67125;
  ldv_67124: 
#line 1377
  sp = *(req->outstanding_cmds + (unsigned long )cnt);
#line 1378
  if ((unsigned long )sp != (unsigned long )((srb_t *)0)) {
#line 1379
    *(req->outstanding_cmds + (unsigned long )cnt) = (srb_t *)0;
#line 1380
    (*(sp->done))((void *)vha, (void *)sp, res);
  } else {

  }
#line 1376
  cnt = cnt + 1;
  ldv_67125: ;
#line 1376
  if ((int )req->num_outstanding_cmds > cnt) {
#line 1378
    goto ldv_67124;
  } else {

  }

  ldv_67123: 
#line 1370
  que = que + 1;
  ldv_67128: ;
#line 1370
  if ((int )ha->max_req_queues > que) {
#line 1372
    goto ldv_67127;
  } else {

  }
#line 1384
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1385
  return;
}
}
#line 1388 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int qla2xxx_slave_alloc(struct scsi_device *sdev ) 
{ 
  struct fc_rport *rport ;
  struct device  const  *__mptr ;
  struct scsi_target *tmp___1 ;
  struct fc_rport *tmp___2 ;
  struct scsi_target *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1390
  tmp___3 = scsi_target(sdev);
#line 1390
  tmp___4 = scsi_is_fc_rport((struct device  const  *)tmp___3->dev.parent);
#line 1390
  if (tmp___4 != 0) {
#line 1390
    tmp___1 = scsi_target(sdev);
#line 1390
    __mptr = (struct device  const  *)tmp___1->dev.parent;
#line 1390
    tmp___2 = (struct fc_rport *)__mptr + 0xffffffffffffffa0UL;
  } else {
#line 1390
    tmp___2 = (struct fc_rport *)0;
  }
#line 1390
  rport = tmp___2;
#line 1392
  if ((unsigned long )rport == (unsigned long )((struct fc_rport *)0)) {
#line 1393
    return (-6);
  } else {
#line 1392
    tmp___5 = fc_remote_port_chkready(rport);
#line 1392
    if (tmp___5 != 0) {
#line 1393
      return (-6);
    } else {

    }
  }
#line 1395
  sdev->hostdata = (void *)*((fc_port_t **)rport->dd_data);
#line 1397
  return (0);
}
}
#line 1401 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int qla2xxx_slave_configure(struct scsi_device *sdev ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct req_que *req ;

  {
#line 1403
  tmp = shost_priv(sdev->host);
#line 1403
  vha = (scsi_qla_host_t *)tmp;
#line 1404
  req = vha->req;
#line 1406
  if (((vha->hw)->device_type & 33554432U) != 0U) {
#line 1407
    blk_queue_update_dma_alignment(sdev->request_queue, 7);
  } else {

  }
#line 1409
  scsi_change_queue_depth(sdev, req->max_q_depth);
#line 1410
  return (0);
}
}
#line 1414 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla2xxx_slave_destroy(struct scsi_device *sdev ) 
{ 


  {
#line 1416
  sdev->hostdata = (void *)0;
#line 1417
  return;
}
}
#line 1427 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla2x00_config_dma_addressing(struct qla_hw_data *ha ) 
{ 
  u64 tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1430
  ha->flags.enable_64bit_addressing = 0U;
#line 1432
  tmp___1 = dma_set_mask(& (ha->pdev)->dev, 0xffffffffffffffffULL);
#line 1432
  if (tmp___1 == 0) {
#line 1434
    tmp = dma_get_required_mask(& (ha->pdev)->dev);
#line 1434
    if ((unsigned int )(tmp >> 32ULL) != 0U) {
#line 1434
      tmp___0 = pci_set_consistent_dma_mask(ha->pdev, 0xffffffffffffffffULL);
#line 1434
      if (tmp___0 == 0) {
#line 1437
        ha->flags.enable_64bit_addressing = 1U;
#line 1438
        (ha->isp_ops)->calc_req_entries = & qla2x00_calc_iocbs_64;
#line 1439
        (ha->isp_ops)->build_iocbs = & qla2x00_build_scsi_iocbs_64;
#line 1440
        return;
      } else {

      }
    } else {

    }
  } else {

  }
#line 1444
  dma_set_mask(& (ha->pdev)->dev, 4294967295ULL);
#line 1445
  pci_set_consistent_dma_mask(ha->pdev, 4294967295ULL);
#line 1446
  return;
}
}
#line 1449 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla2x00_enable_intrs(struct qla_hw_data *ha ) 
{ 
  unsigned long flags ;
  struct device_reg_2xxx *reg ;
  raw_spinlock_t *tmp ;

  {
#line 1451
  flags = 0UL;
#line 1452
  reg = & (ha->iobase)->isp;
#line 1454
  tmp = spinlock_check(& ha->hardware_lock);
#line 1454
  flags = _raw_spin_lock_irqsave(tmp);
#line 1455
  ha->interrupts_on = 1U;
#line 1457
  writew(32776, (void volatile   *)(& reg->ictrl));
#line 1458
  readw((void const volatile   *)(& reg->ictrl));
#line 1459
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1460
  return;
}
}
#line 1464 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla2x00_disable_intrs(struct qla_hw_data *ha ) 
{ 
  unsigned long flags ;
  struct device_reg_2xxx *reg ;
  raw_spinlock_t *tmp ;

  {
#line 1466
  flags = 0UL;
#line 1467
  reg = & (ha->iobase)->isp;
#line 1469
  tmp = spinlock_check(& ha->hardware_lock);
#line 1469
  flags = _raw_spin_lock_irqsave(tmp);
#line 1470
  ha->interrupts_on = 0U;
#line 1472
  writew(0, (void volatile   *)(& reg->ictrl));
#line 1473
  readw((void const volatile   *)(& reg->ictrl));
#line 1474
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1475
  return;
}
}
#line 1478 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla24xx_enable_intrs(struct qla_hw_data *ha ) 
{ 
  unsigned long flags ;
  struct device_reg_24xx *reg ;
  raw_spinlock_t *tmp ;

  {
#line 1480
  flags = 0UL;
#line 1481
  reg = & (ha->iobase)->isp24;
#line 1483
  tmp = spinlock_check(& ha->hardware_lock);
#line 1483
  flags = _raw_spin_lock_irqsave(tmp);
#line 1484
  ha->interrupts_on = 1U;
#line 1485
  writel(8U, (void volatile   *)(& reg->ictrl));
#line 1486
  readl((void const volatile   *)(& reg->ictrl));
#line 1487
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1488
  return;
}
}
#line 1491 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla24xx_disable_intrs(struct qla_hw_data *ha ) 
{ 
  unsigned long flags ;
  struct device_reg_24xx *reg ;
  raw_spinlock_t *tmp ;

  {
#line 1493
  flags = 0UL;
#line 1494
  reg = & (ha->iobase)->isp24;
#line 1496
  if ((ha->device_type & 8192U) != 0U && *((unsigned long *)ha + 2UL) != 0UL) {
#line 1497
    return;
  } else {

  }
#line 1498
  tmp = spinlock_check(& ha->hardware_lock);
#line 1498
  flags = _raw_spin_lock_irqsave(tmp);
#line 1499
  ha->interrupts_on = 0U;
#line 1500
  writel(0U, (void volatile   *)(& reg->ictrl));
#line 1501
  readl((void const volatile   *)(& reg->ictrl));
#line 1502
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1503
  return;
}
}
#line 1506 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int qla2x00_iospace_config(struct qla_hw_data *ha ) 
{ 
  resource_size_t pio ;
  uint16_t msix ;
  int cpus ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  void *tmp___5 ;
  char const   *tmp___6 ;
  uint8_t tmp___7 ;
  void *tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 1512
  tmp___0 = pci_request_selected_regions(ha->pdev, ha->bars, "qla2xxx");
#line 1512
  if (tmp___0 != 0) {
#line 1514
    tmp = pci_name((struct pci_dev  const  *)ha->pdev);
#line 1514
    ql_log_pci(0U, ha->pdev, 17, "Failed to reserve PIO/MMIO regions (%s), aborting.\n",
               tmp);
#line 1517
    goto iospace_error_exit;
  } else {

  }
#line 1519
  if ((ha->bars & 1) == 0) {
#line 1520
    goto skip_pio;
  } else {

  }
#line 1523
  pio = (ha->pdev)->resource[0].start;
#line 1524
  if (((ha->pdev)->resource[0].flags & 256UL) != 0UL) {
#line 1525
    if (((ha->pdev)->resource[0].start == 0ULL && (ha->pdev)->resource[0].end == (ha->pdev)->resource[0].start) || ((ha->pdev)->resource[0].end - (ha->pdev)->resource[0].start) + 1ULL <= 255ULL) {
#line 1526
      tmp___1 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 1526
      ql_log_pci(1U, ha->pdev, 18, "Invalid pci I/O region size (%s).\n", tmp___1);
#line 1529
      pio = 0ULL;
    } else {

    }
  } else {
#line 1532
    tmp___2 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 1532
    ql_log_pci(1U, ha->pdev, 19, "Region #0 no a PIO resource (%s).\n", tmp___2);
#line 1535
    pio = 0ULL;
  }
#line 1537
  ha->pio_address = pio;
#line 1538
  ql_dbg_pci(1073741824U, ha->pdev, 20, "PIO address=%llu.\n", ha->pio_address);
  skip_pio: ;
#line 1544
  if (((ha->pdev)->resource[1].flags & 512UL) == 0UL) {
#line 1545
    tmp___3 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 1545
    ql_log_pci(0U, ha->pdev, 21, "Region #1 not an MMIO resource (%s), aborting.\n",
               tmp___3);
#line 1548
    goto iospace_error_exit;
  } else {

  }
#line 1550
  if (((ha->pdev)->resource[1].start == 0ULL && (ha->pdev)->resource[1].end == (ha->pdev)->resource[1].start) || ((ha->pdev)->resource[1].end - (ha->pdev)->resource[1].start) + 1ULL <= 255ULL) {
#line 1551
    tmp___4 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 1551
    ql_log_pci(0U, ha->pdev, 22, "Invalid PCI mem region size (%s), aborting.\n",
               tmp___4);
#line 1554
    goto iospace_error_exit;
  } else {

  }
#line 1557
  tmp___5 = ioremap((ha->pdev)->resource[1].start, 256UL);
#line 1557
  ha->iobase = (device_reg_t *)tmp___5;
#line 1558
  if ((unsigned long )ha->iobase == (unsigned long )((device_reg_t *)0)) {
#line 1559
    tmp___6 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 1559
    ql_log_pci(0U, ha->pdev, 23, "Cannot remap MMIO (%s), aborting.\n", tmp___6);
#line 1562
    goto iospace_error_exit;
  } else {

  }
#line 1566
  tmp___7 = 1U;
#line 1566
  ha->max_rsp_queues = tmp___7;
#line 1566
  ha->max_req_queues = tmp___7;
#line 1567
  if (((ql2xmaxqueues <= 1 && ql2xmultique_tag == 0) || (ql2xmaxqueues > 1 && ql2xmultique_tag != 0)) || ((ha->device_type & 2048U) == 0U && (ha->device_type & 8192U) == 0U)) {
#line 1570
    goto mqiobase_exit;
  } else {

  }
#line 1572
  tmp___8 = ioremap((ha->pdev)->resource[3].start, (ha->pdev)->resource[3].start != 0ULL || (ha->pdev)->resource[3].end != (ha->pdev)->resource[3].start ? (unsigned long )(((ha->pdev)->resource[3].end - (ha->pdev)->resource[3].start) + 1ULL) : 0UL);
#line 1572
  ha->mqiobase = (device_reg_t *)tmp___8;
#line 1574
  if ((unsigned long )ha->mqiobase != (unsigned long )((device_reg_t *)0)) {
#line 1575
    ql_dbg_pci(1073741824U, ha->pdev, 24, "MQIO Base=%p.\n", ha->mqiobase);
#line 1578
    pci_read_config_word((struct pci_dev  const  *)ha->pdev, 162, & msix);
#line 1579
    ha->msix_count = msix;
#line 1582
    if (ql2xmultique_tag != 0) {
#line 1583
      tmp___9 = cpumask_weight(cpu_online_mask);
#line 1583
      cpus = (int )tmp___9;
#line 1584
      ha->max_rsp_queues = (int )ha->msix_count + -1 > cpus ? (unsigned int )((uint8_t )cpus) + 1U : (unsigned int )((uint8_t )ha->msix_count) + 255U;
#line 1586
      ha->max_req_queues = 2U;
    } else
#line 1587
    if (ql2xmaxqueues > 1) {
#line 1588
      ha->max_req_queues = (uint8_t )(32 < ql2xmaxqueues ? 32 : ql2xmaxqueues);
#line 1590
      ql_dbg_pci(1048576U, ha->pdev, 49160, "QoS mode set, max no of request queues:%d.\n",
                 (int )ha->max_req_queues);
#line 1593
      ql_dbg_pci(1073741824U, ha->pdev, 25, "QoS mode set, max no of request queues:%d.\n",
                 (int )ha->max_req_queues);
    } else {

    }
#line 1597
    ql_log_pci(2U, ha->pdev, 26, "MSI-X vector count: %d.\n", (int )msix);
  } else {
#line 1600
    ql_log_pci(2U, ha->pdev, 27, "BAR 3 not enabled.\n");
  }
  mqiobase_exit: 
#line 1604
  ha->msix_count = (unsigned int )((uint16_t )ha->max_rsp_queues) + 1U;
#line 1605
  ql_dbg_pci(1073741824U, ha->pdev, 28, "MSIX Count:%d.\n", (int )ha->msix_count);
#line 1607
  return (0);
  iospace_error_exit: ;
#line 1610
  return (-12);
}
}
#line 1615 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int qla83xx_iospace_config(struct qla_hw_data *ha ) 
{ 
  uint16_t msix ;
  int cpus ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  void *tmp___3 ;
  char const   *tmp___4 ;
  uint8_t tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  unsigned int tmp___8 ;

  {
#line 1620
  tmp___0 = pci_request_selected_regions(ha->pdev, ha->bars, "qla2xxx");
#line 1620
  if (tmp___0 != 0) {
#line 1622
    tmp = pci_name((struct pci_dev  const  *)ha->pdev);
#line 1622
    ql_log_pci(0U, ha->pdev, 279, "Failed to reserve PIO/MMIO regions (%s), aborting.\n",
               tmp);
#line 1626
    goto iospace_error_exit;
  } else {

  }
#line 1630
  if (((ha->pdev)->resource[0].flags & 512UL) == 0UL) {
#line 1631
    tmp___1 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 1631
    ql_log_pci(1U, ha->pdev, 280, "Invalid pci I/O region size (%s).\n", tmp___1);
#line 1634
    goto iospace_error_exit;
  } else {

  }
#line 1636
  if (((ha->pdev)->resource[0].start == 0ULL && (ha->pdev)->resource[0].end == (ha->pdev)->resource[0].start) || ((ha->pdev)->resource[0].end - (ha->pdev)->resource[0].start) + 1ULL <= 255ULL) {
#line 1637
    tmp___2 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 1637
    ql_log_pci(1U, ha->pdev, 281, "Invalid PCI mem region size (%s), aborting\n",
               tmp___2);
#line 1640
    goto iospace_error_exit;
  } else {

  }
#line 1643
  tmp___3 = ioremap((ha->pdev)->resource[0].start, 256UL);
#line 1643
  ha->iobase = (device_reg_t *)tmp___3;
#line 1644
  if ((unsigned long )ha->iobase == (unsigned long )((device_reg_t *)0)) {
#line 1645
    tmp___4 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 1645
    ql_log_pci(0U, ha->pdev, 282, "Cannot remap MMIO (%s), aborting.\n", tmp___4);
#line 1648
    goto iospace_error_exit;
  } else {

  }
#line 1654
  tmp___5 = 1U;
#line 1654
  ha->max_rsp_queues = tmp___5;
#line 1654
  ha->max_req_queues = tmp___5;
#line 1655
  tmp___6 = ioremap((ha->pdev)->resource[4].start, (ha->pdev)->resource[4].start != 0ULL || (ha->pdev)->resource[4].end != (ha->pdev)->resource[4].start ? (unsigned long )(((ha->pdev)->resource[4].end - (ha->pdev)->resource[4].start) + 1ULL) : 0UL);
#line 1655
  ha->mqiobase = (device_reg_t *)tmp___6;
#line 1658
  if ((unsigned long )ha->mqiobase == (unsigned long )((device_reg_t *)0)) {
#line 1659
    ql_log_pci(0U, ha->pdev, 285, "BAR2/region4 not enabled\n");
#line 1661
    goto mqiobase_exit;
  } else {

  }
#line 1664
  tmp___7 = ioremap((ha->pdev)->resource[2].start, (ha->pdev)->resource[2].start != 0ULL || (ha->pdev)->resource[2].end != (ha->pdev)->resource[2].start ? (unsigned long )(((ha->pdev)->resource[2].end - (ha->pdev)->resource[2].start) + 1ULL) : 0UL);
#line 1664
  ha->msixbase = (device_reg_t *)tmp___7;
#line 1666
  if ((unsigned long )ha->msixbase != (unsigned long )((device_reg_t *)0)) {
#line 1668
    pci_read_config_word((struct pci_dev  const  *)ha->pdev, 146, & msix);
#line 1670
    ha->msix_count = msix;
#line 1673
    if (ql2xmultique_tag != 0) {
#line 1674
      tmp___8 = cpumask_weight(cpu_online_mask);
#line 1674
      cpus = (int )tmp___8;
#line 1675
      ha->max_rsp_queues = (int )ha->msix_count + -1 > cpus ? (unsigned int )((uint8_t )cpus) + 1U : (unsigned int )((uint8_t )ha->msix_count) + 255U;
#line 1677
      ha->max_req_queues = 2U;
    } else
#line 1678
    if (ql2xmaxqueues > 1) {
#line 1679
      ha->max_req_queues = (uint8_t )(32 < ql2xmaxqueues ? 32 : ql2xmaxqueues);
#line 1681
      ql_dbg_pci(1048576U, ha->pdev, 49164, "QoS mode set, max no of request queues:%d.\n",
                 (int )ha->max_req_queues);
#line 1684
      ql_dbg_pci(1073741824U, ha->pdev, 283, "QoS mode set, max no of request queues:%d.\n",
                 (int )ha->max_req_queues);
    } else {

    }
#line 1688
    ql_log_pci(2U, ha->pdev, 284, "MSI-X vector count: %d.\n", (int )msix);
  } else {
#line 1691
    ql_log_pci(2U, ha->pdev, 286, "BAR 1 not enabled.\n");
  }
  mqiobase_exit: 
#line 1695
  ha->msix_count = (unsigned int )((uint16_t )ha->max_rsp_queues) + 1U;
#line 1697
  qlt_83xx_iospace_config(ha);
#line 1699
  ql_dbg_pci(1073741824U, ha->pdev, 287, "MSIX Count:%d.\n", (int )ha->msix_count);
#line 1701
  return (0);
  iospace_error_exit: ;
#line 1704
  return (-12);
}
}
#line 1707 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static struct isp_operations qla2100_isp_ops  = 
#line 1707
     {& qla2100_pci_config, & qla2x00_reset_chip, & qla2x00_chip_diag, & qla2x00_config_rings,
    & qla2x00_reset_adapter, & qla2x00_nvram_config, & qla2x00_update_fw_options,
    & qla2x00_load_risc, & qla2x00_pci_info_str, & qla2x00_fw_version_str, & qla2100_intr_handler,
    & qla2x00_enable_intrs, & qla2x00_disable_intrs, & qla2x00_abort_command, & qla2x00_abort_target,
    & qla2x00_lun_reset, & qla2x00_login_fabric, & qla2x00_fabric_logout, & qla2x00_calc_iocbs_32,
    & qla2x00_build_scsi_iocbs_32, & qla2x00_prep_ms_iocb, & qla2x00_prep_ms_fdmi_iocb,
    & qla2x00_read_nvram_data, & qla2x00_write_nvram_data, & qla2100_fw_dump, (int (*)(struct scsi_qla_host * ))0,
    (int (*)(struct scsi_qla_host * ))0, (void (*)(struct scsi_qla_host * ))0, & qla2x00_read_optrom_data,
    & qla2x00_write_optrom_data, & qla2x00_get_flash_version, & qla2x00_start_scsi,
    & qla2x00_abort_isp, & qla2x00_iospace_config, & qla2x00_initialize_adapter};
#line 1745 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static struct isp_operations qla2300_isp_ops  = 
#line 1745
     {& qla2300_pci_config, & qla2x00_reset_chip, & qla2x00_chip_diag, & qla2x00_config_rings,
    & qla2x00_reset_adapter, & qla2x00_nvram_config, & qla2x00_update_fw_options,
    & qla2x00_load_risc, & qla2x00_pci_info_str, & qla2x00_fw_version_str, & qla2300_intr_handler,
    & qla2x00_enable_intrs, & qla2x00_disable_intrs, & qla2x00_abort_command, & qla2x00_abort_target,
    & qla2x00_lun_reset, & qla2x00_login_fabric, & qla2x00_fabric_logout, & qla2x00_calc_iocbs_32,
    & qla2x00_build_scsi_iocbs_32, & qla2x00_prep_ms_iocb, & qla2x00_prep_ms_fdmi_iocb,
    & qla2x00_read_nvram_data, & qla2x00_write_nvram_data, & qla2300_fw_dump, & qla2x00_beacon_on,
    & qla2x00_beacon_off, & qla2x00_beacon_blink, & qla2x00_read_optrom_data, & qla2x00_write_optrom_data,
    & qla2x00_get_flash_version, & qla2x00_start_scsi, & qla2x00_abort_isp, & qla2x00_iospace_config,
    & qla2x00_initialize_adapter};
#line 1783 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static struct isp_operations qla24xx_isp_ops  = 
#line 1783
     {& qla24xx_pci_config, & qla24xx_reset_chip, & qla24xx_chip_diag, & qla24xx_config_rings,
    & qla24xx_reset_adapter, & qla24xx_nvram_config, & qla24xx_update_fw_options,
    & qla24xx_load_risc, & qla24xx_pci_info_str, & qla24xx_fw_version_str, & qla24xx_intr_handler,
    & qla24xx_enable_intrs, & qla24xx_disable_intrs, & qla24xx_abort_command, & qla24xx_abort_target,
    & qla24xx_lun_reset, & qla24xx_login_fabric, & qla24xx_fabric_logout, (uint16_t (*)(uint16_t  ))0,
    (void (*)(srb_t * , cmd_entry_t * , uint16_t  ))0, & qla24xx_prep_ms_iocb, & qla24xx_prep_ms_fdmi_iocb,
    & qla24xx_read_nvram_data, & qla24xx_write_nvram_data, & qla24xx_fw_dump, & qla24xx_beacon_on,
    & qla24xx_beacon_off, & qla24xx_beacon_blink, & qla24xx_read_optrom_data, & qla24xx_write_optrom_data,
    & qla24xx_get_flash_version, & qla24xx_start_scsi, & qla2x00_abort_isp, & qla2x00_iospace_config,
    & qla2x00_initialize_adapter};
#line 1821 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static struct isp_operations qla25xx_isp_ops  = 
#line 1821
     {& qla25xx_pci_config, & qla24xx_reset_chip, & qla24xx_chip_diag, & qla24xx_config_rings,
    & qla24xx_reset_adapter, & qla24xx_nvram_config, & qla24xx_update_fw_options,
    & qla24xx_load_risc, & qla24xx_pci_info_str, & qla24xx_fw_version_str, & qla24xx_intr_handler,
    & qla24xx_enable_intrs, & qla24xx_disable_intrs, & qla24xx_abort_command, & qla24xx_abort_target,
    & qla24xx_lun_reset, & qla24xx_login_fabric, & qla24xx_fabric_logout, (uint16_t (*)(uint16_t  ))0,
    (void (*)(srb_t * , cmd_entry_t * , uint16_t  ))0, & qla24xx_prep_ms_iocb, & qla24xx_prep_ms_fdmi_iocb,
    & qla25xx_read_nvram_data, & qla25xx_write_nvram_data, & qla25xx_fw_dump, & qla24xx_beacon_on,
    & qla24xx_beacon_off, & qla24xx_beacon_blink, & qla25xx_read_optrom_data, & qla24xx_write_optrom_data,
    & qla24xx_get_flash_version, & qla24xx_dif_start_scsi, & qla2x00_abort_isp, & qla2x00_iospace_config,
    & qla2x00_initialize_adapter};
#line 1859 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static struct isp_operations qla81xx_isp_ops  = 
#line 1859
     {& qla25xx_pci_config, & qla24xx_reset_chip, & qla24xx_chip_diag, & qla24xx_config_rings,
    & qla24xx_reset_adapter, & qla81xx_nvram_config, & qla81xx_update_fw_options,
    & qla81xx_load_risc, & qla24xx_pci_info_str, & qla24xx_fw_version_str, & qla24xx_intr_handler,
    & qla24xx_enable_intrs, & qla24xx_disable_intrs, & qla24xx_abort_command, & qla24xx_abort_target,
    & qla24xx_lun_reset, & qla24xx_login_fabric, & qla24xx_fabric_logout, (uint16_t (*)(uint16_t  ))0,
    (void (*)(srb_t * , cmd_entry_t * , uint16_t  ))0, & qla24xx_prep_ms_iocb, & qla24xx_prep_ms_fdmi_iocb,
    (uint8_t *(*)(struct scsi_qla_host * , uint8_t * , uint32_t  , uint32_t  ))0,
    (int (*)(struct scsi_qla_host * , uint8_t * , uint32_t  , uint32_t  ))0, & qla81xx_fw_dump,
    & qla24xx_beacon_on, & qla24xx_beacon_off, & qla83xx_beacon_blink, & qla25xx_read_optrom_data,
    & qla24xx_write_optrom_data, & qla24xx_get_flash_version, & qla24xx_dif_start_scsi,
    & qla2x00_abort_isp, & qla2x00_iospace_config, & qla2x00_initialize_adapter};
#line 1897 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static struct isp_operations qla82xx_isp_ops  = 
#line 1897
     {& qla82xx_pci_config, & qla82xx_reset_chip, & qla24xx_chip_diag, & qla82xx_config_rings,
    & qla24xx_reset_adapter, & qla81xx_nvram_config, & qla24xx_update_fw_options,
    & qla82xx_load_risc, & qla24xx_pci_info_str, & qla24xx_fw_version_str, & qla82xx_intr_handler,
    & qla82xx_enable_intrs, & qla82xx_disable_intrs, & qla24xx_abort_command, & qla24xx_abort_target,
    & qla24xx_lun_reset, & qla24xx_login_fabric, & qla24xx_fabric_logout, (uint16_t (*)(uint16_t  ))0,
    (void (*)(srb_t * , cmd_entry_t * , uint16_t  ))0, & qla24xx_prep_ms_iocb, & qla24xx_prep_ms_fdmi_iocb,
    & qla24xx_read_nvram_data, & qla24xx_write_nvram_data, & qla82xx_fw_dump, & qla82xx_beacon_on,
    & qla82xx_beacon_off, (void (*)(struct scsi_qla_host * ))0, & qla82xx_read_optrom_data,
    & qla82xx_write_optrom_data, & qla82xx_get_flash_version, & qla82xx_start_scsi,
    & qla82xx_abort_isp, & qla82xx_iospace_config, & qla2x00_initialize_adapter};
#line 1935 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static struct isp_operations qla8044_isp_ops  = 
#line 1935
     {& qla82xx_pci_config, & qla82xx_reset_chip, & qla24xx_chip_diag, & qla82xx_config_rings,
    & qla24xx_reset_adapter, & qla81xx_nvram_config, & qla24xx_update_fw_options,
    & qla82xx_load_risc, & qla24xx_pci_info_str, & qla24xx_fw_version_str, & qla8044_intr_handler,
    & qla82xx_enable_intrs, & qla82xx_disable_intrs, & qla24xx_abort_command, & qla24xx_abort_target,
    & qla24xx_lun_reset, & qla24xx_login_fabric, & qla24xx_fabric_logout, (uint16_t (*)(uint16_t  ))0,
    (void (*)(srb_t * , cmd_entry_t * , uint16_t  ))0, & qla24xx_prep_ms_iocb, & qla24xx_prep_ms_fdmi_iocb,
    (uint8_t *(*)(struct scsi_qla_host * , uint8_t * , uint32_t  , uint32_t  ))0,
    (int (*)(struct scsi_qla_host * , uint8_t * , uint32_t  , uint32_t  ))0, & qla8044_fw_dump,
    & qla82xx_beacon_on, & qla82xx_beacon_off, (void (*)(struct scsi_qla_host * ))0,
    & qla8044_read_optrom_data, & qla8044_write_optrom_data, & qla82xx_get_flash_version,
    & qla82xx_start_scsi, & qla8044_abort_isp, & qla82xx_iospace_config, & qla2x00_initialize_adapter};
#line 1973 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static struct isp_operations qla83xx_isp_ops  = 
#line 1973
     {& qla25xx_pci_config, & qla24xx_reset_chip, & qla24xx_chip_diag, & qla24xx_config_rings,
    & qla24xx_reset_adapter, & qla81xx_nvram_config, & qla81xx_update_fw_options,
    & qla81xx_load_risc, & qla24xx_pci_info_str, & qla24xx_fw_version_str, & qla24xx_intr_handler,
    & qla24xx_enable_intrs, & qla24xx_disable_intrs, & qla24xx_abort_command, & qla24xx_abort_target,
    & qla24xx_lun_reset, & qla24xx_login_fabric, & qla24xx_fabric_logout, (uint16_t (*)(uint16_t  ))0,
    (void (*)(srb_t * , cmd_entry_t * , uint16_t  ))0, & qla24xx_prep_ms_iocb, & qla24xx_prep_ms_fdmi_iocb,
    (uint8_t *(*)(struct scsi_qla_host * , uint8_t * , uint32_t  , uint32_t  ))0,
    (int (*)(struct scsi_qla_host * , uint8_t * , uint32_t  , uint32_t  ))0, & qla83xx_fw_dump,
    & qla24xx_beacon_on, & qla24xx_beacon_off, & qla83xx_beacon_blink, & qla25xx_read_optrom_data,
    & qla24xx_write_optrom_data, & qla24xx_get_flash_version, & qla24xx_dif_start_scsi,
    & qla2x00_abort_isp, & qla83xx_iospace_config, & qla2x00_initialize_adapter};
#line 2011 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static struct isp_operations qlafx00_isp_ops  = 
#line 2011
     {& qlafx00_pci_config, & qlafx00_soft_reset, & qlafx00_chip_diag, & qlafx00_config_rings,
    & qlafx00_soft_reset, (int (*)(struct scsi_qla_host * ))0, (void (*)(struct scsi_qla_host * ))0,
    (int (*)(struct scsi_qla_host * , uint32_t * ))0, & qlafx00_pci_info_str, & qlafx00_fw_version_str,
    & qlafx00_intr_handler, & qlafx00_enable_intrs, & qlafx00_disable_intrs, & qla24xx_async_abort_command,
    & qlafx00_abort_target, & qlafx00_lun_reset, (int (*)(struct scsi_qla_host * ,
                                                          uint16_t  , uint8_t  , uint8_t  ,
                                                          uint8_t  , uint16_t * ,
                                                          uint8_t  ))0, (int (*)(struct scsi_qla_host * ,
                                                                                 uint16_t  ,
                                                                                 uint8_t  ,
                                                                                 uint8_t  ,
                                                                                 uint8_t  ))0,
    (uint16_t (*)(uint16_t  ))0, (void (*)(srb_t * , cmd_entry_t * , uint16_t  ))0,
    & qla24xx_prep_ms_iocb, & qla24xx_prep_ms_fdmi_iocb, & qla24xx_read_nvram_data,
    & qla24xx_write_nvram_data, (void (*)(struct scsi_qla_host * , int  ))0, & qla24xx_beacon_on,
    & qla24xx_beacon_off, (void (*)(struct scsi_qla_host * ))0, & qla24xx_read_optrom_data,
    & qla24xx_write_optrom_data, & qla24xx_get_flash_version, & qlafx00_start_scsi,
    & qlafx00_abort_isp, & qlafx00_iospace_config, & qlafx00_initialize_adapter};
#line 2049 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static struct isp_operations qla27xx_isp_ops  = 
#line 2049
     {& qla25xx_pci_config, & qla24xx_reset_chip, & qla24xx_chip_diag, & qla24xx_config_rings,
    & qla24xx_reset_adapter, & qla81xx_nvram_config, & qla81xx_update_fw_options,
    & qla81xx_load_risc, & qla24xx_pci_info_str, & qla24xx_fw_version_str, & qla24xx_intr_handler,
    & qla24xx_enable_intrs, & qla24xx_disable_intrs, & qla24xx_abort_command, & qla24xx_abort_target,
    & qla24xx_lun_reset, & qla24xx_login_fabric, & qla24xx_fabric_logout, (uint16_t (*)(uint16_t  ))0,
    (void (*)(srb_t * , cmd_entry_t * , uint16_t  ))0, & qla24xx_prep_ms_iocb, & qla24xx_prep_ms_fdmi_iocb,
    (uint8_t *(*)(struct scsi_qla_host * , uint8_t * , uint32_t  , uint32_t  ))0,
    (int (*)(struct scsi_qla_host * , uint8_t * , uint32_t  , uint32_t  ))0, & qla27xx_fwdump,
    & qla24xx_beacon_on, & qla24xx_beacon_off, & qla83xx_beacon_blink, & qla25xx_read_optrom_data,
    & qla24xx_write_optrom_data, & qla24xx_get_flash_version, & qla24xx_dif_start_scsi,
    & qla2x00_abort_isp, & qla83xx_iospace_config, & qla2x00_initialize_adapter};
#line 2088 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
__inline static void qla2x00_set_isp_flags(struct qla_hw_data *ha ) 
{ 


  {
#line 2090
  ha->device_type = 2147483648U;
#line 2091
  switch ((int )(ha->pdev)->device) {
  case 8448: 
#line 2093
  ha->device_type = ha->device_type | 1U;
#line 2094
  ha->device_type = ha->device_type & 2147483647U;
#line 2095
  ha->fw_srisc_address = 4096U;
#line 2096
  goto ldv_67209;
  case 8704: 
#line 2098
  ha->device_type = ha->device_type | 2U;
#line 2099
  ha->device_type = ha->device_type & 2147483647U;
#line 2100
  ha->fw_srisc_address = 4096U;
#line 2101
  goto ldv_67209;
  case 8960: 
#line 2103
  ha->device_type = ha->device_type | 4U;
#line 2104
  ha->device_type = ha->device_type | 268435456U;
#line 2105
  ha->fw_srisc_address = 2048U;
#line 2106
  goto ldv_67209;
  case 8978: 
#line 2108
  ha->device_type = ha->device_type | 8U;
#line 2109
  ha->device_type = ha->device_type | 268435456U;
#line 2110
  ha->fw_srisc_address = 2048U;
#line 2111
  goto ldv_67209;
  case 8994: 
#line 2113
  ha->device_type = ha->device_type | 16U;
#line 2114
  ha->device_type = ha->device_type | 268435456U;
#line 2115
  if ((unsigned int )(ha->pdev)->subsystem_vendor == 4136U && (unsigned int )(ha->pdev)->subsystem_device == 368U) {
#line 2117
    ha->device_type = ha->device_type | 536870912U;
  } else {

  }
#line 2118
  ha->fw_srisc_address = 2048U;
#line 2119
  goto ldv_67209;
  case 25362: 
#line 2121
  ha->device_type = ha->device_type | 32U;
#line 2122
  ha->fw_srisc_address = 2048U;
#line 2123
  goto ldv_67209;
  case 25378: 
#line 2125
  ha->device_type = ha->device_type | 64U;
#line 2126
  ha->fw_srisc_address = 2048U;
#line 2127
  goto ldv_67209;
  case 9250: 
#line 2129
  ha->device_type = ha->device_type | 128U;
#line 2130
  ha->device_type = ha->device_type | 268435456U;
#line 2131
  ha->device_type = ha->device_type | 134217728U;
#line 2132
  ha->device_type = ha->device_type | 67108864U;
#line 2133
  ha->fw_srisc_address = 1048576U;
#line 2134
  goto ldv_67209;
  case 9266: 
#line 2136
  ha->device_type = ha->device_type | 256U;
#line 2137
  ha->device_type = ha->device_type | 268435456U;
#line 2138
  ha->device_type = ha->device_type | 134217728U;
#line 2139
  ha->device_type = ha->device_type | 67108864U;
#line 2140
  ha->fw_srisc_address = 1048576U;
#line 2141
  goto ldv_67209;
  case 33842: 
#line 2143
  ha->device_type = ha->device_type | 4096U;
#line 2144
  ha->device_type = ha->device_type | 268435456U;
#line 2145
  ha->device_type = ha->device_type | 134217728U;
#line 2146
  ha->device_type = ha->device_type | 67108864U;
#line 2147
  ha->fw_srisc_address = 1048576U;
#line 2148
  goto ldv_67209;
  case 21538: 
#line 2150
  ha->device_type = ha->device_type | 512U;
#line 2151
  ha->device_type = ha->device_type | 134217728U;
#line 2152
  ha->fw_srisc_address = 1048576U;
#line 2153
  goto ldv_67209;
  case 21554: 
#line 2155
  ha->device_type = ha->device_type | 1024U;
#line 2156
  ha->device_type = ha->device_type | 134217728U;
#line 2157
  ha->fw_srisc_address = 1048576U;
#line 2158
  goto ldv_67209;
  case 9522: 
#line 2160
  ha->device_type = ha->device_type | 2048U;
#line 2161
  ha->device_type = ha->device_type | 268435456U;
#line 2162
  ha->device_type = ha->device_type | 134217728U;
#line 2163
  ha->device_type = ha->device_type | 67108864U;
#line 2164
  ha->fw_srisc_address = 1048576U;
#line 2165
  goto ldv_67209;
  case 32769: 
#line 2167
  ha->device_type = ha->device_type | 8192U;
#line 2168
  ha->device_type = ha->device_type | 268435456U;
#line 2169
  ha->device_type = ha->device_type | 134217728U;
#line 2170
  ha->device_type = ha->device_type | 67108864U;
#line 2171
  ha->fw_srisc_address = 1048576U;
#line 2172
  goto ldv_67209;
  case 32801: 
#line 2174
  ha->device_type = ha->device_type | 16384U;
#line 2175
  ha->device_type = ha->device_type | 268435456U;
#line 2176
  ha->device_type = ha->device_type | 134217728U;
#line 2177
  ha->fw_srisc_address = 1048576U;
#line 2179
  qla82xx_init_flags(ha);
#line 2180
  goto ldv_67209;
  case 32836: 
#line 2182
  ha->device_type = ha->device_type | 262144U;
#line 2183
  ha->device_type = ha->device_type | 268435456U;
#line 2184
  ha->device_type = ha->device_type | 134217728U;
#line 2185
  ha->fw_srisc_address = 1048576U;
#line 2187
  qla82xx_init_flags(ha);
#line 2188
  goto ldv_67209;
  case 8241: 
#line 2190
  ha->device_type = ha->device_type | 32768U;
#line 2191
  ha->device_type = ha->device_type | 268435456U;
#line 2192
  ha->device_type = ha->device_type | 134217728U;
#line 2193
  ha->device_type = ha->device_type | 67108864U;
#line 2194
  ha->device_type = ha->device_type | 33554432U;
#line 2195
  ha->fw_srisc_address = 1048576U;
#line 2196
  goto ldv_67209;
  case 32817: 
#line 2198
  ha->device_type = ha->device_type | 65536U;
#line 2199
  ha->device_type = ha->device_type | 268435456U;
#line 2200
  ha->device_type = ha->device_type | 134217728U;
#line 2201
  ha->device_type = ha->device_type | 67108864U;
#line 2202
  ha->device_type = ha->device_type | 33554432U;
#line 2203
  ha->fw_srisc_address = 1048576U;
#line 2204
  goto ldv_67209;
  case 61441: 
#line 2206
  ha->device_type = ha->device_type | 131072U;
#line 2207
  goto ldv_67209;
  case 8305: 
#line 2209
  ha->device_type = ha->device_type | 524288U;
#line 2210
  ha->device_type = ha->device_type | 268435456U;
#line 2211
  ha->device_type = ha->device_type | 134217728U;
#line 2212
  ha->device_type = ha->device_type | 67108864U;
#line 2213
  ha->fw_srisc_address = 1048576U;
#line 2214
  goto ldv_67209;
  case 8817: 
#line 2216
  ha->device_type = ha->device_type | 1048576U;
#line 2217
  ha->device_type = ha->device_type | 268435456U;
#line 2218
  ha->device_type = ha->device_type | 134217728U;
#line 2219
  ha->device_type = ha->device_type | 67108864U;
#line 2220
  ha->fw_srisc_address = 1048576U;
#line 2221
  goto ldv_67209;
  }
  ldv_67209: ;
#line 2224
  if ((ha->device_type & 16384U) != 0U) {
#line 2225
    ha->port_no = (unsigned int )((uint8_t )ha->portnum) & 1U;
  } else {
#line 2228
    pci_read_config_byte((struct pci_dev  const  *)ha->pdev, 61, & ha->port_no);
#line 2229
    if ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) {
#line 2230
      ha->port_no = (uint8_t )((int )ha->port_no - 1);
    } else {
#line 2232
      ha->port_no = ((int )ha->port_no & 1) == 0;
    }
  }
#line 2235
  ql_dbg_pci(1073741824U, ha->pdev, 11, "device_type=0x%x port=%d fw_srisc_address=0x%x.\n",
             ha->device_type, (int )ha->port_no, ha->fw_srisc_address);
#line 2238
  return;
}
}
#line 2241 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla2xxx_scan_start(struct Scsi_Host *shost ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 2243
  tmp = shost_priv(shost);
#line 2243
  vha = (scsi_qla_host_t *)tmp;
#line 2245
  if (*((unsigned long *)vha->hw + 2UL) != 0UL) {
#line 2246
    return;
  } else {

  }
#line 2248
  set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2249
  set_bit(6L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2250
  set_bit(7L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2251
  set_bit(16L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2252
  return;
}
}
#line 2255 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int qla2xxx_scan_finished(struct Scsi_Host *shost , unsigned long time ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2257
  tmp = shost_priv(shost);
#line 2257
  vha = (scsi_qla_host_t *)tmp;
#line 2259
  if ((unsigned long )vha->host == (unsigned long )((struct Scsi_Host *)0)) {
#line 2260
    return (1);
  } else {

  }
#line 2261
  if ((unsigned long )((int )(vha->hw)->loop_reset_delay * 250) < time) {
#line 2262
    return (1);
  } else {

  }
#line 2264
  tmp___0 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 2264
  return (tmp___0 == 5);
}
}
#line 2271 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int qla2x00_probe_one(struct pci_dev *pdev , struct pci_device_id  const  *id ) 
{ 
  int ret ;
  struct Scsi_Host *host ;
  scsi_qla_host_t *base_vha ;
  struct qla_hw_data *ha ;
  char pci_info[30U] ;
  char fw_str[30U] ;
  char wq_name[30U] ;
  struct scsi_host_template *sht ;
  int bars ;
  int mem_only ;
  uint16_t req_length ;
  uint16_t rsp_length ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  struct lock_class_key __key___3 ;
  struct lock_class_key __key___4 ;
  struct scsi_qla_host *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  bool tmp___7 ;
  struct lock_class_key __key___5 ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___6 ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp___8 ;
  struct lock_class_key __key___7 ;
  atomic_long_t __constr_expr_1 ;
  struct lock_class_key __key___8 ;
  char const   *__lock_name___0 ;
  struct workqueue_struct *tmp___9 ;
  struct lock_class_key __key___9 ;
  atomic_long_t __constr_expr_2 ;
  struct lock_class_key __key___10 ;
  atomic_long_t __constr_expr_3 ;
  struct lock_class_key __key___11 ;
  atomic_long_t __constr_expr_4 ;
  int prot ;
  int guard ;
  bool tmp___10 ;
  char *tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  uint8_t tmp___14 ;
  struct task_struct *t ;

  {
#line 2273
  ret = -19;
#line 2275
  base_vha = (scsi_qla_host_t *)0;
#line 2280
  mem_only = 0;
#line 2281
  req_length = 0U;
#line 2281
  rsp_length = 0U;
#line 2282
  req = (struct req_que *)0;
#line 2283
  rsp = (struct rsp_que *)0;
#line 2284
  bars = pci_select_bars(pdev, 768UL);
#line 2285
  sht = & qla2xxx_driver_template;
#line 2286
  if ((((((((((((((unsigned int )pdev->device == 9250U || (unsigned int )pdev->device == 9266U) || (unsigned int )pdev->device == 33842U) || (unsigned int )pdev->device == 21538U) || (unsigned int )pdev->device == 21554U) || (unsigned int )pdev->device == 9522U) || (unsigned int )pdev->device == 32769U) || (unsigned int )pdev->device == 32801U) || (unsigned int )pdev->device == 8241U) || (unsigned int )pdev->device == 32817U) || (unsigned int )pdev->device == 61441U) || (unsigned int )pdev->device == 32836U) || (unsigned int )pdev->device == 8305U) || (unsigned int )pdev->device == 8817U) {
#line 2300
    bars = pci_select_bars(pdev, 512UL);
#line 2301
    mem_only = 1;
#line 2302
    ql_dbg_pci(1073741824U, pdev, 7, "Mem only adapter.\n");
  } else {

  }
#line 2305
  ql_dbg_pci(1073741824U, pdev, 8, "Bars=%d.\n", bars);
#line 2308
  if (mem_only != 0) {
#line 2309
    tmp = pci_enable_device_mem(pdev);
#line 2309
    if (tmp != 0) {
#line 2310
      goto probe_out;
    } else {

    }
  } else {
#line 2312
    tmp___0 = pci_enable_device(pdev);
#line 2312
    if (tmp___0 != 0) {
#line 2313
      goto probe_out;
    } else {

    }
  }
#line 2317
  pci_enable_pcie_error_reporting(pdev);
#line 2319
  tmp___1 = kzalloc(12288UL, 208U);
#line 2319
  ha = (struct qla_hw_data *)tmp___1;
#line 2320
  if ((unsigned long )ha == (unsigned long )((struct qla_hw_data *)0)) {
#line 2321
    ql_log_pci(0U, pdev, 9, "Unable to allocate memory for ha.\n");
#line 2323
    goto probe_out;
  } else {

  }
#line 2325
  ql_dbg_pci(1073741824U, pdev, 10, "Memory allocated for ha=%p.\n", ha);
#line 2327
  ha->pdev = pdev;
#line 2328
  ha->tgt.enable_class_2 = (unsigned char )ql2xenableclass2;
#line 2329
  INIT_LIST_HEAD(& ha->tgt.q_full_list);
#line 2330
  spinlock_check(& ha->tgt.q_full_lock);
#line 2330
  __raw_spin_lock_init(& ha->tgt.q_full_lock.__annonCompField18.rlock, "&(&ha->tgt.q_full_lock)->rlock",
                       & __key);
#line 2333
  ha->bars = bars;
#line 2334
  ha->mem_only = mem_only;
#line 2335
  spinlock_check(& ha->hardware_lock);
#line 2335
  __raw_spin_lock_init(& ha->hardware_lock.__annonCompField18.rlock, "&(&ha->hardware_lock)->rlock",
                       & __key___0);
#line 2336
  spinlock_check(& ha->vport_slock);
#line 2336
  __raw_spin_lock_init(& ha->vport_slock.__annonCompField18.rlock, "&(&ha->vport_slock)->rlock",
                       & __key___1);
#line 2337
  __mutex_init(& ha->selflogin_lock, "&ha->selflogin_lock", & __key___2);
#line 2338
  __mutex_init(& ha->optrom_mutex, "&ha->optrom_mutex", & __key___3);
#line 2341
  qla2x00_set_isp_flags(ha);
#line 2344
  if ((((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || (ha->device_type & 2048U) != 0U) || (ha->device_type & 8192U) != 0U) || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 2346
    pdev->needs_freset = 1U;
  } else {

  }
#line 2348
  ha->prev_topology = 0U;
#line 2349
  ha->init_cb_size = 96;
#line 2350
  ha->link_data_rate = 65535U;
#line 2351
  ha->optrom_size = 131072U;
#line 2354
  if ((int )ha->device_type & 1) {
#line 2355
    ha->max_fibre_devices = 512U;
#line 2356
    ha->mbx_count = 8U;
#line 2357
    req_length = 128U;
#line 2358
    rsp_length = 64U;
#line 2359
    ha->max_loop_id = 254U;
#line 2360
    ha->gid_list_info_size = 4;
#line 2361
    ha->flash_conf_off = 4294967295U;
#line 2362
    ha->flash_data_off = 4294967295U;
#line 2363
    ha->nvram_conf_off = 4294967295U;
#line 2364
    ha->nvram_data_off = 4294967295U;
#line 2365
    ha->isp_ops = & qla2100_isp_ops;
  } else
#line 2366
  if ((ha->device_type & 2U) != 0U) {
#line 2367
    ha->max_fibre_devices = 512U;
#line 2368
    ha->mbx_count = 24U;
#line 2369
    req_length = 2048U;
#line 2370
    rsp_length = 64U;
#line 2371
    ha->max_loop_id = 254U;
#line 2372
    ha->gid_list_info_size = 4;
#line 2373
    ha->flash_conf_off = 4294967295U;
#line 2374
    ha->flash_data_off = 4294967295U;
#line 2375
    ha->nvram_conf_off = 4294967295U;
#line 2376
    ha->nvram_data_off = 4294967295U;
#line 2377
    ha->isp_ops = & qla2100_isp_ops;
  } else
#line 2378
  if (((((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 16U) != 0U) || (ha->device_type & 32U) != 0U) || (ha->device_type & 64U) != 0U) {
#line 2379
    ha->max_fibre_devices = 512U;
#line 2380
    ha->mbx_count = 32U;
#line 2381
    req_length = 2048U;
#line 2382
    rsp_length = 512U;
#line 2383
    ha->max_loop_id = 2047U;
#line 2384
    ha->gid_list_info_size = 6;
#line 2385
    if ((ha->device_type & 16U) != 0U || (ha->device_type & 64U) != 0U) {
#line 2386
      ha->optrom_size = 1048576U;
    } else {

    }
#line 2387
    ha->flash_conf_off = 4294967295U;
#line 2388
    ha->flash_data_off = 4294967295U;
#line 2389
    ha->nvram_conf_off = 4294967295U;
#line 2390
    ha->nvram_data_off = 4294967295U;
#line 2391
    ha->isp_ops = & qla2300_isp_ops;
  } else
#line 2392
  if ((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || ((ha->device_type & 512U) != 0U || (ha->device_type & 1024U) != 0U)) || (ha->device_type & 4096U) != 0U) {
#line 2393
    ha->max_fibre_devices = 2048U;
#line 2394
    ha->mbx_count = 32U;
#line 2395
    req_length = 2048U;
#line 2396
    rsp_length = 512U;
#line 2397
    ha->tgt.atio_q_length = 4096U;
#line 2398
    ha->max_loop_id = 2047U;
#line 2399
    ha->init_cb_size = 5252;
#line 2400
    ha->gid_list_info_size = 8;
#line 2401
    ha->optrom_size = 1048576U;
#line 2402
    ha->nvram_npiv_size = 128U;
#line 2403
    ha->isp_ops = & qla24xx_isp_ops;
#line 2404
    ha->flash_conf_off = 2147287040U;
#line 2405
    ha->flash_data_off = 2146435072U;
#line 2406
    ha->nvram_conf_off = 2147418112U;
#line 2407
    ha->nvram_data_off = 2147352576U;
  } else
#line 2408
  if ((ha->device_type & 2048U) != 0U) {
#line 2409
    ha->max_fibre_devices = 2048U;
#line 2410
    ha->mbx_count = 32U;
#line 2411
    req_length = 2048U;
#line 2412
    rsp_length = 512U;
#line 2413
    ha->tgt.atio_q_length = 4096U;
#line 2414
    ha->max_loop_id = 2047U;
#line 2415
    ha->init_cb_size = 5252;
#line 2416
    ha->gid_list_info_size = 8;
#line 2417
    ha->optrom_size = 2097152U;
#line 2418
    ha->nvram_npiv_size = 256U;
#line 2419
    ha->isp_ops = & qla25xx_isp_ops;
#line 2420
    ha->flash_conf_off = 2147287040U;
#line 2421
    ha->flash_data_off = 2146435072U;
#line 2422
    ha->nvram_conf_off = 2147418112U;
#line 2423
    ha->nvram_data_off = 2147352576U;
  } else
#line 2424
  if ((ha->device_type & 8192U) != 0U) {
#line 2425
    ha->max_fibre_devices = 2048U;
#line 2426
    ha->mbx_count = 32U;
#line 2427
    req_length = 2048U;
#line 2428
    rsp_length = 512U;
#line 2429
    ha->tgt.atio_q_length = 4096U;
#line 2430
    ha->max_loop_id = 2047U;
#line 2431
    ha->init_cb_size = 5252;
#line 2432
    ha->gid_list_info_size = 8;
#line 2433
    ha->optrom_size = 4194304U;
#line 2434
    ha->nvram_npiv_size = 256U;
#line 2435
    ha->isp_ops = & qla81xx_isp_ops;
#line 2436
    ha->flash_conf_off = 2147287040U;
#line 2437
    ha->flash_data_off = 2139095040U;
#line 2438
    ha->nvram_conf_off = 4294967295U;
#line 2439
    ha->nvram_data_off = 4294967295U;
  } else
#line 2440
  if ((ha->device_type & 16384U) != 0U) {
#line 2441
    ha->max_fibre_devices = 2048U;
#line 2442
    ha->mbx_count = 32U;
#line 2443
    req_length = 128U;
#line 2444
    rsp_length = 128U;
#line 2445
    ha->max_loop_id = 2047U;
#line 2446
    ha->init_cb_size = 5252;
#line 2447
    ha->gid_list_info_size = 8;
#line 2448
    ha->optrom_size = 8388608U;
#line 2449
    ha->nvram_npiv_size = 256U;
#line 2450
    ha->isp_ops = & qla82xx_isp_ops;
#line 2451
    ha->flash_conf_off = 2147287040U;
#line 2452
    ha->flash_data_off = 2146435072U;
#line 2453
    ha->nvram_conf_off = 2147418112U;
#line 2454
    ha->nvram_data_off = 2147352576U;
  } else
#line 2455
  if ((ha->device_type & 262144U) != 0U) {
#line 2456
    ha->max_fibre_devices = 2048U;
#line 2457
    ha->mbx_count = 32U;
#line 2458
    req_length = 128U;
#line 2459
    rsp_length = 128U;
#line 2460
    ha->max_loop_id = 2047U;
#line 2461
    ha->init_cb_size = 5252;
#line 2462
    ha->gid_list_info_size = 8;
#line 2463
    ha->optrom_size = 16777216U;
#line 2464
    ha->nvram_npiv_size = 256U;
#line 2465
    ha->isp_ops = & qla8044_isp_ops;
#line 2466
    ha->flash_conf_off = 2147287040U;
#line 2467
    ha->flash_data_off = 2146435072U;
#line 2468
    ha->nvram_conf_off = 2147418112U;
#line 2469
    ha->nvram_data_off = 2147352576U;
  } else
#line 2470
  if ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 2471
    ha->portnum = (unsigned int )((uint16_t )(ha->pdev)->devfn) & 7U;
#line 2472
    ha->max_fibre_devices = 2048U;
#line 2473
    ha->mbx_count = 32U;
#line 2474
    req_length = 8192U;
#line 2475
    rsp_length = 512U;
#line 2476
    ha->tgt.atio_q_length = 4096U;
#line 2477
    ha->max_loop_id = 2047U;
#line 2478
    ha->init_cb_size = 5252;
#line 2479
    ha->gid_list_info_size = 8;
#line 2480
    ha->optrom_size = 16777216U;
#line 2481
    ha->nvram_npiv_size = 256U;
#line 2482
    ha->isp_ops = & qla83xx_isp_ops;
#line 2483
    ha->flash_conf_off = 2147287040U;
#line 2484
    ha->flash_data_off = 2139095040U;
#line 2485
    ha->nvram_conf_off = 4294967295U;
#line 2486
    ha->nvram_data_off = 4294967295U;
  } else
#line 2487
  if ((ha->device_type & 131072U) != 0U) {
#line 2488
    ha->max_fibre_devices = 512U;
#line 2489
    ha->mbx_count = 16U;
#line 2490
    ha->aen_mbx_count = 8U;
#line 2491
    req_length = 512U;
#line 2492
    rsp_length = 256U;
#line 2493
    ha->isp_ops = & qlafx00_isp_ops;
#line 2494
    ha->port_down_retry_count = 30;
#line 2495
    ha->mr.fw_hbt_cnt = 6U;
#line 2496
    ha->mr.fw_reset_timer_tick = 120U;
#line 2497
    ha->mr.fw_critemp_timer_tick = 60U;
#line 2498
    ha->mr.fw_hbt_en = 1U;
#line 2499
    ha->mr.host_info_resend = 0;
#line 2500
    ha->mr.hinfo_resend_timer_tick = 60U;
  } else
#line 2501
  if ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) {
#line 2502
    ha->portnum = (unsigned int )((uint16_t )(ha->pdev)->devfn) & 7U;
#line 2503
    ha->max_fibre_devices = 2048U;
#line 2504
    ha->mbx_count = 32U;
#line 2505
    req_length = 2048U;
#line 2506
    rsp_length = 512U;
#line 2507
    ha->max_loop_id = 2047U;
#line 2508
    ha->init_cb_size = 5252;
#line 2509
    ha->gid_list_info_size = 8;
#line 2510
    ha->optrom_size = 16777216U;
#line 2511
    ha->nvram_npiv_size = 256U;
#line 2512
    ha->isp_ops = & qla27xx_isp_ops;
#line 2513
    ha->flash_conf_off = 2147287040U;
#line 2514
    ha->flash_data_off = 2139095040U;
#line 2515
    ha->nvram_conf_off = 4294967295U;
#line 2516
    ha->nvram_data_off = 4294967295U;
  } else {

  }
#line 2519
  ql_dbg_pci(1073741824U, pdev, 30, "mbx_count=%d, req_length=%d, rsp_length=%d, max_loop_id=%d, init_cb_size=%d, gid_list_info_size=%d, optrom_size=%d, nvram_npiv_size=%d, max_fibre_devices=%d.\n",
             (int )ha->mbx_count, (int )req_length, (int )rsp_length, (int )ha->max_loop_id,
             ha->init_cb_size, ha->gid_list_info_size, ha->optrom_size, (int )ha->nvram_npiv_size,
             (int )ha->max_fibre_devices);
#line 2527
  ql_dbg_pci(1073741824U, pdev, 31, "isp_ops=%p, flash_conf_off=%d, flash_data_off=%d, nvram_conf_off=%d, nvram_data_off=%d.\n",
             ha->isp_ops, ha->flash_conf_off, ha->flash_data_off, ha->nvram_conf_off,
             ha->nvram_data_off);
#line 2534
  ret = (*((ha->isp_ops)->iospace_config))(ha);
#line 2535
  if (ret != 0) {
#line 2536
    goto iospace_config_failed;
  } else {

  }
#line 2538
  ql_log_pci(2U, pdev, 29, "Found an ISP%04X irq %d iobase 0x%p.\n", (int )pdev->device,
             pdev->irq, ha->iobase);
#line 2541
  __mutex_init(& ha->vport_lock, "&ha->vport_lock", & __key___4);
#line 2542
  init_completion(& ha->mbx_cmd_comp);
#line 2543
  complete(& ha->mbx_cmd_comp);
#line 2544
  init_completion(& ha->mbx_intr_comp);
#line 2545
  init_completion(& ha->dcbx_comp);
#line 2546
  init_completion(& ha->lb_portup_comp);
#line 2548
  set_bit(0L, (unsigned long volatile   *)(& ha->vp_idx_map));
#line 2550
  qla2x00_config_dma_addressing(ha);
#line 2551
  ql_dbg_pci(1073741824U, pdev, 32, "64 Bit addressing is %s.\n", *((unsigned long *)ha + 2UL) != 0UL ? (char *)"enable" : (char *)"disable");
#line 2555
  ret = qla2x00_mem_alloc(ha, (int )req_length, (int )rsp_length, & req, & rsp);
#line 2556
  if (ret != 0) {
#line 2557
    ql_log_pci(0U, pdev, 49, "Failed to allocate memory for adapter, aborting.\n");
#line 2560
    goto probe_hw_failed;
  } else {

  }
#line 2563
  req->max_q_depth = 32;
#line 2564
  if (ql2xmaxqdepth != 0 && (unsigned int )ql2xmaxqdepth <= 65535U) {
#line 2565
    req->max_q_depth = ql2xmaxqdepth;
  } else {

  }
#line 2568
  tmp___2 = qla2x00_create_host(sht, ha);
#line 2568
  base_vha = tmp___2;
#line 2569
  if ((unsigned long )base_vha == (unsigned long )((scsi_qla_host_t *)0)) {
#line 2570
    ret = -12;
#line 2571
    qla2x00_mem_free(ha);
#line 2572
    qla2x00_free_req_que(ha, req);
#line 2573
    qla2x00_free_rsp_que(ha, rsp);
#line 2574
    goto probe_hw_failed;
  } else {

  }
#line 2577
  pci_set_drvdata(pdev, (void *)base_vha);
#line 2578
  set_bit(2L, (unsigned long volatile   *)(& base_vha->pci_flags));
#line 2580
  host = base_vha->host;
#line 2581
  base_vha->req = req;
#line 2582
  if (((((((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || (ha->device_type & 4096U) != 0U) || (ha->device_type & 2048U) != 0U) || (ha->device_type & 8192U) != 0U) || (ha->device_type & 16384U) != 0U) || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || (ha->device_type & 262144U) != 0U) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 2583
    base_vha->mgmt_svr_loop_id = (unsigned int )base_vha->vp_idx + 10U;
  } else {
#line 2585
    base_vha->mgmt_svr_loop_id = (unsigned int )base_vha->vp_idx + 254U;
  }
#line 2589
  ha->mr.fcport.vha = base_vha;
#line 2590
  ha->mr.fcport.port_type = 0;
#line 2591
  ha->mr.fcport.loop_id = 4096U;
#line 2592
  qla2x00_set_fcport_state(& ha->mr.fcport, 1);
#line 2593
  ha->mr.fcport.supported_classes = 0U;
#line 2594
  ha->mr.fcport.scan_state = 1U;
#line 2597
  if ((ha->device_type & 134217728U) == 0U) {
#line 2598
    if ((int )ha->device_type & 1) {
#line 2599
      host->sg_tablesize = 32U;
    } else {

    }
  } else
#line 2601
  if ((ha->device_type & 16384U) == 0U) {
#line 2602
    host->sg_tablesize = 1024U;
  } else {

  }
#line 2604
  host->max_id = (unsigned int )ha->max_fibre_devices;
#line 2605
  host->cmd_per_lun = 3;
#line 2606
  host->unique_id = host->host_no;
#line 2607
  if ((ha->device_type & 33554432U) != 0U && ql2xenabledif != 0) {
#line 2608
    host->max_cmd_len = 32U;
  } else {
#line 2610
    host->max_cmd_len = 16U;
  }
#line 2611
  host->max_channel = 0U;
#line 2613
  if (((ha->device_type & 131072U) == 0U && (ha->device_type & 134217728U) == 0U) && ql2xmaxlun > 65535ULL) {
#line 2615
    host->max_lun = 65535ULL;
  } else {
#line 2617
    host->max_lun = ql2xmaxlun;
  }
#line 2618
  host->transportt = qla2xxx_transport_template;
#line 2619
  sht->vendor_id = 72057594037932151ULL;
#line 2621
  ql_dbg(1073741824U, base_vha, 51, "max_id=%d this_id=%d cmd_per_len=%d unique_id=%d max_cmd_len=%d max_channel=%d max_lun=%llu transportt=%p, vendor_id=%llu.\n",
         host->max_id, host->this_id, (int )host->cmd_per_lun, host->unique_id, (int )host->max_cmd_len,
         host->max_channel, host->max_lun, host->transportt, sht->vendor_id);
  que_init: 
#line 2631
  tmp___3 = qla2x00_alloc_queues(ha, req, rsp);
#line 2631
  if (tmp___3 == 0) {
#line 2632
    ql_log(0U, base_vha, 61, "Failed to allocate memory for queue pointers...aborting.\n");
#line 2635
    goto probe_init_failed;
  } else {

  }
#line 2638
  qlt_probe_one_stage1(base_vha, ha);
#line 2641
  ret = qla2x00_request_irqs(ha, rsp);
#line 2642
  if (ret != 0) {
#line 2643
    goto probe_init_failed;
  } else {

  }
#line 2645
  pci_save_state(pdev);
#line 2648
  rsp->req = req;
#line 2649
  req->rsp = rsp;
#line 2651
  if ((ha->device_type & 131072U) != 0U) {
#line 2652
    *(ha->rsp_q_map) = rsp;
#line 2653
    *(ha->req_q_map) = req;
#line 2654
    set_bit(0L, (unsigned long volatile   *)(& ha->req_qid_map));
#line 2655
    set_bit(0L, (unsigned long volatile   *)(& ha->rsp_qid_map));
  } else {

  }
#line 2659
  req->req_q_in = & (ha->iobase)->isp24.req_q_in;
#line 2660
  req->req_q_out = & (ha->iobase)->isp24.req_q_out;
#line 2661
  rsp->rsp_q_in = & (ha->iobase)->isp24.rsp_q_in;
#line 2662
  rsp->rsp_q_out = & (ha->iobase)->isp24.rsp_q_out;
#line 2663
  if (((unsigned int )ha->mqenable != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 2664
    req->req_q_in = & (ha->mqiobase)->isp25mq.req_q_in;
#line 2665
    req->req_q_out = & (ha->mqiobase)->isp25mq.req_q_out;
#line 2666
    rsp->rsp_q_in = & (ha->mqiobase)->isp25mq.rsp_q_in;
#line 2667
    rsp->rsp_q_out = & (ha->mqiobase)->isp25mq.rsp_q_out;
  } else {

  }
#line 2670
  if ((ha->device_type & 131072U) != 0U) {
#line 2671
    req->req_q_in = & (ha->iobase)->ispfx00.req_q_in;
#line 2672
    req->req_q_out = & (ha->iobase)->ispfx00.req_q_out;
#line 2673
    rsp->rsp_q_in = & (ha->iobase)->ispfx00.rsp_q_in;
#line 2674
    rsp->rsp_q_out = & (ha->iobase)->ispfx00.rsp_q_out;
  } else {

  }
#line 2677
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 2678
    req->req_q_out = (uint32_t *)(& (ha->iobase)->isp82.req_q_out);
#line 2679
    rsp->rsp_q_in = (uint32_t *)(& (ha->iobase)->isp82.rsp_q_in);
#line 2680
    rsp->rsp_q_out = (uint32_t *)(& (ha->iobase)->isp82.rsp_q_out);
  } else {

  }
#line 2683
  ql_dbg(1048576U, base_vha, 49161, "rsp_q_map=%p req_q_map=%p rsp->req=%p req->rsp=%p.\n",
         ha->rsp_q_map, ha->req_q_map, rsp->req, req->rsp);
#line 2686
  ql_dbg(1048576U, base_vha, 49162, "req->req_q_in=%p req->req_q_out=%p rsp->rsp_q_in=%p rsp->rsp_q_out=%p.\n",
         req->req_q_in, req->req_q_out, rsp->rsp_q_in, rsp->rsp_q_out);
#line 2691
  ql_dbg(1073741824U, base_vha, 62, "rsp_q_map=%p req_q_map=%p rsp->req=%p req->rsp=%p.\n",
         ha->rsp_q_map, ha->req_q_map, rsp->req, req->rsp);
#line 2694
  ql_dbg(1073741824U, base_vha, 63, "req->req_q_in=%p req->req_q_out=%p rsp->rsp_q_in=%p rsp->rsp_q_out=%p.\n",
         req->req_q_in, req->req_q_out, rsp->rsp_q_in, rsp->rsp_q_out);
#line 2698
  tmp___4 = (*((ha->isp_ops)->initialize_adapter))(base_vha);
#line 2698
  if (tmp___4 != 0) {
#line 2699
    ql_log(0U, base_vha, 214, "Failed to initialize adapter - Adapter flags %x.\n",
           base_vha->device_flags);
#line 2703
    if ((ha->device_type & 16384U) != 0U) {
#line 2704
      qla82xx_idc_lock(ha);
#line 2705
      qla82xx_wr_32(ha, 136323392UL, 6U);
#line 2707
      qla82xx_idc_unlock(ha);
#line 2708
      ql_log(0U, base_vha, 215, "HW State: FAILED.\n");
    } else
#line 2710
    if ((ha->device_type & 262144U) != 0U) {
#line 2711
      qla8044_idc_lock(ha);
#line 2712
      qla8044_wr_direct(base_vha, 4U, 6U);
#line 2715
      qla8044_idc_unlock(ha);
#line 2716
      ql_log(0U, base_vha, 336, "HW State: FAILED.\n");
    } else {

    }
#line 2720
    ret = -19;
#line 2721
    goto probe_failed;
  } else {

  }
#line 2724
  if ((ha->device_type & 131072U) != 0U) {
#line 2725
    host->can_queue = 1024;
  } else {
#line 2727
    host->can_queue = (int )req->num_outstanding_cmds + -10;
  }
#line 2729
  ql_dbg(1073741824U, base_vha, 50, "can_queue=%d, req=%p, mgmt_svr_loop_id=%d, sg_tablesize=%d.\n",
         host->can_queue, base_vha->req, (int )base_vha->mgmt_svr_loop_id, (int )host->sg_tablesize);
#line 2734
  if ((unsigned int )ha->mqenable != 0U) {
#line 2735
    tmp___5 = qla25xx_setup_mode(base_vha);
#line 2735
    if (tmp___5 != 0) {
#line 2736
      ql_log(1U, base_vha, 236, "Failed to create queues, falling back to single queue mode.\n");
#line 2738
      goto que_init;
    } else {

    }
  } else {

  }
#line 2742
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 2743
    goto skip_dpc;
  } else {

  }
#line 2748
  ha->dpc_thread = kthread_create_on_node(& qla2x00_do_dpc, (void *)ha, -1, "%s_dpc",
                                          (uint8_t *)(& base_vha->host_str));
#line 2750
  tmp___7 = IS_ERR((void const   *)ha->dpc_thread);
#line 2750
  if ((int )tmp___7) {
#line 2751
    ql_log(0U, base_vha, 237, "Failed to start DPC thread.\n");
#line 2753
    tmp___6 = PTR_ERR((void const   *)ha->dpc_thread);
#line 2753
    ret = (int )tmp___6;
#line 2754
    goto probe_failed;
  } else {

  }
#line 2756
  ql_dbg(1073741824U, base_vha, 238, "DPC thread started successfully.\n");
#line 2765
  qla2xxx_wake_dpc(base_vha);
#line 2767
  __init_work(& ha->board_disable, 0);
#line 2767
  __constr_expr_0.counter = 137438953408L;
#line 2767
  ha->board_disable.data = __constr_expr_0;
#line 2767
  lockdep_init_map(& ha->board_disable.lockdep_map, "(&ha->board_disable)", & __key___5,
                   0);
#line 2767
  INIT_LIST_HEAD(& ha->board_disable.entry);
#line 2767
  ha->board_disable.func = & qla2x00_disable_board_on_pci_error;
#line 2769
  if ((ha->device_type & 65536U) != 0U || ((ha->device_type & 32768U) != 0U && (int )ha->fw_attributes_ext[0] & 1)) {
#line 2770
    sprintf((char *)(& wq_name), "qla2xxx_%lu_dpc_lp_wq", base_vha->host_no);
#line 2771
    __lock_name = "\"%s\"wq_name";
#line 2771
    tmp___8 = __alloc_workqueue_key("%s", 131082U, 1, & __key___6, __lock_name, (char *)(& wq_name));
#line 2771
    ha->dpc_lp_wq = tmp___8;
#line 2772
    __init_work(& ha->idc_aen, 0);
#line 2772
    __constr_expr_1.counter = 137438953408L;
#line 2772
    ha->idc_aen.data = __constr_expr_1;
#line 2772
    lockdep_init_map(& ha->idc_aen.lockdep_map, "(&ha->idc_aen)", & __key___7, 0);
#line 2772
    INIT_LIST_HEAD(& ha->idc_aen.entry);
#line 2772
    ha->idc_aen.func = & qla83xx_service_idc_aen;
#line 2774
    sprintf((char *)(& wq_name), "qla2xxx_%lu_dpc_hp_wq", base_vha->host_no);
#line 2775
    __lock_name___0 = "\"%s\"wq_name";
#line 2775
    tmp___9 = __alloc_workqueue_key("%s", 131082U, 1, & __key___8, __lock_name___0,
                                    (char *)(& wq_name));
#line 2775
    ha->dpc_hp_wq = tmp___9;
#line 2776
    __init_work(& ha->nic_core_reset, 0);
#line 2776
    __constr_expr_2.counter = 137438953408L;
#line 2776
    ha->nic_core_reset.data = __constr_expr_2;
#line 2776
    lockdep_init_map(& ha->nic_core_reset.lockdep_map, "(&ha->nic_core_reset)", & __key___9,
                     0);
#line 2776
    INIT_LIST_HEAD(& ha->nic_core_reset.entry);
#line 2776
    ha->nic_core_reset.func = & qla83xx_nic_core_reset_work;
#line 2777
    __init_work(& ha->idc_state_handler, 0);
#line 2777
    __constr_expr_3.counter = 137438953408L;
#line 2777
    ha->idc_state_handler.data = __constr_expr_3;
#line 2777
    lockdep_init_map(& ha->idc_state_handler.lockdep_map, "(&ha->idc_state_handler)",
                     & __key___10, 0);
#line 2777
    INIT_LIST_HEAD(& ha->idc_state_handler.entry);
#line 2777
    ha->idc_state_handler.func = & qla83xx_idc_state_handler_work;
#line 2779
    __init_work(& ha->nic_core_unrecoverable, 0);
#line 2779
    __constr_expr_4.counter = 137438953408L;
#line 2779
    ha->nic_core_unrecoverable.data = __constr_expr_4;
#line 2779
    lockdep_init_map(& ha->nic_core_unrecoverable.lockdep_map, "(&ha->nic_core_unrecoverable)",
                     & __key___11, 0);
#line 2779
    INIT_LIST_HEAD(& ha->nic_core_unrecoverable.entry);
#line 2779
    ha->nic_core_unrecoverable.func = & qla83xx_nic_core_unrecoverable_work;
  } else {

  }
  skip_dpc: 
#line 2784
  list_add_tail(& base_vha->list, & ha->vp_list);
#line 2785
  (base_vha->host)->irq = (ha->pdev)->irq;
#line 2788
  qla2x00_start_timer(base_vha, (void *)(& qla2x00_timer), 1UL);
#line 2789
  ql_dbg(1073741824U, base_vha, 239, "Started qla2x00_timer with interval=%d.\n",
         1);
#line 2792
  ql_dbg(1073741824U, base_vha, 240, "Detected hba at address=%p.\n", ha);
#line 2796
  if ((ha->device_type & 33554432U) != 0U && ql2xenabledif != 0) {
#line 2797
    if (((int )ha->fw_attributes & 16) != 0) {
#line 2798
      prot = 0;
#line 2799
      base_vha->flags.difdix_supported = 1U;
#line 2800
      ql_dbg(1073741824U, base_vha, 241, "Registering for DIF/DIX type 1 and 3 protection.\n");
#line 2802
      if (ql2xenabledif == 1) {
#line 2803
        prot = 8;
      } else {

      }
#line 2804
      scsi_host_set_prot(host, (unsigned int )(prot | 119));
#line 2812
      guard = 1;
#line 2814
      if (((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) && ql2xenabledif > 1) {
#line 2816
        guard = guard | 2;
      } else {

      }
#line 2818
      scsi_host_set_guard(host, (int )((unsigned char )guard));
    } else {
#line 2820
      base_vha->flags.difdix_supported = 0U;
    }
  } else {

  }
#line 2823
  (*((ha->isp_ops)->enable_intrs))(ha);
#line 2825
  if ((ha->device_type & 131072U) != 0U) {
#line 2826
    ret = qlafx00_fx_disc(base_vha, & (base_vha->hw)->mr.fcport, 1);
#line 2828
    host->sg_tablesize = (int )ha->mr.extended_io_enabled ? 1024U : 128U;
  } else {

  }
#line 2832
  ret = scsi_add_host(host, & pdev->dev);
#line 2833
  if (ret != 0) {
#line 2834
    goto probe_failed;
  } else {

  }
#line 2836
  base_vha->flags.init_done = 1U;
#line 2837
  base_vha->flags.online = 1U;
#line 2838
  ha->prev_minidump_failed = 0;
#line 2840
  ql_dbg(1073741824U, base_vha, 242, "Init done and hba is online.\n");
#line 2843
  tmp___10 = qla_ini_mode_enabled(base_vha);
#line 2843
  if ((int )tmp___10) {
#line 2844
    scsi_scan_host(host);
  } else {
#line 2846
    ql_dbg(1073741824U, base_vha, 290, "skipping scsi_scan_host() for non-initiator port\n");
  }
#line 2849
  qla2x00_alloc_sysfs_attr(base_vha);
#line 2851
  if ((ha->device_type & 131072U) != 0U) {
#line 2852
    ret = qlafx00_fx_disc(base_vha, & (base_vha->hw)->mr.fcport, 2);
#line 2856
    ret = qlafx00_fx_disc(base_vha, & (base_vha->hw)->mr.fcport, 153);
  } else {

  }
#line 2860
  qla2x00_init_host_attr(base_vha);
#line 2862
  qla2x00_dfs_setup(base_vha);
#line 2864
  ql_log(2U, base_vha, 251, "QLogic %s - %s.\n", (uint8_t *)(& ha->model_number),
         (char *)(& ha->model_desc));
#line 2866
  tmp___11 = (*((ha->isp_ops)->fw_version_str))(base_vha, (char *)(& fw_str), 30UL);
#line 2866
  tmp___12 = pci_name((struct pci_dev  const  *)pdev);
#line 2866
  tmp___13 = (*((ha->isp_ops)->pci_info_str))(base_vha, (char *)(& pci_info));
#line 2866
  ql_log(2U, base_vha, 252, "ISP%04X: %s @ %s hdma%c host#=%ld fw=%s.\n", (int )pdev->device,
         tmp___13, tmp___12, *((unsigned long *)ha + 2UL) != 0UL ? 43 : 45, base_vha->host_no,
         tmp___11);
#line 2873
  qlt_add_target(ha, base_vha);
#line 2875
  clear_bit(2L, (unsigned long volatile   *)(& base_vha->pci_flags));
#line 2876
  return (0);
  probe_init_failed: 
#line 2879
  qla2x00_free_req_que(ha, req);
#line 2880
  *(ha->req_q_map) = (struct req_que *)0;
#line 2881
  clear_bit(0L, (unsigned long volatile   *)(& ha->req_qid_map));
#line 2882
  qla2x00_free_rsp_que(ha, rsp);
#line 2883
  *(ha->rsp_q_map) = (struct rsp_que *)0;
#line 2884
  clear_bit(0L, (unsigned long volatile   *)(& ha->rsp_qid_map));
#line 2885
  tmp___14 = 0U;
#line 2885
  ha->max_rsp_queues = tmp___14;
#line 2885
  ha->max_req_queues = tmp___14;
  probe_failed: ;
#line 2888
  if (base_vha->timer_active != 0U) {
#line 2889
    qla2x00_stop_timer(base_vha);
  } else {

  }
#line 2890
  base_vha->flags.online = 0U;
#line 2891
  if ((unsigned long )ha->dpc_thread != (unsigned long )((struct task_struct *)0)) {
#line 2892
    t = ha->dpc_thread;
#line 2894
    ha->dpc_thread = (struct task_struct *)0;
#line 2895
    kthread_stop(t);
  } else {

  }
#line 2898
  qla2x00_free_device(base_vha);
#line 2900
  scsi_host_put(base_vha->host);
  probe_hw_failed: 
#line 2903
  qla2x00_clear_drv_active(ha);
  iospace_config_failed: ;
#line 2906
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 2907
    if (ha->nx_pcibase == 0UL) {
#line 2908
      iounmap((void volatile   *)ha->nx_pcibase);
    } else {

    }
#line 2909
    if (ql2xdbwr == 0) {
#line 2910
      iounmap((void volatile   *)ha->nxdb_wr_ptr);
    } else {

    }
  } else {
#line 2912
    if ((unsigned long )ha->iobase != (unsigned long )((device_reg_t *)0)) {
#line 2913
      iounmap((void volatile   *)ha->iobase);
    } else {

    }
#line 2914
    if ((unsigned long )ha->cregbase != (unsigned long )((void *)0)) {
#line 2915
      iounmap((void volatile   *)ha->cregbase);
    } else {

    }
  }
#line 2917
  pci_release_selected_regions(ha->pdev, ha->bars);
#line 2918
  kfree((void const   *)ha);
#line 2919
  ha = (struct qla_hw_data *)0;
  probe_out: 
#line 2922
  pci_disable_device(pdev);
#line 2923
  return (ret);
}
}
#line 2927 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla2x00_shutdown(struct pci_dev *pdev ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  int tmp ;
  void *tmp___0 ;

  {
#line 2932
  tmp = atomic_read((atomic_t const   *)(& pdev->enable_cnt));
#line 2932
  if (tmp == 0) {
#line 2933
    return;
  } else {

  }
#line 2935
  tmp___0 = pci_get_drvdata(pdev);
#line 2935
  vha = (scsi_qla_host_t *)tmp___0;
#line 2936
  ha = vha->hw;
#line 2939
  if ((ha->device_type & 131072U) != 0U) {
#line 2940
    qlafx00_driver_shutdown(vha, 20);
  } else {

  }
#line 2943
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 2944
    qla2x00_disable_fce_trace(vha, (uint64_t *)0ULL, (uint64_t *)0ULL);
#line 2945
    ha->flags.fce_enabled = 0U;
  } else {

  }
#line 2949
  if ((unsigned long )ha->eft != (unsigned long )((void *)0)) {
#line 2950
    qla2x00_disable_eft_trace(vha);
  } else {

  }
#line 2953
  qla2x00_try_to_stop_firmware(vha);
#line 2956
  vha->flags.online = 0U;
#line 2959
  if ((unsigned int )ha->interrupts_on != 0U) {
#line 2960
    vha->flags.init_done = 0U;
#line 2961
    (*((ha->isp_ops)->disable_intrs))(ha);
  } else {

  }
#line 2964
  qla2x00_free_irqs(vha);
#line 2966
  qla2x00_free_fw_dump(ha);
#line 2968
  pci_disable_pcie_error_reporting(pdev);
#line 2969
  pci_disable_device(pdev);
#line 2970
  return;
}
}
#line 2974 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla2x00_delete_all_vps(struct qla_hw_data *ha , scsi_qla_host_t *base_vha ) 
{ 
  struct Scsi_Host *scsi_host ;
  scsi_qla_host_t *vha ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  long tmp___0 ;
  struct list_head  const  *__mptr ;

  {
#line 2980
  mutex_lock_nested(& ha->vport_lock, 0U);
#line 2981
  goto ldv_67308;
  ldv_67307: 
#line 2982
  tmp = spinlock_check(& ha->vport_slock);
#line 2982
  flags = _raw_spin_lock_irqsave(tmp);
#line 2984
  tmp___0 = ldv__builtin_expect((unsigned long )base_vha->list.next == (unsigned long )(& ha->vp_list),
                             0L);
#line 2984
  if (tmp___0 != 0L) {
#line 2984
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"),
                         "i" (2984), "i" (12UL));
    ldv_67304: ;
#line 2984
    goto ldv_67304;
  } else {

  }
#line 2986
  __mptr = (struct list_head  const  *)base_vha->list.next;
#line 2986
  vha = (scsi_qla_host_t *)__mptr;
#line 2987
  scsi_host = scsi_host_get(vha->host);
#line 2989
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 2990
  mutex_unlock(& ha->vport_lock);
#line 2992
  fc_vport_terminate(vha->fc_vport);
#line 2993
  scsi_host_put(vha->host);
#line 2995
  mutex_lock_nested(& ha->vport_lock, 0U);
  ldv_67308: ;
#line 2981
  if (ha->cur_vport_count != 0) {
#line 2983
    goto ldv_67307;
  } else {

  }
#line 2997
  mutex_unlock(& ha->vport_lock);
#line 2998
  return;
}
}
#line 3002 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla2x00_destroy_deferred_work(struct qla_hw_data *ha ) 
{ 
  struct task_struct *t ;

  {
#line 3005
  if ((unsigned long )ha->wq != (unsigned long )((struct workqueue_struct *)0)) {
#line 3006
    ldv_flush_workqueue_15(ha->wq);
#line 3007
    ldv_destroy_workqueue_16(ha->wq);
#line 3008
    ha->wq = (struct workqueue_struct *)0;
  } else {

  }
#line 3012
  if ((unsigned long )ha->dpc_lp_wq != (unsigned long )((struct workqueue_struct *)0)) {
#line 3013
    ldv_cancel_work_sync_17(& ha->idc_aen);
#line 3014
    ldv_destroy_workqueue_18(ha->dpc_lp_wq);
#line 3015
    ha->dpc_lp_wq = (struct workqueue_struct *)0;
  } else {

  }
#line 3018
  if ((unsigned long )ha->dpc_hp_wq != (unsigned long )((struct workqueue_struct *)0)) {
#line 3019
    ldv_cancel_work_sync_19(& ha->nic_core_reset);
#line 3020
    ldv_cancel_work_sync_20(& ha->idc_state_handler);
#line 3021
    ldv_cancel_work_sync_21(& ha->nic_core_unrecoverable);
#line 3022
    ldv_destroy_workqueue_22(ha->dpc_hp_wq);
#line 3023
    ha->dpc_hp_wq = (struct workqueue_struct *)0;
  } else {

  }
#line 3027
  if ((unsigned long )ha->dpc_thread != (unsigned long )((struct task_struct *)0)) {
#line 3028
    t = ha->dpc_thread;
#line 3034
    ha->dpc_thread = (struct task_struct *)0;
#line 3035
    kthread_stop(t);
  } else {

  }
#line 3037
  return;
}
}
#line 3040 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla2x00_unmap_iobases(struct qla_hw_data *ha ) 
{ 


  {
#line 3042
  if ((ha->device_type & 16384U) != 0U) {
#line 3044
    iounmap((void volatile   *)ha->nx_pcibase);
#line 3045
    if (ql2xdbwr == 0) {
#line 3046
      iounmap((void volatile   *)ha->nxdb_wr_ptr);
    } else {

    }
  } else {
#line 3048
    if ((unsigned long )ha->iobase != (unsigned long )((device_reg_t *)0)) {
#line 3049
      iounmap((void volatile   *)ha->iobase);
    } else {

    }
#line 3051
    if ((unsigned long )ha->cregbase != (unsigned long )((void *)0)) {
#line 3052
      iounmap((void volatile   *)ha->cregbase);
    } else {

    }
#line 3054
    if ((unsigned long )ha->mqiobase != (unsigned long )((device_reg_t *)0)) {
#line 3055
      iounmap((void volatile   *)ha->mqiobase);
    } else {

    }
#line 3057
    if ((((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) && (unsigned long )ha->msixbase != (unsigned long )((device_reg_t *)0)) {
#line 3058
      iounmap((void volatile   *)ha->msixbase);
    } else {

    }
  }
#line 3060
  return;
}
}
#line 3063 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla2x00_clear_drv_active(struct qla_hw_data *ha ) 
{ 


  {
#line 3065
  if ((ha->device_type & 262144U) != 0U) {
#line 3066
    qla8044_idc_lock(ha);
#line 3067
    qla8044_clear_drv_active(ha);
#line 3068
    qla8044_idc_unlock(ha);
  } else
#line 3069
  if ((ha->device_type & 16384U) != 0U) {
#line 3070
    qla82xx_idc_lock(ha);
#line 3071
    qla82xx_clear_drv_active(ha);
#line 3072
    qla82xx_idc_unlock(ha);
  } else {

  }
#line 3074
  return;
}
}
#line 3077 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla2x00_remove_one(struct pci_dev *pdev ) 
{ 
  scsi_qla_host_t *base_vha ;
  struct qla_hw_data *ha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 3082
  tmp = pci_get_drvdata(pdev);
#line 3082
  base_vha = (scsi_qla_host_t *)tmp;
#line 3083
  ha = base_vha->hw;
#line 3087
  set_bit(1L, (unsigned long volatile   *)(& base_vha->pci_flags));
#line 3088
  ldv_cancel_work_sync_23(& ha->board_disable);
#line 3095
  tmp___0 = atomic_read((atomic_t const   *)(& pdev->enable_cnt));
#line 3095
  if (tmp___0 == 0) {
#line 3096
    scsi_host_put(base_vha->host);
#line 3097
    kfree((void const   *)ha);
#line 3098
    pci_set_drvdata(pdev, (void *)0);
#line 3099
    return;
  } else {

  }
#line 3102
  qla2x00_wait_for_hba_ready(base_vha);
#line 3104
  set_bit(15L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 3106
  if ((ha->device_type & 131072U) != 0U) {
#line 3107
    qlafx00_driver_shutdown(base_vha, 20);
  } else {

  }
#line 3109
  qla2x00_delete_all_vps(ha, base_vha);
#line 3111
  if ((ha->device_type & 65536U) != 0U) {
#line 3112
    ql_dbg(524288U, base_vha, 45182, "Clearing fcoe driver presence.\n");
#line 3114
    tmp___1 = qla83xx_clear_drv_presence(base_vha);
#line 3114
    if (tmp___1 != 0) {
#line 3115
      ql_dbg(524288U, base_vha, 45177, "Error while clearing DRV-Presence.\n");
    } else {

    }
  } else {

  }
#line 3119
  qla2x00_abort_all_cmds(base_vha, 65536);
#line 3121
  qla2x00_dfs_remove(base_vha);
#line 3123
  qla84xx_put_chip(base_vha);
#line 3126
  if ((ha->device_type & 32768U) != 0U) {
#line 3127
    qla83xx_disable_laser(base_vha);
  } else {

  }
#line 3130
  if (base_vha->timer_active != 0U) {
#line 3131
    qla2x00_stop_timer(base_vha);
  } else {

  }
#line 3133
  base_vha->flags.online = 0U;
#line 3135
  qla2x00_destroy_deferred_work(ha);
#line 3137
  qlt_remove_target(ha, base_vha);
#line 3139
  qla2x00_free_sysfs_attr(base_vha, 1);
#line 3141
  fc_remove_host(base_vha->host);
#line 3143
  ldv_scsi_remove_host_24(base_vha->host);
#line 3145
  qla2x00_free_device(base_vha);
#line 3147
  qla2x00_clear_drv_active(ha);
#line 3149
  scsi_host_put(base_vha->host);
#line 3151
  qla2x00_unmap_iobases(ha);
#line 3153
  pci_release_selected_regions(ha->pdev, ha->bars);
#line 3154
  kfree((void const   *)ha);
#line 3155
  ha = (struct qla_hw_data *)0;
#line 3157
  pci_disable_pcie_error_reporting(pdev);
#line 3159
  pci_disable_device(pdev);
#line 3160
  return;
}
}
#line 3163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla2x00_free_device(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 3165
  ha = vha->hw;
#line 3167
  qla2x00_abort_all_cmds(vha, 65536);
#line 3170
  if (vha->timer_active != 0U) {
#line 3171
    qla2x00_stop_timer(vha);
  } else {

  }
#line 3173
  qla25xx_delete_queues(vha);
#line 3175
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 3176
    qla2x00_disable_fce_trace(vha, (uint64_t *)0ULL, (uint64_t *)0ULL);
  } else {

  }
#line 3178
  if ((unsigned long )ha->eft != (unsigned long )((void *)0)) {
#line 3179
    qla2x00_disable_eft_trace(vha);
  } else {

  }
#line 3182
  qla2x00_try_to_stop_firmware(vha);
#line 3184
  vha->flags.online = 0U;
#line 3187
  if ((unsigned int )ha->interrupts_on != 0U) {
#line 3188
    vha->flags.init_done = 0U;
#line 3189
    (*((ha->isp_ops)->disable_intrs))(ha);
  } else {

  }
#line 3192
  qla2x00_free_irqs(vha);
#line 3194
  qla2x00_free_fcports(vha);
#line 3196
  qla2x00_mem_free(ha);
#line 3198
  qla82xx_md_free(vha);
#line 3200
  qla2x00_free_queues(ha);
#line 3201
  return;
}
}
#line 3203 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
void qla2x00_free_fcports(struct scsi_qla_host *vha ) 
{ 
  fc_port_t *fcport ;
  fc_port_t *tfcport ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 3207
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 3207
  fcport = (fc_port_t *)__mptr;
#line 3207
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 3207
  tfcport = (fc_port_t *)__mptr___0;
#line 3207
  goto ldv_67341;
  ldv_67340: 
#line 3208
  list_del(& fcport->list);
#line 3209
  qla2x00_clear_loop_id(fcport);
#line 3210
  kfree((void const   *)fcport);
#line 3211
  fcport = (fc_port_t *)0;
#line 3207
  fcport = tfcport;
#line 3207
  __mptr___1 = (struct list_head  const  *)tfcport->list.next;
#line 3207
  tfcport = (fc_port_t *)__mptr___1;
  ldv_67341: ;
#line 3207
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 3209
    goto ldv_67340;
  } else {

  }

#line 3214
  return;
}
}
#line 3216 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
__inline static void qla2x00_schedule_rport_del(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                                int defer ) 
{ 
  struct fc_rport *rport ;
  scsi_qla_host_t *base_vha ;
  unsigned long flags ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 3223
  if ((unsigned long )fcport->rport == (unsigned long )((struct fc_rport *)0)) {
#line 3224
    return;
  } else {

  }
#line 3226
  rport = fcport->rport;
#line 3227
  if (defer != 0) {
#line 3228
    tmp = pci_get_drvdata((vha->hw)->pdev);
#line 3228
    base_vha = (scsi_qla_host_t *)tmp;
#line 3229
    tmp___0 = spinlock_check((vha->host)->host_lock);
#line 3229
    flags = _raw_spin_lock_irqsave(tmp___0);
#line 3230
    fcport->drport = rport;
#line 3231
    spin_unlock_irqrestore((vha->host)->host_lock, flags);
#line 3232
    set_bit(13L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 3233
    qla2xxx_wake_dpc(base_vha);
  } else {
#line 3235
    fc_remote_port_delete(rport);
#line 3236
    qlt_fc_port_deleted(vha, fcport);
  }
#line 3238
  return;
}
}
#line 3249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
void qla2x00_mark_device_lost(scsi_qla_host_t *vha , fc_port_t *fcport , int do_login ,
                              int defer ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 3252
  if (((vha->hw)->device_type & 131072U) != 0U) {
#line 3253
    qla2x00_set_fcport_state(fcport, 3);
#line 3254
    qla2x00_schedule_rport_del(vha, fcport, defer);
#line 3255
    return;
  } else {

  }
#line 3258
  tmp = atomic_read((atomic_t const   *)(& fcport->state));
#line 3258
  if (tmp == 4 && (int )vha->vp_idx == (int )(fcport->vha)->vp_idx) {
#line 3260
    qla2x00_set_fcport_state(fcport, 3);
#line 3261
    qla2x00_schedule_rport_del(vha, fcport, defer);
  } else {

  }
#line 3267
  tmp___0 = atomic_read((atomic_t const   *)(& fcport->state));
#line 3267
  if (tmp___0 != 2) {
#line 3268
    qla2x00_set_fcport_state(fcport, 3);
  } else {

  }
#line 3270
  if (do_login == 0) {
#line 3271
    return;
  } else {

  }
#line 3273
  if (fcport->login_retry == 0) {
#line 3274
    fcport->login_retry = (int )(vha->hw)->login_retry_count;
#line 3275
    set_bit(8L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3277
    ql_dbg(268435456U, vha, 8295, "Port login retry %8phN, id = 0x%04x retry cnt=%d.\n",
           (uint8_t *)(& fcport->port_name), (int )fcport->loop_id, fcport->login_retry);
  } else {

  }
#line 3281
  return;
}
}
#line 3297 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
void qla2x00_mark_all_devices_lost(scsi_qla_host_t *vha , int defer ) 
{ 
  fc_port_t *fcport ;
  struct list_head  const  *__mptr ;
  int tmp ;
  int tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 3301
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 3301
  fcport = (fc_port_t *)__mptr;
#line 3301
  goto ldv_67371;
  ldv_67370: ;
#line 3302
  if ((unsigned int )vha->vp_idx != 0U && (int )vha->vp_idx != (int )(fcport->vha)->vp_idx) {
#line 3303
    goto ldv_67369;
  } else {

  }
#line 3309
  tmp = atomic_read((atomic_t const   *)(& fcport->state));
#line 3309
  if (tmp == 2) {
#line 3310
    goto ldv_67369;
  } else {

  }
#line 3311
  tmp___0 = atomic_read((atomic_t const   *)(& fcport->state));
#line 3311
  if (tmp___0 == 4) {
#line 3312
    qla2x00_set_fcport_state(fcport, 3);
#line 3313
    if (defer != 0) {
#line 3314
      qla2x00_schedule_rport_del(vha, fcport, defer);
    } else
#line 3315
    if ((int )vha->vp_idx == (int )(fcport->vha)->vp_idx) {
#line 3316
      qla2x00_schedule_rport_del(vha, fcport, defer);
    } else {

    }
  } else {

  }
  ldv_67369: 
#line 3301
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 3301
  fcport = (fc_port_t *)__mptr___0;
  ldv_67371: ;
#line 3301
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 3303
    goto ldv_67370;
  } else {

  }

#line 3308
  return;
}
}
#line 3330 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int qla2x00_mem_alloc(struct qla_hw_data *ha , uint16_t req_len , uint16_t rsp_len ,
                             struct req_que **req , struct rsp_que **rsp ) 
{ 
  char name[16U] ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;

  {
#line 3335
  tmp = dma_alloc_attrs(& (ha->pdev)->dev, (size_t )ha->init_cb_size, & ha->init_cb_dma,
                        208U, (struct dma_attrs *)0);
#line 3335
  ha->init_cb = (init_cb_t *)tmp;
#line 3337
  if ((unsigned long )ha->init_cb == (unsigned long )((init_cb_t *)0)) {
#line 3338
    goto fail;
  } else {

  }
#line 3340
  tmp___0 = qlt_mem_alloc(ha);
#line 3340
  if (tmp___0 < 0) {
#line 3341
    goto fail_free_init_cb;
  } else {

  }
#line 3343
  tmp___1 = qla2x00_gid_list_size(ha);
#line 3343
  tmp___2 = dma_alloc_attrs(& (ha->pdev)->dev, (size_t )tmp___1, & ha->gid_list_dma,
                            208U, (struct dma_attrs *)0);
#line 3343
  ha->gid_list = (struct gid_list_info *)tmp___2;
#line 3345
  if ((unsigned long )ha->gid_list == (unsigned long )((struct gid_list_info *)0)) {
#line 3346
    goto fail_free_tgt_mem;
  } else {

  }
#line 3348
  ha->srb_mempool = mempool_create_slab_pool(128, srb_cachep);
#line 3349
  if ((unsigned long )ha->srb_mempool == (unsigned long )((mempool_t *)0)) {
#line 3350
    goto fail_free_gid_list;
  } else {

  }
#line 3352
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 3354
    if ((unsigned long )ctx_cachep == (unsigned long )((struct kmem_cache *)0)) {
#line 3355
      ctx_cachep = kmem_cache_create("qla2xxx_ctx", 48UL, 0UL, 8192UL, (void (*)(void * ))0);
#line 3358
      if ((unsigned long )ctx_cachep == (unsigned long )((struct kmem_cache *)0)) {
#line 3359
        goto fail_free_gid_list;
      } else {

      }
    } else {

    }
#line 3361
    ha->ctx_mempool = mempool_create_slab_pool(128, ctx_cachep);
#line 3363
    if ((unsigned long )ha->ctx_mempool == (unsigned long )((mempool_t *)0)) {
#line 3364
      goto fail_free_srb_mempool;
    } else {

    }
#line 3365
    ql_dbg_pci(1073741824U, ha->pdev, 33, "ctx_cachep=%p ctx_mempool=%p.\n", ctx_cachep,
               ha->ctx_mempool);
  } else {

  }
#line 3371
  ha->nvram = kzalloc(4096UL, 208U);
#line 3372
  if ((unsigned long )ha->nvram == (unsigned long )((void *)0)) {
#line 3373
    goto fail_free_ctx_mempool;
  } else {

  }
#line 3375
  snprintf((char *)(& name), 16UL, "%s_%d", (char *)"qla2xxx", (int )(ha->pdev)->device);
#line 3377
  ha->s_dma_pool = dma_pool_create((char const   *)(& name), & (ha->pdev)->dev, 256UL,
                                   8UL, 0UL);
#line 3379
  if ((unsigned long )ha->s_dma_pool == (unsigned long )((struct dma_pool *)0)) {
#line 3380
    goto fail_free_nvram;
  } else {

  }
#line 3382
  ql_dbg_pci(1073741824U, ha->pdev, 34, "init_cb=%p gid_list=%p, srb_mempool=%p s_dma_pool=%p.\n",
             ha->init_cb, ha->gid_list, ha->srb_mempool, ha->s_dma_pool);
#line 3386
  if (((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) || ql2xenabledif != 0) {
#line 3387
    ha->dl_dma_pool = dma_pool_create((char const   *)(& name), & (ha->pdev)->dev,
                                      512UL, 8UL, 0UL);
#line 3389
    if ((unsigned long )ha->dl_dma_pool == (unsigned long )((struct dma_pool *)0)) {
#line 3390
      ql_log_pci(0U, ha->pdev, 35, "Failed to allocate memory for dl_dma_pool.\n");
#line 3392
      goto fail_s_dma_pool;
    } else {

    }
#line 3395
    ha->fcp_cmnd_dma_pool = dma_pool_create((char const   *)(& name), & (ha->pdev)->dev,
                                            512UL, 8UL, 0UL);
#line 3397
    if ((unsigned long )ha->fcp_cmnd_dma_pool == (unsigned long )((struct dma_pool *)0)) {
#line 3398
      ql_log_pci(0U, ha->pdev, 36, "Failed to allocate memory for fcp_cmnd_dma_pool.\n");
#line 3400
      goto fail_dl_dma_pool;
    } else {

    }
#line 3402
    ql_dbg_pci(1073741824U, ha->pdev, 37, "dl_dma_pool=%p fcp_cmnd_dma_pool=%p.\n",
               ha->dl_dma_pool, ha->fcp_cmnd_dma_pool);
  } else {

  }
#line 3408
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 3410
    tmp___3 = dma_alloc_attrs(& (ha->pdev)->dev, 2064UL, & ha->sns_cmd_dma, 208U,
                              (struct dma_attrs *)0);
#line 3410
    ha->sns_cmd = (struct sns_cmd_pkt *)tmp___3;
#line 3412
    if ((unsigned long )ha->sns_cmd == (unsigned long )((struct sns_cmd_pkt *)0)) {
#line 3413
      goto fail_dma_pool;
    } else {

    }
#line 3414
    ql_dbg_pci(1073741824U, ha->pdev, 38, "sns_cmd: %p.\n", ha->sns_cmd);
  } else {
#line 3418
    tmp___4 = dma_pool_alloc(ha->s_dma_pool, 208U, & ha->ms_iocb_dma);
#line 3418
    ha->ms_iocb = (ms_iocb_entry_t *)tmp___4;
#line 3420
    if ((unsigned long )ha->ms_iocb == (unsigned long )((ms_iocb_entry_t *)0)) {
#line 3421
      goto fail_dma_pool;
    } else {

    }
#line 3423
    tmp___5 = dma_alloc_attrs(& (ha->pdev)->dev, 8208UL, & ha->ct_sns_dma, 208U, (struct dma_attrs *)0);
#line 3423
    ha->ct_sns = (struct ct_sns_pkt *)tmp___5;
#line 3425
    if ((unsigned long )ha->ct_sns == (unsigned long )((struct ct_sns_pkt *)0)) {
#line 3426
      goto fail_free_ms_iocb;
    } else {

    }
#line 3427
    ql_dbg_pci(1073741824U, ha->pdev, 39, "ms_iocb=%p ct_sns=%p.\n", ha->ms_iocb,
               ha->ct_sns);
  }
#line 3433
  tmp___6 = kzalloc(192UL, 208U);
#line 3433
  *req = (struct req_que *)tmp___6;
#line 3434
  if ((unsigned long )*req == (unsigned long )((struct req_que *)0)) {
#line 3435
    ql_log_pci(0U, ha->pdev, 40, "Failed to allocate memory for req.\n");
#line 3437
    goto fail_req;
  } else {

  }
#line 3439
  (*req)->length = req_len;
#line 3440
  tmp___7 = dma_alloc_attrs(& (ha->pdev)->dev, (unsigned long )((int )(*req)->length + 1) * 64UL,
                            & (*req)->dma, 208U, (struct dma_attrs *)0);
#line 3440
  (*req)->ring = (request_t *)tmp___7;
#line 3443
  if ((unsigned long )(*req)->ring == (unsigned long )((request_t *)0)) {
#line 3444
    ql_log_pci(0U, ha->pdev, 41, "Failed to allocate memory for req_ring.\n");
#line 3446
    goto fail_req_ring;
  } else {

  }
#line 3449
  tmp___8 = kzalloc(272UL, 208U);
#line 3449
  *rsp = (struct rsp_que *)tmp___8;
#line 3450
  if ((unsigned long )*rsp == (unsigned long )((struct rsp_que *)0)) {
#line 3451
    ql_log_pci(0U, ha->pdev, 42, "Failed to allocate memory for rsp.\n");
#line 3453
    goto fail_rsp;
  } else {

  }
#line 3455
  (*rsp)->hw = ha;
#line 3456
  (*rsp)->length = rsp_len;
#line 3457
  tmp___9 = dma_alloc_attrs(& (ha->pdev)->dev, (unsigned long )((int )(*rsp)->length + 1) * 64UL,
                            & (*rsp)->dma, 208U, (struct dma_attrs *)0);
#line 3457
  (*rsp)->ring = (response_t *)tmp___9;
#line 3460
  if ((unsigned long )(*rsp)->ring == (unsigned long )((response_t *)0)) {
#line 3461
    ql_log_pci(0U, ha->pdev, 43, "Failed to allocate memory for rsp_ring.\n");
#line 3463
    goto fail_rsp_ring;
  } else {

  }
#line 3465
  (*req)->rsp = *rsp;
#line 3466
  (*rsp)->req = *req;
#line 3467
  ql_dbg_pci(1073741824U, ha->pdev, 44, "req=%p req->length=%d req->ring=%p rsp=%p rsp->length=%d rsp->ring=%p.\n",
             *req, (int )(*req)->length, (*req)->ring, *rsp, (int )(*rsp)->length,
             (*rsp)->ring);
#line 3473
  if ((unsigned int )ha->nvram_npiv_size != 0U) {
#line 3474
    tmp___10 = kzalloc((unsigned long )ha->nvram_npiv_size * 24UL, 208U);
#line 3474
    ha->npiv_info = (struct qla_npiv_entry *)tmp___10;
#line 3476
    if ((unsigned long )ha->npiv_info == (unsigned long )((struct qla_npiv_entry *)0)) {
#line 3477
      ql_log_pci(0U, ha->pdev, 45, "Failed to allocate memory for npiv_info.\n");
#line 3479
      goto fail_npiv_info;
    } else {

    }
  } else {
#line 3482
    ha->npiv_info = (struct qla_npiv_entry *)0;
  }
#line 3485
  if ((((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) || (ha->device_type & 32768U) != 0U) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 3486
    tmp___11 = dma_pool_alloc(ha->s_dma_pool, 208U, & ha->ex_init_cb_dma);
#line 3486
    ha->ex_init_cb = (struct ex_init_cb_81xx *)tmp___11;
#line 3488
    if ((unsigned long )ha->ex_init_cb == (unsigned long )((struct ex_init_cb_81xx *)0)) {
#line 3489
      goto fail_ex_init_cb;
    } else {

    }
#line 3490
    ql_dbg_pci(1073741824U, ha->pdev, 46, "ex_init_cb=%p.\n", ha->ex_init_cb);
  } else {

  }
#line 3494
  INIT_LIST_HEAD(& ha->gbl_dsd_list);
#line 3497
  if ((ha->device_type & 134217728U) == 0U) {
#line 3498
    ha->async_pd = dma_pool_alloc(ha->s_dma_pool, 208U, & ha->async_pd_dma);
#line 3500
    if ((unsigned long )ha->async_pd == (unsigned long )((void *)0)) {
#line 3501
      goto fail_async_pd;
    } else {

    }
#line 3502
    ql_dbg_pci(1073741824U, ha->pdev, 47, "async_pd=%p.\n", ha->async_pd);
  } else {

  }
#line 3506
  INIT_LIST_HEAD(& ha->vp_list);
#line 3509
  ha->loop_id_map = kzalloc((((unsigned long )ha->max_fibre_devices + 63UL) / 64UL) * 8UL,
                            208U);
#line 3511
  if ((unsigned long )ha->loop_id_map == (unsigned long )((void *)0)) {
#line 3512
    goto fail_async_pd;
  } else {
#line 3514
    qla2x00_set_reserved_loop_ids(ha);
#line 3515
    ql_dbg_pci(1073741824U, ha->pdev, 291, "loop_id_map=%p.\n", ha->loop_id_map);
  }
#line 3519
  return (0);
  fail_async_pd: 
#line 3522
  dma_pool_free(ha->s_dma_pool, (void *)ha->ex_init_cb, ha->ex_init_cb_dma);
  fail_ex_init_cb: 
#line 3524
  kfree((void const   *)ha->npiv_info);
  fail_npiv_info: 
#line 3526
  dma_free_attrs(& (ha->pdev)->dev, (unsigned long )((int )(*rsp)->length + 1) * 64UL,
                 (void *)(*rsp)->ring, (*rsp)->dma, (struct dma_attrs *)0);
#line 3528
  (*rsp)->ring = (response_t *)0;
#line 3529
  (*rsp)->dma = 0ULL;
  fail_rsp_ring: 
#line 3531
  kfree((void const   *)*rsp);
  fail_rsp: 
#line 3533
  dma_free_attrs(& (ha->pdev)->dev, (unsigned long )((int )(*req)->length + 1) * 64UL,
                 (void *)(*req)->ring, (*req)->dma, (struct dma_attrs *)0);
#line 3535
  (*req)->ring = (request_t *)0;
#line 3536
  (*req)->dma = 0ULL;
  fail_req_ring: 
#line 3538
  kfree((void const   *)*req);
  fail_req: 
#line 3540
  dma_free_attrs(& (ha->pdev)->dev, 8208UL, (void *)ha->ct_sns, ha->ct_sns_dma, (struct dma_attrs *)0);
#line 3542
  ha->ct_sns = (struct ct_sns_pkt *)0;
#line 3543
  ha->ct_sns_dma = 0ULL;
  fail_free_ms_iocb: 
#line 3545
  dma_pool_free(ha->s_dma_pool, (void *)ha->ms_iocb, ha->ms_iocb_dma);
#line 3546
  ha->ms_iocb = (ms_iocb_entry_t *)0;
#line 3547
  ha->ms_iocb_dma = 0ULL;
  fail_dma_pool: ;
#line 3549
  if ((ha->device_type & 16384U) != 0U || ql2xenabledif != 0) {
#line 3550
    dma_pool_destroy(ha->fcp_cmnd_dma_pool);
#line 3551
    ha->fcp_cmnd_dma_pool = (struct dma_pool *)0;
  } else {

  }
  fail_dl_dma_pool: ;
#line 3554
  if ((ha->device_type & 16384U) != 0U || ql2xenabledif != 0) {
#line 3555
    dma_pool_destroy(ha->dl_dma_pool);
#line 3556
    ha->dl_dma_pool = (struct dma_pool *)0;
  } else {

  }
  fail_s_dma_pool: 
#line 3559
  dma_pool_destroy(ha->s_dma_pool);
#line 3560
  ha->s_dma_pool = (struct dma_pool *)0;
  fail_free_nvram: 
#line 3562
  kfree((void const   *)ha->nvram);
#line 3563
  ha->nvram = (void *)0;
  fail_free_ctx_mempool: 
#line 3565
  mempool_destroy(ha->ctx_mempool);
#line 3566
  ha->ctx_mempool = (mempool_t *)0;
  fail_free_srb_mempool: 
#line 3568
  mempool_destroy(ha->srb_mempool);
#line 3569
  ha->srb_mempool = (mempool_t *)0;
  fail_free_gid_list: 
#line 3571
  tmp___12 = qla2x00_gid_list_size(ha);
#line 3571
  dma_free_attrs(& (ha->pdev)->dev, (size_t )tmp___12, (void *)ha->gid_list, ha->gid_list_dma,
                 (struct dma_attrs *)0);
#line 3574
  ha->gid_list = (struct gid_list_info *)0;
#line 3575
  ha->gid_list_dma = 0ULL;
  fail_free_tgt_mem: 
#line 3577
  qlt_mem_free(ha);
  fail_free_init_cb: 
#line 3579
  dma_free_attrs(& (ha->pdev)->dev, (size_t )ha->init_cb_size, (void *)ha->init_cb,
                 ha->init_cb_dma, (struct dma_attrs *)0);
#line 3581
  ha->init_cb = (init_cb_t *)0;
#line 3582
  ha->init_cb_dma = 0ULL;
  fail: 
#line 3584
  ql_log(0U, (scsi_qla_host_t *)0, 48, "Memory allocation failure.\n");
#line 3586
  return (-12);
}
}
#line 3597 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla2x00_free_fw_dump(struct qla_hw_data *ha ) 
{ 


  {
#line 3599
  if ((unsigned long )ha->fce != (unsigned long )((void *)0)) {
#line 3600
    dma_free_attrs(& (ha->pdev)->dev, 65536UL, ha->fce, ha->fce_dma, (struct dma_attrs *)0);
  } else {

  }
#line 3603
  if ((unsigned long )ha->eft != (unsigned long )((void *)0)) {
#line 3604
    dma_free_attrs(& (ha->pdev)->dev, 65536UL, ha->eft, ha->eft_dma, (struct dma_attrs *)0);
  } else {

  }
#line 3607
  if ((unsigned long )ha->fw_dump != (unsigned long )((struct qla2xxx_fw_dump *)0)) {
#line 3608
    vfree((void const   *)ha->fw_dump);
  } else {

  }
#line 3609
  if ((unsigned long )ha->fw_dump_template != (unsigned long )((void *)0)) {
#line 3610
    vfree((void const   *)ha->fw_dump_template);
  } else {

  }
#line 3612
  ha->fce = (void *)0;
#line 3613
  ha->fce_dma = 0ULL;
#line 3614
  ha->eft = (void *)0;
#line 3615
  ha->eft_dma = 0ULL;
#line 3616
  ha->fw_dumped = 0;
#line 3617
  ha->fw_dump_cap_flags = 0UL;
#line 3618
  ha->fw_dump_reading = 0;
#line 3619
  ha->fw_dump = (struct qla2xxx_fw_dump *)0;
#line 3620
  ha->fw_dump_len = 0U;
#line 3621
  ha->fw_dump_template = (void *)0;
#line 3622
  ha->fw_dump_template_len = 0U;
#line 3623
  return;
}
}
#line 3633 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla2x00_mem_free(struct qla_hw_data *ha ) 
{ 
  int tmp ;
  struct dsd_dma *dsd_ptr ;
  struct dsd_dma *tdsd_ptr ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  int tmp___0 ;

  {
#line 3635
  qla2x00_free_fw_dump(ha);
#line 3637
  if ((unsigned long )ha->mctp_dump != (unsigned long )((void *)0)) {
#line 3638
    dma_free_attrs(& (ha->pdev)->dev, 548964UL, ha->mctp_dump, ha->mctp_dump_dma,
                   (struct dma_attrs *)0);
  } else {

  }
#line 3641
  if ((unsigned long )ha->srb_mempool != (unsigned long )((mempool_t *)0)) {
#line 3642
    mempool_destroy(ha->srb_mempool);
  } else {

  }
#line 3644
  if ((unsigned long )ha->dcbx_tlv != (unsigned long )((void *)0)) {
#line 3645
    dma_free_attrs(& (ha->pdev)->dev, 4096UL, ha->dcbx_tlv, ha->dcbx_tlv_dma, (struct dma_attrs *)0);
  } else {

  }
#line 3648
  if ((unsigned long )ha->xgmac_data != (unsigned long )((void *)0)) {
#line 3649
    dma_free_attrs(& (ha->pdev)->dev, 4096UL, ha->xgmac_data, ha->xgmac_data_dma,
                   (struct dma_attrs *)0);
  } else {

  }
#line 3652
  if ((unsigned long )ha->sns_cmd != (unsigned long )((struct sns_cmd_pkt *)0)) {
#line 3653
    dma_free_attrs(& (ha->pdev)->dev, 2064UL, (void *)ha->sns_cmd, ha->sns_cmd_dma,
                   (struct dma_attrs *)0);
  } else {

  }
#line 3656
  if ((unsigned long )ha->ct_sns != (unsigned long )((struct ct_sns_pkt *)0)) {
#line 3657
    dma_free_attrs(& (ha->pdev)->dev, 8208UL, (void *)ha->ct_sns, ha->ct_sns_dma,
                   (struct dma_attrs *)0);
  } else {

  }
#line 3660
  if ((unsigned long )ha->sfp_data != (unsigned long )((void *)0)) {
#line 3661
    dma_pool_free(ha->s_dma_pool, ha->sfp_data, ha->sfp_data_dma);
  } else {

  }
#line 3663
  if ((unsigned long )ha->ms_iocb != (unsigned long )((ms_iocb_entry_t *)0)) {
#line 3664
    dma_pool_free(ha->s_dma_pool, (void *)ha->ms_iocb, ha->ms_iocb_dma);
  } else {

  }
#line 3666
  if ((unsigned long )ha->ex_init_cb != (unsigned long )((struct ex_init_cb_81xx *)0)) {
#line 3667
    dma_pool_free(ha->s_dma_pool, (void *)ha->ex_init_cb, ha->ex_init_cb_dma);
  } else {

  }
#line 3670
  if ((unsigned long )ha->async_pd != (unsigned long )((void *)0)) {
#line 3671
    dma_pool_free(ha->s_dma_pool, ha->async_pd, ha->async_pd_dma);
  } else {

  }
#line 3673
  if ((unsigned long )ha->s_dma_pool != (unsigned long )((struct dma_pool *)0)) {
#line 3674
    dma_pool_destroy(ha->s_dma_pool);
  } else {

  }
#line 3676
  if ((unsigned long )ha->gid_list != (unsigned long )((struct gid_list_info *)0)) {
#line 3677
    tmp = qla2x00_gid_list_size(ha);
#line 3677
    dma_free_attrs(& (ha->pdev)->dev, (size_t )tmp, (void *)ha->gid_list, ha->gid_list_dma,
                   (struct dma_attrs *)0);
  } else {

  }
#line 3680
  if ((ha->device_type & 16384U) != 0U) {
#line 3681
    tmp___0 = list_empty((struct list_head  const  *)(& ha->gbl_dsd_list));
#line 3681
    if (tmp___0 == 0) {
#line 3685
      __mptr = (struct list_head  const  *)ha->gbl_dsd_list.next;
#line 3685
      dsd_ptr = (struct dsd_dma *)__mptr;
#line 3685
      __mptr___0 = (struct list_head  const  *)dsd_ptr->list.next;
#line 3685
      tdsd_ptr = (struct dsd_dma *)__mptr___0;
#line 3685
      goto ldv_67414;
      ldv_67413: 
#line 3687
      dma_pool_free(ha->dl_dma_pool, dsd_ptr->dsd_addr, dsd_ptr->dsd_list_dma);
#line 3689
      list_del(& dsd_ptr->list);
#line 3690
      kfree((void const   *)dsd_ptr);
#line 3685
      dsd_ptr = tdsd_ptr;
#line 3685
      __mptr___1 = (struct list_head  const  *)tdsd_ptr->list.next;
#line 3685
      tdsd_ptr = (struct dsd_dma *)__mptr___1;
      ldv_67414: ;
#line 3685
      if ((unsigned long )(& dsd_ptr->list) != (unsigned long )(& ha->gbl_dsd_list)) {
#line 3687
        goto ldv_67413;
      } else {

      }

    } else {

    }
  } else {

  }
#line 3695
  if ((unsigned long )ha->dl_dma_pool != (unsigned long )((struct dma_pool *)0)) {
#line 3696
    dma_pool_destroy(ha->dl_dma_pool);
  } else {

  }
#line 3698
  if ((unsigned long )ha->fcp_cmnd_dma_pool != (unsigned long )((struct dma_pool *)0)) {
#line 3699
    dma_pool_destroy(ha->fcp_cmnd_dma_pool);
  } else {

  }
#line 3701
  if ((unsigned long )ha->ctx_mempool != (unsigned long )((mempool_t *)0)) {
#line 3702
    mempool_destroy(ha->ctx_mempool);
  } else {

  }
#line 3704
  qlt_mem_free(ha);
#line 3706
  if ((unsigned long )ha->init_cb != (unsigned long )((init_cb_t *)0)) {
#line 3707
    dma_free_attrs(& (ha->pdev)->dev, (size_t )ha->init_cb_size, (void *)ha->init_cb,
                   ha->init_cb_dma, (struct dma_attrs *)0);
  } else {

  }
#line 3709
  vfree((void const   *)ha->optrom_buffer);
#line 3710
  kfree((void const   *)ha->nvram);
#line 3711
  kfree((void const   *)ha->npiv_info);
#line 3712
  kfree((void const   *)ha->swl);
#line 3713
  kfree((void const   *)ha->loop_id_map);
#line 3715
  ha->srb_mempool = (mempool_t *)0;
#line 3716
  ha->ctx_mempool = (mempool_t *)0;
#line 3717
  ha->sns_cmd = (struct sns_cmd_pkt *)0;
#line 3718
  ha->sns_cmd_dma = 0ULL;
#line 3719
  ha->ct_sns = (struct ct_sns_pkt *)0;
#line 3720
  ha->ct_sns_dma = 0ULL;
#line 3721
  ha->ms_iocb = (ms_iocb_entry_t *)0;
#line 3722
  ha->ms_iocb_dma = 0ULL;
#line 3723
  ha->init_cb = (init_cb_t *)0;
#line 3724
  ha->init_cb_dma = 0ULL;
#line 3725
  ha->ex_init_cb = (struct ex_init_cb_81xx *)0;
#line 3726
  ha->ex_init_cb_dma = 0ULL;
#line 3727
  ha->async_pd = (void *)0;
#line 3728
  ha->async_pd_dma = 0ULL;
#line 3730
  ha->s_dma_pool = (struct dma_pool *)0;
#line 3731
  ha->dl_dma_pool = (struct dma_pool *)0;
#line 3732
  ha->fcp_cmnd_dma_pool = (struct dma_pool *)0;
#line 3734
  ha->gid_list = (struct gid_list_info *)0;
#line 3735
  ha->gid_list_dma = 0ULL;
#line 3737
  ha->tgt.atio_ring = (struct atio *)0;
#line 3738
  ha->tgt.atio_dma = 0ULL;
#line 3739
  ha->tgt.tgt_vp_map = (struct qla_tgt_vp_map *)0;
#line 3740
  return;
}
}
#line 3742 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
struct scsi_qla_host *qla2x00_create_host(struct scsi_host_template *sht , struct qla_hw_data *ha ) 
{ 
  struct Scsi_Host *host ;
  struct scsi_qla_host *vha ;
  void *tmp ;
  struct lock_class_key __key ;
  char const   *tmp___0 ;

  {
#line 3746
  vha = (struct scsi_qla_host *)0;
#line 3748
  host = ldv_scsi_host_alloc_25(sht, 1360);
#line 3749
  if ((unsigned long )host == (unsigned long )((struct Scsi_Host *)0)) {
#line 3750
    ql_log_pci(0U, ha->pdev, 263, "Failed to allocate host from the scsi layer, aborting.\n");
#line 3752
    goto fail;
  } else {

  }
#line 3756
  tmp = shost_priv(host);
#line 3756
  vha = (struct scsi_qla_host *)tmp;
#line 3757
  memset((void *)vha, 0, 1360UL);
#line 3759
  vha->host = host;
#line 3760
  vha->host_no = (unsigned long )host->host_no;
#line 3761
  vha->hw = ha;
#line 3763
  INIT_LIST_HEAD(& vha->vp_fcports);
#line 3764
  INIT_LIST_HEAD(& vha->work_list);
#line 3765
  INIT_LIST_HEAD(& vha->list);
#line 3767
  spinlock_check(& vha->work_lock);
#line 3767
  __raw_spin_lock_init(& vha->work_lock.__annonCompField18.rlock, "&(&vha->work_lock)->rlock",
                       & __key);
#line 3769
  sprintf((char *)(& vha->host_str), "%s_%ld", (char *)"qla2xxx", vha->host_no);
#line 3770
  tmp___0 = dev_name((struct device  const  *)(& (ha->pdev)->dev));
#line 3770
  ql_dbg(1073741824U, vha, 65, "Allocated the host=%p hw=%p vha=%p dev_name=%s", vha->host,
         vha->hw, vha, tmp___0);
#line 3775
  return (vha);
  fail: ;
#line 3778
  return (vha);
}
}
#line 3782 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static struct qla_work_evt *qla2x00_alloc_work(struct scsi_qla_host *vha , enum qla_work_type type ) 
{ 
  struct qla_work_evt *e ;
  uint8_t bail ;
  void *tmp ;

  {
#line 3787
  atomic_inc(& vha->vref_count);
#line 3787
  __asm__  volatile   ("mfence": : : "memory");
#line 3787
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 3787
    atomic_dec(& vha->vref_count);
#line 3787
    bail = 1U;
  } else {
#line 3787
    bail = 0U;
  }
#line 3788
  if ((unsigned int )bail != 0U) {
#line 3789
    return ((struct qla_work_evt *)0);
  } else {

  }
#line 3791
  tmp = kzalloc(64UL, 32U);
#line 3791
  e = (struct qla_work_evt *)tmp;
#line 3792
  if ((unsigned long )e == (unsigned long )((struct qla_work_evt *)0)) {
#line 3793
    atomic_dec(& vha->vref_count);
#line 3794
    return ((struct qla_work_evt *)0);
  } else {

  }
#line 3797
  INIT_LIST_HEAD(& e->list);
#line 3798
  e->type = type;
#line 3799
  e->flags = 1U;
#line 3800
  return (e);
}
}
#line 3804 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int qla2x00_post_work(struct scsi_qla_host *vha , struct qla_work_evt *e ) 
{ 
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 3808
  tmp = spinlock_check(& vha->work_lock);
#line 3808
  flags = _raw_spin_lock_irqsave(tmp);
#line 3809
  list_add_tail(& e->list, & vha->work_list);
#line 3810
  spin_unlock_irqrestore(& vha->work_lock, flags);
#line 3811
  qla2xxx_wake_dpc(vha);
#line 3813
  return (0);
}
}
#line 3817 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int qla2x00_post_aen_work(struct scsi_qla_host *vha , enum fc_host_event_code code ,
                          u32 data ) 
{ 
  struct qla_work_evt *e ;
  int tmp ;

  {
#line 3822
  e = qla2x00_alloc_work(vha, 0);
#line 3823
  if ((unsigned long )e == (unsigned long )((struct qla_work_evt *)0)) {
#line 3824
    return (258);
  } else {

  }
#line 3826
  e->u.aen.code = code;
#line 3827
  e->u.aen.data = data;
#line 3828
  tmp = qla2x00_post_work(vha, e);
#line 3828
  return (tmp);
}
}
#line 3832 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int qla2x00_post_idc_ack_work(struct scsi_qla_host *vha , uint16_t *mb ) 
{ 
  struct qla_work_evt *e ;
  int tmp ;

  {
#line 3836
  e = qla2x00_alloc_work(vha, 1);
#line 3837
  if ((unsigned long )e == (unsigned long )((struct qla_work_evt *)0)) {
#line 3838
    return (258);
  } else {

  }
#line 3840
  memcpy((void *)(& e->u.idc_ack.mb), (void const   *)mb, 14UL);
#line 3841
  tmp = qla2x00_post_work(vha, e);
#line 3841
  return (tmp);
}
}
#line 3863 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int qla2x00_post_async_login_work(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                  uint16_t *data ) 
{ 
  struct qla_work_evt *e ;
  int tmp ;

  {
#line 3863
  e = qla2x00_alloc_work(vha, 2);
#line 3863
  if ((unsigned long )e == (unsigned long )((struct qla_work_evt *)0)) {
#line 3863
    return (258);
  } else {

  }
#line 3863
  e->u.logio.fcport = fcport;
#line 3863
  if ((unsigned long )data != (unsigned long )((uint16_t *)0U)) {
#line 3863
    e->u.logio.data[0] = *data;
#line 3863
    e->u.logio.data[1] = *(data + 1UL);
  } else {

  }
#line 3863
  tmp = qla2x00_post_work(vha, e);
#line 3863
  return (tmp);
}
}
#line 3864 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int qla2x00_post_async_login_done_work(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                       uint16_t *data ) 
{ 
  struct qla_work_evt *e ;
  int tmp ;

  {
#line 3864
  e = qla2x00_alloc_work(vha, 3);
#line 3864
  if ((unsigned long )e == (unsigned long )((struct qla_work_evt *)0)) {
#line 3864
    return (258);
  } else {

  }
#line 3864
  e->u.logio.fcport = fcport;
#line 3864
  if ((unsigned long )data != (unsigned long )((uint16_t *)0U)) {
#line 3864
    e->u.logio.data[0] = *data;
#line 3864
    e->u.logio.data[1] = *(data + 1UL);
  } else {

  }
#line 3864
  tmp = qla2x00_post_work(vha, e);
#line 3864
  return (tmp);
}
}
#line 3865 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int qla2x00_post_async_logout_work(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                   uint16_t *data ) 
{ 
  struct qla_work_evt *e ;
  int tmp ;

  {
#line 3865
  e = qla2x00_alloc_work(vha, 4);
#line 3865
  if ((unsigned long )e == (unsigned long )((struct qla_work_evt *)0)) {
#line 3865
    return (258);
  } else {

  }
#line 3865
  e->u.logio.fcport = fcport;
#line 3865
  if ((unsigned long )data != (unsigned long )((uint16_t *)0U)) {
#line 3865
    e->u.logio.data[0] = *data;
#line 3865
    e->u.logio.data[1] = *(data + 1UL);
  } else {

  }
#line 3865
  tmp = qla2x00_post_work(vha, e);
#line 3865
  return (tmp);
}
}
#line 3866 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int qla2x00_post_async_logout_done_work(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                        uint16_t *data ) 
{ 
  struct qla_work_evt *e ;
  int tmp ;

  {
#line 3866
  e = qla2x00_alloc_work(vha, 5);
#line 3866
  if ((unsigned long )e == (unsigned long )((struct qla_work_evt *)0)) {
#line 3866
    return (258);
  } else {

  }
#line 3866
  e->u.logio.fcport = fcport;
#line 3866
  if ((unsigned long )data != (unsigned long )((uint16_t *)0U)) {
#line 3866
    e->u.logio.data[0] = *data;
#line 3866
    e->u.logio.data[1] = *(data + 1UL);
  } else {

  }
#line 3866
  tmp = qla2x00_post_work(vha, e);
#line 3866
  return (tmp);
}
}
#line 3867 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int qla2x00_post_async_adisc_work(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                  uint16_t *data ) 
{ 
  struct qla_work_evt *e ;
  int tmp ;

  {
#line 3867
  e = qla2x00_alloc_work(vha, 6);
#line 3867
  if ((unsigned long )e == (unsigned long )((struct qla_work_evt *)0)) {
#line 3867
    return (258);
  } else {

  }
#line 3867
  e->u.logio.fcport = fcport;
#line 3867
  if ((unsigned long )data != (unsigned long )((uint16_t *)0U)) {
#line 3867
    e->u.logio.data[0] = *data;
#line 3867
    e->u.logio.data[1] = *(data + 1UL);
  } else {

  }
#line 3867
  tmp = qla2x00_post_work(vha, e);
#line 3867
  return (tmp);
}
}
#line 3868 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int qla2x00_post_async_adisc_done_work(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                       uint16_t *data ) 
{ 
  struct qla_work_evt *e ;
  int tmp ;

  {
#line 3868
  e = qla2x00_alloc_work(vha, 7);
#line 3868
  if ((unsigned long )e == (unsigned long )((struct qla_work_evt *)0)) {
#line 3868
    return (258);
  } else {

  }
#line 3868
  e->u.logio.fcport = fcport;
#line 3868
  if ((unsigned long )data != (unsigned long )((uint16_t *)0U)) {
#line 3868
    e->u.logio.data[0] = *data;
#line 3868
    e->u.logio.data[1] = *(data + 1UL);
  } else {

  }
#line 3868
  tmp = qla2x00_post_work(vha, e);
#line 3868
  return (tmp);
}
}
#line 3871 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int qla2x00_post_uevent_work(struct scsi_qla_host *vha , u32 code ) 
{ 
  struct qla_work_evt *e ;
  int tmp ;

  {
#line 3875
  e = qla2x00_alloc_work(vha, 8);
#line 3876
  if ((unsigned long )e == (unsigned long )((struct qla_work_evt *)0)) {
#line 3877
    return (258);
  } else {

  }
#line 3879
  e->u.uevent.code = code;
#line 3880
  tmp = qla2x00_post_work(vha, e);
#line 3880
  return (tmp);
}
}
#line 3884 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla2x00_uevent_emit(struct scsi_qla_host *vha , u32 code ) 
{ 
  char event_string[40U] ;
  char *envp[2U] ;

  {
#line 3887
  envp[0] = (char *)(& event_string);
#line 3887
  envp[1] = (char *)0;
#line 3889
  switch (code) {
  case 0U: 
#line 3891
  snprintf((char *)(& event_string), 40UL, "FW_DUMP=%ld", vha->host_no);
#line 3893
  goto ldv_67497;
  default: ;
#line 3896
  goto ldv_67497;
  }
  ldv_67497: 
#line 3898
  kobject_uevent_env(& ((vha->hw)->pdev)->dev.kobj, 2, (char **)(& envp));
#line 3899
  return;
}
}
#line 3902 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int qlafx00_post_aenfx_work(struct scsi_qla_host *vha , uint32_t evtcode , uint32_t *data ,
                            int cnt ) 
{ 
  struct qla_work_evt *e ;
  int tmp ;

  {
#line 3907
  e = qla2x00_alloc_work(vha, 9);
#line 3908
  if ((unsigned long )e == (unsigned long )((struct qla_work_evt *)0)) {
#line 3909
    return (258);
  } else {

  }
#line 3911
  e->u.aenfx.evtcode = evtcode;
#line 3912
  e->u.aenfx.count = (uint32_t )cnt;
#line 3913
  memcpy((void *)(& e->u.aenfx.mbx), (void const   *)data, (unsigned long )cnt * 4UL);
#line 3914
  tmp = qla2x00_post_work(vha, e);
#line 3914
  return (tmp);
}
}
#line 3918 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
void qla2x00_do_work(struct scsi_qla_host *vha ) 
{ 
  struct qla_work_evt *e ;
  struct qla_work_evt *tmp ;
  unsigned long flags ;
  struct list_head work ;
  raw_spinlock_t *tmp___0 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  u32 tmp___1 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 3922
  work.next = & work;
#line 3922
  work.prev = & work;
#line 3924
  tmp___0 = spinlock_check(& vha->work_lock);
#line 3924
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 3925
  list_splice_init(& vha->work_list, & work);
#line 3926
  spin_unlock_irqrestore(& vha->work_lock, flags);
#line 3928
  __mptr = (struct list_head  const  *)work.next;
#line 3928
  e = (struct qla_work_evt *)__mptr;
#line 3928
  __mptr___0 = (struct list_head  const  *)e->list.next;
#line 3928
  tmp = (struct qla_work_evt *)__mptr___0;
#line 3928
  goto ldv_67534;
  ldv_67533: 
#line 3929
  list_del_init(& e->list);
#line 3931
  switch ((unsigned int )e->type) {
  case 0U: 
#line 3933
  tmp___1 = fc_get_event_number();
#line 3933
  fc_host_post_event(vha->host, tmp___1, e->u.aen.code, e->u.aen.data);
#line 3935
  goto ldv_67523;
  case 1U: 
#line 3937
  qla81xx_idc_ack(vha, (uint16_t *)(& e->u.idc_ack.mb));
#line 3938
  goto ldv_67523;
  case 2U: 
#line 3940
  qla2x00_async_login(vha, e->u.logio.fcport, (uint16_t *)(& e->u.logio.data));
#line 3942
  goto ldv_67523;
  case 3U: 
#line 3944
  qla2x00_async_login_done(vha, e->u.logio.fcport, (uint16_t *)(& e->u.logio.data));
#line 3946
  goto ldv_67523;
  case 4U: 
#line 3948
  qla2x00_async_logout(vha, e->u.logio.fcport);
#line 3949
  goto ldv_67523;
  case 5U: 
#line 3951
  qla2x00_async_logout_done(vha, e->u.logio.fcport, (uint16_t *)(& e->u.logio.data));
#line 3953
  goto ldv_67523;
  case 6U: 
#line 3955
  qla2x00_async_adisc(vha, e->u.logio.fcport, (uint16_t *)(& e->u.logio.data));
#line 3957
  goto ldv_67523;
  case 7U: 
#line 3959
  qla2x00_async_adisc_done(vha, e->u.logio.fcport, (uint16_t *)(& e->u.logio.data));
#line 3961
  goto ldv_67523;
  case 8U: 
#line 3963
  qla2x00_uevent_emit(vha, e->u.uevent.code);
#line 3964
  goto ldv_67523;
  case 9U: 
#line 3966
  qlafx00_process_aen(vha, e);
#line 3967
  goto ldv_67523;
  }
  ldv_67523: ;
#line 3969
  if ((int )e->flags & 1) {
#line 3970
    kfree((void const   *)e);
  } else {

  }
#line 3973
  atomic_dec(& vha->vref_count);
#line 3928
  e = tmp;
#line 3928
  __mptr___1 = (struct list_head  const  *)tmp->list.next;
#line 3928
  tmp = (struct qla_work_evt *)__mptr___1;
  ldv_67534: ;
#line 3928
  if ((unsigned long )(& e->list) != (unsigned long )(& work)) {
#line 3930
    goto ldv_67533;
  } else {

  }

#line 3935
  return;
}
}
#line 3980 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
void qla2x00_relogin(struct scsi_qla_host *vha ) 
{ 
  fc_port_t *fcport ;
  int status ;
  uint16_t next_loopid ;
  struct qla_hw_data *ha ;
  uint16_t data[2U] ;
  struct list_head  const  *__mptr ;
  int status2 ;
  uint8_t opts ;
  int tmp ;
  int tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 3984
  next_loopid = 0U;
#line 3985
  ha = vha->hw;
#line 3988
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 3988
  fcport = (fc_port_t *)__mptr;
#line 3988
  goto ldv_67553;
  ldv_67552: 
#line 3993
  tmp = atomic_read((atomic_t const   *)(& fcport->state));
#line 3993
  if ((tmp != 4 && fcport->login_retry != 0) && (fcport->flags & 8U) == 0U) {
#line 3995
    fcport->login_retry = fcport->login_retry - 1;
#line 3996
    if ((int )fcport->flags & 1) {
#line 3997
      if ((fcport->flags & 4U) != 0U) {
#line 3998
        (*((ha->isp_ops)->fabric_logout))(vha, (int )fcport->loop_id, (int )fcport->d_id.b.domain,
                                          (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
      } else {

      }
#line 4004
      if ((unsigned int )fcport->loop_id == 4096U) {
#line 4005
        next_loopid = ha->min_external_loopid;
#line 4005
        fcport->loop_id = next_loopid;
#line 4007
        status = qla2x00_find_new_loop_id(vha, fcport);
#line 4009
        if (status != 0) {
#line 4011
          goto ldv_67548;
        } else {

        }
      } else {

      }
#line 4015
      if ((((((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 16U) != 0U) || (ha->device_type & 32U) != 0U) || (ha->device_type & 64U) != 0U) || (ha->device_type & 134217728U) != 0U) {
#line 4016
        fcport->flags = fcport->flags | 8U;
#line 4017
        data[0] = 0U;
#line 4018
        data[1] = 1U;
#line 4019
        status = qla2x00_post_async_login_work(vha, fcport, (uint16_t *)(& data));
#line 4021
        if (status == 0) {
#line 4022
          goto ldv_67549;
        } else {

        }
#line 4024
        status = 1;
      } else {
#line 4026
        status = qla2x00_fabric_login(vha, fcport, & next_loopid);
#line 4028
        if (status == 0) {
#line 4032
          opts = 0U;
#line 4033
          if ((fcport->flags & 4U) != 0U) {
#line 4035
            opts = (uint8_t )((unsigned int )opts | 2U);
          } else {

          }
#line 4036
          status2 = qla2x00_get_port_database(vha, fcport, (int )opts);
#line 4039
          if (status2 != 0) {
#line 4040
            status = 1;
          } else {

          }
        } else {

        }
      }
    } else {
#line 4044
      status = qla2x00_local_device_login(vha, fcport);
    }
#line 4047
    if (status == 0) {
#line 4048
      fcport->old_loop_id = fcport->loop_id;
#line 4050
      ql_dbg(268435456U, vha, 8195, "Port login OK: logged in ID 0x%x.\n", (int )fcport->loop_id);
#line 4054
      qla2x00_update_fcport(vha, fcport);
    } else
#line 4056
    if (status == 1) {
#line 4057
      set_bit(8L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4059
      ql_dbg(268435456U, vha, 8199, "Retrying %d login again loop_id 0x%x.\n", fcport->login_retry,
             (int )fcport->loop_id);
    } else {
#line 4063
      fcport->login_retry = 0;
    }
#line 4066
    if (fcport->login_retry == 0 && status != 0) {
#line 4067
      qla2x00_clear_loop_id(fcport);
    } else {

    }
  } else {

  }
#line 4069
  tmp___0 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 4069
  if (tmp___0 != 0) {
#line 4070
    goto ldv_67548;
  } else {

  }
  ldv_67549: 
#line 3988
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 3988
  fcport = (fc_port_t *)__mptr___0;
  ldv_67553: ;
#line 3988
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 3990
    goto ldv_67552;
  } else {

  }
  ldv_67548: ;
#line 3995
  return;
}
}
#line 4076 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
void qla83xx_schedule_work(scsi_qla_host_t *base_vha , int work_code ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 4078
  ha = base_vha->hw;
#line 4080
  switch (work_code) {
  case 33280: ;
#line 4082
  if ((unsigned long )ha->dpc_lp_wq != (unsigned long )((struct workqueue_struct *)0)) {
#line 4083
    queue_work(ha->dpc_lp_wq, & ha->idc_aen);
  } else {

  }
#line 4084
  goto ldv_67560;
  case 1: ;
#line 4087
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 4088
    if ((unsigned long )ha->dpc_hp_wq != (unsigned long )((struct workqueue_struct *)0)) {
#line 4089
      queue_work(ha->dpc_hp_wq, & ha->nic_core_reset);
    } else {

    }
  } else {
#line 4091
    ql_dbg(524288U, base_vha, 45150, "NIC Core reset is already active. Skip scheduling it again.\n");
  }
#line 4094
  goto ldv_67560;
  case 2: ;
#line 4096
  if ((unsigned long )ha->dpc_hp_wq != (unsigned long )((struct workqueue_struct *)0)) {
#line 4097
    queue_work(ha->dpc_hp_wq, & ha->idc_state_handler);
  } else {

  }
#line 4098
  goto ldv_67560;
  case 3: ;
#line 4100
  if ((unsigned long )ha->dpc_hp_wq != (unsigned long )((struct workqueue_struct *)0)) {
#line 4101
    queue_work(ha->dpc_hp_wq, & ha->nic_core_unrecoverable);
  } else {

  }
#line 4102
  goto ldv_67560;
  default: 
#line 4104
  ql_log(1U, base_vha, 45151, "Unknown work-code=0x%x.\n", work_code);
  }
  ldv_67560: ;
#line 4108
  return;
}
}
#line 4113 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
void qla83xx_nic_core_unrecoverable_work(struct work_struct *work ) 
{ 
  struct qla_hw_data *ha ;
  struct work_struct  const  *__mptr ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  uint32_t dev_state ;

  {
#line 4116
  __mptr = (struct work_struct  const  *)work;
#line 4116
  ha = (struct qla_hw_data *)__mptr + 0xfffffffffffff320UL;
#line 4117
  tmp = pci_get_drvdata(ha->pdev);
#line 4117
  base_vha = (scsi_qla_host_t *)tmp;
#line 4118
  dev_state = 0U;
#line 4120
  qla83xx_idc_lock(base_vha, 0);
#line 4121
  qla83xx_rd_reg(base_vha, 571483012U, & dev_state);
#line 4122
  qla83xx_reset_ownership(base_vha);
#line 4123
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 4124
    ha->flags.nic_core_reset_owner = 0U;
#line 4125
    qla83xx_wr_reg(base_vha, 571483012U, 6U);
#line 4127
    ql_log(2U, base_vha, 45152, "HW State: FAILED.\n");
#line 4128
    qla83xx_schedule_work(base_vha, 2);
  } else {

  }
#line 4130
  qla83xx_idc_unlock(base_vha, 0);
#line 4131
  return;
}
}
#line 4135 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
void qla83xx_idc_state_handler_work(struct work_struct *work ) 
{ 
  struct qla_hw_data *ha ;
  struct work_struct  const  *__mptr ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  uint32_t dev_state ;

  {
#line 4138
  __mptr = (struct work_struct  const  *)work;
#line 4138
  ha = (struct qla_hw_data *)__mptr + 0xfffffffffffff370UL;
#line 4139
  tmp = pci_get_drvdata(ha->pdev);
#line 4139
  base_vha = (scsi_qla_host_t *)tmp;
#line 4140
  dev_state = 0U;
#line 4142
  qla83xx_idc_lock(base_vha, 0);
#line 4143
  qla83xx_rd_reg(base_vha, 571483012U, & dev_state);
#line 4144
  if (dev_state == 6U || dev_state == 5U) {
#line 4146
    qla83xx_idc_state_handler(base_vha);
  } else {

  }
#line 4147
  qla83xx_idc_unlock(base_vha, 0);
#line 4148
  return;
}
}
#line 4151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int qla83xx_check_nic_core_fw_alive(scsi_qla_host_t *base_vha ) 
{ 
  int rval ;
  unsigned long heart_beat_wait ;
  uint32_t heart_beat_counter1 ;
  uint32_t heart_beat_counter2 ;

  {
#line 4153
  rval = 0;
#line 4154
  heart_beat_wait = (unsigned long )jiffies + 250UL;
  ldv_67595: ;
#line 4158
  if ((long )(heart_beat_wait - (unsigned long )jiffies) < 0L) {
#line 4159
    ql_dbg(524288U, base_vha, 45180, "Nic Core f/w is not alive.\n");
#line 4161
    rval = 258;
#line 4162
    goto ldv_67594;
  } else {

  }
#line 4165
  qla83xx_idc_lock(base_vha, 0);
#line 4166
  qla83xx_rd_reg(base_vha, 571482288U, & heart_beat_counter1);
#line 4168
  qla83xx_idc_unlock(base_vha, 0);
#line 4169
  msleep(100U);
#line 4170
  qla83xx_idc_lock(base_vha, 0);
#line 4171
  qla83xx_rd_reg(base_vha, 571482288U, & heart_beat_counter2);
#line 4173
  qla83xx_idc_unlock(base_vha, 0);
#line 4174
  if (heart_beat_counter1 == heart_beat_counter2) {
#line 4176
    goto ldv_67595;
  } else {

  }
  ldv_67594: ;
#line 4176
  return (rval);
}
}
#line 4181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
void qla83xx_nic_core_reset_work(struct work_struct *work ) 
{ 
  struct qla_hw_data *ha ;
  struct work_struct  const  *__mptr ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  uint32_t dev_state ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 4184
  __mptr = (struct work_struct  const  *)work;
#line 4184
  ha = (struct qla_hw_data *)__mptr + 0xfffffffffffff3c0UL;
#line 4185
  tmp = pci_get_drvdata(ha->pdev);
#line 4185
  base_vha = (scsi_qla_host_t *)tmp;
#line 4186
  dev_state = 0U;
#line 4188
  if ((ha->device_type & 32768U) != 0U) {
#line 4189
    tmp___0 = qla2xxx_mctp_dump(base_vha);
#line 4189
    if (tmp___0 != 0) {
#line 4190
      ql_log(1U, base_vha, 45185, "Failed to dump mctp\n");
    } else {

    }
#line 4192
    return;
  } else {

  }
#line 4195
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 4196
    tmp___1 = qla83xx_check_nic_core_fw_alive(base_vha);
#line 4196
    if (tmp___1 == 0) {
#line 4197
      qla83xx_idc_lock(base_vha, 0);
#line 4198
      qla83xx_rd_reg(base_vha, 571483012U, & dev_state);
#line 4200
      qla83xx_idc_unlock(base_vha, 0);
#line 4201
      if (dev_state != 4U) {
#line 4202
        ql_dbg(524288U, base_vha, 45178, "Nic Core f/w is alive.\n");
#line 4204
        return;
      } else {

      }
    } else {

    }
#line 4208
    ha->flags.nic_core_reset_hdlr_active = 1U;
#line 4209
    tmp___2 = qla83xx_nic_core_reset(base_vha);
#line 4209
    if (tmp___2 != 0) {
#line 4211
      ql_dbg(524288U, base_vha, 45153, "NIC Core reset failed.\n");
    } else {

    }
#line 4214
    ha->flags.nic_core_reset_hdlr_active = 0U;
  } else {

  }
#line 4216
  return;
}
}
#line 4220 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
void qla83xx_service_idc_aen(struct work_struct *work ) 
{ 
  struct qla_hw_data *ha ;
  struct work_struct  const  *__mptr ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  uint32_t dev_state ;
  uint32_t idc_control ;
  int tmp___0 ;

  {
#line 4223
  __mptr = (struct work_struct  const  *)work;
#line 4223
  ha = (struct qla_hw_data *)__mptr + 0xfffffffffffff418UL;
#line 4224
  tmp = pci_get_drvdata(ha->pdev);
#line 4224
  base_vha = (scsi_qla_host_t *)tmp;
#line 4227
  qla83xx_idc_lock(base_vha, 0);
#line 4228
  qla83xx_rd_reg(base_vha, 571483012U, & dev_state);
#line 4229
  qla83xx_rd_reg(base_vha, 571483024U, & idc_control);
#line 4230
  qla83xx_idc_unlock(base_vha, 0);
#line 4231
  if (dev_state == 4U) {
#line 4232
    if ((idc_control & 2U) != 0U) {
#line 4233
      ql_dbg(524288U, base_vha, 45154, "Application requested NIC Core Reset.\n");
#line 4235
      qla83xx_schedule_work(base_vha, 1);
    } else {
#line 4236
      tmp___0 = qla83xx_check_nic_core_fw_alive(base_vha);
#line 4236
      if (tmp___0 == 0) {
#line 4238
        ql_dbg(524288U, base_vha, 45179, "Other protocol driver requested NIC Core Reset.\n");
#line 4240
        qla83xx_schedule_work(base_vha, 1);
      } else {

      }
    }
  } else
#line 4242
  if (dev_state == 6U || dev_state == 5U) {
#line 4244
    qla83xx_schedule_work(base_vha, 2);
  } else {

  }
#line 4245
  return;
}
}
#line 4249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla83xx_wait_logic(void) 
{ 
  int i ;
  int tmp ;

  {
#line 4254
  tmp = preempt_count();
#line 4254
  if (((unsigned long )tmp & 2096896UL) == 0UL) {
#line 4260
    msleep(100U);
#line 4261
    schedule();
  } else {
#line 4263
    i = 0;
#line 4263
    goto ldv_67618;
    ldv_67617: 
#line 4264
    cpu_relax();
#line 4263
    i = i + 1;
    ldv_67618: ;
#line 4263
    if (i <= 19) {
#line 4265
      goto ldv_67617;
    } else {

    }

  }
#line 4271
  return;
}
}
#line 4269 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int qla83xx_force_lock_recovery(scsi_qla_host_t *base_vha ) 
{ 
  int rval ;
  uint32_t data ;
  uint32_t idc_lck_rcvry_stage_mask ;
  uint32_t idc_lck_rcvry_owner_mask ;
  struct qla_hw_data *ha ;

  {
#line 4273
  idc_lck_rcvry_stage_mask = 3U;
#line 4274
  idc_lck_rcvry_owner_mask = 60U;
#line 4275
  ha = base_vha->hw;
#line 4276
  ql_dbg(524288U, base_vha, 45190, "Trying force recovery of the IDC lock.\n");
#line 4279
  rval = qla83xx_rd_reg(base_vha, 571483036U, & data);
#line 4280
  if (rval != 0) {
#line 4281
    return (rval);
  } else {

  }
#line 4283
  if ((data & idc_lck_rcvry_stage_mask) != 0U) {
#line 4284
    return (0);
  } else {
#line 4286
    data = (uint32_t )(((int )ha->portnum << 2) | 1);
#line 4287
    rval = qla83xx_wr_reg(base_vha, 571483036U, data);
#line 4289
    if (rval != 0) {
#line 4290
      return (rval);
    } else {

    }
#line 4292
    msleep(200U);
#line 4294
    rval = qla83xx_rd_reg(base_vha, 571483036U, & data);
#line 4296
    if (rval != 0) {
#line 4297
      return (rval);
    } else {

    }
#line 4299
    if ((data & idc_lck_rcvry_owner_mask) >> 2 == (uint32_t )ha->portnum) {
#line 4300
      data = (~ idc_lck_rcvry_stage_mask | 2U) & data;
#line 4302
      rval = qla83xx_wr_reg(base_vha, 571483036U, data);
#line 4304
      if (rval != 0) {
#line 4305
        return (rval);
      } else {

      }
#line 4308
      rval = qla83xx_rd_reg(base_vha, 2165424172U, & data);
#line 4310
      if (rval != 0) {
#line 4311
        return (rval);
      } else {

      }
#line 4313
      rval = qla83xx_wr_reg(base_vha, 571482372U, 255U);
#line 4315
      if (rval != 0) {
#line 4316
        return (rval);
      } else {

      }
#line 4318
      rval = qla83xx_wr_reg(base_vha, 571483036U, 0U);
#line 4320
      if (rval != 0) {
#line 4321
        return (rval);
      } else {

      }
    } else {
#line 4323
      return (0);
    }
  }
#line 4326
  return (rval);
}
}
#line 4330 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int qla83xx_idc_lock_recovery(scsi_qla_host_t *base_vha ) 
{ 
  int rval ;
  uint32_t o_drv_lockid ;
  uint32_t n_drv_lockid ;
  unsigned long lock_recovery_timeout ;
  int tmp ;

  {
#line 4332
  rval = 0;
#line 4336
  lock_recovery_timeout = (unsigned long )jiffies + 500UL;
  retry_lockid: 
#line 4338
  rval = qla83xx_rd_reg(base_vha, 571482372U, & o_drv_lockid);
#line 4339
  if (rval != 0) {
#line 4340
    goto exit;
  } else {

  }
#line 4343
  if ((long )((unsigned long )jiffies - lock_recovery_timeout) >= 0L) {
#line 4344
    tmp = qla83xx_force_lock_recovery(base_vha);
#line 4344
    if (tmp == 0) {
#line 4345
      return (0);
    } else {
#line 4347
      return (258);
    }
  } else {

  }
#line 4350
  rval = qla83xx_rd_reg(base_vha, 571482372U, & n_drv_lockid);
#line 4351
  if (rval != 0) {
#line 4352
    goto exit;
  } else {

  }
#line 4354
  if (o_drv_lockid == n_drv_lockid) {
#line 4355
    qla83xx_wait_logic();
#line 4356
    goto retry_lockid;
  } else {
#line 4358
    return (0);
  }
  exit: ;
#line 4361
  return (rval);
}
}
#line 4365 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
void qla83xx_idc_lock(scsi_qla_host_t *base_vha , uint16_t requester_id ) 
{ 
  uint16_t options ;
  uint32_t data ;
  uint32_t lock_owner ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 4367
  options = (uint16_t )((int )((short )((int )requester_id << 15)) | 64);
#line 4370
  ha = base_vha->hw;
  retry_lock: 
#line 4374
  tmp___0 = qla83xx_rd_reg(base_vha, 2165424168U, & data);
#line 4374
  if (tmp___0 == 0) {
#line 4376
    if (data != 0U) {
#line 4378
      qla83xx_wr_reg(base_vha, 571482372U, (uint32_t )ha->portnum);
    } else {
#line 4381
      qla83xx_rd_reg(base_vha, 571482372U, & lock_owner);
#line 4383
      ql_dbg(524288U, base_vha, 45155, "Failed to acquire IDC lock, acquired by %d, retrying...\n",
             lock_owner);
#line 4388
      tmp = qla83xx_idc_lock_recovery(base_vha);
#line 4388
      if (tmp == 0) {
#line 4390
        qla83xx_wait_logic();
#line 4391
        goto retry_lock;
      } else {
#line 4393
        ql_log(1U, base_vha, 45173, "IDC Lock recovery FAILED.\n");
      }
    }
  } else {

  }
#line 4399
  return;
  retry_lock2: 
#line 4403
  tmp___2 = qla83xx_access_control(base_vha, (int )options, 0U, 0U, (uint16_t *)0U);
#line 4403
  if (tmp___2 != 0) {
#line 4404
    ql_dbg(524288U, base_vha, 45170, "Failed to acquire IDC lock. retrying...\n");
#line 4407
    tmp___1 = qla83xx_idc_lock_recovery(base_vha);
#line 4407
    if (tmp___1 == 0) {
#line 4408
      qla83xx_wait_logic();
#line 4409
      goto retry_lock2;
    } else {
#line 4411
      ql_log(1U, base_vha, 45174, "IDC Lock recovery FAILED.\n");
    }
  } else {

  }
#line 4415
  return;
}
}
#line 4419 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
void qla83xx_idc_unlock(scsi_qla_host_t *base_vha , uint16_t requester_id ) 
{ 
  uint16_t retry ;
  uint32_t data ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 4426
  ha = base_vha->hw;
#line 4431
  retry = 0U;
  retry_unlock: 
#line 4433
  tmp = qla83xx_rd_reg(base_vha, 571482372U, & data);
#line 4433
  if (tmp == 0) {
#line 4435
    if ((uint32_t )ha->portnum == data) {
#line 4436
      qla83xx_rd_reg(base_vha, 2165424172U, & data);
#line 4438
      qla83xx_wr_reg(base_vha, 571482372U, 255U);
    } else
#line 4439
    if ((unsigned int )retry <= 9U) {
#line 4443
      qla83xx_wait_logic();
#line 4444
      retry = (uint16_t )((int )retry + 1);
#line 4445
      ql_dbg(524288U, base_vha, 45156, "Failed to release IDC lock, retyring=%d\n",
             (int )retry);
#line 4447
      goto retry_unlock;
    } else {

    }
  } else
#line 4449
  if ((unsigned int )retry <= 9U) {
#line 4451
    qla83xx_wait_logic();
#line 4452
    retry = (uint16_t )((int )retry + 1);
#line 4453
    ql_dbg(524288U, base_vha, 45157, "Failed to read drv-lockid, retyring=%d\n", (int )retry);
#line 4455
    goto retry_unlock;
  } else {

  }
#line 4458
  return;
}
}
#line 4480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int __qla83xx_set_drv_presence(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  uint32_t drv_presence ;

  {
#line 4482
  rval = 0;
#line 4483
  ha = vha->hw;
#line 4486
  rval = qla83xx_rd_reg(vha, 571483016U, & drv_presence);
#line 4487
  if (rval == 0) {
#line 4488
    drv_presence = (uint32_t )(1 << (int )ha->portnum) | drv_presence;
#line 4489
    rval = qla83xx_wr_reg(vha, 571483016U, drv_presence);
  } else {

  }
#line 4493
  return (rval);
}
}
#line 4497 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int qla83xx_set_drv_presence(scsi_qla_host_t *vha ) 
{ 
  int rval ;

  {
#line 4499
  rval = 0;
#line 4501
  qla83xx_idc_lock(vha, 0);
#line 4502
  rval = __qla83xx_set_drv_presence(vha);
#line 4503
  qla83xx_idc_unlock(vha, 0);
#line 4505
  return (rval);
}
}
#line 4509 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int __qla83xx_clear_drv_presence(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  uint32_t drv_presence ;

  {
#line 4511
  rval = 0;
#line 4512
  ha = vha->hw;
#line 4515
  rval = qla83xx_rd_reg(vha, 571483016U, & drv_presence);
#line 4516
  if (rval == 0) {
#line 4517
    drv_presence = (uint32_t )(~ (1 << (int )ha->portnum)) & drv_presence;
#line 4518
    rval = qla83xx_wr_reg(vha, 571483016U, drv_presence);
  } else {

  }
#line 4522
  return (rval);
}
}
#line 4526 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int qla83xx_clear_drv_presence(scsi_qla_host_t *vha ) 
{ 
  int rval ;

  {
#line 4528
  rval = 0;
#line 4530
  qla83xx_idc_lock(vha, 0);
#line 4531
  rval = __qla83xx_clear_drv_presence(vha);
#line 4532
  qla83xx_idc_unlock(vha, 0);
#line 4534
  return (rval);
}
}
#line 4538 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla83xx_need_reset_handler(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t drv_ack ;
  uint32_t drv_presence ;
  unsigned long ack_timeout ;

  {
#line 4540
  ha = vha->hw;
#line 4545
  ack_timeout = (unsigned long )(ha->fcoe_reset_timeout * 250U) + (unsigned long )jiffies;
  ldv_67695: 
#line 4547
  qla83xx_rd_reg(vha, 571483020U, & drv_ack);
#line 4548
  qla83xx_rd_reg(vha, 571483016U, & drv_presence);
#line 4549
  if ((drv_ack & drv_presence) == drv_presence) {
#line 4550
    goto ldv_67688;
  } else {

  }
#line 4552
  if ((long )((unsigned long )jiffies - ack_timeout) >= 0L) {
#line 4553
    ql_log(1U, vha, 45159, "RESET ACK TIMEOUT! drv_presence=0x%x drv_ack=0x%x\n",
           drv_presence, drv_ack);
#line 4561
    if (drv_ack != drv_presence) {
#line 4562
      qla83xx_wr_reg(vha, 571483016U, drv_ack);
    } else {

    }
#line 4564
    goto ldv_67688;
  } else {

  }
#line 4567
  qla83xx_idc_unlock(vha, 0);
#line 4568
  msleep(1000U);
#line 4569
  qla83xx_idc_lock(vha, 0);
#line 4570
  goto ldv_67695;
  ldv_67688: 
#line 4572
  qla83xx_wr_reg(vha, 571483012U, 1U);
#line 4573
  ql_log(2U, vha, 45160, "HW State: COLD/RE-INIT.\n");
#line 4574
  return;
}
}
#line 4577 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int qla83xx_device_bootstrap(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  uint32_t idc_control ;

  {
#line 4579
  rval = 0;
#line 4582
  qla83xx_wr_reg(vha, 571483012U, 2U);
#line 4583
  ql_log(2U, vha, 45161, "HW State: INITIALIZING.\n");
#line 4586
  __qla83xx_get_idc_control(vha, & idc_control);
#line 4587
  idc_control = idc_control & 4294967293U;
#line 4588
  __qla83xx_set_idc_control(vha, 0U);
#line 4590
  qla83xx_idc_unlock(vha, 0);
#line 4591
  rval = qla83xx_restart_nic_firmware(vha);
#line 4592
  qla83xx_idc_lock(vha, 0);
#line 4594
  if (rval != 0) {
#line 4595
    ql_log(0U, vha, 45162, "Failed to restart NIC f/w.\n");
#line 4597
    qla83xx_wr_reg(vha, 571483012U, 6U);
#line 4598
    ql_log(2U, vha, 45163, "HW State: FAILED.\n");
  } else {
#line 4600
    ql_dbg(524288U, vha, 45164, "Success in restarting nic f/w.\n");
#line 4602
    qla83xx_wr_reg(vha, 571483012U, 3U);
#line 4603
    ql_log(2U, vha, 45165, "HW State: READY.\n");
  }
#line 4606
  return (rval);
}
}
#line 4611 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
int qla83xx_idc_state_handler(scsi_qla_host_t *base_vha ) 
{ 
  struct qla_hw_data *ha ;
  int rval ;
  unsigned long dev_init_timeout ;
  uint32_t dev_state ;

  {
#line 4613
  ha = base_vha->hw;
#line 4614
  rval = 0;
#line 4619
  dev_init_timeout = (unsigned long )(ha->fcoe_dev_init_timeout * 250U) + (unsigned long )jiffies;
  ldv_67725: ;
#line 4623
  if ((long )((unsigned long )jiffies - dev_init_timeout) >= 0L) {
#line 4624
    ql_log(1U, base_vha, 45166, "Initialization TIMEOUT!\n");
#line 4629
    qla83xx_wr_reg(base_vha, 571483012U, 6U);
#line 4631
    ql_log(2U, base_vha, 45167, "HW State: FAILED.\n");
  } else {

  }
#line 4635
  qla83xx_rd_reg(base_vha, 571483012U, & dev_state);
#line 4636
  switch (dev_state) {
  case 3U: ;
#line 4638
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 4639
    qla83xx_idc_audit(base_vha, 1);
  } else {

  }
#line 4641
  ha->flags.nic_core_reset_owner = 0U;
#line 4642
  ql_dbg(524288U, base_vha, 45168, "Reset_owner reset by 0x%x.\n", (int )ha->portnum);
#line 4645
  goto exit;
  case 1U: ;
#line 4647
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 4648
    rval = qla83xx_device_bootstrap(base_vha);
  } else {
#line 4651
    qla83xx_idc_unlock(base_vha, 0);
#line 4652
    msleep(1000U);
#line 4653
    qla83xx_idc_lock(base_vha, 0);
  }
#line 4655
  goto ldv_67717;
  case 2U: 
#line 4658
  qla83xx_idc_unlock(base_vha, 0);
#line 4659
  msleep(1000U);
#line 4660
  qla83xx_idc_lock(base_vha, 0);
#line 4661
  goto ldv_67717;
  case 4U: ;
#line 4663
  if (ql2xdontresethba == 0 && *((unsigned long *)ha + 2UL) != 0UL) {
#line 4664
    qla83xx_need_reset_handler(base_vha);
  } else {
#line 4667
    qla83xx_idc_unlock(base_vha, 0);
#line 4668
    msleep(1000U);
#line 4669
    qla83xx_idc_lock(base_vha, 0);
  }
#line 4672
  dev_init_timeout = (unsigned long )(ha->fcoe_dev_init_timeout * 250U) + (unsigned long )jiffies;
#line 4674
  goto ldv_67717;
  case 5U: 
#line 4677
  qla83xx_idc_unlock(base_vha, 0);
#line 4678
  msleep(1000U);
#line 4679
  qla83xx_idc_lock(base_vha, 0);
#line 4680
  goto ldv_67717;
  case 7U: ;
#line 4683
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 4684
    goto exit;
  } else {

  }
#line 4686
  qla83xx_idc_unlock(base_vha, 0);
#line 4687
  msleep(1000U);
#line 4688
  qla83xx_idc_lock(base_vha, 0);
#line 4689
  dev_init_timeout = (unsigned long )(ha->fcoe_dev_init_timeout * 250U) + (unsigned long )jiffies;
#line 4691
  goto ldv_67717;
  case 6U: ;
#line 4693
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 4694
    qla83xx_idc_audit(base_vha, 1);
  } else {

  }
#line 4696
  ha->flags.nic_core_reset_owner = 0U;
#line 4697
  __qla83xx_clear_drv_presence(base_vha);
#line 4698
  qla83xx_idc_unlock(base_vha, 0);
#line 4699
  qla8xxx_dev_failed_handler(base_vha);
#line 4700
  rval = 258;
#line 4701
  qla83xx_idc_lock(base_vha, 0);
#line 4702
  goto exit;
  case 3134241488U: 
#line 4704
  qla83xx_idc_unlock(base_vha, 0);
#line 4705
  msleep(1000U);
#line 4706
  qla83xx_idc_lock(base_vha, 0);
#line 4707
  goto ldv_67717;
  default: 
#line 4709
  ql_log(1U, base_vha, 45169, "Unknown Device State: %x.\n", dev_state);
#line 4711
  qla83xx_idc_unlock(base_vha, 0);
#line 4712
  qla8xxx_dev_failed_handler(base_vha);
#line 4713
  rval = 258;
#line 4714
  qla83xx_idc_lock(base_vha, 0);
#line 4715
  goto exit;
  }
  ldv_67717: ;
#line 4717
  goto ldv_67725;
  exit: ;
#line 4720
  return (rval);
}
}
#line 4724 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
void qla2x00_disable_board_on_pci_error(struct work_struct *work ) 
{ 
  struct qla_hw_data *ha ;
  struct work_struct  const  *__mptr ;
  struct pci_dev *pdev ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;

  {
#line 4726
  __mptr = (struct work_struct  const  *)work;
#line 4726
  ha = (struct qla_hw_data *)__mptr + 0xfffffffffffff2d0UL;
#line 4728
  pdev = ha->pdev;
#line 4729
  tmp = pci_get_drvdata(ha->pdev);
#line 4729
  base_vha = (scsi_qla_host_t *)tmp;
#line 4731
  ql_log(1U, base_vha, 347, "Disabling adapter.\n");
#line 4734
  set_bit(15L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 4736
  qla2x00_delete_all_vps(ha, base_vha);
#line 4738
  qla2x00_abort_all_cmds(base_vha, 65536);
#line 4740
  qla2x00_dfs_remove(base_vha);
#line 4742
  qla84xx_put_chip(base_vha);
#line 4744
  if (base_vha->timer_active != 0U) {
#line 4745
    qla2x00_stop_timer(base_vha);
  } else {

  }
#line 4747
  base_vha->flags.online = 0U;
#line 4749
  qla2x00_destroy_deferred_work(ha);
#line 4755
  qla2x00_free_sysfs_attr(base_vha, 0);
#line 4757
  fc_remove_host(base_vha->host);
#line 4759
  ldv_scsi_remove_host_26(base_vha->host);
#line 4761
  base_vha->flags.init_done = 0U;
#line 4762
  qla25xx_delete_queues(base_vha);
#line 4763
  qla2x00_free_irqs(base_vha);
#line 4764
  qla2x00_free_fcports(base_vha);
#line 4765
  qla2x00_mem_free(ha);
#line 4766
  qla82xx_md_free(base_vha);
#line 4767
  qla2x00_free_queues(ha);
#line 4769
  qla2x00_unmap_iobases(ha);
#line 4771
  pci_release_selected_regions(ha->pdev, ha->bars);
#line 4772
  pci_disable_pcie_error_reporting(pdev);
#line 4773
  pci_disable_device(pdev);
#line 4774
  return;
}
}
#line 4794 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int qla2x00_do_dpc(void *data ) 
{ 
  int rval ;
  scsi_qla_host_t *base_vha ;
  struct qla_hw_data *ha ;
  void *tmp ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  long volatile   __ret ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  struct task_struct *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int ret ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  struct task_struct *tmp___34 ;
  long volatile   __ret___0 ;
  struct task_struct *tmp___35 ;
  struct task_struct *tmp___36 ;
  struct task_struct *tmp___37 ;
  struct task_struct *tmp___38 ;
  bool tmp___39 ;
  int tmp___40 ;
  struct task_struct *tmp___41 ;
  struct task_struct *tmp___42 ;

  {
#line 4800
  ha = (struct qla_hw_data *)data;
#line 4801
  tmp = pci_get_drvdata(ha->pdev);
#line 4801
  base_vha = (scsi_qla_host_t *)tmp;
#line 4803
  tmp___0 = get_current();
#line 4803
  set_user_nice(tmp___0, -20L);
#line 4805
  tmp___1 = get_current();
#line 4805
  tmp___1->task_state_change = 0UL;
#line 4805
  __ret = 1L;
#line 4805
  switch (8UL) {
  case 1UL: 
#line 4805
  tmp___2 = get_current();
#line 4805
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
#line 4805
  goto ldv_67742;
  case 2UL: 
#line 4805
  tmp___3 = get_current();
#line 4805
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
#line 4805
  goto ldv_67742;
  case 4UL: 
#line 4805
  tmp___4 = get_current();
#line 4805
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___4->state): : "memory",
                       "cc");
#line 4805
  goto ldv_67742;
  case 8UL: 
#line 4805
  tmp___5 = get_current();
#line 4805
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___5->state): : "memory",
                       "cc");
#line 4805
  goto ldv_67742;
  default: 
#line 4805
  __xchg_wrong_size();
  }
  ldv_67742: ;
#line 4806
  goto ldv_67749;
  ldv_67761: 
#line 4807
  ql_dbg(67108864U, base_vha, 16384, "DPC handler sleeping.\n");
#line 4810
  schedule();
#line 4812
  if (*((unsigned long *)base_vha + 19UL) == 0UL || *((unsigned long *)ha + 2UL) != 0UL) {
#line 4813
    goto end_loop;
  } else {

  }
#line 4815
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 4816
    ql_dbg(67108864U, base_vha, 16387, "eeh_busy=%d.\n", (int )ha->flags.eeh_busy);
#line 4818
    goto end_loop;
  } else {

  }
#line 4821
  ha->dpc_active = 1U;
#line 4823
  ql_dbg(67141632U, base_vha, 16385, "DPC handler waking up, dpc_flags=0x%lx.\n",
         base_vha->dpc_flags);
#line 4827
  qla2x00_do_work(base_vha);
#line 4829
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 4830
    if ((ha->device_type & 262144U) != 0U) {
#line 4831
      tmp___6 = test_and_clear_bit(17L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 4831
      if (tmp___6 != 0) {
#line 4833
        qla8044_idc_lock(ha);
#line 4834
        qla8044_wr_direct(base_vha, 4U, 6U);
#line 4837
        qla8044_idc_unlock(ha);
#line 4838
        ql_log(2U, base_vha, 16388, "HW State: FAILED.\n");
#line 4840
        qla8044_device_state_handler(base_vha);
#line 4841
        goto ldv_67749;
      } else {

      }
    } else {
#line 4845
      tmp___7 = test_and_clear_bit(17L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 4845
      if (tmp___7 != 0) {
#line 4847
        qla82xx_idc_lock(ha);
#line 4848
        qla82xx_wr_32(ha, 136323392UL, 6U);
#line 4850
        qla82xx_idc_unlock(ha);
#line 4851
        ql_log(2U, base_vha, 337, "HW State: FAILED.\n");
#line 4853
        qla82xx_device_state_handler(base_vha);
#line 4854
        goto ldv_67749;
      } else {

      }
    }
#line 4858
    tmp___10 = test_and_clear_bit(18L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 4858
    if (tmp___10 != 0) {
#line 4861
      ql_dbg(67108864U, base_vha, 16389, "FCoE context reset scheduled.\n");
#line 4863
      tmp___9 = test_and_set_bit(3L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 4863
      if (tmp___9 == 0) {
#line 4865
        tmp___8 = qla82xx_fcoe_ctx_reset(base_vha);
#line 4865
        if (tmp___8 != 0) {
#line 4869
          set_bit(2L, (unsigned long volatile   *)(& base_vha->dpc_flags));
        } else {

        }
#line 4872
        clear_bit(3L, (unsigned long volatile   *)(& base_vha->dpc_flags));
      } else {

      }
#line 4876
      ql_dbg(67108864U, base_vha, 16390, "FCoE context reset end.\n");
    } else {

    }
  } else
#line 4879
  if ((ha->device_type & 131072U) != 0U) {
#line 4880
    tmp___13 = test_and_clear_bit(17L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 4880
    if (tmp___13 != 0) {
#line 4882
      ql_dbg(67108864U, base_vha, 16416, "Firmware Reset Recovery\n");
#line 4884
      tmp___12 = qlafx00_reset_initialize(base_vha);
#line 4884
      if (tmp___12 != 0) {
#line 4886
        tmp___11 = constant_test_bit(15L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 4886
        if (tmp___11 == 0) {
#line 4888
          set_bit(17L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 4890
          ql_dbg(67108864U, base_vha, 16417, "Reset Recovery Failed\n");
        } else {

        }
      } else {

      }
    } else {

    }
#line 4897
    tmp___16 = test_and_clear_bit(24L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 4897
    if (tmp___16 != 0) {
#line 4899
      ql_dbg(67108864U, base_vha, 16418, "ISPFx00 Target Scan scheduled\n");
#line 4901
      tmp___15 = qlafx00_rescan_isp(base_vha);
#line 4901
      if (tmp___15 != 0) {
#line 4902
        tmp___14 = constant_test_bit(15L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 4902
        if (tmp___14 == 0) {
#line 4904
          set_bit(17L, (unsigned long volatile   *)(& base_vha->dpc_flags));
        } else {

        }
#line 4906
        ql_dbg(67108864U, base_vha, 16414, "ISPFx00 Target Scan Failed\n");
      } else {

      }
#line 4909
      ql_dbg(67108864U, base_vha, 16415, "ISPFx00 Target Scan End\n");
    } else {

    }
#line 4912
    tmp___17 = test_and_clear_bit(26L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 4912
    if (tmp___17 != 0) {
#line 4914
      ql_dbg(67108864U, base_vha, 16419, "ISPFx00 Host Info resend scheduled\n");
#line 4916
      qlafx00_fx_disc(base_vha, & (base_vha->hw)->mr.fcport, 153);
    } else {

    }
  } else {

  }
#line 4922
  tmp___20 = test_and_clear_bit(2L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 4922
  if (tmp___20 != 0) {
#line 4925
    ql_dbg(67108864U, base_vha, 16391, "ISP abort scheduled.\n");
#line 4927
    tmp___19 = test_and_set_bit(3L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 4927
    if (tmp___19 == 0) {
#line 4930
      tmp___18 = (*((ha->isp_ops)->abort_isp))(base_vha);
#line 4930
      if (tmp___18 != 0) {
#line 4932
        set_bit(2L, (unsigned long volatile   *)(& base_vha->dpc_flags));
      } else {

      }
#line 4935
      clear_bit(3L, (unsigned long volatile   *)(& base_vha->dpc_flags));
    } else {

    }
#line 4939
    ql_dbg(67108864U, base_vha, 16392, "ISP abort end.\n");
  } else {

  }
#line 4943
  tmp___21 = test_and_clear_bit(13L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 4943
  if (tmp___21 != 0) {
#line 4945
    qla2x00_update_fcports(base_vha);
  } else {

  }
#line 4948
  tmp___22 = constant_test_bit(21L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 4948
  if (tmp___22 != 0) {
#line 4950
    ret = qla2x00_send_change_request(base_vha, 3, 0);
#line 4951
    if (ret != 0) {
#line 4952
      ql_log(1U, base_vha, 289, "Failed to enable receiving of RSCN requests: 0x%x.\n",
             ret);
    } else {

    }
#line 4955
    clear_bit(21L, (unsigned long volatile   *)(& base_vha->dpc_flags));
  } else {

  }
#line 4958
  if ((ha->device_type & 131072U) != 0U) {
#line 4959
    goto loop_resync_check;
  } else {

  }
#line 4961
  tmp___23 = constant_test_bit(20L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 4961
  if (tmp___23 != 0) {
#line 4962
    ql_dbg(67108864U, base_vha, 16393, "Quiescence mode scheduled.\n");
#line 4964
    if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 4965
      if ((ha->device_type & 16384U) != 0U) {
#line 4966
        qla82xx_device_state_handler(base_vha);
      } else {

      }
#line 4967
      if ((ha->device_type & 262144U) != 0U) {
#line 4968
        qla8044_device_state_handler(base_vha);
      } else {

      }
#line 4969
      clear_bit(20L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 4971
      if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 4972
        qla2x00_perform_loop_resync(base_vha);
#line 4973
        if ((ha->device_type & 16384U) != 0U) {
#line 4974
          qla82xx_idc_lock(ha);
#line 4975
          qla82xx_clear_qsnt_ready(base_vha);
#line 4977
          qla82xx_idc_unlock(ha);
        } else
#line 4978
        if ((ha->device_type & 262144U) != 0U) {
#line 4979
          qla8044_idc_lock(ha);
#line 4980
          qla8044_clear_qsnt_ready(base_vha);
#line 4982
          qla8044_idc_unlock(ha);
        } else {

        }
      } else {

      }
    } else {
#line 4986
      clear_bit(20L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 4988
      qla2x00_quiesce_io(base_vha);
    }
#line 4990
    ql_dbg(67108864U, base_vha, 16394, "Quiescence mode end.\n");
  } else {

  }
#line 4994
  tmp___24 = test_and_clear_bit(0L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 4994
  if (tmp___24 != 0) {
#line 4994
    tmp___25 = test_and_set_bit(1L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 4994
    if (tmp___25 == 0) {
#line 4998
      ql_dbg(67108864U, base_vha, 16395, "Reset marker scheduled.\n");
#line 5000
      qla2x00_rst_aen(base_vha);
#line 5001
      clear_bit(1L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5002
      ql_dbg(67108864U, base_vha, 16396, "Reset marker end.\n");
    } else {

    }
  } else {

  }
#line 5007
  tmp___26 = test_and_clear_bit(8L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5007
  if (tmp___26 != 0) {
#line 5007
    tmp___27 = constant_test_bit(4L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 5007
    if (tmp___27 == 0) {
#line 5007
      tmp___28 = atomic_read((atomic_t const   *)(& base_vha->loop_state));
#line 5007
      if (tmp___28 != 2) {
#line 5012
        ql_dbg(67108864U, base_vha, 16397, "Relogin scheduled.\n");
#line 5014
        qla2x00_relogin(base_vha);
#line 5015
        ql_dbg(67108864U, base_vha, 16398, "Relogin end.\n");
      } else {

      }
    } else {

    }
  } else {

  }
  loop_resync_check: 
#line 5019
  tmp___30 = test_and_clear_bit(4L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5019
  if (tmp___30 != 0) {
#line 5022
    ql_dbg(67108864U, base_vha, 16399, "Loop resync scheduled.\n");
#line 5025
    tmp___29 = test_and_set_bit(5L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5025
    if (tmp___29 == 0) {
#line 5028
      rval = qla2x00_loop_resync(base_vha);
#line 5030
      clear_bit(5L, (unsigned long volatile   *)(& base_vha->dpc_flags));
    } else {

    }
#line 5034
    ql_dbg(67108864U, base_vha, 16400, "Loop resync end.\n");
  } else {

  }
#line 5038
  if ((ha->device_type & 131072U) != 0U) {
#line 5039
    goto intr_on_check;
  } else {

  }
#line 5041
  tmp___31 = constant_test_bit(16L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 5041
  if (tmp___31 != 0) {
#line 5041
    tmp___32 = atomic_read((atomic_t const   *)(& base_vha->loop_state));
#line 5041
    if (tmp___32 == 5) {
#line 5043
      clear_bit(16L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5044
      qla2xxx_flash_npiv_conf(base_vha);
    } else {

    }
  } else {

  }
  intr_on_check: ;
#line 5048
  if ((unsigned int )ha->interrupts_on == 0U) {
#line 5049
    (*((ha->isp_ops)->enable_intrs))(ha);
  } else {

  }
#line 5051
  tmp___33 = test_and_clear_bit(11L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5051
  if (tmp___33 != 0) {
#line 5053
    if ((unsigned int )ha->beacon_blink_led == 1U) {
#line 5054
      (*((ha->isp_ops)->beacon_blink))(base_vha);
    } else {

    }
  } else {

  }
#line 5057
  if ((ha->device_type & 131072U) == 0U) {
#line 5058
    qla2x00_do_dpc_all_vps(base_vha);
  } else {

  }
#line 5060
  ha->dpc_active = 0U;
  end_loop: 
#line 5062
  tmp___34 = get_current();
#line 5062
  tmp___34->task_state_change = 0UL;
#line 5062
  __ret___0 = 1L;
#line 5062
  switch (8UL) {
  case 1UL: 
#line 5062
  tmp___35 = get_current();
#line 5062
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret___0), "+m" (tmp___35->state): : "memory",
                       "cc");
#line 5062
  goto ldv_67755;
  case 2UL: 
#line 5062
  tmp___36 = get_current();
#line 5062
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret___0), "+m" (tmp___36->state): : "memory",
                       "cc");
#line 5062
  goto ldv_67755;
  case 4UL: 
#line 5062
  tmp___37 = get_current();
#line 5062
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret___0), "+m" (tmp___37->state): : "memory",
                       "cc");
#line 5062
  goto ldv_67755;
  case 8UL: 
#line 5062
  tmp___38 = get_current();
#line 5062
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret___0), "+m" (tmp___38->state): : "memory",
                       "cc");
#line 5062
  goto ldv_67755;
  default: 
#line 5062
  __xchg_wrong_size();
  }
  ldv_67755: ;
  ldv_67749: 
#line 4806
  tmp___39 = kthread_should_stop();
#line 4806
  if (tmp___39) {
#line 4806
    tmp___40 = 0;
  } else {
#line 4806
    tmp___40 = 1;
  }
#line 4806
  if (tmp___40) {
#line 4808
    goto ldv_67761;
  } else {

  }
#line 5064
  tmp___41 = get_current();
#line 5064
  tmp___41->task_state_change = 0UL;
#line 5064
  tmp___42 = get_current();
#line 5064
  tmp___42->state = 0L;
#line 5066
  ql_dbg(67108864U, base_vha, 16401, "DPC handler exiting.\n");
#line 5072
  ha->dpc_active = 0U;
#line 5075
  qla2x00_abort_all_cmds(base_vha, 65536);
#line 5077
  return (0);
}
}
#line 5081 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
void qla2xxx_wake_dpc(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct task_struct *t ;
  int tmp ;

  {
#line 5083
  ha = vha->hw;
#line 5084
  t = ha->dpc_thread;
#line 5086
  tmp = constant_test_bit(15L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5086
  if (tmp == 0 && (unsigned long )t != (unsigned long )((struct task_struct *)0)) {
#line 5087
    wake_up_process(t);
  } else {

  }
#line 5088
  return;
}
}
#line 5098 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla2x00_rst_aen(scsi_qla_host_t *vha ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 5100
  if (*((unsigned long *)vha + 19UL) != 0UL && *((unsigned long *)vha + 19UL) == 0UL) {
#line 5100
    tmp___1 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 5100
    if (tmp___1 == 0) {
#line 5100
      tmp___2 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5100
      if (tmp___2 == 0) {
        ldv_67771: 
#line 5104
        clear_bit(0L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 5110
        vha->marker_needed = 1U;
#line 5112
        tmp = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 5112
        if (tmp == 0) {
#line 5112
          tmp___0 = constant_test_bit(0L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5112
          if (tmp___0 != 0) {
#line 5113
            goto ldv_67771;
          } else {
#line 5116
            goto ldv_67772;
          }
        } else {

        }
        ldv_67772: ;
      } else {

      }
    } else {

    }
  } else {

  }
#line 5119
  return;
}
}
#line 5125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
void qla2x00_timer(scsi_qla_host_t *vha ) 
{ 
  unsigned long cpu_flags ;
  int start_dpc ;
  int index ;
  srb_t *sp ;
  uint16_t w ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  int tmp ;
  int tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  fc_port_t *sfcp ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;

  {
#line 5127
  cpu_flags = 0UL;
#line 5128
  start_dpc = 0;
#line 5132
  ha = vha->hw;
#line 5135
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 5136
    ql_dbg(16777216U, vha, 24576, "EEH = %d, restarting timer.\n", (int )ha->flags.eeh_busy);
#line 5139
    qla2x00_restart_timer(vha, 1UL);
#line 5140
    return;
  } else {

  }
#line 5147
  tmp = pci_channel_offline(ha->pdev);
#line 5147
  if (tmp == 0) {
#line 5148
    pci_read_config_word((struct pci_dev  const  *)ha->pdev, 0, & w);
#line 5149
    qla2x00_check_reg16_for_disconnect(vha, (int )w);
  } else {

  }
#line 5153
  if ((unsigned int )vha->vp_idx == 0U && ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U)) {
#line 5154
    tmp___0 = constant_test_bit(20L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5154
    if (tmp___0 != 0) {
#line 5155
      start_dpc = start_dpc + 1;
    } else {

    }
#line 5156
    if ((ha->device_type & 16384U) != 0U) {
#line 5157
      qla82xx_watchdog(vha);
    } else
#line 5158
    if ((ha->device_type & 262144U) != 0U) {
#line 5159
      qla8044_watchdog(vha);
    } else {

    }
  } else {

  }
#line 5162
  if ((unsigned int )vha->vp_idx == 0U && (ha->device_type & 131072U) != 0U) {
#line 5163
    qlafx00_timer_routine(vha);
  } else {

  }
#line 5166
  tmp___5 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 5166
  if (tmp___5 > 0) {
#line 5166
    tmp___6 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5166
    if (tmp___6 == 0) {
#line 5166
      tmp___7 = constant_test_bit(18L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5166
      if (tmp___7 == 0) {
#line 5166
        if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 5171
          tmp___2 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 5171
          if (tmp___2 == (int )vha->loop_down_abort_time) {
#line 5174
            ql_log(2U, vha, 24584, "Loop down - aborting the queues before time expires.\n");
#line 5177
            if ((ha->device_type & 1U) == 0U && (unsigned int )vha->link_down_timeout != 0U) {
#line 5178
              atomic_set(& vha->loop_state, 6);
            } else {

            }
#line 5185
            if ((unsigned int )vha->vp_idx == 0U) {
#line 5186
              tmp___1 = spinlock_check(& ha->hardware_lock);
#line 5186
              cpu_flags = _raw_spin_lock_irqsave(tmp___1);
#line 5188
              req = *(ha->req_q_map);
#line 5189
              index = 1;
#line 5189
              goto ldv_67790;
              ldv_67789: 
#line 5194
              sp = *(req->outstanding_cmds + (unsigned long )index);
#line 5195
              if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 5196
                goto ldv_67787;
              } else {

              }
#line 5197
              if ((unsigned int )sp->type != 8U) {
#line 5198
                goto ldv_67787;
              } else {

              }
#line 5199
              sfcp = sp->fcport;
#line 5200
              if ((sfcp->flags & 4U) == 0U) {
#line 5201
                goto ldv_67787;
              } else {

              }
#line 5203
              if ((ha->device_type & 16384U) != 0U) {
#line 5204
                set_bit(18L, (unsigned long volatile   *)(& vha->dpc_flags));
              } else {
#line 5207
                set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
              }
#line 5209
              goto ldv_67788;
              ldv_67787: 
#line 5191
              index = index + 1;
              ldv_67790: ;
#line 5189
              if ((int )req->num_outstanding_cmds > index) {
#line 5192
                goto ldv_67789;
              } else {

              }
              ldv_67788: 
#line 5211
              spin_unlock_irqrestore(& ha->hardware_lock, cpu_flags);
            } else {

            }
#line 5214
            start_dpc = start_dpc + 1;
          } else {

          }
#line 5218
          tmp___3 = atomic_dec_and_test(& vha->loop_down_timer);
#line 5218
          if (tmp___3 != 0) {
#line 5219
            if ((vha->device_flags & 2U) == 0U) {
#line 5220
              ql_log(1U, vha, 24585, "Loop down - aborting ISP.\n");
#line 5223
              if ((ha->device_type & 16384U) != 0U) {
#line 5224
                set_bit(18L, (unsigned long volatile   *)(& vha->dpc_flags));
              } else {
#line 5227
                set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
              }
            } else {

            }
          } else {

          }
#line 5231
          tmp___4 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 5231
          ql_dbg(16777216U, vha, 24586, "Loop down - seconds remaining %d.\n", tmp___4);
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 5236
  if ((unsigned int )vha->vp_idx == 0U && (unsigned int )ha->beacon_blink_led == 1U) {
#line 5238
    if ((ha->device_type & 16384U) == 0U && (ha->device_type & 262144U) == 0U) {
#line 5239
      set_bit(11L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 5240
      start_dpc = start_dpc + 1;
    } else {

    }
  } else {

  }
#line 5245
  tmp___8 = list_empty((struct list_head  const  *)(& vha->work_list));
#line 5245
  if (tmp___8 == 0) {
#line 5246
    start_dpc = start_dpc + 1;
  } else {

  }
#line 5249
  tmp___18 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5249
  if (tmp___18 != 0) {
#line 5249
    goto _L;
  } else {
#line 5249
    tmp___19 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5249
    if (tmp___19 != 0) {
#line 5249
      goto _L;
    } else {
#line 5249
      tmp___20 = constant_test_bit(13L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5249
      if (tmp___20 != 0) {
#line 5249
        goto _L;
      } else
#line 5249
      if (start_dpc != 0) {
#line 5249
        goto _L;
      } else {
#line 5249
        tmp___21 = constant_test_bit(0L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5249
        if (tmp___21 != 0) {
#line 5249
          goto _L;
        } else {
#line 5249
          tmp___22 = constant_test_bit(11L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5249
          if (tmp___22 != 0) {
#line 5249
            goto _L;
          } else {
#line 5249
            tmp___23 = constant_test_bit(17L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5249
            if (tmp___23 != 0) {
#line 5249
              goto _L;
            } else {
#line 5249
              tmp___24 = constant_test_bit(18L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5249
              if (tmp___24 != 0) {
#line 5249
                goto _L;
              } else {
#line 5249
                tmp___25 = constant_test_bit(14L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5249
                if (tmp___25 != 0) {
#line 5249
                  goto _L;
                } else {
#line 5249
                  tmp___26 = constant_test_bit(8L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5249
                  if (tmp___26 != 0) {
                    _L: /* CIL Label */ 
#line 5259
                    tmp___9 = constant_test_bit(0L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5259
                    tmp___10 = constant_test_bit(13L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5259
                    tmp___11 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5259
                    tmp___12 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5259
                    ql_dbg(16777216U, vha, 24587, "isp_abort_needed=%d loop_resync_needed=%d fcport_update_needed=%d start_dpc=%d reset_marker_needed=%d",
                           tmp___12, tmp___11, tmp___10, start_dpc, tmp___9);
#line 5268
                    tmp___13 = constant_test_bit(8L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5268
                    tmp___14 = constant_test_bit(14L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5268
                    tmp___15 = constant_test_bit(18L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5268
                    tmp___16 = constant_test_bit(17L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5268
                    tmp___17 = constant_test_bit(11L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5268
                    ql_dbg(16777216U, vha, 24588, "beacon_blink_needed=%d isp_unrecoverable=%d fcoe_ctx_reset_needed=%d vp_dpc_needed=%d relogin_needed=%d.\n",
                           tmp___17, tmp___16, tmp___15, tmp___14, tmp___13);
#line 5277
                    qla2xxx_wake_dpc(vha);
                  } else {

                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 5280
  qla2x00_restart_timer(vha, 1UL);
#line 5281
  return;
}
}
#line 5311 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static struct mutex qla_fw_lock  =    {{1}, {{{{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "qla_fw_lock.wait_lock",
                                                          0, 0UL}}}}, {& qla_fw_lock.wait_list,
                                                                       & qla_fw_lock.wait_list},
    0, (void *)(& qla_fw_lock), {0, {0, 0}, "qla_fw_lock", 0, 0UL}};
#line 5313 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static struct fw_blob qla_fw_blobs[11U]  = 
#line 5313
  {      {(char *)"ql2100_fw.bin", {4096U, 0U}, 0}, 
        {(char *)"ql2200_fw.bin", {4096U, 0U}, 0}, 
        {(char *)"ql2300_fw.bin", {2048U, 0U}, 0}, 
        {(char *)"ql2322_fw.bin", {2048U, 114688U, 122880U, 0U}, 0}, 
        {(char *)"ql2400_fw.bin", {0U, 0U, 0U, 0U}, 0}, 
        {(char *)"ql2500_fw.bin", {0U, 0U, 0U, 0U}, 0}, 
        {(char *)"ql8100_fw.bin", {0U, 0U, 0U, 0U}, 0}, 
        {(char *)"ql8200_fw.bin", {0U, 0U, 0U, 0U}, 0}, 
        {(char *)"ql2600_fw.bin", {0U, 0U, 0U, 0U}, 0}, 
        {(char *)"ql8300_fw.bin", {0U, 0U, 0U, 0U}, 0}, 
        {(char *)"ql2700_fw.bin", {0U, 0U, 0U, 0U}, 0}};
#line 5328 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
struct fw_blob *qla2x00_request_firmware(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct fw_blob *blob ;
  int tmp ;

  {
#line 5330
  ha = vha->hw;
#line 5333
  if ((int )ha->device_type & 1) {
#line 5334
    blob = (struct fw_blob *)(& qla_fw_blobs);
  } else
#line 5335
  if ((ha->device_type & 2U) != 0U) {
#line 5336
    blob = (struct fw_blob *)(& qla_fw_blobs) + 1UL;
  } else
#line 5337
  if (((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 32U) != 0U) {
#line 5338
    blob = (struct fw_blob *)(& qla_fw_blobs) + 2UL;
  } else
#line 5339
  if ((ha->device_type & 16U) != 0U || (ha->device_type & 64U) != 0U) {
#line 5340
    blob = (struct fw_blob *)(& qla_fw_blobs) + 3UL;
  } else
#line 5341
  if ((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || ((ha->device_type & 512U) != 0U || (ha->device_type & 1024U) != 0U)) || (ha->device_type & 4096U) != 0U) {
#line 5342
    blob = (struct fw_blob *)(& qla_fw_blobs) + 4UL;
  } else
#line 5343
  if ((ha->device_type & 2048U) != 0U) {
#line 5344
    blob = (struct fw_blob *)(& qla_fw_blobs) + 5UL;
  } else
#line 5345
  if ((ha->device_type & 8192U) != 0U) {
#line 5346
    blob = (struct fw_blob *)(& qla_fw_blobs) + 6UL;
  } else
#line 5347
  if ((ha->device_type & 16384U) != 0U) {
#line 5348
    blob = (struct fw_blob *)(& qla_fw_blobs) + 7UL;
  } else
#line 5349
  if ((ha->device_type & 32768U) != 0U) {
#line 5350
    blob = (struct fw_blob *)(& qla_fw_blobs) + 8UL;
  } else
#line 5351
  if ((ha->device_type & 65536U) != 0U) {
#line 5352
    blob = (struct fw_blob *)(& qla_fw_blobs) + 9UL;
  } else
#line 5353
  if ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) {
#line 5354
    blob = (struct fw_blob *)(& qla_fw_blobs) + 10UL;
  } else {
#line 5356
    return ((struct fw_blob *)0);
  }
#line 5359
  mutex_lock_nested(& qla_fw_lock, 0U);
#line 5360
  if ((unsigned long )blob->fw != (unsigned long )((struct firmware  const  *)0)) {
#line 5361
    goto out;
  } else {

  }
#line 5363
  tmp = request_firmware(& blob->fw, (char const   *)blob->name, & (ha->pdev)->dev);
#line 5363
  if (tmp != 0) {
#line 5364
    ql_log(1U, vha, 99, "Failed to load firmware image (%s).\n", blob->name);
#line 5366
    blob->fw = (struct firmware  const  *)0;
#line 5367
    blob = (struct fw_blob *)0;
#line 5368
    goto out;
  } else {

  }
  out: 
#line 5372
  mutex_unlock(& qla_fw_lock);
#line 5373
  return (blob);
}
}
#line 5377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla2x00_release_firmware(void) 
{ 
  int idx ;

  {
#line 5381
  mutex_lock_nested(& qla_fw_lock, 0U);
#line 5382
  idx = 0;
#line 5382
  goto ldv_67805;
  ldv_67804: 
#line 5383
  release_firmware(qla_fw_blobs[idx].fw);
#line 5382
  idx = idx + 1;
  ldv_67805: ;
#line 5382
  if (idx <= 10) {
#line 5384
    goto ldv_67804;
  } else {

  }
#line 5384
  mutex_unlock(& qla_fw_lock);
#line 5385
  return;
}
}
#line 5388 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static pci_ers_result_t qla2xxx_pci_error_detected(struct pci_dev *pdev , pci_channel_state_t state ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;

  {
#line 5390
  tmp = pci_get_drvdata(pdev);
#line 5390
  vha = (scsi_qla_host_t *)tmp;
#line 5391
  ha = vha->hw;
#line 5393
  ql_dbg(2097152U, vha, 36864, "PCI error detected, state %x.\n", state);
#line 5396
  switch (state) {
  case 1U: 
#line 5398
  ha->flags.eeh_busy = 0U;
#line 5399
  return (2U);
  case 2U: 
#line 5401
  ha->flags.eeh_busy = 1U;
#line 5403
  if ((ha->device_type & 16384U) != 0U) {
#line 5404
    ha->flags.isp82xx_fw_hung = 1U;
#line 5405
    ql_dbg(2097152U, vha, 36865, "Pci channel io frozen\n");
#line 5406
    qla82xx_clear_pending_mbx(vha);
  } else {

  }
#line 5408
  qla2x00_free_irqs(vha);
#line 5409
  pci_disable_device(pdev);
#line 5411
  qla2x00_abort_all_cmds(vha, 524288);
#line 5412
  return (3U);
  case 3U: 
#line 5414
  ha->flags.pci_channel_io_perm_failure = 1U;
#line 5415
  qla2x00_abort_all_cmds(vha, 65536);
#line 5416
  return (4U);
  }
#line 5418
  return (3U);
}
}
#line 5422 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static pci_ers_result_t qla2xxx_pci_mmio_enabled(struct pci_dev *pdev ) 
{ 
  int risc_paused ;
  uint32_t stat ;
  unsigned long flags ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  struct device_reg_24xx *reg24 ;
  raw_spinlock_t *tmp___0 ;

  {
#line 5424
  risc_paused = 0;
#line 5427
  tmp = pci_get_drvdata(pdev);
#line 5427
  base_vha = (scsi_qla_host_t *)tmp;
#line 5428
  ha = base_vha->hw;
#line 5429
  reg = & (ha->iobase)->isp;
#line 5430
  reg24 = & (ha->iobase)->isp24;
#line 5432
  if ((ha->device_type & 16384U) != 0U) {
#line 5433
    return (5U);
  } else {

  }
#line 5435
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 5435
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 5436
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 5437
    stat = readl((void const volatile   *)(& reg->hccr));
#line 5438
    if ((stat & 32U) != 0U) {
#line 5439
      risc_paused = 1;
    } else {

    }
  } else
#line 5440
  if (((((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 16U) != 0U) || (ha->device_type & 32U) != 0U) || (ha->device_type & 64U) != 0U) {
#line 5441
    stat = readl((void const volatile   *)(& reg->u.isp2300.host_status));
#line 5442
    if ((stat & 256U) != 0U) {
#line 5443
      risc_paused = 1;
    } else {

    }
  } else
#line 5444
  if ((ha->device_type & 134217728U) != 0U) {
#line 5445
    stat = readl((void const volatile   *)(& reg24->host_status));
#line 5446
    if ((stat & 256U) != 0U) {
#line 5447
      risc_paused = 1;
    } else {

    }
  } else {

  }
#line 5449
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 5451
  if (risc_paused != 0) {
#line 5452
    ql_log(2U, base_vha, 36867, "RISC paused -- mmio_enabled, Dumping firmware.\n");
#line 5454
    (*((ha->isp_ops)->fw_dump))(base_vha, 0);
#line 5456
    return (3U);
  } else {
#line 5458
    return (5U);
  }
}
}
#line 5462 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static uint32_t qla82xx_error_recovery(scsi_qla_host_t *base_vha ) 
{ 
  uint32_t rval ;
  uint32_t drv_active ;
  struct qla_hw_data *ha ;
  int fn ;
  struct pci_dev *other_pdev ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 5464
  rval = 258U;
#line 5465
  drv_active = 0U;
#line 5466
  ha = base_vha->hw;
#line 5468
  other_pdev = (struct pci_dev *)0;
#line 5470
  ql_dbg(2097152U, base_vha, 36870, "Entered %s.\n", "qla82xx_error_recovery");
#line 5473
  set_bit(3L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5475
  if (*((unsigned long *)base_vha + 19UL) != 0UL) {
#line 5478
    qla2x00_abort_isp_cleanup(base_vha);
  } else {

  }
#line 5482
  fn = (int )(ha->pdev)->devfn & 7;
#line 5483
  goto ldv_67838;
  ldv_67840: 
#line 5484
  fn = fn - 1;
#line 5485
  ql_dbg(2097152U, base_vha, 36871, "Finding pci device at function = 0x%x.\n", fn);
#line 5487
  tmp = pci_domain_nr((ha->pdev)->bus);
#line 5487
  other_pdev = pci_get_domain_bus_and_slot(tmp, (unsigned int )((ha->pdev)->bus)->number,
                                           ((ha->pdev)->devfn & 248U) | ((unsigned int )fn & 7U));
#line 5492
  if ((unsigned long )other_pdev == (unsigned long )((struct pci_dev *)0)) {
#line 5493
    goto ldv_67838;
  } else {

  }
#line 5494
  tmp___0 = atomic_read((atomic_t const   *)(& other_pdev->enable_cnt));
#line 5494
  if (tmp___0 != 0) {
#line 5495
    ql_dbg(2097152U, base_vha, 36872, "Found PCI func available and enable at 0x%x.\n",
           fn);
#line 5498
    pci_dev_put(other_pdev);
#line 5499
    goto ldv_67839;
  } else {

  }
#line 5501
  pci_dev_put(other_pdev);
  ldv_67838: ;
#line 5483
  if (fn > 0) {
#line 5485
    goto ldv_67840;
  } else {

  }
  ldv_67839: ;
#line 5504
  if (fn == 0) {
#line 5506
    ql_dbg(2097152U, base_vha, 36873, "This devfn is reset owner = 0x%x.\n", (ha->pdev)->devfn);
#line 5509
    qla82xx_idc_lock(ha);
#line 5511
    qla82xx_wr_32(ha, 136323392UL, 2U);
#line 5514
    qla82xx_wr_32(ha, 136323444UL, 1U);
#line 5517
    tmp___1 = qla82xx_rd_32(ha, 136323384UL);
#line 5517
    drv_active = (uint32_t )tmp___1;
#line 5518
    ql_dbg(2097152U, base_vha, 36874, "drv_active = 0x%x.\n", drv_active);
#line 5521
    qla82xx_idc_unlock(ha);
#line 5525
    if (drv_active != 0U) {
#line 5526
      tmp___2 = qla82xx_start_firmware(base_vha);
#line 5526
      rval = (uint32_t )tmp___2;
    } else {
#line 5528
      rval = 0U;
    }
#line 5529
    qla82xx_idc_lock(ha);
#line 5531
    if (rval != 0U) {
#line 5532
      ql_log(2U, base_vha, 36875, "HW State: FAILED.\n");
#line 5534
      qla82xx_clear_drv_active(ha);
#line 5535
      qla82xx_wr_32(ha, 136323392UL, 6U);
    } else {
#line 5538
      ql_log(2U, base_vha, 36876, "HW State: READY.\n");
#line 5540
      qla82xx_wr_32(ha, 136323392UL, 3U);
#line 5542
      qla82xx_idc_unlock(ha);
#line 5543
      ha->flags.isp82xx_fw_hung = 0U;
#line 5544
      tmp___3 = qla82xx_restart_isp(base_vha);
#line 5544
      rval = (uint32_t )tmp___3;
#line 5545
      qla82xx_idc_lock(ha);
#line 5547
      qla82xx_wr_32(ha, 136323396UL, 0U);
#line 5548
      qla82xx_set_drv_active(base_vha);
    }
#line 5550
    qla82xx_idc_unlock(ha);
  } else {
#line 5552
    ql_dbg(2097152U, base_vha, 36877, "This devfn is not reset owner = 0x%x.\n", (ha->pdev)->devfn);
#line 5555
    tmp___5 = qla82xx_rd_32(ha, 136323392UL);
#line 5555
    if (tmp___5 == 3) {
#line 5557
      ha->flags.isp82xx_fw_hung = 0U;
#line 5558
      tmp___4 = qla82xx_restart_isp(base_vha);
#line 5558
      rval = (uint32_t )tmp___4;
#line 5559
      qla82xx_idc_lock(ha);
#line 5560
      qla82xx_set_drv_active(base_vha);
#line 5561
      qla82xx_idc_unlock(ha);
    } else {

    }
  }
#line 5564
  clear_bit(3L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5566
  return (rval);
}
}
#line 5570 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static pci_ers_result_t qla2xxx_pci_slot_reset(struct pci_dev *pdev ) 
{ 
  pci_ers_result_t ret ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  struct rsp_que *rsp ;
  int rc ;
  int retries ;
  int tmp___0 ;
  int tmp___1 ;
  uint32_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 5572
  ret = 4U;
#line 5573
  tmp = pci_get_drvdata(pdev);
#line 5573
  base_vha = (scsi_qla_host_t *)tmp;
#line 5574
  ha = base_vha->hw;
#line 5576
  retries = 10;
#line 5578
  ql_dbg(2097152U, base_vha, 36868, "Slot Reset.\n");
#line 5585
  pdev->error_state = 1U;
#line 5587
  pci_restore_state(pdev);
#line 5592
  pci_save_state(pdev);
#line 5594
  if (ha->mem_only != 0) {
#line 5595
    rc = pci_enable_device_mem(pdev);
  } else {
#line 5597
    rc = pci_enable_device(pdev);
  }
#line 5599
  if (rc != 0) {
#line 5600
    ql_log(1U, base_vha, 36869, "Can\'t re-enable PCI device after reset.\n");
#line 5602
    goto exit_slot_reset;
  } else {

  }
#line 5605
  rsp = *(ha->rsp_q_map);
#line 5606
  tmp___0 = qla2x00_request_irqs(ha, rsp);
#line 5606
  if (tmp___0 != 0) {
#line 5607
    goto exit_slot_reset;
  } else {

  }
#line 5609
  tmp___1 = (*((ha->isp_ops)->pci_config))(base_vha);
#line 5609
  if (tmp___1 != 0) {
#line 5610
    goto exit_slot_reset;
  } else {

  }
#line 5612
  if ((ha->device_type & 16384U) != 0U) {
#line 5613
    tmp___2 = qla82xx_error_recovery(base_vha);
#line 5613
    if (tmp___2 == 0U) {
#line 5614
      ret = 5U;
#line 5615
      goto exit_slot_reset;
    } else {
#line 5617
      goto exit_slot_reset;
    }
  } else {

  }
#line 5620
  goto ldv_67852;
  ldv_67851: 
#line 5621
  msleep(1000U);
  ldv_67852: ;
#line 5620
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 5620
    tmp___3 = retries;
#line 5620
    retries = retries - 1;
#line 5620
    if (tmp___3 != 0) {
#line 5622
      goto ldv_67851;
    } else {
#line 5625
      goto ldv_67853;
    }
  } else {

  }
  ldv_67853: 
#line 5623
  set_bit(3L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5624
  tmp___4 = (*((ha->isp_ops)->abort_isp))(base_vha);
#line 5624
  if (tmp___4 == 0) {
#line 5625
    ret = 5U;
  } else {

  }
#line 5626
  clear_bit(3L, (unsigned long volatile   *)(& base_vha->dpc_flags));
  exit_slot_reset: 
#line 5630
  ql_dbg(2097152U, base_vha, 36878, "slot_reset return %x.\n", ret);
#line 5633
  return (ret);
}
}
#line 5637 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla2xxx_pci_resume(struct pci_dev *pdev ) 
{ 
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int ret ;

  {
#line 5639
  tmp = pci_get_drvdata(pdev);
#line 5639
  base_vha = (scsi_qla_host_t *)tmp;
#line 5640
  ha = base_vha->hw;
#line 5643
  ql_dbg(2097152U, base_vha, 36879, "pci_resume.\n");
#line 5646
  ret = qla2x00_wait_for_hba_online(base_vha);
#line 5647
  if (ret != 0) {
#line 5648
    ql_log(0U, base_vha, 36866, "The device failed to resume I/O from slot/link_reset.\n");
  } else {

  }
#line 5652
  pci_cleanup_aer_uncorrect_error_status(pdev);
#line 5654
  ha->flags.eeh_busy = 0U;
#line 5655
  return;
}
}
#line 5658 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla83xx_disable_laser(scsi_qla_host_t *vha ) 
{ 
  uint32_t reg ;
  uint32_t data ;
  uint32_t fn ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *isp_reg ;
  unsigned int tmp ;

  {
#line 5661
  ha = vha->hw;
#line 5662
  isp_reg = & (ha->iobase)->isp24;
#line 5665
  ql_dbg(1073741824U, vha, 75, "Disabling Laser for hba: %p\n", vha);
#line 5668
  tmp = readl((void const volatile   *)(& isp_reg->ctrl_status));
#line 5668
  fn = tmp & 61440U;
#line 5671
  fn = fn >> 12;
#line 5673
  if ((int )fn & 1) {
#line 5674
    reg = 2102096U;
  } else {
#line 5676
    reg = 2102080U;
  }
#line 5678
  data = 25166208U;
#line 5680
  qla83xx_wr_reg(vha, reg, data);
#line 5681
  return;
}
}
#line 5683 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static struct pci_error_handlers  const  qla2xxx_err_handler  =    {(pci_ers_result_t (*)(struct pci_dev * , enum pci_channel_state  ))(& qla2xxx_pci_error_detected),
    & qla2xxx_pci_mmio_enabled, 0, & qla2xxx_pci_slot_reset, 0, & qla2xxx_pci_resume};
#line 5690 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static struct pci_device_id qla2xxx_pci_tbl[22U]  = 
#line 5690
  {      {4215U, 8448U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 8704U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 8960U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 8978U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 8994U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 25362U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 25378U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 9250U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 9266U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 33842U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 21538U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 21554U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 9522U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 8241U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 32769U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 32801U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 32817U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 61441U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 32836U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 8305U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 8817U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {0U, 0U, 0U, 0U, 0U, 0U, 0UL}};
#line 5714 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
struct pci_device_id  const  __mod_pci__qla2xxx_pci_tbl_device_table[22U]  ;
#line 5716 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static struct pci_driver qla2xxx_pci_driver  = 
#line 5716
     {{0, 0}, "qla2xxx", (struct pci_device_id  const  *)(& qla2xxx_pci_tbl), & qla2x00_probe_one,
    & qla2x00_remove_one, 0, 0, 0, 0, & qla2x00_shutdown, 0, & qla2xxx_err_handler,
    {0, 0, & __this_module, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {{{{{{0}},
                                                                               0U,
                                                                               0U,
                                                                               0,
                                                                               {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}}}},
                                                                            {0, 0}}};
#line 5728 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static struct file_operations  const  apidev_fops  = 
#line 5728
     {& __this_module, & noop_llseek, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 5737 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static int qla2x00_module_init(void) 
{ 
  int ret ;

  {
#line 5739
  ret = 0;
#line 5742
  srb_cachep = kmem_cache_create("qla2xxx_srbs", 376UL, 0UL, 8192UL, (void (*)(void * ))0);
#line 5744
  if ((unsigned long )srb_cachep == (unsigned long )((struct kmem_cache *)0)) {
#line 5745
    ql_log(0U, (scsi_qla_host_t *)0, 1, "Unable to allocate SRB cache...Failing load!.\n");
#line 5747
    return (-12);
  } else {

  }
#line 5751
  ret = qlt_init();
#line 5752
  if (ret < 0) {
#line 5753
    kmem_cache_destroy(srb_cachep);
#line 5754
    return (ret);
  } else
#line 5755
  if (ret > 0) {
#line 5761
    qla2xxx_transport_functions.disable_target_scan = 1U;
#line 5762
    qla2xxx_transport_vport_functions.disable_target_scan = 1U;
  } else {

  }
#line 5766
  strcpy((char *)(& qla2x00_version_str), "8.07.00.18-k");
#line 5767
  if (ql2xextended_error_logging != 0) {
#line 5768
    strcat((char *)(& qla2x00_version_str), "-debug");
  } else {

  }
#line 5770
  qla2xxx_transport_template = fc_attach_transport(& qla2xxx_transport_functions);
#line 5772
  if ((unsigned long )qla2xxx_transport_template == (unsigned long )((struct scsi_transport_template *)0)) {
#line 5773
    kmem_cache_destroy(srb_cachep);
#line 5774
    ql_log(0U, (scsi_qla_host_t *)0, 2, "fc_attach_transport failed...Failing load!.\n");
#line 5776
    qlt_exit();
#line 5777
    return (-19);
  } else {

  }
#line 5780
  apidev_major = ldv_register_chrdev_27(0U, "ql2xapidev", & apidev_fops);
#line 5781
  if (apidev_major < 0) {
#line 5782
    ql_log(0U, (scsi_qla_host_t *)0, 3, "Unable to register char device %s.\n", (char *)"ql2xapidev");
  } else {

  }
#line 5786
  qla2xxx_transport_vport_template = fc_attach_transport(& qla2xxx_transport_vport_functions);
#line 5788
  if ((unsigned long )qla2xxx_transport_vport_template == (unsigned long )((struct scsi_transport_template *)0)) {
#line 5789
    kmem_cache_destroy(srb_cachep);
#line 5790
    qlt_exit();
#line 5791
    fc_release_transport(qla2xxx_transport_template);
#line 5792
    ql_log(0U, (scsi_qla_host_t *)0, 4, "fc_attach_transport vport failed...Failing load!.\n");
#line 5794
    return (-19);
  } else {

  }
#line 5796
  ql_log(2U, (scsi_qla_host_t *)0, 5, "QLogic Fibre Channel HBA Driver: %s.\n", (char *)(& qla2x00_version_str));
#line 5799
  ret = ldv___pci_register_driver_28(& qla2xxx_pci_driver, & __this_module, "qla2xxx");
#line 5800
  if (ret != 0) {
#line 5801
    kmem_cache_destroy(srb_cachep);
#line 5802
    qlt_exit();
#line 5803
    fc_release_transport(qla2xxx_transport_template);
#line 5804
    fc_release_transport(qla2xxx_transport_vport_template);
#line 5805
    ql_log(0U, (scsi_qla_host_t *)0, 6, "pci_register_driver failed...ret=%d Failing load!.\n",
           ret);
  } else {

  }
#line 5809
  return (ret);
}
}
#line 5816 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.c"
static void qla2x00_module_exit(void) 
{ 


  {
#line 5818
  ldv_unregister_chrdev_29((unsigned int )apidev_major, "ql2xapidev");
#line 5819
  ldv_pci_unregister_driver_30(& qla2xxx_pci_driver);
#line 5820
  qla2x00_release_firmware();
#line 5821
  kmem_cache_destroy(srb_cachep);
#line 5822
  qlt_exit();
#line 5823
  if ((unsigned long )ctx_cachep != (unsigned long )((struct kmem_cache *)0)) {
#line 5824
    kmem_cache_destroy(ctx_cachep);
  } else {

  }
#line 5825
  fc_release_transport(qla2xxx_transport_template);
#line 5826
  fc_release_transport(qla2xxx_transport_vport_template);
#line 5827
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
extern int ldv_release_85(void) ;
#line 489
extern int ldv_probe_78(void) ;
#line 490
extern int ldv_release_86(void) ;
#line 491
extern int ldv_release_77(void) ;
#line 492
extern int ldv_release_80(void) ;
#line 493
extern int ldv_suspend_77(void) ;
#line 494
extern int ldv_probe_82(void) ;
#line 495
extern int ldv_probe_81(void) ;
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_retval_2  ;
#line 497
extern int ldv_release_87(void) ;
#line 498
extern int ldv_probe_87(void) ;
#line 499 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_retval_1  ;
#line 500
extern void ldv_initialize(void) ;
#line 501
extern int ldv_release_79(void) ;
#line 502
extern int ldv_probe_77(void) ;
#line 503
extern int ldv_probe_84(void) ;
#line 504
extern int ldv_probe_79(void) ;
#line 505
extern int ldv_probe_85(void) ;
#line 506
extern int ldv_release_84(void) ;
#line 507
extern int ldv_release_81(void) ;
#line 508
extern int ldv_release_78(void) ;
#line 509
extern int ldv_probe_86(void) ;
#line 510
extern int ldv_release_83(void) ;
#line 511
extern int ldv_probe_83(void) ;
#line 512
extern int ldv_open_75(void) ;
#line 513
extern int ldv_probe_80(void) ;
#line 514
extern int ldv_release_75(void) ;
#line 515
void ldv_check_final_state(void) ;
#line 516 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_retval_3  ;
#line 517
extern int ldv_release_82(void) ;
#line 520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void activate_work_5(struct work_struct *work , int state ) 
{ 


  {
#line 521
  if (ldv_work_5_0 == 0) {
#line 522
    ldv_work_struct_5_0 = work;
#line 523
    ldv_work_5_0 = state;
#line 524
    return;
  } else {

  }
#line 527
  if (ldv_work_5_1 == 0) {
#line 528
    ldv_work_struct_5_1 = work;
#line 529
    ldv_work_5_1 = state;
#line 530
    return;
  } else {

  }
#line 533
  if (ldv_work_5_2 == 0) {
#line 534
    ldv_work_struct_5_2 = work;
#line 535
    ldv_work_5_2 = state;
#line 536
    return;
  } else {

  }
#line 539
  if (ldv_work_5_3 == 0) {
#line 540
    ldv_work_struct_5_3 = work;
#line 541
    ldv_work_5_3 = state;
#line 542
    return;
  } else {

  }
#line 544
  return;
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void choose_timer_13(struct timer_list *timer ) 
{ 


  {
#line 548
  LDV_IN_INTERRUPT = 2;
#line 549
  (*(timer->function))(timer->data);
#line 550
  LDV_IN_INTERRUPT = 1;
#line 551
  ldv_timer_state_13 = 2;
#line 552
  return;
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_initialize_isp_operations_85(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 556
  tmp = ldv_init_zalloc(1360UL);
#line 556
  qla24xx_isp_ops_group0 = (struct scsi_qla_host *)tmp;
#line 557
  tmp___0 = ldv_init_zalloc(12288UL);
#line 557
  qla24xx_isp_ops_group1 = (struct qla_hw_data *)tmp___0;
#line 558
  tmp___1 = ldv_init_zalloc(136UL);
#line 558
  qla24xx_isp_ops_group2 = (struct fc_port *)tmp___1;
#line 559
  return;
}
}
#line 561 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_initialize_isp_operations_78(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 562
  tmp = ldv_init_zalloc(1360UL);
#line 562
  qla27xx_isp_ops_group0 = (struct scsi_qla_host *)tmp;
#line 563
  tmp___0 = ldv_init_zalloc(12288UL);
#line 563
  qla27xx_isp_ops_group1 = (struct qla_hw_data *)tmp___0;
#line 564
  tmp___1 = ldv_init_zalloc(136UL);
#line 564
  qla27xx_isp_ops_group2 = (struct fc_port *)tmp___1;
#line 565
  return;
}
}
#line 567 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void work_init_5(void) 
{ 


  {
#line 568
  ldv_work_5_0 = 0;
#line 569
  ldv_work_5_1 = 0;
#line 570
  ldv_work_5_2 = 0;
#line 571
  ldv_work_5_3 = 0;
#line 572
  return;
}
}
#line 575 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void call_and_disable_all_4(int state ) 
{ 


  {
#line 577
  if (ldv_work_4_0 == state) {
#line 578
    call_and_disable_work_4(ldv_work_struct_4_0);
  } else {

  }
#line 579
  if (ldv_work_4_1 == state) {
#line 580
    call_and_disable_work_4(ldv_work_struct_4_1);
  } else {

  }
#line 581
  if (ldv_work_4_2 == state) {
#line 582
    call_and_disable_work_4(ldv_work_struct_4_2);
  } else {

  }
#line 583
  if (ldv_work_4_3 == state) {
#line 584
    call_and_disable_work_4(ldv_work_struct_4_3);
  } else {

  }
#line 585
  return;
}
}
#line 588 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void activate_work_1(struct work_struct *work , int state ) 
{ 


  {
#line 589
  if (ldv_work_1_0 == 0) {
#line 590
    ldv_work_struct_1_0 = work;
#line 591
    ldv_work_1_0 = state;
#line 592
    return;
  } else {

  }
#line 595
  if (ldv_work_1_1 == 0) {
#line 596
    ldv_work_struct_1_1 = work;
#line 597
    ldv_work_1_1 = state;
#line 598
    return;
  } else {

  }
#line 601
  if (ldv_work_1_2 == 0) {
#line 602
    ldv_work_struct_1_2 = work;
#line 603
    ldv_work_1_2 = state;
#line 604
    return;
  } else {

  }
#line 607
  if (ldv_work_1_3 == 0) {
#line 608
    ldv_work_struct_1_3 = work;
#line 609
    ldv_work_1_3 = state;
#line 610
    return;
  } else {

  }
#line 612
  return;
}
}
#line 615 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_initialize_isp_operations_81(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 616
  tmp = ldv_init_zalloc(1360UL);
#line 616
  qla8044_isp_ops_group0 = (struct scsi_qla_host *)tmp;
#line 617
  tmp___0 = ldv_init_zalloc(12288UL);
#line 617
  qla8044_isp_ops_group1 = (struct qla_hw_data *)tmp___0;
#line 618
  tmp___1 = ldv_init_zalloc(136UL);
#line 618
  qla8044_isp_ops_group2 = (struct fc_port *)tmp___1;
#line 619
  return;
}
}
#line 621 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void call_and_disable_work_3(struct work_struct *work ) 
{ 


  {
#line 624
  if ((ldv_work_3_0 == 2 || ldv_work_3_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_0) {
#line 626
    qla83xx_nic_core_reset_work(work);
#line 627
    ldv_work_3_0 = 1;
#line 628
    return;
  } else {

  }
#line 630
  if ((ldv_work_3_1 == 2 || ldv_work_3_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_1) {
#line 632
    qla83xx_nic_core_reset_work(work);
#line 633
    ldv_work_3_1 = 1;
#line 634
    return;
  } else {

  }
#line 636
  if ((ldv_work_3_2 == 2 || ldv_work_3_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_2) {
#line 638
    qla83xx_nic_core_reset_work(work);
#line 639
    ldv_work_3_2 = 1;
#line 640
    return;
  } else {

  }
#line 642
  if ((ldv_work_3_3 == 2 || ldv_work_3_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_3) {
#line 644
    qla83xx_nic_core_reset_work(work);
#line 645
    ldv_work_3_3 = 1;
#line 646
    return;
  } else {

  }
#line 648
  return;
}
}
#line 651 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void disable_work_3(struct work_struct *work ) 
{ 


  {
#line 653
  if ((ldv_work_3_0 == 3 || ldv_work_3_0 == 2) && (unsigned long )ldv_work_struct_3_0 == (unsigned long )work) {
#line 655
    ldv_work_3_0 = 1;
  } else {

  }
#line 657
  if ((ldv_work_3_1 == 3 || ldv_work_3_1 == 2) && (unsigned long )ldv_work_struct_3_1 == (unsigned long )work) {
#line 659
    ldv_work_3_1 = 1;
  } else {

  }
#line 661
  if ((ldv_work_3_2 == 3 || ldv_work_3_2 == 2) && (unsigned long )ldv_work_struct_3_2 == (unsigned long )work) {
#line 663
    ldv_work_3_2 = 1;
  } else {

  }
#line 665
  if ((ldv_work_3_3 == 3 || ldv_work_3_3 == 2) && (unsigned long )ldv_work_struct_3_3 == (unsigned long )work) {
#line 667
    ldv_work_3_3 = 1;
  } else {

  }
#line 668
  return;
}
}
#line 672 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_initialize_isp_operations_82(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 673
  tmp = ldv_init_zalloc(1360UL);
#line 673
  qla82xx_isp_ops_group0 = (struct scsi_qla_host *)tmp;
#line 674
  tmp___0 = ldv_init_zalloc(12288UL);
#line 674
  qla82xx_isp_ops_group1 = (struct qla_hw_data *)tmp___0;
#line 675
  tmp___1 = ldv_init_zalloc(136UL);
#line 675
  qla82xx_isp_ops_group2 = (struct fc_port *)tmp___1;
#line 676
  return;
}
}
#line 678 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void work_init_1(void) 
{ 


  {
#line 679
  ldv_work_1_0 = 0;
#line 680
  ldv_work_1_1 = 0;
#line 681
  ldv_work_1_2 = 0;
#line 682
  ldv_work_1_3 = 0;
#line 683
  return;
}
}
#line 686 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void invoke_work_4(void) 
{ 
  int tmp ;

  {
#line 688
  tmp = __VERIFIER_nondet_int();
#line 688
  switch (tmp) {
  case 0: ;
#line 690
  if (ldv_work_4_0 == 2 || ldv_work_4_0 == 3) {
#line 691
    ldv_work_4_0 = 4;
#line 692
    qla83xx_idc_state_handler_work(ldv_work_struct_4_0);
#line 693
    ldv_work_4_0 = 1;
  } else {

  }
#line 696
  goto ldv_68006;
  case 1: ;
#line 698
  if (ldv_work_4_1 == 2 || ldv_work_4_1 == 3) {
#line 699
    ldv_work_4_1 = 4;
#line 700
    qla83xx_idc_state_handler_work(ldv_work_struct_4_0);
#line 701
    ldv_work_4_1 = 1;
  } else {

  }
#line 704
  goto ldv_68006;
  case 2: ;
#line 706
  if (ldv_work_4_2 == 2 || ldv_work_4_2 == 3) {
#line 707
    ldv_work_4_2 = 4;
#line 708
    qla83xx_idc_state_handler_work(ldv_work_struct_4_0);
#line 709
    ldv_work_4_2 = 1;
  } else {

  }
#line 712
  goto ldv_68006;
  case 3: ;
#line 714
  if (ldv_work_4_3 == 2 || ldv_work_4_3 == 3) {
#line 715
    ldv_work_4_3 = 4;
#line 716
    qla83xx_idc_state_handler_work(ldv_work_struct_4_0);
#line 717
    ldv_work_4_3 = 1;
  } else {

  }
#line 720
  goto ldv_68006;
  default: 
#line 721
  ldv_stop();
  }
  ldv_68006: ;
#line 723
  return;
}
}
#line 727 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void activate_pending_timer_13(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 727
  if ((unsigned long )ldv_timer_list_13 == (unsigned long )timer) {
#line 728
    if (ldv_timer_state_13 == 2 || pending_flag != 0) {
#line 729
      ldv_timer_list_13 = timer;
#line 730
      ldv_timer_list_13->data = data;
#line 731
      ldv_timer_state_13 = 1;
    } else {

    }
#line 733
    return;
  } else {

  }
#line 735
  reg_timer_13(timer);
#line 736
  ldv_timer_list_13->data = data;
#line 737
  return;
}
}
#line 740 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_pci_driver_76(void) 
{ 
  void *tmp ;

  {
#line 741
  tmp = ldv_init_zalloc(2976UL);
#line 741
  qla2xxx_pci_driver_group1 = (struct pci_dev *)tmp;
#line 742
  return;
}
}
#line 745 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void activate_work_2(struct work_struct *work , int state ) 
{ 


  {
#line 746
  if (ldv_work_2_0 == 0) {
#line 747
    ldv_work_struct_2_0 = work;
#line 748
    ldv_work_2_0 = state;
#line 749
    return;
  } else {

  }
#line 752
  if (ldv_work_2_1 == 0) {
#line 753
    ldv_work_struct_2_1 = work;
#line 754
    ldv_work_2_1 = state;
#line 755
    return;
  } else {

  }
#line 758
  if (ldv_work_2_2 == 0) {
#line 759
    ldv_work_struct_2_2 = work;
#line 760
    ldv_work_2_2 = state;
#line 761
    return;
  } else {

  }
#line 764
  if (ldv_work_2_3 == 0) {
#line 765
    ldv_work_struct_2_3 = work;
#line 766
    ldv_work_2_3 = state;
#line 767
    return;
  } else {

  }
#line 769
  return;
}
}
#line 772 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void invoke_work_5(void) 
{ 
  int tmp ;

  {
#line 774
  tmp = __VERIFIER_nondet_int();
#line 774
  switch (tmp) {
  case 0: ;
#line 776
  if (ldv_work_5_0 == 2 || ldv_work_5_0 == 3) {
#line 777
    ldv_work_5_0 = 4;
#line 778
    qla83xx_nic_core_unrecoverable_work(ldv_work_struct_5_0);
#line 779
    ldv_work_5_0 = 1;
  } else {

  }
#line 782
  goto ldv_68029;
  case 1: ;
#line 784
  if (ldv_work_5_1 == 2 || ldv_work_5_1 == 3) {
#line 785
    ldv_work_5_1 = 4;
#line 786
    qla83xx_nic_core_unrecoverable_work(ldv_work_struct_5_0);
#line 787
    ldv_work_5_1 = 1;
  } else {

  }
#line 790
  goto ldv_68029;
  case 2: ;
#line 792
  if (ldv_work_5_2 == 2 || ldv_work_5_2 == 3) {
#line 793
    ldv_work_5_2 = 4;
#line 794
    qla83xx_nic_core_unrecoverable_work(ldv_work_struct_5_0);
#line 795
    ldv_work_5_2 = 1;
  } else {

  }
#line 798
  goto ldv_68029;
  case 3: ;
#line 800
  if (ldv_work_5_3 == 2 || ldv_work_5_3 == 3) {
#line 801
    ldv_work_5_3 = 4;
#line 802
    qla83xx_nic_core_unrecoverable_work(ldv_work_struct_5_0);
#line 803
    ldv_work_5_3 = 1;
  } else {

  }
#line 806
  goto ldv_68029;
  default: 
#line 807
  ldv_stop();
  }
  ldv_68029: ;
#line 809
  return;
}
}
#line 813 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_initialize_scsi_host_template_88(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 814
  tmp = __VERIFIER_nondet_pointer();
#line 814
  qla2xxx_driver_template_group0 = (struct scsi_cmnd *)tmp;
#line 815
  tmp___0 = ldv_init_zalloc(3816UL);
#line 815
  qla2xxx_driver_template_group1 = (struct Scsi_Host *)tmp___0;
#line 816
  tmp___1 = __VERIFIER_nondet_pointer();
#line 816
  qla2xxx_driver_template_group2 = (struct scsi_device *)tmp___1;
#line 817
  return;
}
}
#line 819 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_initialize_isp_operations_79(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 820
  tmp = ldv_init_zalloc(1360UL);
#line 820
  qlafx00_isp_ops_group0 = (struct scsi_qla_host *)tmp;
#line 821
  tmp___0 = ldv_init_zalloc(12288UL);
#line 821
  qlafx00_isp_ops_group1 = (struct qla_hw_data *)tmp___0;
#line 822
  tmp___1 = ldv_init_zalloc(136UL);
#line 822
  qlafx00_isp_ops_group2 = (struct fc_port *)tmp___1;
#line 823
  return;
}
}
#line 825 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_initialize_isp_operations_83(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 826
  tmp = ldv_init_zalloc(1360UL);
#line 826
  qla81xx_isp_ops_group0 = (struct scsi_qla_host *)tmp;
#line 827
  tmp___0 = ldv_init_zalloc(12288UL);
#line 827
  qla81xx_isp_ops_group1 = (struct qla_hw_data *)tmp___0;
#line 828
  tmp___1 = ldv_init_zalloc(136UL);
#line 828
  qla81xx_isp_ops_group2 = (struct fc_port *)tmp___1;
#line 829
  return;
}
}
#line 831 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void disable_work_4(struct work_struct *work ) 
{ 


  {
#line 833
  if ((ldv_work_4_0 == 3 || ldv_work_4_0 == 2) && (unsigned long )ldv_work_struct_4_0 == (unsigned long )work) {
#line 835
    ldv_work_4_0 = 1;
  } else {

  }
#line 837
  if ((ldv_work_4_1 == 3 || ldv_work_4_1 == 2) && (unsigned long )ldv_work_struct_4_1 == (unsigned long )work) {
#line 839
    ldv_work_4_1 = 1;
  } else {

  }
#line 841
  if ((ldv_work_4_2 == 3 || ldv_work_4_2 == 2) && (unsigned long )ldv_work_struct_4_2 == (unsigned long )work) {
#line 843
    ldv_work_4_2 = 1;
  } else {

  }
#line 845
  if ((ldv_work_4_3 == 3 || ldv_work_4_3 == 2) && (unsigned long )ldv_work_struct_4_3 == (unsigned long )work) {
#line 847
    ldv_work_4_3 = 1;
  } else {

  }
#line 848
  return;
}
}
#line 852 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void work_init_4(void) 
{ 


  {
#line 853
  ldv_work_4_0 = 0;
#line 854
  ldv_work_4_1 = 0;
#line 855
  ldv_work_4_2 = 0;
#line 856
  ldv_work_4_3 = 0;
#line 857
  return;
}
}
#line 860 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void invoke_work_1(void) 
{ 
  int tmp ;

  {
#line 862
  tmp = __VERIFIER_nondet_int();
#line 862
  switch (tmp) {
  case 0: ;
#line 864
  if (ldv_work_1_0 == 2 || ldv_work_1_0 == 3) {
#line 865
    ldv_work_1_0 = 4;
#line 866
    qla2x00_disable_board_on_pci_error(ldv_work_struct_1_0);
#line 867
    ldv_work_1_0 = 1;
  } else {

  }
#line 870
  goto ldv_68055;
  case 1: ;
#line 872
  if (ldv_work_1_1 == 2 || ldv_work_1_1 == 3) {
#line 873
    ldv_work_1_1 = 4;
#line 874
    qla2x00_disable_board_on_pci_error(ldv_work_struct_1_0);
#line 875
    ldv_work_1_1 = 1;
  } else {

  }
#line 878
  goto ldv_68055;
  case 2: ;
#line 880
  if (ldv_work_1_2 == 2 || ldv_work_1_2 == 3) {
#line 881
    ldv_work_1_2 = 4;
#line 882
    qla2x00_disable_board_on_pci_error(ldv_work_struct_1_0);
#line 883
    ldv_work_1_2 = 1;
  } else {

  }
#line 886
  goto ldv_68055;
  case 3: ;
#line 888
  if (ldv_work_1_3 == 2 || ldv_work_1_3 == 3) {
#line 889
    ldv_work_1_3 = 4;
#line 890
    qla2x00_disable_board_on_pci_error(ldv_work_struct_1_0);
#line 891
    ldv_work_1_3 = 1;
  } else {

  }
#line 894
  goto ldv_68055;
  default: 
#line 895
  ldv_stop();
  }
  ldv_68055: ;
#line 897
  return;
}
}
#line 901 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void call_and_disable_all_3(int state ) 
{ 


  {
#line 903
  if (ldv_work_3_0 == state) {
#line 904
    call_and_disable_work_3(ldv_work_struct_3_0);
  } else {

  }
#line 905
  if (ldv_work_3_1 == state) {
#line 906
    call_and_disable_work_3(ldv_work_struct_3_1);
  } else {

  }
#line 907
  if (ldv_work_3_2 == state) {
#line 908
    call_and_disable_work_3(ldv_work_struct_3_2);
  } else {

  }
#line 909
  if (ldv_work_3_3 == state) {
#line 910
    call_and_disable_work_3(ldv_work_struct_3_3);
  } else {

  }
#line 911
  return;
}
}
#line 914 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void activate_pending_timer_14(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 914
  if ((unsigned long )ldv_timer_list_14 == (unsigned long )timer) {
#line 915
    if (ldv_timer_state_14 == 2 || pending_flag != 0) {
#line 916
      ldv_timer_list_14 = timer;
#line 917
      ldv_timer_list_14->data = data;
#line 918
      ldv_timer_state_14 = 1;
    } else {

    }
#line 920
    return;
  } else {

  }
#line 922
  reg_timer_14(timer);
#line 923
  ldv_timer_list_14->data = data;
#line 924
  return;
}
}
#line 927 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void call_and_disable_work_4(struct work_struct *work ) 
{ 


  {
#line 930
  if ((ldv_work_4_0 == 2 || ldv_work_4_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_0) {
#line 932
    qla83xx_idc_state_handler_work(work);
#line 933
    ldv_work_4_0 = 1;
#line 934
    return;
  } else {

  }
#line 936
  if ((ldv_work_4_1 == 2 || ldv_work_4_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_1) {
#line 938
    qla83xx_idc_state_handler_work(work);
#line 939
    ldv_work_4_1 = 1;
#line 940
    return;
  } else {

  }
#line 942
  if ((ldv_work_4_2 == 2 || ldv_work_4_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_2) {
#line 944
    qla83xx_idc_state_handler_work(work);
#line 945
    ldv_work_4_2 = 1;
#line 946
    return;
  } else {

  }
#line 948
  if ((ldv_work_4_3 == 2 || ldv_work_4_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_3) {
#line 950
    qla83xx_idc_state_handler_work(work);
#line 951
    ldv_work_4_3 = 1;
#line 952
    return;
  } else {

  }
#line 954
  return;
}
}
#line 957 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void work_init_3(void) 
{ 


  {
#line 958
  ldv_work_3_0 = 0;
#line 959
  ldv_work_3_1 = 0;
#line 960
  ldv_work_3_2 = 0;
#line 961
  ldv_work_3_3 = 0;
#line 962
  return;
}
}
#line 965 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void call_and_disable_work_1(struct work_struct *work ) 
{ 


  {
#line 968
  if ((ldv_work_1_0 == 2 || ldv_work_1_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_0) {
#line 970
    qla2x00_disable_board_on_pci_error(work);
#line 971
    ldv_work_1_0 = 1;
#line 972
    return;
  } else {

  }
#line 974
  if ((ldv_work_1_1 == 2 || ldv_work_1_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_1) {
#line 976
    qla2x00_disable_board_on_pci_error(work);
#line 977
    ldv_work_1_1 = 1;
#line 978
    return;
  } else {

  }
#line 980
  if ((ldv_work_1_2 == 2 || ldv_work_1_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_2) {
#line 982
    qla2x00_disable_board_on_pci_error(work);
#line 983
    ldv_work_1_2 = 1;
#line 984
    return;
  } else {

  }
#line 986
  if ((ldv_work_1_3 == 2 || ldv_work_1_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_3) {
#line 988
    qla2x00_disable_board_on_pci_error(work);
#line 989
    ldv_work_1_3 = 1;
#line 990
    return;
  } else {

  }
#line 992
  return;
}
}
#line 995 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void disable_suitable_timer_13(struct timer_list *timer ) 
{ 


  {
#line 996
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_13) {
#line 997
    ldv_timer_state_13 = 0;
#line 998
    return;
  } else {

  }
#line 1000
  return;
}
}
#line 1003 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_file_operations_75(void) 
{ 
  void *tmp ;

  {
#line 1004
  apidev_fops_group1 = ldv_init_zalloc(1000UL);
#line 1005
  tmp = ldv_init_zalloc(504UL);
#line 1005
  apidev_fops_group2 = (struct file *)tmp;
#line 1006
  return;
}
}
#line 1009 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void call_and_disable_all_2(int state ) 
{ 


  {
#line 1011
  if (ldv_work_2_0 == state) {
#line 1012
    call_and_disable_work_2(ldv_work_struct_2_0);
  } else {

  }
#line 1013
  if (ldv_work_2_1 == state) {
#line 1014
    call_and_disable_work_2(ldv_work_struct_2_1);
  } else {

  }
#line 1015
  if (ldv_work_2_2 == state) {
#line 1016
    call_and_disable_work_2(ldv_work_struct_2_2);
  } else {

  }
#line 1017
  if (ldv_work_2_3 == state) {
#line 1018
    call_and_disable_work_2(ldv_work_struct_2_3);
  } else {

  }
#line 1019
  return;
}
}
#line 1022 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void activate_work_3(struct work_struct *work , int state ) 
{ 


  {
#line 1023
  if (ldv_work_3_0 == 0) {
#line 1024
    ldv_work_struct_3_0 = work;
#line 1025
    ldv_work_3_0 = state;
#line 1026
    return;
  } else {

  }
#line 1029
  if (ldv_work_3_1 == 0) {
#line 1030
    ldv_work_struct_3_1 = work;
#line 1031
    ldv_work_3_1 = state;
#line 1032
    return;
  } else {

  }
#line 1035
  if (ldv_work_3_2 == 0) {
#line 1036
    ldv_work_struct_3_2 = work;
#line 1037
    ldv_work_3_2 = state;
#line 1038
    return;
  } else {

  }
#line 1041
  if (ldv_work_3_3 == 0) {
#line 1042
    ldv_work_struct_3_3 = work;
#line 1043
    ldv_work_3_3 = state;
#line 1044
    return;
  } else {

  }
#line 1046
  return;
}
}
#line 1049 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_initialize_isp_operations_87(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1050
  tmp = ldv_init_zalloc(1360UL);
#line 1050
  qla2100_isp_ops_group0 = (struct scsi_qla_host *)tmp;
#line 1051
  tmp___0 = ldv_init_zalloc(12288UL);
#line 1051
  qla2100_isp_ops_group1 = (struct qla_hw_data *)tmp___0;
#line 1052
  tmp___1 = ldv_init_zalloc(136UL);
#line 1052
  qla2100_isp_ops_group2 = (struct fc_port *)tmp___1;
#line 1053
  return;
}
}
#line 1055 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void disable_work_5(struct work_struct *work ) 
{ 


  {
#line 1057
  if ((ldv_work_5_0 == 3 || ldv_work_5_0 == 2) && (unsigned long )ldv_work_struct_5_0 == (unsigned long )work) {
#line 1059
    ldv_work_5_0 = 1;
  } else {

  }
#line 1061
  if ((ldv_work_5_1 == 3 || ldv_work_5_1 == 2) && (unsigned long )ldv_work_struct_5_1 == (unsigned long )work) {
#line 1063
    ldv_work_5_1 = 1;
  } else {

  }
#line 1065
  if ((ldv_work_5_2 == 3 || ldv_work_5_2 == 2) && (unsigned long )ldv_work_struct_5_2 == (unsigned long )work) {
#line 1067
    ldv_work_5_2 = 1;
  } else {

  }
#line 1069
  if ((ldv_work_5_3 == 3 || ldv_work_5_3 == 2) && (unsigned long )ldv_work_struct_5_3 == (unsigned long )work) {
#line 1071
    ldv_work_5_3 = 1;
  } else {

  }
#line 1072
  return;
}
}
#line 1076 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void disable_work_1(struct work_struct *work ) 
{ 


  {
#line 1078
  if ((ldv_work_1_0 == 3 || ldv_work_1_0 == 2) && (unsigned long )ldv_work_struct_1_0 == (unsigned long )work) {
#line 1080
    ldv_work_1_0 = 1;
  } else {

  }
#line 1082
  if ((ldv_work_1_1 == 3 || ldv_work_1_1 == 2) && (unsigned long )ldv_work_struct_1_1 == (unsigned long )work) {
#line 1084
    ldv_work_1_1 = 1;
  } else {

  }
#line 1086
  if ((ldv_work_1_2 == 3 || ldv_work_1_2 == 2) && (unsigned long )ldv_work_struct_1_2 == (unsigned long )work) {
#line 1088
    ldv_work_1_2 = 1;
  } else {

  }
#line 1090
  if ((ldv_work_1_3 == 3 || ldv_work_1_3 == 2) && (unsigned long )ldv_work_struct_1_3 == (unsigned long )work) {
#line 1092
    ldv_work_1_3 = 1;
  } else {

  }
#line 1093
  return;
}
}
#line 1097 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_initialize_isp_operations_80(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1098
  tmp = ldv_init_zalloc(1360UL);
#line 1098
  qla83xx_isp_ops_group0 = (struct scsi_qla_host *)tmp;
#line 1099
  tmp___0 = ldv_init_zalloc(12288UL);
#line 1099
  qla83xx_isp_ops_group1 = (struct qla_hw_data *)tmp___0;
#line 1100
  tmp___1 = ldv_init_zalloc(136UL);
#line 1100
  qla83xx_isp_ops_group2 = (struct fc_port *)tmp___1;
#line 1101
  return;
}
}
#line 1103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void call_and_disable_work_5(struct work_struct *work ) 
{ 


  {
#line 1106
  if ((ldv_work_5_0 == 2 || ldv_work_5_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_0) {
#line 1108
    qla83xx_nic_core_unrecoverable_work(work);
#line 1109
    ldv_work_5_0 = 1;
#line 1110
    return;
  } else {

  }
#line 1112
  if ((ldv_work_5_1 == 2 || ldv_work_5_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_1) {
#line 1114
    qla83xx_nic_core_unrecoverable_work(work);
#line 1115
    ldv_work_5_1 = 1;
#line 1116
    return;
  } else {

  }
#line 1118
  if ((ldv_work_5_2 == 2 || ldv_work_5_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_2) {
#line 1120
    qla83xx_nic_core_unrecoverable_work(work);
#line 1121
    ldv_work_5_2 = 1;
#line 1122
    return;
  } else {

  }
#line 1124
  if ((ldv_work_5_3 == 2 || ldv_work_5_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_3) {
#line 1126
    qla83xx_nic_core_unrecoverable_work(work);
#line 1127
    ldv_work_5_3 = 1;
#line 1128
    return;
  } else {

  }
#line 1130
  return;
}
}
#line 1133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int reg_timer_14(struct timer_list *timer ) 
{ 


  {
#line 1134
  ldv_timer_list_14 = timer;
#line 1135
  ldv_timer_state_14 = 1;
#line 1136
  return (0);
}
}
#line 1139 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void invoke_work_2(void) 
{ 
  int tmp ;

  {
#line 1141
  tmp = __VERIFIER_nondet_int();
#line 1141
  switch (tmp) {
  case 0: ;
#line 1143
  if (ldv_work_2_0 == 2 || ldv_work_2_0 == 3) {
#line 1144
    ldv_work_2_0 = 4;
#line 1145
    qla83xx_service_idc_aen(ldv_work_struct_2_0);
#line 1146
    ldv_work_2_0 = 1;
  } else {

  }
#line 1149
  goto ldv_68120;
  case 1: ;
#line 1151
  if (ldv_work_2_1 == 2 || ldv_work_2_1 == 3) {
#line 1152
    ldv_work_2_1 = 4;
#line 1153
    qla83xx_service_idc_aen(ldv_work_struct_2_0);
#line 1154
    ldv_work_2_1 = 1;
  } else {

  }
#line 1157
  goto ldv_68120;
  case 2: ;
#line 1159
  if (ldv_work_2_2 == 2 || ldv_work_2_2 == 3) {
#line 1160
    ldv_work_2_2 = 4;
#line 1161
    qla83xx_service_idc_aen(ldv_work_struct_2_0);
#line 1162
    ldv_work_2_2 = 1;
  } else {

  }
#line 1165
  goto ldv_68120;
  case 3: ;
#line 1167
  if (ldv_work_2_3 == 2 || ldv_work_2_3 == 3) {
#line 1168
    ldv_work_2_3 = 4;
#line 1169
    qla83xx_service_idc_aen(ldv_work_struct_2_0);
#line 1170
    ldv_work_2_3 = 1;
  } else {

  }
#line 1173
  goto ldv_68120;
  default: 
#line 1174
  ldv_stop();
  }
  ldv_68120: ;
#line 1176
  return;
}
}
#line 1180 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_initialize_pci_error_handlers_77(void) 
{ 
  void *tmp ;

  {
#line 1181
  tmp = __VERIFIER_nondet_pointer();
#line 1181
  qla2xxx_err_handler_group0 = (struct pci_dev *)tmp;
#line 1182
  return;
}
}
#line 1184 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void activate_work_4(struct work_struct *work , int state ) 
{ 


  {
#line 1185
  if (ldv_work_4_0 == 0) {
#line 1186
    ldv_work_struct_4_0 = work;
#line 1187
    ldv_work_4_0 = state;
#line 1188
    return;
  } else {

  }
#line 1191
  if (ldv_work_4_1 == 0) {
#line 1192
    ldv_work_struct_4_1 = work;
#line 1193
    ldv_work_4_1 = state;
#line 1194
    return;
  } else {

  }
#line 1197
  if (ldv_work_4_2 == 0) {
#line 1198
    ldv_work_struct_4_2 = work;
#line 1199
    ldv_work_4_2 = state;
#line 1200
    return;
  } else {

  }
#line 1203
  if (ldv_work_4_3 == 0) {
#line 1204
    ldv_work_struct_4_3 = work;
#line 1205
    ldv_work_4_3 = state;
#line 1206
    return;
  } else {

  }
#line 1208
  return;
}
}
#line 1211 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_initialize_isp_operations_84(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1212
  tmp = ldv_init_zalloc(1360UL);
#line 1212
  qla25xx_isp_ops_group0 = (struct scsi_qla_host *)tmp;
#line 1213
  tmp___0 = ldv_init_zalloc(12288UL);
#line 1213
  qla25xx_isp_ops_group1 = (struct qla_hw_data *)tmp___0;
#line 1214
  tmp___1 = ldv_init_zalloc(136UL);
#line 1214
  qla25xx_isp_ops_group2 = (struct fc_port *)tmp___1;
#line 1215
  return;
}
}
#line 1217 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void call_and_disable_all_5(int state ) 
{ 


  {
#line 1219
  if (ldv_work_5_0 == state) {
#line 1220
    call_and_disable_work_5(ldv_work_struct_5_0);
  } else {

  }
#line 1221
  if (ldv_work_5_1 == state) {
#line 1222
    call_and_disable_work_5(ldv_work_struct_5_1);
  } else {

  }
#line 1223
  if (ldv_work_5_2 == state) {
#line 1224
    call_and_disable_work_5(ldv_work_struct_5_2);
  } else {

  }
#line 1225
  if (ldv_work_5_3 == state) {
#line 1226
    call_and_disable_work_5(ldv_work_struct_5_3);
  } else {

  }
#line 1227
  return;
}
}
#line 1230 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void work_init_2(void) 
{ 


  {
#line 1231
  ldv_work_2_0 = 0;
#line 1232
  ldv_work_2_1 = 0;
#line 1233
  ldv_work_2_2 = 0;
#line 1234
  ldv_work_2_3 = 0;
#line 1235
  return;
}
}
#line 1238 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void disable_suitable_timer_14(struct timer_list *timer ) 
{ 


  {
#line 1239
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_14) {
#line 1240
    ldv_timer_state_14 = 0;
#line 1241
    return;
  } else {

  }
#line 1243
  return;
}
}
#line 1246 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void call_and_disable_all_1(int state ) 
{ 


  {
#line 1248
  if (ldv_work_1_0 == state) {
#line 1249
    call_and_disable_work_1(ldv_work_struct_1_0);
  } else {

  }
#line 1250
  if (ldv_work_1_1 == state) {
#line 1251
    call_and_disable_work_1(ldv_work_struct_1_1);
  } else {

  }
#line 1252
  if (ldv_work_1_2 == state) {
#line 1253
    call_and_disable_work_1(ldv_work_struct_1_2);
  } else {

  }
#line 1254
  if (ldv_work_1_3 == state) {
#line 1255
    call_and_disable_work_1(ldv_work_struct_1_3);
  } else {

  }
#line 1256
  return;
}
}
#line 1259 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_initialize_isp_operations_86(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1260
  tmp = ldv_init_zalloc(1360UL);
#line 1260
  qla2300_isp_ops_group0 = (struct scsi_qla_host *)tmp;
#line 1261
  tmp___0 = ldv_init_zalloc(12288UL);
#line 1261
  qla2300_isp_ops_group1 = (struct qla_hw_data *)tmp___0;
#line 1262
  tmp___1 = ldv_init_zalloc(136UL);
#line 1262
  qla2300_isp_ops_group2 = (struct fc_port *)tmp___1;
#line 1263
  return;
}
}
#line 1265 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void disable_work_2(struct work_struct *work ) 
{ 


  {
#line 1267
  if ((ldv_work_2_0 == 3 || ldv_work_2_0 == 2) && (unsigned long )ldv_work_struct_2_0 == (unsigned long )work) {
#line 1269
    ldv_work_2_0 = 1;
  } else {

  }
#line 1271
  if ((ldv_work_2_1 == 3 || ldv_work_2_1 == 2) && (unsigned long )ldv_work_struct_2_1 == (unsigned long )work) {
#line 1273
    ldv_work_2_1 = 1;
  } else {

  }
#line 1275
  if ((ldv_work_2_2 == 3 || ldv_work_2_2 == 2) && (unsigned long )ldv_work_struct_2_2 == (unsigned long )work) {
#line 1277
    ldv_work_2_2 = 1;
  } else {

  }
#line 1279
  if ((ldv_work_2_3 == 3 || ldv_work_2_3 == 2) && (unsigned long )ldv_work_struct_2_3 == (unsigned long )work) {
#line 1281
    ldv_work_2_3 = 1;
  } else {

  }
#line 1282
  return;
}
}
#line 1286 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void invoke_work_3(void) 
{ 
  int tmp ;

  {
#line 1288
  tmp = __VERIFIER_nondet_int();
#line 1288
  switch (tmp) {
  case 0: ;
#line 1290
  if (ldv_work_3_0 == 2 || ldv_work_3_0 == 3) {
#line 1291
    ldv_work_3_0 = 4;
#line 1292
    qla83xx_nic_core_reset_work(ldv_work_struct_3_0);
#line 1293
    ldv_work_3_0 = 1;
  } else {

  }
#line 1296
  goto ldv_68159;
  case 1: ;
#line 1298
  if (ldv_work_3_1 == 2 || ldv_work_3_1 == 3) {
#line 1299
    ldv_work_3_1 = 4;
#line 1300
    qla83xx_nic_core_reset_work(ldv_work_struct_3_0);
#line 1301
    ldv_work_3_1 = 1;
  } else {

  }
#line 1304
  goto ldv_68159;
  case 2: ;
#line 1306
  if (ldv_work_3_2 == 2 || ldv_work_3_2 == 3) {
#line 1307
    ldv_work_3_2 = 4;
#line 1308
    qla83xx_nic_core_reset_work(ldv_work_struct_3_0);
#line 1309
    ldv_work_3_2 = 1;
  } else {

  }
#line 1312
  goto ldv_68159;
  case 3: ;
#line 1314
  if (ldv_work_3_3 == 2 || ldv_work_3_3 == 3) {
#line 1315
    ldv_work_3_3 = 4;
#line 1316
    qla83xx_nic_core_reset_work(ldv_work_struct_3_0);
#line 1317
    ldv_work_3_3 = 1;
  } else {

  }
#line 1320
  goto ldv_68159;
  default: 
#line 1321
  ldv_stop();
  }
  ldv_68159: ;
#line 1323
  return;
}
}
#line 1327 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int reg_timer_13(struct timer_list *timer ) 
{ 


  {
#line 1328
  ldv_timer_list_13 = timer;
#line 1329
  ldv_timer_state_13 = 1;
#line 1330
  return (0);
}
}
#line 1333 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void choose_timer_14(struct timer_list *timer ) 
{ 


  {
#line 1334
  LDV_IN_INTERRUPT = 2;
#line 1335
  (*(timer->function))(timer->data);
#line 1336
  LDV_IN_INTERRUPT = 1;
#line 1337
  ldv_timer_state_14 = 2;
#line 1338
  return;
}
}
#line 1342 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void call_and_disable_work_2(struct work_struct *work ) 
{ 


  {
#line 1345
  if ((ldv_work_2_0 == 2 || ldv_work_2_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_0) {
#line 1347
    qla83xx_service_idc_aen(work);
#line 1348
    ldv_work_2_0 = 1;
#line 1349
    return;
  } else {

  }
#line 1351
  if ((ldv_work_2_1 == 2 || ldv_work_2_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_1) {
#line 1353
    qla83xx_service_idc_aen(work);
#line 1354
    ldv_work_2_1 = 1;
#line 1355
    return;
  } else {

  }
#line 1357
  if ((ldv_work_2_2 == 2 || ldv_work_2_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_2) {
#line 1359
    qla83xx_service_idc_aen(work);
#line 1360
    ldv_work_2_2 = 1;
#line 1361
    return;
  } else {

  }
#line 1363
  if ((ldv_work_2_3 == 2 || ldv_work_2_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_3) {
#line 1365
    qla83xx_service_idc_aen(work);
#line 1366
    ldv_work_2_3 = 1;
#line 1367
    return;
  } else {

  }
#line 1369
  return;
}
}
#line 1373
void ldv_main_exported_31(void) ;
#line 1389
void ldv_main_exported_67(void) ;
#line 1390
void ldv_main_exported_33(void) ;
#line 1391
void ldv_main_exported_32(void) ;
#line 1392
void ldv_main_exported_63(void) ;
#line 1393
void ldv_main_exported_71(void) ;
#line 1394
void ldv_main_exported_70(void) ;
#line 1395
void ldv_main_exported_68(void) ;
#line 1396
void ldv_main_exported_72(void) ;
#line 1397
void ldv_main_exported_44(void) ;
#line 1398
void ldv_main_exported_55(void) ;
#line 1399
void ldv_main_exported_74(void) ;
#line 1400
void ldv_main_exported_57(void) ;
#line 1401
void ldv_main_exported_40(void) ;
#line 1402
void ldv_main_exported_61(void) ;
#line 1403
void ldv_main_exported_69(void) ;
#line 1404
void ldv_main_exported_59(void) ;
#line 1405
void ldv_main_exported_49(void) ;
#line 1406
void ldv_main_exported_35(void) ;
#line 1407
void ldv_main_exported_53(void) ;
#line 1408
void ldv_main_exported_48(void) ;
#line 1409
void ldv_main_exported_42(void) ;
#line 1410
void ldv_main_exported_46(void) ;
#line 1411
void ldv_main_exported_65(void) ;
#line 1412
void ldv_main_exported_50(void) ;
#line 1413
void ldv_main_exported_39(void) ;
#line 1414
void ldv_main_exported_64(void) ;
#line 1415
void ldv_main_exported_36(void) ;
#line 1416
void ldv_main_exported_51(void) ;
#line 1417
void ldv_main_exported_41(void) ;
#line 1418
void ldv_main_exported_58(void) ;
#line 1419
void ldv_main_exported_47(void) ;
#line 1420
void ldv_main_exported_38(void) ;
#line 1421
void ldv_main_exported_52(void) ;
#line 1422
void ldv_main_exported_60(void) ;
#line 1423
void ldv_main_exported_34(void) ;
#line 1424
void ldv_main_exported_56(void) ;
#line 1425
void ldv_main_exported_73(void) ;
#line 1426
void ldv_main_exported_66(void) ;
#line 1427
void ldv_main_exported_45(void) ;
#line 1428
void ldv_main_exported_37(void) ;
#line 1429
void ldv_main_exported_43(void) ;
#line 1430
void ldv_main_exported_62(void) ;
#line 1431
void ldv_main_exported_54(void) ;
#line 1435 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int main(void) 
{ 
  uint8_t ldvarg18 ;
  uint64_t ldvarg32 ;
  srb_t *ldvarg23 ;
  void *tmp ;
  void *ldvarg43 ;
  void *tmp___0 ;
  int ldvarg42 ;
  uint8_t *ldvarg46 ;
  void *tmp___1 ;
  uint16_t ldvarg37 ;
  size_t ldvarg29 ;
  uint32_t ldvarg44 ;
  uint32_t ldvarg24 ;
  uint8_t ldvarg35 ;
  uint8_t ldvarg38 ;
  uint32_t ldvarg33 ;
  uint8_t ldvarg16 ;
  uint32_t ldvarg14 ;
  uint32_t ldvarg34 ;
  void *ldvarg28 ;
  void *tmp___2 ;
  srb_t *ldvarg39 ;
  void *tmp___3 ;
  uint8_t ldvarg20 ;
  int ldvarg31 ;
  uint64_t ldvarg41 ;
  uint32_t ldvarg13 ;
  uint8_t ldvarg36 ;
  int ldvarg40 ;
  uint32_t ldvarg45 ;
  char *ldvarg27 ;
  void *tmp___4 ;
  uint8_t *ldvarg26 ;
  void *tmp___5 ;
  uint16_t *ldvarg15 ;
  void *tmp___6 ;
  char *ldvarg30 ;
  void *tmp___7 ;
  uint32_t *ldvarg21 ;
  void *tmp___8 ;
  uint32_t ldvarg25 ;
  uint8_t ldvarg17 ;
  int ldvarg22 ;
  uint16_t ldvarg19 ;
  uint32_t ldvarg77 ;
  uint64_t ldvarg84 ;
  int ldvarg94 ;
  srb_t *ldvarg91 ;
  void *tmp___9 ;
  uint16_t *ldvarg67 ;
  void *tmp___10 ;
  uint16_t ldvarg71 ;
  uint8_t ldvarg72 ;
  uint8_t *ldvarg98 ;
  void *tmp___11 ;
  uint32_t ldvarg97 ;
  uint32_t ldvarg64 ;
  int ldvarg83 ;
  void *ldvarg95 ;
  void *tmp___12 ;
  uint32_t ldvarg85 ;
  uint8_t ldvarg69 ;
  uint64_t ldvarg93 ;
  uint16_t ldvarg89 ;
  uint32_t ldvarg60 ;
  void *ldvarg80 ;
  void *tmp___13 ;
  uint32_t ldvarg59 ;
  uint8_t ldvarg87 ;
  uint32_t ldvarg86 ;
  uint32_t ldvarg62 ;
  uint32_t ldvarg65 ;
  char *ldvarg79 ;
  void *tmp___14 ;
  uint8_t *ldvarg66 ;
  void *tmp___15 ;
  uint32_t ldvarg96 ;
  size_t ldvarg81 ;
  uint8_t *ldvarg63 ;
  void *tmp___16 ;
  uint32_t *ldvarg73 ;
  void *tmp___17 ;
  uint8_t ldvarg70 ;
  uint8_t ldvarg88 ;
  uint8_t *ldvarg78 ;
  void *tmp___18 ;
  uint8_t ldvarg68 ;
  uint8_t ldvarg90 ;
  uint32_t ldvarg61 ;
  int ldvarg92 ;
  int ldvarg74 ;
  uint32_t ldvarg76 ;
  char *ldvarg82 ;
  void *tmp___19 ;
  srb_t *ldvarg75 ;
  void *tmp___20 ;
  uint32_t ldvarg131 ;
  void *ldvarg134 ;
  void *tmp___21 ;
  int ldvarg146 ;
  uint8_t ldvarg141 ;
  char *ldvarg136 ;
  void *tmp___22 ;
  uint16_t ldvarg125 ;
  srb_t *ldvarg145 ;
  void *tmp___23 ;
  uint32_t ldvarg140 ;
  uint8_t *ldvarg152 ;
  void *tmp___24 ;
  uint8_t *ldvarg132 ;
  void *tmp___25 ;
  uint64_t ldvarg138 ;
  srb_t *ldvarg129 ;
  void *tmp___26 ;
  void *ldvarg149 ;
  void *tmp___27 ;
  uint8_t ldvarg142 ;
  uint16_t *ldvarg121 ;
  void *tmp___28 ;
  uint32_t ldvarg151 ;
  int ldvarg137 ;
  uint8_t ldvarg122 ;
  uint8_t ldvarg144 ;
  int ldvarg128 ;
  uint8_t ldvarg126 ;
  uint8_t ldvarg123 ;
  uint32_t ldvarg120 ;
  size_t ldvarg135 ;
  uint32_t ldvarg119 ;
  uint64_t ldvarg147 ;
  uint32_t *ldvarg127 ;
  void *tmp___29 ;
  uint8_t ldvarg124 ;
  char *ldvarg133 ;
  void *tmp___30 ;
  uint32_t ldvarg150 ;
  uint16_t ldvarg143 ;
  uint32_t ldvarg130 ;
  uint32_t ldvarg139 ;
  int ldvarg148 ;
  uint8_t *ldvarg178 ;
  void *tmp___31 ;
  uint32_t ldvarg157 ;
  void *ldvarg181 ;
  void *tmp___32 ;
  uint16_t ldvarg174 ;
  uint16_t ldvarg168 ;
  uint8_t ldvarg165 ;
  uint8_t ldvarg188 ;
  uint64_t ldvarg185 ;
  uint8_t ldvarg191 ;
  uint8_t ldvarg167 ;
  void *ldvarg196 ;
  void *tmp___33 ;
  uint32_t ldvarg197 ;
  uint32_t *ldvarg170 ;
  void *tmp___34 ;
  uint8_t ldvarg189 ;
  size_t ldvarg182 ;
  uint32_t ldvarg198 ;
  uint8_t *ldvarg163 ;
  void *tmp___35 ;
  uint8_t *ldvarg199 ;
  void *tmp___36 ;
  uint8_t ldvarg169 ;
  uint32_t ldvarg161 ;
  uint8_t *ldvarg160 ;
  void *tmp___37 ;
  uint32_t ldvarg158 ;
  cmd_entry_t *ldvarg175 ;
  void *tmp___38 ;
  int ldvarg195 ;
  uint32_t ldvarg187 ;
  srb_t *ldvarg172 ;
  void *tmp___39 ;
  int ldvarg184 ;
  uint32_t ldvarg186 ;
  uint16_t ldvarg190 ;
  uint32_t ldvarg177 ;
  int ldvarg193 ;
  uint32_t ldvarg156 ;
  uint8_t ldvarg166 ;
  srb_t *ldvarg192 ;
  void *tmp___40 ;
  uint16_t *ldvarg164 ;
  void *tmp___41 ;
  char *ldvarg183 ;
  void *tmp___42 ;
  uint32_t ldvarg176 ;
  uint64_t ldvarg194 ;
  srb_t *ldvarg173 ;
  void *tmp___43 ;
  char *ldvarg179 ;
  void *tmp___44 ;
  uint16_t ldvarg180 ;
  int ldvarg171 ;
  uint32_t ldvarg159 ;
  uint32_t ldvarg162 ;
  enum pci_channel_state ldvarg200 ;
  uint32_t ldvarg242 ;
  void *ldvarg237 ;
  void *tmp___45 ;
  uint8_t ldvarg225 ;
  uint8_t ldvarg247 ;
  uint32_t ldvarg233 ;
  char *ldvarg236 ;
  void *tmp___46 ;
  uint32_t ldvarg243 ;
  uint32_t ldvarg234 ;
  uint8_t ldvarg244 ;
  uint16_t ldvarg228 ;
  uint8_t ldvarg226 ;
  uint32_t ldvarg222 ;
  uint8_t *ldvarg255 ;
  void *tmp___47 ;
  srb_t *ldvarg232 ;
  void *tmp___48 ;
  uint32_t *ldvarg230 ;
  void *tmp___49 ;
  int ldvarg240 ;
  uint64_t ldvarg241 ;
  uint16_t ldvarg246 ;
  int ldvarg231 ;
  size_t ldvarg238 ;
  uint32_t ldvarg254 ;
  uint16_t *ldvarg224 ;
  void *tmp___50 ;
  srb_t *ldvarg248 ;
  void *tmp___51 ;
  uint32_t ldvarg223 ;
  uint8_t *ldvarg235 ;
  void *tmp___52 ;
  uint8_t ldvarg245 ;
  void *ldvarg252 ;
  void *tmp___53 ;
  uint8_t ldvarg229 ;
  uint8_t ldvarg227 ;
  int ldvarg251 ;
  uint64_t ldvarg250 ;
  int ldvarg249 ;
  char *ldvarg239 ;
  void *tmp___54 ;
  uint32_t ldvarg253 ;
  uint8_t ldvarg290 ;
  uint8_t ldvarg315 ;
  int ldvarg308 ;
  void *ldvarg305 ;
  void *tmp___55 ;
  uint8_t ldvarg313 ;
  char *ldvarg307 ;
  void *tmp___56 ;
  cmd_entry_t *ldvarg299 ;
  void *tmp___57 ;
  uint32_t ldvarg321 ;
  uint32_t ldvarg311 ;
  uint64_t ldvarg309 ;
  uint32_t ldvarg322 ;
  uint32_t ldvarg285 ;
  uint32_t ldvarg300 ;
  uint32_t ldvarg310 ;
  int ldvarg295 ;
  srb_t *ldvarg296 ;
  void *tmp___58 ;
  uint32_t ldvarg281 ;
  char *ldvarg303 ;
  void *tmp___59 ;
  uint8_t *ldvarg302 ;
  void *tmp___60 ;
  uint8_t *ldvarg284 ;
  void *tmp___61 ;
  uint32_t ldvarg280 ;
  int ldvarg317 ;
  uint16_t ldvarg304 ;
  uint8_t ldvarg312 ;
  uint64_t ldvarg318 ;
  uint8_t ldvarg293 ;
  uint16_t *ldvarg288 ;
  void *tmp___62 ;
  uint8_t ldvarg291 ;
  uint8_t ldvarg289 ;
  size_t ldvarg306 ;
  uint16_t ldvarg314 ;
  int ldvarg319 ;
  uint32_t ldvarg282 ;
  uint8_t *ldvarg323 ;
  void *tmp___63 ;
  uint32_t ldvarg301 ;
  uint8_t *ldvarg287 ;
  void *tmp___64 ;
  uint32_t ldvarg286 ;
  void *ldvarg320 ;
  void *tmp___65 ;
  srb_t *ldvarg297 ;
  void *tmp___66 ;
  uint16_t ldvarg292 ;
  uint32_t ldvarg283 ;
  uint16_t ldvarg298 ;
  srb_t *ldvarg316 ;
  void *tmp___67 ;
  uint32_t *ldvarg294 ;
  void *tmp___68 ;
  struct pci_device_id *ldvarg324 ;
  void *tmp___69 ;
  int ldvarg349 ;
  unsigned long ldvarg350 ;
  void *ldvarg372 ;
  void *tmp___70 ;
  uint8_t *ldvarg390 ;
  void *tmp___71 ;
  uint32_t ldvarg389 ;
  uint32_t ldvarg357 ;
  uint16_t ldvarg381 ;
  uint32_t ldvarg352 ;
  uint8_t ldvarg380 ;
  uint16_t ldvarg363 ;
  uint32_t ldvarg369 ;
  srb_t *ldvarg383 ;
  void *tmp___72 ;
  uint8_t ldvarg362 ;
  uint8_t ldvarg379 ;
  uint32_t *ldvarg365 ;
  void *tmp___73 ;
  uint8_t ldvarg360 ;
  uint8_t ldvarg364 ;
  uint64_t ldvarg376 ;
  uint32_t ldvarg377 ;
  void *ldvarg387 ;
  void *tmp___74 ;
  int ldvarg386 ;
  char *ldvarg374 ;
  void *tmp___75 ;
  uint8_t *ldvarg370 ;
  void *tmp___76 ;
  uint8_t ldvarg361 ;
  uint32_t ldvarg354 ;
  int ldvarg375 ;
  int ldvarg384 ;
  uint8_t *ldvarg358 ;
  void *tmp___77 ;
  uint32_t ldvarg351 ;
  srb_t *ldvarg367 ;
  void *tmp___78 ;
  uint32_t ldvarg378 ;
  uint8_t ldvarg382 ;
  uint16_t *ldvarg359 ;
  void *tmp___79 ;
  uint32_t ldvarg368 ;
  uint32_t ldvarg353 ;
  size_t ldvarg373 ;
  uint32_t ldvarg388 ;
  uint64_t ldvarg385 ;
  char *ldvarg371 ;
  void *tmp___80 ;
  int ldvarg366 ;
  uint8_t *ldvarg355 ;
  void *tmp___81 ;
  uint32_t ldvarg356 ;
  uint8_t *ldvarg404 ;
  void *tmp___82 ;
  uint32_t ldvarg412 ;
  uint16_t ldvarg397 ;
  uint8_t ldvarg396 ;
  uint8_t ldvarg394 ;
  char *ldvarg408 ;
  void *tmp___83 ;
  uint32_t ldvarg403 ;
  uint8_t *ldvarg424 ;
  void *tmp___84 ;
  uint8_t ldvarg416 ;
  uint8_t ldvarg395 ;
  uint8_t ldvarg398 ;
  uint32_t ldvarg423 ;
  uint16_t ldvarg415 ;
  int ldvarg418 ;
  uint32_t ldvarg422 ;
  size_t ldvarg407 ;
  uint16_t *ldvarg393 ;
  void *tmp___85 ;
  char *ldvarg405 ;
  void *tmp___86 ;
  int ldvarg409 ;
  uint32_t *ldvarg399 ;
  void *tmp___87 ;
  void *ldvarg406 ;
  void *tmp___88 ;
  uint32_t ldvarg392 ;
  uint64_t ldvarg419 ;
  int ldvarg420 ;
  srb_t *ldvarg401 ;
  void *tmp___89 ;
  void *ldvarg421 ;
  void *tmp___90 ;
  srb_t *ldvarg417 ;
  void *tmp___91 ;
  uint64_t ldvarg410 ;
  uint32_t ldvarg402 ;
  int ldvarg400 ;
  uint32_t ldvarg391 ;
  uint8_t ldvarg413 ;
  uint32_t ldvarg411 ;
  uint8_t ldvarg414 ;
  loff_t ldvarg426 ;
  int ldvarg425 ;
  void *ldvarg469 ;
  void *tmp___92 ;
  uint32_t ldvarg448 ;
  void *ldvarg458 ;
  void *tmp___93 ;
  uint32_t ldvarg463 ;
  srb_t *ldvarg465 ;
  void *tmp___94 ;
  size_t ldvarg459 ;
  uint32_t ldvarg464 ;
  uint8_t *ldvarg472 ;
  void *tmp___95 ;
  int ldvarg461 ;
  uint8_t *ldvarg449 ;
  void *tmp___96 ;
  uint8_t *ldvarg452 ;
  void *tmp___97 ;
  char *ldvarg457 ;
  void *tmp___98 ;
  uint32_t ldvarg447 ;
  uint32_t ldvarg450 ;
  uint64_t ldvarg462 ;
  uint32_t ldvarg446 ;
  char *ldvarg460 ;
  void *tmp___99 ;
  uint32_t ldvarg471 ;
  int ldvarg468 ;
  uint32_t ldvarg451 ;
  uint32_t ldvarg454 ;
  uint32_t ldvarg455 ;
  uint64_t ldvarg467 ;
  uint8_t *ldvarg456 ;
  void *tmp___100 ;
  srb_t *ldvarg453 ;
  void *tmp___101 ;
  uint32_t ldvarg470 ;
  uint32_t ldvarg445 ;
  int ldvarg466 ;
  uint16_t *ldvarg487 ;
  void *tmp___102 ;
  void *ldvarg500 ;
  void *tmp___103 ;
  uint32_t ldvarg479 ;
  uint8_t *ldvarg518 ;
  void *tmp___104 ;
  uint32_t ldvarg485 ;
  int ldvarg512 ;
  uint8_t ldvarg488 ;
  void *ldvarg515 ;
  void *tmp___105 ;
  uint32_t ldvarg506 ;
  size_t ldvarg501 ;
  uint16_t ldvarg509 ;
  int ldvarg514 ;
  uint32_t ldvarg496 ;
  uint8_t ldvarg507 ;
  uint8_t *ldvarg483 ;
  void *tmp___106 ;
  uint32_t ldvarg484 ;
  uint64_t ldvarg504 ;
  uint8_t ldvarg490 ;
  char *ldvarg499 ;
  void *tmp___107 ;
  uint8_t *ldvarg498 ;
  void *tmp___108 ;
  uint32_t ldvarg480 ;
  uint32_t *ldvarg493 ;
  void *tmp___109 ;
  uint32_t ldvarg516 ;
  uint8_t ldvarg489 ;
  uint8_t ldvarg508 ;
  uint32_t ldvarg497 ;
  char *ldvarg502 ;
  void *tmp___110 ;
  uint8_t ldvarg510 ;
  uint32_t ldvarg517 ;
  uint32_t ldvarg482 ;
  srb_t *ldvarg495 ;
  void *tmp___111 ;
  uint16_t ldvarg491 ;
  int ldvarg503 ;
  int ldvarg494 ;
  uint8_t *ldvarg486 ;
  void *tmp___112 ;
  srb_t *ldvarg511 ;
  void *tmp___113 ;
  uint32_t ldvarg481 ;
  uint8_t ldvarg492 ;
  uint64_t ldvarg513 ;
  uint32_t ldvarg505 ;
  int tmp___114 ;
  int tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  int tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  int tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  int tmp___127 ;
  int tmp___128 ;
  int tmp___129 ;

  {
#line 1440
  tmp = ldv_init_zalloc(376UL);
#line 1440
  ldvarg23 = (srb_t *)tmp;
#line 1441
  tmp___0 = ldv_init_zalloc(1UL);
#line 1441
  ldvarg43 = tmp___0;
#line 1443
  tmp___1 = ldv_init_zalloc(1UL);
#line 1443
  ldvarg46 = (uint8_t *)tmp___1;
#line 1454
  tmp___2 = ldv_init_zalloc(1UL);
#line 1454
  ldvarg28 = tmp___2;
#line 1455
  tmp___3 = ldv_init_zalloc(376UL);
#line 1455
  ldvarg39 = (srb_t *)tmp___3;
#line 1463
  tmp___4 = ldv_init_zalloc(1UL);
#line 1463
  ldvarg27 = (char *)tmp___4;
#line 1464
  tmp___5 = ldv_init_zalloc(1UL);
#line 1464
  ldvarg26 = (uint8_t *)tmp___5;
#line 1465
  tmp___6 = ldv_init_zalloc(2UL);
#line 1465
  ldvarg15 = (uint16_t *)tmp___6;
#line 1466
  tmp___7 = ldv_init_zalloc(1UL);
#line 1466
  ldvarg30 = (char *)tmp___7;
#line 1467
  tmp___8 = ldv_init_zalloc(4UL);
#line 1467
  ldvarg21 = (uint32_t *)tmp___8;
#line 1475
  tmp___9 = ldv_init_zalloc(376UL);
#line 1475
  ldvarg91 = (srb_t *)tmp___9;
#line 1476
  tmp___10 = ldv_init_zalloc(2UL);
#line 1476
  ldvarg67 = (uint16_t *)tmp___10;
#line 1479
  tmp___11 = ldv_init_zalloc(1UL);
#line 1479
  ldvarg98 = (uint8_t *)tmp___11;
#line 1483
  tmp___12 = ldv_init_zalloc(1UL);
#line 1483
  ldvarg95 = tmp___12;
#line 1489
  tmp___13 = ldv_init_zalloc(1UL);
#line 1489
  ldvarg80 = tmp___13;
#line 1495
  tmp___14 = ldv_init_zalloc(1UL);
#line 1495
  ldvarg79 = (char *)tmp___14;
#line 1496
  tmp___15 = ldv_init_zalloc(1UL);
#line 1496
  ldvarg66 = (uint8_t *)tmp___15;
#line 1499
  tmp___16 = ldv_init_zalloc(1UL);
#line 1499
  ldvarg63 = (uint8_t *)tmp___16;
#line 1500
  tmp___17 = ldv_init_zalloc(4UL);
#line 1500
  ldvarg73 = (uint32_t *)tmp___17;
#line 1503
  tmp___18 = ldv_init_zalloc(1UL);
#line 1503
  ldvarg78 = (uint8_t *)tmp___18;
#line 1510
  tmp___19 = ldv_init_zalloc(1UL);
#line 1510
  ldvarg82 = (char *)tmp___19;
#line 1511
  tmp___20 = ldv_init_zalloc(376UL);
#line 1511
  ldvarg75 = (srb_t *)tmp___20;
#line 1513
  tmp___21 = ldv_init_zalloc(1UL);
#line 1513
  ldvarg134 = tmp___21;
#line 1516
  tmp___22 = ldv_init_zalloc(1UL);
#line 1516
  ldvarg136 = (char *)tmp___22;
#line 1518
  tmp___23 = ldv_init_zalloc(376UL);
#line 1518
  ldvarg145 = (srb_t *)tmp___23;
#line 1520
  tmp___24 = ldv_init_zalloc(1UL);
#line 1520
  ldvarg152 = (uint8_t *)tmp___24;
#line 1521
  tmp___25 = ldv_init_zalloc(1UL);
#line 1521
  ldvarg132 = (uint8_t *)tmp___25;
#line 1523
  tmp___26 = ldv_init_zalloc(376UL);
#line 1523
  ldvarg129 = (srb_t *)tmp___26;
#line 1524
  tmp___27 = ldv_init_zalloc(1UL);
#line 1524
  ldvarg149 = tmp___27;
#line 1526
  tmp___28 = ldv_init_zalloc(2UL);
#line 1526
  ldvarg121 = (uint16_t *)tmp___28;
#line 1538
  tmp___29 = ldv_init_zalloc(4UL);
#line 1538
  ldvarg127 = (uint32_t *)tmp___29;
#line 1540
  tmp___30 = ldv_init_zalloc(1UL);
#line 1540
  ldvarg133 = (char *)tmp___30;
#line 1546
  tmp___31 = ldv_init_zalloc(1UL);
#line 1546
  ldvarg178 = (uint8_t *)tmp___31;
#line 1548
  tmp___32 = ldv_init_zalloc(1UL);
#line 1548
  ldvarg181 = tmp___32;
#line 1556
  tmp___33 = ldv_init_zalloc(1UL);
#line 1556
  ldvarg196 = tmp___33;
#line 1558
  tmp___34 = ldv_init_zalloc(4UL);
#line 1558
  ldvarg170 = (uint32_t *)tmp___34;
#line 1562
  tmp___35 = ldv_init_zalloc(1UL);
#line 1562
  ldvarg163 = (uint8_t *)tmp___35;
#line 1563
  tmp___36 = ldv_init_zalloc(1UL);
#line 1563
  ldvarg199 = (uint8_t *)tmp___36;
#line 1566
  tmp___37 = ldv_init_zalloc(1UL);
#line 1566
  ldvarg160 = (uint8_t *)tmp___37;
#line 1568
  tmp___38 = ldv_init_zalloc(64UL);
#line 1568
  ldvarg175 = (cmd_entry_t *)tmp___38;
#line 1571
  tmp___39 = ldv_init_zalloc(376UL);
#line 1571
  ldvarg172 = (srb_t *)tmp___39;
#line 1579
  tmp___40 = ldv_init_zalloc(376UL);
#line 1579
  ldvarg192 = (srb_t *)tmp___40;
#line 1580
  tmp___41 = ldv_init_zalloc(2UL);
#line 1580
  ldvarg164 = (uint16_t *)tmp___41;
#line 1581
  tmp___42 = ldv_init_zalloc(1UL);
#line 1581
  ldvarg183 = (char *)tmp___42;
#line 1584
  tmp___43 = ldv_init_zalloc(376UL);
#line 1584
  ldvarg173 = (srb_t *)tmp___43;
#line 1585
  tmp___44 = ldv_init_zalloc(1UL);
#line 1585
  ldvarg179 = (char *)tmp___44;
#line 1592
  tmp___45 = ldv_init_zalloc(1UL);
#line 1592
  ldvarg237 = tmp___45;
#line 1596
  tmp___46 = ldv_init_zalloc(1UL);
#line 1596
  ldvarg236 = (char *)tmp___46;
#line 1603
  tmp___47 = ldv_init_zalloc(1UL);
#line 1603
  ldvarg255 = (uint8_t *)tmp___47;
#line 1604
  tmp___48 = ldv_init_zalloc(376UL);
#line 1604
  ldvarg232 = (srb_t *)tmp___48;
#line 1605
  tmp___49 = ldv_init_zalloc(4UL);
#line 1605
  ldvarg230 = (uint32_t *)tmp___49;
#line 1612
  tmp___50 = ldv_init_zalloc(2UL);
#line 1612
  ldvarg224 = (uint16_t *)tmp___50;
#line 1613
  tmp___51 = ldv_init_zalloc(376UL);
#line 1613
  ldvarg248 = (srb_t *)tmp___51;
#line 1615
  tmp___52 = ldv_init_zalloc(1UL);
#line 1615
  ldvarg235 = (uint8_t *)tmp___52;
#line 1617
  tmp___53 = ldv_init_zalloc(1UL);
#line 1617
  ldvarg252 = tmp___53;
#line 1623
  tmp___54 = ldv_init_zalloc(1UL);
#line 1623
  ldvarg239 = (char *)tmp___54;
#line 1628
  tmp___55 = ldv_init_zalloc(1UL);
#line 1628
  ldvarg305 = tmp___55;
#line 1630
  tmp___56 = ldv_init_zalloc(1UL);
#line 1630
  ldvarg307 = (char *)tmp___56;
#line 1631
  tmp___57 = ldv_init_zalloc(64UL);
#line 1631
  ldvarg299 = (cmd_entry_t *)tmp___57;
#line 1640
  tmp___58 = ldv_init_zalloc(376UL);
#line 1640
  ldvarg296 = (srb_t *)tmp___58;
#line 1642
  tmp___59 = ldv_init_zalloc(1UL);
#line 1642
  ldvarg303 = (char *)tmp___59;
#line 1643
  tmp___60 = ldv_init_zalloc(1UL);
#line 1643
  ldvarg302 = (uint8_t *)tmp___60;
#line 1644
  tmp___61 = ldv_init_zalloc(1UL);
#line 1644
  ldvarg284 = (uint8_t *)tmp___61;
#line 1651
  tmp___62 = ldv_init_zalloc(2UL);
#line 1651
  ldvarg288 = (uint16_t *)tmp___62;
#line 1658
  tmp___63 = ldv_init_zalloc(1UL);
#line 1658
  ldvarg323 = (uint8_t *)tmp___63;
#line 1660
  tmp___64 = ldv_init_zalloc(1UL);
#line 1660
  ldvarg287 = (uint8_t *)tmp___64;
#line 1662
  tmp___65 = ldv_init_zalloc(1UL);
#line 1662
  ldvarg320 = tmp___65;
#line 1663
  tmp___66 = ldv_init_zalloc(376UL);
#line 1663
  ldvarg297 = (srb_t *)tmp___66;
#line 1667
  tmp___67 = ldv_init_zalloc(376UL);
#line 1667
  ldvarg316 = (srb_t *)tmp___67;
#line 1668
  tmp___68 = ldv_init_zalloc(4UL);
#line 1668
  ldvarg294 = (uint32_t *)tmp___68;
#line 1669
  tmp___69 = ldv_init_zalloc(32UL);
#line 1669
  ldvarg324 = (struct pci_device_id *)tmp___69;
#line 1672
  tmp___70 = ldv_init_zalloc(1UL);
#line 1672
  ldvarg372 = tmp___70;
#line 1673
  tmp___71 = ldv_init_zalloc(1UL);
#line 1673
  ldvarg390 = (uint8_t *)tmp___71;
#line 1681
  tmp___72 = ldv_init_zalloc(376UL);
#line 1681
  ldvarg383 = (srb_t *)tmp___72;
#line 1684
  tmp___73 = ldv_init_zalloc(4UL);
#line 1684
  ldvarg365 = (uint32_t *)tmp___73;
#line 1689
  tmp___74 = ldv_init_zalloc(1UL);
#line 1689
  ldvarg387 = tmp___74;
#line 1691
  tmp___75 = ldv_init_zalloc(1UL);
#line 1691
  ldvarg374 = (char *)tmp___75;
#line 1692
  tmp___76 = ldv_init_zalloc(1UL);
#line 1692
  ldvarg370 = (uint8_t *)tmp___76;
#line 1697
  tmp___77 = ldv_init_zalloc(1UL);
#line 1697
  ldvarg358 = (uint8_t *)tmp___77;
#line 1699
  tmp___78 = ldv_init_zalloc(376UL);
#line 1699
  ldvarg367 = (srb_t *)tmp___78;
#line 1702
  tmp___79 = ldv_init_zalloc(2UL);
#line 1702
  ldvarg359 = (uint16_t *)tmp___79;
#line 1708
  tmp___80 = ldv_init_zalloc(1UL);
#line 1708
  ldvarg371 = (char *)tmp___80;
#line 1710
  tmp___81 = ldv_init_zalloc(1UL);
#line 1710
  ldvarg355 = (uint8_t *)tmp___81;
#line 1712
  tmp___82 = ldv_init_zalloc(1UL);
#line 1712
  ldvarg404 = (uint8_t *)tmp___82;
#line 1717
  tmp___83 = ldv_init_zalloc(1UL);
#line 1717
  ldvarg408 = (char *)tmp___83;
#line 1719
  tmp___84 = ldv_init_zalloc(1UL);
#line 1719
  ldvarg424 = (uint8_t *)tmp___84;
#line 1728
  tmp___85 = ldv_init_zalloc(2UL);
#line 1728
  ldvarg393 = (uint16_t *)tmp___85;
#line 1729
  tmp___86 = ldv_init_zalloc(1UL);
#line 1729
  ldvarg405 = (char *)tmp___86;
#line 1731
  tmp___87 = ldv_init_zalloc(4UL);
#line 1731
  ldvarg399 = (uint32_t *)tmp___87;
#line 1732
  tmp___88 = ldv_init_zalloc(1UL);
#line 1732
  ldvarg406 = tmp___88;
#line 1736
  tmp___89 = ldv_init_zalloc(376UL);
#line 1736
  ldvarg401 = (srb_t *)tmp___89;
#line 1737
  tmp___90 = ldv_init_zalloc(1UL);
#line 1737
  ldvarg421 = tmp___90;
#line 1738
  tmp___91 = ldv_init_zalloc(376UL);
#line 1738
  ldvarg417 = (srb_t *)tmp___91;
#line 1748
  tmp___92 = ldv_init_zalloc(1UL);
#line 1748
  ldvarg469 = tmp___92;
#line 1750
  tmp___93 = ldv_init_zalloc(1UL);
#line 1750
  ldvarg458 = tmp___93;
#line 1752
  tmp___94 = ldv_init_zalloc(376UL);
#line 1752
  ldvarg465 = (srb_t *)tmp___94;
#line 1755
  tmp___95 = ldv_init_zalloc(1UL);
#line 1755
  ldvarg472 = (uint8_t *)tmp___95;
#line 1757
  tmp___96 = ldv_init_zalloc(1UL);
#line 1757
  ldvarg449 = (uint8_t *)tmp___96;
#line 1758
  tmp___97 = ldv_init_zalloc(1UL);
#line 1758
  ldvarg452 = (uint8_t *)tmp___97;
#line 1759
  tmp___98 = ldv_init_zalloc(1UL);
#line 1759
  ldvarg457 = (char *)tmp___98;
#line 1764
  tmp___99 = ldv_init_zalloc(1UL);
#line 1764
  ldvarg460 = (char *)tmp___99;
#line 1771
  tmp___100 = ldv_init_zalloc(1UL);
#line 1771
  ldvarg456 = (uint8_t *)tmp___100;
#line 1772
  tmp___101 = ldv_init_zalloc(376UL);
#line 1772
  ldvarg453 = (srb_t *)tmp___101;
#line 1776
  tmp___102 = ldv_init_zalloc(2UL);
#line 1776
  ldvarg487 = (uint16_t *)tmp___102;
#line 1777
  tmp___103 = ldv_init_zalloc(1UL);
#line 1777
  ldvarg500 = tmp___103;
#line 1779
  tmp___104 = ldv_init_zalloc(1UL);
#line 1779
  ldvarg518 = (uint8_t *)tmp___104;
#line 1783
  tmp___105 = ldv_init_zalloc(1UL);
#line 1783
  ldvarg515 = tmp___105;
#line 1790
  tmp___106 = ldv_init_zalloc(1UL);
#line 1790
  ldvarg483 = (uint8_t *)tmp___106;
#line 1794
  tmp___107 = ldv_init_zalloc(1UL);
#line 1794
  ldvarg499 = (char *)tmp___107;
#line 1795
  tmp___108 = ldv_init_zalloc(1UL);
#line 1795
  ldvarg498 = (uint8_t *)tmp___108;
#line 1797
  tmp___109 = ldv_init_zalloc(4UL);
#line 1797
  ldvarg493 = (uint32_t *)tmp___109;
#line 1802
  tmp___110 = ldv_init_zalloc(1UL);
#line 1802
  ldvarg502 = (char *)tmp___110;
#line 1806
  tmp___111 = ldv_init_zalloc(376UL);
#line 1806
  ldvarg495 = (srb_t *)tmp___111;
#line 1810
  tmp___112 = ldv_init_zalloc(1UL);
#line 1810
  ldvarg486 = (uint8_t *)tmp___112;
#line 1811
  tmp___113 = ldv_init_zalloc(376UL);
#line 1811
  ldvarg511 = (srb_t *)tmp___113;
#line 1436
  ldv_initialize();
#line 1438
  ldv_memset((void *)(& ldvarg18), 0, 1UL);
#line 1439
  ldv_memset((void *)(& ldvarg32), 0, 8UL);
#line 1442
  ldv_memset((void *)(& ldvarg42), 0, 4UL);
#line 1444
  ldv_memset((void *)(& ldvarg37), 0, 2UL);
#line 1445
  ldv_memset((void *)(& ldvarg29), 0, 8UL);
#line 1446
  ldv_memset((void *)(& ldvarg44), 0, 4UL);
#line 1447
  ldv_memset((void *)(& ldvarg24), 0, 4UL);
#line 1448
  ldv_memset((void *)(& ldvarg35), 0, 1UL);
#line 1449
  ldv_memset((void *)(& ldvarg38), 0, 1UL);
#line 1450
  ldv_memset((void *)(& ldvarg33), 0, 4UL);
#line 1451
  ldv_memset((void *)(& ldvarg16), 0, 1UL);
#line 1452
  ldv_memset((void *)(& ldvarg14), 0, 4UL);
#line 1453
  ldv_memset((void *)(& ldvarg34), 0, 4UL);
#line 1456
  ldv_memset((void *)(& ldvarg20), 0, 1UL);
#line 1457
  ldv_memset((void *)(& ldvarg31), 0, 4UL);
#line 1458
  ldv_memset((void *)(& ldvarg41), 0, 8UL);
#line 1459
  ldv_memset((void *)(& ldvarg13), 0, 4UL);
#line 1460
  ldv_memset((void *)(& ldvarg36), 0, 1UL);
#line 1461
  ldv_memset((void *)(& ldvarg40), 0, 4UL);
#line 1462
  ldv_memset((void *)(& ldvarg45), 0, 4UL);
#line 1468
  ldv_memset((void *)(& ldvarg25), 0, 4UL);
#line 1469
  ldv_memset((void *)(& ldvarg17), 0, 1UL);
#line 1470
  ldv_memset((void *)(& ldvarg22), 0, 4UL);
#line 1471
  ldv_memset((void *)(& ldvarg19), 0, 2UL);
#line 1472
  ldv_memset((void *)(& ldvarg77), 0, 4UL);
#line 1473
  ldv_memset((void *)(& ldvarg84), 0, 8UL);
#line 1474
  ldv_memset((void *)(& ldvarg94), 0, 4UL);
#line 1477
  ldv_memset((void *)(& ldvarg71), 0, 2UL);
#line 1478
  ldv_memset((void *)(& ldvarg72), 0, 1UL);
#line 1480
  ldv_memset((void *)(& ldvarg97), 0, 4UL);
#line 1481
  ldv_memset((void *)(& ldvarg64), 0, 4UL);
#line 1482
  ldv_memset((void *)(& ldvarg83), 0, 4UL);
#line 1484
  ldv_memset((void *)(& ldvarg85), 0, 4UL);
#line 1485
  ldv_memset((void *)(& ldvarg69), 0, 1UL);
#line 1486
  ldv_memset((void *)(& ldvarg93), 0, 8UL);
#line 1487
  ldv_memset((void *)(& ldvarg89), 0, 2UL);
#line 1488
  ldv_memset((void *)(& ldvarg60), 0, 4UL);
#line 1490
  ldv_memset((void *)(& ldvarg59), 0, 4UL);
#line 1491
  ldv_memset((void *)(& ldvarg87), 0, 1UL);
#line 1492
  ldv_memset((void *)(& ldvarg86), 0, 4UL);
#line 1493
  ldv_memset((void *)(& ldvarg62), 0, 4UL);
#line 1494
  ldv_memset((void *)(& ldvarg65), 0, 4UL);
#line 1497
  ldv_memset((void *)(& ldvarg96), 0, 4UL);
#line 1498
  ldv_memset((void *)(& ldvarg81), 0, 8UL);
#line 1501
  ldv_memset((void *)(& ldvarg70), 0, 1UL);
#line 1502
  ldv_memset((void *)(& ldvarg88), 0, 1UL);
#line 1504
  ldv_memset((void *)(& ldvarg68), 0, 1UL);
#line 1505
  ldv_memset((void *)(& ldvarg90), 0, 1UL);
#line 1506
  ldv_memset((void *)(& ldvarg61), 0, 4UL);
#line 1507
  ldv_memset((void *)(& ldvarg92), 0, 4UL);
#line 1508
  ldv_memset((void *)(& ldvarg74), 0, 4UL);
#line 1509
  ldv_memset((void *)(& ldvarg76), 0, 4UL);
#line 1512
  ldv_memset((void *)(& ldvarg131), 0, 4UL);
#line 1514
  ldv_memset((void *)(& ldvarg146), 0, 4UL);
#line 1515
  ldv_memset((void *)(& ldvarg141), 0, 1UL);
#line 1517
  ldv_memset((void *)(& ldvarg125), 0, 2UL);
#line 1519
  ldv_memset((void *)(& ldvarg140), 0, 4UL);
#line 1522
  ldv_memset((void *)(& ldvarg138), 0, 8UL);
#line 1525
  ldv_memset((void *)(& ldvarg142), 0, 1UL);
#line 1527
  ldv_memset((void *)(& ldvarg151), 0, 4UL);
#line 1528
  ldv_memset((void *)(& ldvarg137), 0, 4UL);
#line 1529
  ldv_memset((void *)(& ldvarg122), 0, 1UL);
#line 1530
  ldv_memset((void *)(& ldvarg144), 0, 1UL);
#line 1531
  ldv_memset((void *)(& ldvarg128), 0, 4UL);
#line 1532
  ldv_memset((void *)(& ldvarg126), 0, 1UL);
#line 1533
  ldv_memset((void *)(& ldvarg123), 0, 1UL);
#line 1534
  ldv_memset((void *)(& ldvarg120), 0, 4UL);
#line 1535
  ldv_memset((void *)(& ldvarg135), 0, 8UL);
#line 1536
  ldv_memset((void *)(& ldvarg119), 0, 4UL);
#line 1537
  ldv_memset((void *)(& ldvarg147), 0, 8UL);
#line 1539
  ldv_memset((void *)(& ldvarg124), 0, 1UL);
#line 1541
  ldv_memset((void *)(& ldvarg150), 0, 4UL);
#line 1542
  ldv_memset((void *)(& ldvarg143), 0, 2UL);
#line 1543
  ldv_memset((void *)(& ldvarg130), 0, 4UL);
#line 1544
  ldv_memset((void *)(& ldvarg139), 0, 4UL);
#line 1545
  ldv_memset((void *)(& ldvarg148), 0, 4UL);
#line 1547
  ldv_memset((void *)(& ldvarg157), 0, 4UL);
#line 1549
  ldv_memset((void *)(& ldvarg174), 0, 2UL);
#line 1550
  ldv_memset((void *)(& ldvarg168), 0, 2UL);
#line 1551
  ldv_memset((void *)(& ldvarg165), 0, 1UL);
#line 1552
  ldv_memset((void *)(& ldvarg188), 0, 1UL);
#line 1553
  ldv_memset((void *)(& ldvarg185), 0, 8UL);
#line 1554
  ldv_memset((void *)(& ldvarg191), 0, 1UL);
#line 1555
  ldv_memset((void *)(& ldvarg167), 0, 1UL);
#line 1557
  ldv_memset((void *)(& ldvarg197), 0, 4UL);
#line 1559
  ldv_memset((void *)(& ldvarg189), 0, 1UL);
#line 1560
  ldv_memset((void *)(& ldvarg182), 0, 8UL);
#line 1561
  ldv_memset((void *)(& ldvarg198), 0, 4UL);
#line 1564
  ldv_memset((void *)(& ldvarg169), 0, 1UL);
#line 1565
  ldv_memset((void *)(& ldvarg161), 0, 4UL);
#line 1567
  ldv_memset((void *)(& ldvarg158), 0, 4UL);
#line 1569
  ldv_memset((void *)(& ldvarg195), 0, 4UL);
#line 1570
  ldv_memset((void *)(& ldvarg187), 0, 4UL);
#line 1572
  ldv_memset((void *)(& ldvarg184), 0, 4UL);
#line 1573
  ldv_memset((void *)(& ldvarg186), 0, 4UL);
#line 1574
  ldv_memset((void *)(& ldvarg190), 0, 2UL);
#line 1575
  ldv_memset((void *)(& ldvarg177), 0, 4UL);
#line 1576
  ldv_memset((void *)(& ldvarg193), 0, 4UL);
#line 1577
  ldv_memset((void *)(& ldvarg156), 0, 4UL);
#line 1578
  ldv_memset((void *)(& ldvarg166), 0, 1UL);
#line 1582
  ldv_memset((void *)(& ldvarg176), 0, 4UL);
#line 1583
  ldv_memset((void *)(& ldvarg194), 0, 8UL);
#line 1586
  ldv_memset((void *)(& ldvarg180), 0, 2UL);
#line 1587
  ldv_memset((void *)(& ldvarg171), 0, 4UL);
#line 1588
  ldv_memset((void *)(& ldvarg159), 0, 4UL);
#line 1589
  ldv_memset((void *)(& ldvarg162), 0, 4UL);
#line 1590
  ldv_memset((void *)(& ldvarg200), 0, 4UL);
#line 1591
  ldv_memset((void *)(& ldvarg242), 0, 4UL);
#line 1593
  ldv_memset((void *)(& ldvarg225), 0, 1UL);
#line 1594
  ldv_memset((void *)(& ldvarg247), 0, 1UL);
#line 1595
  ldv_memset((void *)(& ldvarg233), 0, 4UL);
#line 1597
  ldv_memset((void *)(& ldvarg243), 0, 4UL);
#line 1598
  ldv_memset((void *)(& ldvarg234), 0, 4UL);
#line 1599
  ldv_memset((void *)(& ldvarg244), 0, 1UL);
#line 1600
  ldv_memset((void *)(& ldvarg228), 0, 2UL);
#line 1601
  ldv_memset((void *)(& ldvarg226), 0, 1UL);
#line 1602
  ldv_memset((void *)(& ldvarg222), 0, 4UL);
#line 1606
  ldv_memset((void *)(& ldvarg240), 0, 4UL);
#line 1607
  ldv_memset((void *)(& ldvarg241), 0, 8UL);
#line 1608
  ldv_memset((void *)(& ldvarg246), 0, 2UL);
#line 1609
  ldv_memset((void *)(& ldvarg231), 0, 4UL);
#line 1610
  ldv_memset((void *)(& ldvarg238), 0, 8UL);
#line 1611
  ldv_memset((void *)(& ldvarg254), 0, 4UL);
#line 1614
  ldv_memset((void *)(& ldvarg223), 0, 4UL);
#line 1616
  ldv_memset((void *)(& ldvarg245), 0, 1UL);
#line 1618
  ldv_memset((void *)(& ldvarg229), 0, 1UL);
#line 1619
  ldv_memset((void *)(& ldvarg227), 0, 1UL);
#line 1620
  ldv_memset((void *)(& ldvarg251), 0, 4UL);
#line 1621
  ldv_memset((void *)(& ldvarg250), 0, 8UL);
#line 1622
  ldv_memset((void *)(& ldvarg249), 0, 4UL);
#line 1624
  ldv_memset((void *)(& ldvarg253), 0, 4UL);
#line 1625
  ldv_memset((void *)(& ldvarg290), 0, 1UL);
#line 1626
  ldv_memset((void *)(& ldvarg315), 0, 1UL);
#line 1627
  ldv_memset((void *)(& ldvarg308), 0, 4UL);
#line 1629
  ldv_memset((void *)(& ldvarg313), 0, 1UL);
#line 1632
  ldv_memset((void *)(& ldvarg321), 0, 4UL);
#line 1633
  ldv_memset((void *)(& ldvarg311), 0, 4UL);
#line 1634
  ldv_memset((void *)(& ldvarg309), 0, 8UL);
#line 1635
  ldv_memset((void *)(& ldvarg322), 0, 4UL);
#line 1636
  ldv_memset((void *)(& ldvarg285), 0, 4UL);
#line 1637
  ldv_memset((void *)(& ldvarg300), 0, 4UL);
#line 1638
  ldv_memset((void *)(& ldvarg310), 0, 4UL);
#line 1639
  ldv_memset((void *)(& ldvarg295), 0, 4UL);
#line 1641
  ldv_memset((void *)(& ldvarg281), 0, 4UL);
#line 1645
  ldv_memset((void *)(& ldvarg280), 0, 4UL);
#line 1646
  ldv_memset((void *)(& ldvarg317), 0, 4UL);
#line 1647
  ldv_memset((void *)(& ldvarg304), 0, 2UL);
#line 1648
  ldv_memset((void *)(& ldvarg312), 0, 1UL);
#line 1649
  ldv_memset((void *)(& ldvarg318), 0, 8UL);
#line 1650
  ldv_memset((void *)(& ldvarg293), 0, 1UL);
#line 1652
  ldv_memset((void *)(& ldvarg291), 0, 1UL);
#line 1653
  ldv_memset((void *)(& ldvarg289), 0, 1UL);
#line 1654
  ldv_memset((void *)(& ldvarg306), 0, 8UL);
#line 1655
  ldv_memset((void *)(& ldvarg314), 0, 2UL);
#line 1656
  ldv_memset((void *)(& ldvarg319), 0, 4UL);
#line 1657
  ldv_memset((void *)(& ldvarg282), 0, 4UL);
#line 1659
  ldv_memset((void *)(& ldvarg301), 0, 4UL);
#line 1661
  ldv_memset((void *)(& ldvarg286), 0, 4UL);
#line 1664
  ldv_memset((void *)(& ldvarg292), 0, 2UL);
#line 1665
  ldv_memset((void *)(& ldvarg283), 0, 4UL);
#line 1666
  ldv_memset((void *)(& ldvarg298), 0, 2UL);
#line 1670
  ldv_memset((void *)(& ldvarg349), 0, 4UL);
#line 1671
  ldv_memset((void *)(& ldvarg350), 0, 8UL);
#line 1674
  ldv_memset((void *)(& ldvarg389), 0, 4UL);
#line 1675
  ldv_memset((void *)(& ldvarg357), 0, 4UL);
#line 1676
  ldv_memset((void *)(& ldvarg381), 0, 2UL);
#line 1677
  ldv_memset((void *)(& ldvarg352), 0, 4UL);
#line 1678
  ldv_memset((void *)(& ldvarg380), 0, 1UL);
#line 1679
  ldv_memset((void *)(& ldvarg363), 0, 2UL);
#line 1680
  ldv_memset((void *)(& ldvarg369), 0, 4UL);
#line 1682
  ldv_memset((void *)(& ldvarg362), 0, 1UL);
#line 1683
  ldv_memset((void *)(& ldvarg379), 0, 1UL);
#line 1685
  ldv_memset((void *)(& ldvarg360), 0, 1UL);
#line 1686
  ldv_memset((void *)(& ldvarg364), 0, 1UL);
#line 1687
  ldv_memset((void *)(& ldvarg376), 0, 8UL);
#line 1688
  ldv_memset((void *)(& ldvarg377), 0, 4UL);
#line 1690
  ldv_memset((void *)(& ldvarg386), 0, 4UL);
#line 1693
  ldv_memset((void *)(& ldvarg361), 0, 1UL);
#line 1694
  ldv_memset((void *)(& ldvarg354), 0, 4UL);
#line 1695
  ldv_memset((void *)(& ldvarg375), 0, 4UL);
#line 1696
  ldv_memset((void *)(& ldvarg384), 0, 4UL);
#line 1698
  ldv_memset((void *)(& ldvarg351), 0, 4UL);
#line 1700
  ldv_memset((void *)(& ldvarg378), 0, 4UL);
#line 1701
  ldv_memset((void *)(& ldvarg382), 0, 1UL);
#line 1703
  ldv_memset((void *)(& ldvarg368), 0, 4UL);
#line 1704
  ldv_memset((void *)(& ldvarg353), 0, 4UL);
#line 1705
  ldv_memset((void *)(& ldvarg373), 0, 8UL);
#line 1706
  ldv_memset((void *)(& ldvarg388), 0, 4UL);
#line 1707
  ldv_memset((void *)(& ldvarg385), 0, 8UL);
#line 1709
  ldv_memset((void *)(& ldvarg366), 0, 4UL);
#line 1711
  ldv_memset((void *)(& ldvarg356), 0, 4UL);
#line 1713
  ldv_memset((void *)(& ldvarg412), 0, 4UL);
#line 1714
  ldv_memset((void *)(& ldvarg397), 0, 2UL);
#line 1715
  ldv_memset((void *)(& ldvarg396), 0, 1UL);
#line 1716
  ldv_memset((void *)(& ldvarg394), 0, 1UL);
#line 1718
  ldv_memset((void *)(& ldvarg403), 0, 4UL);
#line 1720
  ldv_memset((void *)(& ldvarg416), 0, 1UL);
#line 1721
  ldv_memset((void *)(& ldvarg395), 0, 1UL);
#line 1722
  ldv_memset((void *)(& ldvarg398), 0, 1UL);
#line 1723
  ldv_memset((void *)(& ldvarg423), 0, 4UL);
#line 1724
  ldv_memset((void *)(& ldvarg415), 0, 2UL);
#line 1725
  ldv_memset((void *)(& ldvarg418), 0, 4UL);
#line 1726
  ldv_memset((void *)(& ldvarg422), 0, 4UL);
#line 1727
  ldv_memset((void *)(& ldvarg407), 0, 8UL);
#line 1730
  ldv_memset((void *)(& ldvarg409), 0, 4UL);
#line 1733
  ldv_memset((void *)(& ldvarg392), 0, 4UL);
#line 1734
  ldv_memset((void *)(& ldvarg419), 0, 8UL);
#line 1735
  ldv_memset((void *)(& ldvarg420), 0, 4UL);
#line 1739
  ldv_memset((void *)(& ldvarg410), 0, 8UL);
#line 1740
  ldv_memset((void *)(& ldvarg402), 0, 4UL);
#line 1741
  ldv_memset((void *)(& ldvarg400), 0, 4UL);
#line 1742
  ldv_memset((void *)(& ldvarg391), 0, 4UL);
#line 1743
  ldv_memset((void *)(& ldvarg413), 0, 1UL);
#line 1744
  ldv_memset((void *)(& ldvarg411), 0, 4UL);
#line 1745
  ldv_memset((void *)(& ldvarg414), 0, 1UL);
#line 1746
  ldv_memset((void *)(& ldvarg426), 0, 8UL);
#line 1747
  ldv_memset((void *)(& ldvarg425), 0, 4UL);
#line 1749
  ldv_memset((void *)(& ldvarg448), 0, 4UL);
#line 1751
  ldv_memset((void *)(& ldvarg463), 0, 4UL);
#line 1753
  ldv_memset((void *)(& ldvarg459), 0, 8UL);
#line 1754
  ldv_memset((void *)(& ldvarg464), 0, 4UL);
#line 1756
  ldv_memset((void *)(& ldvarg461), 0, 4UL);
#line 1760
  ldv_memset((void *)(& ldvarg447), 0, 4UL);
#line 1761
  ldv_memset((void *)(& ldvarg450), 0, 4UL);
#line 1762
  ldv_memset((void *)(& ldvarg462), 0, 8UL);
#line 1763
  ldv_memset((void *)(& ldvarg446), 0, 4UL);
#line 1765
  ldv_memset((void *)(& ldvarg471), 0, 4UL);
#line 1766
  ldv_memset((void *)(& ldvarg468), 0, 4UL);
#line 1767
  ldv_memset((void *)(& ldvarg451), 0, 4UL);
#line 1768
  ldv_memset((void *)(& ldvarg454), 0, 4UL);
#line 1769
  ldv_memset((void *)(& ldvarg455), 0, 4UL);
#line 1770
  ldv_memset((void *)(& ldvarg467), 0, 8UL);
#line 1773
  ldv_memset((void *)(& ldvarg470), 0, 4UL);
#line 1774
  ldv_memset((void *)(& ldvarg445), 0, 4UL);
#line 1775
  ldv_memset((void *)(& ldvarg466), 0, 4UL);
#line 1778
  ldv_memset((void *)(& ldvarg479), 0, 4UL);
#line 1780
  ldv_memset((void *)(& ldvarg485), 0, 4UL);
#line 1781
  ldv_memset((void *)(& ldvarg512), 0, 4UL);
#line 1782
  ldv_memset((void *)(& ldvarg488), 0, 1UL);
#line 1784
  ldv_memset((void *)(& ldvarg506), 0, 4UL);
#line 1785
  ldv_memset((void *)(& ldvarg501), 0, 8UL);
#line 1786
  ldv_memset((void *)(& ldvarg509), 0, 2UL);
#line 1787
  ldv_memset((void *)(& ldvarg514), 0, 4UL);
#line 1788
  ldv_memset((void *)(& ldvarg496), 0, 4UL);
#line 1789
  ldv_memset((void *)(& ldvarg507), 0, 1UL);
#line 1791
  ldv_memset((void *)(& ldvarg484), 0, 4UL);
#line 1792
  ldv_memset((void *)(& ldvarg504), 0, 8UL);
#line 1793
  ldv_memset((void *)(& ldvarg490), 0, 1UL);
#line 1796
  ldv_memset((void *)(& ldvarg480), 0, 4UL);
#line 1798
  ldv_memset((void *)(& ldvarg516), 0, 4UL);
#line 1799
  ldv_memset((void *)(& ldvarg489), 0, 1UL);
#line 1800
  ldv_memset((void *)(& ldvarg508), 0, 1UL);
#line 1801
  ldv_memset((void *)(& ldvarg497), 0, 4UL);
#line 1803
  ldv_memset((void *)(& ldvarg510), 0, 1UL);
#line 1804
  ldv_memset((void *)(& ldvarg517), 0, 4UL);
#line 1805
  ldv_memset((void *)(& ldvarg482), 0, 4UL);
#line 1807
  ldv_memset((void *)(& ldvarg491), 0, 2UL);
#line 1808
  ldv_memset((void *)(& ldvarg503), 0, 4UL);
#line 1809
  ldv_memset((void *)(& ldvarg494), 0, 4UL);
#line 1812
  ldv_memset((void *)(& ldvarg481), 0, 4UL);
#line 1813
  ldv_memset((void *)(& ldvarg492), 0, 1UL);
#line 1814
  ldv_memset((void *)(& ldvarg513), 0, 8UL);
#line 1815
  ldv_memset((void *)(& ldvarg505), 0, 4UL);
#line 1817
  ldv_state_variable_33 = 0;
#line 1818
  ldv_state_variable_32 = 0;
#line 1819
  ldv_state_variable_63 = 0;
#line 1821
  ldv_state_variable_21 = 1;
#line 1822
  ldv_state_variable_71 = 0;
#line 1824
  work_init_7();
#line 1826
  ldv_state_variable_7 = 1;
#line 1827
  ldv_state_variable_80 = 0;
#line 1829
  ldv_state_variable_26 = 1;
#line 1831
  ldv_state_variable_18 = 1;
#line 1832
  ldv_state_variable_72 = 0;
#line 1834
  ldv_state_variable_16 = 1;
#line 1835
  ldv_state_variable_44 = 0;
#line 1836
  ldv_state_variable_55 = 0;
#line 1837
  ldv_state_variable_84 = 0;
#line 1838
  ldv_state_variable_74 = 0;
#line 1840
  ldv_state_variable_27 = 1;
#line 1841
  ldv_state_variable_57 = 0;
#line 1842
  ldv_state_variable_61 = 0;
#line 1844
  ldv_state_variable_20 = 1;
#line 1846
  work_init_10();
#line 1848
  ldv_state_variable_10 = 1;
#line 1849
  ldv_state_variable_31 = 0;
#line 1850
  ldv_state_variable_35 = 0;
#line 1852
  work_init_11();
#line 1854
  ldv_state_variable_11 = 1;
#line 1855
  ldv_state_variable_78 = 0;
#line 1856
  ldv_state_variable_48 = 0;
#line 1857
  ldv_state_variable_87 = 0;
#line 1858
  ldv_state_variable_77 = 0;
#line 1859
  ldv_state_variable_65 = 0;
#line 1861
  ldv_state_variable_29 = 1;
#line 1862
  ldv_state_variable_50 = 0;
#line 1863
  ldv_state_variable_39 = 0;
#line 1864
  ldv_state_variable_64 = 0;
#line 1865
  ldv_state_variable_58 = 0;
#line 1866
  ldv_state_variable_41 = 0;
#line 1868
  work_init_12();
#line 1870
  ldv_state_variable_12 = 1;
#line 1872
  ldv_state_variable_15 = 1;
#line 1873
  ldv_state_variable_81 = 0;
#line 1874
  ldv_state_variable_52 = 0;
#line 1875
  ldv_state_variable_60 = 0;
#line 1876
  ldv_state_variable_56 = 0;
#line 1877
  ldv_state_variable_73 = 0;
#line 1878
  ldv_state_variable_66 = 0;
#line 1879
  ldv_state_variable_45 = 0;
#line 1880
  ldv_state_variable_86 = 0;
#line 1881
  ldv_state_variable_76 = 0;
#line 1883
  ldv_state_variable_19 = 1;
#line 1884
  ldv_state_variable_62 = 0;
#line 1885
  ldv_state_variable_54 = 0;
#line 1886
  ldv_state_variable_67 = 0;
#line 1887
  ldv_state_variable_70 = 0;
#line 1888
  ldv_state_variable_68 = 0;
#line 1890
  work_init_2();
#line 1892
  ldv_state_variable_2 = 1;
#line 1894
  ldv_state_variable_17 = 1;
#line 1896
  work_init_1();
#line 1898
  ldv_state_variable_1 = 1;
#line 1899
  ldv_state_variable_88 = 0;
#line 1901
  ldv_state_variable_30 = 1;
#line 1902
  ldv_state_variable_82 = 0;
#line 1904
  ldv_state_variable_25 = 1;
#line 1906
  ldv_state_variable_28 = 1;
#line 1907
  ldv_state_variable_83 = 0;
#line 1908
  ldv_state_variable_75 = 0;
#line 1909
  ldv_state_variable_40 = 0;
#line 1911
  ldv_state_variable_14 = 1;
#line 1912
  ldv_state_variable_69 = 0;
#line 1913
  ldv_state_variable_59 = 0;
#line 1914
  ldv_state_variable_49 = 0;
#line 1916
  ldv_state_variable_24 = 1;
#line 1917
  ldv_state_variable_53 = 0;
#line 1918
  ldv_state_variable_79 = 0;
#line 1920
  ldv_state_variable_22 = 1;
#line 1921
  ldv_state_variable_42 = 0;
#line 1922
  ref_cnt = 0;
#line 1923
  ldv_state_variable_0 = 1;
#line 1924
  ldv_state_variable_46 = 0;
#line 1926
  ldv_state_variable_23 = 1;
#line 1928
  ldv_state_variable_13 = 1;
#line 1930
  work_init_6();
#line 1932
  ldv_state_variable_6 = 1;
#line 1933
  ldv_state_variable_85 = 0;
#line 1935
  work_init_3();
#line 1937
  ldv_state_variable_3 = 1;
#line 1938
  ldv_state_variable_36 = 0;
#line 1940
  work_init_9();
#line 1942
  ldv_state_variable_9 = 1;
#line 1943
  ldv_state_variable_51 = 0;
#line 1944
  ldv_state_variable_47 = 0;
#line 1946
  work_init_8();
#line 1948
  ldv_state_variable_8 = 1;
#line 1949
  ldv_state_variable_38 = 0;
#line 1951
  work_init_4();
#line 1953
  ldv_state_variable_4 = 1;
#line 1954
  ldv_state_variable_34 = 0;
#line 1955
  ldv_state_variable_37 = 0;
#line 1956
  ldv_state_variable_43 = 0;
#line 1958
  work_init_5();
#line 1960
  ldv_state_variable_5 = 1;
  ldv_69159: 
#line 1962
  tmp___114 = __VERIFIER_nondet_int();
#line 1962
  switch (tmp___114) {
  case 0: ;
#line 1966
  if (ldv_state_variable_33 != 0) {
#line 1967
    ldv_main_exported_33();
  } else {

  }
#line 1970
  goto ldv_68677;
  case 1: ;
#line 1974
  if (ldv_state_variable_32 != 0) {
#line 1975
    ldv_main_exported_32();
  } else {

  }
#line 1978
  goto ldv_68677;
  case 2: ;
#line 1982
  if (ldv_state_variable_63 != 0) {
#line 1983
    ldv_main_exported_63();
  } else {

  }
#line 1986
  goto ldv_68677;
  case 3: ;
#line 1993
  goto ldv_68677;
  case 4: ;
#line 1997
  if (ldv_state_variable_71 != 0) {
#line 1998
    ldv_main_exported_71();
  } else {

  }
#line 2001
  goto ldv_68677;
  case 5: ;
#line 2008
  goto ldv_68677;
  case 6: ;
#line 2012
  if (ldv_state_variable_80 != 0) {
#line 2013
    tmp___115 = __VERIFIER_nondet_int();
#line 2013
    switch (tmp___115) {
    case 0: ;
#line 2016
    if (ldv_state_variable_80 == 1) {
#line 2018
      qla24xx_reset_adapter(qla83xx_isp_ops_group0);
#line 2020
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2023
    if (ldv_state_variable_80 == 2) {
#line 2025
      qla24xx_reset_adapter(qla83xx_isp_ops_group0);
#line 2027
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2030
    goto ldv_68685;
    case 1: ;
#line 2033
    if (ldv_state_variable_80 == 2) {
#line 2035
      qla24xx_write_optrom_data(qla83xx_isp_ops_group0, ldvarg46, ldvarg45, ldvarg44);
#line 2037
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2040
    goto ldv_68685;
    case 2: ;
#line 2043
    if (ldv_state_variable_80 == 1) {
#line 2045
      qla24xx_enable_intrs(qla83xx_isp_ops_group1);
#line 2047
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2050
    if (ldv_state_variable_80 == 2) {
#line 2052
      qla24xx_enable_intrs(qla83xx_isp_ops_group1);
#line 2054
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2057
    goto ldv_68685;
    case 3: ;
#line 2060
    if (ldv_state_variable_80 == 1) {
#line 2062
      qla24xx_intr_handler(ldvarg42, ldvarg43);
#line 2064
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2067
    if (ldv_state_variable_80 == 2) {
#line 2069
      qla24xx_intr_handler(ldvarg42, ldvarg43);
#line 2071
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2074
    goto ldv_68685;
    case 4: ;
#line 2077
    if (ldv_state_variable_80 == 1) {
#line 2079
      qla24xx_abort_target(qla83xx_isp_ops_group2, ldvarg41, ldvarg40);
#line 2081
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2084
    if (ldv_state_variable_80 == 2) {
#line 2086
      qla24xx_abort_target(qla83xx_isp_ops_group2, ldvarg41, ldvarg40);
#line 2088
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2091
    goto ldv_68685;
    case 5: ;
#line 2094
    if (ldv_state_variable_80 == 1) {
#line 2096
      qla81xx_update_fw_options(qla83xx_isp_ops_group0);
#line 2098
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2101
    if (ldv_state_variable_80 == 2) {
#line 2103
      qla81xx_update_fw_options(qla83xx_isp_ops_group0);
#line 2105
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2108
    goto ldv_68685;
    case 6: ;
#line 2111
    if (ldv_state_variable_80 == 1) {
#line 2113
      qla2x00_abort_isp(qla83xx_isp_ops_group0);
#line 2115
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2118
    if (ldv_state_variable_80 == 2) {
#line 2120
      qla2x00_abort_isp(qla83xx_isp_ops_group0);
#line 2122
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2125
    goto ldv_68685;
    case 7: ;
#line 2128
    if (ldv_state_variable_80 == 1) {
#line 2130
      qla24xx_dif_start_scsi(ldvarg39);
#line 2132
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2135
    if (ldv_state_variable_80 == 2) {
#line 2137
      qla24xx_dif_start_scsi(ldvarg39);
#line 2139
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2142
    goto ldv_68685;
    case 8: ;
#line 2145
    if (ldv_state_variable_80 == 1) {
#line 2147
      qla24xx_chip_diag(qla83xx_isp_ops_group0);
#line 2149
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2152
    if (ldv_state_variable_80 == 2) {
#line 2154
      qla24xx_chip_diag(qla83xx_isp_ops_group0);
#line 2156
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2159
    goto ldv_68685;
    case 9: ;
#line 2162
    if (ldv_state_variable_80 == 1) {
#line 2164
      qla24xx_fabric_logout(qla83xx_isp_ops_group0, (int )ldvarg37, (int )ldvarg36,
                            (int )ldvarg35, (int )ldvarg38);
#line 2166
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2169
    if (ldv_state_variable_80 == 2) {
#line 2171
      qla24xx_fabric_logout(qla83xx_isp_ops_group0, (int )ldvarg37, (int )ldvarg36,
                            (int )ldvarg35, (int )ldvarg38);
#line 2173
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2176
    goto ldv_68685;
    case 10: ;
#line 2179
    if (ldv_state_variable_80 == 1) {
#line 2181
      qla24xx_reset_chip(qla83xx_isp_ops_group0);
#line 2183
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2186
    if (ldv_state_variable_80 == 2) {
#line 2188
      qla24xx_reset_chip(qla83xx_isp_ops_group0);
#line 2190
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2193
    goto ldv_68685;
    case 11: ;
#line 2196
    if (ldv_state_variable_80 == 1) {
#line 2198
      qla24xx_prep_ms_iocb(qla83xx_isp_ops_group0, ldvarg34, ldvarg33);
#line 2200
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2203
    if (ldv_state_variable_80 == 2) {
#line 2205
      qla24xx_prep_ms_iocb(qla83xx_isp_ops_group0, ldvarg34, ldvarg33);
#line 2207
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2210
    goto ldv_68685;
    case 12: ;
#line 2213
    if (ldv_state_variable_80 == 1) {
#line 2215
      qla24xx_lun_reset(qla83xx_isp_ops_group2, ldvarg32, ldvarg31);
#line 2217
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2220
    if (ldv_state_variable_80 == 2) {
#line 2222
      qla24xx_lun_reset(qla83xx_isp_ops_group2, ldvarg32, ldvarg31);
#line 2224
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2227
    goto ldv_68685;
    case 13: ;
#line 2230
    if (ldv_state_variable_80 == 1) {
#line 2232
      qla24xx_fw_version_str(qla83xx_isp_ops_group0, ldvarg30, ldvarg29);
#line 2234
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2237
    if (ldv_state_variable_80 == 2) {
#line 2239
      qla24xx_fw_version_str(qla83xx_isp_ops_group0, ldvarg30, ldvarg29);
#line 2241
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2244
    goto ldv_68685;
    case 14: ;
#line 2247
    if (ldv_state_variable_80 == 1) {
#line 2249
      qla83xx_iospace_config(qla83xx_isp_ops_group1);
#line 2251
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2254
    if (ldv_state_variable_80 == 2) {
#line 2256
      qla83xx_iospace_config(qla83xx_isp_ops_group1);
#line 2258
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2261
    goto ldv_68685;
    case 15: ;
#line 2264
    if (ldv_state_variable_80 == 1) {
#line 2266
      qla2x00_initialize_adapter(qla83xx_isp_ops_group0);
#line 2268
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2271
    if (ldv_state_variable_80 == 2) {
#line 2273
      qla2x00_initialize_adapter(qla83xx_isp_ops_group0);
#line 2275
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2278
    goto ldv_68685;
    case 16: ;
#line 2281
    if (ldv_state_variable_80 == 1) {
#line 2283
      qla24xx_get_flash_version(qla83xx_isp_ops_group0, ldvarg28);
#line 2285
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2288
    if (ldv_state_variable_80 == 2) {
#line 2290
      qla24xx_get_flash_version(qla83xx_isp_ops_group0, ldvarg28);
#line 2292
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2295
    goto ldv_68685;
    case 17: ;
#line 2298
    if (ldv_state_variable_80 == 1) {
#line 2300
      qla24xx_disable_intrs(qla83xx_isp_ops_group1);
#line 2302
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2305
    if (ldv_state_variable_80 == 2) {
#line 2307
      qla24xx_disable_intrs(qla83xx_isp_ops_group1);
#line 2309
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2312
    goto ldv_68685;
    case 18: ;
#line 2315
    if (ldv_state_variable_80 == 1) {
#line 2317
      qla81xx_nvram_config(qla83xx_isp_ops_group0);
#line 2319
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2322
    if (ldv_state_variable_80 == 2) {
#line 2324
      qla81xx_nvram_config(qla83xx_isp_ops_group0);
#line 2326
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2329
    goto ldv_68685;
    case 19: ;
#line 2332
    if (ldv_state_variable_80 == 1) {
#line 2334
      qla24xx_pci_info_str(qla83xx_isp_ops_group0, ldvarg27);
#line 2336
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2339
    if (ldv_state_variable_80 == 2) {
#line 2341
      qla24xx_pci_info_str(qla83xx_isp_ops_group0, ldvarg27);
#line 2343
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2346
    goto ldv_68685;
    case 20: ;
#line 2349
    if (ldv_state_variable_80 == 2) {
#line 2351
      qla25xx_read_optrom_data(qla83xx_isp_ops_group0, ldvarg26, ldvarg25, ldvarg24);
#line 2353
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2356
    goto ldv_68685;
    case 21: ;
#line 2359
    if (ldv_state_variable_80 == 1) {
#line 2361
      qla83xx_beacon_blink(qla83xx_isp_ops_group0);
#line 2363
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2366
    if (ldv_state_variable_80 == 2) {
#line 2368
      qla83xx_beacon_blink(qla83xx_isp_ops_group0);
#line 2370
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2373
    goto ldv_68685;
    case 22: ;
#line 2376
    if (ldv_state_variable_80 == 1) {
#line 2378
      qla24xx_beacon_off(qla83xx_isp_ops_group0);
#line 2380
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2383
    if (ldv_state_variable_80 == 2) {
#line 2385
      qla24xx_beacon_off(qla83xx_isp_ops_group0);
#line 2387
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2390
    goto ldv_68685;
    case 23: ;
#line 2393
    if (ldv_state_variable_80 == 1) {
#line 2395
      qla24xx_abort_command(ldvarg23);
#line 2397
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2400
    if (ldv_state_variable_80 == 2) {
#line 2402
      qla24xx_abort_command(ldvarg23);
#line 2404
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2407
    goto ldv_68685;
    case 24: ;
#line 2410
    if (ldv_state_variable_80 == 1) {
#line 2412
      qla83xx_fw_dump(qla83xx_isp_ops_group0, ldvarg22);
#line 2414
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2417
    if (ldv_state_variable_80 == 2) {
#line 2419
      qla83xx_fw_dump(qla83xx_isp_ops_group0, ldvarg22);
#line 2421
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2424
    goto ldv_68685;
    case 25: ;
#line 2427
    if (ldv_state_variable_80 == 1) {
#line 2429
      qla24xx_config_rings(qla83xx_isp_ops_group0);
#line 2431
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2434
    if (ldv_state_variable_80 == 2) {
#line 2436
      qla24xx_config_rings(qla83xx_isp_ops_group0);
#line 2438
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2441
    goto ldv_68685;
    case 26: ;
#line 2444
    if (ldv_state_variable_80 == 1) {
#line 2446
      qla81xx_load_risc(qla83xx_isp_ops_group0, ldvarg21);
#line 2448
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2451
    if (ldv_state_variable_80 == 2) {
#line 2453
      qla81xx_load_risc(qla83xx_isp_ops_group0, ldvarg21);
#line 2455
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2458
    goto ldv_68685;
    case 27: ;
#line 2461
    if (ldv_state_variable_80 == 1) {
#line 2463
      qla25xx_pci_config(qla83xx_isp_ops_group0);
#line 2465
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2468
    if (ldv_state_variable_80 == 2) {
#line 2470
      qla25xx_pci_config(qla83xx_isp_ops_group0);
#line 2472
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2475
    goto ldv_68685;
    case 28: ;
#line 2478
    if (ldv_state_variable_80 == 1) {
#line 2480
      qla24xx_login_fabric(qla83xx_isp_ops_group0, (int )ldvarg19, (int )ldvarg17,
                           (int )ldvarg16, (int )ldvarg20, ldvarg15, (int )ldvarg18);
#line 2482
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2485
    if (ldv_state_variable_80 == 2) {
#line 2487
      qla24xx_login_fabric(qla83xx_isp_ops_group0, (int )ldvarg19, (int )ldvarg17,
                           (int )ldvarg16, (int )ldvarg20, ldvarg15, (int )ldvarg18);
#line 2489
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2492
    goto ldv_68685;
    case 29: ;
#line 2495
    if (ldv_state_variable_80 == 1) {
#line 2497
      qla24xx_beacon_on(qla83xx_isp_ops_group0);
#line 2499
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2502
    if (ldv_state_variable_80 == 2) {
#line 2504
      qla24xx_beacon_on(qla83xx_isp_ops_group0);
#line 2506
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2509
    goto ldv_68685;
    case 30: ;
#line 2512
    if (ldv_state_variable_80 == 1) {
#line 2514
      qla24xx_prep_ms_fdmi_iocb(qla83xx_isp_ops_group0, ldvarg14, ldvarg13);
#line 2516
      ldv_state_variable_80 = 1;
    } else {

    }
#line 2519
    if (ldv_state_variable_80 == 2) {
#line 2521
      qla24xx_prep_ms_fdmi_iocb(qla83xx_isp_ops_group0, ldvarg14, ldvarg13);
#line 2523
      ldv_state_variable_80 = 2;
    } else {

    }
#line 2526
    goto ldv_68685;
    case 31: ;
#line 2529
    if (ldv_state_variable_80 == 2) {
#line 2531
      ldv_release_80();
#line 2533
      ldv_state_variable_80 = 1;
#line 2534
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 2537
    goto ldv_68685;
    case 32: ;
#line 2540
    if (ldv_state_variable_80 == 1) {
#line 2542
      ldv_probe_80();
#line 2544
      ldv_state_variable_80 = 2;
#line 2545
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 2548
    goto ldv_68685;
    default: 
#line 2549
    ldv_stop();
    }
    ldv_68685: ;
  } else {

  }
#line 2553
  goto ldv_68677;
  case 7: ;
#line 2560
  goto ldv_68677;
  case 8: ;
#line 2567
  goto ldv_68677;
  case 9: ;
#line 2571
  if (ldv_state_variable_72 != 0) {
#line 2572
    ldv_main_exported_72();
  } else {

  }
#line 2575
  goto ldv_68677;
  case 10: ;
#line 2582
  goto ldv_68677;
  case 11: ;
#line 2586
  if (ldv_state_variable_44 != 0) {
#line 2587
    ldv_main_exported_44();
  } else {

  }
#line 2590
  goto ldv_68677;
  case 12: ;
#line 2594
  if (ldv_state_variable_55 != 0) {
#line 2595
    ldv_main_exported_55();
  } else {

  }
#line 2598
  goto ldv_68677;
  case 13: ;
#line 2602
  if (ldv_state_variable_84 != 0) {
#line 2603
    tmp___116 = __VERIFIER_nondet_int();
#line 2603
    switch (tmp___116) {
    case 0: ;
#line 2606
    if (ldv_state_variable_84 == 1) {
#line 2608
      qla24xx_reset_adapter(qla25xx_isp_ops_group0);
#line 2610
      ldv_state_variable_84 = 1;
    } else {

    }
#line 2613
    if (ldv_state_variable_84 == 2) {
#line 2615
      qla24xx_reset_adapter(qla25xx_isp_ops_group0);
#line 2617
      ldv_state_variable_84 = 2;
    } else {

    }
#line 2620
    goto ldv_68727;
    case 1: ;
#line 2623
    if (ldv_state_variable_84 == 1) {
#line 2625
      qla24xx_enable_intrs(qla25xx_isp_ops_group1);
#line 2627
      ldv_state_variable_84 = 1;
    } else {

    }
#line 2630
    if (ldv_state_variable_84 == 2) {
#line 2632
      qla24xx_enable_intrs(qla25xx_isp_ops_group1);
#line 2634
      ldv_state_variable_84 = 2;
    } else {

    }
#line 2637
    goto ldv_68727;
    case 2: ;
#line 2640
    if (ldv_state_variable_84 == 2) {
#line 2642
      qla24xx_write_optrom_data(qla25xx_isp_ops_group0, ldvarg98, ldvarg97, ldvarg96);
#line 2644
      ldv_state_variable_84 = 2;
    } else {

    }
#line 2647
    goto ldv_68727;
    case 3: ;
#line 2650
    if (ldv_state_variable_84 == 1) {
#line 2652
      qla24xx_intr_handler(ldvarg94, ldvarg95);
#line 2654
      ldv_state_variable_84 = 1;
    } else {

    }
#line 2657
    if (ldv_state_variable_84 == 2) {
#line 2659
      qla24xx_intr_handler(ldvarg94, ldvarg95);
#line 2661
      ldv_state_variable_84 = 2;
    } else {

    }
#line 2664
    goto ldv_68727;
    case 4: ;
#line 2667
    if (ldv_state_variable_84 == 1) {
#line 2669
      qla24xx_abort_target(qla25xx_isp_ops_group2, ldvarg93, ldvarg92);
#line 2671
      ldv_state_variable_84 = 1;
    } else {

    }
#line 2674
    if (ldv_state_variable_84 == 2) {
#line 2676
      qla24xx_abort_target(qla25xx_isp_ops_group2, ldvarg93, ldvarg92);
#line 2678
      ldv_state_variable_84 = 2;
    } else {

    }
#line 2681
    goto ldv_68727;
    case 5: ;
#line 2684
    if (ldv_state_variable_84 == 1) {
#line 2686
      qla24xx_update_fw_options(qla25xx_isp_ops_group0);
#line 2688
      ldv_state_variable_84 = 1;
    } else {

    }
#line 2691
    if (ldv_state_variable_84 == 2) {
#line 2693
      qla24xx_update_fw_options(qla25xx_isp_ops_group0);
#line 2695
      ldv_state_variable_84 = 2;
    } else {

    }
#line 2698
    goto ldv_68727;
    case 6: ;
#line 2701
    if (ldv_state_variable_84 == 1) {
#line 2703
      qla24xx_dif_start_scsi(ldvarg91);
#line 2705
      ldv_state_variable_84 = 1;
    } else {

    }
#line 2708
    if (ldv_state_variable_84 == 2) {
#line 2710
      qla24xx_dif_start_scsi(ldvarg91);
#line 2712
      ldv_state_variable_84 = 2;
    } else {

    }
#line 2715
    goto ldv_68727;
    case 7: ;
#line 2718
    if (ldv_state_variable_84 == 1) {
#line 2720
      qla2x00_abort_isp(qla25xx_isp_ops_group0);
#line 2722
      ldv_state_variable_84 = 1;
    } else {

    }
#line 2725
    if (ldv_state_variable_84 == 2) {
#line 2727
      qla2x00_abort_isp(qla25xx_isp_ops_group0);
#line 2729
      ldv_state_variable_84 = 2;
    } else {

    }
#line 2732
    goto ldv_68727;
    case 8: ;
#line 2735
    if (ldv_state_variable_84 == 1) {
#line 2737
      qla24xx_chip_diag(qla25xx_isp_ops_group0);
#line 2739
      ldv_state_variable_84 = 1;
    } else {

    }
#line 2742
    if (ldv_state_variable_84 == 2) {
#line 2744
      qla24xx_chip_diag(qla25xx_isp_ops_group0);
#line 2746
      ldv_state_variable_84 = 2;
    } else {

    }
#line 2749
    goto ldv_68727;
    case 9: ;
#line 2752
    if (ldv_state_variable_84 == 1) {
#line 2754
      qla24xx_fabric_logout(qla25xx_isp_ops_group0, (int )ldvarg89, (int )ldvarg88,
                            (int )ldvarg87, (int )ldvarg90);
#line 2756
      ldv_state_variable_84 = 1;
    } else {

    }
#line 2759
    if (ldv_state_variable_84 == 2) {
#line 2761
      qla24xx_fabric_logout(qla25xx_isp_ops_group0, (int )ldvarg89, (int )ldvarg88,
                            (int )ldvarg87, (int )ldvarg90);
#line 2763
      ldv_state_variable_84 = 2;
    } else {

    }
#line 2766
    goto ldv_68727;
    case 10: ;
#line 2769
    if (ldv_state_variable_84 == 1) {
#line 2771
      qla24xx_reset_chip(qla25xx_isp_ops_group0);
#line 2773
      ldv_state_variable_84 = 1;
    } else {

    }
#line 2776
    if (ldv_state_variable_84 == 2) {
#line 2778
      qla24xx_reset_chip(qla25xx_isp_ops_group0);
#line 2780
      ldv_state_variable_84 = 2;
    } else {

    }
#line 2783
    goto ldv_68727;
    case 11: ;
#line 2786
    if (ldv_state_variable_84 == 1) {
#line 2788
      qla24xx_prep_ms_iocb(qla25xx_isp_ops_group0, ldvarg86, ldvarg85);
#line 2790
      ldv_state_variable_84 = 1;
    } else {

    }
#line 2793
    if (ldv_state_variable_84 == 2) {
#line 2795
      qla24xx_prep_ms_iocb(qla25xx_isp_ops_group0, ldvarg86, ldvarg85);
#line 2797
      ldv_state_variable_84 = 2;
    } else {

    }
#line 2800
    goto ldv_68727;
    case 12: ;
#line 2803
    if (ldv_state_variable_84 == 1) {
#line 2805
      qla24xx_lun_reset(qla25xx_isp_ops_group2, ldvarg84, ldvarg83);
#line 2807
      ldv_state_variable_84 = 1;
    } else {

    }
#line 2810
    if (ldv_state_variable_84 == 2) {
#line 2812
      qla24xx_lun_reset(qla25xx_isp_ops_group2, ldvarg84, ldvarg83);
#line 2814
      ldv_state_variable_84 = 2;
    } else {

    }
#line 2817
    goto ldv_68727;
    case 13: ;
#line 2820
    if (ldv_state_variable_84 == 1) {
#line 2822
      qla24xx_fw_version_str(qla25xx_isp_ops_group0, ldvarg82, ldvarg81);
#line 2824
      ldv_state_variable_84 = 1;
    } else {

    }
#line 2827
    if (ldv_state_variable_84 == 2) {
#line 2829
      qla24xx_fw_version_str(qla25xx_isp_ops_group0, ldvarg82, ldvarg81);
#line 2831
      ldv_state_variable_84 = 2;
    } else {

    }
#line 2834
    goto ldv_68727;
    case 14: ;
#line 2837
    if (ldv_state_variable_84 == 1) {
#line 2839
      qla2x00_iospace_config(qla25xx_isp_ops_group1);
#line 2841
      ldv_state_variable_84 = 1;
    } else {

    }
#line 2844
    if (ldv_state_variable_84 == 2) {
#line 2846
      qla2x00_iospace_config(qla25xx_isp_ops_group1);
#line 2848
      ldv_state_variable_84 = 2;
    } else {

    }
#line 2851
    goto ldv_68727;
    case 15: ;
#line 2854
    if (ldv_state_variable_84 == 1) {
#line 2856
      qla2x00_initialize_adapter(qla25xx_isp_ops_group0);
#line 2858
      ldv_state_variable_84 = 1;
    } else {

    }
#line 2861
    if (ldv_state_variable_84 == 2) {
#line 2863
      qla2x00_initialize_adapter(qla25xx_isp_ops_group0);
#line 2865
      ldv_state_variable_84 = 2;
    } else {

    }
#line 2868
    goto ldv_68727;
    case 16: ;
#line 2871
    if (ldv_state_variable_84 == 1) {
#line 2873
      qla24xx_disable_intrs(qla25xx_isp_ops_group1);
#line 2875
      ldv_state_variable_84 = 1;
    } else {

    }
#line 2878
    if (ldv_state_variable_84 == 2) {
#line 2880
      qla24xx_disable_intrs(qla25xx_isp_ops_group1);
#line 2882
      ldv_state_variable_84 = 2;
    } else {

    }
#line 2885
    goto ldv_68727;
    case 17: ;
#line 2888
    if (ldv_state_variable_84 == 1) {
#line 2890
      qla24xx_get_flash_version(qla25xx_isp_ops_group0, ldvarg80);
#line 2892
      ldv_state_variable_84 = 1;
    } else {

    }
#line 2895
    if (ldv_state_variable_84 == 2) {
#line 2897
      qla24xx_get_flash_version(qla25xx_isp_ops_group0, ldvarg80);
#line 2899
      ldv_state_variable_84 = 2;
    } else {

    }
#line 2902
    goto ldv_68727;
    case 18: ;
#line 2905
    if (ldv_state_variable_84 == 1) {
#line 2907
      qla24xx_nvram_config(qla25xx_isp_ops_group0);
#line 2909
      ldv_state_variable_84 = 1;
    } else {

    }
#line 2912
    if (ldv_state_variable_84 == 2) {
#line 2914
      qla24xx_nvram_config(qla25xx_isp_ops_group0);
#line 2916
      ldv_state_variable_84 = 2;
    } else {

    }
#line 2919
    goto ldv_68727;
    case 19: ;
#line 2922
    if (ldv_state_variable_84 == 1) {
#line 2924
      qla24xx_pci_info_str(qla25xx_isp_ops_group0, ldvarg79);
#line 2926
      ldv_state_variable_84 = 1;
    } else {

    }
#line 2929
    if (ldv_state_variable_84 == 2) {
#line 2931
      qla24xx_pci_info_str(qla25xx_isp_ops_group0, ldvarg79);
#line 2933
      ldv_state_variable_84 = 2;
    } else {

    }
#line 2936
    goto ldv_68727;
    case 20: ;
#line 2939
    if (ldv_state_variable_84 == 2) {
#line 2941
      qla25xx_read_optrom_data(qla25xx_isp_ops_group0, ldvarg78, ldvarg77, ldvarg76);
#line 2943
      ldv_state_variable_84 = 2;
    } else {

    }
#line 2946
    goto ldv_68727;
    case 21: ;
#line 2949
    if (ldv_state_variable_84 == 1) {
#line 2951
      qla24xx_beacon_blink(qla25xx_isp_ops_group0);
#line 2953
      ldv_state_variable_84 = 1;
    } else {

    }
#line 2956
    if (ldv_state_variable_84 == 2) {
#line 2958
      qla24xx_beacon_blink(qla25xx_isp_ops_group0);
#line 2960
      ldv_state_variable_84 = 2;
    } else {

    }
#line 2963
    goto ldv_68727;
    case 22: ;
#line 2966
    if (ldv_state_variable_84 == 1) {
#line 2968
      qla24xx_beacon_off(qla25xx_isp_ops_group0);
#line 2970
      ldv_state_variable_84 = 1;
    } else {

    }
#line 2973
    if (ldv_state_variable_84 == 2) {
#line 2975
      qla24xx_beacon_off(qla25xx_isp_ops_group0);
#line 2977
      ldv_state_variable_84 = 2;
    } else {

    }
#line 2980
    goto ldv_68727;
    case 23: ;
#line 2983
    if (ldv_state_variable_84 == 1) {
#line 2985
      qla24xx_abort_command(ldvarg75);
#line 2987
      ldv_state_variable_84 = 1;
    } else {

    }
#line 2990
    if (ldv_state_variable_84 == 2) {
#line 2992
      qla24xx_abort_command(ldvarg75);
#line 2994
      ldv_state_variable_84 = 2;
    } else {

    }
#line 2997
    goto ldv_68727;
    case 24: ;
#line 3000
    if (ldv_state_variable_84 == 1) {
#line 3002
      qla25xx_fw_dump(qla25xx_isp_ops_group0, ldvarg74);
#line 3004
      ldv_state_variable_84 = 1;
    } else {

    }
#line 3007
    if (ldv_state_variable_84 == 2) {
#line 3009
      qla25xx_fw_dump(qla25xx_isp_ops_group0, ldvarg74);
#line 3011
      ldv_state_variable_84 = 2;
    } else {

    }
#line 3014
    goto ldv_68727;
    case 25: ;
#line 3017
    if (ldv_state_variable_84 == 1) {
#line 3019
      qla24xx_config_rings(qla25xx_isp_ops_group0);
#line 3021
      ldv_state_variable_84 = 1;
    } else {

    }
#line 3024
    if (ldv_state_variable_84 == 2) {
#line 3026
      qla24xx_config_rings(qla25xx_isp_ops_group0);
#line 3028
      ldv_state_variable_84 = 2;
    } else {

    }
#line 3031
    goto ldv_68727;
    case 26: ;
#line 3034
    if (ldv_state_variable_84 == 1) {
#line 3036
      qla24xx_load_risc(qla25xx_isp_ops_group0, ldvarg73);
#line 3038
      ldv_state_variable_84 = 1;
    } else {

    }
#line 3041
    if (ldv_state_variable_84 == 2) {
#line 3043
      qla24xx_load_risc(qla25xx_isp_ops_group0, ldvarg73);
#line 3045
      ldv_state_variable_84 = 2;
    } else {

    }
#line 3048
    goto ldv_68727;
    case 27: ;
#line 3051
    if (ldv_state_variable_84 == 1) {
#line 3053
      qla25xx_pci_config(qla25xx_isp_ops_group0);
#line 3055
      ldv_state_variable_84 = 1;
    } else {

    }
#line 3058
    if (ldv_state_variable_84 == 2) {
#line 3060
      qla25xx_pci_config(qla25xx_isp_ops_group0);
#line 3062
      ldv_state_variable_84 = 2;
    } else {

    }
#line 3065
    goto ldv_68727;
    case 28: ;
#line 3068
    if (ldv_state_variable_84 == 1) {
#line 3070
      qla24xx_login_fabric(qla25xx_isp_ops_group0, (int )ldvarg71, (int )ldvarg69,
                           (int )ldvarg68, (int )ldvarg72, ldvarg67, (int )ldvarg70);
#line 3072
      ldv_state_variable_84 = 1;
    } else {

    }
#line 3075
    if (ldv_state_variable_84 == 2) {
#line 3077
      qla24xx_login_fabric(qla25xx_isp_ops_group0, (int )ldvarg71, (int )ldvarg69,
                           (int )ldvarg68, (int )ldvarg72, ldvarg67, (int )ldvarg70);
#line 3079
      ldv_state_variable_84 = 2;
    } else {

    }
#line 3082
    goto ldv_68727;
    case 29: ;
#line 3085
    if (ldv_state_variable_84 == 1) {
#line 3087
      qla25xx_write_nvram_data(qla25xx_isp_ops_group0, ldvarg66, ldvarg65, ldvarg64);
#line 3089
      ldv_state_variable_84 = 1;
    } else {

    }
#line 3092
    if (ldv_state_variable_84 == 2) {
#line 3094
      qla25xx_write_nvram_data(qla25xx_isp_ops_group0, ldvarg66, ldvarg65, ldvarg64);
#line 3096
      ldv_state_variable_84 = 2;
    } else {

    }
#line 3099
    goto ldv_68727;
    case 30: ;
#line 3102
    if (ldv_state_variable_84 == 1) {
#line 3104
      qla24xx_beacon_on(qla25xx_isp_ops_group0);
#line 3106
      ldv_state_variable_84 = 1;
    } else {

    }
#line 3109
    if (ldv_state_variable_84 == 2) {
#line 3111
      qla24xx_beacon_on(qla25xx_isp_ops_group0);
#line 3113
      ldv_state_variable_84 = 2;
    } else {

    }
#line 3116
    goto ldv_68727;
    case 31: ;
#line 3119
    if (ldv_state_variable_84 == 1) {
#line 3121
      qla25xx_read_nvram_data(qla25xx_isp_ops_group0, ldvarg63, ldvarg62, ldvarg61);
#line 3123
      ldv_state_variable_84 = 1;
    } else {

    }
#line 3126
    if (ldv_state_variable_84 == 2) {
#line 3128
      qla25xx_read_nvram_data(qla25xx_isp_ops_group0, ldvarg63, ldvarg62, ldvarg61);
#line 3130
      ldv_state_variable_84 = 2;
    } else {

    }
#line 3133
    goto ldv_68727;
    case 32: ;
#line 3136
    if (ldv_state_variable_84 == 1) {
#line 3138
      qla24xx_prep_ms_fdmi_iocb(qla25xx_isp_ops_group0, ldvarg60, ldvarg59);
#line 3140
      ldv_state_variable_84 = 1;
    } else {

    }
#line 3143
    if (ldv_state_variable_84 == 2) {
#line 3145
      qla24xx_prep_ms_fdmi_iocb(qla25xx_isp_ops_group0, ldvarg60, ldvarg59);
#line 3147
      ldv_state_variable_84 = 2;
    } else {

    }
#line 3150
    goto ldv_68727;
    case 33: ;
#line 3153
    if (ldv_state_variable_84 == 2) {
#line 3155
      ldv_release_84();
#line 3157
      ldv_state_variable_84 = 1;
#line 3158
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 3161
    goto ldv_68727;
    case 34: ;
#line 3164
    if (ldv_state_variable_84 == 1) {
#line 3166
      ldv_probe_84();
#line 3168
      ldv_state_variable_84 = 2;
#line 3169
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 3172
    goto ldv_68727;
    default: 
#line 3173
    ldv_stop();
    }
    ldv_68727: ;
  } else {

  }
#line 3177
  goto ldv_68677;
  case 14: ;
#line 3181
  if (ldv_state_variable_74 != 0) {
#line 3182
    ldv_main_exported_74();
  } else {

  }
#line 3185
  goto ldv_68677;
  case 15: ;
#line 3192
  goto ldv_68677;
  case 16: ;
#line 3196
  if (ldv_state_variable_57 != 0) {
#line 3197
    ldv_main_exported_57();
  } else {

  }
#line 3200
  goto ldv_68677;
  case 17: ;
#line 3204
  if (ldv_state_variable_61 != 0) {
#line 3205
    ldv_main_exported_61();
  } else {

  }
#line 3208
  goto ldv_68677;
  case 18: ;
#line 3215
  goto ldv_68677;
  case 19: ;
#line 3222
  goto ldv_68677;
  case 20: ;
#line 3226
  if (ldv_state_variable_31 != 0) {
#line 3227
    ldv_main_exported_31();
  } else {

  }
#line 3230
  goto ldv_68677;
  case 21: ;
#line 3234
  if (ldv_state_variable_35 != 0) {
#line 3235
    ldv_main_exported_35();
  } else {

  }
#line 3238
  goto ldv_68677;
  case 22: ;
#line 3245
  goto ldv_68677;
  case 23: ;
#line 3249
  if (ldv_state_variable_78 != 0) {
#line 3250
    tmp___117 = __VERIFIER_nondet_int();
#line 3250
    switch (tmp___117) {
    case 0: ;
#line 3253
    if (ldv_state_variable_78 == 1) {
#line 3255
      qla24xx_reset_adapter(qla27xx_isp_ops_group0);
#line 3257
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3260
    if (ldv_state_variable_78 == 2) {
#line 3262
      qla24xx_reset_adapter(qla27xx_isp_ops_group0);
#line 3264
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3267
    goto ldv_68774;
    case 1: ;
#line 3270
    if (ldv_state_variable_78 == 2) {
#line 3272
      qla24xx_write_optrom_data(qla27xx_isp_ops_group0, ldvarg152, ldvarg151, ldvarg150);
#line 3274
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3277
    goto ldv_68774;
    case 2: ;
#line 3280
    if (ldv_state_variable_78 == 1) {
#line 3282
      qla24xx_enable_intrs(qla27xx_isp_ops_group1);
#line 3284
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3287
    if (ldv_state_variable_78 == 2) {
#line 3289
      qla24xx_enable_intrs(qla27xx_isp_ops_group1);
#line 3291
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3294
    goto ldv_68774;
    case 3: ;
#line 3297
    if (ldv_state_variable_78 == 1) {
#line 3299
      qla24xx_intr_handler(ldvarg148, ldvarg149);
#line 3301
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3304
    if (ldv_state_variable_78 == 2) {
#line 3306
      qla24xx_intr_handler(ldvarg148, ldvarg149);
#line 3308
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3311
    goto ldv_68774;
    case 4: ;
#line 3314
    if (ldv_state_variable_78 == 1) {
#line 3316
      qla24xx_abort_target(qla27xx_isp_ops_group2, ldvarg147, ldvarg146);
#line 3318
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3321
    if (ldv_state_variable_78 == 2) {
#line 3323
      qla24xx_abort_target(qla27xx_isp_ops_group2, ldvarg147, ldvarg146);
#line 3325
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3328
    goto ldv_68774;
    case 5: ;
#line 3331
    if (ldv_state_variable_78 == 1) {
#line 3333
      qla81xx_update_fw_options(qla27xx_isp_ops_group0);
#line 3335
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3338
    if (ldv_state_variable_78 == 2) {
#line 3340
      qla81xx_update_fw_options(qla27xx_isp_ops_group0);
#line 3342
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3345
    goto ldv_68774;
    case 6: ;
#line 3348
    if (ldv_state_variable_78 == 1) {
#line 3350
      qla2x00_abort_isp(qla27xx_isp_ops_group0);
#line 3352
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3355
    if (ldv_state_variable_78 == 2) {
#line 3357
      qla2x00_abort_isp(qla27xx_isp_ops_group0);
#line 3359
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3362
    goto ldv_68774;
    case 7: ;
#line 3365
    if (ldv_state_variable_78 == 1) {
#line 3367
      qla24xx_dif_start_scsi(ldvarg145);
#line 3369
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3372
    if (ldv_state_variable_78 == 2) {
#line 3374
      qla24xx_dif_start_scsi(ldvarg145);
#line 3376
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3379
    goto ldv_68774;
    case 8: ;
#line 3382
    if (ldv_state_variable_78 == 1) {
#line 3384
      qla24xx_chip_diag(qla27xx_isp_ops_group0);
#line 3386
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3389
    if (ldv_state_variable_78 == 2) {
#line 3391
      qla24xx_chip_diag(qla27xx_isp_ops_group0);
#line 3393
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3396
    goto ldv_68774;
    case 9: ;
#line 3399
    if (ldv_state_variable_78 == 1) {
#line 3401
      qla24xx_fabric_logout(qla27xx_isp_ops_group0, (int )ldvarg143, (int )ldvarg142,
                            (int )ldvarg141, (int )ldvarg144);
#line 3403
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3406
    if (ldv_state_variable_78 == 2) {
#line 3408
      qla24xx_fabric_logout(qla27xx_isp_ops_group0, (int )ldvarg143, (int )ldvarg142,
                            (int )ldvarg141, (int )ldvarg144);
#line 3410
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3413
    goto ldv_68774;
    case 10: ;
#line 3416
    if (ldv_state_variable_78 == 1) {
#line 3418
      qla24xx_reset_chip(qla27xx_isp_ops_group0);
#line 3420
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3423
    if (ldv_state_variable_78 == 2) {
#line 3425
      qla24xx_reset_chip(qla27xx_isp_ops_group0);
#line 3427
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3430
    goto ldv_68774;
    case 11: ;
#line 3433
    if (ldv_state_variable_78 == 1) {
#line 3435
      qla24xx_prep_ms_iocb(qla27xx_isp_ops_group0, ldvarg140, ldvarg139);
#line 3437
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3440
    if (ldv_state_variable_78 == 2) {
#line 3442
      qla24xx_prep_ms_iocb(qla27xx_isp_ops_group0, ldvarg140, ldvarg139);
#line 3444
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3447
    goto ldv_68774;
    case 12: ;
#line 3450
    if (ldv_state_variable_78 == 1) {
#line 3452
      qla24xx_lun_reset(qla27xx_isp_ops_group2, ldvarg138, ldvarg137);
#line 3454
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3457
    if (ldv_state_variable_78 == 2) {
#line 3459
      qla24xx_lun_reset(qla27xx_isp_ops_group2, ldvarg138, ldvarg137);
#line 3461
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3464
    goto ldv_68774;
    case 13: ;
#line 3467
    if (ldv_state_variable_78 == 1) {
#line 3469
      qla24xx_fw_version_str(qla27xx_isp_ops_group0, ldvarg136, ldvarg135);
#line 3471
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3474
    if (ldv_state_variable_78 == 2) {
#line 3476
      qla24xx_fw_version_str(qla27xx_isp_ops_group0, ldvarg136, ldvarg135);
#line 3478
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3481
    goto ldv_68774;
    case 14: ;
#line 3484
    if (ldv_state_variable_78 == 1) {
#line 3486
      qla83xx_iospace_config(qla27xx_isp_ops_group1);
#line 3488
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3491
    if (ldv_state_variable_78 == 2) {
#line 3493
      qla83xx_iospace_config(qla27xx_isp_ops_group1);
#line 3495
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3498
    goto ldv_68774;
    case 15: ;
#line 3501
    if (ldv_state_variable_78 == 1) {
#line 3503
      qla2x00_initialize_adapter(qla27xx_isp_ops_group0);
#line 3505
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3508
    if (ldv_state_variable_78 == 2) {
#line 3510
      qla2x00_initialize_adapter(qla27xx_isp_ops_group0);
#line 3512
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3515
    goto ldv_68774;
    case 16: ;
#line 3518
    if (ldv_state_variable_78 == 1) {
#line 3520
      qla24xx_get_flash_version(qla27xx_isp_ops_group0, ldvarg134);
#line 3522
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3525
    if (ldv_state_variable_78 == 2) {
#line 3527
      qla24xx_get_flash_version(qla27xx_isp_ops_group0, ldvarg134);
#line 3529
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3532
    goto ldv_68774;
    case 17: ;
#line 3535
    if (ldv_state_variable_78 == 1) {
#line 3537
      qla24xx_disable_intrs(qla27xx_isp_ops_group1);
#line 3539
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3542
    if (ldv_state_variable_78 == 2) {
#line 3544
      qla24xx_disable_intrs(qla27xx_isp_ops_group1);
#line 3546
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3549
    goto ldv_68774;
    case 18: ;
#line 3552
    if (ldv_state_variable_78 == 1) {
#line 3554
      qla81xx_nvram_config(qla27xx_isp_ops_group0);
#line 3556
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3559
    if (ldv_state_variable_78 == 2) {
#line 3561
      qla81xx_nvram_config(qla27xx_isp_ops_group0);
#line 3563
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3566
    goto ldv_68774;
    case 19: ;
#line 3569
    if (ldv_state_variable_78 == 1) {
#line 3571
      qla24xx_pci_info_str(qla27xx_isp_ops_group0, ldvarg133);
#line 3573
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3576
    if (ldv_state_variable_78 == 2) {
#line 3578
      qla24xx_pci_info_str(qla27xx_isp_ops_group0, ldvarg133);
#line 3580
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3583
    goto ldv_68774;
    case 20: ;
#line 3586
    if (ldv_state_variable_78 == 2) {
#line 3588
      qla25xx_read_optrom_data(qla27xx_isp_ops_group0, ldvarg132, ldvarg131, ldvarg130);
#line 3590
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3593
    goto ldv_68774;
    case 21: ;
#line 3596
    if (ldv_state_variable_78 == 1) {
#line 3598
      qla83xx_beacon_blink(qla27xx_isp_ops_group0);
#line 3600
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3603
    if (ldv_state_variable_78 == 2) {
#line 3605
      qla83xx_beacon_blink(qla27xx_isp_ops_group0);
#line 3607
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3610
    goto ldv_68774;
    case 22: ;
#line 3613
    if (ldv_state_variable_78 == 1) {
#line 3615
      qla24xx_beacon_off(qla27xx_isp_ops_group0);
#line 3617
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3620
    if (ldv_state_variable_78 == 2) {
#line 3622
      qla24xx_beacon_off(qla27xx_isp_ops_group0);
#line 3624
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3627
    goto ldv_68774;
    case 23: ;
#line 3630
    if (ldv_state_variable_78 == 1) {
#line 3632
      qla24xx_abort_command(ldvarg129);
#line 3634
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3637
    if (ldv_state_variable_78 == 2) {
#line 3639
      qla24xx_abort_command(ldvarg129);
#line 3641
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3644
    goto ldv_68774;
    case 24: ;
#line 3647
    if (ldv_state_variable_78 == 1) {
#line 3649
      qla27xx_fwdump(qla27xx_isp_ops_group0, ldvarg128);
#line 3651
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3654
    if (ldv_state_variable_78 == 2) {
#line 3656
      qla27xx_fwdump(qla27xx_isp_ops_group0, ldvarg128);
#line 3658
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3661
    goto ldv_68774;
    case 25: ;
#line 3664
    if (ldv_state_variable_78 == 1) {
#line 3666
      qla24xx_config_rings(qla27xx_isp_ops_group0);
#line 3668
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3671
    if (ldv_state_variable_78 == 2) {
#line 3673
      qla24xx_config_rings(qla27xx_isp_ops_group0);
#line 3675
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3678
    goto ldv_68774;
    case 26: ;
#line 3681
    if (ldv_state_variable_78 == 1) {
#line 3683
      qla81xx_load_risc(qla27xx_isp_ops_group0, ldvarg127);
#line 3685
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3688
    if (ldv_state_variable_78 == 2) {
#line 3690
      qla81xx_load_risc(qla27xx_isp_ops_group0, ldvarg127);
#line 3692
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3695
    goto ldv_68774;
    case 27: ;
#line 3698
    if (ldv_state_variable_78 == 1) {
#line 3700
      qla25xx_pci_config(qla27xx_isp_ops_group0);
#line 3702
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3705
    if (ldv_state_variable_78 == 2) {
#line 3707
      qla25xx_pci_config(qla27xx_isp_ops_group0);
#line 3709
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3712
    goto ldv_68774;
    case 28: ;
#line 3715
    if (ldv_state_variable_78 == 1) {
#line 3717
      qla24xx_login_fabric(qla27xx_isp_ops_group0, (int )ldvarg125, (int )ldvarg123,
                           (int )ldvarg122, (int )ldvarg126, ldvarg121, (int )ldvarg124);
#line 3719
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3722
    if (ldv_state_variable_78 == 2) {
#line 3724
      qla24xx_login_fabric(qla27xx_isp_ops_group0, (int )ldvarg125, (int )ldvarg123,
                           (int )ldvarg122, (int )ldvarg126, ldvarg121, (int )ldvarg124);
#line 3726
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3729
    goto ldv_68774;
    case 29: ;
#line 3732
    if (ldv_state_variable_78 == 1) {
#line 3734
      qla24xx_beacon_on(qla27xx_isp_ops_group0);
#line 3736
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3739
    if (ldv_state_variable_78 == 2) {
#line 3741
      qla24xx_beacon_on(qla27xx_isp_ops_group0);
#line 3743
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3746
    goto ldv_68774;
    case 30: ;
#line 3749
    if (ldv_state_variable_78 == 1) {
#line 3751
      qla24xx_prep_ms_fdmi_iocb(qla27xx_isp_ops_group0, ldvarg120, ldvarg119);
#line 3753
      ldv_state_variable_78 = 1;
    } else {

    }
#line 3756
    if (ldv_state_variable_78 == 2) {
#line 3758
      qla24xx_prep_ms_fdmi_iocb(qla27xx_isp_ops_group0, ldvarg120, ldvarg119);
#line 3760
      ldv_state_variable_78 = 2;
    } else {

    }
#line 3763
    goto ldv_68774;
    case 31: ;
#line 3766
    if (ldv_state_variable_78 == 2) {
#line 3768
      ldv_release_78();
#line 3770
      ldv_state_variable_78 = 1;
#line 3771
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 3774
    goto ldv_68774;
    case 32: ;
#line 3777
    if (ldv_state_variable_78 == 1) {
#line 3779
      ldv_probe_78();
#line 3781
      ldv_state_variable_78 = 2;
#line 3782
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 3785
    goto ldv_68774;
    default: 
#line 3786
    ldv_stop();
    }
    ldv_68774: ;
  } else {

  }
#line 3790
  goto ldv_68677;
  case 24: ;
#line 3794
  if (ldv_state_variable_48 != 0) {
#line 3795
    ldv_main_exported_48();
  } else {

  }
#line 3798
  goto ldv_68677;
  case 25: ;
#line 3802
  if (ldv_state_variable_87 != 0) {
#line 3803
    tmp___118 = __VERIFIER_nondet_int();
#line 3803
    switch (tmp___118) {
    case 0: ;
#line 3806
    if (ldv_state_variable_87 == 1) {
#line 3808
      qla2x00_reset_adapter(qla2100_isp_ops_group0);
#line 3810
      ldv_state_variable_87 = 1;
    } else {

    }
#line 3813
    if (ldv_state_variable_87 == 2) {
#line 3815
      qla2x00_reset_adapter(qla2100_isp_ops_group0);
#line 3817
      ldv_state_variable_87 = 2;
    } else {

    }
#line 3820
    goto ldv_68811;
    case 1: ;
#line 3823
    if (ldv_state_variable_87 == 2) {
#line 3825
      qla2x00_write_optrom_data(qla2100_isp_ops_group0, ldvarg199, ldvarg198, ldvarg197);
#line 3827
      ldv_state_variable_87 = 2;
    } else {

    }
#line 3830
    goto ldv_68811;
    case 2: ;
#line 3833
    if (ldv_state_variable_87 == 1) {
#line 3835
      qla2x00_enable_intrs(qla2100_isp_ops_group1);
#line 3837
      ldv_state_variable_87 = 1;
    } else {

    }
#line 3840
    if (ldv_state_variable_87 == 2) {
#line 3842
      qla2x00_enable_intrs(qla2100_isp_ops_group1);
#line 3844
      ldv_state_variable_87 = 2;
    } else {

    }
#line 3847
    goto ldv_68811;
    case 3: ;
#line 3850
    if (ldv_state_variable_87 == 1) {
#line 3852
      qla2100_intr_handler(ldvarg195, ldvarg196);
#line 3854
      ldv_state_variable_87 = 1;
    } else {

    }
#line 3857
    if (ldv_state_variable_87 == 2) {
#line 3859
      qla2100_intr_handler(ldvarg195, ldvarg196);
#line 3861
      ldv_state_variable_87 = 2;
    } else {

    }
#line 3864
    goto ldv_68811;
    case 4: ;
#line 3867
    if (ldv_state_variable_87 == 1) {
#line 3869
      qla2x00_abort_target(qla2100_isp_ops_group2, ldvarg194, ldvarg193);
#line 3871
      ldv_state_variable_87 = 1;
    } else {

    }
#line 3874
    if (ldv_state_variable_87 == 2) {
#line 3876
      qla2x00_abort_target(qla2100_isp_ops_group2, ldvarg194, ldvarg193);
#line 3878
      ldv_state_variable_87 = 2;
    } else {

    }
#line 3881
    goto ldv_68811;
    case 5: ;
#line 3884
    if (ldv_state_variable_87 == 1) {
#line 3886
      qla2x00_update_fw_options(qla2100_isp_ops_group0);
#line 3888
      ldv_state_variable_87 = 1;
    } else {

    }
#line 3891
    if (ldv_state_variable_87 == 2) {
#line 3893
      qla2x00_update_fw_options(qla2100_isp_ops_group0);
#line 3895
      ldv_state_variable_87 = 2;
    } else {

    }
#line 3898
    goto ldv_68811;
    case 6: ;
#line 3901
    if (ldv_state_variable_87 == 1) {
#line 3903
      qla2x00_abort_isp(qla2100_isp_ops_group0);
#line 3905
      ldv_state_variable_87 = 1;
    } else {

    }
#line 3908
    if (ldv_state_variable_87 == 2) {
#line 3910
      qla2x00_abort_isp(qla2100_isp_ops_group0);
#line 3912
      ldv_state_variable_87 = 2;
    } else {

    }
#line 3915
    goto ldv_68811;
    case 7: ;
#line 3918
    if (ldv_state_variable_87 == 1) {
#line 3920
      qla2x00_start_scsi(ldvarg192);
#line 3922
      ldv_state_variable_87 = 1;
    } else {

    }
#line 3925
    if (ldv_state_variable_87 == 2) {
#line 3927
      qla2x00_start_scsi(ldvarg192);
#line 3929
      ldv_state_variable_87 = 2;
    } else {

    }
#line 3932
    goto ldv_68811;
    case 8: ;
#line 3935
    if (ldv_state_variable_87 == 1) {
#line 3937
      qla2x00_chip_diag(qla2100_isp_ops_group0);
#line 3939
      ldv_state_variable_87 = 1;
    } else {

    }
#line 3942
    if (ldv_state_variable_87 == 2) {
#line 3944
      qla2x00_chip_diag(qla2100_isp_ops_group0);
#line 3946
      ldv_state_variable_87 = 2;
    } else {

    }
#line 3949
    goto ldv_68811;
    case 9: ;
#line 3952
    if (ldv_state_variable_87 == 1) {
#line 3954
      qla2x00_fabric_logout(qla2100_isp_ops_group0, (int )ldvarg190, (int )ldvarg189,
                            (int )ldvarg188, (int )ldvarg191);
#line 3956
      ldv_state_variable_87 = 1;
    } else {

    }
#line 3959
    if (ldv_state_variable_87 == 2) {
#line 3961
      qla2x00_fabric_logout(qla2100_isp_ops_group0, (int )ldvarg190, (int )ldvarg189,
                            (int )ldvarg188, (int )ldvarg191);
#line 3963
      ldv_state_variable_87 = 2;
    } else {

    }
#line 3966
    goto ldv_68811;
    case 10: ;
#line 3969
    if (ldv_state_variable_87 == 1) {
#line 3971
      qla2x00_reset_chip(qla2100_isp_ops_group0);
#line 3973
      ldv_state_variable_87 = 1;
    } else {

    }
#line 3976
    if (ldv_state_variable_87 == 2) {
#line 3978
      qla2x00_reset_chip(qla2100_isp_ops_group0);
#line 3980
      ldv_state_variable_87 = 2;
    } else {

    }
#line 3983
    goto ldv_68811;
    case 11: ;
#line 3986
    if (ldv_state_variable_87 == 1) {
#line 3988
      qla2x00_prep_ms_iocb(qla2100_isp_ops_group0, ldvarg187, ldvarg186);
#line 3990
      ldv_state_variable_87 = 1;
    } else {

    }
#line 3993
    if (ldv_state_variable_87 == 2) {
#line 3995
      qla2x00_prep_ms_iocb(qla2100_isp_ops_group0, ldvarg187, ldvarg186);
#line 3997
      ldv_state_variable_87 = 2;
    } else {

    }
#line 4000
    goto ldv_68811;
    case 12: ;
#line 4003
    if (ldv_state_variable_87 == 1) {
#line 4005
      qla2x00_lun_reset(qla2100_isp_ops_group2, ldvarg185, ldvarg184);
#line 4007
      ldv_state_variable_87 = 1;
    } else {

    }
#line 4010
    if (ldv_state_variable_87 == 2) {
#line 4012
      qla2x00_lun_reset(qla2100_isp_ops_group2, ldvarg185, ldvarg184);
#line 4014
      ldv_state_variable_87 = 2;
    } else {

    }
#line 4017
    goto ldv_68811;
    case 13: ;
#line 4020
    if (ldv_state_variable_87 == 1) {
#line 4022
      qla2x00_fw_version_str(qla2100_isp_ops_group0, ldvarg183, ldvarg182);
#line 4024
      ldv_state_variable_87 = 1;
    } else {

    }
#line 4027
    if (ldv_state_variable_87 == 2) {
#line 4029
      qla2x00_fw_version_str(qla2100_isp_ops_group0, ldvarg183, ldvarg182);
#line 4031
      ldv_state_variable_87 = 2;
    } else {

    }
#line 4034
    goto ldv_68811;
    case 14: ;
#line 4037
    if (ldv_state_variable_87 == 1) {
#line 4039
      qla2x00_iospace_config(qla2100_isp_ops_group1);
#line 4041
      ldv_state_variable_87 = 1;
    } else {

    }
#line 4044
    if (ldv_state_variable_87 == 2) {
#line 4046
      qla2x00_iospace_config(qla2100_isp_ops_group1);
#line 4048
      ldv_state_variable_87 = 2;
    } else {

    }
#line 4051
    goto ldv_68811;
    case 15: ;
#line 4054
    if (ldv_state_variable_87 == 1) {
#line 4056
      qla2x00_initialize_adapter(qla2100_isp_ops_group0);
#line 4058
      ldv_state_variable_87 = 1;
    } else {

    }
#line 4061
    if (ldv_state_variable_87 == 2) {
#line 4063
      qla2x00_initialize_adapter(qla2100_isp_ops_group0);
#line 4065
      ldv_state_variable_87 = 2;
    } else {

    }
#line 4068
    goto ldv_68811;
    case 16: ;
#line 4071
    if (ldv_state_variable_87 == 1) {
#line 4073
      qla2x00_get_flash_version(qla2100_isp_ops_group0, ldvarg181);
#line 4075
      ldv_state_variable_87 = 1;
    } else {

    }
#line 4078
    if (ldv_state_variable_87 == 2) {
#line 4080
      qla2x00_get_flash_version(qla2100_isp_ops_group0, ldvarg181);
#line 4082
      ldv_state_variable_87 = 2;
    } else {

    }
#line 4085
    goto ldv_68811;
    case 17: ;
#line 4088
    if (ldv_state_variable_87 == 1) {
#line 4090
      qla2x00_disable_intrs(qla2100_isp_ops_group1);
#line 4092
      ldv_state_variable_87 = 1;
    } else {

    }
#line 4095
    if (ldv_state_variable_87 == 2) {
#line 4097
      qla2x00_disable_intrs(qla2100_isp_ops_group1);
#line 4099
      ldv_state_variable_87 = 2;
    } else {

    }
#line 4102
    goto ldv_68811;
    case 18: ;
#line 4105
    if (ldv_state_variable_87 == 1) {
#line 4107
      qla2x00_calc_iocbs_32((int )ldvarg180);
#line 4109
      ldv_state_variable_87 = 1;
    } else {

    }
#line 4112
    if (ldv_state_variable_87 == 2) {
#line 4114
      qla2x00_calc_iocbs_32((int )ldvarg180);
#line 4116
      ldv_state_variable_87 = 2;
    } else {

    }
#line 4119
    goto ldv_68811;
    case 19: ;
#line 4122
    if (ldv_state_variable_87 == 1) {
#line 4124
      qla2x00_nvram_config(qla2100_isp_ops_group0);
#line 4126
      ldv_state_variable_87 = 1;
    } else {

    }
#line 4129
    if (ldv_state_variable_87 == 2) {
#line 4131
      qla2x00_nvram_config(qla2100_isp_ops_group0);
#line 4133
      ldv_state_variable_87 = 2;
    } else {

    }
#line 4136
    goto ldv_68811;
    case 20: ;
#line 4139
    if (ldv_state_variable_87 == 1) {
#line 4141
      qla2x00_pci_info_str(qla2100_isp_ops_group0, ldvarg179);
#line 4143
      ldv_state_variable_87 = 1;
    } else {

    }
#line 4146
    if (ldv_state_variable_87 == 2) {
#line 4148
      qla2x00_pci_info_str(qla2100_isp_ops_group0, ldvarg179);
#line 4150
      ldv_state_variable_87 = 2;
    } else {

    }
#line 4153
    goto ldv_68811;
    case 21: ;
#line 4156
    if (ldv_state_variable_87 == 2) {
#line 4158
      qla2x00_read_optrom_data(qla2100_isp_ops_group0, ldvarg178, ldvarg177, ldvarg176);
#line 4160
      ldv_state_variable_87 = 2;
    } else {

    }
#line 4163
    goto ldv_68811;
    case 22: ;
#line 4166
    if (ldv_state_variable_87 == 1) {
#line 4168
      qla2x00_build_scsi_iocbs_32(ldvarg173, ldvarg175, (int )ldvarg174);
#line 4170
      ldv_state_variable_87 = 1;
    } else {

    }
#line 4173
    if (ldv_state_variable_87 == 2) {
#line 4175
      qla2x00_build_scsi_iocbs_32(ldvarg173, ldvarg175, (int )ldvarg174);
#line 4177
      ldv_state_variable_87 = 2;
    } else {

    }
#line 4180
    goto ldv_68811;
    case 23: ;
#line 4183
    if (ldv_state_variable_87 == 1) {
#line 4185
      qla2x00_abort_command(ldvarg172);
#line 4187
      ldv_state_variable_87 = 1;
    } else {

    }
#line 4190
    if (ldv_state_variable_87 == 2) {
#line 4192
      qla2x00_abort_command(ldvarg172);
#line 4194
      ldv_state_variable_87 = 2;
    } else {

    }
#line 4197
    goto ldv_68811;
    case 24: ;
#line 4200
    if (ldv_state_variable_87 == 1) {
#line 4202
      qla2x00_config_rings(qla2100_isp_ops_group0);
#line 4204
      ldv_state_variable_87 = 1;
    } else {

    }
#line 4207
    if (ldv_state_variable_87 == 2) {
#line 4209
      qla2x00_config_rings(qla2100_isp_ops_group0);
#line 4211
      ldv_state_variable_87 = 2;
    } else {

    }
#line 4214
    goto ldv_68811;
    case 25: ;
#line 4217
    if (ldv_state_variable_87 == 1) {
#line 4219
      qla2100_fw_dump(qla2100_isp_ops_group0, ldvarg171);
#line 4221
      ldv_state_variable_87 = 1;
    } else {

    }
#line 4224
    if (ldv_state_variable_87 == 2) {
#line 4226
      qla2100_fw_dump(qla2100_isp_ops_group0, ldvarg171);
#line 4228
      ldv_state_variable_87 = 2;
    } else {

    }
#line 4231
    goto ldv_68811;
    case 26: ;
#line 4234
    if (ldv_state_variable_87 == 1) {
#line 4236
      qla2x00_load_risc(qla2100_isp_ops_group0, ldvarg170);
#line 4238
      ldv_state_variable_87 = 1;
    } else {

    }
#line 4241
    if (ldv_state_variable_87 == 2) {
#line 4243
      qla2x00_load_risc(qla2100_isp_ops_group0, ldvarg170);
#line 4245
      ldv_state_variable_87 = 2;
    } else {

    }
#line 4248
    goto ldv_68811;
    case 27: ;
#line 4251
    if (ldv_state_variable_87 == 1) {
#line 4253
      qla2100_pci_config(qla2100_isp_ops_group0);
#line 4255
      ldv_state_variable_87 = 1;
    } else {

    }
#line 4258
    if (ldv_state_variable_87 == 2) {
#line 4260
      qla2100_pci_config(qla2100_isp_ops_group0);
#line 4262
      ldv_state_variable_87 = 2;
    } else {

    }
#line 4265
    goto ldv_68811;
    case 28: ;
#line 4268
    if (ldv_state_variable_87 == 1) {
#line 4270
      qla2x00_login_fabric(qla2100_isp_ops_group0, (int )ldvarg168, (int )ldvarg166,
                           (int )ldvarg165, (int )ldvarg169, ldvarg164, (int )ldvarg167);
#line 4272
      ldv_state_variable_87 = 1;
    } else {

    }
#line 4275
    if (ldv_state_variable_87 == 2) {
#line 4277
      qla2x00_login_fabric(qla2100_isp_ops_group0, (int )ldvarg168, (int )ldvarg166,
                           (int )ldvarg165, (int )ldvarg169, ldvarg164, (int )ldvarg167);
#line 4279
      ldv_state_variable_87 = 2;
    } else {

    }
#line 4282
    goto ldv_68811;
    case 29: ;
#line 4285
    if (ldv_state_variable_87 == 1) {
#line 4287
      qla2x00_write_nvram_data(qla2100_isp_ops_group0, ldvarg163, ldvarg162, ldvarg161);
#line 4289
      ldv_state_variable_87 = 1;
    } else {

    }
#line 4292
    if (ldv_state_variable_87 == 2) {
#line 4294
      qla2x00_write_nvram_data(qla2100_isp_ops_group0, ldvarg163, ldvarg162, ldvarg161);
#line 4296
      ldv_state_variable_87 = 2;
    } else {

    }
#line 4299
    goto ldv_68811;
    case 30: ;
#line 4302
    if (ldv_state_variable_87 == 1) {
#line 4304
      qla2x00_read_nvram_data(qla2100_isp_ops_group0, ldvarg160, ldvarg159, ldvarg158);
#line 4306
      ldv_state_variable_87 = 1;
    } else {

    }
#line 4309
    if (ldv_state_variable_87 == 2) {
#line 4311
      qla2x00_read_nvram_data(qla2100_isp_ops_group0, ldvarg160, ldvarg159, ldvarg158);
#line 4313
      ldv_state_variable_87 = 2;
    } else {

    }
#line 4316
    goto ldv_68811;
    case 31: ;
#line 4319
    if (ldv_state_variable_87 == 1) {
#line 4321
      qla2x00_prep_ms_fdmi_iocb(qla2100_isp_ops_group0, ldvarg157, ldvarg156);
#line 4323
      ldv_state_variable_87 = 1;
    } else {

    }
#line 4326
    if (ldv_state_variable_87 == 2) {
#line 4328
      qla2x00_prep_ms_fdmi_iocb(qla2100_isp_ops_group0, ldvarg157, ldvarg156);
#line 4330
      ldv_state_variable_87 = 2;
    } else {

    }
#line 4333
    goto ldv_68811;
    case 32: ;
#line 4336
    if (ldv_state_variable_87 == 2) {
#line 4338
      ldv_release_87();
#line 4340
      ldv_state_variable_87 = 1;
#line 4341
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 4344
    goto ldv_68811;
    case 33: ;
#line 4347
    if (ldv_state_variable_87 == 1) {
#line 4349
      ldv_probe_87();
#line 4351
      ldv_state_variable_87 = 2;
#line 4352
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 4355
    goto ldv_68811;
    default: 
#line 4356
    ldv_stop();
    }
    ldv_68811: ;
  } else {

  }
#line 4360
  goto ldv_68677;
  case 26: ;
#line 4364
  if (ldv_state_variable_77 != 0) {
#line 4365
    tmp___119 = __VERIFIER_nondet_int();
#line 4365
    switch (tmp___119) {
    case 0: ;
#line 4368
    if (ldv_state_variable_77 == 3) {
#line 4370
      qla2xxx_pci_resume(qla2xxx_err_handler_group0);
#line 4372
      ldv_state_variable_77 = 2;
    } else {

    }
#line 4375
    goto ldv_68848;
    case 1: ;
#line 4378
    if (ldv_state_variable_77 == 1) {
#line 4380
      qla2xxx_pci_slot_reset(qla2xxx_err_handler_group0);
#line 4382
      ldv_state_variable_77 = 1;
    } else {

    }
#line 4385
    if (ldv_state_variable_77 == 3) {
#line 4387
      qla2xxx_pci_slot_reset(qla2xxx_err_handler_group0);
#line 4389
      ldv_state_variable_77 = 3;
    } else {

    }
#line 4392
    if (ldv_state_variable_77 == 2) {
#line 4394
      qla2xxx_pci_slot_reset(qla2xxx_err_handler_group0);
#line 4396
      ldv_state_variable_77 = 2;
    } else {

    }
#line 4399
    goto ldv_68848;
    case 2: ;
#line 4402
    if (ldv_state_variable_77 == 1) {
#line 4404
      qla2xxx_pci_error_detected(qla2xxx_err_handler_group0, (pci_channel_state_t )ldvarg200);
#line 4406
      ldv_state_variable_77 = 1;
    } else {

    }
#line 4409
    if (ldv_state_variable_77 == 3) {
#line 4411
      qla2xxx_pci_error_detected(qla2xxx_err_handler_group0, (pci_channel_state_t )ldvarg200);
#line 4413
      ldv_state_variable_77 = 3;
    } else {

    }
#line 4416
    if (ldv_state_variable_77 == 2) {
#line 4418
      qla2xxx_pci_error_detected(qla2xxx_err_handler_group0, (pci_channel_state_t )ldvarg200);
#line 4420
      ldv_state_variable_77 = 2;
    } else {

    }
#line 4423
    goto ldv_68848;
    case 3: ;
#line 4426
    if (ldv_state_variable_77 == 1) {
#line 4428
      qla2xxx_pci_mmio_enabled(qla2xxx_err_handler_group0);
#line 4430
      ldv_state_variable_77 = 1;
    } else {

    }
#line 4433
    if (ldv_state_variable_77 == 3) {
#line 4435
      qla2xxx_pci_mmio_enabled(qla2xxx_err_handler_group0);
#line 4437
      ldv_state_variable_77 = 3;
    } else {

    }
#line 4440
    if (ldv_state_variable_77 == 2) {
#line 4442
      qla2xxx_pci_mmio_enabled(qla2xxx_err_handler_group0);
#line 4444
      ldv_state_variable_77 = 2;
    } else {

    }
#line 4447
    goto ldv_68848;
    case 4: ;
#line 4450
    if (ldv_state_variable_77 == 2) {
#line 4452
      ldv_suspend_77();
#line 4454
      ldv_state_variable_77 = 3;
    } else {

    }
#line 4457
    goto ldv_68848;
    case 5: ;
#line 4460
    if (ldv_state_variable_77 == 3) {
#line 4462
      ldv_release_77();
#line 4464
      ldv_state_variable_77 = 1;
#line 4465
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 4468
    if (ldv_state_variable_77 == 2) {
#line 4470
      ldv_release_77();
#line 4472
      ldv_state_variable_77 = 1;
#line 4473
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 4476
    goto ldv_68848;
    case 6: ;
#line 4479
    if (ldv_state_variable_77 == 1) {
#line 4481
      ldv_probe_77();
#line 4483
      ldv_state_variable_77 = 2;
#line 4484
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 4487
    goto ldv_68848;
    default: 
#line 4488
    ldv_stop();
    }
    ldv_68848: ;
  } else {

  }
#line 4492
  goto ldv_68677;
  case 27: ;
#line 4496
  if (ldv_state_variable_65 != 0) {
#line 4497
    ldv_main_exported_65();
  } else {

  }
#line 4500
  goto ldv_68677;
  case 28: ;
#line 4507
  goto ldv_68677;
  case 29: ;
#line 4511
  if (ldv_state_variable_50 != 0) {
#line 4512
    ldv_main_exported_50();
  } else {

  }
#line 4515
  goto ldv_68677;
  case 30: ;
#line 4519
  if (ldv_state_variable_39 != 0) {
#line 4520
    ldv_main_exported_39();
  } else {

  }
#line 4523
  goto ldv_68677;
  case 31: ;
#line 4527
  if (ldv_state_variable_64 != 0) {
#line 4528
    ldv_main_exported_64();
  } else {

  }
#line 4531
  goto ldv_68677;
  case 32: ;
#line 4535
  if (ldv_state_variable_58 != 0) {
#line 4536
    ldv_main_exported_58();
  } else {

  }
#line 4539
  goto ldv_68677;
  case 33: ;
#line 4543
  if (ldv_state_variable_41 != 0) {
#line 4544
    ldv_main_exported_41();
  } else {

  }
#line 4547
  goto ldv_68677;
  case 34: ;
#line 4554
  goto ldv_68677;
  case 35: ;
#line 4561
  goto ldv_68677;
  case 36: ;
#line 4565
  if (ldv_state_variable_81 != 0) {
#line 4566
    tmp___120 = __VERIFIER_nondet_int();
#line 4566
    switch (tmp___120) {
    case 0: ;
#line 4569
    if (ldv_state_variable_81 == 1) {
#line 4571
      qla24xx_reset_adapter(qla8044_isp_ops_group0);
#line 4573
      ldv_state_variable_81 = 1;
    } else {

    }
#line 4576
    if (ldv_state_variable_81 == 2) {
#line 4578
      qla24xx_reset_adapter(qla8044_isp_ops_group0);
#line 4580
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4583
    goto ldv_68867;
    case 1: ;
#line 4586
    if (ldv_state_variable_81 == 2) {
#line 4588
      qla8044_write_optrom_data(qla8044_isp_ops_group0, ldvarg255, ldvarg254, ldvarg253);
#line 4590
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4593
    goto ldv_68867;
    case 2: ;
#line 4596
    if (ldv_state_variable_81 == 1) {
#line 4598
      qla82xx_enable_intrs(qla8044_isp_ops_group1);
#line 4600
      ldv_state_variable_81 = 1;
    } else {

    }
#line 4603
    if (ldv_state_variable_81 == 2) {
#line 4605
      qla82xx_enable_intrs(qla8044_isp_ops_group1);
#line 4607
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4610
    goto ldv_68867;
    case 3: ;
#line 4613
    if (ldv_state_variable_81 == 1) {
#line 4615
      qla8044_intr_handler(ldvarg251, ldvarg252);
#line 4617
      ldv_state_variable_81 = 1;
    } else {

    }
#line 4620
    if (ldv_state_variable_81 == 2) {
#line 4622
      qla8044_intr_handler(ldvarg251, ldvarg252);
#line 4624
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4627
    goto ldv_68867;
    case 4: ;
#line 4630
    if (ldv_state_variable_81 == 1) {
#line 4632
      qla24xx_abort_target(qla8044_isp_ops_group2, ldvarg250, ldvarg249);
#line 4634
      ldv_state_variable_81 = 1;
    } else {

    }
#line 4637
    if (ldv_state_variable_81 == 2) {
#line 4639
      qla24xx_abort_target(qla8044_isp_ops_group2, ldvarg250, ldvarg249);
#line 4641
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4644
    goto ldv_68867;
    case 5: ;
#line 4647
    if (ldv_state_variable_81 == 1) {
#line 4649
      qla24xx_update_fw_options(qla8044_isp_ops_group0);
#line 4651
      ldv_state_variable_81 = 1;
    } else {

    }
#line 4654
    if (ldv_state_variable_81 == 2) {
#line 4656
      qla24xx_update_fw_options(qla8044_isp_ops_group0);
#line 4658
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4661
    goto ldv_68867;
    case 6: ;
#line 4664
    if (ldv_state_variable_81 == 1) {
#line 4666
      qla8044_abort_isp(qla8044_isp_ops_group0);
#line 4668
      ldv_state_variable_81 = 1;
    } else {

    }
#line 4671
    if (ldv_state_variable_81 == 2) {
#line 4673
      qla8044_abort_isp(qla8044_isp_ops_group0);
#line 4675
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4678
    goto ldv_68867;
    case 7: ;
#line 4681
    if (ldv_state_variable_81 == 1) {
#line 4683
      qla82xx_start_scsi(ldvarg248);
#line 4685
      ldv_state_variable_81 = 1;
    } else {

    }
#line 4688
    if (ldv_state_variable_81 == 2) {
#line 4690
      qla82xx_start_scsi(ldvarg248);
#line 4692
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4695
    goto ldv_68867;
    case 8: ;
#line 4698
    if (ldv_state_variable_81 == 1) {
#line 4700
      qla24xx_chip_diag(qla8044_isp_ops_group0);
#line 4702
      ldv_state_variable_81 = 1;
    } else {

    }
#line 4705
    if (ldv_state_variable_81 == 2) {
#line 4707
      qla24xx_chip_diag(qla8044_isp_ops_group0);
#line 4709
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4712
    goto ldv_68867;
    case 9: ;
#line 4715
    if (ldv_state_variable_81 == 1) {
#line 4717
      qla24xx_fabric_logout(qla8044_isp_ops_group0, (int )ldvarg246, (int )ldvarg245,
                            (int )ldvarg244, (int )ldvarg247);
#line 4719
      ldv_state_variable_81 = 1;
    } else {

    }
#line 4722
    if (ldv_state_variable_81 == 2) {
#line 4724
      qla24xx_fabric_logout(qla8044_isp_ops_group0, (int )ldvarg246, (int )ldvarg245,
                            (int )ldvarg244, (int )ldvarg247);
#line 4726
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4729
    goto ldv_68867;
    case 10: ;
#line 4732
    if (ldv_state_variable_81 == 1) {
#line 4734
      qla82xx_reset_chip(qla8044_isp_ops_group0);
#line 4736
      ldv_state_variable_81 = 1;
    } else {

    }
#line 4739
    if (ldv_state_variable_81 == 2) {
#line 4741
      qla82xx_reset_chip(qla8044_isp_ops_group0);
#line 4743
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4746
    goto ldv_68867;
    case 11: ;
#line 4749
    if (ldv_state_variable_81 == 1) {
#line 4751
      qla24xx_prep_ms_iocb(qla8044_isp_ops_group0, ldvarg243, ldvarg242);
#line 4753
      ldv_state_variable_81 = 1;
    } else {

    }
#line 4756
    if (ldv_state_variable_81 == 2) {
#line 4758
      qla24xx_prep_ms_iocb(qla8044_isp_ops_group0, ldvarg243, ldvarg242);
#line 4760
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4763
    goto ldv_68867;
    case 12: ;
#line 4766
    if (ldv_state_variable_81 == 1) {
#line 4768
      qla24xx_lun_reset(qla8044_isp_ops_group2, ldvarg241, ldvarg240);
#line 4770
      ldv_state_variable_81 = 1;
    } else {

    }
#line 4773
    if (ldv_state_variable_81 == 2) {
#line 4775
      qla24xx_lun_reset(qla8044_isp_ops_group2, ldvarg241, ldvarg240);
#line 4777
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4780
    goto ldv_68867;
    case 13: ;
#line 4783
    if (ldv_state_variable_81 == 1) {
#line 4785
      qla24xx_fw_version_str(qla8044_isp_ops_group0, ldvarg239, ldvarg238);
#line 4787
      ldv_state_variable_81 = 1;
    } else {

    }
#line 4790
    if (ldv_state_variable_81 == 2) {
#line 4792
      qla24xx_fw_version_str(qla8044_isp_ops_group0, ldvarg239, ldvarg238);
#line 4794
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4797
    goto ldv_68867;
    case 14: ;
#line 4800
    if (ldv_state_variable_81 == 1) {
#line 4802
      qla82xx_iospace_config(qla8044_isp_ops_group1);
#line 4804
      ldv_state_variable_81 = 1;
    } else {

    }
#line 4807
    if (ldv_state_variable_81 == 2) {
#line 4809
      qla82xx_iospace_config(qla8044_isp_ops_group1);
#line 4811
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4814
    goto ldv_68867;
    case 15: ;
#line 4817
    if (ldv_state_variable_81 == 1) {
#line 4819
      qla2x00_initialize_adapter(qla8044_isp_ops_group0);
#line 4821
      ldv_state_variable_81 = 1;
    } else {

    }
#line 4824
    if (ldv_state_variable_81 == 2) {
#line 4826
      qla2x00_initialize_adapter(qla8044_isp_ops_group0);
#line 4828
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4831
    goto ldv_68867;
    case 16: ;
#line 4834
    if (ldv_state_variable_81 == 1) {
#line 4836
      qla82xx_get_flash_version(qla8044_isp_ops_group0, ldvarg237);
#line 4838
      ldv_state_variable_81 = 1;
    } else {

    }
#line 4841
    if (ldv_state_variable_81 == 2) {
#line 4843
      qla82xx_get_flash_version(qla8044_isp_ops_group0, ldvarg237);
#line 4845
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4848
    goto ldv_68867;
    case 17: ;
#line 4851
    if (ldv_state_variable_81 == 1) {
#line 4853
      qla82xx_disable_intrs(qla8044_isp_ops_group1);
#line 4855
      ldv_state_variable_81 = 1;
    } else {

    }
#line 4858
    if (ldv_state_variable_81 == 2) {
#line 4860
      qla82xx_disable_intrs(qla8044_isp_ops_group1);
#line 4862
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4865
    goto ldv_68867;
    case 18: ;
#line 4868
    if (ldv_state_variable_81 == 1) {
#line 4870
      qla81xx_nvram_config(qla8044_isp_ops_group0);
#line 4872
      ldv_state_variable_81 = 1;
    } else {

    }
#line 4875
    if (ldv_state_variable_81 == 2) {
#line 4877
      qla81xx_nvram_config(qla8044_isp_ops_group0);
#line 4879
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4882
    goto ldv_68867;
    case 19: ;
#line 4885
    if (ldv_state_variable_81 == 1) {
#line 4887
      qla24xx_pci_info_str(qla8044_isp_ops_group0, ldvarg236);
#line 4889
      ldv_state_variable_81 = 1;
    } else {

    }
#line 4892
    if (ldv_state_variable_81 == 2) {
#line 4894
      qla24xx_pci_info_str(qla8044_isp_ops_group0, ldvarg236);
#line 4896
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4899
    goto ldv_68867;
    case 20: ;
#line 4902
    if (ldv_state_variable_81 == 2) {
#line 4904
      qla8044_read_optrom_data(qla8044_isp_ops_group0, ldvarg235, ldvarg234, ldvarg233);
#line 4906
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4909
    goto ldv_68867;
    case 21: ;
#line 4912
    if (ldv_state_variable_81 == 1) {
#line 4914
      qla82xx_beacon_off(qla8044_isp_ops_group0);
#line 4916
      ldv_state_variable_81 = 1;
    } else {

    }
#line 4919
    if (ldv_state_variable_81 == 2) {
#line 4921
      qla82xx_beacon_off(qla8044_isp_ops_group0);
#line 4923
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4926
    goto ldv_68867;
    case 22: ;
#line 4929
    if (ldv_state_variable_81 == 1) {
#line 4931
      qla24xx_abort_command(ldvarg232);
#line 4933
      ldv_state_variable_81 = 1;
    } else {

    }
#line 4936
    if (ldv_state_variable_81 == 2) {
#line 4938
      qla24xx_abort_command(ldvarg232);
#line 4940
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4943
    goto ldv_68867;
    case 23: ;
#line 4946
    if (ldv_state_variable_81 == 1) {
#line 4948
      qla8044_fw_dump(qla8044_isp_ops_group0, ldvarg231);
#line 4950
      ldv_state_variable_81 = 1;
    } else {

    }
#line 4953
    if (ldv_state_variable_81 == 2) {
#line 4955
      qla8044_fw_dump(qla8044_isp_ops_group0, ldvarg231);
#line 4957
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4960
    goto ldv_68867;
    case 24: ;
#line 4963
    if (ldv_state_variable_81 == 1) {
#line 4965
      qla82xx_config_rings(qla8044_isp_ops_group0);
#line 4967
      ldv_state_variable_81 = 1;
    } else {

    }
#line 4970
    if (ldv_state_variable_81 == 2) {
#line 4972
      qla82xx_config_rings(qla8044_isp_ops_group0);
#line 4974
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4977
    goto ldv_68867;
    case 25: ;
#line 4980
    if (ldv_state_variable_81 == 1) {
#line 4982
      qla82xx_load_risc(qla8044_isp_ops_group0, ldvarg230);
#line 4984
      ldv_state_variable_81 = 1;
    } else {

    }
#line 4987
    if (ldv_state_variable_81 == 2) {
#line 4989
      qla82xx_load_risc(qla8044_isp_ops_group0, ldvarg230);
#line 4991
      ldv_state_variable_81 = 2;
    } else {

    }
#line 4994
    goto ldv_68867;
    case 26: ;
#line 4997
    if (ldv_state_variable_81 == 1) {
#line 4999
      qla82xx_pci_config(qla8044_isp_ops_group0);
#line 5001
      ldv_state_variable_81 = 1;
    } else {

    }
#line 5004
    if (ldv_state_variable_81 == 2) {
#line 5006
      qla82xx_pci_config(qla8044_isp_ops_group0);
#line 5008
      ldv_state_variable_81 = 2;
    } else {

    }
#line 5011
    goto ldv_68867;
    case 27: ;
#line 5014
    if (ldv_state_variable_81 == 1) {
#line 5016
      qla24xx_login_fabric(qla8044_isp_ops_group0, (int )ldvarg228, (int )ldvarg226,
                           (int )ldvarg225, (int )ldvarg229, ldvarg224, (int )ldvarg227);
#line 5018
      ldv_state_variable_81 = 1;
    } else {

    }
#line 5021
    if (ldv_state_variable_81 == 2) {
#line 5023
      qla24xx_login_fabric(qla8044_isp_ops_group0, (int )ldvarg228, (int )ldvarg226,
                           (int )ldvarg225, (int )ldvarg229, ldvarg224, (int )ldvarg227);
#line 5025
      ldv_state_variable_81 = 2;
    } else {

    }
#line 5028
    goto ldv_68867;
    case 28: ;
#line 5031
    if (ldv_state_variable_81 == 1) {
#line 5033
      qla82xx_beacon_on(qla8044_isp_ops_group0);
#line 5035
      ldv_state_variable_81 = 1;
    } else {

    }
#line 5038
    if (ldv_state_variable_81 == 2) {
#line 5040
      qla82xx_beacon_on(qla8044_isp_ops_group0);
#line 5042
      ldv_state_variable_81 = 2;
    } else {

    }
#line 5045
    goto ldv_68867;
    case 29: ;
#line 5048
    if (ldv_state_variable_81 == 1) {
#line 5050
      qla24xx_prep_ms_fdmi_iocb(qla8044_isp_ops_group0, ldvarg223, ldvarg222);
#line 5052
      ldv_state_variable_81 = 1;
    } else {

    }
#line 5055
    if (ldv_state_variable_81 == 2) {
#line 5057
      qla24xx_prep_ms_fdmi_iocb(qla8044_isp_ops_group0, ldvarg223, ldvarg222);
#line 5059
      ldv_state_variable_81 = 2;
    } else {

    }
#line 5062
    goto ldv_68867;
    case 30: ;
#line 5065
    if (ldv_state_variable_81 == 2) {
#line 5067
      ldv_release_81();
#line 5069
      ldv_state_variable_81 = 1;
#line 5070
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 5073
    goto ldv_68867;
    case 31: ;
#line 5076
    if (ldv_state_variable_81 == 1) {
#line 5078
      ldv_probe_81();
#line 5080
      ldv_state_variable_81 = 2;
#line 5081
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 5084
    goto ldv_68867;
    default: 
#line 5085
    ldv_stop();
    }
    ldv_68867: ;
  } else {

  }
#line 5089
  goto ldv_68677;
  case 37: ;
#line 5093
  if (ldv_state_variable_52 != 0) {
#line 5094
    ldv_main_exported_52();
  } else {

  }
#line 5097
  goto ldv_68677;
  case 38: ;
#line 5101
  if (ldv_state_variable_60 != 0) {
#line 5102
    ldv_main_exported_60();
  } else {

  }
#line 5105
  goto ldv_68677;
  case 39: ;
#line 5109
  if (ldv_state_variable_56 != 0) {
#line 5110
    ldv_main_exported_56();
  } else {

  }
#line 5113
  goto ldv_68677;
  case 40: ;
#line 5117
  if (ldv_state_variable_73 != 0) {
#line 5118
    ldv_main_exported_73();
  } else {

  }
#line 5121
  goto ldv_68677;
  case 41: ;
#line 5125
  if (ldv_state_variable_66 != 0) {
#line 5126
    ldv_main_exported_66();
  } else {

  }
#line 5129
  goto ldv_68677;
  case 42: ;
#line 5133
  if (ldv_state_variable_45 != 0) {
#line 5134
    ldv_main_exported_45();
  } else {

  }
#line 5137
  goto ldv_68677;
  case 43: ;
#line 5141
  if (ldv_state_variable_86 != 0) {
#line 5142
    tmp___121 = __VERIFIER_nondet_int();
#line 5142
    switch (tmp___121) {
    case 0: ;
#line 5145
    if (ldv_state_variable_86 == 1) {
#line 5147
      qla2x00_reset_adapter(qla2300_isp_ops_group0);
#line 5149
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5152
    if (ldv_state_variable_86 == 2) {
#line 5154
      qla2x00_reset_adapter(qla2300_isp_ops_group0);
#line 5156
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5159
    goto ldv_68908;
    case 1: ;
#line 5162
    if (ldv_state_variable_86 == 1) {
#line 5164
      qla2x00_enable_intrs(qla2300_isp_ops_group1);
#line 5166
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5169
    if (ldv_state_variable_86 == 2) {
#line 5171
      qla2x00_enable_intrs(qla2300_isp_ops_group1);
#line 5173
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5176
    goto ldv_68908;
    case 2: ;
#line 5179
    if (ldv_state_variable_86 == 2) {
#line 5181
      qla2x00_write_optrom_data(qla2300_isp_ops_group0, ldvarg323, ldvarg322, ldvarg321);
#line 5183
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5186
    goto ldv_68908;
    case 3: ;
#line 5189
    if (ldv_state_variable_86 == 1) {
#line 5191
      qla2300_intr_handler(ldvarg319, ldvarg320);
#line 5193
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5196
    if (ldv_state_variable_86 == 2) {
#line 5198
      qla2300_intr_handler(ldvarg319, ldvarg320);
#line 5200
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5203
    goto ldv_68908;
    case 4: ;
#line 5206
    if (ldv_state_variable_86 == 1) {
#line 5208
      qla2x00_abort_target(qla2300_isp_ops_group2, ldvarg318, ldvarg317);
#line 5210
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5213
    if (ldv_state_variable_86 == 2) {
#line 5215
      qla2x00_abort_target(qla2300_isp_ops_group2, ldvarg318, ldvarg317);
#line 5217
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5220
    goto ldv_68908;
    case 5: ;
#line 5223
    if (ldv_state_variable_86 == 1) {
#line 5225
      qla2x00_update_fw_options(qla2300_isp_ops_group0);
#line 5227
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5230
    if (ldv_state_variable_86 == 2) {
#line 5232
      qla2x00_update_fw_options(qla2300_isp_ops_group0);
#line 5234
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5237
    goto ldv_68908;
    case 6: ;
#line 5240
    if (ldv_state_variable_86 == 1) {
#line 5242
      qla2x00_abort_isp(qla2300_isp_ops_group0);
#line 5244
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5247
    if (ldv_state_variable_86 == 2) {
#line 5249
      qla2x00_abort_isp(qla2300_isp_ops_group0);
#line 5251
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5254
    goto ldv_68908;
    case 7: ;
#line 5257
    if (ldv_state_variable_86 == 1) {
#line 5259
      qla2x00_start_scsi(ldvarg316);
#line 5261
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5264
    if (ldv_state_variable_86 == 2) {
#line 5266
      qla2x00_start_scsi(ldvarg316);
#line 5268
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5271
    goto ldv_68908;
    case 8: ;
#line 5274
    if (ldv_state_variable_86 == 1) {
#line 5276
      qla2x00_chip_diag(qla2300_isp_ops_group0);
#line 5278
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5281
    if (ldv_state_variable_86 == 2) {
#line 5283
      qla2x00_chip_diag(qla2300_isp_ops_group0);
#line 5285
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5288
    goto ldv_68908;
    case 9: ;
#line 5291
    if (ldv_state_variable_86 == 1) {
#line 5293
      qla2x00_fabric_logout(qla2300_isp_ops_group0, (int )ldvarg314, (int )ldvarg313,
                            (int )ldvarg312, (int )ldvarg315);
#line 5295
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5298
    if (ldv_state_variable_86 == 2) {
#line 5300
      qla2x00_fabric_logout(qla2300_isp_ops_group0, (int )ldvarg314, (int )ldvarg313,
                            (int )ldvarg312, (int )ldvarg315);
#line 5302
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5305
    goto ldv_68908;
    case 10: ;
#line 5308
    if (ldv_state_variable_86 == 1) {
#line 5310
      qla2x00_reset_chip(qla2300_isp_ops_group0);
#line 5312
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5315
    if (ldv_state_variable_86 == 2) {
#line 5317
      qla2x00_reset_chip(qla2300_isp_ops_group0);
#line 5319
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5322
    goto ldv_68908;
    case 11: ;
#line 5325
    if (ldv_state_variable_86 == 1) {
#line 5327
      qla2x00_prep_ms_iocb(qla2300_isp_ops_group0, ldvarg311, ldvarg310);
#line 5329
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5332
    if (ldv_state_variable_86 == 2) {
#line 5334
      qla2x00_prep_ms_iocb(qla2300_isp_ops_group0, ldvarg311, ldvarg310);
#line 5336
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5339
    goto ldv_68908;
    case 12: ;
#line 5342
    if (ldv_state_variable_86 == 1) {
#line 5344
      qla2x00_lun_reset(qla2300_isp_ops_group2, ldvarg309, ldvarg308);
#line 5346
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5349
    if (ldv_state_variable_86 == 2) {
#line 5351
      qla2x00_lun_reset(qla2300_isp_ops_group2, ldvarg309, ldvarg308);
#line 5353
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5356
    goto ldv_68908;
    case 13: ;
#line 5359
    if (ldv_state_variable_86 == 1) {
#line 5361
      qla2x00_fw_version_str(qla2300_isp_ops_group0, ldvarg307, ldvarg306);
#line 5363
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5366
    if (ldv_state_variable_86 == 2) {
#line 5368
      qla2x00_fw_version_str(qla2300_isp_ops_group0, ldvarg307, ldvarg306);
#line 5370
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5373
    goto ldv_68908;
    case 14: ;
#line 5376
    if (ldv_state_variable_86 == 1) {
#line 5378
      qla2x00_iospace_config(qla2300_isp_ops_group1);
#line 5380
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5383
    if (ldv_state_variable_86 == 2) {
#line 5385
      qla2x00_iospace_config(qla2300_isp_ops_group1);
#line 5387
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5390
    goto ldv_68908;
    case 15: ;
#line 5393
    if (ldv_state_variable_86 == 1) {
#line 5395
      qla2x00_initialize_adapter(qla2300_isp_ops_group0);
#line 5397
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5400
    if (ldv_state_variable_86 == 2) {
#line 5402
      qla2x00_initialize_adapter(qla2300_isp_ops_group0);
#line 5404
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5407
    goto ldv_68908;
    case 16: ;
#line 5410
    if (ldv_state_variable_86 == 1) {
#line 5412
      qla2x00_disable_intrs(qla2300_isp_ops_group1);
#line 5414
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5417
    if (ldv_state_variable_86 == 2) {
#line 5419
      qla2x00_disable_intrs(qla2300_isp_ops_group1);
#line 5421
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5424
    goto ldv_68908;
    case 17: ;
#line 5427
    if (ldv_state_variable_86 == 1) {
#line 5429
      qla2x00_get_flash_version(qla2300_isp_ops_group0, ldvarg305);
#line 5431
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5434
    if (ldv_state_variable_86 == 2) {
#line 5436
      qla2x00_get_flash_version(qla2300_isp_ops_group0, ldvarg305);
#line 5438
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5441
    goto ldv_68908;
    case 18: ;
#line 5444
    if (ldv_state_variable_86 == 1) {
#line 5446
      qla2x00_calc_iocbs_32((int )ldvarg304);
#line 5448
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5451
    if (ldv_state_variable_86 == 2) {
#line 5453
      qla2x00_calc_iocbs_32((int )ldvarg304);
#line 5455
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5458
    goto ldv_68908;
    case 19: ;
#line 5461
    if (ldv_state_variable_86 == 1) {
#line 5463
      qla2x00_nvram_config(qla2300_isp_ops_group0);
#line 5465
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5468
    if (ldv_state_variable_86 == 2) {
#line 5470
      qla2x00_nvram_config(qla2300_isp_ops_group0);
#line 5472
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5475
    goto ldv_68908;
    case 20: ;
#line 5478
    if (ldv_state_variable_86 == 1) {
#line 5480
      qla2x00_pci_info_str(qla2300_isp_ops_group0, ldvarg303);
#line 5482
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5485
    if (ldv_state_variable_86 == 2) {
#line 5487
      qla2x00_pci_info_str(qla2300_isp_ops_group0, ldvarg303);
#line 5489
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5492
    goto ldv_68908;
    case 21: ;
#line 5495
    if (ldv_state_variable_86 == 2) {
#line 5497
      qla2x00_read_optrom_data(qla2300_isp_ops_group0, ldvarg302, ldvarg301, ldvarg300);
#line 5499
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5502
    goto ldv_68908;
    case 22: ;
#line 5505
    if (ldv_state_variable_86 == 1) {
#line 5507
      qla2x00_beacon_blink(qla2300_isp_ops_group0);
#line 5509
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5512
    if (ldv_state_variable_86 == 2) {
#line 5514
      qla2x00_beacon_blink(qla2300_isp_ops_group0);
#line 5516
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5519
    goto ldv_68908;
    case 23: ;
#line 5522
    if (ldv_state_variable_86 == 1) {
#line 5524
      qla2x00_beacon_off(qla2300_isp_ops_group0);
#line 5526
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5529
    if (ldv_state_variable_86 == 2) {
#line 5531
      qla2x00_beacon_off(qla2300_isp_ops_group0);
#line 5533
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5536
    goto ldv_68908;
    case 24: ;
#line 5539
    if (ldv_state_variable_86 == 1) {
#line 5541
      qla2x00_build_scsi_iocbs_32(ldvarg297, ldvarg299, (int )ldvarg298);
#line 5543
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5546
    if (ldv_state_variable_86 == 2) {
#line 5548
      qla2x00_build_scsi_iocbs_32(ldvarg297, ldvarg299, (int )ldvarg298);
#line 5550
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5553
    goto ldv_68908;
    case 25: ;
#line 5556
    if (ldv_state_variable_86 == 1) {
#line 5558
      qla2x00_abort_command(ldvarg296);
#line 5560
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5563
    if (ldv_state_variable_86 == 2) {
#line 5565
      qla2x00_abort_command(ldvarg296);
#line 5567
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5570
    goto ldv_68908;
    case 26: ;
#line 5573
    if (ldv_state_variable_86 == 1) {
#line 5575
      qla2300_fw_dump(qla2300_isp_ops_group0, ldvarg295);
#line 5577
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5580
    if (ldv_state_variable_86 == 2) {
#line 5582
      qla2300_fw_dump(qla2300_isp_ops_group0, ldvarg295);
#line 5584
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5587
    goto ldv_68908;
    case 27: ;
#line 5590
    if (ldv_state_variable_86 == 1) {
#line 5592
      qla2x00_config_rings(qla2300_isp_ops_group0);
#line 5594
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5597
    if (ldv_state_variable_86 == 2) {
#line 5599
      qla2x00_config_rings(qla2300_isp_ops_group0);
#line 5601
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5604
    goto ldv_68908;
    case 28: ;
#line 5607
    if (ldv_state_variable_86 == 1) {
#line 5609
      qla2x00_load_risc(qla2300_isp_ops_group0, ldvarg294);
#line 5611
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5614
    if (ldv_state_variable_86 == 2) {
#line 5616
      qla2x00_load_risc(qla2300_isp_ops_group0, ldvarg294);
#line 5618
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5621
    goto ldv_68908;
    case 29: ;
#line 5624
    if (ldv_state_variable_86 == 1) {
#line 5626
      qla2300_pci_config(qla2300_isp_ops_group0);
#line 5628
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5631
    if (ldv_state_variable_86 == 2) {
#line 5633
      qla2300_pci_config(qla2300_isp_ops_group0);
#line 5635
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5638
    goto ldv_68908;
    case 30: ;
#line 5641
    if (ldv_state_variable_86 == 1) {
#line 5643
      qla2x00_login_fabric(qla2300_isp_ops_group0, (int )ldvarg292, (int )ldvarg290,
                           (int )ldvarg289, (int )ldvarg293, ldvarg288, (int )ldvarg291);
#line 5645
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5648
    if (ldv_state_variable_86 == 2) {
#line 5650
      qla2x00_login_fabric(qla2300_isp_ops_group0, (int )ldvarg292, (int )ldvarg290,
                           (int )ldvarg289, (int )ldvarg293, ldvarg288, (int )ldvarg291);
#line 5652
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5655
    goto ldv_68908;
    case 31: ;
#line 5658
    if (ldv_state_variable_86 == 1) {
#line 5660
      qla2x00_write_nvram_data(qla2300_isp_ops_group0, ldvarg287, ldvarg286, ldvarg285);
#line 5662
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5665
    if (ldv_state_variable_86 == 2) {
#line 5667
      qla2x00_write_nvram_data(qla2300_isp_ops_group0, ldvarg287, ldvarg286, ldvarg285);
#line 5669
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5672
    goto ldv_68908;
    case 32: ;
#line 5675
    if (ldv_state_variable_86 == 1) {
#line 5677
      qla2x00_beacon_on(qla2300_isp_ops_group0);
#line 5679
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5682
    if (ldv_state_variable_86 == 2) {
#line 5684
      qla2x00_beacon_on(qla2300_isp_ops_group0);
#line 5686
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5689
    goto ldv_68908;
    case 33: ;
#line 5692
    if (ldv_state_variable_86 == 1) {
#line 5694
      qla2x00_read_nvram_data(qla2300_isp_ops_group0, ldvarg284, ldvarg283, ldvarg282);
#line 5696
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5699
    if (ldv_state_variable_86 == 2) {
#line 5701
      qla2x00_read_nvram_data(qla2300_isp_ops_group0, ldvarg284, ldvarg283, ldvarg282);
#line 5703
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5706
    goto ldv_68908;
    case 34: ;
#line 5709
    if (ldv_state_variable_86 == 1) {
#line 5711
      qla2x00_prep_ms_fdmi_iocb(qla2300_isp_ops_group0, ldvarg281, ldvarg280);
#line 5713
      ldv_state_variable_86 = 1;
    } else {

    }
#line 5716
    if (ldv_state_variable_86 == 2) {
#line 5718
      qla2x00_prep_ms_fdmi_iocb(qla2300_isp_ops_group0, ldvarg281, ldvarg280);
#line 5720
      ldv_state_variable_86 = 2;
    } else {

    }
#line 5723
    goto ldv_68908;
    case 35: ;
#line 5726
    if (ldv_state_variable_86 == 2) {
#line 5728
      ldv_release_86();
#line 5730
      ldv_state_variable_86 = 1;
#line 5731
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 5734
    goto ldv_68908;
    case 36: ;
#line 5737
    if (ldv_state_variable_86 == 1) {
#line 5739
      ldv_probe_86();
#line 5741
      ldv_state_variable_86 = 2;
#line 5742
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 5745
    goto ldv_68908;
    default: 
#line 5746
    ldv_stop();
    }
    ldv_68908: ;
  } else {

  }
#line 5750
  goto ldv_68677;
  case 44: ;
#line 5754
  if (ldv_state_variable_76 != 0) {
#line 5755
    tmp___122 = __VERIFIER_nondet_int();
#line 5755
    switch (tmp___122) {
    case 0: ;
#line 5758
    if (ldv_state_variable_76 == 1) {
#line 5760
      ldv_retval_1 = qla2x00_probe_one(qla2xxx_pci_driver_group1, (struct pci_device_id  const  *)ldvarg324);
#line 5761
      if (ldv_retval_1 == 0) {
#line 5762
        ldv_state_variable_76 = 2;
#line 5763
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 5767
    goto ldv_68948;
    case 1: ;
#line 5770
    if (ldv_state_variable_76 == 2) {
#line 5772
      qla2x00_shutdown(qla2xxx_pci_driver_group1);
#line 5773
      ldv_state_variable_76 = 2;
    } else {

    }
#line 5776
    goto ldv_68948;
    case 2: ;
#line 5779
    if (ldv_state_variable_76 == 2) {
#line 5781
      qla2x00_remove_one(qla2xxx_pci_driver_group1);
#line 5782
      ldv_state_variable_76 = 1;
    } else {

    }
#line 5785
    goto ldv_68948;
    default: 
#line 5786
    ldv_stop();
    }
    ldv_68948: ;
  } else {

  }
#line 5790
  goto ldv_68677;
  case 45: ;
#line 5797
  goto ldv_68677;
  case 46: ;
#line 5801
  if (ldv_state_variable_62 != 0) {
#line 5802
    ldv_main_exported_62();
  } else {

  }
#line 5805
  goto ldv_68677;
  case 47: ;
#line 5809
  if (ldv_state_variable_54 != 0) {
#line 5810
    ldv_main_exported_54();
  } else {

  }
#line 5813
  goto ldv_68677;
  case 48: ;
#line 5817
  if (ldv_state_variable_67 != 0) {
#line 5818
    ldv_main_exported_67();
  } else {

  }
#line 5821
  goto ldv_68677;
  case 49: ;
#line 5825
  if (ldv_state_variable_70 != 0) {
#line 5826
    ldv_main_exported_70();
  } else {

  }
#line 5829
  goto ldv_68677;
  case 50: ;
#line 5833
  if (ldv_state_variable_68 != 0) {
#line 5834
    ldv_main_exported_68();
  } else {

  }
#line 5837
  goto ldv_68677;
  case 51: ;
#line 5841
  if (ldv_state_variable_2 != 0) {
#line 5842
    invoke_work_2();
  } else {

  }
#line 5845
  goto ldv_68677;
  case 52: ;
#line 5852
  goto ldv_68677;
  case 53: ;
#line 5856
  if (ldv_state_variable_1 != 0) {
#line 5857
    invoke_work_1();
  } else {

  }
#line 5860
  goto ldv_68677;
  case 54: ;
#line 5864
  if (ldv_state_variable_88 != 0) {
#line 5865
    tmp___123 = __VERIFIER_nondet_int();
#line 5865
    switch (tmp___123) {
    case 0: ;
#line 5868
    if (ldv_state_variable_88 == 1) {
#line 5870
      qla2xxx_scan_finished(qla2xxx_driver_template_group1, ldvarg350);
#line 5872
      ldv_state_variable_88 = 1;
    } else {

    }
#line 5875
    goto ldv_68963;
    case 1: ;
#line 5878
    if (ldv_state_variable_88 == 1) {
#line 5880
      qla2xxx_slave_configure(qla2xxx_driver_template_group2);
#line 5882
      ldv_state_variable_88 = 1;
    } else {

    }
#line 5885
    goto ldv_68963;
    case 2: ;
#line 5888
    if (ldv_state_variable_88 == 1) {
#line 5890
      scsi_change_queue_depth(qla2xxx_driver_template_group2, ldvarg349);
#line 5892
      ldv_state_variable_88 = 1;
    } else {

    }
#line 5895
    goto ldv_68963;
    case 3: ;
#line 5898
    if (ldv_state_variable_88 == 1) {
#line 5900
      qla2xxx_queuecommand(qla2xxx_driver_template_group1, qla2xxx_driver_template_group0);
#line 5902
      ldv_state_variable_88 = 1;
    } else {

    }
#line 5905
    goto ldv_68963;
    case 4: ;
#line 5908
    if (ldv_state_variable_88 == 1) {
#line 5910
      qla2xxx_eh_target_reset(qla2xxx_driver_template_group0);
#line 5912
      ldv_state_variable_88 = 1;
    } else {

    }
#line 5915
    goto ldv_68963;
    case 5: ;
#line 5918
    if (ldv_state_variable_88 == 1) {
#line 5920
      qla2xxx_eh_device_reset(qla2xxx_driver_template_group0);
#line 5922
      ldv_state_variable_88 = 1;
    } else {

    }
#line 5925
    goto ldv_68963;
    case 6: ;
#line 5928
    if (ldv_state_variable_88 == 1) {
#line 5930
      qla2xxx_scan_start(qla2xxx_driver_template_group1);
#line 5932
      ldv_state_variable_88 = 1;
    } else {

    }
#line 5935
    goto ldv_68963;
    case 7: ;
#line 5938
    if (ldv_state_variable_88 == 1) {
#line 5940
      qla2xxx_eh_abort(qla2xxx_driver_template_group0);
#line 5942
      ldv_state_variable_88 = 1;
    } else {

    }
#line 5945
    goto ldv_68963;
    case 8: ;
#line 5948
    if (ldv_state_variable_88 == 1) {
#line 5950
      qla2xxx_slave_alloc(qla2xxx_driver_template_group2);
#line 5952
      ldv_state_variable_88 = 1;
    } else {

    }
#line 5955
    goto ldv_68963;
    case 9: ;
#line 5958
    if (ldv_state_variable_88 == 1) {
#line 5960
      qla2xxx_slave_destroy(qla2xxx_driver_template_group2);
#line 5962
      ldv_state_variable_88 = 1;
    } else {

    }
#line 5965
    goto ldv_68963;
    case 10: ;
#line 5968
    if (ldv_state_variable_88 == 1) {
#line 5970
      qla2xxx_eh_bus_reset(qla2xxx_driver_template_group0);
#line 5972
      ldv_state_variable_88 = 1;
    } else {

    }
#line 5975
    goto ldv_68963;
    case 11: ;
#line 5978
    if (ldv_state_variable_88 == 1) {
#line 5980
      qla2xxx_eh_host_reset(qla2xxx_driver_template_group0);
#line 5982
      ldv_state_variable_88 = 1;
    } else {

    }
#line 5985
    goto ldv_68963;
    default: 
#line 5986
    ldv_stop();
    }
    ldv_68963: ;
  } else {

  }
#line 5990
  goto ldv_68677;
  case 55: ;
#line 5997
  goto ldv_68677;
  case 56: ;
#line 6001
  if (ldv_state_variable_82 != 0) {
#line 6002
    tmp___124 = __VERIFIER_nondet_int();
#line 6002
    switch (tmp___124) {
    case 0: ;
#line 6005
    if (ldv_state_variable_82 == 1) {
#line 6007
      qla24xx_reset_adapter(qla82xx_isp_ops_group0);
#line 6009
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6012
    if (ldv_state_variable_82 == 2) {
#line 6014
      qla24xx_reset_adapter(qla82xx_isp_ops_group0);
#line 6016
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6019
    goto ldv_68979;
    case 1: ;
#line 6022
    if (ldv_state_variable_82 == 1) {
#line 6024
      qla82xx_enable_intrs(qla82xx_isp_ops_group1);
#line 6026
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6029
    if (ldv_state_variable_82 == 2) {
#line 6031
      qla82xx_enable_intrs(qla82xx_isp_ops_group1);
#line 6033
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6036
    goto ldv_68979;
    case 2: ;
#line 6039
    if (ldv_state_variable_82 == 2) {
#line 6041
      qla82xx_write_optrom_data(qla82xx_isp_ops_group0, ldvarg390, ldvarg389, ldvarg388);
#line 6043
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6046
    goto ldv_68979;
    case 3: ;
#line 6049
    if (ldv_state_variable_82 == 1) {
#line 6051
      qla82xx_intr_handler(ldvarg386, ldvarg387);
#line 6053
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6056
    if (ldv_state_variable_82 == 2) {
#line 6058
      qla82xx_intr_handler(ldvarg386, ldvarg387);
#line 6060
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6063
    goto ldv_68979;
    case 4: ;
#line 6066
    if (ldv_state_variable_82 == 1) {
#line 6068
      qla24xx_abort_target(qla82xx_isp_ops_group2, ldvarg385, ldvarg384);
#line 6070
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6073
    if (ldv_state_variable_82 == 2) {
#line 6075
      qla24xx_abort_target(qla82xx_isp_ops_group2, ldvarg385, ldvarg384);
#line 6077
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6080
    goto ldv_68979;
    case 5: ;
#line 6083
    if (ldv_state_variable_82 == 1) {
#line 6085
      qla24xx_update_fw_options(qla82xx_isp_ops_group0);
#line 6087
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6090
    if (ldv_state_variable_82 == 2) {
#line 6092
      qla24xx_update_fw_options(qla82xx_isp_ops_group0);
#line 6094
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6097
    goto ldv_68979;
    case 6: ;
#line 6100
    if (ldv_state_variable_82 == 1) {
#line 6102
      qla82xx_start_scsi(ldvarg383);
#line 6104
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6107
    if (ldv_state_variable_82 == 2) {
#line 6109
      qla82xx_start_scsi(ldvarg383);
#line 6111
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6114
    goto ldv_68979;
    case 7: ;
#line 6117
    if (ldv_state_variable_82 == 1) {
#line 6119
      qla82xx_abort_isp(qla82xx_isp_ops_group0);
#line 6121
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6124
    if (ldv_state_variable_82 == 2) {
#line 6126
      qla82xx_abort_isp(qla82xx_isp_ops_group0);
#line 6128
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6131
    goto ldv_68979;
    case 8: ;
#line 6134
    if (ldv_state_variable_82 == 1) {
#line 6136
      qla24xx_chip_diag(qla82xx_isp_ops_group0);
#line 6138
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6141
    if (ldv_state_variable_82 == 2) {
#line 6143
      qla24xx_chip_diag(qla82xx_isp_ops_group0);
#line 6145
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6148
    goto ldv_68979;
    case 9: ;
#line 6151
    if (ldv_state_variable_82 == 1) {
#line 6153
      qla24xx_fabric_logout(qla82xx_isp_ops_group0, (int )ldvarg381, (int )ldvarg380,
                            (int )ldvarg379, (int )ldvarg382);
#line 6155
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6158
    if (ldv_state_variable_82 == 2) {
#line 6160
      qla24xx_fabric_logout(qla82xx_isp_ops_group0, (int )ldvarg381, (int )ldvarg380,
                            (int )ldvarg379, (int )ldvarg382);
#line 6162
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6165
    goto ldv_68979;
    case 10: ;
#line 6168
    if (ldv_state_variable_82 == 1) {
#line 6170
      qla82xx_reset_chip(qla82xx_isp_ops_group0);
#line 6172
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6175
    if (ldv_state_variable_82 == 2) {
#line 6177
      qla82xx_reset_chip(qla82xx_isp_ops_group0);
#line 6179
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6182
    goto ldv_68979;
    case 11: ;
#line 6185
    if (ldv_state_variable_82 == 1) {
#line 6187
      qla24xx_prep_ms_iocb(qla82xx_isp_ops_group0, ldvarg378, ldvarg377);
#line 6189
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6192
    if (ldv_state_variable_82 == 2) {
#line 6194
      qla24xx_prep_ms_iocb(qla82xx_isp_ops_group0, ldvarg378, ldvarg377);
#line 6196
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6199
    goto ldv_68979;
    case 12: ;
#line 6202
    if (ldv_state_variable_82 == 1) {
#line 6204
      qla24xx_lun_reset(qla82xx_isp_ops_group2, ldvarg376, ldvarg375);
#line 6206
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6209
    if (ldv_state_variable_82 == 2) {
#line 6211
      qla24xx_lun_reset(qla82xx_isp_ops_group2, ldvarg376, ldvarg375);
#line 6213
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6216
    goto ldv_68979;
    case 13: ;
#line 6219
    if (ldv_state_variable_82 == 1) {
#line 6221
      qla24xx_fw_version_str(qla82xx_isp_ops_group0, ldvarg374, ldvarg373);
#line 6223
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6226
    if (ldv_state_variable_82 == 2) {
#line 6228
      qla24xx_fw_version_str(qla82xx_isp_ops_group0, ldvarg374, ldvarg373);
#line 6230
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6233
    goto ldv_68979;
    case 14: ;
#line 6236
    if (ldv_state_variable_82 == 1) {
#line 6238
      qla82xx_iospace_config(qla82xx_isp_ops_group1);
#line 6240
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6243
    if (ldv_state_variable_82 == 2) {
#line 6245
      qla82xx_iospace_config(qla82xx_isp_ops_group1);
#line 6247
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6250
    goto ldv_68979;
    case 15: ;
#line 6253
    if (ldv_state_variable_82 == 1) {
#line 6255
      qla2x00_initialize_adapter(qla82xx_isp_ops_group0);
#line 6257
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6260
    if (ldv_state_variable_82 == 2) {
#line 6262
      qla2x00_initialize_adapter(qla82xx_isp_ops_group0);
#line 6264
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6267
    goto ldv_68979;
    case 16: ;
#line 6270
    if (ldv_state_variable_82 == 1) {
#line 6272
      qla82xx_disable_intrs(qla82xx_isp_ops_group1);
#line 6274
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6277
    if (ldv_state_variable_82 == 2) {
#line 6279
      qla82xx_disable_intrs(qla82xx_isp_ops_group1);
#line 6281
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6284
    goto ldv_68979;
    case 17: ;
#line 6287
    if (ldv_state_variable_82 == 1) {
#line 6289
      qla82xx_get_flash_version(qla82xx_isp_ops_group0, ldvarg372);
#line 6291
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6294
    if (ldv_state_variable_82 == 2) {
#line 6296
      qla82xx_get_flash_version(qla82xx_isp_ops_group0, ldvarg372);
#line 6298
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6301
    goto ldv_68979;
    case 18: ;
#line 6304
    if (ldv_state_variable_82 == 1) {
#line 6306
      qla81xx_nvram_config(qla82xx_isp_ops_group0);
#line 6308
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6311
    if (ldv_state_variable_82 == 2) {
#line 6313
      qla81xx_nvram_config(qla82xx_isp_ops_group0);
#line 6315
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6318
    goto ldv_68979;
    case 19: ;
#line 6321
    if (ldv_state_variable_82 == 1) {
#line 6323
      qla24xx_pci_info_str(qla82xx_isp_ops_group0, ldvarg371);
#line 6325
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6328
    if (ldv_state_variable_82 == 2) {
#line 6330
      qla24xx_pci_info_str(qla82xx_isp_ops_group0, ldvarg371);
#line 6332
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6335
    goto ldv_68979;
    case 20: ;
#line 6338
    if (ldv_state_variable_82 == 2) {
#line 6340
      qla82xx_read_optrom_data(qla82xx_isp_ops_group0, ldvarg370, ldvarg369, ldvarg368);
#line 6342
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6345
    goto ldv_68979;
    case 21: ;
#line 6348
    if (ldv_state_variable_82 == 1) {
#line 6350
      qla82xx_beacon_off(qla82xx_isp_ops_group0);
#line 6352
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6355
    if (ldv_state_variable_82 == 2) {
#line 6357
      qla82xx_beacon_off(qla82xx_isp_ops_group0);
#line 6359
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6362
    goto ldv_68979;
    case 22: ;
#line 6365
    if (ldv_state_variable_82 == 1) {
#line 6367
      qla24xx_abort_command(ldvarg367);
#line 6369
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6372
    if (ldv_state_variable_82 == 2) {
#line 6374
      qla24xx_abort_command(ldvarg367);
#line 6376
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6379
    goto ldv_68979;
    case 23: ;
#line 6382
    if (ldv_state_variable_82 == 1) {
#line 6384
      qla82xx_fw_dump(qla82xx_isp_ops_group0, ldvarg366);
#line 6386
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6389
    if (ldv_state_variable_82 == 2) {
#line 6391
      qla82xx_fw_dump(qla82xx_isp_ops_group0, ldvarg366);
#line 6393
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6396
    goto ldv_68979;
    case 24: ;
#line 6399
    if (ldv_state_variable_82 == 1) {
#line 6401
      qla82xx_config_rings(qla82xx_isp_ops_group0);
#line 6403
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6406
    if (ldv_state_variable_82 == 2) {
#line 6408
      qla82xx_config_rings(qla82xx_isp_ops_group0);
#line 6410
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6413
    goto ldv_68979;
    case 25: ;
#line 6416
    if (ldv_state_variable_82 == 1) {
#line 6418
      qla82xx_load_risc(qla82xx_isp_ops_group0, ldvarg365);
#line 6420
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6423
    if (ldv_state_variable_82 == 2) {
#line 6425
      qla82xx_load_risc(qla82xx_isp_ops_group0, ldvarg365);
#line 6427
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6430
    goto ldv_68979;
    case 26: ;
#line 6433
    if (ldv_state_variable_82 == 1) {
#line 6435
      qla82xx_pci_config(qla82xx_isp_ops_group0);
#line 6437
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6440
    if (ldv_state_variable_82 == 2) {
#line 6442
      qla82xx_pci_config(qla82xx_isp_ops_group0);
#line 6444
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6447
    goto ldv_68979;
    case 27: ;
#line 6450
    if (ldv_state_variable_82 == 1) {
#line 6452
      qla24xx_login_fabric(qla82xx_isp_ops_group0, (int )ldvarg363, (int )ldvarg361,
                           (int )ldvarg360, (int )ldvarg364, ldvarg359, (int )ldvarg362);
#line 6454
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6457
    if (ldv_state_variable_82 == 2) {
#line 6459
      qla24xx_login_fabric(qla82xx_isp_ops_group0, (int )ldvarg363, (int )ldvarg361,
                           (int )ldvarg360, (int )ldvarg364, ldvarg359, (int )ldvarg362);
#line 6461
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6464
    goto ldv_68979;
    case 28: ;
#line 6467
    if (ldv_state_variable_82 == 1) {
#line 6469
      qla24xx_write_nvram_data(qla82xx_isp_ops_group0, ldvarg358, ldvarg357, ldvarg356);
#line 6471
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6474
    if (ldv_state_variable_82 == 2) {
#line 6476
      qla24xx_write_nvram_data(qla82xx_isp_ops_group0, ldvarg358, ldvarg357, ldvarg356);
#line 6478
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6481
    goto ldv_68979;
    case 29: ;
#line 6484
    if (ldv_state_variable_82 == 1) {
#line 6486
      qla82xx_beacon_on(qla82xx_isp_ops_group0);
#line 6488
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6491
    if (ldv_state_variable_82 == 2) {
#line 6493
      qla82xx_beacon_on(qla82xx_isp_ops_group0);
#line 6495
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6498
    goto ldv_68979;
    case 30: ;
#line 6501
    if (ldv_state_variable_82 == 1) {
#line 6503
      qla24xx_read_nvram_data(qla82xx_isp_ops_group0, ldvarg355, ldvarg354, ldvarg353);
#line 6505
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6508
    if (ldv_state_variable_82 == 2) {
#line 6510
      qla24xx_read_nvram_data(qla82xx_isp_ops_group0, ldvarg355, ldvarg354, ldvarg353);
#line 6512
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6515
    goto ldv_68979;
    case 31: ;
#line 6518
    if (ldv_state_variable_82 == 1) {
#line 6520
      qla24xx_prep_ms_fdmi_iocb(qla82xx_isp_ops_group0, ldvarg352, ldvarg351);
#line 6522
      ldv_state_variable_82 = 1;
    } else {

    }
#line 6525
    if (ldv_state_variable_82 == 2) {
#line 6527
      qla24xx_prep_ms_fdmi_iocb(qla82xx_isp_ops_group0, ldvarg352, ldvarg351);
#line 6529
      ldv_state_variable_82 = 2;
    } else {

    }
#line 6532
    goto ldv_68979;
    case 32: ;
#line 6535
    if (ldv_state_variable_82 == 2) {
#line 6537
      ldv_release_82();
#line 6539
      ldv_state_variable_82 = 1;
#line 6540
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 6543
    goto ldv_68979;
    case 33: ;
#line 6546
    if (ldv_state_variable_82 == 1) {
#line 6548
      ldv_probe_82();
#line 6550
      ldv_state_variable_82 = 2;
#line 6551
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 6554
    goto ldv_68979;
    default: 
#line 6555
    ldv_stop();
    }
    ldv_68979: ;
  } else {

  }
#line 6559
  goto ldv_68677;
  case 57: ;
#line 6566
  goto ldv_68677;
  case 58: ;
#line 6573
  goto ldv_68677;
  case 59: ;
#line 6577
  if (ldv_state_variable_83 != 0) {
#line 6578
    tmp___125 = __VERIFIER_nondet_int();
#line 6578
    switch (tmp___125) {
    case 0: ;
#line 6581
    if (ldv_state_variable_83 == 1) {
#line 6583
      qla24xx_reset_adapter(qla81xx_isp_ops_group0);
#line 6585
      ldv_state_variable_83 = 1;
    } else {

    }
#line 6588
    if (ldv_state_variable_83 == 2) {
#line 6590
      qla24xx_reset_adapter(qla81xx_isp_ops_group0);
#line 6592
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6595
    goto ldv_69018;
    case 1: ;
#line 6598
    if (ldv_state_variable_83 == 2) {
#line 6600
      qla24xx_write_optrom_data(qla81xx_isp_ops_group0, ldvarg424, ldvarg423, ldvarg422);
#line 6602
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6605
    goto ldv_69018;
    case 2: ;
#line 6608
    if (ldv_state_variable_83 == 1) {
#line 6610
      qla24xx_enable_intrs(qla81xx_isp_ops_group1);
#line 6612
      ldv_state_variable_83 = 1;
    } else {

    }
#line 6615
    if (ldv_state_variable_83 == 2) {
#line 6617
      qla24xx_enable_intrs(qla81xx_isp_ops_group1);
#line 6619
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6622
    goto ldv_69018;
    case 3: ;
#line 6625
    if (ldv_state_variable_83 == 1) {
#line 6627
      qla24xx_intr_handler(ldvarg420, ldvarg421);
#line 6629
      ldv_state_variable_83 = 1;
    } else {

    }
#line 6632
    if (ldv_state_variable_83 == 2) {
#line 6634
      qla24xx_intr_handler(ldvarg420, ldvarg421);
#line 6636
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6639
    goto ldv_69018;
    case 4: ;
#line 6642
    if (ldv_state_variable_83 == 1) {
#line 6644
      qla24xx_abort_target(qla81xx_isp_ops_group2, ldvarg419, ldvarg418);
#line 6646
      ldv_state_variable_83 = 1;
    } else {

    }
#line 6649
    if (ldv_state_variable_83 == 2) {
#line 6651
      qla24xx_abort_target(qla81xx_isp_ops_group2, ldvarg419, ldvarg418);
#line 6653
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6656
    goto ldv_69018;
    case 5: ;
#line 6659
    if (ldv_state_variable_83 == 1) {
#line 6661
      qla81xx_update_fw_options(qla81xx_isp_ops_group0);
#line 6663
      ldv_state_variable_83 = 1;
    } else {

    }
#line 6666
    if (ldv_state_variable_83 == 2) {
#line 6668
      qla81xx_update_fw_options(qla81xx_isp_ops_group0);
#line 6670
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6673
    goto ldv_69018;
    case 6: ;
#line 6676
    if (ldv_state_variable_83 == 1) {
#line 6678
      qla2x00_abort_isp(qla81xx_isp_ops_group0);
#line 6680
      ldv_state_variable_83 = 1;
    } else {

    }
#line 6683
    if (ldv_state_variable_83 == 2) {
#line 6685
      qla2x00_abort_isp(qla81xx_isp_ops_group0);
#line 6687
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6690
    goto ldv_69018;
    case 7: ;
#line 6693
    if (ldv_state_variable_83 == 1) {
#line 6695
      qla24xx_dif_start_scsi(ldvarg417);
#line 6697
      ldv_state_variable_83 = 1;
    } else {

    }
#line 6700
    if (ldv_state_variable_83 == 2) {
#line 6702
      qla24xx_dif_start_scsi(ldvarg417);
#line 6704
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6707
    goto ldv_69018;
    case 8: ;
#line 6710
    if (ldv_state_variable_83 == 1) {
#line 6712
      qla24xx_chip_diag(qla81xx_isp_ops_group0);
#line 6714
      ldv_state_variable_83 = 1;
    } else {

    }
#line 6717
    if (ldv_state_variable_83 == 2) {
#line 6719
      qla24xx_chip_diag(qla81xx_isp_ops_group0);
#line 6721
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6724
    goto ldv_69018;
    case 9: ;
#line 6727
    if (ldv_state_variable_83 == 1) {
#line 6729
      qla24xx_fabric_logout(qla81xx_isp_ops_group0, (int )ldvarg415, (int )ldvarg414,
                            (int )ldvarg413, (int )ldvarg416);
#line 6731
      ldv_state_variable_83 = 1;
    } else {

    }
#line 6734
    if (ldv_state_variable_83 == 2) {
#line 6736
      qla24xx_fabric_logout(qla81xx_isp_ops_group0, (int )ldvarg415, (int )ldvarg414,
                            (int )ldvarg413, (int )ldvarg416);
#line 6738
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6741
    goto ldv_69018;
    case 10: ;
#line 6744
    if (ldv_state_variable_83 == 1) {
#line 6746
      qla24xx_reset_chip(qla81xx_isp_ops_group0);
#line 6748
      ldv_state_variable_83 = 1;
    } else {

    }
#line 6751
    if (ldv_state_variable_83 == 2) {
#line 6753
      qla24xx_reset_chip(qla81xx_isp_ops_group0);
#line 6755
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6758
    goto ldv_69018;
    case 11: ;
#line 6761
    if (ldv_state_variable_83 == 1) {
#line 6763
      qla24xx_prep_ms_iocb(qla81xx_isp_ops_group0, ldvarg412, ldvarg411);
#line 6765
      ldv_state_variable_83 = 1;
    } else {

    }
#line 6768
    if (ldv_state_variable_83 == 2) {
#line 6770
      qla24xx_prep_ms_iocb(qla81xx_isp_ops_group0, ldvarg412, ldvarg411);
#line 6772
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6775
    goto ldv_69018;
    case 12: ;
#line 6778
    if (ldv_state_variable_83 == 1) {
#line 6780
      qla24xx_lun_reset(qla81xx_isp_ops_group2, ldvarg410, ldvarg409);
#line 6782
      ldv_state_variable_83 = 1;
    } else {

    }
#line 6785
    if (ldv_state_variable_83 == 2) {
#line 6787
      qla24xx_lun_reset(qla81xx_isp_ops_group2, ldvarg410, ldvarg409);
#line 6789
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6792
    goto ldv_69018;
    case 13: ;
#line 6795
    if (ldv_state_variable_83 == 1) {
#line 6797
      qla24xx_fw_version_str(qla81xx_isp_ops_group0, ldvarg408, ldvarg407);
#line 6799
      ldv_state_variable_83 = 1;
    } else {

    }
#line 6802
    if (ldv_state_variable_83 == 2) {
#line 6804
      qla24xx_fw_version_str(qla81xx_isp_ops_group0, ldvarg408, ldvarg407);
#line 6806
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6809
    goto ldv_69018;
    case 14: ;
#line 6812
    if (ldv_state_variable_83 == 1) {
#line 6814
      qla2x00_iospace_config(qla81xx_isp_ops_group1);
#line 6816
      ldv_state_variable_83 = 1;
    } else {

    }
#line 6819
    if (ldv_state_variable_83 == 2) {
#line 6821
      qla2x00_iospace_config(qla81xx_isp_ops_group1);
#line 6823
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6826
    goto ldv_69018;
    case 15: ;
#line 6829
    if (ldv_state_variable_83 == 1) {
#line 6831
      qla2x00_initialize_adapter(qla81xx_isp_ops_group0);
#line 6833
      ldv_state_variable_83 = 1;
    } else {

    }
#line 6836
    if (ldv_state_variable_83 == 2) {
#line 6838
      qla2x00_initialize_adapter(qla81xx_isp_ops_group0);
#line 6840
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6843
    goto ldv_69018;
    case 16: ;
#line 6846
    if (ldv_state_variable_83 == 1) {
#line 6848
      qla24xx_get_flash_version(qla81xx_isp_ops_group0, ldvarg406);
#line 6850
      ldv_state_variable_83 = 1;
    } else {

    }
#line 6853
    if (ldv_state_variable_83 == 2) {
#line 6855
      qla24xx_get_flash_version(qla81xx_isp_ops_group0, ldvarg406);
#line 6857
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6860
    goto ldv_69018;
    case 17: ;
#line 6863
    if (ldv_state_variable_83 == 1) {
#line 6865
      qla24xx_disable_intrs(qla81xx_isp_ops_group1);
#line 6867
      ldv_state_variable_83 = 1;
    } else {

    }
#line 6870
    if (ldv_state_variable_83 == 2) {
#line 6872
      qla24xx_disable_intrs(qla81xx_isp_ops_group1);
#line 6874
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6877
    goto ldv_69018;
    case 18: ;
#line 6880
    if (ldv_state_variable_83 == 1) {
#line 6882
      qla81xx_nvram_config(qla81xx_isp_ops_group0);
#line 6884
      ldv_state_variable_83 = 1;
    } else {

    }
#line 6887
    if (ldv_state_variable_83 == 2) {
#line 6889
      qla81xx_nvram_config(qla81xx_isp_ops_group0);
#line 6891
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6894
    goto ldv_69018;
    case 19: ;
#line 6897
    if (ldv_state_variable_83 == 1) {
#line 6899
      qla24xx_pci_info_str(qla81xx_isp_ops_group0, ldvarg405);
#line 6901
      ldv_state_variable_83 = 1;
    } else {

    }
#line 6904
    if (ldv_state_variable_83 == 2) {
#line 6906
      qla24xx_pci_info_str(qla81xx_isp_ops_group0, ldvarg405);
#line 6908
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6911
    goto ldv_69018;
    case 20: ;
#line 6914
    if (ldv_state_variable_83 == 2) {
#line 6916
      qla25xx_read_optrom_data(qla81xx_isp_ops_group0, ldvarg404, ldvarg403, ldvarg402);
#line 6918
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6921
    goto ldv_69018;
    case 21: ;
#line 6924
    if (ldv_state_variable_83 == 1) {
#line 6926
      qla83xx_beacon_blink(qla81xx_isp_ops_group0);
#line 6928
      ldv_state_variable_83 = 1;
    } else {

    }
#line 6931
    if (ldv_state_variable_83 == 2) {
#line 6933
      qla83xx_beacon_blink(qla81xx_isp_ops_group0);
#line 6935
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6938
    goto ldv_69018;
    case 22: ;
#line 6941
    if (ldv_state_variable_83 == 1) {
#line 6943
      qla24xx_beacon_off(qla81xx_isp_ops_group0);
#line 6945
      ldv_state_variable_83 = 1;
    } else {

    }
#line 6948
    if (ldv_state_variable_83 == 2) {
#line 6950
      qla24xx_beacon_off(qla81xx_isp_ops_group0);
#line 6952
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6955
    goto ldv_69018;
    case 23: ;
#line 6958
    if (ldv_state_variable_83 == 1) {
#line 6960
      qla24xx_abort_command(ldvarg401);
#line 6962
      ldv_state_variable_83 = 1;
    } else {

    }
#line 6965
    if (ldv_state_variable_83 == 2) {
#line 6967
      qla24xx_abort_command(ldvarg401);
#line 6969
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6972
    goto ldv_69018;
    case 24: ;
#line 6975
    if (ldv_state_variable_83 == 1) {
#line 6977
      qla81xx_fw_dump(qla81xx_isp_ops_group0, ldvarg400);
#line 6979
      ldv_state_variable_83 = 1;
    } else {

    }
#line 6982
    if (ldv_state_variable_83 == 2) {
#line 6984
      qla81xx_fw_dump(qla81xx_isp_ops_group0, ldvarg400);
#line 6986
      ldv_state_variable_83 = 2;
    } else {

    }
#line 6989
    goto ldv_69018;
    case 25: ;
#line 6992
    if (ldv_state_variable_83 == 1) {
#line 6994
      qla24xx_config_rings(qla81xx_isp_ops_group0);
#line 6996
      ldv_state_variable_83 = 1;
    } else {

    }
#line 6999
    if (ldv_state_variable_83 == 2) {
#line 7001
      qla24xx_config_rings(qla81xx_isp_ops_group0);
#line 7003
      ldv_state_variable_83 = 2;
    } else {

    }
#line 7006
    goto ldv_69018;
    case 26: ;
#line 7009
    if (ldv_state_variable_83 == 1) {
#line 7011
      qla81xx_load_risc(qla81xx_isp_ops_group0, ldvarg399);
#line 7013
      ldv_state_variable_83 = 1;
    } else {

    }
#line 7016
    if (ldv_state_variable_83 == 2) {
#line 7018
      qla81xx_load_risc(qla81xx_isp_ops_group0, ldvarg399);
#line 7020
      ldv_state_variable_83 = 2;
    } else {

    }
#line 7023
    goto ldv_69018;
    case 27: ;
#line 7026
    if (ldv_state_variable_83 == 1) {
#line 7028
      qla25xx_pci_config(qla81xx_isp_ops_group0);
#line 7030
      ldv_state_variable_83 = 1;
    } else {

    }
#line 7033
    if (ldv_state_variable_83 == 2) {
#line 7035
      qla25xx_pci_config(qla81xx_isp_ops_group0);
#line 7037
      ldv_state_variable_83 = 2;
    } else {

    }
#line 7040
    goto ldv_69018;
    case 28: ;
#line 7043
    if (ldv_state_variable_83 == 1) {
#line 7045
      qla24xx_login_fabric(qla81xx_isp_ops_group0, (int )ldvarg397, (int )ldvarg395,
                           (int )ldvarg394, (int )ldvarg398, ldvarg393, (int )ldvarg396);
#line 7047
      ldv_state_variable_83 = 1;
    } else {

    }
#line 7050
    if (ldv_state_variable_83 == 2) {
#line 7052
      qla24xx_login_fabric(qla81xx_isp_ops_group0, (int )ldvarg397, (int )ldvarg395,
                           (int )ldvarg394, (int )ldvarg398, ldvarg393, (int )ldvarg396);
#line 7054
      ldv_state_variable_83 = 2;
    } else {

    }
#line 7057
    goto ldv_69018;
    case 29: ;
#line 7060
    if (ldv_state_variable_83 == 1) {
#line 7062
      qla24xx_beacon_on(qla81xx_isp_ops_group0);
#line 7064
      ldv_state_variable_83 = 1;
    } else {

    }
#line 7067
    if (ldv_state_variable_83 == 2) {
#line 7069
      qla24xx_beacon_on(qla81xx_isp_ops_group0);
#line 7071
      ldv_state_variable_83 = 2;
    } else {

    }
#line 7074
    goto ldv_69018;
    case 30: ;
#line 7077
    if (ldv_state_variable_83 == 1) {
#line 7079
      qla24xx_prep_ms_fdmi_iocb(qla81xx_isp_ops_group0, ldvarg392, ldvarg391);
#line 7081
      ldv_state_variable_83 = 1;
    } else {

    }
#line 7084
    if (ldv_state_variable_83 == 2) {
#line 7086
      qla24xx_prep_ms_fdmi_iocb(qla81xx_isp_ops_group0, ldvarg392, ldvarg391);
#line 7088
      ldv_state_variable_83 = 2;
    } else {

    }
#line 7091
    goto ldv_69018;
    case 31: ;
#line 7094
    if (ldv_state_variable_83 == 2) {
#line 7096
      ldv_release_83();
#line 7098
      ldv_state_variable_83 = 1;
#line 7099
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 7102
    goto ldv_69018;
    case 32: ;
#line 7105
    if (ldv_state_variable_83 == 1) {
#line 7107
      ldv_probe_83();
#line 7109
      ldv_state_variable_83 = 2;
#line 7110
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 7113
    goto ldv_69018;
    default: 
#line 7114
    ldv_stop();
    }
    ldv_69018: ;
  } else {

  }
#line 7118
  goto ldv_68677;
  case 60: ;
#line 7122
  if (ldv_state_variable_75 != 0) {
#line 7123
    tmp___126 = __VERIFIER_nondet_int();
#line 7123
    switch (tmp___126) {
    case 0: ;
#line 7126
    if (ldv_state_variable_75 == 2) {
#line 7128
      noop_llseek(apidev_fops_group2, ldvarg426, ldvarg425);
#line 7130
      ldv_state_variable_75 = 2;
    } else {

    }
#line 7133
    goto ldv_69054;
    case 1: ;
#line 7136
    if (ldv_state_variable_75 == 1) {
#line 7138
      ldv_retval_2 = ldv_open_75();
#line 7139
      if (ldv_retval_2 == 0) {
#line 7140
        ldv_state_variable_75 = 2;
#line 7141
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 7145
    goto ldv_69054;
    case 2: ;
#line 7148
    if (ldv_state_variable_75 == 2) {
#line 7150
      ldv_release_75();
#line 7151
      ldv_state_variable_75 = 1;
#line 7152
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 7155
    goto ldv_69054;
    default: 
#line 7156
    ldv_stop();
    }
    ldv_69054: ;
  } else {

  }
#line 7160
  goto ldv_68677;
  case 61: ;
#line 7164
  if (ldv_state_variable_40 != 0) {
#line 7165
    ldv_main_exported_40();
  } else {

  }
#line 7168
  goto ldv_68677;
  case 62: ;
#line 7172
  if (ldv_state_variable_14 != 0) {
#line 7173
    choose_timer_14(ldv_timer_list_14);
  } else {

  }
#line 7176
  goto ldv_68677;
  case 63: ;
#line 7180
  if (ldv_state_variable_69 != 0) {
#line 7181
    ldv_main_exported_69();
  } else {

  }
#line 7184
  goto ldv_68677;
  case 64: ;
#line 7188
  if (ldv_state_variable_59 != 0) {
#line 7189
    ldv_main_exported_59();
  } else {

  }
#line 7192
  goto ldv_68677;
  case 65: ;
#line 7196
  if (ldv_state_variable_49 != 0) {
#line 7197
    ldv_main_exported_49();
  } else {

  }
#line 7200
  goto ldv_68677;
  case 66: ;
#line 7207
  goto ldv_68677;
  case 67: ;
#line 7211
  if (ldv_state_variable_53 != 0) {
#line 7212
    ldv_main_exported_53();
  } else {

  }
#line 7215
  goto ldv_68677;
  case 68: ;
#line 7219
  if (ldv_state_variable_79 != 0) {
#line 7220
    tmp___127 = __VERIFIER_nondet_int();
#line 7220
    switch (tmp___127) {
    case 0: ;
#line 7223
    if (ldv_state_variable_79 == 1) {
#line 7225
      qlafx00_soft_reset(qlafx00_isp_ops_group0);
#line 7227
      ldv_state_variable_79 = 1;
    } else {

    }
#line 7230
    if (ldv_state_variable_79 == 2) {
#line 7232
      qlafx00_soft_reset(qlafx00_isp_ops_group0);
#line 7234
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7237
    goto ldv_69067;
    case 1: ;
#line 7240
    if (ldv_state_variable_79 == 2) {
#line 7242
      qla24xx_write_optrom_data(qlafx00_isp_ops_group0, ldvarg472, ldvarg471, ldvarg470);
#line 7244
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7247
    goto ldv_69067;
    case 2: ;
#line 7250
    if (ldv_state_variable_79 == 1) {
#line 7252
      qlafx00_enable_intrs(qlafx00_isp_ops_group1);
#line 7254
      ldv_state_variable_79 = 1;
    } else {

    }
#line 7257
    if (ldv_state_variable_79 == 2) {
#line 7259
      qlafx00_enable_intrs(qlafx00_isp_ops_group1);
#line 7261
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7264
    goto ldv_69067;
    case 3: ;
#line 7267
    if (ldv_state_variable_79 == 1) {
#line 7269
      qlafx00_intr_handler(ldvarg468, ldvarg469);
#line 7271
      ldv_state_variable_79 = 1;
    } else {

    }
#line 7274
    if (ldv_state_variable_79 == 2) {
#line 7276
      qlafx00_intr_handler(ldvarg468, ldvarg469);
#line 7278
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7281
    goto ldv_69067;
    case 4: ;
#line 7284
    if (ldv_state_variable_79 == 1) {
#line 7286
      qlafx00_abort_target(qlafx00_isp_ops_group2, ldvarg467, ldvarg466);
#line 7288
      ldv_state_variable_79 = 1;
    } else {

    }
#line 7291
    if (ldv_state_variable_79 == 2) {
#line 7293
      qlafx00_abort_target(qlafx00_isp_ops_group2, ldvarg467, ldvarg466);
#line 7295
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7298
    goto ldv_69067;
    case 5: ;
#line 7301
    if (ldv_state_variable_79 == 1) {
#line 7303
      qlafx00_abort_isp(qlafx00_isp_ops_group0);
#line 7305
      ldv_state_variable_79 = 1;
    } else {

    }
#line 7308
    if (ldv_state_variable_79 == 2) {
#line 7310
      qlafx00_abort_isp(qlafx00_isp_ops_group0);
#line 7312
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7315
    goto ldv_69067;
    case 6: ;
#line 7318
    if (ldv_state_variable_79 == 1) {
#line 7320
      qlafx00_start_scsi(ldvarg465);
#line 7322
      ldv_state_variable_79 = 1;
    } else {

    }
#line 7325
    if (ldv_state_variable_79 == 2) {
#line 7327
      qlafx00_start_scsi(ldvarg465);
#line 7329
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7332
    goto ldv_69067;
    case 7: ;
#line 7335
    if (ldv_state_variable_79 == 1) {
#line 7337
      qlafx00_chip_diag(qlafx00_isp_ops_group0);
#line 7339
      ldv_state_variable_79 = 1;
    } else {

    }
#line 7342
    if (ldv_state_variable_79 == 2) {
#line 7344
      qlafx00_chip_diag(qlafx00_isp_ops_group0);
#line 7346
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7349
    goto ldv_69067;
    case 8: ;
#line 7352
    if (ldv_state_variable_79 == 1) {
#line 7354
      qlafx00_soft_reset(qlafx00_isp_ops_group0);
#line 7356
      ldv_state_variable_79 = 1;
    } else {

    }
#line 7359
    if (ldv_state_variable_79 == 2) {
#line 7361
      qlafx00_soft_reset(qlafx00_isp_ops_group0);
#line 7363
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7366
    goto ldv_69067;
    case 9: ;
#line 7369
    if (ldv_state_variable_79 == 1) {
#line 7371
      qla24xx_prep_ms_iocb(qlafx00_isp_ops_group0, ldvarg464, ldvarg463);
#line 7373
      ldv_state_variable_79 = 1;
    } else {

    }
#line 7376
    if (ldv_state_variable_79 == 2) {
#line 7378
      qla24xx_prep_ms_iocb(qlafx00_isp_ops_group0, ldvarg464, ldvarg463);
#line 7380
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7383
    goto ldv_69067;
    case 10: ;
#line 7386
    if (ldv_state_variable_79 == 1) {
#line 7388
      qlafx00_lun_reset(qlafx00_isp_ops_group2, ldvarg462, ldvarg461);
#line 7390
      ldv_state_variable_79 = 1;
    } else {

    }
#line 7393
    if (ldv_state_variable_79 == 2) {
#line 7395
      qlafx00_lun_reset(qlafx00_isp_ops_group2, ldvarg462, ldvarg461);
#line 7397
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7400
    goto ldv_69067;
    case 11: ;
#line 7403
    if (ldv_state_variable_79 == 1) {
#line 7405
      qlafx00_fw_version_str(qlafx00_isp_ops_group0, ldvarg460, ldvarg459);
#line 7407
      ldv_state_variable_79 = 1;
    } else {

    }
#line 7410
    if (ldv_state_variable_79 == 2) {
#line 7412
      qlafx00_fw_version_str(qlafx00_isp_ops_group0, ldvarg460, ldvarg459);
#line 7414
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7417
    goto ldv_69067;
    case 12: ;
#line 7420
    if (ldv_state_variable_79 == 1) {
#line 7422
      qlafx00_iospace_config(qlafx00_isp_ops_group1);
#line 7424
      ldv_state_variable_79 = 1;
    } else {

    }
#line 7427
    if (ldv_state_variable_79 == 2) {
#line 7429
      qlafx00_iospace_config(qlafx00_isp_ops_group1);
#line 7431
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7434
    goto ldv_69067;
    case 13: ;
#line 7437
    if (ldv_state_variable_79 == 1) {
#line 7439
      qlafx00_initialize_adapter(qlafx00_isp_ops_group0);
#line 7441
      ldv_state_variable_79 = 1;
    } else {

    }
#line 7444
    if (ldv_state_variable_79 == 2) {
#line 7446
      qlafx00_initialize_adapter(qlafx00_isp_ops_group0);
#line 7448
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7451
    goto ldv_69067;
    case 14: ;
#line 7454
    if (ldv_state_variable_79 == 1) {
#line 7456
      qla24xx_get_flash_version(qlafx00_isp_ops_group0, ldvarg458);
#line 7458
      ldv_state_variable_79 = 1;
    } else {

    }
#line 7461
    if (ldv_state_variable_79 == 2) {
#line 7463
      qla24xx_get_flash_version(qlafx00_isp_ops_group0, ldvarg458);
#line 7465
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7468
    goto ldv_69067;
    case 15: ;
#line 7471
    if (ldv_state_variable_79 == 1) {
#line 7473
      qlafx00_disable_intrs(qlafx00_isp_ops_group1);
#line 7475
      ldv_state_variable_79 = 1;
    } else {

    }
#line 7478
    if (ldv_state_variable_79 == 2) {
#line 7480
      qlafx00_disable_intrs(qlafx00_isp_ops_group1);
#line 7482
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7485
    goto ldv_69067;
    case 16: ;
#line 7488
    if (ldv_state_variable_79 == 1) {
#line 7490
      qlafx00_pci_info_str(qlafx00_isp_ops_group0, ldvarg457);
#line 7492
      ldv_state_variable_79 = 1;
    } else {

    }
#line 7495
    if (ldv_state_variable_79 == 2) {
#line 7497
      qlafx00_pci_info_str(qlafx00_isp_ops_group0, ldvarg457);
#line 7499
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7502
    goto ldv_69067;
    case 17: ;
#line 7505
    if (ldv_state_variable_79 == 2) {
#line 7507
      qla24xx_read_optrom_data(qlafx00_isp_ops_group0, ldvarg456, ldvarg455, ldvarg454);
#line 7509
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7512
    goto ldv_69067;
    case 18: ;
#line 7515
    if (ldv_state_variable_79 == 1) {
#line 7517
      qla24xx_beacon_off(qlafx00_isp_ops_group0);
#line 7519
      ldv_state_variable_79 = 1;
    } else {

    }
#line 7522
    if (ldv_state_variable_79 == 2) {
#line 7524
      qla24xx_beacon_off(qlafx00_isp_ops_group0);
#line 7526
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7529
    goto ldv_69067;
    case 19: ;
#line 7532
    if (ldv_state_variable_79 == 1) {
#line 7534
      qla24xx_async_abort_command(ldvarg453);
#line 7536
      ldv_state_variable_79 = 1;
    } else {

    }
#line 7539
    if (ldv_state_variable_79 == 2) {
#line 7541
      qla24xx_async_abort_command(ldvarg453);
#line 7543
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7546
    goto ldv_69067;
    case 20: ;
#line 7549
    if (ldv_state_variable_79 == 1) {
#line 7551
      qlafx00_config_rings(qlafx00_isp_ops_group0);
#line 7553
      ldv_state_variable_79 = 1;
    } else {

    }
#line 7556
    if (ldv_state_variable_79 == 2) {
#line 7558
      qlafx00_config_rings(qlafx00_isp_ops_group0);
#line 7560
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7563
    goto ldv_69067;
    case 21: ;
#line 7566
    if (ldv_state_variable_79 == 1) {
#line 7568
      qlafx00_pci_config(qlafx00_isp_ops_group0);
#line 7570
      ldv_state_variable_79 = 1;
    } else {

    }
#line 7573
    if (ldv_state_variable_79 == 2) {
#line 7575
      qlafx00_pci_config(qlafx00_isp_ops_group0);
#line 7577
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7580
    goto ldv_69067;
    case 22: ;
#line 7583
    if (ldv_state_variable_79 == 1) {
#line 7585
      qla24xx_write_nvram_data(qlafx00_isp_ops_group0, ldvarg452, ldvarg451, ldvarg450);
#line 7587
      ldv_state_variable_79 = 1;
    } else {

    }
#line 7590
    if (ldv_state_variable_79 == 2) {
#line 7592
      qla24xx_write_nvram_data(qlafx00_isp_ops_group0, ldvarg452, ldvarg451, ldvarg450);
#line 7594
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7597
    goto ldv_69067;
    case 23: ;
#line 7600
    if (ldv_state_variable_79 == 1) {
#line 7602
      qla24xx_beacon_on(qlafx00_isp_ops_group0);
#line 7604
      ldv_state_variable_79 = 1;
    } else {

    }
#line 7607
    if (ldv_state_variable_79 == 2) {
#line 7609
      qla24xx_beacon_on(qlafx00_isp_ops_group0);
#line 7611
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7614
    goto ldv_69067;
    case 24: ;
#line 7617
    if (ldv_state_variable_79 == 1) {
#line 7619
      qla24xx_read_nvram_data(qlafx00_isp_ops_group0, ldvarg449, ldvarg448, ldvarg447);
#line 7621
      ldv_state_variable_79 = 1;
    } else {

    }
#line 7624
    if (ldv_state_variable_79 == 2) {
#line 7626
      qla24xx_read_nvram_data(qlafx00_isp_ops_group0, ldvarg449, ldvarg448, ldvarg447);
#line 7628
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7631
    goto ldv_69067;
    case 25: ;
#line 7634
    if (ldv_state_variable_79 == 1) {
#line 7636
      qla24xx_prep_ms_fdmi_iocb(qlafx00_isp_ops_group0, ldvarg446, ldvarg445);
#line 7638
      ldv_state_variable_79 = 1;
    } else {

    }
#line 7641
    if (ldv_state_variable_79 == 2) {
#line 7643
      qla24xx_prep_ms_fdmi_iocb(qlafx00_isp_ops_group0, ldvarg446, ldvarg445);
#line 7645
      ldv_state_variable_79 = 2;
    } else {

    }
#line 7648
    goto ldv_69067;
    case 26: ;
#line 7651
    if (ldv_state_variable_79 == 2) {
#line 7653
      ldv_release_79();
#line 7655
      ldv_state_variable_79 = 1;
#line 7656
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 7659
    goto ldv_69067;
    case 27: ;
#line 7662
    if (ldv_state_variable_79 == 1) {
#line 7664
      ldv_probe_79();
#line 7666
      ldv_state_variable_79 = 2;
#line 7667
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 7670
    goto ldv_69067;
    default: 
#line 7671
    ldv_stop();
    }
    ldv_69067: ;
  } else {

  }
#line 7675
  goto ldv_68677;
  case 69: ;
#line 7682
  goto ldv_68677;
  case 70: ;
#line 7686
  if (ldv_state_variable_42 != 0) {
#line 7687
    ldv_main_exported_42();
  } else {

  }
#line 7690
  goto ldv_68677;
  case 71: ;
#line 7694
  if (ldv_state_variable_0 != 0) {
#line 7695
    tmp___128 = __VERIFIER_nondet_int();
#line 7695
    switch (tmp___128) {
    case 0: ;
#line 7698
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
#line 7700
      qla2x00_module_exit();
#line 7701
      ldv_state_variable_0 = 2;
#line 7702
      goto ldv_final;
    } else {

    }
#line 7705
    goto ldv_69101;
    case 1: ;
#line 7708
    if (ldv_state_variable_0 == 1) {
#line 7710
      ldv_retval_3 = qla2x00_module_init();
#line 7712
      if (ldv_retval_3 == 0) {
#line 7713
        ldv_state_variable_0 = 3;
#line 7714
        ldv_state_variable_54 = 1;
#line 7715
        ldv_initialize_device_attribute_54();
#line 7716
        ldv_state_variable_62 = 1;
#line 7717
        ldv_state_variable_43 = 1;
#line 7718
        ldv_state_variable_86 = 1;
#line 7719
        ldv_initialize_isp_operations_86();
#line 7720
        ldv_state_variable_37 = 1;
#line 7721
        ldv_state_variable_45 = 1;
#line 7722
        ldv_state_variable_66 = 1;
#line 7723
        ldv_state_variable_73 = 1;
#line 7724
        ldv_initialize_bin_attribute_73();
#line 7725
        ldv_state_variable_56 = 1;
#line 7726
        ldv_state_variable_34 = 1;
#line 7727
        ldv_initialize_device_attribute_34();
#line 7728
        ldv_state_variable_60 = 1;
#line 7729
        ldv_state_variable_52 = 1;
#line 7730
        ldv_state_variable_38 = 1;
#line 7731
        ldv_state_variable_81 = 1;
#line 7732
        ldv_initialize_isp_operations_81();
#line 7733
        ldv_state_variable_47 = 1;
#line 7734
        ldv_state_variable_58 = 1;
#line 7735
        ldv_state_variable_41 = 1;
#line 7736
        ldv_state_variable_51 = 1;
#line 7737
        ldv_state_variable_36 = 1;
#line 7738
        ldv_state_variable_64 = 1;
#line 7739
        ldv_state_variable_39 = 1;
#line 7740
        ldv_state_variable_85 = 1;
#line 7741
        ldv_initialize_isp_operations_85();
#line 7742
        ldv_state_variable_50 = 1;
#line 7743
        ldv_state_variable_65 = 1;
#line 7744
        ldv_state_variable_46 = 1;
#line 7745
        ldv_state_variable_77 = 1;
#line 7746
        ldv_initialize_pci_error_handlers_77();
#line 7747
        ldv_state_variable_87 = 1;
#line 7748
        ldv_initialize_isp_operations_87();
#line 7749
        ldv_state_variable_42 = 1;
#line 7750
        ldv_state_variable_48 = 1;
#line 7751
        ldv_state_variable_79 = 1;
#line 7752
        ldv_initialize_isp_operations_79();
#line 7753
        ldv_state_variable_78 = 1;
#line 7754
        ldv_initialize_isp_operations_78();
#line 7755
        ldv_state_variable_53 = 1;
#line 7756
        ldv_initialize_device_attribute_53();
#line 7757
        ldv_state_variable_35 = 1;
#line 7758
        ldv_state_variable_49 = 1;
#line 7759
        ldv_state_variable_59 = 1;
#line 7760
        ldv_state_variable_69 = 1;
#line 7761
        ldv_initialize_bin_attribute_69();
#line 7762
        ldv_state_variable_61 = 1;
#line 7763
        ldv_state_variable_40 = 1;
#line 7764
        ldv_state_variable_57 = 1;
#line 7765
        ldv_state_variable_83 = 1;
#line 7766
        ldv_initialize_isp_operations_83();
#line 7767
        ldv_state_variable_74 = 1;
#line 7768
        ldv_initialize_bin_attribute_74();
#line 7769
        ldv_state_variable_84 = 1;
#line 7770
        ldv_initialize_isp_operations_84();
#line 7771
        ldv_state_variable_55 = 1;
#line 7772
        ldv_initialize_device_attribute_55();
#line 7773
        ldv_state_variable_82 = 1;
#line 7774
        ldv_initialize_isp_operations_82();
#line 7775
        ldv_state_variable_44 = 1;
#line 7776
        ldv_state_variable_72 = 1;
#line 7777
        ldv_initialize_bin_attribute_72();
#line 7778
        ldv_state_variable_68 = 1;
#line 7779
        ldv_state_variable_80 = 1;
#line 7780
        ldv_initialize_isp_operations_80();
#line 7781
        ldv_state_variable_70 = 1;
#line 7782
        ldv_state_variable_71 = 1;
#line 7783
        ldv_initialize_bin_attribute_71();
#line 7784
        ldv_state_variable_63 = 1;
#line 7785
        ldv_state_variable_32 = 1;
#line 7786
        ldv_initialize_fc_function_template_32();
#line 7787
        ldv_state_variable_33 = 1;
#line 7788
        ldv_initialize_fc_function_template_33();
#line 7789
        ldv_state_variable_67 = 1;
      } else {

      }
#line 7791
      if (ldv_retval_3 != 0) {
#line 7792
        ldv_state_variable_0 = 2;
#line 7793
        goto ldv_final;
      } else {

      }
    } else {

    }
#line 7797
    goto ldv_69101;
    default: 
#line 7798
    ldv_stop();
    }
    ldv_69101: ;
  } else {

  }
#line 7802
  goto ldv_68677;
  case 72: ;
#line 7806
  if (ldv_state_variable_46 != 0) {
#line 7807
    ldv_main_exported_46();
  } else {

  }
#line 7810
  goto ldv_68677;
  case 73: ;
#line 7817
  goto ldv_68677;
  case 74: ;
#line 7821
  if (ldv_state_variable_13 != 0) {
#line 7822
    choose_timer_13(ldv_timer_list_13);
  } else {

  }
#line 7825
  goto ldv_68677;
  case 75: ;
#line 7832
  goto ldv_68677;
  case 76: ;
#line 7836
  if (ldv_state_variable_85 != 0) {
#line 7837
    tmp___129 = __VERIFIER_nondet_int();
#line 7837
    switch (tmp___129) {
    case 0: ;
#line 7840
    if (ldv_state_variable_85 == 1) {
#line 7842
      qla24xx_reset_adapter(qla24xx_isp_ops_group0);
#line 7844
      ldv_state_variable_85 = 1;
    } else {

    }
#line 7847
    if (ldv_state_variable_85 == 2) {
#line 7849
      qla24xx_reset_adapter(qla24xx_isp_ops_group0);
#line 7851
      ldv_state_variable_85 = 2;
    } else {

    }
#line 7854
    goto ldv_69110;
    case 1: ;
#line 7857
    if (ldv_state_variable_85 == 1) {
#line 7859
      qla24xx_enable_intrs(qla24xx_isp_ops_group1);
#line 7861
      ldv_state_variable_85 = 1;
    } else {

    }
#line 7864
    if (ldv_state_variable_85 == 2) {
#line 7866
      qla24xx_enable_intrs(qla24xx_isp_ops_group1);
#line 7868
      ldv_state_variable_85 = 2;
    } else {

    }
#line 7871
    goto ldv_69110;
    case 2: ;
#line 7874
    if (ldv_state_variable_85 == 2) {
#line 7876
      qla24xx_write_optrom_data(qla24xx_isp_ops_group0, ldvarg518, ldvarg517, ldvarg516);
#line 7878
      ldv_state_variable_85 = 2;
    } else {

    }
#line 7881
    goto ldv_69110;
    case 3: ;
#line 7884
    if (ldv_state_variable_85 == 1) {
#line 7886
      qla24xx_intr_handler(ldvarg514, ldvarg515);
#line 7888
      ldv_state_variable_85 = 1;
    } else {

    }
#line 7891
    if (ldv_state_variable_85 == 2) {
#line 7893
      qla24xx_intr_handler(ldvarg514, ldvarg515);
#line 7895
      ldv_state_variable_85 = 2;
    } else {

    }
#line 7898
    goto ldv_69110;
    case 4: ;
#line 7901
    if (ldv_state_variable_85 == 1) {
#line 7903
      qla24xx_abort_target(qla24xx_isp_ops_group2, ldvarg513, ldvarg512);
#line 7905
      ldv_state_variable_85 = 1;
    } else {

    }
#line 7908
    if (ldv_state_variable_85 == 2) {
#line 7910
      qla24xx_abort_target(qla24xx_isp_ops_group2, ldvarg513, ldvarg512);
#line 7912
      ldv_state_variable_85 = 2;
    } else {

    }
#line 7915
    goto ldv_69110;
    case 5: ;
#line 7918
    if (ldv_state_variable_85 == 1) {
#line 7920
      qla24xx_update_fw_options(qla24xx_isp_ops_group0);
#line 7922
      ldv_state_variable_85 = 1;
    } else {

    }
#line 7925
    if (ldv_state_variable_85 == 2) {
#line 7927
      qla24xx_update_fw_options(qla24xx_isp_ops_group0);
#line 7929
      ldv_state_variable_85 = 2;
    } else {

    }
#line 7932
    goto ldv_69110;
    case 6: ;
#line 7935
    if (ldv_state_variable_85 == 1) {
#line 7937
      qla24xx_start_scsi(ldvarg511);
#line 7939
      ldv_state_variable_85 = 1;
    } else {

    }
#line 7942
    if (ldv_state_variable_85 == 2) {
#line 7944
      qla24xx_start_scsi(ldvarg511);
#line 7946
      ldv_state_variable_85 = 2;
    } else {

    }
#line 7949
    goto ldv_69110;
    case 7: ;
#line 7952
    if (ldv_state_variable_85 == 1) {
#line 7954
      qla2x00_abort_isp(qla24xx_isp_ops_group0);
#line 7956
      ldv_state_variable_85 = 1;
    } else {

    }
#line 7959
    if (ldv_state_variable_85 == 2) {
#line 7961
      qla2x00_abort_isp(qla24xx_isp_ops_group0);
#line 7963
      ldv_state_variable_85 = 2;
    } else {

    }
#line 7966
    goto ldv_69110;
    case 8: ;
#line 7969
    if (ldv_state_variable_85 == 1) {
#line 7971
      qla24xx_chip_diag(qla24xx_isp_ops_group0);
#line 7973
      ldv_state_variable_85 = 1;
    } else {

    }
#line 7976
    if (ldv_state_variable_85 == 2) {
#line 7978
      qla24xx_chip_diag(qla24xx_isp_ops_group0);
#line 7980
      ldv_state_variable_85 = 2;
    } else {

    }
#line 7983
    goto ldv_69110;
    case 9: ;
#line 7986
    if (ldv_state_variable_85 == 1) {
#line 7988
      qla24xx_fabric_logout(qla24xx_isp_ops_group0, (int )ldvarg509, (int )ldvarg508,
                            (int )ldvarg507, (int )ldvarg510);
#line 7990
      ldv_state_variable_85 = 1;
    } else {

    }
#line 7993
    if (ldv_state_variable_85 == 2) {
#line 7995
      qla24xx_fabric_logout(qla24xx_isp_ops_group0, (int )ldvarg509, (int )ldvarg508,
                            (int )ldvarg507, (int )ldvarg510);
#line 7997
      ldv_state_variable_85 = 2;
    } else {

    }
#line 8000
    goto ldv_69110;
    case 10: ;
#line 8003
    if (ldv_state_variable_85 == 1) {
#line 8005
      qla24xx_reset_chip(qla24xx_isp_ops_group0);
#line 8007
      ldv_state_variable_85 = 1;
    } else {

    }
#line 8010
    if (ldv_state_variable_85 == 2) {
#line 8012
      qla24xx_reset_chip(qla24xx_isp_ops_group0);
#line 8014
      ldv_state_variable_85 = 2;
    } else {

    }
#line 8017
    goto ldv_69110;
    case 11: ;
#line 8020
    if (ldv_state_variable_85 == 1) {
#line 8022
      qla24xx_prep_ms_iocb(qla24xx_isp_ops_group0, ldvarg506, ldvarg505);
#line 8024
      ldv_state_variable_85 = 1;
    } else {

    }
#line 8027
    if (ldv_state_variable_85 == 2) {
#line 8029
      qla24xx_prep_ms_iocb(qla24xx_isp_ops_group0, ldvarg506, ldvarg505);
#line 8031
      ldv_state_variable_85 = 2;
    } else {

    }
#line 8034
    goto ldv_69110;
    case 12: ;
#line 8037
    if (ldv_state_variable_85 == 1) {
#line 8039
      qla24xx_lun_reset(qla24xx_isp_ops_group2, ldvarg504, ldvarg503);
#line 8041
      ldv_state_variable_85 = 1;
    } else {

    }
#line 8044
    if (ldv_state_variable_85 == 2) {
#line 8046
      qla24xx_lun_reset(qla24xx_isp_ops_group2, ldvarg504, ldvarg503);
#line 8048
      ldv_state_variable_85 = 2;
    } else {

    }
#line 8051
    goto ldv_69110;
    case 13: ;
#line 8054
    if (ldv_state_variable_85 == 1) {
#line 8056
      qla24xx_fw_version_str(qla24xx_isp_ops_group0, ldvarg502, ldvarg501);
#line 8058
      ldv_state_variable_85 = 1;
    } else {

    }
#line 8061
    if (ldv_state_variable_85 == 2) {
#line 8063
      qla24xx_fw_version_str(qla24xx_isp_ops_group0, ldvarg502, ldvarg501);
#line 8065
      ldv_state_variable_85 = 2;
    } else {

    }
#line 8068
    goto ldv_69110;
    case 14: ;
#line 8071
    if (ldv_state_variable_85 == 1) {
#line 8073
      qla2x00_iospace_config(qla24xx_isp_ops_group1);
#line 8075
      ldv_state_variable_85 = 1;
    } else {

    }
#line 8078
    if (ldv_state_variable_85 == 2) {
#line 8080
      qla2x00_iospace_config(qla24xx_isp_ops_group1);
#line 8082
      ldv_state_variable_85 = 2;
    } else {

    }
#line 8085
    goto ldv_69110;
    case 15: ;
#line 8088
    if (ldv_state_variable_85 == 1) {
#line 8090
      qla2x00_initialize_adapter(qla24xx_isp_ops_group0);
#line 8092
      ldv_state_variable_85 = 1;
    } else {

    }
#line 8095
    if (ldv_state_variable_85 == 2) {
#line 8097
      qla2x00_initialize_adapter(qla24xx_isp_ops_group0);
#line 8099
      ldv_state_variable_85 = 2;
    } else {

    }
#line 8102
    goto ldv_69110;
    case 16: ;
#line 8105
    if (ldv_state_variable_85 == 1) {
#line 8107
      qla24xx_disable_intrs(qla24xx_isp_ops_group1);
#line 8109
      ldv_state_variable_85 = 1;
    } else {

    }
#line 8112
    if (ldv_state_variable_85 == 2) {
#line 8114
      qla24xx_disable_intrs(qla24xx_isp_ops_group1);
#line 8116
      ldv_state_variable_85 = 2;
    } else {

    }
#line 8119
    goto ldv_69110;
    case 17: ;
#line 8122
    if (ldv_state_variable_85 == 1) {
#line 8124
      qla24xx_get_flash_version(qla24xx_isp_ops_group0, ldvarg500);
#line 8126
      ldv_state_variable_85 = 1;
    } else {

    }
#line 8129
    if (ldv_state_variable_85 == 2) {
#line 8131
      qla24xx_get_flash_version(qla24xx_isp_ops_group0, ldvarg500);
#line 8133
      ldv_state_variable_85 = 2;
    } else {

    }
#line 8136
    goto ldv_69110;
    case 18: ;
#line 8139
    if (ldv_state_variable_85 == 1) {
#line 8141
      qla24xx_nvram_config(qla24xx_isp_ops_group0);
#line 8143
      ldv_state_variable_85 = 1;
    } else {

    }
#line 8146
    if (ldv_state_variable_85 == 2) {
#line 8148
      qla24xx_nvram_config(qla24xx_isp_ops_group0);
#line 8150
      ldv_state_variable_85 = 2;
    } else {

    }
#line 8153
    goto ldv_69110;
    case 19: ;
#line 8156
    if (ldv_state_variable_85 == 1) {
#line 8158
      qla24xx_pci_info_str(qla24xx_isp_ops_group0, ldvarg499);
#line 8160
      ldv_state_variable_85 = 1;
    } else {

    }
#line 8163
    if (ldv_state_variable_85 == 2) {
#line 8165
      qla24xx_pci_info_str(qla24xx_isp_ops_group0, ldvarg499);
#line 8167
      ldv_state_variable_85 = 2;
    } else {

    }
#line 8170
    goto ldv_69110;
    case 20: ;
#line 8173
    if (ldv_state_variable_85 == 2) {
#line 8175
      qla24xx_read_optrom_data(qla24xx_isp_ops_group0, ldvarg498, ldvarg497, ldvarg496);
#line 8177
      ldv_state_variable_85 = 2;
    } else {

    }
#line 8180
    goto ldv_69110;
    case 21: ;
#line 8183
    if (ldv_state_variable_85 == 1) {
#line 8185
      qla24xx_beacon_blink(qla24xx_isp_ops_group0);
#line 8187
      ldv_state_variable_85 = 1;
    } else {

    }
#line 8190
    if (ldv_state_variable_85 == 2) {
#line 8192
      qla24xx_beacon_blink(qla24xx_isp_ops_group0);
#line 8194
      ldv_state_variable_85 = 2;
    } else {

    }
#line 8197
    goto ldv_69110;
    case 22: ;
#line 8200
    if (ldv_state_variable_85 == 1) {
#line 8202
      qla24xx_beacon_off(qla24xx_isp_ops_group0);
#line 8204
      ldv_state_variable_85 = 1;
    } else {

    }
#line 8207
    if (ldv_state_variable_85 == 2) {
#line 8209
      qla24xx_beacon_off(qla24xx_isp_ops_group0);
#line 8211
      ldv_state_variable_85 = 2;
    } else {

    }
#line 8214
    goto ldv_69110;
    case 23: ;
#line 8217
    if (ldv_state_variable_85 == 1) {
#line 8219
      qla24xx_abort_command(ldvarg495);
#line 8221
      ldv_state_variable_85 = 1;
    } else {

    }
#line 8224
    if (ldv_state_variable_85 == 2) {
#line 8226
      qla24xx_abort_command(ldvarg495);
#line 8228
      ldv_state_variable_85 = 2;
    } else {

    }
#line 8231
    goto ldv_69110;
    case 24: ;
#line 8234
    if (ldv_state_variable_85 == 1) {
#line 8236
      qla24xx_fw_dump(qla24xx_isp_ops_group0, ldvarg494);
#line 8238
      ldv_state_variable_85 = 1;
    } else {

    }
#line 8241
    if (ldv_state_variable_85 == 2) {
#line 8243
      qla24xx_fw_dump(qla24xx_isp_ops_group0, ldvarg494);
#line 8245
      ldv_state_variable_85 = 2;
    } else {

    }
#line 8248
    goto ldv_69110;
    case 25: ;
#line 8251
    if (ldv_state_variable_85 == 1) {
#line 8253
      qla24xx_config_rings(qla24xx_isp_ops_group0);
#line 8255
      ldv_state_variable_85 = 1;
    } else {

    }
#line 8258
    if (ldv_state_variable_85 == 2) {
#line 8260
      qla24xx_config_rings(qla24xx_isp_ops_group0);
#line 8262
      ldv_state_variable_85 = 2;
    } else {

    }
#line 8265
    goto ldv_69110;
    case 26: ;
#line 8268
    if (ldv_state_variable_85 == 1) {
#line 8270
      qla24xx_load_risc(qla24xx_isp_ops_group0, ldvarg493);
#line 8272
      ldv_state_variable_85 = 1;
    } else {

    }
#line 8275
    if (ldv_state_variable_85 == 2) {
#line 8277
      qla24xx_load_risc(qla24xx_isp_ops_group0, ldvarg493);
#line 8279
      ldv_state_variable_85 = 2;
    } else {

    }
#line 8282
    goto ldv_69110;
    case 27: ;
#line 8285
    if (ldv_state_variable_85 == 1) {
#line 8287
      qla24xx_pci_config(qla24xx_isp_ops_group0);
#line 8289
      ldv_state_variable_85 = 1;
    } else {

    }
#line 8292
    if (ldv_state_variable_85 == 2) {
#line 8294
      qla24xx_pci_config(qla24xx_isp_ops_group0);
#line 8296
      ldv_state_variable_85 = 2;
    } else {

    }
#line 8299
    goto ldv_69110;
    case 28: ;
#line 8302
    if (ldv_state_variable_85 == 1) {
#line 8304
      qla24xx_login_fabric(qla24xx_isp_ops_group0, (int )ldvarg491, (int )ldvarg489,
                           (int )ldvarg488, (int )ldvarg492, ldvarg487, (int )ldvarg490);
#line 8306
      ldv_state_variable_85 = 1;
    } else {

    }
#line 8309
    if (ldv_state_variable_85 == 2) {
#line 8311
      qla24xx_login_fabric(qla24xx_isp_ops_group0, (int )ldvarg491, (int )ldvarg489,
                           (int )ldvarg488, (int )ldvarg492, ldvarg487, (int )ldvarg490);
#line 8313
      ldv_state_variable_85 = 2;
    } else {

    }
#line 8316
    goto ldv_69110;
    case 29: ;
#line 8319
    if (ldv_state_variable_85 == 1) {
#line 8321
      qla24xx_write_nvram_data(qla24xx_isp_ops_group0, ldvarg486, ldvarg485, ldvarg484);
#line 8323
      ldv_state_variable_85 = 1;
    } else {

    }
#line 8326
    if (ldv_state_variable_85 == 2) {
#line 8328
      qla24xx_write_nvram_data(qla24xx_isp_ops_group0, ldvarg486, ldvarg485, ldvarg484);
#line 8330
      ldv_state_variable_85 = 2;
    } else {

    }
#line 8333
    goto ldv_69110;
    case 30: ;
#line 8336
    if (ldv_state_variable_85 == 1) {
#line 8338
      qla24xx_beacon_on(qla24xx_isp_ops_group0);
#line 8340
      ldv_state_variable_85 = 1;
    } else {

    }
#line 8343
    if (ldv_state_variable_85 == 2) {
#line 8345
      qla24xx_beacon_on(qla24xx_isp_ops_group0);
#line 8347
      ldv_state_variable_85 = 2;
    } else {

    }
#line 8350
    goto ldv_69110;
    case 31: ;
#line 8353
    if (ldv_state_variable_85 == 1) {
#line 8355
      qla24xx_read_nvram_data(qla24xx_isp_ops_group0, ldvarg483, ldvarg482, ldvarg481);
#line 8357
      ldv_state_variable_85 = 1;
    } else {

    }
#line 8360
    if (ldv_state_variable_85 == 2) {
#line 8362
      qla24xx_read_nvram_data(qla24xx_isp_ops_group0, ldvarg483, ldvarg482, ldvarg481);
#line 8364
      ldv_state_variable_85 = 2;
    } else {

    }
#line 8367
    goto ldv_69110;
    case 32: ;
#line 8370
    if (ldv_state_variable_85 == 1) {
#line 8372
      qla24xx_prep_ms_fdmi_iocb(qla24xx_isp_ops_group0, ldvarg480, ldvarg479);
#line 8374
      ldv_state_variable_85 = 1;
    } else {

    }
#line 8377
    if (ldv_state_variable_85 == 2) {
#line 8379
      qla24xx_prep_ms_fdmi_iocb(qla24xx_isp_ops_group0, ldvarg480, ldvarg479);
#line 8381
      ldv_state_variable_85 = 2;
    } else {

    }
#line 8384
    goto ldv_69110;
    case 33: ;
#line 8387
    if (ldv_state_variable_85 == 2) {
#line 8389
      ldv_release_85();
#line 8391
      ldv_state_variable_85 = 1;
#line 8392
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 8395
    goto ldv_69110;
    case 34: ;
#line 8398
    if (ldv_state_variable_85 == 1) {
#line 8400
      ldv_probe_85();
#line 8402
      ldv_state_variable_85 = 2;
#line 8403
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 8406
    goto ldv_69110;
    default: 
#line 8407
    ldv_stop();
    }
    ldv_69110: ;
  } else {

  }
#line 8411
  goto ldv_68677;
  case 77: ;
#line 8415
  if (ldv_state_variable_3 != 0) {
#line 8416
    invoke_work_3();
  } else {

  }
#line 8419
  goto ldv_68677;
  case 78: ;
#line 8423
  if (ldv_state_variable_36 != 0) {
#line 8424
    ldv_main_exported_36();
  } else {

  }
#line 8427
  goto ldv_68677;
  case 79: ;
#line 8434
  goto ldv_68677;
  case 80: ;
#line 8438
  if (ldv_state_variable_51 != 0) {
#line 8439
    ldv_main_exported_51();
  } else {

  }
#line 8442
  goto ldv_68677;
  case 81: ;
#line 8446
  if (ldv_state_variable_47 != 0) {
#line 8447
    ldv_main_exported_47();
  } else {

  }
#line 8450
  goto ldv_68677;
  case 82: ;
#line 8457
  goto ldv_68677;
  case 83: ;
#line 8461
  if (ldv_state_variable_38 != 0) {
#line 8462
    ldv_main_exported_38();
  } else {

  }
#line 8465
  goto ldv_68677;
  case 84: ;
#line 8469
  if (ldv_state_variable_4 != 0) {
#line 8470
    invoke_work_4();
  } else {

  }
#line 8473
  goto ldv_68677;
  case 85: ;
#line 8477
  if (ldv_state_variable_34 != 0) {
#line 8478
    ldv_main_exported_34();
  } else {

  }
#line 8481
  goto ldv_68677;
  case 86: ;
#line 8485
  if (ldv_state_variable_37 != 0) {
#line 8486
    ldv_main_exported_37();
  } else {

  }
#line 8489
  goto ldv_68677;
  case 87: ;
#line 8493
  if (ldv_state_variable_43 != 0) {
#line 8494
    ldv_main_exported_43();
  } else {

  }
#line 8497
  goto ldv_68677;
  case 88: ;
#line 8501
  if (ldv_state_variable_5 != 0) {
#line 8502
    invoke_work_5();
  } else {

  }
#line 8505
  goto ldv_68677;
  default: 
#line 8506
  ldv_stop();
  }
  ldv_68677: ;
#line 8508
  goto ldv_69159;
  ldv_final: 
#line 8510
  ldv_check_final_state();
#line 8511
  return 0;
}
}
#line 8520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
__inline static long PTR_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
#line 8523
  tmp = ldv_ptr_err(ptr);
#line 8523
  return (tmp);
}
}
#line 8526 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
__inline static bool IS_ERR(void const   *ptr ) 
{ 
  bool tmp ;

  {
#line 8529
  tmp = ldv_is_err(ptr);
#line 8529
  return (tmp);
}
}
#line 8538 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 8542
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 8542
  ldv_func_res = tmp;
#line 8544
  activate_work_7(ldv_func_arg3, 2);
#line 8546
  return (ldv_func_res);
}
}
#line 8549 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 8553
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 8553
  ldv_func_res = tmp;
#line 8555
  activate_work_7(& ldv_func_arg3->work, 2);
#line 8557
  return (ldv_func_res);
}
}
#line 8560 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 8564
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 8564
  ldv_func_res = tmp;
#line 8566
  activate_work_7(ldv_func_arg3, 2);
#line 8568
  return (ldv_func_res);
}
}
#line 8571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 8574
  flush_workqueue(ldv_func_arg1);
#line 8576
  call_and_disable_all_7(2);
#line 8577
  return;
}
}
#line 8579 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 8583
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 8583
  ldv_func_res = tmp;
#line 8585
  activate_work_7(& ldv_func_arg3->work, 2);
#line 8587
  return (ldv_func_res);
}
}
#line 8590 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_scsi_add_host_with_dma_10(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 8594
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 8594
  ldv_func_res = tmp;
#line 8596
  if (ldv_func_res == 0) {
#line 8597
    ldv_state_variable_88 = 1;
#line 8597
    ldv_initialize_scsi_host_template_88();
  } else {

  }
#line 8601
  return (ldv_func_res);
}
}
#line 8604 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_mod_timer_11(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 8608
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 8608
  ldv_func_res = tmp;
#line 8610
  activate_pending_timer_21(ldv_func_arg1, ldv_func_arg2, 1);
#line 8612
  return (ldv_func_res);
}
}
#line 8615 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_del_timer_sync_12(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
#line 8619
  tmp = del_timer_sync(ldv_func_arg1);
#line 8619
  ldv_func_res = tmp;
#line 8621
  disable_suitable_timer_21(ldv_func_arg1);
#line 8623
  return (ldv_func_res);
}
}
#line 8626 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_destroy_workqueue_13(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 8629
  destroy_workqueue(ldv_func_arg1);
#line 8631
  call_and_disable_all_7(2);
#line 8632
  return;
}
}
#line 8634 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_flush_workqueue_14(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 8637
  flush_workqueue(ldv_func_arg1);
#line 8639
  call_and_disable_all_7(2);
#line 8640
  return;
}
}
#line 8642 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_flush_workqueue_15(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 8645
  flush_workqueue(ldv_func_arg1);
#line 8647
  call_and_disable_all_7(2);
#line 8648
  return;
}
}
#line 8650 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_destroy_workqueue_16(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 8653
  destroy_workqueue(ldv_func_arg1);
#line 8655
  call_and_disable_all_7(2);
#line 8656
  return;
}
}
#line 8658 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
bool ldv_cancel_work_sync_17(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  bool tmp ;

  {
#line 8662
  tmp = cancel_work_sync(ldv_func_arg1);
#line 8662
  ldv_func_res = tmp;
#line 8664
  disable_work_7(ldv_func_arg1);
#line 8666
  return (ldv_func_res);
}
}
#line 8669 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_destroy_workqueue_18(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 8672
  destroy_workqueue(ldv_func_arg1);
#line 8674
  call_and_disable_all_7(2);
#line 8675
  return;
}
}
#line 8677 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
bool ldv_cancel_work_sync_19(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  bool tmp ;

  {
#line 8681
  tmp = cancel_work_sync(ldv_func_arg1);
#line 8681
  ldv_func_res = tmp;
#line 8683
  disable_work_7(ldv_func_arg1);
#line 8685
  return (ldv_func_res);
}
}
#line 8688 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
bool ldv_cancel_work_sync_20(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  bool tmp ;

  {
#line 8692
  tmp = cancel_work_sync(ldv_func_arg1);
#line 8692
  ldv_func_res = tmp;
#line 8694
  disable_work_7(ldv_func_arg1);
#line 8696
  return (ldv_func_res);
}
}
#line 8699 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
bool ldv_cancel_work_sync_21(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  bool tmp ;

  {
#line 8703
  tmp = cancel_work_sync(ldv_func_arg1);
#line 8703
  ldv_func_res = tmp;
#line 8705
  disable_work_7(ldv_func_arg1);
#line 8707
  return (ldv_func_res);
}
}
#line 8710 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_destroy_workqueue_22(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 8713
  destroy_workqueue(ldv_func_arg1);
#line 8715
  call_and_disable_all_7(2);
#line 8716
  return;
}
}
#line 8718 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
bool ldv_cancel_work_sync_23(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  bool tmp ;

  {
#line 8722
  tmp = cancel_work_sync(ldv_func_arg1);
#line 8722
  ldv_func_res = tmp;
#line 8724
  disable_work_7(ldv_func_arg1);
#line 8726
  return (ldv_func_res);
}
}
#line 8729 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_scsi_remove_host_24(struct Scsi_Host *shost ) 
{ 


  {
#line 8732
  scsi_remove_host(shost);
#line 8734
  ldv_state_variable_88 = 0;
#line 8735
  return;
}
}
#line 8737 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct Scsi_Host *ldv_scsi_host_alloc_25(struct scsi_host_template *sht , int privsize ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  struct Scsi_Host *tmp ;

  {
#line 8741
  tmp = scsi_host_alloc(sht, privsize);
#line 8741
  ldv_func_res = tmp;
#line 8743
  if ((unsigned long )ldv_func_res != (unsigned long )((ldv_func_ret_type___11 )0)) {
#line 8744
    ldv_state_variable_88 = 1;
#line 8744
    ldv_initialize_scsi_host_template_88();
  } else {

  }
#line 8748
  return (ldv_func_res);
}
}
#line 8751 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_scsi_remove_host_26(struct Scsi_Host *shost ) 
{ 


  {
#line 8754
  scsi_remove_host(shost);
#line 8756
  ldv_state_variable_88 = 0;
#line 8757
  return;
}
}
#line 8759 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
__inline static int ldv_register_chrdev_27(unsigned int major , char const   *name ,
                                           struct file_operations  const  *fops ) 
{ 
  ldv_func_ret_type___12 ldv_func_res ;
  int tmp ;

  {
#line 8763
  tmp = register_chrdev(major, name, fops);
#line 8763
  ldv_func_res = tmp;
#line 8765
  ldv_state_variable_31 = 1;
#line 8766
  ldv_file_operations_31();
#line 8769
  return (ldv_func_res);
}
}
#line 8772 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv___pci_register_driver_28(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                 char const   *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;

  {
#line 8776
  tmp = __pci_register_driver(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 8776
  ldv_func_res = tmp;
#line 8778
  ldv_state_variable_76 = 1;
#line 8779
  ldv_pci_driver_76();
#line 8782
  return (ldv_func_res);
}
}
#line 8785 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
__inline static void ldv_unregister_chrdev_29(unsigned int major , char const   *name ) 
{ 


  {
#line 8788
  unregister_chrdev(major, name);
#line 8790
  ldv_state_variable_31 = 0;
#line 8791
  return;
}
}
#line 8793 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_pci_unregister_driver_30(struct pci_driver *ldv_func_arg1 ) 
{ 


  {
#line 8796
  pci_unregister_driver(ldv_func_arg1);
#line 8798
  ldv_state_variable_76 = 0;
#line 8799
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 53 "include/asm-generic/bitops/find.h"
extern unsigned long find_first_zero_bit(unsigned long const   * , unsigned long  ) ;
#line 7 "./arch/x86/include/uapi/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val ) 
{ 


  {
#line 9
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
#line 10
  return (val);
}
}
#line 46 "include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val ) 
{ 


  {
#line 53
  return ((__u16 )((int )((short )((int )val << 8)) | (int )((short )((int )val >> 8))));
}
}
#line 57 "include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val ) 
{ 
  __u32 tmp ;

  {
#line 62
  tmp = __arch_swab32(val);
#line 62
  return (tmp);
}
}
#line 165 "include/linux/list.h"
__inline static void list_move_tail(struct list_head *list , struct list_head *head ) 
{ 


  {
#line 168
  __list_del_entry(list);
#line 169
  list_add_tail(list, head);
#line 170
  return;
}
}
#line 71 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 63 "./arch/x86/include/asm/string_64.h"
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 23 "include/linux/string.h"
extern char *strncpy(char * , char const   * , __kernel_size_t  ) ;
#line 15 "./arch/x86/include/asm/cmpxchg.h"
extern void __xadd_wrong_size(void) ;
#line 79 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_sub_and_test(int i , atomic_t *v ) 
{ 
  char c ;

  {
#line 81
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; subl %2, %0; sete %1": "+m" (v->counter),
                       "=qm" (c): "er" (i): "memory");
#line 81
  return ((int )((signed char )c) != 0);
}
}
#line 155 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ 
  int __ret ;

  {
#line 157
  __ret = i;
#line 157
  switch (4UL) {
  case 1UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddb %b0, %1\n": "+q" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5659;
  case 2UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddw %w0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5659;
  case 4UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddl %0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5659;
  case 8UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddq %q0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5659;
  default: 
#line 157
  __xadd_wrong_size();
  }
  ldv_5659: ;
#line 157
  return (__ret + i);
}
}
#line 91 "include/linux/completion.h"
extern void wait_for_completion(struct completion * ) ;
#line 83 "include/linux/jiffies.h"
__inline static u64 get_jiffies_64(void) 
{ 


  {
#line 85
  return ((u64 )jiffies);
}
}
#line 284
extern unsigned int jiffies_to_msecs(unsigned long const    ) ;
#line 169 "include/linux/timer.h"
extern int del_timer(struct timer_list * ) ;
#line 172
int ldv_del_timer_67(struct timer_list *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_61(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_63(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_62(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_65(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_64(struct workqueue_struct *ldv_func_arg1 ) ;
#line 32 "include/linux/kref.h"
__inline static void kref_init(struct kref *kref ) 
{ 


  {
#line 34
  atomic_set(& kref->refcount, 1);
#line 35
  return;
}
}
#line 41 "include/linux/kref.h"
__inline static void kref_get(struct kref *kref ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 47
  tmp = atomic_add_return(1, & kref->refcount);
#line 47
  __ret_warn_once = tmp <= 1;
#line 47
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 47
  if (tmp___2 != 0L) {
#line 47
    __ret_warn_on = ! __warned;
#line 47
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 47
    if (tmp___0 != 0L) {
#line 47
      warn_slowpath_null("include/linux/kref.h", 47);
    } else {

    }
#line 47
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 47
    if (tmp___1 != 0L) {
#line 47
      __warned = 1;
    } else {

    }
  } else {

  }
#line 47
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 49
  return;
}
}
#line 68 "include/linux/kref.h"
__inline static int kref_sub(struct kref *kref , unsigned int count , void (*release)(struct kref * ) ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
#line 71
  __ret_warn_on = (unsigned long )release == (unsigned long )((void (*)(struct kref * ))0);
#line 71
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 71
  if (tmp != 0L) {
#line 71
    warn_slowpath_null("include/linux/kref.h", 71);
  } else {

  }
#line 71
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 73
  tmp___0 = atomic_sub_and_test((int )count, & kref->refcount);
#line 73
  if (tmp___0 != 0) {
#line 74
    (*release)(kref);
#line 75
    return (1);
  } else {

  }
#line 77
  return (0);
}
}
#line 97 "include/linux/kref.h"
__inline static int kref_put(struct kref *kref , void (*release)(struct kref * ) ) 
{ 
  int tmp ;

  {
#line 99
  tmp = kref_sub(kref, 1U, release);
#line 99
  return (tmp);
}
}
#line 525 "include/linux/slab.h"
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 527
  if (size != 0UL && 0xffffffffffffffffUL / size < n) {
#line 528
    return ((void *)0);
  } else {

  }
#line 529
  tmp = __kmalloc(n * size, flags);
#line 529
  return (tmp);
}
}
#line 538 "include/linux/slab.h"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 540
  tmp = kmalloc_array(n, size, flags | 32768U);
#line 540
  return (tmp);
}
}
#line 362 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int reg_timer_15(struct timer_list *timer ) ;
#line 370
void activate_pending_timer_15(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 417
void choose_timer_15(struct timer_list *timer ) ;
#line 461
void disable_suitable_timer_15(struct timer_list *timer ) ;
#line 833 "include/linux/pci.h"
extern int pci_find_capability(struct pci_dev * , int  ) ;
#line 863
extern int pci_bus_write_config_byte(struct pci_bus * , unsigned int  , int  , u8  ) ;
#line 865
extern int pci_bus_write_config_word(struct pci_bus * , unsigned int  , int  , u16  ) ;
#line 894 "include/linux/pci.h"
__inline static int pci_write_config_byte(struct pci_dev  const  *dev , int where ,
                                          u8 val ) 
{ 
  int tmp ;

  {
#line 896
  tmp = pci_bus_write_config_byte(dev->bus, dev->devfn, where, (int )val);
#line 896
  return (tmp);
}
}
#line 898 "include/linux/pci.h"
__inline static int pci_write_config_word(struct pci_dev  const  *dev , int where ,
                                          u16 val ) 
{ 
  int tmp ;

  {
#line 900
  tmp = pci_bus_write_config_word(dev->bus, dev->devfn, where, (int )val);
#line 900
  return (tmp);
}
}
#line 969
extern void pci_set_master(struct pci_dev * ) ;
#line 976
extern int pci_try_set_mwi(struct pci_dev * ) ;
#line 977
extern void pci_clear_mwi(struct pci_dev * ) ;
#line 988
extern int pcix_set_mmrbc(struct pci_dev * , int  ) ;
#line 990
extern int pcie_set_readrq(struct pci_dev * , int  ) ;
#line 1017
extern void pci_disable_rom(struct pci_dev * ) ;
#line 183 "include/linux/dma-mapping.h"
__inline static void *dma_zalloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                          gfp_t flag ) 
{ 
  void *ret ;
  void *tmp ;

  {
#line 186
  tmp = dma_alloc_attrs(dev, size, dma_handle, flag | 32768U, (struct dma_attrs *)0);
#line 186
  ret = tmp;
#line 188
  return (ret);
}
}
#line 795 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_66(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 798 "include/scsi/scsi_transport_fc.h"
__inline static u64 wwn_to_u64(u8 *wwn ) 
{ 


  {
#line 800
  return (((((((((unsigned long long )*wwn << 56) | ((unsigned long long )*(wwn + 1UL) << 48)) | ((unsigned long long )*(wwn + 2UL) << 40)) | ((unsigned long long )*(wwn + 3UL) << 32)) | ((unsigned long long )*(wwn + 4UL) << 24)) | ((unsigned long long )*(wwn + 5UL) << 16)) | ((unsigned long long )*(wwn + 6UL) << 8)) | (unsigned long long )*(wwn + 7UL));
}
}
#line 842
extern struct fc_rport *fc_remote_port_add(struct Scsi_Host * , int  , struct fc_rport_identifiers * ) ;
#line 845
extern void fc_remote_port_rolechg(struct fc_rport * , u32  ) ;
#line 2041 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
static char const   * const  port_state_str___0[5U]  = {      "Unknown",      "UNCONFIGURED",      "DEAD",      "LOST", 
        "ONLINE"};
#line 55 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
void qla2x00_alloc_fw_dump(scsi_qla_host_t *vha ) ;
#line 67
int qla2x00_async_tm_cmd(fc_port_t *fcport , uint32_t flags , uint32_t lun , uint32_t tag ) ;
#line 76
int qla24xx_update_fcport_fcp_prio(scsi_qla_host_t *vha , fc_port_t *fcport ) ;
#line 79
fc_port_t *qla2x00_alloc_fcport(scsi_qla_host_t *vha , gfp_t flags ) ;
#line 89
int qla2x00_alloc_outstanding_cmds(struct qla_hw_data *ha , struct req_que *req ) ;
#line 90
int qla2x00_init_rings(scsi_qla_host_t *vha ) ;
#line 180
int qla24xx_configure_vhba(scsi_qla_host_t *vha ) ;
#line 215
int qla2x00_marker(struct scsi_qla_host *vha , struct req_que *req , struct rsp_que *rsp ,
                   uint16_t loop_id , uint64_t lun , uint8_t type ) ;
#line 217
int qla2x00_start_sp(srb_t *sp ) ;
#line 220
unsigned long qla2x00_get_async_timeout(struct scsi_qla_host *vha ) ;
#line 236
int qla2x00_load_ram(scsi_qla_host_t *vha , dma_addr_t req_dma , uint32_t risc_addr ,
                     uint32_t risc_code_size ) ;
#line 242
int qla2x00_execute_fw(scsi_qla_host_t *vha , uint32_t risc_addr ) ;
#line 245
int qla2x00_get_fw_version(scsi_qla_host_t *vha ) ;
#line 248
int qla2x00_get_fw_options(scsi_qla_host_t *vha , uint16_t *fwopts ) ;
#line 251
int qla2x00_set_fw_options(scsi_qla_host_t *vha , uint16_t *fwopts ) ;
#line 254
int qla2x00_mbx_reg_test(scsi_qla_host_t *vha ) ;
#line 257
int qla2x00_verify_checksum(scsi_qla_host_t *vha , uint32_t risc_addr ) ;
#line 272
int qla2x00_get_adapter_id(scsi_qla_host_t *vha , uint16_t *id , uint8_t *al_pa ,
                           uint8_t *area , uint8_t *domain , uint16_t *top , uint16_t *sw_cap ) ;
#line 276
int qla2x00_get_retry_cnt(scsi_qla_host_t *vha , uint8_t *retry_cnt , uint8_t *tov ,
                          uint16_t *r_a_tov ) ;
#line 279
int qla2x00_init_firmware(scsi_qla_host_t *vha , uint16_t size ) ;
#line 288
int qla2x00_get_firmware_state(scsi_qla_host_t *vha , uint16_t *states ) ;
#line 291
int qla2x00_get_port_name(scsi_qla_host_t *vha , uint16_t loop_id , uint8_t *name ,
                          uint8_t opt ) ;
#line 294
int qla24xx_link_initialize(scsi_qla_host_t *vha ) ;
#line 310
int qla2x00_login_local_device(scsi_qla_host_t *vha , fc_port_t *fcport , uint16_t *mb_ret ,
                               uint8_t opt ) ;
#line 323
int qla2x00_get_id_list(scsi_qla_host_t *vha , void *id_list , dma_addr_t id_list_dma ,
                        uint16_t *entries ) ;
#line 326
int qla2x00_get_resource_cnts(scsi_qla_host_t *vha , uint16_t *cur_xchg_cnt , uint16_t *orig_xchg_cnt ,
                              uint16_t *cur_iocb_cnt , uint16_t *orig_iocb_cnt , uint16_t *max_npiv_vports ,
                              uint16_t *max_fcfs ) ;
#line 363
int qla2x00_set_serdes_params(scsi_qla_host_t *vha , uint16_t sw_em_1g , uint16_t sw_em_2g ,
                              uint16_t sw_em_4g ) ;
#line 366
int qla2x00_stop_firmware(scsi_qla_host_t *vha ) ;
#line 369
int qla2x00_enable_eft_trace(scsi_qla_host_t *vha , dma_addr_t eft_dma , uint16_t buffers ) ;
#line 374
int qla2x00_enable_fce_trace(scsi_qla_host_t *vha , dma_addr_t fce_dma , uint16_t buffers ,
                             uint16_t *mb , uint32_t *dwords ) ;
#line 381
int qla82xx_set_driver_version(scsi_qla_host_t *vha , char *version ) ;
#line 384
int qla25xx_set_driver_version(scsi_qla_host_t *vha , char *version ) ;
#line 395
int qla2x00_set_idma_speed(scsi_qla_host_t *vha , uint16_t loop_id , uint16_t port_speed ,
                           uint16_t *mb ) ;
#line 397
int qla84xx_verify_chip(struct scsi_qla_host *vha , uint16_t *status ) ;
#line 402
int qla81xx_fac_get_sector_size(scsi_qla_host_t *vha , uint32_t *sector_size ) ;
#line 417
int qla2x00_read_ram_word(scsi_qla_host_t *vha , uint32_t risc_addr , uint32_t *data ) ;
#line 420
int qla2x00_write_ram_word(scsi_qla_host_t *vha , uint32_t risc_addr , uint32_t data ) ;
#line 423
int qla81xx_write_mpi_register(scsi_qla_host_t *vha , uint16_t *mb ) ;
#line 424
int qla2x00_get_data_rate(scsi_qla_host_t *vha ) ;
#line 425
int qla24xx_set_fcp_prio(scsi_qla_host_t *vha , uint16_t loop_id , uint16_t priority ,
                         uint16_t *mb ) ;
#line 428
int qla81xx_get_port_config(scsi_qla_host_t *vha , uint16_t *mb ) ;
#line 437
int qla2x00_dump_mctp_data(scsi_qla_host_t *vha , dma_addr_t req_dma , uint32_t addr ,
                           uint32_t size ) ;
#line 452
char const   *qla2x00_get_link_speed_str(struct qla_hw_data *ha , uint16_t speed ) ;
#line 464
uint32_t *qla24xx_read_flash_data(scsi_qla_host_t *vha , uint32_t *dwptr , uint32_t faddr ,
                                  uint32_t dwords ) ;
#line 478
int qla2x00_is_a_vp_did(scsi_qla_host_t *vha , uint32_t rscn_entry ) ;
#line 515
int qla2xxx_get_flash_info(scsi_qla_host_t *vha ) ;
#line 516
int qla2xxx_get_vpd_field(scsi_qla_host_t *vha , char *key , char *str , size_t size ) ;
#line 519
int qla24xx_read_fcp_prio_cfg(scsi_qla_host_t *vha ) ;
#line 533
ulong qla27xx_fwdt_calculate_dump_size(struct scsi_qla_host *vha ) ;
#line 534
int qla27xx_fwdt_template_valid(void *p ) ;
#line 535
ulong qla27xx_fwdt_template_size(void *p ) ;
#line 536
void const   *qla27xx_fwdt_template_default(void) ;
#line 537
ulong qla27xx_fwdt_template_default_size(void) ;
#line 543
void ql_dump_buffer(uint32_t level , scsi_qla_host_t *vha , int32_t id , uint8_t *b ,
                    uint32_t size ) ;
#line 552
int qla2x00_ga_nxt(scsi_qla_host_t *vha , fc_port_t *fcport ) ;
#line 553
int qla2x00_gid_pt(scsi_qla_host_t *vha , sw_info_t *list ) ;
#line 554
int qla2x00_gpn_id(scsi_qla_host_t *vha , sw_info_t *list ) ;
#line 555
int qla2x00_gnn_id(scsi_qla_host_t *vha , sw_info_t *list ) ;
#line 556
void qla2x00_gff_id(scsi_qla_host_t *vha , sw_info_t *list ) ;
#line 557
int qla2x00_rft_id(scsi_qla_host_t *vha ) ;
#line 558
int qla2x00_rff_id(scsi_qla_host_t *vha ) ;
#line 559
int qla2x00_rnn_id(scsi_qla_host_t *vha ) ;
#line 560
int qla2x00_rsnn_nn(scsi_qla_host_t *vha ) ;
#line 563
int qla2x00_fdmi_register(scsi_qla_host_t *vha ) ;
#line 564
int qla2x00_gfpn_id(scsi_qla_host_t *vha , sw_info_t *list ) ;
#line 565
int qla2x00_gpsc(scsi_qla_host_t *vha , sw_info_t *list ) ;
#line 583
int qla24xx_update_all_fcp_prio(scsi_qla_host_t *vha ) ;
#line 595
int qla25xx_init_req_que(struct scsi_qla_host *vha , struct req_que *req ) ;
#line 596
int qla25xx_init_rsp_que(struct scsi_qla_host *vha , struct rsp_que *rsp ) ;
#line 601
void qla2x00_init_response_q_entries(struct rsp_que *rsp ) ;
#line 627
int qlafx00_init_firmware(scsi_qla_host_t *vha , uint16_t size ) ;
#line 629
int qlafx00_fw_ready(scsi_qla_host_t *vha ) ;
#line 630
int qlafx00_configure_devices(scsi_qla_host_t *vha ) ;
#line 639
void qlafx00_init_response_q_entries(struct rsp_que *rsp ) ;
#line 675
void qla2x00_sp_free(void *data , void *ptr ) ;
#line 676
void qla2x00_sp_timeout(unsigned long __data ) ;
#line 707
__inline void qla2x00_set_model_info(scsi_qla_host_t *vha , uint8_t *model , size_t len ,
                                     char *def ) ;
#line 713
int qla82xx_check_md_needed(scsi_qla_host_t *vha ) ;
#line 714
void qla82xx_chip_reset_cleanup(scsi_qla_host_t *vha ) ;
#line 750
void qla8044_read_reset_template(struct scsi_qla_host *vha ) ;
#line 751
void qla8044_set_idc_dontreset(struct scsi_qla_host *vha ) ;
#line 752
int qla8044_rd_direct(struct scsi_qla_host *vha , uint32_t const   crb_reg ) ;
#line 10 "include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 1045 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
void qlt_fc_port_added(struct scsi_qla_host *vha , fc_port_t *fcport ) ;
#line 1049
void qlt_update_vp_map(struct scsi_qla_host *vha , int cmd ) ;
#line 1058 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
__inline static bool qla_tgt_mode_enabled(struct scsi_qla_host *ha ) 
{ 


  {
#line 1060
  return (((int )(ha->host)->active_mode & 2) != 0);
}
}
#line 1089
void qlt_init_atio_q_entries(struct scsi_qla_host *vha ) ;
#line 1090
void qlt_24xx_process_atio_queue(struct scsi_qla_host *vha ) ;
#line 1091
void qlt_24xx_config_rings(struct scsi_qla_host *vha ) ;
#line 1092
void qlt_24xx_config_nvram_stage1(struct scsi_qla_host *vha , struct nvram_24xx *nv ) ;
#line 1094
void qlt_24xx_config_nvram_stage2(struct scsi_qla_host *vha , struct init_cb_24xx *icb ) ;
#line 1096
void qlt_81xx_config_nvram_stage2(struct scsi_qla_host *vha , struct init_cb_81xx *icb ) ;
#line 1098
void qlt_81xx_config_nvram_stage1(struct scsi_qla_host *vha , struct nvram_81xx *nv ) ;
#line 42 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static uint16_t qla2x00_debounce_register(uint16_t volatile   *addr ) 
{ 
  uint16_t volatile   first ;
  uint16_t volatile   second ;
  unsigned short tmp ;
  unsigned short tmp___0 ;

  {
  ldv_65633: 
#line 48
  tmp = readw((void const volatile   *)addr);
#line 48
  first = tmp;
#line 49
  __asm__  volatile   ("": : : "memory");
#line 50
  cpu_relax();
#line 51
  tmp___0 = readw((void const volatile   *)addr);
#line 51
  second = tmp___0;
#line 52
  if ((int )((unsigned short )first) != (int )((unsigned short )second)) {
#line 54
    goto ldv_65633;
  } else {

  }

#line 54
  return ((uint16_t )first);
}
}
#line 159 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_set_fcport_state___0(fc_port_t *fcport , int state ) 
{ 
  int old_state ;

  {
#line 163
  old_state = atomic_read((atomic_t const   *)(& fcport->state));
#line 164
  atomic_set(& fcport->state, state);
#line 167
  if (old_state != 0 && old_state != state) {
#line 168
    ql_dbg(268435456U, fcport->vha, 8317, "FCPort state transitioned from %s to %s - portid=%02x%02x%02x.\n",
           port_state_str___0[old_state], port_state_str___0[state], (int )fcport->d_id.b.domain,
           (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
  } else {

  }
#line 174
  return;
}
}
#line 250 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_init_timer(srb_t *sp , unsigned long tmo ) 
{ 


  {
#line 252
  reg_timer_21(& sp->u.iocb_cmd.timer);
#line 253
  sp->u.iocb_cmd.timer.expires = tmo * 250UL + (unsigned long )jiffies;
#line 254
  sp->u.iocb_cmd.timer.data = (unsigned long )sp;
#line 255
  sp->u.iocb_cmd.timer.function = & qla2x00_sp_timeout;
#line 256
  add_timer(& sp->u.iocb_cmd.timer);
#line 257
  sp->free = & qla2x00_sp_free;
#line 258
  if (((((sp->fcport)->vha)->hw)->device_type & 131072U) != 0U && (unsigned int )sp->type == 10U) {
#line 260
    init_completion(& sp->u.iocb_cmd.u.fxiocb.fxiocb_comp);
  } else {

  }
#line 261
  return;
}
}
#line 69 "include/linux/vmalloc.h"
extern void *vmalloc(unsigned long  ) ;
#line 6 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_devtbl.h"
static char *qla2x00_model_name[184U]  = 
#line 6 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_devtbl.h"
  {      (char *)"QLA2340",      (char *)"133MHz PCI-X to 2Gb FC, Single Channel",      (char *)"QLA2342",      (char *)"133MHz PCI-X to 2Gb FC, Dual Channel", 
        (char *)"QLA2344",      (char *)"133MHz PCI-X to 2Gb FC, Quad Channel",      (char *)"QCP2342",      (char *)"cPCI to 2Gb FC, Dual Channel", 
        (char *)"QSB2340",      (char *)"SBUS to 2Gb FC, Single Channel",      (char *)"QSB2342",      (char *)"SBUS to 2Gb FC, Dual Channel", 
        (char *)"QLA2310",      (char *)"Sun 66MHz PCI-X to 2Gb FC, Single Channel",      (char *)"QLA2332",      (char *)"Sun 66MHz PCI-X to 2Gb FC, Single Channel", 
        (char *)"QCP2332",      (char *)"Sun cPCI to 2Gb FC, Dual Channel",      (char *)"QCP2340",      (char *)"cPCI to 2Gb FC, Single Channel", 
        (char *)"QLA2342",      (char *)"Sun 133MHz PCI-X to 2Gb FC, Dual Channel",      (char *)"QCP2342",      (char *)"Sun - cPCI to 2Gb FC, Dual Channel", 
        (char *)"QLA2350",      (char *)"133MHz PCI-X to 2Gb FC, Single Channel",      (char *)"QLA2352",      (char *)"133MHz PCI-X to 2Gb FC, Dual Channel", 
        (char *)"QLA2352",      (char *)"Sun 133MHz PCI-X to 2Gb FC, Dual Channel",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)"QLA2360",      (char *)"133MHz PCI-X to 2Gb FC, Single Channel", 
        (char *)"QLA2362",      (char *)"133MHz PCI-X to 2Gb FC, Dual Channel",      (char *)"QLE2360",      (char *)"PCI-Express to 2Gb FC, Single Channel", 
        (char *)"QLE2362",      (char *)"PCI-Express to 2Gb FC, Dual Channel",      (char *)"QLA200",      (char *)"133MHz PCI-X to 2Gb FC Optical", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)"QLA200P",      (char *)"133MHz PCI-X to 2Gb FC SFP",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)"QLA210",      (char *)"133MHz PCI-X to 2Gb FC, Single Channel", 
        (char *)"EMC 250",      (char *)"133MHz PCI-X to 2Gb FC, Single Channel",      (char *)"HP A7538A",      (char *)"HP 1p2g PCI-X to 2Gb FC, Single Channel", 
        (char *)"QLA210",      (char *)"Sun 133MHz PCI-X to 2Gb FC, Single Channel",      (char *)"QLA2460",      (char *)"PCI-X 2.0 to 4Gb FC, Single Channel", 
        (char *)"QLA2462",      (char *)"PCI-X 2.0 to 4Gb FC, Dual Channel",      (char *)"QMC2462",      (char *)"IBM eServer BC 4Gb FC Expansion Card", 
        (char *)"QMC2462S",      (char *)"IBM eServer BC 4Gb FC Expansion Card SFF",      (char *)"QLE2460",      (char *)"PCI-Express to 4Gb FC, Single Channel", 
        (char *)"QLE2462",      (char *)"PCI-Express to 4Gb FC, Dual Channel",      (char *)"QME2462",      (char *)"Dell BS PCI-Express to 4Gb FC, Dual Channel", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)"QEM2462",      (char *)"Sun Server I/O Module 4Gb FC, Dual Channel", 
        (char *)"QLE210",      (char *)"PCI-Express to 2Gb FC, Single Channel",      (char *)"QLE220",      (char *)"PCI-Express to 4Gb FC, Single Channel", 
        (char *)"QLA2460",      (char *)"Sun PCI-X 2.0 to 4Gb FC, Single Channel",      (char *)"QLA2462",      (char *)"Sun PCI-X 2.0 to 4Gb FC, Dual Channel", 
        (char *)"QLE2460",      (char *)"Sun PCI-Express to 2Gb FC, Single Channel",      (char *)"QLE2462",      (char *)"Sun PCI-Express to 4Gb FC, Single Channel", 
        (char *)"QEM2462",      (char *)"Server I/O Module 4Gb FC, Dual Channel",      (char *)"QLE2440",      (char *)"PCI-Express to 4Gb FC, Single Channel", 
        (char *)"QLE2464",      (char *)"PCI-Express to 4Gb FC, Quad Channel",      (char *)"QLA2440",      (char *)"PCI-X 2.0 to 4Gb FC, Single Channel", 
        (char *)"HP AE369A",      (char *)"PCI-X 2.0 to 4Gb FC, Dual Channel",      (char *)"QLA2340",      (char *)"Sun 133MHz PCI-X to 2Gb FC, Single Channel", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)"QMC2432M",      (char *)"IBM eServer BC 4Gb FC Expansion Card CFFE",      (char *)"QMC2422M",      (char *)"IBM eServer BC 4Gb FC Expansion Card CFFX", 
        (char *)"QLE220",      (char *)"Sun PCI-Express to 4Gb FC, Single Channel",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)"QME2462",      (char *)"PCI-Express to 4Gb FC, Dual Channel Mezz HBA",      (char *)"QMH2462",      (char *)"PCI-Express to 4Gb FC, Dual Channel Mezz HBA", 
        (char *)" ",      (char *)" ",      (char *)"QLE220",      (char *)"PCI-Express to 4Gb FC, Single Channel", 
        (char *)"QLE220",      (char *)"PCI-Express to 4Gb FC, Single Channel",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)"QME2472",      (char *)"Dell BS PCI-Express to 4Gb FC, Dual Channel"};
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static int qla2x00_isp_firmware(scsi_qla_host_t *vha ) ;
#line 27
static int qla2x00_setup_chip(scsi_qla_host_t *vha ) ;
#line 28
static int qla2x00_fw_ready(scsi_qla_host_t *vha ) ;
#line 29
static int qla2x00_configure_hba(scsi_qla_host_t *vha ) ;
#line 30
static int qla2x00_configure_loop(scsi_qla_host_t *vha ) ;
#line 31
static int qla2x00_configure_local_loop(scsi_qla_host_t *vha ) ;
#line 32
static int qla2x00_configure_fabric(scsi_qla_host_t *vha ) ;
#line 33
static int qla2x00_find_all_fabric_devs(scsi_qla_host_t *vha , struct list_head *new_fcports ) ;
#line 34
static int qla2x00_fabric_dev_login(scsi_qla_host_t *vha , fc_port_t *fcport , uint16_t *next_loopid ) ;
#line 37
static int qla2x00_restart_isp(scsi_qla_host_t *vha ) ;
#line 39
static struct qla_chip_state_84xx *qla84xx_get_chip(struct scsi_qla_host *vha ) ;
#line 40
static int qla84xx_init_chip(scsi_qla_host_t *vha ) ;
#line 41
static int qla25xx_init_queues(struct qla_hw_data *ha ) ;
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
void qla2x00_sp_timeout(unsigned long __data ) 
{ 
  srb_t *sp ;
  struct srb_iocb *iocb ;
  fc_port_t *fcport ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 48
  sp = (srb_t *)__data;
#line 50
  fcport = sp->fcport;
#line 51
  ha = (fcport->vha)->hw;
#line 55
  tmp = spinlock_check(& ha->hardware_lock);
#line 55
  flags = _raw_spin_lock_irqsave(tmp);
#line 56
  req = *(ha->req_q_map);
#line 57
  *(req->outstanding_cmds + (unsigned long )sp->handle) = (srb_t *)0;
#line 58
  iocb = & sp->u.iocb_cmd;
#line 59
  (*(iocb->timeout))((void *)sp);
#line 60
  (*(sp->free))((void *)fcport->vha, (void *)sp);
#line 61
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 62
  return;
}
}
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
void qla2x00_sp_free(void *data , void *ptr ) 
{ 
  srb_t *sp ;
  struct srb_iocb *iocb ;
  struct scsi_qla_host *vha ;

  {
#line 67
  sp = (srb_t *)ptr;
#line 68
  iocb = & sp->u.iocb_cmd;
#line 69
  vha = (struct scsi_qla_host *)data;
#line 71
  ldv_del_timer_67(& iocb->timer);
#line 72
  qla2x00_rel_sp(vha, sp);
#line 73
  return;
}
}
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
unsigned long qla2x00_get_async_timeout(struct scsi_qla_host *vha ) 
{ 
  unsigned long tmo ;
  struct qla_hw_data *ha ;

  {
#line 81
  ha = vha->hw;
#line 84
  tmo = (unsigned long )((int )((unsigned int )ha->r_a_tov / 10U) * 2);
#line 85
  if ((ha->device_type & 131072U) != 0U) {
#line 86
    tmo = 20UL;
  } else
#line 87
  if ((ha->device_type & 134217728U) == 0U) {
#line 92
    tmo = (unsigned long )ha->login_timeout;
  } else {

  }
#line 94
  return (tmo);
}
}
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static void qla2x00_async_iocb_timeout(void *data ) 
{ 
  srb_t *sp ;
  fc_port_t *fcport ;
  struct srb_iocb *lio ;

  {
#line 100
  sp = (srb_t *)data;
#line 101
  fcport = sp->fcport;
#line 103
  ql_dbg(268435456U, fcport->vha, 8305, "Async-%s timeout - hdl=%x portid=%02x%02x%02x.\n",
         sp->name, sp->handle, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
         (int )fcport->d_id.b.al_pa);
#line 108
  fcport->flags = fcport->flags & 4294967287U;
#line 109
  if ((unsigned int )sp->type == 1U) {
#line 110
    lio = & sp->u.iocb_cmd;
#line 111
    qla2x00_post_async_logout_work(fcport->vha, fcport, (uint16_t *)0U);
#line 113
    lio->u.logio.data[0] = 16389U;
#line 114
    lio->u.logio.data[1] = (unsigned int )lio->u.logio.flags & 1U;
#line 116
    qla2x00_post_async_login_done_work(fcport->vha, fcport, (uint16_t *)(& lio->u.logio.data));
  } else {

  }
#line 119
  return;
}
}
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static void qla2x00_async_login_sp_done(void *data , void *ptr , int res ) 
{ 
  srb_t *sp ;
  struct srb_iocb *lio ;
  struct scsi_qla_host *vha ;
  int tmp ;

  {
#line 124
  sp = (srb_t *)ptr;
#line 125
  lio = & sp->u.iocb_cmd;
#line 126
  vha = (struct scsi_qla_host *)data;
#line 128
  tmp = constant_test_bit(15L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 128
  if (tmp == 0) {
#line 129
    qla2x00_post_async_login_done_work((sp->fcport)->vha, sp->fcport, (uint16_t *)(& lio->u.logio.data));
  } else {

  }
#line 131
  (*(sp->free))((void *)(sp->fcport)->vha, (void *)sp);
#line 132
  return;
}
}
#line 135 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla2x00_async_login(struct scsi_qla_host *vha , fc_port_t *fcport , uint16_t *data ) 
{ 
  srb_t *sp ;
  struct srb_iocb *lio ;
  int rval ;
  unsigned long tmp ;

  {
#line 142
  rval = 258;
#line 143
  sp = qla2x00_get_sp(vha, fcport, 208U);
#line 144
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 145
    goto done;
  } else {

  }
#line 147
  sp->type = 1U;
#line 148
  sp->name = (char *)"login";
#line 149
  tmp = qla2x00_get_async_timeout(vha);
#line 149
  qla2x00_init_timer(sp, tmp + 2UL);
#line 151
  lio = & sp->u.iocb_cmd;
#line 152
  lio->timeout = & qla2x00_async_iocb_timeout;
#line 153
  sp->done = & qla2x00_async_login_sp_done;
#line 154
  lio->u.logio.flags = (uint16_t )((unsigned int )lio->u.logio.flags | 2U);
#line 155
  if ((int )*(data + 1UL) & 1) {
#line 156
    lio->u.logio.flags = (uint16_t )((unsigned int )lio->u.logio.flags | 1U);
  } else {

  }
#line 157
  rval = qla2x00_start_sp(sp);
#line 158
  if (rval != 0) {
#line 159
    goto done_free_sp;
  } else {

  }
#line 161
  ql_dbg(268435456U, vha, 8306, "Async-login - hdl=%x, loopid=%x portid=%02x%02x%02x retries=%d.\n",
         sp->handle, (int )fcport->loop_id, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
         (int )fcport->d_id.b.al_pa, fcport->login_retry);
#line 166
  return (rval);
  done_free_sp: 
#line 169
  (*(sp->free))((void *)fcport->vha, (void *)sp);
  done: ;
#line 171
  return (rval);
}
}
#line 175 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static void qla2x00_async_logout_sp_done(void *data , void *ptr , int res ) 
{ 
  srb_t *sp ;
  struct srb_iocb *lio ;
  struct scsi_qla_host *vha ;
  int tmp ;

  {
#line 177
  sp = (srb_t *)ptr;
#line 178
  lio = & sp->u.iocb_cmd;
#line 179
  vha = (struct scsi_qla_host *)data;
#line 181
  tmp = constant_test_bit(15L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 181
  if (tmp == 0) {
#line 182
    qla2x00_post_async_logout_done_work((sp->fcport)->vha, sp->fcport, (uint16_t *)(& lio->u.logio.data));
  } else {

  }
#line 184
  (*(sp->free))((void *)(sp->fcport)->vha, (void *)sp);
#line 185
  return;
}
}
#line 188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla2x00_async_logout(struct scsi_qla_host *vha , fc_port_t *fcport ) 
{ 
  srb_t *sp ;
  struct srb_iocb *lio ;
  int rval ;
  unsigned long tmp ;

  {
#line 194
  rval = 258;
#line 195
  sp = qla2x00_get_sp(vha, fcport, 208U);
#line 196
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 197
    goto done;
  } else {

  }
#line 199
  sp->type = 2U;
#line 200
  sp->name = (char *)"logout";
#line 201
  tmp = qla2x00_get_async_timeout(vha);
#line 201
  qla2x00_init_timer(sp, tmp + 2UL);
#line 203
  lio = & sp->u.iocb_cmd;
#line 204
  lio->timeout = & qla2x00_async_iocb_timeout;
#line 205
  sp->done = & qla2x00_async_logout_sp_done;
#line 206
  rval = qla2x00_start_sp(sp);
#line 207
  if (rval != 0) {
#line 208
    goto done_free_sp;
  } else {

  }
#line 210
  ql_dbg(268435456U, vha, 8304, "Async-logout - hdl=%x loop-id=%x portid=%02x%02x%02x.\n",
         sp->handle, (int )fcport->loop_id, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
         (int )fcport->d_id.b.al_pa);
#line 214
  return (rval);
  done_free_sp: 
#line 217
  (*(sp->free))((void *)fcport->vha, (void *)sp);
  done: ;
#line 219
  return (rval);
}
}
#line 223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static void qla2x00_async_adisc_sp_done(void *data , void *ptr , int res ) 
{ 
  srb_t *sp ;
  struct srb_iocb *lio ;
  struct scsi_qla_host *vha ;
  int tmp ;

  {
#line 225
  sp = (srb_t *)ptr;
#line 226
  lio = & sp->u.iocb_cmd;
#line 227
  vha = (struct scsi_qla_host *)data;
#line 229
  tmp = constant_test_bit(15L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 229
  if (tmp == 0) {
#line 230
    qla2x00_post_async_adisc_done_work((sp->fcport)->vha, sp->fcport, (uint16_t *)(& lio->u.logio.data));
  } else {

  }
#line 232
  (*(sp->free))((void *)(sp->fcport)->vha, (void *)sp);
#line 233
  return;
}
}
#line 236 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla2x00_async_adisc(struct scsi_qla_host *vha , fc_port_t *fcport , uint16_t *data ) 
{ 
  srb_t *sp ;
  struct srb_iocb *lio ;
  int rval ;
  unsigned long tmp ;

  {
#line 243
  rval = 258;
#line 244
  sp = qla2x00_get_sp(vha, fcport, 208U);
#line 245
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 246
    goto done;
  } else {

  }
#line 248
  sp->type = 6U;
#line 249
  sp->name = (char *)"adisc";
#line 250
  tmp = qla2x00_get_async_timeout(vha);
#line 250
  qla2x00_init_timer(sp, tmp + 2UL);
#line 252
  lio = & sp->u.iocb_cmd;
#line 253
  lio->timeout = & qla2x00_async_iocb_timeout;
#line 254
  sp->done = & qla2x00_async_adisc_sp_done;
#line 255
  if ((int )*(data + 1UL) & 1) {
#line 256
    lio->u.logio.flags = (uint16_t )((unsigned int )lio->u.logio.flags | 1U);
  } else {

  }
#line 257
  rval = qla2x00_start_sp(sp);
#line 258
  if (rval != 0) {
#line 259
    goto done_free_sp;
  } else {

  }
#line 261
  ql_dbg(268435456U, vha, 8303, "Async-adisc - hdl=%x loopid=%x portid=%02x%02x%02x.\n",
         sp->handle, (int )fcport->loop_id, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
         (int )fcport->d_id.b.al_pa);
#line 265
  return (rval);
  done_free_sp: 
#line 268
  (*(sp->free))((void *)fcport->vha, (void *)sp);
  done: ;
#line 270
  return (rval);
}
}
#line 274 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static void qla2x00_tmf_iocb_timeout(void *data ) 
{ 
  srb_t *sp ;
  struct srb_iocb *tmf ;

  {
#line 276
  sp = (srb_t *)data;
#line 277
  tmf = & sp->u.iocb_cmd;
#line 279
  tmf->u.tmf.comp_status = 6U;
#line 280
  complete(& tmf->u.tmf.comp);
#line 281
  return;
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static void qla2x00_tmf_sp_done(void *data , void *ptr , int res ) 
{ 
  srb_t *sp ;
  struct srb_iocb *tmf ;

  {
#line 286
  sp = (srb_t *)ptr;
#line 287
  tmf = & sp->u.iocb_cmd;
#line 288
  complete(& tmf->u.tmf.comp);
#line 289
  return;
}
}
#line 292 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla2x00_async_tm_cmd(fc_port_t *fcport , uint32_t flags , uint32_t lun , uint32_t tag ) 
{ 
  struct scsi_qla_host *vha ;
  struct srb_iocb *tm_iocb ;
  srb_t *sp ;
  int rval ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 295
  vha = fcport->vha;
#line 298
  rval = 258;
#line 300
  sp = qla2x00_get_sp(vha, fcport, 208U);
#line 301
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 302
    goto done;
  } else {

  }
#line 304
  tm_iocb = & sp->u.iocb_cmd;
#line 305
  sp->type = 7U;
#line 306
  sp->name = (char *)"tmf";
#line 307
  tmp = qla2x00_get_async_timeout(vha);
#line 307
  qla2x00_init_timer(sp, tmp);
#line 308
  tm_iocb->u.tmf.flags = flags;
#line 309
  tm_iocb->u.tmf.lun = (uint64_t )lun;
#line 310
  tm_iocb->u.tmf.data = tag;
#line 311
  sp->done = & qla2x00_tmf_sp_done;
#line 312
  tm_iocb->timeout = & qla2x00_tmf_iocb_timeout;
#line 313
  init_completion(& tm_iocb->u.tmf.comp);
#line 315
  rval = qla2x00_start_sp(sp);
#line 316
  if (rval != 0) {
#line 317
    goto done_free_sp;
  } else {

  }
#line 319
  ql_dbg(4194304U, vha, 32815, "Async-tmf hdl=%x loop-id=%x portid=%02x%02x%02x.\n",
         sp->handle, (int )fcport->loop_id, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
         (int )fcport->d_id.b.al_pa);
#line 324
  wait_for_completion(& tm_iocb->u.tmf.comp);
#line 326
  rval = (unsigned int )tm_iocb->u.tmf.comp_status == 0U ? 0 : 258;
#line 329
  if (rval != 0 || tm_iocb->u.tmf.data != 0U) {
#line 330
    ql_dbg(4194304U, vha, 32816, "TM IOCB failed (%x).\n", rval);
  } else {

  }
#line 334
  tmp___0 = constant_test_bit(15L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 334
  if (tmp___0 == 0 && ((vha->hw)->device_type & 131072U) == 0U) {
#line 335
    flags = tm_iocb->u.tmf.flags;
#line 336
    lun = (uint32_t )((unsigned short )tm_iocb->u.tmf.lun);
#line 339
    qla2x00_marker(vha, *((vha->hw)->req_q_map), *((vha->hw)->rsp_q_map), (int )(sp->fcport)->loop_id,
                   (uint64_t )lun, flags != 16U);
  } else {

  }
  done_free_sp: 
#line 345
  (*(sp->free))((void *)vha, (void *)sp);
  done: ;
#line 347
  return (rval);
}
}
#line 351 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static void qla24xx_abort_iocb_timeout(void *data ) 
{ 
  srb_t *sp ;
  struct srb_iocb *abt ;

  {
#line 353
  sp = (srb_t *)data;
#line 354
  abt = & sp->u.iocb_cmd;
#line 356
  abt->u.abt.comp_status = 6U;
#line 357
  complete(& abt->u.abt.comp);
#line 358
  return;
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static void qla24xx_abort_sp_done(void *data , void *ptr , int res ) 
{ 
  srb_t *sp ;
  struct srb_iocb *abt ;

  {
#line 363
  sp = (srb_t *)ptr;
#line 364
  abt = & sp->u.iocb_cmd;
#line 366
  complete(& abt->u.abt.comp);
#line 367
  return;
}
}
#line 370 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static int qla24xx_async_abort_cmd(srb_t *cmd_sp ) 
{ 
  scsi_qla_host_t *vha ;
  fc_port_t *fcport ;
  struct srb_iocb *abt_iocb ;
  srb_t *sp ;
  int rval ;
  unsigned long tmp ;

  {
#line 372
  vha = (cmd_sp->fcport)->vha;
#line 373
  fcport = cmd_sp->fcport;
#line 376
  rval = 258;
#line 378
  sp = qla2x00_get_sp(vha, fcport, 208U);
#line 379
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 380
    goto done;
  } else {

  }
#line 382
  abt_iocb = & sp->u.iocb_cmd;
#line 383
  sp->type = 12U;
#line 384
  sp->name = (char *)"abort";
#line 385
  tmp = qla2x00_get_async_timeout(vha);
#line 385
  qla2x00_init_timer(sp, tmp);
#line 386
  abt_iocb->u.abt.cmd_hndl = cmd_sp->handle;
#line 387
  sp->done = & qla24xx_abort_sp_done;
#line 388
  abt_iocb->timeout = & qla24xx_abort_iocb_timeout;
#line 389
  init_completion(& abt_iocb->u.abt.comp);
#line 391
  rval = qla2x00_start_sp(sp);
#line 392
  if (rval != 0) {
#line 393
    goto done_free_sp;
  } else {

  }
#line 395
  ql_dbg(33554432U, vha, 20604, "Abort command issued - hdl=%x, target_id=%x\n", cmd_sp->handle,
         (int )fcport->tgt_id);
#line 399
  wait_for_completion(& abt_iocb->u.abt.comp);
#line 401
  rval = (unsigned int )abt_iocb->u.abt.comp_status == 0U ? 0 : 258;
  done_free_sp: 
#line 405
  (*(sp->free))((void *)vha, (void *)sp);
  done: ;
#line 407
  return (rval);
}
}
#line 411 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla24xx_async_abort_command(srb_t *sp ) 
{ 
  unsigned long flags ;
  uint32_t handle ;
  fc_port_t *fcport ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 413
  flags = 0UL;
#line 416
  fcport = sp->fcport;
#line 417
  vha = fcport->vha;
#line 418
  ha = vha->hw;
#line 419
  req = vha->req;
#line 421
  tmp = spinlock_check(& ha->hardware_lock);
#line 421
  flags = _raw_spin_lock_irqsave(tmp);
#line 422
  handle = 1U;
#line 422
  goto ldv_66081;
  ldv_66080: ;
#line 423
  if ((unsigned long )*(req->outstanding_cmds + (unsigned long )handle) == (unsigned long )sp) {
#line 424
    goto ldv_66079;
  } else {

  }
#line 422
  handle = handle + 1U;
  ldv_66081: ;
#line 422
  if ((uint32_t )req->num_outstanding_cmds > handle) {
#line 424
    goto ldv_66080;
  } else {

  }
  ldv_66079: 
#line 426
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 427
  if ((uint32_t )req->num_outstanding_cmds == handle) {
#line 429
    return (258);
  } else {

  }
#line 431
  if ((unsigned int )sp->type == 10U) {
#line 432
    tmp___0 = qlafx00_fx_disc(vha, & (vha->hw)->mr.fcport, 255);
#line 432
    return (tmp___0);
  } else {

  }
#line 435
  tmp___1 = qla24xx_async_abort_cmd(sp);
#line 435
  return (tmp___1);
}
}
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
void qla2x00_async_login_done(struct scsi_qla_host *vha , fc_port_t *fcport , uint16_t *data ) 
{ 
  int rval ;

  {
#line 444
  switch ((int )*data) {
  case 16384: 
#line 451
  rval = qla2x00_get_port_database(vha, fcport, 0);
#line 452
  if (rval == 10) {
#line 453
    fcport->flags = fcport->flags & 4294967287U;
#line 454
    fcport->flags = fcport->flags | 2U;
#line 455
    set_bit(8L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 456
    goto ldv_66089;
  } else {

  }
#line 459
  if (rval != 0) {
#line 460
    qla2x00_post_async_logout_work(vha, fcport, (uint16_t *)0U);
#line 461
    qla2x00_post_async_login_work(vha, fcport, (uint16_t *)0U);
#line 462
    goto ldv_66089;
  } else {

  }
#line 464
  if ((fcport->flags & 4U) != 0U) {
#line 465
    qla2x00_post_async_adisc_work(vha, fcport, data);
#line 466
    goto ldv_66089;
  } else {

  }
#line 468
  qla2x00_update_fcport(vha, fcport);
#line 469
  goto ldv_66089;
  case 16389: 
#line 471
  fcport->flags = fcport->flags & 4294967287U;
#line 472
  if ((int )*(data + 1UL) & 1) {
#line 473
    set_bit(8L, (unsigned long volatile   *)(& vha->dpc_flags));
  } else {
#line 475
    qla2x00_mark_device_lost(vha, fcport, 1, 0);
  }
#line 476
  goto ldv_66089;
  case 16391: 
#line 478
  fcport->loop_id = *(data + 1UL);
#line 479
  qla2x00_post_async_logout_work(vha, fcport, (uint16_t *)0U);
#line 480
  qla2x00_post_async_login_work(vha, fcport, (uint16_t *)0U);
#line 481
  goto ldv_66089;
  case 16392: 
#line 483
  fcport->loop_id = (uint16_t )((int )fcport->loop_id + 1);
#line 484
  rval = qla2x00_find_new_loop_id(vha, fcport);
#line 485
  if (rval != 0) {
#line 486
    fcport->flags = fcport->flags & 4294967287U;
#line 487
    qla2x00_mark_device_lost(vha, fcport, 1, 0);
#line 488
    goto ldv_66089;
  } else {

  }
#line 490
  qla2x00_post_async_login_work(vha, fcport, (uint16_t *)0U);
#line 491
  goto ldv_66089;
  }
  ldv_66089: ;
#line 493
  return;
}
}
#line 497 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
void qla2x00_async_logout_done(struct scsi_qla_host *vha , fc_port_t *fcport , uint16_t *data ) 
{ 


  {
#line 500
  qla2x00_mark_device_lost(vha, fcport, 1, 0);
#line 501
  return;
}
}
#line 505 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
void qla2x00_async_adisc_done(struct scsi_qla_host *vha , fc_port_t *fcport , uint16_t *data ) 
{ 


  {
#line 508
  if ((unsigned int )*data == 16384U) {
#line 509
    qla2x00_update_fcport(vha, fcport);
#line 511
    return;
  } else {

  }
#line 515
  fcport->flags = fcport->flags & 4294967287U;
#line 516
  if ((int )*(data + 1UL) & 1) {
#line 517
    set_bit(8L, (unsigned long volatile   *)(& vha->dpc_flags));
  } else {
#line 519
    qla2x00_mark_device_lost(vha, fcport, 1, 0);
  }
#line 521
  return;
}
}
#line 529 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static int qla83xx_nic_core_fw_load(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  uint32_t idc_major_ver ;
  uint32_t idc_minor_ver ;
  uint16_t config[4U] ;
  int tmp ;
  int tmp___0 ;

  {
#line 531
  rval = 0;
#line 532
  ha = vha->hw;
#line 536
  qla83xx_idc_lock(vha, 0);
#line 541
  ha->fcoe_dev_init_timeout = 30U;
#line 542
  ha->fcoe_reset_timeout = 10U;
#line 545
  tmp = __qla83xx_set_drv_presence(vha);
#line 545
  if (tmp != 0) {
#line 546
    ql_dbg(524288U, vha, 45175, "Error while setting DRV-Presence.\n");
#line 548
    rval = 258;
#line 549
    goto exit;
  } else {

  }
#line 553
  qla83xx_reset_ownership(vha);
#line 561
  qla83xx_rd_reg(vha, 571483008U, & idc_major_ver);
#line 562
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 564
    idc_major_ver = 1U;
#line 565
    qla83xx_wr_reg(vha, 571483008U, idc_major_ver);
#line 568
    qla83xx_wr_reg(vha, 571483036U, 0U);
  } else
#line 569
  if (idc_major_ver != 1U) {
#line 574
    ql_log(1U, vha, 45181, "Failing load, idc_major_ver=%d, expected_major_ver=%d.\n",
           idc_major_ver, 1);
#line 577
    __qla83xx_clear_drv_presence(vha);
#line 578
    rval = 258;
#line 579
    goto exit;
  } else {

  }
#line 582
  qla83xx_rd_reg(vha, 571483032U, & idc_minor_ver);
#line 583
  idc_minor_ver = idc_minor_ver;
#line 584
  qla83xx_wr_reg(vha, 571483032U, idc_minor_ver);
#line 586
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 587
    memset((void *)(& config), 0, 8UL);
#line 588
    tmp___0 = qla81xx_get_port_config(vha, (uint16_t *)(& config));
#line 588
    if (tmp___0 == 0) {
#line 589
      qla83xx_wr_reg(vha, 571483012U, 3U);
    } else {

    }
  } else {

  }
#line 593
  rval = qla83xx_idc_state_handler(vha);
  exit: 
#line 596
  qla83xx_idc_unlock(vha, 0);
#line 598
  return (rval);
}
}
#line 612 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla2x00_initialize_adapter(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  int tmp ;
  bool tmp___0 ;

  {
#line 615
  ha = vha->hw;
#line 616
  req = *(ha->req_q_map);
#line 619
  vha->flags.online = 0U;
#line 620
  ha->flags.chip_reset_done = 0U;
#line 621
  vha->flags.reset_active = 0U;
#line 622
  ha->flags.pci_channel_io_perm_failure = 0U;
#line 623
  ha->flags.eeh_busy = 0U;
#line 624
  vha->qla_stats.jiffies_at_last_reset = get_jiffies_64();
#line 625
  atomic_set(& vha->loop_down_timer, 255);
#line 626
  atomic_set(& vha->loop_state, 2);
#line 627
  vha->device_flags = 2U;
#line 628
  vha->dpc_flags = 0UL;
#line 629
  vha->flags.management_server_logged_in = 0U;
#line 630
  vha->marker_needed = 0U;
#line 631
  ha->isp_abort_cnt = 0U;
#line 632
  ha->beacon_blink_led = 0U;
#line 634
  set_bit(0L, (unsigned long volatile   *)(& ha->req_qid_map));
#line 635
  set_bit(0L, (unsigned long volatile   *)(& ha->rsp_qid_map));
#line 637
  ql_dbg(1073741824U, vha, 64, "Configuring PCI space...\n");
#line 639
  rval = (*((ha->isp_ops)->pci_config))(vha);
#line 640
  if (rval != 0) {
#line 641
    ql_log(1U, vha, 68, "Unable to configure PCI space.\n");
#line 643
    return (rval);
  } else {

  }
#line 646
  (*((ha->isp_ops)->reset_chip))(vha);
#line 648
  rval = qla2xxx_get_flash_info(vha);
#line 649
  if (rval != 0) {
#line 650
    ql_log(0U, vha, 79, "Unable to validate FLASH data.\n");
#line 652
    return (rval);
  } else {

  }
#line 655
  if ((ha->device_type & 262144U) != 0U) {
#line 656
    qla8044_read_reset_template(vha);
#line 662
    if (ql2xdontresethba == 1) {
#line 663
      qla8044_set_idc_dontreset(vha);
    } else {

    }
  } else {

  }
#line 666
  (*((ha->isp_ops)->get_flash_version))(vha, (void *)req->ring);
#line 667
  ql_dbg(1073741824U, vha, 97, "Configure NVRAM parameters...\n");
#line 670
  (*((ha->isp_ops)->nvram_config))(vha);
#line 672
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 674
    ql_log(2U, vha, 119, "Masking HBA WWPN %8phN (via NVRAM).\n", (uint8_t *)(& vha->port_name));
#line 676
    return (258);
  } else {

  }
#line 679
  ql_dbg(1073741824U, vha, 120, "Verifying loaded RISC code...\n");
#line 682
  tmp = qla2x00_isp_firmware(vha);
#line 682
  if (tmp != 0) {
#line 683
    rval = (*((ha->isp_ops)->chip_diag))(vha);
#line 684
    if (rval != 0) {
#line 685
      return (rval);
    } else {

    }
#line 686
    rval = qla2x00_setup_chip(vha);
#line 687
    if (rval != 0) {
#line 688
      return (rval);
    } else {

    }
  } else {

  }
#line 691
  if ((ha->device_type & 4096U) != 0U) {
#line 692
    ha->cs84xx = qla84xx_get_chip(vha);
#line 693
    if ((unsigned long )ha->cs84xx == (unsigned long )((struct qla_chip_state_84xx *)0)) {
#line 694
      ql_log(1U, vha, 208, "Unable to configure ISP84XX.\n");
#line 696
      return (258);
    } else {

    }
  } else {

  }
#line 700
  tmp___0 = qla_ini_mode_enabled(vha);
#line 700
  if ((int )tmp___0) {
#line 701
    rval = qla2x00_init_rings(vha);
  } else {

  }
#line 703
  ha->flags.chip_reset_done = 1U;
#line 705
  if (rval == 0 && (ha->device_type & 4096U) != 0U) {
#line 707
    rval = qla84xx_init_chip(vha);
#line 708
    if (rval != 0) {
#line 709
      ql_log(1U, vha, 212, "Unable to initialize ISP84XX.\n");
#line 711
      qla84xx_put_chip(vha);
    } else {

    }
  } else {

  }
#line 716
  if ((ha->device_type & 65536U) != 0U) {
#line 717
    rval = qla83xx_nic_core_fw_load(vha);
#line 718
    if (rval != 0) {
#line 719
      ql_log(1U, vha, 292, "Error in initializing NIC Core f/w.\n");
    } else {

    }
  } else {

  }
#line 723
  if (((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || ((ha->device_type & 512U) != 0U || (ha->device_type & 1024U) != 0U)) || (ha->device_type & 4096U) != 0U) || (ha->device_type & 2048U) != 0U) {
#line 724
    qla24xx_read_fcp_prio_cfg(vha);
  } else {

  }
#line 726
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 727
    qla82xx_set_driver_version(vha, (char *)"8.07.00.18-k");
  } else {
#line 729
    qla25xx_set_driver_version(vha, (char *)"8.07.00.18-k");
  }
#line 731
  return (rval);
}
}
#line 741 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla2100_pci_config(struct scsi_qla_host *vha ) 
{ 
  uint16_t w ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  raw_spinlock_t *tmp ;
  unsigned short tmp___0 ;

  {
#line 745
  ha = vha->hw;
#line 746
  reg = & (ha->iobase)->isp;
#line 748
  pci_set_master(ha->pdev);
#line 749
  pci_try_set_mwi(ha->pdev);
#line 751
  pci_read_config_word((struct pci_dev  const  *)ha->pdev, 4, & w);
#line 752
  w = (uint16_t )((unsigned int )w | 320U);
#line 753
  pci_write_config_word((struct pci_dev  const  *)ha->pdev, 4, (int )w);
#line 755
  pci_disable_rom(ha->pdev);
#line 758
  tmp = spinlock_check(& ha->hardware_lock);
#line 758
  flags = _raw_spin_lock_irqsave(tmp);
#line 759
  tmp___0 = readw((void const volatile   *)(& reg->ctrl_status));
#line 759
  ha->pci_attr = (uint32_t )tmp___0;
#line 760
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 762
  return (0);
}
}
#line 772 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla2300_pci_config(struct scsi_qla_host *vha ) 
{ 
  uint16_t w ;
  unsigned long flags ;
  uint32_t cnt ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  raw_spinlock_t *tmp ;
  unsigned short tmp___0 ;
  unsigned short tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  unsigned short tmp___3 ;

  {
#line 775
  flags = 0UL;
#line 777
  ha = vha->hw;
#line 778
  reg = & (ha->iobase)->isp;
#line 780
  pci_set_master(ha->pdev);
#line 781
  pci_try_set_mwi(ha->pdev);
#line 783
  pci_read_config_word((struct pci_dev  const  *)ha->pdev, 4, & w);
#line 784
  w = (uint16_t )((unsigned int )w | 320U);
#line 786
  if ((ha->device_type & 16U) != 0U || (ha->device_type & 64U) != 0U) {
#line 787
    w = (unsigned int )w & 64511U;
  } else {

  }
#line 788
  pci_write_config_word((struct pci_dev  const  *)ha->pdev, 4, (int )w);
#line 797
  if ((ha->device_type & 4U) != 0U) {
#line 798
    tmp = spinlock_check(& ha->hardware_lock);
#line 798
    flags = _raw_spin_lock_irqsave(tmp);
#line 801
    writew(8192, (void volatile   *)(& reg->hccr));
#line 802
    cnt = 0U;
#line 802
    goto ldv_66141;
    ldv_66140: 
#line 803
    tmp___0 = readw((void const volatile   *)(& reg->hccr));
#line 803
    if (((int )tmp___0 & 32) != 0) {
#line 804
      goto ldv_66139;
    } else {

    }
#line 806
    __const_udelay(42950UL);
#line 802
    cnt = cnt + 1U;
    ldv_66141: ;
#line 802
    if (cnt <= 29999U) {
#line 804
      goto ldv_66140;
    } else {

    }
    ldv_66139: 
#line 810
    writew(32, (void volatile   *)(& reg->ctrl_status));
#line 811
    readw((void const volatile   *)(& reg->ctrl_status));
#line 814
    ha->fb_rev = readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->fb_cmd_2100 : & reg->u.isp2300.fb_cmd));
#line 816
    if ((unsigned int )ha->fb_rev == 6U) {
#line 817
      pci_clear_mwi(ha->pdev);
    } else {

    }
#line 820
    writew(0, (void volatile   *)(& reg->ctrl_status));
#line 821
    readw((void const volatile   *)(& reg->ctrl_status));
#line 824
    writew(12288, (void volatile   *)(& reg->hccr));
#line 825
    cnt = 0U;
#line 825
    goto ldv_66144;
    ldv_66143: 
#line 826
    tmp___1 = readw((void const volatile   *)(& reg->hccr));
#line 826
    if (((int )tmp___1 & 32) == 0) {
#line 827
      goto ldv_66142;
    } else {

    }
#line 829
    __const_udelay(42950UL);
#line 825
    cnt = cnt + 1U;
    ldv_66144: ;
#line 825
    if (cnt <= 29999U) {
#line 827
      goto ldv_66143;
    } else {

    }
    ldv_66142: 
#line 832
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
  } else {

  }
#line 835
  pci_write_config_byte((struct pci_dev  const  *)ha->pdev, 13, 128);
#line 837
  pci_disable_rom(ha->pdev);
#line 840
  tmp___2 = spinlock_check(& ha->hardware_lock);
#line 840
  flags = _raw_spin_lock_irqsave(tmp___2);
#line 841
  tmp___3 = readw((void const volatile   *)(& reg->ctrl_status));
#line 841
  ha->pci_attr = (uint32_t )tmp___3;
#line 842
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 844
  return (0);
}
}
#line 854 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla24xx_pci_config(scsi_qla_host_t *vha ) 
{ 
  uint16_t w ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  int tmp ;
  bool tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
#line 857
  flags = 0UL;
#line 858
  ha = vha->hw;
#line 859
  reg = & (ha->iobase)->isp24;
#line 861
  pci_set_master(ha->pdev);
#line 862
  pci_try_set_mwi(ha->pdev);
#line 864
  pci_read_config_word((struct pci_dev  const  *)ha->pdev, 4, & w);
#line 865
  w = (uint16_t )((unsigned int )w | 320U);
#line 866
  w = (unsigned int )w & 64511U;
#line 867
  pci_write_config_word((struct pci_dev  const  *)ha->pdev, 4, (int )w);
#line 869
  pci_write_config_byte((struct pci_dev  const  *)ha->pdev, 13, 128);
#line 872
  tmp = pci_find_capability(ha->pdev, 7);
#line 872
  if (tmp != 0) {
#line 873
    pcix_set_mmrbc(ha->pdev, 2048);
  } else {

  }
#line 876
  tmp___0 = pci_is_pcie(ha->pdev);
#line 876
  if ((int )tmp___0) {
#line 877
    pcie_set_readrq(ha->pdev, 4096);
  } else {

  }
#line 879
  pci_disable_rom(ha->pdev);
#line 881
  ha->chip_revision = (uint16_t )(ha->pdev)->revision;
#line 884
  tmp___1 = spinlock_check(& ha->hardware_lock);
#line 884
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 885
  ha->pci_attr = readl((void const volatile   *)(& reg->ctrl_status));
#line 886
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 888
  return (0);
}
}
#line 898 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla25xx_pci_config(scsi_qla_host_t *vha ) 
{ 
  uint16_t w ;
  struct qla_hw_data *ha ;
  bool tmp ;

  {
#line 901
  ha = vha->hw;
#line 903
  pci_set_master(ha->pdev);
#line 904
  pci_try_set_mwi(ha->pdev);
#line 906
  pci_read_config_word((struct pci_dev  const  *)ha->pdev, 4, & w);
#line 907
  w = (uint16_t )((unsigned int )w | 320U);
#line 908
  w = (unsigned int )w & 64511U;
#line 909
  pci_write_config_word((struct pci_dev  const  *)ha->pdev, 4, (int )w);
#line 912
  tmp = pci_is_pcie(ha->pdev);
#line 912
  if ((int )tmp) {
#line 913
    pcie_set_readrq(ha->pdev, 4096);
  } else {

  }
#line 915
  pci_disable_rom(ha->pdev);
#line 917
  ha->chip_revision = (uint16_t )(ha->pdev)->revision;
#line 919
  return (0);
}
}
#line 929 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static int qla2x00_isp_firmware(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  uint16_t loop_id ;
  uint16_t topo ;
  uint16_t sw_cap ;
  uint8_t domain ;
  uint8_t area ;
  uint8_t al_pa ;
  struct qla_hw_data *ha ;

  {
#line 934
  ha = vha->hw;
#line 937
  rval = 258;
#line 939
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 940
    ql_log(2U, vha, 121, "RISC CODE NOT loaded.\n");
#line 943
    rval = qla2x00_verify_checksum(vha, ha->fw_srisc_address);
#line 944
    if (rval == 0) {
#line 946
      rval = qla2x00_get_adapter_id(vha, & loop_id, & al_pa, & area, & domain, & topo,
                                    & sw_cap);
    } else {

    }
  } else {

  }
#line 951
  if (rval != 0) {
#line 952
    ql_dbg(1073741824U, vha, 122, "**** Load RISC code ****.\n");
  } else {

  }
#line 955
  return (rval);
}
}
#line 965 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
void qla2x00_reset_chip(struct scsi_qla_host *vha ) 
{ 
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  uint32_t cnt ;
  uint16_t cmd ;
  int tmp ;
  long tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  unsigned short tmp___2 ;
  unsigned short tmp___3 ;
  unsigned short tmp___4 ;
  unsigned short tmp___5 ;

  {
#line 967
  flags = 0UL;
#line 968
  ha = vha->hw;
#line 969
  reg = & (ha->iobase)->isp;
#line 973
  tmp = pci_channel_offline(ha->pdev);
#line 973
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 973
  if (tmp___0 != 0L) {
#line 974
    return;
  } else {

  }
#line 976
  (*((ha->isp_ops)->disable_intrs))(ha);
#line 978
  tmp___1 = spinlock_check(& ha->hardware_lock);
#line 978
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 981
  cmd = 0U;
#line 982
  pci_read_config_word((struct pci_dev  const  *)ha->pdev, 4, & cmd);
#line 983
  cmd = (unsigned int )cmd & 65531U;
#line 984
  pci_write_config_word((struct pci_dev  const  *)ha->pdev, 4, (int )cmd);
#line 986
  if ((ha->device_type & 1U) == 0U) {
#line 988
    writew(8192, (void volatile   *)(& reg->hccr));
#line 989
    if ((ha->device_type & 2U) != 0U || (ha->device_type & 4U) != 0U) {
#line 990
      cnt = 0U;
#line 990
      goto ldv_66187;
      ldv_66186: 
#line 991
      tmp___2 = readw((void const volatile   *)(& reg->hccr));
#line 991
      if (((int )tmp___2 & 32) != 0) {
#line 993
        goto ldv_66185;
      } else {

      }
#line 994
      __const_udelay(429500UL);
#line 990
      cnt = cnt + 1U;
      ldv_66187: ;
#line 990
      if (cnt <= 29999U) {
#line 992
        goto ldv_66186;
      } else {

      }
      ldv_66185: ;
    } else {
#line 997
      readw((void const volatile   *)(& reg->hccr));
#line 998
      __const_udelay(42950UL);
    }
#line 1002
    writew(32, (void volatile   *)(& reg->ctrl_status));
#line 1003
    readw((void const volatile   *)(& reg->ctrl_status));
#line 1006
    writew(256, (void volatile   *)(& reg->fpm_diag_config));
#line 1007
    readw((void const volatile   *)(& reg->fpm_diag_config));
#line 1010
    if ((ha->device_type & 2U) == 0U) {
#line 1011
      writew(0, (void volatile   *)(& reg->fpm_diag_config));
#line 1012
      readw((void const volatile   *)(& reg->fpm_diag_config));
    } else {

    }
#line 1016
    writew(16, (void volatile   *)(& reg->ctrl_status));
#line 1017
    readw((void const volatile   *)(& reg->ctrl_status));
#line 1020
    if ((ha->device_type & 2U) != 0U) {
#line 1021
      writew(40960, (void volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->fb_cmd_2100 : & reg->u.isp2300.fb_cmd));
#line 1022
      readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->fb_cmd_2100 : & reg->u.isp2300.fb_cmd));
    } else {
#line 1024
      writew(252, (void volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->fb_cmd_2100 : & reg->u.isp2300.fb_cmd));
#line 1027
      cnt = 0U;
#line 1027
      goto ldv_66190;
      ldv_66189: 
#line 1028
      tmp___3 = readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->fb_cmd_2100 : & reg->u.isp2300.fb_cmd));
#line 1028
      if (((int )tmp___3 & 255) == 0) {
#line 1029
        goto ldv_66188;
      } else {

      }
#line 1030
      __const_udelay(429500UL);
#line 1027
      cnt = cnt + 1U;
      ldv_66190: ;
#line 1027
      if (cnt <= 2999U) {
#line 1029
        goto ldv_66189;
      } else {

      }
      ldv_66188: ;
    }
#line 1035
    writew(0, (void volatile   *)(& reg->ctrl_status));
#line 1036
    readw((void const volatile   *)(& reg->ctrl_status));
#line 1039
    writew(4096, (void volatile   *)(& reg->hccr));
#line 1040
    readw((void const volatile   *)(& reg->hccr));
#line 1043
    writew(12288, (void volatile   *)(& reg->hccr));
#line 1044
    readw((void const volatile   *)(& reg->hccr));
  } else {

  }
#line 1047
  writew(28672, (void volatile   *)(& reg->hccr));
#line 1048
  writew(24576, (void volatile   *)(& reg->hccr));
#line 1051
  writew(1, (void volatile   *)(& reg->ctrl_status));
#line 1054
  if (((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) || (ha->device_type & 4U) != 0U) {
#line 1060
    __const_udelay(85900UL);
#line 1061
    cnt = 30000U;
#line 1061
    goto ldv_66193;
    ldv_66192: 
#line 1062
    tmp___4 = readw((void const volatile   *)(& reg->ctrl_status));
#line 1062
    if (((int )tmp___4 & 1) == 0) {
#line 1064
      goto ldv_66191;
    } else {

    }
#line 1065
    __const_udelay(429500UL);
#line 1061
    cnt = cnt - 1U;
    ldv_66193: ;
#line 1061
    if (cnt != 0U) {
#line 1063
      goto ldv_66192;
    } else {

    }
    ldv_66191: ;
  } else {
#line 1068
    __const_udelay(42950UL);
  }
#line 1071
  writew(4096, (void volatile   *)(& reg->hccr));
#line 1073
  writew(0, (void volatile   *)(& reg->semaphore));
#line 1076
  writew(12288, (void volatile   *)(& reg->hccr));
#line 1077
  readw((void const volatile   *)(& reg->hccr));
#line 1079
  if (((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) || (ha->device_type & 4U) != 0U) {
#line 1080
    cnt = 0U;
#line 1080
    goto ldv_66196;
    ldv_66195: 
#line 1081
    tmp___5 = readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 : & reg->u.isp2300.mailbox0));
#line 1081
    if ((unsigned int )tmp___5 != 4U) {
#line 1082
      goto ldv_66194;
    } else {

    }
#line 1084
    __const_udelay(429500UL);
#line 1080
    cnt = cnt + 1U;
    ldv_66196: ;
#line 1080
    if (cnt <= 29999U) {
#line 1082
      goto ldv_66195;
    } else {

    }
    ldv_66194: ;
  } else {
#line 1087
    __const_udelay(429500UL);
  }
#line 1090
  cmd = (uint16_t )((unsigned int )cmd | 4U);
#line 1091
  pci_write_config_word((struct pci_dev  const  *)ha->pdev, 4, (int )cmd);
#line 1094
  if ((ha->device_type & 1U) == 0U) {
#line 1095
    writew(16385, (void volatile   *)(& reg->hccr));
#line 1096
    readw((void const volatile   *)(& reg->hccr));
  } else {

  }
#line 1099
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1100
  return;
}
}
#line 1108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static int qla81xx_reset_mpi(scsi_qla_host_t *vha ) 
{ 
  uint16_t mb[4U] ;
  int tmp ;

  {
#line 1110
  mb[0] = 4112U;
#line 1110
  mb[1] = 0U;
#line 1110
  mb[2] = 1U;
#line 1110
  mb[3] = 0U;
#line 1112
  if (((vha->hw)->device_type & 8192U) == 0U) {
#line 1113
    return (0);
  } else {

  }
#line 1115
  tmp = qla81xx_write_mpi_register(vha, (uint16_t *)(& mb));
#line 1115
  return (tmp);
}
}
#line 1125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
__inline static int qla24xx_reset_risc(scsi_qla_host_t *vha ) 
{ 
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  uint32_t cnt ;
  uint32_t d2 ;
  uint16_t wd ;
  int abts_cnt ;
  int rval ;
  raw_spinlock_t *tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned short tmp___5 ;
  unsigned short tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned short tmp___15 ;
  unsigned short tmp___16 ;
  unsigned short tmp___17 ;
  unsigned int tmp___18 ;

  {
#line 1127
  flags = 0UL;
#line 1128
  ha = vha->hw;
#line 1129
  reg = & (ha->iobase)->isp24;
#line 1133
  rval = 0;
#line 1135
  tmp = spinlock_check(& ha->hardware_lock);
#line 1135
  flags = _raw_spin_lock_irqsave(tmp);
#line 1138
  writel(65584U, (void volatile   *)(& reg->ctrl_status));
#line 1139
  cnt = 0U;
#line 1139
  goto ldv_66217;
  ldv_66216: 
#line 1140
  tmp___0 = readl((void const volatile   *)(& reg->ctrl_status));
#line 1140
  if ((tmp___0 & 131072U) == 0U) {
#line 1141
    goto ldv_66215;
  } else {

  }
#line 1143
  __const_udelay(42950UL);
#line 1139
  cnt = cnt + 1U;
  ldv_66217: ;
#line 1139
  if (cnt <= 29999U) {
#line 1141
    goto ldv_66216;
  } else {

  }
  ldv_66215: 
#line 1146
  tmp___1 = readl((void const volatile   *)(& reg->ctrl_status));
#line 1146
  if ((tmp___1 & 131072U) == 0U) {
#line 1147
    set_bit(1L, (unsigned long volatile   *)(& ha->fw_dump_cap_flags));
  } else {

  }
#line 1149
  tmp___2 = readl((void const volatile   *)(& reg->ctrl_status));
#line 1149
  tmp___3 = readl((void const volatile   *)(& reg->ctrl_status));
#line 1149
  tmp___4 = readl((void const volatile   *)(& reg->hccr));
#line 1149
  ql_dbg(1073774592U, vha, 382, "HCCR: 0x%x, Control Status %x, DMA active status:0x%x\n",
         tmp___4, tmp___3, tmp___2 & 131072U);
#line 1155
  writel(65585U, (void volatile   *)(& reg->ctrl_status));
#line 1157
  pci_read_config_word((struct pci_dev  const  *)ha->pdev, 4, & wd);
#line 1159
  __const_udelay(429500UL);
#line 1162
  tmp___5 = readw((void const volatile   *)(& reg->mailbox0));
#line 1162
  d2 = (unsigned int )tmp___5;
#line 1163
  cnt = 10000U;
#line 1163
  goto ldv_66219;
  ldv_66218: 
#line 1165
  __asm__  volatile   ("": : : "memory");
#line 1166
  if (cnt != 0U) {
#line 1167
    __const_udelay(21475UL);
  } else {
#line 1169
    rval = 256;
  }
#line 1164
  cnt = cnt - 1U;
  ldv_66219: 
#line 1163
  tmp___6 = readw((void const volatile   *)(& reg->mailbox0));
#line 1163
  if ((unsigned int )tmp___6 != 0U && rval == 0) {
#line 1166
    goto ldv_66218;
  } else {

  }

#line 1172
  if (rval == 0) {
#line 1173
    set_bit(6L, (unsigned long volatile   *)(& ha->fw_dump_cap_flags));
  } else {

  }
#line 1175
  tmp___7 = readl((void const volatile   *)(& reg->mailbox0));
#line 1175
  tmp___8 = readl((void const volatile   *)(& reg->hccr));
#line 1175
  ql_dbg(1073774592U, vha, 383, "HCCR: 0x%x, MailBox0 Status 0x%x\n", tmp___8, tmp___7);
#line 1181
  d2 = readl((void const volatile   *)(& reg->ctrl_status));
#line 1182
  cnt = 0U;
#line 1182
  goto ldv_66223;
  ldv_66222: 
#line 1183
  __asm__  volatile   ("": : : "memory");
#line 1184
  tmp___9 = readl((void const volatile   *)(& reg->ctrl_status));
#line 1184
  if ((tmp___9 & 1U) == 0U) {
#line 1186
    goto ldv_66221;
  } else {

  }
#line 1188
  __const_udelay(21475UL);
#line 1182
  cnt = cnt + 1U;
  ldv_66223: ;
#line 1182
  if (cnt <= 5999999U) {
#line 1184
    goto ldv_66222;
  } else {

  }
  ldv_66221: 
#line 1190
  tmp___10 = readl((void const volatile   *)(& reg->ctrl_status));
#line 1190
  if ((tmp___10 & 1U) == 0U) {
#line 1191
    set_bit(7L, (unsigned long volatile   *)(& ha->fw_dump_cap_flags));
  } else {

  }
#line 1193
  tmp___11 = readl((void const volatile   *)(& reg->ctrl_status));
#line 1193
  tmp___12 = readl((void const volatile   *)(& reg->hccr));
#line 1193
  ql_dbg(1073774592U, vha, 349, "HCCR: 0x%x, Soft Reset status: 0x%x\n", tmp___12,
         tmp___11);
#line 1199
  tmp___14 = test_and_clear_bit(19L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1199
  if (tmp___14 != 0) {
#line 1200
    tmp___13 = qla81xx_reset_mpi(vha);
#line 1200
    if (tmp___13 != 0) {
#line 1201
      abts_cnt = abts_cnt + 1;
#line 1201
      if (abts_cnt <= 4) {
#line 1202
        set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1203
        set_bit(19L, (unsigned long volatile   *)(& vha->dpc_flags));
      } else {
#line 1209
        abts_cnt = 0;
#line 1210
        vha->flags.online = 0U;
      }
    } else {

    }
  } else {

  }
#line 1215
  writel(268435456U, (void volatile   *)(& reg->hccr));
#line 1216
  readl((void const volatile   *)(& reg->hccr));
#line 1218
  writel(1073741824U, (void volatile   *)(& reg->hccr));
#line 1219
  readl((void const volatile   *)(& reg->hccr));
#line 1221
  writel(536870912U, (void volatile   *)(& reg->hccr));
#line 1222
  readl((void const volatile   *)(& reg->hccr));
#line 1224
  tmp___15 = readw((void const volatile   *)(& reg->mailbox0));
#line 1224
  d2 = (unsigned int )tmp___15;
#line 1225
  cnt = 6000000U;
#line 1225
  goto ldv_66225;
  ldv_66224: 
#line 1227
  __asm__  volatile   ("": : : "memory");
#line 1228
  if (cnt != 0U) {
#line 1229
    __const_udelay(21475UL);
  } else {
#line 1231
    rval = 256;
  }
#line 1226
  cnt = cnt - 1U;
  ldv_66225: 
#line 1225
  tmp___16 = readw((void const volatile   *)(& reg->mailbox0));
#line 1225
  if ((unsigned int )tmp___16 != 0U && rval == 0) {
#line 1228
    goto ldv_66224;
  } else {

  }

#line 1233
  if (rval == 0) {
#line 1234
    set_bit(3L, (unsigned long volatile   *)(& ha->fw_dump_cap_flags));
  } else {

  }
#line 1236
  tmp___17 = readw((void const volatile   *)(& reg->mailbox0));
#line 1236
  tmp___18 = readl((void const volatile   *)(& reg->hccr));
#line 1236
  ql_dbg(1073774592U, vha, 350, "Host Risc 0x%x, mailbox0 0x%x\n", tmp___18, (int )tmp___17);
#line 1241
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1243
  ql_dbg(1073774592U, vha, 351, "Driver in %s mode\n", (ha->device_type & 8192U) != 0U && *((unsigned long *)ha + 2UL) != 0UL ? (char *)"Interrupt" : (char *)"Polling");
#line 1247
  if ((ha->device_type & 8192U) != 0U && *((unsigned long *)ha + 2UL) != 0UL) {
#line 1248
    (*((ha->isp_ops)->enable_intrs))(ha);
  } else {

  }
#line 1250
  return (rval);
}
}
#line 1254 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static void qla25xx_read_risc_sema_reg(scsi_qla_host_t *vha , uint32_t *data ) 
{ 
  struct device_reg_24xx *reg ;

  {
#line 1256
  reg = & ((vha->hw)->iobase)->isp24;
#line 1258
  writel(28688U, (void volatile   *)(& reg->iobase_addr));
#line 1259
  *data = readl((void const volatile   *)(& reg->iobase_window) + 6U);
#line 1260
  return;
}
}
#line 1264 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static void qla25xx_write_risc_sema_reg(scsi_qla_host_t *vha , uint32_t data ) 
{ 
  struct device_reg_24xx *reg ;

  {
#line 1266
  reg = & ((vha->hw)->iobase)->isp24;
#line 1268
  writel(28688U, (void volatile   *)(& reg->iobase_addr));
#line 1269
  writel(data, (void volatile   *)(& reg->iobase_window) + 6U);
#line 1270
  return;
}
}
#line 1273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static void qla25xx_manipulate_risc_semaphore(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t wd32 ;
  uint delta_msec ;
  uint elapsed_msec ;
  uint timeout_msec ;
  ulong n ;
  ulong tmp ;
  ulong tmp___0 ;

  {
#line 1275
  ha = vha->hw;
#line 1276
  wd32 = 0U;
#line 1277
  delta_msec = 100U;
#line 1278
  elapsed_msec = 0U;
#line 1282
  if ((ha->device_type & 2048U) == 0U && (ha->device_type & 32768U) == 0U) {
#line 1283
    return;
  } else {

  }
  attempt: 
#line 1286
  timeout_msec = 2500U;
#line 1287
  n = (ulong )(timeout_msec / delta_msec);
#line 1288
  goto ldv_66250;
  ldv_66249: 
#line 1289
  qla25xx_write_risc_sema_reg(vha, 65537U);
#line 1290
  qla25xx_read_risc_sema_reg(vha, & wd32);
#line 1291
  if ((int )wd32 & 1) {
#line 1292
    goto ldv_66247;
  } else {

  }
#line 1293
  msleep(delta_msec);
#line 1294
  elapsed_msec = elapsed_msec + delta_msec;
#line 1295
  if (elapsed_msec > 4500U) {
#line 1296
    goto force;
  } else {

  }
  ldv_66250: 
#line 1288
  tmp = n;
#line 1288
  n = n - 1UL;
#line 1288
  if (tmp != 0UL) {
#line 1290
    goto ldv_66249;
  } else {

  }
  ldv_66247: ;
#line 1299
  if (((unsigned long )wd32 & 1UL) == 0UL) {
#line 1300
    goto force;
  } else {

  }
#line 1302
  if (((unsigned long )wd32 & 32768UL) == 0UL) {
#line 1303
    goto acquired;
  } else {

  }
#line 1305
  qla25xx_write_risc_sema_reg(vha, 65536U);
#line 1306
  timeout_msec = 2000U;
#line 1307
  n = (ulong )(timeout_msec / delta_msec);
#line 1308
  goto ldv_66254;
  ldv_66253: 
#line 1309
  qla25xx_read_risc_sema_reg(vha, & wd32);
#line 1310
  if (((unsigned long )wd32 & 32768UL) == 0UL) {
#line 1311
    goto ldv_66252;
  } else {

  }
#line 1312
  msleep(delta_msec);
#line 1313
  elapsed_msec = elapsed_msec + delta_msec;
#line 1314
  if (elapsed_msec > 4500U) {
#line 1315
    goto force;
  } else {

  }
  ldv_66254: 
#line 1308
  tmp___0 = n;
#line 1308
  n = n - 1UL;
#line 1308
  if (tmp___0 != 0UL) {
#line 1310
    goto ldv_66253;
  } else {

  }
  ldv_66252: ;
#line 1318
  if (((unsigned long )wd32 & 32768UL) != 0UL) {
#line 1319
    qla25xx_write_risc_sema_reg(vha, 2147483648U);
  } else {

  }
#line 1321
  goto attempt;
  force: 
#line 1324
  qla25xx_write_risc_sema_reg(vha, 2147516416U);
  acquired: ;
#line 1327
  return;
}
}
#line 1337 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
void qla24xx_reset_chip(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 1339
  ha = vha->hw;
#line 1341
  tmp = pci_channel_offline(ha->pdev);
#line 1341
  if (tmp != 0 && *((unsigned long *)ha + 2UL) != 0UL) {
#line 1343
    return;
  } else {

  }
#line 1346
  (*((ha->isp_ops)->disable_intrs))(ha);
#line 1348
  qla25xx_manipulate_risc_semaphore(vha);
#line 1351
  qla24xx_reset_risc(vha);
#line 1352
  return;
}
}
#line 1361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla2x00_chip_diag(struct scsi_qla_host *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  unsigned long flags ;
  uint16_t data ;
  uint32_t cnt ;
  uint16_t mb[5U] ;
  struct req_que *req ;
  raw_spinlock_t *tmp ;
  unsigned short tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
#line 1364
  ha = vha->hw;
#line 1365
  reg = & (ha->iobase)->isp;
#line 1366
  flags = 0UL;
#line 1370
  req = *(ha->req_q_map);
#line 1373
  rval = 258;
#line 1375
  ql_dbg(1073741824U, vha, 123, "Testing device at %lx.\n", (unsigned long )(& reg->flash_address));
#line 1378
  tmp = spinlock_check(& ha->hardware_lock);
#line 1378
  flags = _raw_spin_lock_irqsave(tmp);
#line 1381
  writew(1, (void volatile   *)(& reg->ctrl_status));
#line 1387
  __const_udelay(85900UL);
#line 1388
  data = qla2x00_debounce_register((uint16_t volatile   *)(& reg->ctrl_status));
#line 1389
  cnt = 6000000U;
#line 1389
  goto ldv_66274;
  ldv_66273: 
#line 1390
  __const_udelay(21475UL);
#line 1391
  data = readw((void const volatile   *)(& reg->ctrl_status));
#line 1392
  __asm__  volatile   ("": : : "memory");
#line 1389
  cnt = cnt - 1U;
  ldv_66274: ;
#line 1389
  if (cnt != 0U && (int )data & 1) {
#line 1391
    goto ldv_66273;
  } else {

  }

#line 1395
  if (cnt == 0U) {
#line 1396
    goto chip_diag_failed;
  } else {

  }
#line 1398
  ql_dbg(1073741824U, vha, 124, "Reset register cleared by chip reset.\n");
#line 1402
  writew(4096, (void volatile   *)(& reg->hccr));
#line 1403
  writew(12288, (void volatile   *)(& reg->hccr));
#line 1406
  if (((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) || (ha->device_type & 4U) != 0U) {
#line 1407
    data = qla2x00_debounce_register((uint16_t volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 : & reg->u.isp2300.mailbox0));
#line 1408
    cnt = 6000000U;
#line 1408
    goto ldv_66278;
    ldv_66277: 
#line 1409
    __const_udelay(21475UL);
#line 1410
    data = readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 : & reg->u.isp2300.mailbox0));
#line 1411
    __asm__  volatile   ("": : : "memory");
#line 1408
    cnt = cnt - 1U;
    ldv_66278: ;
#line 1408
    if (cnt != 0U && (unsigned int )data == 4U) {
#line 1410
      goto ldv_66277;
    } else {

    }

  } else {
#line 1414
    __const_udelay(42950UL);
  }
#line 1416
  if (cnt == 0U) {
#line 1417
    goto chip_diag_failed;
  } else {

  }
#line 1420
  ql_dbg(1073741824U, vha, 125, "Checking product Id of chip.\n");
#line 1422
  mb[1] = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 1U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 1U);
#line 1423
  mb[2] = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 2U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 2U);
#line 1424
  mb[3] = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 3U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 3U);
#line 1425
  mb[4] = qla2x00_debounce_register((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (uint16_t volatile   *)(& reg->u.isp2100.mailbox0) + 4U : (uint16_t volatile   *)(& reg->u.isp2300.mailbox0) + 4U);
#line 1426
  if (((unsigned int )mb[1] != 18771U || ((unsigned int )mb[2] != 0U && (unsigned int )mb[2] != 20512U)) || (unsigned int )mb[3] != 8224U) {
#line 1428
    ql_log(1U, vha, 98, "Wrong product ID = 0x%x,0x%x,0x%x.\n", (int )mb[1], (int )mb[2],
           (int )mb[3]);
#line 1432
    goto chip_diag_failed;
  } else {

  }
#line 1434
  ha->product_id[0] = mb[1];
#line 1435
  ha->product_id[1] = mb[2];
#line 1436
  ha->product_id[2] = mb[3];
#line 1437
  ha->product_id[3] = mb[4];
#line 1440
  if ((unsigned int )req->length > 1024U) {
#line 1441
    ha->fw_transfer_size = 65536U;
  } else {
#line 1443
    ha->fw_transfer_size = (uint32_t )req->length * 64U;
  }
#line 1446
  if ((ha->device_type & 2U) != 0U) {
#line 1446
    tmp___0 = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 7U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 7U);
#line 1446
    if ((unsigned int )tmp___0 == 4U) {
#line 1449
      ql_dbg(1073741824U, vha, 126, "Found QLA2200A Chip.\n");
#line 1451
      ha->device_type = ha->device_type | 1073741824U;
#line 1452
      ha->fw_transfer_size = 128U;
    } else {

    }
  } else {

  }
#line 1456
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1458
  ql_dbg(1073741824U, vha, 127, "Checking mailboxes.\n");
#line 1459
  rval = qla2x00_mbx_reg_test(vha);
#line 1460
  if (rval != 0) {
#line 1461
    ql_log(1U, vha, 128, "Failed mailbox send register test.\n");
  } else {
#line 1465
    rval = 0;
  }
#line 1466
  tmp___1 = spinlock_check(& ha->hardware_lock);
#line 1466
  flags = _raw_spin_lock_irqsave(tmp___1);
  chip_diag_failed: ;
#line 1469
  if (rval != 0) {
#line 1470
    ql_log(2U, vha, 129, "Chip diagnostics **** FAILED ****.\n");
  } else {

  }
#line 1473
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1475
  return (rval);
}
}
#line 1485 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla24xx_chip_diag(struct scsi_qla_host *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  struct req_que *req ;

  {
#line 1488
  ha = vha->hw;
#line 1489
  req = *(ha->req_q_map);
#line 1491
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1492
    return (0);
  } else {

  }
#line 1494
  ha->fw_transfer_size = (uint32_t )req->length * 64U;
#line 1496
  rval = qla2x00_mbx_reg_test(vha);
#line 1497
  if (rval != 0) {
#line 1498
    ql_log(1U, vha, 130, "Failed mailbox send register test.\n");
  } else {
#line 1502
    rval = 0;
  }
#line 1505
  return (rval);
}
}
#line 1509 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
void qla2x00_alloc_fw_dump(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  uint32_t dump_size ;
  uint32_t fixed_size ;
  uint32_t mem_size ;
  uint32_t req_q_size ;
  uint32_t rsp_q_size ;
  uint32_t eft_size ;
  uint32_t fce_size ;
  uint32_t mq_size ;
  dma_addr_t tc_dma ;
  void *tc ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  ulong tmp ;
  void *tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;

  {
#line 1516
  ha = vha->hw;
#line 1517
  req = *(ha->req_q_map);
#line 1518
  rsp = *(ha->rsp_q_map);
#line 1520
  if ((unsigned long )ha->fw_dump != (unsigned long )((struct qla2xxx_fw_dump *)0)) {
#line 1521
    ql_dbg(1073741824U, vha, 189, "Firmware dump already allocated.\n");
#line 1523
    return;
  } else {

  }
#line 1526
  ha->fw_dumped = 0;
#line 1527
  ha->fw_dump_cap_flags = 0UL;
#line 1528
  mq_size = 0U;
#line 1528
  fce_size = mq_size;
#line 1528
  eft_size = fce_size;
#line 1528
  mem_size = eft_size;
#line 1528
  fixed_size = mem_size;
#line 1528
  dump_size = fixed_size;
#line 1529
  rsp_q_size = 0U;
#line 1529
  req_q_size = rsp_q_size;
#line 1531
  if ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) {
#line 1532
    goto try_fce;
  } else {

  }
#line 1534
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 1535
    fixed_size = 123634U;
  } else
#line 1536
  if (((((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 16U) != 0U) || (ha->device_type & 32U) != 0U) || (ha->device_type & 64U) != 0U) {
#line 1537
    fixed_size = 136098U;
#line 1538
    mem_size = (ha->fw_memory_size + 2147414017U) * 2U;
  } else
#line 1540
  if ((ha->device_type & 134217728U) != 0U) {
#line 1541
    if ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 1542
      fixed_size = 51192U;
    } else
#line 1543
    if ((ha->device_type & 8192U) != 0U) {
#line 1544
      fixed_size = 39416U;
    } else
#line 1545
    if ((ha->device_type & 2048U) != 0U) {
#line 1546
      fixed_size = 39224U;
    } else {
#line 1548
      fixed_size = 37972U;
    }
#line 1550
    mem_size = (ha->fw_memory_size + 1072693249U) * 4U;
#line 1552
    if ((unsigned int )ha->mqenable != 0U) {
#line 1553
      if ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U) {
#line 1554
        mq_size = 524U;
      } else {

      }
#line 1559
      mq_size = ((uint32_t )ha->max_req_queues * (uint32_t )req->length) * 64U + mq_size;
#line 1561
      mq_size = ((uint32_t )ha->max_rsp_queues * (uint32_t )rsp->length) * 64U + mq_size;
    } else {

    }
#line 1564
    if ((unsigned long )ha->tgt.atio_ring != (unsigned long )((struct atio *)0)) {
#line 1565
      mq_size = (uint32_t )ha->tgt.atio_q_length * 64U + mq_size;
    } else {

    }
#line 1567
    if ((((ha->device_type & 2048U) == 0U && (ha->device_type & 8192U) == 0U) && ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U)) && ((ha->device_type & 524288U) == 0U && (ha->device_type & 1048576U) == 0U)) {
#line 1569
      goto try_eft;
    } else {

    }
    try_fce: ;
#line 1572
    if ((unsigned long )ha->fce != (unsigned long )((void *)0)) {
#line 1573
      dma_free_attrs(& (ha->pdev)->dev, 65536UL, ha->fce, ha->fce_dma, (struct dma_attrs *)0);
    } else {

    }
#line 1577
    tc = dma_zalloc_coherent(& (ha->pdev)->dev, 65536UL, & tc_dma, 208U);
#line 1579
    if ((unsigned long )tc == (unsigned long )((void *)0)) {
#line 1580
      ql_log(1U, vha, 190, "Unable to allocate (%d KB) for FCE.\n", 64);
#line 1583
      goto try_eft;
    } else {

    }
#line 1586
    rval = qla2x00_enable_fce_trace(vha, tc_dma, 64, (uint16_t *)(& ha->fce_mb), & ha->fce_bufs);
#line 1588
    if (rval != 0) {
#line 1589
      ql_log(1U, vha, 191, "Unable to initialize FCE (%d).\n", rval);
#line 1591
      dma_free_attrs(& (ha->pdev)->dev, 65536UL, tc, tc_dma, (struct dma_attrs *)0);
#line 1593
      ha->flags.fce_enabled = 0U;
#line 1594
      goto try_eft;
    } else {

    }
#line 1596
    ql_dbg(1073741824U, vha, 192, "Allocate (%d KB) for FCE...\n", 64);
#line 1599
    fce_size = 65588U;
#line 1600
    ha->flags.fce_enabled = 1U;
#line 1601
    ha->fce_dma = tc_dma;
#line 1602
    ha->fce = tc;
    try_eft: ;
#line 1605
    if ((unsigned long )ha->eft != (unsigned long )((void *)0)) {
#line 1606
      dma_free_attrs(& (ha->pdev)->dev, 65536UL, ha->eft, ha->eft_dma, (struct dma_attrs *)0);
    } else {

    }
#line 1610
    tc = dma_zalloc_coherent(& (ha->pdev)->dev, 65536UL, & tc_dma, 208U);
#line 1612
    if ((unsigned long )tc == (unsigned long )((void *)0)) {
#line 1613
      ql_log(1U, vha, 193, "Unable to allocate (%d KB) for EFT.\n", 64);
#line 1616
      goto cont_alloc;
    } else {

    }
#line 1619
    rval = qla2x00_enable_eft_trace(vha, tc_dma, 4);
#line 1620
    if (rval != 0) {
#line 1621
      ql_log(1U, vha, 194, "Unable to initialize EFT (%d).\n", rval);
#line 1623
      dma_free_attrs(& (ha->pdev)->dev, 65536UL, tc, tc_dma, (struct dma_attrs *)0);
#line 1625
      goto cont_alloc;
    } else {

    }
#line 1627
    ql_dbg(1073741824U, vha, 195, "Allocated (%d KB) EFT ...\n", 64);
#line 1630
    eft_size = 65536U;
#line 1631
    ha->eft_dma = tc_dma;
#line 1632
    ha->eft = tc;
  } else {

  }
  cont_alloc: ;
#line 1636
  if ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) {
#line 1637
    if ((unsigned long )ha->fw_dump_template == (unsigned long )((void *)0)) {
#line 1638
      ql_log(1U, vha, 186, "Failed missing fwdump template\n");
#line 1640
      return;
    } else {

    }
#line 1642
    tmp = qla27xx_fwdt_calculate_dump_size(vha);
#line 1642
    dump_size = (uint32_t )tmp;
#line 1643
    ql_dbg(1073741824U, vha, 250, "-> allocating fwdump (%x bytes)...\n", dump_size);
#line 1645
    goto allocate;
  } else {

  }
#line 1648
  req_q_size = (uint32_t )req->length * 64U;
#line 1649
  rsp_q_size = (uint32_t )rsp->length * 64U;
#line 1650
  dump_size = 72U;
#line 1651
  dump_size = ((((fixed_size + mem_size) + req_q_size) + rsp_q_size) + eft_size) + dump_size;
#line 1652
  ha->chain_offset = dump_size;
#line 1653
  dump_size = (mq_size + fce_size) + dump_size;
  allocate: 
#line 1656
  tmp___0 = vmalloc((unsigned long )dump_size);
#line 1656
  ha->fw_dump = (struct qla2xxx_fw_dump *)tmp___0;
#line 1657
  if ((unsigned long )ha->fw_dump == (unsigned long )((struct qla2xxx_fw_dump *)0)) {
#line 1658
    ql_log(1U, vha, 196, "Unable to allocate (%d KB) for firmware dump.\n", dump_size / 1024U);
#line 1662
    if ((unsigned long )ha->fce != (unsigned long )((void *)0)) {
#line 1663
      dma_free_attrs(& (ha->pdev)->dev, 65536UL, ha->fce, ha->fce_dma, (struct dma_attrs *)0);
#line 1665
      ha->fce = (void *)0;
#line 1666
      ha->fce_dma = 0ULL;
    } else {

    }
#line 1669
    if ((unsigned long )ha->eft != (unsigned long )((void *)0)) {
#line 1670
      dma_free_attrs(& (ha->pdev)->dev, (size_t )eft_size, ha->eft, ha->eft_dma, (struct dma_attrs *)0);
#line 1672
      ha->eft = (void *)0;
#line 1673
      ha->eft_dma = 0ULL;
    } else {

    }
#line 1675
    return;
  } else {

  }
#line 1677
  ha->fw_dump_len = dump_size;
#line 1678
  ql_dbg(1073741824U, vha, 197, "Allocated (%d KB) for firmware dump.\n", dump_size / 1024U);
#line 1681
  if ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) {
#line 1682
    return;
  } else {

  }
#line 1684
  (ha->fw_dump)->signature[0] = 81U;
#line 1685
  (ha->fw_dump)->signature[1] = 76U;
#line 1686
  (ha->fw_dump)->signature[2] = 71U;
#line 1687
  (ha->fw_dump)->signature[3] = 67U;
#line 1688
  (ha->fw_dump)->version = 16777216U;
#line 1690
  tmp___1 = __fswab32(fixed_size);
#line 1690
  (ha->fw_dump)->fixed_size = tmp___1;
#line 1691
  tmp___2 = __fswab32(mem_size);
#line 1691
  (ha->fw_dump)->mem_size = tmp___2;
#line 1692
  tmp___3 = __fswab32(req_q_size);
#line 1692
  (ha->fw_dump)->req_q_size = tmp___3;
#line 1693
  tmp___4 = __fswab32(rsp_q_size);
#line 1693
  (ha->fw_dump)->rsp_q_size = tmp___4;
#line 1695
  tmp___5 = __fswab32(eft_size);
#line 1695
  (ha->fw_dump)->eft_size = tmp___5;
#line 1696
  tmp___6 = __fswab32((unsigned int )ha->eft_dma);
#line 1696
  (ha->fw_dump)->eft_addr_l = tmp___6;
#line 1697
  tmp___7 = __fswab32((unsigned int )(ha->eft_dma >> 32ULL));
#line 1697
  (ha->fw_dump)->eft_addr_h = tmp___7;
#line 1699
  (ha->fw_dump)->header_size = 1207959552U;
#line 1700
  return;
}
}
#line 1704 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static int qla81xx_mpi_sync(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  uint16_t dc ;
  uint32_t dw ;

  {
#line 1711
  if (((vha->hw)->device_type & 8192U) == 0U) {
#line 1712
    return (0);
  } else {

  }
#line 1714
  rval = qla2x00_write_ram_word(vha, 31744U, 1U);
#line 1715
  if (rval != 0) {
#line 1716
    ql_log(1U, vha, 261, "Unable to acquire semaphore.\n");
#line 1718
    goto done;
  } else {

  }
#line 1721
  pci_read_config_word((struct pci_dev  const  *)(vha->hw)->pdev, 84, & dc);
#line 1722
  rval = qla2x00_read_ram_word(vha, 31253U, & dw);
#line 1723
  if (rval != 0) {
#line 1724
    ql_log(1U, vha, 103, "Unable to read sync.\n");
#line 1725
    goto done_release;
  } else {

  }
#line 1728
  dc = (unsigned int )dc & 224U;
#line 1729
  if ((uint32_t )dc == (dw & 224U)) {
#line 1730
    goto done_release;
  } else {

  }
#line 1732
  dw = dw & 4294967071U;
#line 1733
  dw = (uint32_t )dc | dw;
#line 1734
  rval = qla2x00_write_ram_word(vha, 31253U, dw);
#line 1735
  if (rval != 0) {
#line 1736
    ql_log(1U, vha, 276, "Unable to gain sync.\n");
  } else {

  }
  done_release: 
#line 1740
  rval = qla2x00_write_ram_word(vha, 31744U, 0U);
#line 1741
  if (rval != 0) {
#line 1742
    ql_log(1U, vha, 109, "Unable to release semaphore.\n");
  } else {

  }
  done: ;
#line 1747
  return (rval);
}
}
#line 1751 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla2x00_alloc_outstanding_cmds(struct qla_hw_data *ha , struct req_que *req ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 1754
  if ((unsigned long )req->outstanding_cmds != (unsigned long )((srb_t **)0)) {
#line 1755
    return (0);
  } else {

  }
#line 1757
  if ((ha->device_type & 134217728U) == 0U || ((unsigned long )ha->mqiobase != (unsigned long )((device_reg_t *)0) && (ql2xmultique_tag != 0 || ql2xmaxqueues > 1))) {
#line 1759
    req->num_outstanding_cmds = 1024U;
  } else
#line 1761
  if ((int )ha->fw_xcb_count <= (int )ha->fw_iocb_count) {
#line 1762
    req->num_outstanding_cmds = ha->fw_xcb_count;
  } else {
#line 1764
    req->num_outstanding_cmds = ha->fw_iocb_count;
  }
#line 1767
  tmp = kzalloc((unsigned long )req->num_outstanding_cmds * 8UL, 208U);
#line 1767
  req->outstanding_cmds = (srb_t **)tmp;
#line 1770
  if ((unsigned long )req->outstanding_cmds == (unsigned long )((srb_t **)0)) {
#line 1775
    req->num_outstanding_cmds = 128U;
#line 1776
    tmp___0 = kzalloc((unsigned long )req->num_outstanding_cmds * 8UL, 208U);
#line 1776
    req->outstanding_cmds = (srb_t **)tmp___0;
#line 1779
    if ((unsigned long )req->outstanding_cmds == (unsigned long )((srb_t **)0)) {
#line 1780
      ql_log(0U, (scsi_qla_host_t *)0, 294, "Failed to allocate memory for outstanding_cmds for req_que %p.\n",
             req);
#line 1783
      req->num_outstanding_cmds = 0U;
#line 1784
      return (258);
    } else {

    }
  } else {

  }
#line 1788
  return (0);
}
}
#line 1798 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static int qla2x00_setup_chip(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  uint32_t srisc_address ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  unsigned long flags ;
  uint16_t fw_major_version ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;
  uint32_t size ;

  {
#line 1801
  srisc_address = 0U;
#line 1802
  ha = vha->hw;
#line 1803
  reg = & (ha->iobase)->isp;
#line 1807
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1808
    rval = (*((ha->isp_ops)->load_risc))(vha, & srisc_address);
#line 1809
    if (rval == 0) {
#line 1810
      qla2x00_stop_firmware(vha);
#line 1811
      goto enable_82xx_npiv;
    } else {
#line 1813
      goto failed;
    }
  } else {

  }
#line 1816
  if (((ha->device_type & 134217728U) == 0U && (ha->device_type & 1U) == 0U) && (ha->device_type & 2U) == 0U) {
#line 1818
    tmp = spinlock_check(& ha->hardware_lock);
#line 1818
    flags = _raw_spin_lock_irqsave(tmp);
#line 1819
    writew(40960, (void volatile   *)(& reg->hccr));
#line 1820
    readw((void const volatile   *)(& reg->hccr));
#line 1821
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
  } else {

  }
#line 1824
  qla81xx_mpi_sync(vha);
#line 1827
  rval = (*((ha->isp_ops)->load_risc))(vha, & srisc_address);
#line 1828
  if (rval == 0) {
#line 1829
    ql_dbg(1073741824U, vha, 201, "Verifying Checksum of loaded RISC code.\n");
#line 1832
    rval = qla2x00_verify_checksum(vha, srisc_address);
#line 1833
    if (rval == 0) {
#line 1835
      ql_dbg(1073741824U, vha, 202, "Starting firmware.\n");
#line 1838
      rval = qla2x00_execute_fw(vha, srisc_address);
#line 1840
      if (rval == 0) {
        enable_82xx_npiv: 
#line 1842
        fw_major_version = ha->fw_major_version;
#line 1843
        if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1844
          qla82xx_check_md_needed(vha);
        } else {
#line 1846
          rval = qla2x00_get_fw_version(vha);
        }
#line 1847
        if (rval != 0) {
#line 1848
          goto failed;
        } else {

        }
#line 1849
        ha->flags.npiv_supported = 0U;
#line 1850
        if ((((((((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || (ha->device_type & 4096U) != 0U) || (ha->device_type & 2048U) != 0U) || (ha->device_type & 8192U) != 0U) || (ha->device_type & 16384U) != 0U) || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || (ha->device_type & 262144U) != 0U) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) && ((int )ha->fw_attributes & 4) != 0) {
#line 1852
          ha->flags.npiv_supported = 1U;
#line 1853
          if ((unsigned int )ha->max_npiv_vports == 0U || ((unsigned int )((int )ha->max_npiv_vports + 1) & 63U) != 0U) {
#line 1856
            ha->max_npiv_vports = 63U;
          } else {

          }
        } else {

        }
#line 1859
        qla2x00_get_resource_cnts(vha, (uint16_t *)0U, & ha->fw_xcb_count, (uint16_t *)0U,
                                  & ha->fw_iocb_count, & ha->max_npiv_vports, (uint16_t *)0U);
#line 1867
        rval = qla2x00_alloc_outstanding_cmds(ha, vha->req);
#line 1869
        if (rval != 0) {
#line 1870
          goto failed;
        } else {

        }
#line 1872
        if (((unsigned int )fw_major_version == 0U && ql2xallocfwdump != 0) && ((ha->device_type & 16384U) == 0U && (ha->device_type & 262144U) == 0U)) {
#line 1874
          qla2x00_alloc_fw_dump(vha);
        } else {

        }
      } else {
#line 1876
        goto failed;
      }
    } else {
#line 1879
      ql_log(0U, vha, 205, "ISP Firmware failed checksum.\n");
#line 1881
      goto failed;
    }
  } else {
#line 1884
    goto failed;
  }
#line 1886
  if (((ha->device_type & 134217728U) == 0U && (ha->device_type & 1U) == 0U) && (ha->device_type & 2U) == 0U) {
#line 1888
    tmp___0 = spinlock_check(& ha->hardware_lock);
#line 1888
    flags = _raw_spin_lock_irqsave(tmp___0);
#line 1889
    if ((ha->device_type & 4U) != 0U) {
#line 1891
      writew(40961, (void volatile   *)(& reg->hccr));
    } else {
#line 1894
      writew(40967, (void volatile   *)(& reg->hccr));
    }
#line 1895
    readw((void const volatile   *)(& reg->hccr));
#line 1896
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
  } else {

  }
#line 1899
  if ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) {
#line 1900
    ha->flags.fac_supported = 1U;
  } else
#line 1901
  if (rval == 0 && (((ha->device_type & 8192U) != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U))) {
#line 1904
    rval = qla81xx_fac_get_sector_size(vha, & size);
#line 1905
    if (rval == 0) {
#line 1906
      ha->flags.fac_supported = 1U;
#line 1907
      ha->fdt_block_size = size << 2;
    } else {
#line 1909
      ql_log(1U, vha, 206, "Unsupported FAC firmware (%d.%02d.%02d).\n", (int )ha->fw_major_version,
             (int )ha->fw_minor_version, (int )ha->fw_subminor_version);
#line 1914
      if (((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 1915
        ha->flags.fac_supported = 0U;
#line 1916
        rval = 0;
      } else {

      }
    }
  } else {

  }
  failed: ;
#line 1921
  if (rval != 0) {
#line 1922
    ql_log(0U, vha, 207, "Setup chip ****FAILED****.\n");
  } else {

  }
#line 1926
  return (rval);
}
}
#line 1939 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
void qla2x00_init_response_q_entries(struct rsp_que *rsp ) 
{ 
  uint16_t cnt ;
  response_t *pkt ;

  {
#line 1944
  rsp->ring_ptr = rsp->ring;
#line 1945
  rsp->ring_index = 0U;
#line 1946
  rsp->status_srb = (srb_t *)0;
#line 1947
  pkt = rsp->ring_ptr;
#line 1948
  cnt = 0U;
#line 1948
  goto ldv_66346;
  ldv_66345: 
#line 1949
  pkt->signature = 3735936685U;
#line 1950
  pkt = pkt + 1;
#line 1948
  cnt = (uint16_t )((int )cnt + 1);
  ldv_66346: ;
#line 1948
  if ((int )rsp->length > (int )cnt) {
#line 1950
    goto ldv_66345;
  } else {

  }

#line 1955
  return;
}
}
#line 1961 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
void qla2x00_update_fw_options(struct scsi_qla_host *vha ) 
{ 
  uint16_t swing ;
  uint16_t emphasis ;
  uint16_t tx_sens ;
  uint16_t rx_sens ;
  struct qla_hw_data *ha ;

  {
#line 1964
  ha = vha->hw;
#line 1966
  memset((void *)(& ha->fw_options), 0, 32UL);
#line 1967
  qla2x00_get_fw_options(vha, (uint16_t *)(& ha->fw_options));
#line 1969
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 1970
    return;
  } else {

  }
#line 1973
  ql_dbg(1073872896U, vha, 277, "Serial link options.\n");
#line 1975
  ql_dump_buffer(1073872896U, vha, 265, (uint8_t *)(& ha->fw_seriallink_options),
                 4U);
#line 1979
  ha->fw_options[1] = (unsigned int )ha->fw_options[1] & 65279U;
#line 1980
  if (((int )ha->fw_seriallink_options[3] & 4) != 0) {
#line 1981
    ha->fw_options[1] = (uint16_t )((unsigned int )ha->fw_options[1] | 256U);
#line 1984
    swing = (unsigned int )((uint16_t )ha->fw_seriallink_options[2]) & 7U;
#line 1985
    emphasis = (uint16_t )(((int )ha->fw_seriallink_options[2] & 24) >> 3);
#line 1987
    tx_sens = (unsigned int )((uint16_t )ha->fw_seriallink_options[0]) & 15U;
#line 1989
    rx_sens = (uint16_t )((int )ha->fw_seriallink_options[0] >> 4);
#line 1991
    ha->fw_options[10] = (uint16_t )((int )((short )((int )emphasis << 14)) | (int )((short )((int )swing << 8)));
#line 1992
    if (((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 32U) != 0U) {
#line 1993
      if ((unsigned int )rx_sens == 0U) {
#line 1994
        rx_sens = 3U;
      } else {

      }
#line 1995
      ha->fw_options[10] = (uint16_t )((int )((short )ha->fw_options[10]) | ((int )((short )((int )tx_sens << 4)) | (int )((short )rx_sens)));
    } else
#line 1996
    if ((ha->device_type & 16U) != 0U || (ha->device_type & 64U) != 0U) {
#line 1997
      ha->fw_options[10] = (uint16_t )((int )((short )ha->fw_options[10]) | (((int )((short )(((int )rx_sens & 3) << 2)) | 32) | ((int )((short )tx_sens) & 3)));
    } else {

    }
#line 2002
    swing = (uint16_t )((int )ha->fw_seriallink_options[2] >> 5);
#line 2004
    emphasis = (unsigned int )((uint16_t )ha->fw_seriallink_options[3]) & 3U;
#line 2005
    tx_sens = (unsigned int )((uint16_t )ha->fw_seriallink_options[1]) & 15U;
#line 2007
    rx_sens = (uint16_t )((int )ha->fw_seriallink_options[1] >> 4);
#line 2009
    ha->fw_options[11] = (uint16_t )((int )((short )((int )emphasis << 14)) | (int )((short )((int )swing << 8)));
#line 2010
    if (((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 32U) != 0U) {
#line 2011
      if ((unsigned int )rx_sens == 0U) {
#line 2012
        rx_sens = 3U;
      } else {

      }
#line 2013
      ha->fw_options[11] = (uint16_t )((int )((short )ha->fw_options[11]) | ((int )((short )((int )tx_sens << 4)) | (int )((short )rx_sens)));
    } else
#line 2014
    if ((ha->device_type & 16U) != 0U || (ha->device_type & 64U) != 0U) {
#line 2015
      ha->fw_options[11] = (uint16_t )((int )((short )ha->fw_options[11]) | (((int )((short )(((int )rx_sens & 3) << 2)) | 32) | ((int )((short )tx_sens) & 3)));
    } else {

    }
  } else {

  }
#line 2022
  ha->fw_options[3] = (uint16_t )((unsigned int )ha->fw_options[3] | 8192U);
#line 2025
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 2026
    ha->fw_options[2] = (uint16_t )((unsigned int )ha->fw_options[2] | 4096U);
  } else {

  }
#line 2029
  if ((ha->device_type & 32U) != 0U) {
#line 2030
    ha->fw_options[2] = (uint16_t )((unsigned int )ha->fw_options[2] | 8192U);
  } else {

  }
#line 2033
  qla2x00_set_fw_options(vha, (uint16_t *)(& ha->fw_options));
#line 2034
  return;
}
}
#line 2037 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
void qla24xx_update_fw_options(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;

  {
#line 2040
  ha = vha->hw;
#line 2042
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 2043
    return;
  } else {

  }
#line 2046
  if (((int )ha->fw_seriallink_options24[0] & 1) == 0) {
#line 2047
    return;
  } else {

  }
#line 2049
  rval = qla2x00_set_serdes_params(vha, (int )ha->fw_seriallink_options24[1], (int )ha->fw_seriallink_options24[2],
                                   (int )ha->fw_seriallink_options24[3]);
#line 2053
  if (rval != 0) {
#line 2054
    ql_log(1U, vha, 260, "Unable to update Serial Link options (%x).\n", rval);
  } else {

  }
#line 2056
  return;
}
}
#line 2060 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
void qla2x00_config_rings(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  struct req_que *req ;
  struct rsp_que *rsp ;

  {
#line 2062
  ha = vha->hw;
#line 2063
  reg = & (ha->iobase)->isp;
#line 2064
  req = *(ha->req_q_map);
#line 2065
  rsp = *(ha->rsp_q_map);
#line 2068
  (ha->init_cb)->request_q_outpointer = 0U;
#line 2069
  (ha->init_cb)->response_q_inpointer = 0U;
#line 2070
  (ha->init_cb)->request_q_length = req->length;
#line 2071
  (ha->init_cb)->response_q_length = rsp->length;
#line 2072
  (ha->init_cb)->request_q_address[0] = (unsigned int )req->dma;
#line 2073
  (ha->init_cb)->request_q_address[1] = (unsigned int )(req->dma >> 32ULL);
#line 2074
  (ha->init_cb)->response_q_address[0] = (unsigned int )rsp->dma;
#line 2075
  (ha->init_cb)->response_q_address[1] = (unsigned int )(rsp->dma >> 32ULL);
#line 2077
  writew(0, (void volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox4 : & reg->u.isp2300.req_q_in));
#line 2078
  writew(0, (void volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox4 : & reg->u.isp2300.req_q_out));
#line 2079
  writew(0, (void volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox5 : & reg->u.isp2300.rsp_q_in));
#line 2080
  writew(0, (void volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox5 : & reg->u.isp2300.rsp_q_out));
#line 2081
  readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox5 : & reg->u.isp2300.rsp_q_out));
#line 2082
  return;
}
}
#line 2085 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
void qla24xx_config_rings(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  device_reg_t *reg ;
  struct device_reg_2xxx *ioreg ;
  struct qla_msix_entry *msix ;
  struct init_cb_24xx *icb ;
  uint16_t rid ;
  struct req_que *req ;
  struct rsp_que *rsp ;

  {
#line 2087
  ha = vha->hw;
#line 2088
  reg = ((unsigned int )ha->mqenable != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) ? ha->mqiobase : ha->iobase;
#line 2089
  ioreg = & (ha->iobase)->isp;
#line 2092
  rid = 0U;
#line 2093
  req = *(ha->req_q_map);
#line 2094
  rsp = *(ha->rsp_q_map);
#line 2097
  icb = (struct init_cb_24xx *)ha->init_cb;
#line 2098
  icb->request_q_outpointer = 0U;
#line 2099
  icb->response_q_inpointer = 0U;
#line 2100
  icb->request_q_length = req->length;
#line 2101
  icb->response_q_length = rsp->length;
#line 2102
  icb->request_q_address[0] = (unsigned int )req->dma;
#line 2103
  icb->request_q_address[1] = (unsigned int )(req->dma >> 32ULL);
#line 2104
  icb->response_q_address[0] = (unsigned int )rsp->dma;
#line 2105
  icb->response_q_address[1] = (unsigned int )(rsp->dma >> 32ULL);
#line 2108
  icb->atio_q_inpointer = 0U;
#line 2109
  icb->atio_q_length = ha->tgt.atio_q_length;
#line 2110
  icb->atio_q_address[0] = (unsigned int )ha->tgt.atio_dma;
#line 2111
  icb->atio_q_address[1] = (unsigned int )(ha->tgt.atio_dma >> 32ULL);
#line 2113
  if ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) {
#line 2114
    icb->firmware_options_2 = icb->firmware_options_2 | 1610612736U;
  } else {

  }
#line 2117
  if (((unsigned int )ha->mqenable != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 2118
    icb->qos = 5U;
#line 2119
    icb->rid = rid;
#line 2120
    if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 2121
      msix = ha->msix_entries + 1UL;
#line 2122
      ql_dbg(1073741824U, vha, 253, "Registering vector 0x%x for base que.\n", (int )msix->entry);
#line 2125
      icb->msix = msix->entry;
    } else {

    }
#line 2128
    if ((unsigned int )((unsigned char )((int )rid >> 8)) != 0U) {
#line 2129
      icb->firmware_options_2 = icb->firmware_options_2 | 524288U;
    } else {

    }
#line 2132
    if ((unsigned int )((unsigned char )rid) != 0U) {
#line 2133
      icb->firmware_options_2 = icb->firmware_options_2 | 262144U;
    } else {

    }
#line 2137
    if ((((int )ha->fw_attributes & 64) != 0 && (((ha->device_type & 8192U) != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U))) && *((unsigned long *)ha + 2UL) != 0UL) {
#line 2139
      icb->firmware_options_2 = icb->firmware_options_2 & 4290772991U;
#line 2141
      ha->flags.disable_msix_handshake = 1U;
#line 2142
      ql_dbg(1073741824U, vha, 254, "MSIX Handshake Disable Mode turned on.\n");
    } else {
#line 2145
      icb->firmware_options_2 = icb->firmware_options_2 | 4194304U;
    }
#line 2148
    icb->firmware_options_2 = icb->firmware_options_2 | 8388608U;
#line 2150
    writel(0U, (void volatile   *)(& reg->isp25mq.req_q_in));
#line 2151
    writel(0U, (void volatile   *)(& reg->isp25mq.req_q_out));
#line 2152
    writel(0U, (void volatile   *)(& reg->isp25mq.rsp_q_in));
#line 2153
    writel(0U, (void volatile   *)(& reg->isp25mq.rsp_q_out));
  } else {
#line 2155
    writel(0U, (void volatile   *)(& reg->isp24.req_q_in));
#line 2156
    writel(0U, (void volatile   *)(& reg->isp24.req_q_out));
#line 2157
    writel(0U, (void volatile   *)(& reg->isp24.rsp_q_in));
#line 2158
    writel(0U, (void volatile   *)(& reg->isp24.rsp_q_out));
  }
#line 2160
  qlt_24xx_config_rings(vha);
#line 2163
  readl((void const volatile   *)(& ioreg->hccr));
#line 2164
  return;
}
}
#line 2176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla2x00_init_rings(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  unsigned long flags ;
  int cnt ;
  int que ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  struct mid_init_cb_24xx *mid_init_cb ;
  raw_spinlock_t *tmp ;

  {
#line 2179
  flags = 0UL;
#line 2181
  ha = vha->hw;
#line 2184
  mid_init_cb = (struct mid_init_cb_24xx *)ha->init_cb;
#line 2187
  tmp = spinlock_check(& ha->hardware_lock);
#line 2187
  flags = _raw_spin_lock_irqsave(tmp);
#line 2190
  que = 0;
#line 2190
  goto ldv_66398;
  ldv_66397: 
#line 2191
  req = *(ha->req_q_map + (unsigned long )que);
#line 2192
  if ((unsigned long )req == (unsigned long )((struct req_que *)0)) {
#line 2193
    goto ldv_66393;
  } else {

  }
#line 2194
  req->out_ptr = (uint16_t *)req->ring + (unsigned long )req->length;
#line 2195
  *(req->out_ptr) = 0U;
#line 2196
  cnt = 1;
#line 2196
  goto ldv_66395;
  ldv_66394: 
#line 2197
  *(req->outstanding_cmds + (unsigned long )cnt) = (srb_t *)0;
#line 2196
  cnt = cnt + 1;
  ldv_66395: ;
#line 2196
  if ((int )req->num_outstanding_cmds > cnt) {
#line 2198
    goto ldv_66394;
  } else {

  }
#line 2199
  req->current_outstanding_cmd = 1U;
#line 2202
  req->ring_ptr = req->ring;
#line 2203
  req->ring_index = 0U;
#line 2204
  req->cnt = req->length;
  ldv_66393: 
#line 2190
  que = que + 1;
  ldv_66398: ;
#line 2190
  if ((int )ha->max_req_queues > que) {
#line 2192
    goto ldv_66397;
  } else {

  }
#line 2207
  que = 0;
#line 2207
  goto ldv_66402;
  ldv_66401: 
#line 2208
  rsp = *(ha->rsp_q_map + (unsigned long )que);
#line 2209
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 2210
    goto ldv_66400;
  } else {

  }
#line 2211
  rsp->in_ptr = (uint16_t *)rsp->ring + (unsigned long )rsp->length;
#line 2212
  *(rsp->in_ptr) = 0U;
#line 2214
  if ((ha->device_type & 131072U) != 0U) {
#line 2215
    qlafx00_init_response_q_entries(rsp);
  } else {
#line 2217
    qla2x00_init_response_q_entries(rsp);
  }
  ldv_66400: 
#line 2207
  que = que + 1;
  ldv_66402: ;
#line 2207
  if ((int )ha->max_rsp_queues > que) {
#line 2209
    goto ldv_66401;
  } else {

  }
#line 2220
  ha->tgt.atio_ring_ptr = ha->tgt.atio_ring;
#line 2221
  ha->tgt.atio_ring_index = 0U;
#line 2223
  qlt_init_atio_q_entries(vha);
#line 2225
  (*((ha->isp_ops)->config_rings))(vha);
#line 2227
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2229
  ql_dbg(1073741824U, vha, 209, "Issue init firmware.\n");
#line 2231
  if ((ha->device_type & 131072U) != 0U) {
#line 2232
    rval = qlafx00_init_firmware(vha, (int )((uint16_t )ha->init_cb_size));
#line 2233
    goto next_check;
  } else {

  }
#line 2237
  (*((ha->isp_ops)->update_fw_options))(vha);
#line 2239
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 2240
    if ((unsigned int )ha->operating_mode == 0U && ((((ha->device_type & 8192U) == 0U && (ha->device_type & 16384U) == 0U) && (ha->device_type & 65536U) == 0U) && (ha->device_type & 262144U) == 0U)) {
#line 2241
      ha->max_npiv_vports = 63U;
    } else {

    }
#line 2242
    mid_init_cb->count = ha->max_npiv_vports;
  } else {

  }
#line 2245
  if ((ha->device_type & 134217728U) != 0U) {
#line 2246
    mid_init_cb->options = 2U;
#line 2247
    mid_init_cb->init_cb.execution_throttle = ha->fw_xcb_count;
#line 2250
    if (((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 2251
      mid_init_cb->init_cb.firmware_options_1 = mid_init_cb->init_cb.firmware_options_1 | 128U;
    } else {

    }
#line 2254
    ha->flags.fawwpn_enabled = (mid_init_cb->init_cb.firmware_options_1 & 64U) != 0U;
#line 2256
    ql_dbg(1073741824U, vha, 321, "FA-WWPN Support: %s.\n", *((unsigned long *)ha + 2UL) != 0UL ? (char *)"enabled" : (char *)"disabled");
  } else {

  }
#line 2260
  rval = qla2x00_init_firmware(vha, (int )((uint16_t )ha->init_cb_size));
  next_check: ;
#line 2262
  if (rval != 0) {
#line 2263
    ql_log(0U, vha, 210, "Init Firmware **** FAILED ****.\n");
  } else {
#line 2266
    ql_dbg(1073741824U, vha, 211, "Init Firmware -- success.\n");
  }
#line 2270
  return (rval);
}
}
#line 2280 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static int qla2x00_fw_ready(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  unsigned long wtime ;
  unsigned long mtime ;
  unsigned long cs84xx_time ;
  uint16_t min_wait ;
  uint16_t wait_time ;
  uint16_t state[6U] ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;

  {
#line 2287
  ha = vha->hw;
#line 2289
  if (((vha->hw)->device_type & 131072U) != 0U) {
#line 2290
    tmp = qlafx00_fw_ready(vha);
#line 2290
    return (tmp);
  } else {

  }
#line 2292
  rval = 0;
#line 2295
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 2296
    min_wait = 30U;
  } else {
#line 2298
    min_wait = 20U;
  }
#line 2304
  wait_time = (unsigned int )((int )((uint16_t )ha->retry_count) * (int )((uint16_t )ha->login_timeout)) + 5U;
#line 2304
  if ((int )wait_time < (int )min_wait) {
#line 2305
    wait_time = min_wait;
  } else {

  }
#line 2309
  mtime = (unsigned long )((int )min_wait * 250) + (unsigned long )jiffies;
#line 2312
  wtime = (unsigned long )((int )wait_time * 250) + (unsigned long )jiffies;
#line 2315
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 2316
    ql_log(2U, vha, 32798, "Waiting for LIP to complete.\n");
  } else {

  }
  ldv_66435: 
#line 2320
  memset((void *)(& state), -1, 12UL);
#line 2321
  rval = qla2x00_get_firmware_state(vha, (uint16_t *)(& state));
#line 2322
  if (rval == 0) {
#line 2323
    if ((unsigned int )state[0] <= 3U) {
#line 2324
      vha->device_flags = vha->device_flags & 4294967293U;
    } else {

    }
#line 2326
    if ((ha->device_type & 4096U) != 0U && (unsigned int )state[0] != 3U) {
#line 2327
      ql_dbg(4194304U, vha, 32799, "fw_state=%x 84xx=%x.\n", (int )state[0], (int )state[2]);
#line 2330
      if (((int )state[2] & 8) != 0 && ((int )state[2] & 16) != 0) {
#line 2332
        ql_dbg(4194304U, vha, 32808, "Sending verify iocb.\n");
#line 2335
        cs84xx_time = jiffies;
#line 2336
        rval = qla84xx_init_chip(vha);
#line 2337
        if (rval != 0) {
#line 2338
          ql_log(1U, vha, 32775, "Init chip failed.\n");
#line 2341
          goto ldv_66416;
        } else {

        }
#line 2345
        cs84xx_time = (unsigned long )jiffies - cs84xx_time;
#line 2346
        wtime = wtime + cs84xx_time;
#line 2347
        mtime = mtime + cs84xx_time;
#line 2348
        ql_dbg(4194304U, vha, 32776, "Increasing wait time by %ld. New time %ld.\n",
               cs84xx_time, wtime);
      } else {

      }
    } else
#line 2353
    if ((unsigned int )state[0] == 3U) {
#line 2354
      ql_dbg(4194304U, vha, 32823, "F/W Ready - OK.\n");
#line 2357
      qla2x00_get_retry_cnt(vha, & ha->retry_count, & ha->login_timeout, & ha->r_a_tov);
#line 2360
      rval = 0;
#line 2361
      goto ldv_66416;
    } else {

    }
#line 2364
    rval = 258;
#line 2366
    tmp___0 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 2366
    if (tmp___0 != 0 && (unsigned int )state[0] != 3U) {
#line 2371
      if ((long )((unsigned long )jiffies - mtime) >= 0L) {
#line 2372
        ql_log(2U, vha, 32824, "Cable is unplugged...\n");
#line 2375
        vha->device_flags = vha->device_flags | 2U;
#line 2376
        goto ldv_66416;
      } else {

      }
    } else {

    }
  } else
#line 2381
  if ((long )((unsigned long )jiffies - mtime) >= 0L || *((unsigned long *)ha + 2UL) != 0UL) {
#line 2383
    goto ldv_66416;
  } else {

  }
#line 2386
  if ((long )((unsigned long )jiffies - wtime) >= 0L) {
#line 2387
    goto ldv_66416;
  } else {

  }
#line 2390
  msleep(500U);
#line 2391
  goto ldv_66435;
  ldv_66416: 
#line 2393
  ql_dbg(4194304U, vha, 32826, "fw_state=%x (%x, %x, %x, %x %x) curr time=%lx.\n",
         (int )state[0], (int )state[1], (int )state[2], (int )state[3], (int )state[4],
         (int )state[5], jiffies);
#line 2397
  if (rval != 0 && (vha->device_flags & 2U) == 0U) {
#line 2398
    ql_log(1U, vha, 32827, "Firmware ready **** FAILED ****.\n");
  } else {

  }
#line 2402
  return (rval);
}
}
#line 2419 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static int qla2x00_configure_hba(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  uint16_t loop_id ;
  uint16_t topo ;
  uint16_t sw_cap ;
  uint8_t al_pa ;
  uint8_t area ;
  uint8_t domain ;
  char connect_type[22U] ;
  struct qla_hw_data *ha ;
  unsigned long flags ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  raw_spinlock_t *tmp___5 ;

  {
#line 2429
  ha = vha->hw;
#line 2431
  tmp = pci_get_drvdata(ha->pdev);
#line 2431
  base_vha = (scsi_qla_host_t *)tmp;
#line 2434
  rval = qla2x00_get_adapter_id(vha, & loop_id, & al_pa, & area, & domain, & topo,
                                & sw_cap);
#line 2436
  if (rval != 0) {
#line 2437
    tmp___1 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 2437
    if (tmp___1 != 0) {
#line 2440
      ql_dbg(268435456U, vha, 8200, "Loop is in a transition state.\n");
    } else {
#line 2437
      tmp___2 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 2437
      if (tmp___2 != 0) {
#line 2440
        ql_dbg(268435456U, vha, 8200, "Loop is in a transition state.\n");
      } else {
#line 2437
        tmp___3 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 2437
        if (tmp___3 == 2) {
#line 2440
          ql_dbg(268435456U, vha, 8200, "Loop is in a transition state.\n");
        } else {
#line 2437
          tmp___4 = atomic_read((atomic_t const   *)(& ha->loop_down_timer));
#line 2437
          if (tmp___4 != 0) {
#line 2440
            ql_dbg(268435456U, vha, 8200, "Loop is in a transition state.\n");
          } else
#line 2437
          if ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 2440
            ql_dbg(268435456U, vha, 8200, "Loop is in a transition state.\n");
          } else
#line 2437
          if (rval == 5 && (unsigned int )loop_id == 7U) {
#line 2440
            ql_dbg(268435456U, vha, 8200, "Loop is in a transition state.\n");
          } else {
#line 2443
            ql_log(1U, vha, 8201, "Unable to get host loop ID.\n");
#line 2445
            if (((ha->device_type & 134217728U) != 0U && (unsigned long )vha == (unsigned long )base_vha) && (rval == 5 && (unsigned int )loop_id == 27U)) {
#line 2447
              ql_log(1U, vha, 4433, "Doing link init.\n");
#line 2449
              tmp___0 = qla24xx_link_initialize(vha);
#line 2449
              if (tmp___0 == 0) {
#line 2450
                return (rval);
              } else {

              }
            } else {

            }
#line 2452
            set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
          }
        }
      }
    }
#line 2454
    return (rval);
  } else {

  }
#line 2457
  if ((unsigned int )topo == 4U) {
#line 2458
    ql_log(2U, vha, 8202, "Cannot get topology - retrying.\n");
#line 2460
    return (258);
  } else {

  }
#line 2463
  vha->loop_id = loop_id;
#line 2466
  ha->min_external_loopid = 129U;
#line 2467
  ha->operating_mode = 0U;
#line 2468
  ha->switch_cap = 0U;
#line 2470
  switch ((int )topo) {
  case 0: 
#line 2472
  ql_dbg(268435456U, vha, 8203, "HBA in NL topology.\n");
#line 2473
  ha->current_topology = 1U;
#line 2474
  strcpy((char *)(& connect_type), "(Loop)");
#line 2475
  goto ldv_66451;
  case 1: 
#line 2478
  ql_dbg(268435456U, vha, 8204, "HBA in FL topology.\n");
#line 2479
  ha->switch_cap = sw_cap;
#line 2480
  ha->current_topology = 4U;
#line 2481
  strcpy((char *)(& connect_type), "(FL_Port)");
#line 2482
  goto ldv_66451;
  case 2: 
#line 2485
  ql_dbg(268435456U, vha, 8205, "HBA in N P2P topology.\n");
#line 2486
  ha->operating_mode = 1U;
#line 2487
  ha->current_topology = 2U;
#line 2488
  strcpy((char *)(& connect_type), "(N_Port-to-N_Port)");
#line 2489
  goto ldv_66451;
  case 3: 
#line 2492
  ql_dbg(268435456U, vha, 8206, "HBA in F P2P topology.\n");
#line 2493
  ha->switch_cap = sw_cap;
#line 2494
  ha->operating_mode = 1U;
#line 2495
  ha->current_topology = 8U;
#line 2496
  strcpy((char *)(& connect_type), "(F_Port)");
#line 2497
  goto ldv_66451;
  default: 
#line 2500
  ql_dbg(268435456U, vha, 8207, "HBA in unknown topology %x, using NL.\n", (int )topo);
#line 2502
  ha->current_topology = 1U;
#line 2503
  strcpy((char *)(& connect_type), "(Loop)");
#line 2504
  goto ldv_66451;
  }
  ldv_66451: 
#line 2509
  vha->d_id.b.domain = domain;
#line 2510
  vha->d_id.b.area = area;
#line 2511
  vha->d_id.b.al_pa = al_pa;
#line 2513
  tmp___5 = spinlock_check(& ha->vport_slock);
#line 2513
  flags = _raw_spin_lock_irqsave(tmp___5);
#line 2514
  qlt_update_vp_map(vha, 2);
#line 2515
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 2517
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 2518
    ql_log(2U, vha, 8208, "Topology - %s, Host Loop address 0x%x.\n", (char *)(& connect_type),
           (int )vha->loop_id);
  } else {

  }
#line 2522
  return (rval);
}
}
#line 2526 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
__inline void qla2x00_set_model_info(scsi_qla_host_t *vha , uint8_t *model , size_t len ,
                                     char *def ) 
{ 
  char *st ;
  char *en ;
  uint16_t index ;
  struct qla_hw_data *ha ;
  int use_tbl ;
  char *tmp ;
  int tmp___0 ;

  {
#line 2531
  ha = vha->hw;
#line 2532
  use_tbl = ((((((ha->device_type & 128U) == 0U && (ha->device_type & 256U) == 0U) && ((ha->device_type & 512U) == 0U && (ha->device_type & 1024U) == 0U)) && (ha->device_type & 4096U) == 0U) && (ha->device_type & 2048U) == 0U) && ((((ha->device_type & 8192U) == 0U && (ha->device_type & 16384U) == 0U) && (ha->device_type & 65536U) == 0U) && (ha->device_type & 262144U) == 0U)) && (ha->device_type & 32768U) == 0U;
#line 2535
  tmp___0 = memcmp((void const   *)model, (void const   *)"", len);
#line 2535
  if (tmp___0 != 0) {
#line 2536
    strncpy((char *)(& ha->model_number), (char const   *)model, len);
#line 2537
    en = (char *)(& ha->model_number);
#line 2537
    st = en;
#line 2538
    en = en + (len + 0xffffffffffffffffUL);
#line 2539
    goto ldv_66472;
    ldv_66471: ;
#line 2540
    if ((int )((signed char )*en) != 32 && (int )((signed char )*en) != 0) {
#line 2541
      goto ldv_66470;
    } else {

    }
#line 2542
    tmp = en;
#line 2542
    en = en - 1;
#line 2542
    *tmp = 0;
    ldv_66472: ;
#line 2539
    if ((unsigned long )en > (unsigned long )st) {
#line 2541
      goto ldv_66471;
    } else {

    }
    ldv_66470: 
#line 2545
    index = (unsigned int )(ha->pdev)->subsystem_device & 255U;
#line 2546
    if ((use_tbl != 0 && (unsigned int )(ha->pdev)->subsystem_vendor == 4215U) && (unsigned int )index <= 91U) {
#line 2549
      strncpy((char *)(& ha->model_desc), (char const   *)qla2x00_model_name[(int )index * 2 + 1],
              79UL);
    } else {

    }
  } else {
#line 2553
    index = (unsigned int )(ha->pdev)->subsystem_device & 255U;
#line 2554
    if ((use_tbl != 0 && (unsigned int )(ha->pdev)->subsystem_vendor == 4215U) && (unsigned int )index <= 91U) {
#line 2557
      strcpy((char *)(& ha->model_number), (char const   *)qla2x00_model_name[(int )index * 2]);
#line 2559
      strncpy((char *)(& ha->model_desc), (char const   *)qla2x00_model_name[(int )index * 2 + 1],
              79UL);
    } else {
#line 2563
      strcpy((char *)(& ha->model_number), (char const   *)def);
    }
  }
#line 2566
  if ((ha->device_type & 134217728U) != 0U) {
#line 2567
    qla2xxx_get_vpd_field(vha, (char *)"\202", (char *)(& ha->model_desc), 80UL);
  } else {

  }
#line 2568
  return;
}
}
#line 2574 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static void qla2xxx_nvram_wwn_from_ofw(scsi_qla_host_t *vha , nvram_t *nv ) 
{ 


  {
#line 2576
  return;
}
}
#line 2607 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla2x00_nvram_config(struct scsi_qla_host *vha ) 
{ 
  int rval ;
  uint8_t chksum ;
  uint16_t cnt ;
  uint8_t *dptr1 ;
  uint8_t *dptr2 ;
  struct qla_hw_data *ha ;
  init_cb_t *icb ;
  nvram_t *nv ;
  uint8_t *ptr ;
  struct device_reg_2xxx *reg ;
  unsigned short tmp ;
  uint8_t *tmp___0 ;
  uint8_t *tmp___1 ;
  uint8_t *tmp___2 ;
  uint16_t tmp___3 ;
  uint8_t *tmp___4 ;
  uint8_t *tmp___5 ;
  uint16_t tmp___6 ;

  {
#line 2610
  chksum = 0U;
#line 2613
  ha = vha->hw;
#line 2614
  icb = ha->init_cb;
#line 2615
  nv = (nvram_t *)ha->nvram;
#line 2616
  ptr = (uint8_t *)ha->nvram;
#line 2617
  reg = & (ha->iobase)->isp;
#line 2619
  rval = 0;
#line 2622
  ha->nvram_size = 256U;
#line 2623
  ha->nvram_base = 0U;
#line 2624
  if (((ha->device_type & 1U) == 0U && (ha->device_type & 2U) == 0U) && (ha->device_type & 4U) == 0U) {
#line 2625
    tmp = readw((void const volatile   *)(& reg->ctrl_status));
#line 2625
    if ((unsigned int )((int )tmp >> 14) == 1U) {
#line 2626
      ha->nvram_base = 128U;
    } else {

    }
  } else {

  }
#line 2629
  (*((ha->isp_ops)->read_nvram))(vha, ptr, (uint32_t )ha->nvram_base, (uint32_t )ha->nvram_size);
#line 2630
  cnt = 0U;
#line 2630
  chksum = 0U;
#line 2630
  goto ldv_66491;
  ldv_66490: 
#line 2631
  tmp___0 = ptr;
#line 2631
  ptr = ptr + 1;
#line 2631
  chksum = (int )*tmp___0 + (int )chksum;
#line 2630
  cnt = (uint16_t )((int )cnt + 1);
  ldv_66491: ;
#line 2630
  if ((int )ha->nvram_size > (int )cnt) {
#line 2632
    goto ldv_66490;
  } else {

  }
#line 2633
  ql_dbg(1073872896U, vha, 271, "Contents of NVRAM.\n");
#line 2635
  ql_dump_buffer(1073872896U, vha, 272, (uint8_t *)nv, (uint32_t )ha->nvram_size);
#line 2639
  if ((((((unsigned int )chksum != 0U || (unsigned int )nv->id[0] != 73U) || (unsigned int )nv->id[1] != 83U) || (unsigned int )nv->id[2] != 80U) || (unsigned int )nv->id[3] != 32U) || (unsigned int )nv->nvram_version == 0U) {
#line 2642
    ql_log(1U, vha, 100, "Inconsistent NVRAM detected: checksum=0x%x id=%c version=0x%x.\n",
           (int )chksum, (int )nv->id[0], (int )nv->nvram_version);
#line 2646
    ql_log(1U, vha, 101, "Falling back to functioning (yet invalid -- WWPN) defaults.\n");
#line 2653
    memset((void *)nv, 0, (size_t )ha->nvram_size);
#line 2654
    nv->parameter_block_version = 1U;
#line 2656
    if (((((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 16U) != 0U) || (ha->device_type & 32U) != 0U) || (ha->device_type & 64U) != 0U) {
#line 2657
      nv->firmware_options[0] = 6U;
#line 2658
      nv->firmware_options[1] = 160U;
#line 2659
      nv->add_firmware_options[0] = 32U;
#line 2660
      nv->add_firmware_options[1] = 48U;
#line 2661
      nv->frame_payload_size = 2048U;
#line 2662
      nv->special_options[1] = 128U;
    } else
#line 2663
    if ((ha->device_type & 2U) != 0U) {
#line 2664
      nv->firmware_options[0] = 6U;
#line 2665
      nv->firmware_options[1] = 160U;
#line 2666
      nv->add_firmware_options[0] = 32U;
#line 2667
      nv->add_firmware_options[1] = 48U;
#line 2668
      nv->frame_payload_size = 1024U;
    } else
#line 2669
    if ((int )ha->device_type & 1) {
#line 2670
      nv->firmware_options[0] = 10U;
#line 2671
      nv->firmware_options[1] = 32U;
#line 2672
      nv->frame_payload_size = 1024U;
    } else {

    }
#line 2675
    nv->max_iocb_allocation = 256U;
#line 2676
    nv->execution_throttle = 16U;
#line 2677
    nv->retry_count = 8U;
#line 2678
    nv->retry_delay = 1U;
#line 2680
    nv->port_name[0] = 33U;
#line 2681
    nv->port_name[3] = 224U;
#line 2682
    nv->port_name[4] = 139U;
#line 2684
    qla2xxx_nvram_wwn_from_ofw(vha, nv);
#line 2686
    nv->login_timeout = 4U;
#line 2691
    nv->host_p[1] = 4U;
#line 2692
    nv->reset_delay = 5U;
#line 2693
    nv->port_down_retry_count = 8U;
#line 2694
    nv->max_luns_per_target = 8U;
#line 2695
    nv->link_down_timeout = 60U;
#line 2697
    rval = 1;
  } else {

  }
#line 2715
  memset((void *)icb, 0, (size_t )ha->init_cb_size);
#line 2720
  nv->firmware_options[0] = (uint8_t )((unsigned int )nv->firmware_options[0] | 66U);
#line 2721
  nv->firmware_options[0] = (unsigned int )nv->firmware_options[0] & 207U;
#line 2722
  nv->firmware_options[1] = (uint8_t )((unsigned int )nv->firmware_options[1] | 33U);
#line 2723
  nv->firmware_options[1] = (unsigned int )nv->firmware_options[1] & 239U;
#line 2725
  if (((((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 16U) != 0U) || (ha->device_type & 32U) != 0U) || (ha->device_type & 64U) != 0U) {
#line 2726
    nv->firmware_options[0] = (uint8_t )((unsigned int )nv->firmware_options[0] | 4U);
#line 2727
    nv->firmware_options[0] = (unsigned int )nv->firmware_options[0] & 247U;
#line 2728
    nv->special_options[0] = (unsigned int )nv->special_options[0] & 191U;
#line 2729
    nv->add_firmware_options[1] = (uint8_t )((unsigned int )nv->add_firmware_options[1] | 48U);
#line 2731
    if ((ha->device_type & 4U) != 0U) {
#line 2732
      if ((unsigned int )ha->fb_rev == 7U) {
#line 2733
        strcpy((char *)(& ha->model_number), "QLA2310");
      } else {
#line 2735
        strcpy((char *)(& ha->model_number), "QLA2300");
      }
    } else {
#line 2738
      qla2x00_set_model_info(vha, (uint8_t *)(& nv->model_number), 16UL, (char *)"QLA23xx");
    }
  } else
#line 2741
  if ((ha->device_type & 2U) != 0U) {
#line 2742
    nv->firmware_options[0] = (uint8_t )((unsigned int )nv->firmware_options[0] | 4U);
#line 2747
    if (((int )nv->add_firmware_options[0] & 112) == 48) {
#line 2750
      nv->add_firmware_options[0] = (unsigned int )nv->add_firmware_options[0] & 143U;
#line 2751
      nv->add_firmware_options[0] = (uint8_t )((unsigned int )nv->add_firmware_options[0] | 32U);
    } else {

    }
#line 2753
    strcpy((char *)(& ha->model_number), "QLA22xx");
  } else {
#line 2755
    strcpy((char *)(& ha->model_number), "QLA2100");
  }
#line 2761
  dptr1 = (uint8_t *)icb;
#line 2762
  dptr2 = & nv->parameter_block_version;
#line 2763
  cnt = 32U;
#line 2764
  goto ldv_66494;
  ldv_66493: 
#line 2765
  tmp___1 = dptr1;
#line 2765
  dptr1 = dptr1 + 1;
#line 2765
  tmp___2 = dptr2;
#line 2765
  dptr2 = dptr2 + 1;
#line 2765
  *tmp___1 = *tmp___2;
  ldv_66494: 
#line 2764
  tmp___3 = cnt;
#line 2764
  cnt = (uint16_t )((int )cnt - 1);
#line 2764
  if ((unsigned int )tmp___3 != 0U) {
#line 2766
    goto ldv_66493;
  } else {

  }
#line 2768
  dptr1 = (uint8_t *)(& icb->add_firmware_options);
#line 2769
  cnt = 6U;
#line 2770
  goto ldv_66497;
  ldv_66496: 
#line 2771
  tmp___4 = dptr1;
#line 2771
  dptr1 = dptr1 + 1;
#line 2771
  tmp___5 = dptr2;
#line 2771
  dptr2 = dptr2 + 1;
#line 2771
  *tmp___4 = *tmp___5;
  ldv_66497: 
#line 2770
  tmp___6 = cnt;
#line 2770
  cnt = (uint16_t )((int )cnt - 1);
#line 2770
  if ((unsigned int )tmp___6 != 0U) {
#line 2772
    goto ldv_66496;
  } else {

  }

#line 2774
  if ((int )((signed char )nv->host_p[1]) < 0) {
#line 2775
    memcpy((void *)(& icb->node_name), (void const   *)(& nv->alternate_node_name),
             8UL);
#line 2776
    memcpy((void *)(& icb->port_name), (void const   *)(& nv->alternate_port_name),
             8UL);
  } else {

  }
#line 2780
  if (((int )icb->firmware_options[1] & 64) == 0) {
#line 2785
    memcpy((void *)(& icb->node_name), (void const   *)(& icb->port_name), 8UL);
#line 2786
    icb->node_name[0] = (unsigned int )icb->node_name[0] & 240U;
  } else {

  }
#line 2797
  if ((int )((signed char )nv->host_p[0]) < 0) {
#line 2798
    ql2xextended_error_logging = 507510784;
  } else {

  }
#line 2799
  ha->flags.disable_risc_code_load = ((int )nv->host_p[0] & 16) != 0;
#line 2801
  if ((ha->device_type & 1U) == 0U && (ha->device_type & 2U) == 0U) {
#line 2802
    ha->flags.disable_risc_code_load = 0U;
  } else {

  }
#line 2803
  ha->flags.enable_lip_reset = ((int )nv->host_p[1] & 2) != 0;
#line 2804
  ha->flags.enable_lip_full_login = ((int )nv->host_p[1] & 4) != 0;
#line 2805
  ha->flags.enable_target_reset = ((int )nv->host_p[1] & 8) != 0;
#line 2806
  ha->flags.enable_led_scheme = ((int )nv->special_options[1] & 16) != 0;
#line 2807
  ha->flags.disable_serdes = 0U;
#line 2809
  ha->operating_mode = (uint8_t )(((int )icb->add_firmware_options[0] & 112) >> 4);
#line 2812
  memcpy((void *)(& ha->fw_seriallink_options), (void const   *)(& nv->seriallink_options),
           4UL);
#line 2816
  ha->serial0 = icb->port_name[5];
#line 2817
  ha->serial1 = icb->port_name[6];
#line 2818
  ha->serial2 = icb->port_name[7];
#line 2819
  memcpy((void *)(& vha->node_name), (void const   *)(& icb->node_name), 8UL);
#line 2820
  memcpy((void *)(& vha->port_name), (void const   *)(& icb->port_name), 8UL);
#line 2822
  icb->execution_throttle = 65535U;
#line 2824
  ha->retry_count = nv->retry_count;
#line 2827
  if ((int )nv->login_timeout != ql2xlogintimeout) {
#line 2828
    nv->login_timeout = (uint8_t )ql2xlogintimeout;
  } else {

  }
#line 2829
  if ((unsigned int )nv->login_timeout <= 3U) {
#line 2830
    nv->login_timeout = 4U;
  } else {

  }
#line 2831
  ha->login_timeout = nv->login_timeout;
#line 2832
  icb->login_timeout = nv->login_timeout;
#line 2835
  ha->r_a_tov = 100U;
#line 2837
  ha->loop_reset_delay = (uint16_t )nv->reset_delay;
#line 2849
  if ((unsigned int )nv->link_down_timeout == 0U) {
#line 2850
    ha->loop_down_abort_time = 195U;
  } else {
#line 2853
    ha->link_down_timeout = nv->link_down_timeout;
#line 2854
    ha->loop_down_abort_time = ~ ((int )ha->link_down_timeout);
  }
#line 2861
  ha->port_down_retry_count = (int )nv->port_down_retry_count;
#line 2862
  if (qlport_down_retry != 0) {
#line 2863
    ha->port_down_retry_count = qlport_down_retry;
  } else {

  }
#line 2865
  ha->login_retry_count = (uint32_t )nv->retry_count;
#line 2866
  if (ha->port_down_retry_count == (int )nv->port_down_retry_count && ha->port_down_retry_count > 3) {
#line 2868
    ha->login_retry_count = (uint32_t )ha->port_down_retry_count;
  } else
#line 2869
  if (ha->port_down_retry_count > (int )ha->login_retry_count) {
#line 2870
    ha->login_retry_count = (uint32_t )ha->port_down_retry_count;
  } else {

  }
#line 2871
  if (ql2xloginretrycount != 0) {
#line 2872
    ha->login_retry_count = (uint32_t )ql2xloginretrycount;
  } else {

  }
#line 2874
  icb->lun_enables = 0U;
#line 2875
  icb->command_resource_count = 0U;
#line 2876
  icb->immediate_notify_resource_count = 0U;
#line 2877
  icb->timeout = 0U;
#line 2879
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 2881
    icb->firmware_options[0] = (unsigned int )icb->firmware_options[0] & 247U;
#line 2882
    icb->add_firmware_options[0] = (unsigned int )icb->add_firmware_options[0] & 240U;
#line 2884
    icb->add_firmware_options[0] = (uint8_t )((unsigned int )icb->add_firmware_options[0] | 4U);
#line 2885
    icb->response_accumulation_timer = 3U;
#line 2886
    icb->interrupt_delay_timer = 5U;
#line 2888
    vha->flags.process_response_queue = 1U;
  } else {
#line 2891
    if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 2892
      ha->zio_mode = (unsigned int )((uint16_t )icb->add_firmware_options[0]) & 15U;
#line 2894
      ha->zio_timer = (unsigned int )icb->interrupt_delay_timer != 0U ? (uint16_t )icb->interrupt_delay_timer : 2U;
    } else {

    }
#line 2897
    icb->add_firmware_options[0] = (unsigned int )icb->add_firmware_options[0] & 240U;
#line 2899
    vha->flags.process_response_queue = 0U;
#line 2900
    if ((unsigned int )ha->zio_mode != 0U) {
#line 2901
      ha->zio_mode = 6U;
#line 2903
      ql_log(2U, vha, 104, "ZIO mode %d enabled; timer delay (%d us).\n", (int )ha->zio_mode,
             (int )ha->zio_timer * 100);
#line 2907
      icb->add_firmware_options[0] = (uint8_t )((int )icb->add_firmware_options[0] | (int )((unsigned char )ha->zio_mode));
#line 2908
      icb->interrupt_delay_timer = (unsigned char )ha->zio_timer;
#line 2909
      vha->flags.process_response_queue = 1U;
    } else {

    }
  }
#line 2913
  if (rval != 0) {
#line 2914
    ql_log(1U, vha, 105, "NVRAM configuration failed.\n");
  } else {

  }
#line 2917
  return (rval);
}
}
#line 2921 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static void qla2x00_rport_del(void *data ) 
{ 
  fc_port_t *fcport ;
  struct fc_rport *rport ;
  scsi_qla_host_t *vha ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 2923
  fcport = (fc_port_t *)data;
#line 2925
  vha = fcport->vha;
#line 2928
  tmp = spinlock_check(((fcport->vha)->host)->host_lock);
#line 2928
  flags = _raw_spin_lock_irqsave(tmp);
#line 2929
  rport = (unsigned long )fcport->drport != (unsigned long )((struct fc_rport *)0) ? fcport->drport : fcport->rport;
#line 2930
  fcport->drport = (struct fc_rport *)0;
#line 2931
  spin_unlock_irqrestore(((fcport->vha)->host)->host_lock, flags);
#line 2932
  if ((unsigned long )rport != (unsigned long )((struct fc_rport *)0)) {
#line 2933
    fc_remote_port_delete(rport);
#line 2938
    qlt_fc_port_deleted(vha, fcport);
  } else {

  }
#line 2940
  return;
}
}
#line 2950 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
fc_port_t *qla2x00_alloc_fcport(scsi_qla_host_t *vha , gfp_t flags ) 
{ 
  fc_port_t *fcport ;
  void *tmp ;

  {
#line 2954
  tmp = kzalloc(136UL, flags);
#line 2954
  fcport = (fc_port_t *)tmp;
#line 2955
  if ((unsigned long )fcport == (unsigned long )((fc_port_t *)0)) {
#line 2956
    return ((fc_port_t *)0);
  } else {

  }
#line 2959
  fcport->vha = vha;
#line 2960
  fcport->port_type = 0;
#line 2961
  fcport->loop_id = 4096U;
#line 2962
  qla2x00_set_fcport_state___0(fcport, 1);
#line 2963
  fcport->supported_classes = 0U;
#line 2965
  return (fcport);
}
}
#line 2981 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static int qla2x00_configure_loop(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  unsigned long flags ;
  unsigned long save_flags ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 2985
  ha = vha->hw;
#line 2986
  rval = 0;
#line 2989
  tmp = constant_test_bit(6L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 2989
  if (tmp != 0) {
#line 2990
    rval = qla2x00_configure_hba(vha);
#line 2991
    if (rval != 0) {
#line 2992
      ql_dbg(268435456U, vha, 8211, "Unable to configure HBA.\n");
#line 2994
      return (rval);
    } else {

    }
  } else {

  }
#line 2998
  flags = vha->dpc_flags;
#line 2998
  save_flags = flags;
#line 2999
  ql_dbg(268435456U, vha, 8212, "Configure loop -- dpc flags = 0x%lx.\n", flags);
#line 3006
  clear_bit(6L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3007
  clear_bit(7L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3009
  qla2x00_get_data_rate(vha);
#line 3012
  if ((unsigned int )ha->current_topology == 4U) {
#line 3012
    tmp___2 = constant_test_bit(6L, (unsigned long const volatile   *)(& flags));
#line 3012
    if (tmp___2 != 0) {
#line 3015
      set_bit(7L, (unsigned long volatile   *)(& flags));
    } else {
#line 3012
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 3017
  if ((unsigned int )ha->current_topology == 8U) {
#line 3017
    tmp___1 = constant_test_bit(6L, (unsigned long const volatile   *)(& flags));
#line 3017
    if (tmp___1 != 0) {
#line 3020
      set_bit(7L, (unsigned long volatile   *)(& flags));
#line 3021
      clear_bit(6L, (unsigned long volatile   *)(& flags));
    } else {
#line 3017
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3023
  if ((unsigned int )ha->current_topology == 2U) {
#line 3024
    clear_bit(7L, (unsigned long volatile   *)(& flags));
  } else
#line 3026
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 3029
    set_bit(7L, (unsigned long volatile   *)(& flags));
#line 3030
    set_bit(6L, (unsigned long volatile   *)(& flags));
  } else {
#line 3026
    tmp___0 = constant_test_bit(3L, (unsigned long const volatile   *)(& flags));
#line 3026
    if (tmp___0 != 0) {
#line 3029
      set_bit(7L, (unsigned long volatile   *)(& flags));
#line 3030
      set_bit(6L, (unsigned long volatile   *)(& flags));
    } else {

    }
  }
#line 3033
  tmp___4 = constant_test_bit(6L, (unsigned long const volatile   *)(& flags));
#line 3033
  if (tmp___4 != 0) {
#line 3034
    tmp___3 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3034
    if (tmp___3 != 0) {
#line 3035
      ql_dbg(268435456U, vha, 8213, "Loop resync needed, failing.\n");
#line 3037
      rval = 258;
    } else {
#line 3039
      rval = qla2x00_configure_local_loop(vha);
    }
  } else {

  }
#line 3042
  if (rval == 0) {
#line 3042
    tmp___8 = constant_test_bit(7L, (unsigned long const volatile   *)(& flags));
#line 3042
    if (tmp___8 != 0) {
#line 3043
      tmp___5 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3043
      if (tmp___5 != 0) {
#line 3044
        ql_dbg(268435456U, vha, 8222, "Needs RSCN update and loop transition.\n");
#line 3046
        rval = 258;
      } else {
#line 3043
        tmp___6 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3043
        if (tmp___6 != 0) {
#line 3044
          ql_dbg(268435456U, vha, 8222, "Needs RSCN update and loop transition.\n");
#line 3046
          rval = 258;
        } else {
#line 3043
          tmp___7 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 3043
          if (tmp___7 == 2) {
#line 3044
            ql_dbg(268435456U, vha, 8222, "Needs RSCN update and loop transition.\n");
#line 3046
            rval = 258;
          } else {
#line 3049
            rval = qla2x00_configure_fabric(vha);
          }
        }
      }
    } else {

    }
  } else {

  }
#line 3052
  if (rval == 0) {
#line 3053
    tmp___9 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 3053
    if (tmp___9 != 0) {
#line 3055
      rval = 258;
    } else {
#line 3053
      tmp___10 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3053
      if (tmp___10 != 0) {
#line 3055
        rval = 258;
      } else {
#line 3057
        atomic_set(& vha->loop_state, 5);
#line 3058
        ql_dbg(268435456U, vha, 8297, "LOOP READY.\n");
      }
    }
  } else {

  }
#line 3063
  if (rval != 0) {
#line 3064
    ql_dbg(268435456U, vha, 8298, "%s *** FAILED ***.\n", "qla2x00_configure_loop");
  } else {
#line 3067
    ql_dbg(268435456U, vha, 8299, "%s: exiting normally.\n", "qla2x00_configure_loop");
  }
#line 3072
  tmp___13 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3072
  if (tmp___13 != 0) {
#line 3073
    tmp___11 = constant_test_bit(6L, (unsigned long const volatile   *)(& save_flags));
#line 3073
    if (tmp___11 != 0) {
#line 3074
      set_bit(6L, (unsigned long volatile   *)(& vha->dpc_flags));
    } else {

    }
#line 3075
    tmp___12 = constant_test_bit(7L, (unsigned long const volatile   *)(& save_flags));
#line 3075
    if (tmp___12 != 0) {
#line 3076
      set_bit(7L, (unsigned long volatile   *)(& vha->dpc_flags));
    } else {

    }
  } else {

  }
#line 3080
  return (rval);
}
}
#line 3096 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static int qla2x00_configure_local_loop(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  int rval2 ;
  int found_devs ;
  int found ;
  fc_port_t *fcport ;
  fc_port_t *new_fcport ;
  uint16_t index ;
  uint16_t entries ;
  char *id_iter ;
  uint16_t loop_id ;
  uint8_t domain ;
  uint8_t area ;
  uint8_t al_pa ;
  struct qla_hw_data *ha ;
  int tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  int tmp___1 ;
  struct list_head  const  *__mptr___2 ;

  {
#line 3108
  ha = vha->hw;
#line 3110
  found_devs = 0;
#line 3111
  new_fcport = (fc_port_t *)0;
#line 3112
  entries = 128U;
#line 3115
  tmp = qla2x00_gid_list_size(ha);
#line 3115
  memset((void *)ha->gid_list, 0, (size_t )tmp);
#line 3116
  rval = qla2x00_get_id_list(vha, (void *)ha->gid_list, ha->gid_list_dma, & entries);
#line 3118
  if (rval != 0) {
#line 3119
    goto cleanup_allocation;
  } else {

  }
#line 3121
  ql_dbg(268435456U, vha, 8215, "Entries in ID list (%d).\n", (int )entries);
#line 3123
  ql_dump_buffer(268566528U, vha, 8309, (uint8_t *)ha->gid_list, (uint32_t )entries * 8U);
#line 3128
  new_fcport = qla2x00_alloc_fcport(vha, 208U);
#line 3129
  if ((unsigned long )new_fcport == (unsigned long )((fc_port_t *)0)) {
#line 3130
    ql_log(1U, vha, 8216, "Memory allocation failed for fcport.\n");
#line 3132
    rval = 259;
#line 3133
    goto cleanup_allocation;
  } else {

  }
#line 3135
  new_fcport->flags = new_fcport->flags & 4294967294U;
#line 3140
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 3140
  fcport = (fc_port_t *)__mptr;
#line 3140
  goto ldv_66545;
  ldv_66544: 
#line 3141
  tmp___0 = atomic_read((atomic_t const   *)(& fcport->state));
#line 3141
  if ((tmp___0 == 4 && (unsigned int )fcport->port_type != 3U) && (fcport->flags & 1U) == 0U) {
#line 3145
    ql_dbg(268435456U, vha, 8217, "Marking port lost loop_id=0x%04x.\n", (int )fcport->loop_id);
#line 3149
    qla2x00_set_fcport_state___0(fcport, 3);
  } else {

  }
#line 3140
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 3140
  fcport = (fc_port_t *)__mptr___0;
  ldv_66545: ;
#line 3140
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 3142
    goto ldv_66544;
  } else {

  }
#line 3154
  id_iter = (char *)ha->gid_list;
#line 3155
  index = 0U;
#line 3155
  goto ldv_66557;
  ldv_66556: 
#line 3156
  domain = ((struct gid_list_info *)id_iter)->domain;
#line 3157
  area = ((struct gid_list_info *)id_iter)->area;
#line 3158
  al_pa = ((struct gid_list_info *)id_iter)->al_pa;
#line 3159
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 3160
    loop_id = (unsigned short )((struct gid_list_info *)id_iter)->loop_id_2100;
  } else {
#line 3163
    loop_id = ((struct gid_list_info *)id_iter)->loop_id;
  }
#line 3165
  id_iter = id_iter + (unsigned long )ha->gid_list_info_size;
#line 3168
  if (((int )domain & 240) == 240) {
#line 3169
    goto ldv_66547;
  } else {

  }
#line 3172
  if (((unsigned int )area != 0U && (unsigned int )domain != 0U) && ((int )vha->d_id.b.area != (int )area || (int )vha->d_id.b.domain != (int )domain)) {
#line 3174
    goto ldv_66547;
  } else {

  }
#line 3177
  if ((unsigned int )loop_id > 125U) {
#line 3178
    goto ldv_66547;
  } else {

  }
#line 3180
  memset((void *)new_fcport, 0, 136UL);
#line 3183
  new_fcport->d_id.b.domain = domain;
#line 3184
  new_fcport->d_id.b.area = area;
#line 3185
  new_fcport->d_id.b.al_pa = al_pa;
#line 3186
  new_fcport->loop_id = loop_id;
#line 3187
  rval2 = qla2x00_get_port_database(vha, new_fcport, 0);
#line 3188
  if (rval2 != 0) {
#line 3189
    ql_dbg(268435456U, vha, 8218, "Failed to retrieve fcport information -- get_port_database=%x, loop_id=0x%04x.\n",
           rval2, (int )new_fcport->loop_id);
#line 3193
    ql_dbg(268435456U, vha, 8219, "Scheduling resync.\n");
#line 3195
    set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3196
    goto ldv_66547;
  } else {

  }
#line 3200
  found = 0;
#line 3201
  fcport = (fc_port_t *)0;
#line 3202
  __mptr___1 = (struct list_head  const  *)vha->vp_fcports.next;
#line 3202
  fcport = (fc_port_t *)__mptr___1;
#line 3202
  goto ldv_66555;
  ldv_66554: 
#line 3203
  tmp___1 = memcmp((void const   *)(& new_fcport->port_name), (void const   *)(& fcport->port_name),
                   8UL);
#line 3203
  if (tmp___1 != 0) {
#line 3205
    goto ldv_66552;
  } else {

  }
#line 3207
  fcport->flags = fcport->flags & 4294967294U;
#line 3208
  fcport->loop_id = new_fcport->loop_id;
#line 3209
  fcport->port_type = new_fcport->port_type;
#line 3210
  fcport->d_id.b24 = new_fcport->d_id.b24;
#line 3211
  memcpy((void *)(& fcport->node_name), (void const   *)(& new_fcport->node_name),
           8UL);
#line 3214
  found = found + 1;
#line 3215
  goto ldv_66553;
  ldv_66552: 
#line 3202
  __mptr___2 = (struct list_head  const  *)fcport->list.next;
#line 3202
  fcport = (fc_port_t *)__mptr___2;
  ldv_66555: ;
#line 3202
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 3204
    goto ldv_66554;
  } else {

  }
  ldv_66553: ;
#line 3218
  if (found == 0) {
#line 3220
    list_add_tail(& new_fcport->list, & vha->vp_fcports);
#line 3223
    fcport = new_fcport;
#line 3224
    new_fcport = qla2x00_alloc_fcport(vha, 208U);
#line 3225
    if ((unsigned long )new_fcport == (unsigned long )((fc_port_t *)0)) {
#line 3226
      ql_log(1U, vha, 8220, "Failed to allocate memory for fcport.\n");
#line 3228
      rval = 259;
#line 3229
      goto cleanup_allocation;
    } else {

    }
#line 3231
    new_fcport->flags = new_fcport->flags & 4294967294U;
  } else {

  }
#line 3235
  fcport->fp_speed = ha->link_data_rate;
#line 3237
  qla2x00_update_fcport(vha, fcport);
#line 3239
  found_devs = found_devs + 1;
  ldv_66547: 
#line 3155
  index = (uint16_t )((int )index + 1);
  ldv_66557: ;
#line 3155
  if ((int )index < (int )entries) {
#line 3157
    goto ldv_66556;
  } else {

  }

  cleanup_allocation: 
#line 3243
  kfree((void const   *)new_fcport);
#line 3245
  if (rval != 0) {
#line 3246
    ql_dbg(268435456U, vha, 8221, "Configure local loop error exit: rval=%x.\n", rval);
  } else {

  }
#line 3250
  return (rval);
}
}
#line 3254 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static void qla2x00_iidma_fcport(scsi_qla_host_t *vha , fc_port_t *fcport ) 
{ 
  int rval ;
  uint16_t mb[32U] ;
  struct qla_hw_data *ha ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 3258
  ha = vha->hw;
#line 3260
  if ((ha->device_type & 67108864U) == 0U) {
#line 3261
    return;
  } else {

  }
#line 3263
  tmp = atomic_read((atomic_t const   *)(& fcport->state));
#line 3263
  if (tmp != 4) {
#line 3264
    return;
  } else {

  }
#line 3266
  if ((unsigned int )fcport->fp_speed == 65535U || (int )fcport->fp_speed > (int )ha->link_data_rate) {
#line 3268
    return;
  } else {

  }
#line 3270
  rval = qla2x00_set_idma_speed(vha, (int )fcport->loop_id, (int )fcport->fp_speed,
                                (uint16_t *)(& mb));
#line 3272
  if (rval != 0) {
#line 3273
    ql_dbg(268435456U, vha, 8196, "Unable to adjust iIDMA %8phN -- %04x %x %04x %04x.\n",
           (uint8_t *)(& fcport->port_name), rval, (int )fcport->fp_speed, (int )mb[0],
           (int )mb[1]);
  } else {
#line 3277
    tmp___0 = qla2x00_get_link_speed_str(ha, (int )fcport->fp_speed);
#line 3277
    ql_dbg(268435456U, vha, 8197, "iIDMA adjusted to %s GB/s on %8phN.\n", tmp___0,
           (uint8_t *)(& fcport->port_name));
  }
#line 3281
  return;
}
}
#line 3285 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static void qla2x00_reg_remote_port(scsi_qla_host_t *vha , fc_port_t *fcport ) 
{ 
  struct fc_rport_identifiers rport_ids ;
  struct fc_rport *rport ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 3291
  rport_ids.node_name = wwn_to_u64((u8 *)(& fcport->node_name));
#line 3292
  rport_ids.port_name = wwn_to_u64((u8 *)(& fcport->port_name));
#line 3293
  rport_ids.port_id = (u32 )((((int )fcport->d_id.b.domain << 16) | ((int )fcport->d_id.b.area << 8)) | (int )fcport->d_id.b.al_pa);
#line 3295
  rport_ids.roles = 0U;
#line 3296
  rport = fc_remote_port_add(vha->host, 0, & rport_ids);
#line 3296
  fcport->rport = rport;
#line 3297
  if ((unsigned long )rport == (unsigned long )((struct fc_rport *)0)) {
#line 3298
    ql_log(1U, vha, 8198, "Unable to allocate fc remote port.\n");
#line 3300
    return;
  } else {

  }
#line 3306
  qlt_fc_port_added(vha, fcport);
#line 3308
  tmp = spinlock_check(((fcport->vha)->host)->host_lock);
#line 3308
  flags = _raw_spin_lock_irqsave(tmp);
#line 3309
  *((fc_port_t **)rport->dd_data) = fcport;
#line 3310
  spin_unlock_irqrestore(((fcport->vha)->host)->host_lock, flags);
#line 3312
  rport->supported_classes = fcport->supported_classes;
#line 3314
  rport_ids.roles = 0U;
#line 3315
  if ((unsigned int )fcport->port_type == 4U) {
#line 3316
    rport_ids.roles = rport_ids.roles | 2U;
  } else {

  }
#line 3317
  if ((unsigned int )fcport->port_type == 5U) {
#line 3318
    rport_ids.roles = rport_ids.roles | 1U;
  } else {

  }
#line 3319
  fc_remote_port_rolechg(rport, rport_ids.roles);
#line 3320
  return;
}
}
#line 3338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
void qla2x00_update_fcport(scsi_qla_host_t *vha , fc_port_t *fcport ) 
{ 


  {
#line 3340
  fcport->vha = vha;
#line 3342
  if (((vha->hw)->device_type & 131072U) != 0U) {
#line 3343
    qla2x00_set_fcport_state___0(fcport, 4);
#line 3344
    qla2x00_reg_remote_port(vha, fcport);
#line 3345
    return;
  } else {

  }
#line 3347
  fcport->login_retry = 0;
#line 3348
  fcport->flags = fcport->flags & 4294967285U;
#line 3350
  qla2x00_set_fcport_state___0(fcport, 4);
#line 3351
  qla2x00_iidma_fcport(vha, fcport);
#line 3352
  qla24xx_update_fcport_fcp_prio(vha, fcport);
#line 3353
  qla2x00_reg_remote_port(vha, fcport);
#line 3354
  return;
}
}
#line 3368 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static int qla2x00_configure_fabric(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  fc_port_t *fcport ;
  fc_port_t *fcptemp ;
  uint16_t next_loopid ;
  uint16_t mb[32U] ;
  uint16_t loop_id ;
  struct list_head new_fcports ;
  struct qla_hw_data *ha ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  int tmp___6 ;
  int tmp___7 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  int tmp___8 ;
  int tmp___9 ;
  struct list_head  const  *__mptr___4 ;
  struct list_head  const  *__mptr___5 ;
  struct list_head  const  *__mptr___6 ;
  int tmp___10 ;
  int tmp___11 ;
  struct list_head  const  *__mptr___7 ;
  struct list_head  const  *__mptr___8 ;
  struct list_head  const  *__mptr___9 ;
  struct list_head  const  *__mptr___10 ;

  {
#line 3375
  new_fcports.next = & new_fcports;
#line 3375
  new_fcports.prev = & new_fcports;
#line 3376
  ha = vha->hw;
#line 3377
  tmp = pci_get_drvdata(ha->pdev);
#line 3377
  base_vha = (struct scsi_qla_host *)tmp;
#line 3380
  if ((ha->device_type & 134217728U) != 0U) {
#line 3381
    loop_id = 2046U;
  } else {
#line 3383
    loop_id = 126U;
  }
#line 3384
  rval = qla2x00_get_port_name(vha, (int )loop_id, (uint8_t *)(& vha->fabric_node_name),
                               1);
#line 3385
  if (rval != 0) {
#line 3386
    ql_dbg(268435456U, vha, 8223, "MBX_GET_PORT_NAME failed, No FL Port.\n");
#line 3389
    vha->device_flags = vha->device_flags & 4294967294U;
#line 3390
    return (0);
  } else {

  }
#line 3392
  vha->device_flags = vha->device_flags | 1U;
#line 3396
  if (ql2xfdmienable != 0) {
#line 3396
    tmp___0 = test_and_clear_bit(12L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3396
    if (tmp___0 != 0) {
#line 3398
      qla2x00_fdmi_register(vha);
    } else {

    }
  } else {

  }
#line 3401
  if ((ha->device_type & 134217728U) != 0U) {
#line 3402
    loop_id = 2044U;
  } else {
#line 3404
    loop_id = 128U;
  }
#line 3405
  rval = (*((ha->isp_ops)->fabric_login))(vha, (int )loop_id, 255, 255, 252, (uint16_t *)(& mb),
                                          3);
#line 3407
  if (rval != 0) {
#line 3408
    set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3409
    return (rval);
  } else {

  }
#line 3411
  if ((unsigned int )mb[0] != 16384U) {
#line 3412
    ql_dbg(268435456U, vha, 8258, "Failed SNS login: loop_id=%x mb[0]=%x mb[1]=%x mb[2]=%x mb[6]=%x mb[7]=%x.\n",
           (int )loop_id, (int )mb[0], (int )mb[1], (int )mb[2], (int )mb[6], (int )mb[7]);
#line 3416
    return (0);
  } else {

  }
#line 3419
  tmp___5 = test_and_clear_bit(9L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3419
  if (tmp___5 != 0) {
#line 3420
    tmp___1 = qla2x00_rft_id(vha);
#line 3420
    if (tmp___1 != 0) {
#line 3422
      ql_dbg(268435456U, vha, 8261, "Register FC-4 TYPE failed.\n");
    } else {

    }
#line 3425
    tmp___2 = qla2x00_rff_id(vha);
#line 3425
    if (tmp___2 != 0) {
#line 3427
      ql_dbg(268435456U, vha, 8265, "Register FC-4 Features failed.\n");
    } else {

    }
#line 3430
    tmp___4 = qla2x00_rnn_id(vha);
#line 3430
    if (tmp___4 != 0) {
#line 3432
      ql_dbg(268435456U, vha, 8271, "Register Node Name failed.\n");
    } else {
#line 3434
      tmp___3 = qla2x00_rsnn_nn(vha);
#line 3434
      if (tmp___3 != 0) {
#line 3436
        ql_dbg(268435456U, vha, 8275, "Register Symobilic Node Name failed.\n");
      } else {

      }
    }
  } else {

  }
#line 3444
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 3444
  fcport = (fc_port_t *)__mptr;
#line 3444
  goto ldv_66597;
  ldv_66596: 
#line 3445
  fcport->scan_state = 1U;
#line 3444
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 3444
  fcport = (fc_port_t *)__mptr___0;
  ldv_66597: ;
#line 3444
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 3446
    goto ldv_66596;
  } else {

  }
#line 3448
  rval = qla2x00_find_all_fabric_devs(vha, & new_fcports);
#line 3449
  if (rval != 0) {
#line 3450
    goto ldv_66599;
  } else {

  }
#line 3456
  __mptr___1 = (struct list_head  const  *)vha->vp_fcports.next;
#line 3456
  fcport = (fc_port_t *)__mptr___1;
#line 3456
  goto ldv_66607;
  ldv_66606: 
#line 3457
  tmp___6 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3457
  if (tmp___6 != 0) {
#line 3458
    goto ldv_66604;
  } else {

  }
#line 3460
  if ((fcport->flags & 1U) == 0U) {
#line 3461
    goto ldv_66605;
  } else {

  }
#line 3463
  if ((unsigned int )fcport->scan_state == 1U) {
#line 3463
    tmp___7 = atomic_read((atomic_t const   *)(& fcport->state));
#line 3463
    if (tmp___7 == 4) {
#line 3465
      qla2x00_mark_device_lost(vha, fcport, ql2xplogiabsentdevice, 0);
#line 3467
      if ((((unsigned int )fcport->loop_id != 4096U && (fcport->flags & 4U) == 0U) && (unsigned int )fcport->port_type != 4U) && (unsigned int )fcport->port_type != 3U) {
#line 3471
        (*((ha->isp_ops)->fabric_logout))(vha, (int )fcport->loop_id, (int )fcport->d_id.b.domain,
                                          (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
#line 3476
        qla2x00_clear_loop_id(fcport);
      } else {

      }
    } else {

    }
  } else {

  }
  ldv_66605: 
#line 3456
  __mptr___2 = (struct list_head  const  *)fcport->list.next;
#line 3456
  fcport = (fc_port_t *)__mptr___2;
  ldv_66607: ;
#line 3456
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 3458
    goto ldv_66606;
  } else {

  }
  ldv_66604: 
#line 3482
  next_loopid = ha->min_external_loopid;
#line 3488
  __mptr___3 = (struct list_head  const  *)vha->vp_fcports.next;
#line 3488
  fcport = (fc_port_t *)__mptr___3;
#line 3488
  goto ldv_66615;
  ldv_66614: 
#line 3489
  tmp___8 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 3489
  if (tmp___8 != 0) {
#line 3491
    goto ldv_66612;
  } else {
#line 3489
    tmp___9 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3489
    if (tmp___9 != 0) {
#line 3491
      goto ldv_66612;
    } else {

    }
  }
#line 3493
  if ((fcport->flags & 1U) == 0U || (fcport->flags & 2U) == 0U) {
#line 3495
    goto ldv_66613;
  } else {

  }
#line 3497
  if ((unsigned int )fcport->loop_id == 4096U) {
#line 3498
    fcport->loop_id = next_loopid;
#line 3499
    rval = qla2x00_find_new_loop_id(base_vha, fcport);
#line 3501
    if (rval != 0) {
#line 3503
      goto ldv_66612;
    } else {

    }
  } else {

  }
#line 3507
  qla2x00_fabric_dev_login(vha, fcport, & next_loopid);
  ldv_66613: 
#line 3488
  __mptr___4 = (struct list_head  const  *)fcport->list.next;
#line 3488
  fcport = (fc_port_t *)__mptr___4;
  ldv_66615: ;
#line 3488
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 3490
    goto ldv_66614;
  } else {

  }
  ldv_66612: ;
#line 3511
  if (rval != 0) {
#line 3512
    goto ldv_66599;
  } else {

  }
#line 3518
  __mptr___5 = (struct list_head  const  *)new_fcports.next;
#line 3518
  fcport = (fc_port_t *)__mptr___5;
#line 3518
  __mptr___6 = (struct list_head  const  *)fcport->list.next;
#line 3518
  fcptemp = (fc_port_t *)__mptr___6;
#line 3518
  goto ldv_66624;
  ldv_66623: 
#line 3519
  tmp___10 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 3519
  if (tmp___10 != 0) {
#line 3521
    goto ldv_66622;
  } else {
#line 3519
    tmp___11 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3519
    if (tmp___11 != 0) {
#line 3521
      goto ldv_66622;
    } else {

    }
  }
#line 3524
  fcport->loop_id = next_loopid;
#line 3525
  rval = qla2x00_find_new_loop_id(base_vha, fcport);
#line 3526
  if (rval != 0) {
#line 3528
    goto ldv_66622;
  } else {

  }
#line 3532
  qla2x00_fabric_dev_login(vha, fcport, & next_loopid);
#line 3534
  list_move_tail(& fcport->list, & vha->vp_fcports);
#line 3518
  fcport = fcptemp;
#line 3518
  __mptr___7 = (struct list_head  const  *)fcptemp->list.next;
#line 3518
  fcptemp = (fc_port_t *)__mptr___7;
  ldv_66624: ;
#line 3518
  if ((unsigned long )(& fcport->list) != (unsigned long )(& new_fcports)) {
#line 3520
    goto ldv_66623;
  } else {

  }
  ldv_66622: ;
  ldv_66599: 
#line 3539
  __mptr___8 = (struct list_head  const  *)new_fcports.next;
#line 3539
  fcport = (fc_port_t *)__mptr___8;
#line 3539
  __mptr___9 = (struct list_head  const  *)fcport->list.next;
#line 3539
  fcptemp = (fc_port_t *)__mptr___9;
#line 3539
  goto ldv_66632;
  ldv_66631: 
#line 3540
  list_del(& fcport->list);
#line 3541
  kfree((void const   *)fcport);
#line 3539
  fcport = fcptemp;
#line 3539
  __mptr___10 = (struct list_head  const  *)fcptemp->list.next;
#line 3539
  fcptemp = (fc_port_t *)__mptr___10;
  ldv_66632: ;
#line 3539
  if ((unsigned long )(& fcport->list) != (unsigned long )(& new_fcports)) {
#line 3541
    goto ldv_66631;
  } else {

  }

#line 3544
  if (rval != 0) {
#line 3545
    ql_dbg(268435456U, vha, 8296, "Configure fabric error exit rval=%d.\n", rval);
  } else {

  }
#line 3549
  return (rval);
}
}
#line 3566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static int qla2x00_find_all_fabric_devs(scsi_qla_host_t *vha , struct list_head *new_fcports ) 
{ 
  int rval ;
  uint16_t loop_id ;
  fc_port_t *fcport ;
  fc_port_t *new_fcport ;
  fc_port_t *fcptemp ;
  int found ;
  sw_info_t *swl ;
  int swl_idx ;
  int first_dev ;
  int last_dev ;
  port_id_t wrap ;
  port_id_t nxt_d_id ;
  struct qla_hw_data *ha ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  int tmp___9 ;
  struct list_head  const  *__mptr___2 ;
  int tmp___10 ;
  int tmp___11 ;
  struct list_head  const  *__mptr___3 ;

  {
#line 3577
  wrap.b24 = 0U;
#line 3578
  ha = vha->hw;
#line 3579
  tmp = pci_get_drvdata(ha->pdev);
#line 3579
  base_vha = (struct scsi_qla_host *)tmp;
#line 3581
  rval = 0;
#line 3584
  if ((unsigned long )ha->swl == (unsigned long )((void *)0)) {
#line 3585
    ha->swl = kcalloc((size_t )ha->max_fibre_devices, 32UL, 208U);
  } else {

  }
#line 3587
  swl = (sw_info_t *)ha->swl;
#line 3588
  if ((unsigned long )swl == (unsigned long )((sw_info_t *)0)) {
#line 3590
    ql_dbg(268435456U, vha, 8276, "GID_PT allocations failed, fallback on GA_NXT.\n");
  } else {
#line 3593
    memset((void *)swl, 0, (unsigned long )ha->max_fibre_devices * 32UL);
#line 3594
    tmp___3 = qla2x00_gid_pt(vha, swl);
#line 3594
    if (tmp___3 != 0) {
#line 3595
      swl = (sw_info_t *)0;
    } else {
#line 3596
      tmp___2 = qla2x00_gpn_id(vha, swl);
#line 3596
      if (tmp___2 != 0) {
#line 3597
        swl = (sw_info_t *)0;
      } else {
#line 3598
        tmp___1 = qla2x00_gnn_id(vha, swl);
#line 3598
        if (tmp___1 != 0) {
#line 3599
          swl = (sw_info_t *)0;
        } else
#line 3600
        if (ql2xiidmaenable != 0) {
#line 3600
          tmp___0 = qla2x00_gfpn_id(vha, swl);
#line 3600
          if (tmp___0 == 0) {
#line 3602
            qla2x00_gpsc(vha, swl);
          } else {

          }
        } else {

        }
      }
    }
#line 3606
    if ((unsigned long )swl != (unsigned long )((sw_info_t *)0)) {
#line 3607
      qla2x00_gff_id(vha, swl);
    } else {

    }
  }
#line 3609
  swl_idx = 0;
#line 3612
  new_fcport = qla2x00_alloc_fcport(vha, 208U);
#line 3613
  if ((unsigned long )new_fcport == (unsigned long )((fc_port_t *)0)) {
#line 3614
    ql_log(1U, vha, 8286, "Failed to allocate memory for fcport.\n");
#line 3616
    return (259);
  } else {

  }
#line 3618
  new_fcport->flags = new_fcport->flags | 3U;
#line 3620
  first_dev = 1;
#line 3621
  last_dev = 0;
#line 3624
  loop_id = ha->min_external_loopid;
#line 3625
  goto ldv_66672;
  ldv_66671: 
#line 3626
  tmp___4 = qla2x00_is_reserved_id(vha, (int )loop_id);
#line 3626
  if (tmp___4 != 0) {
#line 3627
    goto ldv_66652;
  } else {

  }
#line 3629
  if ((unsigned int )ha->current_topology == 4U) {
#line 3629
    tmp___5 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 3629
    if (tmp___5 != 0) {
#line 3632
      atomic_set(& vha->loop_down_timer, 0);
#line 3633
      set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3634
      set_bit(6L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3635
      goto ldv_66653;
    } else {
#line 3629
      tmp___6 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3629
      if (tmp___6 != 0) {
#line 3632
        atomic_set(& vha->loop_down_timer, 0);
#line 3633
        set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3634
        set_bit(6L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3635
        goto ldv_66653;
      } else {
#line 3629
        tmp___7 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3629
        if (tmp___7 != 0) {
#line 3632
          atomic_set(& vha->loop_down_timer, 0);
#line 3633
          set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3634
          set_bit(6L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3635
          goto ldv_66653;
        } else {
#line 3629
          tmp___8 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 3629
          if (tmp___8 == 2) {
#line 3632
            atomic_set(& vha->loop_down_timer, 0);
#line 3633
            set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3634
            set_bit(6L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3635
            goto ldv_66653;
          } else {

          }
        }
      }
    }
  } else {

  }
#line 3638
  if ((unsigned long )swl != (unsigned long )((sw_info_t *)0)) {
#line 3639
    if (last_dev != 0) {
#line 3640
      wrap.b24 = new_fcport->d_id.b24;
    } else {
#line 3642
      new_fcport->d_id.b24 = (swl + (unsigned long )swl_idx)->d_id.b24;
#line 3643
      memcpy((void *)(& new_fcport->node_name), (void const   *)(& (swl + (unsigned long )swl_idx)->node_name),
               8UL);
#line 3645
      memcpy((void *)(& new_fcport->port_name), (void const   *)(& (swl + (unsigned long )swl_idx)->port_name),
               8UL);
#line 3647
      memcpy((void *)(& new_fcport->fabric_port_name), (void const   *)(& (swl + (unsigned long )swl_idx)->fabric_port_name),
               8UL);
#line 3649
      new_fcport->fp_speed = (swl + (unsigned long )swl_idx)->fp_speed;
#line 3650
      new_fcport->fc4_type = (swl + (unsigned long )swl_idx)->fc4_type;
#line 3652
      if ((unsigned int )(swl + (unsigned long )swl_idx)->d_id.b.rsvd_1 != 0U) {
#line 3653
        last_dev = 1;
      } else {

      }
#line 3655
      swl_idx = swl_idx + 1;
    }
  } else {
#line 3659
    rval = qla2x00_ga_nxt(vha, new_fcport);
#line 3660
    if (rval != 0) {
#line 3661
      ql_log(1U, vha, 8292, "SNS scan failed -- assuming zero-entry result.\n");
#line 3664
      __mptr = (struct list_head  const  *)new_fcports->next;
#line 3664
      fcport = (fc_port_t *)__mptr;
#line 3664
      __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 3664
      fcptemp = (fc_port_t *)__mptr___0;
#line 3664
      goto ldv_66661;
      ldv_66660: 
#line 3666
      list_del(& fcport->list);
#line 3667
      kfree((void const   *)fcport);
#line 3664
      fcport = fcptemp;
#line 3664
      __mptr___1 = (struct list_head  const  *)fcptemp->list.next;
#line 3664
      fcptemp = (fc_port_t *)__mptr___1;
      ldv_66661: ;
#line 3664
      if ((unsigned long )(& fcport->list) != (unsigned long )new_fcports) {
#line 3666
        goto ldv_66660;
      } else {

      }
#line 3669
      rval = 0;
#line 3670
      goto ldv_66653;
    } else {

    }
  }
#line 3675
  if (first_dev != 0) {
#line 3676
    wrap.b24 = new_fcport->d_id.b24;
#line 3677
    first_dev = 0;
  } else
#line 3678
  if (new_fcport->d_id.b24 == wrap.b24) {
#line 3679
    ql_dbg(268435456U, vha, 8293, "Device wrap (%02x%02x%02x).\n", (int )new_fcport->d_id.b.domain,
           (int )new_fcport->d_id.b.area, (int )new_fcport->d_id.b.al_pa);
#line 3684
    goto ldv_66653;
  } else {

  }
#line 3688
  if (new_fcport->d_id.b24 == base_vha->d_id.b24) {
#line 3689
    goto ldv_66652;
  } else {

  }
#line 3692
  tmp___9 = qla2x00_is_a_vp_did(vha, new_fcport->d_id.b24);
#line 3692
  if (tmp___9 != 0) {
#line 3693
    goto ldv_66652;
  } else {

  }
#line 3696
  if ((((int )new_fcport->d_id.b24 ^ (int )vha->d_id.b24) & 16776960) == 0 && (unsigned int )ha->current_topology == 4U) {
#line 3699
    goto ldv_66652;
  } else {

  }
#line 3702
  if (((int )new_fcport->d_id.b.domain & 240) == 240) {
#line 3703
    goto ldv_66652;
  } else {

  }
#line 3706
  if (ql2xgffidenable != 0 && ((unsigned int )new_fcport->fc4_type != 8U && (unsigned int )new_fcport->fc4_type != 255U)) {
#line 3709
    goto ldv_66652;
  } else {

  }
#line 3712
  found = 0;
#line 3713
  __mptr___2 = (struct list_head  const  *)vha->vp_fcports.next;
#line 3713
  fcport = (fc_port_t *)__mptr___2;
#line 3713
  goto ldv_66670;
  ldv_66669: 
#line 3714
  tmp___10 = memcmp((void const   *)(& new_fcport->port_name), (void const   *)(& fcport->port_name),
                    8UL);
#line 3714
  if (tmp___10 != 0) {
#line 3716
    goto ldv_66667;
  } else {

  }
#line 3718
  fcport->scan_state = 2U;
#line 3720
  found = found + 1;
#line 3723
  memcpy((void *)(& fcport->fabric_port_name), (void const   *)(& new_fcport->fabric_port_name),
           8UL);
#line 3725
  fcport->fp_speed = new_fcport->fp_speed;
#line 3731
  if (fcport->d_id.b24 == new_fcport->d_id.b24) {
#line 3731
    tmp___11 = atomic_read((atomic_t const   *)(& fcport->state));
#line 3731
    if (tmp___11 == 4) {
#line 3733
      goto ldv_66668;
    } else {

    }
  } else {

  }
#line 3739
  if ((fcport->flags & 1U) == 0U) {
#line 3740
    fcport->d_id.b24 = new_fcport->d_id.b24;
#line 3741
    qla2x00_clear_loop_id(fcport);
#line 3742
    fcport->flags = fcport->flags | 3U;
#line 3744
    goto ldv_66668;
  } else {

  }
#line 3752
  fcport->d_id.b24 = new_fcport->d_id.b24;
#line 3753
  fcport->flags = fcport->flags | 2U;
#line 3754
  if (((((unsigned int )fcport->loop_id != 4096U && (fcport->flags & 4U) == 0U) && (fcport->flags & 8U) == 0U) && (unsigned int )fcport->port_type != 4U) && (unsigned int )fcport->port_type != 3U) {
#line 3759
    (*((ha->isp_ops)->fabric_logout))(vha, (int )fcport->loop_id, (int )fcport->d_id.b.domain,
                                      (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
#line 3762
    qla2x00_clear_loop_id(fcport);
  } else {

  }
#line 3765
  goto ldv_66668;
  ldv_66667: 
#line 3713
  __mptr___3 = (struct list_head  const  *)fcport->list.next;
#line 3713
  fcport = (fc_port_t *)__mptr___3;
  ldv_66670: ;
#line 3713
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 3715
    goto ldv_66669;
  } else {

  }
  ldv_66668: ;
#line 3768
  if (found != 0) {
#line 3769
    goto ldv_66652;
  } else {

  }
#line 3771
  list_add_tail(& new_fcport->list, new_fcports);
#line 3774
  nxt_d_id.b24 = new_fcport->d_id.b24;
#line 3775
  new_fcport = qla2x00_alloc_fcport(vha, 208U);
#line 3776
  if ((unsigned long )new_fcport == (unsigned long )((fc_port_t *)0)) {
#line 3777
    ql_log(1U, vha, 8294, "Memory allocation failed for fcport.\n");
#line 3779
    return (259);
  } else {

  }
#line 3781
  new_fcport->flags = new_fcport->flags | 3U;
#line 3782
  new_fcport->d_id.b24 = nxt_d_id.b24;
  ldv_66652: 
#line 3625
  loop_id = (uint16_t )((int )loop_id + 1);
  ldv_66672: ;
#line 3625
  if ((int )ha->max_loop_id >= (int )loop_id) {
#line 3627
    goto ldv_66671;
  } else {

  }
  ldv_66653: 
#line 3785
  kfree((void const   *)new_fcport);
#line 3787
  return (rval);
}
}
#line 3805 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla2x00_find_new_loop_id(scsi_qla_host_t *vha , fc_port_t *dev ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 3808
  ha = vha->hw;
#line 3809
  flags = 0UL;
#line 3811
  rval = 0;
#line 3813
  tmp = spinlock_check(& ha->vport_slock);
#line 3813
  flags = _raw_spin_lock_irqsave(tmp);
#line 3815
  tmp___0 = find_first_zero_bit((unsigned long const   *)ha->loop_id_map, (unsigned long )ha->max_fibre_devices);
#line 3815
  dev->loop_id = (uint16_t )tmp___0;
#line 3817
  if ((int )dev->loop_id >= (int )ha->max_fibre_devices) {
#line 3819
    dev->loop_id = 4096U;
#line 3820
    rval = 258;
  } else {
#line 3817
    tmp___1 = qla2x00_is_reserved_id(vha, (int )dev->loop_id);
#line 3817
    if (tmp___1 != 0) {
#line 3819
      dev->loop_id = 4096U;
#line 3820
      rval = 258;
    } else {
#line 3822
      set_bit((long )dev->loop_id, (unsigned long volatile   *)ha->loop_id_map);
    }
  }
#line 3824
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 3826
  if (rval == 0) {
#line 3827
    ql_dbg(268435456U, dev->vha, 8326, "Assigning new loopid=%x, portid=%x.\n", (int )dev->loop_id,
           (int )dev->d_id.b24);
  } else {
#line 3831
    ql_log(1U, dev->vha, 8327, "No loop_id\'s available, portid=%x.\n", (int )dev->d_id.b24);
  }
#line 3835
  return (rval);
}
}
#line 3855 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static int qla2x00_fabric_dev_login(scsi_qla_host_t *vha , fc_port_t *fcport , uint16_t *next_loopid ) 
{ 
  int rval ;
  int retry ;
  uint8_t opts ;
  struct qla_hw_data *ha ;

  {
#line 3861
  ha = vha->hw;
#line 3863
  rval = 0;
#line 3864
  retry = 0;
#line 3866
  if ((((((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 16U) != 0U) || (ha->device_type & 32U) != 0U) || (ha->device_type & 64U) != 0U) || (ha->device_type & 134217728U) != 0U) {
#line 3867
    if ((fcport->flags & 8U) != 0U) {
#line 3868
      return (rval);
    } else {

    }
#line 3869
    fcport->flags = fcport->flags | 8U;
#line 3870
    rval = qla2x00_post_async_login_work(vha, fcport, (uint16_t *)0U);
#line 3871
    if (rval == 0) {
#line 3872
      return (rval);
    } else {

    }
  } else {

  }
#line 3875
  fcport->flags = fcport->flags & 4294967287U;
#line 3876
  rval = qla2x00_fabric_login(vha, fcport, next_loopid);
#line 3877
  if (rval == 0) {
#line 3879
    opts = 0U;
#line 3880
    if ((fcport->flags & 4U) != 0U) {
#line 3881
      opts = (uint8_t )((unsigned int )opts | 2U);
    } else {

    }
#line 3882
    rval = qla2x00_get_port_database(vha, fcport, (int )opts);
#line 3883
    if (rval != 0) {
#line 3884
      (*((ha->isp_ops)->fabric_logout))(vha, (int )fcport->loop_id, (int )fcport->d_id.b.domain,
                                        (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
#line 3887
      qla2x00_mark_device_lost(vha, fcport, 1, 0);
    } else {
#line 3889
      qla2x00_update_fcport(vha, fcport);
    }
  } else {
#line 3893
    qla2x00_mark_device_lost(vha, fcport, 1, 0);
  }
#line 3896
  return (rval);
}
}
#line 3914 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla2x00_fabric_login(scsi_qla_host_t *vha , fc_port_t *fcport , uint16_t *next_loopid ) 
{ 
  int rval ;
  int retry ;
  uint16_t tmp_loopid ;
  uint16_t mb[32U] ;
  struct qla_hw_data *ha ;

  {
#line 3921
  ha = vha->hw;
#line 3923
  retry = 0;
#line 3924
  tmp_loopid = 0U;
  ldv_66703: 
#line 3927
  ql_dbg(268435456U, vha, 8192, "Trying Fabric Login w/loop id 0x%04x for port %02x%02x%02x.\n",
         (int )fcport->loop_id, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
         (int )fcport->d_id.b.al_pa);
#line 3934
  rval = (*((ha->isp_ops)->fabric_login))(vha, (int )fcport->loop_id, (int )fcport->d_id.b.domain,
                                          (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa,
                                          (uint16_t *)(& mb), 1);
#line 3937
  if (rval != 0) {
#line 3938
    return (rval);
  } else {

  }
#line 3940
  if ((unsigned int )mb[0] == 16391U) {
#line 3948
    retry = retry + 1;
#line 3949
    tmp_loopid = fcport->loop_id;
#line 3950
    fcport->loop_id = mb[1];
#line 3952
    ql_dbg(268435456U, vha, 8193, "Fabric Login: port in use - next loop id=0x%04x, port id= %02x%02x%02x.\n",
           (int )fcport->loop_id, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
           (int )fcport->d_id.b.al_pa);
  } else
#line 3958
  if ((unsigned int )mb[0] == 16384U) {
#line 3962
    if (retry != 0) {
#line 3964
      *next_loopid = tmp_loopid;
    } else {
#line 3970
      *next_loopid = (unsigned int )fcport->loop_id + 1U;
    }
#line 3973
    if ((int )mb[1] & 1) {
#line 3974
      fcport->port_type = 4;
    } else {
#line 3976
      fcport->port_type = 5;
#line 3977
      if (((int )mb[1] & 2) != 0) {
#line 3978
        fcport->flags = fcport->flags | 4U;
      } else {

      }
    }
#line 3982
    if ((int )mb[10] & 1) {
#line 3983
      fcport->supported_classes = fcport->supported_classes | 4U;
    } else {

    }
#line 3984
    if (((int )mb[10] & 2) != 0) {
#line 3985
      fcport->supported_classes = fcport->supported_classes | 8U;
    } else {

    }
#line 3987
    if ((ha->device_type & 134217728U) != 0U) {
#line 3988
      if (((int )mb[10] & 128) != 0) {
#line 3989
        fcport->flags = fcport->flags | 16U;
      } else {

      }
    } else {

    }
#line 3993
    rval = 0;
#line 3994
    goto ldv_66702;
  } else
#line 3995
  if ((unsigned int )mb[0] == 16392U) {
#line 3999
    fcport->loop_id = (uint16_t )((int )fcport->loop_id + 1);
#line 4000
    rval = qla2x00_find_new_loop_id(vha, fcport);
#line 4001
    if (rval != 0) {
#line 4003
      goto ldv_66702;
    } else {

    }
  } else
#line 4005
  if ((unsigned int )mb[0] == 16389U) {
#line 4011
    *next_loopid = fcport->loop_id;
#line 4012
    (*((ha->isp_ops)->fabric_logout))(vha, (int )fcport->loop_id, (int )fcport->d_id.b.domain,
                                      (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
#line 4015
    qla2x00_mark_device_lost(vha, fcport, 1, 0);
#line 4017
    rval = 1;
#line 4018
    goto ldv_66702;
  } else {
#line 4023
    ql_dbg(268435456U, vha, 8194, "Failed=%x port_id=%02x%02x%02x loop_id=%x jiffies=%lx.\n",
           (int )mb[0], (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa,
           (int )fcport->loop_id, jiffies);
#line 4029
    *next_loopid = fcport->loop_id;
#line 4030
    (*((ha->isp_ops)->fabric_logout))(vha, (int )fcport->loop_id, (int )fcport->d_id.b.domain,
                                      (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
#line 4033
    qla2x00_clear_loop_id(fcport);
#line 4034
    fcport->login_retry = 0;
#line 4036
    rval = 3;
#line 4037
    goto ldv_66702;
  }
#line 4039
  goto ldv_66703;
  ldv_66702: ;
#line 4041
  return (rval);
}
}
#line 4058 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla2x00_local_device_login(scsi_qla_host_t *vha , fc_port_t *fcport ) 
{ 
  int rval ;
  uint16_t mb[32U] ;

  {
#line 4063
  memset((void *)(& mb), 0, 64UL);
#line 4064
  rval = qla2x00_login_local_device(vha, fcport, (uint16_t *)(& mb), 1);
#line 4065
  if (rval == 0) {
#line 4067
    if ((unsigned int )mb[0] == 16389U) {
#line 4068
      rval = 1;
    } else
#line 4069
    if ((unsigned int )mb[0] == 16390U) {
#line 4071
      rval = 3;
    } else {

    }
  } else {

  }
#line 4074
  return (rval);
}
}
#line 4088 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla2x00_loop_resync(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  uint32_t wait_time ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 4090
  rval = 0;
#line 4095
  if (*((unsigned long *)vha->hw + 2UL) != 0UL) {
#line 4096
    req = *((vha->hw)->req_q_map);
  } else {
#line 4098
    req = vha->req;
  }
#line 4099
  rsp = req->rsp;
#line 4101
  clear_bit(10L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4102
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 4103
    rval = qla2x00_fw_ready(vha);
#line 4103
    if (rval == 0) {
#line 4105
      wait_time = 256U;
      ldv_66717: ;
#line 4107
      if (((vha->hw)->device_type & 131072U) == 0U) {
#line 4112
        qla2x00_marker(vha, req, rsp, 0, 0ULL, 2);
#line 4114
        vha->marker_needed = 0U;
      } else {

      }
#line 4118
      clear_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4120
      if (((vha->hw)->device_type & 131072U) != 0U) {
#line 4121
        qlafx00_configure_devices(vha);
      } else {
#line 4123
        qla2x00_configure_loop(vha);
      }
#line 4125
      wait_time = wait_time - 1U;
#line 4129
      tmp = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 4129
      if (tmp == 0) {
#line 4129
        tmp___0 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 4129
        if (tmp___0 == 0) {
#line 4129
          if (wait_time != 0U) {
#line 4129
            tmp___1 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 4129
            if (tmp___1 != 0) {
#line 4130
              goto ldv_66717;
            } else {
#line 4133
              goto ldv_66718;
            }
          } else {
#line 4133
            goto ldv_66718;
          }
        } else {
#line 4133
          goto ldv_66718;
        }
      } else {

      }
      ldv_66718: ;
    } else {

    }
  } else {

  }
#line 4133
  tmp___2 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 4133
  if (tmp___2 != 0) {
#line 4134
    return (258);
  } else {

  }
#line 4136
  if (rval != 0) {
#line 4137
    ql_dbg(268435456U, vha, 8300, "%s *** FAILED ***.\n", "qla2x00_loop_resync");
  } else {

  }
#line 4140
  return (rval);
}
}
#line 4151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla2x00_perform_loop_resync(scsi_qla_host_t *ha ) 
{ 
  int32_t rval ;
  int tmp ;

  {
#line 4153
  rval = 0;
#line 4155
  tmp = test_and_set_bit(5L, (unsigned long volatile   *)(& ha->dpc_flags));
#line 4155
  if (tmp == 0) {
#line 4157
    atomic_set(& ha->loop_down_timer, 0);
#line 4158
    if ((ha->device_flags & 2U) == 0U) {
#line 4159
      atomic_set(& ha->loop_state, 3);
#line 4160
      set_bit(6L, (unsigned long volatile   *)(& ha->dpc_flags));
#line 4161
      set_bit(9L, (unsigned long volatile   *)(& ha->dpc_flags));
#line 4162
      set_bit(4L, (unsigned long volatile   *)(& ha->dpc_flags));
#line 4164
      rval = qla2x00_loop_resync(ha);
    } else {
#line 4166
      atomic_set(& ha->loop_state, 6);
    }
#line 4168
    clear_bit(5L, (unsigned long volatile   *)(& ha->dpc_flags));
  } else {

  }
#line 4171
  return (rval);
}
}
#line 4175 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
void qla2x00_update_fcports(scsi_qla_host_t *base_vha ) 
{ 
  fc_port_t *fcport ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
#line 4179
  ha = base_vha->hw;
#line 4182
  tmp = spinlock_check(& ha->vport_slock);
#line 4182
  flags = _raw_spin_lock_irqsave(tmp);
#line 4184
  __mptr = (struct list_head  const  *)(base_vha->hw)->vp_list.next;
#line 4184
  vha = (struct scsi_qla_host *)__mptr;
#line 4184
  goto ldv_66749;
  ldv_66748: 
#line 4185
  atomic_inc(& vha->vref_count);
#line 4186
  __mptr___0 = (struct list_head  const  *)vha->vp_fcports.next;
#line 4186
  fcport = (fc_port_t *)__mptr___0;
#line 4186
  goto ldv_66746;
  ldv_66745: ;
#line 4187
  if ((unsigned long )fcport->drport != (unsigned long )((struct fc_rport *)0)) {
#line 4187
    tmp___1 = atomic_read((atomic_t const   *)(& fcport->state));
#line 4187
    if (tmp___1 != 1) {
#line 4189
      spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 4190
      qla2x00_rport_del((void *)fcport);
#line 4191
      tmp___0 = spinlock_check(& ha->vport_slock);
#line 4191
      flags = _raw_spin_lock_irqsave(tmp___0);
    } else {

    }
  } else {

  }
#line 4186
  __mptr___1 = (struct list_head  const  *)fcport->list.next;
#line 4186
  fcport = (fc_port_t *)__mptr___1;
  ldv_66746: ;
#line 4186
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 4188
    goto ldv_66745;
  } else {

  }
#line 4194
  atomic_dec(& vha->vref_count);
#line 4184
  __mptr___2 = (struct list_head  const  *)vha->list.next;
#line 4184
  vha = (struct scsi_qla_host *)__mptr___2;
  ldv_66749: ;
#line 4184
  if ((unsigned long )(& vha->list) != (unsigned long )(& (base_vha->hw)->vp_list)) {
#line 4186
    goto ldv_66748;
  } else {

  }
#line 4196
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 4197
  return;
}
}
#line 4201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
void qla83xx_reset_ownership(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t drv_presence ;
  uint32_t drv_presence_mask ;
  uint32_t dev_part_info1 ;
  uint32_t dev_part_info2 ;
  uint32_t class_type ;
  uint32_t class_type_mask ;
  uint16_t fcoe_other_function ;
  uint16_t i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 4203
  ha = vha->hw;
#line 4206
  class_type_mask = 3U;
#line 4207
  fcoe_other_function = 65535U;
#line 4209
  if ((ha->device_type & 262144U) != 0U) {
#line 4210
    tmp = qla8044_rd_direct(vha, 3U);
#line 4210
    drv_presence = (uint32_t )tmp;
#line 4212
    tmp___0 = qla8044_rd_direct(vha, 7U);
#line 4212
    dev_part_info1 = (uint32_t )tmp___0;
#line 4214
    tmp___1 = qla8044_rd_direct(vha, 14308U);
#line 4214
    dev_part_info2 = (uint32_t )tmp___1;
  } else {
#line 4217
    qla83xx_rd_reg(vha, 571483016U, & drv_presence);
#line 4218
    qla83xx_rd_reg(vha, 571483104U, & dev_part_info1);
#line 4219
    qla83xx_rd_reg(vha, 571483108U, & dev_part_info2);
  }
#line 4221
  i = 0U;
#line 4221
  goto ldv_66765;
  ldv_66764: 
#line 4222
  class_type = (dev_part_info1 >> (int )i * 4) & class_type_mask;
#line 4223
  if (class_type == 2U && (int )ha->portnum != (int )i) {
#line 4225
    fcoe_other_function = i;
#line 4226
    goto ldv_66763;
  } else {

  }
#line 4221
  i = (uint16_t )((int )i + 1);
  ldv_66765: ;
#line 4221
  if ((unsigned int )i <= 7U) {
#line 4223
    goto ldv_66764;
  } else {

  }
  ldv_66763: ;
#line 4229
  if ((unsigned int )fcoe_other_function == 65535U) {
#line 4230
    i = 0U;
#line 4230
    goto ldv_66768;
    ldv_66767: 
#line 4231
    class_type = (dev_part_info2 >> (int )i * 4) & class_type_mask;
#line 4233
    if (class_type == 2U && (int )i + 8 != (int )ha->portnum) {
#line 4235
      fcoe_other_function = (unsigned int )i + 8U;
#line 4236
      goto ldv_66766;
    } else {

    }
#line 4230
    i = (uint16_t )((int )i + 1);
    ldv_66768: ;
#line 4230
    if ((unsigned int )i <= 7U) {
#line 4232
      goto ldv_66767;
    } else {

    }
    ldv_66766: ;
  } else {

  }
#line 4244
  drv_presence_mask = (uint32_t )(~ ((1 << (int )ha->portnum) | ((unsigned int )fcoe_other_function != 65535U ? 1 << (int )fcoe_other_function : 0)));
#line 4251
  if ((drv_presence & drv_presence_mask) == 0U && (int )ha->portnum < (int )fcoe_other_function) {
#line 4253
    ql_dbg(524288U, vha, 45183, "This host is Reset owner.\n");
#line 4255
    ha->flags.nic_core_reset_owner = 1U;
  } else {

  }
#line 4257
  return;
}
}
#line 4260 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static int __qla83xx_set_drv_ack(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  uint32_t drv_ack ;

  {
#line 4262
  rval = 0;
#line 4263
  ha = vha->hw;
#line 4266
  rval = qla83xx_rd_reg(vha, 571483020U, & drv_ack);
#line 4267
  if (rval == 0) {
#line 4268
    drv_ack = (uint32_t )(1 << (int )ha->portnum) | drv_ack;
#line 4269
    rval = qla83xx_wr_reg(vha, 571483020U, drv_ack);
  } else {

  }
#line 4272
  return (rval);
}
}
#line 4276 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static int __qla83xx_clear_drv_ack(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  uint32_t drv_ack ;

  {
#line 4278
  rval = 0;
#line 4279
  ha = vha->hw;
#line 4282
  rval = qla83xx_rd_reg(vha, 571483020U, & drv_ack);
#line 4283
  if (rval == 0) {
#line 4284
    drv_ack = (uint32_t )(~ (1 << (int )ha->portnum)) & drv_ack;
#line 4285
    rval = qla83xx_wr_reg(vha, 571483020U, drv_ack);
  } else {

  }
#line 4288
  return (rval);
}
}
#line 4292 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static char const   *qla83xx_dev_state_to_string(uint32_t dev_state ) 
{ 


  {
#line 4294
  switch (dev_state) {
  case 1U: ;
#line 4296
  return ("COLD/RE-INIT");
  case 2U: ;
#line 4298
  return ("INITIALIZING");
  case 3U: ;
#line 4300
  return ("READY");
  case 4U: ;
#line 4302
  return ("NEED RESET");
  case 5U: ;
#line 4304
  return ("NEED QUIESCENT");
  case 6U: ;
#line 4306
  return ("FAILED");
  case 7U: ;
#line 4308
  return ("QUIESCENT");
  default: ;
#line 4310
  return ("Unknown");
  }
}
}
#line 4316 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
void qla83xx_idc_audit(scsi_qla_host_t *vha , int audit_type ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t idc_audit_reg ;
  uint32_t duration_secs ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 4318
  ha = vha->hw;
#line 4319
  idc_audit_reg = 0U;
#line 4319
  duration_secs = 0U;
#line 4321
  switch (audit_type) {
  case 0: 
#line 4323
  tmp = jiffies_to_msecs(jiffies);
#line 4323
  ha->idc_audit_ts = tmp / 1000U;
#line 4324
  idc_audit_reg = (uint32_t )ha->portnum | (ha->idc_audit_ts << 8);
#line 4326
  qla83xx_wr_reg(vha, 571483028U, idc_audit_reg);
#line 4327
  goto ldv_66800;
  case 1: 
#line 4330
  tmp___0 = jiffies_to_msecs(jiffies);
#line 4330
  tmp___1 = jiffies_to_msecs((unsigned long const   )ha->idc_audit_ts);
#line 4330
  duration_secs = (tmp___0 - tmp___1) / 1000U;
#line 4332
  idc_audit_reg = ((unsigned int )ha->portnum | 128U) | (duration_secs << 8);
#line 4334
  qla83xx_wr_reg(vha, 571483028U, idc_audit_reg);
#line 4335
  goto ldv_66800;
  default: 
#line 4338
  ql_log(1U, vha, 45176, "Invalid audit type specified.\n");
#line 4340
  goto ldv_66800;
  }
  ldv_66800: ;
#line 4343
  return;
}
}
#line 4346 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static int qla83xx_initiating_reset(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t idc_control ;
  uint32_t dev_state ;
  char const   *state ;
  char const   *tmp ;

  {
#line 4348
  ha = vha->hw;
#line 4351
  __qla83xx_get_idc_control(vha, & idc_control);
#line 4352
  if ((int )idc_control & 1) {
#line 4353
    ql_log(2U, vha, 45184, "NIC Core reset has been disabled. idc-control=0x%x\n",
           idc_control);
#line 4356
    return (258);
  } else {

  }
#line 4360
  qla83xx_rd_reg(vha, 571483012U, & dev_state);
#line 4361
  if (*((unsigned long *)ha + 2UL) != 0UL && dev_state == 3U) {
#line 4362
    qla83xx_wr_reg(vha, 571483012U, 4U);
#line 4364
    ql_log(2U, vha, 45142, "HW State: NEED RESET.\n");
#line 4365
    qla83xx_idc_audit(vha, 0);
  } else {
#line 4367
    tmp = qla83xx_dev_state_to_string(dev_state);
#line 4367
    state = tmp;
#line 4368
    ql_log(2U, vha, 45143, "HW State: %s.\n", state);
#line 4372
    goto ldv_66811;
    ldv_66810: 
#line 4373
    qla83xx_idc_unlock(vha, 0);
#line 4374
    msleep(200U);
#line 4375
    qla83xx_idc_lock(vha, 0);
#line 4376
    qla83xx_rd_reg(vha, 571483012U, & dev_state);
    ldv_66811: ;
#line 4372
    if (dev_state == 3U) {
#line 4374
      goto ldv_66810;
    } else {

    }

  }
#line 4381
  __qla83xx_set_drv_ack(vha);
#line 4383
  return (0);
}
}
#line 4387 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int __qla83xx_set_idc_control(scsi_qla_host_t *vha , uint32_t idc_control ) 
{ 
  int tmp ;

  {
#line 4389
  tmp = qla83xx_wr_reg(vha, 571483024U, idc_control);
#line 4389
  return (tmp);
}
}
#line 4393 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int __qla83xx_get_idc_control(scsi_qla_host_t *vha , uint32_t *idc_control ) 
{ 
  int tmp ;

  {
#line 4395
  tmp = qla83xx_rd_reg(vha, 571483024U, idc_control);
#line 4395
  return (tmp);
}
}
#line 4399 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static int qla83xx_check_driver_presence(scsi_qla_host_t *vha ) 
{ 
  uint32_t drv_presence ;
  struct qla_hw_data *ha ;

  {
#line 4401
  drv_presence = 0U;
#line 4402
  ha = vha->hw;
#line 4404
  qla83xx_rd_reg(vha, 571483016U, & drv_presence);
#line 4405
  if (((uint32_t )(1 << (int )ha->portnum) & drv_presence) != 0U) {
#line 4406
    return (0);
  } else {
#line 4408
    return (3);
  }
}
}
#line 4412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla83xx_nic_core_reset(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 4414
  rval = 0;
#line 4415
  ha = vha->hw;
#line 4417
  ql_dbg(524288U, vha, 45144, "Entered  %s().\n", "qla83xx_nic_core_reset");
#line 4420
  if ((vha->device_flags & 32U) != 0U) {
#line 4421
    ql_log(1U, vha, 45145, "Device in unrecoverable FAILED state.\n");
#line 4423
    return (258);
  } else {

  }
#line 4426
  qla83xx_idc_lock(vha, 0);
#line 4428
  tmp = qla83xx_check_driver_presence(vha);
#line 4428
  if (tmp != 0) {
#line 4429
    ql_log(1U, vha, 45146, "Function=0x%x has been removed from IDC participation.\n",
           (int )ha->portnum);
#line 4432
    rval = 258;
#line 4433
    goto exit;
  } else {

  }
#line 4436
  qla83xx_reset_ownership(vha);
#line 4438
  rval = qla83xx_initiating_reset(vha);
#line 4444
  if (rval == 0) {
#line 4445
    rval = qla83xx_idc_state_handler(vha);
#line 4447
    if (rval == 0) {
#line 4448
      ha->flags.nic_core_hung = 0U;
    } else {

    }
#line 4449
    __qla83xx_clear_drv_ack(vha);
  } else {

  }
  exit: 
#line 4453
  qla83xx_idc_unlock(vha, 0);
#line 4455
  ql_dbg(524288U, vha, 45147, "Exiting %s.\n", "qla83xx_nic_core_reset");
#line 4457
  return (rval);
}
}
#line 4461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla2xxx_mctp_dump(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  int rval ;

  {
#line 4463
  ha = vha->hw;
#line 4464
  rval = 258;
#line 4466
  if ((ha->device_type & 32768U) == 0U || ((int )ha->fw_attributes_ext[0] & 1) == 0) {
#line 4468
    ql_log(2U, vha, 20589, "This board is not MCTP capable\n");
#line 4470
    return (rval);
  } else {

  }
#line 4473
  if ((unsigned long )ha->mctp_dump == (unsigned long )((void *)0)) {
#line 4474
    ha->mctp_dump = dma_alloc_attrs(& (ha->pdev)->dev, 548964UL, & ha->mctp_dump_dma,
                                    208U, (struct dma_attrs *)0);
#line 4477
    if ((unsigned long )ha->mctp_dump == (unsigned long )((void *)0)) {
#line 4478
      ql_log(1U, vha, 20590, "Failed to allocate memory for mctp dump\n");
#line 4480
      return (rval);
    } else {

    }
  } else {

  }
#line 4485
  rval = qla2x00_dump_mctp_data(vha, ha->mctp_dump_dma, 0U, 137241U);
#line 4487
  if (rval != 0) {
#line 4488
    ql_log(1U, vha, 20591, "Failed to capture mctp dump\n");
  } else {
#line 4491
    ql_log(2U, vha, 20592, "Mctp dump capture for host (%ld/%p).\n", vha->host_no,
           ha->mctp_dump);
#line 4494
    ha->mctp_dumped = 1;
  }
#line 4497
  if (*((unsigned long *)ha + 2UL) == 0UL && (unsigned int )ha->portnum == 0U) {
#line 4498
    ha->flags.nic_core_reset_hdlr_active = 1U;
#line 4499
    rval = qla83xx_restart_nic_firmware(vha);
#line 4500
    if (rval != 0) {
#line 4502
      ql_log(1U, vha, 20593, "Failed to restart nic firmware\n");
    } else {
#line 4505
      ql_dbg(524288U, vha, 45188, "Restarted NIC firmware successfully.\n");
    }
#line 4507
    ha->flags.nic_core_reset_hdlr_active = 0U;
  } else {

  }
#line 4510
  return (rval);
}
}
#line 4523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
void qla2x00_quiesce_io(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct scsi_qla_host *vp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 4525
  ha = vha->hw;
#line 4528
  ql_dbg(67108864U, vha, 16413, "Quiescing I/O - ha=%p.\n", ha);
#line 4531
  atomic_set(& ha->loop_down_timer, 255);
#line 4532
  tmp___0 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 4532
  if (tmp___0 != 2) {
#line 4533
    atomic_set(& vha->loop_state, 2);
#line 4534
    qla2x00_mark_all_devices_lost(vha, 0);
#line 4535
    __mptr = (struct list_head  const  *)ha->vp_list.next;
#line 4535
    vp = (struct scsi_qla_host *)__mptr;
#line 4535
    goto ldv_66848;
    ldv_66847: 
#line 4536
    qla2x00_mark_all_devices_lost(vp, 0);
#line 4535
    __mptr___0 = (struct list_head  const  *)vp->list.next;
#line 4535
    vp = (struct scsi_qla_host *)__mptr___0;
    ldv_66848: ;
#line 4535
    if ((unsigned long )(& vp->list) != (unsigned long )(& ha->vp_list)) {
#line 4537
      goto ldv_66847;
    } else {

    }

  } else {
#line 4538
    tmp = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 4538
    if (tmp == 0) {
#line 4539
      atomic_set(& vha->loop_down_timer, 255);
    } else {

    }
  }
#line 4543
  qla2x00_eh_wait_for_pending_commands(vha, 0U, 0ULL, 0);
#line 4544
  return;
}
}
#line 4547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
void qla2x00_abort_isp_cleanup(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct scsi_qla_host *vp ;
  unsigned long flags ;
  fc_port_t *fcport ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  raw_spinlock_t *tmp___0 ;
  struct list_head  const  *__mptr___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  raw_spinlock_t *tmp___3 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;
  struct list_head  const  *__mptr___5 ;
  raw_spinlock_t *tmp___4 ;
  struct list_head  const  *__mptr___6 ;

  {
#line 4549
  ha = vha->hw;
#line 4557
  if ((ha->device_type & 16384U) == 0U && (ha->device_type & 262144U) == 0U) {
#line 4558
    vha->flags.online = 0U;
  } else {

  }
#line 4559
  ha->flags.chip_reset_done = 0U;
#line 4560
  clear_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4561
  vha->qla_stats.total_isp_aborts = vha->qla_stats.total_isp_aborts + 1U;
#line 4563
  ql_log(2U, vha, 175, "Performing ISP error recovery - ha=%p.\n", ha);
#line 4570
  if ((ha->device_type & 16384U) == 0U && (ha->device_type & 262144U) == 0U) {
#line 4571
    (*((ha->isp_ops)->reset_chip))(vha);
  } else {

  }
#line 4573
  atomic_set(& vha->loop_down_timer, 255);
#line 4574
  tmp___2 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 4574
  if (tmp___2 != 2) {
#line 4575
    atomic_set(& vha->loop_state, 2);
#line 4576
    qla2x00_mark_all_devices_lost(vha, 0);
#line 4578
    tmp = spinlock_check(& ha->vport_slock);
#line 4578
    flags = _raw_spin_lock_irqsave(tmp);
#line 4579
    __mptr = (struct list_head  const  *)ha->vp_list.next;
#line 4579
    vp = (struct scsi_qla_host *)__mptr;
#line 4579
    goto ldv_66868;
    ldv_66867: 
#line 4580
    atomic_inc(& vp->vref_count);
#line 4581
    spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 4583
    qla2x00_mark_all_devices_lost(vp, 0);
#line 4585
    tmp___0 = spinlock_check(& ha->vport_slock);
#line 4585
    flags = _raw_spin_lock_irqsave(tmp___0);
#line 4586
    atomic_dec(& vp->vref_count);
#line 4579
    __mptr___0 = (struct list_head  const  *)vp->list.next;
#line 4579
    vp = (struct scsi_qla_host *)__mptr___0;
    ldv_66868: ;
#line 4579
    if ((unsigned long )(& vp->list) != (unsigned long )(& ha->vp_list)) {
#line 4581
      goto ldv_66867;
    } else {

    }
#line 4588
    spin_unlock_irqrestore(& ha->vport_slock, flags);
  } else {
#line 4590
    tmp___1 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 4590
    if (tmp___1 == 0) {
#line 4591
      atomic_set(& vha->loop_down_timer, 255);
    } else {

    }
  }
#line 4596
  __mptr___1 = (struct list_head  const  *)vha->vp_fcports.next;
#line 4596
  fcport = (fc_port_t *)__mptr___1;
#line 4596
  goto ldv_66875;
  ldv_66874: 
#line 4597
  fcport->flags = fcport->flags & 4294967285U;
#line 4596
  __mptr___2 = (struct list_head  const  *)fcport->list.next;
#line 4596
  fcport = (fc_port_t *)__mptr___2;
  ldv_66875: ;
#line 4596
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 4598
    goto ldv_66874;
  } else {

  }
#line 4598
  tmp___3 = spinlock_check(& ha->vport_slock);
#line 4598
  flags = _raw_spin_lock_irqsave(tmp___3);
#line 4599
  __mptr___3 = (struct list_head  const  *)ha->vp_list.next;
#line 4599
  vp = (struct scsi_qla_host *)__mptr___3;
#line 4599
  goto ldv_66895;
  ldv_66894: 
#line 4600
  atomic_inc(& vp->vref_count);
#line 4601
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 4603
  __mptr___4 = (struct list_head  const  *)vp->vp_fcports.next;
#line 4603
  fcport = (fc_port_t *)__mptr___4;
#line 4603
  goto ldv_66889;
  ldv_66888: 
#line 4604
  fcport->flags = fcport->flags & 4294967285U;
#line 4603
  __mptr___5 = (struct list_head  const  *)fcport->list.next;
#line 4603
  fcport = (fc_port_t *)__mptr___5;
  ldv_66889: ;
#line 4603
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vp->vp_fcports)) {
#line 4605
    goto ldv_66888;
  } else {

  }
#line 4606
  tmp___4 = spinlock_check(& ha->vport_slock);
#line 4606
  flags = _raw_spin_lock_irqsave(tmp___4);
#line 4607
  atomic_dec(& vp->vref_count);
#line 4599
  __mptr___6 = (struct list_head  const  *)vp->list.next;
#line 4599
  vp = (struct scsi_qla_host *)__mptr___6;
  ldv_66895: ;
#line 4599
  if ((unsigned long )(& vp->list) != (unsigned long )(& ha->vp_list)) {
#line 4601
    goto ldv_66894;
  } else {

  }
#line 4609
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 4611
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 4613
    if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 4614
      qla82xx_chip_reset_cleanup(vha);
#line 4615
      ql_log(2U, vha, 180, "Done chip reset cleanup.\n");
#line 4621
      vha->flags.online = 0U;
    } else {

    }
#line 4625
    qla2x00_abort_all_cmds(vha, 524288);
  } else {

  }
#line 4628
  ha->chip_reset = ha->chip_reset + 1U;
#line 4630
  __asm__  volatile   ("sfence": : : "memory");
#line 4631
  return;
}
}
#line 4644 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla2x00_abort_isp(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  uint8_t status ;
  struct qla_hw_data *ha ;
  struct scsi_qla_host *vp ;
  struct req_que *req ;
  unsigned long flags ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  raw_spinlock_t *tmp___5 ;
  struct list_head  const  *__mptr ;
  raw_spinlock_t *tmp___6 ;
  struct list_head  const  *__mptr___0 ;
  int tmp___7 ;

  {
#line 4647
  status = 0U;
#line 4648
  ha = vha->hw;
#line 4650
  req = *(ha->req_q_map);
#line 4653
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 4654
    qla2x00_abort_isp_cleanup(vha);
#line 4656
    if ((ha->device_type & 65536U) != 0U) {
#line 4657
      ql_dbg(524288U, vha, 45148, "Clearing fcoe driver presence.\n");
#line 4659
      tmp = qla83xx_clear_drv_presence(vha);
#line 4659
      if (tmp != 0) {
#line 4660
        ql_dbg(524288U, vha, 45171, "Error while clearing DRV-Presence.\n");
      } else {

      }
    } else {

    }
#line 4664
    tmp___0 = pci_channel_offline(ha->pdev);
#line 4664
    tmp___1 = ldv__builtin_expect((long )(tmp___0 != 0 && *((unsigned long *)ha + 2UL) != 0UL),
                               0L);
#line 4664
    if (tmp___1 != 0L) {
#line 4666
      clear_bit(10L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4667
      status = 0U;
#line 4668
      return ((int )status);
    } else {

    }
#line 4671
    (*((ha->isp_ops)->get_flash_version))(vha, (void *)req->ring);
#line 4673
    (*((ha->isp_ops)->nvram_config))(vha);
#line 4675
    tmp___4 = qla2x00_restart_isp(vha);
#line 4675
    if (tmp___4 == 0) {
#line 4676
      clear_bit(0L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4678
      tmp___2 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 4678
      if (tmp___2 == 0) {
#line 4683
        vha->marker_needed = 1U;
      } else {

      }
#line 4686
      vha->flags.online = 1U;
#line 4688
      (*((ha->isp_ops)->enable_intrs))(ha);
#line 4690
      ha->isp_abort_cnt = 0U;
#line 4691
      clear_bit(10L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4693
      if ((ha->device_type & 8192U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 4694
        qla2x00_get_fw_version(vha);
      } else {

      }
#line 4695
      if ((unsigned long )ha->fce != (unsigned long )((void *)0)) {
#line 4696
        ha->flags.fce_enabled = 1U;
#line 4697
        memset(ha->fce, 0, (size_t )(ha->fce_bufs * 1024U));
#line 4699
        rval = qla2x00_enable_fce_trace(vha, ha->fce_dma, (int )((uint16_t )ha->fce_bufs),
                                        (uint16_t *)(& ha->fce_mb), & ha->fce_bufs);
#line 4702
        if (rval != 0) {
#line 4703
          ql_log(1U, vha, 32819, "Unable to reinitialize FCE (%d).\n", rval);
#line 4706
          ha->flags.fce_enabled = 0U;
        } else {

        }
      } else {

      }
#line 4710
      if ((unsigned long )ha->eft != (unsigned long )((void *)0)) {
#line 4711
        memset(ha->eft, 0, 65536UL);
#line 4712
        rval = qla2x00_enable_eft_trace(vha, ha->eft_dma, 4);
#line 4714
        if (rval != 0) {
#line 4715
          ql_log(1U, vha, 32820, "Unable to reinitialize EFT (%d).\n", rval);
        } else {

        }
      } else {

      }
    } else {
#line 4721
      vha->flags.online = 1U;
#line 4722
      tmp___3 = constant_test_bit(10L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 4722
      if (tmp___3 != 0) {
#line 4723
        if (ha->isp_abort_cnt == 0U) {
#line 4724
          ql_log(0U, vha, 32821, "ISP error recover failed - board disabled.\n");
#line 4731
          (*((ha->isp_ops)->reset_adapter))(vha);
#line 4732
          vha->flags.online = 0U;
#line 4733
          clear_bit(10L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4735
          status = 0U;
        } else {
#line 4737
          ha->isp_abort_cnt = ha->isp_abort_cnt - 1U;
#line 4738
          ql_dbg(4194304U, vha, 32800, "ISP abort - retry remaining %d.\n", ha->isp_abort_cnt);
#line 4741
          status = 1U;
        }
      } else {
#line 4744
        ha->isp_abort_cnt = 5U;
#line 4745
        ql_dbg(4194304U, vha, 32801, "ISP error recovery - retrying (%d) more times.\n",
               ha->isp_abort_cnt);
#line 4748
        set_bit(10L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4749
        status = 1U;
      }
    }
  } else {

  }
#line 4755
  if ((unsigned int )status == 0U) {
#line 4756
    ql_dbg(4194304U, vha, 32802, "%s succeeded.\n", "qla2x00_abort_isp");
#line 4758
    tmp___5 = spinlock_check(& ha->vport_slock);
#line 4758
    flags = _raw_spin_lock_irqsave(tmp___5);
#line 4759
    __mptr = (struct list_head  const  *)ha->vp_list.next;
#line 4759
    vp = (struct scsi_qla_host *)__mptr;
#line 4759
    goto ldv_66918;
    ldv_66917: ;
#line 4760
    if ((unsigned int )vp->vp_idx != 0U) {
#line 4761
      atomic_inc(& vp->vref_count);
#line 4762
      spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 4764
      qla2x00_vp_abort_isp(vp);
#line 4766
      tmp___6 = spinlock_check(& ha->vport_slock);
#line 4766
      flags = _raw_spin_lock_irqsave(tmp___6);
#line 4767
      atomic_dec(& vp->vref_count);
    } else {

    }
#line 4759
    __mptr___0 = (struct list_head  const  *)vp->list.next;
#line 4759
    vp = (struct scsi_qla_host *)__mptr___0;
    ldv_66918: ;
#line 4759
    if ((unsigned long )(& vp->list) != (unsigned long )(& ha->vp_list)) {
#line 4761
      goto ldv_66917;
    } else {

    }
#line 4770
    spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 4772
    if ((ha->device_type & 65536U) != 0U) {
#line 4773
      ql_dbg(524288U, vha, 45149, "Setting back fcoe driver presence.\n");
#line 4775
      tmp___7 = qla83xx_set_drv_presence(vha);
#line 4775
      if (tmp___7 != 0) {
#line 4776
        ql_dbg(524288U, vha, 45172, "Error while setting DRV-Presence.\n");
      } else {

      }
    } else {

    }
  } else {
#line 4780
    ql_log(1U, vha, 32803, "%s **** FAILED ****.\n", "qla2x00_abort_isp");
  }
#line 4784
  return ((int )status);
}
}
#line 4798 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static int qla2x00_restart_isp(scsi_qla_host_t *vha ) 
{ 
  int status ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  unsigned long flags ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  bool tmp___1 ;

  {
#line 4800
  status = 0;
#line 4801
  ha = vha->hw;
#line 4802
  req = *(ha->req_q_map);
#line 4803
  rsp = *(ha->rsp_q_map);
#line 4807
  tmp = qla2x00_isp_firmware(vha);
#line 4807
  if (tmp != 0) {
#line 4808
    vha->flags.online = 0U;
#line 4809
    status = (*((ha->isp_ops)->chip_diag))(vha);
#line 4810
    if (status == 0) {
#line 4811
      status = qla2x00_setup_chip(vha);
    } else {

    }
  } else {

  }
#line 4814
  if (status == 0) {
#line 4814
    status = qla2x00_init_rings(vha);
#line 4814
    if (status == 0) {
#line 4815
      clear_bit(0L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4816
      ha->flags.chip_reset_done = 1U;
#line 4819
      qla25xx_init_queues(ha);
#line 4821
      status = qla2x00_fw_ready(vha);
#line 4822
      if (status == 0) {
#line 4824
        qla2x00_marker(vha, req, rsp, 0, 0ULL, 2);
#line 4826
        vha->flags.online = 1U;
#line 4832
        tmp___0 = spinlock_check(& ha->hardware_lock);
#line 4832
        flags = _raw_spin_lock_irqsave(tmp___0);
#line 4833
        tmp___1 = qla_tgt_mode_enabled(vha);
#line 4833
        if ((int )tmp___1) {
#line 4834
          qlt_24xx_process_atio_queue(vha);
        } else {

        }
#line 4835
        spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 4837
        set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
      } else {

      }
#line 4841
      if ((vha->device_flags & 2U) != 0U) {
#line 4842
        status = 0;
      } else {

      }
    } else {

    }
  } else {

  }
#line 4844
  return (status);
}
}
#line 4848 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static int qla25xx_init_queues(struct qla_hw_data *ha ) 
{ 
  struct rsp_que *rsp ;
  struct req_que *req ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  int ret ;
  int i ;

  {
#line 4850
  rsp = (struct rsp_que *)0;
#line 4851
  req = (struct req_que *)0;
#line 4852
  tmp = pci_get_drvdata(ha->pdev);
#line 4852
  base_vha = (struct scsi_qla_host *)tmp;
#line 4853
  ret = -1;
#line 4856
  i = 1;
#line 4856
  goto ldv_66941;
  ldv_66940: 
#line 4857
  rsp = *(ha->rsp_q_map + (unsigned long )i);
#line 4858
  if ((unsigned long )rsp != (unsigned long )((struct rsp_que *)0)) {
#line 4859
    rsp->options = (unsigned int )rsp->options & 65534U;
#line 4860
    ret = qla25xx_init_rsp_que(base_vha, rsp);
#line 4861
    if (ret != 0) {
#line 4862
      ql_dbg(1073741824U, base_vha, 255, "%s Rsp que: %d init failed.\n", "qla25xx_init_queues",
             (int )rsp->id);
    } else {
#line 4866
      ql_dbg(1073741824U, base_vha, 256, "%s Rsp que: %d inited.\n", "qla25xx_init_queues",
             (int )rsp->id);
    }
  } else {

  }
#line 4856
  i = i + 1;
  ldv_66941: ;
#line 4856
  if ((int )ha->max_rsp_queues > i) {
#line 4858
    goto ldv_66940;
  } else {

  }
#line 4871
  i = 1;
#line 4871
  goto ldv_66944;
  ldv_66943: 
#line 4872
  req = *(ha->req_q_map + (unsigned long )i);
#line 4873
  if ((unsigned long )req != (unsigned long )((struct req_que *)0)) {
#line 4875
    req->options = (unsigned int )req->options & 65534U;
#line 4876
    ret = qla25xx_init_req_que(base_vha, req);
#line 4877
    if (ret != 0) {
#line 4878
      ql_dbg(1073741824U, base_vha, 257, "%s Req que: %d init failed.\n", "qla25xx_init_queues",
             (int )req->id);
    } else {
#line 4882
      ql_dbg(1073741824U, base_vha, 258, "%s Req que: %d inited.\n", "qla25xx_init_queues",
             (int )req->id);
    }
  } else {

  }
#line 4871
  i = i + 1;
  ldv_66944: ;
#line 4871
  if ((int )ha->max_req_queues > i) {
#line 4873
    goto ldv_66943;
  } else {

  }

#line 4887
  return (ret);
}
}
#line 4898 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
void qla2x00_reset_adapter(struct scsi_qla_host *vha ) 
{ 
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  raw_spinlock_t *tmp ;

  {
#line 4900
  flags = 0UL;
#line 4901
  ha = vha->hw;
#line 4902
  reg = & (ha->iobase)->isp;
#line 4904
  vha->flags.online = 0U;
#line 4905
  (*((ha->isp_ops)->disable_intrs))(ha);
#line 4907
  tmp = spinlock_check(& ha->hardware_lock);
#line 4907
  flags = _raw_spin_lock_irqsave(tmp);
#line 4908
  writew(4096, (void volatile   *)(& reg->hccr));
#line 4909
  readw((void const volatile   *)(& reg->hccr));
#line 4910
  writew(12288, (void volatile   *)(& reg->hccr));
#line 4911
  readw((void const volatile   *)(& reg->hccr));
#line 4912
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 4913
  return;
}
}
#line 4916 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
void qla24xx_reset_adapter(struct scsi_qla_host *vha ) 
{ 
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  raw_spinlock_t *tmp ;

  {
#line 4918
  flags = 0UL;
#line 4919
  ha = vha->hw;
#line 4920
  reg = & (ha->iobase)->isp24;
#line 4922
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 4923
    return;
  } else {

  }
#line 4925
  vha->flags.online = 0U;
#line 4926
  (*((ha->isp_ops)->disable_intrs))(ha);
#line 4928
  tmp = spinlock_check(& ha->hardware_lock);
#line 4928
  flags = _raw_spin_lock_irqsave(tmp);
#line 4929
  writel(268435456U, (void volatile   *)(& reg->hccr));
#line 4930
  readl((void const volatile   *)(& reg->hccr));
#line 4931
  writel(1073741824U, (void volatile   *)(& reg->hccr));
#line 4932
  readl((void const volatile   *)(& reg->hccr));
#line 4933
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 4935
  if ((ha->device_type & 8192U) != 0U && *((unsigned long *)ha + 2UL) != 0UL) {
#line 4936
    (*((ha->isp_ops)->enable_intrs))(ha);
  } else {

  }
#line 4937
  return;
}
}
#line 4942 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static void qla24xx_nvram_wwn_from_ofw(scsi_qla_host_t *vha , struct nvram_24xx *nv ) 
{ 


  {
#line 4944
  return;
}
}
#line 4963 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla24xx_nvram_config(struct scsi_qla_host *vha ) 
{ 
  int rval ;
  struct init_cb_24xx *icb ;
  struct nvram_24xx *nv ;
  uint32_t *dptr ;
  uint8_t *dptr1 ;
  uint8_t *dptr2 ;
  uint32_t chksum ;
  uint16_t cnt ;
  struct qla_hw_data *ha ;
  uint32_t *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  uint8_t *tmp___2 ;
  uint8_t *tmp___3 ;
  uint16_t tmp___4 ;
  uint8_t *tmp___5 ;
  uint8_t *tmp___6 ;
  uint16_t tmp___7 ;

  {
#line 4972
  ha = vha->hw;
#line 4974
  rval = 0;
#line 4975
  icb = (struct init_cb_24xx *)ha->init_cb;
#line 4976
  nv = (struct nvram_24xx *)ha->nvram;
#line 4979
  if ((unsigned int )ha->port_no == 0U) {
#line 4980
    ha->nvram_base = 128U;
#line 4981
    ha->vpd_base = 0U;
  } else {
#line 4983
    ha->nvram_base = 384U;
#line 4984
    ha->vpd_base = 256U;
  }
#line 4987
  ha->nvram_size = 512U;
#line 4988
  ha->vpd_size = 512U;
#line 4991
  ha->vpd = ha->nvram + 2048UL;
#line 4992
  (*((ha->isp_ops)->read_nvram))(vha, (uint8_t *)ha->vpd, (uint32_t )((int )ha->nvram_base + -128),
                                 2048U);
#line 4996
  dptr = (uint32_t *)nv;
#line 4997
  (*((ha->isp_ops)->read_nvram))(vha, (uint8_t *)dptr, (uint32_t )ha->nvram_base,
                                 (uint32_t )ha->nvram_size);
#line 4999
  cnt = 0U;
#line 4999
  chksum = 0U;
#line 4999
  goto ldv_66981;
  ldv_66980: 
#line 5000
  tmp = dptr;
#line 5000
  dptr = dptr + 1;
#line 5000
  chksum = *tmp + chksum;
#line 4999
  cnt = (uint16_t )((int )cnt + 1);
  ldv_66981: ;
#line 4999
  if ((int )ha->nvram_size >> 2 > (int )cnt) {
#line 5001
    goto ldv_66980;
  } else {

  }
#line 5002
  ql_dbg(1073872896U, vha, 106, "Contents of NVRAM\n");
#line 5004
  ql_dump_buffer(1073872896U, vha, 269, (uint8_t *)nv, (uint32_t )ha->nvram_size);
#line 5008
  if (((((chksum != 0U || (unsigned int )nv->id[0] != 73U) || (unsigned int )nv->id[1] != 83U) || (unsigned int )nv->id[2] != 80U) || (unsigned int )nv->id[3] != 32U) || (unsigned int )nv->nvram_version == 0U) {
#line 5012
    ql_log(1U, vha, 107, "Inconsistent NVRAM detected: checksum=0x%x id=%c version=0x%x.\n",
           chksum, (int )nv->id[0], (int )nv->nvram_version);
#line 5015
    ql_log(1U, vha, 108, "Falling back to functioning (yet invalid -- WWPN) defaults.\n");
#line 5022
    memset((void *)nv, 0, (size_t )ha->nvram_size);
#line 5023
    nv->nvram_version = 1U;
#line 5024
    nv->version = 1U;
#line 5025
    nv->frame_payload_size = 2048U;
#line 5026
    nv->execution_throttle = 65535U;
#line 5027
    nv->exchange_count = 0U;
#line 5028
    nv->hard_address = 124U;
#line 5029
    nv->port_name[0] = 33U;
#line 5030
    nv->port_name[1] = (unsigned int )ha->port_no + 1U;
#line 5031
    nv->port_name[2] = 0U;
#line 5032
    nv->port_name[3] = 224U;
#line 5033
    nv->port_name[4] = 139U;
#line 5034
    nv->port_name[5] = 28U;
#line 5035
    nv->port_name[6] = 85U;
#line 5036
    nv->port_name[7] = 134U;
#line 5037
    nv->node_name[0] = 32U;
#line 5038
    nv->node_name[1] = 0U;
#line 5039
    nv->node_name[2] = 0U;
#line 5040
    nv->node_name[3] = 224U;
#line 5041
    nv->node_name[4] = 139U;
#line 5042
    nv->node_name[5] = 28U;
#line 5043
    nv->node_name[6] = 85U;
#line 5044
    nv->node_name[7] = 134U;
#line 5045
    qla24xx_nvram_wwn_from_ofw(vha, nv);
#line 5046
    nv->login_retry_count = 8U;
#line 5047
    nv->interrupt_delay_timer = 0U;
#line 5048
    nv->login_timeout = 0U;
#line 5049
    nv->firmware_options_1 = 24582U;
#line 5051
    nv->firmware_options_2 = 32U;
#line 5052
    nv->firmware_options_2 = nv->firmware_options_2 | 4096U;
#line 5053
    nv->firmware_options_3 = 16384U;
#line 5054
    nv->host_p = 3072U;
#line 5055
    nv->efi_parameters = 0U;
#line 5056
    nv->reset_delay = 5U;
#line 5057
    nv->max_luns_per_target = 128U;
#line 5058
    nv->port_down_retry_count = 30U;
#line 5059
    nv->link_down_timeout = 30U;
#line 5061
    rval = 1;
  } else {

  }
#line 5064
  tmp___0 = qla_ini_mode_enabled(vha);
#line 5064
  if (tmp___0) {
#line 5064
    tmp___1 = 0;
  } else {
#line 5064
    tmp___1 = 1;
  }
#line 5064
  if (tmp___1) {
#line 5066
    nv->firmware_options_1 = nv->firmware_options_1 & 4294959103U;
#line 5068
    nv->host_p = nv->host_p & 4294966271U;
  } else {

  }
#line 5071
  qlt_24xx_config_nvram_stage1(vha, nv);
#line 5074
  memset((void *)icb, 0, (size_t )ha->init_cb_size);
#line 5077
  dptr1 = (uint8_t *)icb;
#line 5078
  dptr2 = (uint8_t *)(& nv->version);
#line 5079
  cnt = 28U;
#line 5080
  goto ldv_66984;
  ldv_66983: 
#line 5081
  tmp___2 = dptr1;
#line 5081
  dptr1 = dptr1 + 1;
#line 5081
  tmp___3 = dptr2;
#line 5081
  dptr2 = dptr2 + 1;
#line 5081
  *tmp___2 = *tmp___3;
  ldv_66984: 
#line 5080
  tmp___4 = cnt;
#line 5080
  cnt = (uint16_t )((int )cnt - 1);
#line 5080
  if ((unsigned int )tmp___4 != 0U) {
#line 5082
    goto ldv_66983;
  } else {

  }
#line 5083
  icb->login_retry_count = nv->login_retry_count;
#line 5084
  icb->link_down_on_nos = nv->link_down_on_nos;
#line 5087
  dptr1 = (uint8_t *)(& icb->interrupt_delay_timer);
#line 5088
  dptr2 = (uint8_t *)(& nv->interrupt_delay_timer);
#line 5089
  cnt = 20U;
#line 5091
  goto ldv_66987;
  ldv_66986: 
#line 5092
  tmp___5 = dptr1;
#line 5092
  dptr1 = dptr1 + 1;
#line 5092
  tmp___6 = dptr2;
#line 5092
  dptr2 = dptr2 + 1;
#line 5092
  *tmp___5 = *tmp___6;
  ldv_66987: 
#line 5091
  tmp___7 = cnt;
#line 5091
  cnt = (uint16_t )((int )cnt - 1);
#line 5091
  if ((unsigned int )tmp___7 != 0U) {
#line 5093
    goto ldv_66986;
  } else {

  }
#line 5097
  qla2x00_set_model_info(vha, (uint8_t *)(& nv->model_name), 16UL, (char *)"QLA2462");
#line 5100
  qlt_24xx_config_nvram_stage2(vha, icb);
#line 5102
  if ((nv->host_p & 32768U) != 0U) {
#line 5104
    memcpy((void *)(& icb->node_name), (void const   *)(& nv->alternate_node_name),
             8UL);
#line 5105
    memcpy((void *)(& icb->port_name), (void const   *)(& nv->alternate_port_name),
             8UL);
  } else {

  }
#line 5109
  if ((icb->firmware_options_1 & 16384U) == 0U) {
#line 5114
    memcpy((void *)(& icb->node_name), (void const   *)(& icb->port_name), 8UL);
#line 5115
    icb->node_name[0] = (unsigned int )icb->node_name[0] & 240U;
  } else {

  }
#line 5119
  ha->flags.disable_risc_code_load = 0U;
#line 5120
  ha->flags.enable_lip_reset = 0U;
#line 5121
  ha->flags.enable_lip_full_login = (nv->host_p & 1024U) != 0U;
#line 5123
  ha->flags.enable_target_reset = (nv->host_p & 2048U) != 0U;
#line 5125
  ha->flags.enable_led_scheme = 0U;
#line 5126
  ha->flags.disable_serdes = (nv->host_p & 32U) != 0U;
#line 5128
  ha->operating_mode = (uint8_t )((icb->firmware_options_2 & 112U) >> 4);
#line 5131
  memcpy((void *)(& ha->fw_seriallink_options24), (void const   *)(& nv->seriallink_options),
           8UL);
#line 5135
  ha->serial0 = icb->port_name[5];
#line 5136
  ha->serial1 = icb->port_name[6];
#line 5137
  ha->serial2 = icb->port_name[7];
#line 5138
  memcpy((void *)(& vha->node_name), (void const   *)(& icb->node_name), 8UL);
#line 5139
  memcpy((void *)(& vha->port_name), (void const   *)(& icb->port_name), 8UL);
#line 5141
  icb->execution_throttle = 65535U;
#line 5143
  ha->retry_count = (uint8_t )nv->login_retry_count;
#line 5146
  if ((int )nv->login_timeout < ql2xlogintimeout) {
#line 5147
    nv->login_timeout = (unsigned short )ql2xlogintimeout;
  } else {

  }
#line 5148
  if ((unsigned int )nv->login_timeout <= 3U) {
#line 5149
    nv->login_timeout = 4U;
  } else {

  }
#line 5150
  ha->login_timeout = (uint8_t )nv->login_timeout;
#line 5151
  icb->login_timeout = nv->login_timeout;
#line 5154
  ha->r_a_tov = 100U;
#line 5156
  ha->loop_reset_delay = (uint16_t )nv->reset_delay;
#line 5168
  if ((unsigned int )nv->link_down_timeout == 0U) {
#line 5169
    ha->loop_down_abort_time = 195U;
  } else {
#line 5172
    ha->link_down_timeout = (uint8_t )nv->link_down_timeout;
#line 5173
    ha->loop_down_abort_time = ~ ((int )ha->link_down_timeout);
  }
#line 5178
  ha->port_down_retry_count = (int )nv->port_down_retry_count;
#line 5179
  if (qlport_down_retry != 0) {
#line 5180
    ha->port_down_retry_count = qlport_down_retry;
  } else {

  }
#line 5183
  ha->login_retry_count = (uint32_t )nv->login_retry_count;
#line 5184
  if (ha->port_down_retry_count == (int )nv->port_down_retry_count && ha->port_down_retry_count > 3) {
#line 5187
    ha->login_retry_count = (uint32_t )ha->port_down_retry_count;
  } else
#line 5188
  if (ha->port_down_retry_count > (int )ha->login_retry_count) {
#line 5189
    ha->login_retry_count = (uint32_t )ha->port_down_retry_count;
  } else {

  }
#line 5190
  if (ql2xloginretrycount != 0) {
#line 5191
    ha->login_retry_count = (uint32_t )ql2xloginretrycount;
  } else {

  }
#line 5194
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 5195
    ha->zio_mode = (unsigned int )((uint16_t )icb->firmware_options_2) & 15U;
#line 5197
    ha->zio_timer = (unsigned int )icb->interrupt_delay_timer != 0U ? icb->interrupt_delay_timer : 2U;
  } else {

  }
#line 5200
  icb->firmware_options_2 = icb->firmware_options_2 & 4294967280U;
#line 5202
  vha->flags.process_response_queue = 0U;
#line 5203
  if ((unsigned int )ha->zio_mode != 0U) {
#line 5204
    ha->zio_mode = 6U;
#line 5206
    ql_log(2U, vha, 111, "ZIO mode %d enabled; timer delay (%d us).\n", (int )ha->zio_mode,
           (int )ha->zio_timer * 100);
#line 5210
    icb->firmware_options_2 = icb->firmware_options_2 | (uint32_t )ha->zio_mode;
#line 5212
    icb->interrupt_delay_timer = ha->zio_timer;
#line 5213
    vha->flags.process_response_queue = 1U;
  } else {

  }
#line 5216
  if (rval != 0) {
#line 5217
    ql_log(1U, vha, 112, "NVRAM configuration failed.\n");
  } else {

  }
#line 5220
  return (rval);
}
}
#line 5224 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static int qla24xx_load_risc_flash(scsi_qla_host_t *vha , uint32_t *srisc_addr , uint32_t faddr ) 
{ 
  int rval ;
  int segments ;
  int fragment ;
  uint32_t *dcode ;
  uint32_t dlen ;
  uint32_t risc_addr ;
  uint32_t risc_size ;
  uint32_t i ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  int tmp___4 ;
  ulong tmp___5 ;
  ulong tmp___6 ;
  void const   *tmp___7 ;
  __u32 tmp___8 ;
  int tmp___9 ;
  ulong tmp___10 ;

  {
#line 5227
  rval = 0;
#line 5233
  ha = vha->hw;
#line 5234
  req = *(ha->req_q_map);
#line 5236
  ql_dbg(1073741824U, vha, 139, "FW: Loading firmware from flash (%x).\n", faddr);
#line 5239
  rval = 0;
#line 5241
  segments = 2;
#line 5242
  dcode = (uint32_t *)req->ring;
#line 5243
  *srisc_addr = 0U;
#line 5246
  qla24xx_read_flash_data(vha, dcode, faddr + 4U, 4U);
#line 5247
  i = 0U;
#line 5247
  goto ldv_67005;
  ldv_67004: 
#line 5248
  tmp = __fswab32(*(dcode + (unsigned long )i));
#line 5248
  *(dcode + (unsigned long )i) = tmp;
#line 5247
  i = i + 1U;
  ldv_67005: ;
#line 5247
  if (i <= 3U) {
#line 5249
    goto ldv_67004;
  } else {

  }

#line 5249
  if ((((*dcode == 4294967295U && *(dcode + 1UL) == 4294967295U) && *(dcode + 2UL) == 4294967295U) && *(dcode + 3UL) == 4294967295U) || (((*dcode == 0U && *(dcode + 1UL) == 0U) && *(dcode + 2UL) == 0U) && *(dcode + 3UL) == 0U)) {
#line 5253
    ql_log(0U, vha, 140, "Unable to verify the integrity of flash firmware image.\n");
#line 5256
    ql_log(0U, vha, 141, "Firmware data: %08x %08x %08x %08x.\n", *dcode, *(dcode + 1UL),
           *(dcode + 2UL), *(dcode + 3UL));
#line 5260
    return (258);
  } else {

  }
#line 5263
  goto ldv_67014;
  ldv_67013: 
#line 5265
  qla24xx_read_flash_data(vha, dcode, faddr, 4U);
#line 5267
  tmp___0 = __fswab32(*(dcode + 2UL));
#line 5267
  risc_addr = tmp___0;
#line 5268
  *srisc_addr = *srisc_addr != 0U ? *srisc_addr : risc_addr;
#line 5269
  tmp___1 = __fswab32(*(dcode + 3UL));
#line 5269
  risc_size = tmp___1;
#line 5271
  fragment = 0;
#line 5272
  goto ldv_67011;
  ldv_67010: 
#line 5273
  dlen = ha->fw_transfer_size >> 2;
#line 5274
  if (dlen > risc_size) {
#line 5275
    dlen = risc_size;
  } else {

  }
#line 5277
  ql_dbg(1073741824U, vha, 142, "Loading risc segment@ risc addr %x number of dwords 0x%x offset 0x%x.\n",
         risc_addr, dlen, faddr);
#line 5282
  qla24xx_read_flash_data(vha, dcode, faddr, dlen);
#line 5283
  i = 0U;
#line 5283
  goto ldv_67008;
  ldv_67007: 
#line 5284
  tmp___2 = __fswab32(*(dcode + (unsigned long )i));
#line 5284
  *(dcode + (unsigned long )i) = tmp___2;
#line 5283
  i = i + 1U;
  ldv_67008: ;
#line 5283
  if (i < dlen) {
#line 5285
    goto ldv_67007;
  } else {

  }
#line 5286
  rval = qla2x00_load_ram(vha, req->dma, risc_addr, dlen);
#line 5288
  if (rval != 0) {
#line 5289
    ql_log(0U, vha, 143, "Failed to load segment %d of firmware.\n", fragment);
#line 5292
    return (258);
  } else {

  }
#line 5295
  faddr = faddr + dlen;
#line 5296
  risc_addr = risc_addr + dlen;
#line 5297
  risc_size = risc_size - dlen;
#line 5298
  fragment = fragment + 1;
  ldv_67011: ;
#line 5272
  if (risc_size != 0U && rval == 0) {
#line 5274
    goto ldv_67010;
  } else {

  }
#line 5302
  segments = segments - 1;
  ldv_67014: ;
#line 5263
  if (segments != 0 && rval == 0) {
#line 5265
    goto ldv_67013;
  } else {

  }

#line 5305
  if ((ha->device_type & 524288U) == 0U && (ha->device_type & 1048576U) == 0U) {
#line 5306
    return (rval);
  } else {

  }
#line 5308
  if ((unsigned long )ha->fw_dump_template != (unsigned long )((void *)0)) {
#line 5309
    vfree((void const   *)ha->fw_dump_template);
  } else {

  }
#line 5310
  ha->fw_dump_template = (void *)0;
#line 5311
  ha->fw_dump_template_len = 0U;
#line 5313
  ql_dbg(1073741824U, vha, 353, "Loading fwdump template from %x\n", faddr);
#line 5315
  qla24xx_read_flash_data(vha, dcode, faddr, 7U);
#line 5316
  tmp___3 = __fswab32(*(dcode + 2UL));
#line 5316
  risc_size = tmp___3;
#line 5317
  ql_dbg(1073741824U, vha, 354, "-> array size %x dwords\n", risc_size);
#line 5319
  if (risc_size == 0U || risc_size == 4294967295U) {
#line 5320
    goto default_template;
  } else {

  }
#line 5322
  dlen = (risc_size + 1073741816U) * 4U;
#line 5323
  ql_dbg(1073741824U, vha, 355, "-> template allocating %x bytes...\n", dlen);
#line 5325
  ha->fw_dump_template = vmalloc((unsigned long )dlen);
#line 5326
  if ((unsigned long )ha->fw_dump_template == (unsigned long )((void *)0)) {
#line 5327
    ql_log(1U, vha, 356, "Failed fwdump template allocate %x bytes.\n", risc_size);
#line 5329
    goto default_template;
  } else {

  }
#line 5332
  faddr = faddr + 7U;
#line 5333
  risc_size = risc_size - 8U;
#line 5334
  dcode = (uint32_t *)ha->fw_dump_template;
#line 5335
  qla24xx_read_flash_data(vha, dcode, faddr, risc_size);
#line 5336
  i = 0U;
#line 5336
  goto ldv_67018;
  ldv_67017: 
#line 5337
  *(dcode + (unsigned long )i) = *(dcode + (unsigned long )i);
#line 5336
  i = i + 1U;
  ldv_67018: ;
#line 5336
  if (i < risc_size) {
#line 5338
    goto ldv_67017;
  } else {

  }
#line 5339
  tmp___4 = qla27xx_fwdt_template_valid((void *)dcode);
#line 5339
  if (tmp___4 == 0) {
#line 5340
    ql_log(1U, vha, 357, "Failed fwdump template validate\n");
#line 5342
    goto default_template;
  } else {

  }
#line 5345
  tmp___5 = qla27xx_fwdt_template_size((void *)dcode);
#line 5345
  dlen = (uint32_t )tmp___5;
#line 5346
  ql_dbg(1073741824U, vha, 358, "-> template size %x bytes\n", dlen);
#line 5348
  if ((unsigned long )dlen > (unsigned long )risc_size * 4UL) {
#line 5349
    ql_log(1U, vha, 359, "Failed fwdump template exceeds array by %x bytes\n", dlen - risc_size * 4U);
#line 5352
    goto default_template;
  } else {

  }
#line 5354
  ha->fw_dump_template_len = dlen;
#line 5355
  return (rval);
  default_template: 
#line 5358
  ql_log(1U, vha, 360, "Using default fwdump template\n");
#line 5359
  if ((unsigned long )ha->fw_dump_template != (unsigned long )((void *)0)) {
#line 5360
    vfree((void const   *)ha->fw_dump_template);
  } else {

  }
#line 5361
  ha->fw_dump_template = (void *)0;
#line 5362
  ha->fw_dump_template_len = 0U;
#line 5364
  tmp___6 = qla27xx_fwdt_template_default_size();
#line 5364
  dlen = (uint32_t )tmp___6;
#line 5365
  ql_dbg(1073741824U, vha, 361, "-> template allocating %x bytes...\n", dlen);
#line 5367
  ha->fw_dump_template = vmalloc((unsigned long )dlen);
#line 5368
  if ((unsigned long )ha->fw_dump_template == (unsigned long )((void *)0)) {
#line 5369
    ql_log(1U, vha, 362, "Failed fwdump template allocate %x bytes.\n", risc_size);
#line 5371
    goto failed_template;
  } else {

  }
#line 5374
  dcode = (uint32_t *)ha->fw_dump_template;
#line 5375
  risc_size = dlen / 4U;
#line 5376
  tmp___7 = qla27xx_fwdt_template_default();
#line 5376
  memcpy((void *)dcode, tmp___7, (size_t )dlen);
#line 5377
  i = 0U;
#line 5377
  goto ldv_67022;
  ldv_67021: 
#line 5378
  tmp___8 = __fswab32(*(dcode + (unsigned long )i));
#line 5378
  *(dcode + (unsigned long )i) = tmp___8;
#line 5377
  i = i + 1U;
  ldv_67022: ;
#line 5377
  if (i < risc_size) {
#line 5379
    goto ldv_67021;
  } else {

  }
#line 5380
  tmp___9 = qla27xx_fwdt_template_valid(ha->fw_dump_template);
#line 5380
  if (tmp___9 == 0) {
#line 5381
    ql_log(1U, vha, 363, "Failed fwdump template validate\n");
#line 5383
    goto failed_template;
  } else {

  }
#line 5386
  tmp___10 = qla27xx_fwdt_template_size(ha->fw_dump_template);
#line 5386
  dlen = (uint32_t )tmp___10;
#line 5387
  ql_dbg(1073741824U, vha, 364, "-> template size %x bytes\n", dlen);
#line 5389
  ha->fw_dump_template_len = dlen;
#line 5390
  return (rval);
  failed_template: 
#line 5393
  ql_log(1U, vha, 365, "Failed default fwdump template\n");
#line 5394
  if ((unsigned long )ha->fw_dump_template != (unsigned long )((void *)0)) {
#line 5395
    vfree((void const   *)ha->fw_dump_template);
  } else {

  }
#line 5396
  ha->fw_dump_template = (void *)0;
#line 5397
  ha->fw_dump_template_len = 0U;
#line 5398
  return (rval);
}
}
#line 5404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla2x00_load_risc(struct scsi_qla_host *vha , uint32_t *srisc_addr ) 
{ 
  int rval ;
  int i ;
  int fragment ;
  uint16_t *wcode ;
  uint16_t *fwcode ;
  uint32_t risc_addr ;
  uint32_t risc_size ;
  uint32_t fwclen ;
  uint32_t wlen ;
  uint32_t *seg ;
  struct fw_blob *blob ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  __u16 tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;

  {
#line 5411
  ha = vha->hw;
#line 5412
  req = *(ha->req_q_map);
#line 5415
  blob = qla2x00_request_firmware(vha);
#line 5416
  if ((unsigned long )blob == (unsigned long )((struct fw_blob *)0)) {
#line 5417
    ql_log(2U, vha, 131, "Firmware image unavailable.\n");
#line 5419
    ql_log(2U, vha, 132, "Firmware images can be retrieved from: http://ldriver.qlogic.com/firmware/.\n");
#line 5421
    return (258);
  } else {

  }
#line 5424
  rval = 0;
#line 5426
  wcode = (uint16_t *)req->ring;
#line 5427
  *srisc_addr = 0U;
#line 5428
  fwcode = (uint16_t *)(blob->fw)->data;
#line 5429
  fwclen = 0U;
#line 5432
  if ((unsigned long )(blob->fw)->size <= 15UL) {
#line 5433
    ql_log(0U, vha, 133, "Unable to verify integrity of firmware image (%Zd).\n",
           (blob->fw)->size);
#line 5436
    goto fail_fw_integrity;
  } else {

  }
#line 5438
  i = 0;
#line 5438
  goto ldv_67043;
  ldv_67042: 
#line 5439
  tmp = __fswab16((int )*(fwcode + ((unsigned long )i + 4UL)));
#line 5439
  *(wcode + (unsigned long )i) = tmp;
#line 5438
  i = i + 1;
  ldv_67043: ;
#line 5438
  if (i <= 3) {
#line 5440
    goto ldv_67042;
  } else {

  }

#line 5440
  if (((((unsigned int )*wcode == 65535U && (unsigned int )*(wcode + 1UL) == 65535U) && (unsigned int )*(wcode + 2UL) == 65535U) && (unsigned int )*(wcode + 3UL) == 65535U) || ((((unsigned int )*wcode == 0U && (unsigned int )*(wcode + 1UL) == 0U) && (unsigned int )*(wcode + 2UL) == 0U) && (unsigned int )*(wcode + 3UL) == 0U)) {
#line 5443
    ql_log(0U, vha, 134, "Unable to verify integrity of firmware image.\n");
#line 5445
    ql_log(0U, vha, 135, "Firmware data: %04x %04x %04x %04x.\n", (int )*wcode, (int )*(wcode + 1UL),
           (int )*(wcode + 2UL), (int )*(wcode + 3UL));
#line 5448
    goto fail_fw_integrity;
  } else {

  }
#line 5451
  seg = (uint32_t *)(& blob->segs);
#line 5452
  goto ldv_67052;
  ldv_67051: 
#line 5453
  risc_addr = *seg;
#line 5454
  *srisc_addr = *srisc_addr == 0U ? *seg : *srisc_addr;
#line 5455
  tmp___0 = __fswab16((int )*(fwcode + 3UL));
#line 5455
  risc_size = (uint32_t )tmp___0;
#line 5458
  fwclen = risc_size * 2U + fwclen;
#line 5459
  if ((unsigned long )(blob->fw)->size < (unsigned long )fwclen) {
#line 5460
    ql_log(0U, vha, 136, "Unable to verify integrity of firmware image (%Zd).\n",
           (blob->fw)->size);
#line 5463
    goto fail_fw_integrity;
  } else {

  }
#line 5466
  fragment = 0;
#line 5467
  goto ldv_67050;
  ldv_67049: 
#line 5468
  wlen = (uint32_t )((unsigned short )(ha->fw_transfer_size >> 1));
#line 5469
  if (wlen > risc_size) {
#line 5470
    wlen = risc_size;
  } else {

  }
#line 5471
  ql_dbg(1073741824U, vha, 137, "Loading risc segment@ risc addr %x number of words 0x%x.\n",
         risc_addr, wlen);
#line 5475
  i = 0;
#line 5475
  goto ldv_67046;
  ldv_67045: 
#line 5476
  tmp___1 = __fswab16((int )*(fwcode + (unsigned long )i));
#line 5476
  *(wcode + (unsigned long )i) = tmp___1;
#line 5475
  i = i + 1;
  ldv_67046: ;
#line 5475
  if ((uint32_t )i < wlen) {
#line 5477
    goto ldv_67045;
  } else {

  }
#line 5478
  rval = qla2x00_load_ram(vha, req->dma, risc_addr, wlen);
#line 5480
  if (rval != 0) {
#line 5481
    ql_log(0U, vha, 138, "Failed to load segment %d of firmware.\n", fragment);
#line 5484
    goto ldv_67048;
  } else {

  }
#line 5487
  fwcode = fwcode + (unsigned long )wlen;
#line 5488
  risc_addr = risc_addr + wlen;
#line 5489
  risc_size = risc_size - wlen;
#line 5490
  fragment = fragment + 1;
  ldv_67050: ;
#line 5467
  if (risc_size != 0U && rval == 0) {
#line 5469
    goto ldv_67049;
  } else {

  }
  ldv_67048: 
#line 5494
  seg = seg + 1;
  ldv_67052: ;
#line 5452
  if (*seg != 0U && rval == 0) {
#line 5454
    goto ldv_67051;
  } else {

  }

#line 5496
  return (rval);
  fail_fw_integrity: ;
#line 5499
  return (258);
}
}
#line 5503 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static int qla24xx_load_risc_blob(scsi_qla_host_t *vha , uint32_t *srisc_addr ) 
{ 
  int rval ;
  int segments ;
  int fragment ;
  uint32_t *dcode ;
  uint32_t dlen ;
  uint32_t risc_addr ;
  uint32_t risc_size ;
  uint32_t i ;
  struct fw_blob *blob ;
  uint32_t const   *fwcode ;
  uint32_t fwclen ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  int tmp___4 ;
  ulong tmp___5 ;
  ulong tmp___6 ;
  void const   *tmp___7 ;
  __u32 tmp___8 ;
  int tmp___9 ;
  ulong tmp___10 ;

  {
#line 5514
  ha = vha->hw;
#line 5515
  req = *(ha->req_q_map);
#line 5518
  blob = qla2x00_request_firmware(vha);
#line 5519
  if ((unsigned long )blob == (unsigned long )((struct fw_blob *)0)) {
#line 5520
    ql_log(1U, vha, 144, "Firmware image unavailable.\n");
#line 5522
    ql_log(1U, vha, 145, "Firmware images can be retrieved from: http://ldriver.qlogic.com/firmware/.\n");
#line 5526
    return (258);
  } else {

  }
#line 5529
  ql_dbg(1073741824U, vha, 146, "FW: Loading via request-firmware.\n");
#line 5532
  rval = 0;
#line 5534
  segments = 2;
#line 5535
  dcode = (uint32_t *)req->ring;
#line 5536
  *srisc_addr = 0U;
#line 5537
  fwcode = (uint32_t const   *)(blob->fw)->data;
#line 5538
  fwclen = 0U;
#line 5541
  if ((unsigned long )(blob->fw)->size <= 31UL) {
#line 5542
    ql_log(0U, vha, 147, "Unable to verify integrity of firmware image (%Zd).\n",
           (blob->fw)->size);
#line 5545
    return (258);
  } else {

  }
#line 5547
  i = 0U;
#line 5547
  goto ldv_67072;
  ldv_67071: 
#line 5548
  tmp = __fswab32(*(fwcode + (unsigned long )(i + 4U)));
#line 5548
  *(dcode + (unsigned long )i) = tmp;
#line 5547
  i = i + 1U;
  ldv_67072: ;
#line 5547
  if (i <= 3U) {
#line 5549
    goto ldv_67071;
  } else {

  }

#line 5549
  if ((((*dcode == 4294967295U && *(dcode + 1UL) == 4294967295U) && *(dcode + 2UL) == 4294967295U) && *(dcode + 3UL) == 4294967295U) || (((*dcode == 0U && *(dcode + 1UL) == 0U) && *(dcode + 2UL) == 0U) && *(dcode + 3UL) == 0U)) {
#line 5553
    ql_log(0U, vha, 148, "Unable to verify integrity of firmware image (%Zd).\n",
           (blob->fw)->size);
#line 5556
    ql_log(0U, vha, 149, "Firmware data: %08x %08x %08x %08x.\n", *dcode, *(dcode + 1UL),
           *(dcode + 2UL), *(dcode + 3UL));
#line 5559
    return (258);
  } else {

  }
#line 5562
  goto ldv_67081;
  ldv_67080: 
#line 5563
  tmp___0 = __fswab32(*(fwcode + 2UL));
#line 5563
  risc_addr = tmp___0;
#line 5564
  *srisc_addr = *srisc_addr != 0U ? *srisc_addr : risc_addr;
#line 5565
  tmp___1 = __fswab32(*(fwcode + 3UL));
#line 5565
  risc_size = tmp___1;
#line 5568
  fwclen = risc_size * 4U + fwclen;
#line 5569
  if ((unsigned long )(blob->fw)->size < (unsigned long )fwclen) {
#line 5570
    ql_log(0U, vha, 150, "Unable to verify integrity of firmware image (%Zd).\n",
           (blob->fw)->size);
#line 5573
    return (258);
  } else {

  }
#line 5576
  fragment = 0;
#line 5577
  goto ldv_67078;
  ldv_67077: 
#line 5578
  dlen = ha->fw_transfer_size >> 2;
#line 5579
  if (dlen > risc_size) {
#line 5580
    dlen = risc_size;
  } else {

  }
#line 5582
  ql_dbg(1073741824U, vha, 151, "Loading risc segment@ risc addr %x number of dwords 0x%x.\n",
         risc_addr, dlen);
#line 5586
  i = 0U;
#line 5586
  goto ldv_67075;
  ldv_67074: 
#line 5587
  tmp___2 = __fswab32(*(fwcode + (unsigned long )i));
#line 5587
  *(dcode + (unsigned long )i) = tmp___2;
#line 5586
  i = i + 1U;
  ldv_67075: ;
#line 5586
  if (i < dlen) {
#line 5588
    goto ldv_67074;
  } else {

  }
#line 5589
  rval = qla2x00_load_ram(vha, req->dma, risc_addr, dlen);
#line 5591
  if (rval != 0) {
#line 5592
    ql_log(0U, vha, 152, "Failed to load segment %d of firmware.\n", fragment);
#line 5595
    return (258);
  } else {

  }
#line 5598
  fwcode = fwcode + (unsigned long )dlen;
#line 5599
  risc_addr = risc_addr + dlen;
#line 5600
  risc_size = risc_size - dlen;
#line 5601
  fragment = fragment + 1;
  ldv_67078: ;
#line 5577
  if (risc_size != 0U && rval == 0) {
#line 5579
    goto ldv_67077;
  } else {

  }
#line 5605
  segments = segments - 1;
  ldv_67081: ;
#line 5562
  if (segments != 0 && rval == 0) {
#line 5564
    goto ldv_67080;
  } else {

  }

#line 5608
  if ((ha->device_type & 524288U) == 0U && (ha->device_type & 1048576U) == 0U) {
#line 5609
    return (rval);
  } else {

  }
#line 5611
  if ((unsigned long )ha->fw_dump_template != (unsigned long )((void *)0)) {
#line 5612
    vfree((void const   *)ha->fw_dump_template);
  } else {

  }
#line 5613
  ha->fw_dump_template = (void *)0;
#line 5614
  ha->fw_dump_template_len = 0U;
#line 5616
  ql_dbg(1073741824U, vha, 369, "Loading fwdump template from %x\n", (unsigned int )((long )fwcode) - (unsigned int )((long )(blob->fw)->data));
#line 5619
  tmp___3 = __fswab32(*(fwcode + 2UL));
#line 5619
  risc_size = tmp___3;
#line 5620
  ql_dbg(1073741824U, vha, 370, "-> array size %x dwords\n", risc_size);
#line 5622
  if (risc_size == 0U || risc_size == 4294967295U) {
#line 5623
    goto default_template;
  } else {

  }
#line 5625
  dlen = (risc_size + 1073741816U) * 4U;
#line 5626
  ql_dbg(1073741824U, vha, 371, "-> template allocating %x bytes...\n", dlen);
#line 5628
  ha->fw_dump_template = vmalloc((unsigned long )dlen);
#line 5629
  if ((unsigned long )ha->fw_dump_template == (unsigned long )((void *)0)) {
#line 5630
    ql_log(1U, vha, 372, "Failed fwdump template allocate %x bytes.\n", risc_size);
#line 5632
    goto default_template;
  } else {

  }
#line 5635
  fwcode = fwcode + 7UL;
#line 5636
  risc_size = risc_size - 8U;
#line 5637
  dcode = (uint32_t *)ha->fw_dump_template;
#line 5638
  i = 0U;
#line 5638
  goto ldv_67085;
  ldv_67084: 
#line 5639
  *(dcode + (unsigned long )i) = *(fwcode + (unsigned long )i);
#line 5638
  i = i + 1U;
  ldv_67085: ;
#line 5638
  if (i < risc_size) {
#line 5640
    goto ldv_67084;
  } else {

  }
#line 5641
  tmp___4 = qla27xx_fwdt_template_valid((void *)dcode);
#line 5641
  if (tmp___4 == 0) {
#line 5642
    ql_log(1U, vha, 373, "Failed fwdump template validate\n");
#line 5644
    goto default_template;
  } else {

  }
#line 5647
  tmp___5 = qla27xx_fwdt_template_size((void *)dcode);
#line 5647
  dlen = (uint32_t )tmp___5;
#line 5648
  ql_dbg(1073741824U, vha, 374, "-> template size %x bytes\n", dlen);
#line 5650
  if ((unsigned long )dlen > (unsigned long )risc_size * 4UL) {
#line 5651
    ql_log(1U, vha, 375, "Failed fwdump template exceeds array by %x bytes\n", dlen - risc_size * 4U);
#line 5654
    goto default_template;
  } else {

  }
#line 5656
  ha->fw_dump_template_len = dlen;
#line 5657
  return (rval);
  default_template: 
#line 5660
  ql_log(1U, vha, 376, "Using default fwdump template\n");
#line 5661
  if ((unsigned long )ha->fw_dump_template != (unsigned long )((void *)0)) {
#line 5662
    vfree((void const   *)ha->fw_dump_template);
  } else {

  }
#line 5663
  ha->fw_dump_template = (void *)0;
#line 5664
  ha->fw_dump_template_len = 0U;
#line 5666
  tmp___6 = qla27xx_fwdt_template_default_size();
#line 5666
  dlen = (uint32_t )tmp___6;
#line 5667
  ql_dbg(1073741824U, vha, 377, "-> template allocating %x bytes...\n", dlen);
#line 5669
  ha->fw_dump_template = vmalloc((unsigned long )dlen);
#line 5670
  if ((unsigned long )ha->fw_dump_template == (unsigned long )((void *)0)) {
#line 5671
    ql_log(1U, vha, 378, "Failed fwdump template allocate %x bytes.\n", risc_size);
#line 5673
    goto failed_template;
  } else {

  }
#line 5676
  dcode = (uint32_t *)ha->fw_dump_template;
#line 5677
  risc_size = dlen / 4U;
#line 5678
  tmp___7 = qla27xx_fwdt_template_default();
#line 5678
  fwcode = (uint32_t const   *)tmp___7;
#line 5679
  i = 0U;
#line 5679
  goto ldv_67089;
  ldv_67088: 
#line 5680
  tmp___8 = __fswab32(*(fwcode + (unsigned long )i));
#line 5680
  *(dcode + (unsigned long )i) = tmp___8;
#line 5679
  i = i + 1U;
  ldv_67089: ;
#line 5679
  if (i < risc_size) {
#line 5681
    goto ldv_67088;
  } else {

  }
#line 5682
  tmp___9 = qla27xx_fwdt_template_valid(ha->fw_dump_template);
#line 5682
  if (tmp___9 == 0) {
#line 5683
    ql_log(1U, vha, 379, "Failed fwdump template validate\n");
#line 5685
    goto failed_template;
  } else {

  }
#line 5688
  tmp___10 = qla27xx_fwdt_template_size(ha->fw_dump_template);
#line 5688
  dlen = (uint32_t )tmp___10;
#line 5689
  ql_dbg(1073741824U, vha, 380, "-> template size %x bytes\n", dlen);
#line 5691
  ha->fw_dump_template_len = dlen;
#line 5692
  return (rval);
  failed_template: 
#line 5695
  ql_log(1U, vha, 381, "Failed default fwdump template\n");
#line 5696
  if ((unsigned long )ha->fw_dump_template != (unsigned long )((void *)0)) {
#line 5697
    vfree((void const   *)ha->fw_dump_template);
  } else {

  }
#line 5698
  ha->fw_dump_template = (void *)0;
#line 5699
  ha->fw_dump_template_len = 0U;
#line 5700
  return (rval);
}
}
#line 5704 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla24xx_load_risc(scsi_qla_host_t *vha , uint32_t *srisc_addr ) 
{ 
  int rval ;
  int tmp ;
  int tmp___0 ;

  {
#line 5708
  if (ql2xfwloadbin == 1) {
#line 5709
    tmp = qla81xx_load_risc(vha, srisc_addr);
#line 5709
    return (tmp);
  } else {

  }
#line 5716
  rval = qla24xx_load_risc_blob(vha, srisc_addr);
#line 5717
  if (rval == 0) {
#line 5718
    return (rval);
  } else {

  }
#line 5720
  tmp___0 = qla24xx_load_risc_flash(vha, srisc_addr, (vha->hw)->flt_region_fw);
#line 5720
  return (tmp___0);
}
}
#line 5725 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla81xx_load_risc(scsi_qla_host_t *vha , uint32_t *srisc_addr ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;

  {
#line 5728
  ha = vha->hw;
#line 5730
  if (ql2xfwloadbin == 2) {
#line 5731
    goto try_blob_fw;
  } else {

  }
#line 5739
  rval = qla24xx_load_risc_flash(vha, srisc_addr, ha->flt_region_fw);
#line 5740
  if (rval == 0) {
#line 5741
    return (rval);
  } else {

  }
  try_blob_fw: 
#line 5744
  rval = qla24xx_load_risc_blob(vha, srisc_addr);
#line 5745
  if (rval == 0 || ha->flt_region_gold_fw == 0U) {
#line 5746
    return (rval);
  } else {

  }
#line 5748
  ql_log(2U, vha, 153, "Attempting to fallback to golden firmware.\n");
#line 5750
  rval = qla24xx_load_risc_flash(vha, srisc_addr, ha->flt_region_gold_fw);
#line 5751
  if (rval != 0) {
#line 5752
    return (rval);
  } else {

  }
#line 5754
  ql_log(2U, vha, 154, "Update operational firmware.\n");
#line 5755
  ha->flags.running_gold_fw = 1U;
#line 5756
  return (rval);
}
}
#line 5760 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
void qla2x00_try_to_stop_firmware(scsi_qla_host_t *vha ) 
{ 
  int ret ;
  int retries ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;

  {
#line 5763
  ha = vha->hw;
#line 5765
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 5766
    return;
  } else {

  }
#line 5767
  if ((ha->device_type & 134217728U) == 0U) {
#line 5768
    return;
  } else {

  }
#line 5769
  if ((unsigned int )ha->fw_major_version == 0U) {
#line 5770
    return;
  } else {

  }
#line 5772
  ret = qla2x00_stop_firmware(vha);
#line 5773
  retries = 5;
#line 5773
  goto ldv_67111;
  ldv_67110: 
#line 5775
  (*((ha->isp_ops)->reset_chip))(vha);
#line 5776
  tmp = (*((ha->isp_ops)->chip_diag))(vha);
#line 5776
  if (tmp != 0) {
#line 5777
    goto ldv_67109;
  } else {

  }
#line 5778
  tmp___0 = qla2x00_setup_chip(vha);
#line 5778
  if (tmp___0 != 0) {
#line 5779
    goto ldv_67109;
  } else {

  }
#line 5780
  ql_log(2U, vha, 32789, "Attempting retry of stop-firmware command.\n");
#line 5782
  ret = qla2x00_stop_firmware(vha);
  ldv_67109: 
#line 5774
  retries = retries - 1;
  ldv_67111: ;
#line 5773
  if (((ret != 0 && ret != 256) && ret != 1) && retries != 0) {
#line 5776
    goto ldv_67110;
  } else {

  }

#line 5781
  return;
}
}
#line 5787 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla24xx_configure_vhba(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  int rval2 ;
  uint16_t mb[32U] ;
  struct qla_hw_data *ha ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  struct req_que *req ;
  struct rsp_que *rsp ;

  {
#line 5789
  rval = 0;
#line 5792
  ha = vha->hw;
#line 5793
  tmp = pci_get_drvdata(ha->pdev);
#line 5793
  base_vha = (struct scsi_qla_host *)tmp;
#line 5797
  if ((unsigned int )vha->vp_idx == 0U) {
#line 5798
    return (-22);
  } else {

  }
#line 5800
  rval = qla2x00_fw_ready(base_vha);
#line 5801
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 5802
    req = *(ha->req_q_map);
  } else {
#line 5804
    req = vha->req;
  }
#line 5805
  rsp = req->rsp;
#line 5807
  if (rval == 0) {
#line 5808
    clear_bit(0L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 5809
    qla2x00_marker(vha, req, rsp, 0, 0ULL, 2);
  } else {

  }
#line 5812
  vha->flags.management_server_logged_in = 0U;
#line 5815
  rval2 = (*((ha->isp_ops)->fabric_login))(vha, 2044, 255, 255, 252, (uint16_t *)(& mb),
                                           2);
#line 5817
  if (rval2 != 0 || (unsigned int )mb[0] != 16384U) {
#line 5818
    if (rval2 == 259) {
#line 5819
      ql_dbg(1073741824U, vha, 288, "Failed SNS login: loop_id=%x, rval2=%d\n", 2044,
             rval2);
    } else {
#line 5823
      ql_dbg(1073741824U, vha, 259, "Failed SNS login: loop_id=%x mb[0]=%x mb[1]=%x mb[2]=%x mb[6]=%x mb[7]=%x.\n",
             2044, (int )mb[0], (int )mb[1], (int )mb[2], (int )mb[6], (int )mb[7]);
    }
#line 5827
    return (258);
  } else {

  }
#line 5830
  atomic_set(& vha->loop_down_timer, 0);
#line 5831
  atomic_set(& vha->loop_state, 3);
#line 5832
  set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 5833
  set_bit(6L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 5834
  rval = qla2x00_loop_resync(base_vha);
#line 5836
  return (rval);
}
}
#line 5841 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static struct list_head qla_cs84xx_list  =    {& qla_cs84xx_list, & qla_cs84xx_list};
#line 5842 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static struct mutex qla_cs84xx_mutex  =    {{1}, {{{{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "qla_cs84xx_mutex.wait_lock",
                                                          0, 0UL}}}}, {& qla_cs84xx_mutex.wait_list,
                                                                       & qla_cs84xx_mutex.wait_list},
    0, (void *)(& qla_cs84xx_mutex), {0, {0, 0}, "qla_cs84xx_mutex", 0, 0UL}};
#line 5845 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static struct qla_chip_state_84xx *qla84xx_get_chip(struct scsi_qla_host *vha ) 
{ 
  struct qla_chip_state_84xx *cs84xx ;
  struct qla_hw_data *ha ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;

  {
#line 5848
  ha = vha->hw;
#line 5850
  mutex_lock_nested(& qla_cs84xx_mutex, 0U);
#line 5853
  __mptr = (struct list_head  const  *)qla_cs84xx_list.next;
#line 5853
  cs84xx = (struct qla_chip_state_84xx *)__mptr;
#line 5853
  goto ldv_67137;
  ldv_67136: ;
#line 5854
  if ((unsigned long )cs84xx->bus == (unsigned long )((void *)(ha->pdev)->bus)) {
#line 5855
    kref_get(& cs84xx->kref);
#line 5856
    goto done;
  } else {

  }
#line 5853
  __mptr___0 = (struct list_head  const  *)cs84xx->list.next;
#line 5853
  cs84xx = (struct qla_chip_state_84xx *)__mptr___0;
  ldv_67137: ;
#line 5853
  if ((unsigned long )(& cs84xx->list) != (unsigned long )(& qla_cs84xx_list)) {
#line 5855
    goto ldv_67136;
  } else {

  }
#line 5860
  tmp = kzalloc(288UL, 208U);
#line 5860
  cs84xx = (struct qla_chip_state_84xx *)tmp;
#line 5861
  if ((unsigned long )cs84xx == (unsigned long )((struct qla_chip_state_84xx *)0)) {
#line 5862
    goto done;
  } else {

  }
#line 5864
  kref_init(& cs84xx->kref);
#line 5865
  spinlock_check(& cs84xx->access_lock);
#line 5865
  __raw_spin_lock_init(& cs84xx->access_lock.__annonCompField18.rlock, "&(&cs84xx->access_lock)->rlock",
                       & __key);
#line 5866
  __mutex_init(& cs84xx->fw_update_mutex, "&cs84xx->fw_update_mutex", & __key___0);
#line 5867
  cs84xx->bus = (void *)(ha->pdev)->bus;
#line 5869
  list_add_tail(& cs84xx->list, & qla_cs84xx_list);
  done: 
#line 5871
  mutex_unlock(& qla_cs84xx_mutex);
#line 5872
  return (cs84xx);
}
}
#line 5876 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static void __qla84xx_chip_release(struct kref *kref ) 
{ 
  struct qla_chip_state_84xx *cs84xx ;
  struct kref  const  *__mptr ;

  {
#line 5879
  __mptr = (struct kref  const  *)kref;
#line 5879
  cs84xx = (struct qla_chip_state_84xx *)__mptr + 0xfffffffffffffff0UL;
#line 5881
  mutex_lock_nested(& qla_cs84xx_mutex, 0U);
#line 5882
  list_del(& cs84xx->list);
#line 5883
  mutex_unlock(& qla_cs84xx_mutex);
#line 5884
  kfree((void const   *)cs84xx);
#line 5885
  return;
}
}
#line 5888 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
void qla84xx_put_chip(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 5890
  ha = vha->hw;
#line 5891
  if ((unsigned long )ha->cs84xx != (unsigned long )((struct qla_chip_state_84xx *)0)) {
#line 5892
    kref_put(& (ha->cs84xx)->kref, & __qla84xx_chip_release);
  } else {

  }
#line 5893
  return;
}
}
#line 5896 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static int qla84xx_init_chip(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  uint16_t status[2U] ;
  struct qla_hw_data *ha ;

  {
#line 5900
  ha = vha->hw;
#line 5902
  mutex_lock_nested(& (ha->cs84xx)->fw_update_mutex, 0U);
#line 5904
  rval = qla84xx_verify_chip(vha, (uint16_t *)(& status));
#line 5906
  mutex_unlock(& (ha->cs84xx)->fw_update_mutex);
#line 5908
  return (rval != 0 || (unsigned int )status[0] != 0U ? 258 : 0);
}
}
#line 5915 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla81xx_nvram_config(struct scsi_qla_host *vha ) 
{ 
  int rval ;
  struct init_cb_81xx *icb ;
  struct nvram_81xx *nv ;
  uint32_t *dptr ;
  uint8_t *dptr1 ;
  uint8_t *dptr2 ;
  uint32_t chksum ;
  uint16_t cnt ;
  struct qla_hw_data *ha ;
  uint32_t *tmp ;
  uint8_t *tmp___0 ;
  uint8_t *tmp___1 ;
  uint16_t tmp___2 ;
  uint8_t *tmp___3 ;
  uint8_t *tmp___4 ;
  uint16_t tmp___5 ;
  int tmp___6 ;

  {
#line 5924
  ha = vha->hw;
#line 5926
  rval = 0;
#line 5927
  icb = (struct init_cb_81xx *)ha->init_cb;
#line 5928
  nv = (struct nvram_81xx *)ha->nvram;
#line 5931
  ha->nvram_size = 512U;
#line 5932
  ha->vpd_size = 512U;
#line 5933
  if (((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) || (ha->device_type & 65536U) != 0U) {
#line 5934
    ha->vpd_size = 1024U;
  } else {

  }
#line 5937
  ha->vpd = ha->nvram + 2048UL;
#line 5938
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)ha->vpd, ha->flt_region_vpd << 2,
                                  (uint32_t )ha->vpd_size);
#line 5942
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)ha->nvram, ha->flt_region_nvram << 2,
                                  (uint32_t )ha->nvram_size);
#line 5944
  dptr = (uint32_t *)nv;
#line 5945
  cnt = 0U;
#line 5945
  chksum = 0U;
#line 5945
  goto ldv_67170;
  ldv_67169: 
#line 5946
  tmp = dptr;
#line 5946
  dptr = dptr + 1;
#line 5946
  chksum = *tmp + chksum;
#line 5945
  cnt = (uint16_t )((int )cnt + 1);
  ldv_67170: ;
#line 5945
  if ((int )ha->nvram_size >> 2 > (int )cnt) {
#line 5947
    goto ldv_67169;
  } else {

  }
#line 5948
  ql_dbg(1073872896U, vha, 273, "Contents of NVRAM:\n");
#line 5950
  ql_dump_buffer(1073872896U, vha, 274, (uint8_t *)nv, (uint32_t )ha->nvram_size);
#line 5954
  if (((((chksum != 0U || (unsigned int )nv->id[0] != 73U) || (unsigned int )nv->id[1] != 83U) || (unsigned int )nv->id[2] != 80U) || (unsigned int )nv->id[3] != 32U) || (unsigned int )nv->nvram_version == 0U) {
#line 5958
    ql_log(2U, vha, 115, "Inconsistent NVRAM detected: checksum=0x%x id=%c version=0x%x.\n",
           chksum, (int )nv->id[0], (int )nv->nvram_version);
#line 5962
    ql_log(2U, vha, 116, "Falling back to functioning (yet invalid -- WWPN) defaults.\n");
#line 5969
    memset((void *)nv, 0, (size_t )ha->nvram_size);
#line 5970
    nv->nvram_version = 1U;
#line 5971
    nv->version = 1U;
#line 5972
    nv->frame_payload_size = 2048U;
#line 5973
    nv->execution_throttle = 65535U;
#line 5974
    nv->exchange_count = 0U;
#line 5975
    nv->port_name[0] = 33U;
#line 5976
    nv->port_name[1] = (unsigned int )ha->port_no + 1U;
#line 5977
    nv->port_name[2] = 0U;
#line 5978
    nv->port_name[3] = 224U;
#line 5979
    nv->port_name[4] = 139U;
#line 5980
    nv->port_name[5] = 28U;
#line 5981
    nv->port_name[6] = 85U;
#line 5982
    nv->port_name[7] = 134U;
#line 5983
    nv->node_name[0] = 32U;
#line 5984
    nv->node_name[1] = 0U;
#line 5985
    nv->node_name[2] = 0U;
#line 5986
    nv->node_name[3] = 224U;
#line 5987
    nv->node_name[4] = 139U;
#line 5988
    nv->node_name[5] = 28U;
#line 5989
    nv->node_name[6] = 85U;
#line 5990
    nv->node_name[7] = 134U;
#line 5991
    nv->login_retry_count = 8U;
#line 5992
    nv->interrupt_delay_timer = 0U;
#line 5993
    nv->login_timeout = 0U;
#line 5994
    nv->firmware_options_1 = 24582U;
#line 5996
    nv->firmware_options_2 = 32U;
#line 5997
    nv->firmware_options_2 = nv->firmware_options_2 | 4096U;
#line 5998
    nv->firmware_options_3 = 16384U;
#line 5999
    nv->host_p = 3072U;
#line 6000
    nv->efi_parameters = 0U;
#line 6001
    nv->reset_delay = 5U;
#line 6002
    nv->max_luns_per_target = 128U;
#line 6003
    nv->port_down_retry_count = 30U;
#line 6004
    nv->link_down_timeout = 180U;
#line 6005
    nv->enode_mac[0] = 0U;
#line 6006
    nv->enode_mac[1] = 192U;
#line 6007
    nv->enode_mac[2] = 221U;
#line 6008
    nv->enode_mac[3] = 4U;
#line 6009
    nv->enode_mac[4] = 5U;
#line 6010
    nv->enode_mac[5] = (unsigned int )ha->port_no + 7U;
#line 6012
    rval = 1;
  } else {

  }
#line 6015
  if ((ha->device_type & 33554432U) != 0U) {
#line 6016
    nv->frame_payload_size = (unsigned int )nv->frame_payload_size & 65528U;
  } else {

  }
#line 6018
  qlt_81xx_config_nvram_stage1(vha, nv);
#line 6021
  memset((void *)icb, 0, (size_t )ha->init_cb_size);
#line 6024
  dptr1 = (uint8_t *)icb;
#line 6025
  dptr2 = (uint8_t *)(& nv->version);
#line 6026
  cnt = 28U;
#line 6027
  goto ldv_67173;
  ldv_67172: 
#line 6028
  tmp___0 = dptr1;
#line 6028
  dptr1 = dptr1 + 1;
#line 6028
  tmp___1 = dptr2;
#line 6028
  dptr2 = dptr2 + 1;
#line 6028
  *tmp___0 = *tmp___1;
  ldv_67173: 
#line 6027
  tmp___2 = cnt;
#line 6027
  cnt = (uint16_t )((int )cnt - 1);
#line 6027
  if ((unsigned int )tmp___2 != 0U) {
#line 6029
    goto ldv_67172;
  } else {

  }
#line 6030
  icb->login_retry_count = nv->login_retry_count;
#line 6033
  dptr1 = (uint8_t *)(& icb->interrupt_delay_timer);
#line 6034
  dptr2 = (uint8_t *)(& nv->interrupt_delay_timer);
#line 6035
  cnt = 16U;
#line 6037
  goto ldv_67176;
  ldv_67175: 
#line 6038
  tmp___3 = dptr1;
#line 6038
  dptr1 = dptr1 + 1;
#line 6038
  tmp___4 = dptr2;
#line 6038
  dptr2 = dptr2 + 1;
#line 6038
  *tmp___3 = *tmp___4;
  ldv_67176: 
#line 6037
  tmp___5 = cnt;
#line 6037
  cnt = (uint16_t )((int )cnt - 1);
#line 6037
  if ((unsigned int )tmp___5 != 0U) {
#line 6039
    goto ldv_67175;
  } else {

  }
#line 6040
  memcpy((void *)(& icb->enode_mac), (void const   *)(& nv->enode_mac), 6UL);
#line 6042
  tmp___6 = memcmp((void const   *)(& icb->enode_mac), (void const   *)"", 6UL);
#line 6042
  if (tmp___6 == 0) {
#line 6043
    icb->enode_mac[0] = 0U;
#line 6044
    icb->enode_mac[1] = 192U;
#line 6045
    icb->enode_mac[2] = 221U;
#line 6046
    icb->enode_mac[3] = 4U;
#line 6047
    icb->enode_mac[4] = 5U;
#line 6048
    icb->enode_mac[5] = (unsigned int )ha->port_no + 7U;
  } else {

  }
#line 6052
  memcpy((void *)ha->ex_init_cb, (void const   *)(& nv->ex_version), 64UL);
#line 6057
  qla2x00_set_model_info(vha, (uint8_t *)(& nv->model_name), 16UL, (char *)"QLE8XXX");
#line 6060
  qlt_81xx_config_nvram_stage2(vha, icb);
#line 6063
  if ((nv->host_p & 32768U) != 0U) {
#line 6064
    memcpy((void *)(& icb->node_name), (void const   *)(& nv->alternate_node_name),
             8UL);
#line 6065
    memcpy((void *)(& icb->port_name), (void const   *)(& nv->alternate_port_name),
             8UL);
  } else {

  }
#line 6069
  if ((icb->firmware_options_1 & 16384U) == 0U) {
#line 6074
    memcpy((void *)(& icb->node_name), (void const   *)(& icb->port_name), 8UL);
#line 6075
    icb->node_name[0] = (unsigned int )icb->node_name[0] & 240U;
  } else {

  }
#line 6079
  ha->flags.disable_risc_code_load = 0U;
#line 6080
  ha->flags.enable_lip_reset = 0U;
#line 6081
  ha->flags.enable_lip_full_login = (nv->host_p & 1024U) != 0U;
#line 6083
  ha->flags.enable_target_reset = (nv->host_p & 2048U) != 0U;
#line 6085
  ha->flags.enable_led_scheme = 0U;
#line 6086
  ha->flags.disable_serdes = (nv->host_p & 32U) != 0U;
#line 6088
  ha->operating_mode = (uint8_t )((icb->firmware_options_2 & 112U) >> 4);
#line 6092
  ha->serial0 = icb->port_name[5];
#line 6093
  ha->serial1 = icb->port_name[6];
#line 6094
  ha->serial2 = icb->port_name[7];
#line 6095
  memcpy((void *)(& vha->node_name), (void const   *)(& icb->node_name), 8UL);
#line 6096
  memcpy((void *)(& vha->port_name), (void const   *)(& icb->port_name), 8UL);
#line 6098
  icb->execution_throttle = 65535U;
#line 6100
  ha->retry_count = (uint8_t )nv->login_retry_count;
#line 6103
  if ((int )nv->login_timeout < ql2xlogintimeout) {
#line 6104
    nv->login_timeout = (unsigned short )ql2xlogintimeout;
  } else {

  }
#line 6105
  if ((unsigned int )nv->login_timeout <= 3U) {
#line 6106
    nv->login_timeout = 4U;
  } else {

  }
#line 6107
  ha->login_timeout = (uint8_t )nv->login_timeout;
#line 6108
  icb->login_timeout = nv->login_timeout;
#line 6111
  ha->r_a_tov = 100U;
#line 6113
  ha->loop_reset_delay = (uint16_t )nv->reset_delay;
#line 6125
  if ((unsigned int )nv->link_down_timeout == 0U) {
#line 6126
    ha->loop_down_abort_time = 195U;
  } else {
#line 6129
    ha->link_down_timeout = (uint8_t )nv->link_down_timeout;
#line 6130
    ha->loop_down_abort_time = ~ ((int )ha->link_down_timeout);
  }
#line 6135
  ha->port_down_retry_count = (int )nv->port_down_retry_count;
#line 6136
  if (qlport_down_retry != 0) {
#line 6137
    ha->port_down_retry_count = qlport_down_retry;
  } else {

  }
#line 6140
  ha->login_retry_count = (uint32_t )nv->login_retry_count;
#line 6141
  if (ha->port_down_retry_count == (int )nv->port_down_retry_count && ha->port_down_retry_count > 3) {
#line 6144
    ha->login_retry_count = (uint32_t )ha->port_down_retry_count;
  } else
#line 6145
  if (ha->port_down_retry_count > (int )ha->login_retry_count) {
#line 6146
    ha->login_retry_count = (uint32_t )ha->port_down_retry_count;
  } else {

  }
#line 6147
  if (ql2xloginretrycount != 0) {
#line 6148
    ha->login_retry_count = (uint32_t )ql2xloginretrycount;
  } else {

  }
#line 6151
  if (*((unsigned long *)vha->hw + 2UL) == 0UL && (((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U))) {
#line 6152
    icb->firmware_options_2 = icb->firmware_options_2 | 4194304U;
  } else {

  }
#line 6155
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 6156
    ha->zio_mode = (unsigned int )((uint16_t )icb->firmware_options_2) & 15U;
#line 6158
    ha->zio_timer = (unsigned int )icb->interrupt_delay_timer != 0U ? icb->interrupt_delay_timer : 2U;
  } else {

  }
#line 6161
  icb->firmware_options_2 = icb->firmware_options_2 & 4294967280U;
#line 6163
  vha->flags.process_response_queue = 0U;
#line 6164
  if ((unsigned int )ha->zio_mode != 0U) {
#line 6165
    ha->zio_mode = 6U;
#line 6167
    ql_log(2U, vha, 117, "ZIO mode %d enabled; timer delay (%d us).\n", (int )ha->zio_mode,
           (int )ha->zio_timer * 100);
#line 6172
    icb->firmware_options_2 = icb->firmware_options_2 | (uint32_t )ha->zio_mode;
#line 6174
    icb->interrupt_delay_timer = ha->zio_timer;
#line 6175
    vha->flags.process_response_queue = 1U;
  } else {

  }
#line 6178
  if (rval != 0) {
#line 6179
    ql_log(1U, vha, 118, "NVRAM configuration failed.\n");
  } else {

  }
#line 6182
  return (rval);
}
}
#line 6186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla82xx_restart_isp(scsi_qla_host_t *vha ) 
{ 
  int status ;
  int rval ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  struct scsi_qla_host *vp ;
  unsigned long flags ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  struct list_head  const  *__mptr ;
  raw_spinlock_t *tmp___1 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 6189
  ha = vha->hw;
#line 6190
  req = *(ha->req_q_map);
#line 6191
  rsp = *(ha->rsp_q_map);
#line 6195
  status = qla2x00_init_rings(vha);
#line 6196
  if (status == 0) {
#line 6197
    clear_bit(0L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 6198
    ha->flags.chip_reset_done = 1U;
#line 6200
    status = qla2x00_fw_ready(vha);
#line 6201
    if (status == 0) {
#line 6203
      qla2x00_marker(vha, req, rsp, 0, 0ULL, 2);
#line 6204
      vha->flags.online = 1U;
#line 6205
      set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
    } else {

    }
#line 6209
    if ((vha->device_flags & 2U) != 0U) {
#line 6210
      status = 0;
    } else {

    }
  } else {

  }
#line 6213
  if (status == 0) {
#line 6214
    clear_bit(0L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 6216
    tmp = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 6216
    if (tmp == 0) {
#line 6221
      vha->marker_needed = 1U;
    } else {

    }
#line 6224
    (*((ha->isp_ops)->enable_intrs))(ha);
#line 6226
    ha->isp_abort_cnt = 0U;
#line 6227
    clear_bit(10L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 6230
    status = qla82xx_check_md_needed(vha);
#line 6232
    if ((unsigned long )ha->fce != (unsigned long )((void *)0)) {
#line 6233
      ha->flags.fce_enabled = 1U;
#line 6234
      memset(ha->fce, 0, (size_t )(ha->fce_bufs * 1024U));
#line 6236
      rval = qla2x00_enable_fce_trace(vha, ha->fce_dma, (int )((uint16_t )ha->fce_bufs),
                                      (uint16_t *)(& ha->fce_mb), & ha->fce_bufs);
#line 6239
      if (rval != 0) {
#line 6240
        ql_log(1U, vha, 32769, "Unable to reinitialize FCE (%d).\n", rval);
#line 6243
        ha->flags.fce_enabled = 0U;
      } else {

      }
    } else {

    }
#line 6247
    if ((unsigned long )ha->eft != (unsigned long )((void *)0)) {
#line 6248
      memset(ha->eft, 0, 65536UL);
#line 6249
      rval = qla2x00_enable_eft_trace(vha, ha->eft_dma, 4);
#line 6251
      if (rval != 0) {
#line 6252
        ql_log(1U, vha, 32784, "Unable to reinitialize EFT (%d).\n", rval);
      } else {

      }
    } else {

    }
  } else {

  }
#line 6259
  if (status == 0) {
#line 6260
    ql_dbg(4194304U, vha, 32785, "qla82xx_restart_isp succeeded.\n");
#line 6263
    tmp___0 = spinlock_check(& ha->vport_slock);
#line 6263
    flags = _raw_spin_lock_irqsave(tmp___0);
#line 6264
    __mptr = (struct list_head  const  *)ha->vp_list.next;
#line 6264
    vp = (struct scsi_qla_host *)__mptr;
#line 6264
    goto ldv_67199;
    ldv_67198: ;
#line 6265
    if ((unsigned int )vp->vp_idx != 0U) {
#line 6266
      atomic_inc(& vp->vref_count);
#line 6267
      spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 6269
      qla2x00_vp_abort_isp(vp);
#line 6271
      tmp___1 = spinlock_check(& ha->vport_slock);
#line 6271
      flags = _raw_spin_lock_irqsave(tmp___1);
#line 6272
      atomic_dec(& vp->vref_count);
    } else {

    }
#line 6264
    __mptr___0 = (struct list_head  const  *)vp->list.next;
#line 6264
    vp = (struct scsi_qla_host *)__mptr___0;
    ldv_67199: ;
#line 6264
    if ((unsigned long )(& vp->list) != (unsigned long )(& ha->vp_list)) {
#line 6266
      goto ldv_67198;
    } else {

    }
#line 6275
    spin_unlock_irqrestore(& ha->vport_slock, flags);
  } else {
#line 6278
    ql_log(1U, vha, 32790, "qla82xx_restart_isp **** FAILED ****.\n");
  }
#line 6282
  return (status);
}
}
#line 6286 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
void qla81xx_update_fw_options(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 6288
  ha = vha->hw;
#line 6290
  if (ql2xetsenable == 0) {
#line 6291
    return;
  } else {

  }
#line 6294
  memset((void *)(& ha->fw_options), 0, 32UL);
#line 6295
  ha->fw_options[2] = (uint16_t )((unsigned int )ha->fw_options[2] | 512U);
#line 6296
  qla2x00_set_fw_options(vha, (uint16_t *)(& ha->fw_options));
#line 6297
  return;
}
}
#line 6318 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
static int qla24xx_get_fcp_prio(scsi_qla_host_t *vha , fc_port_t *fcport ) 
{ 
  int i ;
  int entries ;
  uint8_t pid_match ;
  uint8_t wwn_match ;
  int priority ;
  uint32_t pid1 ;
  uint32_t pid2 ;
  uint64_t wwn1 ;
  uint64_t wwn2 ;
  struct qla_fcp_prio_entry *pri_entry ;
  struct qla_hw_data *ha ;

  {
#line 6326
  ha = vha->hw;
#line 6328
  if ((unsigned long )ha->fcp_prio_cfg == (unsigned long )((struct qla_fcp_prio_cfg *)0) || *((unsigned long *)ha + 2UL) == 0UL) {
#line 6329
    return (-1);
  } else {

  }
#line 6331
  priority = -1;
#line 6332
  entries = (int )(ha->fcp_prio_cfg)->num_entries;
#line 6333
  pri_entry = (struct qla_fcp_prio_entry *)(& (ha->fcp_prio_cfg)->entry);
#line 6335
  i = 0;
#line 6335
  goto ldv_67223;
  ldv_67222: 
#line 6336
  wwn_match = 0U;
#line 6336
  pid_match = wwn_match;
#line 6338
  if (((int )pri_entry->flags & 1) == 0) {
#line 6339
    pri_entry = pri_entry + 1;
#line 6340
    goto ldv_67220;
  } else {

  }
#line 6344
  if (((int )pri_entry->flags & 4) != 0) {
#line 6345
    pid1 = pri_entry->src_pid & 16777215U;
#line 6346
    pid2 = vha->d_id.b24;
#line 6347
    if (pid1 == 16777215U) {
#line 6348
      pid_match = (uint8_t )((int )pid_match + 1);
    } else
#line 6349
    if (pid1 == pid2) {
#line 6350
      pid_match = (uint8_t )((int )pid_match + 1);
    } else {

    }
  } else {

  }
#line 6354
  if (((int )pri_entry->flags & 8) != 0) {
#line 6355
    pid1 = pri_entry->dst_pid & 16777215U;
#line 6356
    pid2 = fcport->d_id.b24;
#line 6357
    if (pid1 == 16777215U) {
#line 6358
      pid_match = (uint8_t )((int )pid_match + 1);
    } else
#line 6359
    if (pid1 == pid2) {
#line 6360
      pid_match = (uint8_t )((int )pid_match + 1);
    } else {

    }
  } else {

  }
#line 6364
  if (((int )pri_entry->flags & 64) != 0) {
#line 6365
    wwn1 = wwn_to_u64((u8 *)(& vha->port_name));
#line 6366
    wwn2 = wwn_to_u64((u8 *)(& pri_entry->src_wwpn));
#line 6367
    if (wwn2 == 0xffffffffffffffffULL) {
#line 6368
      wwn_match = (uint8_t )((int )wwn_match + 1);
    } else
#line 6369
    if (wwn1 == wwn2) {
#line 6370
      wwn_match = (uint8_t )((int )wwn_match + 1);
    } else {

    }
  } else {

  }
#line 6374
  if (((int )pri_entry->flags & 128) != 0) {
#line 6375
    wwn1 = wwn_to_u64((u8 *)(& fcport->port_name));
#line 6376
    wwn2 = wwn_to_u64((u8 *)(& pri_entry->dst_wwpn));
#line 6377
    if (wwn2 == 0xffffffffffffffffULL) {
#line 6378
      wwn_match = (uint8_t )((int )wwn_match + 1);
    } else
#line 6379
    if (wwn1 == wwn2) {
#line 6380
      wwn_match = (uint8_t )((int )wwn_match + 1);
    } else {

    }
  } else {

  }
#line 6383
  if ((unsigned int )pid_match == 2U || (unsigned int )wwn_match == 2U) {
#line 6385
    if (((int )pri_entry->flags & 2) != 0) {
#line 6386
      priority = (int )pri_entry->tag;
    } else {

    }
#line 6387
    goto ldv_67221;
  } else {

  }
#line 6390
  pri_entry = pri_entry + 1;
  ldv_67220: 
#line 6335
  i = i + 1;
  ldv_67223: ;
#line 6335
  if (i < entries) {
#line 6337
    goto ldv_67222;
  } else {

  }
  ldv_67221: ;
#line 6393
  return (priority);
}
}
#line 6411 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla24xx_update_fcport_fcp_prio(scsi_qla_host_t *vha , fc_port_t *fcport ) 
{ 
  int ret ;
  int priority ;
  uint16_t mb[5U] ;

  {
#line 6417
  if ((unsigned int )fcport->port_type != 5U || (unsigned int )fcport->loop_id == 4096U) {
#line 6419
    return (258);
  } else {

  }
#line 6421
  priority = qla24xx_get_fcp_prio(vha, fcport);
#line 6422
  if (priority < 0) {
#line 6423
    return (258);
  } else {

  }
#line 6425
  if (((vha->hw)->device_type & 16384U) != 0U || ((vha->hw)->device_type & 262144U) != 0U) {
#line 6426
    fcport->fcp_prio = (unsigned int )((uint8_t )priority) & 15U;
#line 6427
    return (0);
  } else {

  }
#line 6430
  ret = qla24xx_set_fcp_prio(vha, (int )fcport->loop_id, (int )((uint16_t )priority),
                             (uint16_t *)(& mb));
#line 6431
  if (ret == 0) {
#line 6432
    if ((int )fcport->fcp_prio != priority) {
#line 6433
      ql_dbg(8388608U, vha, 28830, "Updated FCP_CMND priority - value=%d loop_id=%d port_id=%02x%02x%02x.\n",
             priority, (int )fcport->loop_id, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
             (int )fcport->d_id.b.al_pa);
    } else {

    }
#line 6438
    fcport->fcp_prio = (unsigned int )((uint8_t )priority) & 15U;
  } else {
#line 6440
    ql_dbg(8388608U, vha, 28751, "Unable to update FCP_CMND priority - ret=0x%x for loop_id=%d port_id=%02x%02x%02x.\n",
           ret, (int )fcport->loop_id, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
           (int )fcport->d_id.b.al_pa);
  }
#line 6445
  return (ret);
}
}
#line 6462 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.c"
int qla24xx_update_all_fcp_prio(scsi_qla_host_t *vha ) 
{ 
  int ret ;
  fc_port_t *fcport ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 6467
  ret = 258;
#line 6469
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 6469
  fcport = (fc_port_t *)__mptr;
#line 6469
  goto ldv_67241;
  ldv_67240: 
#line 6470
  ret = qla24xx_update_fcport_fcp_prio(vha, fcport);
#line 6469
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 6469
  fcport = (fc_port_t *)__mptr___0;
  ldv_67241: ;
#line 6469
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 6471
    goto ldv_67240;
  } else {

  }

#line 6472
  return (ret);
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int reg_timer_15(struct timer_list *timer ) 
{ 


  {
#line 489
  ldv_timer_list_15 = timer;
#line 490
  ldv_timer_state_15 = 1;
#line 491
  return (0);
}
}
#line 494 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void activate_pending_timer_15(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 494
  if ((unsigned long )ldv_timer_list_15 == (unsigned long )timer) {
#line 495
    if (ldv_timer_state_15 == 2 || pending_flag != 0) {
#line 496
      ldv_timer_list_15 = timer;
#line 497
      ldv_timer_list_15->data = data;
#line 498
      ldv_timer_state_15 = 1;
    } else {

    }
#line 500
    return;
  } else {

  }
#line 502
  reg_timer_15(timer);
#line 503
  ldv_timer_list_15->data = data;
#line 504
  return;
}
}
#line 507 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void choose_timer_15(struct timer_list *timer ) 
{ 


  {
#line 508
  LDV_IN_INTERRUPT = 2;
#line 509
  (*(timer->function))(timer->data);
#line 510
  LDV_IN_INTERRUPT = 1;
#line 511
  ldv_timer_state_15 = 2;
#line 512
  return;
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void disable_suitable_timer_15(struct timer_list *timer ) 
{ 


  {
#line 516
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_15) {
#line 517
    ldv_timer_state_15 = 0;
#line 518
    return;
  } else {

  }
#line 520
  return;
}
}
#line 546 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
bool ldv_queue_work_on_61(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 550
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 550
  ldv_func_res = tmp;
#line 552
  activate_work_7(ldv_func_arg3, 2);
#line 554
  return (ldv_func_res);
}
}
#line 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
bool ldv_queue_delayed_work_on_62(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 561
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 561
  ldv_func_res = tmp;
#line 563
  activate_work_7(& ldv_func_arg3->work, 2);
#line 565
  return (ldv_func_res);
}
}
#line 568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
bool ldv_queue_work_on_63(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 572
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 572
  ldv_func_res = tmp;
#line 574
  activate_work_7(ldv_func_arg3, 2);
#line 576
  return (ldv_func_res);
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void ldv_flush_workqueue_64(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 582
  flush_workqueue(ldv_func_arg1);
#line 584
  call_and_disable_all_7(2);
#line 585
  return;
}
}
#line 587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
bool ldv_queue_delayed_work_on_65(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 591
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 591
  ldv_func_res = tmp;
#line 593
  activate_work_7(& ldv_func_arg3->work, 2);
#line 595
  return (ldv_func_res);
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int ldv_scsi_add_host_with_dma_66(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 602
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 602
  ldv_func_res = tmp;
#line 604
  if (ldv_func_res == 0) {
#line 605
    ldv_state_variable_88 = 1;
#line 605
    ldv_initialize_scsi_host_template_88();
  } else {

  }
#line 609
  return (ldv_func_res);
}
}
#line 612 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int ldv_del_timer_67(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 616
  tmp = del_timer(ldv_func_arg1);
#line 616
  ldv_func_res = tmp;
#line 618
  disable_suitable_timer_21(ldv_func_arg1);
#line 620
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 369 "./arch/x86/include/asm/paravirt_types.h"
extern struct pv_irq_ops pv_irq_ops ;
#line 59 "include/uapi/linux/byteorder/little_endian.h"
__inline static __le16 __cpu_to_le16p(__u16 const   *p ) 
{ 


  {
#line 61
  return ((__le16 )*p);
}
}
#line 64 "./arch/x86/include/asm/string_64.h"
extern size_t strlen(char const   * ) ;
#line 121 "include/linux/string.h"
extern void *kmemdup(void const   * , size_t  , gfp_t  ) ;
#line 829 "./arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 831
  __edi = __edi;
#line 831
  __esi = __esi;
#line 831
  __edx = __edx;
#line 831
  __ecx = __ecx;
#line 831
  __eax = __eax;
#line 831
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
#line 831
  if (tmp != 0L) {
#line 831
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (831), "i" (12UL));
    ldv_4860: ;
#line 831
    goto ldv_4860;
  } else {

  }
#line 831
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (43UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 831
  __ret = __eax;
#line 831
  return (__ret);
}
}
#line 834 "./arch/x86/include/asm/paravirt.h"
__inline static void arch_local_irq_restore(unsigned long f ) 
{ 
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 836
  __edi = __edi;
#line 836
  __esi = __esi;
#line 836
  __edx = __edx;
#line 836
  __ecx = __ecx;
#line 836
  __eax = __eax;
#line 836
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.restore_fl.func == (unsigned long )((void *)0),
                         0L);
#line 836
  if (tmp != 0L) {
#line 836
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (836), "i" (12UL));
    ldv_4870: ;
#line 836
    goto ldv_4870;
  } else {

  }
#line 836
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (44UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.restore_fl.func), [paravirt_clobber] "i" (1),
                       "D" (f): "memory", "cc");
#line 838
  return;
}
}
#line 839 "./arch/x86/include/asm/paravirt.h"
__inline static void arch_local_irq_disable(void) 
{ 
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 841
  __edi = __edi;
#line 841
  __esi = __esi;
#line 841
  __edx = __edx;
#line 841
  __ecx = __ecx;
#line 841
  __eax = __eax;
#line 841
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.irq_disable.func == (unsigned long )((void *)0),
                         0L);
#line 841
  if (tmp != 0L) {
#line 841
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (841), "i" (12UL));
    ldv_4879: ;
#line 841
    goto ldv_4879;
  } else {

  }
#line 841
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (45UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.irq_disable.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 843
  return;
}
}
#line 849 "./arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_irq_save(void) 
{ 
  unsigned long f ;

  {
#line 853
  f = arch_local_save_flags();
#line 854
  arch_local_irq_disable();
#line 855
  return (f);
}
}
#line 151 "./arch/x86/include/asm/irqflags.h"
__inline static int arch_irqs_disabled_flags(unsigned long flags ) 
{ 


  {
#line 153
  return ((flags & 512UL) == 0UL);
}
}
#line 20 "include/linux/irqflags.h"
extern void trace_hardirqs_on(void) ;
#line 21
extern void trace_hardirqs_off(void) ;
#line 95 "include/linux/completion.h"
extern unsigned long wait_for_completion_timeout(struct completion * , unsigned long  ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_79(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_81(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_80(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_83(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_82(struct workqueue_struct *ldv_func_arg1 ) ;
#line 321 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
void disable_suitable_timer_16(struct timer_list *timer ) ;
#line 420
void activate_pending_timer_16(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 435
int reg_timer_16(struct timer_list *timer ) ;
#line 442
void choose_timer_16(struct timer_list *timer ) ;
#line 30 "include/scsi/scsi_common.h"
extern void int_to_scsilun(u64  , struct scsi_lun * ) ;
#line 795 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_84(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 830 "include/scsi/scsi_transport_fc.h"
__inline static void fc_vport_set_state(struct fc_vport *vport , enum fc_vport_state new_state ) 
{ 


  {
#line 832
  if ((unsigned int )new_state != 0U && (unsigned int )new_state != 4U) {
#line 834
    vport->vport_last_state = vport->vport_state;
  } else {

  }
#line 835
  vport->vport_state = new_state;
#line 836
  return;
}
}
#line 58 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int qla2x00_get_thermal_temp(scsi_qla_host_t *vha , uint16_t *temp ) ;
#line 139
int qla81xx_restart_mpi_firmware(scsi_qla_host_t *vha ) ;
#line 176
int qla24xx_control_vp(scsi_qla_host_t *vha , int cmd ) ;
#line 177
int qla24xx_modify_vp_config(scsi_qla_host_t *vha ) ;
#line 181
void qla24xx_report_id_acquisition(scsi_qla_host_t *vha , struct vp_rpt_id_entry_24xx *rptid_entry ) ;
#line 239
int qla2x00_dump_ram(scsi_qla_host_t *vha , dma_addr_t req_dma , uint32_t addr , uint32_t size ) ;
#line 260
int qla2x00_issue_iocb(scsi_qla_host_t *vha , void *buffer , dma_addr_t phys_addr ,
                       size_t size ) ;
#line 282
int qla2x00_get_node_name_list(scsi_qla_host_t *vha , void **out_data , int *out_len ) ;
#line 300
int qla2x00_send_sns(scsi_qla_host_t *vha , dma_addr_t sns_phys_address , uint16_t cmd_size ,
                     size_t buf_size ) ;
#line 330
int qla2x00_get_fcal_position_map(scsi_qla_host_t *vha , char *pos_map ) ;
#line 333
int qla2x00_get_link_status(scsi_qla_host_t *vha , uint16_t loop_id , struct link_statistics *stats ,
                            dma_addr_t stats_dma ) ;
#line 337
int qla24xx_get_isp_stats(scsi_qla_host_t *vha , struct link_statistics *stats , dma_addr_t stats_dma ) ;
#line 350
int qla2x00_system_error(scsi_qla_host_t *vha ) ;
#line 353
int qla2x00_write_serdes_word(scsi_qla_host_t *vha , uint16_t addr , uint16_t data ) ;
#line 355
int qla2x00_read_serdes_word(scsi_qla_host_t *vha , uint16_t addr , uint16_t *data ) ;
#line 358
int qla8044_write_serdes_word(scsi_qla_host_t *vha , uint32_t addr , uint32_t data ) ;
#line 360
int qla8044_read_serdes_word(scsi_qla_host_t *vha , uint32_t addr , uint32_t *data ) ;
#line 387
int qla2x00_read_sfp(scsi_qla_host_t *vha , dma_addr_t sfp_dma , uint8_t *sfp , uint16_t dev ,
                     uint16_t off , uint16_t len , uint16_t opt ) ;
#line 391
int qla2x00_write_sfp(scsi_qla_host_t *vha , dma_addr_t sfp_dma , uint8_t *sfp , uint16_t dev ,
                      uint16_t off , uint16_t len , uint16_t opt ) ;
#line 405
int qla81xx_fac_do_write_enable(scsi_qla_host_t *vha , int enable ) ;
#line 408
int qla81xx_fac_erase_sector(scsi_qla_host_t *vha , uint32_t start , uint32_t finish ) ;
#line 411
int qla2x00_get_xgmac_stats(scsi_qla_host_t *vha , dma_addr_t stats_dma , uint16_t size_in_bytes ,
                            uint16_t *actual_size ) ;
#line 414
int qla2x00_get_dcbx_params(scsi_qla_host_t *vha , dma_addr_t tlv_dma , uint16_t size ) ;
#line 431
int qla81xx_set_port_config(scsi_qla_host_t *vha , uint16_t *mb ) ;
#line 434
int qla2x00_port_logout(scsi_qla_host_t *vha , struct fc_port *fcport ) ;
#line 542
void ql_dump_regs(uint32_t level , scsi_qla_host_t *vha , int32_t id ) ;
#line 580
int qla2x00_loopback_test(scsi_qla_host_t *vha , struct msg_echo_lb *mreq , uint16_t *mresp ) ;
#line 581
int qla2x00_echo_test(scsi_qla_host_t *vha , struct msg_echo_lb *mreq , uint16_t *mresp ) ;
#line 688
void qla82xx_poll(int irq , void *dev_id ) ;
#line 709
int qla82xx_mbx_intr_enable(scsi_qla_host_t *vha ) ;
#line 710
int qla82xx_mbx_intr_disable(scsi_qla_host_t *vha ) ;
#line 715
int qla81xx_set_led_config(scsi_qla_host_t *vha , uint16_t *led_cfg ) ;
#line 716
int qla81xx_get_led_config(scsi_qla_host_t *vha , uint16_t *led_cfg ) ;
#line 717
int qla82xx_mbx_beacon_ctl(scsi_qla_host_t *vha , int enable ) ;
#line 720
int qla82xx_read_temperature(scsi_qla_host_t *vha ) ;
#line 721
int qla8044_read_temperature(scsi_qla_host_t *vha ) ;
#line 726
int qla84xx_reset_chip(scsi_qla_host_t *vha , uint16_t enable_diagnostic ) ;
#line 727
int qla2x00_issue_iocb_timeout(scsi_qla_host_t *vha , void *buffer , dma_addr_t phys_addr ,
                               size_t size , uint32_t tov ) ;
#line 729
int qla2x00_get_idma_speed(scsi_qla_host_t *vha , uint16_t loop_id , uint16_t *port_speed ,
                           uint16_t *mb ) ;
#line 736
int qla82xx_md_get_template_size(scsi_qla_host_t *vha ) ;
#line 737
int qla82xx_md_get_template(scsi_qla_host_t *vha ) ;
#line 760
int qla8044_md_get_template(scsi_qla_host_t *vha ) ;
#line 1102 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
void qlt_modify_vp_config(struct scsi_qla_host *vha , struct vp_config_entry_24xx *vpmod ) ;
#line 58 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_poll(struct rsp_que *rsp ) 
{ 
  unsigned long flags ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 61
  ha = rsp->hw;
#line 62
  flags = arch_local_irq_save();
#line 62
  trace_hardirqs_off();
#line 63
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 64
    qla82xx_poll(0, (void *)rsp);
  } else {
#line 66
    (*((ha->isp_ops)->intr_handler))(0, (void *)rsp);
  }
#line 67
  tmp = arch_irqs_disabled_flags(flags);
#line 67
  if (tmp != 0) {
#line 67
    arch_local_irq_restore(flags);
#line 67
    trace_hardirqs_off();
  } else {
#line 67
    trace_hardirqs_on();
#line 67
    arch_local_irq_restore(flags);
  }
#line 69
  return;
}
}
#line 71 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static uint8_t *host_to_fcp_swap(uint8_t *fcp , uint32_t bsize ) 
{ 
  uint32_t *ifcp ;
  uint32_t *ofcp ;
  uint32_t iter ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  __u32 tmp___1 ;

  {
#line 73
  ifcp = (uint32_t *)fcp;
#line 74
  ofcp = (uint32_t *)fcp;
#line 75
  iter = bsize >> 2;
#line 77
  goto ldv_65657;
  ldv_65656: 
#line 78
  tmp = ofcp;
#line 78
  ofcp = ofcp + 1;
#line 78
  tmp___0 = ifcp;
#line 78
  ifcp = ifcp + 1;
#line 78
  tmp___1 = __fswab32(*tmp___0);
#line 78
  *tmp = tmp___1;
#line 77
  iter = iter - 1U;
  ldv_65657: ;
#line 77
  if (iter != 0U) {
#line 79
    goto ldv_65656;
  } else {

  }

#line 80
  return (fcp);
}
}
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
static int qla2x00_mailbox_command(scsi_qla_host_t *vha , mbx_cmd_t *mcp ) 
{ 
  int rval ;
  int i ;
  unsigned long flags ;
  device_reg_t *reg ;
  uint8_t abort_active ;
  uint8_t io_lock_on ;
  uint16_t command ;
  uint16_t *iptr ;
  uint16_t *optr ;
  uint32_t cnt ;
  uint32_t mboxes ;
  uint16_t *mbx_reg ;
  unsigned long wait_time ;
  struct qla_hw_data *ha ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  unsigned int tmp___3 ;
  raw_spinlock_t *tmp___4 ;
  unsigned long tmp___5 ;
  unsigned int tmp___6 ;
  uint16_t *iptr2 ;
  uint16_t mb0 ;
  uint32_t ictrl ;
  unsigned short tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  uint16_t *tmp___18 ;
  unsigned short tmp___19 ;

  {
#line 37
  flags = 0UL;
#line 41
  command = 0U;
#line 48
  ha = vha->hw;
#line 49
  tmp = pci_get_drvdata(ha->pdev);
#line 49
  base_vha = (scsi_qla_host_t *)tmp;
#line 52
  ql_dbg(536870912U, vha, 4096, "Entered %s.\n", "qla2x00_mailbox_command");
#line 54
  if ((ha->pdev)->error_state > 2U) {
#line 55
    ql_log(1U, vha, 4097, "error_state is greater than pci_channel_io_frozen, exiting.\n");
#line 58
    return (256);
  } else {

  }
#line 61
  if ((vha->device_flags & 32U) != 0U) {
#line 62
    ql_log(1U, vha, 4098, "Device in failed state, exiting.\n");
#line 64
    return (256);
  } else {

  }
#line 67
  reg = ha->iobase;
#line 68
  io_lock_on = (uint8_t )base_vha->flags.init_done;
#line 70
  rval = 0;
#line 71
  tmp___0 = constant_test_bit(3L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 71
  abort_active = (uint8_t )tmp___0;
#line 74
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 75
    ql_log(1U, vha, 4099, "Perm failure on EEH timeout MBX, exiting.\n");
#line 77
    return (256);
  } else {

  }
#line 80
  if (((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) && *((unsigned long *)ha + 2UL) != 0UL) {
#line 82
    mcp->mb[0] = 16395U;
#line 83
    ql_log(1U, vha, 4100, "FW hung = %d.\n", (int )ha->flags.isp82xx_fw_hung);
#line 85
    return (256);
  } else {

  }
#line 93
  tmp___1 = wait_for_completion_timeout(& ha->mbx_cmd_comp, (unsigned long )(mcp->tov * 250U));
#line 93
  if (tmp___1 == 0UL) {
#line 95
    ql_log(1U, vha, 4101, "Cmd access timeout, cmd=0x%x, Exiting.\n", (int )mcp->mb[0]);
#line 98
    return (256);
  } else {

  }
#line 101
  ha->flags.mbox_busy = 1U;
#line 103
  ha->mcp = mcp;
#line 105
  ql_dbg(536870912U, vha, 4102, "Prepare to issue mbox cmd=0x%x.\n", (int )mcp->mb[0]);
#line 108
  tmp___2 = spinlock_check(& ha->hardware_lock);
#line 108
  flags = _raw_spin_lock_irqsave(tmp___2);
#line 111
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 112
    optr = (uint16_t *)(& reg->isp82.mailbox_in);
  } else
#line 113
  if ((ha->device_type & 134217728U) != 0U && ((ha->device_type & 16384U) == 0U && (ha->device_type & 262144U) == 0U)) {
#line 114
    optr = & reg->isp24.mailbox0;
  } else {
#line 116
    optr = (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->isp.u.isp2100.mailbox0 : & reg->isp.u.isp2300.mailbox0;
  }
#line 118
  iptr = (uint16_t *)(& mcp->mb);
#line 119
  command = mcp->mb[0];
#line 120
  mboxes = mcp->out_mb;
#line 122
  ql_dbg(536870912U, vha, 4369, "Mailbox registers (OUT):\n");
#line 124
  cnt = 0U;
#line 124
  goto ldv_65775;
  ldv_65774: ;
#line 125
  if ((ha->device_type & 2U) != 0U && cnt == 8U) {
#line 126
    optr = (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->isp.u_end.isp2200.mailbox8 : & reg->isp.u.isp2300.mailbox0 + 8UL;
  } else {

  }
#line 128
  if ((int )mboxes & 1) {
#line 129
    ql_dbg(536870912U, vha, 4370, "mbox[%d]<-0x%04x\n", cnt, (int )*iptr);
#line 131
    writew((int )*iptr, (void volatile   *)optr);
  } else {

  }
#line 134
  mboxes = mboxes >> 1;
#line 135
  optr = optr + 1;
#line 136
  iptr = iptr + 1;
#line 124
  cnt = cnt + 1U;
  ldv_65775: ;
#line 124
  if ((uint32_t )ha->mbx_count > cnt) {
#line 126
    goto ldv_65774;
  } else {

  }
#line 139
  ql_dbg(537001984U, vha, 4375, "I/O Address = %p.\n", optr);
#line 143
  ha->flags.mbox_int = 0U;
#line 144
  clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 147
  ql_dbg(536870912U, vha, 4111, "Going to unlock irq & waiting for interrupts. jiffies=%lx.\n",
         jiffies);
#line 153
  if (((unsigned int )abort_active == 0U && (unsigned int )io_lock_on != 0U) || ((ha->device_type & 8192U) != 0U && *((unsigned long *)ha + 2UL) != 0UL)) {
#line 154
    set_bit(2L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 156
    if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 157
      tmp___3 = readl((void const volatile   *)(& reg->isp82.hint));
#line 157
      if ((int )tmp___3 & 1) {
#line 159
        spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 161
        ha->flags.mbox_busy = 0U;
#line 162
        ql_dbg(536870912U, vha, 4112, "Pending mailbox timeout, exiting.\n");
#line 164
        rval = 256;
#line 165
        goto premature_exit;
      } else {

      }
#line 167
      writel(1U, (void volatile   *)(& reg->isp82.hint));
    } else
#line 168
    if ((ha->device_type & 134217728U) != 0U) {
#line 169
      writel(1342177280U, (void volatile   *)(& reg->isp24.hccr));
    } else {
#line 171
      writew(20480, (void volatile   *)(& reg->isp.hccr));
    }
#line 172
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 174
    tmp___5 = wait_for_completion_timeout(& ha->mbx_intr_comp, (unsigned long )(mcp->tov * 250U));
#line 174
    if (tmp___5 == 0UL) {
#line 176
      ql_dbg(536870912U, vha, 4474, "cmd=%x Timeout.\n", (int )command);
#line 178
      tmp___4 = spinlock_check(& ha->hardware_lock);
#line 178
      flags = _raw_spin_lock_irqsave(tmp___4);
#line 179
      clear_bit(2L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 180
      spin_unlock_irqrestore(& ha->hardware_lock, flags);
    } else {

    }
  } else {
#line 183
    ql_dbg(536870912U, vha, 4113, "Cmd=%x Polling Mode.\n", (int )command);
#line 186
    if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 187
      tmp___6 = readl((void const volatile   *)(& reg->isp82.hint));
#line 187
      if ((int )tmp___6 & 1) {
#line 189
        spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 191
        ha->flags.mbox_busy = 0U;
#line 192
        ql_dbg(536870912U, vha, 4114, "Pending mailbox timeout, exiting.\n");
#line 194
        rval = 256;
#line 195
        goto premature_exit;
      } else {

      }
#line 197
      writel(1U, (void volatile   *)(& reg->isp82.hint));
    } else
#line 198
    if ((ha->device_type & 134217728U) != 0U) {
#line 199
      writel(1342177280U, (void volatile   *)(& reg->isp24.hccr));
    } else {
#line 201
      writew(20480, (void volatile   *)(& reg->isp.hccr));
    }
#line 202
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 204
    wait_time = (unsigned long )(mcp->tov * 250U) + (unsigned long )jiffies;
#line 205
    goto ldv_65789;
    ldv_65788: ;
#line 206
    if ((long )(wait_time - (unsigned long )jiffies) < 0L) {
#line 207
      goto ldv_65787;
    } else {

    }
#line 210
    qla2x00_poll(*(ha->rsp_q_map));
#line 212
    if (*((unsigned long *)ha + 2UL) == 0UL && ((ha->device_type & 2U) == 0U || (unsigned int )command != 11U)) {
#line 215
      msleep(10U);
    } else {

    }
    ldv_65789: ;
#line 205
    if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 207
      goto ldv_65788;
    } else {

    }
    ldv_65787: 
#line 217
    ql_dbg(536870912U, vha, 4115, "Waited %d sec.\n", (unsigned int )((((unsigned long )(mcp->tov * 250U) - wait_time) + (unsigned long )jiffies) / 250UL));
  }
#line 223
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 226
    ql_dbg(536870912U, vha, 4116, "Cmd=%x completed.\n", (int )command);
#line 230
    ha->flags.mbox_int = 0U;
#line 231
    clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 233
    if (((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) && *((unsigned long *)ha + 2UL) != 0UL) {
#line 234
      ha->flags.mbox_busy = 0U;
#line 236
      mcp->mb[0] = 16395U;
#line 237
      ha->mcp = (mbx_cmd_t *)0;
#line 238
      rval = 258;
#line 239
      ql_log(1U, vha, 4117, "FW hung = %d.\n", (int )ha->flags.isp82xx_fw_hung);
#line 241
      goto premature_exit;
    } else {

    }
#line 244
    if ((unsigned int )ha->mailbox_out[0] != 16384U) {
#line 245
      rval = 258;
    } else {

    }
#line 248
    iptr2 = (uint16_t *)(& mcp->mb);
#line 249
    iptr = (uint16_t *)(& ha->mailbox_out);
#line 250
    mboxes = mcp->in_mb;
#line 252
    ql_dbg(536870912U, vha, 4371, "Mailbox registers (IN):\n");
#line 254
    cnt = 0U;
#line 254
    goto ldv_65792;
    ldv_65791: ;
#line 255
    if ((int )mboxes & 1) {
#line 256
      *iptr2 = *iptr;
#line 257
      ql_dbg(536870912U, vha, 4372, "mbox[%d]->0x%04x\n", cnt, (int )*iptr2);
    } else {

    }
#line 261
    mboxes = mboxes >> 1;
#line 262
    iptr2 = iptr2 + 1;
#line 263
    iptr = iptr + 1;
#line 254
    cnt = cnt + 1U;
    ldv_65792: ;
#line 254
    if ((uint32_t )ha->mbx_count > cnt) {
#line 256
      goto ldv_65791;
    } else {

    }

  } else {
#line 270
    if ((ha->device_type & 134217728U) != 0U) {
#line 271
      mb0 = readw((void const volatile   *)(& reg->isp24.mailbox0));
#line 272
      ictrl = readl((void const volatile   *)(& reg->isp24.ictrl));
    } else {
#line 274
      mb0 = readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->isp.u.isp2100.mailbox0 : & reg->isp.u.isp2300.mailbox0));
#line 275
      tmp___7 = readw((void const volatile   *)(& reg->isp.ictrl));
#line 275
      ictrl = (uint32_t )tmp___7;
    }
#line 277
    ql_dbg(537001984U, vha, 4377, "MBX Command timeout for cmd %x, iocontrol=%x jiffies=%lx mb[0]=0x%x\n",
           (int )command, ictrl, jiffies, (int )mb0);
#line 280
    ql_dump_regs(537001984U, vha, 4121);
#line 287
    if ((unsigned int )mcp->mb[0] != 42U) {
#line 288
      (*((ha->isp_ops)->fw_dump))(vha, 0);
    } else {

    }
#line 290
    rval = 256;
  }
#line 293
  ha->flags.mbox_busy = 0U;
#line 296
  ha->mcp = (mbx_cmd_t *)0;
#line 298
  if (((unsigned int )abort_active != 0U || (unsigned int )io_lock_on == 0U) && ((ha->device_type & 8192U) == 0U || *((unsigned long *)ha + 2UL) == 0UL)) {
#line 299
    ql_dbg(536870912U, vha, 4122, "Checking for additional resp interrupt.\n");
#line 303
    qla2x00_poll(*(ha->rsp_q_map));
  } else {

  }
#line 306
  if (rval == 256 && (unsigned int )mcp->mb[0] != 42U) {
#line 308
    if (((unsigned int )io_lock_on == 0U || ((int )mcp->flags & 4) != 0) || *((unsigned long *)ha + 2UL) != 0UL) {
#line 311
      ql_dbg(536870912U, vha, 4123, "Timeout, schedule isp_abort_needed.\n");
#line 314
      tmp___8 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 314
      if (tmp___8 == 0) {
#line 314
        tmp___9 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 314
        if (tmp___9 == 0) {
#line 314
          tmp___10 = constant_test_bit(10L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 314
          if (tmp___10 == 0) {
#line 317
            if ((ha->device_type & 16384U) != 0U) {
#line 318
              ql_dbg(536870912U, vha, 4394, "disabling pause transmit on port 0 & 1.\n");
#line 321
              qla82xx_wr_32(ha, 106954904UL, 9U);
            } else {

            }
#line 326
            ql_log(2U, base_vha, 4124, "Mailbox cmd timeout occurred, cmd=0x%x, mb[0]=0x%x, eeh_busy=0x%x. Scheduling ISP abort.\n",
                   (int )command, (int )mcp->mb[0], (int )ha->flags.eeh_busy);
#line 331
            set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 332
            qla2xxx_wake_dpc(vha);
          } else {

          }
        } else {

        }
      } else {

      }
    } else
#line 334
    if ((unsigned int )abort_active == 0U) {
#line 336
      ql_dbg(536870912U, vha, 4125, "Timeout, calling abort_isp.\n");
#line 339
      tmp___12 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 339
      if (tmp___12 == 0) {
#line 339
        tmp___13 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 339
        if (tmp___13 == 0) {
#line 339
          tmp___14 = constant_test_bit(10L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 339
          if (tmp___14 == 0) {
#line 342
            if ((ha->device_type & 16384U) != 0U) {
#line 343
              ql_dbg(536870912U, vha, 4395, "disabling pause transmit on port 0 & 1.\n");
#line 346
              qla82xx_wr_32(ha, 106954904UL, 9U);
            } else {

            }
#line 351
            ql_log(2U, base_vha, 4126, "Mailbox cmd timeout occurred, cmd=0x%x, mb[0]=0x%x. Scheduling ISP abort ",
                   (int )command, (int )mcp->mb[0]);
#line 355
            set_bit(3L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 356
            clear_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 358
            complete(& ha->mbx_cmd_comp);
#line 359
            tmp___11 = (*((ha->isp_ops)->abort_isp))(vha);
#line 359
            if (tmp___11 != 0) {
#line 361
              set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
            } else {

            }
#line 364
            clear_bit(3L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 365
            ql_dbg(536870912U, vha, 4127, "Finished abort_isp.\n");
#line 367
            goto mbx_done;
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
  premature_exit: 
#line 374
  complete(& ha->mbx_cmd_comp);
  mbx_done: ;
#line 377
  if (rval != 0) {
#line 378
    ql_dbg(268435456U, base_vha, 4128, "**** Failed mbx[0]=%x, mb[1]=%x, mb[2]=%x, mb[3]=%x, cmd=%x ****.\n",
           (int )mcp->mb[0], (int )mcp->mb[1], (int )mcp->mb[2], (int )mcp->mb[3],
           (int )command);
#line 382
    tmp___15 = readl((void const volatile   *)(& reg->isp24.istatus));
#line 382
    tmp___16 = readl((void const volatile   *)(& reg->isp24.ictrl));
#line 382
    tmp___17 = readl((void const volatile   *)(& reg->isp24.host_status));
#line 382
    ql_dbg(268435456U, vha, 4373, "host status: 0x%x, flags:0x%lx, intr ctrl reg:0x%x, intr status:0x%x\n",
           tmp___17, ha->fw_dump_cap_flags, tmp___16, tmp___15);
#line 389
    mbx_reg = & reg->isp24.mailbox0;
#line 390
    i = 0;
#line 390
    goto ldv_65798;
    ldv_65797: 
#line 391
    tmp___18 = mbx_reg;
#line 391
    mbx_reg = mbx_reg + 1;
#line 391
    tmp___19 = readw((void const volatile   *)tmp___18);
#line 391
    ql_dbg(268468224U, vha, 4374, "mbox[%d] 0x%04x\n", i, (int )tmp___19);
#line 390
    i = i + 1;
    ldv_65798: ;
#line 390
    if (i <= 5) {
#line 392
      goto ldv_65797;
    } else {

    }

  } else {
#line 394
    ql_dbg(536870912U, base_vha, 4129, "Done %s.\n", "qla2x00_mailbox_command");
  }
#line 397
  return (rval);
}
}
#line 401 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_load_ram(scsi_qla_host_t *vha , dma_addr_t req_dma , uint32_t risc_addr ,
                     uint32_t risc_code_size ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 405
  ha = vha->hw;
#line 407
  mcp = & mc;
#line 409
  ql_dbg(536903680U, vha, 4130, "Entered %s.\n", "qla2x00_load_ram");
#line 412
  if ((unsigned int )((unsigned short )(risc_addr >> 16)) != 0U || (ha->device_type & 134217728U) != 0U) {
#line 413
    mcp->mb[0] = 11U;
#line 414
    mcp->mb[8] = (unsigned short )(risc_addr >> 16);
#line 415
    mcp->out_mb = 257U;
  } else {
#line 417
    mcp->mb[0] = 9U;
#line 418
    mcp->out_mb = 1U;
  }
#line 420
  mcp->mb[1] = (unsigned short )risc_addr;
#line 421
  mcp->mb[2] = (unsigned short )((unsigned int )req_dma >> 16);
#line 422
  mcp->mb[3] = (unsigned short )req_dma;
#line 423
  mcp->mb[6] = (unsigned short )((unsigned int )(req_dma >> 32ULL) >> 16);
#line 424
  mcp->mb[7] = (unsigned short )(req_dma >> 32ULL);
#line 425
  mcp->out_mb = mcp->out_mb | 206U;
#line 426
  if ((ha->device_type & 134217728U) != 0U) {
#line 427
    mcp->mb[4] = (unsigned short )(risc_code_size >> 16);
#line 428
    mcp->mb[5] = (unsigned short )risc_code_size;
#line 429
    mcp->out_mb = mcp->out_mb | 48U;
  } else {
#line 431
    mcp->mb[4] = (unsigned short )risc_code_size;
#line 432
    mcp->out_mb = mcp->out_mb | 16U;
  }
#line 435
  mcp->in_mb = 1U;
#line 436
  mcp->tov = 30U;
#line 437
  mcp->flags = 0U;
#line 438
  rval = qla2x00_mailbox_command(vha, mcp);
#line 440
  if (rval != 0) {
#line 441
    ql_dbg(536870912U, vha, 4131, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 444
    ql_dbg(536903680U, vha, 4132, "Done %s.\n", "qla2x00_load_ram");
  }
#line 448
  return (rval);
}
}
#line 468 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_execute_fw(scsi_qla_host_t *vha , uint32_t risc_addr ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct nvram_81xx *nv ;

  {
#line 471
  ha = vha->hw;
#line 473
  mcp = & mc;
#line 475
  ql_dbg(536903680U, vha, 4133, "Entered %s.\n", "qla2x00_execute_fw");
#line 478
  mcp->mb[0] = 2U;
#line 479
  mcp->out_mb = 1U;
#line 480
  mcp->in_mb = 1U;
#line 481
  if ((ha->device_type & 134217728U) != 0U) {
#line 482
    mcp->mb[1] = (unsigned short )(risc_addr >> 16);
#line 483
    mcp->mb[2] = (unsigned short )risc_addr;
#line 484
    mcp->mb[3] = 0U;
#line 485
    if ((((ha->device_type & 2048U) != 0U || (ha->device_type & 8192U) != 0U) || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 487
      nv = (struct nvram_81xx *)ha->nvram;
#line 488
      mcp->mb[4] = (unsigned int )((uint16_t )nv->enhanced_features) & 1U;
    } else {
#line 491
      mcp->mb[4] = 0U;
    }
#line 492
    mcp->out_mb = mcp->out_mb | 30U;
#line 493
    mcp->in_mb = mcp->in_mb | 2U;
  } else {
#line 495
    mcp->mb[1] = (unsigned short )risc_addr;
#line 496
    mcp->out_mb = mcp->out_mb | 2U;
#line 497
    if ((ha->device_type & 16U) != 0U || (ha->device_type & 64U) != 0U) {
#line 498
      mcp->mb[2] = 0U;
#line 499
      mcp->out_mb = mcp->out_mb | 4U;
    } else {

    }
  }
#line 503
  mcp->tov = 30U;
#line 504
  mcp->flags = 0U;
#line 505
  rval = qla2x00_mailbox_command(vha, mcp);
#line 507
  if (rval != 0) {
#line 508
    ql_dbg(536870912U, vha, 4134, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else
#line 511
  if ((ha->device_type & 134217728U) != 0U) {
#line 512
    ql_dbg(536903680U, vha, 4135, "Done exchanges=%x.\n", (int )mcp->mb[1]);
  } else {
#line 515
    ql_dbg(536903680U, vha, 4136, "Done %s.\n", "qla2x00_execute_fw");
  }
#line 520
  return (rval);
}
}
#line 540 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_get_fw_version(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;

  {
#line 544
  mcp = & mc;
#line 545
  ha = vha->hw;
#line 547
  ql_dbg(536903680U, vha, 4137, "Entered %s.\n", "qla2x00_get_fw_version");
#line 550
  mcp->mb[0] = 8U;
#line 551
  mcp->out_mb = 1U;
#line 552
  mcp->in_mb = 127U;
#line 553
  if ((((vha->hw)->device_type & 8192U) != 0U || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 554
    mcp->in_mb = mcp->in_mb | 16128U;
  } else {

  }
#line 555
  if ((ha->device_type & 134217728U) != 0U) {
#line 556
    mcp->in_mb = mcp->in_mb | 229376U;
  } else {

  }
#line 557
  if ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) {
#line 558
    mcp->in_mb = mcp->in_mb | 3932160U;
  } else {

  }
#line 559
  mcp->flags = 0U;
#line 560
  mcp->tov = 30U;
#line 561
  rval = qla2x00_mailbox_command(vha, mcp);
#line 562
  if (rval != 0) {
#line 563
    goto failed;
  } else {

  }
#line 566
  ha->fw_major_version = mcp->mb[1];
#line 567
  ha->fw_minor_version = mcp->mb[2];
#line 568
  ha->fw_subminor_version = mcp->mb[3];
#line 569
  ha->fw_attributes = mcp->mb[6];
#line 570
  if ((int )(vha->hw)->device_type & 1 || ((vha->hw)->device_type & 2U) != 0U) {
#line 571
    ha->fw_memory_size = 131071U;
  } else {
#line 573
    ha->fw_memory_size = (uint32_t )(((int )mcp->mb[5] << 16) | (int )mcp->mb[4]);
  }
#line 574
  if ((((vha->hw)->device_type & 8192U) != 0U || ((vha->hw)->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 575
    ha->mpi_version[0] = (uint8_t )mcp->mb[10];
#line 576
    ha->mpi_version[1] = (uint8_t )((int )mcp->mb[11] >> 8);
#line 577
    ha->mpi_version[2] = (uint8_t )mcp->mb[11];
#line 578
    ha->mpi_capabilities = (uint32_t )(((int )mcp->mb[12] << 16) | (int )mcp->mb[13]);
#line 579
    ha->phy_version[0] = (uint8_t )mcp->mb[8];
#line 580
    ha->phy_version[1] = (uint8_t )((int )mcp->mb[9] >> 8);
#line 581
    ha->phy_version[2] = (uint8_t )mcp->mb[9];
  } else {

  }
#line 583
  if ((ha->device_type & 134217728U) != 0U) {
#line 584
    ha->fw_attributes_h = mcp->mb[15];
#line 585
    ha->fw_attributes_ext[0] = mcp->mb[16];
#line 586
    ha->fw_attributes_ext[1] = mcp->mb[17];
#line 587
    ql_dbg(536903680U, vha, 4409, "%s: FW_attributes Upper: 0x%x, Lower: 0x%x.\n",
           "qla2x00_get_fw_version", (int )mcp->mb[15], (int )mcp->mb[6]);
#line 590
    ql_dbg(536903680U, vha, 4399, "%s: Ext_FwAttributes Upper: 0x%x, Lower: 0x%x.\n",
           "qla2x00_get_fw_version", (int )mcp->mb[17], (int )mcp->mb[16]);
  } else {

  }
#line 594
  if ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) {
#line 595
    ha->fw_shared_ram_start = (uint32_t )(((int )mcp->mb[19] << 16) | (int )mcp->mb[18]);
#line 596
    ha->fw_shared_ram_end = (uint32_t )(((int )mcp->mb[21] << 16) | (int )mcp->mb[20]);
  } else {

  }
  failed: ;
#line 600
  if (rval != 0) {
#line 602
    ql_dbg(536870912U, vha, 4138, "Failed=%x.\n", rval);
  } else {
#line 605
    ql_dbg(536903680U, vha, 4139, "Done %s.\n", "qla2x00_get_fw_version");
  }
#line 608
  return (rval);
}
}
#line 626 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_get_fw_options(scsi_qla_host_t *vha , uint16_t *fwopts ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 630
  mcp = & mc;
#line 632
  ql_dbg(536903680U, vha, 4140, "Entered %s.\n", "qla2x00_get_fw_options");
#line 635
  mcp->mb[0] = 40U;
#line 636
  mcp->out_mb = 1U;
#line 637
  mcp->in_mb = 15U;
#line 638
  mcp->tov = 30U;
#line 639
  mcp->flags = 0U;
#line 640
  rval = qla2x00_mailbox_command(vha, mcp);
#line 642
  if (rval != 0) {
#line 644
    ql_dbg(536870912U, vha, 4141, "Failed=%x.\n", rval);
  } else {
#line 646
    *fwopts = mcp->mb[0];
#line 647
    *(fwopts + 1UL) = mcp->mb[1];
#line 648
    *(fwopts + 2UL) = mcp->mb[2];
#line 649
    *(fwopts + 3UL) = mcp->mb[3];
#line 651
    ql_dbg(536903680U, vha, 4142, "Done %s.\n", "qla2x00_get_fw_options");
  }
#line 655
  return (rval);
}
}
#line 674 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_set_fw_options(scsi_qla_host_t *vha , uint16_t *fwopts ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 678
  mcp = & mc;
#line 680
  ql_dbg(536903680U, vha, 4143, "Entered %s.\n", "qla2x00_set_fw_options");
#line 683
  mcp->mb[0] = 56U;
#line 684
  mcp->mb[1] = *(fwopts + 1UL);
#line 685
  mcp->mb[2] = *(fwopts + 2UL);
#line 686
  mcp->mb[3] = *(fwopts + 3UL);
#line 687
  mcp->out_mb = 15U;
#line 688
  mcp->in_mb = 1U;
#line 689
  if (((vha->hw)->device_type & 134217728U) != 0U) {
#line 690
    mcp->in_mb = mcp->in_mb | 2U;
  } else {
#line 692
    mcp->mb[10] = *(fwopts + 10UL);
#line 693
    mcp->mb[11] = *(fwopts + 11UL);
#line 694
    mcp->mb[12] = 0U;
#line 695
    mcp->out_mb = mcp->out_mb | 7168U;
  }
#line 697
  mcp->tov = 30U;
#line 698
  mcp->flags = 0U;
#line 699
  rval = qla2x00_mailbox_command(vha, mcp);
#line 701
  *fwopts = mcp->mb[0];
#line 703
  if (rval != 0) {
#line 705
    ql_dbg(536870912U, vha, 4144, "Failed=%x (%x/%x).\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 709
    ql_dbg(536903680U, vha, 4145, "Done %s.\n", "qla2x00_set_fw_options");
  }
#line 713
  return (rval);
}
}
#line 732 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_mbx_reg_test(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 736
  mcp = & mc;
#line 738
  ql_dbg(536903680U, vha, 4146, "Entered %s.\n", "qla2x00_mbx_reg_test");
#line 741
  mcp->mb[0] = 6U;
#line 742
  mcp->mb[1] = 43690U;
#line 743
  mcp->mb[2] = 21845U;
#line 744
  mcp->mb[3] = 43605U;
#line 745
  mcp->mb[4] = 21930U;
#line 746
  mcp->mb[5] = 42405U;
#line 747
  mcp->mb[6] = 23130U;
#line 748
  mcp->mb[7] = 9509U;
#line 749
  mcp->out_mb = 255U;
#line 750
  mcp->in_mb = 255U;
#line 751
  mcp->tov = 30U;
#line 752
  mcp->flags = 0U;
#line 753
  rval = qla2x00_mailbox_command(vha, mcp);
#line 755
  if (rval == 0) {
#line 756
    if ((((unsigned int )mcp->mb[1] != 43690U || (unsigned int )mcp->mb[2] != 21845U) || (unsigned int )mcp->mb[3] != 43605U) || (unsigned int )mcp->mb[4] != 21930U) {
#line 758
      rval = 258;
    } else {

    }
#line 759
    if (((unsigned int )mcp->mb[5] != 42405U || (unsigned int )mcp->mb[6] != 23130U) || (unsigned int )mcp->mb[7] != 9509U) {
#line 761
      rval = 258;
    } else {

    }
  } else {

  }
#line 764
  if (rval != 0) {
#line 766
    ql_dbg(536870912U, vha, 4147, "Failed=%x.\n", rval);
  } else {
#line 769
    ql_dbg(536903680U, vha, 4148, "Done %s.\n", "qla2x00_mbx_reg_test");
  }
#line 773
  return (rval);
}
}
#line 792 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_verify_checksum(scsi_qla_host_t *vha , uint32_t risc_addr ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 796
  mcp = & mc;
#line 798
  ql_dbg(536903680U, vha, 4149, "Entered %s.\n", "qla2x00_verify_checksum");
#line 801
  mcp->mb[0] = 7U;
#line 802
  mcp->out_mb = 1U;
#line 803
  mcp->in_mb = 1U;
#line 804
  if (((vha->hw)->device_type & 134217728U) != 0U) {
#line 805
    mcp->mb[1] = (unsigned short )(risc_addr >> 16);
#line 806
    mcp->mb[2] = (unsigned short )risc_addr;
#line 807
    mcp->out_mb = mcp->out_mb | 6U;
#line 808
    mcp->in_mb = mcp->in_mb | 6U;
  } else {
#line 810
    mcp->mb[1] = (unsigned short )risc_addr;
#line 811
    mcp->out_mb = mcp->out_mb | 2U;
#line 812
    mcp->in_mb = mcp->in_mb | 2U;
  }
#line 815
  mcp->tov = 30U;
#line 816
  mcp->flags = 0U;
#line 817
  rval = qla2x00_mailbox_command(vha, mcp);
#line 819
  if (rval != 0) {
#line 820
    ql_dbg(536870912U, vha, 4150, "Failed=%x chm sum=%x.\n", rval, ((vha->hw)->device_type & 134217728U) != 0U ? ((int )mcp->mb[2] << 16) | (int )mcp->mb[1] : (int )mcp->mb[1]);
  } else {
#line 824
    ql_dbg(536903680U, vha, 4151, "Done %s.\n", "qla2x00_verify_checksum");
  }
#line 828
  return (rval);
}
}
#line 850 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_issue_iocb_timeout(scsi_qla_host_t *vha , void *buffer , dma_addr_t phys_addr ,
                               size_t size , uint32_t tov ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  sts_entry_t *sts_entry ;

  {
#line 855
  mcp = & mc;
#line 857
  ql_dbg(536903680U, vha, 4152, "Entered %s.\n", "qla2x00_issue_iocb_timeout");
#line 860
  mcp->mb[0] = 84U;
#line 861
  mcp->mb[1] = 0U;
#line 862
  mcp->mb[2] = (unsigned short )((unsigned int )phys_addr >> 16);
#line 863
  mcp->mb[3] = (unsigned short )phys_addr;
#line 864
  mcp->mb[6] = (unsigned short )((unsigned int )(phys_addr >> 32ULL) >> 16);
#line 865
  mcp->mb[7] = (unsigned short )(phys_addr >> 32ULL);
#line 866
  mcp->out_mb = 207U;
#line 867
  mcp->in_mb = 5U;
#line 868
  mcp->tov = tov;
#line 869
  mcp->flags = 0U;
#line 870
  rval = qla2x00_mailbox_command(vha, mcp);
#line 872
  if (rval != 0) {
#line 874
    ql_dbg(536870912U, vha, 4153, "Failed=%x.\n", rval);
  } else {
#line 876
    sts_entry = (sts_entry_t *)buffer;
#line 879
    sts_entry->entry_status = (uint8_t )((int )((signed char )sts_entry->entry_status) & (((vha->hw)->device_type & 134217728U) != 0U ? 60 : 126));
#line 881
    ql_dbg(536903680U, vha, 4154, "Done %s.\n", "qla2x00_issue_iocb_timeout");
  }
#line 885
  return (rval);
}
}
#line 889 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_issue_iocb(scsi_qla_host_t *vha , void *buffer , dma_addr_t phys_addr ,
                       size_t size ) 
{ 
  int tmp ;

  {
#line 892
  tmp = qla2x00_issue_iocb_timeout(vha, buffer, phys_addr, size, 30U);
#line 892
  return (tmp);
}
}
#line 911 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_abort_command(srb_t *sp ) 
{ 
  unsigned long flags ;
  int rval ;
  uint32_t handle ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  fc_port_t *fcport ;
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct scsi_cmnd *cmd ;
  raw_spinlock_t *tmp ;

  {
#line 913
  flags = 0UL;
#line 915
  handle = 0U;
#line 917
  mcp = & mc;
#line 918
  fcport = sp->fcport;
#line 919
  vha = fcport->vha;
#line 920
  ha = vha->hw;
#line 921
  req = vha->req;
#line 922
  cmd = sp->u.scmd.cmd;
#line 924
  ql_dbg(536903680U, vha, 4155, "Entered %s.\n", "qla2x00_abort_command");
#line 927
  tmp = spinlock_check(& ha->hardware_lock);
#line 927
  flags = _raw_spin_lock_irqsave(tmp);
#line 928
  handle = 1U;
#line 928
  goto ldv_65898;
  ldv_65897: ;
#line 929
  if ((unsigned long )*(req->outstanding_cmds + (unsigned long )handle) == (unsigned long )sp) {
#line 930
    goto ldv_65896;
  } else {

  }
#line 928
  handle = handle + 1U;
  ldv_65898: ;
#line 928
  if ((uint32_t )req->num_outstanding_cmds > handle) {
#line 930
    goto ldv_65897;
  } else {

  }
  ldv_65896: 
#line 932
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 934
  if ((uint32_t )req->num_outstanding_cmds == handle) {
#line 936
    return (258);
  } else {

  }
#line 939
  mcp->mb[0] = 21U;
#line 940
  if ((int )ha->device_type < 0) {
#line 941
    mcp->mb[1] = fcport->loop_id;
  } else {
#line 943
    mcp->mb[1] = (int )fcport->loop_id << 8U;
  }
#line 944
  mcp->mb[2] = (unsigned short )handle;
#line 945
  mcp->mb[3] = (unsigned short )(handle >> 16);
#line 946
  mcp->mb[6] = (unsigned short )(cmd->device)->lun;
#line 947
  mcp->out_mb = 79U;
#line 948
  mcp->in_mb = 1U;
#line 949
  mcp->tov = 30U;
#line 950
  mcp->flags = 0U;
#line 951
  rval = qla2x00_mailbox_command(vha, mcp);
#line 953
  if (rval != 0) {
#line 954
    ql_dbg(536870912U, vha, 4156, "Failed=%x.\n", rval);
  } else {
#line 956
    ql_dbg(536903680U, vha, 4157, "Done %s.\n", "qla2x00_abort_command");
  }
#line 960
  return (rval);
}
}
#line 964 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_abort_target(struct fc_port *fcport , uint64_t l , int tag ) 
{ 
  int rval ;
  int rval2 ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  scsi_qla_host_t *vha ;
  struct req_que *req ;
  struct rsp_que *rsp ;

  {
#line 968
  mcp = & mc;
#line 973
  l = l;
#line 974
  vha = fcport->vha;
#line 976
  ql_dbg(536903680U, vha, 4158, "Entered %s.\n", "qla2x00_abort_target");
#line 979
  req = *((vha->hw)->req_q_map);
#line 980
  rsp = req->rsp;
#line 981
  mcp->mb[0] = 23U;
#line 982
  mcp->out_mb = 519U;
#line 983
  if ((int )(vha->hw)->device_type < 0) {
#line 984
    mcp->mb[1] = fcport->loop_id;
#line 985
    mcp->mb[10] = 0U;
#line 986
    mcp->out_mb = mcp->out_mb | 1024U;
  } else {
#line 988
    mcp->mb[1] = (int )fcport->loop_id << 8U;
  }
#line 990
  mcp->mb[2] = (vha->hw)->loop_reset_delay;
#line 991
  mcp->mb[9] = vha->vp_idx;
#line 993
  mcp->in_mb = 1U;
#line 994
  mcp->tov = 30U;
#line 995
  mcp->flags = 0U;
#line 996
  rval = qla2x00_mailbox_command(vha, mcp);
#line 997
  if (rval != 0) {
#line 998
    ql_dbg(536903680U, vha, 4159, "Failed=%x.\n", rval);
  } else {

  }
#line 1003
  rval2 = qla2x00_marker(vha, req, rsp, (int )fcport->loop_id, 0ULL, 1);
#line 1005
  if (rval2 != 0) {
#line 1006
    ql_dbg(536870912U, vha, 4160, "Failed to issue marker IOCB (%x).\n", rval2);
  } else {
#line 1009
    ql_dbg(536903680U, vha, 4161, "Done %s.\n", "qla2x00_abort_target");
  }
#line 1013
  return (rval);
}
}
#line 1017 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_lun_reset(struct fc_port *fcport , uint64_t l , int tag ) 
{ 
  int rval ;
  int rval2 ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  scsi_qla_host_t *vha ;
  struct req_que *req ;
  struct rsp_que *rsp ;

  {
#line 1021
  mcp = & mc;
#line 1026
  vha = fcport->vha;
#line 1028
  ql_dbg(536903680U, vha, 4162, "Entered %s.\n", "qla2x00_lun_reset");
#line 1031
  req = *((vha->hw)->req_q_map);
#line 1032
  rsp = req->rsp;
#line 1033
  mcp->mb[0] = 126U;
#line 1034
  mcp->out_mb = 527U;
#line 1035
  if ((int )(vha->hw)->device_type < 0) {
#line 1036
    mcp->mb[1] = fcport->loop_id;
  } else {
#line 1038
    mcp->mb[1] = (int )fcport->loop_id << 8U;
  }
#line 1039
  mcp->mb[2] = (uint16_t )l;
#line 1040
  mcp->mb[3] = 0U;
#line 1041
  mcp->mb[9] = vha->vp_idx;
#line 1043
  mcp->in_mb = 1U;
#line 1044
  mcp->tov = 30U;
#line 1045
  mcp->flags = 0U;
#line 1046
  rval = qla2x00_mailbox_command(vha, mcp);
#line 1047
  if (rval != 0) {
#line 1048
    ql_dbg(536870912U, vha, 4163, "Failed=%x.\n", rval);
  } else {

  }
#line 1052
  rval2 = qla2x00_marker(vha, req, rsp, (int )fcport->loop_id, l, 0);
#line 1054
  if (rval2 != 0) {
#line 1055
    ql_dbg(536870912U, vha, 4164, "Failed to issue marker IOCB (%x).\n", rval2);
  } else {
#line 1058
    ql_dbg(536903680U, vha, 4165, "Done %s.\n", "qla2x00_lun_reset");
  }
#line 1062
  return (rval);
}
}
#line 1086 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_get_adapter_id(scsi_qla_host_t *vha , uint16_t *id , uint8_t *al_pa ,
                           uint8_t *area , uint8_t *domain , uint16_t *top , uint16_t *sw_cap ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  u64 tmp ;

  {
#line 1091
  mcp = & mc;
#line 1093
  ql_dbg(536903680U, vha, 4166, "Entered %s.\n", "qla2x00_get_adapter_id");
#line 1096
  mcp->mb[0] = 32U;
#line 1097
  mcp->mb[9] = vha->vp_idx;
#line 1098
  mcp->out_mb = 513U;
#line 1099
  mcp->in_mb = 719U;
#line 1100
  if (((((vha->hw)->device_type & 8192U) != 0U || ((vha->hw)->device_type & 16384U) != 0U) || ((vha->hw)->device_type & 65536U) != 0U) || ((vha->hw)->device_type & 262144U) != 0U) {
#line 1101
    mcp->in_mb = mcp->in_mb | 15360U;
  } else {

  }
#line 1102
  if (((vha->hw)->device_type & 134217728U) != 0U) {
#line 1103
    mcp->in_mb = mcp->in_mb | 983040U;
  } else {

  }
#line 1104
  mcp->tov = 30U;
#line 1105
  mcp->flags = 0U;
#line 1106
  rval = qla2x00_mailbox_command(vha, mcp);
#line 1107
  if ((unsigned int )mcp->mb[0] == 16389U) {
#line 1108
    rval = 5;
  } else
#line 1109
  if ((unsigned int )mcp->mb[0] == 16385U) {
#line 1110
    rval = 1;
  } else {

  }
#line 1113
  *id = mcp->mb[1];
#line 1114
  *al_pa = (unsigned char )mcp->mb[2];
#line 1115
  *area = (unsigned char )((int )mcp->mb[2] >> 8);
#line 1116
  *domain = (unsigned char )mcp->mb[3];
#line 1117
  *top = mcp->mb[6];
#line 1118
  *sw_cap = mcp->mb[7];
#line 1120
  if (rval != 0) {
#line 1122
    ql_dbg(536870912U, vha, 4167, "Failed=%x.\n", rval);
  } else {
#line 1124
    ql_dbg(536903680U, vha, 4168, "Done %s.\n", "qla2x00_get_adapter_id");
#line 1127
    if (((((vha->hw)->device_type & 8192U) != 0U || ((vha->hw)->device_type & 16384U) != 0U) || ((vha->hw)->device_type & 65536U) != 0U) || ((vha->hw)->device_type & 262144U) != 0U) {
#line 1128
      vha->fcoe_vlan_id = (unsigned int )mcp->mb[9] & 4095U;
#line 1129
      vha->fcoe_fcf_idx = mcp->mb[10];
#line 1130
      vha->fcoe_vn_port_mac[5] = (uint8_t )((int )mcp->mb[11] >> 8);
#line 1131
      vha->fcoe_vn_port_mac[4] = (uint8_t )mcp->mb[11];
#line 1132
      vha->fcoe_vn_port_mac[3] = (uint8_t )((int )mcp->mb[12] >> 8);
#line 1133
      vha->fcoe_vn_port_mac[2] = (uint8_t )mcp->mb[12];
#line 1134
      vha->fcoe_vn_port_mac[1] = (uint8_t )((int )mcp->mb[13] >> 8);
#line 1135
      vha->fcoe_vn_port_mac[0] = (uint8_t )mcp->mb[13];
    } else {

    }
#line 1138
    if (((int )mcp->mb[7] & 16384) != 0) {
#line 1139
      vha->port_name[0] = (unsigned char )((int )mcp->mb[16] >> 8);
#line 1140
      vha->port_name[1] = (unsigned char )mcp->mb[16];
#line 1141
      vha->port_name[2] = (unsigned char )((int )mcp->mb[17] >> 8);
#line 1142
      vha->port_name[3] = (unsigned char )mcp->mb[17];
#line 1143
      vha->port_name[4] = (unsigned char )((int )mcp->mb[18] >> 8);
#line 1144
      vha->port_name[5] = (unsigned char )mcp->mb[18];
#line 1145
      vha->port_name[6] = (unsigned char )((int )mcp->mb[19] >> 8);
#line 1146
      vha->port_name[7] = (unsigned char )mcp->mb[19];
#line 1147
      ((struct fc_host_attrs *)(vha->host)->shost_data)->port_name = wwn_to_u64((u8 *)(& vha->port_name));
#line 1149
      tmp = wwn_to_u64((u8 *)(& vha->port_name));
#line 1149
      ql_dbg(536870912U, vha, 4298, "FA-WWN acquired %016llx\n", tmp);
    } else {

    }
  }
#line 1155
  return (rval);
}
}
#line 1174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_get_retry_cnt(scsi_qla_host_t *vha , uint8_t *retry_cnt , uint8_t *tov ,
                          uint16_t *r_a_tov ) 
{ 
  int rval ;
  uint16_t ratov ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 1180
  mcp = & mc;
#line 1182
  ql_dbg(536903680U, vha, 4169, "Entered %s.\n", "qla2x00_get_retry_cnt");
#line 1185
  mcp->mb[0] = 34U;
#line 1186
  mcp->out_mb = 1U;
#line 1187
  mcp->in_mb = 15U;
#line 1188
  mcp->tov = 30U;
#line 1189
  mcp->flags = 0U;
#line 1190
  rval = qla2x00_mailbox_command(vha, mcp);
#line 1192
  if (rval != 0) {
#line 1194
    ql_dbg(536870912U, vha, 4170, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 1198
    *r_a_tov = (uint16_t )((unsigned int )mcp->mb[3] / 2U);
#line 1199
    ratov = (uint16_t )((unsigned int )mcp->mb[3] / 20U);
#line 1200
    if ((int )mcp->mb[1] * (int )ratov > (int )*retry_cnt * (int )*tov) {
#line 1202
      *retry_cnt = (unsigned char )mcp->mb[1];
#line 1203
      *tov = (uint8_t )ratov;
    } else {

    }
#line 1206
    ql_dbg(536903680U, vha, 4171, "Done %s mb3=%d ratov=%d.\n", "qla2x00_get_retry_cnt",
           (int )mcp->mb[3], (int )ratov);
  }
#line 1210
  return (rval);
}
}
#line 1231 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_init_firmware(scsi_qla_host_t *vha , uint16_t size ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;

  {
#line 1235
  mcp = & mc;
#line 1236
  ha = vha->hw;
#line 1238
  ql_dbg(536903680U, vha, 4172, "Entered %s.\n", "qla2x00_init_firmware");
#line 1241
  if (((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) && ql2xdbwr != 0) {
#line 1242
    qla82xx_wr_32(ha, ha->nxdb_wr_ptr, (u32 )(((int )ha->portnum << 5) | 4));
  } else {

  }
#line 1245
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1246
    mcp->mb[0] = 72U;
  } else {
#line 1248
    mcp->mb[0] = 96U;
  }
#line 1250
  mcp->mb[1] = 0U;
#line 1251
  mcp->mb[2] = (unsigned short )((unsigned int )ha->init_cb_dma >> 16);
#line 1252
  mcp->mb[3] = (unsigned short )ha->init_cb_dma;
#line 1253
  mcp->mb[6] = (unsigned short )((unsigned int )(ha->init_cb_dma >> 32ULL) >> 16);
#line 1254
  mcp->mb[7] = (unsigned short )(ha->init_cb_dma >> 32ULL);
#line 1255
  mcp->out_mb = 207U;
#line 1256
  if ((unsigned long )ha->ex_init_cb != (unsigned long )((struct ex_init_cb_81xx *)0) && (unsigned int )(ha->ex_init_cb)->ex_version != 0U) {
#line 1257
    mcp->mb[1] = 1U;
#line 1258
    mcp->mb[10] = (unsigned short )((unsigned int )ha->ex_init_cb_dma >> 16);
#line 1259
    mcp->mb[11] = (unsigned short )ha->ex_init_cb_dma;
#line 1260
    mcp->mb[12] = (unsigned short )((unsigned int )(ha->ex_init_cb_dma >> 32ULL) >> 16);
#line 1261
    mcp->mb[13] = (unsigned short )(ha->ex_init_cb_dma >> 32ULL);
#line 1262
    mcp->mb[14] = 64U;
#line 1263
    mcp->out_mb = mcp->out_mb | 31744U;
  } else {

  }
#line 1266
  mcp->in_mb = 7U;
#line 1267
  if (((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 1269
    mcp->in_mb = mcp->in_mb | 8U;
  } else {

  }
#line 1270
  mcp->buf_size = (long )size;
#line 1271
  mcp->flags = 2U;
#line 1272
  mcp->tov = 30U;
#line 1273
  rval = qla2x00_mailbox_command(vha, mcp);
#line 1275
  if (rval != 0) {
#line 1277
    ql_dbg(536870912U, vha, 4173, "Failed=%x mb[0]=%x, mb[1]=%x, mb[2]=%x, mb[3]=%x,.\n",
           rval, (int )mcp->mb[0], (int )mcp->mb[1], (int )mcp->mb[2], (int )mcp->mb[3]);
  } else {
#line 1282
    ql_dbg(536903680U, vha, 4174, "Done %s.\n", "qla2x00_init_firmware");
  }
#line 1286
  return (rval);
}
}
#line 1306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_get_node_name_list(scsi_qla_host_t *vha , void **out_data , int *out_len ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_port_24xx_data *list ;
  void *pmap ;
  mbx_cmd_t mc ;
  dma_addr_t pmap_dma ;
  ulong dma_size ;
  int rval ;
  int left ;
  void *tmp ;

  {
#line 1308
  ha = vha->hw;
#line 1309
  list = (struct qla_port_24xx_data *)0;
#line 1316
  left = 1;
#line 1317
  goto ldv_65976;
  ldv_65975: 
#line 1318
  dma_size = (unsigned long )left * 12UL;
#line 1319
  pmap = dma_alloc_attrs(& (ha->pdev)->dev, dma_size, & pmap_dma, 208U, (struct dma_attrs *)0);
#line 1321
  if ((unsigned long )pmap == (unsigned long )((void *)0)) {
#line 1322
    ql_log(1U, vha, 4415, "%s(%ld): DMA Alloc failed of %ld\n", "qla2x00_get_node_name_list",
           vha->host_no, dma_size);
#line 1325
    rval = 259;
#line 1326
    goto out;
  } else {

  }
#line 1329
  mc.mb[0] = 117U;
#line 1330
  mc.mb[1] = 10U;
#line 1331
  mc.mb[2] = (unsigned short )((unsigned int )pmap_dma >> 16);
#line 1332
  mc.mb[3] = (unsigned short )pmap_dma;
#line 1333
  mc.mb[6] = (unsigned short )((unsigned int )(pmap_dma >> 32ULL) >> 16);
#line 1334
  mc.mb[7] = (unsigned short )(pmap_dma >> 32ULL);
#line 1335
  mc.mb[8] = (uint16_t )dma_size;
#line 1336
  mc.out_mb = 463U;
#line 1337
  mc.in_mb = 3U;
#line 1338
  mc.tov = 30U;
#line 1339
  mc.flags = 1U;
#line 1341
  rval = qla2x00_mailbox_command(vha, & mc);
#line 1342
  if (rval != 0) {
#line 1343
    if ((unsigned int )mc.mb[0] == 16389U && (unsigned int )mc.mb[1] == 10U) {
#line 1345
      left = (int )((unsigned int )mc.mb[2] / 12U + (unsigned int )left);
#line 1347
      goto restart;
    } else {

    }
#line 1349
    goto out_free;
  } else {

  }
#line 1352
  left = 0;
#line 1354
  tmp = kmemdup((void const   *)pmap, dma_size, 208U);
#line 1354
  list = (struct qla_port_24xx_data *)tmp;
#line 1355
  if ((unsigned long )list == (unsigned long )((struct qla_port_24xx_data *)0)) {
#line 1356
    ql_log(1U, vha, 4416, "%s(%ld): failed to allocate node names list structure.\n",
           "qla2x00_get_node_name_list", vha->host_no);
#line 1359
    rval = 259;
#line 1360
    goto out_free;
  } else {

  }
  restart: 
#line 1364
  dma_free_attrs(& (ha->pdev)->dev, dma_size, pmap, pmap_dma, (struct dma_attrs *)0);
  ldv_65976: ;
#line 1317
  if (left > 0) {
#line 1319
    goto ldv_65975;
  } else {

  }
#line 1367
  *out_data = (void *)list;
#line 1368
  *out_len = (int )dma_size;
  out: ;
#line 1371
  return (rval);
  out_free: 
#line 1374
  dma_free_attrs(& (ha->pdev)->dev, dma_size, pmap, pmap_dma, (struct dma_attrs *)0);
#line 1375
  return (rval);
}
}
#line 1395 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_get_port_database(scsi_qla_host_t *vha , fc_port_t *fcport , uint8_t opt ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  port_database_t *pd ;
  struct port_database_24xx *pd24 ;
  dma_addr_t pd_dma ;
  struct qla_hw_data *ha ;
  void *tmp ;
  int _max1 ;
  int _max2 ;
  uint64_t zero ;
  int tmp___0 ;
  int tmp___1 ;
  uint64_t zero___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1399
  mcp = & mc;
#line 1403
  ha = vha->hw;
#line 1405
  ql_dbg(536903680U, vha, 4175, "Entered %s.\n", "qla2x00_get_port_database");
#line 1408
  pd24 = (struct port_database_24xx *)0;
#line 1409
  tmp = dma_pool_alloc(ha->s_dma_pool, 208U, & pd_dma);
#line 1409
  pd = (port_database_t *)tmp;
#line 1410
  if ((unsigned long )pd == (unsigned long )((port_database_t *)0)) {
#line 1411
    ql_log(1U, vha, 4176, "Failed to allocate port database structure.\n");
#line 1413
    return (259);
  } else {

  }
#line 1415
  _max1 = 128;
#line 1415
  _max2 = 64;
#line 1415
  memset((void *)pd, 0, (size_t )(_max1 > _max2 ? _max1 : _max2));
#line 1417
  mcp->mb[0] = 100U;
#line 1418
  if ((unsigned int )opt != 0U && (ha->device_type & 134217728U) == 0U) {
#line 1419
    mcp->mb[0] = 71U;
  } else {

  }
#line 1420
  mcp->mb[2] = (unsigned short )((unsigned int )pd_dma >> 16);
#line 1421
  mcp->mb[3] = (unsigned short )pd_dma;
#line 1422
  mcp->mb[6] = (unsigned short )((unsigned int )(pd_dma >> 32ULL) >> 16);
#line 1423
  mcp->mb[7] = (unsigned short )(pd_dma >> 32ULL);
#line 1424
  mcp->mb[9] = vha->vp_idx;
#line 1425
  mcp->out_mb = 717U;
#line 1426
  mcp->in_mb = 1U;
#line 1427
  if ((ha->device_type & 134217728U) != 0U) {
#line 1428
    mcp->mb[1] = fcport->loop_id;
#line 1429
    mcp->mb[10] = (uint16_t )opt;
#line 1430
    mcp->out_mb = mcp->out_mb | 1026U;
#line 1431
    mcp->in_mb = mcp->in_mb | 2U;
  } else
#line 1432
  if ((int )ha->device_type < 0) {
#line 1433
    mcp->mb[1] = fcport->loop_id;
#line 1434
    mcp->mb[10] = (uint16_t )opt;
#line 1435
    mcp->out_mb = mcp->out_mb | 1026U;
  } else {
#line 1437
    mcp->mb[1] = (uint16_t )((int )((short )((int )fcport->loop_id << 8)) | (int )((short )opt));
#line 1438
    mcp->out_mb = mcp->out_mb | 2U;
  }
#line 1440
  mcp->buf_size = (ha->device_type & 134217728U) != 0U ? 64L : 128L;
#line 1442
  mcp->flags = 1U;
#line 1443
  mcp->tov = (uint32_t )((int )ha->login_timeout * 2 + (int )((unsigned int )ha->login_timeout / 2U));
#line 1444
  rval = qla2x00_mailbox_command(vha, mcp);
#line 1445
  if (rval != 0) {
#line 1446
    goto gpd_error_out;
  } else {

  }
#line 1448
  if ((ha->device_type & 134217728U) != 0U) {
#line 1449
    zero = 0ULL;
#line 1450
    pd24 = (struct port_database_24xx *)pd;
#line 1453
    if ((unsigned int )pd24->current_login_state != 6U && (unsigned int )pd24->last_login_state != 6U) {
#line 1455
      ql_dbg(536870912U, vha, 4177, "Unable to verify login-state (%x/%x) for loop_id %x.\n",
             (int )pd24->current_login_state, (int )pd24->last_login_state, (int )fcport->loop_id);
#line 1459
      rval = 258;
#line 1460
      goto gpd_error_out;
    } else {

    }
#line 1463
    if ((unsigned int )fcport->loop_id == 4096U) {
#line 1467
      rval = 10;
#line 1468
      goto gpd_error_out;
    } else {
#line 1463
      tmp___0 = memcmp((void const   *)(& fcport->port_name), (void const   *)(& zero),
                       8UL);
#line 1463
      if (tmp___0 != 0) {
#line 1463
        tmp___1 = memcmp((void const   *)(& fcport->port_name), (void const   *)(& pd24->port_name),
                         8UL);
#line 1463
        if (tmp___1 != 0) {
#line 1467
          rval = 10;
#line 1468
          goto gpd_error_out;
        } else {

        }
      } else {

      }
    }
#line 1472
    memcpy((void *)(& fcport->node_name), (void const   *)(& pd24->node_name), 8UL);
#line 1473
    memcpy((void *)(& fcport->port_name), (void const   *)(& pd24->port_name), 8UL);
#line 1476
    fcport->d_id.b.domain = pd24->port_id[0];
#line 1477
    fcport->d_id.b.area = pd24->port_id[1];
#line 1478
    fcport->d_id.b.al_pa = pd24->port_id[2];
#line 1479
    fcport->d_id.b.rsvd_1 = 0U;
#line 1482
    if (((int )pd24->prli_svc_param_word_3[0] & 16) == 0) {
#line 1483
      fcport->port_type = 4;
    } else {
#line 1485
      fcport->port_type = 5;
    }
#line 1488
    fcport->supported_classes = ((int )pd24->flags & 16) != 0 ? 4U : 8U;
#line 1491
    if ((int )((signed char )pd24->prli_svc_param_word_3[0]) < 0) {
#line 1492
      fcport->flags = fcport->flags | 16U;
    } else {

    }
  } else {
#line 1494
    zero___0 = 0ULL;
#line 1497
    if ((unsigned int )pd->master_state != 6U && (unsigned int )pd->slave_state != 6U) {
#line 1499
      ql_dbg(536870912U, vha, 4106, "Unable to verify login-state (%x/%x) - portid=%02x%02x%02x.\n",
             (int )pd->master_state, (int )pd->slave_state, (int )fcport->d_id.b.domain,
             (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
#line 1504
      rval = 258;
#line 1505
      goto gpd_error_out;
    } else {

    }
#line 1508
    if ((unsigned int )fcport->loop_id == 4096U) {
#line 1512
      rval = 10;
#line 1513
      goto gpd_error_out;
    } else {
#line 1508
      tmp___2 = memcmp((void const   *)(& fcport->port_name), (void const   *)(& zero___0),
                       8UL);
#line 1508
      if (tmp___2 != 0) {
#line 1508
        tmp___3 = memcmp((void const   *)(& fcport->port_name), (void const   *)(& pd->port_name),
                         8UL);
#line 1508
        if (tmp___3 != 0) {
#line 1512
          rval = 10;
#line 1513
          goto gpd_error_out;
        } else {

        }
      } else {

      }
    }
#line 1517
    memcpy((void *)(& fcport->node_name), (void const   *)(& pd->node_name), 8UL);
#line 1518
    memcpy((void *)(& fcport->port_name), (void const   *)(& pd->port_name), 8UL);
#line 1521
    fcport->d_id.b.domain = pd->port_id[0];
#line 1522
    fcport->d_id.b.area = pd->port_id[3];
#line 1523
    fcport->d_id.b.al_pa = pd->port_id[2];
#line 1524
    fcport->d_id.b.rsvd_1 = 0U;
#line 1527
    if (((int )pd->prli_svc_param_word_3[0] & 16) == 0) {
#line 1528
      fcport->port_type = 4;
    } else {
#line 1530
      fcport->port_type = 5;
    }
#line 1533
    fcport->supported_classes = ((int )pd->options & 16) != 0 ? 4U : 8U;
  }
  gpd_error_out: 
#line 1538
  dma_pool_free(ha->s_dma_pool, (void *)pd, pd_dma);
#line 1540
  if (rval != 0) {
#line 1541
    ql_dbg(536870912U, vha, 4178, "Failed=%x mb[0]=%x mb[1]=%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 1545
    ql_dbg(536903680U, vha, 4179, "Done %s.\n", "qla2x00_get_port_database");
  }
#line 1549
  return (rval);
}
}
#line 1569 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_get_firmware_state(scsi_qla_host_t *vha , uint16_t *states ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 1573
  mcp = & mc;
#line 1575
  ql_dbg(536903680U, vha, 4180, "Entered %s.\n", "qla2x00_get_firmware_state");
#line 1578
  mcp->mb[0] = 105U;
#line 1579
  mcp->out_mb = 1U;
#line 1580
  if (((vha->hw)->device_type & 134217728U) != 0U) {
#line 1581
    mcp->in_mb = 127U;
  } else {
#line 1583
    mcp->in_mb = 3U;
  }
#line 1584
  mcp->tov = 30U;
#line 1585
  mcp->flags = 0U;
#line 1586
  rval = qla2x00_mailbox_command(vha, mcp);
#line 1589
  *states = mcp->mb[1];
#line 1590
  if (((vha->hw)->device_type & 134217728U) != 0U) {
#line 1591
    *(states + 1UL) = mcp->mb[2];
#line 1592
    *(states + 2UL) = mcp->mb[3];
#line 1593
    *(states + 3UL) = mcp->mb[4];
#line 1594
    *(states + 4UL) = mcp->mb[5];
#line 1595
    *(states + 5UL) = mcp->mb[6];
  } else {

  }
#line 1598
  if (rval != 0) {
#line 1600
    ql_dbg(536870912U, vha, 4181, "Failed=%x.\n", rval);
  } else {
#line 1603
    ql_dbg(536903680U, vha, 4182, "Done %s.\n", "qla2x00_get_firmware_state");
  }
#line 1607
  return (rval);
}
}
#line 1629 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_get_port_name(scsi_qla_host_t *vha , uint16_t loop_id , uint8_t *name ,
                          uint8_t opt ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 1634
  mcp = & mc;
#line 1636
  ql_dbg(536903680U, vha, 4183, "Entered %s.\n", "qla2x00_get_port_name");
#line 1639
  mcp->mb[0] = 106U;
#line 1640
  mcp->mb[9] = vha->vp_idx;
#line 1641
  mcp->out_mb = 515U;
#line 1642
  if ((int )(vha->hw)->device_type < 0) {
#line 1643
    mcp->mb[1] = loop_id;
#line 1644
    mcp->mb[10] = (uint16_t )opt;
#line 1645
    mcp->out_mb = mcp->out_mb | 1024U;
  } else {
#line 1647
    mcp->mb[1] = (uint16_t )((int )((short )((int )loop_id << 8)) | (int )((short )opt));
  }
#line 1650
  mcp->in_mb = 207U;
#line 1651
  mcp->tov = 30U;
#line 1652
  mcp->flags = 0U;
#line 1653
  rval = qla2x00_mailbox_command(vha, mcp);
#line 1655
  if (rval != 0) {
#line 1657
    ql_dbg(536870912U, vha, 4184, "Failed=%x.\n", rval);
  } else {
#line 1659
    if ((unsigned long )name != (unsigned long )((uint8_t *)0U)) {
#line 1661
      *name = (unsigned char )((int )mcp->mb[2] >> 8);
#line 1662
      *(name + 1UL) = (unsigned char )mcp->mb[2];
#line 1663
      *(name + 2UL) = (unsigned char )((int )mcp->mb[3] >> 8);
#line 1664
      *(name + 3UL) = (unsigned char )mcp->mb[3];
#line 1665
      *(name + 4UL) = (unsigned char )((int )mcp->mb[6] >> 8);
#line 1666
      *(name + 5UL) = (unsigned char )mcp->mb[6];
#line 1667
      *(name + 6UL) = (unsigned char )((int )mcp->mb[7] >> 8);
#line 1668
      *(name + 7UL) = (unsigned char )mcp->mb[7];
    } else {

    }
#line 1671
    ql_dbg(536903680U, vha, 4185, "Done %s.\n", "qla2x00_get_port_name");
  }
#line 1675
  return (rval);
}
}
#line 1694 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla24xx_link_initialize(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 1698
  mcp = & mc;
#line 1700
  ql_dbg(536903680U, vha, 4434, "Entered %s.\n", "qla24xx_link_initialize");
#line 1703
  if (((vha->hw)->device_type & 134217728U) == 0U || (((((vha->hw)->device_type & 8192U) != 0U || ((vha->hw)->device_type & 16384U) != 0U) || ((vha->hw)->device_type & 65536U) != 0U) || ((vha->hw)->device_type & 262144U) != 0U)) {
#line 1704
    return (258);
  } else {

  }
#line 1706
  mcp->mb[0] = 114U;
#line 1707
  mcp->mb[1] = 16U;
#line 1708
  if ((unsigned int )(vha->hw)->operating_mode == 0U) {
#line 1709
    mcp->mb[1] = (uint16_t )((unsigned int )mcp->mb[1] | 64U);
  } else {
#line 1711
    mcp->mb[1] = (uint16_t )((unsigned int )mcp->mb[1] | 32U);
  }
#line 1712
  mcp->mb[2] = 0U;
#line 1713
  mcp->mb[3] = 0U;
#line 1714
  mcp->out_mb = 15U;
#line 1715
  mcp->in_mb = 1U;
#line 1716
  mcp->tov = 30U;
#line 1717
  mcp->flags = 0U;
#line 1718
  rval = qla2x00_mailbox_command(vha, mcp);
#line 1720
  if (rval != 0) {
#line 1721
    ql_dbg(536870912U, vha, 4435, "Failed=%x.\n", rval);
  } else {
#line 1723
    ql_dbg(536903680U, vha, 4436, "Done %s.\n", "qla24xx_link_initialize");
  }
#line 1727
  return (rval);
}
}
#line 1746 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_lip_reset(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 1750
  mcp = & mc;
#line 1752
  ql_dbg(536903680U, vha, 4186, "Entered %s.\n", "qla2x00_lip_reset");
#line 1755
  if (((((vha->hw)->device_type & 8192U) != 0U || ((vha->hw)->device_type & 16384U) != 0U) || ((vha->hw)->device_type & 65536U) != 0U) || ((vha->hw)->device_type & 262144U) != 0U) {
#line 1757
    mcp->mb[0] = 114U;
#line 1758
    mcp->mb[1] = 2U;
#line 1759
    mcp->mb[2] = 0U;
#line 1760
    mcp->out_mb = 7U;
  } else
#line 1761
  if (((vha->hw)->device_type & 134217728U) != 0U) {
#line 1762
    mcp->mb[0] = 114U;
#line 1763
    mcp->mb[1] = 64U;
#line 1764
    mcp->mb[2] = 0U;
#line 1765
    mcp->mb[3] = (vha->hw)->loop_reset_delay;
#line 1766
    mcp->out_mb = 15U;
  } else {
#line 1768
    mcp->mb[0] = 108U;
#line 1769
    mcp->out_mb = 15U;
#line 1770
    if ((int )(vha->hw)->device_type < 0) {
#line 1771
      mcp->mb[1] = 255U;
#line 1772
      mcp->mb[10] = 0U;
#line 1773
      mcp->out_mb = mcp->out_mb | 1024U;
    } else {
#line 1775
      mcp->mb[1] = 65280U;
    }
#line 1777
    mcp->mb[2] = (vha->hw)->loop_reset_delay;
#line 1778
    mcp->mb[3] = 0U;
  }
#line 1780
  mcp->in_mb = 1U;
#line 1781
  mcp->tov = 30U;
#line 1782
  mcp->flags = 0U;
#line 1783
  rval = qla2x00_mailbox_command(vha, mcp);
#line 1785
  if (rval != 0) {
#line 1787
    ql_dbg(536870912U, vha, 4187, "Failed=%x.\n", rval);
  } else {
#line 1790
    ql_dbg(536903680U, vha, 4188, "Done %s.\n", "qla2x00_lip_reset");
  }
#line 1794
  return (rval);
}
}
#line 1816 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_send_sns(scsi_qla_host_t *vha , dma_addr_t sns_phys_address , uint16_t cmd_size ,
                     size_t buf_size ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 1821
  mcp = & mc;
#line 1823
  ql_dbg(536903680U, vha, 4189, "Entered %s.\n", "qla2x00_send_sns");
#line 1826
  ql_dbg(536903680U, vha, 4190, "Retry cnt=%d ratov=%d total tov=%d.\n", (int )(vha->hw)->retry_count,
         (int )(vha->hw)->login_timeout, mcp->tov);
#line 1830
  mcp->mb[0] = 110U;
#line 1831
  mcp->mb[1] = cmd_size;
#line 1832
  mcp->mb[2] = (unsigned short )((unsigned int )sns_phys_address >> 16);
#line 1833
  mcp->mb[3] = (unsigned short )sns_phys_address;
#line 1834
  mcp->mb[6] = (unsigned short )((unsigned int )(sns_phys_address >> 32ULL) >> 16);
#line 1835
  mcp->mb[7] = (unsigned short )(sns_phys_address >> 32ULL);
#line 1836
  mcp->out_mb = 207U;
#line 1837
  mcp->in_mb = 3U;
#line 1838
  mcp->buf_size = (long )buf_size;
#line 1839
  mcp->flags = 3U;
#line 1840
  mcp->tov = (uint32_t )((int )(vha->hw)->login_timeout * 2 + (int )((unsigned int )(vha->hw)->login_timeout / 2U));
#line 1841
  rval = qla2x00_mailbox_command(vha, mcp);
#line 1843
  if (rval != 0) {
#line 1845
    ql_dbg(536870912U, vha, 4191, "Failed=%x mb[0]=%x mb[1]=%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 1850
    ql_dbg(536903680U, vha, 4192, "Done %s.\n", "qla2x00_send_sns");
  }
#line 1854
  return (rval);
}
}
#line 1858 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla24xx_login_fabric(scsi_qla_host_t *vha , uint16_t loop_id , uint8_t domain ,
                         uint8_t area , uint8_t al_pa , uint16_t *mb , uint8_t opt ) 
{ 
  int rval ;
  struct logio_entry_24xx *lg ;
  dma_addr_t lg_dma ;
  uint32_t iop[2U] ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  void *tmp ;

  {
#line 1866
  ha = vha->hw;
#line 1870
  ql_dbg(536903680U, vha, 4193, "Entered %s.\n", "qla24xx_login_fabric");
#line 1873
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1874
    req = *(ha->req_q_map);
  } else {
#line 1876
    req = vha->req;
  }
#line 1877
  rsp = req->rsp;
#line 1879
  tmp = dma_pool_alloc(ha->s_dma_pool, 208U, & lg_dma);
#line 1879
  lg = (struct logio_entry_24xx *)tmp;
#line 1880
  if ((unsigned long )lg == (unsigned long )((struct logio_entry_24xx *)0)) {
#line 1881
    ql_log(1U, vha, 4194, "Failed to allocate login IOCB.\n");
#line 1883
    return (259);
  } else {

  }
#line 1885
  memset((void *)lg, 0, 64UL);
#line 1887
  lg->entry_type = 82U;
#line 1888
  lg->entry_count = 1U;
#line 1889
  lg->handle = ((unsigned int )req->id << 16) | lg->handle;
#line 1890
  lg->nport_handle = loop_id;
#line 1891
  lg->control_flags = 0U;
#line 1892
  if ((int )opt & 1) {
#line 1893
    lg->control_flags = (uint16_t )((unsigned int )lg->control_flags | 16U);
  } else {

  }
#line 1894
  if (((int )opt & 2) != 0) {
#line 1895
    lg->control_flags = (uint16_t )((unsigned int )lg->control_flags | 32U);
  } else {

  }
#line 1896
  lg->port_id[0] = al_pa;
#line 1897
  lg->port_id[1] = area;
#line 1898
  lg->port_id[2] = domain;
#line 1899
  lg->vp_index = (uint8_t )vha->vp_idx;
#line 1900
  rval = qla2x00_issue_iocb_timeout(vha, (void *)lg, lg_dma, 0UL, (uint32_t )(((int )((unsigned int )ha->r_a_tov / 10U) + 1) * 2));
#line 1902
  if (rval != 0) {
#line 1903
    ql_dbg(536870912U, vha, 4195, "Failed to issue login IOCB (%x).\n", rval);
  } else
#line 1905
  if ((unsigned int )lg->entry_status != 0U) {
#line 1906
    ql_dbg(536870912U, vha, 4196, "Failed to complete IOCB -- error status (%x).\n",
           (int )lg->entry_status);
#line 1909
    rval = 258;
  } else
#line 1910
  if ((unsigned int )lg->comp_status != 0U) {
#line 1911
    iop[0] = lg->io_parameter[0];
#line 1912
    iop[1] = lg->io_parameter[1];
#line 1914
    ql_dbg(536870912U, vha, 4197, "Failed to complete IOCB -- completion  status (%x) ioparam=%x/%x.\n",
           (int )lg->comp_status, iop[0], iop[1]);
#line 1919
    switch (iop[0]) {
    case 26U: 
#line 1921
    *mb = 16391U;
#line 1922
    *(mb + 1UL) = (unsigned short )iop[1];
#line 1923
    goto ldv_66057;
    case 27U: 
#line 1925
    *mb = 16392U;
#line 1926
    goto ldv_66057;
    case 1U: ;
    case 2U: ;
    case 3U: ;
    case 4U: ;
    case 5U: ;
    case 7U: ;
    case 9U: ;
    case 10U: ;
    case 24U: ;
    case 25U: ;
    case 28U: ;
    case 29U: ;
    case 31U: ;
    default: 
#line 1941
    *mb = 16389U;
#line 1942
    goto ldv_66057;
    }
    ldv_66057: ;
  } else {
#line 1945
    ql_dbg(536903680U, vha, 4198, "Done %s.\n", "qla24xx_login_fabric");
#line 1948
    iop[0] = lg->io_parameter[0];
#line 1950
    *mb = 16384U;
#line 1951
    *(mb + 1UL) = 0U;
#line 1952
    if ((iop[0] & 16U) != 0U) {
#line 1953
      if ((iop[0] & 256U) != 0U) {
#line 1954
        *(mb + 1UL) = (uint16_t )((unsigned int )*(mb + 1UL) | 2U);
      } else {

      }
    } else {
#line 1956
      *(mb + 1UL) = 1U;
    }
#line 1959
    *(mb + 10UL) = 0U;
#line 1960
    if (lg->io_parameter[7] != 0U || lg->io_parameter[8] != 0U) {
#line 1961
      *(mb + 10UL) = (uint16_t )((unsigned int )*(mb + 10UL) | 1U);
    } else {

    }
#line 1962
    if (lg->io_parameter[9] != 0U || lg->io_parameter[10] != 0U) {
#line 1963
      *(mb + 10UL) = (uint16_t )((unsigned int )*(mb + 10UL) | 2U);
    } else {

    }
#line 1964
    if ((lg->io_parameter[0] & 128U) != 0U) {
#line 1965
      *(mb + 10UL) = (uint16_t )((unsigned int )*(mb + 10UL) | 128U);
    } else {

    }
  }
#line 1970
  dma_pool_free(ha->s_dma_pool, (void *)lg, lg_dma);
#line 1972
  return (rval);
}
}
#line 1997 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_login_fabric(scsi_qla_host_t *vha , uint16_t loop_id , uint8_t domain ,
                         uint8_t area , uint8_t al_pa , uint16_t *mb , uint8_t opt ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;

  {
#line 2002
  mcp = & mc;
#line 2003
  ha = vha->hw;
#line 2005
  ql_dbg(536903680U, vha, 4199, "Entered %s.\n", "qla2x00_login_fabric");
#line 2008
  mcp->mb[0] = 111U;
#line 2009
  mcp->out_mb = 15U;
#line 2010
  if ((int )ha->device_type < 0) {
#line 2011
    mcp->mb[1] = loop_id;
#line 2012
    mcp->mb[10] = (uint16_t )opt;
#line 2013
    mcp->out_mb = mcp->out_mb | 1024U;
  } else {
#line 2015
    mcp->mb[1] = (uint16_t )((int )((short )((int )loop_id << 8)) | (int )((short )opt));
  }
#line 2017
  mcp->mb[2] = (uint16_t )domain;
#line 2018
  mcp->mb[3] = (uint16_t )((int )((short )((int )area << 8)) | (int )((short )al_pa));
#line 2020
  mcp->in_mb = 199U;
#line 2021
  mcp->tov = (uint32_t )((int )ha->login_timeout * 2 + (int )((unsigned int )ha->login_timeout / 2U));
#line 2022
  mcp->flags = 0U;
#line 2023
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2026
  if ((unsigned long )mb != (unsigned long )((uint16_t *)0U)) {
#line 2027
    *mb = mcp->mb[0];
#line 2028
    *(mb + 1UL) = mcp->mb[1];
#line 2029
    *(mb + 2UL) = mcp->mb[2];
#line 2030
    *(mb + 6UL) = mcp->mb[6];
#line 2031
    *(mb + 7UL) = mcp->mb[7];
#line 2033
    *(mb + 10UL) = 0U;
  } else {

  }
#line 2036
  if (rval != 0) {
#line 2043
    if (((((unsigned int )mcp->mb[0] == 16385U || (unsigned int )mcp->mb[0] == 16386U) || (unsigned int )mcp->mb[0] == 16387U) || (unsigned int )mcp->mb[0] == 16389U) || (unsigned int )mcp->mb[0] == 16390U) {
#line 2046
      rval = 0;
    } else {

    }
#line 2049
    ql_dbg(536870912U, vha, 4200, "Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x.\n", rval,
           (int )mcp->mb[0], (int )mcp->mb[1], (int )mcp->mb[2]);
  } else {
#line 2054
    ql_dbg(536903680U, vha, 4201, "Done %s.\n", "qla2x00_login_fabric");
  }
#line 2058
  return (rval);
}
}
#line 2078 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_login_local_device(scsi_qla_host_t *vha , fc_port_t *fcport , uint16_t *mb_ret ,
                               uint8_t opt ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 2083
  mcp = & mc;
#line 2084
  ha = vha->hw;
#line 2086
  ql_dbg(536903680U, vha, 4202, "Entered %s.\n", "qla2x00_login_local_device");
#line 2089
  if ((ha->device_type & 134217728U) != 0U) {
#line 2090
    tmp = qla24xx_login_fabric(vha, (int )fcport->loop_id, (int )fcport->d_id.b.domain,
                               (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa,
                               mb_ret, (int )opt);
#line 2090
    return (tmp);
  } else {

  }
#line 2094
  mcp->mb[0] = 116U;
#line 2095
  if ((int )ha->device_type < 0) {
#line 2096
    mcp->mb[1] = fcport->loop_id;
  } else {
#line 2098
    mcp->mb[1] = (int )fcport->loop_id << 8U;
  }
#line 2099
  mcp->mb[2] = (uint16_t )opt;
#line 2100
  mcp->out_mb = 7U;
#line 2101
  mcp->in_mb = 195U;
#line 2102
  mcp->tov = (uint32_t )((int )ha->login_timeout * 2 + (int )((unsigned int )ha->login_timeout / 2U));
#line 2103
  mcp->flags = 0U;
#line 2104
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2107
  if ((unsigned long )mb_ret != (unsigned long )((uint16_t *)0U)) {
#line 2108
    *mb_ret = mcp->mb[0];
#line 2109
    *(mb_ret + 1UL) = mcp->mb[1];
#line 2110
    *(mb_ret + 6UL) = mcp->mb[6];
#line 2111
    *(mb_ret + 7UL) = mcp->mb[7];
  } else {

  }
#line 2114
  if (rval != 0) {
#line 2121
    if ((unsigned int )mcp->mb[0] == 16389U || (unsigned int )mcp->mb[0] == 16390U) {
#line 2122
      rval = 0;
    } else {

    }
#line 2124
    ql_dbg(536870912U, vha, 4203, "Failed=%x mb[0]=%x mb[1]=%x mb[6]=%x mb[7]=%x.\n",
           rval, (int )mcp->mb[0], (int )mcp->mb[1], (int )mcp->mb[6], (int )mcp->mb[7]);
  } else {
#line 2129
    ql_dbg(536903680U, vha, 4204, "Done %s.\n", "qla2x00_login_local_device");
  }
#line 2133
  return (rval);
}
}
#line 2137 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla24xx_fabric_logout(scsi_qla_host_t *vha , uint16_t loop_id , uint8_t domain ,
                          uint8_t area , uint8_t al_pa ) 
{ 
  int rval ;
  struct logio_entry_24xx *lg ;
  dma_addr_t lg_dma ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  void *tmp ;

  {
#line 2143
  ha = vha->hw;
#line 2147
  ql_dbg(536903680U, vha, 4205, "Entered %s.\n", "qla24xx_fabric_logout");
#line 2150
  tmp = dma_pool_alloc(ha->s_dma_pool, 208U, & lg_dma);
#line 2150
  lg = (struct logio_entry_24xx *)tmp;
#line 2151
  if ((unsigned long )lg == (unsigned long )((struct logio_entry_24xx *)0)) {
#line 2152
    ql_log(1U, vha, 4206, "Failed to allocate logout IOCB.\n");
#line 2154
    return (259);
  } else {

  }
#line 2156
  memset((void *)lg, 0, 64UL);
#line 2158
  if (ql2xmaxqueues > 1) {
#line 2159
    req = *(ha->req_q_map);
  } else {
#line 2161
    req = vha->req;
  }
#line 2162
  rsp = req->rsp;
#line 2163
  lg->entry_type = 82U;
#line 2164
  lg->entry_count = 1U;
#line 2165
  lg->handle = ((unsigned int )req->id << 16) | lg->handle;
#line 2166
  lg->nport_handle = loop_id;
#line 2167
  lg->control_flags = 152U;
#line 2170
  lg->port_id[0] = al_pa;
#line 2171
  lg->port_id[1] = area;
#line 2172
  lg->port_id[2] = domain;
#line 2173
  lg->vp_index = (uint8_t )vha->vp_idx;
#line 2174
  rval = qla2x00_issue_iocb_timeout(vha, (void *)lg, lg_dma, 0UL, (uint32_t )(((int )((unsigned int )ha->r_a_tov / 10U) + 1) * 2));
#line 2176
  if (rval != 0) {
#line 2177
    ql_dbg(536870912U, vha, 4207, "Failed to issue logout IOCB (%x).\n", rval);
  } else
#line 2179
  if ((unsigned int )lg->entry_status != 0U) {
#line 2180
    ql_dbg(536870912U, vha, 4208, "Failed to complete IOCB -- error status (%x).\n",
           (int )lg->entry_status);
#line 2183
    rval = 258;
  } else
#line 2184
  if ((unsigned int )lg->comp_status != 0U) {
#line 2185
    ql_dbg(536870912U, vha, 4209, "Failed to complete IOCB -- completion status (%x) ioparam=%x/%x.\n",
           (int )lg->comp_status, lg->io_parameter[0], lg->io_parameter[1]);
  } else {
#line 2192
    ql_dbg(536903680U, vha, 4210, "Done %s.\n", "qla24xx_fabric_logout");
  }
#line 2196
  dma_pool_free(ha->s_dma_pool, (void *)lg, lg_dma);
#line 2198
  return (rval);
}
}
#line 2218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_fabric_logout(scsi_qla_host_t *vha , uint16_t loop_id , uint8_t domain ,
                          uint8_t area , uint8_t al_pa ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 2223
  mcp = & mc;
#line 2225
  ql_dbg(536903680U, vha, 4211, "Entered %s.\n", "qla2x00_fabric_logout");
#line 2228
  mcp->mb[0] = 113U;
#line 2229
  mcp->out_mb = 3U;
#line 2230
  if ((int )(vha->hw)->device_type < 0) {
#line 2231
    mcp->mb[1] = loop_id;
#line 2232
    mcp->mb[10] = 0U;
#line 2233
    mcp->out_mb = mcp->out_mb | 1024U;
  } else {
#line 2235
    mcp->mb[1] = (int )loop_id << 8U;
  }
#line 2238
  mcp->in_mb = 3U;
#line 2239
  mcp->tov = 30U;
#line 2240
  mcp->flags = 0U;
#line 2241
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2243
  if (rval != 0) {
#line 2245
    ql_dbg(536870912U, vha, 4212, "Failed=%x mb[1]=%x.\n", rval, (int )mcp->mb[1]);
  } else {
#line 2249
    ql_dbg(536903680U, vha, 4213, "Done %s.\n", "qla2x00_fabric_logout");
  }
#line 2253
  return (rval);
}
}
#line 2272 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_full_login_lip(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 2276
  mcp = & mc;
#line 2278
  ql_dbg(536903680U, vha, 4214, "Entered %s.\n", "qla2x00_full_login_lip");
#line 2281
  mcp->mb[0] = 114U;
#line 2282
  mcp->mb[1] = ((vha->hw)->device_type & 134217728U) != 0U ? 8U : 0U;
#line 2283
  mcp->mb[2] = 0U;
#line 2284
  mcp->mb[3] = 0U;
#line 2285
  mcp->out_mb = 15U;
#line 2286
  mcp->in_mb = 1U;
#line 2287
  mcp->tov = 30U;
#line 2288
  mcp->flags = 0U;
#line 2289
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2291
  if (rval != 0) {
#line 2293
    ql_dbg(536870912U, vha, 4215, "Failed=%x.\n", rval);
  } else {
#line 2296
    ql_dbg(536903680U, vha, 4216, "Done %s.\n", "qla2x00_full_login_lip");
  }
#line 2300
  return (rval);
}
}
#line 2316 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_get_id_list(scsi_qla_host_t *vha , void *id_list , dma_addr_t id_list_dma ,
                        uint16_t *entries ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 2321
  mcp = & mc;
#line 2323
  ql_dbg(536903680U, vha, 4217, "Entered %s.\n", "qla2x00_get_id_list");
#line 2326
  if ((unsigned long )id_list == (unsigned long )((void *)0)) {
#line 2327
    return (258);
  } else {

  }
#line 2329
  mcp->mb[0] = 124U;
#line 2330
  mcp->out_mb = 1U;
#line 2331
  if (((vha->hw)->device_type & 134217728U) != 0U) {
#line 2332
    mcp->mb[2] = (unsigned short )((unsigned int )id_list_dma >> 16);
#line 2333
    mcp->mb[3] = (unsigned short )id_list_dma;
#line 2334
    mcp->mb[6] = (unsigned short )((unsigned int )(id_list_dma >> 32ULL) >> 16);
#line 2335
    mcp->mb[7] = (unsigned short )(id_list_dma >> 32ULL);
#line 2336
    mcp->mb[8] = 0U;
#line 2337
    mcp->mb[9] = vha->vp_idx;
#line 2338
    mcp->out_mb = mcp->out_mb | 972U;
  } else {
#line 2340
    mcp->mb[1] = (unsigned short )((unsigned int )id_list_dma >> 16);
#line 2341
    mcp->mb[2] = (unsigned short )id_list_dma;
#line 2342
    mcp->mb[3] = (unsigned short )((unsigned int )(id_list_dma >> 32ULL) >> 16);
#line 2343
    mcp->mb[6] = (unsigned short )(id_list_dma >> 32ULL);
#line 2344
    mcp->out_mb = mcp->out_mb | 78U;
  }
#line 2346
  mcp->in_mb = 3U;
#line 2347
  mcp->tov = 30U;
#line 2348
  mcp->flags = 0U;
#line 2349
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2351
  if (rval != 0) {
#line 2353
    ql_dbg(536870912U, vha, 4218, "Failed=%x.\n", rval);
  } else {
#line 2355
    *entries = mcp->mb[1];
#line 2356
    ql_dbg(536903680U, vha, 4219, "Done %s.\n", "qla2x00_get_id_list");
  }
#line 2360
  return (rval);
}
}
#line 2377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_get_resource_cnts(scsi_qla_host_t *vha , uint16_t *cur_xchg_cnt , uint16_t *orig_xchg_cnt ,
                              uint16_t *cur_iocb_cnt , uint16_t *orig_iocb_cnt , uint16_t *max_npiv_vports ,
                              uint16_t *max_fcfs ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 2383
  mcp = & mc;
#line 2385
  ql_dbg(536903680U, vha, 4220, "Entered %s.\n", "qla2x00_get_resource_cnts");
#line 2388
  mcp->mb[0] = 66U;
#line 2389
  mcp->out_mb = 1U;
#line 2390
  mcp->in_mb = 3279U;
#line 2391
  if ((((vha->hw)->device_type & 8192U) != 0U || (((vha->hw)->device_type & 32768U) != 0U || ((vha->hw)->device_type & 65536U) != 0U)) || (((vha->hw)->device_type & 524288U) != 0U || ((vha->hw)->device_type & 1048576U) != 0U)) {
#line 2392
    mcp->in_mb = mcp->in_mb | 4096U;
  } else {

  }
#line 2393
  mcp->tov = 30U;
#line 2394
  mcp->flags = 0U;
#line 2395
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2397
  if (rval != 0) {
#line 2399
    ql_dbg(536870912U, vha, 4221, "Failed mb[0]=%x.\n", (int )mcp->mb[0]);
  } else {
#line 2402
    ql_dbg(536903680U, vha, 4222, "Done %s mb1=%x mb2=%x mb3=%x mb6=%x mb7=%x mb10=%x mb11=%x mb12=%x.\n",
           "qla2x00_get_resource_cnts", (int )mcp->mb[1], (int )mcp->mb[2], (int )mcp->mb[3],
           (int )mcp->mb[6], (int )mcp->mb[7], (int )mcp->mb[10], (int )mcp->mb[11],
           (int )mcp->mb[12]);
#line 2408
    if ((unsigned long )cur_xchg_cnt != (unsigned long )((uint16_t *)0U)) {
#line 2409
      *cur_xchg_cnt = mcp->mb[3];
    } else {

    }
#line 2410
    if ((unsigned long )orig_xchg_cnt != (unsigned long )((uint16_t *)0U)) {
#line 2411
      *orig_xchg_cnt = mcp->mb[6];
    } else {

    }
#line 2412
    if ((unsigned long )cur_iocb_cnt != (unsigned long )((uint16_t *)0U)) {
#line 2413
      *cur_iocb_cnt = mcp->mb[7];
    } else {

    }
#line 2414
    if ((unsigned long )orig_iocb_cnt != (unsigned long )((uint16_t *)0U)) {
#line 2415
      *orig_iocb_cnt = mcp->mb[10];
    } else {

    }
#line 2416
    if (*((unsigned long *)vha->hw + 2UL) != 0UL && (unsigned long )max_npiv_vports != (unsigned long )((uint16_t *)0U)) {
#line 2417
      *max_npiv_vports = mcp->mb[11];
    } else {

    }
#line 2418
    if ((((vha->hw)->device_type & 8192U) != 0U || (((vha->hw)->device_type & 32768U) != 0U || ((vha->hw)->device_type & 65536U) != 0U)) && (unsigned long )max_fcfs != (unsigned long )((uint16_t *)0U)) {
#line 2419
      *max_fcfs = mcp->mb[12];
    } else {

    }
  }
#line 2422
  return (rval);
}
}
#line 2440 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_get_fcal_position_map(scsi_qla_host_t *vha , char *pos_map ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  char *pmap ;
  dma_addr_t pmap_dma ;
  struct qla_hw_data *ha ;
  void *tmp ;

  {
#line 2444
  mcp = & mc;
#line 2447
  ha = vha->hw;
#line 2449
  ql_dbg(536903680U, vha, 4223, "Entered %s.\n", "qla2x00_get_fcal_position_map");
#line 2452
  tmp = dma_pool_alloc(ha->s_dma_pool, 208U, & pmap_dma);
#line 2452
  pmap = (char *)tmp;
#line 2453
  if ((unsigned long )pmap == (unsigned long )((char *)0)) {
#line 2454
    ql_log(1U, vha, 4224, "Memory alloc failed.\n");
#line 2456
    return (259);
  } else {

  }
#line 2458
  memset((void *)pmap, 0, 128UL);
#line 2460
  mcp->mb[0] = 99U;
#line 2461
  mcp->mb[2] = (unsigned short )((unsigned int )pmap_dma >> 16);
#line 2462
  mcp->mb[3] = (unsigned short )pmap_dma;
#line 2463
  mcp->mb[6] = (unsigned short )((unsigned int )(pmap_dma >> 32ULL) >> 16);
#line 2464
  mcp->mb[7] = (unsigned short )(pmap_dma >> 32ULL);
#line 2465
  mcp->out_mb = 205U;
#line 2466
  mcp->in_mb = 3U;
#line 2467
  mcp->buf_size = 128L;
#line 2468
  mcp->flags = 1U;
#line 2469
  mcp->tov = (uint32_t )((int )ha->login_timeout * 2 + (int )((unsigned int )ha->login_timeout / 2U));
#line 2470
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2472
  if (rval == 0) {
#line 2473
    ql_dbg(537001984U, vha, 4225, "mb0/mb1=%x/%X FC/AL position map size (%x).\n",
           (int )mcp->mb[0], (int )mcp->mb[1], (unsigned int )*pmap);
#line 2476
    ql_dump_buffer(537001984U, vha, 4381, (uint8_t *)pmap, (uint32_t )((int )*pmap + 1));
#line 2479
    if ((unsigned long )pos_map != (unsigned long )((char *)0)) {
#line 2480
      memcpy((void *)pos_map, (void const   *)pmap, 128UL);
    } else {

    }
  } else {

  }
#line 2482
  dma_pool_free(ha->s_dma_pool, (void *)pmap, pmap_dma);
#line 2484
  if (rval != 0) {
#line 2485
    ql_dbg(536870912U, vha, 4226, "Failed=%x.\n", rval);
  } else {
#line 2487
    ql_dbg(536903680U, vha, 4227, "Done %s.\n", "qla2x00_get_fcal_position_map");
  }
#line 2491
  return (rval);
}
}
#line 2508 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_get_link_status(scsi_qla_host_t *vha , uint16_t loop_id , struct link_statistics *stats ,
                            dma_addr_t stats_dma ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  uint32_t *siter ;
  uint32_t *diter ;
  uint32_t dwords ;
  struct qla_hw_data *ha ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 2513
  mcp = & mc;
#line 2515
  ha = vha->hw;
#line 2517
  ql_dbg(536903680U, vha, 4228, "Entered %s.\n", "qla2x00_get_link_status");
#line 2520
  mcp->mb[0] = 107U;
#line 2521
  mcp->mb[2] = (unsigned short )((unsigned int )stats_dma >> 16);
#line 2522
  mcp->mb[3] = (unsigned short )stats_dma;
#line 2523
  mcp->mb[6] = (unsigned short )((unsigned int )(stats_dma >> 32ULL) >> 16);
#line 2524
  mcp->mb[7] = (unsigned short )(stats_dma >> 32ULL);
#line 2525
  mcp->out_mb = 205U;
#line 2526
  mcp->in_mb = 1U;
#line 2527
  if ((ha->device_type & 134217728U) != 0U) {
#line 2528
    mcp->mb[1] = loop_id;
#line 2529
    mcp->mb[4] = 0U;
#line 2530
    mcp->mb[10] = 0U;
#line 2531
    mcp->out_mb = mcp->out_mb | 1042U;
#line 2532
    mcp->in_mb = mcp->in_mb | 2U;
  } else
#line 2533
  if ((int )ha->device_type < 0) {
#line 2534
    mcp->mb[1] = loop_id;
#line 2535
    mcp->mb[10] = 0U;
#line 2536
    mcp->out_mb = mcp->out_mb | 1026U;
  } else {
#line 2538
    mcp->mb[1] = (int )loop_id << 8U;
#line 2539
    mcp->out_mb = mcp->out_mb | 2U;
  }
#line 2541
  mcp->tov = 30U;
#line 2542
  mcp->flags = 4U;
#line 2543
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2545
  if (rval == 0) {
#line 2546
    if ((unsigned int )mcp->mb[0] != 16384U) {
#line 2547
      ql_dbg(536870912U, vha, 4229, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
#line 2549
      rval = 258;
    } else {
#line 2552
      ql_dbg(536903680U, vha, 4230, "Done %s.\n", "qla2x00_get_link_status");
#line 2554
      dwords = 7U;
#line 2555
      diter = & stats->link_fail_cnt;
#line 2555
      siter = diter;
#line 2556
      goto ldv_66179;
      ldv_66178: 
#line 2557
      tmp = diter;
#line 2557
      diter = diter + 1;
#line 2557
      tmp___0 = siter;
#line 2557
      siter = siter + 1;
#line 2557
      *tmp = *tmp___0;
      ldv_66179: 
#line 2556
      tmp___1 = dwords;
#line 2556
      dwords = dwords - 1U;
#line 2556
      if (tmp___1 != 0U) {
#line 2558
        goto ldv_66178;
      } else {

      }

    }
  } else {
#line 2561
    ql_dbg(536870912U, vha, 4231, "Failed=%x.\n", rval);
  }
#line 2564
  return (rval);
}
}
#line 2568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla24xx_get_isp_stats(scsi_qla_host_t *vha , struct link_statistics *stats , dma_addr_t stats_dma ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  uint32_t *siter ;
  uint32_t *diter ;
  uint32_t dwords ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 2573
  mcp = & mc;
#line 2576
  ql_dbg(536903680U, vha, 4232, "Entered %s.\n", "qla24xx_get_isp_stats");
#line 2579
  mcp->mb[0] = 109U;
#line 2580
  mcp->mb[2] = (unsigned short )((unsigned int )stats_dma >> 16);
#line 2581
  mcp->mb[3] = (unsigned short )stats_dma;
#line 2582
  mcp->mb[6] = (unsigned short )((unsigned int )(stats_dma >> 32ULL) >> 16);
#line 2583
  mcp->mb[7] = (unsigned short )(stats_dma >> 32ULL);
#line 2584
  mcp->mb[8] = 39U;
#line 2585
  mcp->mb[9] = vha->vp_idx;
#line 2586
  mcp->mb[10] = 0U;
#line 2587
  mcp->out_mb = 1997U;
#line 2588
  mcp->in_mb = 7U;
#line 2589
  mcp->tov = 30U;
#line 2590
  mcp->flags = 4U;
#line 2591
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2593
  if (rval == 0) {
#line 2594
    if ((unsigned int )mcp->mb[0] != 16384U) {
#line 2595
      ql_dbg(536870912U, vha, 4233, "Failed mb[0]=%x.\n", (int )mcp->mb[0]);
#line 2597
      rval = 258;
    } else {
#line 2599
      ql_dbg(536903680U, vha, 4234, "Done %s.\n", "qla24xx_get_isp_stats");
#line 2602
      dwords = 39U;
#line 2603
      diter = & stats->link_fail_cnt;
#line 2603
      siter = diter;
#line 2604
      goto ldv_66194;
      ldv_66193: 
#line 2605
      tmp = diter;
#line 2605
      diter = diter + 1;
#line 2605
      tmp___0 = siter;
#line 2605
      siter = siter + 1;
#line 2605
      *tmp = *tmp___0;
      ldv_66194: 
#line 2604
      tmp___1 = dwords;
#line 2604
      dwords = dwords - 1U;
#line 2604
      if (tmp___1 != 0U) {
#line 2606
        goto ldv_66193;
      } else {

      }

    }
  } else {
#line 2609
    ql_dbg(536870912U, vha, 4235, "Failed=%x.\n", rval);
  }
#line 2612
  return (rval);
}
}
#line 2616 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla24xx_abort_command(srb_t *sp ) 
{ 
  int rval ;
  unsigned long flags ;
  struct abort_entry_24xx *abt ;
  dma_addr_t abt_dma ;
  uint32_t handle ;
  fc_port_t *fcport ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  void *tmp___1 ;

  {
#line 2619
  flags = 0UL;
#line 2624
  fcport = sp->fcport;
#line 2625
  vha = fcport->vha;
#line 2626
  ha = vha->hw;
#line 2627
  req = vha->req;
#line 2629
  ql_dbg(536903680U, vha, 4236, "Entered %s.\n", "qla24xx_abort_command");
#line 2632
  if (ql2xasynctmfenable != 0) {
#line 2633
    tmp = qla24xx_async_abort_command(sp);
#line 2633
    return (tmp);
  } else {

  }
#line 2635
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 2635
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 2636
  handle = 1U;
#line 2636
  goto ldv_66214;
  ldv_66213: ;
#line 2637
  if ((unsigned long )*(req->outstanding_cmds + (unsigned long )handle) == (unsigned long )sp) {
#line 2638
    goto ldv_66212;
  } else {

  }
#line 2636
  handle = handle + 1U;
  ldv_66214: ;
#line 2636
  if ((uint32_t )req->num_outstanding_cmds > handle) {
#line 2638
    goto ldv_66213;
  } else {

  }
  ldv_66212: 
#line 2640
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2641
  if ((uint32_t )req->num_outstanding_cmds == handle) {
#line 2643
    return (258);
  } else {

  }
#line 2646
  tmp___1 = dma_pool_alloc(ha->s_dma_pool, 208U, & abt_dma);
#line 2646
  abt = (struct abort_entry_24xx *)tmp___1;
#line 2647
  if ((unsigned long )abt == (unsigned long )((struct abort_entry_24xx *)0)) {
#line 2648
    ql_log(1U, vha, 4237, "Failed to allocate abort IOCB.\n");
#line 2650
    return (259);
  } else {

  }
#line 2652
  memset((void *)abt, 0, 64UL);
#line 2654
  abt->entry_type = 51U;
#line 2655
  abt->entry_count = 1U;
#line 2656
  abt->handle = ((unsigned int )req->id << 16) | abt->handle;
#line 2657
  abt->nport_handle = fcport->loop_id;
#line 2658
  abt->handle_to_abort = ((unsigned int )req->id << 16) | handle;
#line 2659
  abt->port_id[0] = fcport->d_id.b.al_pa;
#line 2660
  abt->port_id[1] = fcport->d_id.b.area;
#line 2661
  abt->port_id[2] = fcport->d_id.b.domain;
#line 2662
  abt->vp_index = (uint8_t )(fcport->vha)->vp_idx;
#line 2664
  abt->req_que_no = req->id;
#line 2666
  rval = qla2x00_issue_iocb(vha, (void *)abt, abt_dma, 0UL);
#line 2667
  if (rval != 0) {
#line 2668
    ql_dbg(536870912U, vha, 4238, "Failed to issue IOCB (%x).\n", rval);
  } else
#line 2670
  if ((unsigned int )abt->entry_status != 0U) {
#line 2671
    ql_dbg(536870912U, vha, 4239, "Failed to complete IOCB -- error status (%x).\n",
           (int )abt->entry_status);
#line 2674
    rval = 258;
  } else
#line 2675
  if ((unsigned int )abt->nport_handle != 0U) {
#line 2676
    ql_dbg(536870912U, vha, 4240, "Failed to complete IOCB -- completion status (%x).\n",
           (int )abt->nport_handle);
#line 2679
    if ((unsigned int )abt->nport_handle == 49U) {
#line 2680
      rval = 257;
    } else {
#line 2682
      rval = 258;
    }
  } else {
#line 2684
    ql_dbg(536903680U, vha, 4241, "Done %s.\n", "qla24xx_abort_command");
  }
#line 2688
  dma_pool_free(ha->s_dma_pool, (void *)abt, abt_dma);
#line 2690
  return (rval);
}
}
#line 2701 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
static int __qla24xx_issue_tmf(char *name , uint32_t type , struct fc_port *fcport ,
                               uint64_t l , int tag ) 
{ 
  int rval ;
  int rval2 ;
  struct tsk_mgmt_cmd *tsk ;
  struct sts_entry_24xx *sts ;
  dma_addr_t tsk_dma ;
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  void *tmp ;

  {
#line 2713
  vha = fcport->vha;
#line 2714
  ha = vha->hw;
#line 2715
  req = vha->req;
#line 2717
  ql_dbg(536903680U, vha, 4242, "Entered %s.\n", "__qla24xx_issue_tmf");
#line 2720
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 2721
    rsp = *(ha->rsp_q_map + ((unsigned long )tag + 1UL));
  } else {
#line 2723
    rsp = req->rsp;
  }
#line 2724
  tmp = dma_pool_alloc(ha->s_dma_pool, 208U, & tsk_dma);
#line 2724
  tsk = (struct tsk_mgmt_cmd *)tmp;
#line 2725
  if ((unsigned long )tsk == (unsigned long )((struct tsk_mgmt_cmd *)0)) {
#line 2726
    ql_log(1U, vha, 4243, "Failed to allocate task management IOCB.\n");
#line 2728
    return (259);
  } else {

  }
#line 2730
  memset((void *)tsk, 0, 64UL);
#line 2732
  tsk->p.tsk.entry_type = 20U;
#line 2733
  tsk->p.tsk.entry_count = 1U;
#line 2734
  tsk->p.tsk.handle = ((unsigned int )req->id << 16) | tsk->p.tsk.handle;
#line 2735
  tsk->p.tsk.nport_handle = fcport->loop_id;
#line 2736
  tsk->p.tsk.timeout = ((unsigned int )ha->r_a_tov / 10U) * 2U;
#line 2737
  tsk->p.tsk.control_flags = type;
#line 2738
  tsk->p.tsk.port_id[0] = fcport->d_id.b.al_pa;
#line 2739
  tsk->p.tsk.port_id[1] = fcport->d_id.b.area;
#line 2740
  tsk->p.tsk.port_id[2] = fcport->d_id.b.domain;
#line 2741
  tsk->p.tsk.vp_index = (uint8_t )(fcport->vha)->vp_idx;
#line 2742
  if (type == 16U) {
#line 2743
    int_to_scsilun(l, & tsk->p.tsk.lun);
#line 2744
    host_to_fcp_swap((uint8_t *)(& tsk->p.tsk.lun), 8U);
  } else {

  }
#line 2748
  sts = & tsk->p.sts;
#line 2749
  rval = qla2x00_issue_iocb(vha, (void *)tsk, tsk_dma, 0UL);
#line 2750
  if (rval != 0) {
#line 2751
    ql_dbg(536870912U, vha, 4244, "Failed to issue %s reset IOCB (%x).\n", name, rval);
  } else
#line 2753
  if ((unsigned int )sts->entry_status != 0U) {
#line 2754
    ql_dbg(536870912U, vha, 4245, "Failed to complete IOCB -- error status (%x).\n",
           (int )sts->entry_status);
#line 2757
    rval = 258;
  } else
#line 2758
  if ((unsigned int )sts->comp_status != 0U) {
#line 2760
    ql_dbg(536870912U, vha, 4246, "Failed to complete IOCB -- completion status (%x).\n",
           (int )sts->comp_status);
#line 2763
    rval = 258;
  } else
#line 2764
  if (((int )sts->scsi_status & 256) != 0) {
#line 2766
    if (sts->rsp_data_len <= 3U) {
#line 2767
      ql_dbg(536903680U, vha, 4247, "Ignoring inconsistent data length -- not enough response info (%d).\n",
             sts->rsp_data_len);
    } else
#line 2771
    if ((unsigned int )sts->data[3] != 0U) {
#line 2772
      ql_dbg(536870912U, vha, 4248, "Failed to complete IOCB -- response (%x).\n",
             (int )sts->data[3]);
#line 2775
      rval = 258;
    } else {

    }
  } else {

  }
#line 2780
  rval2 = qla2x00_marker(vha, req, rsp, (int )fcport->loop_id, l, type != 16U);
#line 2782
  if (rval2 != 0) {
#line 2783
    ql_dbg(536870912U, vha, 4249, "Failed to issue marker IOCB (%x).\n", rval2);
  } else {
#line 2786
    ql_dbg(536903680U, vha, 4250, "Done %s.\n", "__qla24xx_issue_tmf");
  }
#line 2790
  dma_pool_free(ha->s_dma_pool, (void *)tsk, tsk_dma);
#line 2792
  return (rval);
}
}
#line 2796 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla24xx_abort_target(struct fc_port *fcport , uint64_t l , int tag ) 
{ 
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;

  {
#line 2798
  ha = (fcport->vha)->hw;
#line 2800
  if (ql2xasynctmfenable != 0 && (ha->device_type & 134217728U) != 0U) {
#line 2801
    tmp = qla2x00_async_tm_cmd(fcport, 2U, (uint32_t )l, (uint32_t )tag);
#line 2801
    return (tmp);
  } else {

  }
#line 2803
  tmp___0 = __qla24xx_issue_tmf((char *)"Target", 2U, fcport, l, tag);
#line 2803
  return (tmp___0);
}
}
#line 2807 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla24xx_lun_reset(struct fc_port *fcport , uint64_t l , int tag ) 
{ 
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;

  {
#line 2809
  ha = (fcport->vha)->hw;
#line 2811
  if (ql2xasynctmfenable != 0 && (ha->device_type & 134217728U) != 0U) {
#line 2812
    tmp = qla2x00_async_tm_cmd(fcport, 16U, (uint32_t )l, (uint32_t )tag);
#line 2812
    return (tmp);
  } else {

  }
#line 2814
  tmp___0 = __qla24xx_issue_tmf((char *)"Lun", 16U, fcport, l, tag);
#line 2814
  return (tmp___0);
}
}
#line 2818 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_system_error(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;

  {
#line 2822
  mcp = & mc;
#line 2823
  ha = vha->hw;
#line 2825
  if ((((((ha->device_type & 4U) == 0U && (ha->device_type & 8U) == 0U) && (ha->device_type & 16U) == 0U) && (ha->device_type & 32U) == 0U) && (ha->device_type & 64U) == 0U) && (ha->device_type & 134217728U) == 0U) {
#line 2826
    return (258);
  } else {

  }
#line 2828
  ql_dbg(536903680U, vha, 4251, "Entered %s.\n", "qla2x00_system_error");
#line 2831
  mcp->mb[0] = 42U;
#line 2832
  mcp->out_mb = 1U;
#line 2833
  mcp->in_mb = 1U;
#line 2834
  mcp->tov = 5U;
#line 2835
  mcp->flags = 0U;
#line 2836
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2838
  if (rval != 0) {
#line 2839
    ql_dbg(536870912U, vha, 4252, "Failed=%x.\n", rval);
  } else {
#line 2841
    ql_dbg(536903680U, vha, 4253, "Done %s.\n", "qla2x00_system_error");
  }
#line 2845
  return (rval);
}
}
#line 2849 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_write_serdes_word(scsi_qla_host_t *vha , uint16_t addr , uint16_t data ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 2853
  mcp = & mc;
#line 2855
  if (((vha->hw)->device_type & 32768U) == 0U && (((vha->hw)->device_type & 524288U) == 0U && ((vha->hw)->device_type & 1048576U) == 0U)) {
#line 2856
    return (258);
  } else {

  }
#line 2858
  ql_dbg(536903680U, vha, 4482, "Entered %s.\n", "qla2x00_write_serdes_word");
#line 2861
  mcp->mb[0] = 3U;
#line 2862
  mcp->mb[1] = addr;
#line 2863
  if (((vha->hw)->device_type & 32768U) != 0U) {
#line 2864
    mcp->mb[2] = (unsigned int )data & 255U;
  } else {
#line 2866
    mcp->mb[2] = data;
  }
#line 2868
  mcp->mb[3] = 0U;
#line 2869
  mcp->out_mb = 15U;
#line 2870
  mcp->in_mb = 1U;
#line 2871
  mcp->tov = 30U;
#line 2872
  mcp->flags = 0U;
#line 2873
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2875
  if (rval != 0) {
#line 2876
    ql_dbg(536870912U, vha, 4483, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 2879
    ql_dbg(536903680U, vha, 4484, "Done %s.\n", "qla2x00_write_serdes_word");
  }
#line 2883
  return (rval);
}
}
#line 2887 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_read_serdes_word(scsi_qla_host_t *vha , uint16_t addr , uint16_t *data ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 2891
  mcp = & mc;
#line 2893
  if (((vha->hw)->device_type & 32768U) == 0U && (((vha->hw)->device_type & 524288U) == 0U && ((vha->hw)->device_type & 1048576U) == 0U)) {
#line 2894
    return (258);
  } else {

  }
#line 2896
  ql_dbg(536903680U, vha, 4485, "Entered %s.\n", "qla2x00_read_serdes_word");
#line 2899
  mcp->mb[0] = 4U;
#line 2900
  mcp->mb[1] = addr;
#line 2901
  mcp->mb[3] = 0U;
#line 2902
  mcp->out_mb = 11U;
#line 2903
  mcp->in_mb = 3U;
#line 2904
  mcp->tov = 30U;
#line 2905
  mcp->flags = 0U;
#line 2906
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2908
  if (((vha->hw)->device_type & 32768U) != 0U) {
#line 2909
    *data = (unsigned int )mcp->mb[1] & 255U;
  } else {
#line 2911
    *data = mcp->mb[1];
  }
#line 2913
  if (rval != 0) {
#line 2914
    ql_dbg(536870912U, vha, 4486, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 2917
    ql_dbg(536903680U, vha, 4487, "Done %s.\n", "qla2x00_read_serdes_word");
  }
#line 2921
  return (rval);
}
}
#line 2925 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla8044_write_serdes_word(scsi_qla_host_t *vha , uint32_t addr , uint32_t data ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 2929
  mcp = & mc;
#line 2931
  if (((vha->hw)->device_type & 262144U) == 0U) {
#line 2932
    return (258);
  } else {

  }
#line 2934
  ql_dbg(536903680U, vha, 4486, "Entered %s.\n", "qla8044_write_serdes_word");
#line 2937
  mcp->mb[0] = 336U;
#line 2938
  mcp->mb[1] = 3U;
#line 2939
  mcp->mb[3] = (unsigned short )addr;
#line 2940
  mcp->mb[4] = (unsigned short )(addr >> 16);
#line 2941
  mcp->mb[5] = (unsigned short )data;
#line 2942
  mcp->mb[6] = (unsigned short )(data >> 16);
#line 2943
  mcp->out_mb = 123U;
#line 2944
  mcp->in_mb = 1U;
#line 2945
  mcp->tov = 30U;
#line 2946
  mcp->flags = 0U;
#line 2947
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2949
  if (rval != 0) {
#line 2950
    ql_dbg(536870912U, vha, 4487, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 2953
    ql_dbg(536903680U, vha, 4488, "Done %s.\n", "qla8044_write_serdes_word");
  }
#line 2957
  return (rval);
}
}
#line 2961 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla8044_read_serdes_word(scsi_qla_host_t *vha , uint32_t addr , uint32_t *data ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 2965
  mcp = & mc;
#line 2967
  if (((vha->hw)->device_type & 262144U) == 0U) {
#line 2968
    return (258);
  } else {

  }
#line 2970
  ql_dbg(536903680U, vha, 4489, "Entered %s.\n", "qla8044_read_serdes_word");
#line 2973
  mcp->mb[0] = 336U;
#line 2974
  mcp->mb[1] = 4U;
#line 2975
  mcp->mb[3] = (unsigned short )addr;
#line 2976
  mcp->mb[4] = (unsigned short )(addr >> 16);
#line 2977
  mcp->out_mb = 27U;
#line 2978
  mcp->in_mb = 7U;
#line 2979
  mcp->tov = 30U;
#line 2980
  mcp->flags = 0U;
#line 2981
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2983
  *data = (uint32_t )(((int )mcp->mb[2] << 16) | (int )mcp->mb[1]);
#line 2985
  if (rval != 0) {
#line 2986
    ql_dbg(536870912U, vha, 4490, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 2989
    ql_dbg(536903680U, vha, 4491, "Done %s.\n", "qla8044_read_serdes_word");
  }
#line 2993
  return (rval);
}
}
#line 3003 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_set_serdes_params(scsi_qla_host_t *vha , uint16_t sw_em_1g , uint16_t sw_em_2g ,
                              uint16_t sw_em_4g ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 3008
  mcp = & mc;
#line 3010
  ql_dbg(536903680U, vha, 4254, "Entered %s.\n", "qla2x00_set_serdes_params");
#line 3013
  mcp->mb[0] = 16U;
#line 3014
  mcp->mb[1] = 1U;
#line 3015
  mcp->mb[2] = (uint16_t )((unsigned int )sw_em_1g | 32768U);
#line 3016
  mcp->mb[3] = (uint16_t )((unsigned int )sw_em_2g | 32768U);
#line 3017
  mcp->mb[4] = (uint16_t )((unsigned int )sw_em_4g | 32768U);
#line 3018
  mcp->out_mb = 31U;
#line 3019
  mcp->in_mb = 1U;
#line 3020
  mcp->tov = 30U;
#line 3021
  mcp->flags = 0U;
#line 3022
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3024
  if (rval != 0) {
#line 3026
    ql_dbg(536870912U, vha, 4255, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 3030
    ql_dbg(536903680U, vha, 4256, "Done %s.\n", "qla2x00_set_serdes_params");
  }
#line 3034
  return (rval);
}
}
#line 3038 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_stop_firmware(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 3042
  mcp = & mc;
#line 3044
  if (((vha->hw)->device_type & 134217728U) == 0U) {
#line 3045
    return (258);
  } else {

  }
#line 3047
  ql_dbg(536903680U, vha, 4257, "Entered %s.\n", "qla2x00_stop_firmware");
#line 3050
  mcp->mb[0] = 20U;
#line 3051
  mcp->mb[1] = 0U;
#line 3052
  mcp->out_mb = 3U;
#line 3053
  mcp->in_mb = 1U;
#line 3054
  mcp->tov = 5U;
#line 3055
  mcp->flags = 0U;
#line 3056
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3058
  if (rval != 0) {
#line 3059
    ql_dbg(536870912U, vha, 4258, "Failed=%x.\n", rval);
#line 3060
    if ((unsigned int )mcp->mb[0] == 16385U) {
#line 3061
      rval = 1;
    } else {

    }
  } else {
#line 3063
    ql_dbg(536903680U, vha, 4259, "Done %s.\n", "qla2x00_stop_firmware");
  }
#line 3067
  return (rval);
}
}
#line 3071 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_enable_eft_trace(scsi_qla_host_t *vha , dma_addr_t eft_dma , uint16_t buffers ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  int tmp ;
  long tmp___0 ;

  {
#line 3076
  mcp = & mc;
#line 3078
  ql_dbg(536903680U, vha, 4260, "Entered %s.\n", "qla2x00_enable_eft_trace");
#line 3081
  if (((vha->hw)->device_type & 134217728U) == 0U) {
#line 3082
    return (258);
  } else {

  }
#line 3084
  tmp = pci_channel_offline((vha->hw)->pdev);
#line 3084
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 3084
  if (tmp___0 != 0L) {
#line 3085
    return (258);
  } else {

  }
#line 3087
  mcp->mb[0] = 39U;
#line 3088
  mcp->mb[1] = 4U;
#line 3089
  mcp->mb[2] = (unsigned short )eft_dma;
#line 3090
  mcp->mb[3] = (unsigned short )((unsigned int )eft_dma >> 16);
#line 3091
  mcp->mb[4] = (unsigned short )(eft_dma >> 32ULL);
#line 3092
  mcp->mb[5] = (unsigned short )((unsigned int )(eft_dma >> 32ULL) >> 16);
#line 3093
  mcp->mb[6] = buffers;
#line 3094
  mcp->mb[7] = 0U;
#line 3095
  mcp->out_mb = 255U;
#line 3096
  mcp->in_mb = 3U;
#line 3097
  mcp->tov = 30U;
#line 3098
  mcp->flags = 0U;
#line 3099
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3100
  if (rval != 0) {
#line 3101
    ql_dbg(536870912U, vha, 4261, "Failed=%x mb[0]=%x mb[1]=%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 3105
    ql_dbg(536903680U, vha, 4262, "Done %s.\n", "qla2x00_enable_eft_trace");
  }
#line 3109
  return (rval);
}
}
#line 3113 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_disable_eft_trace(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  int tmp ;
  long tmp___0 ;

  {
#line 3117
  mcp = & mc;
#line 3119
  ql_dbg(536903680U, vha, 4263, "Entered %s.\n", "qla2x00_disable_eft_trace");
#line 3122
  if (((vha->hw)->device_type & 134217728U) == 0U) {
#line 3123
    return (258);
  } else {

  }
#line 3125
  tmp = pci_channel_offline((vha->hw)->pdev);
#line 3125
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 3125
  if (tmp___0 != 0L) {
#line 3126
    return (258);
  } else {

  }
#line 3128
  mcp->mb[0] = 39U;
#line 3129
  mcp->mb[1] = 5U;
#line 3130
  mcp->out_mb = 3U;
#line 3131
  mcp->in_mb = 3U;
#line 3132
  mcp->tov = 30U;
#line 3133
  mcp->flags = 0U;
#line 3134
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3135
  if (rval != 0) {
#line 3136
    ql_dbg(536870912U, vha, 4264, "Failed=%x mb[0]=%x mb[1]=%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 3140
    ql_dbg(536903680U, vha, 4265, "Done %s.\n", "qla2x00_disable_eft_trace");
  }
#line 3144
  return (rval);
}
}
#line 3148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_enable_fce_trace(scsi_qla_host_t *vha , dma_addr_t fce_dma , uint16_t buffers ,
                             uint16_t *mb , uint32_t *dwords ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  int tmp ;
  long tmp___0 ;

  {
#line 3153
  mcp = & mc;
#line 3155
  ql_dbg(536903680U, vha, 4266, "Entered %s.\n", "qla2x00_enable_fce_trace");
#line 3158
  if (((((vha->hw)->device_type & 2048U) == 0U && ((vha->hw)->device_type & 8192U) == 0U) && (((vha->hw)->device_type & 32768U) == 0U && ((vha->hw)->device_type & 65536U) == 0U)) && (((vha->hw)->device_type & 524288U) == 0U && ((vha->hw)->device_type & 1048576U) == 0U)) {
#line 3160
    return (258);
  } else {

  }
#line 3162
  tmp = pci_channel_offline((vha->hw)->pdev);
#line 3162
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 3162
  if (tmp___0 != 0L) {
#line 3163
    return (258);
  } else {

  }
#line 3165
  mcp->mb[0] = 39U;
#line 3166
  mcp->mb[1] = 8U;
#line 3167
  mcp->mb[2] = (unsigned short )fce_dma;
#line 3168
  mcp->mb[3] = (unsigned short )((unsigned int )fce_dma >> 16);
#line 3169
  mcp->mb[4] = (unsigned short )(fce_dma >> 32ULL);
#line 3170
  mcp->mb[5] = (unsigned short )((unsigned int )(fce_dma >> 32ULL) >> 16);
#line 3171
  mcp->mb[6] = buffers;
#line 3172
  mcp->mb[7] = 0U;
#line 3173
  mcp->mb[8] = 0U;
#line 3174
  mcp->mb[9] = 2112U;
#line 3175
  mcp->mb[10] = 2112U;
#line 3176
  mcp->out_mb = 2047U;
#line 3178
  mcp->in_mb = 127U;
#line 3179
  mcp->tov = 30U;
#line 3180
  mcp->flags = 0U;
#line 3181
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3182
  if (rval != 0) {
#line 3183
    ql_dbg(536870912U, vha, 4267, "Failed=%x mb[0]=%x mb[1]=%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 3187
    ql_dbg(536903680U, vha, 4268, "Done %s.\n", "qla2x00_enable_fce_trace");
#line 3190
    if ((unsigned long )mb != (unsigned long )((uint16_t *)0U)) {
#line 3191
      memcpy((void *)mb, (void const   *)(& mcp->mb), 16UL);
    } else {

    }
#line 3192
    if ((unsigned long )dwords != (unsigned long )((uint32_t *)0U)) {
#line 3193
      *dwords = (uint32_t )buffers;
    } else {

    }
  }
#line 3196
  return (rval);
}
}
#line 3200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_disable_fce_trace(scsi_qla_host_t *vha , uint64_t *wr , uint64_t *rd ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  int tmp ;
  long tmp___0 ;

  {
#line 3204
  mcp = & mc;
#line 3206
  ql_dbg(536903680U, vha, 4269, "Entered %s.\n", "qla2x00_disable_fce_trace");
#line 3209
  if (((vha->hw)->device_type & 134217728U) == 0U) {
#line 3210
    return (258);
  } else {

  }
#line 3212
  tmp = pci_channel_offline((vha->hw)->pdev);
#line 3212
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 3212
  if (tmp___0 != 0L) {
#line 3213
    return (258);
  } else {

  }
#line 3215
  mcp->mb[0] = 39U;
#line 3216
  mcp->mb[1] = 9U;
#line 3217
  mcp->mb[2] = 1U;
#line 3218
  mcp->out_mb = 7U;
#line 3219
  mcp->in_mb = 1023U;
#line 3221
  mcp->tov = 30U;
#line 3222
  mcp->flags = 0U;
#line 3223
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3224
  if (rval != 0) {
#line 3225
    ql_dbg(536870912U, vha, 4270, "Failed=%x mb[0]=%x mb[1]=%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 3229
    ql_dbg(536903680U, vha, 4271, "Done %s.\n", "qla2x00_disable_fce_trace");
#line 3232
    if ((unsigned long )wr != (unsigned long )((uint64_t *)0ULL)) {
#line 3233
      *wr = ((((unsigned long long )mcp->mb[5] << 48) | ((unsigned long long )mcp->mb[4] << 32)) | ((unsigned long long )mcp->mb[3] << 16)) | (unsigned long long )mcp->mb[2];
    } else {

    }
#line 3237
    if ((unsigned long )rd != (unsigned long )((uint64_t *)0ULL)) {
#line 3238
      *rd = ((((unsigned long long )mcp->mb[9] << 48) | ((unsigned long long )mcp->mb[8] << 32)) | ((unsigned long long )mcp->mb[7] << 16)) | (unsigned long long )mcp->mb[6];
    } else {

    }
  }
#line 3244
  return (rval);
}
}
#line 3248 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_get_idma_speed(scsi_qla_host_t *vha , uint16_t loop_id , uint16_t *port_speed ,
                           uint16_t *mb ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  uint16_t tmp ;

  {
#line 3253
  mcp = & mc;
#line 3255
  ql_dbg(536903680U, vha, 4272, "Entered %s.\n", "qla2x00_get_idma_speed");
#line 3258
  if (((vha->hw)->device_type & 67108864U) == 0U) {
#line 3259
    return (258);
  } else {

  }
#line 3261
  mcp->mb[0] = 26U;
#line 3262
  mcp->mb[1] = loop_id;
#line 3263
  tmp = 0U;
#line 3263
  mcp->mb[3] = tmp;
#line 3263
  mcp->mb[2] = tmp;
#line 3264
  mcp->mb[9] = vha->vp_idx;
#line 3265
  mcp->out_mb = 527U;
#line 3266
  mcp->in_mb = 11U;
#line 3267
  mcp->tov = 30U;
#line 3268
  mcp->flags = 0U;
#line 3269
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3272
  if ((unsigned long )mb != (unsigned long )((uint16_t *)0U)) {
#line 3273
    *mb = mcp->mb[0];
#line 3274
    *(mb + 1UL) = mcp->mb[1];
#line 3275
    *(mb + 3UL) = mcp->mb[3];
  } else {

  }
#line 3278
  if (rval != 0) {
#line 3279
    ql_dbg(536870912U, vha, 4273, "Failed=%x.\n", rval);
  } else {
#line 3281
    ql_dbg(536903680U, vha, 4274, "Done %s.\n", "qla2x00_get_idma_speed");
#line 3283
    if ((unsigned long )port_speed != (unsigned long )((uint16_t *)0U)) {
#line 3284
      *port_speed = mcp->mb[3];
    } else {

    }
  }
#line 3287
  return (rval);
}
}
#line 3291 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_set_idma_speed(scsi_qla_host_t *vha , uint16_t loop_id , uint16_t port_speed ,
                           uint16_t *mb ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 3296
  mcp = & mc;
#line 3298
  ql_dbg(536903680U, vha, 4275, "Entered %s.\n", "qla2x00_set_idma_speed");
#line 3301
  if (((vha->hw)->device_type & 67108864U) == 0U) {
#line 3302
    return (258);
  } else {

  }
#line 3304
  mcp->mb[0] = 26U;
#line 3305
  mcp->mb[1] = loop_id;
#line 3306
  mcp->mb[2] = 1U;
#line 3307
  if (((((vha->hw)->device_type & 8192U) != 0U || ((vha->hw)->device_type & 16384U) != 0U) || ((vha->hw)->device_type & 65536U) != 0U) || ((vha->hw)->device_type & 262144U) != 0U) {
#line 3308
    mcp->mb[3] = (unsigned int )port_speed & 63U;
  } else {
#line 3310
    mcp->mb[3] = (unsigned int )port_speed & 7U;
  }
#line 3311
  mcp->mb[9] = vha->vp_idx;
#line 3312
  mcp->out_mb = 527U;
#line 3313
  mcp->in_mb = 11U;
#line 3314
  mcp->tov = 30U;
#line 3315
  mcp->flags = 0U;
#line 3316
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3319
  if ((unsigned long )mb != (unsigned long )((uint16_t *)0U)) {
#line 3320
    *mb = mcp->mb[0];
#line 3321
    *(mb + 1UL) = mcp->mb[1];
#line 3322
    *(mb + 3UL) = mcp->mb[3];
  } else {

  }
#line 3325
  if (rval != 0) {
#line 3326
    ql_dbg(536870912U, vha, 4276, "Failed=%x.\n", rval);
  } else {
#line 3329
    ql_dbg(536903680U, vha, 4277, "Done %s.\n", "qla2x00_set_idma_speed");
  }
#line 3333
  return (rval);
}
}
#line 3337 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
void qla24xx_report_id_acquisition(scsi_qla_host_t *vha , struct vp_rpt_id_entry_24xx *rptid_entry ) 
{ 
  uint8_t vp_idx ;
  uint16_t stat ;
  struct qla_hw_data *ha ;
  scsi_qla_host_t *vp ;
  unsigned long flags ;
  int found ;
  void *wwpn ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 3341
  stat = rptid_entry->vp_idx;
#line 3342
  ha = vha->hw;
#line 3347
  ql_dbg(536903680U, vha, 4278, "Entered %s.\n", "qla24xx_report_id_acquisition");
#line 3350
  if ((unsigned int )rptid_entry->entry_status != 0U) {
#line 3351
    return;
  } else {

  }
#line 3353
  if ((unsigned int )rptid_entry->format == 0U) {
#line 3354
    ql_dbg(536903680U, vha, 4279, "Format 0 : Number of VPs setup %d, number of VPs acquired %d.\n",
           (int )((unsigned char )((int )rptid_entry->vp_count >> 8)), (int )((unsigned char )rptid_entry->vp_count));
#line 3359
    ql_dbg(536903680U, vha, 4280, "Primary port id %02x%02x%02x.\n", (int )rptid_entry->port_id[2],
           (int )rptid_entry->port_id[1], (int )rptid_entry->port_id[0]);
  } else
#line 3363
  if ((unsigned int )rptid_entry->format == 1U) {
#line 3364
    vp_idx = (unsigned char )stat;
#line 3365
    ql_dbg(536903680U, vha, 4281, "Format 1: VP[%d] enabled - status %d - with port id %02x%02x%02x.\n",
           (int )vp_idx, (int )((unsigned char )((int )stat >> 8)), (int )rptid_entry->port_id[2],
           (int )rptid_entry->port_id[1], (int )rptid_entry->port_id[0]);
#line 3372
    if ((unsigned int )vp_idx == 0U) {
#line 3373
      wwpn = (void *)(& (ha->init_cb)->port_name);
#line 3375
      if ((unsigned int )((unsigned char )((int )stat >> 8)) == 0U) {
#line 3376
        if (((int )rptid_entry->vp_idx_map[1] & 64) != 0) {
#line 3377
          wwpn = (void *)(& rptid_entry->reserved_4) + 8U;
        } else {

        }
      } else {

      }
#line 3379
      memcpy((void *)(& vha->port_name), (void const   *)wwpn, 8UL);
#line 3380
      ((struct fc_host_attrs *)(vha->host)->shost_data)->port_name = wwn_to_u64((u8 *)(& vha->port_name));
#line 3382
      ql_dbg(536870912U, vha, 4120, "FA-WWN portname %016llx (%x)\n", ((struct fc_host_attrs *)(vha->host)->shost_data)->port_name,
             (int )((unsigned char )((int )stat >> 8)));
    } else {

    }
#line 3387
    vp = vha;
#line 3388
    if ((unsigned int )vp_idx == 0U) {
#line 3389
      goto reg_needed;
    } else {

    }
#line 3391
    if ((unsigned int )((unsigned char )((int )stat >> 8)) != 0U && (unsigned int )((unsigned char )((int )stat >> 8)) != 2U) {
#line 3392
      ql_dbg(536870912U, vha, 4282, "Could not acquire ID for VP[%d].\n", (int )vp_idx);
#line 3394
      return;
    } else {

    }
#line 3397
    found = 0;
#line 3398
    tmp = spinlock_check(& ha->vport_slock);
#line 3398
    flags = _raw_spin_lock_irqsave(tmp);
#line 3399
    __mptr = (struct list_head  const  *)ha->vp_list.next;
#line 3399
    vp = (scsi_qla_host_t *)__mptr;
#line 3399
    goto ldv_66388;
    ldv_66387: ;
#line 3400
    if ((int )((unsigned short )vp_idx) == (int )vp->vp_idx) {
#line 3401
      found = 1;
#line 3402
      goto ldv_66386;
    } else {

    }
#line 3399
    __mptr___0 = (struct list_head  const  *)vp->list.next;
#line 3399
    vp = (scsi_qla_host_t *)__mptr___0;
    ldv_66388: ;
#line 3399
    if ((unsigned long )(& vp->list) != (unsigned long )(& ha->vp_list)) {
#line 3401
      goto ldv_66387;
    } else {

    }
    ldv_66386: 
#line 3405
    spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 3407
    if (found == 0) {
#line 3408
      return;
    } else {

    }
#line 3410
    vp->d_id.b.domain = rptid_entry->port_id[2];
#line 3411
    vp->d_id.b.area = rptid_entry->port_id[1];
#line 3412
    vp->d_id.b.al_pa = rptid_entry->port_id[0];
#line 3418
    set_bit(0L, (unsigned long volatile   *)(& vp->vp_flags));
    reg_needed: 
#line 3421
    set_bit(9L, (unsigned long volatile   *)(& vp->dpc_flags));
#line 3422
    set_bit(12L, (unsigned long volatile   *)(& vp->dpc_flags));
#line 3423
    set_bit(14L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3424
    qla2xxx_wake_dpc(vha);
  } else {

  }
#line 3426
  return;
}
}
#line 3442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla24xx_modify_vp_config(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct vp_config_entry_24xx *vpmod ;
  dma_addr_t vpmod_dma ;
  struct qla_hw_data *ha ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 3447
  ha = vha->hw;
#line 3448
  tmp = pci_get_drvdata(ha->pdev);
#line 3448
  base_vha = (struct scsi_qla_host *)tmp;
#line 3452
  ql_dbg(536903680U, vha, 4283, "Entered %s.\n", "qla24xx_modify_vp_config");
#line 3455
  tmp___0 = dma_pool_alloc(ha->s_dma_pool, 208U, & vpmod_dma);
#line 3455
  vpmod = (struct vp_config_entry_24xx *)tmp___0;
#line 3456
  if ((unsigned long )vpmod == (unsigned long )((struct vp_config_entry_24xx *)0)) {
#line 3457
    ql_log(1U, vha, 4284, "Failed to allocate modify VP IOCB.\n");
#line 3459
    return (259);
  } else {

  }
#line 3462
  memset((void *)vpmod, 0, 64UL);
#line 3463
  vpmod->entry_type = 49U;
#line 3464
  vpmod->entry_count = 1U;
#line 3465
  vpmod->command = 1U;
#line 3466
  vpmod->vp_count = 1U;
#line 3467
  vpmod->vp_index1 = (uint8_t )vha->vp_idx;
#line 3468
  vpmod->options_idx1 = 56U;
#line 3470
  qlt_modify_vp_config(vha, vpmod);
#line 3472
  memcpy((void *)(& vpmod->node_name_idx1), (void const   *)(& vha->node_name),
           8UL);
#line 3473
  memcpy((void *)(& vpmod->port_name_idx1), (void const   *)(& vha->port_name),
           8UL);
#line 3474
  vpmod->entry_count = 1U;
#line 3476
  rval = qla2x00_issue_iocb(base_vha, (void *)vpmod, vpmod_dma, 0UL);
#line 3477
  if (rval != 0) {
#line 3478
    ql_dbg(536870912U, vha, 4285, "Failed to issue VP config IOCB (%x).\n", rval);
  } else
#line 3480
  if ((unsigned int )vpmod->comp_status != 0U) {
#line 3481
    ql_dbg(536870912U, vha, 4286, "Failed to complete IOCB -- error status (%x).\n",
           (int )vpmod->comp_status);
#line 3484
    rval = 258;
  } else
#line 3485
  if ((unsigned int )vpmod->comp_status != 0U) {
#line 3486
    ql_dbg(536870912U, vha, 4287, "Failed to complete IOCB -- completion status (%x).\n",
           (int )vpmod->comp_status);
#line 3489
    rval = 258;
  } else {
#line 3492
    ql_dbg(536903680U, vha, 4288, "Done %s.\n", "qla24xx_modify_vp_config");
#line 3494
    fc_vport_set_state(vha->fc_vport, 4);
  }
#line 3496
  dma_pool_free(ha->s_dma_pool, (void *)vpmod, vpmod_dma);
#line 3498
  return (rval);
}
}
#line 3517 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla24xx_control_vp(scsi_qla_host_t *vha , int cmd ) 
{ 
  int rval ;
  int map ;
  int pos ;
  struct vp_ctrl_entry_24xx *vce ;
  dma_addr_t vce_dma ;
  struct qla_hw_data *ha ;
  int vp_index ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 3523
  ha = vha->hw;
#line 3524
  vp_index = (int )vha->vp_idx;
#line 3525
  tmp = pci_get_drvdata(ha->pdev);
#line 3525
  base_vha = (struct scsi_qla_host *)tmp;
#line 3527
  ql_dbg(536903680U, vha, 4289, "Entered %s enabling index %d.\n", "qla24xx_control_vp",
         vp_index);
#line 3530
  if (vp_index == 0 || (int )ha->max_npiv_vports <= vp_index) {
#line 3531
    return (6);
  } else {

  }
#line 3533
  tmp___0 = dma_pool_alloc(ha->s_dma_pool, 208U, & vce_dma);
#line 3533
  vce = (struct vp_ctrl_entry_24xx *)tmp___0;
#line 3534
  if ((unsigned long )vce == (unsigned long )((struct vp_ctrl_entry_24xx *)0)) {
#line 3535
    ql_log(1U, vha, 4290, "Failed to allocate VP control IOCB.\n");
#line 3537
    return (259);
  } else {

  }
#line 3539
  memset((void *)vce, 0, 64UL);
#line 3541
  vce->entry_type = 48U;
#line 3542
  vce->entry_count = 1U;
#line 3543
  vce->command = (unsigned short )cmd;
#line 3544
  vce->vp_count = 1U;
#line 3549
  map = (vp_index + -1) / 8;
#line 3550
  pos = (vp_index + -1) & 7;
#line 3551
  mutex_lock_nested(& ha->vport_lock, 0U);
#line 3552
  vce->vp_idx_map[map] = (uint8_t )((int )((signed char )vce->vp_idx_map[map]) | (int )((signed char )(1 << pos)));
#line 3553
  mutex_unlock(& ha->vport_lock);
#line 3555
  rval = qla2x00_issue_iocb(base_vha, (void *)vce, vce_dma, 0UL);
#line 3556
  if (rval != 0) {
#line 3557
    ql_dbg(536870912U, vha, 4291, "Failed to issue VP control IOCB (%x).\n", rval);
  } else
#line 3559
  if ((unsigned int )vce->entry_status != 0U) {
#line 3560
    ql_dbg(536870912U, vha, 4292, "Failed to complete IOCB -- error status (%x).\n",
           (int )vce->entry_status);
#line 3563
    rval = 258;
  } else
#line 3564
  if ((unsigned int )vce->comp_status != 0U) {
#line 3565
    ql_dbg(536870912U, vha, 4293, "Failed to complet IOCB -- completion status (%x).\n",
           (int )vce->comp_status);
#line 3568
    rval = 258;
  } else {
#line 3570
    ql_dbg(536903680U, vha, 4294, "Done %s.\n", "qla24xx_control_vp");
  }
#line 3574
  dma_pool_free(ha->s_dma_pool, (void *)vce, vce_dma);
#line 3576
  return (rval);
}
}
#line 3601 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_send_change_request(scsi_qla_host_t *vha , uint16_t format , uint16_t vp_idx ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 3606
  mcp = & mc;
#line 3608
  ql_dbg(536903680U, vha, 4295, "Entered %s.\n", "qla2x00_send_change_request");
#line 3611
  mcp->mb[0] = 112U;
#line 3612
  mcp->mb[1] = format;
#line 3613
  mcp->mb[9] = vp_idx;
#line 3614
  mcp->out_mb = 515U;
#line 3615
  mcp->in_mb = 3U;
#line 3616
  mcp->tov = 30U;
#line 3617
  mcp->flags = 0U;
#line 3618
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3620
  if (rval == 0) {
#line 3621
    if ((unsigned int )mcp->mb[0] != 16384U) {
#line 3622
      rval = 2;
    } else {

    }
  } else {
#line 3625
    rval = 2;
  }
#line 3627
  return (rval);
}
}
#line 3631 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_dump_ram(scsi_qla_host_t *vha , dma_addr_t req_dma , uint32_t addr , uint32_t size ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 3636
  mcp = & mc;
#line 3638
  ql_dbg(536903680U, vha, 4105, "Entered %s.\n", "qla2x00_dump_ram");
#line 3641
  if ((unsigned int )((unsigned short )(addr >> 16)) != 0U || ((vha->hw)->device_type & 134217728U) != 0U) {
#line 3642
    mcp->mb[0] = 12U;
#line 3643
    mcp->mb[8] = (unsigned short )(addr >> 16);
#line 3644
    mcp->out_mb = 257U;
  } else {
#line 3646
    mcp->mb[0] = 10U;
#line 3647
    mcp->out_mb = 1U;
  }
#line 3649
  mcp->mb[1] = (unsigned short )addr;
#line 3650
  mcp->mb[2] = (unsigned short )((unsigned int )req_dma >> 16);
#line 3651
  mcp->mb[3] = (unsigned short )req_dma;
#line 3652
  mcp->mb[6] = (unsigned short )((unsigned int )(req_dma >> 32ULL) >> 16);
#line 3653
  mcp->mb[7] = (unsigned short )(req_dma >> 32ULL);
#line 3654
  mcp->out_mb = mcp->out_mb | 206U;
#line 3655
  if (((vha->hw)->device_type & 134217728U) != 0U) {
#line 3656
    mcp->mb[4] = (unsigned short )(size >> 16);
#line 3657
    mcp->mb[5] = (unsigned short )size;
#line 3658
    mcp->out_mb = mcp->out_mb | 48U;
  } else {
#line 3660
    mcp->mb[4] = (unsigned short )size;
#line 3661
    mcp->out_mb = mcp->out_mb | 16U;
  }
#line 3664
  mcp->in_mb = 1U;
#line 3665
  mcp->tov = 30U;
#line 3666
  mcp->flags = 0U;
#line 3667
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3669
  if (rval != 0) {
#line 3670
    ql_dbg(536870912U, vha, 4104, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 3673
    ql_dbg(536903680U, vha, 4103, "Done %s.\n", "qla2x00_dump_ram");
  }
#line 3677
  return (rval);
}
}
#line 3689 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla84xx_verify_chip(struct scsi_qla_host *vha , uint16_t *status ) 
{ 
  int rval ;
  int retry ;
  struct cs84xx_mgmt_cmd *mn ;
  dma_addr_t mn_dma ;
  uint16_t options ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 3696
  ha = vha->hw;
#line 3698
  ql_dbg(536903680U, vha, 4296, "Entered %s.\n", "qla84xx_verify_chip");
#line 3701
  tmp = dma_pool_alloc(ha->s_dma_pool, 208U, & mn_dma);
#line 3701
  mn = (struct cs84xx_mgmt_cmd *)tmp;
#line 3702
  if ((unsigned long )mn == (unsigned long )((struct cs84xx_mgmt_cmd *)0)) {
#line 3703
    return (259);
  } else {

  }
#line 3707
  options = (ha->cs84xx)->fw_update != 0U ? 2U : 0U;
#line 3711
  options = (uint16_t )((unsigned int )options | 16384U);
  ldv_66451: 
#line 3714
  retry = 0;
#line 3715
  memset((void *)mn, 0, 64UL);
#line 3716
  mn->p.req.entry_type = 27U;
#line 3717
  mn->p.req.entry_count = 1U;
#line 3718
  mn->p.req.options = options;
#line 3720
  ql_dbg(537001984U, vha, 4380, "Dump of Verify Request.\n");
#line 3722
  ql_dump_buffer(537001984U, vha, 4382, (uint8_t *)mn, 64U);
#line 3725
  rval = qla2x00_issue_iocb_timeout(vha, (void *)mn, mn_dma, 0UL, 120U);
#line 3726
  if (rval != 0) {
#line 3727
    ql_dbg(536870912U, vha, 4299, "Failed to issue verify IOCB (%x).\n", rval);
#line 3729
    goto verify_done;
  } else {

  }
#line 3732
  ql_dbg(537001984U, vha, 4368, "Dump of Verify Response.\n");
#line 3734
  ql_dump_buffer(537001984U, vha, 4376, (uint8_t *)mn, 64U);
#line 3737
  *status = mn->p.rsp.comp_status;
#line 3738
  *(status + 1UL) = (unsigned int )*status == 3U ? mn->p.rsp.failure_code : 0U;
#line 3740
  ql_dbg(536903680U, vha, 4302, "cs=%x fc=%x.\n", (int )*status, (int )*(status + 1UL));
#line 3743
  if ((unsigned int )*status != 0U) {
#line 3744
    rval = 258;
#line 3745
    if (((int )options & 1) == 0) {
#line 3746
      ql_dbg(536870912U, vha, 4303, "Firmware update failed. Retrying without update firmware.\n");
#line 3749
      options = (uint16_t )((unsigned int )options | 1U);
#line 3750
      options = (unsigned int )options & 65533U;
#line 3751
      retry = 1;
    } else {

    }
  } else {
#line 3754
    ql_dbg(536903680U, vha, 4304, "Firmware updated to %x.\n", mn->p.rsp.fw_ver);
#line 3759
    tmp___0 = spinlock_check(& (ha->cs84xx)->access_lock);
#line 3759
    flags = _raw_spin_lock_irqsave(tmp___0);
#line 3760
    (ha->cs84xx)->op_fw_version = mn->p.rsp.fw_ver;
#line 3762
    spin_unlock_irqrestore(& (ha->cs84xx)->access_lock, flags);
  }
#line 3765
  if (retry != 0) {
#line 3767
    goto ldv_66451;
  } else {

  }

  verify_done: 
#line 3768
  dma_pool_free(ha->s_dma_pool, (void *)mn, mn_dma);
#line 3770
  if (rval != 0) {
#line 3771
    ql_dbg(536870912U, vha, 4305, "Failed=%x.\n", rval);
  } else {
#line 3774
    ql_dbg(536903680U, vha, 4306, "Done %s.\n", "qla84xx_verify_chip");
  }
#line 3778
  return (rval);
}
}
#line 3782 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla25xx_init_req_que(struct scsi_qla_host *vha , struct req_que *req ) 
{ 
  int rval ;
  unsigned long flags ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;
  uint16_t tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 3787
  mcp = & mc;
#line 3788
  ha = vha->hw;
#line 3790
  ql_dbg(536903680U, vha, 4307, "Entered %s.\n", "qla25xx_init_req_que");
#line 3793
  if ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) {
#line 3794
    req->options = (uint16_t )((unsigned int )req->options | 8192U);
  } else {

  }
#line 3796
  mcp->mb[0] = 31U;
#line 3797
  mcp->mb[1] = req->options;
#line 3798
  mcp->mb[2] = (unsigned short )((unsigned int )req->dma >> 16);
#line 3799
  mcp->mb[3] = (unsigned short )req->dma;
#line 3800
  mcp->mb[6] = (unsigned short )((unsigned int )(req->dma >> 32ULL) >> 16);
#line 3801
  mcp->mb[7] = (unsigned short )(req->dma >> 32ULL);
#line 3802
  mcp->mb[5] = req->length;
#line 3803
  if ((unsigned long )req->rsp != (unsigned long )((struct rsp_que *)0)) {
#line 3804
    mcp->mb[10] = (req->rsp)->id;
  } else {

  }
#line 3805
  mcp->mb[12] = req->qos;
#line 3806
  mcp->mb[11] = req->vp_idx;
#line 3807
  mcp->mb[13] = req->rid;
#line 3808
  if (((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 3809
    mcp->mb[15] = 0U;
  } else {

  }
#line 3811
  mcp->mb[4] = req->id;
#line 3813
  mcp->mb[8] = 0U;
#line 3815
  tmp = 0U;
#line 3815
  *(req->out_ptr) = tmp;
#line 3815
  mcp->mb[9] = tmp;
#line 3816
  mcp->out_mb = 32767U;
#line 3818
  mcp->in_mb = 1U;
#line 3819
  mcp->flags = 2U;
#line 3820
  mcp->tov = 60U;
#line 3822
  if (((ha->device_type & 8192U) != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 3823
    mcp->in_mb = mcp->in_mb | 2U;
  } else {

  }
#line 3824
  if (((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 3825
    mcp->out_mb = mcp->out_mb | 32768U;
#line 3827
    mcp->in_mb = mcp->in_mb | 896U;
  } else {

  }
#line 3830
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 3830
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 3831
  if (((int )req->options & 1) == 0) {
#line 3832
    writel(0U, (void volatile   *)req->req_q_in);
#line 3833
    if (((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U) && ((ha->device_type & 524288U) == 0U && (ha->device_type & 1048576U) == 0U)) {
#line 3834
      writel(0U, (void volatile   *)req->req_q_out);
    } else {

    }
  } else {

  }
#line 3836
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3838
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3839
  if (rval != 0) {
#line 3840
    ql_dbg(536870912U, vha, 4308, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 3843
    ql_dbg(536903680U, vha, 4309, "Done %s.\n", "qla25xx_init_req_que");
  }
#line 3847
  return (rval);
}
}
#line 3851 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla25xx_init_rsp_que(struct scsi_qla_host *vha , struct rsp_que *rsp ) 
{ 
  int rval ;
  unsigned long flags ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;
  uint16_t tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 3856
  mcp = & mc;
#line 3857
  ha = vha->hw;
#line 3859
  ql_dbg(536903680U, vha, 4310, "Entered %s.\n", "qla25xx_init_rsp_que");
#line 3862
  if ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) {
#line 3863
    rsp->options = (uint16_t )((unsigned int )rsp->options | 8192U);
  } else {

  }
#line 3865
  mcp->mb[0] = 31U;
#line 3866
  mcp->mb[1] = rsp->options;
#line 3867
  mcp->mb[2] = (unsigned short )((unsigned int )rsp->dma >> 16);
#line 3868
  mcp->mb[3] = (unsigned short )rsp->dma;
#line 3869
  mcp->mb[6] = (unsigned short )((unsigned int )(rsp->dma >> 32ULL) >> 16);
#line 3870
  mcp->mb[7] = (unsigned short )(rsp->dma >> 32ULL);
#line 3871
  mcp->mb[5] = rsp->length;
#line 3872
  mcp->mb[14] = (rsp->msix)->entry;
#line 3873
  mcp->mb[13] = rsp->rid;
#line 3874
  if (((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 3875
    mcp->mb[15] = 0U;
  } else {

  }
#line 3877
  mcp->mb[4] = rsp->id;
#line 3879
  tmp = 0U;
#line 3879
  *(rsp->in_ptr) = tmp;
#line 3879
  mcp->mb[8] = tmp;
#line 3881
  mcp->mb[9] = 0U;
#line 3882
  mcp->out_mb = 25599U;
#line 3884
  mcp->in_mb = 1U;
#line 3885
  mcp->flags = 2U;
#line 3886
  mcp->tov = 60U;
#line 3888
  if ((ha->device_type & 8192U) != 0U) {
#line 3889
    mcp->out_mb = mcp->out_mb | 7168U;
#line 3890
    mcp->in_mb = mcp->in_mb | 2U;
  } else
#line 3891
  if (((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 3892
    mcp->out_mb = mcp->out_mb | 39936U;
#line 3893
    mcp->in_mb = mcp->in_mb | 2U;
#line 3895
    mcp->in_mb = mcp->in_mb | 896U;
  } else {

  }
#line 3898
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 3898
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 3899
  if (((int )rsp->options & 1) == 0) {
#line 3900
    writel(0U, (void volatile   *)rsp->rsp_q_out);
#line 3901
    if ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U) {
#line 3902
      writel(0U, (void volatile   *)rsp->rsp_q_in);
    } else {

    }
  } else {

  }
#line 3905
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3907
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3908
  if (rval != 0) {
#line 3909
    ql_dbg(536870912U, vha, 4311, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 3912
    ql_dbg(536903680U, vha, 4312, "Done %s.\n", "qla25xx_init_rsp_que");
  }
#line 3916
  return (rval);
}
}
#line 3920 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla81xx_idc_ack(scsi_qla_host_t *vha , uint16_t *mb ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 3924
  mcp = & mc;
#line 3926
  ql_dbg(536903680U, vha, 4313, "Entered %s.\n", "qla81xx_idc_ack");
#line 3929
  mcp->mb[0] = 257U;
#line 3930
  memcpy((void *)(& mcp->mb) + 1U, (void const   *)mb, 14UL);
#line 3931
  mcp->out_mb = 255U;
#line 3932
  mcp->in_mb = 1U;
#line 3933
  mcp->tov = 30U;
#line 3934
  mcp->flags = 0U;
#line 3935
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3937
  if (rval != 0) {
#line 3938
    ql_dbg(536870912U, vha, 4314, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 3941
    ql_dbg(536903680U, vha, 4315, "Done %s.\n", "qla81xx_idc_ack");
  }
#line 3945
  return (rval);
}
}
#line 3949 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla81xx_fac_get_sector_size(scsi_qla_host_t *vha , uint32_t *sector_size ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 3953
  mcp = & mc;
#line 3955
  ql_dbg(536903680U, vha, 4316, "Entered %s.\n", "qla81xx_fac_get_sector_size");
#line 3958
  if ((((vha->hw)->device_type & 8192U) == 0U && (((vha->hw)->device_type & 32768U) == 0U && ((vha->hw)->device_type & 65536U) == 0U)) && (((vha->hw)->device_type & 524288U) == 0U && ((vha->hw)->device_type & 1048576U) == 0U)) {
#line 3960
    return (258);
  } else {

  }
#line 3962
  mcp->mb[0] = 62U;
#line 3963
  mcp->mb[1] = 5U;
#line 3964
  mcp->out_mb = 3U;
#line 3965
  mcp->in_mb = 3U;
#line 3966
  mcp->tov = 30U;
#line 3967
  mcp->flags = 0U;
#line 3968
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3970
  if (rval != 0) {
#line 3971
    ql_dbg(536870912U, vha, 4317, "Failed=%x mb[0]=%x mb[1]=%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 3975
    ql_dbg(536903680U, vha, 4318, "Done %s.\n", "qla81xx_fac_get_sector_size");
#line 3977
    *sector_size = (uint32_t )mcp->mb[1];
  }
#line 3980
  return (rval);
}
}
#line 3984 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla81xx_fac_do_write_enable(scsi_qla_host_t *vha , int enable ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 3988
  mcp = & mc;
#line 3990
  if ((((vha->hw)->device_type & 8192U) == 0U && (((vha->hw)->device_type & 32768U) == 0U && ((vha->hw)->device_type & 65536U) == 0U)) && (((vha->hw)->device_type & 524288U) == 0U && ((vha->hw)->device_type & 1048576U) == 0U)) {
#line 3992
    return (258);
  } else {

  }
#line 3994
  ql_dbg(536903680U, vha, 4319, "Entered %s.\n", "qla81xx_fac_do_write_enable");
#line 3997
  mcp->mb[0] = 62U;
#line 3998
  mcp->mb[1] = enable != 0;
#line 4000
  mcp->out_mb = 3U;
#line 4001
  mcp->in_mb = 3U;
#line 4002
  mcp->tov = 30U;
#line 4003
  mcp->flags = 0U;
#line 4004
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4006
  if (rval != 0) {
#line 4007
    ql_dbg(536870912U, vha, 4320, "Failed=%x mb[0]=%x mb[1]=%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 4011
    ql_dbg(536903680U, vha, 4321, "Done %s.\n", "qla81xx_fac_do_write_enable");
  }
#line 4015
  return (rval);
}
}
#line 4019 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla81xx_fac_erase_sector(scsi_qla_host_t *vha , uint32_t start , uint32_t finish ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 4023
  mcp = & mc;
#line 4025
  if ((((vha->hw)->device_type & 8192U) == 0U && (((vha->hw)->device_type & 32768U) == 0U && ((vha->hw)->device_type & 65536U) == 0U)) && (((vha->hw)->device_type & 524288U) == 0U && ((vha->hw)->device_type & 1048576U) == 0U)) {
#line 4027
    return (258);
  } else {

  }
#line 4029
  ql_dbg(536903680U, vha, 4322, "Entered %s.\n", "qla81xx_fac_erase_sector");
#line 4032
  mcp->mb[0] = 62U;
#line 4033
  mcp->mb[1] = 2U;
#line 4034
  mcp->mb[2] = (unsigned short )start;
#line 4035
  mcp->mb[3] = (unsigned short )(start >> 16);
#line 4036
  mcp->mb[4] = (unsigned short )finish;
#line 4037
  mcp->mb[5] = (unsigned short )(finish >> 16);
#line 4038
  mcp->out_mb = 63U;
#line 4039
  mcp->in_mb = 7U;
#line 4040
  mcp->tov = 30U;
#line 4041
  mcp->flags = 0U;
#line 4042
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4044
  if (rval != 0) {
#line 4045
    ql_dbg(536870912U, vha, 4323, "Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x.\n", rval,
           (int )mcp->mb[0], (int )mcp->mb[1], (int )mcp->mb[2]);
  } else {
#line 4049
    ql_dbg(536903680U, vha, 4324, "Done %s.\n", "qla81xx_fac_erase_sector");
  }
#line 4053
  return (rval);
}
}
#line 4057 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla81xx_restart_mpi_firmware(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 4059
  rval = 0;
#line 4061
  mcp = & mc;
#line 4063
  ql_dbg(536903680U, vha, 4325, "Entered %s.\n", "qla81xx_restart_mpi_firmware");
#line 4066
  mcp->mb[0] = 61U;
#line 4067
  mcp->out_mb = 1U;
#line 4068
  mcp->in_mb = 3U;
#line 4069
  mcp->tov = 30U;
#line 4070
  mcp->flags = 0U;
#line 4071
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4073
  if (rval != 0) {
#line 4074
    ql_dbg(536870912U, vha, 4326, "Failed=%x mb[0]=%x mb[1]=%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 4078
    ql_dbg(536903680U, vha, 4327, "Done %s.\n", "qla81xx_restart_mpi_firmware");
  }
#line 4082
  return (rval);
}
}
#line 4086 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla82xx_set_driver_version(scsi_qla_host_t *vha , char *version ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  int i ;
  int len ;
  uint16_t *str ;
  struct qla_hw_data *ha ;
  size_t tmp ;

  {
#line 4090
  mcp = & mc;
#line 4094
  ha = vha->hw;
#line 4096
  if ((ha->device_type & 16384U) == 0U && (ha->device_type & 262144U) == 0U) {
#line 4097
    return (258);
  } else {

  }
#line 4099
  ql_dbg(536903680U, vha, 4475, "Entered %s.\n", "qla82xx_set_driver_version");
#line 4102
  str = (uint16_t *)version;
#line 4103
  tmp = strlen((char const   *)version);
#line 4103
  len = (int )tmp;
#line 4105
  mcp->mb[0] = 89U;
#line 4106
  mcp->mb[1] = 2304U;
#line 4107
  mcp->out_mb = 3U;
#line 4108
  i = 4;
#line 4108
  goto ldv_66532;
  ldv_66531: 
#line 4109
  mcp->mb[i] = __cpu_to_le16p((__u16 const   *)str);
#line 4110
  mcp->out_mb = mcp->out_mb | (uint32_t )(1 << i);
#line 4108
  i = i + 1;
#line 4108
  str = str + 1;
#line 4108
  len = len + -2;
  ldv_66532: ;
#line 4108
  if (i <= 15 && len != 0) {
#line 4110
    goto ldv_66531;
  } else {

  }

#line 4112
  goto ldv_66535;
  ldv_66534: 
#line 4113
  mcp->mb[i] = 0U;
#line 4114
  mcp->out_mb = mcp->out_mb | (uint32_t )(1 << i);
#line 4112
  i = i + 1;
  ldv_66535: ;
#line 4112
  if (i <= 15) {
#line 4114
    goto ldv_66534;
  } else {

  }
#line 4116
  mcp->in_mb = 3U;
#line 4117
  mcp->tov = 30U;
#line 4118
  mcp->flags = 0U;
#line 4119
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4121
  if (rval != 0) {
#line 4122
    ql_dbg(536870912U, vha, 4476, "Failed=%x mb[0]=%x,%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 4125
    ql_dbg(536903680U, vha, 4477, "Done %s.\n", "qla82xx_set_driver_version");
  }
#line 4129
  return (rval);
}
}
#line 4133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla25xx_set_driver_version(scsi_qla_host_t *vha , char *version ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  int len ;
  uint16_t dwlen ;
  uint8_t *str ;
  dma_addr_t str_dma ;
  struct qla_hw_data *ha ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 4137
  mcp = & mc;
#line 4142
  ha = vha->hw;
#line 4144
  if ((((ha->device_type & 134217728U) == 0U || ((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || ((ha->device_type & 512U) != 0U || (ha->device_type & 1024U) != 0U)) || (ha->device_type & 4096U) != 0U)) || (ha->device_type & 8192U) != 0U) || ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U)) {
#line 4146
    return (258);
  } else {

  }
#line 4148
  ql_dbg(536903680U, vha, 4478, "Entered %s.\n", "qla25xx_set_driver_version");
#line 4151
  tmp = dma_pool_alloc(ha->s_dma_pool, 208U, & str_dma);
#line 4151
  str = (uint8_t *)tmp;
#line 4152
  if ((unsigned long )str == (unsigned long )((uint8_t *)0U)) {
#line 4153
    ql_log(1U, vha, 4479, "Failed to allocate driver version param.\n");
#line 4155
    return (259);
  } else {

  }
#line 4158
  memcpy((void *)str, (void const   *)"\a\003\021", 4UL);
#line 4159
  dwlen = (uint16_t )*str;
#line 4160
  len = ((int )dwlen + -1) * 4;
#line 4161
  memset((void *)str + 4U, 0, (size_t )len);
#line 4162
  tmp___1 = strlen((char const   *)version);
#line 4162
  if ((size_t )len > tmp___1) {
#line 4163
    tmp___0 = strlen((char const   *)version);
#line 4163
    len = (int )tmp___0;
  } else {

  }
#line 4164
  memcpy((void *)str + 4U, (void const   *)version, (size_t )len);
#line 4166
  mcp->mb[0] = 89U;
#line 4167
  mcp->mb[1] = (uint16_t )((unsigned int )dwlen | 2304U);
#line 4168
  mcp->mb[2] = (unsigned short )((unsigned int )str_dma >> 16);
#line 4169
  mcp->mb[3] = (unsigned short )str_dma;
#line 4170
  mcp->mb[6] = (unsigned short )((unsigned int )(str_dma >> 32ULL) >> 16);
#line 4171
  mcp->mb[7] = (unsigned short )(str_dma >> 32ULL);
#line 4172
  mcp->out_mb = 207U;
#line 4173
  mcp->in_mb = 3U;
#line 4174
  mcp->tov = 30U;
#line 4175
  mcp->flags = 0U;
#line 4176
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4178
  if (rval != 0) {
#line 4179
    ql_dbg(536870912U, vha, 4480, "Failed=%x mb[0]=%x,%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 4182
    ql_dbg(536903680U, vha, 4481, "Done %s.\n", "qla25xx_set_driver_version");
  }
#line 4186
  dma_pool_free(ha->s_dma_pool, (void *)str, str_dma);
#line 4188
  return (rval);
}
}
#line 4192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
static int qla2x00_read_asic_temperature(scsi_qla_host_t *vha , uint16_t *temp ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 4196
  mcp = & mc;
#line 4198
  if (((vha->hw)->device_type & 134217728U) == 0U) {
#line 4199
    return (258);
  } else {

  }
#line 4201
  ql_dbg(536903680U, vha, 4441, "Entered %s.\n", "qla2x00_read_asic_temperature");
#line 4204
  mcp->mb[0] = 90U;
#line 4205
  mcp->mb[1] = 3072U;
#line 4206
  mcp->out_mb = 3U;
#line 4207
  mcp->in_mb = 3U;
#line 4208
  mcp->tov = 30U;
#line 4209
  mcp->flags = 0U;
#line 4210
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4211
  *temp = mcp->mb[1];
#line 4213
  if (rval != 0) {
#line 4214
    ql_dbg(536870912U, vha, 4442, "Failed=%x mb[0]=%x,%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 4217
    ql_dbg(536903680U, vha, 4443, "Done %s.\n", "qla2x00_read_asic_temperature");
  }
#line 4221
  return (rval);
}
}
#line 4225 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_read_sfp(scsi_qla_host_t *vha , dma_addr_t sfp_dma , uint8_t *sfp , uint16_t dev ,
                     uint16_t off , uint16_t len , uint16_t opt ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;

  {
#line 4230
  mcp = & mc;
#line 4231
  ha = vha->hw;
#line 4233
  ql_dbg(536903680U, vha, 4328, "Entered %s.\n", "qla2x00_read_sfp");
#line 4236
  if ((ha->device_type & 134217728U) == 0U) {
#line 4237
    return (258);
  } else {

  }
#line 4239
  if ((unsigned int )len == 1U) {
#line 4240
    opt = (uint16_t )((unsigned int )opt | 1U);
  } else {

  }
#line 4242
  mcp->mb[0] = 49U;
#line 4243
  mcp->mb[1] = dev;
#line 4244
  mcp->mb[2] = (unsigned short )((unsigned int )sfp_dma >> 16);
#line 4245
  mcp->mb[3] = (unsigned short )sfp_dma;
#line 4246
  mcp->mb[6] = (unsigned short )((unsigned int )(sfp_dma >> 32ULL) >> 16);
#line 4247
  mcp->mb[7] = (unsigned short )(sfp_dma >> 32ULL);
#line 4248
  mcp->mb[8] = len;
#line 4249
  mcp->mb[9] = off;
#line 4250
  mcp->mb[10] = opt;
#line 4251
  mcp->out_mb = 1999U;
#line 4252
  mcp->in_mb = 3U;
#line 4253
  mcp->tov = 30U;
#line 4254
  mcp->flags = 0U;
#line 4255
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4257
  if ((int )opt & 1) {
#line 4258
    *sfp = (uint8_t )mcp->mb[1];
  } else {

  }
#line 4260
  if (rval != 0) {
#line 4261
    ql_dbg(536870912U, vha, 4329, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 4264
    ql_dbg(536903680U, vha, 4330, "Done %s.\n", "qla2x00_read_sfp");
  }
#line 4268
  return (rval);
}
}
#line 4272 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_write_sfp(scsi_qla_host_t *vha , dma_addr_t sfp_dma , uint8_t *sfp , uint16_t dev ,
                      uint16_t off , uint16_t len , uint16_t opt ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;

  {
#line 4277
  mcp = & mc;
#line 4278
  ha = vha->hw;
#line 4280
  ql_dbg(536903680U, vha, 4331, "Entered %s.\n", "qla2x00_write_sfp");
#line 4283
  if ((ha->device_type & 134217728U) == 0U) {
#line 4284
    return (258);
  } else {

  }
#line 4286
  if ((unsigned int )len == 1U) {
#line 4287
    opt = (uint16_t )((unsigned int )opt | 1U);
  } else {

  }
#line 4289
  if ((int )opt & 1) {
#line 4290
    len = (uint16_t )*sfp;
  } else {

  }
#line 4292
  mcp->mb[0] = 48U;
#line 4293
  mcp->mb[1] = dev;
#line 4294
  mcp->mb[2] = (unsigned short )((unsigned int )sfp_dma >> 16);
#line 4295
  mcp->mb[3] = (unsigned short )sfp_dma;
#line 4296
  mcp->mb[6] = (unsigned short )((unsigned int )(sfp_dma >> 32ULL) >> 16);
#line 4297
  mcp->mb[7] = (unsigned short )(sfp_dma >> 32ULL);
#line 4298
  mcp->mb[8] = len;
#line 4299
  mcp->mb[9] = off;
#line 4300
  mcp->mb[10] = opt;
#line 4301
  mcp->out_mb = 1999U;
#line 4302
  mcp->in_mb = 3U;
#line 4303
  mcp->tov = 30U;
#line 4304
  mcp->flags = 0U;
#line 4305
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4307
  if (rval != 0) {
#line 4308
    ql_dbg(536870912U, vha, 4332, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 4311
    ql_dbg(536903680U, vha, 4333, "Done %s.\n", "qla2x00_write_sfp");
  }
#line 4315
  return (rval);
}
}
#line 4319 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_get_xgmac_stats(scsi_qla_host_t *vha , dma_addr_t stats_dma , uint16_t size_in_bytes ,
                            uint16_t *actual_size ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 4324
  mcp = & mc;
#line 4326
  ql_dbg(536903680U, vha, 4334, "Entered %s.\n", "qla2x00_get_xgmac_stats");
#line 4329
  if (((((vha->hw)->device_type & 8192U) == 0U && ((vha->hw)->device_type & 16384U) == 0U) && ((vha->hw)->device_type & 65536U) == 0U) && ((vha->hw)->device_type & 262144U) == 0U) {
#line 4330
    return (258);
  } else {

  }
#line 4332
  mcp->mb[0] = 122U;
#line 4333
  mcp->mb[2] = (unsigned short )((unsigned int )stats_dma >> 16);
#line 4334
  mcp->mb[3] = (unsigned short )stats_dma;
#line 4335
  mcp->mb[6] = (unsigned short )((unsigned int )(stats_dma >> 32ULL) >> 16);
#line 4336
  mcp->mb[7] = (unsigned short )(stats_dma >> 32ULL);
#line 4337
  mcp->mb[8] = (uint16_t )((int )size_in_bytes >> 2);
#line 4338
  mcp->out_mb = 461U;
#line 4339
  mcp->in_mb = 7U;
#line 4340
  mcp->tov = 30U;
#line 4341
  mcp->flags = 0U;
#line 4342
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4344
  if (rval != 0) {
#line 4345
    ql_dbg(536870912U, vha, 4335, "Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x.\n", rval,
           (int )mcp->mb[0], (int )mcp->mb[1], (int )mcp->mb[2]);
  } else {
#line 4349
    ql_dbg(536903680U, vha, 4336, "Done %s.\n", "qla2x00_get_xgmac_stats");
#line 4353
    *actual_size = (int )mcp->mb[2] << 2U;
  }
#line 4356
  return (rval);
}
}
#line 4360 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_get_dcbx_params(scsi_qla_host_t *vha , dma_addr_t tlv_dma , uint16_t size ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 4365
  mcp = & mc;
#line 4367
  ql_dbg(536903680U, vha, 4337, "Entered %s.\n", "qla2x00_get_dcbx_params");
#line 4370
  if (((((vha->hw)->device_type & 8192U) == 0U && ((vha->hw)->device_type & 16384U) == 0U) && ((vha->hw)->device_type & 65536U) == 0U) && ((vha->hw)->device_type & 262144U) == 0U) {
#line 4371
    return (258);
  } else {

  }
#line 4373
  mcp->mb[0] = 81U;
#line 4374
  mcp->mb[1] = 0U;
#line 4375
  mcp->mb[2] = (unsigned short )((unsigned int )tlv_dma >> 16);
#line 4376
  mcp->mb[3] = (unsigned short )tlv_dma;
#line 4377
  mcp->mb[6] = (unsigned short )((unsigned int )(tlv_dma >> 32ULL) >> 16);
#line 4378
  mcp->mb[7] = (unsigned short )(tlv_dma >> 32ULL);
#line 4379
  mcp->mb[8] = size;
#line 4380
  mcp->out_mb = 463U;
#line 4381
  mcp->in_mb = 7U;
#line 4382
  mcp->tov = 30U;
#line 4383
  mcp->flags = 0U;
#line 4384
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4386
  if (rval != 0) {
#line 4387
    ql_dbg(536870912U, vha, 4338, "Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x.\n", rval,
           (int )mcp->mb[0], (int )mcp->mb[1], (int )mcp->mb[2]);
  } else {
#line 4391
    ql_dbg(536903680U, vha, 4339, "Done %s.\n", "qla2x00_get_dcbx_params");
  }
#line 4395
  return (rval);
}
}
#line 4399 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_read_ram_word(scsi_qla_host_t *vha , uint32_t risc_addr , uint32_t *data ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 4403
  mcp = & mc;
#line 4405
  ql_dbg(536903680U, vha, 4340, "Entered %s.\n", "qla2x00_read_ram_word");
#line 4408
  if (((vha->hw)->device_type & 134217728U) == 0U) {
#line 4409
    return (258);
  } else {

  }
#line 4411
  mcp->mb[0] = 15U;
#line 4412
  mcp->mb[1] = (unsigned short )risc_addr;
#line 4413
  mcp->mb[8] = (unsigned short )(risc_addr >> 16);
#line 4414
  mcp->out_mb = 259U;
#line 4415
  mcp->in_mb = 13U;
#line 4416
  mcp->tov = 30U;
#line 4417
  mcp->flags = 0U;
#line 4418
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4419
  if (rval != 0) {
#line 4420
    ql_dbg(536870912U, vha, 4341, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 4423
    ql_dbg(536903680U, vha, 4342, "Done %s.\n", "qla2x00_read_ram_word");
#line 4425
    *data = (uint32_t )(((int )mcp->mb[3] << 16) | (int )mcp->mb[2]);
  }
#line 4428
  return (rval);
}
}
#line 4432 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_loopback_test(scsi_qla_host_t *vha , struct msg_echo_lb *mreq , uint16_t *mresp ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 4437
  mcp = & mc;
#line 4439
  ql_dbg(536903680U, vha, 4343, "Entered %s.\n", "qla2x00_loopback_test");
#line 4442
  memset((void *)(& mcp->mb), 0, 64UL);
#line 4443
  mcp->mb[0] = 69U;
#line 4444
  mcp->mb[1] = (uint16_t )((unsigned int )mreq->options | 64U);
#line 4447
  mcp->mb[10] = (unsigned short )mreq->transfer_size;
#line 4448
  mcp->mb[11] = (unsigned short )(mreq->transfer_size >> 16);
#line 4451
  mcp->mb[14] = (unsigned short )mreq->send_dma;
#line 4452
  mcp->mb[15] = (unsigned short )((unsigned int )mreq->send_dma >> 16);
#line 4453
  mcp->mb[20] = (unsigned short )(mreq->send_dma >> 32ULL);
#line 4454
  mcp->mb[21] = (unsigned short )((unsigned int )(mreq->send_dma >> 32ULL) >> 16);
#line 4457
  mcp->mb[16] = (unsigned short )mreq->rcv_dma;
#line 4458
  mcp->mb[17] = (unsigned short )((unsigned int )mreq->rcv_dma >> 16);
#line 4459
  mcp->mb[6] = (unsigned short )(mreq->rcv_dma >> 32ULL);
#line 4460
  mcp->mb[7] = (unsigned short )((unsigned int )(mreq->rcv_dma >> 32ULL) >> 16);
#line 4463
  mcp->mb[18] = (unsigned short )mreq->iteration_count;
#line 4464
  mcp->mb[19] = (unsigned short )(mreq->iteration_count >> 16);
#line 4466
  mcp->out_mb = 4193475U;
#line 4468
  if (((((vha->hw)->device_type & 8192U) != 0U || ((vha->hw)->device_type & 16384U) != 0U) || ((vha->hw)->device_type & 65536U) != 0U) || ((vha->hw)->device_type & 262144U) != 0U) {
#line 4469
    mcp->out_mb = mcp->out_mb | 4U;
  } else {

  }
#line 4470
  mcp->in_mb = 786447U;
#line 4472
  mcp->buf_size = (long )mreq->transfer_size;
#line 4473
  mcp->tov = 30U;
#line 4474
  mcp->flags = 7U;
#line 4476
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4478
  if (rval != 0) {
#line 4479
    ql_dbg(536870912U, vha, 4344, "Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x mb[3]=%x mb[18]=%x mb[19]=%x.\n",
           rval, (int )mcp->mb[0], (int )mcp->mb[1], (int )mcp->mb[2], (int )mcp->mb[3],
           (int )mcp->mb[18], (int )mcp->mb[19]);
  } else {
#line 4484
    ql_dbg(536903680U, vha, 4345, "Done %s.\n", "qla2x00_loopback_test");
  }
#line 4489
  memcpy((void *)mresp, (void const   *)(& mcp->mb), 64UL);
#line 4490
  return (rval);
}
}
#line 4494 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_echo_test(scsi_qla_host_t *vha , struct msg_echo_lb *mreq , uint16_t *mresp ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;

  {
#line 4499
  mcp = & mc;
#line 4500
  ha = vha->hw;
#line 4502
  ql_dbg(536903680U, vha, 4346, "Entered %s.\n", "qla2x00_echo_test");
#line 4505
  memset((void *)(& mcp->mb), 0, 64UL);
#line 4506
  mcp->mb[0] = 68U;
#line 4507
  mcp->mb[1] = (uint16_t )((unsigned int )mreq->options | 64U);
#line 4508
  if ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 4509
    mcp->mb[1] = (uint16_t )((unsigned int )mcp->mb[1] | 32768U);
#line 4510
    mcp->mb[2] = vha->fcoe_fcf_idx;
  } else {

  }
#line 4512
  mcp->mb[16] = (unsigned short )mreq->rcv_dma;
#line 4513
  mcp->mb[17] = (unsigned short )((unsigned int )mreq->rcv_dma >> 16);
#line 4514
  mcp->mb[6] = (unsigned short )(mreq->rcv_dma >> 32ULL);
#line 4515
  mcp->mb[7] = (unsigned short )((unsigned int )(mreq->rcv_dma >> 32ULL) >> 16);
#line 4517
  mcp->mb[10] = (unsigned short )mreq->transfer_size;
#line 4519
  mcp->mb[14] = (unsigned short )mreq->send_dma;
#line 4520
  mcp->mb[15] = (unsigned short )((unsigned int )mreq->send_dma >> 16);
#line 4521
  mcp->mb[20] = (unsigned short )(mreq->send_dma >> 32ULL);
#line 4522
  mcp->mb[21] = (unsigned short )((unsigned int )(mreq->send_dma >> 32ULL) >> 16);
#line 4524
  mcp->out_mb = 3392707U;
#line 4526
  if ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 4527
    mcp->out_mb = mcp->out_mb | 4U;
  } else {

  }
#line 4529
  mcp->in_mb = 1U;
#line 4530
  if (((((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || ((ha->device_type & 512U) != 0U || (ha->device_type & 1024U) != 0U)) || (ha->device_type & 4096U) != 0U) || (ha->device_type & 2048U) != 0U) || ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U)) || (ha->device_type & 32768U) != 0U) {
#line 4532
    mcp->in_mb = mcp->in_mb | 2U;
  } else {

  }
#line 4533
  if (((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) || (ha->device_type & 32768U) != 0U) {
#line 4534
    mcp->in_mb = mcp->in_mb | 8U;
  } else {

  }
#line 4536
  mcp->tov = 30U;
#line 4537
  mcp->flags = 7U;
#line 4538
  mcp->buf_size = (long )mreq->transfer_size;
#line 4540
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4542
  if (rval != 0) {
#line 4543
    ql_dbg(536870912U, vha, 4347, "Failed=%x mb[0]=%x mb[1]=%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 4547
    ql_dbg(536903680U, vha, 4348, "Done %s.\n", "qla2x00_echo_test");
  }
#line 4552
  memcpy((void *)mresp, (void const   *)(& mcp->mb), 64UL);
#line 4553
  return (rval);
}
}
#line 4557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla84xx_reset_chip(scsi_qla_host_t *vha , uint16_t enable_diagnostic ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 4561
  mcp = & mc;
#line 4563
  ql_dbg(536903680U, vha, 4349, "Entered %s enable_diag=%d.\n", "qla84xx_reset_chip",
         (int )enable_diagnostic);
#line 4566
  mcp->mb[0] = 58U;
#line 4567
  mcp->mb[1] = enable_diagnostic;
#line 4568
  mcp->out_mb = 3U;
#line 4569
  mcp->in_mb = 3U;
#line 4570
  mcp->tov = 30U;
#line 4571
  mcp->flags = 7U;
#line 4572
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4574
  if (rval != 0) {
#line 4575
    ql_dbg(536870912U, vha, 4350, "Failed=%x.\n", rval);
  } else {
#line 4577
    ql_dbg(536903680U, vha, 4351, "Done %s.\n", "qla84xx_reset_chip");
  }
#line 4580
  return (rval);
}
}
#line 4584 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_write_ram_word(scsi_qla_host_t *vha , uint32_t risc_addr , uint32_t data ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 4588
  mcp = & mc;
#line 4590
  ql_dbg(536903680U, vha, 4352, "Entered %s.\n", "qla2x00_write_ram_word");
#line 4593
  if (((vha->hw)->device_type & 134217728U) == 0U) {
#line 4594
    return (258);
  } else {

  }
#line 4596
  mcp->mb[0] = 13U;
#line 4597
  mcp->mb[1] = (unsigned short )risc_addr;
#line 4598
  mcp->mb[2] = (unsigned short )data;
#line 4599
  mcp->mb[3] = (unsigned short )(data >> 16);
#line 4600
  mcp->mb[8] = (unsigned short )(risc_addr >> 16);
#line 4601
  mcp->out_mb = 271U;
#line 4602
  mcp->in_mb = 1U;
#line 4603
  mcp->tov = 30U;
#line 4604
  mcp->flags = 0U;
#line 4605
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4606
  if (rval != 0) {
#line 4607
    ql_dbg(536870912U, vha, 4353, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 4610
    ql_dbg(536903680U, vha, 4354, "Done %s.\n", "qla2x00_write_ram_word");
  }
#line 4614
  return (rval);
}
}
#line 4618 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla81xx_write_mpi_register(scsi_qla_host_t *vha , uint16_t *mb ) 
{ 
  int rval ;
  uint32_t stat ;
  uint32_t timer ;
  uint16_t mb0 ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  int tmp ;

  {
#line 4622
  mb0 = 0U;
#line 4623
  ha = vha->hw;
#line 4624
  reg = & (ha->iobase)->isp24;
#line 4626
  rval = 0;
#line 4628
  ql_dbg(536903680U, vha, 4355, "Entered %s.\n", "qla81xx_write_mpi_register");
#line 4631
  clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 4634
  writew(1, (void volatile   *)(& reg->mailbox0));
#line 4635
  writew((int )*mb, (void volatile   *)(& reg->mailbox1));
#line 4636
  writew((int )*(mb + 1UL), (void volatile   *)(& reg->mailbox2));
#line 4637
  writew((int )*(mb + 2UL), (void volatile   *)(& reg->mailbox3));
#line 4638
  writew((int )*(mb + 3UL), (void volatile   *)(& reg->mailbox4));
#line 4640
  writel(1342177280U, (void volatile   *)(& reg->hccr));
#line 4643
  timer = 6000000U;
#line 4643
  goto ldv_66663;
  ldv_66662: 
#line 4645
  stat = readl((void const volatile   *)(& reg->host_status));
#line 4646
  if ((stat & 32768U) != 0U) {
#line 4647
    stat = stat & 255U;
#line 4649
    if (((stat == 1U || stat == 2U) || stat == 16U) || stat == 17U) {
#line 4651
      set_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 4653
      mb0 = readw((void const volatile   *)(& reg->mailbox0));
#line 4654
      writel(2684354560U, (void volatile   *)(& reg->hccr));
#line 4656
      readl((void const volatile   *)(& reg->hccr));
#line 4657
      goto ldv_66661;
    } else {

    }
  } else {

  }
#line 4660
  __const_udelay(21475UL);
#line 4643
  timer = timer - 1U;
  ldv_66663: ;
#line 4643
  if (timer != 0U) {
#line 4645
    goto ldv_66662;
  } else {

  }
  ldv_66661: 
#line 4663
  tmp = test_and_clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 4663
  if (tmp != 0) {
#line 4664
    rval = (int )mb0 & 16383;
  } else {
#line 4666
    rval = 258;
  }
#line 4668
  if (rval != 0) {
#line 4669
    ql_dbg(536870912U, vha, 4356, "Failed=%x mb[0]=%x.\n", rval, (int )*mb);
  } else {
#line 4672
    ql_dbg(536903680U, vha, 4357, "Done %s.\n", "qla81xx_write_mpi_register");
  }
#line 4676
  return (rval);
}
}
#line 4680 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_get_data_rate(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;

  {
#line 4684
  mcp = & mc;
#line 4685
  ha = vha->hw;
#line 4687
  ql_dbg(536903680U, vha, 4358, "Entered %s.\n", "qla2x00_get_data_rate");
#line 4690
  if ((ha->device_type & 134217728U) == 0U) {
#line 4691
    return (258);
  } else {

  }
#line 4693
  mcp->mb[0] = 93U;
#line 4694
  mcp->mb[1] = 0U;
#line 4695
  mcp->out_mb = 3U;
#line 4696
  mcp->in_mb = 7U;
#line 4697
  if (((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 4698
    mcp->in_mb = mcp->in_mb | 8U;
  } else {

  }
#line 4699
  mcp->tov = 30U;
#line 4700
  mcp->flags = 0U;
#line 4701
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4702
  if (rval != 0) {
#line 4703
    ql_dbg(536870912U, vha, 4359, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 4706
    ql_dbg(536903680U, vha, 4360, "Done %s.\n", "qla2x00_get_data_rate");
#line 4708
    if ((unsigned int )mcp->mb[1] != 7U) {
#line 4709
      ha->link_data_rate = mcp->mb[1];
    } else {

    }
  }
#line 4712
  return (rval);
}
}
#line 4716 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla81xx_get_port_config(scsi_qla_host_t *vha , uint16_t *mb ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;

  {
#line 4720
  mcp = & mc;
#line 4721
  ha = vha->hw;
#line 4723
  ql_dbg(536903680U, vha, 4361, "Entered %s.\n", "qla81xx_get_port_config");
#line 4726
  if ((((ha->device_type & 8192U) == 0U && ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U)) && (ha->device_type & 262144U) == 0U) && ((ha->device_type & 524288U) == 0U && (ha->device_type & 1048576U) == 0U)) {
#line 4728
    return (258);
  } else {

  }
#line 4729
  mcp->mb[0] = 291U;
#line 4730
  mcp->out_mb = 1U;
#line 4731
  mcp->in_mb = 31U;
#line 4732
  mcp->tov = 30U;
#line 4733
  mcp->flags = 0U;
#line 4735
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4737
  if (rval != 0) {
#line 4738
    ql_dbg(536870912U, vha, 4362, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 4742
    memcpy((void *)mb, (void const   *)(& mcp->mb) + 1U, 8UL);
#line 4744
    ql_dbg(536903680U, vha, 4363, "Done %s.\n", "qla81xx_get_port_config");
  }
#line 4747
  return (rval);
}
}
#line 4751 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla81xx_set_port_config(scsi_qla_host_t *vha , uint16_t *mb ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 4755
  mcp = & mc;
#line 4757
  ql_dbg(536903680U, vha, 4364, "Entered %s.\n", "qla81xx_set_port_config");
#line 4760
  mcp->mb[0] = 290U;
#line 4762
  memcpy((void *)(& mcp->mb) + 1U, (void const   *)mb, 8UL);
#line 4763
  mcp->out_mb = 31U;
#line 4764
  mcp->in_mb = 1U;
#line 4765
  mcp->tov = 30U;
#line 4766
  mcp->flags = 0U;
#line 4767
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4769
  if (rval != 0) {
#line 4770
    ql_dbg(536870912U, vha, 4365, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 4773
    ql_dbg(536903680U, vha, 4366, "Done %s.\n", "qla81xx_set_port_config");
  }
#line 4776
  return (rval);
}
}
#line 4781 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla24xx_set_fcp_prio(scsi_qla_host_t *vha , uint16_t loop_id , uint16_t priority ,
                         uint16_t *mb ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;

  {
#line 4786
  mcp = & mc;
#line 4787
  ha = vha->hw;
#line 4789
  ql_dbg(536903680U, vha, 4367, "Entered %s.\n", "qla24xx_set_fcp_prio");
#line 4792
  if (((((ha->device_type & 128U) == 0U && (ha->device_type & 256U) == 0U) && ((ha->device_type & 512U) == 0U && (ha->device_type & 1024U) == 0U)) && (ha->device_type & 4096U) == 0U) && (ha->device_type & 2048U) == 0U) {
#line 4793
    return (258);
  } else {

  }
#line 4795
  mcp->mb[0] = 26U;
#line 4796
  mcp->mb[1] = loop_id;
#line 4797
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 4798
    mcp->mb[2] = 2U;
  } else {
#line 4800
    mcp->mb[2] = 4U;
  }
#line 4801
  mcp->mb[4] = (unsigned int )priority & 15U;
#line 4802
  mcp->mb[9] = vha->vp_idx;
#line 4803
  mcp->out_mb = 543U;
#line 4804
  mcp->in_mb = 27U;
#line 4805
  mcp->tov = 30U;
#line 4806
  mcp->flags = 0U;
#line 4807
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4808
  if ((unsigned long )mb != (unsigned long )((uint16_t *)0U)) {
#line 4809
    *mb = mcp->mb[0];
#line 4810
    *(mb + 1UL) = mcp->mb[1];
#line 4811
    *(mb + 3UL) = mcp->mb[3];
#line 4812
    *(mb + 4UL) = mcp->mb[4];
  } else {

  }
#line 4815
  if (rval != 0) {
#line 4816
    ql_dbg(536870912U, vha, 4301, "Failed=%x.\n", rval);
  } else {
#line 4818
    ql_dbg(536903680U, vha, 4300, "Done %s.\n", "qla24xx_set_fcp_prio");
  }
#line 4822
  return (rval);
}
}
#line 4826 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_get_thermal_temp(scsi_qla_host_t *vha , uint16_t *temp ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  uint8_t byte ;
  int tmp ;
  int tmp___0 ;

  {
#line 4828
  rval = 258;
#line 4829
  ha = vha->hw;
#line 4832
  if (((ha->device_type & 134217728U) == 0U || ((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || ((ha->device_type & 512U) != 0U || (ha->device_type & 1024U) != 0U)) || (ha->device_type & 4096U) != 0U)) || (ha->device_type & 8192U) != 0U) {
#line 4833
    ql_dbg(536870912U, vha, 4432, "Thermal not supported by this card.\n");
#line 4835
    return (rval);
  } else {

  }
#line 4838
  if ((ha->device_type & 2048U) != 0U) {
#line 4839
    if ((unsigned int )(ha->pdev)->subsystem_vendor == 4215U && (unsigned int )(ha->pdev)->subsystem_device == 373U) {
#line 4841
      rval = qla2x00_read_sfp(vha, 0ULL, & byte, 152, 1, 1, 8193);
#line 4843
      *temp = (uint16_t )byte;
#line 4844
      return (rval);
    } else {

    }
#line 4846
    if ((unsigned int )(ha->pdev)->subsystem_vendor == 4156U && (unsigned int )(ha->pdev)->subsystem_device == 13198U) {
#line 4848
      rval = qla2x00_read_sfp(vha, 0ULL, & byte, 152, 1, 1, 49153);
#line 4850
      *temp = (uint16_t )byte;
#line 4851
      return (rval);
    } else {

    }
#line 4853
    ql_dbg(536870912U, vha, 4297, "Thermal not supported by this card.\n");
#line 4855
    return (rval);
  } else {

  }
#line 4858
  if ((ha->device_type & 16384U) != 0U) {
#line 4859
    tmp = qla82xx_read_temperature(vha);
#line 4859
    *temp = (uint16_t )tmp;
#line 4860
    rval = 0;
#line 4861
    return (rval);
  } else
#line 4862
  if ((ha->device_type & 262144U) != 0U) {
#line 4863
    tmp___0 = qla8044_read_temperature(vha);
#line 4863
    *temp = (uint16_t )tmp___0;
#line 4864
    rval = 0;
#line 4865
    return (rval);
  } else {

  }
#line 4868
  rval = qla2x00_read_asic_temperature(vha, temp);
#line 4869
  return (rval);
}
}
#line 4873 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla82xx_mbx_intr_enable(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 4876
  ha = vha->hw;
#line 4878
  mcp = & mc;
#line 4880
  ql_dbg(536903680U, vha, 4119, "Entered %s.\n", "qla82xx_mbx_intr_enable");
#line 4883
  if ((ha->device_type & 134217728U) == 0U) {
#line 4884
    return (258);
  } else {

  }
#line 4886
  memset((void *)mcp, 0, 96UL);
#line 4887
  mcp->mb[0] = 16U;
#line 4888
  mcp->mb[1] = 1U;
#line 4890
  mcp->out_mb = 3U;
#line 4891
  mcp->in_mb = 1U;
#line 4892
  mcp->tov = 30U;
#line 4893
  mcp->flags = 0U;
#line 4895
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4896
  if (rval != 0) {
#line 4897
    ql_dbg(536870912U, vha, 4118, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 4900
    ql_dbg(536903680U, vha, 4110, "Done %s.\n", "qla82xx_mbx_intr_enable");
  }
#line 4904
  return (rval);
}
}
#line 4908 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla82xx_mbx_intr_disable(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 4911
  ha = vha->hw;
#line 4913
  mcp = & mc;
#line 4915
  ql_dbg(536903680U, vha, 4109, "Entered %s.\n", "qla82xx_mbx_intr_disable");
#line 4918
  if ((ha->device_type & 16384U) == 0U && (ha->device_type & 262144U) == 0U) {
#line 4919
    return (258);
  } else {

  }
#line 4921
  memset((void *)mcp, 0, 96UL);
#line 4922
  mcp->mb[0] = 16U;
#line 4923
  mcp->mb[1] = 0U;
#line 4925
  mcp->out_mb = 3U;
#line 4926
  mcp->in_mb = 1U;
#line 4927
  mcp->tov = 30U;
#line 4928
  mcp->flags = 0U;
#line 4930
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4931
  if (rval != 0) {
#line 4932
    ql_dbg(536870912U, vha, 4108, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 4935
    ql_dbg(536903680U, vha, 4107, "Done %s.\n", "qla82xx_mbx_intr_disable");
  }
#line 4939
  return (rval);
}
}
#line 4943 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla82xx_md_get_template_size(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  int rval ;

  {
#line 4945
  ha = vha->hw;
#line 4947
  mcp = & mc;
#line 4948
  rval = 258;
#line 4950
  ql_dbg(536903680U, vha, 4383, "Entered %s.\n", "qla82xx_md_get_template_size");
#line 4953
  memset((void *)(& mcp->mb), 0, 64UL);
#line 4954
  mcp->mb[0] = 297U;
#line 4955
  mcp->mb[1] = 0U;
#line 4956
  mcp->mb[2] = 0U;
#line 4957
  mcp->mb[3] = 0U;
#line 4959
  mcp->out_mb = 15U;
#line 4960
  mcp->in_mb = 32767U;
#line 4963
  mcp->flags = 7U;
#line 4964
  mcp->tov = 30U;
#line 4965
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4968
  if (rval != 0) {
#line 4969
    ql_dbg(536870912U, vha, 4384, "mailbox command FAILED=0x%x, subcode=%x.\n", ((int )mcp->mb[1] << 16) | (int )mcp->mb[0],
           ((int )mcp->mb[3] << 16) | (int )mcp->mb[2]);
  } else {
#line 4974
    ql_dbg(536903680U, vha, 4385, "Done %s.\n", "qla82xx_md_get_template_size");
#line 4976
    ha->md_template_size = (uint32_t )(((int )mcp->mb[3] << 16) | (int )mcp->mb[2]);
#line 4977
    if (ha->md_template_size == 0U) {
#line 4978
      ql_dbg(536870912U, vha, 4386, "Null template size obtained.\n");
#line 4980
      rval = 258;
    } else {

    }
  }
#line 4983
  return (rval);
}
}
#line 4987 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla82xx_md_get_template(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  int rval ;

  {
#line 4989
  ha = vha->hw;
#line 4991
  mcp = & mc;
#line 4992
  rval = 258;
#line 4994
  ql_dbg(536903680U, vha, 4387, "Entered %s.\n", "qla82xx_md_get_template");
#line 4997
  ha->md_tmplt_hdr = dma_alloc_attrs(& (ha->pdev)->dev, (size_t )ha->md_template_size,
                                     & ha->md_tmplt_hdr_dma, 208U, (struct dma_attrs *)0);
#line 4999
  if ((unsigned long )ha->md_tmplt_hdr == (unsigned long )((void *)0)) {
#line 5000
    ql_log(1U, vha, 4388, "Unable to allocate memory for Minidump template.\n");
#line 5002
    return (rval);
  } else {

  }
#line 5005
  memset((void *)(& mcp->mb), 0, 64UL);
#line 5006
  mcp->mb[0] = 297U;
#line 5007
  mcp->mb[1] = 0U;
#line 5008
  mcp->mb[2] = 1U;
#line 5009
  mcp->mb[3] = 0U;
#line 5010
  mcp->mb[4] = (unsigned short )ha->md_tmplt_hdr_dma;
#line 5011
  mcp->mb[5] = (unsigned short )((unsigned int )ha->md_tmplt_hdr_dma >> 16);
#line 5012
  mcp->mb[6] = (unsigned short )(ha->md_tmplt_hdr_dma >> 32ULL);
#line 5013
  mcp->mb[7] = (unsigned short )((unsigned int )(ha->md_tmplt_hdr_dma >> 32ULL) >> 16);
#line 5014
  mcp->mb[8] = (unsigned short )ha->md_template_size;
#line 5015
  mcp->mb[9] = (unsigned short )(ha->md_template_size >> 16);
#line 5017
  mcp->flags = 7U;
#line 5018
  mcp->tov = 30U;
#line 5019
  mcp->out_mb = 4095U;
#line 5021
  mcp->in_mb = 15U;
#line 5022
  rval = qla2x00_mailbox_command(vha, mcp);
#line 5024
  if (rval != 0) {
#line 5025
    ql_dbg(536870912U, vha, 4389, "mailbox command FAILED=0x%x, subcode=%x.\n", ((int )mcp->mb[1] << 16) | (int )mcp->mb[0],
           ((int )mcp->mb[3] << 16) | (int )mcp->mb[2]);
  } else {
#line 5030
    ql_dbg(536903680U, vha, 4390, "Done %s.\n", "qla82xx_md_get_template");
  }
#line 5032
  return (rval);
}
}
#line 5036 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla8044_md_get_template(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  int rval ;
  int offset ;
  int size ;

  {
#line 5038
  ha = vha->hw;
#line 5040
  mcp = & mc;
#line 5041
  rval = 258;
#line 5042
  offset = 0;
#line 5042
  size = 36864;
#line 5043
  ql_dbg(536903680U, vha, 45343, "Entered %s.\n", "qla8044_md_get_template");
#line 5046
  ha->md_tmplt_hdr = dma_alloc_attrs(& (ha->pdev)->dev, (size_t )ha->md_template_size,
                                     & ha->md_tmplt_hdr_dma, 208U, (struct dma_attrs *)0);
#line 5048
  if ((unsigned long )ha->md_tmplt_hdr == (unsigned long )((void *)0)) {
#line 5049
    ql_log(1U, vha, 45339, "Unable to allocate memory for Minidump template.\n");
#line 5051
    return (rval);
  } else {

  }
#line 5054
  memset((void *)(& mcp->mb), 0, 64UL);
#line 5055
  goto ldv_66750;
  ldv_66749: 
#line 5056
  mcp->mb[0] = 297U;
#line 5057
  mcp->mb[1] = 0U;
#line 5058
  mcp->mb[2] = 1U;
#line 5059
  mcp->mb[3] = 0U;
#line 5060
  mcp->mb[4] = (int )((unsigned short )ha->md_tmplt_hdr_dma) + (int )((unsigned short )offset);
#line 5061
  mcp->mb[5] = (unsigned short )(((unsigned int )ha->md_tmplt_hdr_dma + (unsigned int )offset) >> 16);
#line 5062
  mcp->mb[6] = (unsigned short )((ha->md_tmplt_hdr_dma + (dma_addr_t )offset) >> 32ULL);
#line 5063
  mcp->mb[7] = (unsigned short )((unsigned int )((ha->md_tmplt_hdr_dma + (dma_addr_t )offset) >> 32ULL) >> 16);
#line 5064
  mcp->mb[8] = (unsigned short )size;
#line 5065
  mcp->mb[9] = (unsigned short )((unsigned int )size >> 16);
#line 5066
  mcp->mb[10] = (uint16_t )offset;
#line 5067
  mcp->mb[11] = 0U;
#line 5068
  mcp->flags = 7U;
#line 5069
  mcp->tov = 30U;
#line 5070
  mcp->out_mb = 4095U;
#line 5072
  mcp->in_mb = 15U;
#line 5073
  rval = qla2x00_mailbox_command(vha, mcp);
#line 5075
  if (rval != 0) {
#line 5076
    ql_dbg(536870912U, vha, 45340, "mailbox command FAILED=0x%x, subcode=%x.\n", ((int )mcp->mb[1] << 16) | (int )mcp->mb[0],
           ((int )mcp->mb[3] << 16) | (int )mcp->mb[2]);
#line 5080
    return (rval);
  } else {
#line 5082
    ql_dbg(536903680U, vha, 45341, "Done %s.\n", "qla8044_md_get_template");
  }
#line 5084
  offset = offset + size;
  ldv_66750: ;
#line 5055
  if ((uint32_t )offset < ha->md_template_size) {
#line 5057
    goto ldv_66749;
  } else {

  }

#line 5086
  return (rval);
}
}
#line 5090 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla81xx_set_led_config(scsi_qla_host_t *vha , uint16_t *led_cfg ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 5093
  ha = vha->hw;
#line 5095
  mcp = & mc;
#line 5097
  if ((ha->device_type & 8192U) == 0U && (ha->device_type & 65536U) == 0U) {
#line 5098
    return (258);
  } else {

  }
#line 5100
  ql_dbg(536903680U, vha, 4403, "Entered %s.\n", "qla81xx_set_led_config");
#line 5103
  memset((void *)mcp, 0, 96UL);
#line 5104
  mcp->mb[0] = 293U;
#line 5105
  mcp->mb[1] = *led_cfg;
#line 5106
  mcp->mb[2] = *(led_cfg + 1UL);
#line 5107
  if ((ha->device_type & 65536U) != 0U) {
#line 5108
    mcp->mb[3] = *(led_cfg + 2UL);
#line 5109
    mcp->mb[4] = *(led_cfg + 3UL);
#line 5110
    mcp->mb[5] = *(led_cfg + 4UL);
#line 5111
    mcp->mb[6] = *(led_cfg + 5UL);
  } else {

  }
#line 5114
  mcp->out_mb = 7U;
#line 5115
  if ((ha->device_type & 65536U) != 0U) {
#line 5116
    mcp->out_mb = mcp->out_mb | 120U;
  } else {

  }
#line 5117
  mcp->in_mb = 1U;
#line 5118
  mcp->tov = 30U;
#line 5119
  mcp->flags = 0U;
#line 5121
  rval = qla2x00_mailbox_command(vha, mcp);
#line 5122
  if (rval != 0) {
#line 5123
    ql_dbg(536870912U, vha, 4404, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 5126
    ql_dbg(536903680U, vha, 4405, "Done %s.\n", "qla81xx_set_led_config");
  }
#line 5130
  return (rval);
}
}
#line 5134 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla81xx_get_led_config(scsi_qla_host_t *vha , uint16_t *led_cfg ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 5137
  ha = vha->hw;
#line 5139
  mcp = & mc;
#line 5141
  if ((ha->device_type & 8192U) == 0U && (ha->device_type & 65536U) == 0U) {
#line 5142
    return (258);
  } else {

  }
#line 5144
  ql_dbg(536903680U, vha, 4406, "Entered %s.\n", "qla81xx_get_led_config");
#line 5147
  memset((void *)mcp, 0, 96UL);
#line 5148
  mcp->mb[0] = 294U;
#line 5150
  mcp->out_mb = 1U;
#line 5151
  mcp->in_mb = 7U;
#line 5152
  if ((ha->device_type & 65536U) != 0U) {
#line 5153
    mcp->in_mb = mcp->in_mb | 120U;
  } else {

  }
#line 5154
  mcp->tov = 30U;
#line 5155
  mcp->flags = 0U;
#line 5157
  rval = qla2x00_mailbox_command(vha, mcp);
#line 5158
  if (rval != 0) {
#line 5159
    ql_dbg(536870912U, vha, 4407, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 5162
    *led_cfg = mcp->mb[1];
#line 5163
    *(led_cfg + 1UL) = mcp->mb[2];
#line 5164
    if ((ha->device_type & 65536U) != 0U) {
#line 5165
      *(led_cfg + 2UL) = mcp->mb[3];
#line 5166
      *(led_cfg + 3UL) = mcp->mb[4];
#line 5167
      *(led_cfg + 4UL) = mcp->mb[5];
#line 5168
      *(led_cfg + 5UL) = mcp->mb[6];
    } else {

    }
#line 5170
    ql_dbg(536903680U, vha, 4408, "Done %s.\n", "qla81xx_get_led_config");
  }
#line 5174
  return (rval);
}
}
#line 5178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla82xx_mbx_beacon_ctl(scsi_qla_host_t *vha , int enable ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 5181
  ha = vha->hw;
#line 5183
  mcp = & mc;
#line 5185
  if ((ha->device_type & 16384U) == 0U && (ha->device_type & 262144U) == 0U) {
#line 5186
    return (258);
  } else {

  }
#line 5188
  ql_dbg(536903680U, vha, 4391, "Entered %s.\n", "qla82xx_mbx_beacon_ctl");
#line 5191
  memset((void *)mcp, 0, 96UL);
#line 5192
  mcp->mb[0] = 293U;
#line 5193
  if (enable != 0) {
#line 5194
    mcp->mb[7] = 14U;
  } else {
#line 5196
    mcp->mb[7] = 13U;
  }
#line 5198
  mcp->out_mb = 129U;
#line 5199
  mcp->in_mb = 1U;
#line 5200
  mcp->tov = 30U;
#line 5201
  mcp->flags = 0U;
#line 5203
  rval = qla2x00_mailbox_command(vha, mcp);
#line 5204
  if (rval != 0) {
#line 5205
    ql_dbg(536870912U, vha, 4392, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 5208
    ql_dbg(536903680U, vha, 4393, "Done %s.\n", "qla82xx_mbx_beacon_ctl");
  }
#line 5212
  return (rval);
}
}
#line 5216 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla83xx_wr_reg(scsi_qla_host_t *vha , uint32_t reg , uint32_t data ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 5219
  ha = vha->hw;
#line 5221
  mcp = & mc;
#line 5223
  if (((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U) && ((ha->device_type & 524288U) == 0U && (ha->device_type & 1048576U) == 0U)) {
#line 5224
    return (258);
  } else {

  }
#line 5226
  ql_dbg(536903680U, vha, 4400, "Entered %s.\n", "qla83xx_wr_reg");
#line 5229
  mcp->mb[0] = 1U;
#line 5230
  mcp->mb[1] = (unsigned short )reg;
#line 5231
  mcp->mb[2] = (unsigned short )(reg >> 16);
#line 5232
  mcp->mb[3] = (unsigned short )data;
#line 5233
  mcp->mb[4] = (unsigned short )(data >> 16);
#line 5234
  mcp->out_mb = 31U;
#line 5236
  mcp->in_mb = 3U;
#line 5237
  mcp->tov = 30U;
#line 5238
  mcp->flags = 0U;
#line 5239
  rval = qla2x00_mailbox_command(vha, mcp);
#line 5241
  if (rval != 0) {
#line 5242
    ql_dbg(536870912U, vha, 4401, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 5245
    ql_dbg(536903680U, vha, 4402, "Done %s.\n", "qla83xx_wr_reg");
  }
#line 5249
  return (rval);
}
}
#line 5253 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_port_logout(scsi_qla_host_t *vha , struct fc_port *fcport ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 5256
  ha = vha->hw;
#line 5258
  mcp = & mc;
#line 5260
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 5261
    ql_dbg(536903680U, vha, 4411, "Implicit LOGO Unsupported.\n");
#line 5263
    return (258);
  } else {

  }
#line 5267
  ql_dbg(536903680U, vha, 4412, "Entering %s.\n", "qla2x00_port_logout");
#line 5271
  mcp->mb[0] = 86U;
#line 5272
  mcp->mb[1] = fcport->loop_id;
#line 5273
  mcp->mb[10] = 32768U;
#line 5274
  mcp->out_mb = 1027U;
#line 5275
  mcp->in_mb = 1U;
#line 5276
  mcp->tov = 30U;
#line 5277
  mcp->flags = 0U;
#line 5278
  rval = qla2x00_mailbox_command(vha, mcp);
#line 5279
  if (rval != 0) {
#line 5280
    ql_dbg(536870912U, vha, 4413, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 5283
    ql_dbg(536903680U, vha, 4414, "Done %s.\n", "qla2x00_port_logout");
  }
#line 5286
  return (rval);
}
}
#line 5290 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla83xx_rd_reg(scsi_qla_host_t *vha , uint32_t reg , uint32_t *data ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;
  unsigned long retry_max_time ;

  {
#line 5294
  mcp = & mc;
#line 5295
  ha = vha->hw;
#line 5296
  retry_max_time = (unsigned long )jiffies + 500UL;
#line 5298
  if (((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U) && ((ha->device_type & 524288U) == 0U && (ha->device_type & 1048576U) == 0U)) {
#line 5299
    return (258);
  } else {

  }
#line 5301
  ql_dbg(536870912U, vha, 4427, "Entered %s.\n", "qla83xx_rd_reg");
  retry_rd_reg: 
#line 5304
  mcp->mb[0] = 9U;
#line 5305
  mcp->mb[1] = (unsigned short )reg;
#line 5306
  mcp->mb[2] = (unsigned short )(reg >> 16);
#line 5307
  mcp->out_mb = 7U;
#line 5308
  mcp->in_mb = 27U;
#line 5309
  mcp->tov = 30U;
#line 5310
  mcp->flags = 0U;
#line 5311
  rval = qla2x00_mailbox_command(vha, mcp);
#line 5313
  if (rval != 0) {
#line 5314
    ql_dbg(536870912U, vha, 4428, "Failed=%x mb[0]=%x mb[1]=%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 5318
    *data = (uint32_t )((int )mcp->mb[3] | ((int )mcp->mb[4] << 16));
#line 5319
    if (*data == 3134241488U) {
#line 5325
      if ((long )(retry_max_time - (unsigned long )jiffies) < 0L) {
#line 5326
        ql_dbg(536870912U, vha, 4417, "Failure to read CAMRAM register. data=0x%x.\n",
               *data);
#line 5329
        return (258);
      } else {

      }
#line 5331
      msleep(100U);
#line 5332
      goto retry_rd_reg;
    } else {

    }
#line 5334
    ql_dbg(536870912U, vha, 4418, "Done %s.\n", "qla83xx_rd_reg");
  }
#line 5337
  return (rval);
}
}
#line 5341 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla83xx_restart_nic_firmware(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;

  {
#line 5345
  mcp = & mc;
#line 5346
  ha = vha->hw;
#line 5348
  if ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U) {
#line 5349
    return (258);
  } else {

  }
#line 5351
  ql_dbg(536870912U, vha, 4419, "Entered %s.\n", "qla83xx_restart_nic_firmware");
#line 5353
  mcp->mb[0] = 61U;
#line 5354
  mcp->out_mb = 1U;
#line 5355
  mcp->in_mb = 3U;
#line 5356
  mcp->tov = 30U;
#line 5357
  mcp->flags = 0U;
#line 5358
  rval = qla2x00_mailbox_command(vha, mcp);
#line 5360
  if (rval != 0) {
#line 5361
    ql_dbg(536870912U, vha, 4420, "Failed=%x mb[0]=%x mb[1]=%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
#line 5364
    (*((ha->isp_ops)->fw_dump))(vha, 0);
  } else {
#line 5366
    ql_dbg(536870912U, vha, 4421, "Done %s.\n", "qla83xx_restart_nic_firmware");
  }
#line 5369
  return (rval);
}
}
#line 5373 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla83xx_access_control(scsi_qla_host_t *vha , uint16_t options , uint32_t start_addr ,
                           uint32_t end_addr , uint16_t *sector_size ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  uint8_t subcode ;
  struct qla_hw_data *ha ;

  {
#line 5378
  mcp = & mc;
#line 5379
  subcode = (unsigned char )options;
#line 5380
  ha = vha->hw;
#line 5382
  if ((ha->device_type & 65536U) == 0U) {
#line 5383
    return (258);
  } else {

  }
#line 5385
  ql_dbg(536870912U, vha, 4422, "Entered %s.\n", "qla83xx_access_control");
#line 5387
  mcp->mb[0] = 62U;
#line 5388
  mcp->mb[1] = options;
#line 5389
  mcp->out_mb = 3U;
#line 5390
  if (((int )subcode & 4) != 0) {
#line 5391
    mcp->mb[2] = (unsigned short )start_addr;
#line 5392
    mcp->mb[3] = (unsigned short )(start_addr >> 16);
#line 5393
    mcp->mb[4] = (unsigned short )end_addr;
#line 5394
    mcp->mb[5] = (unsigned short )(end_addr >> 16);
#line 5395
    mcp->out_mb = mcp->out_mb | 60U;
  } else {

  }
#line 5397
  mcp->in_mb = 7U;
#line 5398
  if (((int )subcode & 36) == 0) {
#line 5399
    mcp->in_mb = mcp->in_mb | 24U;
  } else {

  }
#line 5400
  mcp->tov = 30U;
#line 5401
  mcp->flags = 0U;
#line 5402
  rval = qla2x00_mailbox_command(vha, mcp);
#line 5404
  if (rval != 0) {
#line 5405
    ql_dbg(536870912U, vha, 4423, "Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x mb[3]=%x mb[4]=%x.\n",
           rval, (int )mcp->mb[0], (int )mcp->mb[1], (int )mcp->mb[2], (int )mcp->mb[3],
           (int )mcp->mb[4]);
#line 5409
    (*((ha->isp_ops)->fw_dump))(vha, 0);
  } else {
#line 5411
    if (((int )subcode & 32) != 0) {
#line 5412
      *sector_size = mcp->mb[1];
    } else
#line 5413
    if (((int )subcode & 192) != 0) {
#line 5414
      ql_dbg(536870912U, vha, 4424, "Driver-lock id=%x%x", (int )mcp->mb[4], (int )mcp->mb[3]);
    } else
#line 5416
    if (((int )subcode & 24) != 0) {
#line 5417
      ql_dbg(536870912U, vha, 4425, "Flash-lock id=%x%x", (int )mcp->mb[4], (int )mcp->mb[3]);
    } else {

    }
#line 5420
    ql_dbg(536870912U, vha, 4426, "Done %s.\n", "qla83xx_access_control");
  }
#line 5423
  return (rval);
}
}
#line 5427 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.c"
int qla2x00_dump_mctp_data(scsi_qla_host_t *vha , dma_addr_t req_dma , uint32_t addr ,
                           uint32_t size ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 5432
  mcp = & mc;
#line 5434
  if (((vha->hw)->device_type & 32768U) == 0U || ((int )(vha->hw)->fw_attributes_ext[0] & 1) == 0) {
#line 5435
    return (258);
  } else {

  }
#line 5437
  ql_dbg(536903680U, vha, 4431, "Entered %s.\n", "qla2x00_dump_mctp_data");
#line 5440
  mcp->mb[0] = 12U;
#line 5441
  mcp->mb[1] = (unsigned short )addr;
#line 5442
  mcp->mb[2] = (unsigned short )((unsigned int )req_dma >> 16);
#line 5443
  mcp->mb[3] = (unsigned short )req_dma;
#line 5444
  mcp->mb[4] = (unsigned short )(size >> 16);
#line 5445
  mcp->mb[5] = (unsigned short )size;
#line 5446
  mcp->mb[6] = (unsigned short )((unsigned int )(req_dma >> 32ULL) >> 16);
#line 5447
  mcp->mb[7] = (unsigned short )(req_dma >> 32ULL);
#line 5448
  mcp->mb[8] = (unsigned short )(addr >> 16);
#line 5450
  mcp->mb[10] = (uint16_t )((unsigned int )mcp->mb[10] | 128U);
#line 5452
  mcp->mb[10] = (uint16_t )((unsigned int )mcp->mb[10] | 64U);
#line 5454
  mcp->out_mb = mcp->out_mb | 1535U;
#line 5457
  mcp->in_mb = 1U;
#line 5458
  mcp->tov = 30U;
#line 5459
  mcp->flags = 0U;
#line 5460
  rval = qla2x00_mailbox_command(vha, mcp);
#line 5462
  if (rval != 0) {
#line 5463
    ql_dbg(536870912U, vha, 4430, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 5466
    ql_dbg(536903680U, vha, 4429, "Done %s.\n", "qla2x00_dump_mctp_data");
  }
#line 5470
  return (rval);
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
void disable_suitable_timer_16(struct timer_list *timer ) 
{ 


  {
#line 489
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_16) {
#line 490
    ldv_timer_state_16 = 0;
#line 491
    return;
  } else {

  }
#line 493
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
void activate_pending_timer_16(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 496
  if ((unsigned long )ldv_timer_list_16 == (unsigned long )timer) {
#line 497
    if (ldv_timer_state_16 == 2 || pending_flag != 0) {
#line 498
      ldv_timer_list_16 = timer;
#line 499
      ldv_timer_list_16->data = data;
#line 500
      ldv_timer_state_16 = 1;
    } else {

    }
#line 502
    return;
  } else {

  }
#line 504
  reg_timer_16(timer);
#line 505
  ldv_timer_list_16->data = data;
#line 506
  return;
}
}
#line 509 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int reg_timer_16(struct timer_list *timer ) 
{ 


  {
#line 510
  ldv_timer_list_16 = timer;
#line 511
  ldv_timer_state_16 = 1;
#line 512
  return (0);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
void choose_timer_16(struct timer_list *timer ) 
{ 


  {
#line 516
  LDV_IN_INTERRUPT = 2;
#line 517
  (*(timer->function))(timer->data);
#line 518
  LDV_IN_INTERRUPT = 1;
#line 519
  ldv_timer_state_16 = 2;
#line 520
  return;
}
}
#line 546 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
bool ldv_queue_work_on_79(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 550
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 550
  ldv_func_res = tmp;
#line 552
  activate_work_7(ldv_func_arg3, 2);
#line 554
  return (ldv_func_res);
}
}
#line 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
bool ldv_queue_delayed_work_on_80(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 561
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 561
  ldv_func_res = tmp;
#line 563
  activate_work_7(& ldv_func_arg3->work, 2);
#line 565
  return (ldv_func_res);
}
}
#line 568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
bool ldv_queue_work_on_81(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 572
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 572
  ldv_func_res = tmp;
#line 574
  activate_work_7(ldv_func_arg3, 2);
#line 576
  return (ldv_func_res);
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
void ldv_flush_workqueue_82(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 582
  flush_workqueue(ldv_func_arg1);
#line 584
  call_and_disable_all_7(2);
#line 585
  return;
}
}
#line 587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
bool ldv_queue_delayed_work_on_83(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 591
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 591
  ldv_func_res = tmp;
#line 593
  activate_work_7(& ldv_func_arg3->work, 2);
#line 595
  return (ldv_func_res);
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int ldv_scsi_add_host_with_dma_84(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 602
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 602
  ldv_func_res = tmp;
#line 604
  if (ldv_func_res == 0) {
#line 605
    ldv_state_variable_88 = 1;
#line 605
    ldv_initialize_scsi_host_template_88();
  } else {

  }
#line 609
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_95(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_97(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_96(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_99(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_98(struct workqueue_struct *ldv_func_arg1 ) ;
#line 61 "./arch/x86/include/asm/io.h"
__inline static unsigned short __readw(void const volatile   *addr ) 
{ 
  unsigned short ret ;

  {
#line 61
  __asm__  volatile   ("movw %1,%0": "=r" (ret): "m" (*((unsigned short volatile   *)addr)));
#line 61
  return (ret);
}
}
#line 62 "./arch/x86/include/asm/io.h"
__inline static unsigned int __readl(void const volatile   *addr ) 
{ 
  unsigned int ret ;

  {
#line 62
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)));
#line 62
  return (ret);
}
}
#line 64 "./arch/x86/include/asm/io.h"
__inline static void writeb(unsigned char val , void volatile   *addr ) 
{ 


  {
#line 64
  __asm__  volatile   ("movb %0,%1": : "q" (val), "m" (*((unsigned char volatile   *)addr)): "memory");
#line 65
  return;
}
}
#line 329 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
void disable_suitable_timer_17(struct timer_list *timer ) ;
#line 410
void choose_timer_17(struct timer_list *timer ) ;
#line 455
int reg_timer_17(struct timer_list *timer ) ;
#line 471
void activate_pending_timer_17(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 924 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 926
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
#line 120 "include/linux/scatterlist.h"
__inline static struct page *sg_page(struct scatterlist *sg ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 123
  tmp = ldv__builtin_expect(sg->sg_magic != 2271560481UL, 0L);
#line 123
  if (tmp != 0L) {
#line 123
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (123), "i" (12UL));
    ldv_26177: ;
#line 123
    goto ldv_26177;
  } else {

  }
#line 124
  tmp___0 = ldv__builtin_expect((long )((int )sg->page_link) & 1L, 0L);
#line 124
  if (tmp___0 != 0L) {
#line 124
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (124), "i" (12UL));
    ldv_26178: ;
#line 124
    goto ldv_26178;
  } else {

  }
#line 126
  return ((struct page *)(sg->page_link & 0xfffffffffffffffcUL));
}
}
#line 243 "include/linux/scatterlist.h"
__inline static void *sg_virt(struct scatterlist *sg ) 
{ 
  struct page *tmp ;
  void *tmp___0 ;

  {
#line 245
  tmp = sg_page(sg);
#line 245
  tmp___0 = lowmem_page_address((struct page  const  *)tmp);
#line 245
  return (tmp___0 + (unsigned long )sg->offset);
}
}
#line 250
extern struct scatterlist *sg_next(struct scatterlist * ) ;
#line 131 "include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 


  {
#line 133
  return;
}
}
#line 47 "include/linux/dma-debug.h"
extern void debug_dma_map_sg(struct device * , struct scatterlist * , int  , int  ,
                             int  ) ;
#line 46 "include/asm-generic/dma-mapping-common.h"
__inline static int dma_map_sg_attrs(struct device *dev , struct scatterlist *sg ,
                                     int nents , enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int i ;
  int ents ;
  struct scatterlist *s ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 50
  tmp = get_dma_ops(dev);
#line 50
  ops = tmp;
#line 54
  i = 0;
#line 54
  s = sg;
#line 54
  goto ldv_26969;
  ldv_26968: 
#line 55
  tmp___0 = sg_virt(s);
#line 55
  kmemcheck_mark_initialized(tmp___0, s->length);
#line 54
  i = i + 1;
#line 54
  s = sg_next(s);
  ldv_26969: ;
#line 54
  if (i < nents) {
#line 56
    goto ldv_26968;
  } else {

  }
#line 56
  tmp___1 = valid_dma_direction((int )dir);
#line 56
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 56
  if (tmp___2 != 0L) {
#line 56
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (56), "i" (12UL));
    ldv_26971: ;
#line 56
    goto ldv_26971;
  } else {

  }
#line 57
  ents = (*(ops->map_sg))(dev, sg, nents, dir, attrs);
#line 58
  tmp___3 = ldv__builtin_expect(ents < 0, 0L);
#line 58
  if (tmp___3 != 0L) {
#line 58
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (58), "i" (12UL));
    ldv_26972: ;
#line 58
    goto ldv_26972;
  } else {

  }
#line 59
  debug_dma_map_sg(dev, sg, nents, ents, (int )dir);
#line 61
  return (ents);
}
}
#line 828 "include/linux/blkdev.h"
__inline static sector_t blk_rq_pos(struct request  const  *rq ) 
{ 


  {
#line 830
  return ((sector_t )rq->__sector);
}
}
#line 795 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_100(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
#line 926 "include/scsi/scsi_host.h"
__inline static unsigned char scsi_host_get_guard(struct Scsi_Host *shost ) 
{ 


  {
#line 928
  return (shost->prot_guard_type);
}
}
#line 171 "include/scsi/scsi_cmnd.h"
__inline static unsigned int scsi_sg_count(struct scsi_cmnd *cmd ) 
{ 


  {
#line 173
  return (cmd->sdb.table.nents);
}
}
#line 176 "include/scsi/scsi_cmnd.h"
__inline static struct scatterlist *scsi_sglist(struct scsi_cmnd *cmd ) 
{ 


  {
#line 178
  return (cmd->sdb.table.sgl);
}
}
#line 181 "include/scsi/scsi_cmnd.h"
__inline static unsigned int scsi_bufflen(struct scsi_cmnd *cmd ) 
{ 


  {
#line 183
  return (cmd->sdb.length);
}
}
#line 287 "include/scsi/scsi_cmnd.h"
__inline static unsigned char scsi_get_prot_type(struct scsi_cmnd *scmd ) 
{ 


  {
#line 289
  return (scmd->prot_type);
}
}
#line 292 "include/scsi/scsi_cmnd.h"
__inline static sector_t scsi_get_lba(struct scsi_cmnd *scmd ) 
{ 
  sector_t tmp ;

  {
#line 294
  tmp = blk_rq_pos((struct request  const  *)scmd->request);
#line 294
  return (tmp);
}
}
#line 74 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
void *qla2x00_alloc_iocbs(struct scsi_qla_host *vha , srb_t *sp ) ;
#line 75
void *qla2x00_alloc_iocbs_ready(struct scsi_qla_host *vha , srb_t *sp ) ;
#line 219
int qla2x00_start_bidir(srb_t *sp , struct scsi_qla_host *vha , uint32_t tot_dsds ) ;
#line 223
int qla2x00_issue_marker(scsi_qla_host_t *vha , int ha_locked ) ;
#line 224
int qla24xx_walk_and_build_sglist_no_difb(struct qla_hw_data *ha , srb_t *sp , uint32_t *dsd ,
                                          uint16_t tot_dsds , struct qla_tgt_cmd *tc ) ;
#line 226
int qla24xx_walk_and_build_sglist(struct qla_hw_data *ha , srb_t *sp , uint32_t *dsd ,
                                  uint16_t tot_dsds , struct qla_tgt_cmd *tc ) ;
#line 228
int qla24xx_walk_and_build_prot_sglist(struct qla_hw_data *ha , srb_t *sp , uint32_t *dsd ,
                                       uint16_t tot_dsds , struct qla_tgt_cmd *tc ) ;
#line 445
void qla2x00_process_response_queue(struct rsp_que *rsp ) ;
#line 447
void qla24xx_process_response_queue(struct scsi_qla_host *vha , struct rsp_que *rsp ) ;
#line 641
void qlafx00_tm_iocb(srb_t *sp , struct tsk_mgmt_entry_fx00 *ptm_iocb ) ;
#line 642
void qlafx00_abort_iocb(srb_t *sp , struct abort_iocb_entry_fx00 *pabt_iocb ) ;
#line 643
void qlafx00_fxdisc_iocb(srb_t *sp , struct fxdisc_entry_fx00 *pfxiocb ) ;
#line 679
void qla2x00_start_iocbs(struct scsi_qla_host *vha , struct req_que *req ) ;
#line 711
void qla82xx_start_iocbs(scsi_qla_host_t *vha ) ;
#line 18 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static uint16_t qla24xx_calc_iocbs(scsi_qla_host_t *vha , uint16_t dsds ) 
{ 
  uint16_t iocbs ;

  {
#line 22
  iocbs = 1U;
#line 23
  if ((unsigned int )dsds > 1U) {
#line 24
    iocbs = (int )((uint16_t )(((int )dsds + -1) / 5)) + (int )iocbs;
#line 25
    if (((int )dsds + -1) % 5 != 0) {
#line 26
      iocbs = (uint16_t )((int )iocbs + 1);
    } else {

    }
  } else {

  }
#line 28
  return (iocbs);
}
}
#line 42 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static uint16_t qla2x00_debounce_register___0(uint16_t volatile   *addr ) 
{ 
  uint16_t volatile   first ;
  uint16_t volatile   second ;
  unsigned short tmp ;
  unsigned short tmp___0 ;

  {
  ldv_65629: 
#line 48
  tmp = readw((void const volatile   *)addr);
#line 48
  first = tmp;
#line 49
  __asm__  volatile   ("": : : "memory");
#line 50
  cpu_relax();
#line 51
  tmp___0 = readw((void const volatile   *)addr);
#line 51
  second = tmp___0;
#line 52
  if ((int )((unsigned short )first) != (int )((unsigned short )second)) {
#line 54
    goto ldv_65629;
  } else {

  }

#line 54
  return ((uint16_t )first);
}
}
#line 178 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static int qla2x00_hba_err_chk_enabled(srb_t *sp ) 
{ 
  unsigned char tmp ;

  {
#line 187
  tmp = scsi_get_prot_op(sp->u.scmd.cmd);
#line 187
  switch ((int )tmp) {
  case 3: ;
  case 4: ;
#line 190
  if (ql2xenablehba_err_chk > 0) {
#line 191
    return (1);
  } else {

  }
#line 192
  goto ldv_65714;
  case 5: ;
  case 6: ;
#line 195
  if (ql2xenablehba_err_chk > 1) {
#line 196
    return (1);
  } else {

  }
#line 197
  goto ldv_65714;
  case 1: ;
  case 2: ;
#line 200
  return (1);
  }
  ldv_65714: ;
#line 202
  return (0);
}
}
#line 15 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
static void qla25xx_set_que(srb_t *sp , struct rsp_que **rsp ) ;
#line 23 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
__inline static uint16_t qla2x00_get_cmd_direction(srb_t *sp ) 
{ 
  uint16_t cflags ;
  struct scsi_cmnd *cmd ;
  struct scsi_qla_host *vha ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 26
  cmd = sp->u.scmd.cmd;
#line 27
  vha = (sp->fcport)->vha;
#line 29
  cflags = 0U;
#line 32
  if ((unsigned int )cmd->sc_data_direction == 1U) {
#line 33
    cflags = 64U;
#line 34
    tmp = scsi_bufflen(cmd);
#line 34
    vha->qla_stats.output_bytes = vha->qla_stats.output_bytes + (uint64_t )tmp;
#line 35
    vha->qla_stats.output_requests = vha->qla_stats.output_requests + 1ULL;
  } else
#line 36
  if ((unsigned int )cmd->sc_data_direction == 2U) {
#line 37
    cflags = 32U;
#line 38
    tmp___0 = scsi_bufflen(cmd);
#line 38
    vha->qla_stats.input_bytes = vha->qla_stats.input_bytes + (uint64_t )tmp___0;
#line 39
    vha->qla_stats.input_requests = vha->qla_stats.input_requests + 1ULL;
  } else {

  }
#line 41
  return (cflags);
}
}
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
uint16_t qla2x00_calc_iocbs_32(uint16_t dsds ) 
{ 
  uint16_t iocbs ;

  {
#line 57
  iocbs = 1U;
#line 58
  if ((unsigned int )dsds > 3U) {
#line 59
    iocbs = (int )((uint16_t )(((int )dsds + -3) / 7)) + (int )iocbs;
#line 60
    if (((int )dsds + -3) % 7 != 0) {
#line 61
      iocbs = (uint16_t )((int )iocbs + 1);
    } else {

    }
  } else {

  }
#line 63
  return (iocbs);
}
}
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
uint16_t qla2x00_calc_iocbs_64(uint16_t dsds ) 
{ 
  uint16_t iocbs ;

  {
#line 79
  iocbs = 1U;
#line 80
  if ((unsigned int )dsds > 2U) {
#line 81
    iocbs = (int )((uint16_t )(((int )dsds + -2) / 5)) + (int )iocbs;
#line 82
    if (((int )dsds + -2) % 5 != 0) {
#line 83
      iocbs = (uint16_t )((int )iocbs + 1);
    } else {

    }
  } else {

  }
#line 85
  return (iocbs);
}
}
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
__inline static cont_entry_t *qla2x00_prep_cont_type0_iocb(struct scsi_qla_host *vha ) 
{ 
  cont_entry_t *cont_pkt ;
  struct req_que *req ;

  {
#line 98
  req = vha->req;
#line 100
  req->ring_index = (uint16_t )((int )req->ring_index + 1);
#line 101
  if ((int )req->ring_index == (int )req->length) {
#line 102
    req->ring_index = 0U;
#line 103
    req->ring_ptr = req->ring;
  } else {
#line 105
    req->ring_ptr = req->ring_ptr + 1;
  }
#line 108
  cont_pkt = (cont_entry_t *)req->ring_ptr;
#line 111
  *((uint32_t *)(& cont_pkt->entry_type)) = 2U;
#line 114
  return (cont_pkt);
}
}
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
__inline static cont_a64_entry_t *qla2x00_prep_cont_type1_iocb(scsi_qla_host_t *vha ,
                                                               struct req_que *req ) 
{ 
  cont_a64_entry_t *cont_pkt ;

  {
#line 129
  req->ring_index = (uint16_t )((int )req->ring_index + 1);
#line 130
  if ((int )req->ring_index == (int )req->length) {
#line 131
    req->ring_index = 0U;
#line 132
    req->ring_ptr = req->ring;
  } else {
#line 134
    req->ring_ptr = req->ring_ptr + 1;
  }
#line 137
  cont_pkt = (cont_a64_entry_t *)req->ring_ptr;
#line 140
  *((uint32_t *)(& cont_pkt->entry_type)) = ((vha->hw)->device_type & 131072U) != 0U ? 3U : 10U;
#line 144
  return (cont_pkt);
}
}
#line 148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
__inline static int qla24xx_configure_prot_mode(srb_t *sp , uint16_t *fw_prot_opts ) 
{ 
  struct scsi_cmnd *cmd ;
  uint8_t guard ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 150
  cmd = sp->u.scmd.cmd;
#line 151
  tmp = scsi_host_get_guard((cmd->device)->host);
#line 151
  guard = tmp;
#line 154
  *fw_prot_opts = 0U;
#line 157
  tmp___0 = scsi_get_prot_op(cmd);
#line 157
  switch ((int )tmp___0) {
  case 3: 
#line 159
  *fw_prot_opts = (uint16_t )((unsigned int )*fw_prot_opts | 1U);
#line 160
  goto ldv_65805;
  case 4: 
#line 162
  *fw_prot_opts = *fw_prot_opts;
#line 163
  goto ldv_65805;
  case 1: 
#line 165
  *fw_prot_opts = *fw_prot_opts;
#line 166
  goto ldv_65805;
  case 2: 
#line 168
  *fw_prot_opts = (uint16_t )((unsigned int )*fw_prot_opts | 1U);
#line 169
  goto ldv_65805;
  case 5: ;
  case 6: ;
#line 172
  if (((int )guard & 2) != 0) {
#line 173
    *fw_prot_opts = (uint16_t )((unsigned int )*fw_prot_opts | 6U);
  } else {
#line 175
    *fw_prot_opts = (uint16_t )((unsigned int )*fw_prot_opts | 2U);
  }
#line 176
  goto ldv_65805;
  default: 
#line 178
  *fw_prot_opts = (uint16_t )((unsigned int )*fw_prot_opts | 2U);
#line 179
  goto ldv_65805;
  }
  ldv_65805: 
#line 182
  tmp___1 = scsi_prot_sg_count(cmd);
#line 182
  return ((int )tmp___1);
}
}
#line 193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
void qla2x00_build_scsi_iocbs_32(srb_t *sp , cmd_entry_t *cmd_pkt , uint16_t tot_dsds ) 
{ 
  uint16_t avail_dsds ;
  uint32_t *cur_dsd ;
  scsi_qla_host_t *vha ;
  struct scsi_cmnd *cmd ;
  struct scatterlist *sg ;
  int i ;
  unsigned int tmp ;
  uint16_t tmp___0 ;
  cont_entry_t *cont_pkt ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;

  {
#line 203
  cmd = sp->u.scmd.cmd;
#line 206
  *((uint32_t *)(& cmd_pkt->entry_type)) = 17U;
#line 210
  tmp = scsi_bufflen(cmd);
#line 210
  if (tmp == 0U || (unsigned int )cmd->sc_data_direction == 3U) {
#line 211
    cmd_pkt->byte_count = 0U;
#line 212
    return;
  } else {

  }
#line 215
  vha = (sp->fcport)->vha;
#line 216
  tmp___0 = qla2x00_get_cmd_direction(sp);
#line 216
  cmd_pkt->control_flags = (uint16_t )((int )cmd_pkt->control_flags | (int )tmp___0);
#line 219
  avail_dsds = 3U;
#line 220
  cur_dsd = & cmd_pkt->dseg_0_address;
#line 223
  i = 0;
#line 223
  sg = scsi_sglist(cmd);
#line 223
  goto ldv_65825;
  ldv_65824: ;
#line 227
  if ((unsigned int )avail_dsds == 0U) {
#line 232
    cont_pkt = qla2x00_prep_cont_type0_iocb(vha);
#line 233
    cur_dsd = & cont_pkt->dseg_0_address;
#line 234
    avail_dsds = 7U;
  } else {

  }
#line 237
  tmp___1 = cur_dsd;
#line 237
  cur_dsd = cur_dsd + 1;
#line 237
  *tmp___1 = (unsigned int )sg->dma_address;
#line 238
  tmp___2 = cur_dsd;
#line 238
  cur_dsd = cur_dsd + 1;
#line 238
  *tmp___2 = sg->dma_length;
#line 239
  avail_dsds = (uint16_t )((int )avail_dsds - 1);
#line 223
  i = i + 1;
#line 223
  sg = sg_next(sg);
  ldv_65825: ;
#line 223
  if ((int )tot_dsds > i) {
#line 225
    goto ldv_65824;
  } else {

  }

#line 230
  return;
}
}
#line 251 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
void qla2x00_build_scsi_iocbs_64(srb_t *sp , cmd_entry_t *cmd_pkt , uint16_t tot_dsds ) 
{ 
  uint16_t avail_dsds ;
  uint32_t *cur_dsd ;
  scsi_qla_host_t *vha ;
  struct scsi_cmnd *cmd ;
  struct scatterlist *sg ;
  int i ;
  unsigned int tmp ;
  uint16_t tmp___0 ;
  dma_addr_t sle_dma ;
  cont_a64_entry_t *cont_pkt ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;

  {
#line 261
  cmd = sp->u.scmd.cmd;
#line 264
  *((uint32_t *)(& cmd_pkt->entry_type)) = 25U;
#line 268
  tmp = scsi_bufflen(cmd);
#line 268
  if (tmp == 0U || (unsigned int )cmd->sc_data_direction == 3U) {
#line 269
    cmd_pkt->byte_count = 0U;
#line 270
    return;
  } else {

  }
#line 273
  vha = (sp->fcport)->vha;
#line 274
  tmp___0 = qla2x00_get_cmd_direction(sp);
#line 274
  cmd_pkt->control_flags = (uint16_t )((int )cmd_pkt->control_flags | (int )tmp___0);
#line 277
  avail_dsds = 2U;
#line 278
  cur_dsd = & cmd_pkt->dseg_0_address;
#line 281
  i = 0;
#line 281
  sg = scsi_sglist(cmd);
#line 281
  goto ldv_65841;
  ldv_65840: ;
#line 286
  if ((unsigned int )avail_dsds == 0U) {
#line 291
    cont_pkt = qla2x00_prep_cont_type1_iocb(vha, vha->req);
#line 292
    cur_dsd = (uint32_t *)(& cont_pkt->dseg_0_address);
#line 293
    avail_dsds = 5U;
  } else {

  }
#line 296
  sle_dma = sg->dma_address;
#line 297
  tmp___1 = cur_dsd;
#line 297
  cur_dsd = cur_dsd + 1;
#line 297
  *tmp___1 = (unsigned int )sle_dma;
#line 298
  tmp___2 = cur_dsd;
#line 298
  cur_dsd = cur_dsd + 1;
#line 298
  *tmp___2 = (unsigned int )(sle_dma >> 32ULL);
#line 299
  tmp___3 = cur_dsd;
#line 299
  cur_dsd = cur_dsd + 1;
#line 299
  *tmp___3 = sg->dma_length;
#line 300
  avail_dsds = (uint16_t )((int )avail_dsds - 1);
#line 281
  i = i + 1;
#line 281
  sg = sg_next(sg);
  ldv_65841: ;
#line 281
  if ((int )tot_dsds > i) {
#line 283
    goto ldv_65840;
  } else {

  }

#line 288
  return;
}
}
#line 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
int qla2x00_start_scsi(srb_t *sp ) 
{ 
  int ret ;
  int nseg ;
  unsigned long flags ;
  scsi_qla_host_t *vha ;
  struct scsi_cmnd *cmd ;
  uint32_t *clr_ptr ;
  uint32_t index ;
  uint32_t handle ;
  cmd_entry_t *cmd_pkt ;
  uint16_t cnt ;
  uint16_t req_cnt ;
  uint16_t tot_dsds ;
  struct device_reg_2xxx *reg ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned int tmp___1 ;
  struct scatterlist *tmp___2 ;
  long tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 330
  ret = 0;
#line 331
  vha = (sp->fcport)->vha;
#line 332
  ha = vha->hw;
#line 333
  reg = & (ha->iobase)->isp;
#line 334
  cmd = sp->u.scmd.cmd;
#line 335
  req = *(ha->req_q_map);
#line 336
  rsp = *(ha->rsp_q_map);
#line 338
  tot_dsds = 0U;
#line 341
  if ((unsigned int )vha->marker_needed != 0U) {
#line 342
    tmp = qla2x00_marker(vha, req, rsp, 0, 0ULL, 2);
#line 342
    if (tmp != 0) {
#line 344
      return (258);
    } else {

    }
#line 346
    vha->marker_needed = 0U;
  } else {

  }
#line 350
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 350
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 353
  handle = req->current_outstanding_cmd;
#line 354
  index = 1U;
#line 354
  goto ldv_65867;
  ldv_65866: 
#line 355
  handle = handle + 1U;
#line 356
  if ((uint32_t )req->num_outstanding_cmds == handle) {
#line 357
    handle = 1U;
  } else {

  }
#line 358
  if ((unsigned long )*(req->outstanding_cmds + (unsigned long )handle) == (unsigned long )((srb_t *)0)) {
#line 359
    goto ldv_65865;
  } else {

  }
#line 354
  index = index + 1U;
  ldv_65867: ;
#line 354
  if ((uint32_t )req->num_outstanding_cmds > index) {
#line 356
    goto ldv_65866;
  } else {

  }
  ldv_65865: ;
#line 361
  if ((uint32_t )req->num_outstanding_cmds == index) {
#line 362
    goto queuing_error;
  } else {

  }
#line 365
  tmp___4 = scsi_sg_count(cmd);
#line 365
  if (tmp___4 != 0U) {
#line 366
    tmp___1 = scsi_sg_count(cmd);
#line 366
    tmp___2 = scsi_sglist(cmd);
#line 366
    nseg = dma_map_sg_attrs(& (ha->pdev)->dev, tmp___2, (int )tmp___1, cmd->sc_data_direction,
                            (struct dma_attrs *)0);
#line 368
    tmp___3 = ldv__builtin_expect(nseg == 0, 0L);
#line 368
    if (tmp___3 != 0L) {
#line 369
      goto queuing_error;
    } else {

    }
  } else {
#line 371
    nseg = 0;
  }
#line 373
  tot_dsds = (uint16_t )nseg;
#line 376
  req_cnt = (*((ha->isp_ops)->calc_req_entries))((int )tot_dsds);
#line 377
  if ((int )req->cnt < (int )req_cnt + 2) {
#line 378
    cnt = __readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox4 : & reg->u.isp2300.req_q_out));
#line 379
    if ((int )req->ring_index < (int )cnt) {
#line 380
      req->cnt = (int )cnt - (int )req->ring_index;
    } else {
#line 382
      req->cnt = (int )req->length + ((int )cnt - (int )req->ring_index);
    }
#line 385
    if ((int )req->cnt < (int )req_cnt + 2) {
#line 386
      goto queuing_error;
    } else {

    }
  } else {

  }
#line 390
  req->current_outstanding_cmd = handle;
#line 391
  *(req->outstanding_cmds + (unsigned long )handle) = sp;
#line 392
  sp->handle = handle;
#line 393
  cmd->host_scribble = (unsigned char *)((unsigned long )handle);
#line 394
  req->cnt = (int )req->cnt - (int )req_cnt;
#line 396
  cmd_pkt = (cmd_entry_t *)req->ring_ptr;
#line 397
  cmd_pkt->handle = handle;
#line 399
  clr_ptr = (uint32_t *)cmd_pkt + 2UL;
#line 400
  memset((void *)clr_ptr, 0, 56UL);
#line 401
  cmd_pkt->dseg_count = tot_dsds;
#line 404
  if ((int )ha->device_type < 0) {
#line 404
    cmd_pkt->target.extended = (sp->fcport)->loop_id;
  } else {
#line 404
    cmd_pkt->target.id.standard = (unsigned char )(sp->fcport)->loop_id;
  }
#line 405
  cmd_pkt->lun = (unsigned short )(cmd->device)->lun;
#line 406
  cmd_pkt->control_flags = 8U;
#line 409
  memcpy((void *)(& cmd_pkt->scsi_cdb), (void const   *)cmd->cmnd, (size_t )cmd->cmd_len);
#line 410
  cmd_pkt->byte_count = scsi_bufflen(cmd);
#line 413
  (*((ha->isp_ops)->build_iocbs))(sp, cmd_pkt, (int )tot_dsds);
#line 416
  cmd_pkt->entry_count = (unsigned char )req_cnt;
#line 417
  __asm__  volatile   ("sfence": : : "memory");
#line 420
  req->ring_index = (uint16_t )((int )req->ring_index + 1);
#line 421
  if ((int )req->ring_index == (int )req->length) {
#line 422
    req->ring_index = 0U;
#line 423
    req->ring_ptr = req->ring;
  } else {
#line 425
    req->ring_ptr = req->ring_ptr + 1;
  }
#line 427
  sp->flags = (uint16_t )((unsigned int )sp->flags | 1U);
#line 430
  writew((int )req->ring_index, (void volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox4 : & reg->u.isp2300.req_q_in));
#line 431
  __readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox4 : & reg->u.isp2300.req_q_in));
#line 434
  if (*((unsigned long *)vha + 19UL) != 0UL && (rsp->ring_ptr)->signature != 3735936685U) {
#line 436
    qla2x00_process_response_queue(rsp);
  } else {

  }
#line 438
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 439
  return (0);
  queuing_error: ;
#line 442
  if ((unsigned int )tot_dsds != 0U) {
#line 443
    scsi_dma_unmap(cmd);
  } else {

  }
#line 445
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 447
  return (258);
}
}
#line 454 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
void qla2x00_start_iocbs(struct scsi_qla_host *vha , struct req_que *req ) 
{ 
  struct qla_hw_data *ha ;
  device_reg_t *reg ;

  {
#line 456
  ha = vha->hw;
#line 457
  reg = ((unsigned int )ha->mqenable != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) ? ha->mqiobase + (unsigned long )((int )req->id * 4096) : ha->iobase;
#line 459
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 460
    qla82xx_start_iocbs(vha);
  } else {
#line 463
    req->ring_index = (uint16_t )((int )req->ring_index + 1);
#line 464
    if ((int )req->ring_index == (int )req->length) {
#line 465
      req->ring_index = 0U;
#line 466
      req->ring_ptr = req->ring;
    } else {
#line 468
      req->ring_ptr = req->ring_ptr + 1;
    }
#line 471
    if (((unsigned int )ha->mqenable != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 472
      writel((unsigned int )req->ring_index, (void volatile   *)req->req_q_in);
#line 473
      __readl((void const volatile   *)(& (ha->iobase)->isp24.hccr));
    } else
#line 474
    if ((ha->device_type & 131072U) != 0U) {
#line 475
      writel((unsigned int )req->ring_index, (void volatile   *)(& reg->ispfx00.req_q_in));
#line 476
      __readl((void const volatile   *)(& reg->ispfx00.req_q_in));
#line 477
      writel(ha->rqstq_intr_code, (void volatile   *)ha->cregbase + 133636U);
    } else
#line 478
    if ((ha->device_type & 134217728U) != 0U) {
#line 479
      writel((unsigned int )req->ring_index, (void volatile   *)(& reg->isp24.req_q_in));
#line 480
      __readl((void const volatile   *)(& reg->isp24.req_q_in));
    } else {
#line 482
      writew((int )req->ring_index, (void volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->isp.u.isp2100.mailbox4 : & reg->isp.u.isp2300.req_q_in));
#line 484
      __readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->isp.u.isp2100.mailbox4 : & reg->isp.u.isp2300.req_q_in));
    }
  }
#line 487
  return;
}
}
#line 501 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
static int __qla2x00_marker(struct scsi_qla_host *vha , struct req_que *req , struct rsp_que *rsp ,
                            uint16_t loop_id , uint64_t lun , uint8_t type ) 
{ 
  mrk_entry_t *mrk ;
  struct mrk_entry_24xx *mrk24 ;
  struct qla_hw_data *ha ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 506
  mrk24 = (struct mrk_entry_24xx *)0;
#line 508
  ha = vha->hw;
#line 509
  tmp = pci_get_drvdata(ha->pdev);
#line 509
  base_vha = (scsi_qla_host_t *)tmp;
#line 511
  req = *(ha->req_q_map);
#line 512
  tmp___0 = qla2x00_alloc_iocbs(vha, (srb_t *)0);
#line 512
  mrk = (mrk_entry_t *)tmp___0;
#line 513
  if ((unsigned long )mrk == (unsigned long )((mrk_entry_t *)0)) {
#line 514
    ql_log(1U, base_vha, 12326, "Failed to allocate Marker IOCB.\n");
#line 517
    return (258);
  } else {

  }
#line 520
  mrk->entry_type = 4U;
#line 521
  mrk->modifier = type;
#line 522
  if ((unsigned int )type != 2U) {
#line 523
    if ((ha->device_type & 134217728U) != 0U) {
#line 524
      mrk24 = (struct mrk_entry_24xx *)mrk;
#line 525
      mrk24->nport_handle = loop_id;
#line 526
      int_to_scsilun(lun, (struct scsi_lun *)(& mrk24->lun));
#line 527
      host_to_fcp_swap((uint8_t *)(& mrk24->lun), 8U);
#line 528
      mrk24->vp_index = (uint8_t )vha->vp_idx;
#line 529
      mrk24->handle = ((unsigned int )req->id << 16) | mrk24->handle;
    } else {
#line 531
      if ((int )ha->device_type < 0) {
#line 531
        mrk->target.extended = loop_id;
      } else {
#line 531
        mrk->target.id.standard = (unsigned char )loop_id;
      }
#line 532
      mrk->lun = (unsigned short )lun;
    }
  } else {

  }
#line 535
  __asm__  volatile   ("sfence": : : "memory");
#line 537
  qla2x00_start_iocbs(vha, req);
#line 539
  return (0);
}
}
#line 543 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
int qla2x00_marker(struct scsi_qla_host *vha , struct req_que *req , struct rsp_que *rsp ,
                   uint16_t loop_id , uint64_t lun , uint8_t type ) 
{ 
  int ret ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 548
  flags = 0UL;
#line 550
  tmp = spinlock_check(& (vha->hw)->hardware_lock);
#line 550
  flags = _raw_spin_lock_irqsave(tmp);
#line 551
  ret = __qla2x00_marker(vha, req, rsp, (int )loop_id, lun, (int )type);
#line 552
  spin_unlock_irqrestore(& (vha->hw)->hardware_lock, flags);
#line 554
  return (ret);
}
}
#line 564 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
int qla2x00_issue_marker(scsi_qla_host_t *vha , int ha_locked ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 566
  if (ha_locked != 0) {
#line 567
    tmp = __qla2x00_marker(vha, vha->req, (vha->req)->rsp, 0, 0ULL, 2);
#line 567
    if (tmp != 0) {
#line 569
      return (258);
    } else {

    }
  } else {
#line 571
    tmp___0 = qla2x00_marker(vha, vha->req, (vha->req)->rsp, 0, 0ULL, 2);
#line 571
    if (tmp___0 != 0) {
#line 573
      return (258);
    } else {

    }
  }
#line 575
  vha->marker_needed = 0U;
#line 577
  return (0);
}
}
#line 581 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
__inline static int qla24xx_build_scsi_type_6_iocbs(srb_t *sp , struct cmd_type_6 *cmd_pkt ,
                                                    uint16_t tot_dsds ) 
{ 
  uint32_t *cur_dsd ;
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct scsi_cmnd *cmd ;
  struct scatterlist *cur_seg ;
  uint32_t *dsd_seg ;
  void *next_dsd ;
  uint8_t avail_dsds ;
  uint8_t first_iocb ;
  uint32_t dsd_list_len ;
  struct dsd_dma *dsd_ptr ;
  struct ct6_dsd *ctx ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  struct list_head  const  *__mptr ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t *tmp___6 ;
  dma_addr_t sle_dma ;
  uint32_t *tmp___7 ;
  uint32_t *tmp___8 ;
  uint32_t *tmp___9 ;
  uint32_t *tmp___10 ;
  uint32_t *tmp___11 ;
  uint32_t *tmp___12 ;

  {
#line 584
  cur_dsd = (uint32_t *)0U;
#line 592
  first_iocb = 1U;
#line 597
  cmd = sp->u.scmd.cmd;
#line 600
  *((uint32_t *)(& cmd_pkt->entry_type)) = 72U;
#line 604
  tmp = scsi_bufflen(cmd);
#line 604
  if (tmp == 0U || (unsigned int )cmd->sc_data_direction == 3U) {
#line 605
    cmd_pkt->byte_count = 0U;
#line 606
    return (0);
  } else {

  }
#line 609
  vha = (sp->fcport)->vha;
#line 610
  ha = vha->hw;
#line 613
  if ((unsigned int )cmd->sc_data_direction == 1U) {
#line 614
    cmd_pkt->control_flags = 1U;
#line 616
    tmp___0 = scsi_bufflen(cmd);
#line 616
    vha->qla_stats.output_bytes = vha->qla_stats.output_bytes + (uint64_t )tmp___0;
#line 617
    vha->qla_stats.output_requests = vha->qla_stats.output_requests + 1ULL;
  } else
#line 618
  if ((unsigned int )cmd->sc_data_direction == 2U) {
#line 619
    cmd_pkt->control_flags = 2U;
#line 621
    tmp___1 = scsi_bufflen(cmd);
#line 621
    vha->qla_stats.input_bytes = vha->qla_stats.input_bytes + (uint64_t )tmp___1;
#line 622
    vha->qla_stats.input_requests = vha->qla_stats.input_requests + 1ULL;
  } else {

  }
#line 625
  cur_seg = scsi_sglist(cmd);
#line 626
  ctx = (struct ct6_dsd *)sp->u.scmd.ctx;
#line 628
  goto ldv_65928;
  ldv_65927: 
#line 629
  avail_dsds = (unsigned int )tot_dsds <= 37U ? (uint8_t )tot_dsds : 37U;
#line 631
  tot_dsds = (int )tot_dsds - (int )((uint16_t )avail_dsds);
#line 632
  dsd_list_len = (uint32_t )(((int )avail_dsds + 1) * 12);
#line 634
  __mptr = (struct list_head  const  *)ha->gbl_dsd_list.next;
#line 634
  dsd_ptr = (struct dsd_dma *)__mptr;
#line 636
  next_dsd = dsd_ptr->dsd_addr;
#line 637
  list_del(& dsd_ptr->list);
#line 638
  ha->gbl_dsd_avail = (uint16_t )((int )ha->gbl_dsd_avail - 1);
#line 639
  list_add_tail(& dsd_ptr->list, & ctx->dsd_list);
#line 640
  ctx->dsd_use_cnt = ctx->dsd_use_cnt + 1;
#line 641
  ha->gbl_dsd_inuse = (uint16_t )((int )ha->gbl_dsd_inuse + 1);
#line 643
  if ((unsigned int )first_iocb != 0U) {
#line 644
    first_iocb = 0U;
#line 645
    dsd_seg = (uint32_t *)(& cmd_pkt->fcp_data_dseg_address);
#line 646
    tmp___2 = dsd_seg;
#line 646
    dsd_seg = dsd_seg + 1;
#line 646
    *tmp___2 = (unsigned int )dsd_ptr->dsd_list_dma;
#line 647
    tmp___3 = dsd_seg;
#line 647
    dsd_seg = dsd_seg + 1;
#line 647
    *tmp___3 = (unsigned int )(dsd_ptr->dsd_list_dma >> 32ULL);
#line 648
    cmd_pkt->fcp_data_dseg_len = dsd_list_len;
  } else {
#line 650
    tmp___4 = cur_dsd;
#line 650
    cur_dsd = cur_dsd + 1;
#line 650
    *tmp___4 = (unsigned int )dsd_ptr->dsd_list_dma;
#line 651
    tmp___5 = cur_dsd;
#line 651
    cur_dsd = cur_dsd + 1;
#line 651
    *tmp___5 = (unsigned int )(dsd_ptr->dsd_list_dma >> 32ULL);
#line 652
    tmp___6 = cur_dsd;
#line 652
    cur_dsd = cur_dsd + 1;
#line 652
    *tmp___6 = dsd_list_len;
  }
#line 654
  cur_dsd = (uint32_t *)next_dsd;
#line 655
  goto ldv_65925;
  ldv_65924: 
#line 658
  sle_dma = cur_seg->dma_address;
#line 659
  tmp___7 = cur_dsd;
#line 659
  cur_dsd = cur_dsd + 1;
#line 659
  *tmp___7 = (unsigned int )sle_dma;
#line 660
  tmp___8 = cur_dsd;
#line 660
  cur_dsd = cur_dsd + 1;
#line 660
  *tmp___8 = (unsigned int )(sle_dma >> 32ULL);
#line 661
  tmp___9 = cur_dsd;
#line 661
  cur_dsd = cur_dsd + 1;
#line 661
  *tmp___9 = cur_seg->dma_length;
#line 662
  cur_seg = sg_next(cur_seg);
#line 663
  avail_dsds = (uint8_t )((int )avail_dsds - 1);
  ldv_65925: ;
#line 655
  if ((unsigned int )avail_dsds != 0U) {
#line 657
    goto ldv_65924;
  } else {

  }

  ldv_65928: ;
#line 628
  if ((unsigned int )tot_dsds != 0U) {
#line 630
    goto ldv_65927;
  } else {

  }
#line 668
  tmp___10 = cur_dsd;
#line 668
  cur_dsd = cur_dsd + 1;
#line 668
  *tmp___10 = 0U;
#line 669
  tmp___11 = cur_dsd;
#line 669
  cur_dsd = cur_dsd + 1;
#line 669
  *tmp___11 = 0U;
#line 670
  tmp___12 = cur_dsd;
#line 670
  cur_dsd = cur_dsd + 1;
#line 670
  *tmp___12 = 0U;
#line 671
  cmd_pkt->control_flags = (uint16_t )((unsigned int )cmd_pkt->control_flags | 4U);
#line 672
  return (0);
}
}
#line 684 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
__inline uint16_t qla24xx_calc_dsd_lists(uint16_t dsds ) 
{ 
  uint16_t dsd_lists ;

  {
#line 686
  dsd_lists = 0U;
#line 688
  dsd_lists = (uint16_t )((unsigned int )dsds / 37U);
#line 689
  if ((unsigned int )dsds % 37U != 0U) {
#line 690
    dsd_lists = (uint16_t )((int )dsd_lists + 1);
  } else {

  }
#line 691
  return (dsd_lists);
}
}
#line 704 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
__inline void qla24xx_build_scsi_iocbs(srb_t *sp , struct cmd_type_7 *cmd_pkt , uint16_t tot_dsds ) 
{ 
  uint16_t avail_dsds ;
  uint32_t *cur_dsd ;
  scsi_qla_host_t *vha ;
  struct scsi_cmnd *cmd ;
  struct scatterlist *sg ;
  int i ;
  struct req_que *req ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  dma_addr_t sle_dma ;
  cont_a64_entry_t *cont_pkt ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;

  {
#line 715
  cmd = sp->u.scmd.cmd;
#line 718
  *((uint32_t *)(& cmd_pkt->entry_type)) = 24U;
#line 722
  tmp = scsi_bufflen(cmd);
#line 722
  if (tmp == 0U || (unsigned int )cmd->sc_data_direction == 3U) {
#line 723
    cmd_pkt->byte_count = 0U;
#line 724
    return;
  } else {

  }
#line 727
  vha = (sp->fcport)->vha;
#line 728
  req = vha->req;
#line 731
  if ((unsigned int )cmd->sc_data_direction == 1U) {
#line 732
    cmd_pkt->task_mgmt_flags = 1U;
#line 734
    tmp___0 = scsi_bufflen(cmd);
#line 734
    vha->qla_stats.output_bytes = vha->qla_stats.output_bytes + (uint64_t )tmp___0;
#line 735
    vha->qla_stats.output_requests = vha->qla_stats.output_requests + 1ULL;
  } else
#line 736
  if ((unsigned int )cmd->sc_data_direction == 2U) {
#line 737
    cmd_pkt->task_mgmt_flags = 2U;
#line 739
    tmp___1 = scsi_bufflen(cmd);
#line 739
    vha->qla_stats.input_bytes = vha->qla_stats.input_bytes + (uint64_t )tmp___1;
#line 740
    vha->qla_stats.input_requests = vha->qla_stats.input_requests + 1ULL;
  } else {

  }
#line 744
  avail_dsds = 1U;
#line 745
  cur_dsd = (uint32_t *)(& cmd_pkt->dseg_0_address);
#line 749
  i = 0;
#line 749
  sg = scsi_sglist(cmd);
#line 749
  goto ldv_65949;
  ldv_65948: ;
#line 754
  if ((unsigned int )avail_dsds == 0U) {
#line 759
    cont_pkt = qla2x00_prep_cont_type1_iocb(vha, vha->req);
#line 760
    cur_dsd = (uint32_t *)(& cont_pkt->dseg_0_address);
#line 761
    avail_dsds = 5U;
  } else {

  }
#line 764
  sle_dma = sg->dma_address;
#line 765
  tmp___2 = cur_dsd;
#line 765
  cur_dsd = cur_dsd + 1;
#line 765
  *tmp___2 = (unsigned int )sle_dma;
#line 766
  tmp___3 = cur_dsd;
#line 766
  cur_dsd = cur_dsd + 1;
#line 766
  *tmp___3 = (unsigned int )(sle_dma >> 32ULL);
#line 767
  tmp___4 = cur_dsd;
#line 767
  cur_dsd = cur_dsd + 1;
#line 767
  *tmp___4 = sg->dma_length;
#line 768
  avail_dsds = (uint16_t )((int )avail_dsds - 1);
#line 749
  i = i + 1;
#line 749
  sg = sg_next(sg);
  ldv_65949: ;
#line 749
  if ((int )tot_dsds > i) {
#line 751
    goto ldv_65948;
  } else {

  }

#line 756
  return;
}
}
#line 784 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
__inline static void qla24xx_set_t10dif_tags(srb_t *sp , struct fw_dif_context *pkt ,
                                             unsigned int protcnt ) 
{ 
  struct scsi_cmnd *cmd ;
  unsigned char tmp ;
  sector_t tmp___0 ;
  int tmp___1 ;
  sector_t tmp___2 ;
  int tmp___3 ;
  uint8_t tmp___4 ;
  uint8_t tmp___5 ;
  uint8_t tmp___6 ;
  sector_t tmp___7 ;
  int tmp___8 ;

  {
#line 787
  cmd = sp->u.scmd.cmd;
#line 789
  tmp = scsi_get_prot_type(cmd);
#line 789
  switch ((int )tmp) {
  case 0: 
#line 795
  tmp___0 = scsi_get_lba(cmd);
#line 795
  pkt->ref_tag = (unsigned int )tmp___0;
#line 798
  tmp___1 = qla2x00_hba_err_chk_enabled(sp);
#line 798
  if (tmp___1 == 0) {
#line 799
    goto ldv_65963;
  } else {

  }
#line 801
  pkt->ref_tag_mask[0] = 255U;
#line 802
  pkt->ref_tag_mask[1] = 255U;
#line 803
  pkt->ref_tag_mask[2] = 255U;
#line 804
  pkt->ref_tag_mask[3] = 255U;
#line 805
  goto ldv_65963;
  case 2: 
#line 812
  pkt->app_tag = 0U;
#line 813
  pkt->app_tag_mask[0] = 0U;
#line 814
  pkt->app_tag_mask[1] = 0U;
#line 816
  tmp___2 = scsi_get_lba(cmd);
#line 816
  pkt->ref_tag = (unsigned int )tmp___2;
#line 819
  tmp___3 = qla2x00_hba_err_chk_enabled(sp);
#line 819
  if (tmp___3 == 0) {
#line 820
    goto ldv_65963;
  } else {

  }
#line 823
  pkt->ref_tag_mask[0] = 255U;
#line 824
  pkt->ref_tag_mask[1] = 255U;
#line 825
  pkt->ref_tag_mask[2] = 255U;
#line 826
  pkt->ref_tag_mask[3] = 255U;
#line 827
  goto ldv_65963;
  case 3: 
#line 831
  tmp___6 = 0U;
#line 831
  pkt->ref_tag_mask[3] = tmp___6;
#line 831
  tmp___5 = tmp___6;
#line 831
  pkt->ref_tag_mask[2] = tmp___5;
#line 831
  tmp___4 = tmp___5;
#line 831
  pkt->ref_tag_mask[1] = tmp___4;
#line 831
  pkt->ref_tag_mask[0] = tmp___4;
#line 834
  goto ldv_65963;
  case 1: 
#line 841
  tmp___7 = scsi_get_lba(cmd);
#line 841
  pkt->ref_tag = (unsigned int )tmp___7;
#line 843
  pkt->app_tag = 0U;
#line 844
  pkt->app_tag_mask[0] = 0U;
#line 845
  pkt->app_tag_mask[1] = 0U;
#line 847
  tmp___8 = qla2x00_hba_err_chk_enabled(sp);
#line 847
  if (tmp___8 == 0) {
#line 848
    goto ldv_65963;
  } else {

  }
#line 851
  pkt->ref_tag_mask[0] = 255U;
#line 852
  pkt->ref_tag_mask[1] = 255U;
#line 853
  pkt->ref_tag_mask[2] = 255U;
#line 854
  pkt->ref_tag_mask[3] = 255U;
#line 855
  goto ldv_65963;
  }
  ldv_65963: ;
#line 858
  return;
}
}
#line 877 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
static int qla24xx_get_one_block_sg(uint32_t blk_sz , struct qla2_sgx *sgx , uint32_t *partial ) 
{ 
  struct scatterlist *sg ;
  uint32_t cumulative_partial ;
  uint32_t sg_len ;
  dma_addr_t sg_dma_addr ;

  {
#line 884
  if (sgx->num_bytes == sgx->tot_bytes) {
#line 885
    return (0);
  } else {

  }
#line 887
  sg = sgx->cur_sg;
#line 888
  cumulative_partial = sgx->tot_partial;
#line 890
  sg_dma_addr = sg->dma_address;
#line 891
  sg_len = sg->dma_length;
#line 893
  sgx->dma_addr = (dma_addr_t )sgx->bytes_consumed + sg_dma_addr;
#line 895
  if ((sg_len - sgx->bytes_consumed) + cumulative_partial >= blk_sz) {
#line 896
    sgx->dma_len = blk_sz - cumulative_partial;
#line 897
    sgx->tot_partial = 0U;
#line 898
    sgx->num_bytes = sgx->num_bytes + blk_sz;
#line 899
    *partial = 0U;
  } else {
#line 901
    sgx->dma_len = sg_len - sgx->bytes_consumed;
#line 902
    sgx->tot_partial = sgx->tot_partial + sgx->dma_len;
#line 903
    *partial = 1U;
  }
#line 906
  sgx->bytes_consumed = sgx->bytes_consumed + sgx->dma_len;
#line 908
  if (sgx->bytes_consumed == sg_len) {
#line 909
    sg = sg_next(sg);
#line 910
    sgx->num_sg = sgx->num_sg + 1U;
#line 911
    sgx->cur_sg = sg;
#line 912
    sgx->bytes_consumed = 0U;
  } else {

  }
#line 915
  return (1);
}
}
#line 919 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
int qla24xx_walk_and_build_sglist_no_difb(struct qla_hw_data *ha , srb_t *sp , uint32_t *dsd ,
                                          uint16_t tot_dsds , struct qla_tgt_cmd *tc ) 
{ 
  void *next_dsd ;
  uint8_t avail_dsds ;
  uint32_t dsd_list_len ;
  struct dsd_dma *dsd_ptr ;
  struct scatterlist *sg_prot ;
  uint32_t *cur_dsd ;
  uint16_t used_dsds ;
  uint32_t prot_int ;
  uint32_t partial ;
  struct qla2_sgx sgx ;
  dma_addr_t sle_dma ;
  uint32_t sle_dma_len ;
  uint32_t tot_prot_dma_len ;
  struct scsi_cmnd *cmd ;
  struct scsi_qla_host *vha ;
  void *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;
  uint32_t *tmp___5 ;
  int tmp___6 ;
  uint32_t *tmp___7 ;
  uint32_t *tmp___8 ;
  uint32_t *tmp___9 ;

  {
#line 923
  avail_dsds = 0U;
#line 927
  cur_dsd = dsd;
#line 928
  used_dsds = tot_dsds;
#line 934
  tot_prot_dma_len = 0U;
#line 938
  memset((void *)(& sgx), 0, 48UL);
#line 939
  if ((unsigned long )sp != (unsigned long )((srb_t *)0)) {
#line 940
    vha = (sp->fcport)->vha;
#line 941
    cmd = sp->u.scmd.cmd;
#line 942
    prot_int = (cmd->device)->sector_size;
#line 944
    sgx.tot_bytes = scsi_bufflen(cmd);
#line 945
    sgx.cur_sg = scsi_sglist(cmd);
#line 946
    sgx.sp = sp;
#line 948
    sg_prot = scsi_prot_sglist(cmd);
  } else
#line 949
  if ((unsigned long )tc != (unsigned long )((struct qla_tgt_cmd *)0)) {
#line 950
    vha = tc->vha;
#line 951
    prot_int = tc->blk_sz;
#line 952
    sgx.tot_bytes = (uint32_t )tc->bufflen;
#line 953
    sgx.cur_sg = tc->sg;
#line 954
    sg_prot = tc->prot_sg;
  } else {
#line 956
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"),
                         "i" (956), "i" (12UL));
    ldv_66008: ;
#line 956
    goto ldv_66008;
#line 957
    return (1);
  }
#line 960
  goto ldv_66011;
  ldv_66010: 
#line 962
  sle_dma = sgx.dma_addr;
#line 963
  sle_dma_len = sgx.dma_len;
  alloc_and_fill: ;
#line 966
  if ((unsigned int )avail_dsds == 0U) {
#line 967
    avail_dsds = (unsigned int )used_dsds <= 37U ? (uint8_t )used_dsds : 37U;
#line 969
    dsd_list_len = (uint32_t )(((int )avail_dsds + 1) * 12);
#line 970
    used_dsds = (int )used_dsds - (int )((uint16_t )avail_dsds);
#line 973
    tmp = kzalloc(32UL, 32U);
#line 973
    dsd_ptr = (struct dsd_dma *)tmp;
#line 974
    if ((unsigned long )dsd_ptr == (unsigned long )((struct dsd_dma *)0)) {
#line 975
      return (1);
    } else {

    }
#line 978
    next_dsd = dma_pool_alloc(ha->dl_dma_pool, 32U, & dsd_ptr->dsd_list_dma);
#line 978
    dsd_ptr->dsd_addr = next_dsd;
#line 982
    if ((unsigned long )next_dsd == (unsigned long )((void *)0)) {
#line 987
      kfree((void const   *)dsd_ptr);
#line 988
      return (1);
    } else {

    }
#line 991
    if ((unsigned long )sp != (unsigned long )((srb_t *)0)) {
#line 992
      list_add_tail(& dsd_ptr->list, & ((struct crc_context *)sp->u.scmd.ctx)->dsd_list);
#line 996
      sp->flags = (uint16_t )((unsigned int )sp->flags | 32U);
    } else {
#line 998
      list_add_tail(& dsd_ptr->list, & (tc->ctx)->dsd_list);
#line 1000
      tc->ctx_dsd_alloced = 1U;
    }
#line 1005
    tmp___0 = cur_dsd;
#line 1005
    cur_dsd = cur_dsd + 1;
#line 1005
    *tmp___0 = (unsigned int )dsd_ptr->dsd_list_dma;
#line 1006
    tmp___1 = cur_dsd;
#line 1006
    cur_dsd = cur_dsd + 1;
#line 1006
    *tmp___1 = (unsigned int )(dsd_ptr->dsd_list_dma >> 32ULL);
#line 1007
    tmp___2 = cur_dsd;
#line 1007
    cur_dsd = cur_dsd + 1;
#line 1007
    *tmp___2 = dsd_list_len;
#line 1008
    cur_dsd = (uint32_t *)next_dsd;
  } else {

  }
#line 1010
  tmp___3 = cur_dsd;
#line 1010
  cur_dsd = cur_dsd + 1;
#line 1010
  *tmp___3 = (unsigned int )sle_dma;
#line 1011
  tmp___4 = cur_dsd;
#line 1011
  cur_dsd = cur_dsd + 1;
#line 1011
  *tmp___4 = (unsigned int )(sle_dma >> 32ULL);
#line 1012
  tmp___5 = cur_dsd;
#line 1012
  cur_dsd = cur_dsd + 1;
#line 1012
  *tmp___5 = sle_dma_len;
#line 1013
  avail_dsds = (uint8_t )((int )avail_dsds - 1);
#line 1015
  if (partial == 0U) {
#line 1017
    sle_dma = sg_prot->dma_address + (dma_addr_t )tot_prot_dma_len;
#line 1018
    sle_dma_len = 8U;
#line 1020
    tot_prot_dma_len = tot_prot_dma_len + sle_dma_len;
#line 1021
    if (sg_prot->dma_length == tot_prot_dma_len) {
#line 1022
      tot_prot_dma_len = 0U;
#line 1023
      sg_prot = sg_next(sg_prot);
    } else {

    }
#line 1026
    partial = 1U;
#line 1027
    goto alloc_and_fill;
  } else {

  }
  ldv_66011: 
#line 960
  tmp___6 = qla24xx_get_one_block_sg(prot_int, & sgx, & partial);
#line 960
  if (tmp___6 != 0) {
#line 962
    goto ldv_66010;
  } else {

  }
#line 1031
  tmp___7 = cur_dsd;
#line 1031
  cur_dsd = cur_dsd + 1;
#line 1031
  *tmp___7 = 0U;
#line 1032
  tmp___8 = cur_dsd;
#line 1032
  cur_dsd = cur_dsd + 1;
#line 1032
  *tmp___8 = 0U;
#line 1033
  tmp___9 = cur_dsd;
#line 1033
  cur_dsd = cur_dsd + 1;
#line 1033
  *tmp___9 = 0U;
#line 1034
  return (0);
}
}
#line 1038 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
int qla24xx_walk_and_build_sglist(struct qla_hw_data *ha , srb_t *sp , uint32_t *dsd ,
                                  uint16_t tot_dsds , struct qla_tgt_cmd *tc ) 
{ 
  void *next_dsd ;
  uint8_t avail_dsds ;
  uint32_t dsd_list_len ;
  struct dsd_dma *dsd_ptr ;
  struct scatterlist *sg ;
  struct scatterlist *sgl ;
  uint32_t *cur_dsd ;
  int i ;
  uint16_t used_dsds ;
  struct scsi_cmnd *cmd ;
  struct scsi_qla_host *vha ;
  dma_addr_t sle_dma ;
  void *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t *tmp___6 ;
  uint32_t *tmp___7 ;
  uint32_t *tmp___8 ;

  {
#line 1042
  avail_dsds = 0U;
#line 1046
  cur_dsd = dsd;
#line 1048
  used_dsds = tot_dsds;
#line 1052
  if ((unsigned long )sp != (unsigned long )((srb_t *)0)) {
#line 1053
    cmd = sp->u.scmd.cmd;
#line 1054
    sgl = scsi_sglist(cmd);
#line 1055
    vha = (sp->fcport)->vha;
  } else
#line 1056
  if ((unsigned long )tc != (unsigned long )((struct qla_tgt_cmd *)0)) {
#line 1057
    sgl = tc->sg;
#line 1058
    vha = tc->vha;
  } else {
#line 1060
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"),
                         "i" (1060), "i" (12UL));
    ldv_66031: ;
#line 1060
    goto ldv_66031;
#line 1061
    return (1);
  }
#line 1065
  i = 0;
#line 1065
  sg = sgl;
#line 1065
  goto ldv_66034;
  ldv_66033: ;
#line 1069
  if ((unsigned int )avail_dsds == 0U) {
#line 1070
    avail_dsds = (unsigned int )used_dsds <= 37U ? (uint8_t )used_dsds : 37U;
#line 1072
    dsd_list_len = (uint32_t )(((int )avail_dsds + 1) * 12);
#line 1073
    used_dsds = (int )used_dsds - (int )((uint16_t )avail_dsds);
#line 1076
    tmp = kzalloc(32UL, 32U);
#line 1076
    dsd_ptr = (struct dsd_dma *)tmp;
#line 1077
    if ((unsigned long )dsd_ptr == (unsigned long )((struct dsd_dma *)0)) {
#line 1078
      return (1);
    } else {

    }
#line 1081
    next_dsd = dma_pool_alloc(ha->dl_dma_pool, 32U, & dsd_ptr->dsd_list_dma);
#line 1081
    dsd_ptr->dsd_addr = next_dsd;
#line 1085
    if ((unsigned long )next_dsd == (unsigned long )((void *)0)) {
#line 1090
      kfree((void const   *)dsd_ptr);
#line 1091
      return (1);
    } else {

    }
#line 1094
    if ((unsigned long )sp != (unsigned long )((srb_t *)0)) {
#line 1095
      list_add_tail(& dsd_ptr->list, & ((struct crc_context *)sp->u.scmd.ctx)->dsd_list);
#line 1099
      sp->flags = (uint16_t )((unsigned int )sp->flags | 32U);
    } else {
#line 1101
      list_add_tail(& dsd_ptr->list, & (tc->ctx)->dsd_list);
#line 1103
      tc->ctx_dsd_alloced = 1U;
    }
#line 1107
    tmp___0 = cur_dsd;
#line 1107
    cur_dsd = cur_dsd + 1;
#line 1107
    *tmp___0 = (unsigned int )dsd_ptr->dsd_list_dma;
#line 1108
    tmp___1 = cur_dsd;
#line 1108
    cur_dsd = cur_dsd + 1;
#line 1108
    *tmp___1 = (unsigned int )(dsd_ptr->dsd_list_dma >> 32ULL);
#line 1109
    tmp___2 = cur_dsd;
#line 1109
    cur_dsd = cur_dsd + 1;
#line 1109
    *tmp___2 = dsd_list_len;
#line 1110
    cur_dsd = (uint32_t *)next_dsd;
  } else {

  }
#line 1112
  sle_dma = sg->dma_address;
#line 1114
  tmp___3 = cur_dsd;
#line 1114
  cur_dsd = cur_dsd + 1;
#line 1114
  *tmp___3 = (unsigned int )sle_dma;
#line 1115
  tmp___4 = cur_dsd;
#line 1115
  cur_dsd = cur_dsd + 1;
#line 1115
  *tmp___4 = (unsigned int )(sle_dma >> 32ULL);
#line 1116
  tmp___5 = cur_dsd;
#line 1116
  cur_dsd = cur_dsd + 1;
#line 1116
  *tmp___5 = sg->dma_length;
#line 1117
  avail_dsds = (uint8_t )((int )avail_dsds - 1);
#line 1065
  i = i + 1;
#line 1065
  sg = sg_next(sg);
  ldv_66034: ;
#line 1065
  if ((int )tot_dsds > i) {
#line 1067
    goto ldv_66033;
  } else {

  }
#line 1121
  tmp___6 = cur_dsd;
#line 1121
  cur_dsd = cur_dsd + 1;
#line 1121
  *tmp___6 = 0U;
#line 1122
  tmp___7 = cur_dsd;
#line 1122
  cur_dsd = cur_dsd + 1;
#line 1122
  *tmp___7 = 0U;
#line 1123
  tmp___8 = cur_dsd;
#line 1123
  cur_dsd = cur_dsd + 1;
#line 1123
  *tmp___8 = 0U;
#line 1124
  return (0);
}
}
#line 1128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
int qla24xx_walk_and_build_prot_sglist(struct qla_hw_data *ha , srb_t *sp , uint32_t *dsd ,
                                       uint16_t tot_dsds , struct qla_tgt_cmd *tc ) 
{ 
  void *next_dsd ;
  uint8_t avail_dsds ;
  uint32_t dsd_list_len ;
  struct dsd_dma *dsd_ptr ;
  struct scatterlist *sg ;
  struct scatterlist *sgl ;
  int i ;
  struct scsi_cmnd *cmd ;
  uint32_t *cur_dsd ;
  uint16_t used_dsds ;
  struct scsi_qla_host *vha ;
  dma_addr_t sle_dma ;
  void *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t *tmp___6 ;
  uint32_t *tmp___7 ;
  uint32_t *tmp___8 ;

  {
#line 1132
  avail_dsds = 0U;
#line 1138
  cur_dsd = dsd;
#line 1139
  used_dsds = tot_dsds;
#line 1142
  if ((unsigned long )sp != (unsigned long )((srb_t *)0)) {
#line 1143
    cmd = sp->u.scmd.cmd;
#line 1144
    sgl = scsi_prot_sglist(cmd);
#line 1145
    vha = (sp->fcport)->vha;
  } else
#line 1146
  if ((unsigned long )tc != (unsigned long )((struct qla_tgt_cmd *)0)) {
#line 1147
    vha = tc->vha;
#line 1148
    sgl = tc->prot_sg;
  } else {
#line 1150
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"),
                         "i" (1150), "i" (12UL));
    ldv_66054: ;
#line 1150
    goto ldv_66054;
#line 1151
    return (1);
  }
#line 1154
  ql_dbg(16384U, vha, 57377, "%s: enter\n", "qla24xx_walk_and_build_prot_sglist");
#line 1157
  i = 0;
#line 1157
  sg = sgl;
#line 1157
  goto ldv_66058;
  ldv_66057: ;
#line 1161
  if ((unsigned int )avail_dsds == 0U) {
#line 1162
    avail_dsds = (unsigned int )used_dsds <= 37U ? (uint8_t )used_dsds : 37U;
#line 1164
    dsd_list_len = (uint32_t )(((int )avail_dsds + 1) * 12);
#line 1165
    used_dsds = (int )used_dsds - (int )((uint16_t )avail_dsds);
#line 1168
    tmp = kzalloc(32UL, 32U);
#line 1168
    dsd_ptr = (struct dsd_dma *)tmp;
#line 1169
    if ((unsigned long )dsd_ptr == (unsigned long )((struct dsd_dma *)0)) {
#line 1170
      return (1);
    } else {

    }
#line 1173
    next_dsd = dma_pool_alloc(ha->dl_dma_pool, 32U, & dsd_ptr->dsd_list_dma);
#line 1173
    dsd_ptr->dsd_addr = next_dsd;
#line 1177
    if ((unsigned long )next_dsd == (unsigned long )((void *)0)) {
#line 1182
      kfree((void const   *)dsd_ptr);
#line 1183
      return (1);
    } else {

    }
#line 1186
    if ((unsigned long )sp != (unsigned long )((srb_t *)0)) {
#line 1187
      list_add_tail(& dsd_ptr->list, & ((struct crc_context *)sp->u.scmd.ctx)->dsd_list);
#line 1191
      sp->flags = (uint16_t )((unsigned int )sp->flags | 32U);
    } else {
#line 1193
      list_add_tail(& dsd_ptr->list, & (tc->ctx)->dsd_list);
#line 1195
      tc->ctx_dsd_alloced = 1U;
    }
#line 1199
    tmp___0 = cur_dsd;
#line 1199
    cur_dsd = cur_dsd + 1;
#line 1199
    *tmp___0 = (unsigned int )dsd_ptr->dsd_list_dma;
#line 1200
    tmp___1 = cur_dsd;
#line 1200
    cur_dsd = cur_dsd + 1;
#line 1200
    *tmp___1 = (unsigned int )(dsd_ptr->dsd_list_dma >> 32ULL);
#line 1201
    tmp___2 = cur_dsd;
#line 1201
    cur_dsd = cur_dsd + 1;
#line 1201
    *tmp___2 = dsd_list_len;
#line 1202
    cur_dsd = (uint32_t *)next_dsd;
  } else {

  }
#line 1204
  sle_dma = sg->dma_address;
#line 1206
  tmp___3 = cur_dsd;
#line 1206
  cur_dsd = cur_dsd + 1;
#line 1206
  *tmp___3 = (unsigned int )sle_dma;
#line 1207
  tmp___4 = cur_dsd;
#line 1207
  cur_dsd = cur_dsd + 1;
#line 1207
  *tmp___4 = (unsigned int )(sle_dma >> 32ULL);
#line 1208
  tmp___5 = cur_dsd;
#line 1208
  cur_dsd = cur_dsd + 1;
#line 1208
  *tmp___5 = sg->dma_length;
#line 1210
  avail_dsds = (uint8_t )((int )avail_dsds - 1);
#line 1157
  i = i + 1;
#line 1157
  sg = sg_next(sg);
  ldv_66058: ;
#line 1157
  if ((int )tot_dsds > i) {
#line 1159
    goto ldv_66057;
  } else {

  }
#line 1213
  tmp___6 = cur_dsd;
#line 1213
  cur_dsd = cur_dsd + 1;
#line 1213
  *tmp___6 = 0U;
#line 1214
  tmp___7 = cur_dsd;
#line 1214
  cur_dsd = cur_dsd + 1;
#line 1214
  *tmp___7 = 0U;
#line 1215
  tmp___8 = cur_dsd;
#line 1215
  cur_dsd = cur_dsd + 1;
#line 1215
  *tmp___8 = 0U;
#line 1216
  return (0);
}
}
#line 1228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
__inline static int qla24xx_build_scsi_crc_2_iocbs(srb_t *sp , struct cmd_type_crc_2 *cmd_pkt ,
                                                   uint16_t tot_dsds , uint16_t tot_prot_dsds ,
                                                   uint16_t fw_prot_opts ) 
{ 
  uint32_t *cur_dsd ;
  uint32_t *fcp_dl ;
  scsi_qla_host_t *vha ;
  struct scsi_cmnd *cmd ;
  int sgc ;
  uint32_t total_bytes ;
  uint32_t data_bytes ;
  uint32_t dif_bytes ;
  uint8_t bundling ;
  uint16_t blk_size ;
  uint8_t *clr_ptr ;
  struct crc_context *crc_ctx_pkt ;
  struct qla_hw_data *ha ;
  uint8_t additional_fcpcdb_len ;
  uint16_t fcp_cmnd_len ;
  struct fcp_cmnd *fcp_cmnd ;
  dma_addr_t crc_ctx_dma ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;
  void *tmp___3 ;
  unsigned char tmp___4 ;
  unsigned char tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  int tmp___8 ;
  __u32 tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 1235
  total_bytes = 0U;
#line 1238
  bundling = 1U;
#line 1241
  crc_ctx_pkt = (struct crc_context *)0;
#line 1248
  cmd = sp->u.scmd.cmd;
#line 1250
  sgc = 0;
#line 1252
  *((uint32_t *)(& cmd_pkt->entry_type)) = 106U;
#line 1255
  vha = (sp->fcport)->vha;
#line 1256
  ha = vha->hw;
#line 1259
  data_bytes = scsi_bufflen(cmd);
#line 1260
  if (data_bytes == 0U || (unsigned int )cmd->sc_data_direction == 3U) {
#line 1261
    cmd_pkt->byte_count = 0U;
#line 1262
    return (0);
  } else {

  }
#line 1265
  cmd_pkt->vp_index = (uint8_t )((sp->fcport)->vha)->vp_idx;
#line 1268
  if ((unsigned int )cmd->sc_data_direction == 1U) {
#line 1269
    cmd_pkt->control_flags = 1U;
  } else
#line 1271
  if ((unsigned int )cmd->sc_data_direction == 2U) {
#line 1272
    cmd_pkt->control_flags = 2U;
  } else {

  }
#line 1276
  tmp = scsi_get_prot_op(cmd);
#line 1276
  if ((unsigned int )tmp == 1U) {
#line 1280
    bundling = 0U;
  } else {
#line 1276
    tmp___0 = scsi_get_prot_op(cmd);
#line 1276
    if ((unsigned int )tmp___0 == 2U) {
#line 1280
      bundling = 0U;
    } else {
#line 1276
      tmp___1 = scsi_get_prot_op(cmd);
#line 1276
      if ((unsigned int )tmp___1 == 3U) {
#line 1280
        bundling = 0U;
      } else {
#line 1276
        tmp___2 = scsi_get_prot_op(cmd);
#line 1276
        if ((unsigned int )tmp___2 == 4U) {
#line 1280
          bundling = 0U;
        } else {

        }
      }
    }
  }
#line 1283
  tmp___3 = dma_pool_alloc(ha->dl_dma_pool, 32U, & crc_ctx_dma);
#line 1283
  sp->u.scmd.ctx = tmp___3;
#line 1283
  crc_ctx_pkt = (struct crc_context *)tmp___3;
#line 1286
  if ((unsigned long )crc_ctx_pkt == (unsigned long )((struct crc_context *)0)) {
#line 1287
    goto crc_queuing_error;
  } else {

  }
#line 1290
  clr_ptr = (uint8_t *)crc_ctx_pkt;
#line 1291
  memset((void *)clr_ptr, 0, 360UL);
#line 1293
  crc_ctx_pkt->crc_ctx_dma = crc_ctx_dma;
#line 1295
  sp->flags = (uint16_t )((unsigned int )sp->flags | 4U);
#line 1298
  crc_ctx_pkt->handle = cmd_pkt->handle;
#line 1300
  INIT_LIST_HEAD(& crc_ctx_pkt->dsd_list);
#line 1302
  qla24xx_set_t10dif_tags(sp, (struct fw_dif_context *)(& crc_ctx_pkt->ref_tag), (unsigned int )tot_prot_dsds);
#line 1305
  cmd_pkt->crc_context_address[0] = (unsigned int )crc_ctx_dma;
#line 1306
  cmd_pkt->crc_context_address[1] = (unsigned int )(crc_ctx_dma >> 32ULL);
#line 1307
  cmd_pkt->crc_context_len = 64U;
#line 1310
  if ((unsigned int )cmd->cmd_len > 16U) {
#line 1311
    additional_fcpcdb_len = (unsigned int )((uint8_t )cmd->cmd_len) + 240U;
#line 1312
    if (((unsigned int )cmd->cmd_len & 3U) != 0U) {
#line 1314
      goto crc_queuing_error;
    } else {

    }
#line 1316
    fcp_cmnd_len = (unsigned int )cmd->cmd_len + 16U;
  } else {
#line 1318
    additional_fcpcdb_len = 0U;
#line 1319
    fcp_cmnd_len = 32U;
  }
#line 1322
  fcp_cmnd = & crc_ctx_pkt->fcp_cmnd;
#line 1324
  fcp_cmnd->additional_cdb_len = additional_fcpcdb_len;
#line 1325
  if ((unsigned int )cmd->sc_data_direction == 1U) {
#line 1326
    fcp_cmnd->additional_cdb_len = (uint8_t )((unsigned int )fcp_cmnd->additional_cdb_len | 1U);
  } else
#line 1327
  if ((unsigned int )cmd->sc_data_direction == 2U) {
#line 1328
    fcp_cmnd->additional_cdb_len = (uint8_t )((unsigned int )fcp_cmnd->additional_cdb_len | 2U);
  } else {

  }
#line 1330
  int_to_scsilun((cmd->device)->lun, & fcp_cmnd->lun);
#line 1331
  memcpy((void *)(& fcp_cmnd->cdb), (void const   *)cmd->cmnd, (size_t )cmd->cmd_len);
#line 1332
  cmd_pkt->fcp_cmnd_dseg_len = fcp_cmnd_len;
#line 1333
  cmd_pkt->fcp_cmnd_dseg_address[0] = (unsigned int )crc_ctx_dma + 64U;
#line 1335
  cmd_pkt->fcp_cmnd_dseg_address[1] = (unsigned int )((crc_ctx_dma + 64ULL) >> 32ULL);
#line 1337
  fcp_cmnd->task_management = 0U;
#line 1338
  fcp_cmnd->task_attribute = 0U;
#line 1340
  cmd_pkt->fcp_rsp_dseg_len = 0U;
#line 1343
  dif_bytes = 0U;
#line 1344
  blk_size = (uint16_t )(cmd->device)->sector_size;
#line 1345
  dif_bytes = (data_bytes / (uint32_t )blk_size) * 8U;
#line 1347
  tmp___4 = scsi_get_prot_op(sp->u.scmd.cmd);
#line 1347
  switch ((int )tmp___4) {
  case 1: ;
  case 2: 
#line 1350
  total_bytes = data_bytes;
#line 1351
  data_bytes = data_bytes + dif_bytes;
#line 1352
  goto ldv_66087;
  case 3: ;
  case 4: ;
  case 5: ;
  case 6: 
#line 1358
  total_bytes = data_bytes + dif_bytes;
#line 1359
  goto ldv_66087;
  default: 
#line 1361
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"),
                       "i" (1361), "i" (12UL));
  ldv_66093: ;
#line 1361
  goto ldv_66093;
  }
  ldv_66087: 
#line 1364
  tmp___8 = qla2x00_hba_err_chk_enabled(sp);
#line 1364
  if (tmp___8 == 0) {
#line 1365
    fw_prot_opts = (uint16_t )((unsigned int )fw_prot_opts | 16U);
  } else
#line 1367
  if ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 1368
    tmp___6 = scsi_get_prot_type(sp->u.scmd.cmd);
#line 1368
    if ((unsigned int )tmp___6 == 1U) {
#line 1371
      fw_prot_opts = (uint16_t )((unsigned int )fw_prot_opts | 1024U);
    } else {
#line 1368
      tmp___7 = scsi_get_prot_type(sp->u.scmd.cmd);
#line 1368
      if ((unsigned int )tmp___7 == 2U) {
#line 1371
        fw_prot_opts = (uint16_t )((unsigned int )fw_prot_opts | 1024U);
      } else {
#line 1372
        tmp___5 = scsi_get_prot_type(sp->u.scmd.cmd);
#line 1372
        if ((unsigned int )tmp___5 == 3U) {
#line 1374
          fw_prot_opts = (uint16_t )((unsigned int )fw_prot_opts | 2048U);
        } else {

        }
      }
    }
  } else {

  }
#line 1377
  if ((unsigned int )bundling == 0U) {
#line 1378
    cur_dsd = (uint32_t *)(& crc_ctx_pkt->u.nobundling.data_address);
  } else {
#line 1384
    fw_prot_opts = (uint16_t )((unsigned int )fw_prot_opts | 256U);
#line 1385
    crc_ctx_pkt->u.bundling.dif_byte_count = dif_bytes;
#line 1386
    crc_ctx_pkt->u.bundling.dseg_count = (int )tot_dsds - (int )tot_prot_dsds;
#line 1388
    cur_dsd = (uint32_t *)(& crc_ctx_pkt->u.bundling.data_address);
  }
#line 1392
  crc_ctx_pkt->blk_size = blk_size;
#line 1393
  crc_ctx_pkt->prot_opts = fw_prot_opts;
#line 1394
  crc_ctx_pkt->byte_count = data_bytes;
#line 1395
  crc_ctx_pkt->guard_seed = 0U;
#line 1397
  cmd_pkt->byte_count = total_bytes;
#line 1398
  fcp_dl = (uint32_t *)(& crc_ctx_pkt->fcp_cmnd.cdb) + ((unsigned long )additional_fcpcdb_len + 16UL);
#line 1400
  tmp___9 = __fswab32(total_bytes);
#line 1400
  *fcp_dl = tmp___9;
#line 1402
  if (data_bytes == 0U || (unsigned int )cmd->sc_data_direction == 3U) {
#line 1403
    cmd_pkt->byte_count = 0U;
#line 1404
    return (0);
  } else {

  }
#line 1408
  cmd_pkt->control_flags = (uint16_t )((unsigned int )cmd_pkt->control_flags | 4U);
#line 1411
  if ((unsigned int )bundling == 0U && (unsigned int )tot_prot_dsds != 0U) {
#line 1412
    tmp___10 = qla24xx_walk_and_build_sglist_no_difb(ha, sp, cur_dsd, (int )tot_dsds,
                                                     (struct qla_tgt_cmd *)0);
#line 1412
    if (tmp___10 != 0) {
#line 1414
      goto crc_queuing_error;
    } else {

    }
  } else {
#line 1415
    tmp___11 = qla24xx_walk_and_build_sglist(ha, sp, cur_dsd, (int )tot_dsds - (int )tot_prot_dsds,
                                             (struct qla_tgt_cmd *)0);
#line 1415
    if (tmp___11 != 0) {
#line 1417
      goto crc_queuing_error;
    } else {

    }
  }
#line 1419
  if ((unsigned int )bundling != 0U && (unsigned int )tot_prot_dsds != 0U) {
#line 1421
    cmd_pkt->control_flags = (uint16_t )((unsigned int )cmd_pkt->control_flags | 8U);
#line 1423
    cur_dsd = (uint32_t *)(& crc_ctx_pkt->u.bundling.dif_address);
#line 1424
    tmp___12 = qla24xx_walk_and_build_prot_sglist(ha, sp, cur_dsd, (int )tot_prot_dsds,
                                                  (struct qla_tgt_cmd *)0);
#line 1424
    if (tmp___12 != 0) {
#line 1426
      goto crc_queuing_error;
    } else {

    }
  } else {

  }
#line 1428
  return (0);
  crc_queuing_error: ;
#line 1433
  return (258);
}
}
#line 1443 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
int qla24xx_start_scsi(srb_t *sp ) 
{ 
  int ret ;
  int nseg ;
  unsigned long flags ;
  uint32_t *clr_ptr ;
  uint32_t index ;
  uint32_t handle ;
  struct cmd_type_7 *cmd_pkt ;
  uint16_t cnt ;
  uint16_t req_cnt ;
  uint16_t tot_dsds ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  struct scsi_cmnd *cmd ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned int tmp___1 ;
  struct scatterlist *tmp___2 ;
  long tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;

  {
#line 1454
  req = (struct req_que *)0;
#line 1455
  rsp = (struct rsp_que *)0;
#line 1456
  cmd = sp->u.scmd.cmd;
#line 1457
  vha = (sp->fcport)->vha;
#line 1458
  ha = vha->hw;
#line 1461
  ret = 0;
#line 1463
  qla25xx_set_que(sp, & rsp);
#line 1464
  req = vha->req;
#line 1467
  tot_dsds = 0U;
#line 1470
  if ((unsigned int )vha->marker_needed != 0U) {
#line 1471
    tmp = qla2x00_marker(vha, req, rsp, 0, 0ULL, 2);
#line 1471
    if (tmp != 0) {
#line 1473
      return (258);
    } else {

    }
#line 1474
    vha->marker_needed = 0U;
  } else {

  }
#line 1478
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 1478
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 1481
  handle = req->current_outstanding_cmd;
#line 1482
  index = 1U;
#line 1482
  goto ldv_66117;
  ldv_66116: 
#line 1483
  handle = handle + 1U;
#line 1484
  if ((uint32_t )req->num_outstanding_cmds == handle) {
#line 1485
    handle = 1U;
  } else {

  }
#line 1486
  if ((unsigned long )*(req->outstanding_cmds + (unsigned long )handle) == (unsigned long )((srb_t *)0)) {
#line 1487
    goto ldv_66115;
  } else {

  }
#line 1482
  index = index + 1U;
  ldv_66117: ;
#line 1482
  if ((uint32_t )req->num_outstanding_cmds > index) {
#line 1484
    goto ldv_66116;
  } else {

  }
  ldv_66115: ;
#line 1489
  if ((uint32_t )req->num_outstanding_cmds == index) {
#line 1490
    goto queuing_error;
  } else {

  }
#line 1493
  tmp___4 = scsi_sg_count(cmd);
#line 1493
  if (tmp___4 != 0U) {
#line 1494
    tmp___1 = scsi_sg_count(cmd);
#line 1494
    tmp___2 = scsi_sglist(cmd);
#line 1494
    nseg = dma_map_sg_attrs(& (ha->pdev)->dev, tmp___2, (int )tmp___1, cmd->sc_data_direction,
                            (struct dma_attrs *)0);
#line 1496
    tmp___3 = ldv__builtin_expect(nseg == 0, 0L);
#line 1496
    if (tmp___3 != 0L) {
#line 1497
      goto queuing_error;
    } else {

    }
  } else {
#line 1499
    nseg = 0;
  }
#line 1501
  tot_dsds = (uint16_t )nseg;
#line 1502
  req_cnt = qla24xx_calc_iocbs(vha, (int )tot_dsds);
#line 1503
  if ((int )req->cnt < (int )req_cnt + 2) {
#line 1504
    if ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) {
#line 1504
      cnt = *(req->out_ptr);
    } else {
#line 1504
      tmp___5 = __readl((void const volatile   *)req->req_q_out);
#line 1504
      cnt = (uint16_t )tmp___5;
    }
#line 1506
    if ((int )req->ring_index < (int )cnt) {
#line 1507
      req->cnt = (int )cnt - (int )req->ring_index;
    } else {
#line 1509
      req->cnt = (int )req->length + ((int )cnt - (int )req->ring_index);
    }
#line 1511
    if ((int )req->cnt < (int )req_cnt + 2) {
#line 1512
      goto queuing_error;
    } else {

    }
  } else {

  }
#line 1516
  req->current_outstanding_cmd = handle;
#line 1517
  *(req->outstanding_cmds + (unsigned long )handle) = sp;
#line 1518
  sp->handle = handle;
#line 1519
  cmd->host_scribble = (unsigned char *)((unsigned long )handle);
#line 1520
  req->cnt = (int )req->cnt - (int )req_cnt;
#line 1522
  cmd_pkt = (struct cmd_type_7 *)req->ring_ptr;
#line 1523
  cmd_pkt->handle = ((unsigned int )req->id << 16) | handle;
#line 1527
  clr_ptr = (uint32_t *)cmd_pkt + 2UL;
#line 1528
  memset((void *)clr_ptr, 0, 56UL);
#line 1529
  cmd_pkt->dseg_count = tot_dsds;
#line 1532
  cmd_pkt->nport_handle = (sp->fcport)->loop_id;
#line 1533
  cmd_pkt->port_id[0] = (sp->fcport)->d_id.b.al_pa;
#line 1534
  cmd_pkt->port_id[1] = (sp->fcport)->d_id.b.area;
#line 1535
  cmd_pkt->port_id[2] = (sp->fcport)->d_id.b.domain;
#line 1536
  cmd_pkt->vp_index = (uint8_t )((sp->fcport)->vha)->vp_idx;
#line 1538
  int_to_scsilun((cmd->device)->lun, & cmd_pkt->lun);
#line 1539
  host_to_fcp_swap((uint8_t *)(& cmd_pkt->lun), 8U);
#line 1541
  cmd_pkt->task = 0U;
#line 1544
  memcpy((void *)(& cmd_pkt->fcp_cdb), (void const   *)cmd->cmnd, (size_t )cmd->cmd_len);
#line 1545
  host_to_fcp_swap((uint8_t *)(& cmd_pkt->fcp_cdb), 16U);
#line 1547
  cmd_pkt->byte_count = scsi_bufflen(cmd);
#line 1550
  qla24xx_build_scsi_iocbs(sp, cmd_pkt, (int )tot_dsds);
#line 1553
  cmd_pkt->entry_count = (unsigned char )req_cnt;
#line 1555
  cmd_pkt->entry_status = (unsigned char )rsp->id;
#line 1556
  __asm__  volatile   ("sfence": : : "memory");
#line 1558
  req->ring_index = (uint16_t )((int )req->ring_index + 1);
#line 1559
  if ((int )req->ring_index == (int )req->length) {
#line 1560
    req->ring_index = 0U;
#line 1561
    req->ring_ptr = req->ring;
  } else {
#line 1563
    req->ring_ptr = req->ring_ptr + 1;
  }
#line 1565
  sp->flags = (uint16_t )((unsigned int )sp->flags | 1U);
#line 1568
  writel((unsigned int )req->ring_index, (void volatile   *)req->req_q_in);
#line 1569
  __readl((void const volatile   *)(& (ha->iobase)->isp24.hccr));
#line 1572
  if (*((unsigned long *)vha + 19UL) != 0UL && (rsp->ring_ptr)->signature != 3735936685U) {
#line 1574
    qla24xx_process_response_queue(vha, rsp);
  } else {

  }
#line 1576
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1577
  return (0);
  queuing_error: ;
#line 1580
  if ((unsigned int )tot_dsds != 0U) {
#line 1581
    scsi_dma_unmap(cmd);
  } else {

  }
#line 1583
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1585
  return (258);
}
}
#line 1595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
int qla24xx_dif_start_scsi(srb_t *sp ) 
{ 
  int nseg ;
  unsigned long flags ;
  uint32_t *clr_ptr ;
  uint32_t index ;
  uint32_t handle ;
  uint16_t cnt ;
  uint16_t req_cnt ;
  uint16_t tot_dsds ;
  uint16_t tot_prot_dsds ;
  uint16_t fw_prot_opts ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  struct scsi_cmnd *cmd ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct cmd_type_crc_2 *cmd_pkt ;
  uint32_t status ;
  int tmp ;
  unsigned char tmp___0 ;
  int tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  unsigned int tmp___3 ;
  struct scatterlist *tmp___4 ;
  long tmp___5 ;
  struct qla2_sgx sgx ;
  uint32_t partial ;
  int tmp___6 ;
  unsigned char tmp___7 ;
  unsigned char tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  struct scatterlist *tmp___11 ;
  long tmp___12 ;
  unsigned int tmp___13 ;
  unsigned char tmp___14 ;
  unsigned char tmp___15 ;
  int tmp___16 ;
  unsigned int tmp___17 ;
  int tmp___18 ;

  {
#line 1603
  req_cnt = 0U;
#line 1606
  fw_prot_opts = 0U;
#line 1607
  req = (struct req_que *)0;
#line 1608
  rsp = (struct rsp_que *)0;
#line 1609
  cmd = sp->u.scmd.cmd;
#line 1610
  vha = (sp->fcport)->vha;
#line 1611
  ha = vha->hw;
#line 1613
  status = 0U;
#line 1618
  tmp___0 = scsi_get_prot_op(cmd);
#line 1618
  if ((unsigned int )tmp___0 == 0U) {
#line 1619
    if ((unsigned int )cmd->cmd_len <= 16U) {
#line 1620
      tmp = qla24xx_start_scsi(sp);
#line 1620
      return (tmp);
    } else {

    }
  } else {

  }
#line 1625
  qla25xx_set_que(sp, & rsp);
#line 1626
  req = vha->req;
#line 1629
  tot_dsds = 0U;
#line 1632
  if ((unsigned int )vha->marker_needed != 0U) {
#line 1633
    tmp___1 = qla2x00_marker(vha, req, rsp, 0, 0ULL, 2);
#line 1633
    if (tmp___1 != 0) {
#line 1635
      return (258);
    } else {

    }
#line 1636
    vha->marker_needed = 0U;
  } else {

  }
#line 1640
  tmp___2 = spinlock_check(& ha->hardware_lock);
#line 1640
  flags = _raw_spin_lock_irqsave(tmp___2);
#line 1643
  handle = req->current_outstanding_cmd;
#line 1644
  index = 1U;
#line 1644
  goto ldv_66144;
  ldv_66143: 
#line 1645
  handle = handle + 1U;
#line 1646
  if ((uint32_t )req->num_outstanding_cmds == handle) {
#line 1647
    handle = 1U;
  } else {

  }
#line 1648
  if ((unsigned long )*(req->outstanding_cmds + (unsigned long )handle) == (unsigned long )((srb_t *)0)) {
#line 1649
    goto ldv_66142;
  } else {

  }
#line 1644
  index = index + 1U;
  ldv_66144: ;
#line 1644
  if ((uint32_t )req->num_outstanding_cmds > index) {
#line 1646
    goto ldv_66143;
  } else {

  }
  ldv_66142: ;
#line 1652
  if ((uint32_t )req->num_outstanding_cmds == index) {
#line 1653
    goto queuing_error;
  } else {

  }
#line 1657
  tmp___9 = scsi_sg_count(cmd);
#line 1657
  if (tmp___9 != 0U) {
#line 1658
    tmp___3 = scsi_sg_count(cmd);
#line 1658
    tmp___4 = scsi_sglist(cmd);
#line 1658
    nseg = dma_map_sg_attrs(& (ha->pdev)->dev, tmp___4, (int )tmp___3, cmd->sc_data_direction,
                            (struct dma_attrs *)0);
#line 1660
    tmp___5 = ldv__builtin_expect(nseg == 0, 0L);
#line 1660
    if (tmp___5 != 0L) {
#line 1661
      goto queuing_error;
    } else {
#line 1663
      sp->flags = (uint16_t )((unsigned int )sp->flags | 1U);
    }
#line 1665
    tmp___7 = scsi_get_prot_op(cmd);
#line 1665
    if ((unsigned int )tmp___7 == 1U) {
#line 1665
      goto _L;
    } else {
#line 1665
      tmp___8 = scsi_get_prot_op(cmd);
#line 1665
      if ((unsigned int )tmp___8 == 2U) {
        _L: /* CIL Label */ 
#line 1670
        memset((void *)(& sgx), 0, 48UL);
#line 1671
        sgx.tot_bytes = scsi_bufflen(cmd);
#line 1672
        sgx.cur_sg = scsi_sglist(cmd);
#line 1673
        sgx.sp = sp;
#line 1675
        nseg = 0;
#line 1676
        goto ldv_66149;
        ldv_66148: 
#line 1678
        nseg = nseg + 1;
        ldv_66149: 
#line 1676
        tmp___6 = qla24xx_get_one_block_sg((cmd->device)->sector_size, & sgx, & partial);
#line 1676
        if (tmp___6 != 0) {
#line 1678
          goto ldv_66148;
        } else {

        }

      } else {

      }
    }
  } else {
#line 1681
    nseg = 0;
  }
#line 1684
  tot_dsds = (uint16_t )nseg;
#line 1687
  tmp___16 = qla24xx_configure_prot_mode(sp, & fw_prot_opts);
#line 1687
  if (tmp___16 != 0) {
#line 1688
    tmp___10 = scsi_prot_sg_count(cmd);
#line 1688
    tmp___11 = scsi_prot_sglist(cmd);
#line 1688
    nseg = dma_map_sg_attrs(& (ha->pdev)->dev, tmp___11, (int )tmp___10, cmd->sc_data_direction,
                            (struct dma_attrs *)0);
#line 1690
    tmp___12 = ldv__builtin_expect(nseg == 0, 0L);
#line 1690
    if (tmp___12 != 0L) {
#line 1691
      goto queuing_error;
    } else {
#line 1693
      sp->flags = (uint16_t )((unsigned int )sp->flags | 16U);
    }
#line 1695
    tmp___14 = scsi_get_prot_op(cmd);
#line 1695
    if ((unsigned int )tmp___14 == 1U) {
#line 1697
      tmp___13 = scsi_bufflen(cmd);
#line 1697
      nseg = (int )(tmp___13 / (cmd->device)->sector_size);
    } else {
#line 1695
      tmp___15 = scsi_get_prot_op(cmd);
#line 1695
      if ((unsigned int )tmp___15 == 2U) {
#line 1697
        tmp___13 = scsi_bufflen(cmd);
#line 1697
        nseg = (int )(tmp___13 / (cmd->device)->sector_size);
      } else {

      }
    }
  } else {
#line 1700
    nseg = 0;
  }
#line 1703
  req_cnt = 1U;
#line 1705
  tot_prot_dsds = (uint16_t )nseg;
#line 1706
  tot_dsds = (int )((uint16_t )nseg) + (int )tot_dsds;
#line 1707
  if ((int )req->cnt < (int )req_cnt + 2) {
#line 1708
    if ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) {
#line 1708
      cnt = *(req->out_ptr);
    } else {
#line 1708
      tmp___17 = __readl((void const volatile   *)req->req_q_out);
#line 1708
      cnt = (uint16_t )tmp___17;
    }
#line 1710
    if ((int )req->ring_index < (int )cnt) {
#line 1711
      req->cnt = (int )cnt - (int )req->ring_index;
    } else {
#line 1713
      req->cnt = (int )req->length + ((int )cnt - (int )req->ring_index);
    }
#line 1715
    if ((int )req->cnt < (int )req_cnt + 2) {
#line 1716
      goto queuing_error;
    } else {

    }
  } else {

  }
#line 1719
  status = status | 1U;
#line 1722
  req->current_outstanding_cmd = handle;
#line 1723
  *(req->outstanding_cmds + (unsigned long )handle) = sp;
#line 1724
  sp->handle = handle;
#line 1725
  cmd->host_scribble = (unsigned char *)((unsigned long )handle);
#line 1726
  req->cnt = (int )req->cnt - (int )req_cnt;
#line 1729
  cmd_pkt = (struct cmd_type_crc_2 *)req->ring_ptr;
#line 1730
  cmd_pkt->handle = ((unsigned int )req->id << 16) | handle;
#line 1732
  clr_ptr = (uint32_t *)cmd_pkt + 2UL;
#line 1733
  memset((void *)clr_ptr, 0, 56UL);
#line 1736
  cmd_pkt->nport_handle = (sp->fcport)->loop_id;
#line 1737
  cmd_pkt->port_id[0] = (sp->fcport)->d_id.b.al_pa;
#line 1738
  cmd_pkt->port_id[1] = (sp->fcport)->d_id.b.area;
#line 1739
  cmd_pkt->port_id[2] = (sp->fcport)->d_id.b.domain;
#line 1741
  int_to_scsilun((cmd->device)->lun, & cmd_pkt->lun);
#line 1742
  host_to_fcp_swap((uint8_t *)(& cmd_pkt->lun), 8U);
#line 1745
  cmd_pkt->dseg_count = tot_dsds;
#line 1748
  tmp___18 = qla24xx_build_scsi_crc_2_iocbs(sp, (struct cmd_type_crc_2 *)req->ring_ptr,
                                            (int )tot_dsds, (int )tot_prot_dsds, (int )fw_prot_opts);
#line 1748
  if (tmp___18 != 0) {
#line 1751
    goto queuing_error;
  } else {

  }
#line 1753
  cmd_pkt->entry_count = (unsigned char )req_cnt;
#line 1755
  cmd_pkt->entry_status = (unsigned char )rsp->id;
#line 1756
  cmd_pkt->timeout = 0U;
#line 1757
  __asm__  volatile   ("sfence": : : "memory");
#line 1760
  req->ring_index = (uint16_t )((int )req->ring_index + 1);
#line 1761
  if ((int )req->ring_index == (int )req->length) {
#line 1762
    req->ring_index = 0U;
#line 1763
    req->ring_ptr = req->ring;
  } else {
#line 1765
    req->ring_ptr = req->ring_ptr + 1;
  }
#line 1768
  writel((unsigned int )req->ring_index, (void volatile   *)req->req_q_in);
#line 1769
  __readl((void const volatile   *)(& (ha->iobase)->isp24.hccr));
#line 1772
  if (*((unsigned long *)vha + 19UL) != 0UL && (rsp->ring_ptr)->signature != 3735936685U) {
#line 1774
    qla24xx_process_response_queue(vha, rsp);
  } else {

  }
#line 1776
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1778
  return (0);
  queuing_error: ;
#line 1781
  if ((int )status & 1) {
#line 1782
    *(req->outstanding_cmds + (unsigned long )handle) = (srb_t *)0;
#line 1783
    req->cnt = (int )req->cnt + (int )req_cnt;
  } else {

  }
#line 1787
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1788
  return (258);
}
}
#line 1792 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
static void qla25xx_set_que(srb_t *sp , struct rsp_que **rsp ) 
{ 
  struct scsi_cmnd *cmd ;
  struct qla_hw_data *ha ;
  int affinity ;

  {
#line 1794
  cmd = sp->u.scmd.cmd;
#line 1795
  ha = ((sp->fcport)->vha)->hw;
#line 1796
  affinity = (cmd->request)->cpu;
#line 1798
  if ((*((unsigned long *)ha + 2UL) != 0UL && affinity >= 0) && (int )ha->max_rsp_queues + -1 > affinity) {
#line 1800
    *rsp = *(ha->rsp_q_map + ((unsigned long )affinity + 1UL));
  } else {
#line 1802
    *rsp = *(ha->rsp_q_map);
  }
#line 1803
  return;
}
}
#line 1809 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
void *qla2x00_alloc_iocbs_ready(struct scsi_qla_host *vha , srb_t *sp ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 1811
  tmp = qla2x00_reset_active(vha);
#line 1811
  if (tmp != 0) {
#line 1812
    return ((void *)0);
  } else {

  }
#line 1814
  tmp___0 = qla2x00_alloc_iocbs(vha, sp);
#line 1814
  return (tmp___0);
}
}
#line 1818 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
void *qla2x00_alloc_iocbs(struct scsi_qla_host *vha , srb_t *sp ) 
{ 
  struct qla_hw_data *ha ;
  struct req_que *req ;
  device_reg_t *reg ;
  uint32_t index ;
  uint32_t handle ;
  request_t *pkt ;
  uint16_t cnt ;
  uint16_t req_cnt ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 1820
  ha = vha->hw;
#line 1821
  req = *(ha->req_q_map);
#line 1822
  reg = ((unsigned int )ha->mqenable != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) ? ha->mqiobase + (unsigned long )((int )req->id * 4096) : ha->iobase;
#line 1827
  pkt = (request_t *)0;
#line 1828
  req_cnt = 1U;
#line 1829
  handle = 0U;
#line 1831
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 1832
    goto skip_cmd_array;
  } else {

  }
#line 1835
  handle = req->current_outstanding_cmd;
#line 1836
  index = 1U;
#line 1836
  goto ldv_66177;
  ldv_66176: 
#line 1837
  handle = handle + 1U;
#line 1838
  if ((uint32_t )req->num_outstanding_cmds == handle) {
#line 1839
    handle = 1U;
  } else {

  }
#line 1840
  if ((unsigned long )*(req->outstanding_cmds + (unsigned long )handle) == (unsigned long )((srb_t *)0)) {
#line 1841
    goto ldv_66175;
  } else {

  }
#line 1836
  index = index + 1U;
  ldv_66177: ;
#line 1836
  if ((uint32_t )req->num_outstanding_cmds > index) {
#line 1838
    goto ldv_66176;
  } else {

  }
  ldv_66175: ;
#line 1843
  if ((uint32_t )req->num_outstanding_cmds == index) {
#line 1844
    ql_log(1U, vha, 28683, "No room on outstanding cmd array.\n");
#line 1846
    goto queuing_error;
  } else {

  }
#line 1850
  req->current_outstanding_cmd = handle;
#line 1851
  *(req->outstanding_cmds + (unsigned long )handle) = sp;
#line 1852
  sp->handle = handle;
#line 1855
  if ((unsigned int )sp->type != 8U) {
#line 1856
    req_cnt = (uint16_t )sp->iocbs;
  } else {

  }
  skip_cmd_array: ;
#line 1860
  if ((int )req->cnt < (int )req_cnt + 2) {
#line 1861
    if (((unsigned int )ha->mqenable != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 1862
      tmp = readl((void const volatile   *)(& reg->isp25mq.req_q_out));
#line 1862
      cnt = (uint16_t )tmp;
    } else
#line 1863
    if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1864
      tmp___0 = readl((void const volatile   *)(& reg->isp82.req_q_out));
#line 1864
      cnt = (uint16_t )tmp___0;
    } else
#line 1865
    if ((ha->device_type & 134217728U) != 0U) {
#line 1866
      tmp___1 = readl((void const volatile   *)(& reg->isp24.req_q_out));
#line 1866
      cnt = (uint16_t )tmp___1;
    } else
#line 1867
    if ((ha->device_type & 131072U) != 0U) {
#line 1868
      tmp___2 = readl((void const volatile   *)(& reg->ispfx00.req_q_out));
#line 1868
      cnt = (uint16_t )tmp___2;
    } else {
#line 1870
      cnt = qla2x00_debounce_register___0((uint16_t volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->isp.u.isp2100.mailbox4 : & reg->isp.u.isp2300.req_q_out));
    }
#line 1873
    if ((int )req->ring_index < (int )cnt) {
#line 1874
      req->cnt = (int )cnt - (int )req->ring_index;
    } else {
#line 1876
      req->cnt = (int )req->length + ((int )cnt - (int )req->ring_index);
    }
  } else {

  }
#line 1879
  if ((int )req->cnt < (int )req_cnt + 2) {
#line 1880
    goto queuing_error;
  } else {

  }
#line 1883
  req->cnt = (int )req->cnt - (int )req_cnt;
#line 1884
  pkt = req->ring_ptr;
#line 1885
  memset((void *)pkt, 0, 64UL);
#line 1886
  if ((ha->device_type & 131072U) != 0U) {
#line 1887
    writeb((int )((unsigned char )req_cnt), (void volatile   *)(& pkt->entry_count));
#line 1888
    writew((int )((unsigned short )handle), (void volatile   *)(& pkt->handle));
  } else {
#line 1890
    pkt->entry_count = (uint8_t )req_cnt;
#line 1891
    pkt->handle = handle;
  }
  queuing_error: ;
#line 1895
  return ((void *)pkt);
}
}
#line 1899 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
static void qla24xx_login_iocb(srb_t *sp , struct logio_entry_24xx *logio ) 
{ 
  struct srb_iocb *lio ;

  {
#line 1901
  lio = & sp->u.iocb_cmd;
#line 1903
  logio->entry_type = 82U;
#line 1904
  logio->control_flags = 0U;
#line 1905
  if (((int )lio->u.logio.flags & 2) != 0) {
#line 1906
    logio->control_flags = (uint16_t )((unsigned int )logio->control_flags | 16U);
  } else {

  }
#line 1907
  if (((int )lio->u.logio.flags & 4) != 0) {
#line 1908
    logio->control_flags = (uint16_t )((unsigned int )logio->control_flags | 32U);
  } else {

  }
#line 1909
  logio->nport_handle = (sp->fcport)->loop_id;
#line 1910
  logio->port_id[0] = (sp->fcport)->d_id.b.al_pa;
#line 1911
  logio->port_id[1] = (sp->fcport)->d_id.b.area;
#line 1912
  logio->port_id[2] = (sp->fcport)->d_id.b.domain;
#line 1913
  logio->vp_index = (uint8_t )((sp->fcport)->vha)->vp_idx;
#line 1914
  return;
}
}
#line 1917 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
static void qla2x00_login_iocb(srb_t *sp , struct mbx_entry *mbx ) 
{ 
  struct qla_hw_data *ha ;
  struct srb_iocb *lio ;
  uint16_t opts ;

  {
#line 1919
  ha = ((sp->fcport)->vha)->hw;
#line 1920
  lio = & sp->u.iocb_cmd;
#line 1923
  mbx->entry_type = 57U;
#line 1924
  if ((int )ha->device_type < 0) {
#line 1924
    mbx->loop_id.extended = (sp->fcport)->loop_id;
  } else {
#line 1924
    mbx->loop_id.id.standard = (unsigned char )(sp->fcport)->loop_id;
  }
#line 1925
  mbx->mb0 = 111U;
#line 1926
  opts = ((int )lio->u.logio.flags & 2) != 0;
#line 1927
  opts = (uint16_t )((((int )lio->u.logio.flags & 4) != 0 ? 2 : 0) | (int )((short )opts));
#line 1928
  if ((int )ha->device_type < 0) {
#line 1929
    mbx->mb1 = (sp->fcport)->loop_id;
#line 1930
    mbx->mb10 = opts;
  } else {
#line 1932
    mbx->mb1 = (unsigned short )((int )((short )((int )(sp->fcport)->loop_id << 8)) | (int )((short )opts));
  }
#line 1934
  mbx->mb2 = (unsigned short )(sp->fcport)->d_id.b.domain;
#line 1935
  mbx->mb3 = (unsigned short )((int )((short )((int )(sp->fcport)->d_id.b.area << 8)) | (int )((short )(sp->fcport)->d_id.b.al_pa));
#line 1937
  mbx->mb9 = ((sp->fcport)->vha)->vp_idx;
#line 1938
  return;
}
}
#line 1941 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
static void qla24xx_logout_iocb(srb_t *sp , struct logio_entry_24xx *logio ) 
{ 


  {
#line 1943
  logio->entry_type = 82U;
#line 1944
  logio->control_flags = 24U;
#line 1946
  logio->nport_handle = (sp->fcport)->loop_id;
#line 1947
  logio->port_id[0] = (sp->fcport)->d_id.b.al_pa;
#line 1948
  logio->port_id[1] = (sp->fcport)->d_id.b.area;
#line 1949
  logio->port_id[2] = (sp->fcport)->d_id.b.domain;
#line 1950
  logio->vp_index = (uint8_t )((sp->fcport)->vha)->vp_idx;
#line 1951
  return;
}
}
#line 1954 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
static void qla2x00_logout_iocb(srb_t *sp , struct mbx_entry *mbx ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 1956
  ha = ((sp->fcport)->vha)->hw;
#line 1958
  mbx->entry_type = 57U;
#line 1959
  if ((int )ha->device_type < 0) {
#line 1959
    mbx->loop_id.extended = (sp->fcport)->loop_id;
  } else {
#line 1959
    mbx->loop_id.id.standard = (unsigned char )(sp->fcport)->loop_id;
  }
#line 1960
  mbx->mb0 = 113U;
#line 1961
  mbx->mb1 = (int )ha->device_type < 0 ? (sp->fcport)->loop_id : (uint16_t )((int )(sp->fcport)->loop_id << 8U);
#line 1964
  mbx->mb2 = (unsigned short )(sp->fcport)->d_id.b.domain;
#line 1965
  mbx->mb3 = (unsigned short )((int )((short )((int )(sp->fcport)->d_id.b.area << 8)) | (int )((short )(sp->fcport)->d_id.b.al_pa));
#line 1967
  mbx->mb9 = ((sp->fcport)->vha)->vp_idx;
#line 1968
  return;
}
}
#line 1972 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
static void qla24xx_adisc_iocb(srb_t *sp , struct logio_entry_24xx *logio ) 
{ 


  {
#line 1974
  logio->entry_type = 82U;
#line 1975
  logio->control_flags = 3U;
#line 1976
  logio->nport_handle = (sp->fcport)->loop_id;
#line 1977
  logio->vp_index = (uint8_t )((sp->fcport)->vha)->vp_idx;
#line 1978
  return;
}
}
#line 1981 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
static void qla2x00_adisc_iocb(srb_t *sp , struct mbx_entry *mbx ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 1983
  ha = ((sp->fcport)->vha)->hw;
#line 1985
  mbx->entry_type = 57U;
#line 1986
  if ((int )ha->device_type < 0) {
#line 1986
    mbx->loop_id.extended = (sp->fcport)->loop_id;
  } else {
#line 1986
    mbx->loop_id.id.standard = (unsigned char )(sp->fcport)->loop_id;
  }
#line 1987
  mbx->mb0 = 100U;
#line 1988
  if ((int )ha->device_type < 0) {
#line 1989
    mbx->mb1 = (sp->fcport)->loop_id;
#line 1990
    mbx->mb10 = 1U;
  } else {
#line 1992
    mbx->mb1 = (unsigned short )((int )((short )((int )(sp->fcport)->loop_id << 8)) | 1);
  }
#line 1994
  mbx->mb2 = (unsigned short )((unsigned int )ha->async_pd_dma >> 16);
#line 1995
  mbx->mb3 = (unsigned short )ha->async_pd_dma;
#line 1996
  mbx->mb6 = (unsigned short )((unsigned int )(ha->async_pd_dma >> 32ULL) >> 16);
#line 1997
  mbx->mb7 = (unsigned short )(ha->async_pd_dma >> 32ULL);
#line 1998
  mbx->mb9 = ((sp->fcport)->vha)->vp_idx;
#line 1999
  return;
}
}
#line 2002 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
static void qla24xx_tm_iocb(srb_t *sp , struct tsk_mgmt_entry *tsk ) 
{ 
  uint32_t flags ;
  uint64_t lun ;
  struct fc_port *fcport ;
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct srb_iocb *iocb ;
  struct req_que *req ;

  {
#line 2006
  fcport = sp->fcport;
#line 2007
  vha = fcport->vha;
#line 2008
  ha = vha->hw;
#line 2009
  iocb = & sp->u.iocb_cmd;
#line 2010
  req = vha->req;
#line 2012
  flags = iocb->u.tmf.flags;
#line 2013
  lun = iocb->u.tmf.lun;
#line 2015
  tsk->entry_type = 20U;
#line 2016
  tsk->entry_count = 1U;
#line 2017
  tsk->handle = ((unsigned int )req->id << 16) | tsk->handle;
#line 2018
  tsk->nport_handle = fcport->loop_id;
#line 2019
  tsk->timeout = ((unsigned int )ha->r_a_tov / 10U) * 2U;
#line 2020
  tsk->control_flags = flags;
#line 2021
  tsk->port_id[0] = fcport->d_id.b.al_pa;
#line 2022
  tsk->port_id[1] = fcport->d_id.b.area;
#line 2023
  tsk->port_id[2] = fcport->d_id.b.domain;
#line 2024
  tsk->vp_index = (uint8_t )(fcport->vha)->vp_idx;
#line 2026
  if (flags == 16U) {
#line 2027
    int_to_scsilun(lun, & tsk->lun);
#line 2028
    host_to_fcp_swap((uint8_t *)(& tsk->lun), 8U);
  } else {

  }
#line 2030
  return;
}
}
#line 2034 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
static void qla24xx_els_iocb(srb_t *sp , struct els_entry_24xx *els_iocb ) 
{ 
  struct fc_bsg_job *bsg_job ;

  {
#line 2036
  bsg_job = sp->u.bsg_job;
#line 2038
  els_iocb->entry_type = 83U;
#line 2039
  els_iocb->entry_count = 1U;
#line 2040
  els_iocb->sys_define = 0U;
#line 2041
  els_iocb->entry_status = 0U;
#line 2042
  els_iocb->handle = sp->handle;
#line 2043
  els_iocb->nport_handle = (sp->fcport)->loop_id;
#line 2044
  els_iocb->tx_dsd_count = (unsigned short )bsg_job->request_payload.sg_cnt;
#line 2045
  els_iocb->vp_index = (uint8_t )((sp->fcport)->vha)->vp_idx;
#line 2046
  els_iocb->sof_type = 16U;
#line 2047
  els_iocb->rx_dsd_count = (unsigned short )bsg_job->reply_payload.sg_cnt;
#line 2049
  els_iocb->opcode = (unsigned int )sp->type == 3U ? (bsg_job->request)->rqst_data.r_els.els_code : (bsg_job->request)->rqst_data.h_els.command_code;
#line 2053
  els_iocb->port_id[0] = (sp->fcport)->d_id.b.al_pa;
#line 2054
  els_iocb->port_id[1] = (sp->fcport)->d_id.b.area;
#line 2055
  els_iocb->port_id[2] = (sp->fcport)->d_id.b.domain;
#line 2056
  els_iocb->control_flags = 0U;
#line 2057
  els_iocb->rx_byte_count = bsg_job->reply_payload.payload_len;
#line 2059
  els_iocb->tx_byte_count = bsg_job->request_payload.payload_len;
#line 2062
  els_iocb->tx_address[0] = (unsigned int )(bsg_job->request_payload.sg_list)->dma_address;
#line 2064
  els_iocb->tx_address[1] = (unsigned int )((bsg_job->request_payload.sg_list)->dma_address >> 32ULL);
#line 2066
  els_iocb->tx_len = (bsg_job->request_payload.sg_list)->dma_length;
#line 2069
  els_iocb->rx_address[0] = (unsigned int )(bsg_job->reply_payload.sg_list)->dma_address;
#line 2071
  els_iocb->rx_address[1] = (unsigned int )((bsg_job->reply_payload.sg_list)->dma_address >> 32ULL);
#line 2073
  els_iocb->rx_len = (bsg_job->reply_payload.sg_list)->dma_length;
#line 2076
  ((sp->fcport)->vha)->qla_stats.control_requests = ((sp->fcport)->vha)->qla_stats.control_requests + 1U;
#line 2077
  return;
}
}
#line 2080 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
static void qla2x00_ct_iocb(srb_t *sp , ms_iocb_entry_t *ct_iocb ) 
{ 
  uint16_t avail_dsds ;
  uint32_t *cur_dsd ;
  struct scatterlist *sg ;
  int index ;
  uint16_t tot_dsds ;
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct fc_bsg_job *bsg_job ;
  int loop_iterartion ;
  int cont_iocb_prsnt ;
  int entry_count ;
  dma_addr_t sle_dma ;
  cont_a64_entry_t *cont_pkt ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;

  {
#line 2087
  vha = (sp->fcport)->vha;
#line 2088
  ha = vha->hw;
#line 2089
  bsg_job = sp->u.bsg_job;
#line 2090
  loop_iterartion = 0;
#line 2091
  cont_iocb_prsnt = 0;
#line 2092
  entry_count = 1;
#line 2094
  memset((void *)ct_iocb, 0, 64UL);
#line 2095
  ct_iocb->entry_type = 41U;
#line 2096
  ct_iocb->entry_status = 0U;
#line 2097
  ct_iocb->handle1 = sp->handle;
#line 2098
  if ((int )ha->device_type < 0) {
#line 2098
    ct_iocb->loop_id.extended = (sp->fcport)->loop_id;
  } else {
#line 2098
    ct_iocb->loop_id.id.standard = (unsigned char )(sp->fcport)->loop_id;
  }
#line 2099
  ct_iocb->status = 0U;
#line 2100
  ct_iocb->control_flags = 0U;
#line 2101
  ct_iocb->timeout = 0U;
#line 2102
  ct_iocb->cmd_dsd_count = (unsigned short )bsg_job->request_payload.sg_cnt;
#line 2104
  ct_iocb->total_dsd_count = (unsigned int )((unsigned short )bsg_job->request_payload.sg_cnt) + 1U;
#line 2106
  ct_iocb->req_bytecount = bsg_job->request_payload.payload_len;
#line 2108
  ct_iocb->rsp_bytecount = bsg_job->reply_payload.payload_len;
#line 2111
  ct_iocb->dseg_req_address[0] = (unsigned int )(bsg_job->request_payload.sg_list)->dma_address;
#line 2113
  ct_iocb->dseg_req_address[1] = (unsigned int )((bsg_job->request_payload.sg_list)->dma_address >> 32ULL);
#line 2115
  ct_iocb->dseg_req_length = ct_iocb->req_bytecount;
#line 2117
  ct_iocb->dseg_rsp_address[0] = (unsigned int )(bsg_job->reply_payload.sg_list)->dma_address;
#line 2119
  ct_iocb->dseg_rsp_address[1] = (unsigned int )((bsg_job->reply_payload.sg_list)->dma_address >> 32ULL);
#line 2121
  ct_iocb->dseg_rsp_length = ct_iocb->rsp_bytecount;
#line 2123
  avail_dsds = 1U;
#line 2124
  cur_dsd = (uint32_t *)(& ct_iocb->dseg_rsp_address);
#line 2125
  index = 0;
#line 2126
  tot_dsds = (uint16_t )bsg_job->reply_payload.sg_cnt;
#line 2128
  index = 0;
#line 2128
  sg = bsg_job->reply_payload.sg_list;
#line 2128
  goto ldv_66243;
  ldv_66242: ;
#line 2133
  if ((unsigned int )avail_dsds == 0U) {
#line 2138
    cont_pkt = qla2x00_prep_cont_type1_iocb(vha, *((vha->hw)->req_q_map));
#line 2140
    cur_dsd = (uint32_t *)(& cont_pkt->dseg_0_address);
#line 2141
    avail_dsds = 5U;
#line 2142
    cont_iocb_prsnt = 1;
#line 2143
    entry_count = entry_count + 1;
  } else {

  }
#line 2146
  sle_dma = sg->dma_address;
#line 2147
  tmp = cur_dsd;
#line 2147
  cur_dsd = cur_dsd + 1;
#line 2147
  *tmp = (unsigned int )sle_dma;
#line 2148
  tmp___0 = cur_dsd;
#line 2148
  cur_dsd = cur_dsd + 1;
#line 2148
  *tmp___0 = (unsigned int )(sle_dma >> 32ULL);
#line 2149
  tmp___1 = cur_dsd;
#line 2149
  cur_dsd = cur_dsd + 1;
#line 2149
  *tmp___1 = sg->dma_length;
#line 2150
  loop_iterartion = loop_iterartion + 1;
#line 2151
  avail_dsds = (uint16_t )((int )avail_dsds - 1);
#line 2128
  index = index + 1;
#line 2128
  sg = sg_next(sg);
  ldv_66243: ;
#line 2128
  if ((int )tot_dsds > index) {
#line 2130
    goto ldv_66242;
  } else {

  }
#line 2153
  ct_iocb->entry_count = (uint8_t )entry_count;
#line 2155
  ((sp->fcport)->vha)->qla_stats.control_requests = ((sp->fcport)->vha)->qla_stats.control_requests + 1U;
#line 2156
  return;
}
}
#line 2159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
static void qla24xx_ct_iocb(srb_t *sp , struct ct_entry_24xx *ct_iocb ) 
{ 
  uint16_t avail_dsds ;
  uint32_t *cur_dsd ;
  struct scatterlist *sg ;
  int index ;
  uint16_t tot_dsds ;
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct fc_bsg_job *bsg_job ;
  int loop_iterartion ;
  int cont_iocb_prsnt ;
  int entry_count ;
  dma_addr_t sle_dma ;
  cont_a64_entry_t *cont_pkt ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;

  {
#line 2166
  vha = (sp->fcport)->vha;
#line 2167
  ha = vha->hw;
#line 2168
  bsg_job = sp->u.bsg_job;
#line 2169
  loop_iterartion = 0;
#line 2170
  cont_iocb_prsnt = 0;
#line 2171
  entry_count = 1;
#line 2173
  ct_iocb->entry_type = 41U;
#line 2174
  ct_iocb->entry_status = 0U;
#line 2175
  ct_iocb->sys_define = 0U;
#line 2176
  ct_iocb->handle = sp->handle;
#line 2178
  ct_iocb->nport_handle = (sp->fcport)->loop_id;
#line 2179
  ct_iocb->vp_index = (uint8_t )((sp->fcport)->vha)->vp_idx;
#line 2180
  ct_iocb->comp_status = 0U;
#line 2182
  ct_iocb->cmd_dsd_count = (unsigned short )bsg_job->request_payload.sg_cnt;
#line 2184
  ct_iocb->timeout = 0U;
#line 2185
  ct_iocb->rsp_dsd_count = (unsigned short )bsg_job->reply_payload.sg_cnt;
#line 2187
  ct_iocb->rsp_byte_count = bsg_job->reply_payload.payload_len;
#line 2189
  ct_iocb->cmd_byte_count = bsg_job->request_payload.payload_len;
#line 2191
  ct_iocb->dseg_0_address[0] = (unsigned int )(bsg_job->request_payload.sg_list)->dma_address;
#line 2193
  ct_iocb->dseg_0_address[1] = (unsigned int )((bsg_job->request_payload.sg_list)->dma_address >> 32ULL);
#line 2195
  ct_iocb->dseg_0_len = (bsg_job->request_payload.sg_list)->dma_length;
#line 2198
  avail_dsds = 1U;
#line 2199
  cur_dsd = (uint32_t *)(& ct_iocb->dseg_1_address);
#line 2200
  index = 0;
#line 2201
  tot_dsds = (uint16_t )bsg_job->reply_payload.sg_cnt;
#line 2203
  index = 0;
#line 2203
  sg = bsg_job->reply_payload.sg_list;
#line 2203
  goto ldv_66263;
  ldv_66262: ;
#line 2208
  if ((unsigned int )avail_dsds == 0U) {
#line 2213
    cont_pkt = qla2x00_prep_cont_type1_iocb(vha, *(ha->req_q_map));
#line 2215
    cur_dsd = (uint32_t *)(& cont_pkt->dseg_0_address);
#line 2216
    avail_dsds = 5U;
#line 2217
    cont_iocb_prsnt = 1;
#line 2218
    entry_count = entry_count + 1;
  } else {

  }
#line 2221
  sle_dma = sg->dma_address;
#line 2222
  tmp = cur_dsd;
#line 2222
  cur_dsd = cur_dsd + 1;
#line 2222
  *tmp = (unsigned int )sle_dma;
#line 2223
  tmp___0 = cur_dsd;
#line 2223
  cur_dsd = cur_dsd + 1;
#line 2223
  *tmp___0 = (unsigned int )(sle_dma >> 32ULL);
#line 2224
  tmp___1 = cur_dsd;
#line 2224
  cur_dsd = cur_dsd + 1;
#line 2224
  *tmp___1 = sg->dma_length;
#line 2225
  loop_iterartion = loop_iterartion + 1;
#line 2226
  avail_dsds = (uint16_t )((int )avail_dsds - 1);
#line 2203
  index = index + 1;
#line 2203
  sg = sg_next(sg);
  ldv_66263: ;
#line 2203
  if ((int )tot_dsds > index) {
#line 2205
    goto ldv_66262;
  } else {

  }
#line 2228
  ct_iocb->entry_count = (uint8_t )entry_count;
#line 2229
  return;
}
}
#line 2238 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
int qla82xx_start_scsi(srb_t *sp ) 
{ 
  int ret ;
  int nseg ;
  unsigned long flags ;
  struct scsi_cmnd *cmd ;
  uint32_t *clr_ptr ;
  uint32_t index ;
  uint32_t handle ;
  uint16_t cnt ;
  uint16_t req_cnt ;
  uint16_t tot_dsds ;
  struct device_reg_82xx *reg ;
  uint32_t dbval ;
  uint32_t *fcp_dl ;
  uint8_t additional_cdb_len ;
  struct ct6_dsd *ctx ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned int tmp___1 ;
  struct scatterlist *tmp___2 ;
  long tmp___3 ;
  unsigned int tmp___4 ;
  struct cmd_type_6 *cmd_pkt ;
  uint16_t more_dsd_lists ;
  struct dsd_dma *dsd_ptr ;
  uint16_t i ;
  void *tmp___5 ;
  unsigned int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  unsigned int tmp___10 ;
  __u32 tmp___11 ;
  struct cmd_type_7 *cmd_pkt___0 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;

  {
#line 2254
  vha = (sp->fcport)->vha;
#line 2255
  ha = vha->hw;
#line 2256
  req = (struct req_que *)0;
#line 2257
  rsp = (struct rsp_que *)0;
#line 2260
  ret = 0;
#line 2261
  reg = & (ha->iobase)->isp82;
#line 2262
  cmd = sp->u.scmd.cmd;
#line 2263
  req = vha->req;
#line 2264
  rsp = *(ha->rsp_q_map);
#line 2267
  tot_dsds = 0U;
#line 2269
  dbval = (uint32_t )(((int )ha->portnum << 5) | 4);
#line 2272
  if ((unsigned int )vha->marker_needed != 0U) {
#line 2273
    tmp = qla2x00_marker(vha, req, rsp, 0, 0ULL, 2);
#line 2273
    if (tmp != 0) {
#line 2275
      ql_log(1U, vha, 12300, "qla2x00_marker failed for cmd=%p.\n", cmd);
#line 2277
      return (258);
    } else {

    }
#line 2279
    vha->marker_needed = 0U;
  } else {

  }
#line 2283
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 2283
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 2286
  handle = req->current_outstanding_cmd;
#line 2287
  index = 1U;
#line 2287
  goto ldv_66292;
  ldv_66291: 
#line 2288
  handle = handle + 1U;
#line 2289
  if ((uint32_t )req->num_outstanding_cmds == handle) {
#line 2290
    handle = 1U;
  } else {

  }
#line 2291
  if ((unsigned long )*(req->outstanding_cmds + (unsigned long )handle) == (unsigned long )((srb_t *)0)) {
#line 2292
    goto ldv_66290;
  } else {

  }
#line 2287
  index = index + 1U;
  ldv_66292: ;
#line 2287
  if ((uint32_t )req->num_outstanding_cmds > index) {
#line 2289
    goto ldv_66291;
  } else {

  }
  ldv_66290: ;
#line 2294
  if ((uint32_t )req->num_outstanding_cmds == index) {
#line 2295
    goto queuing_error;
  } else {

  }
#line 2298
  tmp___4 = scsi_sg_count(cmd);
#line 2298
  if (tmp___4 != 0U) {
#line 2299
    tmp___1 = scsi_sg_count(cmd);
#line 2299
    tmp___2 = scsi_sglist(cmd);
#line 2299
    nseg = dma_map_sg_attrs(& (ha->pdev)->dev, tmp___2, (int )tmp___1, cmd->sc_data_direction,
                            (struct dma_attrs *)0);
#line 2301
    tmp___3 = ldv__builtin_expect(nseg == 0, 0L);
#line 2301
    if (tmp___3 != 0L) {
#line 2302
      goto queuing_error;
    } else {

    }
  } else {
#line 2304
    nseg = 0;
  }
#line 2306
  tot_dsds = (uint16_t )nseg;
#line 2308
  if ((int )tot_dsds > ql2xshiftctondsd) {
#line 2310
    more_dsd_lists = 0U;
#line 2314
    more_dsd_lists = qla24xx_calc_dsd_lists((int )tot_dsds);
#line 2315
    if ((int )more_dsd_lists + (int )ha->gbl_dsd_inuse > 4095) {
#line 2316
      ql_dbg(134217728U, vha, 12301, "Num of DSD list %d is than %d for cmd=%p.\n",
             (int )more_dsd_lists + (int )ha->gbl_dsd_inuse, 4096, cmd);
#line 2320
      goto queuing_error;
    } else {

    }
#line 2323
    if ((int )ha->gbl_dsd_avail >= (int )more_dsd_lists) {
#line 2324
      goto sufficient_dsds;
    } else {
#line 2326
      more_dsd_lists = (int )more_dsd_lists - (int )ha->gbl_dsd_avail;
    }
#line 2328
    i = 0U;
#line 2328
    goto ldv_66300;
    ldv_66299: 
#line 2329
    tmp___5 = kzalloc(32UL, 32U);
#line 2329
    dsd_ptr = (struct dsd_dma *)tmp___5;
#line 2330
    if ((unsigned long )dsd_ptr == (unsigned long )((struct dsd_dma *)0)) {
#line 2331
      ql_log(0U, vha, 12302, "Failed to allocate memory for dsd_dma for cmd=%p.\n",
             cmd);
#line 2334
      goto queuing_error;
    } else {

    }
#line 2337
    dsd_ptr->dsd_addr = dma_pool_alloc(ha->dl_dma_pool, 32U, & dsd_ptr->dsd_list_dma);
#line 2339
    if ((unsigned long )dsd_ptr->dsd_addr == (unsigned long )((void *)0)) {
#line 2340
      kfree((void const   *)dsd_ptr);
#line 2341
      ql_log(0U, vha, 12303, "Failed to allocate memory for dsd_addr for cmd=%p.\n",
             cmd);
#line 2344
      goto queuing_error;
    } else {

    }
#line 2346
    list_add_tail(& dsd_ptr->list, & ha->gbl_dsd_list);
#line 2347
    ha->gbl_dsd_avail = (uint16_t )((int )ha->gbl_dsd_avail + 1);
#line 2328
    i = (uint16_t )((int )i + 1);
    ldv_66300: ;
#line 2328
    if ((int )i < (int )more_dsd_lists) {
#line 2330
      goto ldv_66299;
    } else {

    }

    sufficient_dsds: 
#line 2351
    req_cnt = 1U;
#line 2353
    if ((int )req->cnt < (int )req_cnt + 2) {
#line 2354
      tmp___6 = __readl((void const volatile   *)(& reg->req_q_out));
#line 2354
      cnt = (unsigned short )tmp___6;
#line 2356
      if ((int )req->ring_index < (int )cnt) {
#line 2357
        req->cnt = (int )cnt - (int )req->ring_index;
      } else {
#line 2359
        req->cnt = (int )req->length + ((int )cnt - (int )req->ring_index);
      }
#line 2361
      if ((int )req->cnt < (int )req_cnt + 2) {
#line 2362
        goto queuing_error;
      } else {

      }
    } else {

    }
#line 2365
    tmp___7 = mempool_alloc(ha->ctx_mempool, 32U);
#line 2365
    sp->u.scmd.ctx = tmp___7;
#line 2365
    ctx = (struct ct6_dsd *)tmp___7;
#line 2367
    if ((unsigned long )ctx == (unsigned long )((struct ct6_dsd *)0)) {
#line 2368
      ql_log(0U, vha, 12304, "Failed to allocate ctx for cmd=%p.\n", cmd);
#line 2370
      goto queuing_error;
    } else {

    }
#line 2373
    memset((void *)ctx, 0, 48UL);
#line 2374
    tmp___8 = dma_pool_alloc(ha->fcp_cmnd_dma_pool, 32U, & ctx->fcp_cmnd_dma);
#line 2374
    ctx->fcp_cmnd = (struct fcp_cmnd *)tmp___8;
#line 2376
    if ((unsigned long )ctx->fcp_cmnd == (unsigned long )((struct fcp_cmnd *)0)) {
#line 2377
      ql_log(0U, vha, 12305, "Failed to allocate fcp_cmnd for cmd=%p.\n", cmd);
#line 2379
      goto queuing_error;
    } else {

    }
#line 2383
    INIT_LIST_HEAD(& ctx->dsd_list);
#line 2384
    ctx->dsd_use_cnt = 0;
#line 2386
    if ((unsigned int )cmd->cmd_len > 16U) {
#line 2387
      additional_cdb_len = (unsigned int )((uint8_t )cmd->cmd_len) + 240U;
#line 2388
      if (((unsigned int )cmd->cmd_len & 3U) != 0U) {
#line 2392
        ql_log(1U, vha, 12306, "scsi cmd len %d not multiple of 4 for cmd=%p.\n",
               (int )cmd->cmd_len, cmd);
#line 2395
        goto queuing_error_fcp_cmnd;
      } else {

      }
#line 2397
      ctx->fcp_cmnd_len = (unsigned int )cmd->cmd_len + 16U;
    } else {
#line 2399
      additional_cdb_len = 0U;
#line 2400
      ctx->fcp_cmnd_len = 32U;
    }
#line 2403
    cmd_pkt = (struct cmd_type_6 *)req->ring_ptr;
#line 2404
    cmd_pkt->handle = ((unsigned int )req->id << 16) | handle;
#line 2408
    clr_ptr = (uint32_t *)cmd_pkt + 2UL;
#line 2409
    memset((void *)clr_ptr, 0, 56UL);
#line 2410
    cmd_pkt->dseg_count = tot_dsds;
#line 2413
    cmd_pkt->nport_handle = (sp->fcport)->loop_id;
#line 2414
    cmd_pkt->port_id[0] = (sp->fcport)->d_id.b.al_pa;
#line 2415
    cmd_pkt->port_id[1] = (sp->fcport)->d_id.b.area;
#line 2416
    cmd_pkt->port_id[2] = (sp->fcport)->d_id.b.domain;
#line 2417
    cmd_pkt->vp_index = (uint8_t )((sp->fcport)->vha)->vp_idx;
#line 2420
    tmp___9 = qla24xx_build_scsi_type_6_iocbs(sp, cmd_pkt, (int )tot_dsds);
#line 2420
    if (tmp___9 != 0) {
#line 2421
      goto queuing_error_fcp_cmnd;
    } else {

    }
#line 2423
    int_to_scsilun((cmd->device)->lun, & cmd_pkt->lun);
#line 2424
    host_to_fcp_swap((uint8_t *)(& cmd_pkt->lun), 8U);
#line 2427
    memset((void *)ctx->fcp_cmnd, 0, 272UL);
#line 2428
    int_to_scsilun((cmd->device)->lun, & (ctx->fcp_cmnd)->lun);
#line 2429
    (ctx->fcp_cmnd)->additional_cdb_len = additional_cdb_len;
#line 2431
    if ((unsigned int )cmd->sc_data_direction == 1U) {
#line 2432
      (ctx->fcp_cmnd)->additional_cdb_len = (uint8_t )((unsigned int )(ctx->fcp_cmnd)->additional_cdb_len | 1U);
    } else
#line 2433
    if ((unsigned int )cmd->sc_data_direction == 2U) {
#line 2434
      (ctx->fcp_cmnd)->additional_cdb_len = (uint8_t )((unsigned int )(ctx->fcp_cmnd)->additional_cdb_len | 2U);
    } else {

    }
#line 2437
    if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 2438
      (ctx->fcp_cmnd)->task_attribute = (uint8_t )((int )((signed char )(ctx->fcp_cmnd)->task_attribute) | (int )((signed char )((int )(sp->fcport)->fcp_prio << 3)));
    } else {

    }
#line 2441
    memcpy((void *)(& (ctx->fcp_cmnd)->cdb), (void const   *)cmd->cmnd, (size_t )cmd->cmd_len);
#line 2443
    fcp_dl = (uint32_t *)(& (ctx->fcp_cmnd)->cdb) + ((unsigned long )additional_cdb_len + 16UL);
#line 2445
    tmp___10 = scsi_bufflen(cmd);
#line 2445
    tmp___11 = __fswab32(tmp___10);
#line 2445
    *fcp_dl = tmp___11;
#line 2447
    cmd_pkt->fcp_cmnd_dseg_len = ctx->fcp_cmnd_len;
#line 2448
    cmd_pkt->fcp_cmnd_dseg_address[0] = (unsigned int )ctx->fcp_cmnd_dma;
#line 2450
    cmd_pkt->fcp_cmnd_dseg_address[1] = (unsigned int )(ctx->fcp_cmnd_dma >> 32ULL);
#line 2453
    sp->flags = (uint16_t )((unsigned int )sp->flags | 4096U);
#line 2454
    cmd_pkt->byte_count = scsi_bufflen(cmd);
#line 2456
    cmd_pkt->entry_count = (unsigned char )req_cnt;
#line 2460
    cmd_pkt->entry_status = (unsigned char )rsp->id;
  } else {
#line 2463
    req_cnt = qla24xx_calc_iocbs(vha, (int )tot_dsds);
#line 2464
    if ((int )req->cnt < (int )req_cnt + 2) {
#line 2465
      tmp___12 = __readl((void const volatile   *)(& reg->req_q_out));
#line 2465
      cnt = (unsigned short )tmp___12;
#line 2467
      if ((int )req->ring_index < (int )cnt) {
#line 2468
        req->cnt = (int )cnt - (int )req->ring_index;
      } else {
#line 2470
        req->cnt = (int )req->length + ((int )cnt - (int )req->ring_index);
      }
    } else {

    }
#line 2473
    if ((int )req->cnt < (int )req_cnt + 2) {
#line 2474
      goto queuing_error;
    } else {

    }
#line 2476
    cmd_pkt___0 = (struct cmd_type_7 *)req->ring_ptr;
#line 2477
    cmd_pkt___0->handle = ((unsigned int )req->id << 16) | handle;
#line 2481
    clr_ptr = (uint32_t *)cmd_pkt___0 + 2UL;
#line 2482
    memset((void *)clr_ptr, 0, 56UL);
#line 2483
    cmd_pkt___0->dseg_count = tot_dsds;
#line 2486
    cmd_pkt___0->nport_handle = (sp->fcport)->loop_id;
#line 2487
    cmd_pkt___0->port_id[0] = (sp->fcport)->d_id.b.al_pa;
#line 2488
    cmd_pkt___0->port_id[1] = (sp->fcport)->d_id.b.area;
#line 2489
    cmd_pkt___0->port_id[2] = (sp->fcport)->d_id.b.domain;
#line 2490
    cmd_pkt___0->vp_index = (uint8_t )((sp->fcport)->vha)->vp_idx;
#line 2492
    int_to_scsilun((cmd->device)->lun, & cmd_pkt___0->lun);
#line 2493
    host_to_fcp_swap((uint8_t *)(& cmd_pkt___0->lun), 8U);
#line 2497
    if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 2498
      cmd_pkt___0->task = (uint8_t )((int )((signed char )cmd_pkt___0->task) | (int )((signed char )((int )(sp->fcport)->fcp_prio << 3)));
    } else {

    }
#line 2501
    memcpy((void *)(& cmd_pkt___0->fcp_cdb), (void const   *)cmd->cmnd, (size_t )cmd->cmd_len);
#line 2502
    host_to_fcp_swap((uint8_t *)(& cmd_pkt___0->fcp_cdb), 16U);
#line 2504
    cmd_pkt___0->byte_count = scsi_bufflen(cmd);
#line 2507
    qla24xx_build_scsi_iocbs(sp, cmd_pkt___0, (int )tot_dsds);
#line 2510
    cmd_pkt___0->entry_count = (unsigned char )req_cnt;
#line 2514
    cmd_pkt___0->entry_status = (unsigned char )rsp->id;
  }
#line 2518
  req->current_outstanding_cmd = handle;
#line 2519
  *(req->outstanding_cmds + (unsigned long )handle) = sp;
#line 2520
  sp->handle = handle;
#line 2521
  cmd->host_scribble = (unsigned char *)((unsigned long )handle);
#line 2522
  req->cnt = (int )req->cnt - (int )req_cnt;
#line 2523
  __asm__  volatile   ("sfence": : : "memory");
#line 2526
  req->ring_index = (uint16_t )((int )req->ring_index + 1);
#line 2527
  if ((int )req->ring_index == (int )req->length) {
#line 2528
    req->ring_index = 0U;
#line 2529
    req->ring_ptr = req->ring;
  } else {
#line 2531
    req->ring_ptr = req->ring_ptr + 1;
  }
#line 2533
  sp->flags = (uint16_t )((unsigned int )sp->flags | 1U);
#line 2537
  dbval = ((uint32_t )((int )req->id << 8) | dbval) | (uint32_t )((int )req->ring_index << 16);
#line 2538
  if (ql2xdbwr != 0) {
#line 2539
    qla82xx_wr_32(ha, ha->nxdb_wr_ptr, dbval);
  } else {
#line 2541
    writel(dbval, (void volatile   *)ha->nxdb_wr_ptr);
#line 2544
    __asm__  volatile   ("sfence": : : "memory");
#line 2545
    goto ldv_66305;
    ldv_66304: 
#line 2546
    writel(dbval, (void volatile   *)ha->nxdb_wr_ptr);
#line 2549
    __asm__  volatile   ("sfence": : : "memory");
    ldv_66305: 
#line 2545
    tmp___13 = readl((void const volatile   *)ha->nxdb_rd_ptr);
#line 2545
    if (tmp___13 != dbval) {
#line 2547
      goto ldv_66304;
    } else {

    }

  }
#line 2554
  if (*((unsigned long *)vha + 19UL) != 0UL && (rsp->ring_ptr)->signature != 3735936685U) {
#line 2556
    qla24xx_process_response_queue(vha, rsp);
  } else {

  }
#line 2558
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2559
  return (0);
  queuing_error_fcp_cmnd: 
#line 2562
  dma_pool_free(ha->fcp_cmnd_dma_pool, (void *)ctx->fcp_cmnd, ctx->fcp_cmnd_dma);
  queuing_error: ;
#line 2564
  if ((unsigned int )tot_dsds != 0U) {
#line 2565
    scsi_dma_unmap(cmd);
  } else {

  }
#line 2567
  if ((unsigned long )sp->u.scmd.ctx != (unsigned long )((void *)0)) {
#line 2568
    mempool_free(sp->u.scmd.ctx, ha->ctx_mempool);
#line 2569
    sp->u.scmd.ctx = (void *)0;
  } else {

  }
#line 2571
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2573
  return (258);
}
}
#line 2577 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
static void qla24xx_abort_iocb(srb_t *sp , struct abort_entry_24xx *abt_iocb ) 
{ 
  struct srb_iocb *aio ;
  scsi_qla_host_t *vha ;
  struct req_que *req ;

  {
#line 2579
  aio = & sp->u.iocb_cmd;
#line 2580
  vha = (sp->fcport)->vha;
#line 2581
  req = vha->req;
#line 2583
  memset((void *)abt_iocb, 0, 64UL);
#line 2584
  abt_iocb->entry_type = 51U;
#line 2585
  abt_iocb->entry_count = 1U;
#line 2586
  abt_iocb->handle = ((unsigned int )req->id << 16) | sp->handle;
#line 2587
  abt_iocb->nport_handle = (sp->fcport)->loop_id;
#line 2588
  abt_iocb->handle_to_abort = ((unsigned int )req->id << 16) | aio->u.abt.cmd_hndl;
#line 2590
  abt_iocb->port_id[0] = (sp->fcport)->d_id.b.al_pa;
#line 2591
  abt_iocb->port_id[1] = (sp->fcport)->d_id.b.area;
#line 2592
  abt_iocb->port_id[2] = (sp->fcport)->d_id.b.domain;
#line 2593
  abt_iocb->vp_index = (uint8_t )vha->vp_idx;
#line 2594
  abt_iocb->req_que_no = req->id;
#line 2596
  __asm__  volatile   ("sfence": : : "memory");
#line 2597
  return;
}
}
#line 2600 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
int qla2x00_start_sp(srb_t *sp ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  void *pkt ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 2603
  ha = ((sp->fcport)->vha)->hw;
#line 2607
  rval = 258;
#line 2608
  tmp = spinlock_check(& ha->hardware_lock);
#line 2608
  flags = _raw_spin_lock_irqsave(tmp);
#line 2609
  pkt = qla2x00_alloc_iocbs((sp->fcport)->vha, sp);
#line 2610
  if ((unsigned long )pkt == (unsigned long )((void *)0)) {
#line 2611
    ql_log(1U, (sp->fcport)->vha, 28684, "qla2x00_alloc_iocbs failed.\n");
#line 2613
    goto done;
  } else {

  }
#line 2616
  rval = 0;
#line 2617
  switch ((int )sp->type) {
  case 1: ;
#line 2620
  if ((ha->device_type & 134217728U) != 0U) {
#line 2620
    qla24xx_login_iocb(sp, (struct logio_entry_24xx *)pkt);
  } else {
#line 2621
    qla2x00_login_iocb(sp, (struct mbx_entry *)pkt);
  }
#line 2622
  goto ldv_66326;
  case 2: ;
#line 2625
  if ((ha->device_type & 134217728U) != 0U) {
#line 2625
    qla24xx_logout_iocb(sp, (struct logio_entry_24xx *)pkt);
  } else {
#line 2626
    qla2x00_logout_iocb(sp, (struct mbx_entry *)pkt);
  }
#line 2627
  goto ldv_66326;
  case 3: ;
  case 4: 
#line 2630
  qla24xx_els_iocb(sp, (struct els_entry_24xx *)pkt);
#line 2631
  goto ldv_66326;
  case 5: ;
#line 2634
  if ((ha->device_type & 134217728U) != 0U) {
#line 2634
    qla24xx_ct_iocb(sp, (struct ct_entry_24xx *)pkt);
  } else {
#line 2635
    qla2x00_ct_iocb(sp, (ms_iocb_entry_t *)pkt);
  }
#line 2636
  goto ldv_66326;
  case 6: ;
#line 2639
  if ((ha->device_type & 134217728U) != 0U) {
#line 2639
    qla24xx_adisc_iocb(sp, (struct logio_entry_24xx *)pkt);
  } else {
#line 2640
    qla2x00_adisc_iocb(sp, (struct mbx_entry *)pkt);
  }
#line 2641
  goto ldv_66326;
  case 7: ;
#line 2644
  if ((ha->device_type & 131072U) != 0U) {
#line 2644
    qlafx00_tm_iocb(sp, (struct tsk_mgmt_entry_fx00 *)pkt);
  } else {
#line 2645
    qla24xx_tm_iocb(sp, (struct tsk_mgmt_entry *)pkt);
  }
#line 2646
  goto ldv_66326;
  case 10: ;
  case 11: 
#line 2649
  qlafx00_fxdisc_iocb(sp, (struct fxdisc_entry_fx00 *)pkt);
#line 2650
  goto ldv_66326;
  case 12: ;
#line 2653
  if ((ha->device_type & 131072U) != 0U) {
#line 2653
    qlafx00_abort_iocb(sp, (struct abort_iocb_entry_fx00 *)pkt);
  } else {
#line 2654
    qla24xx_abort_iocb(sp, (struct abort_entry_24xx *)pkt);
  }
#line 2655
  goto ldv_66326;
  default: ;
#line 2657
  goto ldv_66326;
  }
  ldv_66326: 
#line 2660
  __asm__  volatile   ("sfence": : : "memory");
#line 2661
  qla2x00_start_iocbs((sp->fcport)->vha, *(ha->req_q_map));
  done: 
#line 2663
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2664
  return (rval);
}
}
#line 2668 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
static void qla25xx_build_bidir_iocb(srb_t *sp , struct scsi_qla_host *vha , struct cmd_bidir *cmd_pkt ,
                                     uint32_t tot_dsds ) 
{ 
  uint16_t avail_dsds ;
  uint32_t *cur_dsd ;
  uint32_t req_data_len ;
  uint32_t rsp_data_len ;
  struct scatterlist *sg ;
  int index ;
  int entry_count ;
  struct fc_bsg_job *bsg_job ;
  unsigned long tmp ;
  dma_addr_t sle_dma ;
  cont_a64_entry_t *cont_pkt ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  dma_addr_t sle_dma___0 ;
  cont_a64_entry_t *cont_pkt___0 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;
  uint32_t *tmp___5 ;

  {
#line 2673
  req_data_len = 0U;
#line 2674
  rsp_data_len = 0U;
#line 2677
  entry_count = 1;
#line 2678
  bsg_job = sp->u.bsg_job;
#line 2681
  *((uint32_t *)(& cmd_pkt->entry_type)) = 117U;
#line 2688
  cmd_pkt->wr_dseg_count = (unsigned short )bsg_job->request_payload.sg_cnt;
#line 2689
  cmd_pkt->rd_dseg_count = (unsigned short )bsg_job->reply_payload.sg_cnt;
#line 2690
  cmd_pkt->control_flags = 11U;
#line 2694
  rsp_data_len = bsg_job->request_payload.payload_len;
#line 2694
  req_data_len = rsp_data_len;
#line 2695
  cmd_pkt->wr_byte_count = req_data_len;
#line 2696
  cmd_pkt->rd_byte_count = rsp_data_len;
#line 2697
  tmp = qla2x00_get_async_timeout(vha);
#line 2697
  cmd_pkt->timeout = (unsigned int )((unsigned short )tmp) + 2U;
#line 2699
  vha->bidi_stats.transfer_bytes = vha->bidi_stats.transfer_bytes + (unsigned long long )req_data_len;
#line 2700
  vha->bidi_stats.io_count = vha->bidi_stats.io_count + 1ULL;
#line 2702
  vha->qla_stats.output_bytes = vha->qla_stats.output_bytes + (uint64_t )req_data_len;
#line 2703
  vha->qla_stats.output_requests = vha->qla_stats.output_requests + 1ULL;
#line 2708
  avail_dsds = 1U;
#line 2709
  cur_dsd = (uint32_t *)(& cmd_pkt->fcp_data_dseg_address);
#line 2711
  index = 0;
#line 2713
  index = 0;
#line 2713
  sg = bsg_job->request_payload.sg_list;
#line 2713
  goto ldv_66354;
  ldv_66353: ;
#line 2719
  if ((unsigned int )avail_dsds == 0U) {
#line 2723
    cont_pkt = qla2x00_prep_cont_type1_iocb(vha, vha->req);
#line 2724
    cur_dsd = (uint32_t *)(& cont_pkt->dseg_0_address);
#line 2725
    avail_dsds = 5U;
#line 2726
    entry_count = entry_count + 1;
  } else {

  }
#line 2728
  sle_dma = sg->dma_address;
#line 2729
  tmp___0 = cur_dsd;
#line 2729
  cur_dsd = cur_dsd + 1;
#line 2729
  *tmp___0 = (unsigned int )sle_dma;
#line 2730
  tmp___1 = cur_dsd;
#line 2730
  cur_dsd = cur_dsd + 1;
#line 2730
  *tmp___1 = (unsigned int )(sle_dma >> 32ULL);
#line 2731
  tmp___2 = cur_dsd;
#line 2731
  cur_dsd = cur_dsd + 1;
#line 2731
  *tmp___2 = sg->dma_length;
#line 2732
  avail_dsds = (uint16_t )((int )avail_dsds - 1);
#line 2713
  index = index + 1;
#line 2713
  sg = sg_next(sg);
  ldv_66354: ;
#line 2713
  if (bsg_job->request_payload.sg_cnt > index) {
#line 2715
    goto ldv_66353;
  } else {

  }
#line 2739
  index = 0;
#line 2739
  sg = bsg_job->reply_payload.sg_list;
#line 2739
  goto ldv_66359;
  ldv_66358: ;
#line 2745
  if ((unsigned int )avail_dsds == 0U) {
#line 2749
    cont_pkt___0 = qla2x00_prep_cont_type1_iocb(vha, vha->req);
#line 2750
    cur_dsd = (uint32_t *)(& cont_pkt___0->dseg_0_address);
#line 2751
    avail_dsds = 5U;
#line 2752
    entry_count = entry_count + 1;
  } else {

  }
#line 2754
  sle_dma___0 = sg->dma_address;
#line 2755
  tmp___3 = cur_dsd;
#line 2755
  cur_dsd = cur_dsd + 1;
#line 2755
  *tmp___3 = (unsigned int )sle_dma___0;
#line 2756
  tmp___4 = cur_dsd;
#line 2756
  cur_dsd = cur_dsd + 1;
#line 2756
  *tmp___4 = (unsigned int )(sle_dma___0 >> 32ULL);
#line 2757
  tmp___5 = cur_dsd;
#line 2757
  cur_dsd = cur_dsd + 1;
#line 2757
  *tmp___5 = sg->dma_length;
#line 2758
  avail_dsds = (uint16_t )((int )avail_dsds - 1);
#line 2739
  index = index + 1;
#line 2739
  sg = sg_next(sg);
  ldv_66359: ;
#line 2739
  if (bsg_job->reply_payload.sg_cnt > index) {
#line 2741
    goto ldv_66358;
  } else {

  }
#line 2761
  cmd_pkt->entry_count = (uint8_t )entry_count;
#line 2762
  return;
}
}
#line 2765 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.c"
int qla2x00_start_bidir(srb_t *sp , struct scsi_qla_host *vha , uint32_t tot_dsds ) 
{ 
  struct qla_hw_data *ha ;
  unsigned long flags ;
  uint32_t handle ;
  uint32_t index ;
  uint16_t req_cnt ;
  uint16_t cnt ;
  uint32_t *clr_ptr ;
  struct cmd_bidir *cmd_pkt ;
  struct rsp_que *rsp ;
  struct req_que *req ;
  int rval ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 2768
  ha = vha->hw;
#line 2775
  cmd_pkt = (struct cmd_bidir *)0;
#line 2778
  rval = 0;
#line 2780
  rval = 0;
#line 2782
  rsp = *(ha->rsp_q_map);
#line 2783
  req = vha->req;
#line 2786
  if ((unsigned int )vha->marker_needed != 0U) {
#line 2787
    tmp = qla2x00_marker(vha, req, rsp, 0, 0ULL, 2);
#line 2787
    if (tmp != 0) {
#line 2789
      return (11);
    } else {

    }
#line 2790
    vha->marker_needed = 0U;
  } else {

  }
#line 2794
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 2794
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 2797
  handle = req->current_outstanding_cmd;
#line 2798
  index = 1U;
#line 2798
  goto ldv_66382;
  ldv_66381: 
#line 2799
  handle = handle + 1U;
#line 2800
  if ((uint32_t )req->num_outstanding_cmds == handle) {
#line 2801
    handle = 1U;
  } else {

  }
#line 2802
  if ((unsigned long )*(req->outstanding_cmds + (unsigned long )handle) == (unsigned long )((srb_t *)0)) {
#line 2803
    goto ldv_66380;
  } else {

  }
#line 2798
  index = index + 1U;
  ldv_66382: ;
#line 2798
  if ((uint32_t )req->num_outstanding_cmds > index) {
#line 2800
    goto ldv_66381;
  } else {

  }
  ldv_66380: ;
#line 2806
  if ((uint32_t )req->num_outstanding_cmds == index) {
#line 2807
    rval = 2;
#line 2808
    goto queuing_error;
  } else {

  }
#line 2812
  req_cnt = qla24xx_calc_iocbs(vha, (int )((uint16_t )tot_dsds));
#line 2815
  if ((int )req->cnt < (int )req_cnt + 2) {
#line 2816
    if ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) {
#line 2816
      cnt = *(req->out_ptr);
    } else {
#line 2816
      tmp___1 = __readl((void const volatile   *)req->req_q_out);
#line 2816
      cnt = (uint16_t )tmp___1;
    }
#line 2818
    if ((int )req->ring_index < (int )cnt) {
#line 2819
      req->cnt = (int )cnt - (int )req->ring_index;
    } else {
#line 2821
      req->cnt = (int )req->length + ((int )cnt - (int )req->ring_index);
    }
  } else {

  }
#line 2824
  if ((int )req->cnt < (int )req_cnt + 2) {
#line 2825
    rval = 2;
#line 2826
    goto queuing_error;
  } else {

  }
#line 2829
  cmd_pkt = (struct cmd_bidir *)req->ring_ptr;
#line 2830
  cmd_pkt->handle = ((unsigned int )req->id << 16) | handle;
#line 2834
  clr_ptr = (uint32_t *)cmd_pkt + 2UL;
#line 2835
  memset((void *)clr_ptr, 0, 56UL);
#line 2838
  cmd_pkt->nport_handle = vha->self_login_loop_id;
#line 2839
  cmd_pkt->port_id[0] = vha->d_id.b.al_pa;
#line 2840
  cmd_pkt->port_id[1] = vha->d_id.b.area;
#line 2841
  cmd_pkt->port_id[2] = vha->d_id.b.domain;
#line 2843
  qla25xx_build_bidir_iocb(sp, vha, cmd_pkt, tot_dsds);
#line 2844
  cmd_pkt->entry_status = (unsigned char )rsp->id;
#line 2846
  req->current_outstanding_cmd = handle;
#line 2847
  *(req->outstanding_cmds + (unsigned long )handle) = sp;
#line 2848
  sp->handle = handle;
#line 2849
  req->cnt = (int )req->cnt - (int )req_cnt;
#line 2852
  __asm__  volatile   ("sfence": : : "memory");
#line 2853
  qla2x00_start_iocbs(vha, req);
  queuing_error: 
#line 2855
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2856
  return (rval);
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
void disable_suitable_timer_17(struct timer_list *timer ) 
{ 


  {
#line 489
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_17) {
#line 490
    ldv_timer_state_17 = 0;
#line 491
    return;
  } else {

  }
#line 493
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
void choose_timer_17(struct timer_list *timer ) 
{ 


  {
#line 497
  LDV_IN_INTERRUPT = 2;
#line 498
  (*(timer->function))(timer->data);
#line 499
  LDV_IN_INTERRUPT = 1;
#line 500
  ldv_timer_state_17 = 2;
#line 501
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
int reg_timer_17(struct timer_list *timer ) 
{ 


  {
#line 505
  ldv_timer_list_17 = timer;
#line 506
  ldv_timer_state_17 = 1;
#line 507
  return (0);
}
}
#line 510 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
void activate_pending_timer_17(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 510
  if ((unsigned long )ldv_timer_list_17 == (unsigned long )timer) {
#line 511
    if (ldv_timer_state_17 == 2 || pending_flag != 0) {
#line 512
      ldv_timer_list_17 = timer;
#line 513
      ldv_timer_list_17->data = data;
#line 514
      ldv_timer_state_17 = 1;
    } else {

    }
#line 516
    return;
  } else {

  }
#line 518
  reg_timer_17(timer);
#line 519
  ldv_timer_list_17->data = data;
#line 520
  return;
}
}
#line 546 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
bool ldv_queue_work_on_95(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 550
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 550
  ldv_func_res = tmp;
#line 552
  activate_work_7(ldv_func_arg3, 2);
#line 554
  return (ldv_func_res);
}
}
#line 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
bool ldv_queue_delayed_work_on_96(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 561
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 561
  ldv_func_res = tmp;
#line 563
  activate_work_7(& ldv_func_arg3->work, 2);
#line 565
  return (ldv_func_res);
}
}
#line 568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
bool ldv_queue_work_on_97(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 572
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 572
  ldv_func_res = tmp;
#line 574
  activate_work_7(ldv_func_arg3, 2);
#line 576
  return (ldv_func_res);
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
void ldv_flush_workqueue_98(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 582
  flush_workqueue(ldv_func_arg1);
#line 584
  call_and_disable_all_7(2);
#line 585
  return;
}
}
#line 587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
bool ldv_queue_delayed_work_on_99(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 591
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 591
  ldv_func_res = tmp;
#line 593
  activate_work_7(& ldv_func_arg3->work, 2);
#line 595
  return (ldv_func_res);
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
int ldv_scsi_add_host_with_dma_100(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 602
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 602
  ldv_func_res = tmp;
#line 604
  if (ldv_func_res == 0) {
#line 605
    ldv_state_variable_88 = 1;
#line 605
    ldv_initialize_scsi_host_template_88();
  } else {

  }
#line 609
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 31 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock_irq(raw_spinlock_t * ) ;
#line 43
extern void _raw_spin_unlock_irq(raw_spinlock_t * ) ;
#line 340 "include/linux/spinlock.h"
__inline static void spin_lock_irq(spinlock_t *lock ) 
{ 


  {
#line 342
  _raw_spin_lock_irq(& lock->__annonCompField18.rlock);
#line 343
  return;
}
}
#line 365 "include/linux/spinlock.h"
__inline static void spin_unlock_irq(spinlock_t *lock ) 
{ 


  {
#line 367
  _raw_spin_unlock_irq(& lock->__annonCompField18.rlock);
#line 368
  return;
}
}
#line 352 "include/linux/workqueue.h"
extern struct workqueue_struct *system_wq ;
#line 433
bool ldv_queue_work_on_111(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_113(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 441
bool ldv_queue_work_on_117(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 447
bool ldv_queue_delayed_work_on_112(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 451
bool ldv_queue_delayed_work_on_115(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 459
void ldv_flush_workqueue_114(struct workqueue_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work___0(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_111(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 528 "include/linux/workqueue.h"
__inline static bool schedule_work(struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 530
  tmp = queue_work___0(system_wq, work);
#line 530
  return (tmp);
}
}
#line 332 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
int reg_timer_18(struct timer_list *timer ) ;
#line 337
void activate_pending_timer_18(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 350
void choose_timer_18(struct timer_list *timer ) ;
#line 359
void disable_suitable_timer_18(struct timer_list *timer ) ;
#line 120 "include/linux/scatterlist.h"
__inline static struct page *sg_page___0(struct scatterlist *sg ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 123
  tmp = ldv__builtin_expect(sg->sg_magic != 2271560481UL, 0L);
#line 123
  if (tmp != 0L) {
#line 123
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (123), "i" (12UL));
    ldv_26185: ;
#line 123
    goto ldv_26185;
  } else {

  }
#line 124
  tmp___0 = ldv__builtin_expect((long )((int )sg->page_link) & 1L, 0L);
#line 124
  if (tmp___0 != 0L) {
#line 124
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (124), "i" (12UL));
    ldv_26186: ;
#line 124
    goto ldv_26186;
  } else {

  }
#line 126
  return ((struct page *)(sg->page_link & 0xfffffffffffffffcUL));
}
}
#line 1209 "include/linux/pci.h"
extern void pci_disable_msi(struct pci_dev * ) ;
#line 1213
extern void pci_disable_msix(struct pci_dev * ) ;
#line 1216
extern int pci_enable_msi_range(struct pci_dev * , int  , int  ) ;
#line 1217 "include/linux/pci.h"
__inline static int pci_enable_msi_exact(struct pci_dev *dev , int nvec ) 
{ 
  int rc ;
  int tmp ;

  {
#line 1219
  tmp = pci_enable_msi_range(dev, nvec, nvec);
#line 1219
  rc = tmp;
#line 1220
  if (rc < 0) {
#line 1221
    return (rc);
  } else {

  }
#line 1222
  return (0);
}
}
#line 1224
extern int pci_enable_msix_range(struct pci_dev * , struct msix_entry * , int  , int  ) ;
#line 127 "include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 132 "include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
#line 135
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))0, flags,
                             name, dev);
#line 135
  return (tmp);
}
}
#line 146
extern void free_irq(unsigned int  , void * ) ;
#line 795 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_116(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
#line 248 "include/scsi/scsi_device.h"
extern void scmd_printk(char const   * , struct scsi_cmnd  const  * , char const   * 
                        , ...) ;
#line 186 "include/scsi/scsi_cmnd.h"
__inline static void scsi_set_resid(struct scsi_cmnd *cmd , int resid ) 
{ 


  {
#line 188
  cmd->sdb.resid = resid;
#line 189
  return;
}
}
#line 331 "include/scsi/scsi_cmnd.h"
__inline static void set_host_byte(struct scsi_cmnd *cmd , char status ) 
{ 


  {
#line 333
  cmd->result = (int )(((unsigned int )cmd->result & 4278255615U) | (unsigned int )((int )status << 16));
#line 334
  return;
}
}
#line 336 "include/scsi/scsi_cmnd.h"
__inline static void set_driver_byte(struct scsi_cmnd *cmd , char status ) 
{ 


  {
#line 338
  cmd->result = (cmd->result & 16777215) | ((int )status << 24);
#line 339
  return;
}
}
#line 2041 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
static char const   * const  port_state_str___1[5U]  = {      "Unknown",      "UNCONFIGURED",      "DEAD",      "LOST", 
        "ONLINE"};
#line 200 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
void qla2x00_alert_all_vps(struct rsp_que *rsp , uint16_t *mb ) ;
#line 201
void qla2x00_async_event(scsi_qla_host_t *vha , struct rsp_que *rsp , uint16_t *mb ) ;
#line 454
srb_t *qla2x00_get_sp_from_handle(scsi_qla_host_t *vha , char const   *func , struct req_que *req ,
                                  void *iocb ) ;
#line 457
void qla2x00_process_completed_request(struct scsi_qla_host *vha , struct req_que *req ,
                                       uint32_t index ) ;
#line 479
bool qla2x00_check_reg32_for_disconnect(scsi_qla_host_t *vha , uint32_t reg ) ;
#line 594
int qla25xx_request_irq(struct rsp_que *rsp ) ;
#line 684
irqreturn_t qla82xx_msix_default(int irq , void *dev_id ) ;
#line 685
irqreturn_t qla82xx_msix_rsp_q(int irq , void *dev_id ) ;
#line 1056 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
int ql2x_ini_mode ;
#line 1079
void qlt_response_pkt_all_vps(struct scsi_qla_host *vha , response_t *pkt ) ;
#line 1085
void qlt_async_event(uint16_t code , struct scsi_qla_host *vha , uint16_t *mailbox ) ;
#line 1100
int qlt_24xx_process_response_error(struct scsi_qla_host *vha , struct sts_entry_24xx *pkt ) ;
#line 1109
irqreturn_t qla83xx_msix_atio_q(int irq , void *dev_id ) ;
#line 42 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static uint16_t qla2x00_debounce_register___1(uint16_t volatile   *addr ) 
{ 
  uint16_t volatile   first ;
  uint16_t volatile   second ;
  unsigned short tmp ;
  unsigned short tmp___0 ;

  {
  ldv_65637: 
#line 48
  tmp = readw((void const volatile   *)addr);
#line 48
  first = tmp;
#line 49
  __asm__  volatile   ("": : : "memory");
#line 50
  cpu_relax();
#line 51
  tmp___0 = readw((void const volatile   *)addr);
#line 51
  second = tmp___0;
#line 52
  if ((int )((unsigned short )first) != (int )((unsigned short )second)) {
#line 54
    goto ldv_65637;
  } else {

  }

#line 54
  return ((uint16_t )first);
}
}
#line 71 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static uint8_t *host_to_fcp_swap___1(uint8_t *fcp , uint32_t bsize ) 
{ 
  uint32_t *ifcp ;
  uint32_t *ofcp ;
  uint32_t iter ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  __u32 tmp___1 ;

  {
#line 73
  ifcp = (uint32_t *)fcp;
#line 74
  ofcp = (uint32_t *)fcp;
#line 75
  iter = bsize >> 2;
#line 77
  goto ldv_65665;
  ldv_65664: 
#line 78
  tmp = ofcp;
#line 78
  ofcp = ofcp + 1;
#line 78
  tmp___0 = ifcp;
#line 78
  ifcp = ifcp + 1;
#line 78
  tmp___1 = __fswab32(*tmp___0);
#line 78
  *tmp = tmp___1;
#line 77
  iter = iter - 1U;
  ldv_65665: ;
#line 77
  if (iter != 0U) {
#line 79
    goto ldv_65664;
  } else {

  }

#line 80
  return (fcp);
}
}
#line 273 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_handle_mbx_completion(struct qla_hw_data *ha , int status ) 
{ 
  int tmp ;

  {
#line 275
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& ha->mbx_cmd_flags));
#line 275
  if ((tmp != 0 && status & 1) && *((unsigned long *)ha + 2UL) != 0UL) {
#line 277
    set_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 278
    clear_bit(2L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 279
    complete(& ha->mbx_intr_comp);
  } else {

  }
#line 281
  return;
}
}
#line 284 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_set_retry_delay_timestamp(fc_port_t *fcport , uint16_t retry_delay ) 
{ 


  {
#line 286
  if ((unsigned int )retry_delay != 0U) {
#line 287
    fcport->retry_delay_timestamp = (unsigned long )(((int )retry_delay * 250) / 10) + (unsigned long )jiffies;
  } else {

  }
#line 288
  return;
}
}
#line 30 "include/scsi/scsi_eh.h"
extern void scsi_build_sense_buffer(int  , u8 * , u8  , u8  , u8  ) ;
#line 16 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
static void qla2x00_mbx_completion(scsi_qla_host_t *vha , uint16_t mb0 ) ;
#line 17
static void qla2x00_status_entry(scsi_qla_host_t *vha , struct rsp_que *rsp , void *pkt ) ;
#line 18
static void qla2x00_status_cont_entry(struct rsp_que *rsp , sts_cont_entry_t *pkt ) ;
#line 19
static void qla2x00_error_entry(scsi_qla_host_t *vha , struct rsp_que *rsp , sts_entry_t *pkt ) ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
irqreturn_t qla2100_intr_handler(int irq , void *dev_id ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  int status ;
  unsigned long iter ;
  uint16_t hccr ;
  uint16_t mb[4U] ;
  struct rsp_que *rsp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  void *tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  unsigned short tmp___3 ;
  unsigned short tmp___4 ;
  unsigned long tmp___5 ;

  {
#line 44
  rsp = (struct rsp_que *)dev_id;
#line 45
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 46
    ql_log(2U, (scsi_qla_host_t *)0, 20573, "%s: NULL response queue pointer.\n",
           "qla2100_intr_handler");
#line 48
    return (0);
  } else {

  }
#line 51
  ha = rsp->hw;
#line 52
  reg = & (ha->iobase)->isp;
#line 53
  status = 0;
#line 55
  tmp = spinlock_check(& ha->hardware_lock);
#line 55
  flags = _raw_spin_lock_irqsave(tmp);
#line 56
  tmp___0 = pci_get_drvdata(ha->pdev);
#line 56
  vha = (scsi_qla_host_t *)tmp___0;
#line 57
  iter = 50UL;
#line 57
  goto ldv_65872;
  ldv_65871: 
#line 58
  hccr = readw((void const volatile   *)(& reg->hccr));
#line 59
  tmp___1 = qla2x00_check_reg16_for_disconnect(vha, (int )hccr);
#line 59
  if ((int )tmp___1) {
#line 60
    goto ldv_65870;
  } else {

  }
#line 61
  if (((int )hccr & 32) != 0) {
#line 62
    tmp___2 = pci_channel_offline(ha->pdev);
#line 62
    if (tmp___2 != 0) {
#line 63
      goto ldv_65870;
    } else {

    }
#line 70
    writew(4096, (void volatile   *)(& reg->hccr));
#line 71
    readw((void const volatile   *)(& reg->hccr));
#line 73
    (*((ha->isp_ops)->fw_dump))(vha, 1);
#line 74
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 75
    goto ldv_65870;
  } else {
#line 76
    tmp___3 = readw((void const volatile   *)(& reg->istatus));
#line 76
    if (((int )tmp___3 & 8) == 0) {
#line 77
      goto ldv_65870;
    } else {

    }
  }
#line 79
  tmp___4 = readw((void const volatile   *)(& reg->semaphore));
#line 79
  if ((int )tmp___4 & 1) {
#line 80
    writew(28672, (void volatile   *)(& reg->hccr));
#line 81
    readw((void const volatile   *)(& reg->hccr));
#line 84
    mb[0] = readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 : & reg->u.isp2300.mailbox0));
#line 85
    if ((unsigned int )mb[0] > 16383U && (int )((short )mb[0]) >= 0) {
#line 86
      qla2x00_mbx_completion(vha, (int )mb[0]);
#line 87
      status = status | 1;
    } else
#line 88
    if ((int )((short )mb[0]) < 0 && (unsigned int )mb[0] <= 49151U) {
#line 89
      mb[1] = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 1U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 1U);
#line 90
      mb[2] = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 2U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 2U);
#line 91
      mb[3] = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 3U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 3U);
#line 92
      qla2x00_async_event(vha, rsp, (uint16_t *)(& mb));
    } else {
#line 95
      ql_dbg(33554432U, vha, 20517, "Unrecognized interrupt type (%d).\n", (int )mb[0]);
    }
#line 100
    writew(0, (void volatile   *)(& reg->semaphore));
#line 101
    readw((void const volatile   *)(& reg->semaphore));
  } else {
#line 103
    qla2x00_process_response_queue(rsp);
#line 105
    writew(28672, (void volatile   *)(& reg->hccr));
#line 106
    readw((void const volatile   *)(& reg->hccr));
  }
  ldv_65872: 
#line 57
  tmp___5 = iter;
#line 57
  iter = iter - 1UL;
#line 57
  if (tmp___5 != 0UL) {
#line 59
    goto ldv_65871;
  } else {

  }
  ldv_65870: 
#line 109
  qla2x00_handle_mbx_completion(ha, status);
#line 110
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 112
  return (1);
}
}
#line 116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
bool qla2x00_check_reg32_for_disconnect(scsi_qla_host_t *vha , uint32_t reg ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 119
  if (reg == 4294967295U) {
#line 120
    tmp = test_and_set_bit(0L, (unsigned long volatile   *)(& vha->pci_flags));
#line 120
    if (tmp == 0) {
#line 120
      tmp___0 = constant_test_bit(1L, (unsigned long const volatile   *)(& vha->pci_flags));
#line 120
      if (tmp___0 == 0) {
#line 120
        tmp___1 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->pci_flags));
#line 120
        if (tmp___1 == 0) {
#line 128
          schedule_work(& (vha->hw)->board_disable);
        } else {

        }
      } else {

      }
    } else {

    }
#line 130
    return (1);
  } else {
#line 132
    return (0);
  }
}
}
#line 136 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
bool qla2x00_check_reg16_for_disconnect(scsi_qla_host_t *vha , uint16_t reg ) 
{ 
  bool tmp ;

  {
#line 138
  tmp = qla2x00_check_reg32_for_disconnect(vha, (unsigned int )reg | 4294901760U);
#line 138
  return (tmp);
}
}
#line 151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
irqreturn_t qla2300_intr_handler(int irq , void *dev_id ) 
{ 
  scsi_qla_host_t *vha ;
  struct device_reg_2xxx *reg ;
  int status ;
  unsigned long iter ;
  uint32_t stat ;
  uint16_t hccr ;
  uint16_t mb[4U] ;
  struct rsp_que *rsp ;
  struct qla_hw_data *ha ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  void *tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  unsigned long tmp___4 ;

  {
#line 164
  rsp = (struct rsp_que *)dev_id;
#line 165
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 166
    ql_log(2U, (scsi_qla_host_t *)0, 20568, "%s: NULL response queue pointer.\n",
           "qla2300_intr_handler");
#line 168
    return (0);
  } else {

  }
#line 171
  ha = rsp->hw;
#line 172
  reg = & (ha->iobase)->isp;
#line 173
  status = 0;
#line 175
  tmp = spinlock_check(& ha->hardware_lock);
#line 175
  flags = _raw_spin_lock_irqsave(tmp);
#line 176
  tmp___0 = pci_get_drvdata(ha->pdev);
#line 176
  vha = (scsi_qla_host_t *)tmp___0;
#line 177
  iter = 50UL;
#line 177
  goto ldv_65911;
  ldv_65910: 
#line 178
  stat = readl((void const volatile   *)(& reg->u.isp2300.host_status));
#line 179
  tmp___1 = qla2x00_check_reg32_for_disconnect(vha, stat);
#line 179
  if ((int )tmp___1) {
#line 180
    goto ldv_65899;
  } else {

  }
#line 181
  if ((stat & 256U) != 0U) {
#line 182
    tmp___2 = pci_channel_offline(ha->pdev);
#line 182
    tmp___3 = ldv__builtin_expect(tmp___2 != 0, 0L);
#line 182
    if (tmp___3 != 0L) {
#line 183
      goto ldv_65899;
    } else {

    }
#line 185
    hccr = readw((void const volatile   *)(& reg->hccr));
#line 187
    if (((int )hccr & 43264) != 0) {
#line 188
      ql_log(1U, vha, 20518, "Parity error -- HCCR=%x, Dumping firmware.\n", (int )hccr);
    } else {
#line 192
      ql_log(1U, vha, 20519, "RISC paused -- HCCR=%x, Dumping firmware.\n", (int )hccr);
    }
#line 201
    writew(4096, (void volatile   *)(& reg->hccr));
#line 202
    readw((void const volatile   *)(& reg->hccr));
#line 204
    (*((ha->isp_ops)->fw_dump))(vha, 1);
#line 205
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 206
    goto ldv_65899;
  } else
#line 207
  if ((stat & 32768U) == 0U) {
#line 208
    goto ldv_65899;
  } else {

  }
#line 210
  switch (stat & 255U) {
  case 1U: ;
  case 2U: ;
  case 16U: ;
  case 17U: 
#line 215
  qla2x00_mbx_completion(vha, (int )((unsigned short )(stat >> 16)));
#line 216
  status = status | 1;
#line 219
  writew(0, (void volatile   *)(& reg->semaphore));
#line 220
  goto ldv_65904;
  case 18U: 
#line 222
  mb[0] = (unsigned short )(stat >> 16);
#line 223
  mb[1] = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 1U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 1U);
#line 224
  mb[2] = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 2U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 2U);
#line 225
  mb[3] = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 3U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 3U);
#line 226
  qla2x00_async_event(vha, rsp, (uint16_t *)(& mb));
#line 227
  goto ldv_65904;
  case 19U: 
#line 229
  qla2x00_process_response_queue(rsp);
#line 230
  goto ldv_65904;
  case 21U: 
#line 232
  mb[0] = 32817U;
#line 233
  mb[1] = (unsigned short )(stat >> 16);
#line 234
  qla2x00_async_event(vha, rsp, (uint16_t *)(& mb));
#line 235
  goto ldv_65904;
  case 22U: 
#line 237
  mb[0] = 32800U;
#line 238
  mb[1] = (unsigned short )(stat >> 16);
#line 239
  mb[2] = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 2U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 2U);
#line 240
  qla2x00_async_event(vha, rsp, (uint16_t *)(& mb));
#line 241
  goto ldv_65904;
  default: 
#line 243
  ql_dbg(33554432U, vha, 20520, "Unrecognized interrupt type (%d).\n", stat & 255U);
#line 245
  goto ldv_65904;
  }
  ldv_65904: 
#line 247
  writew(28672, (void volatile   *)(& reg->hccr));
#line 248
  __readw((void const volatile   *)(& reg->hccr));
  ldv_65911: 
#line 177
  tmp___4 = iter;
#line 177
  iter = iter - 1UL;
#line 177
  if (tmp___4 != 0UL) {
#line 179
    goto ldv_65910;
  } else {

  }
  ldv_65899: 
#line 250
  qla2x00_handle_mbx_completion(ha, status);
#line 251
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 253
  return (1);
}
}
#line 262 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
static void qla2x00_mbx_completion(scsi_qla_host_t *vha , uint16_t mb0 ) 
{ 
  uint16_t cnt ;
  uint32_t mboxes ;
  uint16_t *wptr ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;

  {
#line 267
  ha = vha->hw;
#line 268
  reg = & (ha->iobase)->isp;
#line 271
  mboxes = (uint32_t )((1 << (int )ha->mbx_count) + -1);
#line 272
  if ((unsigned long )ha->mcp == (unsigned long )((mbx_cmd_t *)0)) {
#line 273
    ql_dbg(33554432U, vha, 20481, "MBX pointer OLD_ERROR.\n");
  } else {
#line 275
    mboxes = (ha->mcp)->in_mb;
  }
#line 278
  ha->flags.mbox_int = 1U;
#line 279
  ha->mailbox_out[0] = mb0;
#line 280
  mboxes = mboxes >> 1;
#line 281
  wptr = (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 + 1UL : & reg->u.isp2300.mailbox0 + 1UL;
#line 283
  cnt = 1U;
#line 283
  goto ldv_65922;
  ldv_65921: ;
#line 284
  if ((ha->device_type & 2U) != 0U && (unsigned int )cnt == 8U) {
#line 285
    wptr = (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u_end.isp2200.mailbox8 : & reg->u.isp2300.mailbox0 + 8UL;
  } else {

  }
#line 286
  if (((unsigned int )cnt == 4U || (unsigned int )cnt == 5U) && (int )mboxes & 1) {
#line 287
    ha->mailbox_out[(int )cnt] = qla2x00_debounce_register___1((uint16_t volatile   *)wptr);
  } else
#line 288
  if ((int )mboxes & 1) {
#line 289
    ha->mailbox_out[(int )cnt] = readw((void const volatile   *)wptr);
  } else {

  }
#line 291
  wptr = wptr + 1;
#line 292
  mboxes = mboxes >> 1;
#line 283
  cnt = (uint16_t )((int )cnt + 1);
  ldv_65922: ;
#line 283
  if ((int )((unsigned short )ha->mbx_count) > (int )cnt) {
#line 285
    goto ldv_65921;
  } else {

  }

#line 290
  return;
}
}
#line 297 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
static void qla81xx_idc_event(scsi_qla_host_t *vha , uint16_t aen , uint16_t descr ) 
{ 
  char *event[3U] ;
  int rval ;
  struct device_reg_24xx *reg24 ;
  struct device_reg_82xx *reg82 ;
  uint16_t *wptr ;
  uint16_t cnt ;
  uint16_t timeout ;
  uint16_t mb[7U] ;

  {
#line 299
  event[0] = (char *)"Complete";
#line 299
  event[1] = (char *)"Request Notification";
#line 299
  event[2] = (char *)"Time Extension";
#line 302
  reg24 = & ((vha->hw)->iobase)->isp24;
#line 303
  reg82 = & ((vha->hw)->iobase)->isp82;
#line 308
  if (((vha->hw)->device_type & 8192U) != 0U || (((vha->hw)->device_type & 32768U) != 0U || ((vha->hw)->device_type & 65536U) != 0U)) {
#line 309
    wptr = & reg24->mailbox1;
  } else
#line 310
  if (((vha->hw)->device_type & 262144U) != 0U) {
#line 311
    wptr = (uint16_t *)(& reg82->mailbox_out) + 1UL;
  } else {
#line 313
    return;
  }
#line 315
  cnt = 0U;
#line 315
  goto ldv_65938;
  ldv_65937: 
#line 316
  mb[(int )cnt] = readw((void const volatile   *)wptr);
#line 315
  cnt = (uint16_t )((int )cnt + 1);
#line 315
  wptr = wptr + 1;
  ldv_65938: ;
#line 315
  if ((unsigned int )cnt <= 6U) {
#line 317
    goto ldv_65937;
  } else {

  }
#line 318
  ql_dbg(33554432U, vha, 20513, "Inter-Driver Communication %s -- %04x %04x %04x %04x %04x %04x %04x.\n",
         event[(int )aen & 255], (int )mb[0], (int )mb[1], (int )mb[2], (int )mb[3],
         (int )mb[4], (int )mb[5], (int )mb[6]);
#line 323
  switch ((int )aen) {
  case 33024: ;
#line 326
  if ((int )((short )mb[1]) < 0) {
#line 327
    (vha->hw)->flags.idc_compl_status = 1U;
#line 328
    if ((vha->hw)->notify_dcbx_comp != 0 && (unsigned int )vha->vp_idx == 0U) {
#line 329
      complete(& (vha->hw)->dcbx_comp);
    } else {

    }
  } else {

  }
#line 331
  goto ldv_65941;
  case 33025: 
#line 335
  timeout = (unsigned int )((uint16_t )((int )descr >> 8)) & 15U;
#line 336
  ql_dbg(33554432U, vha, 20514, "%lu Inter-Driver Communication %s -- ACK timeout=%d.\n",
         vha->host_no, event[(int )aen & 255], (int )timeout);
#line 340
  if ((unsigned int )timeout == 0U) {
#line 341
    return;
  } else {

  }
#line 342
  rval = qla2x00_post_idc_ack_work(vha, (uint16_t *)(& mb));
#line 343
  if (rval != 0) {
#line 344
    ql_log(1U, vha, 20515, "IDC failed to post ACK.\n");
  } else {

  }
#line 346
  goto ldv_65941;
  case 33026: 
#line 348
  (vha->hw)->idc_extend_tmo = (uint32_t )descr;
#line 349
  ql_dbg(33554432U, vha, 20615, "%lu Inter-Driver Communication %s -- Extend timeout by=%d.\n",
         vha->host_no, event[(int )aen & 255], (vha->hw)->idc_extend_tmo);
#line 353
  goto ldv_65941;
  }
  ldv_65941: ;
#line 356
  return;
}
}
#line 359 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
char const   *qla2x00_get_link_speed_str(struct qla_hw_data *ha , uint16_t speed ) 
{ 
  char const   *link_speeds[8U] ;

  {
#line 361
  link_speeds[0] = "1";
#line 361
  link_speeds[1] = "2";
#line 361
  link_speeds[2] = "?";
#line 361
  link_speeds[3] = "4";
#line 361
  link_speeds[4] = "8";
#line 361
  link_speeds[5] = "16";
#line 361
  link_speeds[6] = "32";
#line 361
  link_speeds[7] = "10";
#line 366
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 367
    return (link_speeds[0]);
  } else
#line 368
  if ((unsigned int )speed == 19U) {
#line 369
    return (link_speeds[7]);
  } else
#line 370
  if ((unsigned int )speed <= 6U) {
#line 371
    return (link_speeds[(int )speed]);
  } else {
#line 373
    return (link_speeds[2]);
  }
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
static void qla83xx_handle_8200_aen(scsi_qla_host_t *vha , uint16_t *mb ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t protocol_engine_id ;
  uint32_t fw_err_code ;
  uint32_t err_level ;
  uint16_t peg_fw_state ;
  uint16_t nw_interface_link_up ;
  uint16_t nw_interface_signal_detect ;
  uint16_t sfp_status ;
  uint16_t htbt_counter ;
  uint16_t htbt_monitor_enable ;
  uint16_t sfp_additonal_info ;
  uint16_t sfp_multirate ;
  uint16_t sfp_tx_fault ;
  uint16_t link_speed ;
  uint16_t dcbx_status ;

  {
#line 379
  ha = vha->hw;
#line 392
  ql_dbg(33554432U, vha, 20587, "AEN Code: mb[0] = 0x%x AEN reason: mb[1] = 0x%x PH-status1: mb[2] = 0x%x PH-status1: mb[6] = 0x%x.\n",
         (int )*mb, (int )*(mb + 1UL), (int )*(mb + 2UL), (int )*(mb + 6UL));
#line 395
  ql_dbg(33554432U, vha, 20588, "PH-status2: mb[3] = 0x%x PH-status2: mb[7] = 0x%x Device-State: mb[4] = 0x%x Drv-Presence: mb[5] = 0x%x.\n",
         (int )*(mb + 3UL), (int )*(mb + 7UL), (int )*(mb + 4UL), (int )*(mb + 5UL));
#line 399
  if (((int )*(mb + 1UL) & 14) != 0) {
#line 401
    ha->flags.nic_core_hung = 1U;
#line 402
    ql_log(1U, vha, 20576, "83XX: F/W Error Reported: Check if reset required.\n");
#line 405
    if (((int )*(mb + 1UL) & 2) != 0) {
#line 421
      protocol_engine_id = (uint32_t )*(mb + 2UL) & 255U;
#line 422
      fw_err_code = (uint32_t )(((int )*(mb + 2UL) >> 8) | (((int )*(mb + 6UL) & 8191) << 8));
#line 424
      err_level = (uint32_t )((int )*(mb + 6UL) >> 13);
#line 425
      ql_log(1U, vha, 20577, "PegHalt Status-1 Register: protocol_engine_id=0x%x fw_err_code=0x%x err_level=0x%x.\n",
             protocol_engine_id, fw_err_code, err_level);
#line 429
      ql_log(1U, vha, 20578, "PegHalt Status-2 Register: 0x%x%x.\n", (int )*(mb + 7UL),
             (int )*(mb + 3UL));
#line 431
      if (err_level == 1U) {
#line 432
        ql_log(1U, vha, 20579, "Not a fatal error, f/w has recovered iteself.\n");
      } else
#line 435
      if (err_level == 2U) {
#line 436
        ql_log(0U, vha, 20580, "Recoverable Fatal error: Chip reset required.\n");
#line 439
        qla83xx_schedule_work(vha, 1);
      } else
#line 441
      if (err_level == 4U) {
#line 442
        ql_log(0U, vha, 20581, "Unrecoverable Fatal error: Set FAILED state, reboot required.\n");
#line 445
        qla83xx_schedule_work(vha, 3);
      } else {

      }
    } else {

    }
#line 450
    if (((int )*(mb + 1UL) & 4) != 0) {
#line 488
      peg_fw_state = (unsigned int )*(mb + 2UL) & 255U;
#line 489
      nw_interface_link_up = (uint16_t )(((int )*(mb + 2UL) & 256) >> 8);
#line 490
      nw_interface_signal_detect = (uint16_t )(((int )*(mb + 2UL) & 512) >> 9);
#line 491
      sfp_status = (uint16_t )(((int )*(mb + 2UL) & 3072) >> 10);
#line 492
      htbt_counter = (uint16_t )(((int )*(mb + 2UL) & 28672) >> 12);
#line 493
      htbt_monitor_enable = (int )*(mb + 2UL) >> 15;
#line 494
      sfp_additonal_info = (unsigned int )*(mb + 6UL) & 3U;
#line 495
      sfp_multirate = (uint16_t )(((int )*(mb + 6UL) & 4) >> 2);
#line 496
      sfp_tx_fault = (uint16_t )(((int )*(mb + 6UL) & 8) >> 3);
#line 497
      link_speed = (uint16_t )(((int )*(mb + 6UL) & 112) >> 4);
#line 498
      dcbx_status = (uint16_t )(((int )*(mb + 6UL) & 28672) >> 12);
#line 500
      ql_log(1U, vha, 20582, "Peg-to-Fc Status Register:\npeg_fw_state=0x%x, nw_interface_link_up=0x%x, nw_interface_signal_detect=0x%x\nsfp_statis=0x%x.\n ",
             (int )peg_fw_state, (int )nw_interface_link_up, (int )nw_interface_signal_detect,
             (int )sfp_status);
#line 507
      ql_log(1U, vha, 20583, "htbt_counter=0x%x, htbt_monitor_enable=0x%x, sfp_additonal_info=0x%x, sfp_multirate=0x%x.\n ",
             (int )htbt_counter, (int )htbt_monitor_enable, (int )sfp_additonal_info,
             (int )sfp_multirate);
#line 512
      ql_log(1U, vha, 20584, "sfp_tx_fault=0x%x, link_state=0x%x, dcbx_status=0x%x.\n",
             (int )sfp_tx_fault, (int )link_speed, (int )dcbx_status);
#line 517
      qla83xx_schedule_work(vha, 1);
    } else {

    }
#line 520
    if (((int )*(mb + 1UL) & 8) != 0) {
#line 521
      ql_log(1U, vha, 20585, "Heartbeat Failure encountered, chip reset required.\n");
#line 525
      qla83xx_schedule_work(vha, 1);
    } else {

    }
  } else {

  }
#line 529
  if ((int )*(mb + 1UL) & 1) {
#line 530
    ql_log(2U, vha, 20586, "IDC Device-State changed = 0x%x.\n", (int )*(mb + 4UL));
#line 532
    if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 533
      return;
    } else {

    }
#line 534
    qla83xx_schedule_work(vha, 33280);
  } else {

  }
#line 536
  return;
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
int qla2x00_is_a_vp_did(scsi_qla_host_t *vha , uint32_t rscn_entry ) 
{ 
  struct qla_hw_data *ha ;
  scsi_qla_host_t *vp ;
  uint32_t vp_did ;
  unsigned long flags ;
  int ret ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 541
  ha = vha->hw;
#line 545
  ret = 0;
#line 547
  if ((unsigned int )ha->num_vhosts == 0U) {
#line 548
    return (ret);
  } else {

  }
#line 550
  tmp = spinlock_check(& ha->vport_slock);
#line 550
  flags = _raw_spin_lock_irqsave(tmp);
#line 551
  __mptr = (struct list_head  const  *)ha->vp_list.next;
#line 551
  vp = (scsi_qla_host_t *)__mptr;
#line 551
  goto ldv_65986;
  ldv_65985: 
#line 552
  vp_did = vp->d_id.b24;
#line 553
  if (vp_did == rscn_entry) {
#line 554
    ret = 1;
#line 555
    goto ldv_65984;
  } else {

  }
#line 551
  __mptr___0 = (struct list_head  const  *)vp->list.next;
#line 551
  vp = (scsi_qla_host_t *)__mptr___0;
  ldv_65986: ;
#line 551
  if ((unsigned long )(& vp->list) != (unsigned long )(& ha->vp_list)) {
#line 553
    goto ldv_65985;
  } else {

  }
  ldv_65984: 
#line 558
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 560
  return (ret);
}
}
#line 569 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
void qla2x00_async_event(scsi_qla_host_t *vha , struct rsp_que *rsp , uint16_t *mb ) 
{ 
  uint16_t handle_cnt ;
  uint16_t cnt ;
  uint16_t mbx ;
  uint32_t handles[5U] ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  struct device_reg_24xx *reg24 ;
  struct device_reg_82xx *reg82 ;
  uint32_t rscn_entry ;
  uint32_t host_pid ;
  uint32_t tmp_pid ;
  unsigned long flags ;
  fc_port_t *fcport ;
  unsigned short tmp ;
  unsigned short tmp___0 ;
  unsigned short tmp___1 ;
  unsigned short tmp___2 ;
  unsigned short tmp___3 ;
  unsigned short tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  unsigned short tmp___7 ;
  unsigned short tmp___8 ;
  void *wwpn ;
  u64 tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  bool tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  struct list_head  const  *__mptr ;
  int tmp___24 ;
  struct list_head  const  *__mptr___0 ;
  raw_spinlock_t *tmp___25 ;
  int tmp___26 ;

  {
#line 574
  ha = vha->hw;
#line 575
  reg = & (ha->iobase)->isp;
#line 576
  reg24 = & (ha->iobase)->isp24;
#line 577
  reg82 = & (ha->iobase)->isp82;
#line 580
  fcport = (fc_port_t *)0;
#line 583
  handle_cnt = 0U;
#line 584
  if ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 585
    goto skip_rio;
  } else {

  }
#line 586
  switch ((int )*mb) {
  case 32800: 
#line 588
  handles[0] = (unsigned int )(((int )*(mb + 2UL) << 16) | (int )*(mb + 1UL));
#line 589
  handle_cnt = 1U;
#line 590
  goto ldv_66007;
  case 32817: 
#line 592
  handles[0] = (uint32_t )*(mb + 1UL);
#line 593
  handle_cnt = 1U;
#line 594
  *mb = 32800U;
#line 595
  goto ldv_66007;
  case 32818: 
#line 597
  handles[0] = (uint32_t )*(mb + 1UL);
#line 598
  handles[1] = (uint32_t )*(mb + 2UL);
#line 599
  handle_cnt = 2U;
#line 600
  *mb = 32800U;
#line 601
  goto ldv_66007;
  case 32819: 
#line 603
  handles[0] = (uint32_t )*(mb + 1UL);
#line 604
  handles[1] = (uint32_t )*(mb + 2UL);
#line 605
  handles[2] = (uint32_t )*(mb + 3UL);
#line 606
  handle_cnt = 3U;
#line 607
  *mb = 32800U;
#line 608
  goto ldv_66007;
  case 32820: 
#line 610
  handles[0] = (uint32_t )*(mb + 1UL);
#line 611
  handles[1] = (uint32_t )*(mb + 2UL);
#line 612
  handles[2] = (uint32_t )*(mb + 3UL);
#line 613
  tmp = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 6U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 6U);
#line 613
  handles[3] = (unsigned int )tmp;
#line 614
  handle_cnt = 4U;
#line 615
  *mb = 32800U;
#line 616
  goto ldv_66007;
  case 32821: 
#line 618
  handles[0] = (uint32_t )*(mb + 1UL);
#line 619
  handles[1] = (uint32_t )*(mb + 2UL);
#line 620
  handles[2] = (uint32_t )*(mb + 3UL);
#line 621
  tmp___0 = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 6U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 6U);
#line 621
  handles[3] = (unsigned int )tmp___0;
#line 622
  tmp___1 = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 7U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 7U);
#line 622
  handles[4] = (unsigned int )tmp___1;
#line 623
  handle_cnt = 5U;
#line 624
  *mb = 32800U;
#line 625
  goto ldv_66007;
  case 32834: 
#line 627
  handles[0] = (unsigned int )(((int )*(mb + 2UL) << 16) | (int )*(mb + 1UL));
#line 628
  tmp___2 = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 7U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 7U);
#line 628
  tmp___3 = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 6U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 6U);
#line 628
  handles[1] = (unsigned int )((int )tmp___2 << 16) | (unsigned int )tmp___3;
#line 631
  handle_cnt = 2U;
#line 632
  *mb = 32800U;
#line 633
  goto ldv_66007;
  default: ;
#line 635
  goto ldv_66007;
  }
  ldv_66007: ;
  skip_rio: ;
#line 638
  switch ((int )*mb) {
  case 32800: ;
#line 640
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 641
    goto ldv_66016;
  } else {

  }
#line 643
  cnt = 0U;
#line 643
  goto ldv_66018;
  ldv_66017: 
#line 644
  qla2x00_process_completed_request(vha, rsp->req, handles[(int )cnt]);
#line 643
  cnt = (uint16_t )((int )cnt + 1);
  ldv_66018: ;
#line 643
  if ((int )cnt < (int )handle_cnt) {
#line 645
    goto ldv_66017;
  } else {

  }

#line 646
  goto ldv_66016;
  case 32769: 
#line 649
  ql_dbg(33554432U, vha, 20482, "Asynchronous RESET.\n");
#line 652
  set_bit(0L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 653
  goto ldv_66016;
  case 32770: ;
#line 656
  if (((ha->device_type & 8192U) != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 656
    tmp___4 = readw((void const volatile   *)(& reg24->mailbox7));
#line 656
    mbx = tmp___4;
  } else {
#line 656
    mbx = 0U;
  }
#line 658
  ql_log(1U, vha, 20483, "ISP System Error - mbx1=%xh mbx2=%xh mbx3=%xh mbx7=%xh.\n",
         (int )*(mb + 1UL), (int )*(mb + 2UL), (int )*(mb + 3UL), (int )mbx);
#line 662
  (*((ha->isp_ops)->fw_dump))(vha, 1);
#line 664
  if ((ha->device_type & 134217728U) != 0U) {
#line 665
    if ((unsigned int )*(mb + 1UL) == 0U && (unsigned int )*(mb + 2UL) == 0U) {
#line 666
      ql_log(0U, vha, 20484, "Unrecoverable Hardware Error: adapter marked OFFLINE!\n");
#line 669
      vha->flags.online = 0U;
#line 670
      vha->device_flags = vha->device_flags | 32U;
    } else {
#line 673
      if (((int )mbx & 8) != 0 && (unsigned int )ha->port_no == 0U) {
#line 674
        set_bit(19L, (unsigned long volatile   *)(& vha->dpc_flags));
      } else {

      }
#line 677
      set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
    }
  } else
#line 679
  if ((unsigned int )*(mb + 1UL) == 0U) {
#line 680
    ql_log(0U, vha, 20485, "Unrecoverable Hardware Error: adapter marked OFFLINE!\n");
#line 683
    vha->flags.online = 0U;
#line 684
    vha->device_flags = vha->device_flags | 32U;
  } else {
#line 686
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
  }
#line 687
  goto ldv_66016;
  case 32771: 
#line 690
  ql_log(1U, vha, 20486, "ISP Request Transfer Error (%x).\n", (int )*(mb + 1UL));
#line 693
  set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 694
  goto ldv_66016;
  case 32772: 
#line 697
  ql_log(1U, vha, 20487, "ISP Response Transfer Error.\n");
#line 700
  set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 701
  goto ldv_66016;
  case 32773: 
#line 704
  ql_dbg(33554432U, vha, 20488, "Asynchronous WAKEUP_THRES.\n");
#line 707
  goto ldv_66016;
  case 32784: 
#line 709
  ql_dbg(33554432U, vha, 20489, "LIP occurred (%x).\n", (int )*(mb + 1UL));
#line 712
  tmp___5 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 712
  if (tmp___5 != 2) {
#line 713
    atomic_set(& vha->loop_state, 2);
#line 714
    atomic_set(& vha->loop_down_timer, 255);
#line 715
    qla2x00_mark_all_devices_lost(vha, 1);
  } else {

  }
#line 718
  if ((unsigned int )vha->vp_idx != 0U) {
#line 719
    atomic_set(& vha->vp_state, 2);
#line 720
    fc_vport_set_state(vha->fc_vport, 9);
  } else {

  }
#line 723
  set_bit(9L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 724
  set_bit(12L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 726
  vha->flags.management_server_logged_in = 0U;
#line 727
  qla2x00_post_aen_work(vha, 1, (u32 )*(mb + 1UL));
#line 728
  goto ldv_66016;
  case 32785: ;
#line 731
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 732
    ha->link_data_rate = 0U;
  } else {
#line 734
    ha->link_data_rate = *(mb + 1UL);
  }
#line 736
  tmp___6 = qla2x00_get_link_speed_str(ha, (int )ha->link_data_rate);
#line 736
  ql_log(2U, vha, 20490, "LOOP UP detected (%s Gbps).\n", tmp___6);
#line 740
  vha->flags.management_server_logged_in = 0U;
#line 741
  qla2x00_post_aen_work(vha, 2, (u32 )ha->link_data_rate);
#line 742
  goto ldv_66016;
  case 32786: ;
#line 745
  if ((ha->device_type & 8192U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 745
    tmp___7 = readw((void const volatile   *)(& reg24->mailbox4));
#line 745
    mbx = tmp___7;
  } else {
#line 745
    mbx = 0U;
  }
#line 747
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 747
    tmp___8 = readw((void const volatile   *)(& reg82->mailbox_out) + 4U);
#line 747
    mbx = tmp___8;
  } else {
#line 747
    mbx = mbx;
  }
#line 749
  ql_log(2U, vha, 20491, "LOOP DOWN detected (%x %x %x %x).\n", (int )*(mb + 1UL),
         (int )*(mb + 2UL), (int )*(mb + 3UL), (int )mbx);
#line 753
  tmp___10 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 753
  if (tmp___10 != 2) {
#line 754
    atomic_set(& vha->loop_state, 2);
#line 755
    atomic_set(& vha->loop_down_timer, 255);
#line 761
    if ((unsigned int )vha->vp_idx == 0U) {
#line 762
      if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 763
        wwpn = (void *)(& (ha->init_cb)->port_name);
#line 764
        memcpy((void *)(& vha->port_name), (void const   *)wwpn, 8UL);
#line 765
        ((struct fc_host_attrs *)(vha->host)->shost_data)->port_name = wwn_to_u64((u8 *)(& vha->port_name));
#line 767
        tmp___9 = wwn_to_u64((u8 *)(& vha->port_name));
#line 767
        ql_dbg(1073774592U, vha, 324, "LOOP DOWN detected,restore WWPN %016llx\n",
               tmp___9);
      } else {

      }
#line 773
      clear_bit(5L, (unsigned long volatile   *)(& vha->vp_flags));
    } else {

    }
#line 776
    vha->device_flags = vha->device_flags | 2U;
#line 777
    qla2x00_mark_all_devices_lost(vha, 1);
  } else {

  }
#line 780
  if ((unsigned int )vha->vp_idx != 0U) {
#line 781
    atomic_set(& vha->vp_state, 2);
#line 782
    fc_vport_set_state(vha->fc_vport, 9);
  } else {

  }
#line 785
  vha->flags.management_server_logged_in = 0U;
#line 786
  ha->link_data_rate = 65535U;
#line 787
  qla2x00_post_aen_work(vha, 3, 0U);
#line 788
  goto ldv_66016;
  case 32787: 
#line 791
  ql_dbg(33554432U, vha, 20492, "LIP reset occurred (%x).\n", (int )*(mb + 1UL));
#line 794
  tmp___11 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 794
  if (tmp___11 != 2) {
#line 795
    atomic_set(& vha->loop_state, 2);
#line 796
    atomic_set(& vha->loop_down_timer, 255);
#line 797
    qla2x00_mark_all_devices_lost(vha, 1);
  } else {

  }
#line 800
  if ((unsigned int )vha->vp_idx != 0U) {
#line 801
    atomic_set(& vha->vp_state, 2);
#line 802
    fc_vport_set_state(vha->fc_vport, 9);
  } else {

  }
#line 805
  set_bit(0L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 807
  ha->operating_mode = 0U;
#line 808
  vha->flags.management_server_logged_in = 0U;
#line 809
  qla2x00_post_aen_work(vha, 4, (u32 )*(mb + 1UL));
#line 810
  goto ldv_66016;
  case 32816: ;
#line 814
  if ((int )ha->device_type & 1) {
#line 815
    goto ldv_66016;
  } else {

  }
#line 817
  if ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 818
    ql_dbg(33554432U, vha, 20493, "DCBX Completed -- %04x %04x %04x.\n", (int )*(mb + 1UL),
           (int )*(mb + 2UL), (int )*(mb + 3UL));
#line 821
    if (ha->notify_dcbx_comp != 0 && (unsigned int )vha->vp_idx == 0U) {
#line 822
      complete(& ha->dcbx_comp);
    } else {

    }
  } else {
#line 825
    ql_dbg(33554432U, vha, 20494, "Asynchronous P2P MODE received.\n");
  }
#line 832
  tmp___13 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 832
  if (tmp___13 != 2) {
#line 833
    atomic_set(& vha->loop_state, 2);
#line 834
    tmp___12 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 834
    if (tmp___12 == 0) {
#line 835
      atomic_set(& vha->loop_down_timer, 255);
    } else {

    }
#line 837
    qla2x00_mark_all_devices_lost(vha, 1);
  } else {

  }
#line 840
  if ((unsigned int )vha->vp_idx != 0U) {
#line 841
    atomic_set(& vha->vp_state, 2);
#line 842
    fc_vport_set_state(vha->fc_vport, 9);
  } else {

  }
#line 845
  tmp___14 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 845
  if (tmp___14 == 0) {
#line 846
    set_bit(0L, (unsigned long volatile   *)(& vha->dpc_flags));
  } else {

  }
#line 848
  set_bit(9L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 849
  set_bit(12L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 851
  ha->flags.gpsc_supported = 1U;
#line 852
  vha->flags.management_server_logged_in = 0U;
#line 853
  goto ldv_66016;
  case 32822: ;
#line 856
  if ((int )ha->device_type & 1) {
#line 857
    goto ldv_66016;
  } else {

  }
#line 859
  ql_dbg(33554432U, vha, 20495, "Configuration change detected: value=%x.\n", (int )*(mb + 1UL));
#line 862
  tmp___16 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 862
  if (tmp___16 != 2) {
#line 863
    atomic_set(& vha->loop_state, 2);
#line 864
    tmp___15 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 864
    if (tmp___15 == 0) {
#line 865
      atomic_set(& vha->loop_down_timer, 255);
    } else {

    }
#line 867
    qla2x00_mark_all_devices_lost(vha, 1);
  } else {

  }
#line 870
  if ((unsigned int )vha->vp_idx != 0U) {
#line 871
    atomic_set(& vha->vp_state, 2);
#line 872
    fc_vport_set_state(vha->fc_vport, 9);
  } else {

  }
#line 875
  set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 876
  set_bit(6L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 877
  goto ldv_66016;
  case 32788: ;
#line 895
  if (((((((((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || (ha->device_type & 4096U) != 0U) || (ha->device_type & 2048U) != 0U) || (ha->device_type & 8192U) != 0U) || (ha->device_type & 16384U) != 0U) || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || (ha->device_type & 262144U) != 0U) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) && (((unsigned int )*(mb + 1UL) == 65535U && ((int )*(mb + 3UL) & 255) != 255) || (unsigned int )*(mb + 1UL) != 65535U)) && (int )vha->vp_idx != ((int )*(mb + 3UL) & 255)) {
#line 898
    goto ldv_66016;
  } else {

  }
#line 901
  if ((unsigned int )*(mb + 1UL) == 65535U && (unsigned int )*(mb + 2UL) == 7U) {
#line 902
    ql_dbg(33554432U, vha, 20496, "Port unavailable %04x %04x %04x.\n", (int )*(mb + 1UL),
           (int )*(mb + 2UL), (int )*(mb + 3UL));
#line 905
    ql_log(1U, vha, 20574, "Link is offline.\n");
#line 908
    tmp___17 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 908
    if (tmp___17 != 2) {
#line 909
      atomic_set(& vha->loop_state, 2);
#line 910
      atomic_set(& vha->loop_down_timer, 255);
#line 912
      vha->device_flags = vha->device_flags | 2U;
#line 913
      qla2x00_mark_all_devices_lost(vha, 1);
    } else {

    }
#line 916
    if ((unsigned int )vha->vp_idx != 0U) {
#line 917
      atomic_set(& vha->vp_state, 2);
#line 918
      fc_vport_set_state(vha->fc_vport, 9);
#line 920
      qla2x00_mark_all_devices_lost(vha, 1);
    } else {

    }
#line 923
    vha->flags.management_server_logged_in = 0U;
#line 924
    ha->link_data_rate = 65535U;
#line 925
    goto ldv_66016;
  } else {

  }
#line 933
  atomic_set(& vha->loop_down_timer, 0);
#line 934
  tmp___18 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 934
  if (tmp___18 != 2) {
#line 934
    tmp___19 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 934
    if (tmp___19 != 6) {
#line 936
      ql_dbg(33554432U, vha, 20497, "Asynchronous PORT UPDATE ignored %04x/%04x/%04x.\n",
             (int )*(mb + 1UL), (int )*(mb + 2UL), (int )*(mb + 3UL));
#line 940
      qlt_async_event((int )*mb, vha, mb);
#line 941
      goto ldv_66016;
    } else {

    }
  } else {

  }
#line 944
  ql_dbg(33554432U, vha, 20498, "Port database changed %04x %04x %04x.\n", (int )*(mb + 1UL),
         (int )*(mb + 2UL), (int )*(mb + 3UL));
#line 951
  atomic_set(& vha->loop_state, 3);
#line 953
  qla2x00_mark_all_devices_lost(vha, 1);
#line 955
  if ((unsigned int )vha->vp_idx == 0U) {
#line 955
    tmp___20 = qla_ini_mode_enabled(vha);
#line 955
    if (tmp___20) {
#line 955
      tmp___21 = 0;
    } else {
#line 955
      tmp___21 = 1;
    }
#line 955
    if (tmp___21) {
#line 956
      set_bit(21L, (unsigned long volatile   *)(& vha->dpc_flags));
    } else {

    }
  } else {

  }
#line 958
  set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 959
  set_bit(6L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 960
  set_bit(5L, (unsigned long volatile   *)(& vha->vp_flags));
#line 962
  qlt_async_event((int )*mb, vha, mb);
#line 963
  goto ldv_66016;
  case 32789: ;
#line 967
  if ((unsigned int )vha->vp_idx != 0U) {
#line 967
    tmp___22 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->vp_flags));
#line 967
    if (tmp___22 != 0) {
#line 968
      goto ldv_66016;
    } else {

    }
  } else {

  }
#line 970
  if (*((unsigned long *)ha + 2UL) != 0UL && (int )vha->vp_idx != ((int )*(mb + 3UL) & 255)) {
#line 971
    goto ldv_66016;
  } else {

  }
#line 973
  ql_dbg(33554432U, vha, 20499, "RSCN database changed -- %04x %04x %04x.\n", (int )*(mb + 1UL),
         (int )*(mb + 2UL), (int )*(mb + 3UL));
#line 977
  rscn_entry = (uint32_t )((((int )*(mb + 1UL) & 255) << 16) | (int )*(mb + 2UL));
#line 978
  host_pid = (uint32_t )((((int )vha->d_id.b.domain << 16) | ((int )vha->d_id.b.area << 8)) | (int )vha->d_id.b.al_pa);
#line 980
  if (rscn_entry == host_pid) {
#line 981
    ql_dbg(33554432U, vha, 20500, "Ignoring RSCN update to local host port ID (%06x).\n",
           host_pid);
#line 984
    goto ldv_66016;
  } else {

  }
#line 988
  rscn_entry = (uint32_t )((((int )*(mb + 1UL) & 1023) << 16) | (int )*(mb + 2UL));
#line 991
  tmp___23 = qla2x00_is_a_vp_did(vha, rscn_entry);
#line 991
  if (tmp___23 != 0) {
#line 992
    goto ldv_66016;
  } else {

  }
#line 998
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 998
  fcport = (fc_port_t *)__mptr;
#line 998
  goto ldv_66041;
  ldv_66040: 
#line 999
  tmp___24 = atomic_read((atomic_t const   *)(& fcport->state));
#line 999
  if (tmp___24 != 4) {
#line 1000
    goto ldv_66038;
  } else {

  }
#line 1001
  tmp_pid = fcport->d_id.b24;
#line 1002
  if (fcport->d_id.b24 == rscn_entry) {
#line 1003
    qla2x00_mark_device_lost(vha, fcport, 0, 0);
#line 1004
    goto ldv_66039;
  } else {

  }
  ldv_66038: 
#line 998
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 998
  fcport = (fc_port_t *)__mptr___0;
  ldv_66041: ;
#line 998
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 1000
    goto ldv_66040;
  } else {

  }
  ldv_66039: 
#line 1008
  atomic_set(& vha->loop_down_timer, 0);
#line 1009
  vha->flags.management_server_logged_in = 0U;
#line 1011
  set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1012
  set_bit(7L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1013
  qla2x00_post_aen_work(vha, 5, rscn_entry);
#line 1014
  goto ldv_66016;
  case 32832: 
#line 1018
  ql_dbg(33554432U, vha, 20501, "[R|Z]IO update completion.\n");
#line 1021
  if ((ha->device_type & 134217728U) != 0U) {
#line 1022
    qla24xx_process_response_queue(vha, rsp);
  } else {
#line 1024
    qla2x00_process_response_queue(rsp);
  }
#line 1025
  goto ldv_66016;
  case 32840: 
#line 1028
  ql_dbg(33554432U, vha, 20502, "Discard RND Frame -- %04x %04x %04x.\n", (int )*(mb + 1UL),
         (int )*(mb + 2UL), (int )*(mb + 3UL));
#line 1031
  goto ldv_66016;
  case 32808: 
#line 1034
  ql_dbg(33554432U, vha, 20503, "Trace Notification -- %04x %04x.\n", (int )*(mb + 1UL),
         (int )*(mb + 2UL));
#line 1036
  goto ldv_66016;
  case 32783: 
#line 1039
  ql_dbg(33554432U, vha, 20504, "ISP84XX Alert Notification -- %04x %04x %04x.\n",
         (int )*(mb + 1UL), (int )*(mb + 2UL), (int )*(mb + 3UL));
#line 1043
  tmp___25 = spinlock_check(& (ha->cs84xx)->access_lock);
#line 1043
  flags = _raw_spin_lock_irqsave(tmp___25);
#line 1044
  switch ((int )*(mb + 1UL)) {
  case 1: 
#line 1046
  ql_log(2U, vha, 20505, "Alert 84XX: panic recovery %04x %04x.\n", (int )*(mb + 2UL),
         (int )*(mb + 3UL));
#line 1049
  goto ldv_66050;
  case 2: 
#line 1051
  (ha->cs84xx)->op_fw_version = (uint32_t )(((int )*(mb + 3UL) << 16) | (int )*(mb + 2UL));
#line 1052
  ql_log(2U, vha, 20506, "Alert 84XX: firmware version %x.\n", (ha->cs84xx)->op_fw_version);
#line 1055
  goto ldv_66050;
  case 3: 
#line 1057
  (ha->cs84xx)->diag_fw_version = (uint32_t )(((int )*(mb + 3UL) << 16) | (int )*(mb + 2UL));
#line 1058
  ql_log(2U, vha, 20507, "Alert 84XX: diagnostic firmware version %x.\n", (ha->cs84xx)->diag_fw_version);
#line 1061
  goto ldv_66050;
  case 4: 
#line 1063
  (ha->cs84xx)->diag_fw_version = (uint32_t )(((int )*(mb + 3UL) << 16) | (int )*(mb + 2UL));
#line 1064
  (ha->cs84xx)->fw_update = 1U;
#line 1065
  ql_log(2U, vha, 20508, "Alert 84XX: gold firmware version %x.\n", (ha->cs84xx)->gold_fw_version);
#line 1068
  goto ldv_66050;
  default: 
#line 1070
  ql_log(1U, vha, 20509, "Alert 84xx: Invalid Alert %04x %04x %04x.\n", (int )*(mb + 1UL),
         (int )*(mb + 2UL), (int )*(mb + 3UL));
  }
  ldv_66050: 
#line 1074
  spin_unlock_irqrestore(& (ha->cs84xx)->access_lock, flags);
#line 1075
  goto ldv_66016;
  case 32790: 
#line 1077
  ql_dbg(33554432U, vha, 20510, "DCBX Started -- %04x %04x %04x.\n", (int )*(mb + 1UL),
         (int )*(mb + 2UL), (int )*(mb + 3UL));
#line 1080
  goto ldv_66016;
  case 32818: 
#line 1082
  ql_dbg(33554432U, vha, 20511, "DCBX Parameters Updated -- %04x %04x %04x.\n", (int )*(mb + 1UL),
         (int )*(mb + 2UL), (int )*(mb + 3UL));
#line 1085
  goto ldv_66016;
  case 32817: 
#line 1087
  ql_dbg(33554432U, vha, 20512, "FCF Configuration Error -- %04x %04x %04x.\n", (int )*(mb + 1UL),
         (int )*(mb + 2UL), (int )*(mb + 3UL));
#line 1090
  goto ldv_66016;
  case 33025: ;
#line 1092
  if (((vha->hw)->device_type & 65536U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1093
    *(mb + 4UL) = readw((void const volatile   *)(& reg24->mailbox4));
#line 1094
    if ((((int )*(mb + 2UL) & 32767) == 288 || ((int )*(mb + 2UL) & 32767) == 290) && ((int )*(mb + 4UL) & 14) != 0) {
#line 1097
      set_bit(20L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1101
      tmp___26 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 1101
      if (tmp___26 == 2) {
#line 1102
        atomic_set(& vha->loop_down_timer, 255);
      } else {

      }
#line 1104
      qla2xxx_wake_dpc(vha);
    } else {

    }
  } else {

  }
  case 33024: ;
#line 1108
  if (ha->notify_lb_portup_comp != 0 && (unsigned int )vha->vp_idx == 0U) {
#line 1109
    complete(& ha->lb_portup_comp);
  } else {

  }
  case 33026: ;
#line 1112
  if ((((vha->hw)->device_type & 8192U) != 0U || ((vha->hw)->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 1114
    qla81xx_idc_event(vha, (int )*mb, (int )*(mb + 1UL));
  } else {

  }
#line 1115
  goto ldv_66016;
  case 33280: 
#line 1118
  *(mb + 4UL) = readw((void const volatile   *)(& reg24->mailbox4));
#line 1119
  *(mb + 5UL) = readw((void const volatile   *)(& reg24->mailbox5));
#line 1120
  *(mb + 6UL) = readw((void const volatile   *)(& reg24->mailbox6));
#line 1121
  *(mb + 7UL) = readw((void const volatile   *)(& reg24->mailbox7));
#line 1122
  qla83xx_handle_8200_aen(vha, mb);
#line 1123
  goto ldv_66016;
  case 32896: 
#line 1126
  ql_dbg(33554432U, vha, 20562, "D-Port Diagnostics: %04x %04x=%s\n", (int )*mb, (int )*(mb + 1UL),
         (unsigned int )*(mb + 1UL) != 0U ? ((unsigned int )*(mb + 1UL) != 1U ? ((unsigned int )*(mb + 1UL) == 2U ? (char *)"done (error)" : (char *)"other") : (char *)"done (ok)") : (char *)"start");
#line 1131
  goto ldv_66016;
  default: 
#line 1134
  ql_dbg(33554432U, vha, 20567, "Unknown AEN:%04x %04x %04x %04x\n", (int )*mb, (int )*(mb + 1UL),
         (int )*(mb + 2UL), (int )*(mb + 3UL));
  }
  ldv_66016: 
#line 1139
  qlt_async_event((int )*mb, vha, mb);
#line 1141
  if ((unsigned int )vha->vp_idx == 0U && (unsigned int )ha->num_vhosts != 0U) {
#line 1142
    qla2x00_alert_all_vps(rsp, mb);
  } else {

  }
#line 1143
  return;
}
}
#line 1151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
void qla2x00_process_completed_request(struct scsi_qla_host *vha , struct req_que *req ,
                                       uint32_t index ) 
{ 
  srb_t *sp ;
  struct qla_hw_data *ha ;

  {
#line 1155
  ha = vha->hw;
#line 1158
  if ((uint32_t )req->num_outstanding_cmds <= index) {
#line 1159
    ql_log(1U, vha, 12308, "Invalid SCSI command index (%x).\n", index);
#line 1162
    if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1163
      set_bit(18L, (unsigned long volatile   *)(& vha->dpc_flags));
    } else {
#line 1165
      set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
    }
#line 1166
    return;
  } else {

  }
#line 1169
  sp = *(req->outstanding_cmds + (unsigned long )index);
#line 1170
  if ((unsigned long )sp != (unsigned long )((srb_t *)0)) {
#line 1172
    *(req->outstanding_cmds + (unsigned long )index) = (srb_t *)0;
#line 1175
    (*(sp->done))((void *)ha, (void *)sp, 0);
  } else {
#line 1177
    ql_log(1U, vha, 12310, "Invalid SCSI SRB.\n");
#line 1179
    if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1180
      set_bit(18L, (unsigned long volatile   *)(& vha->dpc_flags));
    } else {
#line 1182
      set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
    }
  }
#line 1184
  return;
}
}
#line 1187 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
srb_t *qla2x00_get_sp_from_handle(scsi_qla_host_t *vha , char const   *func , struct req_que *req ,
                                  void *iocb ) 
{ 
  struct qla_hw_data *ha ;
  sts_entry_t *pkt ;
  srb_t *sp ;
  uint16_t index ;

  {
#line 1190
  ha = vha->hw;
#line 1191
  pkt = (sts_entry_t *)iocb;
#line 1192
  sp = (srb_t *)0;
#line 1195
  index = (unsigned short )pkt->handle;
#line 1196
  if ((int )req->num_outstanding_cmds <= (int )index) {
#line 1197
    ql_log(1U, vha, 20529, "Invalid command index (%x).\n", (int )index);
#line 1199
    if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1200
      set_bit(18L, (unsigned long volatile   *)(& vha->dpc_flags));
    } else {
#line 1202
      set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
    }
#line 1203
    goto done;
  } else {

  }
#line 1205
  sp = *(req->outstanding_cmds + (unsigned long )index);
#line 1206
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 1207
    ql_log(1U, vha, 20530, "Invalid completion handle (%x) -- timed-out.\n", (int )index);
#line 1209
    return (sp);
  } else {

  }
#line 1211
  if (sp->handle != (uint32_t )index) {
#line 1212
    ql_log(1U, vha, 20531, "SRB handle (%x) mismatch %x.\n", sp->handle, (int )index);
#line 1214
    return ((srb_t *)0);
  } else {

  }
#line 1217
  *(req->outstanding_cmds + (unsigned long )index) = (srb_t *)0;
  done: ;
#line 1220
  return (sp);
}
}
#line 1224 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
static void qla2x00_mbx_iocb_entry(scsi_qla_host_t *vha , struct req_que *req , struct mbx_entry *mbx ) 
{ 
  char func[9U] ;
  char const   *type ;
  fc_port_t *fcport ;
  srb_t *sp ;
  struct srb_iocb *lio ;
  uint16_t *data ;
  uint16_t status ;

  {
#line 1227
  func[0] = 'M';
#line 1227
  func[1] = 'B';
#line 1227
  func[2] = 'X';
#line 1227
  func[3] = '-';
#line 1227
  func[4] = 'I';
#line 1227
  func[5] = 'O';
#line 1227
  func[6] = 'C';
#line 1227
  func[7] = 'B';
#line 1227
  func[8] = '\000';
#line 1235
  sp = qla2x00_get_sp_from_handle(vha, (char const   *)(& func), req, (void *)mbx);
#line 1236
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 1237
    return;
  } else {

  }
#line 1239
  lio = & sp->u.iocb_cmd;
#line 1240
  type = (char const   *)sp->name;
#line 1241
  fcport = sp->fcport;
#line 1242
  data = (uint16_t *)(& lio->u.logio.data);
#line 1244
  *data = 16389U;
#line 1245
  *(data + 1UL) = (unsigned int )lio->u.logio.flags & 1U;
#line 1247
  if ((unsigned int )mbx->entry_status != 0U) {
#line 1248
    ql_dbg(33554432U, vha, 20547, "Async-%s error entry - hdl=%x portid=%02x%02x%02x entry-status=%x status=%x state-flag=%x status-flags=%x.\n",
           type, sp->handle, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
           (int )fcport->d_id.b.al_pa, (int )mbx->entry_status, (int )mbx->status,
           (int )mbx->state_flags, (int )mbx->status_flags);
#line 1257
    ql_dump_buffer(33685504U, vha, 20521, (uint8_t *)mbx, 64U);
#line 1260
    goto logio_done;
  } else {

  }
#line 1263
  status = mbx->status;
#line 1264
  if (((unsigned int )status == 48U && (unsigned int )sp->type == 1U) && (unsigned int )mbx->mb0 == 16384U) {
#line 1266
    status = 0U;
  } else {

  }
#line 1267
  if ((unsigned int )status == 0U && (unsigned int )mbx->mb0 == 16384U) {
#line 1268
    ql_dbg(33554432U, vha, 20549, "Async-%s complete - hdl=%x portid=%02x%02x%02x mbx1=%x.\n",
           type, sp->handle, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
           (int )fcport->d_id.b.al_pa, (int )mbx->mb1);
#line 1274
    *data = 16384U;
#line 1275
    if ((unsigned int )sp->type == 1U) {
#line 1276
      fcport->port_type = 5;
#line 1277
      if ((int )mbx->mb1 & 1) {
#line 1278
        fcport->port_type = 4;
      } else
#line 1279
      if (((int )mbx->mb1 & 2) != 0) {
#line 1280
        fcport->flags = fcport->flags | 4U;
      } else {

      }
    } else {

    }
#line 1282
    goto logio_done;
  } else {

  }
#line 1285
  *data = mbx->mb0;
#line 1286
  switch ((int )*data) {
  case 16391: 
#line 1288
  *(data + 1UL) = mbx->mb1;
#line 1289
  goto ldv_66096;
  case 16392: ;
#line 1291
  goto ldv_66096;
  default: 
#line 1293
  *data = 16389U;
#line 1294
  goto ldv_66096;
  }
  ldv_66096: 
#line 1297
  ql_log(1U, vha, 20550, "Async-%s failed - hdl=%x portid=%02x%02x%02x status=%x mb0=%x mb1=%x mb2=%x mb6=%x mb7=%x.\n",
         type, sp->handle, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
         (int )fcport->d_id.b.al_pa, (int )status, (int )mbx->mb0, (int )mbx->mb1,
         (int )mbx->mb2, (int )mbx->mb6, (int )mbx->mb7);
  logio_done: 
#line 1306
  (*(sp->done))((void *)vha, (void *)sp, 0);
#line 1307
  return;
}
}
#line 1310 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
static void qla2x00_ct_entry(scsi_qla_host_t *vha , struct req_que *req , sts_entry_t *pkt ,
                             int iocb_type ) 
{ 
  char func[8U] ;
  char const   *type ;
  srb_t *sp ;
  struct fc_bsg_job *bsg_job ;
  uint16_t comp_status ;
  int res ;

  {
#line 1313
  func[0] = 'C';
#line 1313
  func[1] = 'T';
#line 1313
  func[2] = '_';
#line 1313
  func[3] = 'I';
#line 1313
  func[4] = 'O';
#line 1313
  func[5] = 'C';
#line 1313
  func[6] = 'B';
#line 1313
  func[7] = '\000';
#line 1320
  sp = qla2x00_get_sp_from_handle(vha, (char const   *)(& func), req, (void *)pkt);
#line 1321
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 1322
    return;
  } else {

  }
#line 1324
  bsg_job = sp->u.bsg_job;
#line 1326
  type = "ct pass-through";
#line 1328
  comp_status = pkt->comp_status;
#line 1333
  (bsg_job->reply)->reply_data.ctels_reply.status = 0U;
#line 1334
  bsg_job->reply_len = 16U;
#line 1336
  if ((unsigned int )comp_status != 0U) {
#line 1337
    if ((unsigned int )comp_status == 21U) {
#line 1338
      res = 0;
#line 1339
      (bsg_job->reply)->reply_payload_rcv_len = (uint32_t )pkt->rsp_info_len;
#line 1342
      ql_log(1U, vha, 20552, "CT pass-through-%s error comp_status-status=0x%x total_byte = 0x%x.\n",
             type, (int )comp_status, (bsg_job->reply)->reply_payload_rcv_len);
    } else {
#line 1348
      ql_log(1U, vha, 20553, "CT pass-through-%s error comp_status-status=0x%x.\n",
             type, (int )comp_status);
#line 1351
      res = 458752;
#line 1352
      (bsg_job->reply)->reply_payload_rcv_len = 0U;
    }
#line 1354
    ql_dump_buffer(33685504U, vha, 20533, (uint8_t *)pkt, 64U);
  } else {
#line 1357
    res = 0;
#line 1358
    (bsg_job->reply)->reply_payload_rcv_len = bsg_job->reply_payload.payload_len;
#line 1360
    bsg_job->reply_len = 0U;
  }
#line 1363
  (*(sp->done))((void *)vha, (void *)sp, res);
#line 1364
  return;
}
}
#line 1367 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
static void qla24xx_els_ct_entry(scsi_qla_host_t *vha , struct req_que *req , struct sts_entry_24xx *pkt ,
                                 int iocb_type ) 
{ 
  char func[12U] ;
  char const   *type ;
  srb_t *sp ;
  struct fc_bsg_job *bsg_job ;
  uint16_t comp_status ;
  uint32_t fw_status[3U] ;
  uint8_t *fw_sts_ptr ;
  int res ;

  {
#line 1370
  func[0] = 'E';
#line 1370
  func[1] = 'L';
#line 1370
  func[2] = 'S';
#line 1370
  func[3] = '_';
#line 1370
  func[4] = 'C';
#line 1370
  func[5] = 'T';
#line 1370
  func[6] = '_';
#line 1370
  func[7] = 'I';
#line 1370
  func[8] = 'O';
#line 1370
  func[9] = 'C';
#line 1370
  func[10] = 'B';
#line 1370
  func[11] = '\000';
#line 1379
  sp = qla2x00_get_sp_from_handle(vha, (char const   *)(& func), req, (void *)pkt);
#line 1380
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 1381
    return;
  } else {

  }
#line 1382
  bsg_job = sp->u.bsg_job;
#line 1384
  type = (char const   *)0;
#line 1385
  switch ((int )sp->type) {
  case 3: ;
  case 4: 
#line 1388
  type = "els";
#line 1389
  goto ldv_66127;
  case 5: 
#line 1391
  type = "ct pass-through";
#line 1392
  goto ldv_66127;
  default: 
#line 1394
  ql_dbg(8388608U, vha, 20542, "Unrecognized SRB: (%p) type=%d.\n", sp, (int )sp->type);
#line 1396
  return;
  }
  ldv_66127: 
#line 1399
  fw_status[0] = (uint32_t )pkt->comp_status;
#line 1399
  comp_status = (uint16_t )fw_status[0];
#line 1400
  fw_status[1] = (uint32_t )((unsigned short )((struct els_sts_entry_24xx *)pkt)->error_subcode_1);
#line 1401
  fw_status[2] = (uint32_t )((unsigned short )((struct els_sts_entry_24xx *)pkt)->error_subcode_2);
#line 1406
  (bsg_job->reply)->reply_data.ctels_reply.status = 0U;
#line 1407
  bsg_job->reply_len = 28U;
#line 1409
  if ((unsigned int )comp_status != 0U) {
#line 1410
    if ((unsigned int )comp_status == 21U) {
#line 1411
      res = 0;
#line 1412
      (bsg_job->reply)->reply_payload_rcv_len = (uint32_t )((unsigned short )((struct els_sts_entry_24xx *)pkt)->total_byte_count);
#line 1415
      ql_dbg(8388608U, vha, 20543, "ELS-CT pass-through-%s error hdl=%x comp_status-status=0x%x error subcode 1=0x%x error subcode 2=0x%x total_byte = 0x%x.\n",
             type, sp->handle, (int )comp_status, fw_status[1], fw_status[2], (int )((unsigned short )((struct els_sts_entry_24xx *)pkt)->total_byte_count));
#line 1421
      fw_sts_ptr = (uint8_t *)(bsg_job->req)->sense + 16UL;
#line 1422
      memcpy((void *)fw_sts_ptr, (void const   *)(& fw_status), 12UL);
    } else {
#line 1425
      ql_dbg(8388608U, vha, 20544, "ELS-CT pass-through-%s error hdl=%x comp_status-status=0x%x error subcode 1=0x%x error subcode 2=0x%x.\n",
             type, sp->handle, (int )comp_status, (int )((unsigned short )((struct els_sts_entry_24xx *)pkt)->error_subcode_1),
             (int )((unsigned short )((struct els_sts_entry_24xx *)pkt)->error_subcode_2));
#line 1433
      res = 458752;
#line 1434
      (bsg_job->reply)->reply_payload_rcv_len = 0U;
#line 1435
      fw_sts_ptr = (uint8_t *)(bsg_job->req)->sense + 16UL;
#line 1436
      memcpy((void *)fw_sts_ptr, (void const   *)(& fw_status), 12UL);
    }
#line 1438
    ql_dump_buffer(8519680U, vha, 20566, (uint8_t *)pkt, 64U);
  } else {
#line 1442
    res = 0;
#line 1443
    (bsg_job->reply)->reply_payload_rcv_len = bsg_job->reply_payload.payload_len;
#line 1444
    bsg_job->reply_len = 0U;
  }
#line 1447
  (*(sp->done))((void *)vha, (void *)sp, res);
#line 1448
  return;
}
}
#line 1451 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
static void qla24xx_logio_entry(scsi_qla_host_t *vha , struct req_que *req , struct logio_entry_24xx *logio ) 
{ 
  char func[11U] ;
  char const   *type ;
  fc_port_t *fcport ;
  srb_t *sp ;
  struct srb_iocb *lio ;
  uint16_t *data ;
  uint32_t iop[2U] ;

  {
#line 1454
  func[0] = 'L';
#line 1454
  func[1] = 'O';
#line 1454
  func[2] = 'G';
#line 1454
  func[3] = 'I';
#line 1454
  func[4] = 'O';
#line 1454
  func[5] = '-';
#line 1454
  func[6] = 'I';
#line 1454
  func[7] = 'O';
#line 1454
  func[8] = 'C';
#line 1454
  func[9] = 'B';
#line 1454
  func[10] = '\000';
#line 1462
  sp = qla2x00_get_sp_from_handle(vha, (char const   *)(& func), req, (void *)logio);
#line 1463
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 1464
    return;
  } else {

  }
#line 1466
  lio = & sp->u.iocb_cmd;
#line 1467
  type = (char const   *)sp->name;
#line 1468
  fcport = sp->fcport;
#line 1469
  data = (uint16_t *)(& lio->u.logio.data);
#line 1471
  *data = 16389U;
#line 1472
  *(data + 1UL) = (unsigned int )lio->u.logio.flags & 1U;
#line 1474
  if ((unsigned int )logio->entry_status != 0U) {
#line 1475
    ql_log(1U, fcport->vha, 20532, "Async-%s error entry - hdl=%xportid=%02x%02x%02x entry-status=%x.\n",
           type, sp->handle, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
           (int )fcport->d_id.b.al_pa, (int )logio->entry_status);
#line 1481
    ql_dump_buffer(33685504U, vha, 20557, (uint8_t *)logio, 64U);
#line 1484
    goto logio_done;
  } else {

  }
#line 1487
  if ((unsigned int )logio->comp_status == 0U) {
#line 1488
    ql_dbg(33554432U, fcport->vha, 20534, "Async-%s complete - hdl=%x portid=%02x%02x%02x iop0=%x.\n",
           type, sp->handle, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
           (int )fcport->d_id.b.al_pa, logio->io_parameter[0]);
#line 1494
    *data = 16384U;
#line 1495
    if ((unsigned int )sp->type != 1U) {
#line 1496
      goto logio_done;
    } else {

    }
#line 1498
    iop[0] = logio->io_parameter[0];
#line 1499
    if ((iop[0] & 16U) != 0U) {
#line 1500
      fcport->port_type = 5;
#line 1501
      if ((iop[0] & 256U) != 0U) {
#line 1502
        fcport->flags = fcport->flags | 4U;
      } else {

      }
    } else
#line 1503
    if ((iop[0] & 32U) != 0U) {
#line 1504
      fcport->port_type = 4;
    } else {

    }
#line 1506
    if ((iop[0] & 128U) != 0U) {
#line 1507
      fcport->flags = fcport->flags | 16U;
    } else {

    }
#line 1509
    if (logio->io_parameter[7] != 0U || logio->io_parameter[8] != 0U) {
#line 1510
      fcport->supported_classes = fcport->supported_classes | 4U;
    } else {

    }
#line 1511
    if (logio->io_parameter[9] != 0U || logio->io_parameter[10] != 0U) {
#line 1512
      fcport->supported_classes = fcport->supported_classes | 8U;
    } else {

    }
#line 1514
    goto logio_done;
  } else {

  }
#line 1517
  iop[0] = logio->io_parameter[0];
#line 1518
  iop[1] = logio->io_parameter[1];
#line 1519
  switch (iop[0]) {
  case 26U: 
#line 1521
  *data = 16391U;
#line 1522
  *(data + 1UL) = (unsigned short )iop[1];
#line 1523
  goto ldv_66144;
  case 27U: 
#line 1525
  *data = 16392U;
#line 1526
  goto ldv_66144;
  default: 
#line 1528
  *data = 16389U;
#line 1529
  goto ldv_66144;
  }
  ldv_66144: 
#line 1532
  ql_dbg(33554432U, fcport->vha, 20535, "Async-%s failed - hdl=%x portid=%02x%02x%02x comp=%x iop0=%x iop1=%x.\n",
         type, sp->handle, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
         (int )fcport->d_id.b.al_pa, (int )logio->comp_status, logio->io_parameter[0],
         logio->io_parameter[1]);
  logio_done: 
#line 1541
  (*(sp->done))((void *)vha, (void *)sp, 0);
#line 1542
  return;
}
}
#line 1545 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
static void qla24xx_tm_iocb_entry(scsi_qla_host_t *vha , struct req_que *req , void *tsk ) 
{ 
  char func[9U] ;
  char const   *type ;
  fc_port_t *fcport ;
  srb_t *sp ;
  struct srb_iocb *iocb ;
  struct sts_entry_24xx *sts ;

  {
#line 1547
  func[0] = 'T';
#line 1547
  func[1] = 'M';
#line 1547
  func[2] = 'F';
#line 1547
  func[3] = '-';
#line 1547
  func[4] = 'I';
#line 1547
  func[5] = 'O';
#line 1547
  func[6] = 'C';
#line 1547
  func[7] = 'B';
#line 1547
  func[8] = '\000';
#line 1552
  sts = (struct sts_entry_24xx *)tsk;
#line 1554
  sp = qla2x00_get_sp_from_handle(vha, (char const   *)(& func), req, tsk);
#line 1555
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 1556
    return;
  } else {

  }
#line 1558
  iocb = & sp->u.iocb_cmd;
#line 1559
  type = (char const   *)sp->name;
#line 1560
  fcport = sp->fcport;
#line 1561
  iocb->u.tmf.data = 0U;
#line 1563
  if ((unsigned int )sts->entry_status != 0U) {
#line 1564
    ql_log(1U, fcport->vha, 20536, "Async-%s error - hdl=%x entry-status(%x).\n",
           type, sp->handle, (int )sts->entry_status);
#line 1567
    iocb->u.tmf.data = 258U;
  } else
#line 1568
  if ((unsigned int )sts->comp_status != 0U) {
#line 1569
    ql_log(1U, fcport->vha, 20537, "Async-%s error - hdl=%x completion status(%x).\n",
           type, sp->handle, (int )sts->comp_status);
#line 1572
    iocb->u.tmf.data = 258U;
  } else
#line 1573
  if (((int )sts->scsi_status & 256) != 0) {
#line 1575
    if (sts->rsp_data_len <= 3U) {
#line 1576
      ql_log(1U, fcport->vha, 20539, "Async-%s error - hdl=%x not enough response(%d).\n",
             type, sp->handle, sts->rsp_data_len);
    } else
#line 1579
    if ((unsigned int )sts->data[3] != 0U) {
#line 1580
      ql_log(1U, fcport->vha, 20540, "Async-%s error - hdl=%x response(%x).\n", type,
             sp->handle, (int )sts->data[3]);
#line 1583
      iocb->u.tmf.data = 258U;
    } else {

    }
  } else {

  }
#line 1587
  if (iocb->u.tmf.data != 0U) {
#line 1588
    ql_dump_buffer(33685504U, vha, 20565, (uint8_t *)sts, 64U);
  } else {

  }
#line 1591
  (*(sp->done))((void *)vha, (void *)sp, 0);
#line 1592
  return;
}
}
#line 1599 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
void qla2x00_process_response_queue(struct rsp_que *rsp ) 
{ 
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  sts_entry_t *pkt ;
  uint16_t handle_cnt ;
  uint16_t cnt ;
  void *tmp ;

  {
#line 1602
  ha = rsp->hw;
#line 1603
  reg = & (ha->iobase)->isp;
#line 1608
  tmp = pci_get_drvdata(ha->pdev);
#line 1608
  vha = (struct scsi_qla_host *)tmp;
#line 1610
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 1611
    return;
  } else {

  }
#line 1613
  goto ldv_66167;
  ldv_66182: 
#line 1614
  pkt = (sts_entry_t *)rsp->ring_ptr;
#line 1616
  rsp->ring_index = (uint16_t )((int )rsp->ring_index + 1);
#line 1617
  if ((int )rsp->ring_index == (int )rsp->length) {
#line 1618
    rsp->ring_index = 0U;
#line 1619
    rsp->ring_ptr = rsp->ring;
  } else {
#line 1621
    rsp->ring_ptr = rsp->ring_ptr + 1;
  }
#line 1624
  if ((unsigned int )pkt->entry_status != 0U) {
#line 1625
    qla2x00_error_entry(vha, rsp, pkt);
#line 1626
    ((response_t *)pkt)->signature = 3735936685U;
#line 1627
    __asm__  volatile   ("sfence": : : "memory");
#line 1628
    goto ldv_66167;
  } else {

  }
#line 1631
  switch ((int )pkt->entry_type) {
  case 3: 
#line 1633
  qla2x00_status_entry(vha, rsp, (void *)pkt);
#line 1634
  goto ldv_66169;
  case 33: 
#line 1636
  handle_cnt = (uint16_t )((sts21_entry_t *)pkt)->handle_count;
#line 1637
  cnt = 0U;
#line 1637
  goto ldv_66172;
  ldv_66171: 
#line 1638
  qla2x00_process_completed_request(vha, rsp->req, ((sts21_entry_t *)pkt)->handle[(int )cnt]);
#line 1637
  cnt = (uint16_t )((int )cnt + 1);
  ldv_66172: ;
#line 1637
  if ((int )cnt < (int )handle_cnt) {
#line 1639
    goto ldv_66171;
  } else {

  }

#line 1641
  goto ldv_66169;
  case 34: 
#line 1643
  handle_cnt = (uint16_t )((sts22_entry_t *)pkt)->handle_count;
#line 1644
  cnt = 0U;
#line 1644
  goto ldv_66176;
  ldv_66175: 
#line 1645
  qla2x00_process_completed_request(vha, rsp->req, (uint32_t )((sts22_entry_t *)pkt)->handle[(int )cnt]);
#line 1644
  cnt = (uint16_t )((int )cnt + 1);
  ldv_66176: ;
#line 1644
  if ((int )cnt < (int )handle_cnt) {
#line 1646
    goto ldv_66175;
  } else {

  }

#line 1648
  goto ldv_66169;
  case 16: 
#line 1650
  qla2x00_status_cont_entry(rsp, (sts_cont_entry_t *)pkt);
#line 1651
  goto ldv_66169;
  case 57: 
#line 1653
  qla2x00_mbx_iocb_entry(vha, rsp->req, (struct mbx_entry *)pkt);
#line 1655
  goto ldv_66169;
  case 41: 
#line 1657
  qla2x00_ct_entry(vha, rsp->req, pkt, 41);
#line 1658
  goto ldv_66169;
  default: 
#line 1661
  ql_log(1U, vha, 20554, "Received unknown response pkt type %x entry status=%x.\n",
         (int )pkt->entry_type, (int )pkt->entry_status);
#line 1665
  goto ldv_66169;
  }
  ldv_66169: 
#line 1667
  ((response_t *)pkt)->signature = 3735936685U;
#line 1668
  __asm__  volatile   ("sfence": : : "memory");
  ldv_66167: ;
#line 1613
  if ((rsp->ring_ptr)->signature != 3735936685U) {
#line 1615
    goto ldv_66182;
  } else {

  }
#line 1672
  writew((int )rsp->ring_index, (void volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox5 : & reg->u.isp2300.rsp_q_out));
#line 1673
  return;
}
}
#line 1676 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
__inline static void qla2x00_handle_sense(srb_t *sp , uint8_t *sense_data , uint32_t par_sense_len ,
                                          uint32_t sense_len , struct rsp_que *rsp ,
                                          int res ) 
{ 
  struct scsi_qla_host *vha ;
  struct scsi_cmnd *cp ;
  uint32_t track_sense_len ;

  {
#line 1679
  vha = (sp->fcport)->vha;
#line 1680
  cp = sp->u.scmd.cmd;
#line 1683
  if (sense_len > 95U) {
#line 1684
    sense_len = 96U;
  } else {

  }
#line 1686
  sp->u.scmd.request_sense_length = sense_len;
#line 1687
  sp->u.scmd.request_sense_ptr = cp->sense_buffer;
#line 1688
  track_sense_len = sense_len;
#line 1690
  if (sense_len > par_sense_len) {
#line 1691
    sense_len = par_sense_len;
  } else {

  }
#line 1693
  memcpy((void *)cp->sense_buffer, (void const   *)sense_data, (size_t )sense_len);
#line 1695
  sp->u.scmd.request_sense_ptr = cp->sense_buffer + (unsigned long )sense_len;
#line 1696
  track_sense_len = track_sense_len - sense_len;
#line 1697
  sp->u.scmd.request_sense_length = track_sense_len;
#line 1699
  if (track_sense_len != 0U) {
#line 1700
    rsp->status_srb = sp;
#line 1701
    cp->result = res;
  } else {

  }
#line 1704
  if (sense_len != 0U) {
#line 1705
    ql_dbg(134348800U, vha, 12316, "Check condition Sense data, nexus%ld:%d:%llu cmd=%p.\n",
           ((sp->fcport)->vha)->host_no, (cp->device)->id, (cp->device)->lun, cp);
#line 1709
    ql_dump_buffer(134348800U, vha, 12331, cp->sense_buffer, sense_len);
  } else {

  }
#line 1712
  return;
}
}
#line 1727 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
__inline static int qla2x00_handle_dif_error(srb_t *sp , struct sts_entry_24xx *sts24 ) 
{ 
  struct scsi_qla_host *vha ;
  struct scsi_cmnd *cmd ;
  uint8_t *ap ;
  uint8_t *ep ;
  uint32_t e_ref_tag ;
  uint32_t a_ref_tag ;
  uint16_t e_app_tag ;
  uint16_t a_app_tag ;
  uint16_t e_guard ;
  uint16_t a_guard ;
  sector_t tmp ;
  uint32_t blocks_done ;
  uint32_t resid ;
  sector_t lba_s ;
  sector_t tmp___0 ;
  unsigned int tmp___1 ;
  uint32_t i ;
  uint32_t j ;
  uint32_t k ;
  uint32_t num_ent ;
  struct scatterlist *sg ;
  struct sd_dif_tuple *spt ;
  unsigned int tmp___2 ;
  struct page *tmp___3 ;
  void *tmp___4 ;
  unsigned char tmp___5 ;
  unsigned int tmp___6 ;
  unsigned char tmp___7 ;

  {
#line 1729
  vha = (sp->fcport)->vha;
#line 1730
  cmd = sp->u.scmd.cmd;
#line 1731
  ap = (uint8_t *)(& sts24->data) + 12UL;
#line 1732
  ep = (uint8_t *)(& sts24->data) + 20UL;
#line 1741
  a_guard = *((uint16_t *)ap + 2U);
#line 1742
  a_app_tag = *((uint16_t *)ap);
#line 1743
  a_ref_tag = *((uint32_t *)ap + 4U);
#line 1744
  e_guard = *((uint16_t *)ep + 2U);
#line 1745
  e_app_tag = *((uint16_t *)ep);
#line 1746
  e_ref_tag = *((uint32_t *)ep + 4U);
#line 1748
  ql_dbg(134217728U, vha, 12323, "iocb(s) %p Returned STATUS.\n", sts24);
#line 1751
  tmp = scsi_get_lba(cmd);
#line 1751
  ql_dbg(134217728U, vha, 12324, "DIF OLD_ERROR in cmd 0x%x lba 0x%llx act ref tag=0x%x, exp ref_tag=0x%x, act app tag=0x%x, exp app tag=0x%x, act guard=0x%x, exp guard=0x%x.\n",
         (int )*(cmd->cmnd), (unsigned long long )tmp, a_ref_tag, e_ref_tag, (int )a_app_tag,
         (int )e_app_tag, (int )a_guard, (int )e_guard);
#line 1763
  if ((unsigned int )a_app_tag == 65535U) {
#line 1763
    tmp___7 = scsi_get_prot_type(cmd);
#line 1763
    if ((unsigned int )tmp___7 != 3U || a_ref_tag == 4294967295U) {
#line 1767
      tmp___0 = scsi_get_lba(cmd);
#line 1767
      lba_s = tmp___0;
#line 1770
      blocks_done = (e_ref_tag - (uint32_t )lba_s) + 1U;
#line 1772
      tmp___1 = scsi_bufflen(cmd);
#line 1772
      resid = tmp___1 - (cmd->device)->sector_size * blocks_done;
#line 1775
      scsi_set_resid(cmd, (int )resid);
#line 1776
      cmd->result = 0;
#line 1779
      tmp___6 = scsi_prot_sg_count(cmd);
#line 1779
      if (tmp___6 != 0U) {
#line 1780
        j = 0U;
#line 1780
        k = 0U;
#line 1785
        i = 0U;
#line 1785
        sg = scsi_prot_sglist(cmd);
#line 1785
        goto ldv_66225;
        ldv_66224: 
#line 1787
        num_ent = sg->dma_length / 8U;
#line 1788
        if (k + num_ent < blocks_done) {
#line 1789
          k = k + num_ent;
#line 1790
          goto ldv_66222;
        } else {

        }
#line 1792
        j = (blocks_done - k) - 1U;
#line 1793
        k = blocks_done;
#line 1794
        goto ldv_66223;
        ldv_66222: 
#line 1785
        i = i + 1U;
#line 1785
        sg = sg_next(sg);
        ldv_66225: 
#line 1785
        tmp___2 = scsi_prot_sg_count(cmd);
#line 1785
        if (tmp___2 > i) {
#line 1787
          goto ldv_66224;
        } else {

        }
        ldv_66223: ;
#line 1797
        if (k != blocks_done) {
#line 1798
          ql_log(1U, vha, 12335, "unexpected tag values tag:lba=%x:%llx)\n", e_ref_tag,
                 (unsigned long long )lba_s);
#line 1801
          return (1);
        } else {

        }
#line 1804
        tmp___3 = sg_page___0(sg);
#line 1804
        tmp___4 = lowmem_page_address((struct page  const  *)tmp___3);
#line 1804
        spt = (struct sd_dif_tuple *)tmp___4 + (unsigned long )sg->offset;
#line 1805
        spt = spt + (unsigned long )j;
#line 1807
        spt->app_tag = 65535U;
#line 1808
        tmp___5 = scsi_get_prot_type(cmd);
#line 1808
        if ((unsigned int )tmp___5 == 3U) {
#line 1809
          spt->ref_tag = 4294967295U;
        } else {

        }
      } else {

      }
#line 1812
      return (0);
    } else {

    }
  } else {

  }
#line 1816
  if ((int )e_guard != (int )a_guard) {
#line 1817
    scsi_build_sense_buffer(1, cmd->sense_buffer, 5, 16, 1);
#line 1819
    set_driver_byte(cmd, 8);
#line 1820
    set_host_byte(cmd, 5);
#line 1821
    cmd->result = cmd->result | 4;
#line 1822
    return (1);
  } else {

  }
#line 1826
  if (e_ref_tag != a_ref_tag) {
#line 1827
    scsi_build_sense_buffer(1, cmd->sense_buffer, 5, 16, 3);
#line 1829
    set_driver_byte(cmd, 8);
#line 1830
    set_host_byte(cmd, 5);
#line 1831
    cmd->result = cmd->result | 4;
#line 1832
    return (1);
  } else {

  }
#line 1836
  if ((int )e_app_tag != (int )a_app_tag) {
#line 1837
    scsi_build_sense_buffer(1, cmd->sense_buffer, 5, 16, 2);
#line 1839
    set_driver_byte(cmd, 8);
#line 1840
    set_host_byte(cmd, 5);
#line 1841
    cmd->result = cmd->result | 4;
#line 1842
    return (1);
  } else {

  }
#line 1845
  return (1);
}
}
#line 1849 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
static void qla25xx_process_bidir_status_iocb(scsi_qla_host_t *vha , void *pkt , struct req_que *req ,
                                              uint32_t index ) 
{ 
  struct qla_hw_data *ha ;
  srb_t *sp ;
  uint16_t comp_status ;
  uint16_t scsi_status ;
  uint16_t thread_id ;
  uint32_t rval ;
  struct fc_bsg_job *bsg_job ;
  sts_entry_t *sts ;
  struct sts_entry_24xx *sts24 ;

  {
#line 1852
  ha = vha->hw;
#line 1857
  rval = 0U;
#line 1858
  bsg_job = (struct fc_bsg_job *)0;
#line 1861
  sts = (sts_entry_t *)pkt;
#line 1862
  sts24 = (struct sts_entry_24xx *)pkt;
#line 1865
  if ((uint32_t )req->num_outstanding_cmds <= index) {
#line 1866
    ql_log(1U, vha, 28847, "Invalid SCSI completion handle 0x%x.\n", index);
#line 1868
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1869
    return;
  } else {

  }
#line 1872
  sp = *(req->outstanding_cmds + (unsigned long )index);
#line 1873
  if ((unsigned long )sp != (unsigned long )((srb_t *)0)) {
#line 1875
    *(req->outstanding_cmds + (unsigned long )index) = (srb_t *)0;
#line 1876
    bsg_job = sp->u.bsg_job;
  } else {
#line 1878
    ql_log(1U, vha, 28848, "Req:%d: Invalid ISP SCSI completion handle(0x%x)\n", (int )req->id,
           index);
#line 1882
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1883
    return;
  }
#line 1886
  if ((ha->device_type & 134217728U) != 0U) {
#line 1887
    comp_status = sts24->comp_status;
#line 1888
    scsi_status = (unsigned int )sts24->scsi_status & 4095U;
  } else {
#line 1890
    comp_status = sts->comp_status;
#line 1891
    scsi_status = (unsigned int )sts->scsi_status & 4095U;
  }
#line 1894
  thread_id = (uint16_t )(bsg_job->request)->rqst_data.h_vendor.vendor_cmd[1];
#line 1895
  switch ((int )comp_status) {
  case 0: ;
#line 1897
  if ((unsigned int )scsi_status == 0U) {
#line 1898
    (bsg_job->reply)->reply_payload_rcv_len = bsg_job->reply_payload.payload_len;
#line 1900
    vha->qla_stats.input_bytes = vha->qla_stats.input_bytes + (uint64_t )(bsg_job->reply)->reply_payload_rcv_len;
#line 1902
    vha->qla_stats.input_requests = vha->qla_stats.input_requests + 1ULL;
#line 1903
    rval = 0U;
  } else {

  }
#line 1905
  goto done;
  case 7: 
#line 1908
  ql_dbg(8388608U, vha, 28849, "Command completed with date overrun thread_id=%d\n",
         (int )thread_id);
#line 1911
  rval = 7U;
#line 1912
  goto ldv_66244;
  case 21: 
#line 1915
  ql_dbg(8388608U, vha, 28850, "Command completed with date underrun thread_id=%d\n",
         (int )thread_id);
#line 1918
  rval = 8U;
#line 1919
  goto ldv_66244;
  case 1792: 
#line 1921
  ql_dbg(8388608U, vha, 28851, "Command completed with read data overrun thread_id=%d\n",
         (int )thread_id);
#line 1924
  rval = 7U;
#line 1925
  goto ldv_66244;
  case 1799: 
#line 1928
  ql_dbg(8388608U, vha, 28852, "Command completed with read and write data overrun thread_id=%d\n",
         (int )thread_id);
#line 1931
  rval = 7U;
#line 1932
  goto ldv_66244;
  case 1813: 
#line 1935
  ql_dbg(8388608U, vha, 28853, "Command completed with read data over and write data underrun thread_id=%d\n",
         (int )thread_id);
#line 1938
  rval = 7U;
#line 1939
  goto ldv_66244;
  case 5376: 
#line 1942
  ql_dbg(8388608U, vha, 28854, "Command completed with read data data underrun thread_id=%d\n",
         (int )thread_id);
#line 1945
  rval = 8U;
#line 1946
  goto ldv_66244;
  case 5383: 
#line 1949
  ql_dbg(8388608U, vha, 28855, "Command completed with read data under and write data overrun thread_id=%d\n",
         (int )thread_id);
#line 1952
  rval = 8U;
#line 1953
  goto ldv_66244;
  case 5397: 
#line 1956
  ql_dbg(8388608U, vha, 28856, "Command completed with read and write data underrun thread_id=%d\n",
         (int )thread_id);
#line 1959
  rval = 8U;
#line 1960
  goto ldv_66244;
  case 512: 
#line 1963
  ql_dbg(8388608U, vha, 28857, "Command completed with data DMA error thread_id=%d\n",
         (int )thread_id);
#line 1966
  rval = 29U;
#line 1967
  goto ldv_66244;
  case 6: 
#line 1970
  ql_dbg(8388608U, vha, 28858, "Command completed with timeout thread_id=%d\n", (int )thread_id);
#line 1973
  rval = 30U;
#line 1974
  goto ldv_66244;
  default: 
#line 1976
  ql_dbg(8388608U, vha, 28859, "Command completed with completion status=0x%x thread_id=%d\n",
         (int )comp_status, (int )thread_id);
#line 1979
  rval = 1U;
#line 1980
  goto ldv_66244;
  }
  ldv_66244: 
#line 1982
  (bsg_job->reply)->reply_payload_rcv_len = 0U;
  done: 
#line 1986
  (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = rval;
#line 1987
  bsg_job->reply_len = 16U;
#line 1990
  (*(sp->done))((void *)vha, (void *)sp, 0);
#line 1991
  return;
}
}
#line 2000 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
static void qla2x00_status_entry(scsi_qla_host_t *vha , struct rsp_que *rsp , void *pkt ) 
{ 
  srb_t *sp ;
  fc_port_t *fcport ;
  struct scsi_cmnd *cp ;
  sts_entry_t *sts ;
  struct sts_entry_24xx *sts24 ;
  uint16_t comp_status ;
  uint16_t scsi_status ;
  uint16_t ox_id ;
  uint8_t lscsi_status ;
  int32_t resid ;
  uint32_t sense_len ;
  uint32_t par_sense_len ;
  uint32_t rsp_info_len ;
  uint32_t resid_len ;
  uint32_t fw_resid_len ;
  uint8_t *rsp_info ;
  uint8_t *sense_data ;
  struct qla_hw_data *ha ;
  uint32_t handle ;
  uint16_t que ;
  struct req_que *req ;
  int logit ;
  int res ;
  uint16_t state_flags ;
  uint16_t retry_delay ;
  unsigned long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned int tmp___10 ;

  {
#line 2015
  ha = vha->hw;
#line 2019
  logit = 1;
#line 2020
  res = 0;
#line 2021
  state_flags = 0U;
#line 2022
  retry_delay = 0U;
#line 2024
  sts = (sts_entry_t *)pkt;
#line 2025
  sts24 = (struct sts_entry_24xx *)pkt;
#line 2026
  if ((ha->device_type & 134217728U) != 0U) {
#line 2027
    comp_status = sts24->comp_status;
#line 2028
    scsi_status = (unsigned int )sts24->scsi_status & 4095U;
#line 2029
    state_flags = sts24->state_flags;
  } else {
#line 2031
    comp_status = sts->comp_status;
#line 2032
    scsi_status = (unsigned int )sts->scsi_status & 4095U;
  }
#line 2034
  handle = (unsigned int )((unsigned short )sts->handle);
#line 2035
  que = (unsigned short )(sts->handle >> 16);
#line 2036
  req = *(ha->req_q_map + (unsigned long )que);
#line 2039
  if ((unsigned long )req == (unsigned long )((struct req_que *)0)) {
#line 2041
    ql_dbg(134217728U, vha, 12377, "Invalid status handle (0x%x): Bad req pointer. req=%p, que=%u.\n",
           sts->handle, req, (int )que);
#line 2044
    return;
  } else {
#line 2039
    tmp = find_first_zero_bit((unsigned long const   *)(& ha->req_qid_map), (unsigned long )ha->max_req_queues);
#line 2039
    if ((unsigned long )que >= tmp) {
#line 2041
      ql_dbg(134217728U, vha, 12377, "Invalid status handle (0x%x): Bad req pointer. req=%p, que=%u.\n",
             sts->handle, req, (int )que);
#line 2044
      return;
    } else {

    }
  }
#line 2048
  if ((uint32_t )req->num_outstanding_cmds > handle) {
#line 2049
    sp = *(req->outstanding_cmds + (unsigned long )handle);
  } else {
#line 2051
    sp = (srb_t *)0;
  }
#line 2053
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 2054
    ql_dbg(134217728U, vha, 12311, "Invalid status handle (0x%x).\n", sts->handle);
#line 2057
    tmp___0 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 2057
    if (tmp___0 == 0) {
#line 2058
      if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 2059
        set_bit(18L, (unsigned long volatile   *)(& vha->dpc_flags));
      } else {
#line 2061
        set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
      }
#line 2062
      qla2xxx_wake_dpc(vha);
    } else {

    }
#line 2064
    return;
  } else {

  }
#line 2067
  tmp___1 = ldv__builtin_expect((long )(((int )state_flags & 2) != 0 && (unsigned int )sp->type == 9U),
                             0L);
#line 2067
  if (tmp___1 != 0L) {
#line 2068
    qla25xx_process_bidir_status_iocb(vha, pkt, req, handle);
#line 2069
    return;
  } else {

  }
#line 2073
  if ((unsigned int )sp->type == 7U) {
#line 2074
    qla24xx_tm_iocb_entry(vha, req, pkt);
#line 2075
    return;
  } else {

  }
#line 2079
  if ((unsigned int )comp_status == 0U && (unsigned int )scsi_status == 0U) {
#line 2080
    qla2x00_process_completed_request(vha, req, handle);
#line 2082
    return;
  } else {

  }
#line 2085
  *(req->outstanding_cmds + (unsigned long )handle) = (srb_t *)0;
#line 2086
  cp = sp->u.scmd.cmd;
#line 2087
  if ((unsigned long )cp == (unsigned long )((struct scsi_cmnd *)0)) {
#line 2088
    ql_dbg(134217728U, vha, 12312, "Command already returned (0x%x/%p).\n", sts->handle,
           sp);
#line 2092
    return;
  } else {

  }
#line 2095
  lscsi_status = (unsigned int )((uint8_t )scsi_status) & 254U;
#line 2097
  fcport = sp->fcport;
#line 2099
  ox_id = 0U;
#line 2100
  fw_resid_len = 0U;
#line 2100
  resid_len = fw_resid_len;
#line 2100
  rsp_info_len = resid_len;
#line 2100
  par_sense_len = rsp_info_len;
#line 2100
  sense_len = par_sense_len;
#line 2102
  if ((ha->device_type & 134217728U) != 0U) {
#line 2103
    if (((int )scsi_status & 512) != 0) {
#line 2104
      sense_len = sts24->sense_len;
    } else {

    }
#line 2105
    if (((int )scsi_status & 256) != 0) {
#line 2106
      rsp_info_len = sts24->rsp_data_len;
    } else {

    }
#line 2107
    if (((int )scsi_status & 3072) != 0) {
#line 2108
      resid_len = sts24->rsp_residual_count;
    } else {

    }
#line 2109
    if ((unsigned int )comp_status == 21U) {
#line 2110
      fw_resid_len = sts24->residual_len;
    } else {

    }
#line 2111
    rsp_info = (uint8_t *)(& sts24->data);
#line 2112
    sense_data = (uint8_t *)(& sts24->data);
#line 2113
    host_to_fcp_swap___1((uint8_t *)(& sts24->data), 28U);
#line 2114
    ox_id = sts24->ox_id;
#line 2115
    par_sense_len = 28U;
#line 2117
    if ((unsigned int )sts24->retry_delay != 0U && (unsigned int )sts24->retry_delay <= 65520U) {
#line 2118
      retry_delay = sts24->retry_delay;
    } else {

    }
  } else {
#line 2120
    if (((int )scsi_status & 512) != 0) {
#line 2121
      sense_len = (uint32_t )sts->req_sense_length;
    } else {

    }
#line 2122
    if (((int )scsi_status & 256) != 0) {
#line 2123
      rsp_info_len = (uint32_t )sts->rsp_info_len;
    } else {

    }
#line 2124
    resid_len = sts->residual_length;
#line 2125
    rsp_info = (uint8_t *)(& sts->rsp_info);
#line 2126
    sense_data = (uint8_t *)(& sts->req_sense_data);
#line 2127
    par_sense_len = 32U;
  }
#line 2131
  if (((int )scsi_status & 256) != 0) {
#line 2133
    if ((ha->device_type & 134217728U) != 0U) {
#line 2134
      sense_data = sense_data + (unsigned long )rsp_info_len;
#line 2135
      par_sense_len = par_sense_len - rsp_info_len;
    } else {

    }
#line 2137
    if (rsp_info_len > 3U && (unsigned int )*(rsp_info + 3UL) != 0U) {
#line 2138
      ql_dbg(134217728U, fcport->vha, 12313, "FCP I/O protocol failure (0x%x/0x%x).\n",
             rsp_info_len, (int )*(rsp_info + 3UL));
#line 2142
      res = 131072;
#line 2143
      goto out;
    } else {

    }
  } else {

  }
#line 2148
  if (((ha->device_type & 134217728U) != 0U && (unsigned int )comp_status == 0U) && ((int )scsi_status & 1024) != 0) {
#line 2150
    comp_status = 7U;
  } else {

  }
#line 2156
  if ((unsigned int )lscsi_status == 40U || (unsigned int )lscsi_status == 8U) {
#line 2158
    qla2x00_set_retry_delay_timestamp(fcport, (int )retry_delay);
  } else {

  }
#line 2163
  switch ((int )comp_status) {
  case 0: ;
  case 28: ;
#line 2166
  if ((unsigned int )scsi_status == 0U) {
#line 2167
    res = 0;
#line 2168
    goto ldv_66288;
  } else {

  }
#line 2170
  if (((int )scsi_status & 3072) != 0) {
#line 2171
    resid = (int32_t )resid_len;
#line 2172
    scsi_set_resid(cp, resid);
#line 2174
    if ((unsigned int )lscsi_status == 0U) {
#line 2174
      tmp___3 = scsi_bufflen(cp);
#line 2174
      if (tmp___3 - (unsigned int )resid < cp->underflow) {
#line 2177
        tmp___2 = scsi_bufflen(cp);
#line 2177
        ql_dbg(134217728U, fcport->vha, 12314, "Mid-layer underflow detected (0x%x of 0x%x bytes).\n",
               resid, tmp___2);
#line 2182
        res = 458752;
#line 2183
        goto ldv_66288;
      } else {

      }
    } else {

    }
  } else {

  }
#line 2186
  res = (int )lscsi_status;
#line 2188
  if ((unsigned int )lscsi_status == 40U) {
#line 2189
    ql_dbg(134217728U, fcport->vha, 12315, "QUEUE FULL detected.\n");
#line 2191
    goto ldv_66288;
  } else {

  }
#line 2193
  logit = 0;
#line 2194
  if ((unsigned int )lscsi_status != 2U) {
#line 2195
    goto ldv_66288;
  } else {

  }
#line 2197
  memset((void *)cp->sense_buffer, 0, 96UL);
#line 2198
  if (((int )scsi_status & 512) == 0) {
#line 2199
    goto ldv_66288;
  } else {

  }
#line 2201
  qla2x00_handle_sense(sp, sense_data, par_sense_len, sense_len, rsp, res);
#line 2203
  goto ldv_66288;
  case 21: 
#line 2207
  resid = (int32_t )((ha->device_type & 134217728U) != 0U ? fw_resid_len : resid_len);
#line 2208
  scsi_set_resid(cp, resid);
#line 2209
  if (((int )scsi_status & 2048) != 0) {
#line 2210
    if ((ha->device_type & 134217728U) != 0U && fw_resid_len != resid_len) {
#line 2211
      tmp___4 = scsi_bufflen(cp);
#line 2211
      ql_dbg(134217728U, fcport->vha, 12317, "Dropped frame(s) detected (0x%x of 0x%x bytes).\n",
             resid, tmp___4);
#line 2216
      res = (int )lscsi_status | 458752;
#line 2217
      goto check_scsi_status;
    } else {

    }
#line 2220
    if ((unsigned int )lscsi_status == 0U) {
#line 2220
      tmp___6 = scsi_bufflen(cp);
#line 2220
      if (tmp___6 - (unsigned int )resid < cp->underflow) {
#line 2223
        tmp___5 = scsi_bufflen(cp);
#line 2223
        ql_dbg(134217728U, fcport->vha, 12318, "Mid-layer underflow detected (0x%x of 0x%x bytes).\n",
               resid, tmp___5);
#line 2228
        res = 458752;
#line 2229
        goto ldv_66288;
      } else {

      }
    } else {

    }
  } else
#line 2231
  if ((unsigned int )lscsi_status != 40U && (unsigned int )lscsi_status != 8U) {
#line 2238
    tmp___7 = scsi_bufflen(cp);
#line 2238
    ql_dbg(134217728U, fcport->vha, 12319, "Dropped frame(s) detected (0x%x of 0x%x bytes).\n",
           resid, tmp___7);
#line 2243
    res = (int )lscsi_status | 458752;
#line 2244
    goto check_scsi_status;
  } else {
#line 2246
    ql_dbg(134217728U, fcport->vha, 12336, "scsi_status: 0x%x, lscsi_status: 0x%x\n",
           (int )scsi_status, (int )lscsi_status);
  }
#line 2251
  res = (int )lscsi_status;
#line 2252
  logit = 0;
  check_scsi_status: ;
#line 2259
  if ((unsigned int )lscsi_status != 0U) {
#line 2260
    if ((unsigned int )lscsi_status == 40U) {
#line 2261
      ql_dbg(134217728U, fcport->vha, 12320, "QUEUE FULL detected.\n");
#line 2263
      logit = 1;
#line 2264
      goto ldv_66288;
    } else {

    }
#line 2266
    if ((unsigned int )lscsi_status != 2U) {
#line 2267
      goto ldv_66288;
    } else {

    }
#line 2269
    memset((void *)cp->sense_buffer, 0, 96UL);
#line 2270
    if (((int )scsi_status & 512) == 0) {
#line 2271
      goto ldv_66288;
    } else {

    }
#line 2273
    qla2x00_handle_sense(sp, sense_data, par_sense_len, sense_len, rsp, res);
  } else {

  }
#line 2276
  goto ldv_66288;
  case 41: ;
  case 42: ;
  case 43: ;
  case 1: ;
  case 40: ;
  case 6: ;
  case 4: 
#line 2291
  res = 917504;
#line 2293
  if ((unsigned int )comp_status == 6U) {
#line 2294
    if ((ha->device_type & 134217728U) != 0U) {
#line 2295
      goto ldv_66288;
    } else
#line 2296
    if (((int )sts->status_flags & 8192) == 0) {
#line 2298
      goto ldv_66288;
    } else {

    }
  } else {

  }
#line 2301
  tmp___8 = atomic_read((atomic_t const   *)(& fcport->state));
#line 2301
  ql_dbg(134217728U, fcport->vha, 12321, "Port to be marked lost on fcport=%02x%02x%02x, current port state= %s.\n",
         (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa,
         port_state_str___1[tmp___8]);
#line 2307
  tmp___9 = atomic_read((atomic_t const   *)(& fcport->state));
#line 2307
  if (tmp___9 == 4) {
#line 2308
    qla2x00_mark_device_lost(fcport->vha, fcport, 1, 1);
  } else {

  }
#line 2309
  goto ldv_66288;
  case 5: 
#line 2312
  res = 524288;
#line 2313
  goto ldv_66288;
  case 12: 
#line 2316
  logit = qla2x00_handle_dif_error(sp, sts24);
#line 2317
  res = cp->result;
#line 2318
  goto ldv_66288;
  case 3: 
#line 2321
  res = 458752;
#line 2323
  if (((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U) || ((((int )ha->fw_attributes_h << 16) | (int )ha->fw_attributes) & 4194304) == 0) {
#line 2324
    goto ldv_66288;
  } else {

  }
#line 2326
  if (((int )state_flags & 16) != 0) {
#line 2327
    scmd_printk("\f", (struct scsi_cmnd  const  *)cp, "Unsupported device \'%s\' found.\n",
                (cp->device)->vendor);
  } else {

  }
#line 2330
  goto ldv_66288;
  default: 
#line 2333
  res = 458752;
#line 2334
  goto ldv_66288;
  }
  ldv_66288: ;
  out: ;
#line 2338
  if (logit != 0) {
#line 2339
    tmp___10 = scsi_bufflen(cp);
#line 2339
    ql_dbg(134217728U, fcport->vha, 12322, "FCP command status: 0x%x-0x%x (0x%x) nexus=%ld:%d:%llu portid=%02x%02x%02x oxid=0x%x cdb=%10phN len=0x%x rsp_info=0x%x resid=0x%x fw_resid=0x%x.\n",
           (int )comp_status, (int )scsi_status, res, vha->host_no, (cp->device)->id,
           (cp->device)->lun, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
           (int )fcport->d_id.b.al_pa, (int )ox_id, cp->cmnd, tmp___10, rsp_info_len,
           resid_len, fw_resid_len);
  } else {

  }
#line 2349
  if ((unsigned long )rsp->status_srb == (unsigned long )((srb_t *)0)) {
#line 2350
    (*(sp->done))((void *)ha, (void *)sp, res);
  } else {

  }
#line 2351
  return;
}
}
#line 2361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
static void qla2x00_status_cont_entry(struct rsp_que *rsp , sts_cont_entry_t *pkt ) 
{ 
  uint8_t sense_sz ;
  struct qla_hw_data *ha ;
  struct scsi_qla_host *vha ;
  void *tmp ;
  srb_t *sp ;
  struct scsi_cmnd *cp ;
  uint32_t sense_len ;
  uint8_t *sense_ptr ;

  {
#line 2363
  sense_sz = 0U;
#line 2364
  ha = rsp->hw;
#line 2365
  tmp = pci_get_drvdata(ha->pdev);
#line 2365
  vha = (struct scsi_qla_host *)tmp;
#line 2366
  sp = rsp->status_srb;
#line 2371
  if ((unsigned long )sp == (unsigned long )((srb_t *)0) || sp->u.scmd.request_sense_length == 0U) {
#line 2372
    return;
  } else {

  }
#line 2374
  sense_len = sp->u.scmd.request_sense_length;
#line 2375
  sense_ptr = sp->u.scmd.request_sense_ptr;
#line 2377
  cp = sp->u.scmd.cmd;
#line 2378
  if ((unsigned long )cp == (unsigned long )((struct scsi_cmnd *)0)) {
#line 2379
    ql_log(1U, vha, 12325, "cmd is NULL: already returned to OS (sp=%p).\n", sp);
#line 2382
    rsp->status_srb = (srb_t *)0;
#line 2383
    return;
  } else {

  }
#line 2386
  if (sense_len > 60U) {
#line 2387
    sense_sz = 60U;
  } else {
#line 2389
    sense_sz = (uint8_t )sense_len;
  }
#line 2392
  if ((ha->device_type & 134217728U) != 0U) {
#line 2393
    host_to_fcp_swap___1((uint8_t *)(& pkt->data), 60U);
  } else {

  }
#line 2394
  memcpy((void *)sense_ptr, (void const   *)(& pkt->data), (size_t )sense_sz);
#line 2395
  ql_dump_buffer(134348800U, vha, 12332, sense_ptr, (uint32_t )sense_sz);
#line 2398
  sense_len = sense_len - (uint32_t )sense_sz;
#line 2399
  sense_ptr = sense_ptr + (unsigned long )sense_sz;
#line 2401
  sp->u.scmd.request_sense_ptr = sense_ptr;
#line 2402
  sp->u.scmd.request_sense_length = sense_len;
#line 2405
  if (sense_len == 0U) {
#line 2406
    rsp->status_srb = (srb_t *)0;
#line 2407
    (*(sp->done))((void *)ha, (void *)sp, cp->result);
  } else {

  }
#line 2409
  return;
}
}
#line 2417 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
static void qla2x00_error_entry(scsi_qla_host_t *vha , struct rsp_que *rsp , sts_entry_t *pkt ) 
{ 
  srb_t *sp ;
  struct qla_hw_data *ha ;
  char func[11U] ;
  uint16_t que ;
  struct req_que *req ;
  int res ;

  {
#line 2420
  ha = vha->hw;
#line 2421
  func[0] = 'E';
#line 2421
  func[1] = 'R';
#line 2421
  func[2] = 'R';
#line 2421
  func[3] = 'O';
#line 2421
  func[4] = 'R';
#line 2421
  func[5] = '-';
#line 2421
  func[6] = 'I';
#line 2421
  func[7] = 'O';
#line 2421
  func[8] = 'C';
#line 2421
  func[9] = 'B';
#line 2421
  func[10] = '\000';
#line 2422
  que = (unsigned short )(pkt->handle >> 16);
#line 2423
  req = (struct req_que *)0;
#line 2424
  res = 458752;
#line 2426
  ql_dbg(33554432U, vha, 20522, "type of error status in response: 0x%x\n", (int )pkt->entry_status);
#line 2429
  if ((int )((unsigned short )ha->max_req_queues) <= (int )que || (unsigned long )*(ha->req_q_map + (unsigned long )que) == (unsigned long )((struct req_que *)0)) {
#line 2430
    goto fatal;
  } else {

  }
#line 2432
  req = *(ha->req_q_map + (unsigned long )que);
#line 2434
  if (((int )pkt->entry_status & 2) != 0) {
#line 2435
    res = 131072;
  } else {

  }
#line 2437
  sp = qla2x00_get_sp_from_handle(vha, (char const   *)(& func), req, (void *)pkt);
#line 2438
  if ((unsigned long )sp != (unsigned long )((srb_t *)0)) {
#line 2439
    (*(sp->done))((void *)ha, (void *)sp, res);
#line 2440
    return;
  } else {

  }
  fatal: 
#line 2443
  ql_log(1U, vha, 20528, "Error entry - invalid handle/queue.\n");
#line 2446
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 2447
    set_bit(18L, (unsigned long volatile   *)(& vha->dpc_flags));
  } else {
#line 2449
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
  }
#line 2450
  qla2xxx_wake_dpc(vha);
#line 2451
  return;
}
}
#line 2459 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
static void qla24xx_mbx_completion(scsi_qla_host_t *vha , uint16_t mb0 ) 
{ 
  uint16_t cnt ;
  uint32_t mboxes ;
  uint16_t *wptr ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;

  {
#line 2464
  ha = vha->hw;
#line 2465
  reg = & (ha->iobase)->isp24;
#line 2468
  mboxes = (uint32_t )((1 << (int )ha->mbx_count) + -1);
#line 2469
  if ((unsigned long )ha->mcp == (unsigned long )((mbx_cmd_t *)0)) {
#line 2470
    ql_dbg(33554432U, vha, 20558, "MBX pointer OLD_ERROR.\n");
  } else {
#line 2472
    mboxes = (ha->mcp)->in_mb;
  }
#line 2475
  ha->flags.mbox_int = 1U;
#line 2476
  ha->mailbox_out[0] = mb0;
#line 2477
  mboxes = mboxes >> 1;
#line 2478
  wptr = & reg->mailbox1;
#line 2480
  cnt = 1U;
#line 2480
  goto ldv_66335;
  ldv_66334: ;
#line 2481
  if ((int )mboxes & 1) {
#line 2482
    ha->mailbox_out[(int )cnt] = readw((void const volatile   *)wptr);
  } else {

  }
#line 2484
  mboxes = mboxes >> 1;
#line 2485
  wptr = wptr + 1;
#line 2480
  cnt = (uint16_t )((int )cnt + 1);
  ldv_66335: ;
#line 2480
  if ((int )((unsigned short )ha->mbx_count) > (int )cnt) {
#line 2482
    goto ldv_66334;
  } else {

  }

#line 2487
  return;
}
}
#line 2490 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
static void qla24xx_abort_iocb_entry(scsi_qla_host_t *vha , struct req_que *req ,
                                     struct abort_entry_24xx *pkt ) 
{ 
  char func[9U] ;
  srb_t *sp ;
  struct srb_iocb *abt ;

  {
#line 2493
  func[0] = 'A';
#line 2493
  func[1] = 'B';
#line 2493
  func[2] = 'T';
#line 2493
  func[3] = '_';
#line 2493
  func[4] = 'I';
#line 2493
  func[5] = 'O';
#line 2493
  func[6] = 'C';
#line 2493
  func[7] = 'B';
#line 2493
  func[8] = '\000';
#line 2497
  sp = qla2x00_get_sp_from_handle(vha, (char const   *)(& func), req, (void *)pkt);
#line 2498
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 2499
    return;
  } else {

  }
#line 2501
  abt = & sp->u.iocb_cmd;
#line 2502
  abt->u.abt.comp_status = pkt->nport_handle;
#line 2503
  (*(sp->done))((void *)vha, (void *)sp, 0);
#line 2504
  return;
}
}
#line 2510 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
void qla24xx_process_response_queue(struct scsi_qla_host *vha , struct rsp_que *rsp ) 
{ 
  struct sts_entry_24xx *pkt ;
  struct qla_hw_data *ha ;
  int tmp ;
  struct device_reg_82xx *reg ;

  {
#line 2514
  ha = vha->hw;
#line 2516
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 2517
    return;
  } else {

  }
#line 2519
  goto ldv_66352;
  ldv_66368: 
#line 2520
  pkt = (struct sts_entry_24xx *)rsp->ring_ptr;
#line 2522
  rsp->ring_index = (uint16_t )((int )rsp->ring_index + 1);
#line 2523
  if ((int )rsp->ring_index == (int )rsp->length) {
#line 2524
    rsp->ring_index = 0U;
#line 2525
    rsp->ring_ptr = rsp->ring;
  } else {
#line 2527
    rsp->ring_ptr = rsp->ring_ptr + 1;
  }
#line 2530
  if ((unsigned int )pkt->entry_status != 0U) {
#line 2531
    qla2x00_error_entry(vha, rsp, (sts_entry_t *)pkt);
#line 2533
    tmp = qlt_24xx_process_response_error(vha, pkt);
#line 2533
    if (tmp != 0) {
#line 2534
      goto process_err;
    } else {

    }
#line 2536
    ((response_t *)pkt)->signature = 3735936685U;
#line 2537
    __asm__  volatile   ("sfence": : : "memory");
#line 2538
    goto ldv_66352;
  } else {

  }
  process_err: ;
#line 2542
  switch ((int )pkt->entry_type) {
  case 3: 
#line 2544
  qla2x00_status_entry(vha, rsp, (void *)pkt);
#line 2545
  goto ldv_66354;
  case 16: 
#line 2547
  qla2x00_status_cont_entry(rsp, (sts_cont_entry_t *)pkt);
#line 2548
  goto ldv_66354;
  case 50: 
#line 2550
  qla24xx_report_id_acquisition(vha, (struct vp_rpt_id_entry_24xx *)pkt);
#line 2552
  goto ldv_66354;
  case 82: 
#line 2554
  qla24xx_logio_entry(vha, rsp->req, (struct logio_entry_24xx *)pkt);
#line 2556
  goto ldv_66354;
  case 41: 
#line 2558
  qla24xx_els_ct_entry(vha, rsp->req, pkt, 41);
#line 2559
  goto ldv_66354;
  case 83: 
#line 2561
  qla24xx_els_ct_entry(vha, rsp->req, pkt, 83);
#line 2562
  goto ldv_66354;
  case 84: 
#line 2565
  qlt_24xx_process_atio_queue(vha);
  case 85: ;
  case 18: ;
  case 14: ;
  case 122: 
#line 2570
  qlt_response_pkt_all_vps(vha, (response_t *)pkt);
#line 2571
  goto ldv_66354;
  case 4: ;
#line 2576
  goto ldv_66354;
  case 51: 
#line 2578
  qla24xx_abort_iocb_entry(vha, rsp->req, (struct abort_entry_24xx *)pkt);
#line 2580
  goto ldv_66354;
  default: 
#line 2583
  ql_dbg(33554432U, vha, 20546, "Received unknown response pkt type %x entry status=%x.\n",
         (int )pkt->entry_type, (int )pkt->entry_status);
#line 2587
  goto ldv_66354;
  }
  ldv_66354: 
#line 2589
  ((response_t *)pkt)->signature = 3735936685U;
#line 2590
  __asm__  volatile   ("sfence": : : "memory");
  ldv_66352: ;
#line 2519
  if ((rsp->ring_ptr)->signature != 3735936685U) {
#line 2521
    goto ldv_66368;
  } else {

  }

#line 2594
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 2595
    reg = & (ha->iobase)->isp82;
#line 2596
    writel((unsigned int )rsp->ring_index, (void volatile   *)(& reg->rsp_q_out));
  } else {
#line 2598
    writel((unsigned int )rsp->ring_index, (void volatile   *)rsp->rsp_q_out);
  }
#line 2599
  return;
}
}
#line 2602 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
static void qla2xxx_check_risc_status(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  uint32_t cnt ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 2606
  ha = vha->hw;
#line 2607
  reg = & (ha->iobase)->isp24;
#line 2609
  if ((((ha->device_type & 2048U) == 0U && (ha->device_type & 8192U) == 0U) && ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U)) && ((ha->device_type & 524288U) == 0U && (ha->device_type & 1048576U) == 0U)) {
#line 2611
    return;
  } else {

  }
#line 2613
  rval = 0;
#line 2614
  writel(31744U, (void volatile   *)(& reg->iobase_addr));
#line 2615
  readl((void const volatile   *)(& reg->iobase_addr));
#line 2616
  writel(1U, (void volatile   *)(& reg->iobase_window));
#line 2617
  cnt = 10000U;
#line 2617
  goto ldv_66379;
  ldv_66378: ;
#line 2619
  if (cnt != 0U) {
#line 2620
    writel(1U, (void volatile   *)(& reg->iobase_window));
#line 2621
    __const_udelay(42950UL);
  } else {
#line 2623
    rval = 256;
  }
#line 2618
  cnt = cnt - 1U;
  ldv_66379: 
#line 2617
  tmp = readl((void const volatile   *)(& reg->iobase_window));
#line 2617
  if ((tmp & 1U) == 0U && rval == 0) {
#line 2620
    goto ldv_66378;
  } else {

  }

#line 2625
  if (rval == 0) {
#line 2626
    goto next_test;
  } else {

  }
#line 2628
  rval = 0;
#line 2629
  writel(3U, (void volatile   *)(& reg->iobase_window));
#line 2630
  cnt = 100U;
#line 2630
  goto ldv_66383;
  ldv_66382: ;
#line 2632
  if (cnt != 0U) {
#line 2633
    writel(3U, (void volatile   *)(& reg->iobase_window));
#line 2634
    __const_udelay(42950UL);
  } else {
#line 2636
    rval = 256;
  }
#line 2631
  cnt = cnt - 1U;
  ldv_66383: 
#line 2630
  tmp___0 = readl((void const volatile   *)(& reg->iobase_window));
#line 2630
  if ((tmp___0 & 1U) == 0U && rval == 0) {
#line 2633
    goto ldv_66382;
  } else {

  }

#line 2638
  if (rval != 0) {
#line 2639
    goto done;
  } else {

  }
  next_test: 
#line 2642
  tmp___1 = readl((void const volatile   *)(& reg->iobase_c8));
#line 2642
  if ((tmp___1 & 8U) != 0U) {
#line 2643
    ql_log(2U, vha, 20556, "Additional code -- 0x55AA.\n");
  } else {

  }
  done: 
#line 2647
  writel(0U, (void volatile   *)(& reg->iobase_window));
#line 2648
  readl((void const volatile   *)(& reg->iobase_window));
#line 2649
  return;
}
}
#line 2661 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
irqreturn_t qla24xx_intr_handler(int irq , void *dev_id ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  int status ;
  unsigned long iter ;
  uint32_t stat ;
  uint32_t hccr ;
  uint16_t mb[8U] ;
  struct rsp_que *rsp ;
  unsigned long flags ;
  int tmp ;
  long tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  void *tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  unsigned long tmp___7 ;

  {
#line 2674
  rsp = (struct rsp_que *)dev_id;
#line 2675
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 2676
    ql_log(2U, (scsi_qla_host_t *)0, 20569, "%s: NULL response queue pointer.\n",
           "qla24xx_intr_handler");
#line 2678
    return (0);
  } else {

  }
#line 2681
  ha = rsp->hw;
#line 2682
  reg = & (ha->iobase)->isp24;
#line 2683
  status = 0;
#line 2685
  tmp = pci_channel_offline(ha->pdev);
#line 2685
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 2685
  if (tmp___0 != 0L) {
#line 2686
    return (1);
  } else {

  }
#line 2688
  tmp___1 = spinlock_check(& ha->hardware_lock);
#line 2688
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 2689
  tmp___2 = pci_get_drvdata(ha->pdev);
#line 2689
  vha = (scsi_qla_host_t *)tmp___2;
#line 2690
  iter = 50UL;
#line 2690
  goto ldv_66417;
  ldv_66416: 
#line 2691
  stat = readl((void const volatile   *)(& reg->host_status));
#line 2692
  tmp___3 = qla2x00_check_reg32_for_disconnect(vha, stat);
#line 2692
  if ((int )tmp___3) {
#line 2693
    goto ldv_66404;
  } else {

  }
#line 2694
  if ((stat & 256U) != 0U) {
#line 2695
    tmp___4 = pci_channel_offline(ha->pdev);
#line 2695
    tmp___5 = ldv__builtin_expect(tmp___4 != 0, 0L);
#line 2695
    if (tmp___5 != 0L) {
#line 2696
      goto ldv_66404;
    } else {

    }
#line 2698
    hccr = readl((void const volatile   *)(& reg->hccr));
#line 2700
    ql_log(1U, vha, 20555, "RISC paused -- HCCR=%x, Dumping firmware.\n", hccr);
#line 2704
    qla2xxx_check_risc_status(vha);
#line 2706
    (*((ha->isp_ops)->fw_dump))(vha, 1);
#line 2707
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2708
    goto ldv_66404;
  } else
#line 2709
  if ((stat & 32768U) == 0U) {
#line 2710
    goto ldv_66404;
  } else {

  }
#line 2712
  switch (stat & 255U) {
  case 1U: ;
  case 2U: ;
  case 16U: ;
  case 17U: 
#line 2717
  qla24xx_mbx_completion(vha, (int )((unsigned short )(stat >> 16)));
#line 2718
  status = status | 1;
#line 2720
  goto ldv_66409;
  case 18U: 
#line 2722
  mb[0] = (unsigned short )(stat >> 16);
#line 2723
  mb[1] = readw((void const volatile   *)(& reg->mailbox1));
#line 2724
  mb[2] = readw((void const volatile   *)(& reg->mailbox2));
#line 2725
  mb[3] = readw((void const volatile   *)(& reg->mailbox3));
#line 2726
  qla2x00_async_event(vha, rsp, (uint16_t *)(& mb));
#line 2727
  goto ldv_66409;
  case 19U: ;
  case 20U: 
#line 2730
  qla24xx_process_response_queue(vha, rsp);
#line 2731
  goto ldv_66409;
  case 28U: 
#line 2733
  qlt_24xx_process_atio_queue(vha);
#line 2734
  goto ldv_66409;
  case 29U: 
#line 2736
  qlt_24xx_process_atio_queue(vha);
#line 2737
  qla24xx_process_response_queue(vha, rsp);
#line 2738
  goto ldv_66409;
  default: 
#line 2740
  ql_dbg(33554432U, vha, 20559, "Unrecognized interrupt type (%d).\n", stat * 255U);
#line 2742
  goto ldv_66409;
  }
  ldv_66409: 
#line 2744
  writel(2684354560U, (void volatile   *)(& reg->hccr));
#line 2745
  __readl((void const volatile   *)(& reg->hccr));
#line 2746
  tmp___6 = ldv__builtin_expect((long )(((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) && (unsigned int )(ha->pdev)->revision == 1U),
                             0L);
#line 2746
  if (tmp___6 != 0L) {
#line 2747
    __const_udelay(17500UL);
  } else {

  }
  ldv_66417: 
#line 2690
  tmp___7 = iter;
#line 2690
  iter = iter - 1UL;
#line 2690
  if (tmp___7 != 0UL) {
#line 2692
    goto ldv_66416;
  } else {

  }
  ldv_66404: 
#line 2749
  qla2x00_handle_mbx_completion(ha, status);
#line 2750
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2752
  return (1);
}
}
#line 2756 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
static irqreturn_t qla24xx_msix_rsp_q(int irq , void *dev_id ) 
{ 
  struct qla_hw_data *ha ;
  struct rsp_que *rsp ;
  struct device_reg_24xx *reg ;
  struct scsi_qla_host *vha ;
  unsigned long flags ;
  uint32_t stat ;
  raw_spinlock_t *tmp ;
  void *tmp___0 ;
  bool tmp___1 ;

  {
#line 2763
  stat = 0U;
#line 2765
  rsp = (struct rsp_que *)dev_id;
#line 2766
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 2767
    ql_log(2U, (scsi_qla_host_t *)0, 20570, "%s: NULL response queue pointer.\n",
           "qla24xx_msix_rsp_q");
#line 2769
    return (0);
  } else {

  }
#line 2771
  ha = rsp->hw;
#line 2772
  reg = & (ha->iobase)->isp24;
#line 2774
  tmp = spinlock_check(& ha->hardware_lock);
#line 2774
  flags = _raw_spin_lock_irqsave(tmp);
#line 2776
  tmp___0 = pci_get_drvdata(ha->pdev);
#line 2776
  vha = (struct scsi_qla_host *)tmp___0;
#line 2781
  stat = readl((void const volatile   *)(& reg->host_status));
#line 2782
  tmp___1 = qla2x00_check_reg32_for_disconnect(vha, stat);
#line 2782
  if ((int )tmp___1) {
#line 2783
    goto out;
  } else {

  }
#line 2784
  qla24xx_process_response_queue(vha, rsp);
#line 2785
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 2786
    writel(2684354560U, (void volatile   *)(& reg->hccr));
#line 2787
    __readl((void const volatile   *)(& reg->hccr));
  } else {

  }
  out: 
#line 2790
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2792
  return (1);
}
}
#line 2796 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
static irqreturn_t qla25xx_msix_rsp_q(int irq , void *dev_id ) 
{ 
  struct qla_hw_data *ha ;
  scsi_qla_host_t *vha ;
  struct rsp_que *rsp ;
  struct device_reg_24xx *reg ;
  unsigned long flags ;
  uint32_t hccr ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;
  bool tmp___1 ;

  {
#line 2803
  hccr = 0U;
#line 2805
  rsp = (struct rsp_que *)dev_id;
#line 2806
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 2807
    ql_log(2U, (scsi_qla_host_t *)0, 20571, "%s: NULL response queue pointer.\n",
           "qla25xx_msix_rsp_q");
#line 2809
    return (0);
  } else {

  }
#line 2811
  ha = rsp->hw;
#line 2812
  tmp = pci_get_drvdata(ha->pdev);
#line 2812
  vha = (scsi_qla_host_t *)tmp;
#line 2815
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 2816
    reg = & (ha->iobase)->isp24;
#line 2817
    tmp___0 = spinlock_check(& ha->hardware_lock);
#line 2817
    flags = _raw_spin_lock_irqsave(tmp___0);
#line 2818
    writel(2684354560U, (void volatile   *)(& reg->hccr));
#line 2819
    hccr = __readl((void const volatile   *)(& reg->hccr));
#line 2820
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
  } else {

  }
#line 2822
  tmp___1 = qla2x00_check_reg32_for_disconnect(vha, hccr);
#line 2822
  if ((int )tmp___1) {
#line 2823
    goto out;
  } else {

  }
#line 2824
  ldv_queue_work_on_117((int )rsp->id + -1, ha->wq, & rsp->q_work);
  out: ;
#line 2827
  return (1);
}
}
#line 2831 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
static irqreturn_t qla24xx_msix_default(int irq , void *dev_id ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct rsp_que *rsp ;
  struct device_reg_24xx *reg ;
  int status ;
  uint32_t stat ;
  uint32_t hccr ;
  uint16_t mb[8U] ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  void *tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 2843
  rsp = (struct rsp_que *)dev_id;
#line 2844
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 2845
    ql_log(2U, (scsi_qla_host_t *)0, 20572, "%s: NULL response queue pointer.\n",
           "qla24xx_msix_default");
#line 2847
    return (0);
  } else {

  }
#line 2849
  ha = rsp->hw;
#line 2850
  reg = & (ha->iobase)->isp24;
#line 2851
  status = 0;
#line 2853
  tmp = spinlock_check(& ha->hardware_lock);
#line 2853
  flags = _raw_spin_lock_irqsave(tmp);
#line 2854
  tmp___0 = pci_get_drvdata(ha->pdev);
#line 2854
  vha = (scsi_qla_host_t *)tmp___0;
#line 2856
  stat = readl((void const volatile   *)(& reg->host_status));
#line 2857
  tmp___1 = qla2x00_check_reg32_for_disconnect(vha, stat);
#line 2857
  if ((int )tmp___1) {
#line 2858
    goto ldv_66465;
  } else {

  }
#line 2859
  if ((stat & 256U) != 0U) {
#line 2860
    tmp___2 = pci_channel_offline(ha->pdev);
#line 2860
    tmp___3 = ldv__builtin_expect(tmp___2 != 0, 0L);
#line 2860
    if (tmp___3 != 0L) {
#line 2861
      goto ldv_66465;
    } else {

    }
#line 2863
    hccr = readl((void const volatile   *)(& reg->hccr));
#line 2865
    ql_log(2U, vha, 20560, "RISC paused -- HCCR=%x, Dumping firmware.\n", hccr);
#line 2869
    qla2xxx_check_risc_status(vha);
#line 2871
    (*((ha->isp_ops)->fw_dump))(vha, 1);
#line 2872
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2873
    goto ldv_66465;
  } else
#line 2874
  if ((stat & 32768U) == 0U) {
#line 2875
    goto ldv_66465;
  } else {

  }
#line 2877
  switch (stat & 255U) {
  case 1U: ;
  case 2U: ;
  case 16U: ;
  case 17U: 
#line 2882
  qla24xx_mbx_completion(vha, (int )((unsigned short )(stat >> 16)));
#line 2883
  status = status | 1;
#line 2885
  goto ldv_66470;
  case 18U: 
#line 2887
  mb[0] = (unsigned short )(stat >> 16);
#line 2888
  mb[1] = readw((void const volatile   *)(& reg->mailbox1));
#line 2889
  mb[2] = readw((void const volatile   *)(& reg->mailbox2));
#line 2890
  mb[3] = readw((void const volatile   *)(& reg->mailbox3));
#line 2891
  qla2x00_async_event(vha, rsp, (uint16_t *)(& mb));
#line 2892
  goto ldv_66470;
  case 19U: ;
  case 20U: 
#line 2895
  qla24xx_process_response_queue(vha, rsp);
#line 2896
  goto ldv_66470;
  case 28U: 
#line 2898
  qlt_24xx_process_atio_queue(vha);
#line 2899
  goto ldv_66470;
  case 29U: 
#line 2901
  qlt_24xx_process_atio_queue(vha);
#line 2902
  qla24xx_process_response_queue(vha, rsp);
#line 2903
  goto ldv_66470;
  default: 
#line 2905
  ql_dbg(33554432U, vha, 20561, "Unrecognized interrupt type (%d).\n", stat & 255U);
#line 2907
  goto ldv_66470;
  }
  ldv_66470: 
#line 2909
  writel(2684354560U, (void volatile   *)(& reg->hccr));
  ldv_66465: 
#line 2911
  qla2x00_handle_mbx_completion(ha, status);
#line 2912
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2914
  return (1);
}
}
#line 2924 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
static struct qla_init_msix_entry msix_entries[3U]  = {      {"qla2xxx (default)", & qla24xx_msix_default}, 
        {"qla2xxx (rsp_q)", & qla24xx_msix_rsp_q}, 
        {"qla2xxx (multiq)", & qla25xx_msix_rsp_q}};
#line 2930 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
static struct qla_init_msix_entry qla82xx_msix_entries[2U]  = {      {"qla2xxx (default)", & qla82xx_msix_default}, 
        {"qla2xxx (rsp_q)", & qla82xx_msix_rsp_q}};
#line 2935 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
static struct qla_init_msix_entry qla83xx_msix_entries[3U]  = {      {"qla2xxx (default)", & qla24xx_msix_default}, 
        {"qla2xxx (rsp_q)", & qla24xx_msix_rsp_q}, 
        {"qla2xxx (atio_q)", & qla83xx_msix_atio_q}};
#line 2942 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
static void qla24xx_disable_msix(struct qla_hw_data *ha ) 
{ 
  int i ;
  struct qla_msix_entry *qentry ;
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 2946
  tmp = pci_get_drvdata(ha->pdev);
#line 2946
  vha = (scsi_qla_host_t *)tmp;
#line 2948
  i = 0;
#line 2948
  goto ldv_66490;
  ldv_66489: 
#line 2949
  qentry = ha->msix_entries + (unsigned long )i;
#line 2950
  if (qentry->have_irq != 0) {
#line 2951
    free_irq(qentry->vector, (void *)qentry->rsp);
  } else {

  }
#line 2948
  i = i + 1;
  ldv_66490: ;
#line 2948
  if ((int )ha->msix_count > i) {
#line 2950
    goto ldv_66489;
  } else {

  }
#line 2953
  pci_disable_msix(ha->pdev);
#line 2954
  kfree((void const   *)ha->msix_entries);
#line 2955
  ha->msix_entries = (struct qla_msix_entry *)0;
#line 2956
  ha->flags.msix_enabled = 0U;
#line 2957
  ql_dbg(1073741824U, vha, 66, "Disabled the MSI.\n");
#line 2959
  return;
}
}
#line 2962 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
static int qla24xx_enable_msix(struct qla_hw_data *ha , struct rsp_que *rsp ) 
{ 
  int i ;
  int ret ;
  struct msix_entry *entries ;
  struct qla_msix_entry *qentry ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 2969
  tmp = pci_get_drvdata(ha->pdev);
#line 2969
  vha = (scsi_qla_host_t *)tmp;
#line 2971
  tmp___0 = kzalloc((unsigned long )ha->msix_count * 8UL, 208U);
#line 2971
  entries = (struct msix_entry *)tmp___0;
#line 2973
  if ((unsigned long )entries == (unsigned long )((struct msix_entry *)0)) {
#line 2974
    ql_log(1U, vha, 188, "Failed to allocate memory for msix_entry.\n");
#line 2976
    return (-12);
  } else {

  }
#line 2979
  i = 0;
#line 2979
  goto ldv_66502;
  ldv_66501: 
#line 2980
  (entries + (unsigned long )i)->entry = (u16 )i;
#line 2979
  i = i + 1;
  ldv_66502: ;
#line 2979
  if ((int )ha->msix_count > i) {
#line 2981
    goto ldv_66501;
  } else {

  }
#line 2982
  ret = pci_enable_msix_range(ha->pdev, entries, 2, (int )ha->msix_count);
#line 2984
  if (ret < 0) {
#line 2985
    ql_log(0U, vha, 199, "MSI-X: Failed to enable support, giving   up -- %d/%d.\n",
           (int )ha->msix_count, ret);
#line 2989
    goto msix_out;
  } else
#line 2990
  if ((int )ha->msix_count > ret) {
#line 2991
    ql_log(1U, vha, 198, "MSI-X: Failed to enable support -- %d/%d\n Retry with %d vectors.\n",
           (int )ha->msix_count, ret, ret);
  } else {

  }
#line 2996
  ha->msix_count = (uint16_t )ret;
#line 2997
  ha->max_rsp_queues = (unsigned int )((uint8_t )ha->msix_count) + 255U;
#line 2998
  tmp___1 = kzalloc((unsigned long )ha->msix_count * 24UL, 208U);
#line 2998
  ha->msix_entries = (struct qla_msix_entry *)tmp___1;
#line 3000
  if ((unsigned long )ha->msix_entries == (unsigned long )((struct qla_msix_entry *)0)) {
#line 3001
    ql_log(0U, vha, 200, "Failed to allocate memory for ha->msix_entries.\n");
#line 3003
    ret = -12;
#line 3004
    goto msix_out;
  } else {

  }
#line 3006
  ha->flags.msix_enabled = 1U;
#line 3008
  i = 0;
#line 3008
  goto ldv_66506;
  ldv_66505: 
#line 3009
  qentry = ha->msix_entries + (unsigned long )i;
#line 3010
  qentry->vector = (entries + (unsigned long )i)->vector;
#line 3011
  qentry->entry = (entries + (unsigned long )i)->entry;
#line 3012
  qentry->have_irq = 0;
#line 3013
  qentry->rsp = (struct rsp_que *)0;
#line 3008
  i = i + 1;
  ldv_66506: ;
#line 3008
  if ((int )ha->msix_count > i) {
#line 3010
    goto ldv_66505;
  } else {

  }
#line 3017
  i = 0;
#line 3017
  goto ldv_66510;
  ldv_66509: 
#line 3018
  qentry = ha->msix_entries + (unsigned long )i;
#line 3019
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 3020
    ret = request_irq(qentry->vector, qla82xx_msix_entries[i].handler, 0UL, qla82xx_msix_entries[i].name,
                      (void *)rsp);
  } else {
#line 3024
    ret = request_irq(qentry->vector, msix_entries[i].handler, 0UL, msix_entries[i].name,
                      (void *)rsp);
  }
#line 3027
  if (ret != 0) {
#line 3028
    goto msix_register_fail;
  } else {

  }
#line 3029
  qentry->have_irq = 1;
#line 3030
  qentry->rsp = rsp;
#line 3031
  rsp->msix = qentry;
#line 3017
  i = i + 1;
  ldv_66510: ;
#line 3017
  if (i <= 1) {
#line 3019
    goto ldv_66509;
  } else {

  }

#line 3038
  if (ql2x_ini_mode != 2 && ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) {
#line 3039
    qentry = ha->msix_entries + 2UL;
#line 3040
    ret = request_irq(qentry->vector, qla83xx_msix_entries[2].handler, 0UL, qla83xx_msix_entries[2].name,
                      (void *)rsp);
#line 3043
    qentry->have_irq = 1;
#line 3044
    qentry->rsp = rsp;
#line 3045
    rsp->msix = qentry;
  } else {

  }
  msix_register_fail: ;
#line 3049
  if (ret != 0) {
#line 3050
    ql_log(0U, vha, 203, "MSI-X: unable to register handler -- %x/%d.\n", qentry->vector,
           ret);
#line 3053
    qla24xx_disable_msix(ha);
#line 3054
    ha->mqenable = 0U;
#line 3055
    goto msix_out;
  } else {

  }
#line 3059
  if (((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 3060
    if (((unsigned long )ha->msixbase != (unsigned long )((device_reg_t *)0) && (unsigned long )ha->mqiobase != (unsigned long )((device_reg_t *)0)) && ((unsigned int )ha->max_rsp_queues > 1U || (unsigned int )ha->max_req_queues > 1U)) {
#line 3062
      ha->mqenable = 1U;
    } else {

    }
  } else
#line 3064
  if ((unsigned long )ha->mqiobase != (unsigned long )((device_reg_t *)0) && ((unsigned int )ha->max_rsp_queues > 1U || (unsigned int )ha->max_req_queues > 1U)) {
#line 3066
    ha->mqenable = 1U;
  } else {

  }
#line 3067
  ql_dbg(1048576U, vha, 49157, "mqiobase=%p, max_rsp_queues=%d, max_req_queues=%d.\n",
         ha->mqiobase, (int )ha->max_rsp_queues, (int )ha->max_req_queues);
#line 3070
  ql_dbg(1073741824U, vha, 85, "mqiobase=%p, max_rsp_queues=%d, max_req_queues=%d.\n",
         ha->mqiobase, (int )ha->max_rsp_queues, (int )ha->max_req_queues);
  msix_out: 
#line 3075
  kfree((void const   *)entries);
#line 3076
  return (ret);
}
}
#line 3080 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
int qla2x00_request_irqs(struct qla_hw_data *ha , struct rsp_que *rsp ) 
{ 
  int ret ;
  device_reg_t *reg ;
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 3082
  ret = 258;
#line 3083
  reg = ha->iobase;
#line 3084
  tmp = pci_get_drvdata(ha->pdev);
#line 3084
  vha = (scsi_qla_host_t *)tmp;
#line 3087
  if (((((((ha->device_type & 256U) == 0U && (ha->device_type & 2048U) == 0U) && (ha->device_type & 4096U) == 0U) && ((((ha->device_type & 8192U) == 0U && (ha->device_type & 16384U) == 0U) && (ha->device_type & 65536U) == 0U) && (ha->device_type & 262144U) == 0U)) && (ha->device_type & 32768U) == 0U) && (ha->device_type & 131072U) == 0U) && ((ha->device_type & 524288U) == 0U && (ha->device_type & 1048576U) == 0U)) {
#line 3090
    goto skip_msi;
  } else {

  }
#line 3092
  if ((unsigned int )(ha->pdev)->subsystem_vendor == 4156U && (((unsigned int )(ha->pdev)->subsystem_device == 28736U || (unsigned int )(ha->pdev)->subsystem_device == 28737U) || (unsigned int )(ha->pdev)->subsystem_device == 5893U)) {
#line 3096
    ql_log(1U, vha, 52, "MSI-X: Unsupported ISP 2432 SSVID/SSDID (0x%X,0x%X).\n",
           (int )(ha->pdev)->subsystem_vendor, (int )(ha->pdev)->subsystem_device);
#line 3100
    goto skip_msi;
  } else {

  }
#line 3103
  if ((ha->device_type & 256U) != 0U && (unsigned int )(ha->pdev)->revision <= 2U) {
#line 3104
    ql_log(1U, vha, 53, "MSI-X; Unsupported ISP2432 (0x%X, 0x%X).\n", (int )(ha->pdev)->revision,
           3);
#line 3107
    goto skip_msix;
  } else {

  }
#line 3110
  ret = qla24xx_enable_msix(ha, rsp);
#line 3111
  if (ret == 0) {
#line 3112
    ql_dbg(1073741824U, vha, 54, "MSI-X: Enabled (0x%X, 0x%X).\n", (int )ha->chip_revision,
           (int )ha->fw_attributes);
#line 3115
    goto clear_risc_ints;
  } else {

  }
  skip_msix: 
#line 3120
  ql_log(2U, vha, 55, "Falling back-to MSI mode -%d.\n", ret);
#line 3123
  if ((((((((ha->device_type & 128U) == 0U && (ha->device_type & 256U) == 0U) && (ha->device_type & 2048U) == 0U) && (ha->device_type & 4096U) == 0U) && (ha->device_type & 8192U) == 0U) && ((ha->device_type & 16384U) == 0U && (ha->device_type & 262144U) == 0U)) && (ha->device_type & 131072U) == 0U) && ((ha->device_type & 524288U) == 0U && (ha->device_type & 1048576U) == 0U)) {
#line 3126
    goto skip_msi;
  } else {

  }
#line 3128
  ret = pci_enable_msi_exact(ha->pdev, 1);
#line 3129
  if (ret == 0) {
#line 3130
    ql_dbg(1073741824U, vha, 56, "MSI: Enabled.\n");
#line 3132
    ha->flags.msi_enabled = 1U;
  } else {
#line 3134
    ql_log(1U, vha, 57, "Falling back-to INTa mode -- %d.\n", ret);
  }
  skip_msi: ;
#line 3139
  if (*((unsigned long *)ha + 2UL) == 0UL && (ha->device_type & 16384U) != 0U) {
#line 3140
    return (258);
  } else {

  }
#line 3142
  ret = request_irq((ha->pdev)->irq, (ha->isp_ops)->intr_handler, *((unsigned long *)ha + 2UL) != 0UL ? 0UL : 128UL,
                    "qla2xxx", (void *)rsp);
#line 3145
  if (ret != 0) {
#line 3146
    ql_log(1U, vha, 58, "Failed to reserve interrupt %d already in use.\n", (ha->pdev)->irq);
#line 3149
    goto fail;
  } else
#line 3150
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 3151
    ql_dbg(1073741824U, vha, 293, "INTa mode: Enabled.\n");
#line 3153
    ha->flags.mr_intr_valid = 1U;
  } else {

  }
  clear_risc_ints: ;
#line 3157
  if ((ha->device_type & 134217728U) != 0U || (ha->device_type & 131072U) != 0U) {
#line 3158
    goto fail;
  } else {

  }
#line 3160
  spin_lock_irq(& ha->hardware_lock);
#line 3161
  writew(0, (void volatile   *)(& reg->isp.semaphore));
#line 3162
  spin_unlock_irq(& ha->hardware_lock);
  fail: ;
#line 3165
  return (ret);
}
}
#line 3169 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
void qla2x00_free_irqs(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct rsp_que *rsp ;

  {
#line 3171
  ha = vha->hw;
#line 3178
  if ((unsigned long )ha->rsp_q_map == (unsigned long )((struct rsp_que **)0) || (unsigned long )*(ha->rsp_q_map) == (unsigned long )((struct rsp_que *)0)) {
#line 3179
    return;
  } else {

  }
#line 3180
  rsp = *(ha->rsp_q_map);
#line 3182
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 3183
    qla24xx_disable_msix(ha);
  } else
#line 3184
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 3185
    free_irq((ha->pdev)->irq, (void *)rsp);
#line 3186
    pci_disable_msi(ha->pdev);
  } else {
#line 3188
    free_irq((ha->pdev)->irq, (void *)rsp);
  }
#line 3189
  return;
}
}
#line 3192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.c"
int qla25xx_request_irq(struct rsp_que *rsp ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_init_msix_entry *intr ;
  struct qla_msix_entry *msix ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int ret ;

  {
#line 3194
  ha = rsp->hw;
#line 3195
  intr = (struct qla_init_msix_entry *)(& msix_entries) + 2UL;
#line 3196
  msix = rsp->msix;
#line 3197
  tmp = pci_get_drvdata(ha->pdev);
#line 3197
  vha = (scsi_qla_host_t *)tmp;
#line 3200
  ret = request_irq(msix->vector, intr->handler, 0UL, intr->name, (void *)rsp);
#line 3201
  if (ret != 0) {
#line 3202
    ql_log(0U, vha, 230, "MSI-X: Unable to register handler -- %x/%d.\n", msix->vector,
           ret);
#line 3205
    return (ret);
  } else {

  }
#line 3207
  msix->have_irq = 1;
#line 3208
  msix->rsp = rsp;
#line 3209
  return (ret);
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
int reg_timer_18(struct timer_list *timer ) 
{ 


  {
#line 489
  ldv_timer_list_18 = timer;
#line 490
  ldv_timer_state_18 = 1;
#line 491
  return (0);
}
}
#line 494 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
void activate_pending_timer_18(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 494
  if ((unsigned long )ldv_timer_list_18 == (unsigned long )timer) {
#line 495
    if (ldv_timer_state_18 == 2 || pending_flag != 0) {
#line 496
      ldv_timer_list_18 = timer;
#line 497
      ldv_timer_list_18->data = data;
#line 498
      ldv_timer_state_18 = 1;
    } else {

    }
#line 500
    return;
  } else {

  }
#line 502
  reg_timer_18(timer);
#line 503
  ldv_timer_list_18->data = data;
#line 504
  return;
}
}
#line 507 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
void choose_timer_18(struct timer_list *timer ) 
{ 


  {
#line 508
  LDV_IN_INTERRUPT = 2;
#line 509
  (*(timer->function))(timer->data);
#line 510
  LDV_IN_INTERRUPT = 1;
#line 511
  ldv_timer_state_18 = 2;
#line 512
  return;
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
void disable_suitable_timer_18(struct timer_list *timer ) 
{ 


  {
#line 516
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_18) {
#line 517
    ldv_timer_state_18 = 0;
#line 518
    return;
  } else {

  }
#line 520
  return;
}
}
#line 546 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
bool ldv_queue_work_on_111(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 550
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 550
  ldv_func_res = tmp;
#line 552
  activate_work_7(ldv_func_arg3, 2);
#line 554
  return (ldv_func_res);
}
}
#line 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
bool ldv_queue_delayed_work_on_112(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 561
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 561
  ldv_func_res = tmp;
#line 563
  activate_work_7(& ldv_func_arg3->work, 2);
#line 565
  return (ldv_func_res);
}
}
#line 568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
bool ldv_queue_work_on_113(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 572
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 572
  ldv_func_res = tmp;
#line 574
  activate_work_7(ldv_func_arg3, 2);
#line 576
  return (ldv_func_res);
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
void ldv_flush_workqueue_114(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 582
  flush_workqueue(ldv_func_arg1);
#line 584
  call_and_disable_all_7(2);
#line 585
  return;
}
}
#line 587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
bool ldv_queue_delayed_work_on_115(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 591
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 591
  ldv_func_res = tmp;
#line 593
  activate_work_7(& ldv_func_arg3->work, 2);
#line 595
  return (ldv_func_res);
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
int ldv_scsi_add_host_with_dma_116(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 602
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 602
  ldv_func_res = tmp;
#line 604
  if (ldv_func_res == 0) {
#line 605
    ldv_state_variable_88 = 1;
#line 605
    ldv_initialize_scsi_host_template_88();
  } else {

  }
#line 609
  return (ldv_func_res);
}
}
#line 612 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
bool ldv_queue_work_on_117(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___14 ldv_func_res ;
  bool tmp ;

  {
#line 616
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 616
  ldv_func_res = tmp;
#line 618
  activate_work_7(ldv_func_arg3, 2);
#line 620
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_129(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_131(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_130(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_133(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_132(struct workqueue_struct *ldv_func_arg1 ) ;
#line 320 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
void activate_pending_timer_19(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 341
void choose_timer_19(struct timer_list *timer ) ;
#line 360
int reg_timer_19(struct timer_list *timer ) ;
#line 483
void disable_suitable_timer_19(struct timer_list *timer ) ;
#line 795 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_134(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
#line 566 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
void qla2x00_get_sym_node_name(scsi_qla_host_t *vha , uint8_t *snn , size_t size ) ;
#line 1088 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
void qlt_rff_id(struct scsi_qla_host *vha , struct ct_sns_req *ct_req ) ;
#line 72 "include/linux/utsname.h"
__inline static struct new_utsname *utsname(void) 
{ 
  struct task_struct *tmp ;

  {
#line 74
  tmp = get_current();
#line 74
  return (& ((tmp->nsproxy)->uts_ns)->name);
}
}
#line 11 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
static int qla2x00_sns_ga_nxt(scsi_qla_host_t *vha , fc_port_t *fcport ) ;
#line 12
static int qla2x00_sns_gid_pt(scsi_qla_host_t *vha , sw_info_t *list ) ;
#line 13
static int qla2x00_sns_gpn_id(scsi_qla_host_t *vha , sw_info_t *list ) ;
#line 14
static int qla2x00_sns_gnn_id(scsi_qla_host_t *vha , sw_info_t *list ) ;
#line 15
static int qla2x00_sns_rft_id(scsi_qla_host_t *vha ) ;
#line 16
static int qla2x00_sns_rnn_id(scsi_qla_host_t *vha ) ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
void *qla2x00_prep_ms_iocb(scsi_qla_host_t *vha , uint32_t req_size , uint32_t rsp_size ) 
{ 
  struct qla_hw_data *ha ;
  ms_iocb_entry_t *ms_pkt ;

  {
#line 29
  ha = vha->hw;
#line 32
  ms_pkt = ha->ms_iocb;
#line 33
  memset((void *)ms_pkt, 0, 64UL);
#line 35
  ms_pkt->entry_type = 41U;
#line 36
  ms_pkt->entry_count = 1U;
#line 37
  if ((int )ha->device_type < 0) {
#line 37
    ms_pkt->loop_id.extended = 128U;
  } else {
#line 37
    ms_pkt->loop_id.id.standard = 128U;
  }
#line 38
  ms_pkt->control_flags = 34U;
#line 39
  ms_pkt->timeout = ((unsigned int )ha->r_a_tov / 10U) * 2U;
#line 40
  ms_pkt->cmd_dsd_count = 1U;
#line 41
  ms_pkt->total_dsd_count = 2U;
#line 42
  ms_pkt->rsp_bytecount = rsp_size;
#line 43
  ms_pkt->req_bytecount = req_size;
#line 45
  ms_pkt->dseg_req_address[0] = (unsigned int )ha->ct_sns_dma;
#line 46
  ms_pkt->dseg_req_address[1] = (unsigned int )(ha->ct_sns_dma >> 32ULL);
#line 47
  ms_pkt->dseg_req_length = ms_pkt->req_bytecount;
#line 49
  ms_pkt->dseg_rsp_address[0] = (unsigned int )ha->ct_sns_dma;
#line 50
  ms_pkt->dseg_rsp_address[1] = (unsigned int )(ha->ct_sns_dma >> 32ULL);
#line 51
  ms_pkt->dseg_rsp_length = ms_pkt->rsp_bytecount;
#line 53
  vha->qla_stats.control_requests = vha->qla_stats.control_requests + 1U;
#line 55
  return ((void *)ms_pkt);
}
}
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
void *qla24xx_prep_ms_iocb(scsi_qla_host_t *vha , uint32_t req_size , uint32_t rsp_size ) 
{ 
  struct qla_hw_data *ha ;
  struct ct_entry_24xx *ct_pkt ;

  {
#line 69
  ha = vha->hw;
#line 72
  ct_pkt = (struct ct_entry_24xx *)ha->ms_iocb;
#line 73
  memset((void *)ct_pkt, 0, 64UL);
#line 75
  ct_pkt->entry_type = 41U;
#line 76
  ct_pkt->entry_count = 1U;
#line 77
  ct_pkt->nport_handle = 2044U;
#line 78
  ct_pkt->timeout = ((unsigned int )ha->r_a_tov / 10U) * 2U;
#line 79
  ct_pkt->cmd_dsd_count = 1U;
#line 80
  ct_pkt->rsp_dsd_count = 1U;
#line 81
  ct_pkt->rsp_byte_count = rsp_size;
#line 82
  ct_pkt->cmd_byte_count = req_size;
#line 84
  ct_pkt->dseg_0_address[0] = (unsigned int )ha->ct_sns_dma;
#line 85
  ct_pkt->dseg_0_address[1] = (unsigned int )(ha->ct_sns_dma >> 32ULL);
#line 86
  ct_pkt->dseg_0_len = ct_pkt->cmd_byte_count;
#line 88
  ct_pkt->dseg_1_address[0] = (unsigned int )ha->ct_sns_dma;
#line 89
  ct_pkt->dseg_1_address[1] = (unsigned int )(ha->ct_sns_dma >> 32ULL);
#line 90
  ct_pkt->dseg_1_len = ct_pkt->rsp_byte_count;
#line 91
  ct_pkt->vp_index = (uint8_t )vha->vp_idx;
#line 93
  vha->qla_stats.control_requests = vha->qla_stats.control_requests + 1U;
#line 95
  return ((void *)ct_pkt);
}
}
#line 107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
__inline static struct ct_sns_req *qla2x00_prep_ct_req(struct ct_sns_pkt *p , uint16_t cmd ,
                                                       uint16_t rsp_size ) 
{ 
  __u16 tmp ;
  __u16 tmp___0 ;

  {
#line 109
  memset((void *)p, 0, 8208UL);
#line 111
  p->p.req.header.revision = 1U;
#line 112
  p->p.req.header.gs_type = 252U;
#line 113
  p->p.req.header.gs_subtype = 2U;
#line 114
  tmp = __fswab16((int )cmd);
#line 114
  p->p.req.command = tmp;
#line 115
  tmp___0 = __fswab16((int )((__u16 )(((int )rsp_size + -16) / 4)));
#line 115
  p->p.req.max_rsp_size = tmp___0;
#line 117
  return (& p->p.req);
}
}
#line 121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
static int qla2x00_chk_ms_status(scsi_qla_host_t *vha , ms_iocb_entry_t *ms_pkt ,
                                 struct ct_sns_rsp *ct_rsp , char const   *routine ) 
{ 
  int rval ;
  uint16_t comp_status ;
  struct qla_hw_data *ha ;

  {
#line 126
  ha = vha->hw;
#line 128
  rval = 258;
#line 129
  if ((unsigned int )ms_pkt->entry_status != 0U) {
#line 130
    ql_dbg(268435456U, vha, 8241, "%s failed, error status (%x) on port_id: %02x%02x%02x.\n",
           routine, (int )ms_pkt->entry_status, (int )vha->d_id.b.domain, (int )vha->d_id.b.area,
           (int )vha->d_id.b.al_pa);
  } else {
#line 135
    if ((ha->device_type & 134217728U) != 0U) {
#line 136
      comp_status = ((struct ct_entry_24xx *)ms_pkt)->comp_status;
    } else {
#line 139
      comp_status = ms_pkt->status;
    }
#line 140
    switch ((int )comp_status) {
    case 0: ;
    case 21: ;
    case 7: ;
#line 144
    if ((unsigned int )ct_rsp->header.response != 640U) {
#line 146
      ql_dbg(268566528U, vha, 8311, "%s failed rejected request on port_id: %02x%02x%02x Compeltion status 0x%x, response 0x%x\n",
             routine, (int )vha->d_id.b.domain, (int )vha->d_id.b.area, (int )vha->d_id.b.al_pa,
             (int )comp_status, (int )ct_rsp->header.response);
#line 151
      ql_dump_buffer(268566528U, vha, 8312, (uint8_t *)(& ct_rsp->header), 16U);
#line 154
      rval = 1;
    } else {
#line 156
      rval = 0;
    }
#line 157
    goto ldv_65850;
    default: 
#line 159
    ql_dbg(268435456U, vha, 8243, "%s failed, completion status (%x) on port_id: %02x%02x%02x.\n",
           routine, (int )comp_status, (int )vha->d_id.b.domain, (int )vha->d_id.b.area,
           (int )vha->d_id.b.al_pa);
#line 164
    goto ldv_65850;
    }
    ldv_65850: ;
  }
#line 167
  return (rval);
}
}
#line 178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
int qla2x00_ga_nxt(scsi_qla_host_t *vha , fc_port_t *fcport ) 
{ 
  int rval ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  struct qla_hw_data *ha ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 185
  ha = vha->hw;
#line 187
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 188
    tmp = qla2x00_sns_ga_nxt(vha, fcport);
#line 188
    return (tmp);
  } else {

  }
#line 192
  tmp___0 = (*((ha->isp_ops)->prep_ms_iocb))(vha, 20U, 636U);
#line 192
  ms_pkt = (ms_iocb_entry_t *)tmp___0;
#line 196
  ct_req = qla2x00_prep_ct_req(ha->ct_sns, 256, 636);
#line 198
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 201
  ct_req->req.port_id.port_id[0] = fcport->d_id.b.domain;
#line 202
  ct_req->req.port_id.port_id[1] = fcport->d_id.b.area;
#line 203
  ct_req->req.port_id.port_id[2] = fcport->d_id.b.al_pa;
#line 206
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 208
  if (rval != 0) {
#line 210
    ql_dbg(268435456U, vha, 8290, "GA_NXT issue IOCB failed (%d).\n", rval);
  } else {
#line 212
    tmp___1 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "GA_NXT");
#line 212
    if (tmp___1 != 0) {
#line 214
      rval = 258;
    } else {
#line 217
      fcport->d_id.b.domain = ct_rsp->rsp.ga_nxt.port_id[0];
#line 218
      fcport->d_id.b.area = ct_rsp->rsp.ga_nxt.port_id[1];
#line 219
      fcport->d_id.b.al_pa = ct_rsp->rsp.ga_nxt.port_id[2];
#line 221
      memcpy((void *)(& fcport->node_name), (void const   *)(& ct_rsp->rsp.ga_nxt.node_name),
               8UL);
#line 223
      memcpy((void *)(& fcport->port_name), (void const   *)(& ct_rsp->rsp.ga_nxt.port_name),
               8UL);
#line 226
      fcport->fc4_type = (int )ct_rsp->rsp.ga_nxt.fc4_types[2] & 1 ? 8U : 0U;
#line 229
      if ((unsigned int )ct_rsp->rsp.ga_nxt.port_type != 1U && (unsigned int )ct_rsp->rsp.ga_nxt.port_type != 2U) {
#line 231
        fcport->d_id.b.domain = 240U;
      } else {

      }
#line 233
      ql_dbg(268435456U, vha, 8291, "GA_NXT entry - nn %8phN pn %8phN port_id=%02x%02x%02x.\n",
             (uint8_t *)(& fcport->node_name), (uint8_t *)(& fcport->port_name), (int )fcport->d_id.b.domain,
             (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
    }
  }
#line 241
  return (rval);
}
}
#line 245 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
__inline static int qla2x00_gid_pt_rsp_size(scsi_qla_host_t *vha ) 
{ 


  {
#line 247
  return (((int )(vha->hw)->max_fibre_devices + 4) * 4);
}
}
#line 260 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
int qla2x00_gid_pt(scsi_qla_host_t *vha , sw_info_t *list ) 
{ 
  int rval ;
  uint16_t i ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  struct ct_sns_gid_pt_data *gid_data ;
  struct qla_hw_data *ha ;
  uint16_t gid_pt_rsp_size ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 270
  ha = vha->hw;
#line 273
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 274
    tmp = qla2x00_sns_gid_pt(vha, list);
#line 274
    return (tmp);
  } else {

  }
#line 276
  gid_data = (struct ct_sns_gid_pt_data *)0;
#line 277
  tmp___0 = qla2x00_gid_pt_rsp_size(vha);
#line 277
  gid_pt_rsp_size = (uint16_t )tmp___0;
#line 280
  tmp___1 = (*((ha->isp_ops)->prep_ms_iocb))(vha, 20U, (uint32_t )gid_pt_rsp_size);
#line 280
  ms_pkt = (ms_iocb_entry_t *)tmp___1;
#line 284
  ct_req = qla2x00_prep_ct_req(ha->ct_sns, 417, (int )gid_pt_rsp_size);
#line 285
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 288
  ct_req->req.gid_pt.port_type = 127U;
#line 291
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 293
  if (rval != 0) {
#line 295
    ql_dbg(268435456U, vha, 8277, "GID_PT issue IOCB failed (%d).\n", rval);
  } else {
#line 297
    tmp___2 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "GID_PT");
#line 297
    if (tmp___2 != 0) {
#line 299
      rval = 258;
    } else {
#line 302
      i = 0U;
#line 302
      goto ldv_65878;
      ldv_65877: 
#line 303
      gid_data = (struct ct_sns_gid_pt_data *)(& ct_rsp->rsp.gid_pt.entries) + (unsigned long )i;
#line 304
      (list + (unsigned long )i)->d_id.b.domain = gid_data->port_id[0];
#line 305
      (list + (unsigned long )i)->d_id.b.area = gid_data->port_id[1];
#line 306
      (list + (unsigned long )i)->d_id.b.al_pa = gid_data->port_id[2];
#line 307
      memset((void *)(& (list + (unsigned long )i)->fabric_port_name), 0, 8UL);
#line 308
      (list + (unsigned long )i)->fp_speed = 65535U;
#line 311
      if ((int )((signed char )gid_data->control_byte) < 0) {
#line 312
        (list + (unsigned long )i)->d_id.b.rsvd_1 = gid_data->control_byte;
#line 313
        goto ldv_65876;
      } else {

      }
#line 302
      i = (uint16_t )((int )i + 1);
      ldv_65878: ;
#line 302
      if ((int )ha->max_fibre_devices > (int )i) {
#line 304
        goto ldv_65877;
      } else {

      }
      ldv_65876: ;
#line 323
      if ((int )ha->max_fibre_devices == (int )i) {
#line 324
        rval = 258;
      } else {

      }
    }
  }
#line 327
  return (rval);
}
}
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
int qla2x00_gpn_id(scsi_qla_host_t *vha , sw_info_t *list ) 
{ 
  int rval ;
  uint16_t i ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  struct qla_hw_data *ha ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 340
  rval = 0;
#line 346
  ha = vha->hw;
#line 348
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 349
    tmp = qla2x00_sns_gpn_id(vha, list);
#line 349
    return (tmp);
  } else {

  }
#line 351
  i = 0U;
#line 351
  goto ldv_65891;
  ldv_65890: 
#line 354
  tmp___0 = (*((ha->isp_ops)->prep_ms_iocb))(vha, 20U, 24U);
#line 354
  ms_pkt = (ms_iocb_entry_t *)tmp___0;
#line 358
  ct_req = qla2x00_prep_ct_req(ha->ct_sns, 274, 24);
#line 360
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 363
  ct_req->req.port_id.port_id[0] = (list + (unsigned long )i)->d_id.b.domain;
#line 364
  ct_req->req.port_id.port_id[1] = (list + (unsigned long )i)->d_id.b.area;
#line 365
  ct_req->req.port_id.port_id[2] = (list + (unsigned long )i)->d_id.b.al_pa;
#line 368
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 370
  if (rval != 0) {
#line 372
    ql_dbg(268435456U, vha, 8278, "GPN_ID issue IOCB failed (%d).\n", rval);
#line 374
    goto ldv_65889;
  } else {
#line 375
    tmp___1 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "GPN_ID");
#line 375
    if (tmp___1 != 0) {
#line 377
      rval = 258;
#line 378
      goto ldv_65889;
    } else {
#line 381
      memcpy((void *)(& (list + (unsigned long )i)->port_name), (void const   *)(& ct_rsp->rsp.gpn_id.port_name),
               8UL);
    }
  }
#line 386
  if ((unsigned int )(list + (unsigned long )i)->d_id.b.rsvd_1 != 0U) {
#line 387
    goto ldv_65889;
  } else {

  }
#line 351
  i = (uint16_t )((int )i + 1);
  ldv_65891: ;
#line 351
  if ((int )ha->max_fibre_devices > (int )i) {
#line 353
    goto ldv_65890;
  } else {

  }
  ldv_65889: ;
#line 390
  return (rval);
}
}
#line 401 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
int qla2x00_gnn_id(scsi_qla_host_t *vha , sw_info_t *list ) 
{ 
  int rval ;
  uint16_t i ;
  struct qla_hw_data *ha ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 403
  rval = 0;
#line 405
  ha = vha->hw;
#line 410
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 411
    tmp = qla2x00_sns_gnn_id(vha, list);
#line 411
    return (tmp);
  } else {

  }
#line 413
  i = 0U;
#line 413
  goto ldv_65904;
  ldv_65903: 
#line 416
  tmp___0 = (*((ha->isp_ops)->prep_ms_iocb))(vha, 20U, 24U);
#line 416
  ms_pkt = (ms_iocb_entry_t *)tmp___0;
#line 420
  ct_req = qla2x00_prep_ct_req(ha->ct_sns, 275, 24);
#line 422
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 425
  ct_req->req.port_id.port_id[0] = (list + (unsigned long )i)->d_id.b.domain;
#line 426
  ct_req->req.port_id.port_id[1] = (list + (unsigned long )i)->d_id.b.area;
#line 427
  ct_req->req.port_id.port_id[2] = (list + (unsigned long )i)->d_id.b.al_pa;
#line 430
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 432
  if (rval != 0) {
#line 434
    ql_dbg(268435456U, vha, 8279, "GNN_ID issue IOCB failed (%d).\n", rval);
#line 436
    goto ldv_65902;
  } else {
#line 437
    tmp___1 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "GNN_ID");
#line 437
    if (tmp___1 != 0) {
#line 439
      rval = 258;
#line 440
      goto ldv_65902;
    } else {
#line 443
      memcpy((void *)(& (list + (unsigned long )i)->node_name), (void const   *)(& ct_rsp->rsp.gnn_id.node_name),
               8UL);
#line 446
      ql_dbg(268435456U, vha, 8280, "GID_PT entry - nn %8phN pn %8phN portid=%02x%02x%02x.\n",
             (uint8_t *)(& (list + (unsigned long )i)->node_name), (uint8_t *)(& (list + (unsigned long )i)->port_name),
             (int )(list + (unsigned long )i)->d_id.b.domain, (int )(list + (unsigned long )i)->d_id.b.area,
             (int )(list + (unsigned long )i)->d_id.b.al_pa);
    }
  }
#line 455
  if ((unsigned int )(list + (unsigned long )i)->d_id.b.rsvd_1 != 0U) {
#line 456
    goto ldv_65902;
  } else {

  }
#line 413
  i = (uint16_t )((int )i + 1);
  ldv_65904: ;
#line 413
  if ((int )ha->max_fibre_devices > (int )i) {
#line 415
    goto ldv_65903;
  } else {

  }
  ldv_65902: ;
#line 459
  return (rval);
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
int qla2x00_rft_id(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 472
  ha = vha->hw;
#line 477
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 478
    tmp = qla2x00_sns_rft_id(vha);
#line 478
    return (tmp);
  } else {

  }
#line 482
  tmp___0 = (*((ha->isp_ops)->prep_ms_iocb))(vha, 52U, 16U);
#line 482
  ms_pkt = (ms_iocb_entry_t *)tmp___0;
#line 486
  ct_req = qla2x00_prep_ct_req(ha->ct_sns, 535, 16);
#line 488
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 491
  ct_req->req.rft_id.port_id[0] = vha->d_id.b.domain;
#line 492
  ct_req->req.rft_id.port_id[1] = vha->d_id.b.area;
#line 493
  ct_req->req.rft_id.port_id[2] = vha->d_id.b.al_pa;
#line 495
  ct_req->req.rft_id.fc4_types[2] = 1U;
#line 498
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 500
  if (rval != 0) {
#line 502
    ql_dbg(268435456U, vha, 8259, "RFT_ID issue IOCB failed (%d).\n", rval);
  } else {
#line 504
    tmp___1 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "RFT_ID");
#line 504
    if (tmp___1 != 0) {
#line 506
      rval = 258;
    } else {
#line 508
      ql_dbg(268435456U, vha, 8260, "RFT_ID exiting normally.\n");
    }
  }
#line 512
  return (rval);
}
}
#line 522 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
int qla2x00_rff_id(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  void *tmp ;
  int tmp___0 ;

  {
#line 525
  ha = vha->hw;
#line 530
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 531
    ql_dbg(268435456U, vha, 8262, "RFF_ID call not supported on ISP2100/ISP2200.\n");
#line 533
    return (0);
  } else {

  }
#line 538
  tmp = (*((ha->isp_ops)->prep_ms_iocb))(vha, 24U, 16U);
#line 538
  ms_pkt = (ms_iocb_entry_t *)tmp;
#line 542
  ct_req = qla2x00_prep_ct_req(ha->ct_sns, 543, 16);
#line 544
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 547
  ct_req->req.rff_id.port_id[0] = vha->d_id.b.domain;
#line 548
  ct_req->req.rff_id.port_id[1] = vha->d_id.b.area;
#line 549
  ct_req->req.rff_id.port_id[2] = vha->d_id.b.al_pa;
#line 551
  qlt_rff_id(vha, ct_req);
#line 553
  ct_req->req.rff_id.fc4_type = 8U;
#line 556
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 558
  if (rval != 0) {
#line 560
    ql_dbg(268435456U, vha, 8263, "RFF_ID issue IOCB failed (%d).\n", rval);
  } else {
#line 562
    tmp___0 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "RFF_ID");
#line 562
    if (tmp___0 != 0) {
#line 564
      rval = 258;
    } else {
#line 566
      ql_dbg(268435456U, vha, 8264, "RFF_ID exiting normally.\n");
    }
  }
#line 570
  return (rval);
}
}
#line 580 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
int qla2x00_rnn_id(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 583
  ha = vha->hw;
#line 588
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 589
    tmp = qla2x00_sns_rnn_id(vha);
#line 589
    return (tmp);
  } else {

  }
#line 593
  tmp___0 = (*((ha->isp_ops)->prep_ms_iocb))(vha, 28U, 16U);
#line 593
  ms_pkt = (ms_iocb_entry_t *)tmp___0;
#line 597
  ct_req = qla2x00_prep_ct_req(ha->ct_sns, 531, 16);
#line 598
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 601
  ct_req->req.rnn_id.port_id[0] = vha->d_id.b.domain;
#line 602
  ct_req->req.rnn_id.port_id[1] = vha->d_id.b.area;
#line 603
  ct_req->req.rnn_id.port_id[2] = vha->d_id.b.al_pa;
#line 605
  memcpy((void *)(& ct_req->req.rnn_id.node_name), (void const   *)(& vha->node_name),
           8UL);
#line 608
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 610
  if (rval != 0) {
#line 612
    ql_dbg(268435456U, vha, 8269, "RNN_ID issue IOCB failed (%d).\n", rval);
  } else {
#line 614
    tmp___1 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "RNN_ID");
#line 614
    if (tmp___1 != 0) {
#line 616
      rval = 258;
    } else {
#line 618
      ql_dbg(268435456U, vha, 8270, "RNN_ID exiting normally.\n");
    }
  }
#line 622
  return (rval);
}
}
#line 626 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
void qla2x00_get_sym_node_name(scsi_qla_host_t *vha , uint8_t *snn , size_t size ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 628
  ha = vha->hw;
#line 630
  if ((ha->device_type & 131072U) != 0U) {
#line 631
    snprintf((char *)snn, size, "%s FW:v%s DVR:v%s", (uint8_t *)(& ha->model_number),
             (uint8_t *)(& ha->mr.fw_version), (char *)(& qla2x00_version_str));
  } else {
#line 634
    snprintf((char *)snn, size, "%s FW:v%d.%02d.%02d DVR:v%s", (uint8_t *)(& ha->model_number),
             (int )ha->fw_major_version, (int )ha->fw_minor_version, (int )ha->fw_subminor_version,
             (char *)(& qla2x00_version_str));
  }
#line 638
  return;
}
}
#line 647 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
int qla2x00_rsnn_nn(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 650
  ha = vha->hw;
#line 655
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 656
    ql_dbg(268435456U, vha, 8272, "RSNN_ID call unsupported on ISP2100/ISP2200.\n");
#line 658
    return (0);
  } else {

  }
#line 664
  tmp = (*((ha->isp_ops)->prep_ms_iocb))(vha, 0U, 16U);
#line 664
  ms_pkt = (ms_iocb_entry_t *)tmp;
#line 667
  ct_req = qla2x00_prep_ct_req(ha->ct_sns, 569, 16);
#line 669
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 672
  memcpy((void *)(& ct_req->req.rsnn_nn.node_name), (void const   *)(& vha->node_name),
           8UL);
#line 675
  qla2x00_get_sym_node_name(vha, (uint8_t *)(& ct_req->req.rsnn_nn.sym_node_name),
                            255UL);
#line 679
  tmp___0 = strlen((char const   *)(& ct_req->req.rsnn_nn.sym_node_name));
#line 679
  ct_req->req.rsnn_nn.name_len = (unsigned char )tmp___0;
#line 683
  ms_pkt->req_bytecount = (unsigned int )((int )ct_req->req.rsnn_nn.name_len + 25);
#line 685
  ms_pkt->dseg_req_length = ms_pkt->req_bytecount;
#line 688
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 690
  if (rval != 0) {
#line 692
    ql_dbg(268435456U, vha, 8273, "RSNN_NN issue IOCB failed (%d).\n", rval);
  } else {
#line 694
    tmp___1 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "RSNN_NN");
#line 694
    if (tmp___1 != 0) {
#line 696
      rval = 258;
    } else {
#line 698
      ql_dbg(268435456U, vha, 8274, "RSNN_NN exiting normally.\n");
    }
  }
#line 702
  return (rval);
}
}
#line 715 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
__inline static struct sns_cmd_pkt *qla2x00_prep_sns_cmd(scsi_qla_host_t *vha , uint16_t cmd ,
                                                         uint16_t scmd_len , uint16_t data_size ) 
{ 
  uint16_t wc ;
  struct sns_cmd_pkt *sns_cmd ;
  struct qla_hw_data *ha ;

  {
#line 720
  ha = vha->hw;
#line 722
  sns_cmd = ha->sns_cmd;
#line 723
  memset((void *)sns_cmd, 0, 2064UL);
#line 724
  wc = (uint16_t )((unsigned int )data_size / 2U);
#line 725
  sns_cmd->p.cmd.buffer_length = wc;
#line 726
  sns_cmd->p.cmd.buffer_address[0] = (unsigned int )ha->sns_cmd_dma;
#line 727
  sns_cmd->p.cmd.buffer_address[1] = (unsigned int )(ha->sns_cmd_dma >> 32ULL);
#line 728
  sns_cmd->p.cmd.subcommand_length = scmd_len;
#line 729
  sns_cmd->p.cmd.subcommand = cmd;
#line 730
  wc = (uint16_t )(((int )data_size + -16) / 4);
#line 731
  sns_cmd->p.cmd.size = wc;
#line 733
  vha->qla_stats.control_requests = vha->qla_stats.control_requests + 1U;
#line 735
  return (sns_cmd);
}
}
#line 748 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
static int qla2x00_sns_ga_nxt(scsi_qla_host_t *vha , fc_port_t *fcport ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  struct sns_cmd_pkt *sns_cmd ;

  {
#line 750
  rval = 0;
#line 751
  ha = vha->hw;
#line 756
  sns_cmd = qla2x00_prep_sns_cmd(vha, 256, 6, 636);
#line 760
  sns_cmd->p.cmd.param[0] = fcport->d_id.b.al_pa;
#line 761
  sns_cmd->p.cmd.param[1] = fcport->d_id.b.area;
#line 762
  sns_cmd->p.cmd.param[2] = fcport->d_id.b.domain;
#line 765
  rval = qla2x00_send_sns(vha, ha->sns_cmd_dma, 14, 2064UL);
#line 767
  if (rval != 0) {
#line 769
    ql_dbg(268435456U, vha, 8287, "GA_NXT Send SNS failed (%d).\n", rval);
  } else
#line 771
  if ((unsigned int )sns_cmd->p.gan_data[8] != 128U || (unsigned int )sns_cmd->p.gan_data[9] != 2U) {
#line 773
    ql_dbg(268566528U, vha, 8324, "GA_NXT failed, rejected request ga_nxt_rsp:\n");
#line 775
    ql_dump_buffer(268566528U, vha, 8308, (uint8_t *)(& sns_cmd->p.gan_data), 16U);
#line 777
    rval = 258;
  } else {
#line 780
    fcport->d_id.b.domain = sns_cmd->p.gan_data[17];
#line 781
    fcport->d_id.b.area = sns_cmd->p.gan_data[18];
#line 782
    fcport->d_id.b.al_pa = sns_cmd->p.gan_data[19];
#line 784
    memcpy((void *)(& fcport->node_name), (void const   *)(& sns_cmd->p.gan_data) + 284U,
             8UL);
#line 785
    memcpy((void *)(& fcport->port_name), (void const   *)(& sns_cmd->p.gan_data) + 20U,
             8UL);
#line 787
    if ((unsigned int )sns_cmd->p.gan_data[16] != 1U && (unsigned int )sns_cmd->p.gan_data[16] != 2U) {
#line 789
      fcport->d_id.b.domain = 240U;
    } else {

    }
#line 791
    ql_dbg(268435456U, vha, 8289, "GA_NXT entry - nn %8phN pn %8phN port_id=%02x%02x%02x.\n",
           (uint8_t *)(& fcport->node_name), (uint8_t *)(& fcport->port_name), (int )fcport->d_id.b.domain,
           (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
  }
#line 799
  return (rval);
}
}
#line 814 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
static int qla2x00_sns_gid_pt(scsi_qla_host_t *vha , sw_info_t *list ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  uint16_t i ;
  uint8_t *entry ;
  struct sns_cmd_pkt *sns_cmd ;
  uint16_t gid_pt_sns_data_size ;
  int tmp ;

  {
#line 817
  ha = vha->hw;
#line 823
  tmp = qla2x00_gid_pt_rsp_size(vha);
#line 823
  gid_pt_sns_data_size = (uint16_t )tmp;
#line 827
  sns_cmd = qla2x00_prep_sns_cmd(vha, 417, 6, (int )gid_pt_sns_data_size);
#line 831
  sns_cmd->p.cmd.param[0] = 127U;
#line 834
  rval = qla2x00_send_sns(vha, ha->sns_cmd_dma, 14, 2064UL);
#line 836
  if (rval != 0) {
#line 838
    ql_dbg(268435456U, vha, 8301, "GID_PT Send SNS failed (%d).\n", rval);
  } else
#line 840
  if ((unsigned int )sns_cmd->p.gid_data[8] != 128U || (unsigned int )sns_cmd->p.gid_data[9] != 2U) {
#line 842
    ql_dbg(268435456U, vha, 8239, "GID_PT failed, rejected request, gid_rsp:\n");
#line 844
    ql_dump_buffer(268566528U, vha, 8321, (uint8_t *)(& sns_cmd->p.gid_data), 16U);
#line 846
    rval = 258;
  } else {
#line 849
    i = 0U;
#line 849
    goto ldv_65971;
    ldv_65970: 
#line 850
    entry = (uint8_t *)(& sns_cmd->p.gid_data) + ((unsigned long )((int )i * 4) + 16UL);
#line 851
    (list + (unsigned long )i)->d_id.b.domain = *(entry + 1UL);
#line 852
    (list + (unsigned long )i)->d_id.b.area = *(entry + 2UL);
#line 853
    (list + (unsigned long )i)->d_id.b.al_pa = *(entry + 3UL);
#line 856
    if ((int )((signed char )*entry) < 0) {
#line 857
      (list + (unsigned long )i)->d_id.b.rsvd_1 = *entry;
#line 858
      goto ldv_65969;
    } else {

    }
#line 849
    i = (uint16_t )((int )i + 1);
    ldv_65971: ;
#line 849
    if ((int )ha->max_fibre_devices > (int )i) {
#line 851
      goto ldv_65970;
    } else {

    }
    ldv_65969: ;
#line 868
    if ((int )ha->max_fibre_devices == (int )i) {
#line 869
      rval = 258;
    } else {

    }
  }
#line 872
  return (rval);
}
}
#line 885 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
static int qla2x00_sns_gpn_id(scsi_qla_host_t *vha , sw_info_t *list ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  uint16_t i ;
  struct sns_cmd_pkt *sns_cmd ;

  {
#line 887
  rval = 0;
#line 888
  ha = vha->hw;
#line 892
  i = 0U;
#line 892
  goto ldv_65982;
  ldv_65981: 
#line 895
  sns_cmd = qla2x00_prep_sns_cmd(vha, 274, 6, 24);
#line 899
  sns_cmd->p.cmd.param[0] = (list + (unsigned long )i)->d_id.b.al_pa;
#line 900
  sns_cmd->p.cmd.param[1] = (list + (unsigned long )i)->d_id.b.area;
#line 901
  sns_cmd->p.cmd.param[2] = (list + (unsigned long )i)->d_id.b.domain;
#line 904
  rval = qla2x00_send_sns(vha, ha->sns_cmd_dma, 14, 2064UL);
#line 906
  if (rval != 0) {
#line 908
    ql_dbg(268435456U, vha, 8242, "GPN_ID Send SNS failed (%d).\n", rval);
  } else
#line 910
  if ((unsigned int )sns_cmd->p.gpn_data[8] != 128U || (unsigned int )sns_cmd->p.gpn_data[9] != 2U) {
#line 912
    ql_dbg(268566528U, vha, 8318, "GPN_ID failed, rejected request, gpn_rsp:\n");
#line 914
    ql_dump_buffer(268566528U, vha, 8319, (uint8_t *)(& sns_cmd->p.gpn_data), 16U);
#line 916
    rval = 258;
  } else {
#line 919
    memcpy((void *)(& (list + (unsigned long )i)->port_name), (void const   *)(& sns_cmd->p.gpn_data) + 16U,
             8UL);
  }
#line 924
  if ((unsigned int )(list + (unsigned long )i)->d_id.b.rsvd_1 != 0U) {
#line 925
    goto ldv_65980;
  } else {

  }
#line 892
  i = (uint16_t )((int )i + 1);
  ldv_65982: ;
#line 892
  if ((int )ha->max_fibre_devices > (int )i) {
#line 894
    goto ldv_65981;
  } else {

  }
  ldv_65980: ;
#line 928
  return (rval);
}
}
#line 941 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
static int qla2x00_sns_gnn_id(scsi_qla_host_t *vha , sw_info_t *list ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  uint16_t i ;
  struct sns_cmd_pkt *sns_cmd ;

  {
#line 943
  rval = 0;
#line 944
  ha = vha->hw;
#line 948
  i = 0U;
#line 948
  goto ldv_65993;
  ldv_65992: 
#line 951
  sns_cmd = qla2x00_prep_sns_cmd(vha, 275, 6, 24);
#line 955
  sns_cmd->p.cmd.param[0] = (list + (unsigned long )i)->d_id.b.al_pa;
#line 956
  sns_cmd->p.cmd.param[1] = (list + (unsigned long )i)->d_id.b.area;
#line 957
  sns_cmd->p.cmd.param[2] = (list + (unsigned long )i)->d_id.b.domain;
#line 960
  rval = qla2x00_send_sns(vha, ha->sns_cmd_dma, 14, 2064UL);
#line 962
  if (rval != 0) {
#line 964
    ql_dbg(268435456U, vha, 8255, "GNN_ID Send SNS failed (%d).\n", rval);
  } else
#line 966
  if ((unsigned int )sns_cmd->p.gnn_data[8] != 128U || (unsigned int )sns_cmd->p.gnn_data[9] != 2U) {
#line 968
    ql_dbg(268566528U, vha, 8322, "GNN_ID failed, rejected request, gnn_rsp:\n");
#line 970
    ql_dump_buffer(268566528U, vha, 8314, (uint8_t *)(& sns_cmd->p.gnn_data), 16U);
#line 972
    rval = 258;
  } else {
#line 975
    memcpy((void *)(& (list + (unsigned long )i)->node_name), (void const   *)(& sns_cmd->p.gnn_data) + 16U,
             8UL);
#line 978
    ql_dbg(268435456U, vha, 8302, "GID_PT entry - nn %8phN pn %8phN port_id=%02x%02x%02x.\n",
           (uint8_t *)(& (list + (unsigned long )i)->node_name), (uint8_t *)(& (list + (unsigned long )i)->port_name),
           (int )(list + (unsigned long )i)->d_id.b.domain, (int )(list + (unsigned long )i)->d_id.b.area,
           (int )(list + (unsigned long )i)->d_id.b.al_pa);
  }
#line 987
  if ((unsigned int )(list + (unsigned long )i)->d_id.b.rsvd_1 != 0U) {
#line 988
    goto ldv_65991;
  } else {

  }
#line 948
  i = (uint16_t )((int )i + 1);
  ldv_65993: ;
#line 948
  if ((int )ha->max_fibre_devices > (int )i) {
#line 950
    goto ldv_65992;
  } else {

  }
  ldv_65991: ;
#line 991
  return (rval);
}
}
#line 1003 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
static int qla2x00_sns_rft_id(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  struct sns_cmd_pkt *sns_cmd ;

  {
#line 1006
  ha = vha->hw;
#line 1011
  sns_cmd = qla2x00_prep_sns_cmd(vha, 535, 22, 16);
#line 1015
  sns_cmd->p.cmd.param[0] = vha->d_id.b.al_pa;
#line 1016
  sns_cmd->p.cmd.param[1] = vha->d_id.b.area;
#line 1017
  sns_cmd->p.cmd.param[2] = vha->d_id.b.domain;
#line 1019
  sns_cmd->p.cmd.param[5] = 1U;
#line 1022
  rval = qla2x00_send_sns(vha, ha->sns_cmd_dma, 30, 2064UL);
#line 1024
  if (rval != 0) {
#line 1026
    ql_dbg(268435456U, vha, 8288, "RFT_ID Send SNS failed (%d).\n", rval);
  } else
#line 1028
  if ((unsigned int )sns_cmd->p.rft_data[8] != 128U || (unsigned int )sns_cmd->p.rft_data[9] != 2U) {
#line 1030
    ql_dbg(268566528U, vha, 8323, "RFT_ID failed, rejected request rft_rsp:\n");
#line 1032
    ql_dump_buffer(268566528U, vha, 8320, (uint8_t *)(& sns_cmd->p.rft_data), 16U);
#line 1034
    rval = 258;
  } else {
#line 1036
    ql_dbg(268435456U, vha, 8307, "RFT_ID exiting normally.\n");
  }
#line 1040
  return (rval);
}
}
#line 1053 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
static int qla2x00_sns_rnn_id(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  struct sns_cmd_pkt *sns_cmd ;

  {
#line 1056
  ha = vha->hw;
#line 1061
  sns_cmd = qla2x00_prep_sns_cmd(vha, 531, 10, 16);
#line 1065
  sns_cmd->p.cmd.param[0] = vha->d_id.b.al_pa;
#line 1066
  sns_cmd->p.cmd.param[1] = vha->d_id.b.area;
#line 1067
  sns_cmd->p.cmd.param[2] = vha->d_id.b.domain;
#line 1069
  sns_cmd->p.cmd.param[4] = vha->node_name[7];
#line 1070
  sns_cmd->p.cmd.param[5] = vha->node_name[6];
#line 1071
  sns_cmd->p.cmd.param[6] = vha->node_name[5];
#line 1072
  sns_cmd->p.cmd.param[7] = vha->node_name[4];
#line 1073
  sns_cmd->p.cmd.param[8] = vha->node_name[3];
#line 1074
  sns_cmd->p.cmd.param[9] = vha->node_name[2];
#line 1075
  sns_cmd->p.cmd.param[10] = vha->node_name[1];
#line 1076
  sns_cmd->p.cmd.param[11] = vha->node_name[0];
#line 1079
  rval = qla2x00_send_sns(vha, ha->sns_cmd_dma, 18, 2064UL);
#line 1081
  if (rval != 0) {
#line 1083
    ql_dbg(268435456U, vha, 8266, "RNN_ID Send SNS failed (%d).\n", rval);
  } else
#line 1085
  if ((unsigned int )sns_cmd->p.rnn_data[8] != 128U || (unsigned int )sns_cmd->p.rnn_data[9] != 2U) {
#line 1087
    ql_dbg(268566528U, vha, 8315, "RNN_ID failed, rejected request, rnn_rsp:\n");
#line 1089
    ql_dump_buffer(268566528U, vha, 8316, (uint8_t *)(& sns_cmd->p.rnn_data), 16U);
#line 1091
    rval = 258;
  } else {
#line 1093
    ql_dbg(268435456U, vha, 8268, "RNN_ID exiting normally.\n");
  }
#line 1097
  return (rval);
}
}
#line 1107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
static int qla2x00_mgmt_svr_login(scsi_qla_host_t *vha ) 
{ 
  int ret ;
  int rval ;
  uint16_t mb[32U] ;
  struct qla_hw_data *ha ;

  {
#line 1111
  ha = vha->hw;
#line 1112
  ret = 0;
#line 1113
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 1114
    return (ret);
  } else {

  }
#line 1116
  rval = (*((ha->isp_ops)->fabric_login))(vha, (int )vha->mgmt_svr_loop_id, 255, 255,
                                          250, (uint16_t *)(& mb), 2);
#line 1118
  if (rval != 0 || (unsigned int )mb[0] != 16384U) {
#line 1119
    if (rval == 259) {
#line 1120
      ql_dbg(268435456U, vha, 8325, "Failed management_server login: loopid=%x rval=%d\n",
             (int )vha->mgmt_svr_loop_id, rval);
    } else {
#line 1124
      ql_dbg(268435456U, vha, 8228, "Failed management_server login: loopid=%x mb[0]=%x mb[1]=%x mb[2]=%x mb[6]=%x mb[7]=%x.\n",
             (int )vha->mgmt_svr_loop_id, (int )mb[0], (int )mb[1], (int )mb[2], (int )mb[6],
             (int )mb[7]);
    }
#line 1129
    ret = 258;
  } else {
#line 1131
    vha->flags.management_server_logged_in = 1U;
  }
#line 1133
  return (ret);
}
}
#line 1145 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
void *qla2x00_prep_ms_fdmi_iocb(scsi_qla_host_t *vha , uint32_t req_size , uint32_t rsp_size ) 
{ 
  ms_iocb_entry_t *ms_pkt ;
  struct qla_hw_data *ha ;

  {
#line 1149
  ha = vha->hw;
#line 1150
  ms_pkt = ha->ms_iocb;
#line 1151
  memset((void *)ms_pkt, 0, 64UL);
#line 1153
  ms_pkt->entry_type = 41U;
#line 1154
  ms_pkt->entry_count = 1U;
#line 1155
  if ((int )ha->device_type < 0) {
#line 1155
    ms_pkt->loop_id.extended = vha->mgmt_svr_loop_id;
  } else {
#line 1155
    ms_pkt->loop_id.id.standard = (unsigned char )vha->mgmt_svr_loop_id;
  }
#line 1156
  ms_pkt->control_flags = 34U;
#line 1157
  ms_pkt->timeout = ((unsigned int )ha->r_a_tov / 10U) * 2U;
#line 1158
  ms_pkt->cmd_dsd_count = 1U;
#line 1159
  ms_pkt->total_dsd_count = 2U;
#line 1160
  ms_pkt->rsp_bytecount = rsp_size;
#line 1161
  ms_pkt->req_bytecount = req_size;
#line 1163
  ms_pkt->dseg_req_address[0] = (unsigned int )ha->ct_sns_dma;
#line 1164
  ms_pkt->dseg_req_address[1] = (unsigned int )(ha->ct_sns_dma >> 32ULL);
#line 1165
  ms_pkt->dseg_req_length = ms_pkt->req_bytecount;
#line 1167
  ms_pkt->dseg_rsp_address[0] = (unsigned int )ha->ct_sns_dma;
#line 1168
  ms_pkt->dseg_rsp_address[1] = (unsigned int )(ha->ct_sns_dma >> 32ULL);
#line 1169
  ms_pkt->dseg_rsp_length = ms_pkt->rsp_bytecount;
#line 1171
  return ((void *)ms_pkt);
}
}
#line 1183 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
void *qla24xx_prep_ms_fdmi_iocb(scsi_qla_host_t *vha , uint32_t req_size , uint32_t rsp_size ) 
{ 
  struct ct_entry_24xx *ct_pkt ;
  struct qla_hw_data *ha ;

  {
#line 1187
  ha = vha->hw;
#line 1189
  ct_pkt = (struct ct_entry_24xx *)ha->ms_iocb;
#line 1190
  memset((void *)ct_pkt, 0, 64UL);
#line 1192
  ct_pkt->entry_type = 41U;
#line 1193
  ct_pkt->entry_count = 1U;
#line 1194
  ct_pkt->nport_handle = vha->mgmt_svr_loop_id;
#line 1195
  ct_pkt->timeout = ((unsigned int )ha->r_a_tov / 10U) * 2U;
#line 1196
  ct_pkt->cmd_dsd_count = 1U;
#line 1197
  ct_pkt->rsp_dsd_count = 1U;
#line 1198
  ct_pkt->rsp_byte_count = rsp_size;
#line 1199
  ct_pkt->cmd_byte_count = req_size;
#line 1201
  ct_pkt->dseg_0_address[0] = (unsigned int )ha->ct_sns_dma;
#line 1202
  ct_pkt->dseg_0_address[1] = (unsigned int )(ha->ct_sns_dma >> 32ULL);
#line 1203
  ct_pkt->dseg_0_len = ct_pkt->cmd_byte_count;
#line 1205
  ct_pkt->dseg_1_address[0] = (unsigned int )ha->ct_sns_dma;
#line 1206
  ct_pkt->dseg_1_address[1] = (unsigned int )(ha->ct_sns_dma >> 32ULL);
#line 1207
  ct_pkt->dseg_1_len = ct_pkt->rsp_byte_count;
#line 1208
  ct_pkt->vp_index = (uint8_t )vha->vp_idx;
#line 1210
  return ((void *)ct_pkt);
}
}
#line 1214 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
__inline static ms_iocb_entry_t *qla2x00_update_ms_fdmi_iocb(scsi_qla_host_t *vha ,
                                                             uint32_t req_size ) 
{ 
  struct qla_hw_data *ha ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_entry_24xx *ct_pkt ;

  {
#line 1216
  ha = vha->hw;
#line 1217
  ms_pkt = ha->ms_iocb;
#line 1218
  ct_pkt = (struct ct_entry_24xx *)ha->ms_iocb;
#line 1220
  if ((ha->device_type & 134217728U) != 0U) {
#line 1221
    ct_pkt->cmd_byte_count = req_size;
#line 1222
    ct_pkt->dseg_0_len = ct_pkt->cmd_byte_count;
  } else {
#line 1224
    ms_pkt->req_bytecount = req_size;
#line 1225
    ms_pkt->dseg_req_length = ms_pkt->req_bytecount;
  }
#line 1228
  return (ms_pkt);
}
}
#line 1240 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
__inline static struct ct_sns_req *qla2x00_prep_ct_fdmi_req(struct ct_sns_pkt *p ,
                                                            uint16_t cmd , uint16_t rsp_size ) 
{ 
  __u16 tmp ;
  __u16 tmp___0 ;

  {
#line 1243
  memset((void *)p, 0, 8208UL);
#line 1245
  p->p.req.header.revision = 1U;
#line 1246
  p->p.req.header.gs_type = 250U;
#line 1247
  p->p.req.header.gs_subtype = 16U;
#line 1248
  tmp = __fswab16((int )cmd);
#line 1248
  p->p.req.command = tmp;
#line 1249
  tmp___0 = __fswab16((int )((__u16 )(((int )rsp_size + -16) / 4)));
#line 1249
  p->p.req.max_rsp_size = tmp___0;
#line 1251
  return (& p->p.req);
}
}
#line 1261 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
static int qla2x00_fdmi_rhba(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  int alen ;
  uint32_t size ;
  uint32_t sn ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  void *entries ;
  struct ct_fdmi_hba_attr *eiter ;
  struct qla_hw_data *ha ;
  void *tmp ;
  size_t tmp___0 ;
  __u16 tmp___1 ;
  size_t tmp___2 ;
  __u16 tmp___3 ;
  size_t tmp___4 ;
  __u16 tmp___5 ;
  size_t tmp___6 ;
  __u16 tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  __u16 tmp___11 ;
  size_t tmp___12 ;
  __u16 tmp___13 ;
  size_t tmp___14 ;
  __u16 tmp___15 ;
  size_t tmp___16 ;
  __u16 tmp___17 ;
  int tmp___18 ;

  {
#line 1271
  ha = vha->hw;
#line 1276
  tmp = (*((ha->isp_ops)->prep_ms_fdmi_iocb))(vha, 0U, 16U);
#line 1276
  ms_pkt = (ms_iocb_entry_t *)tmp;
#line 1279
  ct_req = qla2x00_prep_ct_fdmi_req(ha->ct_sns, 512, 16);
#line 1280
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 1283
  memcpy((void *)(& ct_req->req.rhba.hba_identifier), (void const   *)(& vha->port_name),
           8UL);
#line 1284
  ct_req->req.rhba.entry_count = 16777216U;
#line 1285
  memcpy((void *)(& ct_req->req.rhba.port_name), (void const   *)(& vha->port_name),
           8UL);
#line 1286
  size = 24U;
#line 1289
  ct_req->req.rhba.attrs.count = 150994944U;
#line 1291
  entries = (void *)(& ct_req->req.rhba.hba_identifier);
#line 1294
  eiter = (struct ct_fdmi_hba_attr *)entries + (unsigned long )size;
#line 1295
  eiter->type = 256U;
#line 1296
  eiter->len = 3072U;
#line 1297
  memcpy((void *)(& eiter->a.node_name), (void const   *)(& vha->node_name), 8UL);
#line 1298
  size = size + 12U;
#line 1300
  ql_dbg(268435456U, vha, 8229, "NodeName = %8phN.\n", (uint8_t *)(& eiter->a.node_name));
#line 1304
  eiter = (struct ct_fdmi_hba_attr *)entries + (unsigned long )size;
#line 1305
  eiter->type = 512U;
#line 1306
  tmp___0 = strlen("QLogic Corporation");
#line 1306
  alen = (int )tmp___0;
#line 1307
  snprintf((char *)(& eiter->a.manufacturer), 64UL, "%s", (char *)"QLogic Corporation");
#line 1309
  alen = (4 - (alen & 3)) + alen;
#line 1310
  tmp___1 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1310
  eiter->len = tmp___1;
#line 1311
  size = ((uint32_t )alen + size) + 4U;
#line 1313
  ql_dbg(268435456U, vha, 8230, "Manufacturer = %s.\n", (uint8_t *)(& eiter->a.manufacturer));
#line 1317
  eiter = (struct ct_fdmi_hba_attr *)entries + (unsigned long )size;
#line 1318
  eiter->type = 768U;
#line 1319
  if ((ha->device_type & 134217728U) != 0U) {
#line 1320
    qla2xxx_get_vpd_field(vha, (char *)"SN", (char *)(& eiter->a.serial_num), 32UL);
  } else {
#line 1323
    sn = (uint32_t )(((((int )ha->serial0 & 31) << 16) | ((int )ha->serial2 << 8)) | (int )ha->serial1);
#line 1325
    snprintf((char *)(& eiter->a.serial_num), 32UL, "%c%05d", sn / 100000U + 65U,
             sn % 100000U);
  }
#line 1328
  tmp___2 = strlen((char const   *)(& eiter->a.serial_num));
#line 1328
  alen = (int )tmp___2;
#line 1329
  alen = (4 - (alen & 3)) + alen;
#line 1330
  tmp___3 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1330
  eiter->len = tmp___3;
#line 1331
  size = ((uint32_t )alen + size) + 4U;
#line 1333
  ql_dbg(268435456U, vha, 8231, "Serial no. = %s.\n", (uint8_t *)(& eiter->a.serial_num));
#line 1337
  eiter = (struct ct_fdmi_hba_attr *)entries + (unsigned long )size;
#line 1338
  eiter->type = 1024U;
#line 1339
  snprintf((char *)(& eiter->a.model), 17UL, "%s", (uint8_t *)(& ha->model_number));
#line 1341
  tmp___4 = strlen((char const   *)(& eiter->a.model));
#line 1341
  alen = (int )tmp___4;
#line 1342
  alen = (4 - (alen & 3)) + alen;
#line 1343
  tmp___5 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1343
  eiter->len = tmp___5;
#line 1344
  size = ((uint32_t )alen + size) + 4U;
#line 1346
  ql_dbg(268435456U, vha, 8232, "Model Name = %s.\n", (uint8_t *)(& eiter->a.model));
#line 1350
  eiter = (struct ct_fdmi_hba_attr *)entries + (unsigned long )size;
#line 1351
  eiter->type = 1280U;
#line 1352
  snprintf((char *)(& eiter->a.model_desc), 80UL, "%s", (char *)(& ha->model_desc));
#line 1354
  tmp___6 = strlen((char const   *)(& eiter->a.model_desc));
#line 1354
  alen = (int )tmp___6;
#line 1355
  alen = (4 - (alen & 3)) + alen;
#line 1356
  tmp___7 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1356
  eiter->len = tmp___7;
#line 1357
  size = ((uint32_t )alen + size) + 4U;
#line 1359
  ql_dbg(268435456U, vha, 8233, "Model Desc = %s.\n", (uint8_t *)(& eiter->a.model_desc));
#line 1363
  eiter = (struct ct_fdmi_hba_attr *)entries + (unsigned long )size;
#line 1364
  eiter->type = 1536U;
#line 1365
  if ((ha->device_type & 134217728U) == 0U) {
#line 1366
    snprintf((char *)(& eiter->a.hw_version), 32UL, "HW:%s", (uint8_t *)(& ha->adapter_id));
  } else {
#line 1368
    tmp___9 = qla2xxx_get_vpd_field(vha, (char *)"MN", (char *)(& eiter->a.hw_version),
                                    32UL);
#line 1368
    if (tmp___9 != 0) {

    } else {
#line 1371
      tmp___8 = qla2xxx_get_vpd_field(vha, (char *)"EC", (char *)(& eiter->a.hw_version),
                                      32UL);
#line 1371
      if (tmp___8 != 0) {

      } else {
#line 1375
        snprintf((char *)(& eiter->a.hw_version), 32UL, "HW:%s", (uint8_t *)(& ha->adapter_id));
      }
    }
  }
#line 1378
  tmp___10 = strlen((char const   *)(& eiter->a.hw_version));
#line 1378
  alen = (int )tmp___10;
#line 1379
  alen = (4 - (alen & 3)) + alen;
#line 1380
  tmp___11 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1380
  eiter->len = tmp___11;
#line 1381
  size = ((uint32_t )alen + size) + 4U;
#line 1383
  ql_dbg(268435456U, vha, 8234, "Hardware ver = %s.\n", (uint8_t *)(& eiter->a.hw_version));
#line 1387
  eiter = (struct ct_fdmi_hba_attr *)entries + (unsigned long )size;
#line 1388
  eiter->type = 1792U;
#line 1389
  snprintf((char *)(& eiter->a.driver_version), 32UL, "%s", (char *)(& qla2x00_version_str));
#line 1391
  tmp___12 = strlen((char const   *)(& eiter->a.driver_version));
#line 1391
  alen = (int )tmp___12;
#line 1392
  alen = (4 - (alen & 3)) + alen;
#line 1393
  tmp___13 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1393
  eiter->len = tmp___13;
#line 1394
  size = ((uint32_t )alen + size) + 4U;
#line 1396
  ql_dbg(268435456U, vha, 8235, "Driver ver = %s.\n", (uint8_t *)(& eiter->a.driver_version));
#line 1400
  eiter = (struct ct_fdmi_hba_attr *)entries + (unsigned long )size;
#line 1401
  eiter->type = 2048U;
#line 1402
  snprintf((char *)(& eiter->a.orom_version), 16UL, "%d.%02d", (int )ha->bios_revision[1],
           (int )ha->bios_revision[0]);
#line 1404
  tmp___14 = strlen((char const   *)(& eiter->a.orom_version));
#line 1404
  alen = (int )tmp___14;
#line 1405
  alen = (4 - (alen & 3)) + alen;
#line 1406
  tmp___15 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1406
  eiter->len = tmp___15;
#line 1407
  size = ((uint32_t )alen + size) + 4U;
#line 1409
  ql_dbg(268435456U, vha, 8236, "Optrom vers = %s.\n", (uint8_t *)(& eiter->a.orom_version));
#line 1413
  eiter = (struct ct_fdmi_hba_attr *)entries + (unsigned long )size;
#line 1414
  eiter->type = 2304U;
#line 1415
  (*((ha->isp_ops)->fw_version_str))(vha, (char *)(& eiter->a.fw_version), 32UL);
#line 1417
  tmp___16 = strlen((char const   *)(& eiter->a.fw_version));
#line 1417
  alen = (int )tmp___16;
#line 1418
  alen = (4 - (alen & 3)) + alen;
#line 1419
  tmp___17 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1419
  eiter->len = tmp___17;
#line 1420
  size = ((uint32_t )alen + size) + 4U;
#line 1422
  ql_dbg(268435456U, vha, 8237, "Firmware vers = %s.\n", (uint8_t *)(& eiter->a.fw_version));
#line 1426
  qla2x00_update_ms_fdmi_iocb(vha, size + 16U);
#line 1428
  ql_dbg(268435456U, vha, 8238, "RHBA identifier = %8phN size=%d.\n", (uint8_t *)(& ct_req->req.rhba.hba_identifier),
         size);
#line 1431
  ql_dump_buffer(268566528U, vha, 8310, (uint8_t *)entries, size);
#line 1435
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 1437
  if (rval != 0) {
#line 1439
    ql_dbg(268435456U, vha, 8240, "RHBA issue IOCB failed (%d).\n", rval);
  } else {
#line 1441
    tmp___18 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "RHBA");
#line 1441
    if (tmp___18 != 0) {
#line 1443
      rval = 258;
#line 1444
      if ((unsigned int )ct_rsp->header.reason_code == 9U && (unsigned int )ct_rsp->header.explanation_code == 16U) {
#line 1447
        ql_dbg(268435456U, vha, 8244, "HBA already registered.\n");
#line 1449
        rval = 265;
      } else {
#line 1451
        ql_dbg(268435456U, vha, 8365, "RHBA FDMI registration failed, CT Reason code: 0x%x, CT Explanation 0x%x\n",
               (int )ct_rsp->header.reason_code, (int )ct_rsp->header.explanation_code);
      }
    } else {
#line 1457
      ql_dbg(268435456U, vha, 8245, "RHBA exiting normally.\n");
    }
  }
#line 1461
  return (rval);
}
}
#line 1471 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
static int qla2x00_fdmi_rpa(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  int alen ;
  uint32_t size ;
  struct qla_hw_data *ha ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  void *entries ;
  struct ct_fdmi_port_attr *eiter ;
  struct init_cb_24xx *icb24 ;
  struct new_utsname *p_sysid ;
  void *tmp ;
  __u32 tmp___0 ;
  size_t tmp___1 ;
  __u16 tmp___2 ;
  size_t tmp___3 ;
  __u16 tmp___4 ;
  u64 tmp___5 ;
  int tmp___6 ;

  {
#line 1475
  ha = vha->hw;
#line 1481
  icb24 = (struct init_cb_24xx *)ha->init_cb;
#line 1482
  p_sysid = (struct new_utsname *)0;
#line 1487
  tmp = (*((ha->isp_ops)->prep_ms_fdmi_iocb))(vha, 0U, 16U);
#line 1487
  ms_pkt = (ms_iocb_entry_t *)tmp;
#line 1490
  ct_req = qla2x00_prep_ct_fdmi_req(ha->ct_sns, 529, 16);
#line 1492
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 1495
  memcpy((void *)(& ct_req->req.rpa.port_name), (void const   *)(& vha->port_name),
           8UL);
#line 1496
  size = 12U;
#line 1499
  ct_req->req.rpa.attrs.count = 100663296U;
#line 1500
  entries = (void *)(& ct_req->req.rpa.port_name);
#line 1503
  eiter = (struct ct_fdmi_port_attr *)entries + (unsigned long )size;
#line 1504
  eiter->type = 256U;
#line 1505
  eiter->len = 9216U;
#line 1506
  eiter->a.fc4_types[2] = 1U;
#line 1507
  size = size + 36U;
#line 1509
  ql_dbg(268435456U, vha, 8249, "FC4_TYPES=%02x %02x.\n", (int )eiter->a.fc4_types[2],
         (int )eiter->a.fc4_types[1]);
#line 1515
  eiter = (struct ct_fdmi_port_attr *)entries + (unsigned long )size;
#line 1516
  eiter->type = 512U;
#line 1517
  eiter->len = 2048U;
#line 1518
  if ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 1519
    eiter->a.sup_speed = 67108864U;
  } else
#line 1521
  if ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) {
#line 1522
    eiter->a.sup_speed = 1879048192U;
  } else
#line 1526
  if ((ha->device_type & 32768U) != 0U) {
#line 1527
    eiter->a.sup_speed = 939524096U;
  } else
#line 1531
  if ((ha->device_type & 2048U) != 0U) {
#line 1532
    eiter->a.sup_speed = 452984832U;
  } else
#line 1537
  if ((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || ((ha->device_type & 512U) != 0U || (ha->device_type & 1024U) != 0U)) || (ha->device_type & 4096U) != 0U) {
#line 1538
    eiter->a.sup_speed = 184549376U;
  } else
#line 1542
  if (((((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 16U) != 0U) || (ha->device_type & 32U) != 0U) || (ha->device_type & 64U) != 0U) {
#line 1543
    eiter->a.sup_speed = 50331648U;
  } else {
#line 1547
    eiter->a.sup_speed = 16777216U;
  }
#line 1549
  size = size + 8U;
#line 1551
  ql_dbg(268435456U, vha, 8250, "Supported_Speed=%x.\n", eiter->a.sup_speed);
#line 1555
  eiter = (struct ct_fdmi_port_attr *)entries + (unsigned long )size;
#line 1556
  eiter->type = 768U;
#line 1557
  eiter->len = 2048U;
#line 1558
  switch ((int )ha->link_data_rate) {
  case 0: 
#line 1560
  eiter->a.cur_speed = 16777216U;
#line 1562
  goto ldv_66067;
  case 1: 
#line 1564
  eiter->a.cur_speed = 33554432U;
#line 1566
  goto ldv_66067;
  case 3: 
#line 1568
  eiter->a.cur_speed = 134217728U;
#line 1570
  goto ldv_66067;
  case 4: 
#line 1572
  eiter->a.cur_speed = 268435456U;
#line 1574
  goto ldv_66067;
  case 19: 
#line 1576
  eiter->a.cur_speed = 67108864U;
#line 1578
  goto ldv_66067;
  case 5: 
#line 1580
  eiter->a.cur_speed = 536870912U;
#line 1582
  goto ldv_66067;
  case 6: 
#line 1584
  eiter->a.cur_speed = 1073741824U;
#line 1586
  goto ldv_66067;
  default: 
#line 1588
  eiter->a.cur_speed = 8388608U;
#line 1590
  goto ldv_66067;
  }
  ldv_66067: 
#line 1592
  size = size + 8U;
#line 1594
  ql_dbg(268435456U, vha, 8251, "Current_Speed=%x.\n", eiter->a.cur_speed);
#line 1598
  eiter = (struct ct_fdmi_port_attr *)entries + (unsigned long )size;
#line 1599
  eiter->type = 1024U;
#line 1600
  eiter->len = 2048U;
#line 1601
  eiter->a.max_frame_size = (uint32_t )((ha->device_type & 134217728U) != 0U ? icb24->frame_payload_size : (ha->init_cb)->frame_payload_size);
#line 1604
  tmp___0 = __fswab32(eiter->a.max_frame_size);
#line 1604
  eiter->a.max_frame_size = tmp___0;
#line 1605
  size = size + 8U;
#line 1607
  ql_dbg(268435456U, vha, 8252, "Max_Frame_Size=%x.\n", eiter->a.max_frame_size);
#line 1611
  eiter = (struct ct_fdmi_port_attr *)entries + (unsigned long )size;
#line 1612
  eiter->type = 1280U;
#line 1613
  snprintf((char *)(& eiter->a.os_dev_name), 32UL, "%s:host%lu", (char *)"qla2xxx",
           vha->host_no);
#line 1615
  tmp___1 = strlen((char const   *)(& eiter->a.os_dev_name));
#line 1615
  alen = (int )tmp___1;
#line 1616
  alen = (4 - (alen & 3)) + alen;
#line 1617
  tmp___2 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1617
  eiter->len = tmp___2;
#line 1618
  size = ((uint32_t )alen + size) + 4U;
#line 1620
  ql_dbg(268435456U, vha, 8267, "OS_Device_Name=%s.\n", (uint8_t *)(& eiter->a.os_dev_name));
#line 1624
  eiter = (struct ct_fdmi_port_attr *)entries + (unsigned long )size;
#line 1625
  eiter->type = 1536U;
#line 1626
  p_sysid = utsname();
#line 1627
  if ((unsigned long )p_sysid != (unsigned long )((struct new_utsname *)0)) {
#line 1628
    snprintf((char *)(& eiter->a.host_name), 256UL, "%s", (char *)(& p_sysid->nodename));
  } else {
#line 1631
    snprintf((char *)(& eiter->a.host_name), 256UL, "%s", (char *)(& ((struct fc_host_attrs *)(vha->host)->shost_data)->system_hostname));
  }
#line 1634
  tmp___3 = strlen((char const   *)(& eiter->a.host_name));
#line 1634
  alen = (int )tmp___3;
#line 1635
  alen = (4 - (alen & 3)) + alen;
#line 1636
  tmp___4 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1636
  eiter->len = tmp___4;
#line 1637
  size = ((uint32_t )alen + size) + 4U;
#line 1639
  ql_dbg(268435456U, vha, 8253, "HostName=%s.\n", (uint8_t *)(& eiter->a.host_name));
#line 1642
  qla2x00_update_ms_fdmi_iocb(vha, size + 16U);
#line 1644
  tmp___5 = wwn_to_u64((u8 *)(& ct_req->req.rpa.port_name));
#line 1644
  ql_dbg(268435456U, vha, 8254, "RPA portname  %016llx, size = %d.\n", tmp___5, size);
#line 1647
  ql_dump_buffer(268566528U, vha, 8313, (uint8_t *)entries, size);
#line 1651
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 1653
  if (rval != 0) {
#line 1655
    ql_dbg(268435456U, vha, 8256, "RPA issue IOCB failed (%d).\n", rval);
  } else {
#line 1657
    tmp___6 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "RPA");
#line 1657
    if (tmp___6 != 0) {
#line 1659
      rval = 258;
#line 1660
      if ((unsigned int )ct_rsp->header.reason_code == 9U && (unsigned int )ct_rsp->header.explanation_code == 16U) {
#line 1663
        ql_dbg(268435456U, vha, 8397, "RPA already registered.\n");
#line 1665
        rval = 265;
      } else {

      }
    } else {
#line 1669
      ql_dbg(268435456U, vha, 8257, "RPA exiting normally.\n");
    }
  }
#line 1673
  return (rval);
}
}
#line 1683 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
static int qla2x00_fdmiv2_rhba(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  int alen ;
  uint32_t size ;
  uint32_t sn ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  void *entries ;
  struct ct_fdmiv2_hba_attr *eiter ;
  struct qla_hw_data *ha ;
  struct init_cb_24xx *icb24 ;
  struct new_utsname *p_sysid ;
  void *tmp ;
  u64 tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  __u16 tmp___3 ;
  size_t tmp___4 ;
  __u16 tmp___5 ;
  size_t tmp___6 ;
  __u16 tmp___7 ;
  size_t tmp___8 ;
  __u16 tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  __u16 tmp___13 ;
  size_t tmp___14 ;
  __u16 tmp___15 ;
  size_t tmp___16 ;
  __u16 tmp___17 ;
  size_t tmp___18 ;
  __u16 tmp___19 ;
  size_t tmp___20 ;
  __u16 tmp___21 ;
  __u32 tmp___22 ;
  size_t tmp___23 ;
  __u16 tmp___24 ;
  u64 tmp___25 ;
  size_t tmp___26 ;
  __u16 tmp___27 ;
  size_t tmp___28 ;
  __u16 tmp___29 ;
  u64 tmp___30 ;
  int tmp___31 ;

  {
#line 1692
  ha = vha->hw;
#line 1693
  icb24 = (struct init_cb_24xx *)ha->init_cb;
#line 1694
  p_sysid = (struct new_utsname *)0;
#line 1699
  tmp = (*((ha->isp_ops)->prep_ms_fdmi_iocb))(vha, 0U, 16U);
#line 1699
  ms_pkt = (ms_iocb_entry_t *)tmp;
#line 1702
  ct_req = qla2x00_prep_ct_fdmi_req(ha->ct_sns, 512, 16);
#line 1704
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 1707
  memcpy((void *)(& ct_req->req.rhba2.hba_identifier), (void const   *)(& vha->port_name),
           8UL);
#line 1708
  ct_req->req.rhba2.entry_count = 16777216U;
#line 1709
  memcpy((void *)(& ct_req->req.rhba2.port_name), (void const   *)(& vha->port_name),
           8UL);
#line 1710
  size = 24U;
#line 1713
  ct_req->req.rhba2.attrs.count = 285212672U;
#line 1714
  entries = (void *)(& ct_req->req.rhba2.hba_identifier);
#line 1717
  eiter = (struct ct_fdmiv2_hba_attr *)entries + (unsigned long )size;
#line 1718
  eiter->type = 256U;
#line 1719
  eiter->len = 3072U;
#line 1720
  memcpy((void *)(& eiter->a.node_name), (void const   *)(& vha->node_name), 8UL);
#line 1721
  size = size + 12U;
#line 1723
  tmp___0 = wwn_to_u64((u8 *)(& eiter->a.node_name));
#line 1723
  ql_dbg(268435456U, vha, 8317, "NodeName = %016llx.\n", tmp___0);
#line 1727
  eiter = (struct ct_fdmiv2_hba_attr *)entries + (unsigned long )size;
#line 1728
  eiter->type = 512U;
#line 1729
  snprintf((char *)(& eiter->a.manufacturer), 64UL, "%s", (char *)"QLogic Corporation");
#line 1731
  tmp___1 = strlen("QLogic Corporation");
#line 1731
  eiter->a.manufacturer[tmp___1] = 0U;
#line 1732
  tmp___2 = strlen((char const   *)(& eiter->a.manufacturer));
#line 1732
  alen = (int )tmp___2;
#line 1733
  alen = (4 - (alen & 3)) + alen;
#line 1734
  tmp___3 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1734
  eiter->len = tmp___3;
#line 1735
  size = ((uint32_t )alen + size) + 4U;
#line 1737
  ql_dbg(268435456U, vha, 8357, "Manufacturer = %s.\n", (uint8_t *)(& eiter->a.manufacturer));
#line 1741
  eiter = (struct ct_fdmiv2_hba_attr *)entries + (unsigned long )size;
#line 1742
  eiter->type = 768U;
#line 1743
  if ((ha->device_type & 134217728U) != 0U) {
#line 1744
    qla2xxx_get_vpd_field(vha, (char *)"SN", (char *)(& eiter->a.serial_num), 32UL);
  } else {
#line 1747
    sn = (uint32_t )(((((int )ha->serial0 & 31) << 16) | ((int )ha->serial2 << 8)) | (int )ha->serial1);
#line 1749
    snprintf((char *)(& eiter->a.serial_num), 32UL, "%c%05d", sn / 100000U + 65U,
             sn % 100000U);
  }
#line 1752
  tmp___4 = strlen((char const   *)(& eiter->a.serial_num));
#line 1752
  alen = (int )tmp___4;
#line 1753
  alen = (4 - (alen & 3)) + alen;
#line 1754
  tmp___5 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1754
  eiter->len = tmp___5;
#line 1755
  size = ((uint32_t )alen + size) + 4U;
#line 1757
  ql_dbg(268435456U, vha, 8358, "Serial no. = %s.\n", (uint8_t *)(& eiter->a.serial_num));
#line 1761
  eiter = (struct ct_fdmiv2_hba_attr *)entries + (unsigned long )size;
#line 1762
  eiter->type = 1024U;
#line 1763
  snprintf((char *)(& eiter->a.model), 17UL, "%s", (uint8_t *)(& ha->model_number));
#line 1765
  tmp___6 = strlen((char const   *)(& eiter->a.model));
#line 1765
  alen = (int )tmp___6;
#line 1766
  alen = (4 - (alen & 3)) + alen;
#line 1767
  tmp___7 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1767
  eiter->len = tmp___7;
#line 1768
  size = ((uint32_t )alen + size) + 4U;
#line 1770
  ql_dbg(268435456U, vha, 8359, "Model Name = %s.\n", (uint8_t *)(& eiter->a.model));
#line 1774
  eiter = (struct ct_fdmiv2_hba_attr *)entries + (unsigned long )size;
#line 1775
  eiter->type = 1280U;
#line 1776
  snprintf((char *)(& eiter->a.model_desc), 80UL, "%s", (char *)(& ha->model_desc));
#line 1778
  tmp___8 = strlen((char const   *)(& eiter->a.model_desc));
#line 1778
  alen = (int )tmp___8;
#line 1779
  alen = (4 - (alen & 3)) + alen;
#line 1780
  tmp___9 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1780
  eiter->len = tmp___9;
#line 1781
  size = ((uint32_t )alen + size) + 4U;
#line 1783
  ql_dbg(268435456U, vha, 8360, "Model Desc = %s.\n", (uint8_t *)(& eiter->a.model_desc));
#line 1787
  eiter = (struct ct_fdmiv2_hba_attr *)entries + (unsigned long )size;
#line 1788
  eiter->type = 1536U;
#line 1789
  if ((ha->device_type & 134217728U) == 0U) {
#line 1790
    snprintf((char *)(& eiter->a.hw_version), 16UL, "HW:%s", (uint8_t *)(& ha->adapter_id));
  } else {
#line 1792
    tmp___11 = qla2xxx_get_vpd_field(vha, (char *)"MN", (char *)(& eiter->a.hw_version),
                                     16UL);
#line 1792
    if (tmp___11 != 0) {

    } else {
#line 1795
      tmp___10 = qla2xxx_get_vpd_field(vha, (char *)"EC", (char *)(& eiter->a.hw_version),
                                       16UL);
#line 1795
      if (tmp___10 != 0) {

      } else {
#line 1799
        snprintf((char *)(& eiter->a.hw_version), 16UL, "HW:%s", (uint8_t *)(& ha->adapter_id));
      }
    }
  }
#line 1802
  tmp___12 = strlen((char const   *)(& eiter->a.hw_version));
#line 1802
  alen = (int )tmp___12;
#line 1803
  alen = (4 - (alen & 3)) + alen;
#line 1804
  tmp___13 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1804
  eiter->len = tmp___13;
#line 1805
  size = ((uint32_t )alen + size) + 4U;
#line 1807
  ql_dbg(268435456U, vha, 8361, "Hardware ver = %s.\n", (uint8_t *)(& eiter->a.hw_version));
#line 1811
  eiter = (struct ct_fdmiv2_hba_attr *)entries + (unsigned long )size;
#line 1812
  eiter->type = 1792U;
#line 1813
  snprintf((char *)(& eiter->a.driver_version), 32UL, "%s", (char *)(& qla2x00_version_str));
#line 1815
  tmp___14 = strlen((char const   *)(& eiter->a.driver_version));
#line 1815
  alen = (int )tmp___14;
#line 1816
  alen = (4 - (alen & 3)) + alen;
#line 1817
  tmp___15 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1817
  eiter->len = tmp___15;
#line 1818
  size = ((uint32_t )alen + size) + 4U;
#line 1820
  ql_dbg(268435456U, vha, 8362, "Driver ver = %s.\n", (uint8_t *)(& eiter->a.driver_version));
#line 1824
  eiter = (struct ct_fdmiv2_hba_attr *)entries + (unsigned long )size;
#line 1825
  eiter->type = 2048U;
#line 1826
  snprintf((char *)(& eiter->a.orom_version), 16UL, "%d.%02d", (int )ha->bios_revision[1],
           (int )ha->bios_revision[0]);
#line 1828
  tmp___16 = strlen((char const   *)(& eiter->a.orom_version));
#line 1828
  alen = (int )tmp___16;
#line 1829
  alen = (4 - (alen & 3)) + alen;
#line 1830
  tmp___17 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1830
  eiter->len = tmp___17;
#line 1831
  size = ((uint32_t )alen + size) + 4U;
#line 1833
  ql_dbg(268435456U, vha, 8363, "Optrom version = %d.%02d.\n", (int )eiter->a.orom_version[1],
         (int )eiter->a.orom_version[0]);
#line 1838
  eiter = (struct ct_fdmiv2_hba_attr *)entries + (unsigned long )size;
#line 1839
  eiter->type = 2304U;
#line 1840
  (*((ha->isp_ops)->fw_version_str))(vha, (char *)(& eiter->a.fw_version), 32UL);
#line 1842
  tmp___18 = strlen((char const   *)(& eiter->a.fw_version));
#line 1842
  alen = (int )tmp___18;
#line 1843
  alen = (4 - (alen & 3)) + alen;
#line 1844
  tmp___19 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1844
  eiter->len = tmp___19;
#line 1845
  size = ((uint32_t )alen + size) + 4U;
#line 1847
  ql_dbg(268435456U, vha, 8364, "Firmware vers = %s.\n", (uint8_t *)(& eiter->a.fw_version));
#line 1851
  eiter = (struct ct_fdmiv2_hba_attr *)entries + (unsigned long )size;
#line 1852
  eiter->type = 2560U;
#line 1853
  p_sysid = utsname();
#line 1854
  if ((unsigned long )p_sysid != (unsigned long )((struct new_utsname *)0)) {
#line 1855
    snprintf((char *)(& eiter->a.os_version), 128UL, "%s %s %s", (char *)(& p_sysid->sysname),
             (char *)(& p_sysid->release), (char *)(& p_sysid->version));
  } else {
#line 1859
    snprintf((char *)(& eiter->a.os_version), 128UL, "%s %s", (char *)"Linux", (char *)(& ((struct fc_host_attrs *)(vha->host)->shost_data)->system_hostname));
  }
#line 1862
  tmp___20 = strlen((char const   *)(& eiter->a.os_version));
#line 1862
  alen = (int )tmp___20;
#line 1863
  alen = (4 - (alen & 3)) + alen;
#line 1864
  tmp___21 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1864
  eiter->len = tmp___21;
#line 1865
  size = ((uint32_t )alen + size) + 4U;
#line 1867
  ql_dbg(268435456U, vha, 8366, "OS Name and Version = %s.\n", (uint8_t *)(& eiter->a.os_version));
#line 1871
  eiter = (struct ct_fdmiv2_hba_attr *)entries + (unsigned long )size;
#line 1872
  eiter->type = 2816U;
#line 1873
  eiter->a.max_ct_len = (uint32_t )((ha->device_type & 134217728U) != 0U ? icb24->frame_payload_size : (ha->init_cb)->frame_payload_size);
#line 1876
  tmp___22 = __fswab32(eiter->a.max_ct_len);
#line 1876
  eiter->a.max_ct_len = tmp___22;
#line 1877
  eiter->len = 2048U;
#line 1878
  size = size + 8U;
#line 1880
  ql_dbg(268435456U, vha, 8367, "CT Payload Length = 0x%x.\n", eiter->a.max_ct_len);
#line 1884
  eiter = (struct ct_fdmiv2_hba_attr *)entries + (unsigned long )size;
#line 1885
  eiter->type = 3072U;
#line 1886
  qla2x00_get_sym_node_name(vha, (uint8_t *)(& eiter->a.sym_name), 256UL);
#line 1888
  tmp___23 = strlen((char const   *)(& eiter->a.sym_name));
#line 1888
  alen = (int )tmp___23;
#line 1889
  alen = (4 - (alen & 3)) + alen;
#line 1890
  tmp___24 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1890
  eiter->len = tmp___24;
#line 1891
  size = ((uint32_t )alen + size) + 4U;
#line 1893
  ql_dbg(268435456U, vha, 8368, "Symbolic Name = %s.\n", (uint8_t *)(& eiter->a.sym_name));
#line 1897
  eiter = (struct ct_fdmiv2_hba_attr *)entries + (unsigned long )size;
#line 1898
  eiter->type = 3328U;
#line 1899
  eiter->a.vendor_id = 1997537280U;
#line 1900
  eiter->len = 2048U;
#line 1901
  size = size + 8U;
#line 1903
  ql_dbg(268435456U, vha, 8369, "Vendor Id = %x.\n", eiter->a.vendor_id);
#line 1907
  eiter = (struct ct_fdmiv2_hba_attr *)entries + (unsigned long )size;
#line 1908
  eiter->type = 3584U;
#line 1909
  eiter->a.num_ports = 16777216U;
#line 1910
  eiter->len = 2048U;
#line 1911
  size = size + 8U;
#line 1913
  ql_dbg(268435456U, vha, 8370, "Port Num = %x.\n", eiter->a.num_ports);
#line 1917
  eiter = (struct ct_fdmiv2_hba_attr *)entries + (unsigned long )size;
#line 1918
  eiter->type = 3840U;
#line 1919
  memcpy((void *)(& eiter->a.fabric_name), (void const   *)(& vha->fabric_node_name),
           8UL);
#line 1920
  eiter->len = 3072U;
#line 1921
  size = size + 12U;
#line 1923
  tmp___25 = wwn_to_u64((u8 *)(& eiter->a.fabric_name));
#line 1923
  ql_dbg(268435456U, vha, 8371, "Fabric Name = %016llx.\n", tmp___25);
#line 1927
  eiter = (struct ct_fdmiv2_hba_attr *)entries + (unsigned long )size;
#line 1928
  eiter->type = 4096U;
#line 1929
  snprintf((char *)(& eiter->a.bios_name), 32UL, "BIOS %d.%02d", (int )ha->bios_revision[1],
           (int )ha->bios_revision[0]);
#line 1931
  tmp___26 = strlen((char const   *)(& eiter->a.bios_name));
#line 1931
  alen = (int )tmp___26;
#line 1932
  alen = (4 - (alen & 3)) + alen;
#line 1933
  tmp___27 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1933
  eiter->len = tmp___27;
#line 1934
  size = ((uint32_t )alen + size) + 4U;
#line 1936
  ql_dbg(268435456U, vha, 8372, "BIOS Name = %s\n", (uint8_t *)(& eiter->a.bios_name));
#line 1940
  eiter = (struct ct_fdmiv2_hba_attr *)entries + (unsigned long )size;
#line 1941
  eiter->type = 57344U;
#line 1942
  snprintf((char *)(& eiter->a.vendor_indentifer), 8UL, "%s", (char *)"QLGC");
#line 1944
  tmp___28 = strlen((char const   *)(& eiter->a.vendor_indentifer));
#line 1944
  alen = (int )tmp___28;
#line 1945
  alen = (4 - (alen & 3)) + alen;
#line 1946
  tmp___29 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1946
  eiter->len = tmp___29;
#line 1947
  size = ((uint32_t )alen + size) + 4U;
#line 1949
  ql_dbg(268435456U, vha, 8369, "Vendor Identifier = %s.\n", (uint8_t *)(& eiter->a.vendor_indentifer));
#line 1953
  qla2x00_update_ms_fdmi_iocb(vha, size + 16U);
#line 1955
  tmp___30 = wwn_to_u64((u8 *)(& ct_req->req.rhba2.hba_identifier));
#line 1955
  ql_dbg(268435456U, vha, 8373, "RHBA identifier = %016llx.\n", tmp___30);
#line 1958
  ql_dump_buffer(268566528U, vha, 8374, (uint8_t *)entries, size);
#line 1962
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 1964
  if (rval != 0) {
#line 1966
    ql_dbg(268435456U, vha, 8375, "RHBA issue IOCB failed (%d).\n", rval);
  } else {
#line 1968
    tmp___31 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "RHBA");
#line 1968
    if (tmp___31 != 0) {
#line 1970
      rval = 258;
#line 1972
      if ((unsigned int )ct_rsp->header.reason_code == 9U && (unsigned int )ct_rsp->header.explanation_code == 16U) {
#line 1975
        ql_dbg(268435456U, vha, 8376, "HBA already registered.\n");
#line 1977
        rval = 265;
      } else {
#line 1979
        ql_dbg(268435456U, vha, 8214, "RHBA FDMI v2 failed, CT Reason code: 0x%x, CT Explanation 0x%x\n",
               (int )ct_rsp->header.reason_code, (int )ct_rsp->header.explanation_code);
      }
    } else {
#line 1985
      ql_dbg(268435456U, vha, 8377, "RHBA FDMI V2 exiting normally.\n");
    }
  }
#line 1989
  return (rval);
}
}
#line 1999 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
static int qla2x00_fdmi_dhba(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2002
  ha = vha->hw;
#line 2009
  tmp = (*((ha->isp_ops)->prep_ms_fdmi_iocb))(vha, 24U, 16U);
#line 2009
  ms_pkt = (ms_iocb_entry_t *)tmp;
#line 2013
  ct_req = qla2x00_prep_ct_fdmi_req(ha->ct_sns, 768, 16);
#line 2014
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 2017
  memcpy((void *)(& ct_req->req.dhba.port_name), (void const   *)(& vha->port_name),
           8UL);
#line 2019
  ql_dbg(268435456U, vha, 8246, "DHBA portname = %8phN.\n", (uint8_t *)(& ct_req->req.dhba.port_name));
#line 2023
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 2025
  if (rval != 0) {
#line 2027
    ql_dbg(268435456U, vha, 8247, "DHBA issue IOCB failed (%d).\n", rval);
  } else {
#line 2029
    tmp___0 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "DHBA");
#line 2029
    if (tmp___0 != 0) {
#line 2031
      rval = 258;
    } else {
#line 2033
      ql_dbg(268435456U, vha, 8248, "DHBA exiting normally.\n");
    }
  }
#line 2037
  return (rval);
}
}
#line 2047 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
static int qla2x00_fdmiv2_rpa(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  int alen ;
  uint32_t size ;
  struct qla_hw_data *ha ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  void *entries ;
  struct ct_fdmiv2_port_attr *eiter ;
  struct init_cb_24xx *icb24 ;
  struct new_utsname *p_sysid ;
  void *tmp ;
  __u32 tmp___0 ;
  size_t tmp___1 ;
  __u16 tmp___2 ;
  size_t tmp___3 ;
  __u16 tmp___4 ;
  u64 tmp___5 ;
  u64 tmp___6 ;
  size_t tmp___7 ;
  __u16 tmp___8 ;
  u64 tmp___9 ;
  __u32 tmp___10 ;
  int tmp___11 ;

  {
#line 2051
  ha = vha->hw;
#line 2057
  icb24 = (struct init_cb_24xx *)ha->init_cb;
#line 2058
  p_sysid = (struct new_utsname *)0;
#line 2063
  tmp = (*((ha->isp_ops)->prep_ms_fdmi_iocb))(vha, 0U, 16U);
#line 2063
  ms_pkt = (ms_iocb_entry_t *)tmp;
#line 2066
  ct_req = qla2x00_prep_ct_fdmi_req(ha->ct_sns, 529, 16);
#line 2067
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 2070
  memcpy((void *)(& ct_req->req.rpa2.port_name), (void const   *)(& vha->port_name),
           8UL);
#line 2071
  size = 12U;
#line 2074
  ct_req->req.rpa2.attrs.count = 268435456U;
#line 2075
  entries = (void *)(& ct_req->req.rpa2.port_name);
#line 2078
  eiter = (struct ct_fdmiv2_port_attr *)entries + (unsigned long )size;
#line 2079
  eiter->type = 256U;
#line 2080
  eiter->len = 9216U;
#line 2081
  eiter->a.fc4_types[2] = 1U;
#line 2082
  size = size + 36U;
#line 2084
  ql_dbg(268435456U, vha, 8378, "FC4_TYPES=%02x %02x.\n", (int )eiter->a.fc4_types[2],
         (int )eiter->a.fc4_types[1]);
#line 2090
  eiter = (struct ct_fdmiv2_port_attr *)entries + (unsigned long )size;
#line 2091
  eiter->type = 512U;
#line 2092
  eiter->len = 2048U;
#line 2093
  if ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 2094
    eiter->a.sup_speed = 67108864U;
  } else
#line 2096
  if ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) {
#line 2097
    eiter->a.sup_speed = 1879048192U;
  } else
#line 2101
  if ((ha->device_type & 32768U) != 0U) {
#line 2102
    eiter->a.sup_speed = 939524096U;
  } else
#line 2106
  if ((ha->device_type & 2048U) != 0U) {
#line 2107
    eiter->a.sup_speed = 452984832U;
  } else
#line 2112
  if ((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || ((ha->device_type & 512U) != 0U || (ha->device_type & 1024U) != 0U)) || (ha->device_type & 4096U) != 0U) {
#line 2113
    eiter->a.sup_speed = 184549376U;
  } else
#line 2117
  if (((((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 16U) != 0U) || (ha->device_type & 32U) != 0U) || (ha->device_type & 64U) != 0U) {
#line 2118
    eiter->a.sup_speed = 50331648U;
  } else {
#line 2122
    eiter->a.sup_speed = 16777216U;
  }
#line 2124
  size = size + 8U;
#line 2126
  ql_dbg(268435456U, vha, 8379, "Supported Port Speed = %x.\n", eiter->a.sup_speed);
#line 2130
  eiter = (struct ct_fdmiv2_port_attr *)entries + (unsigned long )size;
#line 2131
  eiter->type = 768U;
#line 2132
  eiter->len = 2048U;
#line 2133
  switch ((int )ha->link_data_rate) {
  case 0: 
#line 2135
  eiter->a.cur_speed = 16777216U;
#line 2136
  goto ldv_66113;
  case 1: 
#line 2138
  eiter->a.cur_speed = 33554432U;
#line 2139
  goto ldv_66113;
  case 3: 
#line 2141
  eiter->a.cur_speed = 134217728U;
#line 2142
  goto ldv_66113;
  case 4: 
#line 2144
  eiter->a.cur_speed = 268435456U;
#line 2145
  goto ldv_66113;
  case 19: 
#line 2147
  eiter->a.cur_speed = 67108864U;
#line 2148
  goto ldv_66113;
  case 5: 
#line 2150
  eiter->a.cur_speed = 536870912U;
#line 2151
  goto ldv_66113;
  case 6: 
#line 2153
  eiter->a.cur_speed = 1073741824U;
#line 2154
  goto ldv_66113;
  default: 
#line 2156
  eiter->a.cur_speed = 8388608U;
#line 2157
  goto ldv_66113;
  }
  ldv_66113: 
#line 2159
  size = size + 8U;
#line 2161
  ql_dbg(268435456U, vha, 8380, "Current_Speed = %x.\n", eiter->a.cur_speed);
#line 2165
  eiter = (struct ct_fdmiv2_port_attr *)entries + (unsigned long )size;
#line 2166
  eiter->type = 1024U;
#line 2167
  eiter->len = 2048U;
#line 2168
  eiter->a.max_frame_size = (uint32_t )((ha->device_type & 134217728U) != 0U ? icb24->frame_payload_size : (ha->init_cb)->frame_payload_size);
#line 2171
  tmp___0 = __fswab32(eiter->a.max_frame_size);
#line 2171
  eiter->a.max_frame_size = tmp___0;
#line 2172
  size = size + 8U;
#line 2174
  ql_dbg(268435456U, vha, 8380, "Max_Frame_Size = %x.\n", eiter->a.max_frame_size);
#line 2178
  eiter = (struct ct_fdmiv2_port_attr *)entries + (unsigned long )size;
#line 2179
  eiter->type = 1280U;
#line 2180
  tmp___1 = strlen("qla2xxx");
#line 2180
  alen = (int )tmp___1;
#line 2181
  snprintf((char *)(& eiter->a.os_dev_name), 32UL, "%s:host%lu", (char *)"qla2xxx",
           vha->host_no);
#line 2183
  alen = (4 - (alen & 3)) + alen;
#line 2184
  tmp___2 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 2184
  eiter->len = tmp___2;
#line 2185
  size = ((uint32_t )alen + size) + 4U;
#line 2187
  ql_dbg(268435456U, vha, 8382, "OS_Device_Name = %s.\n", (uint8_t *)(& eiter->a.os_dev_name));
#line 2191
  eiter = (struct ct_fdmiv2_port_attr *)entries + (unsigned long )size;
#line 2192
  eiter->type = 1536U;
#line 2193
  p_sysid = utsname();
#line 2194
  if ((unsigned long )p_sysid != (unsigned long )((struct new_utsname *)0)) {
#line 2195
    snprintf((char *)(& eiter->a.host_name), 256UL, "%s", (char *)(& p_sysid->nodename));
  } else {
#line 2198
    snprintf((char *)(& eiter->a.host_name), 256UL, "%s", (char *)(& ((struct fc_host_attrs *)(vha->host)->shost_data)->system_hostname));
  }
#line 2201
  tmp___3 = strlen((char const   *)(& eiter->a.host_name));
#line 2201
  alen = (int )tmp___3;
#line 2202
  alen = (4 - (alen & 3)) + alen;
#line 2203
  tmp___4 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 2203
  eiter->len = tmp___4;
#line 2204
  size = ((uint32_t )alen + size) + 4U;
#line 2206
  ql_dbg(268435456U, vha, 8253, "HostName=%s.\n", (uint8_t *)(& eiter->a.host_name));
#line 2210
  eiter = (struct ct_fdmiv2_port_attr *)entries + (unsigned long )size;
#line 2211
  eiter->type = 1792U;
#line 2212
  memcpy((void *)(& eiter->a.node_name), (void const   *)(& vha->node_name), 8UL);
#line 2213
  eiter->len = 3072U;
#line 2214
  size = size + 12U;
#line 2216
  tmp___5 = wwn_to_u64((u8 *)(& eiter->a.node_name));
#line 2216
  ql_dbg(268435456U, vha, 8384, "Node Name = %016llx.\n", tmp___5);
#line 2220
  eiter = (struct ct_fdmiv2_port_attr *)entries + (unsigned long )size;
#line 2221
  eiter->type = 2048U;
#line 2222
  memcpy((void *)(& eiter->a.port_name), (void const   *)(& vha->port_name), 8UL);
#line 2223
  eiter->len = 3072U;
#line 2224
  size = size + 12U;
#line 2226
  tmp___6 = wwn_to_u64((u8 *)(& eiter->a.port_name));
#line 2226
  ql_dbg(268435456U, vha, 8385, "Port Name = %016llx.\n", tmp___6);
#line 2230
  eiter = (struct ct_fdmiv2_port_attr *)entries + (unsigned long )size;
#line 2231
  eiter->type = 2304U;
#line 2232
  qla2x00_get_sym_node_name(vha, (uint8_t *)(& eiter->a.port_sym_name), 128UL);
#line 2234
  tmp___7 = strlen((char const   *)(& eiter->a.port_sym_name));
#line 2234
  alen = (int )tmp___7;
#line 2235
  alen = (4 - (alen & 3)) + alen;
#line 2236
  tmp___8 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 2236
  eiter->len = tmp___8;
#line 2237
  size = ((uint32_t )alen + size) + 4U;
#line 2239
  ql_dbg(268435456U, vha, 8386, "port symbolic name = %s\n", (uint8_t *)(& eiter->a.port_sym_name));
#line 2243
  eiter = (struct ct_fdmiv2_port_attr *)entries + (unsigned long )size;
#line 2244
  eiter->type = 2560U;
#line 2245
  eiter->a.port_type = 2130706432U;
#line 2246
  eiter->len = 2048U;
#line 2247
  size = size + 8U;
#line 2249
  ql_dbg(268435456U, vha, 8387, "Port Type = %x.\n", eiter->a.port_type);
#line 2253
  eiter = (struct ct_fdmiv2_port_attr *)entries + (unsigned long )size;
#line 2254
  eiter->type = 2816U;
#line 2255
  eiter->a.port_supported_cos = 134217728U;
#line 2256
  eiter->len = 2048U;
#line 2257
  size = size + 8U;
#line 2259
  ql_dbg(268435456U, vha, 8388, "Supported COS = %08x\n", eiter->a.port_supported_cos);
#line 2263
  eiter = (struct ct_fdmiv2_port_attr *)entries + (unsigned long )size;
#line 2264
  eiter->type = 3072U;
#line 2265
  memcpy((void *)(& eiter->a.fabric_name), (void const   *)(& vha->fabric_node_name),
           8UL);
#line 2266
  eiter->len = 3072U;
#line 2267
  size = size + 12U;
#line 2269
  tmp___9 = wwn_to_u64((u8 *)(& eiter->a.fabric_name));
#line 2269
  ql_dbg(268435456U, vha, 8389, "Fabric Name = %016llx.\n", tmp___9);
#line 2273
  eiter = (struct ct_fdmiv2_port_attr *)entries + (unsigned long )size;
#line 2274
  eiter->type = 3328U;
#line 2275
  eiter->a.port_fc4_type[0] = 0U;
#line 2276
  eiter->a.port_fc4_type[1] = 0U;
#line 2277
  eiter->a.port_fc4_type[2] = 1U;
#line 2278
  eiter->a.port_fc4_type[3] = 0U;
#line 2279
  eiter->len = 9216U;
#line 2280
  size = size + 36U;
#line 2282
  ql_dbg(268435456U, vha, 8390, "Port Active FC4 Type = %02x %02x.\n", (int )eiter->a.port_fc4_type[2],
         (int )eiter->a.port_fc4_type[1]);
#line 2287
  eiter = (struct ct_fdmiv2_port_attr *)entries + (unsigned long )size;
#line 2288
  eiter->type = 257U;
#line 2289
  eiter->a.port_state = 16777216U;
#line 2290
  eiter->len = 2048U;
#line 2291
  size = size + 8U;
#line 2293
  ql_dbg(268435456U, vha, 8391, "Port State = %x.\n", eiter->a.port_state);
#line 2297
  eiter = (struct ct_fdmiv2_port_attr *)entries + (unsigned long )size;
#line 2298
  eiter->type = 513U;
#line 2299
  eiter->a.num_ports = 16777216U;
#line 2300
  eiter->len = 2048U;
#line 2301
  size = size + 8U;
#line 2303
  ql_dbg(268435456U, vha, 8392, "Number of ports = %x.\n", eiter->a.num_ports);
#line 2307
  eiter = (struct ct_fdmiv2_port_attr *)entries + (unsigned long )size;
#line 2308
  eiter->type = 769U;
#line 2309
  tmp___10 = __fswab32(vha->d_id.b24);
#line 2309
  eiter->a.port_id = tmp___10;
#line 2310
  eiter->len = 2048U;
#line 2311
  size = size + 8U;
#line 2313
  ql_dbg(268435456U, vha, 8392, "Port Id = %x.\n", eiter->a.port_id);
#line 2317
  qla2x00_update_ms_fdmi_iocb(vha, size + 16U);
#line 2319
  ql_dbg(268435456U, vha, 8254, "RPA portname= %8phN size=%d.\n", (uint8_t *)(& ct_req->req.rpa.port_name),
         size);
#line 2321
  ql_dump_buffer(268566528U, vha, 8394, (uint8_t *)entries, size);
#line 2325
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 2327
  if (rval != 0) {
#line 2329
    ql_dbg(268435456U, vha, 8395, "RPA FDMI v2 issue IOCB failed (%d).\n", rval);
  } else {
#line 2331
    tmp___11 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "RPA");
#line 2331
    if (tmp___11 != 0) {
#line 2333
      rval = 258;
#line 2334
      if ((unsigned int )ct_rsp->header.reason_code == 9U && (unsigned int )ct_rsp->header.explanation_code == 16U) {
#line 2337
        ql_dbg(268435456U, vha, 8398, "RPA FDMI v2 already registered\n");
#line 2339
        rval = 265;
      } else {
#line 2341
        ql_dbg(268435456U, vha, 8224, "RPA FDMI v2 failed, CT Reason code: 0x%x, CT Explanation 0x%x\n",
               (int )ct_rsp->header.reason_code, (int )ct_rsp->header.explanation_code);
      }
    } else {
#line 2347
      ql_dbg(268435456U, vha, 8396, "RPA FDMI V2 exiting normally.\n");
    }
  }
#line 2351
  return (rval);
}
}
#line 2361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
int qla2x00_fdmi_register(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;

  {
#line 2363
  rval = 258;
#line 2364
  ha = vha->hw;
#line 2366
  if (((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) || (ha->device_type & 131072U) != 0U) {
#line 2368
    return (258);
  } else {

  }
#line 2370
  rval = qla2x00_mgmt_svr_login(vha);
#line 2371
  if (rval != 0) {
#line 2372
    return (rval);
  } else {

  }
#line 2374
  rval = qla2x00_fdmiv2_rhba(vha);
#line 2375
  if (rval != 0) {
#line 2376
    if (rval != 265) {
#line 2377
      goto try_fdmi;
    } else {

    }
#line 2379
    rval = qla2x00_fdmi_dhba(vha);
#line 2380
    if (rval != 0) {
#line 2381
      goto try_fdmi;
    } else {

    }
#line 2383
    rval = qla2x00_fdmiv2_rhba(vha);
#line 2384
    if (rval != 0) {
#line 2385
      goto try_fdmi;
    } else {

    }
  } else {

  }
#line 2387
  rval = qla2x00_fdmiv2_rpa(vha);
#line 2388
  if (rval != 0) {
#line 2389
    goto try_fdmi;
  } else {

  }
#line 2391
  goto out;
  try_fdmi: 
#line 2394
  rval = qla2x00_fdmi_rhba(vha);
#line 2395
  if (rval != 0) {
#line 2396
    if (rval != 265) {
#line 2397
      return (rval);
    } else {

    }
#line 2399
    rval = qla2x00_fdmi_dhba(vha);
#line 2400
    if (rval != 0) {
#line 2401
      return (rval);
    } else {

    }
#line 2403
    rval = qla2x00_fdmi_rhba(vha);
#line 2404
    if (rval != 0) {
#line 2405
      return (rval);
    } else {

    }
  } else {

  }
#line 2407
  rval = qla2x00_fdmi_rpa(vha);
  out: ;
#line 2409
  return (rval);
}
}
#line 2420 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
int qla2x00_gfpn_id(scsi_qla_host_t *vha , sw_info_t *list ) 
{ 
  int rval ;
  uint16_t i ;
  struct qla_hw_data *ha ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2422
  rval = 0;
#line 2424
  ha = vha->hw;
#line 2429
  if ((ha->device_type & 67108864U) == 0U) {
#line 2430
    return (258);
  } else {

  }
#line 2432
  i = 0U;
#line 2432
  goto ldv_66140;
  ldv_66139: 
#line 2435
  tmp = (*((ha->isp_ops)->prep_ms_iocb))(vha, 20U, 24U);
#line 2435
  ms_pkt = (ms_iocb_entry_t *)tmp;
#line 2439
  ct_req = qla2x00_prep_ct_req(ha->ct_sns, 284, 24);
#line 2441
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 2444
  ct_req->req.port_id.port_id[0] = (list + (unsigned long )i)->d_id.b.domain;
#line 2445
  ct_req->req.port_id.port_id[1] = (list + (unsigned long )i)->d_id.b.area;
#line 2446
  ct_req->req.port_id.port_id[2] = (list + (unsigned long )i)->d_id.b.al_pa;
#line 2449
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 2451
  if (rval != 0) {
#line 2453
    ql_dbg(268435456U, vha, 8227, "GFPN_ID issue IOCB failed (%d).\n", rval);
#line 2455
    goto ldv_66138;
  } else {
#line 2456
    tmp___0 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "GFPN_ID");
#line 2456
    if (tmp___0 != 0) {
#line 2458
      rval = 258;
#line 2459
      goto ldv_66138;
    } else {
#line 2462
      memcpy((void *)(& (list + (unsigned long )i)->fabric_port_name), (void const   *)(& ct_rsp->rsp.gfpn_id.port_name),
               8UL);
    }
  }
#line 2467
  if ((unsigned int )(list + (unsigned long )i)->d_id.b.rsvd_1 != 0U) {
#line 2468
    goto ldv_66138;
  } else {

  }
#line 2432
  i = (uint16_t )((int )i + 1);
  ldv_66140: ;
#line 2432
  if ((int )ha->max_fibre_devices > (int )i) {
#line 2434
    goto ldv_66139;
  } else {

  }
  ldv_66138: ;
#line 2471
  return (rval);
}
}
#line 2475 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
__inline static void *qla24xx_prep_ms_fm_iocb(scsi_qla_host_t *vha , uint32_t req_size ,
                                              uint32_t rsp_size ) 
{ 
  struct ct_entry_24xx *ct_pkt ;
  struct qla_hw_data *ha ;

  {
#line 2479
  ha = vha->hw;
#line 2480
  ct_pkt = (struct ct_entry_24xx *)ha->ms_iocb;
#line 2481
  memset((void *)ct_pkt, 0, 64UL);
#line 2483
  ct_pkt->entry_type = 41U;
#line 2484
  ct_pkt->entry_count = 1U;
#line 2485
  ct_pkt->nport_handle = vha->mgmt_svr_loop_id;
#line 2486
  ct_pkt->timeout = ((unsigned int )ha->r_a_tov / 10U) * 2U;
#line 2487
  ct_pkt->cmd_dsd_count = 1U;
#line 2488
  ct_pkt->rsp_dsd_count = 1U;
#line 2489
  ct_pkt->rsp_byte_count = rsp_size;
#line 2490
  ct_pkt->cmd_byte_count = req_size;
#line 2492
  ct_pkt->dseg_0_address[0] = (unsigned int )ha->ct_sns_dma;
#line 2493
  ct_pkt->dseg_0_address[1] = (unsigned int )(ha->ct_sns_dma >> 32ULL);
#line 2494
  ct_pkt->dseg_0_len = ct_pkt->cmd_byte_count;
#line 2496
  ct_pkt->dseg_1_address[0] = (unsigned int )ha->ct_sns_dma;
#line 2497
  ct_pkt->dseg_1_address[1] = (unsigned int )(ha->ct_sns_dma >> 32ULL);
#line 2498
  ct_pkt->dseg_1_len = ct_pkt->rsp_byte_count;
#line 2499
  ct_pkt->vp_index = (uint8_t )vha->vp_idx;
#line 2501
  return ((void *)ct_pkt);
}
}
#line 2506 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
__inline static struct ct_sns_req *qla24xx_prep_ct_fm_req(struct ct_sns_pkt *p , uint16_t cmd ,
                                                          uint16_t rsp_size ) 
{ 
  __u16 tmp ;
  __u16 tmp___0 ;

  {
#line 2509
  memset((void *)p, 0, 8208UL);
#line 2511
  p->p.req.header.revision = 1U;
#line 2512
  p->p.req.header.gs_type = 250U;
#line 2513
  p->p.req.header.gs_subtype = 1U;
#line 2514
  tmp = __fswab16((int )cmd);
#line 2514
  p->p.req.command = tmp;
#line 2515
  tmp___0 = __fswab16((int )((__u16 )(((int )rsp_size + -16) / 4)));
#line 2515
  p->p.req.max_rsp_size = tmp___0;
#line 2517
  return (& p->p.req);
}
}
#line 2528 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
int qla2x00_gpsc(scsi_qla_host_t *vha , sw_info_t *list ) 
{ 
  int rval ;
  uint16_t i ;
  struct qla_hw_data *ha ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  void *tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;

  {
#line 2532
  ha = vha->hw;
#line 2537
  if ((ha->device_type & 67108864U) == 0U) {
#line 2538
    return (258);
  } else {

  }
#line 2539
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 2540
    return (258);
  } else {

  }
#line 2542
  rval = qla2x00_mgmt_svr_login(vha);
#line 2543
  if (rval != 0) {
#line 2544
    return (rval);
  } else {

  }
#line 2546
  i = 0U;
#line 2546
  goto ldv_66173;
  ldv_66172: 
#line 2549
  tmp = qla24xx_prep_ms_fm_iocb(vha, 24U, 20U);
#line 2549
  ms_pkt = (ms_iocb_entry_t *)tmp;
#line 2553
  ct_req = qla24xx_prep_ct_fm_req(ha->ct_sns, 295, 20);
#line 2555
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 2558
  memcpy((void *)(& ct_req->req.gpsc.port_name), (void const   *)(& (list + (unsigned long )i)->fabric_port_name),
           8UL);
#line 2562
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 2564
  if (rval != 0) {
#line 2566
    ql_dbg(268435456U, vha, 8281, "GPSC issue IOCB failed (%d).\n", rval);
  } else {
#line 2568
    rval = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "GPSC");
#line 2568
    if (rval != 0) {
#line 2571
      if (rval == 1 && ((unsigned int )ct_rsp->header.reason_code == 1U || (unsigned int )ct_rsp->header.reason_code == 11U)) {
#line 2576
        ql_dbg(268435456U, vha, 8282, "GPSC command unsupported, disabling query.\n");
#line 2579
        ha->flags.gpsc_supported = 0U;
#line 2580
        rval = 258;
#line 2581
        goto ldv_66163;
      } else {

      }
#line 2583
      rval = 258;
    } else {
#line 2586
      tmp___0 = __fswab16((int )ct_rsp->rsp.gpsc.speed);
#line 2586
      switch ((int )tmp___0) {
      case 32768: 
#line 2588
      (list + (unsigned long )i)->fp_speed = 0U;
#line 2589
      goto ldv_66165;
      case 16384: 
#line 2591
      (list + (unsigned long )i)->fp_speed = 1U;
#line 2592
      goto ldv_66165;
      case 8192: 
#line 2594
      (list + (unsigned long )i)->fp_speed = 3U;
#line 2595
      goto ldv_66165;
      case 4096: 
#line 2597
      (list + (unsigned long )i)->fp_speed = 19U;
#line 2598
      goto ldv_66165;
      case 2048: 
#line 2600
      (list + (unsigned long )i)->fp_speed = 4U;
#line 2601
      goto ldv_66165;
      case 1024: 
#line 2603
      (list + (unsigned long )i)->fp_speed = 5U;
#line 2604
      goto ldv_66165;
      case 256: 
#line 2606
      (list + (unsigned long )i)->fp_speed = 6U;
#line 2607
      goto ldv_66165;
      }
      ldv_66165: 
#line 2610
      tmp___1 = __fswab16((int )ct_rsp->rsp.gpsc.speed);
#line 2610
      tmp___2 = __fswab16((int )ct_rsp->rsp.gpsc.speeds);
#line 2610
      ql_dbg(268435456U, vha, 8283, "GPSC ext entry - fpn %8phN speeds=%04x speed=%04x.\n",
             (uint8_t *)(& (list + (unsigned long )i)->fabric_port_name), (int )tmp___2,
             (int )tmp___1);
    }
  }
#line 2619
  if ((unsigned int )(list + (unsigned long )i)->d_id.b.rsvd_1 != 0U) {
#line 2620
    goto ldv_66163;
  } else {

  }
#line 2546
  i = (uint16_t )((int )i + 1);
  ldv_66173: ;
#line 2546
  if ((int )ha->max_fibre_devices > (int )i) {
#line 2548
    goto ldv_66172;
  } else {

  }
  ldv_66163: ;
#line 2623
  return (rval);
}
}
#line 2634 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.c"
void qla2x00_gff_id(scsi_qla_host_t *vha , sw_info_t *list ) 
{ 
  int rval ;
  uint16_t i ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  struct qla_hw_data *ha ;
  uint8_t fcp_scsi_features ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2642
  ha = vha->hw;
#line 2643
  fcp_scsi_features = 0U;
#line 2645
  i = 0U;
#line 2645
  goto ldv_66188;
  ldv_66187: 
#line 2648
  (list + (unsigned long )i)->fc4_type = 255U;
#line 2651
  if ((ha->device_type & 134217728U) == 0U) {
#line 2652
    goto ldv_66185;
  } else {

  }
#line 2655
  tmp = (*((ha->isp_ops)->prep_ms_iocb))(vha, 20U, 144U);
#line 2655
  ms_pkt = (ms_iocb_entry_t *)tmp;
#line 2659
  ct_req = qla2x00_prep_ct_req(ha->ct_sns, 287, 144);
#line 2661
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 2664
  ct_req->req.port_id.port_id[0] = (list + (unsigned long )i)->d_id.b.domain;
#line 2665
  ct_req->req.port_id.port_id[1] = (list + (unsigned long )i)->d_id.b.area;
#line 2666
  ct_req->req.port_id.port_id[2] = (list + (unsigned long )i)->d_id.b.al_pa;
#line 2669
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 2672
  if (rval != 0) {
#line 2673
    ql_dbg(268435456U, vha, 8284, "GFF_ID issue IOCB failed (%d).\n", rval);
  } else {
#line 2675
    tmp___0 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "GFF_ID");
#line 2675
    if (tmp___0 != 0) {
#line 2677
      ql_dbg(268435456U, vha, 8285, "GFF_ID IOCB status had a failure status code.\n");
    } else {
#line 2680
      fcp_scsi_features = ct_rsp->rsp.gff_id.fc4_features[7];
#line 2682
      fcp_scsi_features = (unsigned int )fcp_scsi_features & 15U;
#line 2684
      if ((unsigned int )fcp_scsi_features != 0U) {
#line 2685
        (list + (unsigned long )i)->fc4_type = 8U;
      } else {
#line 2687
        (list + (unsigned long )i)->fc4_type = 0U;
      }
    }
  }
#line 2691
  if ((unsigned int )(list + (unsigned long )i)->d_id.b.rsvd_1 != 0U) {
#line 2692
    goto ldv_66186;
  } else {

  }
  ldv_66185: 
#line 2645
  i = (uint16_t )((int )i + 1);
  ldv_66188: ;
#line 2645
  if ((int )ha->max_fibre_devices > (int )i) {
#line 2647
    goto ldv_66187;
  } else {

  }
  ldv_66186: ;
#line 2652
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
void activate_pending_timer_19(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 488
  if ((unsigned long )ldv_timer_list_19 == (unsigned long )timer) {
#line 489
    if (ldv_timer_state_19 == 2 || pending_flag != 0) {
#line 490
      ldv_timer_list_19 = timer;
#line 491
      ldv_timer_list_19->data = data;
#line 492
      ldv_timer_state_19 = 1;
    } else {

    }
#line 494
    return;
  } else {

  }
#line 496
  reg_timer_19(timer);
#line 497
  ldv_timer_list_19->data = data;
#line 498
  return;
}
}
#line 501 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
void choose_timer_19(struct timer_list *timer ) 
{ 


  {
#line 502
  LDV_IN_INTERRUPT = 2;
#line 503
  (*(timer->function))(timer->data);
#line 504
  LDV_IN_INTERRUPT = 1;
#line 505
  ldv_timer_state_19 = 2;
#line 506
  return;
}
}
#line 509 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
int reg_timer_19(struct timer_list *timer ) 
{ 


  {
#line 510
  ldv_timer_list_19 = timer;
#line 511
  ldv_timer_state_19 = 1;
#line 512
  return (0);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
void disable_suitable_timer_19(struct timer_list *timer ) 
{ 


  {
#line 516
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_19) {
#line 517
    ldv_timer_state_19 = 0;
#line 518
    return;
  } else {

  }
#line 520
  return;
}
}
#line 546 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
bool ldv_queue_work_on_129(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 550
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 550
  ldv_func_res = tmp;
#line 552
  activate_work_7(ldv_func_arg3, 2);
#line 554
  return (ldv_func_res);
}
}
#line 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
bool ldv_queue_delayed_work_on_130(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 561
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 561
  ldv_func_res = tmp;
#line 563
  activate_work_7(& ldv_func_arg3->work, 2);
#line 565
  return (ldv_func_res);
}
}
#line 568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
bool ldv_queue_work_on_131(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 572
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 572
  ldv_func_res = tmp;
#line 574
  activate_work_7(ldv_func_arg3, 2);
#line 576
  return (ldv_func_res);
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
void ldv_flush_workqueue_132(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 582
  flush_workqueue(ldv_func_arg1);
#line 584
  call_and_disable_all_7(2);
#line 585
  return;
}
}
#line 587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
bool ldv_queue_delayed_work_on_133(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 591
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 591
  ldv_func_res = tmp;
#line 593
  activate_work_7(& ldv_func_arg3->work, 2);
#line 595
  return (ldv_func_res);
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
int ldv_scsi_add_host_with_dma_134(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 602
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 602
  ldv_func_res = tmp;
#line 604
  if (ldv_func_res == 0) {
#line 605
    ldv_state_variable_88 = 1;
#line 605
    ldv_initialize_scsi_host_template_88();
  } else {

  }
#line 609
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
void ldv__builtin_va_end(__builtin_va_list * ) ;
#line 1
void ldv__builtin_va_start(__builtin_va_list * ) ;
#line 142 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_145(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_147(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_146(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_149(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_148(struct workqueue_struct *ldv_func_arg1 ) ;
#line 352 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
int reg_timer_20(struct timer_list *timer ) ;
#line 354
void disable_suitable_timer_20(struct timer_list *timer ) ;
#line 395
void activate_pending_timer_20(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 401
void choose_timer_20(struct timer_list *timer ) ;
#line 795 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_150(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
#line 545 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
void qla2xxx_dump_post_process(scsi_qla_host_t *vha , int rval ) ;
#line 352 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
int qla27xx_dump_mpi_ram(struct qla_hw_data *ha , uint32_t addr , uint32_t *ram ,
                         uint32_t ram_dwords , void **nxt ) ;
#line 354
int qla24xx_dump_ram(struct qla_hw_data *ha , uint32_t addr , uint32_t *ram , uint32_t ram_dwords ,
                     void **nxt ) ;
#line 356
void qla24xx_pause_risc(struct device_reg_24xx *reg , struct qla_hw_data *ha ) ;
#line 358
int qla24xx_soft_reset(struct qla_hw_data *ha ) ;
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
static uint32_t ql_dbg_offset  =    2048U;
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
__inline static void qla2xxx_prep_dump(struct qla_hw_data *ha , struct qla2xxx_fw_dump *fw_dump ) 
{ 
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;

  {
#line 86
  tmp = __fswab32((__u32 )ha->fw_major_version);
#line 86
  fw_dump->fw_major_version = tmp;
#line 87
  tmp___0 = __fswab32((__u32 )ha->fw_minor_version);
#line 87
  fw_dump->fw_minor_version = tmp___0;
#line 88
  tmp___1 = __fswab32((__u32 )ha->fw_subminor_version);
#line 88
  fw_dump->fw_subminor_version = tmp___1;
#line 89
  tmp___2 = __fswab32((__u32 )ha->fw_attributes);
#line 89
  fw_dump->fw_attributes = tmp___2;
#line 91
  tmp___3 = __fswab32((__u32 )(ha->pdev)->vendor);
#line 91
  fw_dump->vendor = tmp___3;
#line 92
  tmp___4 = __fswab32((__u32 )(ha->pdev)->device);
#line 92
  fw_dump->device = tmp___4;
#line 93
  tmp___5 = __fswab32((__u32 )(ha->pdev)->subsystem_vendor);
#line 93
  fw_dump->subsystem_vendor = tmp___5;
#line 94
  tmp___6 = __fswab32((__u32 )(ha->pdev)->subsystem_device);
#line 94
  fw_dump->subsystem_device = tmp___6;
#line 95
  return;
}
}
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
__inline static void *qla2xxx_copy_queues(struct qla_hw_data *ha , void *ptr ) 
{ 
  struct req_que *req ;
  struct rsp_que *rsp ;

  {
#line 100
  req = *(ha->req_q_map);
#line 101
  rsp = *(ha->rsp_q_map);
#line 103
  memcpy(ptr, (void const   *)req->ring, (unsigned long )req->length * 64UL);
#line 107
  ptr = ptr + (unsigned long )req->length * 64UL;
#line 108
  memcpy(ptr, (void const   *)rsp->ring, (unsigned long )rsp->length * 64UL);
#line 111
  return (ptr + (unsigned long )rsp->length * 64UL);
}
}
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
int qla27xx_dump_mpi_ram(struct qla_hw_data *ha , uint32_t addr , uint32_t *ram ,
                         uint32_t ram_dwords , void **nxt ) 
{ 
  int rval ;
  uint32_t cnt ;
  uint32_t stat ;
  uint32_t timer ;
  uint32_t dwords ;
  uint32_t idx ;
  uint16_t mb0 ;
  uint16_t mb1 ;
  struct device_reg_24xx *reg ;
  dma_addr_t dump_dma ;
  uint32_t *dump ;
  int tmp ;
  __u32 tmp___0 ;
  int tmp___1 ;

  {
#line 121
  reg = & (ha->iobase)->isp24;
#line 122
  dump_dma = ha->gid_list_dma;
#line 123
  dump = (uint32_t *)ha->gid_list;
#line 125
  rval = 0;
#line 126
  mb0 = 0U;
#line 128
  writew(5, (void volatile   *)(& reg->mailbox0));
#line 129
  clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 131
  tmp = qla2x00_gid_list_size(ha);
#line 131
  dwords = (uint32_t )(tmp / 4);
#line 132
  cnt = 0U;
#line 132
  goto ldv_65787;
  ldv_65786: ;
#line 134
  if (cnt + dwords > ram_dwords) {
#line 135
    dwords = ram_dwords - cnt;
  } else {

  }
#line 137
  writew((int )((unsigned short )addr), (void volatile   *)(& reg->mailbox1));
#line 138
  writew((int )((unsigned short )(addr >> 16)), (void volatile   *)(& reg->mailbox8));
#line 140
  writew((int )((unsigned short )((unsigned int )dump_dma >> 16)), (void volatile   *)(& reg->mailbox2));
#line 141
  writew((int )((unsigned short )dump_dma), (void volatile   *)(& reg->mailbox3));
#line 142
  writew((int )((unsigned short )((unsigned int )(dump_dma >> 32ULL) >> 16)), (void volatile   *)(& reg->mailbox6));
#line 143
  writew((int )((unsigned short )(dump_dma >> 32ULL)), (void volatile   *)(& reg->mailbox7));
#line 145
  writew((int )((unsigned short )(dwords >> 16)), (void volatile   *)(& reg->mailbox4));
#line 146
  writew((int )((unsigned short )dwords), (void volatile   *)(& reg->mailbox5));
#line 148
  writew(0, (void volatile   *)(& reg->mailbox9));
#line 149
  writel(1342177280U, (void volatile   *)(& reg->hccr));
#line 151
  ha->flags.mbox_int = 0U;
#line 152
  timer = 6000000U;
#line 152
  goto ldv_65782;
  ldv_65781: 
#line 154
  stat = readl((void const volatile   *)(& reg->host_status));
#line 155
  if ((stat & 32768U) != 0U) {
#line 156
    stat = stat & 255U;
#line 158
    if (((stat == 1U || stat == 2U) || stat == 16U) || stat == 17U) {
#line 160
      set_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 163
      mb0 = readw((void const volatile   *)(& reg->mailbox0));
#line 164
      mb1 = readw((void const volatile   *)(& reg->mailbox1));
#line 166
      writel(2684354560U, (void volatile   *)(& reg->hccr));
#line 168
      readl((void const volatile   *)(& reg->hccr));
#line 169
      goto ldv_65780;
    } else {

    }
#line 173
    writel(2684354560U, (void volatile   *)(& reg->hccr));
#line 174
    readl((void const volatile   *)(& reg->hccr));
  } else {

  }
#line 176
  __const_udelay(21475UL);
#line 152
  timer = timer - 1U;
  ldv_65782: ;
#line 152
  if (timer != 0U) {
#line 154
    goto ldv_65781;
  } else {

  }
  ldv_65780: 
#line 178
  ha->flags.mbox_int = 1U;
#line 180
  tmp___1 = test_and_clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 180
  if (tmp___1 != 0) {
#line 181
    rval = (int )mb0 & 16383;
#line 182
    idx = 0U;
#line 182
    goto ldv_65784;
    ldv_65783: ;
#line 183
    if ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) {
#line 183
      *(ram + (unsigned long )(cnt + idx)) = *(dump + (unsigned long )idx);
    } else {
#line 183
      tmp___0 = __fswab32(*(dump + (unsigned long )idx));
#line 183
      *(ram + (unsigned long )(cnt + idx)) = tmp___0;
    }
#line 182
    idx = idx + 1U;
    ldv_65784: ;
#line 182
    if (idx < dwords) {
#line 184
      goto ldv_65783;
    } else {

    }

  } else {
#line 186
    rval = 258;
  }
#line 133
  cnt = cnt + dwords;
#line 133
  addr = addr + dwords;
  ldv_65787: ;
#line 132
  if (cnt < ram_dwords && rval == 0) {
#line 134
    goto ldv_65786;
  } else {

  }
#line 190
  *nxt = rval == 0 ? (void *)ram + (unsigned long )cnt : (void *)0;
#line 191
  return (rval);
}
}
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
int qla24xx_dump_ram(struct qla_hw_data *ha , uint32_t addr , uint32_t *ram , uint32_t ram_dwords ,
                     void **nxt ) 
{ 
  int rval ;
  uint32_t cnt ;
  uint32_t stat ;
  uint32_t timer ;
  uint32_t dwords ;
  uint32_t idx ;
  uint16_t mb0 ;
  struct device_reg_24xx *reg ;
  dma_addr_t dump_dma ;
  uint32_t *dump ;
  int tmp ;
  __u32 tmp___0 ;
  int tmp___1 ;

  {
#line 201
  reg = & (ha->iobase)->isp24;
#line 202
  dump_dma = ha->gid_list_dma;
#line 203
  dump = (uint32_t *)ha->gid_list;
#line 205
  rval = 0;
#line 206
  mb0 = 0U;
#line 208
  writew(12, (void volatile   *)(& reg->mailbox0));
#line 209
  clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 211
  tmp = qla2x00_gid_list_size(ha);
#line 211
  dwords = (uint32_t )(tmp / 4);
#line 212
  cnt = 0U;
#line 212
  goto ldv_65813;
  ldv_65812: ;
#line 214
  if (cnt + dwords > ram_dwords) {
#line 215
    dwords = ram_dwords - cnt;
  } else {

  }
#line 217
  writew((int )((unsigned short )addr), (void volatile   *)(& reg->mailbox1));
#line 218
  writew((int )((unsigned short )(addr >> 16)), (void volatile   *)(& reg->mailbox8));
#line 220
  writew((int )((unsigned short )((unsigned int )dump_dma >> 16)), (void volatile   *)(& reg->mailbox2));
#line 221
  writew((int )((unsigned short )dump_dma), (void volatile   *)(& reg->mailbox3));
#line 222
  writew((int )((unsigned short )((unsigned int )(dump_dma >> 32ULL) >> 16)), (void volatile   *)(& reg->mailbox6));
#line 223
  writew((int )((unsigned short )(dump_dma >> 32ULL)), (void volatile   *)(& reg->mailbox7));
#line 225
  writew((int )((unsigned short )(dwords >> 16)), (void volatile   *)(& reg->mailbox4));
#line 226
  writew((int )((unsigned short )dwords), (void volatile   *)(& reg->mailbox5));
#line 227
  writel(1342177280U, (void volatile   *)(& reg->hccr));
#line 229
  ha->flags.mbox_int = 0U;
#line 230
  timer = 6000000U;
#line 230
  goto ldv_65808;
  ldv_65807: 
#line 232
  stat = readl((void const volatile   *)(& reg->host_status));
#line 233
  if ((stat & 32768U) != 0U) {
#line 234
    stat = stat & 255U;
#line 236
    if (((stat == 1U || stat == 2U) || stat == 16U) || stat == 17U) {
#line 238
      set_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 241
      mb0 = readw((void const volatile   *)(& reg->mailbox0));
#line 243
      writel(2684354560U, (void volatile   *)(& reg->hccr));
#line 245
      readl((void const volatile   *)(& reg->hccr));
#line 246
      goto ldv_65806;
    } else {

    }
#line 250
    writel(2684354560U, (void volatile   *)(& reg->hccr));
#line 251
    readl((void const volatile   *)(& reg->hccr));
  } else {

  }
#line 253
  __const_udelay(21475UL);
#line 230
  timer = timer - 1U;
  ldv_65808: ;
#line 230
  if (timer != 0U) {
#line 232
    goto ldv_65807;
  } else {

  }
  ldv_65806: 
#line 255
  ha->flags.mbox_int = 1U;
#line 257
  tmp___1 = test_and_clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 257
  if (tmp___1 != 0) {
#line 258
    rval = (int )mb0 & 16383;
#line 259
    idx = 0U;
#line 259
    goto ldv_65810;
    ldv_65809: ;
#line 260
    if ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) {
#line 260
      *(ram + (unsigned long )(cnt + idx)) = *(dump + (unsigned long )idx);
    } else {
#line 260
      tmp___0 = __fswab32(*(dump + (unsigned long )idx));
#line 260
      *(ram + (unsigned long )(cnt + idx)) = tmp___0;
    }
#line 259
    idx = idx + 1U;
    ldv_65810: ;
#line 259
    if (idx < dwords) {
#line 261
      goto ldv_65809;
    } else {

    }

  } else {
#line 263
    rval = 258;
  }
#line 213
  cnt = cnt + dwords;
#line 213
  addr = addr + dwords;
  ldv_65813: ;
#line 212
  if (cnt < ram_dwords && rval == 0) {
#line 214
    goto ldv_65812;
  } else {

  }
#line 267
  *nxt = rval == 0 ? (void *)ram + (unsigned long )cnt : (void *)0;
#line 268
  return (rval);
}
}
#line 272 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
static int qla24xx_dump_memory(struct qla_hw_data *ha , uint32_t *code_ram , uint32_t cram_size ,
                               void **nxt ) 
{ 
  int rval ;

  {
#line 278
  rval = qla24xx_dump_ram(ha, 131072U, code_ram, cram_size / 4U, nxt);
#line 279
  if (rval != 0) {
#line 280
    return (rval);
  } else {

  }
#line 282
  set_bit(4L, (unsigned long volatile   *)(& ha->fw_dump_cap_flags));
#line 285
  rval = qla24xx_dump_ram(ha, 1048576U, (uint32_t *)*nxt, ha->fw_memory_size - 1048575U,
                          nxt);
#line 287
  if (rval == 0) {
#line 288
    set_bit(5L, (unsigned long volatile   *)(& ha->fw_dump_cap_flags));
  } else {

  }
#line 290
  return (rval);
}
}
#line 294 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
static uint32_t *qla24xx_read_window(struct device_reg_24xx *reg , uint32_t iobase ,
                                     uint32_t count , uint32_t *buf ) 
{ 
  uint32_t *dmp_reg ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  unsigned int tmp___1 ;
  __u32 tmp___2 ;
  uint32_t tmp___3 ;

  {
#line 299
  writel(iobase, (void volatile   *)(& reg->iobase_addr));
#line 300
  dmp_reg = & reg->iobase_window;
#line 301
  goto ldv_65830;
  ldv_65829: 
#line 302
  tmp = buf;
#line 302
  buf = buf + 1;
#line 302
  tmp___0 = dmp_reg;
#line 302
  dmp_reg = dmp_reg + 1;
#line 302
  tmp___1 = readl((void const volatile   *)tmp___0);
#line 302
  tmp___2 = __fswab32(tmp___1);
#line 302
  *tmp = tmp___2;
  ldv_65830: 
#line 301
  tmp___3 = count;
#line 301
  count = count - 1U;
#line 301
  if (tmp___3 != 0U) {
#line 303
    goto ldv_65829;
  } else {

  }

#line 304
  return (buf);
}
}
#line 308 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
void qla24xx_pause_risc(struct device_reg_24xx *reg , struct qla_hw_data *ha ) 
{ 
  unsigned int tmp ;

  {
#line 310
  writel(805306368U, (void volatile   *)(& reg->hccr));
#line 313
  __const_udelay(429500UL);
#line 314
  tmp = readl((void const volatile   *)(& reg->host_status));
#line 314
  if ((tmp & 256U) != 0U) {
#line 315
    set_bit(0L, (unsigned long volatile   *)(& ha->fw_dump_cap_flags));
  } else {

  }
#line 316
  return;
}
}
#line 319 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
int qla24xx_soft_reset(struct qla_hw_data *ha ) 
{ 
  int rval ;
  uint32_t cnt ;
  uint16_t wd ;
  struct device_reg_24xx *reg ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned short tmp___3 ;

  {
#line 321
  rval = 0;
#line 324
  reg = & (ha->iobase)->isp24;
#line 331
  writel(65584U, (void volatile   *)(& reg->ctrl_status));
#line 332
  cnt = 0U;
#line 332
  goto ldv_65845;
  ldv_65844: 
#line 333
  tmp = readl((void const volatile   *)(& reg->ctrl_status));
#line 333
  if ((tmp & 131072U) == 0U) {
#line 334
    goto ldv_65843;
  } else {

  }
#line 336
  __const_udelay(42950UL);
#line 332
  cnt = cnt + 1U;
  ldv_65845: ;
#line 332
  if (cnt <= 29999U) {
#line 334
    goto ldv_65844;
  } else {

  }
  ldv_65843: 
#line 338
  tmp___0 = readl((void const volatile   *)(& reg->ctrl_status));
#line 338
  if ((tmp___0 & 131072U) == 0U) {
#line 339
    set_bit(1L, (unsigned long volatile   *)(& ha->fw_dump_cap_flags));
  } else {

  }
#line 341
  writel(65585U, (void volatile   *)(& reg->ctrl_status));
#line 343
  pci_read_config_word((struct pci_dev  const  *)ha->pdev, 4, & wd);
#line 345
  __const_udelay(429500UL);
#line 348
  cnt = 0U;
#line 348
  goto ldv_65848;
  ldv_65847: 
#line 349
  tmp___1 = readl((void const volatile   *)(& reg->ctrl_status));
#line 349
  if ((tmp___1 & 1U) == 0U) {
#line 351
    goto ldv_65846;
  } else {

  }
#line 353
  __const_udelay(42950UL);
#line 348
  cnt = cnt + 1U;
  ldv_65848: ;
#line 348
  if (cnt <= 29999U) {
#line 350
    goto ldv_65847;
  } else {

  }
  ldv_65846: 
#line 355
  tmp___2 = readl((void const volatile   *)(& reg->ctrl_status));
#line 355
  if ((tmp___2 & 1U) == 0U) {
#line 356
    set_bit(2L, (unsigned long volatile   *)(& ha->fw_dump_cap_flags));
  } else {

  }
#line 358
  writel(536870912U, (void volatile   *)(& reg->hccr));
#line 359
  readl((void const volatile   *)(& reg->hccr));
#line 361
  cnt = 10000U;
#line 361
  goto ldv_65850;
  ldv_65849: ;
#line 363
  if (cnt != 0U) {
#line 364
    __const_udelay(42950UL);
  } else {
#line 366
    rval = 256;
  }
#line 362
  cnt = cnt - 1U;
  ldv_65850: 
#line 361
  tmp___3 = readw((void const volatile   *)(& reg->mailbox0));
#line 361
  if ((unsigned int )tmp___3 != 0U && rval == 0) {
#line 364
    goto ldv_65849;
  } else {

  }

#line 368
  if (rval == 0) {
#line 369
    set_bit(3L, (unsigned long volatile   *)(& ha->fw_dump_cap_flags));
  } else {

  }
#line 371
  return (rval);
}
}
#line 375 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
static int qla2xxx_dump_ram(struct qla_hw_data *ha , uint32_t addr , uint16_t *ram ,
                            uint32_t ram_words , void **nxt ) 
{ 
  int rval ;
  uint32_t cnt ;
  uint32_t stat ;
  uint32_t timer ;
  uint32_t words ;
  uint32_t idx ;
  uint16_t mb0 ;
  struct device_reg_2xxx *reg ;
  dma_addr_t dump_dma ;
  uint16_t *dump ;
  int tmp ;
  __u16 tmp___0 ;
  int tmp___1 ;

  {
#line 381
  reg = & (ha->iobase)->isp;
#line 382
  dump_dma = ha->gid_list_dma;
#line 383
  dump = (uint16_t *)ha->gid_list;
#line 385
  rval = 0;
#line 386
  mb0 = 0U;
#line 388
  writew(12, (void volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 : & reg->u.isp2300.mailbox0));
#line 389
  clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 391
  tmp = qla2x00_gid_list_size(ha);
#line 391
  words = (uint32_t )(tmp / 2);
#line 392
  cnt = 0U;
#line 392
  goto ldv_65876;
  ldv_65875: ;
#line 394
  if (cnt + words > ram_words) {
#line 395
    words = ram_words - cnt;
  } else {

  }
#line 397
  writew((int )((unsigned short )addr), (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void volatile   *)(& reg->u.isp2100.mailbox0) + 1U : (void volatile   *)(& reg->u.isp2300.mailbox0) + 1U);
#line 398
  writew((int )((unsigned short )(addr >> 16)), (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void volatile   *)(& reg->u_end.isp2200.mailbox8) : (void volatile   *)(& reg->u.isp2300.mailbox0) + 8U);
#line 400
  writew((int )((unsigned short )((unsigned int )dump_dma >> 16)), (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void volatile   *)(& reg->u.isp2100.mailbox0) + 2U : (void volatile   *)(& reg->u.isp2300.mailbox0) + 2U);
#line 401
  writew((int )((unsigned short )dump_dma), (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void volatile   *)(& reg->u.isp2100.mailbox0) + 3U : (void volatile   *)(& reg->u.isp2300.mailbox0) + 3U);
#line 402
  writew((int )((unsigned short )((unsigned int )(dump_dma >> 32ULL) >> 16)), (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void volatile   *)(& reg->u.isp2100.mailbox0) + 6U : (void volatile   *)(& reg->u.isp2300.mailbox0) + 6U);
#line 403
  writew((int )((unsigned short )(dump_dma >> 32ULL)), (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void volatile   *)(& reg->u.isp2100.mailbox0) + 7U : (void volatile   *)(& reg->u.isp2300.mailbox0) + 7U);
#line 405
  writew((int )((unsigned short )words), (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void volatile   *)(& reg->u.isp2100.mailbox0) + 4U : (void volatile   *)(& reg->u.isp2300.mailbox0) + 4U);
#line 406
  writew(20480, (void volatile   *)(& reg->hccr));
#line 408
  timer = 6000000U;
#line 408
  goto ldv_65871;
  ldv_65870: 
#line 410
  stat = readl((void const volatile   *)(& reg->u.isp2300.host_status));
#line 411
  if ((stat & 32768U) != 0U) {
#line 412
    stat = stat & 255U;
#line 414
    if (stat == 1U || stat == 2U) {
#line 415
      set_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 418
      mb0 = readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 : & reg->u.isp2300.mailbox0));
#line 421
      writew(0, (void volatile   *)(& reg->semaphore));
#line 422
      writew(28672, (void volatile   *)(& reg->hccr));
#line 424
      readw((void const volatile   *)(& reg->hccr));
#line 425
      goto ldv_65869;
    } else
#line 426
    if (stat == 16U || stat == 17U) {
#line 427
      set_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 430
      mb0 = readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 : & reg->u.isp2300.mailbox0));
#line 432
      writew(28672, (void volatile   *)(& reg->hccr));
#line 434
      readw((void const volatile   *)(& reg->hccr));
#line 435
      goto ldv_65869;
    } else {

    }
#line 439
    writew(28672, (void volatile   *)(& reg->hccr));
#line 440
    readw((void const volatile   *)(& reg->hccr));
  } else {

  }
#line 442
  __const_udelay(21475UL);
#line 408
  timer = timer - 1U;
  ldv_65871: ;
#line 408
  if (timer != 0U) {
#line 410
    goto ldv_65870;
  } else {

  }
  ldv_65869: 
#line 445
  tmp___1 = test_and_clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 445
  if (tmp___1 != 0) {
#line 446
    rval = (int )mb0 & 16383;
#line 447
    idx = 0U;
#line 447
    goto ldv_65873;
    ldv_65872: 
#line 448
    tmp___0 = __fswab16((int )*(dump + (unsigned long )idx));
#line 448
    *(ram + (unsigned long )(cnt + idx)) = tmp___0;
#line 447
    idx = idx + 1U;
    ldv_65873: ;
#line 447
    if (idx < words) {
#line 449
      goto ldv_65872;
    } else {

    }

  } else {
#line 450
    rval = 258;
  }
#line 393
  cnt = cnt + words;
#line 393
  addr = addr + words;
  ldv_65876: ;
#line 392
  if (cnt < ram_words && rval == 0) {
#line 394
    goto ldv_65875;
  } else {

  }
#line 454
  *nxt = rval == 0 ? (void *)ram + (unsigned long )cnt : (void *)0;
#line 455
  return (rval);
}
}
#line 459 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
__inline static void qla2xxx_read_window(struct device_reg_2xxx *reg , uint32_t count ,
                                         uint16_t *buf ) 
{ 
  uint16_t *dmp_reg ;
  uint16_t *tmp ;
  uint16_t *tmp___0 ;
  unsigned short tmp___1 ;
  __u16 tmp___2 ;
  uint32_t tmp___3 ;

  {
#line 462
  dmp_reg = & reg->u.isp2300.fb_cmd;
#line 464
  goto ldv_65885;
  ldv_65884: 
#line 465
  tmp = buf;
#line 465
  buf = buf + 1;
#line 465
  tmp___0 = dmp_reg;
#line 465
  dmp_reg = dmp_reg + 1;
#line 465
  tmp___1 = readw((void const volatile   *)tmp___0);
#line 465
  tmp___2 = __fswab16((int )tmp___1);
#line 465
  *tmp = tmp___2;
  ldv_65885: 
#line 464
  tmp___3 = count;
#line 464
  count = count - 1U;
#line 464
  if (tmp___3 != 0U) {
#line 466
    goto ldv_65884;
  } else {

  }

#line 471
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
__inline static void *qla24xx_copy_eft(struct qla_hw_data *ha , void *ptr ) 
{ 
  __u32 tmp ;
  __u32 tmp___0 ;

  {
#line 471
  if ((unsigned long )ha->eft == (unsigned long )((void *)0)) {
#line 472
    return (ptr);
  } else {

  }
#line 474
  tmp = __fswab32((ha->fw_dump)->eft_size);
#line 474
  memcpy(ptr, (void const   *)ha->eft, (size_t )tmp);
#line 475
  tmp___0 = __fswab32((ha->fw_dump)->eft_size);
#line 475
  return (ptr + (unsigned long )tmp___0);
}
}
#line 479 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
__inline static void *qla25xx_copy_fce(struct qla_hw_data *ha , void *ptr , uint32_t **last_chain ) 
{ 
  uint32_t cnt ;
  uint32_t *iter_reg ;
  struct qla2xxx_fce_chain *fcec ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  uint32_t *tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;

  {
#line 483
  fcec = (struct qla2xxx_fce_chain *)ptr;
#line 485
  if ((unsigned long )ha->fce == (unsigned long )((void *)0)) {
#line 486
    return (ptr);
  } else {

  }
#line 488
  *last_chain = & fcec->type;
#line 489
  fcec->type = 4042981247U;
#line 490
  tmp = __fswab32(ha->fce_bufs * 1024U + 52U);
#line 490
  fcec->chain_size = tmp;
#line 492
  tmp___0 = __fswab32(ha->fce_bufs * 1024U);
#line 492
  fcec->size = tmp___0;
#line 493
  tmp___1 = __fswab32((unsigned int )ha->fce_dma);
#line 493
  fcec->addr_l = tmp___1;
#line 494
  tmp___2 = __fswab32((unsigned int )(ha->fce_dma >> 32ULL));
#line 494
  fcec->addr_h = tmp___2;
#line 496
  iter_reg = (uint32_t *)(& fcec->eregs);
#line 497
  cnt = 0U;
#line 497
  goto ldv_65900;
  ldv_65899: 
#line 498
  tmp___3 = iter_reg;
#line 498
  iter_reg = iter_reg + 1;
#line 498
  tmp___4 = __fswab32((__u32 )ha->fce_mb[cnt]);
#line 498
  *tmp___3 = tmp___4;
#line 497
  cnt = cnt + 1U;
  ldv_65900: ;
#line 497
  if (cnt <= 7U) {
#line 499
    goto ldv_65899;
  } else {

  }
#line 500
  tmp___5 = __fswab32(fcec->size);
#line 500
  memcpy((void *)iter_reg, (void const   *)ha->fce, (size_t )tmp___5);
#line 502
  tmp___6 = __fswab32(fcec->size);
#line 502
  return ((void *)iter_reg + (unsigned long )tmp___6);
}
}
#line 506 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
__inline static void *qla2xxx_copy_atioqueues(struct qla_hw_data *ha , void *ptr ,
                                              uint32_t **last_chain ) 
{ 
  struct qla2xxx_mqueue_chain *q ;
  struct qla2xxx_mqueue_header *qh ;
  uint32_t num_queues ;
  int que ;
  struct __anonstruct_aq_521 aq ;
  struct __anonstruct_aqp_522 *aqp ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;

  {
#line 518
  if ((unsigned long )ha->tgt.atio_ring == (unsigned long )((struct atio *)0)) {
#line 519
    return (ptr);
  } else {

  }
#line 521
  num_queues = 1U;
#line 522
  aqp = & aq;
#line 523
  aqp->length = (int )ha->tgt.atio_q_length;
#line 524
  aqp->ring = (void *)ha->tgt.atio_ring;
#line 526
  que = 0;
#line 526
  goto ldv_65917;
  ldv_65916: 
#line 528
  q = (struct qla2xxx_mqueue_chain *)ptr;
#line 529
  *last_chain = & q->type;
#line 530
  q->type = 4076535679U;
#line 531
  tmp = __fswab32((__u32 )((unsigned long )aqp->length) * 64U + 20U);
#line 531
  q->chain_size = tmp;
#line 535
  ptr = ptr + 8UL;
#line 538
  qh = (struct qla2xxx_mqueue_header *)ptr;
#line 539
  qh->queue = 50331648U;
#line 540
  tmp___0 = __fswab32((__u32 )que);
#line 540
  qh->number = tmp___0;
#line 541
  tmp___1 = __fswab32((__u32 )((unsigned long )aqp->length) * 64U);
#line 541
  qh->size = tmp___1;
#line 542
  ptr = ptr + 12UL;
#line 545
  memcpy(ptr, (void const   *)aqp->ring, (unsigned long )aqp->length * 64UL);
#line 547
  ptr = ptr + (unsigned long )aqp->length * 64UL;
#line 526
  que = que + 1;
  ldv_65917: ;
#line 526
  if ((uint32_t )que < num_queues) {
#line 528
    goto ldv_65916;
  } else {

  }

#line 550
  return (ptr);
}
}
#line 554 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
__inline static void *qla25xx_copy_mqueues(struct qla_hw_data *ha , void *ptr , uint32_t **last_chain ) 
{ 
  struct qla2xxx_mqueue_chain *q ;
  struct qla2xxx_mqueue_header *qh ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  int que ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;

  {
#line 562
  if ((unsigned int )ha->mqenable == 0U) {
#line 563
    return (ptr);
  } else {

  }
#line 566
  que = 1;
#line 566
  goto ldv_65931;
  ldv_65930: 
#line 567
  req = *(ha->req_q_map + (unsigned long )que);
#line 568
  if ((unsigned long )req == (unsigned long )((struct req_que *)0)) {
#line 569
    goto ldv_65929;
  } else {

  }
#line 572
  q = (struct qla2xxx_mqueue_chain *)ptr;
#line 573
  *last_chain = & q->type;
#line 574
  q->type = 4076535679U;
#line 575
  tmp = __fswab32((__u32 )req->length * 64U + 20U);
#line 575
  q->chain_size = tmp;
#line 579
  ptr = ptr + 8UL;
#line 582
  qh = (struct qla2xxx_mqueue_header *)ptr;
#line 583
  qh->queue = 16777216U;
#line 584
  tmp___0 = __fswab32((__u32 )que);
#line 584
  qh->number = tmp___0;
#line 585
  tmp___1 = __fswab32((__u32 )req->length * 64U);
#line 585
  qh->size = tmp___1;
#line 586
  ptr = ptr + 12UL;
#line 589
  memcpy(ptr, (void const   *)req->ring, (unsigned long )req->length * 64UL);
#line 590
  ptr = ptr + (unsigned long )req->length * 64UL;
#line 566
  que = que + 1;
  ldv_65931: ;
#line 566
  if ((int )ha->max_req_queues > que) {
#line 568
    goto ldv_65930;
  } else {

  }
  ldv_65929: 
#line 594
  que = 1;
#line 594
  goto ldv_65934;
  ldv_65933: 
#line 595
  rsp = *(ha->rsp_q_map + (unsigned long )que);
#line 596
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 597
    goto ldv_65932;
  } else {

  }
#line 600
  q = (struct qla2xxx_mqueue_chain *)ptr;
#line 601
  *last_chain = & q->type;
#line 602
  q->type = 4076535679U;
#line 603
  tmp___2 = __fswab32((__u32 )rsp->length * 64U + 20U);
#line 603
  q->chain_size = tmp___2;
#line 607
  ptr = ptr + 8UL;
#line 610
  qh = (struct qla2xxx_mqueue_header *)ptr;
#line 611
  qh->queue = 33554432U;
#line 612
  tmp___3 = __fswab32((__u32 )que);
#line 612
  qh->number = tmp___3;
#line 613
  tmp___4 = __fswab32((__u32 )rsp->length * 64U);
#line 613
  qh->size = tmp___4;
#line 614
  ptr = ptr + 12UL;
#line 617
  memcpy(ptr, (void const   *)rsp->ring, (unsigned long )rsp->length * 64UL);
#line 618
  ptr = ptr + (unsigned long )rsp->length * 64UL;
#line 594
  que = que + 1;
  ldv_65934: ;
#line 594
  if ((int )ha->max_rsp_queues > que) {
#line 596
    goto ldv_65933;
  } else {

  }
  ldv_65932: ;
#line 621
  return (ptr);
}
}
#line 625 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
__inline static void *qla25xx_copy_mq(struct qla_hw_data *ha , void *ptr , uint32_t **last_chain ) 
{ 
  uint32_t cnt ;
  uint32_t que_idx ;
  uint8_t que_cnt ;
  struct qla2xxx_mq_chain *mq ;
  device_reg_t *reg ;
  __u32 tmp ;
  unsigned int tmp___0 ;
  __u32 tmp___1 ;
  unsigned int tmp___2 ;
  __u32 tmp___3 ;
  unsigned int tmp___4 ;
  __u32 tmp___5 ;
  unsigned int tmp___6 ;
  __u32 tmp___7 ;

  {
#line 629
  mq = (struct qla2xxx_mq_chain *)ptr;
#line 632
  if (((unsigned int )ha->mqenable == 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 633
    return (ptr);
  } else {

  }
#line 635
  mq = (struct qla2xxx_mq_chain *)ptr;
#line 636
  *last_chain = & mq->type;
#line 637
  mq->type = 4059758463U;
#line 638
  mq->chain_size = 201457664U;
#line 640
  que_cnt = (uint8_t )((int )ha->max_req_queues > (int )ha->max_rsp_queues ? ha->max_req_queues : ha->max_rsp_queues);
#line 642
  tmp = __fswab32((__u32 )que_cnt);
#line 642
  mq->count = tmp;
#line 643
  cnt = 0U;
#line 643
  goto ldv_65946;
  ldv_65945: 
#line 644
  reg = ((unsigned int )ha->mqenable != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) ? ha->mqiobase + (unsigned long )(cnt * 4096U) : ha->iobase;
#line 645
  que_idx = cnt * 4U;
#line 646
  tmp___0 = readl((void const volatile   *)(& reg->isp25mq.req_q_in));
#line 646
  tmp___1 = __fswab32(tmp___0);
#line 646
  mq->qregs[que_idx] = tmp___1;
#line 648
  tmp___2 = readl((void const volatile   *)(& reg->isp25mq.req_q_out));
#line 648
  tmp___3 = __fswab32(tmp___2);
#line 648
  mq->qregs[que_idx + 1U] = tmp___3;
#line 650
  tmp___4 = readl((void const volatile   *)(& reg->isp25mq.rsp_q_in));
#line 650
  tmp___5 = __fswab32(tmp___4);
#line 650
  mq->qregs[que_idx + 2U] = tmp___5;
#line 652
  tmp___6 = readl((void const volatile   *)(& reg->isp25mq.rsp_q_out));
#line 652
  tmp___7 = __fswab32(tmp___6);
#line 652
  mq->qregs[que_idx + 3U] = tmp___7;
#line 643
  cnt = cnt + 1U;
  ldv_65946: ;
#line 643
  if ((uint32_t )que_cnt > cnt) {
#line 645
    goto ldv_65945;
  } else {

  }

#line 656
  return (ptr + 524UL);
}
}
#line 660 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
void qla2xxx_dump_post_process(scsi_qla_host_t *vha , int rval ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 662
  ha = vha->hw;
#line 664
  if (rval != 0) {
#line 665
    ql_log(1U, vha, 53248, "Failed to dump firmware (%x), dump status flags (0x%lx).\n",
           rval, ha->fw_dump_cap_flags);
#line 668
    ha->fw_dumped = 0;
  } else {
#line 670
    ql_log(2U, vha, 53249, "Firmware dump saved to temp buffer (%ld/%p), dump status flags (0x%lx).\n",
           vha->host_no, ha->fw_dump, ha->fw_dump_cap_flags);
#line 673
    ha->fw_dumped = 1;
#line 674
    qla2x00_post_uevent_work(vha, 0U);
  }
#line 676
  return;
}
}
#line 684 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
void qla2300_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) 
{ 
  int rval ;
  uint32_t cnt ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  uint16_t *dmp_reg ;
  unsigned long flags ;
  struct qla2300_fw_dump *fw ;
  void *nxt ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned short tmp___1 ;
  __u16 tmp___2 ;
  unsigned short tmp___3 ;
  uint16_t *tmp___4 ;
  unsigned short tmp___5 ;
  __u16 tmp___6 ;
  uint16_t *tmp___7 ;
  unsigned short tmp___8 ;
  __u16 tmp___9 ;
  uint16_t *tmp___10 ;
  unsigned short tmp___11 ;
  __u16 tmp___12 ;
  uint16_t *tmp___13 ;
  unsigned short tmp___14 ;
  __u16 tmp___15 ;
  unsigned short tmp___16 ;
  unsigned short tmp___17 ;

  {
#line 688
  ha = vha->hw;
#line 689
  reg = & (ha->iobase)->isp;
#line 694
  tmp = pci_get_drvdata(ha->pdev);
#line 694
  base_vha = (struct scsi_qla_host *)tmp;
#line 696
  flags = 0UL;
#line 698
  if (hardware_locked == 0) {
#line 699
    tmp___0 = spinlock_check(& ha->hardware_lock);
#line 699
    flags = _raw_spin_lock_irqsave(tmp___0);
  } else {

  }
#line 701
  if ((unsigned long )ha->fw_dump == (unsigned long )((struct qla2xxx_fw_dump *)0)) {
#line 702
    ql_log(1U, vha, 53250, "No buffer available for dump.\n");
#line 704
    goto qla2300_fw_dump_failed;
  } else {

  }
#line 707
  if (ha->fw_dumped != 0) {
#line 708
    ql_log(1U, vha, 53251, "Firmware has been previously dumped (%p) -- ignoring request.\n",
           ha->fw_dump);
#line 712
    goto qla2300_fw_dump_failed;
  } else {

  }
#line 714
  fw = & (ha->fw_dump)->isp.isp23;
#line 715
  qla2xxx_prep_dump(ha, ha->fw_dump);
#line 717
  rval = 0;
#line 718
  tmp___1 = readw((void const volatile   *)(& reg->hccr));
#line 718
  tmp___2 = __fswab16((int )tmp___1);
#line 718
  fw->hccr = tmp___2;
#line 721
  writew(8192, (void volatile   *)(& reg->hccr));
#line 722
  if ((ha->device_type & 4U) != 0U) {
#line 723
    cnt = 30000U;
#line 723
    goto ldv_65971;
    ldv_65970: ;
#line 726
    if (cnt != 0U) {
#line 727
      __const_udelay(429500UL);
    } else {
#line 729
      rval = 256;
    }
#line 725
    cnt = cnt - 1U;
    ldv_65971: 
#line 723
    tmp___3 = readw((void const volatile   *)(& reg->hccr));
#line 723
    if (((int )tmp___3 & 32) == 0 && rval == 0) {
#line 727
      goto ldv_65970;
    } else {

    }

  } else {
#line 732
    readw((void const volatile   *)(& reg->hccr));
#line 733
    __const_udelay(42950UL);
  }
#line 736
  if (rval == 0) {
#line 737
    dmp_reg = & reg->flash_address;
#line 738
    cnt = 0U;
#line 738
    goto ldv_65974;
    ldv_65973: 
#line 739
    tmp___4 = dmp_reg;
#line 739
    dmp_reg = dmp_reg + 1;
#line 739
    tmp___5 = readw((void const volatile   *)tmp___4);
#line 739
    tmp___6 = __fswab16((int )tmp___5);
#line 739
    fw->pbiu_reg[cnt] = tmp___6;
#line 738
    cnt = cnt + 1U;
    ldv_65974: ;
#line 738
    if (cnt <= 7U) {
#line 740
      goto ldv_65973;
    } else {

    }
#line 741
    dmp_reg = & reg->u.isp2300.req_q_in;
#line 742
    cnt = 0U;
#line 742
    goto ldv_65977;
    ldv_65976: 
#line 743
    tmp___7 = dmp_reg;
#line 743
    dmp_reg = dmp_reg + 1;
#line 743
    tmp___8 = readw((void const volatile   *)tmp___7);
#line 743
    tmp___9 = __fswab16((int )tmp___8);
#line 743
    fw->risc_host_reg[cnt] = tmp___9;
#line 742
    cnt = cnt + 1U;
    ldv_65977: ;
#line 742
    if (cnt <= 7U) {
#line 744
      goto ldv_65976;
    } else {

    }
#line 745
    dmp_reg = & reg->u.isp2300.mailbox0;
#line 746
    cnt = 0U;
#line 746
    goto ldv_65980;
    ldv_65979: 
#line 747
    tmp___10 = dmp_reg;
#line 747
    dmp_reg = dmp_reg + 1;
#line 747
    tmp___11 = readw((void const volatile   *)tmp___10);
#line 747
    tmp___12 = __fswab16((int )tmp___11);
#line 747
    fw->mailbox_reg[cnt] = tmp___12;
#line 746
    cnt = cnt + 1U;
    ldv_65980: ;
#line 746
    if (cnt <= 31U) {
#line 748
      goto ldv_65979;
    } else {

    }
#line 749
    writew(64, (void volatile   *)(& reg->ctrl_status));
#line 750
    qla2xxx_read_window(reg, 32U, (uint16_t *)(& fw->resp_dma_reg));
#line 752
    writew(80, (void volatile   *)(& reg->ctrl_status));
#line 753
    qla2xxx_read_window(reg, 48U, (uint16_t *)(& fw->dma_reg));
#line 755
    writew(0, (void volatile   *)(& reg->ctrl_status));
#line 756
    dmp_reg = & reg->risc_hw;
#line 757
    cnt = 0U;
#line 757
    goto ldv_65983;
    ldv_65982: 
#line 758
    tmp___13 = dmp_reg;
#line 758
    dmp_reg = dmp_reg + 1;
#line 758
    tmp___14 = readw((void const volatile   *)tmp___13);
#line 758
    tmp___15 = __fswab16((int )tmp___14);
#line 758
    fw->risc_hdw_reg[cnt] = tmp___15;
#line 757
    cnt = cnt + 1U;
    ldv_65983: ;
#line 757
    if (cnt <= 15U) {
#line 759
      goto ldv_65982;
    } else {

    }
#line 760
    writew(8192, (void volatile   *)(& reg->pcr));
#line 761
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp0_reg));
#line 763
    writew(8704, (void volatile   *)(& reg->pcr));
#line 764
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp1_reg));
#line 766
    writew(9216, (void volatile   *)(& reg->pcr));
#line 767
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp2_reg));
#line 769
    writew(9728, (void volatile   *)(& reg->pcr));
#line 770
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp3_reg));
#line 772
    writew(10240, (void volatile   *)(& reg->pcr));
#line 773
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp4_reg));
#line 775
    writew(10752, (void volatile   *)(& reg->pcr));
#line 776
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp5_reg));
#line 778
    writew(11264, (void volatile   *)(& reg->pcr));
#line 779
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp6_reg));
#line 781
    writew(11776, (void volatile   *)(& reg->pcr));
#line 782
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp7_reg));
#line 784
    writew(16, (void volatile   *)(& reg->ctrl_status));
#line 785
    qla2xxx_read_window(reg, 64U, (uint16_t *)(& fw->frame_buf_hdw_reg));
#line 787
    writew(32, (void volatile   *)(& reg->ctrl_status));
#line 788
    qla2xxx_read_window(reg, 64U, (uint16_t *)(& fw->fpm_b0_reg));
#line 790
    writew(48, (void volatile   *)(& reg->ctrl_status));
#line 791
    qla2xxx_read_window(reg, 64U, (uint16_t *)(& fw->fpm_b1_reg));
#line 794
    writew(1, (void volatile   *)(& reg->ctrl_status));
#line 795
    cnt = 0U;
#line 795
    goto ldv_65987;
    ldv_65986: 
#line 796
    tmp___16 = readw((void const volatile   *)(& reg->ctrl_status));
#line 796
    if (((int )tmp___16 & 1) == 0) {
#line 798
      goto ldv_65985;
    } else {

    }
#line 800
    __const_udelay(42950UL);
#line 795
    cnt = cnt + 1U;
    ldv_65987: ;
#line 795
    if (cnt <= 29999U) {
#line 797
      goto ldv_65986;
    } else {

    }
    ldv_65985: ;
  } else {

  }
#line 804
  if ((ha->device_type & 4U) == 0U) {
#line 805
    cnt = 30000U;
#line 805
    goto ldv_65989;
    ldv_65988: ;
#line 807
    if (cnt != 0U) {
#line 808
      __const_udelay(429500UL);
    } else {
#line 810
      rval = 256;
    }
#line 806
    cnt = cnt - 1U;
    ldv_65989: 
#line 805
    tmp___17 = readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 : & reg->u.isp2300.mailbox0));
#line 805
    if ((unsigned int )tmp___17 != 0U && rval == 0) {
#line 808
      goto ldv_65988;
    } else {

    }

  } else {

  }
#line 815
  if (rval == 0) {
#line 816
    rval = qla2xxx_dump_ram(ha, 2048U, (uint16_t *)(& fw->risc_ram), 63488U, & nxt);
  } else {

  }
#line 820
  if (rval == 0) {
#line 821
    rval = qla2xxx_dump_ram(ha, 65536U, (uint16_t *)(& fw->stack_ram), 4096U, & nxt);
  } else {

  }
#line 825
  if (rval == 0) {
#line 826
    rval = qla2xxx_dump_ram(ha, 69632U, (uint16_t *)(& fw->data_ram), ha->fw_memory_size - 69631U,
                            & nxt);
  } else {

  }
#line 829
  if (rval == 0) {
#line 830
    qla2xxx_copy_queues(ha, nxt);
  } else {

  }
#line 832
  qla2xxx_dump_post_process(base_vha, rval);
  qla2300_fw_dump_failed: ;
#line 835
  if (hardware_locked == 0) {
#line 836
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
  } else {

  }
#line 837
  return;
}
}
#line 845 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
void qla2100_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) 
{ 
  int rval ;
  uint32_t cnt ;
  uint32_t timer ;
  uint16_t risc_address ;
  uint16_t mb0 ;
  uint16_t mb2 ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  uint16_t *dmp_reg ;
  unsigned long flags ;
  struct qla2100_fw_dump *fw ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned short tmp___1 ;
  __u16 tmp___2 ;
  unsigned short tmp___3 ;
  uint16_t *tmp___4 ;
  unsigned short tmp___5 ;
  __u16 tmp___6 ;
  uint16_t *tmp___7 ;
  unsigned short tmp___8 ;
  __u16 tmp___9 ;
  uint16_t *tmp___10 ;
  unsigned short tmp___11 ;
  __u16 tmp___12 ;
  uint16_t *tmp___13 ;
  unsigned short tmp___14 ;
  __u16 tmp___15 ;
  unsigned short tmp___16 ;
  unsigned short tmp___17 ;
  unsigned short tmp___18 ;
  unsigned short tmp___19 ;
  unsigned short tmp___20 ;
  __u16 tmp___21 ;
  int tmp___22 ;

  {
#line 851
  ha = vha->hw;
#line 852
  reg = & (ha->iobase)->isp;
#line 856
  tmp = pci_get_drvdata(ha->pdev);
#line 856
  base_vha = (struct scsi_qla_host *)tmp;
#line 858
  risc_address = 0U;
#line 859
  mb2 = 0U;
#line 859
  mb0 = mb2;
#line 860
  flags = 0UL;
#line 862
  if (hardware_locked == 0) {
#line 863
    tmp___0 = spinlock_check(& ha->hardware_lock);
#line 863
    flags = _raw_spin_lock_irqsave(tmp___0);
  } else {

  }
#line 865
  if ((unsigned long )ha->fw_dump == (unsigned long )((struct qla2xxx_fw_dump *)0)) {
#line 866
    ql_log(1U, vha, 53252, "No buffer available for dump.\n");
#line 868
    goto qla2100_fw_dump_failed;
  } else {

  }
#line 871
  if (ha->fw_dumped != 0) {
#line 872
    ql_log(1U, vha, 53253, "Firmware has been previously dumped (%p) -- ignoring request.\n",
           ha->fw_dump);
#line 876
    goto qla2100_fw_dump_failed;
  } else {

  }
#line 878
  fw = & (ha->fw_dump)->isp.isp21;
#line 879
  qla2xxx_prep_dump(ha, ha->fw_dump);
#line 881
  rval = 0;
#line 882
  tmp___1 = readw((void const volatile   *)(& reg->hccr));
#line 882
  tmp___2 = __fswab16((int )tmp___1);
#line 882
  fw->hccr = tmp___2;
#line 885
  writew(8192, (void volatile   *)(& reg->hccr));
#line 886
  cnt = 30000U;
#line 886
  goto ldv_66012;
  ldv_66011: ;
#line 888
  if (cnt != 0U) {
#line 889
    __const_udelay(429500UL);
  } else {
#line 891
    rval = 256;
  }
#line 887
  cnt = cnt - 1U;
  ldv_66012: 
#line 886
  tmp___3 = readw((void const volatile   *)(& reg->hccr));
#line 886
  if (((int )tmp___3 & 32) == 0 && rval == 0) {
#line 889
    goto ldv_66011;
  } else {

  }

#line 893
  if (rval == 0) {
#line 894
    dmp_reg = & reg->flash_address;
#line 895
    cnt = 0U;
#line 895
    goto ldv_66015;
    ldv_66014: 
#line 896
    tmp___4 = dmp_reg;
#line 896
    dmp_reg = dmp_reg + 1;
#line 896
    tmp___5 = readw((void const volatile   *)tmp___4);
#line 896
    tmp___6 = __fswab16((int )tmp___5);
#line 896
    fw->pbiu_reg[cnt] = tmp___6;
#line 895
    cnt = cnt + 1U;
    ldv_66015: ;
#line 895
    if (cnt <= 7U) {
#line 897
      goto ldv_66014;
    } else {

    }
#line 898
    dmp_reg = & reg->u.isp2100.mailbox0;
#line 899
    cnt = 0U;
#line 899
    goto ldv_66018;
    ldv_66017: ;
#line 900
    if (cnt == 8U) {
#line 901
      dmp_reg = & reg->u_end.isp2200.mailbox8;
    } else {

    }
#line 903
    tmp___7 = dmp_reg;
#line 903
    dmp_reg = dmp_reg + 1;
#line 903
    tmp___8 = readw((void const volatile   *)tmp___7);
#line 903
    tmp___9 = __fswab16((int )tmp___8);
#line 903
    fw->mailbox_reg[cnt] = tmp___9;
#line 899
    cnt = cnt + 1U;
    ldv_66018: ;
#line 899
    if ((uint32_t )ha->mbx_count > cnt) {
#line 901
      goto ldv_66017;
    } else {

    }
#line 906
    dmp_reg = (uint16_t *)(& reg->u.isp2100.unused_2);
#line 907
    cnt = 0U;
#line 907
    goto ldv_66021;
    ldv_66020: 
#line 908
    tmp___10 = dmp_reg;
#line 908
    dmp_reg = dmp_reg + 1;
#line 908
    tmp___11 = readw((void const volatile   *)tmp___10);
#line 908
    tmp___12 = __fswab16((int )tmp___11);
#line 908
    fw->dma_reg[cnt] = tmp___12;
#line 907
    cnt = cnt + 1U;
    ldv_66021: ;
#line 907
    if (cnt <= 47U) {
#line 909
      goto ldv_66020;
    } else {

    }
#line 910
    writew(0, (void volatile   *)(& reg->ctrl_status));
#line 911
    dmp_reg = & reg->risc_hw;
#line 912
    cnt = 0U;
#line 912
    goto ldv_66024;
    ldv_66023: 
#line 913
    tmp___13 = dmp_reg;
#line 913
    dmp_reg = dmp_reg + 1;
#line 913
    tmp___14 = readw((void const volatile   *)tmp___13);
#line 913
    tmp___15 = __fswab16((int )tmp___14);
#line 913
    fw->risc_hdw_reg[cnt] = tmp___15;
#line 912
    cnt = cnt + 1U;
    ldv_66024: ;
#line 912
    if (cnt <= 15U) {
#line 914
      goto ldv_66023;
    } else {

    }
#line 915
    writew(8192, (void volatile   *)(& reg->pcr));
#line 916
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp0_reg));
#line 918
    writew(8448, (void volatile   *)(& reg->pcr));
#line 919
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp1_reg));
#line 921
    writew(8704, (void volatile   *)(& reg->pcr));
#line 922
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp2_reg));
#line 924
    writew(8960, (void volatile   *)(& reg->pcr));
#line 925
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp3_reg));
#line 927
    writew(9216, (void volatile   *)(& reg->pcr));
#line 928
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp4_reg));
#line 930
    writew(9472, (void volatile   *)(& reg->pcr));
#line 931
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp5_reg));
#line 933
    writew(9728, (void volatile   *)(& reg->pcr));
#line 934
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp6_reg));
#line 936
    writew(9984, (void volatile   *)(& reg->pcr));
#line 937
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp7_reg));
#line 939
    writew(16, (void volatile   *)(& reg->ctrl_status));
#line 940
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->frame_buf_hdw_reg));
#line 942
    writew(32, (void volatile   *)(& reg->ctrl_status));
#line 943
    qla2xxx_read_window(reg, 64U, (uint16_t *)(& fw->fpm_b0_reg));
#line 945
    writew(48, (void volatile   *)(& reg->ctrl_status));
#line 946
    qla2xxx_read_window(reg, 64U, (uint16_t *)(& fw->fpm_b1_reg));
#line 949
    writew(1, (void volatile   *)(& reg->ctrl_status));
  } else {

  }
#line 952
  cnt = 30000U;
#line 952
  goto ldv_66027;
  ldv_66026: ;
#line 954
  if (cnt != 0U) {
#line 955
    __const_udelay(429500UL);
  } else {
#line 957
    rval = 256;
  }
#line 953
  cnt = cnt - 1U;
  ldv_66027: 
#line 952
  tmp___16 = readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 : & reg->u.isp2300.mailbox0));
#line 952
  if ((unsigned int )tmp___16 != 0U && rval == 0) {
#line 955
    goto ldv_66026;
  } else {

  }

#line 961
  if (rval == 0) {
#line 961
    if ((ha->device_type & 2U) != 0U) {
#line 961
      goto _L;
    } else
#line 961
    if ((int )ha->device_type & 1) {
#line 961
      tmp___18 = readw((void const volatile   *)(& reg->mctr));
#line 961
      if (((int )tmp___18 & 3) != 0) {
        _L: /* CIL Label */ 
#line 964
        writew(8192, (void volatile   *)(& reg->hccr));
#line 965
        cnt = 30000U;
#line 965
        goto ldv_66030;
        ldv_66029: ;
#line 968
        if (cnt != 0U) {
#line 969
          __const_udelay(429500UL);
        } else {
#line 971
          rval = 256;
        }
#line 967
        cnt = cnt - 1U;
        ldv_66030: 
#line 965
        tmp___17 = readw((void const volatile   *)(& reg->hccr));
#line 965
        if (((int )tmp___17 & 32) == 0 && rval == 0) {
#line 969
          goto ldv_66029;
        } else {

        }

#line 973
        if (rval == 0) {
#line 975
          if ((int )ha->device_type & 1) {
#line 976
            writew(241, (void volatile   *)(& reg->mctr));
          } else {
#line 978
            writew(242, (void volatile   *)(& reg->mctr));
          }
#line 979
          readw((void const volatile   *)(& reg->mctr));
#line 982
          writew(12288, (void volatile   *)(& reg->hccr));
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 986
  if (rval == 0) {
#line 988
    risc_address = 4096U;
#line 989
    writew(5, (void volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 : & reg->u.isp2300.mailbox0));
#line 990
    clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
  } else {

  }
#line 992
  cnt = 0U;
#line 992
  goto ldv_66036;
  ldv_66035: 
#line 994
  writew((int )risc_address, (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void volatile   *)(& reg->u.isp2100.mailbox0) + 1U : (void volatile   *)(& reg->u.isp2300.mailbox0) + 1U);
#line 995
  writew(20480, (void volatile   *)(& reg->hccr));
#line 997
  timer = 6000000U;
#line 997
  goto ldv_66034;
  ldv_66033: 
#line 999
  tmp___20 = readw((void const volatile   *)(& reg->istatus));
#line 999
  if (((int )tmp___20 & 8) != 0) {
#line 1000
    tmp___19 = readw((void const volatile   *)(& reg->semaphore));
#line 1000
    if ((int )tmp___19 & 1) {
#line 1001
      set_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 1004
      mb0 = readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 : & reg->u.isp2300.mailbox0));
#line 1005
      mb2 = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 2U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 2U);
#line 1007
      writew(0, (void volatile   *)(& reg->semaphore));
#line 1008
      writew(28672, (void volatile   *)(& reg->hccr));
#line 1010
      readw((void const volatile   *)(& reg->hccr));
#line 1011
      goto ldv_66032;
    } else {

    }
#line 1013
    writew(28672, (void volatile   *)(& reg->hccr));
#line 1014
    readw((void const volatile   *)(& reg->hccr));
  } else {

  }
#line 1016
  __const_udelay(21475UL);
#line 997
  timer = timer - 1U;
  ldv_66034: ;
#line 997
  if (timer != 0U) {
#line 999
    goto ldv_66033;
  } else {

  }
  ldv_66032: 
#line 1019
  tmp___22 = test_and_clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 1019
  if (tmp___22 != 0) {
#line 1020
    rval = (int )mb0 & 16383;
#line 1021
    tmp___21 = __fswab16((int )mb2);
#line 1021
    fw->risc_ram[cnt] = tmp___21;
  } else {
#line 1023
    rval = 258;
  }
#line 993
  cnt = cnt + 1U;
#line 993
  risc_address = (uint16_t )((int )risc_address + 1);
  ldv_66036: ;
#line 992
  if (cnt <= 61439U && rval == 0) {
#line 994
    goto ldv_66035;
  } else {

  }

#line 1027
  if (rval == 0) {
#line 1028
    qla2xxx_copy_queues(ha, (void *)(& fw->risc_ram) + (unsigned long )cnt);
  } else {

  }
#line 1030
  qla2xxx_dump_post_process(base_vha, rval);
  qla2100_fw_dump_failed: ;
#line 1033
  if (hardware_locked == 0) {
#line 1034
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
  } else {

  }
#line 1035
  return;
}
}
#line 1038 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
void qla24xx_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) 
{ 
  int rval ;
  uint32_t cnt ;
  uint32_t risc_address ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  uint32_t *dmp_reg ;
  uint32_t *iter_reg ;
  uint16_t *mbx_reg ;
  unsigned long flags ;
  struct qla24xx_fw_dump *fw ;
  uint32_t ext_mem_cnt ;
  void *nxt ;
  void *nxt_chain ;
  uint32_t *last_chain ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned int tmp___1 ;
  __u32 tmp___2 ;
  uint32_t *tmp___3 ;
  unsigned int tmp___4 ;
  __u32 tmp___5 ;
  unsigned int tmp___6 ;
  __u32 tmp___7 ;
  unsigned int tmp___8 ;
  __u32 tmp___9 ;
  unsigned int tmp___10 ;
  __u32 tmp___11 ;
  unsigned int tmp___12 ;
  __u32 tmp___13 ;
  unsigned int tmp___14 ;
  __u32 tmp___15 ;
  unsigned int tmp___16 ;
  __u32 tmp___17 ;
  unsigned int tmp___18 ;
  __u32 tmp___19 ;
  uint16_t *tmp___20 ;
  unsigned short tmp___21 ;
  __u16 tmp___22 ;
  uint32_t *tmp___23 ;
  uint32_t *tmp___24 ;
  unsigned int tmp___25 ;
  __u32 tmp___26 ;
  uint32_t *tmp___27 ;
  uint32_t *tmp___28 ;
  unsigned int tmp___29 ;
  __u32 tmp___30 ;
  uint32_t *tmp___31 ;
  uint32_t *tmp___32 ;
  unsigned int tmp___33 ;
  __u32 tmp___34 ;

  {
#line 1043
  ha = vha->hw;
#line 1044
  reg = & (ha->iobase)->isp24;
#line 1053
  last_chain = (uint32_t *)0U;
#line 1054
  tmp = pci_get_drvdata(ha->pdev);
#line 1054
  base_vha = (struct scsi_qla_host *)tmp;
#line 1056
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1057
    return;
  } else {

  }
#line 1059
  ext_mem_cnt = 0U;
#line 1059
  risc_address = ext_mem_cnt;
#line 1060
  flags = 0UL;
#line 1061
  ha->fw_dump_cap_flags = 0UL;
#line 1063
  if (hardware_locked == 0) {
#line 1064
    tmp___0 = spinlock_check(& ha->hardware_lock);
#line 1064
    flags = _raw_spin_lock_irqsave(tmp___0);
  } else {

  }
#line 1066
  if ((unsigned long )ha->fw_dump == (unsigned long )((struct qla2xxx_fw_dump *)0)) {
#line 1067
    ql_log(1U, vha, 53254, "No buffer available for dump.\n");
#line 1069
    goto qla24xx_fw_dump_failed;
  } else {

  }
#line 1072
  if (ha->fw_dumped != 0) {
#line 1073
    ql_log(1U, vha, 53255, "Firmware has been previously dumped (%p) -- ignoring request.\n",
           ha->fw_dump);
#line 1077
    goto qla24xx_fw_dump_failed;
  } else {

  }
#line 1079
  fw = & (ha->fw_dump)->isp.isp24;
#line 1080
  qla2xxx_prep_dump(ha, ha->fw_dump);
#line 1082
  tmp___1 = readl((void const volatile   *)(& reg->host_status));
#line 1082
  tmp___2 = __fswab32(tmp___1);
#line 1082
  fw->host_status = tmp___2;
#line 1088
  qla24xx_pause_risc(reg, ha);
#line 1091
  dmp_reg = & reg->flash_addr;
#line 1092
  cnt = 0U;
#line 1092
  goto ldv_66062;
  ldv_66061: 
#line 1093
  tmp___3 = dmp_reg;
#line 1093
  dmp_reg = dmp_reg + 1;
#line 1093
  tmp___4 = readl((void const volatile   *)tmp___3);
#line 1093
  tmp___5 = __fswab32(tmp___4);
#line 1093
  fw->host_reg[cnt] = tmp___5;
#line 1092
  cnt = cnt + 1U;
  ldv_66062: ;
#line 1092
  if (cnt <= 31U) {
#line 1094
    goto ldv_66061;
  } else {

  }
#line 1096
  writel(0U, (void volatile   *)(& reg->ictrl));
#line 1097
  readl((void const volatile   *)(& reg->ictrl));
#line 1100
  writel(3952U, (void volatile   *)(& reg->iobase_addr));
#line 1101
  readl((void const volatile   *)(& reg->iobase_addr));
#line 1102
  writel(2952790016U, (void volatile   *)(& reg->iobase_select));
#line 1103
  tmp___6 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1103
  tmp___7 = __fswab32(tmp___6);
#line 1103
  fw->shadow_reg[0] = tmp___7;
#line 1105
  writel(2953838592U, (void volatile   *)(& reg->iobase_select));
#line 1106
  tmp___8 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1106
  tmp___9 = __fswab32(tmp___8);
#line 1106
  fw->shadow_reg[1] = tmp___9;
#line 1108
  writel(2954887168U, (void volatile   *)(& reg->iobase_select));
#line 1109
  tmp___10 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1109
  tmp___11 = __fswab32(tmp___10);
#line 1109
  fw->shadow_reg[2] = tmp___11;
#line 1111
  writel(2955935744U, (void volatile   *)(& reg->iobase_select));
#line 1112
  tmp___12 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1112
  tmp___13 = __fswab32(tmp___12);
#line 1112
  fw->shadow_reg[3] = tmp___13;
#line 1114
  writel(2956984320U, (void volatile   *)(& reg->iobase_select));
#line 1115
  tmp___14 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1115
  tmp___15 = __fswab32(tmp___14);
#line 1115
  fw->shadow_reg[4] = tmp___15;
#line 1117
  writel(2958032896U, (void volatile   *)(& reg->iobase_select));
#line 1118
  tmp___16 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1118
  tmp___17 = __fswab32(tmp___16);
#line 1118
  fw->shadow_reg[5] = tmp___17;
#line 1120
  writel(2959081472U, (void volatile   *)(& reg->iobase_select));
#line 1121
  tmp___18 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1121
  tmp___19 = __fswab32(tmp___18);
#line 1121
  fw->shadow_reg[6] = tmp___19;
#line 1124
  mbx_reg = & reg->mailbox0;
#line 1125
  cnt = 0U;
#line 1125
  goto ldv_66065;
  ldv_66064: 
#line 1126
  tmp___20 = mbx_reg;
#line 1126
  mbx_reg = mbx_reg + 1;
#line 1126
  tmp___21 = readw((void const volatile   *)tmp___20);
#line 1126
  tmp___22 = __fswab16((int )tmp___21);
#line 1126
  fw->mailbox_reg[cnt] = tmp___22;
#line 1125
  cnt = cnt + 1U;
  ldv_66065: ;
#line 1125
  if (cnt <= 31U) {
#line 1127
    goto ldv_66064;
  } else {

  }
#line 1129
  iter_reg = (uint32_t *)(& fw->xseq_gp_reg);
#line 1130
  iter_reg = qla24xx_read_window(reg, 48896U, 16U, iter_reg);
#line 1131
  iter_reg = qla24xx_read_window(reg, 48912U, 16U, iter_reg);
#line 1132
  iter_reg = qla24xx_read_window(reg, 48928U, 16U, iter_reg);
#line 1133
  iter_reg = qla24xx_read_window(reg, 48944U, 16U, iter_reg);
#line 1134
  iter_reg = qla24xx_read_window(reg, 48960U, 16U, iter_reg);
#line 1135
  iter_reg = qla24xx_read_window(reg, 48976U, 16U, iter_reg);
#line 1136
  iter_reg = qla24xx_read_window(reg, 48992U, 16U, iter_reg);
#line 1137
  qla24xx_read_window(reg, 49008U, 16U, iter_reg);
#line 1139
  qla24xx_read_window(reg, 49120U, 16U, (uint32_t *)(& fw->xseq_0_reg));
#line 1140
  qla24xx_read_window(reg, 49136U, 16U, (uint32_t *)(& fw->xseq_1_reg));
#line 1143
  iter_reg = (uint32_t *)(& fw->rseq_gp_reg);
#line 1144
  iter_reg = qla24xx_read_window(reg, 65280U, 16U, iter_reg);
#line 1145
  iter_reg = qla24xx_read_window(reg, 65296U, 16U, iter_reg);
#line 1146
  iter_reg = qla24xx_read_window(reg, 65312U, 16U, iter_reg);
#line 1147
  iter_reg = qla24xx_read_window(reg, 65328U, 16U, iter_reg);
#line 1148
  iter_reg = qla24xx_read_window(reg, 65344U, 16U, iter_reg);
#line 1149
  iter_reg = qla24xx_read_window(reg, 65360U, 16U, iter_reg);
#line 1150
  iter_reg = qla24xx_read_window(reg, 65376U, 16U, iter_reg);
#line 1151
  qla24xx_read_window(reg, 65392U, 16U, iter_reg);
#line 1153
  qla24xx_read_window(reg, 65488U, 16U, (uint32_t *)(& fw->rseq_0_reg));
#line 1154
  qla24xx_read_window(reg, 65504U, 16U, (uint32_t *)(& fw->rseq_1_reg));
#line 1155
  qla24xx_read_window(reg, 65520U, 16U, (uint32_t *)(& fw->rseq_2_reg));
#line 1158
  qla24xx_read_window(reg, 28928U, 16U, (uint32_t *)(& fw->cmd_dma_reg));
#line 1161
  iter_reg = (uint32_t *)(& fw->req0_dma_reg);
#line 1162
  iter_reg = qla24xx_read_window(reg, 29184U, 8U, iter_reg);
#line 1163
  dmp_reg = & reg->iobase_q;
#line 1164
  cnt = 0U;
#line 1164
  goto ldv_66068;
  ldv_66067: 
#line 1165
  tmp___23 = iter_reg;
#line 1165
  iter_reg = iter_reg + 1;
#line 1165
  tmp___24 = dmp_reg;
#line 1165
  dmp_reg = dmp_reg + 1;
#line 1165
  tmp___25 = readl((void const volatile   *)tmp___24);
#line 1165
  tmp___26 = __fswab32(tmp___25);
#line 1165
  *tmp___23 = tmp___26;
#line 1164
  cnt = cnt + 1U;
  ldv_66068: ;
#line 1164
  if (cnt <= 6U) {
#line 1166
    goto ldv_66067;
  } else {

  }
#line 1167
  iter_reg = (uint32_t *)(& fw->resp0_dma_reg);
#line 1168
  iter_reg = qla24xx_read_window(reg, 29440U, 8U, iter_reg);
#line 1169
  dmp_reg = & reg->iobase_q;
#line 1170
  cnt = 0U;
#line 1170
  goto ldv_66071;
  ldv_66070: 
#line 1171
  tmp___27 = iter_reg;
#line 1171
  iter_reg = iter_reg + 1;
#line 1171
  tmp___28 = dmp_reg;
#line 1171
  dmp_reg = dmp_reg + 1;
#line 1171
  tmp___29 = readl((void const volatile   *)tmp___28);
#line 1171
  tmp___30 = __fswab32(tmp___29);
#line 1171
  *tmp___27 = tmp___30;
#line 1170
  cnt = cnt + 1U;
  ldv_66071: ;
#line 1170
  if (cnt <= 6U) {
#line 1172
    goto ldv_66070;
  } else {

  }
#line 1173
  iter_reg = (uint32_t *)(& fw->req1_dma_reg);
#line 1174
  iter_reg = qla24xx_read_window(reg, 29696U, 8U, iter_reg);
#line 1175
  dmp_reg = & reg->iobase_q;
#line 1176
  cnt = 0U;
#line 1176
  goto ldv_66074;
  ldv_66073: 
#line 1177
  tmp___31 = iter_reg;
#line 1177
  iter_reg = iter_reg + 1;
#line 1177
  tmp___32 = dmp_reg;
#line 1177
  dmp_reg = dmp_reg + 1;
#line 1177
  tmp___33 = readl((void const volatile   *)tmp___32);
#line 1177
  tmp___34 = __fswab32(tmp___33);
#line 1177
  *tmp___31 = tmp___34;
#line 1176
  cnt = cnt + 1U;
  ldv_66074: ;
#line 1176
  if (cnt <= 6U) {
#line 1178
    goto ldv_66073;
  } else {

  }
#line 1180
  iter_reg = (uint32_t *)(& fw->xmt0_dma_reg);
#line 1181
  iter_reg = qla24xx_read_window(reg, 30208U, 16U, iter_reg);
#line 1182
  qla24xx_read_window(reg, 30224U, 16U, iter_reg);
#line 1184
  iter_reg = (uint32_t *)(& fw->xmt1_dma_reg);
#line 1185
  iter_reg = qla24xx_read_window(reg, 30240U, 16U, iter_reg);
#line 1186
  qla24xx_read_window(reg, 30256U, 16U, iter_reg);
#line 1188
  iter_reg = (uint32_t *)(& fw->xmt2_dma_reg);
#line 1189
  iter_reg = qla24xx_read_window(reg, 30272U, 16U, iter_reg);
#line 1190
  qla24xx_read_window(reg, 30288U, 16U, iter_reg);
#line 1192
  iter_reg = (uint32_t *)(& fw->xmt3_dma_reg);
#line 1193
  iter_reg = qla24xx_read_window(reg, 30304U, 16U, iter_reg);
#line 1194
  qla24xx_read_window(reg, 30320U, 16U, iter_reg);
#line 1196
  iter_reg = (uint32_t *)(& fw->xmt4_dma_reg);
#line 1197
  iter_reg = qla24xx_read_window(reg, 30336U, 16U, iter_reg);
#line 1198
  qla24xx_read_window(reg, 30352U, 16U, iter_reg);
#line 1200
  qla24xx_read_window(reg, 30368U, 16U, (uint32_t *)(& fw->xmt_data_dma_reg));
#line 1203
  iter_reg = (uint32_t *)(& fw->rcvt0_data_dma_reg);
#line 1204
  iter_reg = qla24xx_read_window(reg, 30464U, 16U, iter_reg);
#line 1205
  qla24xx_read_window(reg, 30480U, 16U, iter_reg);
#line 1207
  iter_reg = (uint32_t *)(& fw->rcvt1_data_dma_reg);
#line 1208
  iter_reg = qla24xx_read_window(reg, 30496U, 16U, iter_reg);
#line 1209
  qla24xx_read_window(reg, 30512U, 16U, iter_reg);
#line 1212
  iter_reg = (uint32_t *)(& fw->risc_gp_reg);
#line 1213
  iter_reg = qla24xx_read_window(reg, 3840U, 16U, iter_reg);
#line 1214
  iter_reg = qla24xx_read_window(reg, 3856U, 16U, iter_reg);
#line 1215
  iter_reg = qla24xx_read_window(reg, 3872U, 16U, iter_reg);
#line 1216
  iter_reg = qla24xx_read_window(reg, 3888U, 16U, iter_reg);
#line 1217
  iter_reg = qla24xx_read_window(reg, 3904U, 16U, iter_reg);
#line 1218
  iter_reg = qla24xx_read_window(reg, 3920U, 16U, iter_reg);
#line 1219
  iter_reg = qla24xx_read_window(reg, 3936U, 16U, iter_reg);
#line 1220
  qla24xx_read_window(reg, 3952U, 16U, iter_reg);
#line 1223
  iter_reg = (uint32_t *)(& fw->lmc_reg);
#line 1224
  iter_reg = qla24xx_read_window(reg, 12288U, 16U, iter_reg);
#line 1225
  iter_reg = qla24xx_read_window(reg, 12304U, 16U, iter_reg);
#line 1226
  iter_reg = qla24xx_read_window(reg, 12320U, 16U, iter_reg);
#line 1227
  iter_reg = qla24xx_read_window(reg, 12336U, 16U, iter_reg);
#line 1228
  iter_reg = qla24xx_read_window(reg, 12352U, 16U, iter_reg);
#line 1229
  iter_reg = qla24xx_read_window(reg, 12368U, 16U, iter_reg);
#line 1230
  qla24xx_read_window(reg, 12384U, 16U, iter_reg);
#line 1233
  iter_reg = (uint32_t *)(& fw->fpm_hdw_reg);
#line 1234
  iter_reg = qla24xx_read_window(reg, 16384U, 16U, iter_reg);
#line 1235
  iter_reg = qla24xx_read_window(reg, 16400U, 16U, iter_reg);
#line 1236
  iter_reg = qla24xx_read_window(reg, 16416U, 16U, iter_reg);
#line 1237
  iter_reg = qla24xx_read_window(reg, 16432U, 16U, iter_reg);
#line 1238
  iter_reg = qla24xx_read_window(reg, 16448U, 16U, iter_reg);
#line 1239
  iter_reg = qla24xx_read_window(reg, 16464U, 16U, iter_reg);
#line 1240
  iter_reg = qla24xx_read_window(reg, 16480U, 16U, iter_reg);
#line 1241
  iter_reg = qla24xx_read_window(reg, 16496U, 16U, iter_reg);
#line 1242
  iter_reg = qla24xx_read_window(reg, 16512U, 16U, iter_reg);
#line 1243
  iter_reg = qla24xx_read_window(reg, 16528U, 16U, iter_reg);
#line 1244
  iter_reg = qla24xx_read_window(reg, 16544U, 16U, iter_reg);
#line 1245
  qla24xx_read_window(reg, 16560U, 16U, iter_reg);
#line 1248
  iter_reg = (uint32_t *)(& fw->fb_hdw_reg);
#line 1249
  iter_reg = qla24xx_read_window(reg, 24576U, 16U, iter_reg);
#line 1250
  iter_reg = qla24xx_read_window(reg, 24592U, 16U, iter_reg);
#line 1251
  iter_reg = qla24xx_read_window(reg, 24608U, 16U, iter_reg);
#line 1252
  iter_reg = qla24xx_read_window(reg, 24624U, 16U, iter_reg);
#line 1253
  iter_reg = qla24xx_read_window(reg, 24640U, 16U, iter_reg);
#line 1254
  iter_reg = qla24xx_read_window(reg, 24832U, 16U, iter_reg);
#line 1255
  iter_reg = qla24xx_read_window(reg, 24880U, 16U, iter_reg);
#line 1256
  iter_reg = qla24xx_read_window(reg, 24912U, 16U, iter_reg);
#line 1257
  iter_reg = qla24xx_read_window(reg, 24944U, 16U, iter_reg);
#line 1258
  iter_reg = qla24xx_read_window(reg, 24976U, 16U, iter_reg);
#line 1259
  qla24xx_read_window(reg, 25008U, 16U, iter_reg);
#line 1261
  rval = qla24xx_soft_reset(ha);
#line 1262
  if (rval != 0) {
#line 1263
    goto qla24xx_fw_dump_failed_0;
  } else {

  }
#line 1265
  rval = qla24xx_dump_memory(ha, (uint32_t *)(& fw->code_ram), 32768U, & nxt);
#line 1267
  if (rval != 0) {
#line 1268
    goto qla24xx_fw_dump_failed_0;
  } else {

  }
#line 1270
  nxt = qla2xxx_copy_queues(ha, nxt);
#line 1272
  qla24xx_copy_eft(ha, nxt);
#line 1274
  nxt_chain = (void *)ha->fw_dump + (unsigned long )ha->chain_offset;
#line 1275
  nxt_chain = qla2xxx_copy_atioqueues(ha, nxt_chain, & last_chain);
#line 1276
  if ((unsigned long )last_chain != (unsigned long )((uint32_t *)0U)) {
#line 1277
    (ha->fw_dump)->version = (ha->fw_dump)->version | 128U;
#line 1278
    *last_chain = *last_chain | 128U;
  } else {

  }
#line 1282
  ha->fw_dump_len = (uint32_t )((long )nxt_chain) - (uint32_t )((long )ha->fw_dump);
  qla24xx_fw_dump_failed_0: 
#line 1285
  qla2xxx_dump_post_process(base_vha, rval);
  qla24xx_fw_dump_failed: ;
#line 1288
  if (hardware_locked == 0) {
#line 1289
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
  } else {

  }
#line 1290
  return;
}
}
#line 1293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
void qla25xx_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) 
{ 
  int rval ;
  uint32_t cnt ;
  uint32_t risc_address ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  uint32_t *dmp_reg ;
  uint32_t *iter_reg ;
  uint16_t *mbx_reg ;
  unsigned long flags ;
  struct qla25xx_fw_dump *fw ;
  uint32_t ext_mem_cnt ;
  void *nxt ;
  void *nxt_chain ;
  uint32_t *last_chain ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned int tmp___1 ;
  __u32 tmp___2 ;
  uint32_t *tmp___3 ;
  unsigned int tmp___4 ;
  __u32 tmp___5 ;
  uint32_t *tmp___6 ;
  unsigned int tmp___7 ;
  __u32 tmp___8 ;
  unsigned int tmp___9 ;
  __u32 tmp___10 ;
  unsigned int tmp___11 ;
  __u32 tmp___12 ;
  uint32_t *tmp___13 ;
  unsigned int tmp___14 ;
  __u32 tmp___15 ;
  unsigned int tmp___16 ;
  __u32 tmp___17 ;
  unsigned int tmp___18 ;
  __u32 tmp___19 ;
  unsigned int tmp___20 ;
  __u32 tmp___21 ;
  unsigned int tmp___22 ;
  __u32 tmp___23 ;
  unsigned int tmp___24 ;
  __u32 tmp___25 ;
  unsigned int tmp___26 ;
  __u32 tmp___27 ;
  unsigned int tmp___28 ;
  __u32 tmp___29 ;
  unsigned int tmp___30 ;
  __u32 tmp___31 ;
  unsigned int tmp___32 ;
  __u32 tmp___33 ;
  unsigned int tmp___34 ;
  __u32 tmp___35 ;
  unsigned int tmp___36 ;
  __u32 tmp___37 ;
  unsigned int tmp___38 ;
  __u32 tmp___39 ;
  uint16_t *tmp___40 ;
  unsigned short tmp___41 ;
  __u16 tmp___42 ;
  uint32_t *tmp___43 ;
  uint32_t *tmp___44 ;
  unsigned int tmp___45 ;
  __u32 tmp___46 ;
  uint32_t *tmp___47 ;
  uint32_t *tmp___48 ;
  unsigned int tmp___49 ;
  __u32 tmp___50 ;
  uint32_t *tmp___51 ;
  uint32_t *tmp___52 ;
  unsigned int tmp___53 ;
  __u32 tmp___54 ;

  {
#line 1298
  ha = vha->hw;
#line 1299
  reg = & (ha->iobase)->isp24;
#line 1307
  last_chain = (uint32_t *)0U;
#line 1308
  tmp = pci_get_drvdata(ha->pdev);
#line 1308
  base_vha = (struct scsi_qla_host *)tmp;
#line 1310
  ext_mem_cnt = 0U;
#line 1310
  risc_address = ext_mem_cnt;
#line 1311
  flags = 0UL;
#line 1312
  ha->fw_dump_cap_flags = 0UL;
#line 1314
  if (hardware_locked == 0) {
#line 1315
    tmp___0 = spinlock_check(& ha->hardware_lock);
#line 1315
    flags = _raw_spin_lock_irqsave(tmp___0);
  } else {

  }
#line 1317
  if ((unsigned long )ha->fw_dump == (unsigned long )((struct qla2xxx_fw_dump *)0)) {
#line 1318
    ql_log(1U, vha, 53256, "No buffer available for dump.\n");
#line 1320
    goto qla25xx_fw_dump_failed;
  } else {

  }
#line 1323
  if (ha->fw_dumped != 0) {
#line 1324
    ql_log(1U, vha, 53257, "Firmware has been previously dumped (%p) -- ignoring request.\n",
           ha->fw_dump);
#line 1328
    goto qla25xx_fw_dump_failed;
  } else {

  }
#line 1330
  fw = & (ha->fw_dump)->isp.isp25;
#line 1331
  qla2xxx_prep_dump(ha, ha->fw_dump);
#line 1332
  (ha->fw_dump)->version = 33554432U;
#line 1334
  tmp___1 = readl((void const volatile   *)(& reg->host_status));
#line 1334
  tmp___2 = __fswab32(tmp___1);
#line 1334
  fw->host_status = tmp___2;
#line 1340
  qla24xx_pause_risc(reg, ha);
#line 1343
  iter_reg = (uint32_t *)(& fw->host_risc_reg);
#line 1344
  iter_reg = qla24xx_read_window(reg, 28672U, 16U, iter_reg);
#line 1345
  qla24xx_read_window(reg, 28688U, 16U, iter_reg);
#line 1348
  writel(31744U, (void volatile   *)(& reg->iobase_addr));
#line 1349
  readl((void const volatile   *)(& reg->iobase_addr));
#line 1350
  writel(1U, (void volatile   *)(& reg->iobase_window));
#line 1351
  dmp_reg = & reg->iobase_c4;
#line 1352
  tmp___3 = dmp_reg;
#line 1352
  dmp_reg = dmp_reg + 1;
#line 1352
  tmp___4 = readl((void const volatile   *)tmp___3);
#line 1352
  tmp___5 = __fswab32(tmp___4);
#line 1352
  fw->pcie_regs[0] = tmp___5;
#line 1353
  tmp___6 = dmp_reg;
#line 1353
  dmp_reg = dmp_reg + 1;
#line 1353
  tmp___7 = readl((void const volatile   *)tmp___6);
#line 1353
  tmp___8 = __fswab32(tmp___7);
#line 1353
  fw->pcie_regs[1] = tmp___8;
#line 1354
  tmp___9 = readl((void const volatile   *)dmp_reg);
#line 1354
  tmp___10 = __fswab32(tmp___9);
#line 1354
  fw->pcie_regs[2] = tmp___10;
#line 1355
  tmp___11 = readl((void const volatile   *)(& reg->iobase_window));
#line 1355
  tmp___12 = __fswab32(tmp___11);
#line 1355
  fw->pcie_regs[3] = tmp___12;
#line 1357
  writel(0U, (void volatile   *)(& reg->iobase_window));
#line 1358
  readl((void const volatile   *)(& reg->iobase_window));
#line 1361
  dmp_reg = & reg->flash_addr;
#line 1362
  cnt = 0U;
#line 1362
  goto ldv_66101;
  ldv_66100: 
#line 1363
  tmp___13 = dmp_reg;
#line 1363
  dmp_reg = dmp_reg + 1;
#line 1363
  tmp___14 = readl((void const volatile   *)tmp___13);
#line 1363
  tmp___15 = __fswab32(tmp___14);
#line 1363
  fw->host_reg[cnt] = tmp___15;
#line 1362
  cnt = cnt + 1U;
  ldv_66101: ;
#line 1362
  if (cnt <= 31U) {
#line 1364
    goto ldv_66100;
  } else {

  }
#line 1366
  writel(0U, (void volatile   *)(& reg->ictrl));
#line 1367
  readl((void const volatile   *)(& reg->ictrl));
#line 1370
  writel(3952U, (void volatile   *)(& reg->iobase_addr));
#line 1371
  readl((void const volatile   *)(& reg->iobase_addr));
#line 1372
  writel(2952790016U, (void volatile   *)(& reg->iobase_select));
#line 1373
  tmp___16 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1373
  tmp___17 = __fswab32(tmp___16);
#line 1373
  fw->shadow_reg[0] = tmp___17;
#line 1375
  writel(2953838592U, (void volatile   *)(& reg->iobase_select));
#line 1376
  tmp___18 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1376
  tmp___19 = __fswab32(tmp___18);
#line 1376
  fw->shadow_reg[1] = tmp___19;
#line 1378
  writel(2954887168U, (void volatile   *)(& reg->iobase_select));
#line 1379
  tmp___20 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1379
  tmp___21 = __fswab32(tmp___20);
#line 1379
  fw->shadow_reg[2] = tmp___21;
#line 1381
  writel(2955935744U, (void volatile   *)(& reg->iobase_select));
#line 1382
  tmp___22 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1382
  tmp___23 = __fswab32(tmp___22);
#line 1382
  fw->shadow_reg[3] = tmp___23;
#line 1384
  writel(2956984320U, (void volatile   *)(& reg->iobase_select));
#line 1385
  tmp___24 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1385
  tmp___25 = __fswab32(tmp___24);
#line 1385
  fw->shadow_reg[4] = tmp___25;
#line 1387
  writel(2958032896U, (void volatile   *)(& reg->iobase_select));
#line 1388
  tmp___26 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1388
  tmp___27 = __fswab32(tmp___26);
#line 1388
  fw->shadow_reg[5] = tmp___27;
#line 1390
  writel(2959081472U, (void volatile   *)(& reg->iobase_select));
#line 1391
  tmp___28 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1391
  tmp___29 = __fswab32(tmp___28);
#line 1391
  fw->shadow_reg[6] = tmp___29;
#line 1393
  writel(2960130048U, (void volatile   *)(& reg->iobase_select));
#line 1394
  tmp___30 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1394
  tmp___31 = __fswab32(tmp___30);
#line 1394
  fw->shadow_reg[7] = tmp___31;
#line 1396
  writel(2961178624U, (void volatile   *)(& reg->iobase_select));
#line 1397
  tmp___32 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1397
  tmp___33 = __fswab32(tmp___32);
#line 1397
  fw->shadow_reg[8] = tmp___33;
#line 1399
  writel(2962227200U, (void volatile   *)(& reg->iobase_select));
#line 1400
  tmp___34 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1400
  tmp___35 = __fswab32(tmp___34);
#line 1400
  fw->shadow_reg[9] = tmp___35;
#line 1402
  writel(2963275776U, (void volatile   *)(& reg->iobase_select));
#line 1403
  tmp___36 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1403
  tmp___37 = __fswab32(tmp___36);
#line 1403
  fw->shadow_reg[10] = tmp___37;
#line 1406
  writel(16U, (void volatile   *)(& reg->iobase_addr));
#line 1407
  tmp___38 = readl((void const volatile   *)(& reg->iobase_window));
#line 1407
  tmp___39 = __fswab32(tmp___38);
#line 1407
  fw->risc_io_reg = tmp___39;
#line 1410
  mbx_reg = & reg->mailbox0;
#line 1411
  cnt = 0U;
#line 1411
  goto ldv_66104;
  ldv_66103: 
#line 1412
  tmp___40 = mbx_reg;
#line 1412
  mbx_reg = mbx_reg + 1;
#line 1412
  tmp___41 = readw((void const volatile   *)tmp___40);
#line 1412
  tmp___42 = __fswab16((int )tmp___41);
#line 1412
  fw->mailbox_reg[cnt] = tmp___42;
#line 1411
  cnt = cnt + 1U;
  ldv_66104: ;
#line 1411
  if (cnt <= 31U) {
#line 1413
    goto ldv_66103;
  } else {

  }
#line 1415
  iter_reg = (uint32_t *)(& fw->xseq_gp_reg);
#line 1416
  iter_reg = qla24xx_read_window(reg, 48896U, 16U, iter_reg);
#line 1417
  iter_reg = qla24xx_read_window(reg, 48912U, 16U, iter_reg);
#line 1418
  iter_reg = qla24xx_read_window(reg, 48928U, 16U, iter_reg);
#line 1419
  iter_reg = qla24xx_read_window(reg, 48944U, 16U, iter_reg);
#line 1420
  iter_reg = qla24xx_read_window(reg, 48960U, 16U, iter_reg);
#line 1421
  iter_reg = qla24xx_read_window(reg, 48976U, 16U, iter_reg);
#line 1422
  iter_reg = qla24xx_read_window(reg, 48992U, 16U, iter_reg);
#line 1423
  qla24xx_read_window(reg, 49008U, 16U, iter_reg);
#line 1425
  iter_reg = (uint32_t *)(& fw->xseq_0_reg);
#line 1426
  iter_reg = qla24xx_read_window(reg, 49088U, 16U, iter_reg);
#line 1427
  iter_reg = qla24xx_read_window(reg, 49104U, 16U, iter_reg);
#line 1428
  qla24xx_read_window(reg, 49120U, 16U, iter_reg);
#line 1430
  qla24xx_read_window(reg, 49136U, 16U, (uint32_t *)(& fw->xseq_1_reg));
#line 1433
  iter_reg = (uint32_t *)(& fw->rseq_gp_reg);
#line 1434
  iter_reg = qla24xx_read_window(reg, 65280U, 16U, iter_reg);
#line 1435
  iter_reg = qla24xx_read_window(reg, 65296U, 16U, iter_reg);
#line 1436
  iter_reg = qla24xx_read_window(reg, 65312U, 16U, iter_reg);
#line 1437
  iter_reg = qla24xx_read_window(reg, 65328U, 16U, iter_reg);
#line 1438
  iter_reg = qla24xx_read_window(reg, 65344U, 16U, iter_reg);
#line 1439
  iter_reg = qla24xx_read_window(reg, 65360U, 16U, iter_reg);
#line 1440
  iter_reg = qla24xx_read_window(reg, 65376U, 16U, iter_reg);
#line 1441
  qla24xx_read_window(reg, 65392U, 16U, iter_reg);
#line 1443
  iter_reg = (uint32_t *)(& fw->rseq_0_reg);
#line 1444
  iter_reg = qla24xx_read_window(reg, 65472U, 16U, iter_reg);
#line 1445
  qla24xx_read_window(reg, 65488U, 16U, iter_reg);
#line 1447
  qla24xx_read_window(reg, 65504U, 16U, (uint32_t *)(& fw->rseq_1_reg));
#line 1448
  qla24xx_read_window(reg, 65520U, 16U, (uint32_t *)(& fw->rseq_2_reg));
#line 1451
  iter_reg = (uint32_t *)(& fw->aseq_gp_reg);
#line 1452
  iter_reg = qla24xx_read_window(reg, 45056U, 16U, iter_reg);
#line 1453
  iter_reg = qla24xx_read_window(reg, 45072U, 16U, iter_reg);
#line 1454
  iter_reg = qla24xx_read_window(reg, 45088U, 16U, iter_reg);
#line 1455
  iter_reg = qla24xx_read_window(reg, 45104U, 16U, iter_reg);
#line 1456
  iter_reg = qla24xx_read_window(reg, 45120U, 16U, iter_reg);
#line 1457
  iter_reg = qla24xx_read_window(reg, 45136U, 16U, iter_reg);
#line 1458
  iter_reg = qla24xx_read_window(reg, 45152U, 16U, iter_reg);
#line 1459
  qla24xx_read_window(reg, 45168U, 16U, iter_reg);
#line 1461
  iter_reg = (uint32_t *)(& fw->aseq_0_reg);
#line 1462
  iter_reg = qla24xx_read_window(reg, 45248U, 16U, iter_reg);
#line 1463
  qla24xx_read_window(reg, 45264U, 16U, iter_reg);
#line 1465
  qla24xx_read_window(reg, 45280U, 16U, (uint32_t *)(& fw->aseq_1_reg));
#line 1466
  qla24xx_read_window(reg, 45296U, 16U, (uint32_t *)(& fw->aseq_2_reg));
#line 1469
  qla24xx_read_window(reg, 28928U, 16U, (uint32_t *)(& fw->cmd_dma_reg));
#line 1472
  iter_reg = (uint32_t *)(& fw->req0_dma_reg);
#line 1473
  iter_reg = qla24xx_read_window(reg, 29184U, 8U, iter_reg);
#line 1474
  dmp_reg = & reg->iobase_q;
#line 1475
  cnt = 0U;
#line 1475
  goto ldv_66107;
  ldv_66106: 
#line 1476
  tmp___43 = iter_reg;
#line 1476
  iter_reg = iter_reg + 1;
#line 1476
  tmp___44 = dmp_reg;
#line 1476
  dmp_reg = dmp_reg + 1;
#line 1476
  tmp___45 = readl((void const volatile   *)tmp___44);
#line 1476
  tmp___46 = __fswab32(tmp___45);
#line 1476
  *tmp___43 = tmp___46;
#line 1475
  cnt = cnt + 1U;
  ldv_66107: ;
#line 1475
  if (cnt <= 6U) {
#line 1477
    goto ldv_66106;
  } else {

  }
#line 1478
  iter_reg = (uint32_t *)(& fw->resp0_dma_reg);
#line 1479
  iter_reg = qla24xx_read_window(reg, 29440U, 8U, iter_reg);
#line 1480
  dmp_reg = & reg->iobase_q;
#line 1481
  cnt = 0U;
#line 1481
  goto ldv_66110;
  ldv_66109: 
#line 1482
  tmp___47 = iter_reg;
#line 1482
  iter_reg = iter_reg + 1;
#line 1482
  tmp___48 = dmp_reg;
#line 1482
  dmp_reg = dmp_reg + 1;
#line 1482
  tmp___49 = readl((void const volatile   *)tmp___48);
#line 1482
  tmp___50 = __fswab32(tmp___49);
#line 1482
  *tmp___47 = tmp___50;
#line 1481
  cnt = cnt + 1U;
  ldv_66110: ;
#line 1481
  if (cnt <= 6U) {
#line 1483
    goto ldv_66109;
  } else {

  }
#line 1484
  iter_reg = (uint32_t *)(& fw->req1_dma_reg);
#line 1485
  iter_reg = qla24xx_read_window(reg, 29696U, 8U, iter_reg);
#line 1486
  dmp_reg = & reg->iobase_q;
#line 1487
  cnt = 0U;
#line 1487
  goto ldv_66113;
  ldv_66112: 
#line 1488
  tmp___51 = iter_reg;
#line 1488
  iter_reg = iter_reg + 1;
#line 1488
  tmp___52 = dmp_reg;
#line 1488
  dmp_reg = dmp_reg + 1;
#line 1488
  tmp___53 = readl((void const volatile   *)tmp___52);
#line 1488
  tmp___54 = __fswab32(tmp___53);
#line 1488
  *tmp___51 = tmp___54;
#line 1487
  cnt = cnt + 1U;
  ldv_66113: ;
#line 1487
  if (cnt <= 6U) {
#line 1489
    goto ldv_66112;
  } else {

  }
#line 1491
  iter_reg = (uint32_t *)(& fw->xmt0_dma_reg);
#line 1492
  iter_reg = qla24xx_read_window(reg, 30208U, 16U, iter_reg);
#line 1493
  qla24xx_read_window(reg, 30224U, 16U, iter_reg);
#line 1495
  iter_reg = (uint32_t *)(& fw->xmt1_dma_reg);
#line 1496
  iter_reg = qla24xx_read_window(reg, 30240U, 16U, iter_reg);
#line 1497
  qla24xx_read_window(reg, 30256U, 16U, iter_reg);
#line 1499
  iter_reg = (uint32_t *)(& fw->xmt2_dma_reg);
#line 1500
  iter_reg = qla24xx_read_window(reg, 30272U, 16U, iter_reg);
#line 1501
  qla24xx_read_window(reg, 30288U, 16U, iter_reg);
#line 1503
  iter_reg = (uint32_t *)(& fw->xmt3_dma_reg);
#line 1504
  iter_reg = qla24xx_read_window(reg, 30304U, 16U, iter_reg);
#line 1505
  qla24xx_read_window(reg, 30320U, 16U, iter_reg);
#line 1507
  iter_reg = (uint32_t *)(& fw->xmt4_dma_reg);
#line 1508
  iter_reg = qla24xx_read_window(reg, 30336U, 16U, iter_reg);
#line 1509
  qla24xx_read_window(reg, 30352U, 16U, iter_reg);
#line 1511
  qla24xx_read_window(reg, 30368U, 16U, (uint32_t *)(& fw->xmt_data_dma_reg));
#line 1514
  iter_reg = (uint32_t *)(& fw->rcvt0_data_dma_reg);
#line 1515
  iter_reg = qla24xx_read_window(reg, 30464U, 16U, iter_reg);
#line 1516
  qla24xx_read_window(reg, 30480U, 16U, iter_reg);
#line 1518
  iter_reg = (uint32_t *)(& fw->rcvt1_data_dma_reg);
#line 1519
  iter_reg = qla24xx_read_window(reg, 30496U, 16U, iter_reg);
#line 1520
  qla24xx_read_window(reg, 30512U, 16U, iter_reg);
#line 1523
  iter_reg = (uint32_t *)(& fw->risc_gp_reg);
#line 1524
  iter_reg = qla24xx_read_window(reg, 3840U, 16U, iter_reg);
#line 1525
  iter_reg = qla24xx_read_window(reg, 3856U, 16U, iter_reg);
#line 1526
  iter_reg = qla24xx_read_window(reg, 3872U, 16U, iter_reg);
#line 1527
  iter_reg = qla24xx_read_window(reg, 3888U, 16U, iter_reg);
#line 1528
  iter_reg = qla24xx_read_window(reg, 3904U, 16U, iter_reg);
#line 1529
  iter_reg = qla24xx_read_window(reg, 3920U, 16U, iter_reg);
#line 1530
  iter_reg = qla24xx_read_window(reg, 3936U, 16U, iter_reg);
#line 1531
  qla24xx_read_window(reg, 3952U, 16U, iter_reg);
#line 1534
  iter_reg = (uint32_t *)(& fw->lmc_reg);
#line 1535
  iter_reg = qla24xx_read_window(reg, 12288U, 16U, iter_reg);
#line 1536
  iter_reg = qla24xx_read_window(reg, 12304U, 16U, iter_reg);
#line 1537
  iter_reg = qla24xx_read_window(reg, 12320U, 16U, iter_reg);
#line 1538
  iter_reg = qla24xx_read_window(reg, 12336U, 16U, iter_reg);
#line 1539
  iter_reg = qla24xx_read_window(reg, 12352U, 16U, iter_reg);
#line 1540
  iter_reg = qla24xx_read_window(reg, 12368U, 16U, iter_reg);
#line 1541
  iter_reg = qla24xx_read_window(reg, 12384U, 16U, iter_reg);
#line 1542
  qla24xx_read_window(reg, 12400U, 16U, iter_reg);
#line 1545
  iter_reg = (uint32_t *)(& fw->fpm_hdw_reg);
#line 1546
  iter_reg = qla24xx_read_window(reg, 16384U, 16U, iter_reg);
#line 1547
  iter_reg = qla24xx_read_window(reg, 16400U, 16U, iter_reg);
#line 1548
  iter_reg = qla24xx_read_window(reg, 16416U, 16U, iter_reg);
#line 1549
  iter_reg = qla24xx_read_window(reg, 16432U, 16U, iter_reg);
#line 1550
  iter_reg = qla24xx_read_window(reg, 16448U, 16U, iter_reg);
#line 1551
  iter_reg = qla24xx_read_window(reg, 16464U, 16U, iter_reg);
#line 1552
  iter_reg = qla24xx_read_window(reg, 16480U, 16U, iter_reg);
#line 1553
  iter_reg = qla24xx_read_window(reg, 16496U, 16U, iter_reg);
#line 1554
  iter_reg = qla24xx_read_window(reg, 16512U, 16U, iter_reg);
#line 1555
  iter_reg = qla24xx_read_window(reg, 16528U, 16U, iter_reg);
#line 1556
  iter_reg = qla24xx_read_window(reg, 16544U, 16U, iter_reg);
#line 1557
  qla24xx_read_window(reg, 16560U, 16U, iter_reg);
#line 1560
  iter_reg = (uint32_t *)(& fw->fb_hdw_reg);
#line 1561
  iter_reg = qla24xx_read_window(reg, 24576U, 16U, iter_reg);
#line 1562
  iter_reg = qla24xx_read_window(reg, 24592U, 16U, iter_reg);
#line 1563
  iter_reg = qla24xx_read_window(reg, 24608U, 16U, iter_reg);
#line 1564
  iter_reg = qla24xx_read_window(reg, 24624U, 16U, iter_reg);
#line 1565
  iter_reg = qla24xx_read_window(reg, 24640U, 16U, iter_reg);
#line 1566
  iter_reg = qla24xx_read_window(reg, 24832U, 16U, iter_reg);
#line 1567
  iter_reg = qla24xx_read_window(reg, 24880U, 16U, iter_reg);
#line 1568
  iter_reg = qla24xx_read_window(reg, 24912U, 16U, iter_reg);
#line 1569
  iter_reg = qla24xx_read_window(reg, 24944U, 16U, iter_reg);
#line 1570
  iter_reg = qla24xx_read_window(reg, 24976U, 16U, iter_reg);
#line 1571
  iter_reg = qla24xx_read_window(reg, 25008U, 16U, iter_reg);
#line 1572
  qla24xx_read_window(reg, 28416U, 16U, iter_reg);
#line 1575
  nxt_chain = qla25xx_copy_mq(ha, (void *)ha->fw_dump + (unsigned long )ha->chain_offset,
                              & last_chain);
#line 1578
  rval = qla24xx_soft_reset(ha);
#line 1579
  if (rval != 0) {
#line 1580
    goto qla25xx_fw_dump_failed_0;
  } else {

  }
#line 1582
  rval = qla24xx_dump_memory(ha, (uint32_t *)(& fw->code_ram), 32768U, & nxt);
#line 1584
  if (rval != 0) {
#line 1585
    goto qla25xx_fw_dump_failed_0;
  } else {

  }
#line 1587
  nxt = qla2xxx_copy_queues(ha, nxt);
#line 1589
  qla24xx_copy_eft(ha, nxt);
#line 1592
  nxt_chain = qla25xx_copy_fce(ha, nxt_chain, & last_chain);
#line 1593
  nxt_chain = qla25xx_copy_mqueues(ha, nxt_chain, & last_chain);
#line 1594
  nxt_chain = qla2xxx_copy_atioqueues(ha, nxt_chain, & last_chain);
#line 1595
  if ((unsigned long )last_chain != (unsigned long )((uint32_t *)0U)) {
#line 1596
    (ha->fw_dump)->version = (ha->fw_dump)->version | 128U;
#line 1597
    *last_chain = *last_chain | 128U;
  } else {

  }
#line 1601
  ha->fw_dump_len = (uint32_t )((long )nxt_chain) - (uint32_t )((long )ha->fw_dump);
  qla25xx_fw_dump_failed_0: 
#line 1604
  qla2xxx_dump_post_process(base_vha, rval);
  qla25xx_fw_dump_failed: ;
#line 1607
  if (hardware_locked == 0) {
#line 1608
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
  } else {

  }
#line 1609
  return;
}
}
#line 1612 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
void qla81xx_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) 
{ 
  int rval ;
  uint32_t cnt ;
  uint32_t risc_address ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  uint32_t *dmp_reg ;
  uint32_t *iter_reg ;
  uint16_t *mbx_reg ;
  unsigned long flags ;
  struct qla81xx_fw_dump *fw ;
  uint32_t ext_mem_cnt ;
  void *nxt ;
  void *nxt_chain ;
  uint32_t *last_chain ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned int tmp___1 ;
  __u32 tmp___2 ;
  uint32_t *tmp___3 ;
  unsigned int tmp___4 ;
  __u32 tmp___5 ;
  uint32_t *tmp___6 ;
  unsigned int tmp___7 ;
  __u32 tmp___8 ;
  unsigned int tmp___9 ;
  __u32 tmp___10 ;
  unsigned int tmp___11 ;
  __u32 tmp___12 ;
  uint32_t *tmp___13 ;
  unsigned int tmp___14 ;
  __u32 tmp___15 ;
  unsigned int tmp___16 ;
  __u32 tmp___17 ;
  unsigned int tmp___18 ;
  __u32 tmp___19 ;
  unsigned int tmp___20 ;
  __u32 tmp___21 ;
  unsigned int tmp___22 ;
  __u32 tmp___23 ;
  unsigned int tmp___24 ;
  __u32 tmp___25 ;
  unsigned int tmp___26 ;
  __u32 tmp___27 ;
  unsigned int tmp___28 ;
  __u32 tmp___29 ;
  unsigned int tmp___30 ;
  __u32 tmp___31 ;
  unsigned int tmp___32 ;
  __u32 tmp___33 ;
  unsigned int tmp___34 ;
  __u32 tmp___35 ;
  unsigned int tmp___36 ;
  __u32 tmp___37 ;
  unsigned int tmp___38 ;
  __u32 tmp___39 ;
  uint16_t *tmp___40 ;
  unsigned short tmp___41 ;
  __u16 tmp___42 ;
  uint32_t *tmp___43 ;
  uint32_t *tmp___44 ;
  unsigned int tmp___45 ;
  __u32 tmp___46 ;
  uint32_t *tmp___47 ;
  uint32_t *tmp___48 ;
  unsigned int tmp___49 ;
  __u32 tmp___50 ;
  uint32_t *tmp___51 ;
  uint32_t *tmp___52 ;
  unsigned int tmp___53 ;
  __u32 tmp___54 ;

  {
#line 1617
  ha = vha->hw;
#line 1618
  reg = & (ha->iobase)->isp24;
#line 1626
  last_chain = (uint32_t *)0U;
#line 1627
  tmp = pci_get_drvdata(ha->pdev);
#line 1627
  base_vha = (struct scsi_qla_host *)tmp;
#line 1629
  ext_mem_cnt = 0U;
#line 1629
  risc_address = ext_mem_cnt;
#line 1630
  flags = 0UL;
#line 1631
  ha->fw_dump_cap_flags = 0UL;
#line 1633
  if (hardware_locked == 0) {
#line 1634
    tmp___0 = spinlock_check(& ha->hardware_lock);
#line 1634
    flags = _raw_spin_lock_irqsave(tmp___0);
  } else {

  }
#line 1636
  if ((unsigned long )ha->fw_dump == (unsigned long )((struct qla2xxx_fw_dump *)0)) {
#line 1637
    ql_log(1U, vha, 53258, "No buffer available for dump.\n");
#line 1639
    goto qla81xx_fw_dump_failed;
  } else {

  }
#line 1642
  if (ha->fw_dumped != 0) {
#line 1643
    ql_log(1U, vha, 53259, "Firmware has been previously dumped (%p) -- ignoring request.\n",
           ha->fw_dump);
#line 1647
    goto qla81xx_fw_dump_failed;
  } else {

  }
#line 1649
  fw = & (ha->fw_dump)->isp.isp81;
#line 1650
  qla2xxx_prep_dump(ha, ha->fw_dump);
#line 1652
  tmp___1 = readl((void const volatile   *)(& reg->host_status));
#line 1652
  tmp___2 = __fswab32(tmp___1);
#line 1652
  fw->host_status = tmp___2;
#line 1658
  qla24xx_pause_risc(reg, ha);
#line 1661
  iter_reg = (uint32_t *)(& fw->host_risc_reg);
#line 1662
  iter_reg = qla24xx_read_window(reg, 28672U, 16U, iter_reg);
#line 1663
  qla24xx_read_window(reg, 28688U, 16U, iter_reg);
#line 1666
  writel(31744U, (void volatile   *)(& reg->iobase_addr));
#line 1667
  readl((void const volatile   *)(& reg->iobase_addr));
#line 1668
  writel(1U, (void volatile   *)(& reg->iobase_window));
#line 1669
  dmp_reg = & reg->iobase_c4;
#line 1670
  tmp___3 = dmp_reg;
#line 1670
  dmp_reg = dmp_reg + 1;
#line 1670
  tmp___4 = readl((void const volatile   *)tmp___3);
#line 1670
  tmp___5 = __fswab32(tmp___4);
#line 1670
  fw->pcie_regs[0] = tmp___5;
#line 1671
  tmp___6 = dmp_reg;
#line 1671
  dmp_reg = dmp_reg + 1;
#line 1671
  tmp___7 = readl((void const volatile   *)tmp___6);
#line 1671
  tmp___8 = __fswab32(tmp___7);
#line 1671
  fw->pcie_regs[1] = tmp___8;
#line 1672
  tmp___9 = readl((void const volatile   *)dmp_reg);
#line 1672
  tmp___10 = __fswab32(tmp___9);
#line 1672
  fw->pcie_regs[2] = tmp___10;
#line 1673
  tmp___11 = readl((void const volatile   *)(& reg->iobase_window));
#line 1673
  tmp___12 = __fswab32(tmp___11);
#line 1673
  fw->pcie_regs[3] = tmp___12;
#line 1675
  writel(0U, (void volatile   *)(& reg->iobase_window));
#line 1676
  readl((void const volatile   *)(& reg->iobase_window));
#line 1679
  dmp_reg = & reg->flash_addr;
#line 1680
  cnt = 0U;
#line 1680
  goto ldv_66140;
  ldv_66139: 
#line 1681
  tmp___13 = dmp_reg;
#line 1681
  dmp_reg = dmp_reg + 1;
#line 1681
  tmp___14 = readl((void const volatile   *)tmp___13);
#line 1681
  tmp___15 = __fswab32(tmp___14);
#line 1681
  fw->host_reg[cnt] = tmp___15;
#line 1680
  cnt = cnt + 1U;
  ldv_66140: ;
#line 1680
  if (cnt <= 31U) {
#line 1682
    goto ldv_66139;
  } else {

  }
#line 1684
  writel(0U, (void volatile   *)(& reg->ictrl));
#line 1685
  readl((void const volatile   *)(& reg->ictrl));
#line 1688
  writel(3952U, (void volatile   *)(& reg->iobase_addr));
#line 1689
  readl((void const volatile   *)(& reg->iobase_addr));
#line 1690
  writel(2952790016U, (void volatile   *)(& reg->iobase_select));
#line 1691
  tmp___16 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1691
  tmp___17 = __fswab32(tmp___16);
#line 1691
  fw->shadow_reg[0] = tmp___17;
#line 1693
  writel(2953838592U, (void volatile   *)(& reg->iobase_select));
#line 1694
  tmp___18 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1694
  tmp___19 = __fswab32(tmp___18);
#line 1694
  fw->shadow_reg[1] = tmp___19;
#line 1696
  writel(2954887168U, (void volatile   *)(& reg->iobase_select));
#line 1697
  tmp___20 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1697
  tmp___21 = __fswab32(tmp___20);
#line 1697
  fw->shadow_reg[2] = tmp___21;
#line 1699
  writel(2955935744U, (void volatile   *)(& reg->iobase_select));
#line 1700
  tmp___22 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1700
  tmp___23 = __fswab32(tmp___22);
#line 1700
  fw->shadow_reg[3] = tmp___23;
#line 1702
  writel(2956984320U, (void volatile   *)(& reg->iobase_select));
#line 1703
  tmp___24 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1703
  tmp___25 = __fswab32(tmp___24);
#line 1703
  fw->shadow_reg[4] = tmp___25;
#line 1705
  writel(2958032896U, (void volatile   *)(& reg->iobase_select));
#line 1706
  tmp___26 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1706
  tmp___27 = __fswab32(tmp___26);
#line 1706
  fw->shadow_reg[5] = tmp___27;
#line 1708
  writel(2959081472U, (void volatile   *)(& reg->iobase_select));
#line 1709
  tmp___28 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1709
  tmp___29 = __fswab32(tmp___28);
#line 1709
  fw->shadow_reg[6] = tmp___29;
#line 1711
  writel(2960130048U, (void volatile   *)(& reg->iobase_select));
#line 1712
  tmp___30 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1712
  tmp___31 = __fswab32(tmp___30);
#line 1712
  fw->shadow_reg[7] = tmp___31;
#line 1714
  writel(2961178624U, (void volatile   *)(& reg->iobase_select));
#line 1715
  tmp___32 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1715
  tmp___33 = __fswab32(tmp___32);
#line 1715
  fw->shadow_reg[8] = tmp___33;
#line 1717
  writel(2962227200U, (void volatile   *)(& reg->iobase_select));
#line 1718
  tmp___34 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1718
  tmp___35 = __fswab32(tmp___34);
#line 1718
  fw->shadow_reg[9] = tmp___35;
#line 1720
  writel(2963275776U, (void volatile   *)(& reg->iobase_select));
#line 1721
  tmp___36 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1721
  tmp___37 = __fswab32(tmp___36);
#line 1721
  fw->shadow_reg[10] = tmp___37;
#line 1724
  writel(16U, (void volatile   *)(& reg->iobase_addr));
#line 1725
  tmp___38 = readl((void const volatile   *)(& reg->iobase_window));
#line 1725
  tmp___39 = __fswab32(tmp___38);
#line 1725
  fw->risc_io_reg = tmp___39;
#line 1728
  mbx_reg = & reg->mailbox0;
#line 1729
  cnt = 0U;
#line 1729
  goto ldv_66143;
  ldv_66142: 
#line 1730
  tmp___40 = mbx_reg;
#line 1730
  mbx_reg = mbx_reg + 1;
#line 1730
  tmp___41 = readw((void const volatile   *)tmp___40);
#line 1730
  tmp___42 = __fswab16((int )tmp___41);
#line 1730
  fw->mailbox_reg[cnt] = tmp___42;
#line 1729
  cnt = cnt + 1U;
  ldv_66143: ;
#line 1729
  if (cnt <= 31U) {
#line 1731
    goto ldv_66142;
  } else {

  }
#line 1733
  iter_reg = (uint32_t *)(& fw->xseq_gp_reg);
#line 1734
  iter_reg = qla24xx_read_window(reg, 48896U, 16U, iter_reg);
#line 1735
  iter_reg = qla24xx_read_window(reg, 48912U, 16U, iter_reg);
#line 1736
  iter_reg = qla24xx_read_window(reg, 48928U, 16U, iter_reg);
#line 1737
  iter_reg = qla24xx_read_window(reg, 48944U, 16U, iter_reg);
#line 1738
  iter_reg = qla24xx_read_window(reg, 48960U, 16U, iter_reg);
#line 1739
  iter_reg = qla24xx_read_window(reg, 48976U, 16U, iter_reg);
#line 1740
  iter_reg = qla24xx_read_window(reg, 48992U, 16U, iter_reg);
#line 1741
  qla24xx_read_window(reg, 49008U, 16U, iter_reg);
#line 1743
  iter_reg = (uint32_t *)(& fw->xseq_0_reg);
#line 1744
  iter_reg = qla24xx_read_window(reg, 49088U, 16U, iter_reg);
#line 1745
  iter_reg = qla24xx_read_window(reg, 49104U, 16U, iter_reg);
#line 1746
  qla24xx_read_window(reg, 49120U, 16U, iter_reg);
#line 1748
  qla24xx_read_window(reg, 49136U, 16U, (uint32_t *)(& fw->xseq_1_reg));
#line 1751
  iter_reg = (uint32_t *)(& fw->rseq_gp_reg);
#line 1752
  iter_reg = qla24xx_read_window(reg, 65280U, 16U, iter_reg);
#line 1753
  iter_reg = qla24xx_read_window(reg, 65296U, 16U, iter_reg);
#line 1754
  iter_reg = qla24xx_read_window(reg, 65312U, 16U, iter_reg);
#line 1755
  iter_reg = qla24xx_read_window(reg, 65328U, 16U, iter_reg);
#line 1756
  iter_reg = qla24xx_read_window(reg, 65344U, 16U, iter_reg);
#line 1757
  iter_reg = qla24xx_read_window(reg, 65360U, 16U, iter_reg);
#line 1758
  iter_reg = qla24xx_read_window(reg, 65376U, 16U, iter_reg);
#line 1759
  qla24xx_read_window(reg, 65392U, 16U, iter_reg);
#line 1761
  iter_reg = (uint32_t *)(& fw->rseq_0_reg);
#line 1762
  iter_reg = qla24xx_read_window(reg, 65472U, 16U, iter_reg);
#line 1763
  qla24xx_read_window(reg, 65488U, 16U, iter_reg);
#line 1765
  qla24xx_read_window(reg, 65504U, 16U, (uint32_t *)(& fw->rseq_1_reg));
#line 1766
  qla24xx_read_window(reg, 65520U, 16U, (uint32_t *)(& fw->rseq_2_reg));
#line 1769
  iter_reg = (uint32_t *)(& fw->aseq_gp_reg);
#line 1770
  iter_reg = qla24xx_read_window(reg, 45056U, 16U, iter_reg);
#line 1771
  iter_reg = qla24xx_read_window(reg, 45072U, 16U, iter_reg);
#line 1772
  iter_reg = qla24xx_read_window(reg, 45088U, 16U, iter_reg);
#line 1773
  iter_reg = qla24xx_read_window(reg, 45104U, 16U, iter_reg);
#line 1774
  iter_reg = qla24xx_read_window(reg, 45120U, 16U, iter_reg);
#line 1775
  iter_reg = qla24xx_read_window(reg, 45136U, 16U, iter_reg);
#line 1776
  iter_reg = qla24xx_read_window(reg, 45152U, 16U, iter_reg);
#line 1777
  qla24xx_read_window(reg, 45168U, 16U, iter_reg);
#line 1779
  iter_reg = (uint32_t *)(& fw->aseq_0_reg);
#line 1780
  iter_reg = qla24xx_read_window(reg, 45248U, 16U, iter_reg);
#line 1781
  qla24xx_read_window(reg, 45264U, 16U, iter_reg);
#line 1783
  qla24xx_read_window(reg, 45280U, 16U, (uint32_t *)(& fw->aseq_1_reg));
#line 1784
  qla24xx_read_window(reg, 45296U, 16U, (uint32_t *)(& fw->aseq_2_reg));
#line 1787
  qla24xx_read_window(reg, 28928U, 16U, (uint32_t *)(& fw->cmd_dma_reg));
#line 1790
  iter_reg = (uint32_t *)(& fw->req0_dma_reg);
#line 1791
  iter_reg = qla24xx_read_window(reg, 29184U, 8U, iter_reg);
#line 1792
  dmp_reg = & reg->iobase_q;
#line 1793
  cnt = 0U;
#line 1793
  goto ldv_66146;
  ldv_66145: 
#line 1794
  tmp___43 = iter_reg;
#line 1794
  iter_reg = iter_reg + 1;
#line 1794
  tmp___44 = dmp_reg;
#line 1794
  dmp_reg = dmp_reg + 1;
#line 1794
  tmp___45 = readl((void const volatile   *)tmp___44);
#line 1794
  tmp___46 = __fswab32(tmp___45);
#line 1794
  *tmp___43 = tmp___46;
#line 1793
  cnt = cnt + 1U;
  ldv_66146: ;
#line 1793
  if (cnt <= 6U) {
#line 1795
    goto ldv_66145;
  } else {

  }
#line 1796
  iter_reg = (uint32_t *)(& fw->resp0_dma_reg);
#line 1797
  iter_reg = qla24xx_read_window(reg, 29440U, 8U, iter_reg);
#line 1798
  dmp_reg = & reg->iobase_q;
#line 1799
  cnt = 0U;
#line 1799
  goto ldv_66149;
  ldv_66148: 
#line 1800
  tmp___47 = iter_reg;
#line 1800
  iter_reg = iter_reg + 1;
#line 1800
  tmp___48 = dmp_reg;
#line 1800
  dmp_reg = dmp_reg + 1;
#line 1800
  tmp___49 = readl((void const volatile   *)tmp___48);
#line 1800
  tmp___50 = __fswab32(tmp___49);
#line 1800
  *tmp___47 = tmp___50;
#line 1799
  cnt = cnt + 1U;
  ldv_66149: ;
#line 1799
  if (cnt <= 6U) {
#line 1801
    goto ldv_66148;
  } else {

  }
#line 1802
  iter_reg = (uint32_t *)(& fw->req1_dma_reg);
#line 1803
  iter_reg = qla24xx_read_window(reg, 29696U, 8U, iter_reg);
#line 1804
  dmp_reg = & reg->iobase_q;
#line 1805
  cnt = 0U;
#line 1805
  goto ldv_66152;
  ldv_66151: 
#line 1806
  tmp___51 = iter_reg;
#line 1806
  iter_reg = iter_reg + 1;
#line 1806
  tmp___52 = dmp_reg;
#line 1806
  dmp_reg = dmp_reg + 1;
#line 1806
  tmp___53 = readl((void const volatile   *)tmp___52);
#line 1806
  tmp___54 = __fswab32(tmp___53);
#line 1806
  *tmp___51 = tmp___54;
#line 1805
  cnt = cnt + 1U;
  ldv_66152: ;
#line 1805
  if (cnt <= 6U) {
#line 1807
    goto ldv_66151;
  } else {

  }
#line 1809
  iter_reg = (uint32_t *)(& fw->xmt0_dma_reg);
#line 1810
  iter_reg = qla24xx_read_window(reg, 30208U, 16U, iter_reg);
#line 1811
  qla24xx_read_window(reg, 30224U, 16U, iter_reg);
#line 1813
  iter_reg = (uint32_t *)(& fw->xmt1_dma_reg);
#line 1814
  iter_reg = qla24xx_read_window(reg, 30240U, 16U, iter_reg);
#line 1815
  qla24xx_read_window(reg, 30256U, 16U, iter_reg);
#line 1817
  iter_reg = (uint32_t *)(& fw->xmt2_dma_reg);
#line 1818
  iter_reg = qla24xx_read_window(reg, 30272U, 16U, iter_reg);
#line 1819
  qla24xx_read_window(reg, 30288U, 16U, iter_reg);
#line 1821
  iter_reg = (uint32_t *)(& fw->xmt3_dma_reg);
#line 1822
  iter_reg = qla24xx_read_window(reg, 30304U, 16U, iter_reg);
#line 1823
  qla24xx_read_window(reg, 30320U, 16U, iter_reg);
#line 1825
  iter_reg = (uint32_t *)(& fw->xmt4_dma_reg);
#line 1826
  iter_reg = qla24xx_read_window(reg, 30336U, 16U, iter_reg);
#line 1827
  qla24xx_read_window(reg, 30352U, 16U, iter_reg);
#line 1829
  qla24xx_read_window(reg, 30368U, 16U, (uint32_t *)(& fw->xmt_data_dma_reg));
#line 1832
  iter_reg = (uint32_t *)(& fw->rcvt0_data_dma_reg);
#line 1833
  iter_reg = qla24xx_read_window(reg, 30464U, 16U, iter_reg);
#line 1834
  qla24xx_read_window(reg, 30480U, 16U, iter_reg);
#line 1836
  iter_reg = (uint32_t *)(& fw->rcvt1_data_dma_reg);
#line 1837
  iter_reg = qla24xx_read_window(reg, 30496U, 16U, iter_reg);
#line 1838
  qla24xx_read_window(reg, 30512U, 16U, iter_reg);
#line 1841
  iter_reg = (uint32_t *)(& fw->risc_gp_reg);
#line 1842
  iter_reg = qla24xx_read_window(reg, 3840U, 16U, iter_reg);
#line 1843
  iter_reg = qla24xx_read_window(reg, 3856U, 16U, iter_reg);
#line 1844
  iter_reg = qla24xx_read_window(reg, 3872U, 16U, iter_reg);
#line 1845
  iter_reg = qla24xx_read_window(reg, 3888U, 16U, iter_reg);
#line 1846
  iter_reg = qla24xx_read_window(reg, 3904U, 16U, iter_reg);
#line 1847
  iter_reg = qla24xx_read_window(reg, 3920U, 16U, iter_reg);
#line 1848
  iter_reg = qla24xx_read_window(reg, 3936U, 16U, iter_reg);
#line 1849
  qla24xx_read_window(reg, 3952U, 16U, iter_reg);
#line 1852
  iter_reg = (uint32_t *)(& fw->lmc_reg);
#line 1853
  iter_reg = qla24xx_read_window(reg, 12288U, 16U, iter_reg);
#line 1854
  iter_reg = qla24xx_read_window(reg, 12304U, 16U, iter_reg);
#line 1855
  iter_reg = qla24xx_read_window(reg, 12320U, 16U, iter_reg);
#line 1856
  iter_reg = qla24xx_read_window(reg, 12336U, 16U, iter_reg);
#line 1857
  iter_reg = qla24xx_read_window(reg, 12352U, 16U, iter_reg);
#line 1858
  iter_reg = qla24xx_read_window(reg, 12368U, 16U, iter_reg);
#line 1859
  iter_reg = qla24xx_read_window(reg, 12384U, 16U, iter_reg);
#line 1860
  qla24xx_read_window(reg, 12400U, 16U, iter_reg);
#line 1863
  iter_reg = (uint32_t *)(& fw->fpm_hdw_reg);
#line 1864
  iter_reg = qla24xx_read_window(reg, 16384U, 16U, iter_reg);
#line 1865
  iter_reg = qla24xx_read_window(reg, 16400U, 16U, iter_reg);
#line 1866
  iter_reg = qla24xx_read_window(reg, 16416U, 16U, iter_reg);
#line 1867
  iter_reg = qla24xx_read_window(reg, 16432U, 16U, iter_reg);
#line 1868
  iter_reg = qla24xx_read_window(reg, 16448U, 16U, iter_reg);
#line 1869
  iter_reg = qla24xx_read_window(reg, 16464U, 16U, iter_reg);
#line 1870
  iter_reg = qla24xx_read_window(reg, 16480U, 16U, iter_reg);
#line 1871
  iter_reg = qla24xx_read_window(reg, 16496U, 16U, iter_reg);
#line 1872
  iter_reg = qla24xx_read_window(reg, 16512U, 16U, iter_reg);
#line 1873
  iter_reg = qla24xx_read_window(reg, 16528U, 16U, iter_reg);
#line 1874
  iter_reg = qla24xx_read_window(reg, 16544U, 16U, iter_reg);
#line 1875
  iter_reg = qla24xx_read_window(reg, 16560U, 16U, iter_reg);
#line 1876
  iter_reg = qla24xx_read_window(reg, 16576U, 16U, iter_reg);
#line 1877
  qla24xx_read_window(reg, 16592U, 16U, iter_reg);
#line 1880
  iter_reg = (uint32_t *)(& fw->fb_hdw_reg);
#line 1881
  iter_reg = qla24xx_read_window(reg, 24576U, 16U, iter_reg);
#line 1882
  iter_reg = qla24xx_read_window(reg, 24592U, 16U, iter_reg);
#line 1883
  iter_reg = qla24xx_read_window(reg, 24608U, 16U, iter_reg);
#line 1884
  iter_reg = qla24xx_read_window(reg, 24624U, 16U, iter_reg);
#line 1885
  iter_reg = qla24xx_read_window(reg, 24640U, 16U, iter_reg);
#line 1886
  iter_reg = qla24xx_read_window(reg, 24832U, 16U, iter_reg);
#line 1887
  iter_reg = qla24xx_read_window(reg, 24880U, 16U, iter_reg);
#line 1888
  iter_reg = qla24xx_read_window(reg, 24912U, 16U, iter_reg);
#line 1889
  iter_reg = qla24xx_read_window(reg, 24944U, 16U, iter_reg);
#line 1890
  iter_reg = qla24xx_read_window(reg, 24976U, 16U, iter_reg);
#line 1891
  iter_reg = qla24xx_read_window(reg, 25008U, 16U, iter_reg);
#line 1892
  iter_reg = qla24xx_read_window(reg, 25024U, 16U, iter_reg);
#line 1893
  qla24xx_read_window(reg, 28416U, 16U, iter_reg);
#line 1896
  nxt_chain = qla25xx_copy_mq(ha, (void *)ha->fw_dump + (unsigned long )ha->chain_offset,
                              & last_chain);
#line 1899
  rval = qla24xx_soft_reset(ha);
#line 1900
  if (rval != 0) {
#line 1901
    goto qla81xx_fw_dump_failed_0;
  } else {

  }
#line 1903
  rval = qla24xx_dump_memory(ha, (uint32_t *)(& fw->code_ram), 32768U, & nxt);
#line 1905
  if (rval != 0) {
#line 1906
    goto qla81xx_fw_dump_failed_0;
  } else {

  }
#line 1908
  nxt = qla2xxx_copy_queues(ha, nxt);
#line 1910
  qla24xx_copy_eft(ha, nxt);
#line 1913
  nxt_chain = qla25xx_copy_fce(ha, nxt_chain, & last_chain);
#line 1914
  nxt_chain = qla25xx_copy_mqueues(ha, nxt_chain, & last_chain);
#line 1915
  nxt_chain = qla2xxx_copy_atioqueues(ha, nxt_chain, & last_chain);
#line 1916
  if ((unsigned long )last_chain != (unsigned long )((uint32_t *)0U)) {
#line 1917
    (ha->fw_dump)->version = (ha->fw_dump)->version | 128U;
#line 1918
    *last_chain = *last_chain | 128U;
  } else {

  }
#line 1922
  ha->fw_dump_len = (uint32_t )((long )nxt_chain) - (uint32_t )((long )ha->fw_dump);
  qla81xx_fw_dump_failed_0: 
#line 1925
  qla2xxx_dump_post_process(base_vha, rval);
  qla81xx_fw_dump_failed: ;
#line 1928
  if (hardware_locked == 0) {
#line 1929
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
  } else {

  }
#line 1930
  return;
}
}
#line 1933 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
void qla83xx_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) 
{ 
  int rval ;
  uint32_t cnt ;
  uint32_t reg_data ;
  uint32_t risc_address ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  uint32_t *dmp_reg ;
  uint32_t *iter_reg ;
  uint16_t *mbx_reg ;
  unsigned long flags ;
  struct qla83xx_fw_dump *fw ;
  uint32_t ext_mem_cnt ;
  void *nxt ;
  void *nxt_chain ;
  uint32_t *last_chain ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned int tmp___1 ;
  __u32 tmp___2 ;
  uint32_t *tmp___3 ;
  unsigned int tmp___4 ;
  __u32 tmp___5 ;
  uint32_t *tmp___6 ;
  unsigned int tmp___7 ;
  __u32 tmp___8 ;
  unsigned int tmp___9 ;
  __u32 tmp___10 ;
  unsigned int tmp___11 ;
  __u32 tmp___12 ;
  uint32_t *tmp___13 ;
  unsigned int tmp___14 ;
  __u32 tmp___15 ;
  unsigned int tmp___16 ;
  __u32 tmp___17 ;
  unsigned int tmp___18 ;
  __u32 tmp___19 ;
  unsigned int tmp___20 ;
  __u32 tmp___21 ;
  unsigned int tmp___22 ;
  __u32 tmp___23 ;
  unsigned int tmp___24 ;
  __u32 tmp___25 ;
  unsigned int tmp___26 ;
  __u32 tmp___27 ;
  unsigned int tmp___28 ;
  __u32 tmp___29 ;
  unsigned int tmp___30 ;
  __u32 tmp___31 ;
  unsigned int tmp___32 ;
  __u32 tmp___33 ;
  unsigned int tmp___34 ;
  __u32 tmp___35 ;
  unsigned int tmp___36 ;
  __u32 tmp___37 ;
  unsigned int tmp___38 ;
  __u32 tmp___39 ;
  uint16_t *tmp___40 ;
  unsigned short tmp___41 ;
  __u16 tmp___42 ;
  uint32_t *tmp___43 ;
  uint32_t *tmp___44 ;
  unsigned int tmp___45 ;
  __u32 tmp___46 ;
  uint32_t *tmp___47 ;
  uint32_t *tmp___48 ;
  unsigned int tmp___49 ;
  __u32 tmp___50 ;
  uint32_t *tmp___51 ;
  uint32_t *tmp___52 ;
  unsigned int tmp___53 ;
  __u32 tmp___54 ;
  unsigned short tmp___55 ;

  {
#line 1938
  ha = vha->hw;
#line 1939
  reg = & (ha->iobase)->isp24;
#line 1947
  last_chain = (uint32_t *)0U;
#line 1948
  tmp = pci_get_drvdata(ha->pdev);
#line 1948
  base_vha = (struct scsi_qla_host *)tmp;
#line 1950
  ext_mem_cnt = 0U;
#line 1950
  risc_address = ext_mem_cnt;
#line 1951
  flags = 0UL;
#line 1952
  ha->fw_dump_cap_flags = 0UL;
#line 1954
  if (hardware_locked == 0) {
#line 1955
    tmp___0 = spinlock_check(& ha->hardware_lock);
#line 1955
    flags = _raw_spin_lock_irqsave(tmp___0);
  } else {

  }
#line 1957
  if ((unsigned long )ha->fw_dump == (unsigned long )((struct qla2xxx_fw_dump *)0)) {
#line 1958
    ql_log(1U, vha, 53260, "No buffer available for dump!!!\n");
#line 1960
    goto qla83xx_fw_dump_failed;
  } else {

  }
#line 1963
  if (ha->fw_dumped != 0) {
#line 1964
    ql_log(1U, vha, 53261, "Firmware has been previously dumped (%p) -- ignoring request...\n",
           ha->fw_dump);
#line 1967
    goto qla83xx_fw_dump_failed;
  } else {

  }
#line 1969
  fw = & (ha->fw_dump)->isp.isp83;
#line 1970
  qla2xxx_prep_dump(ha, ha->fw_dump);
#line 1972
  tmp___1 = readl((void const volatile   *)(& reg->host_status));
#line 1972
  tmp___2 = __fswab32(tmp___1);
#line 1972
  fw->host_status = tmp___2;
#line 1978
  qla24xx_pause_risc(reg, ha);
#line 1980
  writel(24576U, (void volatile   *)(& reg->iobase_addr));
#line 1981
  dmp_reg = & reg->iobase_window;
#line 1982
  reg_data = readl((void const volatile   *)dmp_reg);
#line 1983
  writel(0U, (void volatile   *)dmp_reg);
#line 1985
  dmp_reg = (uint32_t *)(& reg->unused_4_1);
#line 1986
  reg_data = readl((void const volatile   *)dmp_reg);
#line 1987
  writel(0U, (void volatile   *)dmp_reg);
#line 1989
  writel(24592U, (void volatile   *)(& reg->iobase_addr));
#line 1990
  dmp_reg = (uint32_t *)(& reg->unused_4_1) + 2UL;
#line 1991
  reg_data = readl((void const volatile   *)dmp_reg);
#line 1992
  writel(0U, (void volatile   *)dmp_reg);
#line 1995
  writel(3952U, (void volatile   *)(& reg->iobase_addr));
#line 1996
  readl((void const volatile   *)(& reg->iobase_addr));
#line 1997
  writel(1610612736U, (void volatile   *)(& reg->iobase_select));
#line 2000
  iter_reg = (uint32_t *)(& fw->host_risc_reg);
#line 2001
  iter_reg = qla24xx_read_window(reg, 28672U, 16U, iter_reg);
#line 2002
  iter_reg = qla24xx_read_window(reg, 28688U, 16U, iter_reg);
#line 2003
  qla24xx_read_window(reg, 28736U, 16U, iter_reg);
#line 2006
  writel(31744U, (void volatile   *)(& reg->iobase_addr));
#line 2007
  readl((void const volatile   *)(& reg->iobase_addr));
#line 2008
  writel(1U, (void volatile   *)(& reg->iobase_window));
#line 2009
  dmp_reg = & reg->iobase_c4;
#line 2010
  tmp___3 = dmp_reg;
#line 2010
  dmp_reg = dmp_reg + 1;
#line 2010
  tmp___4 = readl((void const volatile   *)tmp___3);
#line 2010
  tmp___5 = __fswab32(tmp___4);
#line 2010
  fw->pcie_regs[0] = tmp___5;
#line 2011
  tmp___6 = dmp_reg;
#line 2011
  dmp_reg = dmp_reg + 1;
#line 2011
  tmp___7 = readl((void const volatile   *)tmp___6);
#line 2011
  tmp___8 = __fswab32(tmp___7);
#line 2011
  fw->pcie_regs[1] = tmp___8;
#line 2012
  tmp___9 = readl((void const volatile   *)dmp_reg);
#line 2012
  tmp___10 = __fswab32(tmp___9);
#line 2012
  fw->pcie_regs[2] = tmp___10;
#line 2013
  tmp___11 = readl((void const volatile   *)(& reg->iobase_window));
#line 2013
  tmp___12 = __fswab32(tmp___11);
#line 2013
  fw->pcie_regs[3] = tmp___12;
#line 2015
  writel(0U, (void volatile   *)(& reg->iobase_window));
#line 2016
  readl((void const volatile   *)(& reg->iobase_window));
#line 2019
  dmp_reg = & reg->flash_addr;
#line 2020
  cnt = 0U;
#line 2020
  goto ldv_66180;
  ldv_66179: 
#line 2021
  tmp___13 = dmp_reg;
#line 2021
  dmp_reg = dmp_reg + 1;
#line 2021
  tmp___14 = readl((void const volatile   *)tmp___13);
#line 2021
  tmp___15 = __fswab32(tmp___14);
#line 2021
  fw->host_reg[cnt] = tmp___15;
#line 2020
  cnt = cnt + 1U;
  ldv_66180: ;
#line 2020
  if (cnt <= 31U) {
#line 2022
    goto ldv_66179;
  } else {

  }
#line 2024
  writel(0U, (void volatile   *)(& reg->ictrl));
#line 2025
  readl((void const volatile   *)(& reg->ictrl));
#line 2028
  writel(3952U, (void volatile   *)(& reg->iobase_addr));
#line 2029
  readl((void const volatile   *)(& reg->iobase_addr));
#line 2030
  writel(2952790016U, (void volatile   *)(& reg->iobase_select));
#line 2031
  tmp___16 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 2031
  tmp___17 = __fswab32(tmp___16);
#line 2031
  fw->shadow_reg[0] = tmp___17;
#line 2033
  writel(2953838592U, (void volatile   *)(& reg->iobase_select));
#line 2034
  tmp___18 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 2034
  tmp___19 = __fswab32(tmp___18);
#line 2034
  fw->shadow_reg[1] = tmp___19;
#line 2036
  writel(2954887168U, (void volatile   *)(& reg->iobase_select));
#line 2037
  tmp___20 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 2037
  tmp___21 = __fswab32(tmp___20);
#line 2037
  fw->shadow_reg[2] = tmp___21;
#line 2039
  writel(2955935744U, (void volatile   *)(& reg->iobase_select));
#line 2040
  tmp___22 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 2040
  tmp___23 = __fswab32(tmp___22);
#line 2040
  fw->shadow_reg[3] = tmp___23;
#line 2042
  writel(2956984320U, (void volatile   *)(& reg->iobase_select));
#line 2043
  tmp___24 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 2043
  tmp___25 = __fswab32(tmp___24);
#line 2043
  fw->shadow_reg[4] = tmp___25;
#line 2045
  writel(2958032896U, (void volatile   *)(& reg->iobase_select));
#line 2046
  tmp___26 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 2046
  tmp___27 = __fswab32(tmp___26);
#line 2046
  fw->shadow_reg[5] = tmp___27;
#line 2048
  writel(2959081472U, (void volatile   *)(& reg->iobase_select));
#line 2049
  tmp___28 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 2049
  tmp___29 = __fswab32(tmp___28);
#line 2049
  fw->shadow_reg[6] = tmp___29;
#line 2051
  writel(2960130048U, (void volatile   *)(& reg->iobase_select));
#line 2052
  tmp___30 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 2052
  tmp___31 = __fswab32(tmp___30);
#line 2052
  fw->shadow_reg[7] = tmp___31;
#line 2054
  writel(2961178624U, (void volatile   *)(& reg->iobase_select));
#line 2055
  tmp___32 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 2055
  tmp___33 = __fswab32(tmp___32);
#line 2055
  fw->shadow_reg[8] = tmp___33;
#line 2057
  writel(2962227200U, (void volatile   *)(& reg->iobase_select));
#line 2058
  tmp___34 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 2058
  tmp___35 = __fswab32(tmp___34);
#line 2058
  fw->shadow_reg[9] = tmp___35;
#line 2060
  writel(2963275776U, (void volatile   *)(& reg->iobase_select));
#line 2061
  tmp___36 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 2061
  tmp___37 = __fswab32(tmp___36);
#line 2061
  fw->shadow_reg[10] = tmp___37;
#line 2064
  writel(16U, (void volatile   *)(& reg->iobase_addr));
#line 2065
  tmp___38 = readl((void const volatile   *)(& reg->iobase_window));
#line 2065
  tmp___39 = __fswab32(tmp___38);
#line 2065
  fw->risc_io_reg = tmp___39;
#line 2068
  mbx_reg = & reg->mailbox0;
#line 2069
  cnt = 0U;
#line 2069
  goto ldv_66183;
  ldv_66182: 
#line 2070
  tmp___40 = mbx_reg;
#line 2070
  mbx_reg = mbx_reg + 1;
#line 2070
  tmp___41 = readw((void const volatile   *)tmp___40);
#line 2070
  tmp___42 = __fswab16((int )tmp___41);
#line 2070
  fw->mailbox_reg[cnt] = tmp___42;
#line 2069
  cnt = cnt + 1U;
  ldv_66183: ;
#line 2069
  if (cnt <= 31U) {
#line 2071
    goto ldv_66182;
  } else {

  }
#line 2073
  iter_reg = (uint32_t *)(& fw->xseq_gp_reg);
#line 2074
  iter_reg = qla24xx_read_window(reg, 48640U, 16U, iter_reg);
#line 2075
  iter_reg = qla24xx_read_window(reg, 48656U, 16U, iter_reg);
#line 2076
  iter_reg = qla24xx_read_window(reg, 48672U, 16U, iter_reg);
#line 2077
  iter_reg = qla24xx_read_window(reg, 48688U, 16U, iter_reg);
#line 2078
  iter_reg = qla24xx_read_window(reg, 48704U, 16U, iter_reg);
#line 2079
  iter_reg = qla24xx_read_window(reg, 48720U, 16U, iter_reg);
#line 2080
  iter_reg = qla24xx_read_window(reg, 48736U, 16U, iter_reg);
#line 2081
  iter_reg = qla24xx_read_window(reg, 48752U, 16U, iter_reg);
#line 2082
  iter_reg = qla24xx_read_window(reg, 48896U, 16U, iter_reg);
#line 2083
  iter_reg = qla24xx_read_window(reg, 48912U, 16U, iter_reg);
#line 2084
  iter_reg = qla24xx_read_window(reg, 48928U, 16U, iter_reg);
#line 2085
  iter_reg = qla24xx_read_window(reg, 48944U, 16U, iter_reg);
#line 2086
  iter_reg = qla24xx_read_window(reg, 48960U, 16U, iter_reg);
#line 2087
  iter_reg = qla24xx_read_window(reg, 48976U, 16U, iter_reg);
#line 2088
  iter_reg = qla24xx_read_window(reg, 48992U, 16U, iter_reg);
#line 2089
  qla24xx_read_window(reg, 49008U, 16U, iter_reg);
#line 2091
  iter_reg = (uint32_t *)(& fw->xseq_0_reg);
#line 2092
  iter_reg = qla24xx_read_window(reg, 49088U, 16U, iter_reg);
#line 2093
  iter_reg = qla24xx_read_window(reg, 49104U, 16U, iter_reg);
#line 2094
  qla24xx_read_window(reg, 49120U, 16U, iter_reg);
#line 2096
  qla24xx_read_window(reg, 49136U, 16U, (uint32_t *)(& fw->xseq_1_reg));
#line 2098
  qla24xx_read_window(reg, 48880U, 16U, (uint32_t *)(& fw->xseq_2_reg));
#line 2101
  iter_reg = (uint32_t *)(& fw->rseq_gp_reg);
#line 2102
  iter_reg = qla24xx_read_window(reg, 65024U, 16U, iter_reg);
#line 2103
  iter_reg = qla24xx_read_window(reg, 65040U, 16U, iter_reg);
#line 2104
  iter_reg = qla24xx_read_window(reg, 65056U, 16U, iter_reg);
#line 2105
  iter_reg = qla24xx_read_window(reg, 65072U, 16U, iter_reg);
#line 2106
  iter_reg = qla24xx_read_window(reg, 65088U, 16U, iter_reg);
#line 2107
  iter_reg = qla24xx_read_window(reg, 65104U, 16U, iter_reg);
#line 2108
  iter_reg = qla24xx_read_window(reg, 65120U, 16U, iter_reg);
#line 2109
  iter_reg = qla24xx_read_window(reg, 65136U, 16U, iter_reg);
#line 2110
  iter_reg = qla24xx_read_window(reg, 65280U, 16U, iter_reg);
#line 2111
  iter_reg = qla24xx_read_window(reg, 65296U, 16U, iter_reg);
#line 2112
  iter_reg = qla24xx_read_window(reg, 65312U, 16U, iter_reg);
#line 2113
  iter_reg = qla24xx_read_window(reg, 65328U, 16U, iter_reg);
#line 2114
  iter_reg = qla24xx_read_window(reg, 65344U, 16U, iter_reg);
#line 2115
  iter_reg = qla24xx_read_window(reg, 65360U, 16U, iter_reg);
#line 2116
  iter_reg = qla24xx_read_window(reg, 65376U, 16U, iter_reg);
#line 2117
  qla24xx_read_window(reg, 65392U, 16U, iter_reg);
#line 2119
  iter_reg = (uint32_t *)(& fw->rseq_0_reg);
#line 2120
  iter_reg = qla24xx_read_window(reg, 65472U, 16U, iter_reg);
#line 2121
  qla24xx_read_window(reg, 65488U, 16U, iter_reg);
#line 2123
  qla24xx_read_window(reg, 65504U, 16U, (uint32_t *)(& fw->rseq_1_reg));
#line 2124
  qla24xx_read_window(reg, 65520U, 16U, (uint32_t *)(& fw->rseq_2_reg));
#line 2125
  qla24xx_read_window(reg, 65264U, 16U, (uint32_t *)(& fw->rseq_3_reg));
#line 2128
  iter_reg = (uint32_t *)(& fw->aseq_gp_reg);
#line 2129
  iter_reg = qla24xx_read_window(reg, 45056U, 16U, iter_reg);
#line 2130
  iter_reg = qla24xx_read_window(reg, 45072U, 16U, iter_reg);
#line 2131
  iter_reg = qla24xx_read_window(reg, 45088U, 16U, iter_reg);
#line 2132
  iter_reg = qla24xx_read_window(reg, 45104U, 16U, iter_reg);
#line 2133
  iter_reg = qla24xx_read_window(reg, 45120U, 16U, iter_reg);
#line 2134
  iter_reg = qla24xx_read_window(reg, 45136U, 16U, iter_reg);
#line 2135
  iter_reg = qla24xx_read_window(reg, 45152U, 16U, iter_reg);
#line 2136
  iter_reg = qla24xx_read_window(reg, 45168U, 16U, iter_reg);
#line 2137
  iter_reg = qla24xx_read_window(reg, 45312U, 16U, iter_reg);
#line 2138
  iter_reg = qla24xx_read_window(reg, 45328U, 16U, iter_reg);
#line 2139
  iter_reg = qla24xx_read_window(reg, 45344U, 16U, iter_reg);
#line 2140
  iter_reg = qla24xx_read_window(reg, 45360U, 16U, iter_reg);
#line 2141
  iter_reg = qla24xx_read_window(reg, 45376U, 16U, iter_reg);
#line 2142
  iter_reg = qla24xx_read_window(reg, 45392U, 16U, iter_reg);
#line 2143
  iter_reg = qla24xx_read_window(reg, 45408U, 16U, iter_reg);
#line 2144
  qla24xx_read_window(reg, 45424U, 16U, iter_reg);
#line 2146
  iter_reg = (uint32_t *)(& fw->aseq_0_reg);
#line 2147
  iter_reg = qla24xx_read_window(reg, 45248U, 16U, iter_reg);
#line 2148
  qla24xx_read_window(reg, 45264U, 16U, iter_reg);
#line 2150
  qla24xx_read_window(reg, 45280U, 16U, (uint32_t *)(& fw->aseq_1_reg));
#line 2151
  qla24xx_read_window(reg, 45296U, 16U, (uint32_t *)(& fw->aseq_2_reg));
#line 2152
  qla24xx_read_window(reg, 45552U, 16U, (uint32_t *)(& fw->aseq_3_reg));
#line 2155
  iter_reg = (uint32_t *)(& fw->cmd_dma_reg);
#line 2156
  iter_reg = qla24xx_read_window(reg, 28928U, 16U, iter_reg);
#line 2157
  iter_reg = qla24xx_read_window(reg, 28960U, 16U, iter_reg);
#line 2158
  iter_reg = qla24xx_read_window(reg, 28976U, 16U, iter_reg);
#line 2159
  qla24xx_read_window(reg, 29168U, 16U, iter_reg);
#line 2162
  iter_reg = (uint32_t *)(& fw->req0_dma_reg);
#line 2163
  iter_reg = qla24xx_read_window(reg, 29184U, 8U, iter_reg);
#line 2164
  dmp_reg = & reg->iobase_q;
#line 2165
  cnt = 0U;
#line 2165
  goto ldv_66186;
  ldv_66185: 
#line 2166
  tmp___43 = iter_reg;
#line 2166
  iter_reg = iter_reg + 1;
#line 2166
  tmp___44 = dmp_reg;
#line 2166
  dmp_reg = dmp_reg + 1;
#line 2166
  tmp___45 = readl((void const volatile   *)tmp___44);
#line 2166
  tmp___46 = __fswab32(tmp___45);
#line 2166
  *tmp___43 = tmp___46;
#line 2165
  cnt = cnt + 1U;
  ldv_66186: ;
#line 2165
  if (cnt <= 6U) {
#line 2167
    goto ldv_66185;
  } else {

  }
#line 2168
  iter_reg = (uint32_t *)(& fw->resp0_dma_reg);
#line 2169
  iter_reg = qla24xx_read_window(reg, 29440U, 8U, iter_reg);
#line 2170
  dmp_reg = & reg->iobase_q;
#line 2171
  cnt = 0U;
#line 2171
  goto ldv_66189;
  ldv_66188: 
#line 2172
  tmp___47 = iter_reg;
#line 2172
  iter_reg = iter_reg + 1;
#line 2172
  tmp___48 = dmp_reg;
#line 2172
  dmp_reg = dmp_reg + 1;
#line 2172
  tmp___49 = readl((void const volatile   *)tmp___48);
#line 2172
  tmp___50 = __fswab32(tmp___49);
#line 2172
  *tmp___47 = tmp___50;
#line 2171
  cnt = cnt + 1U;
  ldv_66189: ;
#line 2171
  if (cnt <= 6U) {
#line 2173
    goto ldv_66188;
  } else {

  }
#line 2174
  iter_reg = (uint32_t *)(& fw->req1_dma_reg);
#line 2175
  iter_reg = qla24xx_read_window(reg, 29696U, 8U, iter_reg);
#line 2176
  dmp_reg = & reg->iobase_q;
#line 2177
  cnt = 0U;
#line 2177
  goto ldv_66192;
  ldv_66191: 
#line 2178
  tmp___51 = iter_reg;
#line 2178
  iter_reg = iter_reg + 1;
#line 2178
  tmp___52 = dmp_reg;
#line 2178
  dmp_reg = dmp_reg + 1;
#line 2178
  tmp___53 = readl((void const volatile   *)tmp___52);
#line 2178
  tmp___54 = __fswab32(tmp___53);
#line 2178
  *tmp___51 = tmp___54;
#line 2177
  cnt = cnt + 1U;
  ldv_66192: ;
#line 2177
  if (cnt <= 6U) {
#line 2179
    goto ldv_66191;
  } else {

  }
#line 2181
  iter_reg = (uint32_t *)(& fw->xmt0_dma_reg);
#line 2182
  iter_reg = qla24xx_read_window(reg, 30208U, 16U, iter_reg);
#line 2183
  qla24xx_read_window(reg, 30224U, 16U, iter_reg);
#line 2185
  iter_reg = (uint32_t *)(& fw->xmt1_dma_reg);
#line 2186
  iter_reg = qla24xx_read_window(reg, 30240U, 16U, iter_reg);
#line 2187
  qla24xx_read_window(reg, 30256U, 16U, iter_reg);
#line 2189
  iter_reg = (uint32_t *)(& fw->xmt2_dma_reg);
#line 2190
  iter_reg = qla24xx_read_window(reg, 30272U, 16U, iter_reg);
#line 2191
  qla24xx_read_window(reg, 30288U, 16U, iter_reg);
#line 2193
  iter_reg = (uint32_t *)(& fw->xmt3_dma_reg);
#line 2194
  iter_reg = qla24xx_read_window(reg, 30304U, 16U, iter_reg);
#line 2195
  qla24xx_read_window(reg, 30320U, 16U, iter_reg);
#line 2197
  iter_reg = (uint32_t *)(& fw->xmt4_dma_reg);
#line 2198
  iter_reg = qla24xx_read_window(reg, 30336U, 16U, iter_reg);
#line 2199
  qla24xx_read_window(reg, 30352U, 16U, iter_reg);
#line 2201
  qla24xx_read_window(reg, 30368U, 16U, (uint32_t *)(& fw->xmt_data_dma_reg));
#line 2204
  iter_reg = (uint32_t *)(& fw->rcvt0_data_dma_reg);
#line 2205
  iter_reg = qla24xx_read_window(reg, 30464U, 16U, iter_reg);
#line 2206
  qla24xx_read_window(reg, 30480U, 16U, iter_reg);
#line 2208
  iter_reg = (uint32_t *)(& fw->rcvt1_data_dma_reg);
#line 2209
  iter_reg = qla24xx_read_window(reg, 30496U, 16U, iter_reg);
#line 2210
  qla24xx_read_window(reg, 30512U, 16U, iter_reg);
#line 2213
  iter_reg = (uint32_t *)(& fw->risc_gp_reg);
#line 2214
  iter_reg = qla24xx_read_window(reg, 3840U, 16U, iter_reg);
#line 2215
  iter_reg = qla24xx_read_window(reg, 3856U, 16U, iter_reg);
#line 2216
  iter_reg = qla24xx_read_window(reg, 3872U, 16U, iter_reg);
#line 2217
  iter_reg = qla24xx_read_window(reg, 3888U, 16U, iter_reg);
#line 2218
  iter_reg = qla24xx_read_window(reg, 3904U, 16U, iter_reg);
#line 2219
  iter_reg = qla24xx_read_window(reg, 3920U, 16U, iter_reg);
#line 2220
  iter_reg = qla24xx_read_window(reg, 3936U, 16U, iter_reg);
#line 2221
  qla24xx_read_window(reg, 3952U, 16U, iter_reg);
#line 2224
  iter_reg = (uint32_t *)(& fw->lmc_reg);
#line 2225
  iter_reg = qla24xx_read_window(reg, 12288U, 16U, iter_reg);
#line 2226
  iter_reg = qla24xx_read_window(reg, 12304U, 16U, iter_reg);
#line 2227
  iter_reg = qla24xx_read_window(reg, 12320U, 16U, iter_reg);
#line 2228
  iter_reg = qla24xx_read_window(reg, 12336U, 16U, iter_reg);
#line 2229
  iter_reg = qla24xx_read_window(reg, 12352U, 16U, iter_reg);
#line 2230
  iter_reg = qla24xx_read_window(reg, 12368U, 16U, iter_reg);
#line 2231
  iter_reg = qla24xx_read_window(reg, 12384U, 16U, iter_reg);
#line 2232
  qla24xx_read_window(reg, 12400U, 16U, iter_reg);
#line 2235
  iter_reg = (uint32_t *)(& fw->fpm_hdw_reg);
#line 2236
  iter_reg = qla24xx_read_window(reg, 16384U, 16U, iter_reg);
#line 2237
  iter_reg = qla24xx_read_window(reg, 16400U, 16U, iter_reg);
#line 2238
  iter_reg = qla24xx_read_window(reg, 16416U, 16U, iter_reg);
#line 2239
  iter_reg = qla24xx_read_window(reg, 16432U, 16U, iter_reg);
#line 2240
  iter_reg = qla24xx_read_window(reg, 16448U, 16U, iter_reg);
#line 2241
  iter_reg = qla24xx_read_window(reg, 16464U, 16U, iter_reg);
#line 2242
  iter_reg = qla24xx_read_window(reg, 16480U, 16U, iter_reg);
#line 2243
  iter_reg = qla24xx_read_window(reg, 16496U, 16U, iter_reg);
#line 2244
  iter_reg = qla24xx_read_window(reg, 16512U, 16U, iter_reg);
#line 2245
  iter_reg = qla24xx_read_window(reg, 16528U, 16U, iter_reg);
#line 2246
  iter_reg = qla24xx_read_window(reg, 16544U, 16U, iter_reg);
#line 2247
  iter_reg = qla24xx_read_window(reg, 16560U, 16U, iter_reg);
#line 2248
  iter_reg = qla24xx_read_window(reg, 16576U, 16U, iter_reg);
#line 2249
  iter_reg = qla24xx_read_window(reg, 16592U, 16U, iter_reg);
#line 2250
  iter_reg = qla24xx_read_window(reg, 16608U, 16U, iter_reg);
#line 2251
  qla24xx_read_window(reg, 16624U, 16U, iter_reg);
#line 2254
  iter_reg = (uint32_t *)(& fw->rq0_array_reg);
#line 2255
  iter_reg = qla24xx_read_window(reg, 23552U, 16U, iter_reg);
#line 2256
  iter_reg = qla24xx_read_window(reg, 23568U, 16U, iter_reg);
#line 2257
  iter_reg = qla24xx_read_window(reg, 23584U, 16U, iter_reg);
#line 2258
  iter_reg = qla24xx_read_window(reg, 23600U, 16U, iter_reg);
#line 2259
  iter_reg = qla24xx_read_window(reg, 23616U, 16U, iter_reg);
#line 2260
  iter_reg = qla24xx_read_window(reg, 23632U, 16U, iter_reg);
#line 2261
  iter_reg = qla24xx_read_window(reg, 23648U, 16U, iter_reg);
#line 2262
  iter_reg = qla24xx_read_window(reg, 23664U, 16U, iter_reg);
#line 2263
  iter_reg = qla24xx_read_window(reg, 23680U, 16U, iter_reg);
#line 2264
  iter_reg = qla24xx_read_window(reg, 23696U, 16U, iter_reg);
#line 2265
  iter_reg = qla24xx_read_window(reg, 23712U, 16U, iter_reg);
#line 2266
  iter_reg = qla24xx_read_window(reg, 23728U, 16U, iter_reg);
#line 2267
  iter_reg = qla24xx_read_window(reg, 23744U, 16U, iter_reg);
#line 2268
  iter_reg = qla24xx_read_window(reg, 23760U, 16U, iter_reg);
#line 2269
  iter_reg = qla24xx_read_window(reg, 23776U, 16U, iter_reg);
#line 2270
  qla24xx_read_window(reg, 23792U, 16U, iter_reg);
#line 2273
  iter_reg = (uint32_t *)(& fw->rq1_array_reg);
#line 2274
  iter_reg = qla24xx_read_window(reg, 23808U, 16U, iter_reg);
#line 2275
  iter_reg = qla24xx_read_window(reg, 23824U, 16U, iter_reg);
#line 2276
  iter_reg = qla24xx_read_window(reg, 23840U, 16U, iter_reg);
#line 2277
  iter_reg = qla24xx_read_window(reg, 23856U, 16U, iter_reg);
#line 2278
  iter_reg = qla24xx_read_window(reg, 23872U, 16U, iter_reg);
#line 2279
  iter_reg = qla24xx_read_window(reg, 23888U, 16U, iter_reg);
#line 2280
  iter_reg = qla24xx_read_window(reg, 23904U, 16U, iter_reg);
#line 2281
  iter_reg = qla24xx_read_window(reg, 23920U, 16U, iter_reg);
#line 2282
  iter_reg = qla24xx_read_window(reg, 23936U, 16U, iter_reg);
#line 2283
  iter_reg = qla24xx_read_window(reg, 23952U, 16U, iter_reg);
#line 2284
  iter_reg = qla24xx_read_window(reg, 23968U, 16U, iter_reg);
#line 2285
  iter_reg = qla24xx_read_window(reg, 23984U, 16U, iter_reg);
#line 2286
  iter_reg = qla24xx_read_window(reg, 24000U, 16U, iter_reg);
#line 2287
  iter_reg = qla24xx_read_window(reg, 24016U, 16U, iter_reg);
#line 2288
  iter_reg = qla24xx_read_window(reg, 24032U, 16U, iter_reg);
#line 2289
  qla24xx_read_window(reg, 24048U, 16U, iter_reg);
#line 2292
  iter_reg = (uint32_t *)(& fw->rp0_array_reg);
#line 2293
  iter_reg = qla24xx_read_window(reg, 24064U, 16U, iter_reg);
#line 2294
  iter_reg = qla24xx_read_window(reg, 24080U, 16U, iter_reg);
#line 2295
  iter_reg = qla24xx_read_window(reg, 24096U, 16U, iter_reg);
#line 2296
  iter_reg = qla24xx_read_window(reg, 24112U, 16U, iter_reg);
#line 2297
  iter_reg = qla24xx_read_window(reg, 24128U, 16U, iter_reg);
#line 2298
  iter_reg = qla24xx_read_window(reg, 24144U, 16U, iter_reg);
#line 2299
  iter_reg = qla24xx_read_window(reg, 24160U, 16U, iter_reg);
#line 2300
  iter_reg = qla24xx_read_window(reg, 24176U, 16U, iter_reg);
#line 2301
  iter_reg = qla24xx_read_window(reg, 24192U, 16U, iter_reg);
#line 2302
  iter_reg = qla24xx_read_window(reg, 24208U, 16U, iter_reg);
#line 2303
  iter_reg = qla24xx_read_window(reg, 24224U, 16U, iter_reg);
#line 2304
  iter_reg = qla24xx_read_window(reg, 24240U, 16U, iter_reg);
#line 2305
  iter_reg = qla24xx_read_window(reg, 24256U, 16U, iter_reg);
#line 2306
  iter_reg = qla24xx_read_window(reg, 24272U, 16U, iter_reg);
#line 2307
  iter_reg = qla24xx_read_window(reg, 24288U, 16U, iter_reg);
#line 2308
  qla24xx_read_window(reg, 24304U, 16U, iter_reg);
#line 2311
  iter_reg = (uint32_t *)(& fw->rp1_array_reg);
#line 2312
  iter_reg = qla24xx_read_window(reg, 24320U, 16U, iter_reg);
#line 2313
  iter_reg = qla24xx_read_window(reg, 24336U, 16U, iter_reg);
#line 2314
  iter_reg = qla24xx_read_window(reg, 24352U, 16U, iter_reg);
#line 2315
  iter_reg = qla24xx_read_window(reg, 24368U, 16U, iter_reg);
#line 2316
  iter_reg = qla24xx_read_window(reg, 24384U, 16U, iter_reg);
#line 2317
  iter_reg = qla24xx_read_window(reg, 24400U, 16U, iter_reg);
#line 2318
  iter_reg = qla24xx_read_window(reg, 24416U, 16U, iter_reg);
#line 2319
  iter_reg = qla24xx_read_window(reg, 24432U, 16U, iter_reg);
#line 2320
  iter_reg = qla24xx_read_window(reg, 24448U, 16U, iter_reg);
#line 2321
  iter_reg = qla24xx_read_window(reg, 24464U, 16U, iter_reg);
#line 2322
  iter_reg = qla24xx_read_window(reg, 24480U, 16U, iter_reg);
#line 2323
  iter_reg = qla24xx_read_window(reg, 24496U, 16U, iter_reg);
#line 2324
  iter_reg = qla24xx_read_window(reg, 24512U, 16U, iter_reg);
#line 2325
  iter_reg = qla24xx_read_window(reg, 24528U, 16U, iter_reg);
#line 2326
  iter_reg = qla24xx_read_window(reg, 24544U, 16U, iter_reg);
#line 2327
  qla24xx_read_window(reg, 24560U, 16U, iter_reg);
#line 2329
  iter_reg = (uint32_t *)(& fw->at0_array_reg);
#line 2330
  iter_reg = qla24xx_read_window(reg, 28800U, 16U, iter_reg);
#line 2331
  iter_reg = qla24xx_read_window(reg, 28816U, 16U, iter_reg);
#line 2332
  iter_reg = qla24xx_read_window(reg, 28832U, 16U, iter_reg);
#line 2333
  iter_reg = qla24xx_read_window(reg, 28848U, 16U, iter_reg);
#line 2334
  iter_reg = qla24xx_read_window(reg, 28864U, 16U, iter_reg);
#line 2335
  iter_reg = qla24xx_read_window(reg, 28880U, 16U, iter_reg);
#line 2336
  iter_reg = qla24xx_read_window(reg, 28896U, 16U, iter_reg);
#line 2337
  qla24xx_read_window(reg, 28912U, 16U, iter_reg);
#line 2340
  qla24xx_read_window(reg, 30720U, 16U, (uint32_t *)(& fw->queue_control_reg));
#line 2343
  iter_reg = (uint32_t *)(& fw->fb_hdw_reg);
#line 2344
  iter_reg = qla24xx_read_window(reg, 24576U, 16U, iter_reg);
#line 2345
  iter_reg = qla24xx_read_window(reg, 24592U, 16U, iter_reg);
#line 2346
  iter_reg = qla24xx_read_window(reg, 24608U, 16U, iter_reg);
#line 2347
  iter_reg = qla24xx_read_window(reg, 24624U, 16U, iter_reg);
#line 2348
  iter_reg = qla24xx_read_window(reg, 24640U, 16U, iter_reg);
#line 2349
  iter_reg = qla24xx_read_window(reg, 24672U, 16U, iter_reg);
#line 2350
  iter_reg = qla24xx_read_window(reg, 24688U, 16U, iter_reg);
#line 2351
  iter_reg = qla24xx_read_window(reg, 24832U, 16U, iter_reg);
#line 2352
  iter_reg = qla24xx_read_window(reg, 24880U, 16U, iter_reg);
#line 2353
  iter_reg = qla24xx_read_window(reg, 24912U, 16U, iter_reg);
#line 2354
  iter_reg = qla24xx_read_window(reg, 24944U, 16U, iter_reg);
#line 2355
  iter_reg = qla24xx_read_window(reg, 24976U, 16U, iter_reg);
#line 2356
  iter_reg = qla24xx_read_window(reg, 25008U, 16U, iter_reg);
#line 2357
  iter_reg = qla24xx_read_window(reg, 25024U, 16U, iter_reg);
#line 2358
  iter_reg = qla24xx_read_window(reg, 25904U, 16U, iter_reg);
#line 2359
  iter_reg = qla24xx_read_window(reg, 25920U, 16U, iter_reg);
#line 2360
  iter_reg = qla24xx_read_window(reg, 25936U, 16U, iter_reg);
#line 2361
  iter_reg = qla24xx_read_window(reg, 25952U, 16U, iter_reg);
#line 2362
  iter_reg = qla24xx_read_window(reg, 25968U, 16U, iter_reg);
#line 2363
  iter_reg = qla24xx_read_window(reg, 25984U, 16U, iter_reg);
#line 2364
  iter_reg = qla24xx_read_window(reg, 26000U, 16U, iter_reg);
#line 2365
  iter_reg = qla24xx_read_window(reg, 26016U, 16U, iter_reg);
#line 2366
  iter_reg = qla24xx_read_window(reg, 26032U, 16U, iter_reg);
#line 2367
  iter_reg = qla24xx_read_window(reg, 26048U, 16U, iter_reg);
#line 2368
  iter_reg = qla24xx_read_window(reg, 26064U, 16U, iter_reg);
#line 2369
  iter_reg = qla24xx_read_window(reg, 26080U, 16U, iter_reg);
#line 2370
  qla24xx_read_window(reg, 28416U, 16U, iter_reg);
#line 2373
  nxt_chain = qla25xx_copy_mq(ha, (void *)ha->fw_dump + (unsigned long )ha->chain_offset,
                              & last_chain);
#line 2376
  rval = qla24xx_soft_reset(ha);
#line 2377
  if (rval != 0) {
#line 2378
    ql_log(1U, vha, 53262, "SOFT RESET FAILED, forcing continuation of dump!!!\n");
#line 2380
    rval = 0;
#line 2382
    ql_log(1U, vha, 53263, "try a bigger hammer!!!\n");
#line 2384
    writel(268435456U, (void volatile   *)(& reg->hccr));
#line 2385
    readl((void const volatile   *)(& reg->hccr));
#line 2387
    writel(1073741824U, (void volatile   *)(& reg->hccr));
#line 2388
    readl((void const volatile   *)(& reg->hccr));
#line 2390
    writel(536870912U, (void volatile   *)(& reg->hccr));
#line 2391
    readl((void const volatile   *)(& reg->hccr));
#line 2393
    cnt = 30000U;
#line 2393
    goto ldv_66195;
    ldv_66194: 
#line 2394
    __const_udelay(21475UL);
#line 2393
    cnt = cnt - 1U;
    ldv_66195: ;
#line 2393
    if (cnt != 0U) {
#line 2393
      tmp___55 = readw((void const volatile   *)(& reg->mailbox0));
#line 2393
      if ((unsigned int )tmp___55 != 0U) {
#line 2395
        goto ldv_66194;
      } else {
#line 2398
        goto ldv_66196;
      }
    } else {

    }
    ldv_66196: ;
#line 2396
    if (cnt == 0U) {
#line 2397
      nxt = (void *)(& fw->code_ram);
#line 2398
      nxt = nxt + 36864UL;
#line 2399
      nxt = nxt + (unsigned long )(ha->fw_memory_size - 1048575U);
#line 2400
      goto copy_queue;
    } else {
#line 2402
      set_bit(3L, (unsigned long volatile   *)(& ha->fw_dump_cap_flags));
#line 2403
      ql_log(1U, vha, 53264, "bigger hammer success?\n");
    }
  } else {

  }
#line 2408
  rval = qla24xx_dump_memory(ha, (uint32_t *)(& fw->code_ram), 36864U, & nxt);
#line 2410
  if (rval != 0) {
#line 2411
    goto qla83xx_fw_dump_failed_0;
  } else {

  }
  copy_queue: 
#line 2414
  nxt = qla2xxx_copy_queues(ha, nxt);
#line 2416
  qla24xx_copy_eft(ha, nxt);
#line 2419
  nxt_chain = qla25xx_copy_fce(ha, nxt_chain, & last_chain);
#line 2420
  nxt_chain = qla25xx_copy_mqueues(ha, nxt_chain, & last_chain);
#line 2421
  nxt_chain = qla2xxx_copy_atioqueues(ha, nxt_chain, & last_chain);
#line 2422
  if ((unsigned long )last_chain != (unsigned long )((uint32_t *)0U)) {
#line 2423
    (ha->fw_dump)->version = (ha->fw_dump)->version | 128U;
#line 2424
    *last_chain = *last_chain | 128U;
  } else {

  }
#line 2428
  ha->fw_dump_len = (uint32_t )((long )nxt_chain) - (uint32_t )((long )ha->fw_dump);
  qla83xx_fw_dump_failed_0: 
#line 2431
  qla2xxx_dump_post_process(base_vha, rval);
  qla83xx_fw_dump_failed: ;
#line 2434
  if (hardware_locked == 0) {
#line 2435
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
  } else {

  }
#line 2436
  return;
}
}
#line 2443 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
__inline static int ql_mask_match(uint32_t level ) 
{ 


  {
#line 2445
  if (ql2xextended_error_logging == 1) {
#line 2446
    ql2xextended_error_logging = 507510784;
  } else {

  }
#line 2447
  return ((level & (uint32_t )ql2xextended_error_logging) == level);
}
}
#line 2464 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
void ql_dbg(uint32_t level , scsi_qla_host_t *vha , int32_t id , char const   *fmt 
            , ...) 
{ 
  va_list va ;
  struct va_format vaf ;
  int tmp ;
  struct pci_dev  const  *pdev ;
  char const   *tmp___0 ;

  {
#line 2469
  tmp = ql_mask_match(level);
#line 2469
  if (tmp == 0) {
#line 2470
    return;
  } else {

  }
#line 2472
  ldv__builtin_va_start((va_list *)(& va));
#line 2474
  vaf.fmt = fmt;
#line 2475
  vaf.va = & va;
#line 2477
  if ((unsigned long )vha != (unsigned long )((scsi_qla_host_t *)0)) {
#line 2478
    pdev = (struct pci_dev  const  *)(vha->hw)->pdev;
#line 2480
    tmp___0 = dev_name(& pdev->dev);
#line 2480
    printk("\f%s [%s]-%04x:%ld: %pV", (char *)"qla2xxx", tmp___0, (uint32_t )id + ql_dbg_offset,
           vha->host_no, & vaf);
  } else {
#line 2484
    printk("\f%s [%s]-%04x: : %pV", (char *)"qla2xxx", (char *)"0000:00:00.0", (uint32_t )id + ql_dbg_offset,
           & vaf);
  }
#line 2488
  ldv__builtin_va_end((va_list *)(& va));
#line 2489
  return;
}
}
#line 2507 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
void ql_dbg_pci(uint32_t level , struct pci_dev *pdev , int32_t id , char const   *fmt 
                , ...) 
{ 
  va_list va ;
  struct va_format vaf ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 2513
  if ((unsigned long )pdev == (unsigned long )((struct pci_dev *)0)) {
#line 2514
    return;
  } else {

  }
#line 2515
  tmp = ql_mask_match(level);
#line 2515
  if (tmp == 0) {
#line 2516
    return;
  } else {

  }
#line 2518
  ldv__builtin_va_start((va_list *)(& va));
#line 2520
  vaf.fmt = fmt;
#line 2521
  vaf.va = & va;
#line 2524
  tmp___0 = dev_name((struct device  const  *)(& pdev->dev));
#line 2524
  printk("\f%s [%s]-%04x: : %pV", (char *)"qla2xxx", tmp___0, (uint32_t )id + ql_dbg_offset,
         & vaf);
#line 2527
  ldv__builtin_va_end((va_list *)(& va));
#line 2528
  return;
}
}
#line 2544 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
void ql_log(uint32_t level , scsi_qla_host_t *vha , int32_t id , char const   *fmt 
            , ...) 
{ 
  va_list va ;
  struct va_format vaf ;
  char pbuf[128U] ;
  struct pci_dev  const  *pdev ;
  char const   *tmp ;

  {
#line 2550
  if ((uint32_t )ql_errlev < level) {
#line 2551
    return;
  } else {

  }
#line 2553
  if ((unsigned long )vha != (unsigned long )((scsi_qla_host_t *)0)) {
#line 2554
    pdev = (struct pci_dev  const  *)(vha->hw)->pdev;
#line 2556
    tmp = dev_name(& pdev->dev);
#line 2556
    snprintf((char *)(& pbuf), 128UL, "%s [%s]-%04x:%ld: ", (char *)"qla2xxx", tmp,
             id, vha->host_no);
  } else {
#line 2559
    snprintf((char *)(& pbuf), 128UL, "%s [%s]-%04x: : ", (char *)"qla2xxx", (char *)"0000:00:00.0",
             id);
  }
#line 2562
  pbuf[127UL] = 0;
#line 2564
  ldv__builtin_va_start((va_list *)(& va));
#line 2566
  vaf.fmt = fmt;
#line 2567
  vaf.va = & va;
#line 2569
  switch (level) {
  case 0U: 
#line 2571
  printk("\n%s%pV", (char *)(& pbuf), & vaf);
#line 2572
  goto ldv_66230;
  case 1U: 
#line 2574
  printk("\v%s%pV", (char *)(& pbuf), & vaf);
#line 2575
  goto ldv_66230;
  case 2U: 
#line 2577
  printk("\f%s%pV", (char *)(& pbuf), & vaf);
#line 2578
  goto ldv_66230;
  default: 
#line 2580
  printk("\016%s%pV", (char *)(& pbuf), & vaf);
#line 2581
  goto ldv_66230;
  }
  ldv_66230: 
#line 2584
  ldv__builtin_va_end((va_list *)(& va));
#line 2585
  return;
}
}
#line 2602 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
void ql_log_pci(uint32_t level , struct pci_dev *pdev , int32_t id , char const   *fmt 
                , ...) 
{ 
  va_list va ;
  struct va_format vaf ;
  char pbuf[128U] ;
  char const   *tmp ;

  {
#line 2609
  if ((unsigned long )pdev == (unsigned long )((struct pci_dev *)0)) {
#line 2610
    return;
  } else {

  }
#line 2611
  if ((uint32_t )ql_errlev < level) {
#line 2612
    return;
  } else {

  }
#line 2615
  tmp = dev_name((struct device  const  *)(& pdev->dev));
#line 2615
  snprintf((char *)(& pbuf), 128UL, "%s [%s]-%04x: : ", (char *)"qla2xxx", tmp, id);
#line 2617
  pbuf[127UL] = 0;
#line 2619
  ldv__builtin_va_start((va_list *)(& va));
#line 2621
  vaf.fmt = fmt;
#line 2622
  vaf.va = & va;
#line 2624
  switch (level) {
  case 0U: 
#line 2626
  printk("\n%s%pV", (char *)(& pbuf), & vaf);
#line 2627
  goto ldv_66244;
  case 1U: 
#line 2629
  printk("\v%s%pV", (char *)(& pbuf), & vaf);
#line 2630
  goto ldv_66244;
  case 2U: 
#line 2632
  printk("\f%s%pV", (char *)(& pbuf), & vaf);
#line 2633
  goto ldv_66244;
  default: 
#line 2635
  printk("\016%s%pV", (char *)(& pbuf), & vaf);
#line 2636
  goto ldv_66244;
  }
  ldv_66244: 
#line 2639
  ldv__builtin_va_end((va_list *)(& va));
#line 2640
  return;
}
}
#line 2643 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
void ql_dump_regs(uint32_t level , scsi_qla_host_t *vha , int32_t id ) 
{ 
  int i ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  struct device_reg_24xx *reg24 ;
  struct device_reg_82xx *reg82 ;
  uint16_t *mbx_reg ;
  int tmp ;
  uint16_t *tmp___0 ;
  unsigned short tmp___1 ;

  {
#line 2646
  ha = vha->hw;
#line 2647
  reg = & (ha->iobase)->isp;
#line 2648
  reg24 = & (ha->iobase)->isp24;
#line 2649
  reg82 = & (ha->iobase)->isp82;
#line 2652
  tmp = ql_mask_match(level);
#line 2652
  if (tmp == 0) {
#line 2653
    return;
  } else {

  }
#line 2655
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 2656
    mbx_reg = (uint16_t *)(& reg82->mailbox_in);
  } else
#line 2657
  if ((ha->device_type & 134217728U) != 0U) {
#line 2658
    mbx_reg = & reg24->mailbox0;
  } else {
#line 2660
    mbx_reg = (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 : & reg->u.isp2300.mailbox0;
  }
#line 2662
  ql_dbg(level, vha, id, "Mailbox registers:\n");
#line 2663
  i = 0;
#line 2663
  goto ldv_66260;
  ldv_66259: 
#line 2664
  tmp___0 = mbx_reg;
#line 2664
  mbx_reg = mbx_reg + 1;
#line 2664
  tmp___1 = readw((void const volatile   *)tmp___0);
#line 2664
  ql_dbg(level, vha, id, "mbox[%d] 0x%04x\n", i, (int )tmp___1);
#line 2663
  i = i + 1;
  ldv_66260: ;
#line 2663
  if (i <= 5) {
#line 2665
    goto ldv_66259;
  } else {

  }

#line 2670
  return;
}
}
#line 2670 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.c"
void ql_dump_buffer(uint32_t level , scsi_qla_host_t *vha , int32_t id , uint8_t *b ,
                    uint32_t size ) 
{ 
  uint32_t cnt ;
  uint8_t c ;
  int tmp ;
  uint8_t *tmp___0 ;

  {
#line 2676
  tmp = ql_mask_match(level);
#line 2676
  if (tmp == 0) {
#line 2677
    return;
  } else {

  }
#line 2679
  ql_dbg(level, vha, id, " 0   1   2   3   4   5   6   7   8   9  Ah  Bh  Ch  Dh  Eh  Fh\n");
#line 2681
  ql_dbg(level, vha, id, "--------------------------------------------------------------\n");
#line 2684
  ql_dbg(level, vha, id, " ");
#line 2685
  cnt = 0U;
#line 2685
  goto ldv_66272;
  ldv_66271: 
#line 2686
  tmp___0 = b;
#line 2686
  b = b + 1;
#line 2686
  c = *tmp___0;
#line 2687
  printk("%02x", (unsigned int )c);
#line 2688
  cnt = cnt + 1U;
#line 2689
  if ((cnt & 15U) == 0U) {
#line 2690
    printk("\n");
  } else {
#line 2692
    printk("  ");
  }
  ldv_66272: ;
#line 2685
  if (cnt < size) {
#line 2687
    goto ldv_66271;
  } else {

  }

#line 2694
  if ((cnt & 15U) != 0U) {
#line 2695
    ql_dbg(level, vha, id, "\n");
  } else {

  }
#line 2696
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
int reg_timer_20(struct timer_list *timer ) 
{ 


  {
#line 489
  ldv_timer_list_20 = timer;
#line 490
  ldv_timer_state_20 = 1;
#line 491
  return (0);
}
}
#line 494 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
void disable_suitable_timer_20(struct timer_list *timer ) 
{ 


  {
#line 495
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_20) {
#line 496
    ldv_timer_state_20 = 0;
#line 497
    return;
  } else {

  }
#line 499
  return;
}
}
#line 502 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
void activate_pending_timer_20(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 502
  if ((unsigned long )ldv_timer_list_20 == (unsigned long )timer) {
#line 503
    if (ldv_timer_state_20 == 2 || pending_flag != 0) {
#line 504
      ldv_timer_list_20 = timer;
#line 505
      ldv_timer_list_20->data = data;
#line 506
      ldv_timer_state_20 = 1;
    } else {

    }
#line 508
    return;
  } else {

  }
#line 510
  reg_timer_20(timer);
#line 511
  ldv_timer_list_20->data = data;
#line 512
  return;
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
void choose_timer_20(struct timer_list *timer ) 
{ 


  {
#line 516
  LDV_IN_INTERRUPT = 2;
#line 517
  (*(timer->function))(timer->data);
#line 518
  LDV_IN_INTERRUPT = 1;
#line 519
  ldv_timer_state_20 = 2;
#line 520
  return;
}
}
#line 546 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
bool ldv_queue_work_on_145(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 550
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 550
  ldv_func_res = tmp;
#line 552
  activate_work_7(ldv_func_arg3, 2);
#line 554
  return (ldv_func_res);
}
}
#line 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
bool ldv_queue_delayed_work_on_146(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 561
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 561
  ldv_func_res = tmp;
#line 563
  activate_work_7(& ldv_func_arg3->work, 2);
#line 565
  return (ldv_func_res);
}
}
#line 568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
bool ldv_queue_work_on_147(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 572
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 572
  ldv_func_res = tmp;
#line 574
  activate_work_7(ldv_func_arg3, 2);
#line 576
  return (ldv_func_res);
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
void ldv_flush_workqueue_148(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 582
  flush_workqueue(ldv_func_arg1);
#line 584
  call_and_disable_all_7(2);
#line 585
  return;
}
}
#line 587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
bool ldv_queue_delayed_work_on_149(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 591
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 591
  ldv_func_res = tmp;
#line 593
  activate_work_7(& ldv_func_arg3->work, 2);
#line 595
  return (ldv_func_res);
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
int ldv_scsi_add_host_with_dma_150(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 602
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 602
  ldv_func_res = tmp;
#line 604
  if (ldv_func_res == 0) {
#line 605
    ldv_state_variable_88 = 1;
#line 605
    ldv_initialize_scsi_host_template_88();
  } else {

  }
#line 609
  return (ldv_func_res);
}
}
#line 177 "include/linux/kernel.h"
extern void ___might_sleep(char const   * , int  , int  ) ;
#line 409
extern int scnprintf(char * , size_t  , char const   *  , ...) ;
#line 41 "include/linux/string.h"
extern int strncmp(char const   * , char const   * , __kernel_size_t  ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_161(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_163(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_162(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_165(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_164(struct workqueue_struct *ldv_func_arg1 ) ;
#line 321 "./arch/x86/include/asm/io.h"
__inline static void outw(unsigned short value , int port ) 
{ 


  {
#line 321
  __asm__  volatile   ("outw %w0, %w1": : "a" (value), "Nd" (port));
#line 322
  return;
}
}
#line 321 "./arch/x86/include/asm/io.h"
__inline static unsigned short inw(int port ) 
{ 
  unsigned short value ;

  {
#line 321
  __asm__  volatile   ("inw %w1, %w0": "=a" (value): "Nd" (port));
#line 321
  return (value);
}
}
#line 2879 "include/linux/sched.h"
extern int _cond_resched(void) ;
#line 474 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
void choose_timer_21(struct timer_list *timer ) ;
#line 795 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_166(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
#line 827
extern void scsi_unblock_requests(struct Scsi_Host * ) ;
#line 828
extern void scsi_block_requests(struct Scsi_Host * ) ;
#line 856 "include/scsi/scsi_transport_fc.h"
extern struct fc_vport *fc_vport_create(struct Scsi_Host * , int  , struct fc_vport_identifiers * ) ;
#line 584 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int qla24xx_fcp_prio_cfg_valid(scsi_qla_host_t *vha , struct qla_fcp_prio_cfg *pri_cfg ,
                               uint8_t flag ) ;
#line 23 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static void qla2x00_lock_nvram_access(struct qla_hw_data *ha ) 
{ 
  uint16_t data ;
  struct device_reg_2xxx *reg ;

  {
#line 26
  reg = & (ha->iobase)->isp;
#line 28
  if (((ha->device_type & 1U) == 0U && (ha->device_type & 2U) == 0U) && (ha->device_type & 4U) == 0U) {
#line 29
    data = readw((void const volatile   *)(& reg->nvram));
#line 30
    goto ldv_65910;
    ldv_65909: 
#line 31
    __const_udelay(429500UL);
#line 32
    data = readw((void const volatile   *)(& reg->nvram));
    ldv_65910: ;
#line 30
    if ((int )((short )data) < 0) {
#line 32
      goto ldv_65909;
    } else {

    }
#line 36
    writew(1, (void volatile   *)(& reg->u.isp2300.host_semaphore));
#line 37
    readw((void const volatile   *)(& reg->u.isp2300.host_semaphore));
#line 38
    __const_udelay(21475UL);
#line 39
    data = readw((void const volatile   *)(& reg->u.isp2300.host_semaphore));
#line 40
    goto ldv_65913;
    ldv_65912: 
#line 42
    __const_udelay(429500UL);
#line 43
    writew(1, (void volatile   *)(& reg->u.isp2300.host_semaphore));
#line 44
    readw((void const volatile   *)(& reg->u.isp2300.host_semaphore));
#line 45
    __const_udelay(21475UL);
#line 46
    data = readw((void const volatile   *)(& reg->u.isp2300.host_semaphore));
    ldv_65913: ;
#line 40
    if (((int )data & 1) == 0) {
#line 42
      goto ldv_65912;
    } else {

    }

  } else {

  }
#line 48
  return;
}
}
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static void qla2x00_unlock_nvram_access(struct qla_hw_data *ha ) 
{ 
  struct device_reg_2xxx *reg ;

  {
#line 58
  reg = & (ha->iobase)->isp;
#line 60
  if (((ha->device_type & 1U) == 0U && (ha->device_type & 2U) == 0U) && (ha->device_type & 4U) == 0U) {
#line 61
    writew(0, (void volatile   *)(& reg->u.isp2300.host_semaphore));
#line 62
    readw((void const volatile   *)(& reg->u.isp2300.host_semaphore));
  } else {

  }
#line 64
  return;
}
}
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static void qla2x00_nv_write(struct qla_hw_data *ha , uint16_t data ) 
{ 
  struct device_reg_2xxx *reg ;

  {
#line 74
  reg = & (ha->iobase)->isp;
#line 76
  writew((int )((unsigned int )data | 16386U), (void volatile   *)(& reg->nvram));
#line 77
  readw((void const volatile   *)(& reg->nvram));
#line 78
  __const_udelay(42950UL);
#line 79
  writew((int )((unsigned int )data | 16387U), (void volatile   *)(& reg->nvram));
#line 81
  readw((void const volatile   *)(& reg->nvram));
#line 82
  __const_udelay(42950UL);
#line 83
  writew((int )((unsigned int )data | 16386U), (void volatile   *)(& reg->nvram));
#line 84
  readw((void const volatile   *)(& reg->nvram));
#line 85
  __const_udelay(42950UL);
#line 87
  return;
}
}
#line 104 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static uint16_t qla2x00_nvram_request(struct qla_hw_data *ha , uint32_t nv_cmd ) 
{ 
  uint8_t cnt ;
  struct device_reg_2xxx *reg ;
  uint16_t data ;
  uint16_t reg_data ;

  {
#line 107
  reg = & (ha->iobase)->isp;
#line 108
  data = 0U;
#line 112
  nv_cmd = nv_cmd << 5;
#line 113
  cnt = 0U;
#line 113
  goto ldv_65933;
  ldv_65932: ;
#line 114
  if ((int )nv_cmd < 0) {
#line 115
    qla2x00_nv_write(ha, 4);
  } else {
#line 117
    qla2x00_nv_write(ha, 0);
  }
#line 118
  nv_cmd = nv_cmd << 1;
#line 113
  cnt = (uint8_t )((int )cnt + 1);
  ldv_65933: ;
#line 113
  if ((unsigned int )cnt <= 10U) {
#line 115
    goto ldv_65932;
  } else {

  }
#line 122
  cnt = 0U;
#line 122
  goto ldv_65936;
  ldv_65935: 
#line 123
  writew(3, (void volatile   *)(& reg->nvram));
#line 124
  readw((void const volatile   *)(& reg->nvram));
#line 125
  __const_udelay(42950UL);
#line 126
  data = (int )data << 1U;
#line 127
  reg_data = readw((void const volatile   *)(& reg->nvram));
#line 128
  if (((int )reg_data & 8) != 0) {
#line 129
    data = (uint16_t )((unsigned int )data | 1U);
  } else {

  }
#line 130
  writew(2, (void volatile   *)(& reg->nvram));
#line 131
  readw((void const volatile   *)(& reg->nvram));
#line 132
  __const_udelay(42950UL);
#line 122
  cnt = (uint8_t )((int )cnt + 1);
  ldv_65936: ;
#line 122
  if ((unsigned int )cnt <= 15U) {
#line 124
    goto ldv_65935;
  } else {

  }
#line 136
  writew(0, (void volatile   *)(& reg->nvram));
#line 137
  readw((void const volatile   *)(& reg->nvram));
#line 138
  __const_udelay(42950UL);
#line 140
  return (data);
}
}
#line 153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static uint16_t qla2x00_get_nvram_word(struct qla_hw_data *ha , uint32_t addr ) 
{ 
  uint16_t data ;
  uint32_t nv_cmd ;

  {
#line 158
  nv_cmd = addr << 16;
#line 159
  nv_cmd = nv_cmd | 100663296U;
#line 160
  data = qla2x00_nvram_request(ha, nv_cmd);
#line 162
  return (data);
}
}
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static void qla2x00_nv_deselect(struct qla_hw_data *ha ) 
{ 
  struct device_reg_2xxx *reg ;

  {
#line 172
  reg = & (ha->iobase)->isp;
#line 174
  writew(0, (void volatile   *)(& reg->nvram));
#line 175
  readw((void const volatile   *)(& reg->nvram));
#line 176
  __const_udelay(42950UL);
#line 178
  return;
}
}
#line 186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static void qla2x00_write_nvram_word(struct qla_hw_data *ha , uint32_t addr , uint16_t data ) 
{ 
  int count ;
  uint16_t word ;
  uint32_t nv_cmd ;
  uint32_t wait_cnt ;
  struct device_reg_2xxx *reg ;
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 191
  reg = & (ha->iobase)->isp;
#line 192
  tmp = pci_get_drvdata(ha->pdev);
#line 192
  vha = (scsi_qla_host_t *)tmp;
#line 194
  qla2x00_nv_write(ha, 4);
#line 195
  qla2x00_nv_write(ha, 0);
#line 196
  qla2x00_nv_write(ha, 0);
#line 198
  word = 0U;
#line 198
  goto ldv_65960;
  ldv_65959: 
#line 199
  qla2x00_nv_write(ha, 4);
#line 198
  word = (uint16_t )((int )word + 1);
  ldv_65960: ;
#line 198
  if ((unsigned int )word <= 7U) {
#line 200
    goto ldv_65959;
  } else {

  }
#line 201
  qla2x00_nv_deselect(ha);
#line 204
  nv_cmd = (addr << 16) | 83886080U;
#line 205
  nv_cmd = (uint32_t )data | nv_cmd;
#line 206
  nv_cmd = nv_cmd << 5;
#line 207
  count = 0;
#line 207
  goto ldv_65963;
  ldv_65962: ;
#line 208
  if ((int )nv_cmd < 0) {
#line 209
    qla2x00_nv_write(ha, 4);
  } else {
#line 211
    qla2x00_nv_write(ha, 0);
  }
#line 213
  nv_cmd = nv_cmd << 1;
#line 207
  count = count + 1;
  ldv_65963: ;
#line 207
  if (count <= 26) {
#line 209
    goto ldv_65962;
  } else {

  }
#line 216
  qla2x00_nv_deselect(ha);
#line 219
  writew(2, (void volatile   *)(& reg->nvram));
#line 220
  readw((void const volatile   *)(& reg->nvram));
#line 221
  wait_cnt = 20000U;
  ldv_65966: 
#line 223
  wait_cnt = wait_cnt - 1U;
#line 223
  if (wait_cnt == 0U) {
#line 224
    ql_dbg(8388608U, vha, 28813, "NVRAM didn\'t go ready...\n");
#line 226
    goto ldv_65965;
  } else {

  }
#line 228
  __const_udelay(42950UL);
#line 229
  word = readw((void const volatile   *)(& reg->nvram));
#line 230
  if (((int )word & 8) == 0) {
#line 232
    goto ldv_65966;
  } else {

  }
  ldv_65965: 
#line 232
  qla2x00_nv_deselect(ha);
#line 235
  qla2x00_nv_write(ha, 4);
#line 236
  count = 0;
#line 236
  goto ldv_65968;
  ldv_65967: 
#line 237
  qla2x00_nv_write(ha, 0);
#line 236
  count = count + 1;
  ldv_65968: ;
#line 236
  if (count <= 9) {
#line 238
    goto ldv_65967;
  } else {

  }
#line 239
  qla2x00_nv_deselect(ha);
#line 240
  return;
}
}
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static int qla2x00_write_nvram_word_tmo(struct qla_hw_data *ha , uint32_t addr , uint16_t data ,
                                        uint32_t tmo ) 
{ 
  int ret ;
  int count ;
  uint16_t word ;
  uint32_t nv_cmd ;
  struct device_reg_2xxx *reg ;

  {
#line 249
  reg = & (ha->iobase)->isp;
#line 251
  ret = 0;
#line 253
  qla2x00_nv_write(ha, 4);
#line 254
  qla2x00_nv_write(ha, 0);
#line 255
  qla2x00_nv_write(ha, 0);
#line 257
  word = 0U;
#line 257
  goto ldv_65982;
  ldv_65981: 
#line 258
  qla2x00_nv_write(ha, 4);
#line 257
  word = (uint16_t )((int )word + 1);
  ldv_65982: ;
#line 257
  if ((unsigned int )word <= 7U) {
#line 259
    goto ldv_65981;
  } else {

  }
#line 260
  qla2x00_nv_deselect(ha);
#line 263
  nv_cmd = (addr << 16) | 83886080U;
#line 264
  nv_cmd = (uint32_t )data | nv_cmd;
#line 265
  nv_cmd = nv_cmd << 5;
#line 266
  count = 0;
#line 266
  goto ldv_65985;
  ldv_65984: ;
#line 267
  if ((int )nv_cmd < 0) {
#line 268
    qla2x00_nv_write(ha, 4);
  } else {
#line 270
    qla2x00_nv_write(ha, 0);
  }
#line 272
  nv_cmd = nv_cmd << 1;
#line 266
  count = count + 1;
  ldv_65985: ;
#line 266
  if (count <= 26) {
#line 268
    goto ldv_65984;
  } else {

  }
#line 275
  qla2x00_nv_deselect(ha);
#line 278
  writew(2, (void volatile   *)(& reg->nvram));
#line 279
  readw((void const volatile   *)(& reg->nvram));
  ldv_65988: 
#line 281
  __const_udelay(42950UL);
#line 282
  word = readw((void const volatile   *)(& reg->nvram));
#line 283
  tmo = tmo - 1U;
#line 283
  if (tmo == 0U) {
#line 284
    ret = 258;
#line 285
    goto ldv_65987;
  } else {

  }
#line 287
  if (((int )word & 8) == 0) {
#line 289
    goto ldv_65988;
  } else {

  }
  ldv_65987: 
#line 289
  qla2x00_nv_deselect(ha);
#line 292
  qla2x00_nv_write(ha, 4);
#line 293
  count = 0;
#line 293
  goto ldv_65990;
  ldv_65989: 
#line 294
  qla2x00_nv_write(ha, 0);
#line 293
  count = count + 1;
  ldv_65990: ;
#line 293
  if (count <= 9) {
#line 295
    goto ldv_65989;
  } else {

  }
#line 296
  qla2x00_nv_deselect(ha);
#line 298
  return (ret);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static int qla2x00_clear_nvram_protection(struct qla_hw_data *ha ) 
{ 
  int ret ;
  int stat ;
  struct device_reg_2xxx *reg ;
  uint32_t word ;
  uint32_t wait_cnt ;
  uint16_t wprot ;
  uint16_t wprot_old ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  unsigned short tmp___0 ;

  {
#line 309
  reg = & (ha->iobase)->isp;
#line 312
  tmp = pci_get_drvdata(ha->pdev);
#line 312
  vha = (scsi_qla_host_t *)tmp;
#line 315
  ret = 258;
#line 317
  wprot_old = qla2x00_get_nvram_word(ha, (uint32_t )ha->nvram_base);
#line 318
  stat = qla2x00_write_nvram_word_tmo(ha, (uint32_t )ha->nvram_base, 4660, 100000U);
#line 320
  wprot = qla2x00_get_nvram_word(ha, (uint32_t )ha->nvram_base);
#line 321
  if (stat != 0 || (unsigned int )wprot != 4660U) {
#line 323
    qla2x00_nv_write(ha, 4);
#line 324
    qla2x00_nv_write(ha, 0);
#line 325
    qla2x00_nv_write(ha, 0);
#line 326
    word = 0U;
#line 326
    goto ldv_66004;
    ldv_66003: 
#line 327
    qla2x00_nv_write(ha, 4);
#line 326
    word = word + 1U;
    ldv_66004: ;
#line 326
    if (word <= 7U) {
#line 328
      goto ldv_66003;
    } else {

    }
#line 329
    qla2x00_nv_deselect(ha);
#line 332
    qla2x00_nv_write(ha, 8196);
#line 333
    qla2x00_nv_write(ha, 8192);
#line 334
    qla2x00_nv_write(ha, 8192);
#line 335
    word = 0U;
#line 335
    goto ldv_66007;
    ldv_66006: 
#line 336
    qla2x00_nv_write(ha, 8196);
#line 335
    word = word + 1U;
    ldv_66007: ;
#line 335
    if (word <= 7U) {
#line 337
      goto ldv_66006;
    } else {

    }
#line 338
    qla2x00_nv_deselect(ha);
#line 341
    qla2x00_nv_write(ha, 8196);
#line 342
    qla2x00_nv_write(ha, 8196);
#line 343
    qla2x00_nv_write(ha, 8196);
#line 344
    word = 0U;
#line 344
    goto ldv_66010;
    ldv_66009: 
#line 345
    qla2x00_nv_write(ha, 8196);
#line 344
    word = word + 1U;
    ldv_66010: ;
#line 344
    if (word <= 7U) {
#line 346
      goto ldv_66009;
    } else {

    }
#line 347
    qla2x00_nv_deselect(ha);
#line 350
    writew(2, (void volatile   *)(& reg->nvram));
#line 351
    readw((void const volatile   *)(& reg->nvram));
#line 352
    wait_cnt = 20000U;
    ldv_66013: 
#line 354
    wait_cnt = wait_cnt - 1U;
#line 354
    if (wait_cnt == 0U) {
#line 355
      ql_dbg(8388608U, vha, 28814, "NVRAM didn\'t go ready...\n");
#line 357
      goto ldv_66012;
    } else {

    }
#line 359
    __const_udelay(42950UL);
#line 360
    tmp___0 = readw((void const volatile   *)(& reg->nvram));
#line 360
    word = (uint32_t )tmp___0;
#line 361
    if ((word & 8U) == 0U) {
#line 363
      goto ldv_66013;
    } else {

    }
    ldv_66012: ;
#line 363
    if (wait_cnt != 0U) {
#line 364
      ret = 0;
    } else {

    }
  } else {
#line 366
    qla2x00_write_nvram_word(ha, (uint32_t )ha->nvram_base, (int )wprot_old);
  }
#line 368
  return (ret);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static void qla2x00_set_nvram_protection(struct qla_hw_data *ha , int stat ) 
{ 
  struct device_reg_2xxx *reg ;
  uint32_t word ;
  uint32_t wait_cnt ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  unsigned short tmp___0 ;

  {
#line 374
  reg = & (ha->iobase)->isp;
#line 376
  tmp = pci_get_drvdata(ha->pdev);
#line 376
  vha = (scsi_qla_host_t *)tmp;
#line 378
  if (stat != 0) {
#line 379
    return;
  } else {

  }
#line 383
  qla2x00_nv_write(ha, 4);
#line 384
  qla2x00_nv_write(ha, 0);
#line 385
  qla2x00_nv_write(ha, 0);
#line 386
  word = 0U;
#line 386
  goto ldv_66023;
  ldv_66022: 
#line 387
  qla2x00_nv_write(ha, 4);
#line 386
  word = word + 1U;
  ldv_66023: ;
#line 386
  if (word <= 7U) {
#line 388
    goto ldv_66022;
  } else {

  }
#line 389
  qla2x00_nv_deselect(ha);
#line 392
  qla2x00_nv_write(ha, 8196);
#line 393
  qla2x00_nv_write(ha, 8192);
#line 394
  qla2x00_nv_write(ha, 8192);
#line 395
  word = 0U;
#line 395
  goto ldv_66026;
  ldv_66025: 
#line 396
  qla2x00_nv_write(ha, 8196);
#line 395
  word = word + 1U;
  ldv_66026: ;
#line 395
  if (word <= 7U) {
#line 397
    goto ldv_66025;
  } else {

  }
#line 398
  qla2x00_nv_deselect(ha);
#line 401
  qla2x00_nv_write(ha, 8196);
#line 402
  qla2x00_nv_write(ha, 8192);
#line 403
  qla2x00_nv_write(ha, 8196);
#line 404
  word = 0U;
#line 404
  goto ldv_66029;
  ldv_66028: 
#line 405
  qla2x00_nv_write(ha, 8192);
#line 404
  word = word + 1U;
  ldv_66029: ;
#line 404
  if (word <= 7U) {
#line 406
    goto ldv_66028;
  } else {

  }
#line 407
  qla2x00_nv_deselect(ha);
#line 410
  writew(2, (void volatile   *)(& reg->nvram));
#line 411
  readw((void const volatile   *)(& reg->nvram));
#line 412
  wait_cnt = 20000U;
  ldv_66032: 
#line 414
  wait_cnt = wait_cnt - 1U;
#line 414
  if (wait_cnt == 0U) {
#line 415
    ql_dbg(8388608U, vha, 28815, "NVRAM didn\'t go ready...\n");
#line 417
    goto ldv_66031;
  } else {

  }
#line 419
  __const_udelay(42950UL);
#line 420
  tmp___0 = readw((void const volatile   *)(& reg->nvram));
#line 420
  word = (uint32_t )tmp___0;
#line 421
  if ((word & 8U) == 0U) {
#line 423
    goto ldv_66032;
  } else {

  }
  ldv_66031: ;
#line 428
  return;
}
}
#line 430 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
__inline static uint32_t flash_conf_addr(struct qla_hw_data *ha , uint32_t faddr ) 
{ 


  {
#line 432
  return (ha->flash_conf_off | faddr);
}
}
#line 436 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
__inline static uint32_t flash_data_addr(struct qla_hw_data *ha , uint32_t faddr ) 
{ 


  {
#line 438
  return (ha->flash_data_off | faddr);
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
__inline static uint32_t nvram_conf_addr(struct qla_hw_data *ha , uint32_t naddr ) 
{ 


  {
#line 444
  return (ha->nvram_conf_off | naddr);
}
}
#line 448 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
__inline static uint32_t nvram_data_addr(struct qla_hw_data *ha , uint32_t naddr ) 
{ 


  {
#line 450
  return (ha->nvram_data_off | naddr);
}
}
#line 454 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static uint32_t qla24xx_read_flash_dword(struct qla_hw_data *ha , uint32_t addr ) 
{ 
  int rval ;
  uint32_t cnt ;
  uint32_t data ;
  struct device_reg_24xx *reg ;
  unsigned int tmp ;

  {
#line 458
  reg = & (ha->iobase)->isp24;
#line 460
  writel(addr & 2147483647U, (void volatile   *)(& reg->flash_addr));
#line 462
  rval = 0;
#line 463
  cnt = 3000U;
#line 463
  goto ldv_66059;
  ldv_66058: ;
#line 466
  if (cnt != 0U) {
#line 467
    __const_udelay(42950UL);
  } else {
#line 469
    rval = 256;
  }
#line 470
  ___might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c",
                 470, 0);
#line 470
  _cond_resched();
#line 465
  cnt = cnt - 1U;
  ldv_66059: 
#line 463
  tmp = readl((void const volatile   *)(& reg->flash_addr));
#line 463
  if ((int )tmp >= 0 && rval == 0) {
#line 467
    goto ldv_66058;
  } else {

  }
#line 474
  data = 3735936685U;
#line 475
  if (rval == 0) {
#line 476
    data = readl((void const volatile   *)(& reg->flash_data));
  } else {

  }
#line 478
  return (data);
}
}
#line 482 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
uint32_t *qla24xx_read_flash_data(scsi_qla_host_t *vha , uint32_t *dwptr , uint32_t faddr ,
                                  uint32_t dwords ) 
{ 
  uint32_t i ;
  struct qla_hw_data *ha ;
  uint32_t tmp ;

  {
#line 486
  ha = vha->hw;
#line 489
  i = 0U;
#line 489
  goto ldv_66070;
  ldv_66069: 
#line 490
  tmp = flash_data_addr(ha, faddr);
#line 490
  *(dwptr + (unsigned long )i) = qla24xx_read_flash_dword(ha, tmp);
#line 489
  i = i + 1U;
#line 489
  faddr = faddr + 1U;
  ldv_66070: ;
#line 489
  if (i < dwords) {
#line 491
    goto ldv_66069;
  } else {

  }

#line 493
  return (dwptr);
}
}
#line 497 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static int qla24xx_write_flash_dword(struct qla_hw_data *ha , uint32_t addr , uint32_t data ) 
{ 
  int rval ;
  uint32_t cnt ;
  struct device_reg_24xx *reg ;
  unsigned int tmp ;

  {
#line 501
  reg = & (ha->iobase)->isp24;
#line 503
  writel(data, (void volatile   *)(& reg->flash_data));
#line 504
  readl((void const volatile   *)(& reg->flash_data));
#line 505
  writel(addr | 2147483648U, (void volatile   *)(& reg->flash_addr));
#line 507
  rval = 0;
#line 508
  cnt = 500000U;
#line 508
  goto ldv_66082;
  ldv_66081: ;
#line 510
  if (cnt != 0U) {
#line 511
    __const_udelay(42950UL);
  } else {
#line 513
    rval = 256;
  }
#line 514
  ___might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c",
                 514, 0);
#line 514
  _cond_resched();
#line 509
  cnt = cnt - 1U;
  ldv_66082: 
#line 508
  tmp = readl((void const volatile   *)(& reg->flash_addr));
#line 508
  if ((int )tmp < 0 && rval == 0) {
#line 511
    goto ldv_66081;
  } else {

  }

#line 516
  return (rval);
}
}
#line 520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static void qla24xx_get_flash_manufacturer(struct qla_hw_data *ha , uint8_t *man_id ,
                                           uint8_t *flash_id ) 
{ 
  uint32_t ids ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 525
  tmp = flash_conf_addr(ha, 939U);
#line 525
  ids = qla24xx_read_flash_dword(ha, tmp);
#line 526
  *man_id = (unsigned char )ids;
#line 527
  *flash_id = (unsigned char )((int )((unsigned short )ids) >> 8);
#line 530
  if (ids != 3735936685U && ((unsigned int )*man_id == 0U || (unsigned int )*flash_id == 0U)) {
#line 537
    tmp___0 = flash_conf_addr(ha, 159U);
#line 537
    ids = qla24xx_read_flash_dword(ha, tmp___0);
#line 538
    *man_id = (unsigned char )ids;
#line 539
    *flash_id = (unsigned char )((int )((unsigned short )ids) >> 8);
  } else {

  }
#line 541
  return;
}
}
#line 544 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static int qla2xxx_find_flt_start(scsi_qla_host_t *vha , uint32_t *start ) 
{ 
  char const   *loc ;
  char const   *locations[2U] ;
  uint32_t pcihdr ;
  uint32_t pcids ;
  uint32_t *dcode ;
  uint8_t *buf ;
  uint8_t *bcode ;
  uint8_t last_image ;
  uint16_t cnt ;
  uint16_t chksum ;
  uint16_t *wptr ;
  struct qla_flt_location *fltl ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  uint16_t *tmp ;

  {
#line 546
  locations[0] = "DEF";
#line 546
  locations[1] = "PCI";
#line 552
  ha = vha->hw;
#line 553
  req = *(ha->req_q_map);
#line 560
  loc = locations[0];
#line 561
  *start = 0U;
#line 562
  if ((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || ((ha->device_type & 512U) != 0U || (ha->device_type & 1024U) != 0U)) || (ha->device_type & 4096U) != 0U) {
#line 563
    *start = 70656U;
  } else
#line 564
  if ((ha->device_type & 2048U) != 0U) {
#line 565
    *start = 328704U;
  } else
#line 566
  if ((ha->device_type & 8192U) != 0U) {
#line 567
    *start = 885760U;
  } else
#line 568
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 569
    *start = 1033216U;
#line 570
    goto end;
  } else
#line 571
  if (((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 572
    *start = 1033216U;
#line 573
    goto end;
  } else {

  }
#line 576
  buf = (uint8_t *)req->ring;
#line 577
  dcode = (uint32_t *)req->ring;
#line 578
  pcihdr = 0U;
#line 579
  last_image = 1U;
  ldv_66109: 
#line 582
  qla24xx_read_flash_data(vha, dcode, pcihdr >> 2, 32U);
#line 583
  bcode = buf + ((unsigned long )pcihdr & 3UL);
#line 584
  if ((unsigned int )*bcode != 85U || (unsigned int )*(bcode + 1UL) != 170U) {
#line 585
    goto end;
  } else {

  }
#line 588
  pcids = (uint32_t )(((int )*(bcode + 25UL) << 8) | (int )*(bcode + 24UL)) + pcihdr;
#line 589
  qla24xx_read_flash_data(vha, dcode, pcids >> 2, 32U);
#line 590
  bcode = buf + ((unsigned long )pcihdr & 3UL);
#line 593
  if ((((unsigned int )*bcode != 80U || (unsigned int )*(bcode + 1UL) != 67U) || (unsigned int )*(bcode + 2UL) != 73U) || (unsigned int )*(bcode + 3UL) != 82U) {
#line 595
    goto end;
  } else {

  }
#line 597
  last_image = (unsigned int )*(bcode + 21UL) & 128U;
#line 600
  pcihdr = (uint32_t )((((int )*(bcode + 17UL) << 8) | (int )*(bcode + 16UL)) * 512) + pcihdr;
#line 601
  if ((unsigned int )last_image == 0U) {
#line 603
    goto ldv_66109;
  } else {

  }
#line 604
  fltl = (struct qla_flt_location *)req->ring;
#line 605
  qla24xx_read_flash_data(vha, dcode, pcihdr >> 2, 4U);
#line 607
  if ((((unsigned int )fltl->sig[0] != 81U || (unsigned int )fltl->sig[1] != 70U) || (unsigned int )fltl->sig[2] != 76U) || (unsigned int )fltl->sig[3] != 84U) {
#line 609
    goto end;
  } else {

  }
#line 611
  wptr = (uint16_t *)req->ring;
#line 612
  cnt = 8U;
#line 613
  chksum = 0U;
#line 613
  goto ldv_66112;
  ldv_66111: 
#line 614
  tmp = wptr;
#line 614
  wptr = wptr + 1;
#line 614
  chksum = (int )*tmp + (int )chksum;
#line 613
  cnt = (uint16_t )((int )cnt - 1);
  ldv_66112: ;
#line 613
  if ((unsigned int )cnt != 0U) {
#line 615
    goto ldv_66111;
  } else {

  }

#line 615
  if ((unsigned int )chksum != 0U) {
#line 616
    ql_log(0U, vha, 69, "Inconsistent FLTL detected: checksum=0x%x.\n", (int )chksum);
#line 618
    ql_dump_buffer(1073872896U, vha, 270, buf, 16U);
#line 620
    return (258);
  } else {

  }
#line 624
  loc = locations[1];
#line 625
  *start = (uint32_t )((((int )fltl->start_hi << 16) | (int )fltl->start_lo) >> 2);
  end: 
#line 628
  ql_dbg(1073741824U, vha, 70, "FLTL[%s] = 0x%x.\n", loc, *start);
#line 631
  return (0);
}
}
#line 635 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static void qla2xxx_get_flt_info(scsi_qla_host_t *vha , uint32_t flt_addr ) 
{ 
  char const   *loc ;
  char const   *locations[2U] ;
  uint32_t def_fw[3U] ;
  uint32_t def_boot[3U] ;
  uint32_t def_vpd_nvram[3U] ;
  uint32_t def_vpd0[3U] ;
  uint32_t def_vpd1[3U] ;
  uint32_t def_nvram0[3U] ;
  uint32_t def_nvram1[3U] ;
  uint32_t def_fdt[3U] ;
  uint32_t def_npiv_conf0[3U] ;
  uint32_t def_npiv_conf1[3U] ;
  uint32_t fcp_prio_cfg0[3U] ;
  uint32_t fcp_prio_cfg1[3U] ;
  uint32_t def ;
  uint16_t *wptr ;
  uint16_t cnt ;
  uint16_t chksum ;
  uint32_t start ;
  struct qla_flt_header *flt ;
  struct qla_flt_region *region ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  uint16_t *tmp ;

  {
#line 637
  locations[0] = "DEF";
#line 637
  locations[1] = "FLT";
#line 638
  def_fw[0] = 131072U;
#line 638
  def_fw[1] = 131072U;
#line 638
  def_fw[2] = 655360U;
#line 640
  def_boot[0] = 0U;
#line 640
  def_boot[1] = 0U;
#line 640
  def_boot[2] = 524288U;
#line 642
  def_vpd_nvram[0] = 294912U;
#line 642
  def_vpd_nvram[1] = 294912U;
#line 642
  def_vpd_nvram[2] = 851968U;
#line 644
  def_vpd0[0] = 0U;
#line 644
  def_vpd0[1] = 0U;
#line 644
  def_vpd0[2] = 851968U;
#line 646
  def_vpd1[0] = 0U;
#line 646
  def_vpd1[1] = 0U;
#line 646
  def_vpd1[2] = 852992U;
#line 648
  def_nvram0[0] = 0U;
#line 648
  def_nvram0[1] = 0U;
#line 648
  def_nvram0[2] = 852096U;
#line 650
  def_nvram1[0] = 0U;
#line 650
  def_nvram1[1] = 0U;
#line 650
  def_nvram1[2] = 852352U;
#line 652
  def_fdt[0] = 69632U;
#line 652
  def_fdt[1] = 327680U;
#line 652
  def_fdt[2] = 884736U;
#line 655
  def_npiv_conf0[0] = 90112U;
#line 655
  def_npiv_conf0[1] = 376832U;
#line 655
  def_npiv_conf0[2] = 856064U;
#line 658
  def_npiv_conf1[0] = 94208U;
#line 658
  def_npiv_conf1[1] = 380928U;
#line 658
  def_npiv_conf1[2] = 860160U;
#line 661
  fcp_prio_cfg0[0] = 65536U;
#line 661
  fcp_prio_cfg0[1] = 245760U;
#line 661
  fcp_prio_cfg0[2] = 0U;
#line 664
  fcp_prio_cfg1[0] = 73728U;
#line 664
  fcp_prio_cfg1[1] = 253952U;
#line 664
  fcp_prio_cfg1[2] = 0U;
#line 673
  ha = vha->hw;
#line 674
  req = *(ha->req_q_map);
#line 676
  def = 0U;
#line 677
  if ((ha->device_type & 2048U) != 0U) {
#line 678
    def = 1U;
  } else
#line 679
  if ((ha->device_type & 8192U) != 0U) {
#line 680
    def = 2U;
  } else {

  }
#line 685
  ha->flt_region_fcp_prio = (unsigned int )ha->port_no == 0U ? fcp_prio_cfg0[def] : fcp_prio_cfg1[def];
#line 688
  ha->flt_region_flt = flt_addr;
#line 689
  wptr = (uint16_t *)req->ring;
#line 690
  flt = (struct qla_flt_header *)req->ring;
#line 691
  region = (struct qla_flt_region *)flt + 1U;
#line 692
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)req->ring, flt_addr << 2, 4096U);
#line 694
  if ((unsigned int )*wptr == 65535U) {
#line 695
    goto no_flash_data;
  } else {

  }
#line 696
  if ((unsigned int )flt->version != 1U) {
#line 697
    ql_log(1U, vha, 71, "Unsupported FLT detected: version=0x%x length=0x%x checksum=0x%x.\n",
           (int )flt->version, (int )flt->length, (int )flt->checksum);
#line 701
    goto no_flash_data;
  } else {

  }
#line 704
  cnt = (uint16_t )(((unsigned long )flt->length + 8UL) >> 1);
#line 705
  chksum = 0U;
#line 705
  goto ldv_66143;
  ldv_66142: 
#line 706
  tmp = wptr;
#line 706
  wptr = wptr + 1;
#line 706
  chksum = (int )*tmp + (int )chksum;
#line 705
  cnt = (uint16_t )((int )cnt - 1);
  ldv_66143: ;
#line 705
  if ((unsigned int )cnt != 0U) {
#line 707
    goto ldv_66142;
  } else {

  }

#line 707
  if ((unsigned int )chksum != 0U) {
#line 708
    ql_log(0U, vha, 72, "Inconsistent FLT detected: version=0x%x length=0x%x checksum=0x%x.\n",
           (int )flt->version, (int )flt->length, (int )flt->checksum);
#line 712
    goto no_flash_data;
  } else {

  }
#line 715
  loc = locations[1];
#line 716
  cnt = (uint16_t )((unsigned int )flt->length / 16U);
#line 717
  goto ldv_66173;
  ldv_66172: 
#line 719
  start = region->start >> 2;
#line 720
  ql_dbg(1073741824U, vha, 73, "FLT[%02x]: start=0x%x end=0x%x size=0x%x.\n", region->code & 255U,
         start, region->end >> 2, region->size);
#line 726
  switch (region->code & 255U) {
  case 164U: ;
#line 728
  if ((ha->device_type & 65536U) == 0U) {
#line 729
    goto ldv_66146;
  } else {

  }
#line 730
  ha->flt_region_fw = start;
#line 731
  goto ldv_66146;
  case 1U: ;
#line 733
  if ((ha->device_type & 65536U) != 0U) {
#line 734
    goto ldv_66146;
  } else {

  }
#line 735
  ha->flt_region_fw = start;
#line 736
  goto ldv_66146;
  case 7U: 
#line 738
  ha->flt_region_boot = start;
#line 739
  goto ldv_66146;
  case 20U: ;
#line 741
  if ((ha->device_type & 65536U) != 0U) {
#line 742
    goto ldv_66146;
  } else {

  }
#line 743
  ha->flt_region_vpd_nvram = start;
#line 744
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 745
    goto ldv_66146;
  } else {

  }
#line 746
  if ((unsigned int )ha->port_no == 0U) {
#line 747
    ha->flt_region_vpd = start;
  } else {

  }
#line 748
  goto ldv_66146;
  case 22U: ;
#line 750
  if (((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) || (ha->device_type & 65536U) != 0U) {
#line 751
    goto ldv_66146;
  } else {

  }
#line 752
  if ((unsigned int )ha->port_no == 1U) {
#line 753
    ha->flt_region_vpd = start;
  } else {

  }
#line 754
  goto ldv_66146;
  case 212U: ;
#line 756
  if ((ha->device_type & 524288U) == 0U && (ha->device_type & 1048576U) == 0U) {
#line 757
    goto ldv_66146;
  } else {

  }
#line 758
  if ((unsigned int )ha->port_no == 2U) {
#line 759
    ha->flt_region_vpd = start;
  } else {

  }
#line 760
  goto ldv_66146;
  case 214U: ;
#line 762
  if ((ha->device_type & 524288U) == 0U && (ha->device_type & 1048576U) == 0U) {
#line 763
    goto ldv_66146;
  } else {

  }
#line 764
  if ((unsigned int )ha->port_no == 3U) {
#line 765
    ha->flt_region_vpd = start;
  } else {

  }
#line 766
  goto ldv_66146;
  case 21U: ;
#line 768
  if ((ha->device_type & 65536U) != 0U) {
#line 769
    goto ldv_66146;
  } else {

  }
#line 770
  if ((unsigned int )ha->port_no == 0U) {
#line 771
    ha->flt_region_nvram = start;
  } else {

  }
#line 772
  goto ldv_66146;
  case 23U: ;
#line 774
  if ((ha->device_type & 65536U) != 0U) {
#line 775
    goto ldv_66146;
  } else {

  }
#line 776
  if ((unsigned int )ha->port_no == 1U) {
#line 777
    ha->flt_region_nvram = start;
  } else {

  }
#line 778
  goto ldv_66146;
  case 213U: ;
#line 780
  if ((ha->device_type & 524288U) == 0U && (ha->device_type & 1048576U) == 0U) {
#line 781
    goto ldv_66146;
  } else {

  }
#line 782
  if ((unsigned int )ha->port_no == 2U) {
#line 783
    ha->flt_region_nvram = start;
  } else {

  }
#line 784
  goto ldv_66146;
  case 215U: ;
#line 786
  if ((ha->device_type & 524288U) == 0U && (ha->device_type & 1048576U) == 0U) {
#line 787
    goto ldv_66146;
  } else {

  }
#line 788
  if ((unsigned int )ha->port_no == 3U) {
#line 789
    ha->flt_region_nvram = start;
  } else {

  }
#line 790
  goto ldv_66146;
  case 26U: 
#line 792
  ha->flt_region_fdt = start;
#line 793
  goto ldv_66146;
  case 41U: ;
#line 795
  if ((unsigned int )ha->port_no == 0U) {
#line 796
    ha->flt_region_npiv_conf = start;
  } else {

  }
#line 797
  goto ldv_66146;
  case 42U: ;
#line 799
  if ((unsigned int )ha->port_no == 1U) {
#line 800
    ha->flt_region_npiv_conf = start;
  } else {

  }
#line 801
  goto ldv_66146;
  case 47U: 
#line 803
  ha->flt_region_gold_fw = start;
#line 804
  goto ldv_66146;
  case 135U: ;
#line 806
  if ((unsigned int )ha->port_no == 0U) {
#line 807
    ha->flt_region_fcp_prio = start;
  } else {

  }
#line 808
  goto ldv_66146;
  case 136U: ;
#line 810
  if ((unsigned int )ha->port_no == 1U) {
#line 811
    ha->flt_region_fcp_prio = start;
  } else {

  }
#line 812
  goto ldv_66146;
  case 120U: 
#line 814
  ha->flt_region_boot = start;
#line 815
  goto ldv_66146;
  case 162U: ;
#line 817
  if ((ha->device_type & 262144U) != 0U) {
#line 818
    ha->flt_region_boot = start;
  } else {

  }
#line 819
  goto ldv_66146;
  case 116U: 
#line 821
  ha->flt_region_fw = start;
#line 822
  goto ldv_66146;
  case 151U: ;
#line 824
  if ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 825
    ha->flt_region_fw = start;
  } else {

  }
#line 826
  goto ldv_66146;
  case 117U: 
#line 828
  ha->flt_region_gold_fw = start;
#line 829
  goto ldv_66146;
  case 114U: 
#line 831
  ha->flt_region_bootload = start;
#line 832
  goto ldv_66146;
  case 129U: ;
#line 834
  if ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 835
    ha->flt_region_vpd = start;
  } else {

  }
#line 836
  goto ldv_66146;
  case 170U: ;
#line 838
  if ((ha->device_type & 65536U) == 0U && (ha->device_type & 262144U) == 0U) {
#line 839
    goto ldv_66146;
  } else {

  }
#line 840
  if ((unsigned int )ha->port_no == 0U) {
#line 841
    ha->flt_region_nvram = start;
  } else {

  }
#line 842
  goto ldv_66146;
  case 172U: ;
#line 844
  if ((ha->device_type & 65536U) == 0U && (ha->device_type & 262144U) == 0U) {
#line 845
    goto ldv_66146;
  } else {

  }
#line 846
  if ((unsigned int )ha->port_no == 1U) {
#line 847
    ha->flt_region_nvram = start;
  } else {

  }
#line 848
  goto ldv_66146;
  }
  ldv_66146: 
#line 717
  cnt = (uint16_t )((int )cnt - 1);
#line 717
  region = region + 1;
  ldv_66173: ;
#line 717
  if ((unsigned int )cnt != 0U) {
#line 719
    goto ldv_66172;
  } else {

  }

#line 851
  goto done;
  no_flash_data: 
#line 855
  loc = locations[0];
#line 856
  ha->flt_region_fw = def_fw[def];
#line 857
  ha->flt_region_boot = def_boot[def];
#line 858
  ha->flt_region_vpd_nvram = def_vpd_nvram[def];
#line 859
  ha->flt_region_vpd = (unsigned int )ha->port_no == 0U ? def_vpd0[def] : def_vpd1[def];
#line 861
  ha->flt_region_nvram = (unsigned int )ha->port_no == 0U ? def_nvram0[def] : def_nvram1[def];
#line 863
  ha->flt_region_fdt = def_fdt[def];
#line 864
  ha->flt_region_npiv_conf = (unsigned int )ha->port_no == 0U ? def_npiv_conf0[def] : def_npiv_conf1[def];
  done: 
#line 867
  ql_dbg(1073741824U, vha, 74, "FLT[%s]: boot=0x%x fw=0x%x vpd_nvram=0x%x vpd=0x%x nvram=0x%x fdt=0x%x flt=0x%x npiv=0x%x fcp_prif_cfg=0x%x.\n",
         loc, ha->flt_region_boot, ha->flt_region_fw, ha->flt_region_vpd_nvram, ha->flt_region_vpd,
         ha->flt_region_nvram, ha->flt_region_fdt, ha->flt_region_flt, ha->flt_region_npiv_conf,
         ha->flt_region_fcp_prio);
#line 874
  return;
}
}
#line 877 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static void qla2xxx_get_fdt_info(scsi_qla_host_t *vha ) 
{ 
  char const   *loc ;
  char const   *locations[2U] ;
  uint16_t cnt ;
  uint16_t chksum ;
  uint16_t *wptr ;
  struct qla_fdt_layout *fdt ;
  uint8_t man_id ;
  uint8_t flash_id ;
  uint16_t mid ;
  uint16_t fid ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  uint16_t *tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 882
  locations[0] = "MID";
#line 882
  locations[1] = "FDT";
#line 887
  mid = 0U;
#line 887
  fid = 0U;
#line 888
  ha = vha->hw;
#line 889
  req = *(ha->req_q_map);
#line 891
  wptr = (uint16_t *)req->ring;
#line 892
  fdt = (struct qla_fdt_layout *)req->ring;
#line 893
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)req->ring, ha->flt_region_fdt << 2,
                                  4096U);
#line 895
  if ((unsigned int )*wptr == 65535U) {
#line 896
    goto no_flash_data;
  } else {

  }
#line 897
  if ((((unsigned int )fdt->sig[0] != 81U || (unsigned int )fdt->sig[1] != 76U) || (unsigned int )fdt->sig[2] != 73U) || (unsigned int )fdt->sig[3] != 68U) {
#line 899
    goto no_flash_data;
  } else {

  }
#line 901
  cnt = 0U;
#line 901
  chksum = 0U;
#line 901
  goto ldv_66193;
  ldv_66192: 
#line 903
  tmp = wptr;
#line 903
  wptr = wptr + 1;
#line 903
  chksum = (int )*tmp + (int )chksum;
#line 902
  cnt = (uint16_t )((int )cnt + 1);
  ldv_66193: ;
#line 901
  if ((unsigned int )cnt <= 63U) {
#line 903
    goto ldv_66192;
  } else {

  }

#line 904
  if ((unsigned int )chksum != 0U) {
#line 905
    ql_dbg(1073741824U, vha, 76, "Inconsistent FDT detected: checksum=0x%x id=%c version0x%x.\n",
           (int )chksum, (int )fdt->sig[0], (int )fdt->version);
#line 909
    ql_dump_buffer(1073872896U, vha, 275, (uint8_t *)fdt, 128U);
#line 911
    goto no_flash_data;
  } else {

  }
#line 914
  loc = locations[1];
#line 915
  mid = fdt->man_id;
#line 916
  fid = fdt->id;
#line 917
  ha->fdt_wrt_disable = (uint32_t )fdt->wrt_disable_bits;
#line 918
  ha->fdt_wrt_enable = (uint32_t )fdt->wrt_enable_bits;
#line 919
  ha->fdt_wrt_sts_reg_cmd = (uint32_t )fdt->wrt_sts_reg_cmd;
#line 920
  if ((ha->device_type & 262144U) != 0U) {
#line 921
    ha->fdt_erase_cmd = (uint32_t )fdt->erase_cmd;
  } else {
#line 923
    ha->fdt_erase_cmd = flash_conf_addr(ha, (uint32_t )((int )fdt->erase_cmd | 768));
  }
#line 925
  ha->fdt_block_size = fdt->block_size;
#line 926
  if ((unsigned int )fdt->unprotect_sec_cmd != 0U) {
#line 927
    ha->fdt_unprotect_sec_cmd = flash_conf_addr(ha, (uint32_t )((int )fdt->unprotect_sec_cmd | 768));
#line 929
    if ((unsigned int )fdt->protect_sec_cmd != 0U) {
#line 929
      tmp___0 = flash_conf_addr(ha, (uint32_t )((int )fdt->protect_sec_cmd | 768));
#line 929
      ha->fdt_protect_sec_cmd = tmp___0;
    } else {
#line 929
      tmp___1 = flash_conf_addr(ha, 822U);
#line 929
      ha->fdt_protect_sec_cmd = tmp___1;
    }
  } else {

  }
#line 933
  goto done;
  no_flash_data: 
#line 935
  loc = locations[0];
#line 936
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 937
    ha->fdt_block_size = 65536U;
#line 938
    goto done;
  } else {

  }
#line 940
  qla24xx_get_flash_manufacturer(ha, & man_id, & flash_id);
#line 941
  mid = (uint16_t )man_id;
#line 942
  fid = (uint16_t )flash_id;
#line 943
  ha->fdt_wrt_disable = 156U;
#line 944
  ha->fdt_erase_cmd = flash_conf_addr(ha, 984U);
#line 945
  switch ((int )man_id) {
  case 191: ;
#line 947
  if ((unsigned int )flash_id == 142U) {
#line 948
    ha->fdt_block_size = 65536U;
  } else {
#line 950
    ha->fdt_block_size = 32768U;
  }
#line 952
  if ((unsigned int )flash_id == 128U) {
#line 953
    ha->fdt_erase_cmd = flash_conf_addr(ha, 850U);
  } else {

  }
#line 954
  goto ldv_66197;
  case 19: 
#line 956
  ha->fdt_block_size = 65536U;
#line 957
  goto ldv_66197;
  case 31: 
#line 959
  ha->fdt_block_size = 4096U;
#line 960
  ha->fdt_erase_cmd = flash_conf_addr(ha, 800U);
#line 961
  ha->fdt_unprotect_sec_cmd = flash_conf_addr(ha, 825U);
#line 962
  ha->fdt_protect_sec_cmd = flash_conf_addr(ha, 822U);
#line 963
  goto ldv_66197;
  default: 
#line 966
  ha->fdt_block_size = 65536U;
#line 967
  goto ldv_66197;
  }
  ldv_66197: ;
  done: 
#line 970
  ql_dbg(1073741824U, vha, 77, "FDT[%s]: (0x%x/0x%x) erase=0x%x pr=%x wrtd=0x%x blk=0x%x.\n",
         loc, (int )mid, (int )fid, ha->fdt_erase_cmd, ha->fdt_protect_sec_cmd, ha->fdt_wrt_disable,
         ha->fdt_block_size);
#line 976
  return;
}
}
#line 980 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static void qla2xxx_get_idc_param(scsi_qla_host_t *vha ) 
{ 
  uint32_t *wptr ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  uint32_t *tmp ;

  {
#line 984
  ha = vha->hw;
#line 985
  req = *(ha->req_q_map);
#line 987
  if ((ha->device_type & 16384U) == 0U && (ha->device_type & 262144U) == 0U) {
#line 988
    return;
  } else {

  }
#line 990
  wptr = (uint32_t *)req->ring;
#line 991
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)req->ring, 4098140U, 8U);
#line 994
  if (*wptr == 4294967295U) {
#line 995
    ha->fcoe_dev_init_timeout = 30U;
#line 996
    ha->fcoe_reset_timeout = 10U;
  } else {
#line 998
    tmp = wptr;
#line 998
    wptr = wptr + 1;
#line 998
    ha->fcoe_dev_init_timeout = *tmp;
#line 999
    ha->fcoe_reset_timeout = *wptr;
  }
#line 1001
  ql_dbg(1073741824U, vha, 78, "fcoe_dev_init_timeout=%d fcoe_reset_timeout=%d.\n",
         ha->fcoe_dev_init_timeout, ha->fcoe_reset_timeout);
#line 1005
  return;
}
}
#line 1009 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
int qla2xxx_get_flash_info(scsi_qla_host_t *vha ) 
{ 
  int ret ;
  uint32_t flt_addr ;
  struct qla_hw_data *ha ;

  {
#line 1013
  ha = vha->hw;
#line 1015
  if ((((((((ha->device_type & 128U) == 0U && (ha->device_type & 256U) == 0U) && ((ha->device_type & 512U) == 0U && (ha->device_type & 1024U) == 0U)) && (ha->device_type & 4096U) == 0U) && (ha->device_type & 2048U) == 0U) && ((((ha->device_type & 8192U) == 0U && (ha->device_type & 16384U) == 0U) && (ha->device_type & 65536U) == 0U) && (ha->device_type & 262144U) == 0U)) && (ha->device_type & 32768U) == 0U) && ((ha->device_type & 524288U) == 0U && (ha->device_type & 1048576U) == 0U)) {
#line 1017
    return (0);
  } else {

  }
#line 1019
  ret = qla2xxx_find_flt_start(vha, & flt_addr);
#line 1020
  if (ret != 0) {
#line 1021
    return (ret);
  } else {

  }
#line 1023
  qla2xxx_get_flt_info(vha, flt_addr);
#line 1024
  qla2xxx_get_fdt_info(vha);
#line 1025
  qla2xxx_get_idc_param(vha);
#line 1027
  return (0);
}
}
#line 1031 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
void qla2xxx_flash_npiv_conf(scsi_qla_host_t *vha ) 
{ 
  void *data ;
  uint16_t *wptr ;
  uint16_t cnt ;
  uint16_t chksum ;
  int i ;
  struct qla_npiv_header hdr ;
  struct qla_npiv_entry *entry ;
  struct qla_hw_data *ha ;
  uint16_t *tmp ;
  uint16_t flags ;
  struct fc_vport_identifiers vid ;
  struct fc_vport *vport ;

  {
#line 1040
  ha = vha->hw;
#line 1042
  if (((((((ha->device_type & 128U) == 0U && (ha->device_type & 256U) == 0U) && ((ha->device_type & 512U) == 0U && (ha->device_type & 1024U) == 0U)) && (ha->device_type & 4096U) == 0U) && (ha->device_type & 2048U) == 0U) && ((((ha->device_type & 8192U) == 0U && (ha->device_type & 16384U) == 0U) && (ha->device_type & 65536U) == 0U) && (ha->device_type & 262144U) == 0U)) && (ha->device_type & 32768U) == 0U) {
#line 1044
    return;
  } else {

  }
#line 1046
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1047
    return;
  } else {

  }
#line 1049
  if ((ha->device_type & 262144U) != 0U) {
#line 1050
    return;
  } else {

  }
#line 1052
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)(& hdr), ha->flt_region_npiv_conf << 2,
                                  16U);
#line 1054
  if ((unsigned int )hdr.version == 65535U) {
#line 1055
    return;
  } else {

  }
#line 1056
  if ((unsigned int )hdr.version != 1U) {
#line 1057
    ql_dbg(8388608U, vha, 28816, "Unsupported NPIV-Config detected: version=0x%x entries=0x%x checksum=0x%x.\n",
           (int )hdr.version, (int )hdr.entries, (int )hdr.checksum);
#line 1062
    return;
  } else {

  }
#line 1065
  data = kmalloc(16384UL, 208U);
#line 1066
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1067
    ql_log(1U, vha, 28817, "Unable to allocate memory for data.\n");
#line 1069
    return;
  } else {

  }
#line 1072
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)data, ha->flt_region_npiv_conf << 2,
                                  16384U);
#line 1075
  cnt = (uint16_t )(((unsigned long )hdr.entries * 24UL + 16UL) >> 1);
#line 1077
  wptr = (uint16_t *)data;
#line 1077
  chksum = 0U;
#line 1077
  goto ldv_66225;
  ldv_66224: 
#line 1078
  tmp = wptr;
#line 1078
  wptr = wptr + 1;
#line 1078
  chksum = (int )*tmp + (int )chksum;
#line 1077
  cnt = (uint16_t )((int )cnt - 1);
  ldv_66225: ;
#line 1077
  if ((unsigned int )cnt != 0U) {
#line 1079
    goto ldv_66224;
  } else {

  }

#line 1079
  if ((unsigned int )chksum != 0U) {
#line 1080
    ql_dbg(8388608U, vha, 28818, "Inconsistent NPIV-Config detected: version=0x%x entries=0x%x checksum=0x%x.\n",
           (int )hdr.version, (int )hdr.entries, (int )hdr.checksum);
#line 1085
    goto done;
  } else {

  }
#line 1088
  entry = (struct qla_npiv_entry *)data + 16U;
#line 1089
  cnt = hdr.entries;
#line 1090
  i = 0;
#line 1090
  goto ldv_66233;
  ldv_66232: 
#line 1095
  memcpy((void *)ha->npiv_info + (unsigned long )i, (void const   *)entry, 24UL);
#line 1097
  flags = entry->flags;
#line 1098
  if ((unsigned int )flags == 65535U) {
#line 1099
    goto ldv_66231;
  } else {

  }
#line 1100
  if (((int )flags & 1) == 0) {
#line 1101
    goto ldv_66231;
  } else {

  }
#line 1103
  memset((void *)(& vid), 0, 96UL);
#line 1104
  vid.roles = 2U;
#line 1105
  vid.vport_type = 7;
#line 1106
  vid.disable = 0;
#line 1107
  vid.port_name = wwn_to_u64((u8 *)(& entry->port_name));
#line 1108
  vid.node_name = wwn_to_u64((u8 *)(& entry->node_name));
#line 1110
  ql_dbg(8388608U, vha, 28819, "NPIV[%02x]: wwpn=%llx wwnn=%llx vf_id=0x%x Q_qos=0x%x F_qos=0x%x.\n",
         (int )cnt, vid.port_name, vid.node_name, (int )entry->vf_id, (int )entry->q_qos,
         (int )entry->f_qos);
#line 1118
  if (i <= 31) {
#line 1119
    vport = fc_vport_create(vha->host, 0, & vid);
#line 1120
    if ((unsigned long )vport == (unsigned long )((struct fc_vport *)0)) {
#line 1121
      ql_log(1U, vha, 28820, "NPIV-Config Failed to create vport [%02x]: wwpn=%llx wwnn=%llx.\n",
             (int )cnt, vid.port_name, vid.node_name);
    } else {

    }
  } else {

  }
  ldv_66231: 
#line 1090
  cnt = (uint16_t )((int )cnt - 1);
#line 1090
  entry = entry + 1;
#line 1090
  i = i + 1;
  ldv_66233: ;
#line 1090
  if ((unsigned int )cnt != 0U) {
#line 1092
    goto ldv_66232;
  } else {

  }

  done: 
#line 1129
  kfree((void const   *)data);
#line 1130
  return;
}
}
#line 1133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static int qla24xx_unprotect_flash(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  int tmp ;
  unsigned int tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 1135
  ha = vha->hw;
#line 1136
  reg = & (ha->iobase)->isp24;
#line 1138
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1139
    tmp = qla81xx_fac_do_write_enable(vha, 1);
#line 1139
    return (tmp);
  } else {

  }
#line 1142
  tmp___0 = readl((void const volatile   *)(& reg->ctrl_status));
#line 1142
  writel(tmp___0 | 2U, (void volatile   *)(& reg->ctrl_status));
#line 1144
  readl((void const volatile   *)(& reg->ctrl_status));
#line 1146
  if (ha->fdt_wrt_disable == 0U) {
#line 1147
    goto done;
  } else {

  }
#line 1150
  tmp___1 = flash_conf_addr(ha, 257U);
#line 1150
  qla24xx_write_flash_dword(ha, tmp___1, 0U);
#line 1152
  tmp___2 = flash_conf_addr(ha, 257U);
#line 1152
  qla24xx_write_flash_dword(ha, tmp___2, 0U);
  done: ;
#line 1154
  return (0);
}
}
#line 1158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static int qla24xx_protect_flash(scsi_qla_host_t *vha ) 
{ 
  uint32_t cnt ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 1161
  ha = vha->hw;
#line 1162
  reg = & (ha->iobase)->isp24;
#line 1164
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1165
    tmp = qla81xx_fac_do_write_enable(vha, 0);
#line 1165
    return (tmp);
  } else {

  }
#line 1167
  if (ha->fdt_wrt_disable == 0U) {
#line 1168
    goto skip_wrt_protect;
  } else {

  }
#line 1171
  tmp___0 = flash_conf_addr(ha, 257U);
#line 1171
  qla24xx_write_flash_dword(ha, tmp___0, ha->fdt_wrt_disable);
#line 1173
  cnt = 300U;
#line 1173
  goto ldv_66249;
  ldv_66248: 
#line 1176
  __const_udelay(42950UL);
#line 1175
  cnt = cnt - 1U;
  ldv_66249: ;
#line 1173
  if (cnt != 0U) {
#line 1173
    tmp___1 = flash_conf_addr(ha, 5U);
#line 1173
    tmp___2 = qla24xx_read_flash_dword(ha, tmp___1);
#line 1173
    if ((int )tmp___2 & 1) {
#line 1175
      goto ldv_66248;
    } else {
#line 1178
      goto ldv_66250;
    }
  } else {

  }
  ldv_66250: ;
  skip_wrt_protect: 
#line 1181
  tmp___3 = readl((void const volatile   *)(& reg->ctrl_status));
#line 1181
  writel(tmp___3 & 4294967293U, (void volatile   *)(& reg->ctrl_status));
#line 1183
  readl((void const volatile   *)(& reg->ctrl_status));
#line 1185
  return (0);
}
}
#line 1189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static int qla24xx_erase_sector(scsi_qla_host_t *vha , uint32_t fdata ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t start ;
  uint32_t finish ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1191
  ha = vha->hw;
#line 1194
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1195
    start = fdata >> 2;
#line 1196
    finish = ((ha->fdt_block_size >> 2) + start) - 1U;
#line 1197
    tmp = flash_data_addr(ha, finish);
#line 1197
    tmp___0 = flash_data_addr(ha, start);
#line 1197
    tmp___1 = qla81xx_fac_erase_sector(vha, tmp___0, tmp);
#line 1197
    return (tmp___1);
  } else {

  }
#line 1201
  tmp___2 = qla24xx_write_flash_dword(ha, ha->fdt_erase_cmd, ((fdata & 65280U) | ((fdata << 16) & 16711680U)) | ((fdata >> 16) & 255U));
#line 1201
  return (tmp___2);
}
}
#line 1207 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static int qla24xx_write_flash_data(scsi_qla_host_t *vha , uint32_t *dwptr , uint32_t faddr ,
                                    uint32_t dwords ) 
{ 
  int ret ;
  uint32_t liter ;
  uint32_t sec_mask ;
  uint32_t rest_addr ;
  uint32_t fdata ;
  dma_addr_t optrom_dma ;
  void *optrom ;
  struct qla_hw_data *ha ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 1215
  optrom = (void *)0;
#line 1216
  ha = vha->hw;
#line 1219
  if ((((((ha->device_type & 2048U) != 0U || (ha->device_type & 8192U) != 0U) || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) && (faddr & 4095U) == 0U) && dwords > 1024U) {
#line 1222
    optrom = dma_alloc_attrs(& (ha->pdev)->dev, 4096UL, & optrom_dma, 208U, (struct dma_attrs *)0);
#line 1224
    if ((unsigned long )optrom == (unsigned long )((void *)0)) {
#line 1225
      ql_log(1U, vha, 28821, "Unable to allocate memory for optrom burst write (%x KB).\n",
             4);
    } else {

    }
  } else {

  }
#line 1232
  rest_addr = (ha->fdt_block_size >> 2) - 1U;
#line 1233
  sec_mask = ~ rest_addr;
#line 1235
  ret = qla24xx_unprotect_flash(vha);
#line 1236
  if (ret != 0) {
#line 1237
    ql_log(1U, vha, 28822, "Unable to unprotect flash for update.\n");
#line 1239
    goto done;
  } else {

  }
#line 1242
  liter = 0U;
#line 1242
  goto ldv_66276;
  ldv_66275: 
#line 1243
  fdata = (faddr & sec_mask) << 2;
#line 1246
  if ((faddr & rest_addr) == 0U) {
#line 1248
    if (ha->fdt_unprotect_sec_cmd != 0U) {
#line 1249
      qla24xx_write_flash_dword(ha, ha->fdt_unprotect_sec_cmd, ((fdata & 65280U) | ((fdata << 16) & 16711680U)) | ((fdata >> 16) & 255U));
    } else {

    }
#line 1253
    ret = qla24xx_erase_sector(vha, fdata);
#line 1254
    if (ret != 0) {
#line 1255
      ql_dbg(8388608U, vha, 28679, "Unable to erase erase sector: address=%x.\n",
             faddr);
#line 1258
      goto ldv_66273;
    } else {

    }
  } else {

  }
#line 1263
  if ((unsigned long )optrom != (unsigned long )((void *)0) && liter + 1024U <= dwords) {
#line 1265
    memcpy(optrom, (void const   *)dwptr, 4096UL);
#line 1267
    tmp = flash_data_addr(ha, faddr);
#line 1267
    ret = qla2x00_load_ram(vha, optrom_dma, tmp, 1024U);
#line 1270
    if (ret != 0) {
#line 1271
      tmp___0 = flash_data_addr(ha, faddr);
#line 1271
      ql_log(1U, vha, 28823, "Unable to burst-write optrom segment (%x/%x/%llx).\n",
             ret, tmp___0, optrom_dma);
#line 1276
      ql_log(1U, vha, 28824, "Reverting to slow-write.\n");
#line 1279
      dma_free_attrs(& (ha->pdev)->dev, 4096UL, optrom, optrom_dma, (struct dma_attrs *)0);
#line 1281
      optrom = (void *)0;
    } else {
#line 1283
      liter = liter + 1023U;
#line 1284
      faddr = faddr + 1023U;
#line 1285
      dwptr = dwptr + 1023UL;
#line 1286
      goto ldv_66274;
    }
  } else {

  }
#line 1290
  tmp___1 = flash_data_addr(ha, faddr);
#line 1290
  ret = qla24xx_write_flash_dword(ha, tmp___1, *dwptr);
#line 1292
  if (ret != 0) {
#line 1293
    ql_dbg(8388608U, vha, 28678, "Unable to program flash address=%x data=%x.\n",
           faddr, *dwptr);
#line 1296
    goto ldv_66273;
  } else {

  }
#line 1300
  if (ha->fdt_unprotect_sec_cmd != 0U && (faddr & rest_addr) == rest_addr) {
#line 1302
    qla24xx_write_flash_dword(ha, ha->fdt_protect_sec_cmd, ((fdata & 65280U) | ((fdata << 16) & 16711680U)) | ((fdata >> 16) & 255U));
  } else {

  }
  ldv_66274: 
#line 1242
  liter = liter + 1U;
#line 1242
  faddr = faddr + 1U;
#line 1242
  dwptr = dwptr + 1;
  ldv_66276: ;
#line 1242
  if (liter < dwords) {
#line 1244
    goto ldv_66275;
  } else {

  }
  ldv_66273: 
#line 1308
  ret = qla24xx_protect_flash(vha);
#line 1309
  if (ret != 0) {
#line 1310
    ql_log(1U, vha, 28825, "Unable to protect flash after update.\n");
  } else {

  }
  done: ;
#line 1313
  if ((unsigned long )optrom != (unsigned long )((void *)0)) {
#line 1314
    dma_free_attrs(& (ha->pdev)->dev, 4096UL, optrom, optrom_dma, (struct dma_attrs *)0);
  } else {

  }
#line 1317
  return (ret);
}
}
#line 1321 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
uint8_t *qla2x00_read_nvram_data(scsi_qla_host_t *vha , uint8_t *buf , uint32_t naddr ,
                                 uint32_t bytes ) 
{ 
  uint32_t i ;
  uint16_t *wptr ;
  struct qla_hw_data *ha ;

  {
#line 1326
  ha = vha->hw;
#line 1329
  wptr = (uint16_t *)buf;
#line 1330
  qla2x00_lock_nvram_access(ha);
#line 1331
  i = 0U;
#line 1331
  goto ldv_66287;
  ldv_66286: 
#line 1332
  *(wptr + (unsigned long )i) = qla2x00_get_nvram_word(ha, naddr);
#line 1331
  i = i + 1U;
#line 1331
  naddr = naddr + 1U;
  ldv_66287: ;
#line 1331
  if (bytes >> 1 > i) {
#line 1333
    goto ldv_66286;
  } else {

  }
#line 1334
  qla2x00_unlock_nvram_access(ha);
#line 1336
  return (buf);
}
}
#line 1340 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
uint8_t *qla24xx_read_nvram_data(scsi_qla_host_t *vha , uint8_t *buf , uint32_t naddr ,
                                 uint32_t bytes ) 
{ 
  uint32_t i ;
  uint32_t *dwptr ;
  struct qla_hw_data *ha ;
  uint32_t tmp ;

  {
#line 1345
  ha = vha->hw;
#line 1347
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1348
    return (buf);
  } else {

  }
#line 1351
  dwptr = (uint32_t *)buf;
#line 1352
  i = 0U;
#line 1352
  goto ldv_66299;
  ldv_66298: 
#line 1353
  tmp = nvram_data_addr(ha, naddr);
#line 1353
  *(dwptr + (unsigned long )i) = qla24xx_read_flash_dword(ha, tmp);
#line 1352
  i = i + 1U;
#line 1352
  naddr = naddr + 1U;
  ldv_66299: ;
#line 1352
  if (bytes >> 2 > i) {
#line 1354
    goto ldv_66298;
  } else {

  }

#line 1356
  return (buf);
}
}
#line 1360 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
int qla2x00_write_nvram_data(scsi_qla_host_t *vha , uint8_t *buf , uint32_t naddr ,
                             uint32_t bytes ) 
{ 
  int ret ;
  int stat ;
  uint32_t i ;
  uint16_t *wptr ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  raw_spinlock_t *tmp ;

  {
#line 1367
  ha = vha->hw;
#line 1369
  ret = 0;
#line 1371
  tmp = spinlock_check(& ha->hardware_lock);
#line 1371
  flags = _raw_spin_lock_irqsave(tmp);
#line 1372
  qla2x00_lock_nvram_access(ha);
#line 1375
  stat = qla2x00_clear_nvram_protection(ha);
#line 1377
  wptr = (uint16_t *)buf;
#line 1378
  i = 0U;
#line 1378
  goto ldv_66317;
  ldv_66316: 
#line 1379
  qla2x00_write_nvram_word(ha, naddr, (int )*wptr);
#line 1381
  wptr = wptr + 1;
#line 1378
  i = i + 1U;
#line 1378
  naddr = naddr + 1U;
  ldv_66317: ;
#line 1378
  if (bytes >> 1 > i) {
#line 1380
    goto ldv_66316;
  } else {

  }
#line 1385
  qla2x00_set_nvram_protection(ha, stat);
#line 1387
  qla2x00_unlock_nvram_access(ha);
#line 1388
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1390
  return (ret);
}
}
#line 1394 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
int qla24xx_write_nvram_data(scsi_qla_host_t *vha , uint8_t *buf , uint32_t naddr ,
                             uint32_t bytes ) 
{ 
  int ret ;
  uint32_t i ;
  uint32_t *dwptr ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  unsigned int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 1400
  ha = vha->hw;
#line 1401
  reg = & (ha->iobase)->isp24;
#line 1403
  ret = 0;
#line 1405
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1406
    return (ret);
  } else {

  }
#line 1409
  tmp = readl((void const volatile   *)(& reg->ctrl_status));
#line 1409
  writel(tmp | 2U, (void volatile   *)(& reg->ctrl_status));
#line 1411
  readl((void const volatile   *)(& reg->ctrl_status));
#line 1414
  tmp___0 = nvram_conf_addr(ha, 257U);
#line 1414
  qla24xx_write_flash_dword(ha, tmp___0, 0U);
#line 1415
  tmp___1 = nvram_conf_addr(ha, 257U);
#line 1415
  qla24xx_write_flash_dword(ha, tmp___1, 0U);
#line 1418
  dwptr = (uint32_t *)buf;
#line 1419
  i = 0U;
#line 1419
  goto ldv_66332;
  ldv_66331: 
#line 1420
  tmp___2 = nvram_data_addr(ha, naddr);
#line 1420
  ret = qla24xx_write_flash_dword(ha, tmp___2, *dwptr);
#line 1422
  if (ret != 0) {
#line 1423
    ql_dbg(8388608U, vha, 28826, "Unable to program nvram address=%x data=%x.\n",
           naddr, *dwptr);
#line 1426
    goto ldv_66330;
  } else {

  }
#line 1419
  i = i + 1U;
#line 1419
  naddr = naddr + 1U;
#line 1419
  dwptr = dwptr + 1;
  ldv_66332: ;
#line 1419
  if (bytes >> 2 > i) {
#line 1421
    goto ldv_66331;
  } else {

  }
  ldv_66330: 
#line 1431
  tmp___3 = nvram_conf_addr(ha, 257U);
#line 1431
  qla24xx_write_flash_dword(ha, tmp___3, 140U);
#line 1434
  tmp___4 = readl((void const volatile   *)(& reg->ctrl_status));
#line 1434
  writel(tmp___4 & 4294967293U, (void volatile   *)(& reg->ctrl_status));
#line 1436
  readl((void const volatile   *)(& reg->ctrl_status));
#line 1438
  return (ret);
}
}
#line 1442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
uint8_t *qla25xx_read_nvram_data(scsi_qla_host_t *vha , uint8_t *buf , uint32_t naddr ,
                                 uint32_t bytes ) 
{ 
  uint32_t i ;
  uint32_t *dwptr ;
  struct qla_hw_data *ha ;
  uint32_t tmp ;

  {
#line 1447
  ha = vha->hw;
#line 1450
  dwptr = (uint32_t *)buf;
#line 1451
  i = 0U;
#line 1451
  goto ldv_66343;
  ldv_66342: 
#line 1452
  tmp = flash_data_addr(ha, ha->flt_region_vpd_nvram | naddr);
#line 1452
  *(dwptr + (unsigned long )i) = qla24xx_read_flash_dword(ha, tmp);
#line 1451
  i = i + 1U;
#line 1451
  naddr = naddr + 1U;
  ldv_66343: ;
#line 1451
  if (bytes >> 2 > i) {
#line 1453
    goto ldv_66342;
  } else {

  }

#line 1455
  return (buf);
}
}
#line 1459 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
int qla25xx_write_nvram_data(scsi_qla_host_t *vha , uint8_t *buf , uint32_t naddr ,
                             uint32_t bytes ) 
{ 
  struct qla_hw_data *ha ;
  uint8_t *dbuf ;
  void *tmp ;

  {
#line 1462
  ha = vha->hw;
#line 1466
  tmp = vmalloc(65536UL);
#line 1466
  dbuf = (uint8_t *)tmp;
#line 1467
  if ((unsigned long )dbuf == (unsigned long )((uint8_t *)0U)) {
#line 1468
    return (259);
  } else {

  }
#line 1469
  (*((ha->isp_ops)->read_optrom))(vha, dbuf, ha->flt_region_vpd_nvram << 2, 65536U);
#line 1471
  memcpy((void *)dbuf + (unsigned long )(naddr << 2), (void const   *)buf, (size_t )bytes);
#line 1472
  (*((ha->isp_ops)->write_optrom))(vha, dbuf, ha->flt_region_vpd_nvram << 2, 65536U);
#line 1474
  vfree((void const   *)dbuf);
#line 1476
  return (0);
}
}
#line 1480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
__inline static void qla2x00_flip_colors(struct qla_hw_data *ha , uint16_t *pflags ) 
{ 


  {
#line 1482
  if ((ha->device_type & 16U) != 0U) {
#line 1484
    if ((unsigned int )ha->beacon_color_state == 7U) {
#line 1486
      ha->beacon_color_state = 0U;
#line 1487
      *pflags = 0U;
    } else {
#line 1490
      ha->beacon_color_state = 7U;
#line 1491
      *pflags = 193U;
    }
  } else
#line 1495
  if ((unsigned int )ha->beacon_color_state == 1U) {
#line 1497
    ha->beacon_color_state = 0U;
#line 1498
    *pflags = 0U;
  } else {
#line 1501
    ha->beacon_color_state = 1U;
#line 1502
    *pflags = 64U;
  }
#line 1504
  return;
}
}
#line 1510 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
void qla2x00_beacon_blink(struct scsi_qla_host *vha ) 
{ 
  uint16_t gpio_enable ;
  uint16_t gpio_data ;
  uint16_t led_color ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  raw_spinlock_t *tmp ;

  {
#line 1514
  led_color = 0U;
#line 1516
  ha = vha->hw;
#line 1517
  reg = & (ha->iobase)->isp;
#line 1519
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1520
    return;
  } else {

  }
#line 1522
  tmp = spinlock_check(& ha->hardware_lock);
#line 1522
  flags = _raw_spin_lock_irqsave(tmp);
#line 1525
  if (ha->pio_address != 0ULL) {
#line 1526
    gpio_enable = inw((int )((unsigned int )ha->pio_address + 206U));
#line 1527
    gpio_data = inw((int )((unsigned int )ha->pio_address + 204U));
  } else {
#line 1529
    gpio_enable = readw((void const volatile   *)(& reg->gpioe));
#line 1530
    gpio_data = readw((void const volatile   *)(& reg->gpiod));
  }
#line 1534
  gpio_enable = (uint16_t )((unsigned int )gpio_enable | 192U);
#line 1536
  if (ha->pio_address != 0ULL) {
#line 1537
    outw((int )gpio_enable, (int )((unsigned int )ha->pio_address + 206U));
  } else {
#line 1539
    writew((int )gpio_enable, (void volatile   *)(& reg->gpioe));
#line 1540
    readw((void const volatile   *)(& reg->gpioe));
  }
#line 1543
  qla2x00_flip_colors(ha, & led_color);
#line 1546
  gpio_data = (unsigned int )gpio_data & 65343U;
#line 1549
  gpio_data = (uint16_t )((int )gpio_data | (int )led_color);
#line 1552
  if (ha->pio_address != 0ULL) {
#line 1553
    outw((int )gpio_data, (int )((unsigned int )ha->pio_address + 204U));
  } else {
#line 1555
    writew((int )gpio_data, (void volatile   *)(& reg->gpiod));
#line 1556
    readw((void const volatile   *)(& reg->gpiod));
  }
#line 1559
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1560
  return;
}
}
#line 1563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
int qla2x00_beacon_on(struct scsi_qla_host *vha ) 
{ 
  uint16_t gpio_enable ;
  uint16_t gpio_data ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 1568
  ha = vha->hw;
#line 1569
  reg = & (ha->iobase)->isp;
#line 1571
  ha->fw_options[1] = (unsigned int )ha->fw_options[1] & 65279U;
#line 1572
  ha->fw_options[1] = (uint16_t )((unsigned int )ha->fw_options[1] | 64U);
#line 1574
  tmp = qla2x00_set_fw_options(vha, (uint16_t *)(& ha->fw_options));
#line 1574
  if (tmp != 0) {
#line 1575
    ql_log(1U, vha, 28827, "Unable to update fw options (beacon on).\n");
#line 1577
    return (258);
  } else {

  }
#line 1581
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 1581
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 1582
  if (ha->pio_address != 0ULL) {
#line 1583
    gpio_enable = inw((int )((unsigned int )ha->pio_address + 206U));
#line 1584
    gpio_data = inw((int )((unsigned int )ha->pio_address + 204U));
  } else {
#line 1586
    gpio_enable = readw((void const volatile   *)(& reg->gpioe));
#line 1587
    gpio_data = readw((void const volatile   *)(& reg->gpiod));
  }
#line 1589
  gpio_enable = (uint16_t )((unsigned int )gpio_enable | 192U);
#line 1592
  if (ha->pio_address != 0ULL) {
#line 1593
    outw((int )gpio_enable, (int )((unsigned int )ha->pio_address + 206U));
  } else {
#line 1595
    writew((int )gpio_enable, (void volatile   *)(& reg->gpioe));
#line 1596
    readw((void const volatile   *)(& reg->gpioe));
  }
#line 1600
  gpio_data = (unsigned int )gpio_data & 65343U;
#line 1601
  if (ha->pio_address != 0ULL) {
#line 1602
    outw((int )gpio_data, (int )((unsigned int )ha->pio_address + 204U));
  } else {
#line 1604
    writew((int )gpio_data, (void volatile   *)(& reg->gpiod));
#line 1605
    readw((void const volatile   *)(& reg->gpiod));
  }
#line 1607
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1613
  ha->beacon_blink_led = 1U;
#line 1614
  ha->beacon_color_state = 0U;
#line 1616
  return (0);
}
}
#line 1620 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
int qla2x00_beacon_off(struct scsi_qla_host *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;

  {
#line 1622
  rval = 0;
#line 1623
  ha = vha->hw;
#line 1625
  ha->beacon_blink_led = 0U;
#line 1628
  if ((ha->device_type & 16U) != 0U) {
#line 1629
    ha->beacon_color_state = 7U;
  } else {
#line 1631
    ha->beacon_color_state = 1U;
  }
#line 1633
  (*((ha->isp_ops)->beacon_blink))(vha);
#line 1635
  ha->fw_options[1] = (unsigned int )ha->fw_options[1] & 65279U;
#line 1636
  ha->fw_options[1] = (unsigned int )ha->fw_options[1] & 65471U;
#line 1638
  rval = qla2x00_set_fw_options(vha, (uint16_t *)(& ha->fw_options));
#line 1639
  if (rval != 0) {
#line 1640
    ql_log(1U, vha, 28828, "Unable to update fw options (beacon off).\n");
  } else {

  }
#line 1642
  return (rval);
}
}
#line 1647 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
__inline static void qla24xx_flip_colors(struct qla_hw_data *ha , uint16_t *pflags ) 
{ 


  {
#line 1650
  if ((unsigned int )ha->beacon_color_state == 7U) {
#line 1652
    ha->beacon_color_state = 0U;
#line 1653
    *pflags = 0U;
  } else {
#line 1656
    ha->beacon_color_state = 7U;
#line 1657
    *pflags = 20U;
  }
#line 1659
  return;
}
}
#line 1662 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
void qla24xx_beacon_blink(struct scsi_qla_host *vha ) 
{ 
  uint16_t led_color ;
  uint32_t gpio_data ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  raw_spinlock_t *tmp ;

  {
#line 1664
  led_color = 0U;
#line 1667
  ha = vha->hw;
#line 1668
  reg = & (ha->iobase)->isp24;
#line 1671
  tmp = spinlock_check(& ha->hardware_lock);
#line 1671
  flags = _raw_spin_lock_irqsave(tmp);
#line 1672
  gpio_data = readl((void const volatile   *)(& reg->gpiod));
#line 1675
  gpio_data = gpio_data | 1835008U;
#line 1677
  writel(gpio_data, (void volatile   *)(& reg->gpiod));
#line 1678
  gpio_data = readl((void const volatile   *)(& reg->gpiod));
#line 1681
  qla24xx_flip_colors(ha, & led_color);
#line 1684
  gpio_data = gpio_data & 4294967267U;
#line 1687
  gpio_data = (uint32_t )led_color | gpio_data;
#line 1690
  writel(gpio_data, (void volatile   *)(& reg->gpiod));
#line 1691
  gpio_data = readl((void const volatile   *)(& reg->gpiod));
#line 1692
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1693
  return;
}
}
#line 1696 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static uint32_t qla83xx_select_led_port(struct qla_hw_data *ha ) 
{ 
  uint32_t led_select_value ;

  {
#line 1698
  led_select_value = 0U;
#line 1700
  if ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U) {
#line 1701
    goto out;
  } else {

  }
#line 1703
  if ((unsigned int )ha->port_no == 0U) {
#line 1704
    led_select_value = 2102048U;
  } else {
#line 1706
    led_select_value = 2102056U;
  }
  out: ;
#line 1709
  return (led_select_value);
}
}
#line 1713 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
void qla83xx_beacon_blink(struct scsi_qla_host *vha ) 
{ 
  uint32_t led_select_value ;
  struct qla_hw_data *ha ;
  uint16_t led_cfg[6U] ;
  uint16_t orig_led_cfg[6U] ;
  uint32_t led_10_value ;
  uint32_t led_43_value ;
  int rval ;

  {
#line 1716
  ha = vha->hw;
#line 1721
  if ((((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U) && (ha->device_type & 8192U) == 0U) && ((ha->device_type & 524288U) == 0U && (ha->device_type & 1048576U) == 0U)) {
#line 1722
    return;
  } else {

  }
#line 1724
  if ((unsigned int )ha->beacon_blink_led == 0U) {
#line 1725
    return;
  } else {

  }
#line 1727
  if ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) {
#line 1728
    qla2x00_write_ram_word(vha, 4099U, 1073742384U);
#line 1729
    qla2x00_write_ram_word(vha, 4100U, 1073742384U);
  } else
#line 1730
  if ((ha->device_type & 32768U) != 0U) {
#line 1731
    led_select_value = qla83xx_select_led_port(ha);
#line 1733
    qla83xx_wr_reg(vha, led_select_value, 1073742384U);
#line 1734
    qla83xx_wr_reg(vha, led_select_value + 4U, 1073742384U);
  } else
#line 1735
  if ((ha->device_type & 65536U) != 0U) {
#line 1736
    led_select_value = qla83xx_select_led_port(ha);
#line 1738
    qla83xx_rd_reg(vha, led_select_value, & led_10_value);
#line 1739
    qla83xx_rd_reg(vha, led_select_value + 16U, & led_43_value);
#line 1740
    qla83xx_wr_reg(vha, led_select_value, 32784384U);
#line 1741
    msleep(500U);
#line 1742
    qla83xx_wr_reg(vha, led_select_value, 1073742324U);
#line 1743
    msleep(1000U);
#line 1744
    qla83xx_wr_reg(vha, led_select_value, led_10_value);
#line 1745
    qla83xx_wr_reg(vha, led_select_value + 16U, led_43_value);
  } else
#line 1746
  if ((ha->device_type & 8192U) != 0U) {
#line 1750
    rval = qla81xx_get_led_config(vha, (uint16_t *)(& orig_led_cfg));
#line 1752
    if (rval == 0) {
#line 1753
      if ((ha->device_type & 8192U) != 0U) {
#line 1754
        led_cfg[0] = 16384U;
#line 1755
        led_cfg[1] = 8192U;
#line 1756
        led_cfg[2] = 0U;
#line 1757
        led_cfg[3] = 0U;
#line 1758
        led_cfg[4] = 0U;
#line 1759
        led_cfg[5] = 0U;
      } else {
#line 1761
        led_cfg[0] = 16384U;
#line 1762
        led_cfg[1] = 16384U;
#line 1763
        led_cfg[2] = 16384U;
#line 1764
        led_cfg[3] = 8192U;
#line 1765
        led_cfg[4] = 0U;
#line 1766
        led_cfg[5] = 8192U;
      }
#line 1768
      rval = qla81xx_set_led_config(vha, (uint16_t *)(& led_cfg));
#line 1769
      msleep(1000U);
#line 1770
      if ((ha->device_type & 8192U) != 0U) {
#line 1771
        led_cfg[0] = 16384U;
#line 1772
        led_cfg[1] = 8192U;
#line 1773
        led_cfg[2] = 0U;
      } else {
#line 1775
        led_cfg[0] = 16384U;
#line 1776
        led_cfg[1] = 8192U;
#line 1777
        led_cfg[2] = 16384U;
#line 1778
        led_cfg[3] = 16384U;
#line 1779
        led_cfg[4] = 0U;
#line 1780
        led_cfg[5] = 8192U;
      }
#line 1782
      rval = qla81xx_set_led_config(vha, (uint16_t *)(& led_cfg));
    } else {

    }
#line 1785
    qla81xx_set_led_config(vha, (uint16_t *)(& orig_led_cfg));
  } else {

  }
#line 1787
  return;
}
}
#line 1790 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
int qla24xx_beacon_on(struct scsi_qla_host *vha ) 
{ 
  uint32_t gpio_data ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  int tmp ;
  int tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
#line 1794
  ha = vha->hw;
#line 1795
  reg = & (ha->iobase)->isp24;
#line 1797
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1798
    return (0);
  } else {

  }
#line 1800
  if ((ha->device_type & 65536U) != 0U || (ha->device_type & 8192U) != 0U) {
#line 1801
    goto skip_gpio;
  } else {

  }
#line 1803
  if ((unsigned int )ha->beacon_blink_led == 0U) {
#line 1805
    ha->fw_options[1] = (uint16_t )((unsigned int )ha->fw_options[1] | 64U);
#line 1807
    tmp = qla2x00_set_fw_options(vha, (uint16_t *)(& ha->fw_options));
#line 1807
    if (tmp != 0) {
#line 1808
      return (258);
    } else {

    }
#line 1810
    tmp___0 = qla2x00_get_fw_options(vha, (uint16_t *)(& ha->fw_options));
#line 1810
    if (tmp___0 != 0) {
#line 1812
      ql_log(1U, vha, 28681, "Unable to update fw options (beacon on).\n");
#line 1814
      return (258);
    } else {

    }
#line 1817
    if ((ha->device_type & 32768U) != 0U || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 1818
      goto skip_gpio;
    } else {

    }
#line 1820
    tmp___1 = spinlock_check(& ha->hardware_lock);
#line 1820
    flags = _raw_spin_lock_irqsave(tmp___1);
#line 1821
    gpio_data = readl((void const volatile   *)(& reg->gpiod));
#line 1824
    gpio_data = gpio_data | 1835008U;
#line 1825
    writel(gpio_data, (void volatile   *)(& reg->gpiod));
#line 1826
    readl((void const volatile   *)(& reg->gpiod));
#line 1828
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
  } else {

  }
#line 1832
  ha->beacon_color_state = 0U;
  skip_gpio: 
#line 1836
  ha->beacon_blink_led = 1U;
#line 1838
  return (0);
}
}
#line 1842 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
int qla24xx_beacon_off(struct scsi_qla_host *vha ) 
{ 
  uint32_t gpio_data ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1846
  ha = vha->hw;
#line 1847
  reg = & (ha->iobase)->isp24;
#line 1849
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1850
    return (0);
  } else {

  }
#line 1852
  ha->beacon_blink_led = 0U;
#line 1854
  if ((ha->device_type & 32768U) != 0U || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 1855
    goto set_fw_options;
  } else {

  }
#line 1857
  if ((ha->device_type & 65536U) != 0U || (ha->device_type & 8192U) != 0U) {
#line 1858
    return (0);
  } else {

  }
#line 1860
  ha->beacon_color_state = 7U;
#line 1862
  (*((ha->isp_ops)->beacon_blink))(vha);
#line 1865
  tmp = spinlock_check(& ha->hardware_lock);
#line 1865
  flags = _raw_spin_lock_irqsave(tmp);
#line 1866
  gpio_data = readl((void const volatile   *)(& reg->gpiod));
#line 1869
  gpio_data = gpio_data & 4293132287U;
#line 1870
  writel(gpio_data, (void volatile   *)(& reg->gpiod));
#line 1871
  readl((void const volatile   *)(& reg->gpiod));
#line 1872
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
  set_fw_options: 
#line 1875
  ha->fw_options[1] = (unsigned int )ha->fw_options[1] & 65471U;
#line 1877
  tmp___0 = qla2x00_set_fw_options(vha, (uint16_t *)(& ha->fw_options));
#line 1877
  if (tmp___0 != 0) {
#line 1878
    ql_log(1U, vha, 28749, "Unable to update fw options (beacon on).\n");
#line 1880
    return (258);
  } else {

  }
#line 1883
  tmp___1 = qla2x00_get_fw_options(vha, (uint16_t *)(& ha->fw_options));
#line 1883
  if (tmp___1 != 0) {
#line 1884
    ql_log(1U, vha, 28750, "Unable to update fw options (beacon on).\n");
#line 1886
    return (258);
  } else {

  }
#line 1889
  return (0);
}
}
#line 1902 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static void qla2x00_flash_enable(struct qla_hw_data *ha ) 
{ 
  uint16_t data ;
  struct device_reg_2xxx *reg ;

  {
#line 1905
  reg = & (ha->iobase)->isp;
#line 1907
  data = readw((void const volatile   *)(& reg->ctrl_status));
#line 1908
  data = (uint16_t )((unsigned int )data | 2U);
#line 1909
  writew((int )data, (void volatile   *)(& reg->ctrl_status));
#line 1910
  readw((void const volatile   *)(& reg->ctrl_status));
#line 1911
  return;
}
}
#line 1918 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static void qla2x00_flash_disable(struct qla_hw_data *ha ) 
{ 
  uint16_t data ;
  struct device_reg_2xxx *reg ;

  {
#line 1921
  reg = & (ha->iobase)->isp;
#line 1923
  data = readw((void const volatile   *)(& reg->ctrl_status));
#line 1924
  data = (unsigned int )data & 65533U;
#line 1925
  writew((int )data, (void volatile   *)(& reg->ctrl_status));
#line 1926
  readw((void const volatile   *)(& reg->ctrl_status));
#line 1927
  return;
}
}
#line 1939 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static uint8_t qla2x00_read_flash_byte(struct qla_hw_data *ha , uint32_t addr ) 
{ 
  uint16_t data ;
  uint16_t bank_select ;
  struct device_reg_2xxx *reg ;
  uint16_t data2 ;

  {
#line 1943
  reg = & (ha->iobase)->isp;
#line 1945
  bank_select = readw((void const volatile   *)(& reg->ctrl_status));
#line 1947
  if ((ha->device_type & 16U) != 0U || (ha->device_type & 64U) != 0U) {
#line 1950
    bank_select = (unsigned int )bank_select & 65287U;
#line 1951
    bank_select = ((unsigned int )((uint16_t )(addr >> 12)) & 240U) | (unsigned int )bank_select;
#line 1952
    bank_select = (uint16_t )((unsigned int )bank_select | 8U);
#line 1953
    writew((int )bank_select, (void volatile   *)(& reg->ctrl_status));
#line 1954
    readw((void const volatile   *)(& reg->ctrl_status));
#line 1956
    writew((int )((unsigned short )addr), (void volatile   *)(& reg->flash_address));
#line 1957
    data = readw((void const volatile   *)(& reg->flash_data));
#line 1959
    return ((uint8_t )data);
  } else {

  }
#line 1963
  if ((addr & 65536U) != 0U && ((int )bank_select & 8) == 0) {
#line 1964
    bank_select = (uint16_t )((unsigned int )bank_select | 8U);
#line 1965
    writew((int )bank_select, (void volatile   *)(& reg->ctrl_status));
#line 1966
    readw((void const volatile   *)(& reg->ctrl_status));
  } else
#line 1967
  if ((addr & 65536U) == 0U && ((int )bank_select & 8) != 0) {
#line 1969
    bank_select = (unsigned int )bank_select & 65527U;
#line 1970
    writew((int )bank_select, (void volatile   *)(& reg->ctrl_status));
#line 1971
    readw((void const volatile   *)(& reg->ctrl_status));
  } else {

  }
#line 1975
  if (ha->pio_address != 0ULL) {
#line 1978
    outw((int )((unsigned short )addr), (int )ha->pio_address);
    ldv_66455: 
#line 1980
    data = inw((int )((unsigned int )ha->pio_address + 2U));
#line 1981
    __asm__  volatile   ("": : : "memory");
#line 1982
    cpu_relax();
#line 1983
    data2 = inw((int )((unsigned int )ha->pio_address + 2U));
#line 1984
    if ((int )data != (int )data2) {
#line 1986
      goto ldv_66455;
    } else {

    }

  } else {
#line 1986
    writew((int )((unsigned short )addr), (void volatile   *)(& reg->flash_address));
#line 1987
    data = qla2x00_debounce_register___0((uint16_t volatile   *)(& reg->flash_data));
  }
#line 1990
  return ((uint8_t )data);
}
}
#line 2000 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static void qla2x00_write_flash_byte(struct qla_hw_data *ha , uint32_t addr , uint8_t data ) 
{ 
  uint16_t bank_select ;
  struct device_reg_2xxx *reg ;

  {
#line 2003
  reg = & (ha->iobase)->isp;
#line 2005
  bank_select = readw((void const volatile   *)(& reg->ctrl_status));
#line 2006
  if ((ha->device_type & 16U) != 0U || (ha->device_type & 64U) != 0U) {
#line 2009
    bank_select = (unsigned int )bank_select & 65287U;
#line 2010
    bank_select = ((unsigned int )((uint16_t )(addr >> 12)) & 240U) | (unsigned int )bank_select;
#line 2011
    bank_select = (uint16_t )((unsigned int )bank_select | 8U);
#line 2012
    writew((int )bank_select, (void volatile   *)(& reg->ctrl_status));
#line 2013
    readw((void const volatile   *)(& reg->ctrl_status));
#line 2015
    writew((int )((unsigned short )addr), (void volatile   *)(& reg->flash_address));
#line 2016
    readw((void const volatile   *)(& reg->ctrl_status));
#line 2017
    writew((int )data, (void volatile   *)(& reg->flash_data));
#line 2018
    readw((void const volatile   *)(& reg->ctrl_status));
#line 2020
    return;
  } else {

  }
#line 2024
  if ((addr & 65536U) != 0U && ((int )bank_select & 8) == 0) {
#line 2025
    bank_select = (uint16_t )((unsigned int )bank_select | 8U);
#line 2026
    writew((int )bank_select, (void volatile   *)(& reg->ctrl_status));
#line 2027
    readw((void const volatile   *)(& reg->ctrl_status));
  } else
#line 2028
  if ((addr & 65536U) == 0U && ((int )bank_select & 8) != 0) {
#line 2030
    bank_select = (unsigned int )bank_select & 65527U;
#line 2031
    writew((int )bank_select, (void volatile   *)(& reg->ctrl_status));
#line 2032
    readw((void const volatile   *)(& reg->ctrl_status));
  } else {

  }
#line 2036
  if (ha->pio_address != 0ULL) {
#line 2037
    outw((int )((unsigned short )addr), (int )ha->pio_address);
#line 2038
    outw((int )data, (int )((unsigned int )ha->pio_address + 2U));
  } else {
#line 2040
    writew((int )((unsigned short )addr), (void volatile   *)(& reg->flash_address));
#line 2041
    readw((void const volatile   *)(& reg->ctrl_status));
#line 2042
    writew((int )data, (void volatile   *)(& reg->flash_data));
#line 2043
    readw((void const volatile   *)(& reg->ctrl_status));
  }
#line 2045
  return;
}
}
#line 2063 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static int qla2x00_poll_flash(struct qla_hw_data *ha , uint32_t addr , uint8_t poll_data ,
                              uint8_t man_id , uint8_t flash_id ) 
{ 
  int status ;
  uint8_t flash_data ;
  uint32_t cnt ;

  {
#line 2070
  status = 1;
#line 2073
  poll_data = (unsigned int )poll_data & 128U;
#line 2074
  cnt = 3000000U;
#line 2074
  goto ldv_66477;
  ldv_66476: 
#line 2075
  flash_data = qla2x00_read_flash_byte(ha, addr);
#line 2076
  if (((int )flash_data & 128) == (int )poll_data) {
#line 2077
    status = 0;
#line 2078
    goto ldv_66474;
  } else {

  }
#line 2081
  if ((unsigned int )man_id != 64U && (unsigned int )man_id != 218U) {
#line 2082
    if (((int )flash_data & 32) != 0 && cnt > 2U) {
#line 2083
      cnt = 2U;
    } else {

    }
  } else {

  }
#line 2085
  __const_udelay(42950UL);
#line 2086
  __asm__  volatile   ("": : : "memory");
#line 2087
  ___might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c",
                 2087, 0);
#line 2087
  _cond_resched();
#line 2074
  cnt = cnt - 1U;
  ldv_66477: ;
#line 2074
  if (cnt != 0U) {
#line 2076
    goto ldv_66476;
  } else {

  }
  ldv_66474: ;
#line 2089
  return (status);
}
}
#line 2103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static int qla2x00_program_flash_address(struct qla_hw_data *ha , uint32_t addr ,
                                         uint8_t data , uint8_t man_id , uint8_t flash_id ) 
{ 
  int tmp ;

  {
#line 2107
  if ((ha->device_type & 536870912U) != 0U) {
#line 2108
    qla2x00_write_flash_byte(ha, 2730U, 170);
#line 2109
    qla2x00_write_flash_byte(ha, 1365U, 85);
#line 2110
    qla2x00_write_flash_byte(ha, 2730U, 160);
#line 2111
    qla2x00_write_flash_byte(ha, addr, (int )data);
  } else
#line 2113
  if ((unsigned int )man_id == 218U && (unsigned int )flash_id == 193U) {
#line 2114
    qla2x00_write_flash_byte(ha, addr, (int )data);
#line 2115
    if ((addr & 126U) != 0U) {
#line 2116
      return (0);
    } else {

    }
  } else {
#line 2118
    qla2x00_write_flash_byte(ha, 21845U, 170);
#line 2119
    qla2x00_write_flash_byte(ha, 10922U, 85);
#line 2120
    qla2x00_write_flash_byte(ha, 21845U, 160);
#line 2121
    qla2x00_write_flash_byte(ha, addr, (int )data);
  }
#line 2125
  __const_udelay(644250UL);
#line 2128
  tmp = qla2x00_poll_flash(ha, addr, (int )data, (int )man_id, (int )flash_id);
#line 2128
  return (tmp);
}
}
#line 2140 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static int qla2x00_erase_flash(struct qla_hw_data *ha , uint8_t man_id , uint8_t flash_id ) 
{ 
  int tmp ;

  {
#line 2143
  if ((ha->device_type & 536870912U) != 0U) {
#line 2144
    qla2x00_write_flash_byte(ha, 2730U, 170);
#line 2145
    qla2x00_write_flash_byte(ha, 1365U, 85);
#line 2146
    qla2x00_write_flash_byte(ha, 2730U, 128);
#line 2147
    qla2x00_write_flash_byte(ha, 2730U, 170);
#line 2148
    qla2x00_write_flash_byte(ha, 1365U, 85);
#line 2149
    qla2x00_write_flash_byte(ha, 2730U, 16);
  } else {
#line 2151
    qla2x00_write_flash_byte(ha, 21845U, 170);
#line 2152
    qla2x00_write_flash_byte(ha, 10922U, 85);
#line 2153
    qla2x00_write_flash_byte(ha, 21845U, 128);
#line 2154
    qla2x00_write_flash_byte(ha, 21845U, 170);
#line 2155
    qla2x00_write_flash_byte(ha, 10922U, 85);
#line 2156
    qla2x00_write_flash_byte(ha, 21845U, 16);
  }
#line 2159
  __const_udelay(644250UL);
#line 2162
  tmp = qla2x00_poll_flash(ha, 0U, 128, (int )man_id, (int )flash_id);
#line 2162
  return (tmp);
}
}
#line 2176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static int qla2x00_erase_flash_sector(struct qla_hw_data *ha , uint32_t addr , uint32_t sec_mask ,
                                      uint8_t man_id , uint8_t flash_id ) 
{ 
  int tmp ;

  {
#line 2180
  qla2x00_write_flash_byte(ha, 21845U, 170);
#line 2181
  qla2x00_write_flash_byte(ha, 10922U, 85);
#line 2182
  qla2x00_write_flash_byte(ha, 21845U, 128);
#line 2183
  qla2x00_write_flash_byte(ha, 21845U, 170);
#line 2184
  qla2x00_write_flash_byte(ha, 10922U, 85);
#line 2185
  if ((unsigned int )man_id == 31U && (unsigned int )flash_id == 19U) {
#line 2186
    qla2x00_write_flash_byte(ha, addr & sec_mask, 16);
  } else {
#line 2188
    qla2x00_write_flash_byte(ha, addr & sec_mask, 48);
  }
#line 2190
  __const_udelay(644250UL);
#line 2193
  tmp = qla2x00_poll_flash(ha, addr, 128, (int )man_id, (int )flash_id);
#line 2193
  return (tmp);
}
}
#line 2202 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static void qla2x00_get_flash_manufacturer(struct qla_hw_data *ha , uint8_t *man_id ,
                                           uint8_t *flash_id ) 
{ 


  {
#line 2205
  qla2x00_write_flash_byte(ha, 21845U, 170);
#line 2206
  qla2x00_write_flash_byte(ha, 10922U, 85);
#line 2207
  qla2x00_write_flash_byte(ha, 21845U, 144);
#line 2208
  *man_id = qla2x00_read_flash_byte(ha, 0U);
#line 2209
  *flash_id = qla2x00_read_flash_byte(ha, 1U);
#line 2210
  qla2x00_write_flash_byte(ha, 21845U, 170);
#line 2211
  qla2x00_write_flash_byte(ha, 10922U, 85);
#line 2212
  qla2x00_write_flash_byte(ha, 21845U, 240);
#line 2213
  return;
}
}
#line 2216 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static void qla2x00_read_flash_data(struct qla_hw_data *ha , uint8_t *tmp_buf , uint32_t saddr ,
                                    uint32_t length ) 
{ 
  struct device_reg_2xxx *reg ;
  uint32_t midpoint ;
  uint32_t ilength ;
  uint8_t data ;

  {
#line 2219
  reg = & (ha->iobase)->isp;
#line 2223
  midpoint = length / 2U;
#line 2225
  writew(0, (void volatile   *)(& reg->nvram));
#line 2226
  readw((void const volatile   *)(& reg->nvram));
#line 2227
  ilength = 0U;
#line 2227
  goto ldv_66514;
  ldv_66513: ;
#line 2228
  if (ilength == midpoint) {
#line 2229
    writew(2, (void volatile   *)(& reg->nvram));
#line 2230
    readw((void const volatile   *)(& reg->nvram));
  } else {

  }
#line 2232
  data = qla2x00_read_flash_byte(ha, saddr);
#line 2233
  if (saddr % 100U != 0U) {
#line 2234
    __const_udelay(42950UL);
  } else {

  }
#line 2235
  *tmp_buf = data;
#line 2236
  ___might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c",
                 2236, 0);
#line 2236
  _cond_resched();
#line 2227
  saddr = saddr + 1U;
#line 2227
  ilength = ilength + 1U;
#line 2227
  tmp_buf = tmp_buf + 1;
  ldv_66514: ;
#line 2227
  if (ilength < length) {
#line 2229
    goto ldv_66513;
  } else {

  }

#line 2234
  return;
}
}
#line 2241 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
__inline static void qla2x00_suspend_hba(struct scsi_qla_host *vha ) 
{ 
  int cnt ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  raw_spinlock_t *tmp ;
  unsigned short tmp___0 ;

  {
#line 2245
  ha = vha->hw;
#line 2246
  reg = & (ha->iobase)->isp;
#line 2249
  scsi_block_requests(vha->host);
#line 2250
  (*((ha->isp_ops)->disable_intrs))(ha);
#line 2251
  set_bit(3L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 2254
  tmp = spinlock_check(& ha->hardware_lock);
#line 2254
  flags = _raw_spin_lock_irqsave(tmp);
#line 2255
  writew(8192, (void volatile   *)(& reg->hccr));
#line 2256
  readw((void const volatile   *)(& reg->hccr));
#line 2257
  if (((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) || (ha->device_type & 4U) != 0U) {
#line 2258
    cnt = 0;
#line 2258
    goto ldv_66528;
    ldv_66527: 
#line 2259
    tmp___0 = readw((void const volatile   *)(& reg->hccr));
#line 2259
    if (((int )tmp___0 & 32) != 0) {
#line 2260
      goto ldv_66526;
    } else {

    }
#line 2261
    __const_udelay(429500UL);
#line 2258
    cnt = cnt + 1;
    ldv_66528: ;
#line 2258
    if (cnt <= 29999) {
#line 2260
      goto ldv_66527;
    } else {

    }
    ldv_66526: ;
  } else {
#line 2264
    __const_udelay(42950UL);
  }
#line 2266
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2267
  return;
}
}
#line 2270 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
__inline static void qla2x00_resume_hba(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 2272
  ha = vha->hw;
#line 2275
  clear_bit(3L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 2276
  set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2277
  qla2xxx_wake_dpc(vha);
#line 2278
  qla2x00_wait_for_chip_reset(vha);
#line 2279
  scsi_unblock_requests(vha->host);
#line 2280
  return;
}
}
#line 2283 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
uint8_t *qla2x00_read_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                                  uint32_t length ) 
{ 
  uint32_t addr ;
  uint32_t midpoint ;
  uint8_t *data ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;

  {
#line 2288
  ha = vha->hw;
#line 2289
  reg = & (ha->iobase)->isp;
#line 2292
  qla2x00_suspend_hba(vha);
#line 2295
  midpoint = ha->optrom_size / 2U;
#line 2297
  qla2x00_flash_enable(ha);
#line 2298
  writew(0, (void volatile   *)(& reg->nvram));
#line 2299
  readw((void const volatile   *)(& reg->nvram));
#line 2300
  addr = offset;
#line 2300
  data = buf;
#line 2300
  goto ldv_66545;
  ldv_66544: ;
#line 2301
  if (addr == midpoint) {
#line 2302
    writew(2, (void volatile   *)(& reg->nvram));
#line 2303
    readw((void const volatile   *)(& reg->nvram));
  } else {

  }
#line 2306
  *data = qla2x00_read_flash_byte(ha, addr);
#line 2300
  addr = addr + 1U;
#line 2300
  data = data + 1;
  ldv_66545: ;
#line 2300
  if (addr < length) {
#line 2302
    goto ldv_66544;
  } else {

  }
#line 2308
  qla2x00_flash_disable(ha);
#line 2311
  qla2x00_resume_hba(vha);
#line 2313
  return (buf);
}
}
#line 2317 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
int qla2x00_write_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                              uint32_t length ) 
{ 
  int rval ;
  uint8_t man_id ;
  uint8_t flash_id ;
  uint8_t sec_number ;
  uint8_t data ;
  uint16_t wd ;
  uint32_t addr ;
  uint32_t liter ;
  uint32_t sec_mask ;
  uint32_t rest_addr ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2325
  ha = vha->hw;
#line 2326
  reg = & (ha->iobase)->isp;
#line 2329
  qla2x00_suspend_hba(vha);
#line 2331
  rval = 0;
#line 2332
  sec_number = 0U;
#line 2335
  writew(1, (void volatile   *)(& reg->ctrl_status));
#line 2336
  pci_read_config_word((struct pci_dev  const  *)ha->pdev, 4, & wd);
#line 2339
  qla2x00_flash_enable(ha);
#line 2342
  if ((ha->device_type & 536870912U) != 0U) {
#line 2344
    flash_id = 0U;
#line 2344
    man_id = flash_id;
#line 2345
    rest_addr = 65535U;
#line 2346
    sec_mask = 65536U;
#line 2347
    goto update_flash;
  } else {

  }
#line 2349
  qla2x00_get_flash_manufacturer(ha, & man_id, & flash_id);
#line 2350
  switch ((int )man_id) {
  case 32: ;
#line 2352
  if ((unsigned int )flash_id == 210U || (unsigned int )flash_id == 227U) {
#line 2358
    rest_addr = 65535U;
#line 2359
    sec_mask = 65536U;
#line 2360
    goto ldv_66567;
  } else {

  }
#line 2366
  rest_addr = 16383U;
#line 2367
  sec_mask = 114688U;
#line 2368
  goto ldv_66567;
  case 64: 
#line 2371
  rest_addr = 511U;
#line 2372
  sec_mask = 130560U;
#line 2373
  goto ldv_66567;
  case 191: 
#line 2376
  rest_addr = 4095U;
#line 2377
  sec_mask = 126976U;
#line 2378
  goto ldv_66567;
  case 218: 
#line 2381
  rest_addr = 127U;
#line 2382
  sec_mask = 130944U;
#line 2383
  goto ldv_66567;
  case 194: ;
#line 2386
  if ((unsigned int )flash_id == 56U || (unsigned int )flash_id == 79U) {
#line 2387
    rest_addr = 65535U;
#line 2388
    sec_mask = 65536U;
#line 2389
    goto ldv_66567;
  } else {

  }
  case 31: ;
#line 2395
  if ((unsigned int )flash_id == 19U) {
#line 2396
    rest_addr = 2147483647U;
#line 2397
    sec_mask = 2147483648U;
#line 2398
    goto ldv_66567;
  } else {

  }
  case 1: ;
#line 2403
  if (((unsigned int )flash_id == 56U || (unsigned int )flash_id == 64U) || (unsigned int )flash_id == 79U) {
#line 2407
    rest_addr = 65535U;
#line 2408
    sec_mask = 65536U;
#line 2409
    goto ldv_66567;
  } else
#line 2410
  if ((unsigned int )flash_id == 62U) {
#line 2416
    rest_addr = 65535U;
#line 2417
    sec_mask = 65536U;
#line 2418
    goto ldv_66567;
  } else
#line 2419
  if ((unsigned int )flash_id == 32U || (unsigned int )flash_id == 110U) {
#line 2424
    rest_addr = 16383U;
#line 2425
    sec_mask = 114688U;
#line 2426
    goto ldv_66567;
  } else
#line 2427
  if ((unsigned int )flash_id == 109U) {
#line 2429
    rest_addr = 8191U;
#line 2430
    sec_mask = 122880U;
#line 2431
    goto ldv_66567;
  } else {

  }
  default: 
#line 2435
  rest_addr = 16383U;
#line 2436
  sec_mask = 114688U;
#line 2437
  goto ldv_66567;
  }
  ldv_66567: ;
  update_flash: ;
#line 2441
  if ((ha->device_type & 16U) != 0U || (ha->device_type & 64U) != 0U) {
#line 2442
    tmp = qla2x00_erase_flash(ha, (int )man_id, (int )flash_id);
#line 2442
    if (tmp != 0) {
#line 2443
      rval = 258;
#line 2444
      goto ldv_66575;
    } else {

    }
  } else {

  }
#line 2448
  addr = offset;
#line 2448
  liter = 0U;
#line 2448
  goto ldv_66579;
  ldv_66578: 
#line 2450
  data = *(buf + (unsigned long )liter);
#line 2452
  if ((addr & rest_addr) == 0U) {
#line 2453
    if ((ha->device_type & 16U) != 0U || (ha->device_type & 64U) != 0U) {
#line 2454
      if (addr > 65535U) {
#line 2455
        if (((addr >> 12) & 240U) != 0U && (((unsigned int )man_id == 1U && (unsigned int )flash_id == 62U) || ((unsigned int )man_id == 32U && (unsigned int )flash_id == 210U))) {
#line 2460
          sec_number = (uint8_t )((int )sec_number + 1);
#line 2461
          if ((unsigned int )sec_number == 1U) {
#line 2462
            rest_addr = 32767U;
#line 2464
            sec_mask = 98304U;
          } else
#line 2466
          if ((unsigned int )sec_number == 2U || (unsigned int )sec_number == 3U) {
#line 2469
            rest_addr = 8191U;
#line 2471
            sec_mask = 122880U;
          } else
#line 2473
          if ((unsigned int )sec_number == 4U) {
#line 2475
            rest_addr = 16383U;
#line 2477
            sec_mask = 114688U;
          } else {

          }
        } else {

        }
      } else {

      }
    } else
#line 2482
    if (ha->optrom_size / 2U == addr) {
#line 2483
      writew(2, (void volatile   *)(& reg->nvram));
#line 2484
      readw((void const volatile   *)(& reg->nvram));
    } else {

    }
#line 2487
    if ((unsigned int )flash_id == 218U && (unsigned int )man_id == 193U) {
#line 2488
      qla2x00_write_flash_byte(ha, 21845U, 170);
#line 2490
      qla2x00_write_flash_byte(ha, 10922U, 85);
#line 2492
      qla2x00_write_flash_byte(ha, 21845U, 160);
    } else
#line 2494
    if ((ha->device_type & 16U) == 0U && (ha->device_type & 64U) == 0U) {
#line 2496
      tmp___0 = qla2x00_erase_flash_sector(ha, addr, sec_mask, (int )man_id, (int )flash_id);
#line 2496
      if (tmp___0 != 0) {
#line 2499
        rval = 258;
#line 2500
        goto ldv_66576;
      } else {

      }
#line 2502
      if ((unsigned int )man_id == 1U && (unsigned int )flash_id == 109U) {
#line 2503
        sec_number = (uint8_t )((int )sec_number + 1);
      } else {

      }
    } else {

    }
  } else {

  }
#line 2507
  if ((unsigned int )man_id == 1U && (unsigned int )flash_id == 109U) {
#line 2508
    if ((unsigned int )sec_number == 1U && rest_addr - 1U == addr) {
#line 2510
      rest_addr = 4095U;
#line 2511
      sec_mask = 126976U;
    } else
#line 2512
    if ((unsigned int )sec_number == 3U && (addr & 32766U) != 0U) {
#line 2513
      rest_addr = 16383U;
#line 2514
      sec_mask = 114688U;
    } else {

    }
  } else {

  }
#line 2518
  tmp___1 = qla2x00_program_flash_address(ha, addr, (int )data, (int )man_id, (int )flash_id);
#line 2518
  if (tmp___1 != 0) {
#line 2520
    rval = 258;
#line 2521
    goto ldv_66576;
  } else {

  }
#line 2523
  ___might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c",
                 2523, 0);
#line 2523
  _cond_resched();
#line 2448
  liter = liter + 1U;
#line 2448
  addr = addr + 1U;
  ldv_66579: ;
#line 2448
  if (liter < length) {
#line 2450
    goto ldv_66578;
  } else {

  }
  ldv_66576: ;
  ldv_66575: 
#line 2526
  qla2x00_flash_disable(ha);
#line 2529
  qla2x00_resume_hba(vha);
#line 2531
  return (rval);
}
}
#line 2535 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
uint8_t *qla24xx_read_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                                  uint32_t length ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 2538
  ha = vha->hw;
#line 2541
  scsi_block_requests(vha->host);
#line 2542
  set_bit(3L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 2545
  qla24xx_read_flash_data(vha, (uint32_t *)buf, offset >> 2, length >> 2);
#line 2548
  clear_bit(3L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 2549
  scsi_unblock_requests(vha->host);
#line 2551
  return (buf);
}
}
#line 2555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
int qla24xx_write_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                              uint32_t length ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;

  {
#line 2559
  ha = vha->hw;
#line 2562
  scsi_block_requests(vha->host);
#line 2563
  set_bit(3L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 2566
  rval = qla24xx_write_flash_data(vha, (uint32_t *)buf, offset >> 2, length >> 2);
#line 2569
  clear_bit(3L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 2570
  scsi_unblock_requests(vha->host);
#line 2572
  return (rval);
}
}
#line 2576 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
uint8_t *qla25xx_read_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                                  uint32_t length ) 
{ 
  int rval ;
  dma_addr_t optrom_dma ;
  void *optrom ;
  uint8_t *pbuf ;
  uint32_t faddr ;
  uint32_t left ;
  uint32_t burst ;
  struct qla_hw_data *ha ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint8_t *tmp___1 ;

  {
#line 2584
  ha = vha->hw;
#line 2586
  if ((((ha->device_type & 2048U) != 0U || (ha->device_type & 8192U) != 0U) || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 2588
    goto try_fast;
  } else {

  }
#line 2589
  if ((offset & 4095U) != 0U) {
#line 2590
    goto slow_read;
  } else {

  }
#line 2591
  if (length <= 4095U) {
#line 2592
    goto slow_read;
  } else {

  }
  try_fast: 
#line 2595
  optrom = dma_alloc_attrs(& (ha->pdev)->dev, 4096UL, & optrom_dma, 208U, (struct dma_attrs *)0);
#line 2597
  if ((unsigned long )optrom == (unsigned long )((void *)0)) {
#line 2598
    ql_log(1U, vha, 204, "Unable to allocate memory for optrom burst read (%x KB).\n",
           4);
#line 2601
    goto slow_read;
  } else {

  }
#line 2604
  pbuf = buf;
#line 2605
  faddr = offset >> 2;
#line 2606
  left = length >> 2;
#line 2607
  burst = 1024U;
#line 2608
  goto ldv_66612;
  ldv_66611: ;
#line 2609
  if (burst > left) {
#line 2610
    burst = left;
  } else {

  }
#line 2612
  tmp = flash_data_addr(ha, faddr);
#line 2612
  rval = qla2x00_dump_ram(vha, optrom_dma, tmp, burst);
#line 2614
  if (rval != 0) {
#line 2615
    tmp___0 = flash_data_addr(ha, faddr);
#line 2615
    ql_log(1U, vha, 245, "Unable to burst-read optrom segment (%x/%x/%llx).\n", rval,
           tmp___0, optrom_dma);
#line 2619
    ql_log(1U, vha, 246, "Reverting to slow-read.\n");
#line 2622
    dma_free_attrs(& (ha->pdev)->dev, 4096UL, optrom, optrom_dma, (struct dma_attrs *)0);
#line 2624
    goto slow_read;
  } else {

  }
#line 2627
  memcpy((void *)pbuf, (void const   *)optrom, (size_t )(burst * 4U));
#line 2629
  left = left - burst;
#line 2630
  faddr = faddr + burst;
#line 2631
  pbuf = pbuf + (unsigned long )(burst * 4U);
  ldv_66612: ;
#line 2608
  if (left != 0U) {
#line 2610
    goto ldv_66611;
  } else {

  }
#line 2634
  dma_free_attrs(& (ha->pdev)->dev, 4096UL, optrom, optrom_dma, (struct dma_attrs *)0);
#line 2637
  return (buf);
  slow_read: 
#line 2640
  tmp___1 = qla24xx_read_optrom_data(vha, buf, offset, length);
#line 2640
  return (tmp___1);
}
}
#line 2662 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static void qla2x00_get_fcode_version(struct qla_hw_data *ha , uint32_t pcids ) 
{ 
  int ret ;
  uint32_t istart ;
  uint32_t iend ;
  uint32_t iter ;
  uint32_t vend ;
  uint8_t do_next ;
  uint8_t rbyte ;
  uint8_t *vbyte ;
  uint8_t tmp ;
  uint8_t tmp___0 ;
  uint8_t tmp___1 ;
  uint8_t tmp___2 ;
  uint8_t tmp___3 ;
  uint8_t tmp___4 ;
  uint8_t *tmp___5 ;

  {
#line 2664
  ret = 258;
#line 2668
  memset((void *)(& ha->fcode_revision), 0, 16UL);
#line 2671
  tmp = qla2x00_read_flash_byte(ha, pcids + 11U);
#line 2671
  tmp___0 = qla2x00_read_flash_byte(ha, pcids + 10U);
#line 2671
  istart = (uint32_t )(((int )tmp << 8) | (int )tmp___0) + pcids;
#line 2674
  iend = istart + 256U;
#line 2677
  do_next = 0U;
#line 2678
  iter = istart;
#line 2679
  goto ldv_66627;
  ldv_66626: 
#line 2680
  iter = iter + 1U;
#line 2681
  tmp___3 = qla2x00_read_flash_byte(ha, iter);
#line 2681
  if ((unsigned int )tmp___3 == 47U) {
#line 2682
    tmp___2 = qla2x00_read_flash_byte(ha, iter + 2U);
#line 2682
    if ((unsigned int )tmp___2 == 47U) {
#line 2684
      do_next = (uint8_t )((int )do_next + 1);
    } else {
#line 2685
      tmp___1 = qla2x00_read_flash_byte(ha, iter + 3U);
#line 2685
      if ((unsigned int )tmp___1 == 47U) {
#line 2687
        do_next = (uint8_t )((int )do_next + 1);
      } else {

      }
    }
  } else {

  }
  ldv_66627: ;
#line 2679
  if (iter < iend && (unsigned int )do_next == 0U) {
#line 2681
    goto ldv_66626;
  } else {

  }

#line 2690
  if ((unsigned int )do_next == 0U) {
#line 2691
    goto ldv_66629;
  } else {

  }
#line 2694
  do_next = 0U;
#line 2695
  goto ldv_66631;
  ldv_66630: 
#line 2696
  iter = iter - 1U;
#line 2697
  tmp___4 = qla2x00_read_flash_byte(ha, iter);
#line 2697
  if ((unsigned int )tmp___4 == 32U) {
#line 2698
    do_next = (uint8_t )((int )do_next + 1);
  } else {

  }
  ldv_66631: ;
#line 2695
  if (iter > istart && (unsigned int )do_next == 0U) {
#line 2697
    goto ldv_66630;
  } else {

  }

#line 2700
  if ((unsigned int )do_next == 0U) {
#line 2701
    goto ldv_66629;
  } else {

  }
#line 2707
  vend = iter - 1U;
#line 2708
  do_next = 0U;
#line 2709
  goto ldv_66634;
  ldv_66633: 
#line 2710
  iter = iter - 1U;
#line 2711
  rbyte = qla2x00_read_flash_byte(ha, iter);
#line 2712
  if (((unsigned int )rbyte == 32U || (unsigned int )rbyte == 13U) || (unsigned int )rbyte == 16U) {
#line 2713
    do_next = (uint8_t )((int )do_next + 1);
  } else {

  }
  ldv_66634: ;
#line 2709
  if (iter > istart && (unsigned int )do_next == 0U) {
#line 2711
    goto ldv_66633;
  } else {

  }

#line 2715
  if ((unsigned int )do_next == 0U) {
#line 2716
    goto ldv_66629;
  } else {

  }
#line 2719
  iter = iter + 1U;
#line 2720
  if (vend != iter && vend - iter <= 15U) {
#line 2722
    vbyte = (uint8_t *)(& ha->fcode_revision);
#line 2723
    goto ldv_66637;
    ldv_66636: 
#line 2724
    tmp___5 = vbyte;
#line 2724
    vbyte = vbyte + 1;
#line 2724
    *tmp___5 = qla2x00_read_flash_byte(ha, iter);
#line 2725
    iter = iter + 1U;
    ldv_66637: ;
#line 2723
    if (iter <= vend) {
#line 2725
      goto ldv_66636;
    } else {

    }
#line 2727
    ret = 0;
  } else {

  }
  ldv_66629: ;
#line 2731
  if (ret != 0) {
#line 2732
    memset((void *)(& ha->fcode_revision), 0, 16UL);
  } else {

  }
#line 2733
  return;
}
}
#line 2736 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
int qla2x00_get_flash_version(scsi_qla_host_t *vha , void *mbuf ) 
{ 
  int ret ;
  uint8_t code_type ;
  uint8_t last_image ;
  uint32_t pcihdr ;
  uint32_t pcids ;
  uint8_t *dbyte ;
  uint16_t *dcode ;
  struct qla_hw_data *ha ;
  uint8_t tmp ;
  uint8_t tmp___0 ;
  uint8_t tmp___1 ;
  uint8_t tmp___2 ;
  uint8_t tmp___3 ;
  uint8_t tmp___4 ;
  uint8_t tmp___5 ;
  uint8_t tmp___6 ;
  uint8_t tmp___7 ;
  uint8_t tmp___8 ;
  uint8_t tmp___9 ;

  {
#line 2738
  ret = 0;
#line 2743
  ha = vha->hw;
#line 2745
  if (ha->pio_address == 0ULL || (unsigned long )mbuf == (unsigned long )((void *)0)) {
#line 2746
    return (258);
  } else {

  }
#line 2748
  memset((void *)(& ha->bios_revision), 0, 2UL);
#line 2749
  memset((void *)(& ha->efi_revision), 0, 2UL);
#line 2750
  memset((void *)(& ha->fcode_revision), 0, 16UL);
#line 2751
  memset((void *)(& ha->fw_revision), 0, 16UL);
#line 2753
  qla2x00_flash_enable(ha);
#line 2756
  pcihdr = 0U;
#line 2757
  last_image = 1U;
  ldv_66657: 
#line 2760
  tmp = qla2x00_read_flash_byte(ha, pcihdr);
#line 2760
  if ((unsigned int )tmp != 85U) {
#line 2763
    ql_log(0U, vha, 80, "No matching ROM signature.\n");
#line 2765
    ret = 258;
#line 2766
    goto ldv_66651;
  } else {
#line 2760
    tmp___0 = qla2x00_read_flash_byte(ha, pcihdr + 1U);
#line 2760
    if ((unsigned int )tmp___0 != 170U) {
#line 2763
      ql_log(0U, vha, 80, "No matching ROM signature.\n");
#line 2765
      ret = 258;
#line 2766
      goto ldv_66651;
    } else {

    }
  }
#line 2770
  tmp___1 = qla2x00_read_flash_byte(ha, pcihdr + 25U);
#line 2770
  tmp___2 = qla2x00_read_flash_byte(ha, pcihdr + 24U);
#line 2770
  pcids = (uint32_t )(((int )tmp___1 << 8) | (int )tmp___2) + pcihdr;
#line 2775
  tmp___3 = qla2x00_read_flash_byte(ha, pcids);
#line 2775
  if ((unsigned int )tmp___3 != 80U) {
#line 2780
    ql_log(0U, vha, 81, "PCI data struct not found pcir_adr=%x.\n", pcids);
#line 2782
    ret = 258;
#line 2783
    goto ldv_66651;
  } else {
#line 2775
    tmp___4 = qla2x00_read_flash_byte(ha, pcids + 1U);
#line 2775
    if ((unsigned int )tmp___4 != 67U) {
#line 2780
      ql_log(0U, vha, 81, "PCI data struct not found pcir_adr=%x.\n", pcids);
#line 2782
      ret = 258;
#line 2783
      goto ldv_66651;
    } else {
#line 2775
      tmp___5 = qla2x00_read_flash_byte(ha, pcids + 2U);
#line 2775
      if ((unsigned int )tmp___5 != 73U) {
#line 2780
        ql_log(0U, vha, 81, "PCI data struct not found pcir_adr=%x.\n", pcids);
#line 2782
        ret = 258;
#line 2783
        goto ldv_66651;
      } else {
#line 2775
        tmp___6 = qla2x00_read_flash_byte(ha, pcids + 3U);
#line 2775
        if ((unsigned int )tmp___6 != 82U) {
#line 2780
          ql_log(0U, vha, 81, "PCI data struct not found pcir_adr=%x.\n", pcids);
#line 2782
          ret = 258;
#line 2783
          goto ldv_66651;
        } else {

        }
      }
    }
  }
#line 2787
  code_type = qla2x00_read_flash_byte(ha, pcids + 20U);
#line 2788
  switch ((int )code_type) {
  case 0: 
#line 2791
  ha->bios_revision[0] = qla2x00_read_flash_byte(ha, pcids + 18U);
#line 2793
  ha->bios_revision[1] = qla2x00_read_flash_byte(ha, pcids + 19U);
#line 2795
  ql_dbg(1073741824U, vha, 82, "Read BIOS %d.%d.\n", (int )ha->bios_revision[1], (int )ha->bios_revision[0]);
#line 2798
  goto ldv_66653;
  case 1: 
#line 2802
  qla2x00_get_fcode_version(ha, pcids);
#line 2803
  goto ldv_66653;
  case 3: 
#line 2806
  ha->efi_revision[0] = qla2x00_read_flash_byte(ha, pcids + 18U);
#line 2808
  ha->efi_revision[1] = qla2x00_read_flash_byte(ha, pcids + 19U);
#line 2810
  ql_dbg(1073741824U, vha, 83, "Read EFI %d.%d.\n", (int )ha->efi_revision[1], (int )ha->efi_revision[0]);
#line 2813
  goto ldv_66653;
  default: 
#line 2815
  ql_log(1U, vha, 84, "Unrecognized code type %x at pcids %x.\n", (int )code_type,
         pcids);
#line 2818
  goto ldv_66653;
  }
  ldv_66653: 
#line 2821
  tmp___7 = qla2x00_read_flash_byte(ha, pcids + 21U);
#line 2821
  last_image = (unsigned int )tmp___7 & 128U;
#line 2824
  tmp___8 = qla2x00_read_flash_byte(ha, pcids + 17U);
#line 2824
  tmp___9 = qla2x00_read_flash_byte(ha, pcids + 16U);
#line 2824
  pcihdr = (uint32_t )((((int )tmp___8 << 8) | (int )tmp___9) * 512) + pcihdr;
#line 2826
  if ((unsigned int )last_image == 0U) {
#line 2828
    goto ldv_66657;
  } else {

  }
  ldv_66651: ;
#line 2828
  if ((ha->device_type & 16U) != 0U) {
#line 2830
    memset((void *)(& ha->fw_revision), 0, 16UL);
#line 2831
    dbyte = (uint8_t *)mbuf;
#line 2832
    memset((void *)dbyte, 0, 8UL);
#line 2833
    dcode = (uint16_t *)dbyte;
#line 2835
    qla2x00_read_flash_data(ha, dbyte, ha->flt_region_fw * 4U + 10U, 8U);
#line 2837
    ql_dbg(1073872896U, vha, 266, "Dumping fw ver from flash:.\n");
#line 2840
    ql_dump_buffer(1073872896U, vha, 267, dbyte, 8U);
#line 2843
    if (((((unsigned int )*dcode == 65535U && (unsigned int )*(dcode + 1UL) == 65535U) && (unsigned int )*(dcode + 2UL) == 65535U) && (unsigned int )*(dcode + 3UL) == 65535U) || ((((unsigned int )*dcode == 0U && (unsigned int )*(dcode + 1UL) == 0U) && (unsigned int )*(dcode + 2UL) == 0U) && (unsigned int )*(dcode + 3UL) == 0U)) {
#line 2847
      ql_log(1U, vha, 87, "Unrecognized fw revision at %x.\n", ha->flt_region_fw * 4U);
    } else {
#line 2852
      ha->fw_revision[0] = (uint32_t )(((int )*dbyte << 16) | (int )*(dbyte + 1UL));
#line 2853
      ha->fw_revision[1] = (uint32_t )(((int )*(dbyte + 2UL) << 16) | (int )*(dbyte + 3UL));
#line 2854
      ha->fw_revision[2] = (uint32_t )(((int )*(dbyte + 4UL) << 16) | (int )*(dbyte + 5UL));
#line 2855
      ql_dbg(1073741824U, vha, 88, "FW Version: %d.%d.%d.\n", ha->fw_revision[0],
             ha->fw_revision[1], ha->fw_revision[2]);
    }
  } else {

  }
#line 2862
  qla2x00_flash_disable(ha);
#line 2864
  return (ret);
}
}
#line 2868 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
int qla82xx_get_flash_version(scsi_qla_host_t *vha , void *mbuf ) 
{ 
  int ret ;
  uint32_t pcihdr ;
  uint32_t pcids ;
  uint32_t *dcode ;
  uint8_t *bcode ;
  uint8_t code_type ;
  uint8_t last_image ;
  struct qla_hw_data *ha ;

  {
#line 2870
  ret = 0;
#line 2875
  ha = vha->hw;
#line 2877
  if ((unsigned long )mbuf == (unsigned long )((void *)0)) {
#line 2878
    return (258);
  } else {

  }
#line 2880
  memset((void *)(& ha->bios_revision), 0, 2UL);
#line 2881
  memset((void *)(& ha->efi_revision), 0, 2UL);
#line 2882
  memset((void *)(& ha->fcode_revision), 0, 16UL);
#line 2883
  memset((void *)(& ha->fw_revision), 0, 16UL);
#line 2885
  dcode = (uint32_t *)mbuf;
#line 2888
  pcihdr = ha->flt_region_boot << 2;
#line 2889
  last_image = 1U;
  ldv_66676: 
#line 2892
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)dcode, pcihdr, 128U);
#line 2894
  bcode = (uint8_t *)(mbuf + ((unsigned long )pcihdr & 3UL));
#line 2895
  if ((unsigned int )*bcode != 85U || (unsigned int )*(bcode + 1UL) != 170U) {
#line 2897
    ql_log(0U, vha, 340, "No matching ROM signature.\n");
#line 2899
    ret = 258;
#line 2900
    goto ldv_66670;
  } else {

  }
#line 2904
  pcids = (uint32_t )(((int )*(bcode + 25UL) << 8) | (int )*(bcode + 24UL)) + pcihdr;
#line 2906
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)dcode, pcids, 128U);
#line 2908
  bcode = (uint8_t *)(mbuf + ((unsigned long )pcihdr & 3UL));
#line 2911
  if ((((unsigned int )*bcode != 80U || (unsigned int )*(bcode + 1UL) != 67U) || (unsigned int )*(bcode + 2UL) != 73U) || (unsigned int )*(bcode + 3UL) != 82U) {
#line 2914
    ql_log(0U, vha, 341, "PCI data struct not found pcir_adr=%x.\n", pcids);
#line 2916
    ret = 258;
#line 2917
    goto ldv_66670;
  } else {

  }
#line 2921
  code_type = *(bcode + 20UL);
#line 2922
  switch ((int )code_type) {
  case 0: 
#line 2925
  ha->bios_revision[0] = *(bcode + 18UL);
#line 2926
  ha->bios_revision[1] = *(bcode + 19UL);
#line 2927
  ql_dbg(1073741824U, vha, 342, "Read BIOS %d.%d.\n", (int )ha->bios_revision[1],
         (int )ha->bios_revision[0]);
#line 2930
  goto ldv_66672;
  case 1: 
#line 2933
  ha->fcode_revision[0] = *(bcode + 18UL);
#line 2934
  ha->fcode_revision[1] = *(bcode + 19UL);
#line 2935
  ql_dbg(1073741824U, vha, 343, "Read FCODE %d.%d.\n", (int )ha->fcode_revision[1],
         (int )ha->fcode_revision[0]);
#line 2938
  goto ldv_66672;
  case 3: 
#line 2941
  ha->efi_revision[0] = *(bcode + 18UL);
#line 2942
  ha->efi_revision[1] = *(bcode + 19UL);
#line 2943
  ql_dbg(1073741824U, vha, 344, "Read EFI %d.%d.\n", (int )ha->efi_revision[1], (int )ha->efi_revision[0]);
#line 2946
  goto ldv_66672;
  default: 
#line 2948
  ql_log(1U, vha, 345, "Unrecognized code type %x at pcids %x.\n", (int )code_type,
         pcids);
#line 2951
  goto ldv_66672;
  }
  ldv_66672: 
#line 2954
  last_image = (unsigned int )*(bcode + 21UL) & 128U;
#line 2957
  pcihdr = (uint32_t )((((int )*(bcode + 17UL) << 8) | (int )*(bcode + 16UL)) * 512) + pcihdr;
#line 2958
  if ((unsigned int )last_image == 0U) {
#line 2960
    goto ldv_66676;
  } else {

  }
  ldv_66670: 
#line 2961
  memset((void *)(& ha->fw_revision), 0, 16UL);
#line 2962
  dcode = (uint32_t *)mbuf;
#line 2963
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)dcode, ha->flt_region_fw << 2, 32U);
#line 2965
  bcode = (uint8_t *)(mbuf + ((unsigned long )pcihdr & 3UL));
#line 2968
  if ((((unsigned int )*bcode == 3U && (unsigned int )*(bcode + 1UL) == 0U) && (unsigned int )*(bcode + 2UL) == 64U) && (unsigned int )*(bcode + 3UL) == 64U) {
#line 2970
    ha->fw_revision[0] = (uint32_t )*(bcode + 4UL);
#line 2971
    ha->fw_revision[1] = (uint32_t )*(bcode + 5UL);
#line 2972
    ha->fw_revision[2] = (uint32_t )*(bcode + 6UL);
#line 2973
    ql_dbg(1073741824U, vha, 339, "Firmware revision %d.%d.%d\n", ha->fw_revision[0],
           ha->fw_revision[1], ha->fw_revision[2]);
  } else {

  }
#line 2979
  return (ret);
}
}
#line 2983 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
int qla24xx_get_flash_version(scsi_qla_host_t *vha , void *mbuf ) 
{ 
  int ret ;
  uint32_t pcihdr ;
  uint32_t pcids ;
  uint32_t *dcode ;
  uint8_t *bcode ;
  uint8_t code_type ;
  uint8_t last_image ;
  int i ;
  struct qla_hw_data *ha ;
  __u32 tmp ;
  __u32 tmp___0 ;

  {
#line 2985
  ret = 0;
#line 2991
  ha = vha->hw;
#line 2993
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 2994
    return (ret);
  } else {

  }
#line 2996
  if ((unsigned long )mbuf == (unsigned long )((void *)0)) {
#line 2997
    return (258);
  } else {

  }
#line 2999
  memset((void *)(& ha->bios_revision), 0, 2UL);
#line 3000
  memset((void *)(& ha->efi_revision), 0, 2UL);
#line 3001
  memset((void *)(& ha->fcode_revision), 0, 16UL);
#line 3002
  memset((void *)(& ha->fw_revision), 0, 16UL);
#line 3004
  dcode = (uint32_t *)mbuf;
#line 3007
  pcihdr = ha->flt_region_boot << 2;
#line 3008
  last_image = 1U;
  ldv_66696: 
#line 3011
  qla24xx_read_flash_data(vha, dcode, pcihdr >> 2, 32U);
#line 3012
  bcode = (uint8_t *)(mbuf + ((unsigned long )pcihdr & 3UL));
#line 3013
  if ((unsigned int )*bcode != 85U || (unsigned int )*(bcode + 1UL) != 170U) {
#line 3015
    ql_log(0U, vha, 89, "No matching ROM signature.\n");
#line 3017
    ret = 258;
#line 3018
    goto ldv_66690;
  } else {

  }
#line 3022
  pcids = (uint32_t )(((int )*(bcode + 25UL) << 8) | (int )*(bcode + 24UL)) + pcihdr;
#line 3024
  qla24xx_read_flash_data(vha, dcode, pcids >> 2, 32U);
#line 3025
  bcode = (uint8_t *)(mbuf + ((unsigned long )pcihdr & 3UL));
#line 3028
  if ((((unsigned int )*bcode != 80U || (unsigned int )*(bcode + 1UL) != 67U) || (unsigned int )*(bcode + 2UL) != 73U) || (unsigned int )*(bcode + 3UL) != 82U) {
#line 3031
    ql_log(0U, vha, 90, "PCI data struct not found pcir_adr=%x.\n", pcids);
#line 3033
    ret = 258;
#line 3034
    goto ldv_66690;
  } else {

  }
#line 3038
  code_type = *(bcode + 20UL);
#line 3039
  switch ((int )code_type) {
  case 0: 
#line 3042
  ha->bios_revision[0] = *(bcode + 18UL);
#line 3043
  ha->bios_revision[1] = *(bcode + 19UL);
#line 3044
  ql_dbg(1073741824U, vha, 91, "Read BIOS %d.%d.\n", (int )ha->bios_revision[1], (int )ha->bios_revision[0]);
#line 3047
  goto ldv_66692;
  case 1: 
#line 3050
  ha->fcode_revision[0] = *(bcode + 18UL);
#line 3051
  ha->fcode_revision[1] = *(bcode + 19UL);
#line 3052
  ql_dbg(1073741824U, vha, 92, "Read FCODE %d.%d.\n", (int )ha->fcode_revision[1],
         (int )ha->fcode_revision[0]);
#line 3055
  goto ldv_66692;
  case 3: 
#line 3058
  ha->efi_revision[0] = *(bcode + 18UL);
#line 3059
  ha->efi_revision[1] = *(bcode + 19UL);
#line 3060
  ql_dbg(1073741824U, vha, 93, "Read EFI %d.%d.\n", (int )ha->efi_revision[1], (int )ha->efi_revision[0]);
#line 3063
  goto ldv_66692;
  default: 
#line 3065
  ql_log(1U, vha, 94, "Unrecognized code type %x at pcids %x.\n", (int )code_type,
         pcids);
#line 3068
  goto ldv_66692;
  }
  ldv_66692: 
#line 3071
  last_image = (unsigned int )*(bcode + 21UL) & 128U;
#line 3074
  pcihdr = (uint32_t )((((int )*(bcode + 17UL) << 8) | (int )*(bcode + 16UL)) * 512) + pcihdr;
#line 3075
  if ((unsigned int )last_image == 0U) {
#line 3077
    goto ldv_66696;
  } else {

  }
  ldv_66690: 
#line 3078
  memset((void *)(& ha->fw_revision), 0, 16UL);
#line 3079
  dcode = (uint32_t *)mbuf;
#line 3081
  qla24xx_read_flash_data(vha, dcode, ha->flt_region_fw + 4U, 4U);
#line 3082
  i = 0;
#line 3082
  goto ldv_66698;
  ldv_66697: 
#line 3083
  tmp = __fswab32(*(dcode + (unsigned long )i));
#line 3083
  *(dcode + (unsigned long )i) = tmp;
#line 3082
  i = i + 1;
  ldv_66698: ;
#line 3082
  if (i <= 3) {
#line 3084
    goto ldv_66697;
  } else {

  }

#line 3085
  if ((((*dcode == 4294967295U && *(dcode + 1UL) == 4294967295U) && *(dcode + 2UL) == 4294967295U) && *(dcode + 3UL) == 4294967295U) || (((*dcode == 0U && *(dcode + 1UL) == 0U) && *(dcode + 2UL) == 0U) && *(dcode + 3UL) == 0U)) {
#line 3089
    ql_log(1U, vha, 95, "Unrecognized fw revision at %x.\n", ha->flt_region_fw * 4U);
  } else {
#line 3093
    ha->fw_revision[0] = *dcode;
#line 3094
    ha->fw_revision[1] = *(dcode + 1UL);
#line 3095
    ha->fw_revision[2] = *(dcode + 2UL);
#line 3096
    ha->fw_revision[3] = *(dcode + 3UL);
#line 3097
    ql_dbg(1073741824U, vha, 96, "Firmware revision %d.%d.%d (%x).\n", ha->fw_revision[0],
           ha->fw_revision[1], ha->fw_revision[2], ha->fw_revision[3]);
  }
#line 3104
  if ((ha->device_type & 8192U) == 0U) {
#line 3106
    return (ret);
  } else {

  }
#line 3109
  memset((void *)(& ha->gold_fw_version), 0, 16UL);
#line 3110
  dcode = (uint32_t *)mbuf;
#line 3111
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)dcode, ha->flt_region_gold_fw << 2,
                                  32U);
#line 3114
  if (((*(dcode + 4UL) == 4294967295U && *(dcode + 5UL) == 4294967295U) && *(dcode + 6UL) == 4294967295U) && *(dcode + 7UL) == 4294967295U) {
#line 3116
    ql_log(1U, vha, 86, "Unrecognized golden fw at 0x%x.\n", ha->flt_region_gold_fw * 4U);
#line 3119
    return (ret);
  } else {

  }
#line 3122
  i = 4;
#line 3122
  goto ldv_66701;
  ldv_66700: 
#line 3123
  tmp___0 = __fswab32(*(dcode + (unsigned long )i));
#line 3123
  ha->gold_fw_version[i + -4] = tmp___0;
#line 3122
  i = i + 1;
  ldv_66701: ;
#line 3122
  if (i <= 7) {
#line 3124
    goto ldv_66700;
  } else {

  }

#line 3125
  return (ret);
}
}
#line 3129 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
static int qla2xxx_is_vpd_valid(uint8_t *pos , uint8_t *end ) 
{ 


  {
#line 3131
  if ((unsigned long )pos >= (unsigned long )end || (unsigned int )*pos != 130U) {
#line 3132
    return (0);
  } else {

  }
#line 3134
  pos = pos + (unsigned long )((int )*(pos + 1UL) + 3);
#line 3135
  if ((unsigned long )pos >= (unsigned long )end || (unsigned int )*pos != 144U) {
#line 3136
    return (0);
  } else {

  }
#line 3138
  pos = pos + (unsigned long )((int )*(pos + 1UL) + 3);
#line 3139
  if ((unsigned long )pos >= (unsigned long )end || (unsigned int )*pos != 120U) {
#line 3140
    return (0);
  } else {

  }
#line 3142
  return (1);
}
}
#line 3146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
int qla2xxx_get_vpd_field(scsi_qla_host_t *vha , char *key , char *str , size_t size ) 
{ 
  struct qla_hw_data *ha ;
  uint8_t *pos ;
  uint8_t *end ;
  int len ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 3148
  ha = vha->hw;
#line 3149
  pos = (uint8_t *)ha->vpd;
#line 3150
  end = pos + (unsigned long )ha->vpd_size;
#line 3151
  len = 0;
#line 3153
  if ((ha->device_type & 134217728U) == 0U) {
#line 3154
    return (0);
  } else {
#line 3153
    tmp = qla2xxx_is_vpd_valid(pos, end);
#line 3153
    if (tmp == 0) {
#line 3154
      return (0);
    } else {

    }
  }
#line 3156
  goto ldv_66719;
  ldv_66718: 
#line 3157
  len = (unsigned int )*pos == 130U ? (int )*(pos + 1UL) : (int )*(pos + 2UL);
#line 3159
  tmp___0 = strlen((char const   *)key);
#line 3159
  tmp___1 = strncmp((char const   *)pos, (char const   *)key, tmp___0);
#line 3159
  if (tmp___1 == 0) {
#line 3160
    goto ldv_66717;
  } else {

  }
#line 3162
  if ((unsigned int )*pos != 144U && (unsigned int )*pos != 145U) {
#line 3163
    pos = pos + (unsigned long )len;
  } else {

  }
#line 3165
  pos = pos + 3UL;
  ldv_66719: ;
#line 3156
  if ((unsigned long )pos < (unsigned long )end && (unsigned int )*pos != 120U) {
#line 3158
    goto ldv_66718;
  } else {

  }
  ldv_66717: ;
#line 3168
  if ((unsigned long )(end + - ((unsigned long )len)) > (unsigned long )pos && (unsigned int )*pos != 120U) {
#line 3169
    tmp___2 = scnprintf(str, size, "%.*s", len, pos + 3UL);
#line 3169
    return (tmp___2);
  } else {

  }
#line 3171
  return (0);
}
}
#line 3175 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.c"
int qla24xx_read_fcp_prio_cfg(scsi_qla_host_t *vha ) 
{ 
  int len ;
  int max_len ;
  uint32_t fcp_prio_addr ;
  struct qla_hw_data *ha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 3179
  ha = vha->hw;
#line 3181
  if ((unsigned long )ha->fcp_prio_cfg == (unsigned long )((struct qla_fcp_prio_cfg *)0)) {
#line 3182
    tmp = vmalloc(32768UL);
#line 3182
    ha->fcp_prio_cfg = (struct qla_fcp_prio_cfg *)tmp;
#line 3183
    if ((unsigned long )ha->fcp_prio_cfg == (unsigned long )((struct qla_fcp_prio_cfg *)0)) {
#line 3184
      ql_log(1U, vha, 213, "Unable to allocate memory for fcp priorty data (%x).\n",
             32768);
#line 3187
      return (258);
    } else {

    }
  } else {

  }
#line 3190
  memset((void *)ha->fcp_prio_cfg, 0, 32768UL);
#line 3192
  fcp_prio_addr = ha->flt_region_fcp_prio;
#line 3195
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)ha->fcp_prio_cfg, fcp_prio_addr << 2,
                                  16U);
#line 3198
  tmp___0 = qla24xx_fcp_prio_cfg_valid(vha, ha->fcp_prio_cfg, 0);
#line 3198
  if (tmp___0 == 0) {
#line 3199
    goto fail;
  } else {

  }
#line 3202
  fcp_prio_addr = fcp_prio_addr + 4U;
#line 3203
  len = (int )(ha->fcp_prio_cfg)->num_entries * 32;
#line 3204
  max_len = 32752;
#line 3206
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)(& (ha->fcp_prio_cfg)->entry), fcp_prio_addr << 2,
                                  (uint32_t )(len < max_len ? len : max_len));
#line 3210
  tmp___1 = qla24xx_fcp_prio_cfg_valid(vha, ha->fcp_prio_cfg, 1);
#line 3210
  if (tmp___1 == 0) {
#line 3211
    goto fail;
  } else {

  }
#line 3213
  ha->flags.fcp_prio_enabled = 1U;
#line 3214
  return (0);
  fail: 
#line 3216
  vfree((void const   *)ha->fcp_prio_cfg);
#line 3217
  ha->fcp_prio_cfg = (struct qla_fcp_prio_cfg *)0;
#line 3218
  return (258);
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
int reg_timer_21(struct timer_list *timer ) 
{ 


  {
#line 489
  ldv_timer_list_21 = timer;
#line 490
  ldv_timer_state_21 = 1;
#line 491
  return (0);
}
}
#line 494 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
void disable_suitable_timer_21(struct timer_list *timer ) 
{ 


  {
#line 495
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_21) {
#line 496
    ldv_timer_state_21 = 0;
#line 497
    return;
  } else {

  }
#line 499
  return;
}
}
#line 502 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
void activate_pending_timer_21(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 502
  if ((unsigned long )ldv_timer_list_21 == (unsigned long )timer) {
#line 503
    if (ldv_timer_state_21 == 2 || pending_flag != 0) {
#line 504
      ldv_timer_list_21 = timer;
#line 505
      ldv_timer_list_21->data = data;
#line 506
      ldv_timer_state_21 = 1;
    } else {

    }
#line 508
    return;
  } else {

  }
#line 510
  reg_timer_21(timer);
#line 511
  ldv_timer_list_21->data = data;
#line 512
  return;
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
void choose_timer_21(struct timer_list *timer ) 
{ 


  {
#line 516
  LDV_IN_INTERRUPT = 2;
#line 517
  (*(timer->function))(timer->data);
#line 518
  LDV_IN_INTERRUPT = 1;
#line 519
  ldv_timer_state_21 = 2;
#line 520
  return;
}
}
#line 546 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
bool ldv_queue_work_on_161(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 550
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 550
  ldv_func_res = tmp;
#line 552
  activate_work_7(ldv_func_arg3, 2);
#line 554
  return (ldv_func_res);
}
}
#line 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
bool ldv_queue_delayed_work_on_162(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 561
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 561
  ldv_func_res = tmp;
#line 563
  activate_work_7(& ldv_func_arg3->work, 2);
#line 565
  return (ldv_func_res);
}
}
#line 568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
bool ldv_queue_work_on_163(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 572
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 572
  ldv_func_res = tmp;
#line 574
  activate_work_7(ldv_func_arg3, 2);
#line 576
  return (ldv_func_res);
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
void ldv_flush_workqueue_164(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 582
  flush_workqueue(ldv_func_arg1);
#line 584
  call_and_disable_all_7(2);
#line 585
  return;
}
}
#line 587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
bool ldv_queue_delayed_work_on_165(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 591
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 591
  ldv_func_res = tmp;
#line 593
  activate_work_7(& ldv_func_arg3->work, 2);
#line 595
  return (ldv_func_res);
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
int ldv_scsi_add_host_with_dma_166(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 602
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 602
  ldv_func_res = tmp;
#line 604
  if (ldv_func_res == 0) {
#line 605
    ldv_state_variable_88 = 1;
#line 605
    ldv_initialize_scsi_host_template_88();
  } else {

  }
#line 609
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 394 "include/linux/kernel.h"
extern long simple_strtol(char const   * , char ** , unsigned int  ) ;
#line 417
extern int sscanf(char const   * , char const   *  , ...) ;
#line 135 "include/linux/string.h"
extern ssize_t memory_read_from_buffer(void * , size_t  , loff_t * , void const   * ,
                                       size_t  ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_177(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_179(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_178(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_181(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_180(struct workqueue_struct *ldv_func_arg1 ) ;
#line 230 "include/linux/sysfs.h"
extern int sysfs_create_bin_file(struct kobject * , struct bin_attribute  const  * ) ;
#line 232
extern void sysfs_remove_bin_file(struct kobject * , struct bin_attribute  const  * ) ;
#line 215 "include/linux/capability.h"
extern bool capable(int  ) ;
#line 351 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void choose_timer_22(struct timer_list *timer ) ;
#line 384
void disable_suitable_timer_22(struct timer_list *timer ) ;
#line 418
void activate_pending_timer_22(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 450
int reg_timer_22(struct timer_list *timer ) ;
#line 759 "include/scsi/scsi_host.h"
extern int scsi_is_host_device(struct device  const  * ) ;
#line 761 "include/scsi/scsi_host.h"
__inline static struct Scsi_Host *dev_to_shost(struct device *dev ) 
{ 
  int tmp ;
  struct device  const  *__mptr ;

  {
#line 763
  goto ldv_36704;
  ldv_36703: ;
#line 764
  if ((unsigned long )dev->parent == (unsigned long )((struct device *)0)) {
#line 765
    return ((struct Scsi_Host *)0);
  } else {

  }
#line 766
  dev = dev->parent;
  ldv_36704: 
#line 763
  tmp = scsi_is_host_device((struct device  const  *)dev);
#line 763
  if (tmp == 0) {
#line 765
    goto ldv_36703;
  } else {

  }
#line 768
  __mptr = (struct device  const  *)dev;
#line 768
  return ((struct Scsi_Host *)__mptr + 0xfffffffffffffc48UL);
}
}
#line 795
int ldv_scsi_add_host_with_dma_182(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
#line 799
int ldv_scsi_add_host_with_dma_183(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
#line 806
void ldv_scsi_remove_host_184(struct Scsi_Host *shost ) ;
#line 2041 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
static char const   * const  port_state_str___2[5U]  = {      "Unknown",      "UNCONFIGURED",      "DEAD",      "LOST", 
        "ONLINE"};
#line 173 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
void qla24xx_deallocate_vp_id(scsi_qla_host_t *vha ) ;
#line 174
int qla24xx_disable_vp(scsi_qla_host_t *vha ) ;
#line 175
int qla24xx_enable_vp(scsi_qla_host_t *vha ) ;
#line 179
void qla2x00_vp_stop_timer(scsi_qla_host_t *vha ) ;
#line 184
int qla24xx_vport_create_req_sanity_check(struct fc_vport *fc_vport ) ;
#line 185
scsi_qla_host_t *qla24xx_create_vhost(struct fc_vport *fc_vport ) ;
#line 197
int qla2x00_wait_for_fcoe_ctx_reset(scsi_qla_host_t *vha ) ;
#line 602
int qla25xx_delete_req_que(struct scsi_qla_host *vha , struct req_que *req ) ;
#line 636
uint32_t qlafx00_fw_state_show(struct device *dev , struct device_attribute *attr ,
                               char *buf ) ;
#line 638
void qlafx00_get_host_speed(struct Scsi_Host *shost ) ;
#line 724
int qla24xx_bsg_request(struct fc_bsg_job *bsg_job ) ;
#line 725
int qla24xx_bsg_timeout(struct fc_bsg_job *bsg_job ) ;
#line 741
void qla82xx_md_prep(scsi_qla_host_t *vha ) ;
#line 742
void qla82xx_set_reset_owner(scsi_qla_host_t *vha ) ;
#line 748
uint32_t qla8044_rd_reg(struct qla_hw_data *ha , ulong addr ) ;
#line 749
void qla8044_wr_reg(struct qla_hw_data *ha , ulong addr , uint32_t val ) ;
#line 1087 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
void qlt_vport_create(struct scsi_qla_host *vha , struct qla_hw_data *ha ) ;
#line 159 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_set_fcport_state___1(fc_port_t *fcport , int state ) 
{ 
  int old_state ;

  {
#line 163
  old_state = atomic_read((atomic_t const   *)(& fcport->state));
#line 164
  atomic_set(& fcport->state, state);
#line 167
  if (old_state != 0 && old_state != state) {
#line 168
    ql_dbg(268435456U, fcport->vha, 8317, "FCPort state transitioned from %s to %s - portid=%02x%02x%02x.\n",
           port_state_str___2[old_state], port_state_str___2[state], (int )fcport->d_id.b.domain,
           (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
  } else {

  }
#line 174
  return;
}
}
#line 15 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static int qla24xx_vport_disable(struct fc_vport *fc_vport , bool disable ) ;
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_sysfs_read_fw_dump(struct file *filp , struct kobject *kobj ,
                                          struct bin_attribute *bin_attr , char *buf ,
                                          loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  int rval ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 24
  __mptr = (struct kobject  const  *)kobj;
#line 24
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 24
  tmp___0 = shost_priv(tmp);
#line 24
  vha = (struct scsi_qla_host *)tmp___0;
#line 26
  ha = vha->hw;
#line 27
  rval = 0;
#line 29
  if (ha->fw_dump_reading == 0 && ha->mctp_dump_reading == 0) {
#line 30
    return (0L);
  } else {

  }
#line 32
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 33
    if ((loff_t )ha->md_template_size > off) {
#line 34
      tmp___1 = memory_read_from_buffer((void *)buf, count, & off, (void const   *)ha->md_tmplt_hdr,
                                        (size_t )ha->md_template_size);
#line 34
      rval = (int )tmp___1;
#line 36
      return ((ssize_t )rval);
    } else {

    }
#line 38
    off = off - (loff_t )ha->md_template_size;
#line 39
    tmp___2 = memory_read_from_buffer((void *)buf, count, & off, (void const   *)ha->md_dump,
                                      (size_t )ha->md_dump_size);
#line 39
    rval = (int )tmp___2;
#line 41
    return ((ssize_t )rval);
  } else
#line 42
  if (ha->mctp_dumped != 0 && ha->mctp_dump_reading != 0) {
#line 43
    tmp___3 = memory_read_from_buffer((void *)buf, count, & off, (void const   *)ha->mctp_dump,
                                      548964UL);
#line 43
    return (tmp___3);
  } else
#line 45
  if (ha->fw_dump_reading != 0) {
#line 46
    tmp___4 = memory_read_from_buffer((void *)buf, count, & off, (void const   *)ha->fw_dump,
                                      (size_t )ha->fw_dump_len);
#line 46
    return (tmp___4);
  } else {
#line 49
    return (0L);
  }
}
}
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_sysfs_write_fw_dump(struct file *filp , struct kobject *kobj ,
                                           struct bin_attribute *bin_attr , char *buf ,
                                           loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  int reading ;
  long tmp___1 ;

  {
#line 57
  __mptr = (struct kobject  const  *)kobj;
#line 57
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 57
  tmp___0 = shost_priv(tmp);
#line 57
  vha = (struct scsi_qla_host *)tmp___0;
#line 59
  ha = vha->hw;
#line 62
  if (off != 0LL) {
#line 63
    return (0L);
  } else {

  }
#line 65
  tmp___1 = simple_strtol((char const   *)buf, (char **)0, 10U);
#line 65
  reading = (int )tmp___1;
#line 66
  switch (reading) {
  case 0: ;
#line 68
  if (ha->fw_dump_reading == 0) {
#line 69
    goto ldv_66008;
  } else {

  }
#line 71
  ql_log(2U, vha, 28765, "Firmware dump cleared on (%ld).\n", vha->host_no);
#line 74
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 75
    qla82xx_md_free(vha);
#line 76
    qla82xx_md_prep(vha);
  } else {

  }
#line 78
  ha->fw_dump_reading = 0;
#line 79
  ha->fw_dumped = 0;
#line 80
  goto ldv_66008;
  case 1: ;
#line 82
  if (ha->fw_dumped != 0 && ha->fw_dump_reading == 0) {
#line 83
    ha->fw_dump_reading = 1;
#line 85
    ql_log(2U, vha, 28766, "Raw firmware dump ready for read on (%ld).\n", vha->host_no);
  } else {

  }
#line 89
  goto ldv_66008;
  case 2: 
#line 91
  qla2x00_alloc_fw_dump(vha);
#line 92
  goto ldv_66008;
  case 3: ;
#line 94
  if ((ha->device_type & 16384U) != 0U) {
#line 95
    qla82xx_idc_lock(ha);
#line 96
    qla82xx_set_reset_owner(vha);
#line 97
    qla82xx_idc_unlock(ha);
  } else
#line 98
  if ((ha->device_type & 262144U) != 0U) {
#line 99
    qla8044_idc_lock(ha);
#line 100
    qla82xx_set_reset_owner(vha);
#line 101
    qla8044_idc_unlock(ha);
  } else {
#line 103
    qla2x00_system_error(vha);
  }
#line 104
  goto ldv_66008;
  case 4: ;
#line 106
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 107
    if ((unsigned long )ha->md_tmplt_hdr != (unsigned long )((void *)0)) {
#line 108
      ql_dbg(8388608U, vha, 28763, "MiniDump supported with this firmware.\n");
    } else {
#line 111
      ql_dbg(8388608U, vha, 28829, "MiniDump not supported with this firmware.\n");
    }
  } else {

  }
#line 114
  goto ldv_66008;
  case 5: ;
#line 116
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 117
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
  } else {

  }
#line 118
  goto ldv_66008;
  case 6: ;
#line 120
  if (ha->mctp_dump_reading == 0) {
#line 121
    goto ldv_66008;
  } else {

  }
#line 122
  ql_log(2U, vha, 28865, "MCTP dump cleared on (%ld).\n", vha->host_no);
#line 124
  ha->mctp_dump_reading = 0;
#line 125
  ha->mctp_dumped = 0;
#line 126
  goto ldv_66008;
  case 7: ;
#line 128
  if (ha->mctp_dumped != 0 && ha->mctp_dump_reading == 0) {
#line 129
    ha->mctp_dump_reading = 1;
#line 130
    ql_log(2U, vha, 28866, "Raw mctp dump ready for read on (%ld).\n", vha->host_no);
  } else {

  }
#line 134
  goto ldv_66008;
  }
  ldv_66008: ;
#line 136
  return ((ssize_t )count);
}
}
#line 139 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct bin_attribute sysfs_fw_dump_attr  =    {{"fw_dump", 384U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                     {(char)0}, {(char)0}, {(char)0}}}}, 0UL, 0, & qla2x00_sysfs_read_fw_dump,
    & qla2x00_sysfs_write_fw_dump, 0};
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_sysfs_read_fw_dump_template(struct file *filp , struct kobject *kobj ,
                                                   struct bin_attribute *bin_attr ,
                                                   char *buf , loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  ssize_t tmp___1 ;

  {
#line 154
  __mptr = (struct kobject  const  *)kobj;
#line 154
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 154
  tmp___0 = shost_priv(tmp);
#line 154
  vha = (struct scsi_qla_host *)tmp___0;
#line 156
  ha = vha->hw;
#line 158
  if ((unsigned long )ha->fw_dump_template == (unsigned long )((void *)0) || ha->fw_dump_template_len == 0U) {
#line 159
    return (0L);
  } else {

  }
#line 161
  ql_dbg(8388608U, vha, 28898, "chunk <- off=%llx count=%zx\n", off, count);
#line 163
  tmp___1 = memory_read_from_buffer((void *)buf, count, & off, (void const   *)ha->fw_dump_template,
                                    (size_t )ha->fw_dump_template_len);
#line 163
  return (tmp___1);
}
}
#line 168 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_sysfs_write_fw_dump_template(struct file *filp , struct kobject *kobj ,
                                                    struct bin_attribute *bin_attr ,
                                                    char *buf , loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  uint32_t size ;
  ulong tmp___1 ;
  ulong tmp___2 ;
  void *tmp___3 ;

  {
#line 172
  __mptr = (struct kobject  const  *)kobj;
#line 172
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 172
  tmp___0 = shost_priv(tmp);
#line 172
  vha = (struct scsi_qla_host *)tmp___0;
#line 174
  ha = vha->hw;
#line 177
  if (off == 0LL) {
#line 178
    if ((unsigned long )ha->fw_dump != (unsigned long )((struct qla2xxx_fw_dump *)0)) {
#line 179
      vfree((void const   *)ha->fw_dump);
    } else {

    }
#line 180
    if ((unsigned long )ha->fw_dump_template != (unsigned long )((void *)0)) {
#line 181
      vfree((void const   *)ha->fw_dump_template);
    } else {

    }
#line 183
    ha->fw_dump = (struct qla2xxx_fw_dump *)0;
#line 184
    ha->fw_dump_len = 0U;
#line 185
    ha->fw_dump_template = (void *)0;
#line 186
    ha->fw_dump_template_len = 0U;
#line 188
    tmp___1 = qla27xx_fwdt_template_size((void *)buf);
#line 188
    size = (uint32_t )tmp___1;
#line 189
    ql_dbg(8388608U, vha, 28881, "-> allocating fwdt (%x bytes)...\n", size);
#line 191
    ha->fw_dump_template = vmalloc((unsigned long )size);
#line 192
    if ((unsigned long )ha->fw_dump_template == (unsigned long )((void *)0)) {
#line 193
      ql_log(1U, vha, 28882, "Failed allocate fwdt (%x bytes).\n", size);
#line 195
      return (-12L);
    } else {

    }
#line 197
    ha->fw_dump_template_len = size;
  } else {

  }
#line 200
  if ((unsigned long long )off + (unsigned long long )count > (unsigned long long )ha->fw_dump_template_len) {
#line 201
    count = (size_t )((loff_t )ha->fw_dump_template_len - off);
#line 202
    ql_dbg(8388608U, vha, 28883, "chunk -> truncating to %zx bytes.\n", count);
  } else {

  }
#line 206
  ql_dbg(8388608U, vha, 28884, "chunk -> off=%llx count=%zx\n", off, count);
#line 208
  memcpy(ha->fw_dump_template + (unsigned long )off, (void const   *)buf, count);
#line 210
  if ((unsigned long long )off + (unsigned long long )count == (unsigned long long )ha->fw_dump_template_len) {
#line 211
    tmp___2 = qla27xx_fwdt_calculate_dump_size(vha);
#line 211
    size = (uint32_t )tmp___2;
#line 212
    ql_dbg(8388608U, vha, 28885, "-> allocating fwdump (%x bytes)...\n", size);
#line 214
    tmp___3 = vmalloc((unsigned long )size);
#line 214
    ha->fw_dump = (struct qla2xxx_fw_dump *)tmp___3;
#line 215
    if ((unsigned long )ha->fw_dump == (unsigned long )((struct qla2xxx_fw_dump *)0)) {
#line 216
      ql_log(1U, vha, 28886, "Failed allocate fwdump (%x bytes).\n", size);
#line 218
      return (-12L);
    } else {

    }
#line 220
    ha->fw_dump_len = size;
  } else {

  }
#line 223
  return ((ssize_t )count);
}
}
#line 225 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct bin_attribute sysfs_fw_dump_template_attr  =    {{"fw_dump_template", 384U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                              {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    0UL, 0, & qla2x00_sysfs_read_fw_dump_template, & qla2x00_sysfs_write_fw_dump_template,
    0};
#line 236 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_sysfs_read_nvram(struct file *filp , struct kobject *kobj ,
                                        struct bin_attribute *bin_attr , char *buf ,
                                        loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  bool tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 240
  __mptr = (struct kobject  const  *)kobj;
#line 240
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 240
  tmp___0 = shost_priv(tmp);
#line 240
  vha = (struct scsi_qla_host *)tmp___0;
#line 242
  ha = vha->hw;
#line 244
  tmp___1 = capable(21);
#line 244
  if (tmp___1) {
#line 244
    tmp___2 = 0;
  } else {
#line 244
    tmp___2 = 1;
  }
#line 244
  if (tmp___2) {
#line 245
    return (0L);
  } else {

  }
#line 247
  if (((ha->device_type & 8192U) != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 248
    (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)ha->nvram, ha->flt_region_nvram << 2,
                                    (uint32_t )ha->nvram_size);
  } else {

  }
#line 250
  tmp___3 = memory_read_from_buffer((void *)buf, count, & off, (void const   *)ha->nvram,
                                    (size_t )ha->nvram_size);
#line 250
  return (tmp___3);
}
}
#line 255 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_sysfs_write_nvram(struct file *filp , struct kobject *kobj ,
                                         struct bin_attribute *bin_attr , char *buf ,
                                         loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  uint16_t cnt ;
  bool tmp___1 ;
  int tmp___2 ;
  uint32_t *iter ;
  uint32_t chksum ;
  uint32_t *tmp___3 ;
  uint8_t *iter___0 ;
  uint8_t chksum___0 ;
  uint8_t *tmp___4 ;
  int tmp___5 ;

  {
#line 259
  __mptr = (struct kobject  const  *)kobj;
#line 259
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 259
  tmp___0 = shost_priv(tmp);
#line 259
  vha = (struct scsi_qla_host *)tmp___0;
#line 261
  ha = vha->hw;
#line 264
  tmp___1 = capable(21);
#line 264
  if (tmp___1) {
#line 264
    tmp___2 = 0;
  } else {
#line 264
    tmp___2 = 1;
  }
#line 264
  if (((tmp___2 || off != 0LL) || (size_t )ha->nvram_size != count) || (unsigned long )(ha->isp_ops)->write_nvram == (unsigned long )((int (*)(struct scsi_qla_host * ,
                                                                                                                                               uint8_t * ,
                                                                                                                                               uint32_t  ,
                                                                                                                                               uint32_t  ))0)) {
#line 266
    return (-22L);
  } else {

  }
#line 269
  if ((ha->device_type & 134217728U) != 0U) {
#line 273
    iter = (uint32_t *)buf;
#line 274
    chksum = 0U;
#line 275
    cnt = 0U;
#line 275
    goto ldv_66071;
    ldv_66070: 
#line 276
    tmp___3 = iter;
#line 276
    iter = iter + 1;
#line 276
    chksum = *tmp___3 + chksum;
#line 275
    cnt = (uint16_t )((int )cnt + 1);
    ldv_66071: ;
#line 275
    if ((size_t )cnt < (count >> 2) - 1UL) {
#line 277
      goto ldv_66070;
    } else {

    }
#line 277
    chksum = - chksum;
#line 278
    *iter = chksum;
  } else {
#line 283
    iter___0 = (uint8_t *)buf;
#line 284
    chksum___0 = 0U;
#line 285
    cnt = 0U;
#line 285
    goto ldv_66076;
    ldv_66075: 
#line 286
    tmp___4 = iter___0;
#line 286
    iter___0 = iter___0 + 1;
#line 286
    chksum___0 = (int )*tmp___4 + (int )chksum___0;
#line 285
    cnt = (uint16_t )((int )cnt + 1);
    ldv_66076: ;
#line 285
    if ((size_t )cnt < count - 1UL) {
#line 287
      goto ldv_66075;
    } else {

    }
#line 287
    chksum___0 = - ((int )chksum___0);
#line 288
    *iter___0 = chksum___0;
  }
#line 291
  tmp___5 = qla2x00_wait_for_hba_online(vha);
#line 291
  if (tmp___5 != 0) {
#line 292
    ql_log(1U, vha, 28767, "HBA not online, failing NVRAM update.\n");
#line 294
    return (-11L);
  } else {

  }
#line 298
  (*((ha->isp_ops)->write_nvram))(vha, (uint8_t *)buf, (uint32_t )ha->nvram_base,
                                  (uint32_t )count);
#line 299
  (*((ha->isp_ops)->read_nvram))(vha, (uint8_t *)ha->nvram, (uint32_t )ha->nvram_base,
                                 (uint32_t )count);
#line 302
  ql_dbg(8388608U, vha, 28768, "Setting ISP_ABORT_NEEDED\n");
#line 305
  set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 306
  qla2xxx_wake_dpc(vha);
#line 307
  qla2x00_wait_for_chip_reset(vha);
#line 309
  return ((ssize_t )count);
}
}
#line 312 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct bin_attribute sysfs_nvram_attr  =    {{"nvram", 384U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                   {(char)0}, {(char)0}, {(char)0}}}}, 512UL, 0, & qla2x00_sysfs_read_nvram,
    & qla2x00_sysfs_write_nvram, 0};
#line 323 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_sysfs_read_optrom(struct file *filp , struct kobject *kobj ,
                                         struct bin_attribute *bin_attr , char *buf ,
                                         loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  ssize_t rval ;

  {
#line 327
  __mptr = (struct kobject  const  *)kobj;
#line 327
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 327
  tmp___0 = shost_priv(tmp);
#line 327
  vha = (struct scsi_qla_host *)tmp___0;
#line 329
  ha = vha->hw;
#line 330
  rval = 0L;
#line 332
  if (ha->optrom_state != 1) {
#line 333
    return (0L);
  } else {

  }
#line 335
  mutex_lock_nested(& ha->optrom_mutex, 0U);
#line 336
  rval = memory_read_from_buffer((void *)buf, count, & off, (void const   *)ha->optrom_buffer,
                                 (size_t )ha->optrom_region_size);
#line 338
  mutex_unlock(& ha->optrom_mutex);
#line 340
  return (rval);
}
}
#line 344 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_sysfs_write_optrom(struct file *filp , struct kobject *kobj ,
                                          struct bin_attribute *bin_attr , char *buf ,
                                          loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;

  {
#line 348
  __mptr = (struct kobject  const  *)kobj;
#line 348
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 348
  tmp___0 = shost_priv(tmp);
#line 348
  vha = (struct scsi_qla_host *)tmp___0;
#line 350
  ha = vha->hw;
#line 352
  if (ha->optrom_state != 2) {
#line 353
    return (-22L);
  } else {

  }
#line 354
  if ((loff_t )ha->optrom_region_size < off) {
#line 355
    return (-34L);
  } else {

  }
#line 356
  if ((unsigned long long )off + (unsigned long long )count > (unsigned long long )ha->optrom_region_size) {
#line 357
    count = (size_t )((loff_t )ha->optrom_region_size - off);
  } else {

  }
#line 359
  mutex_lock_nested(& ha->optrom_mutex, 0U);
#line 360
  memcpy((void *)ha->optrom_buffer + (unsigned long )off, (void const   *)buf, count);
#line 361
  mutex_unlock(& ha->optrom_mutex);
#line 363
  return ((ssize_t )count);
}
}
#line 366 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct bin_attribute sysfs_optrom_attr  =    {{"optrom", 384U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                    {(char)0}, {(char)0}, {(char)0}}}}, 0UL, 0, & qla2x00_sysfs_read_optrom,
    & qla2x00_sysfs_write_optrom, 0};
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_sysfs_write_optrom_ctl(struct file *filp , struct kobject *kobj ,
                                              struct bin_attribute *bin_attr , char *buf ,
                                              loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  uint32_t start ;
  uint32_t size ;
  int val ;
  int valid ;
  ssize_t rval ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;

  {
#line 381
  __mptr = (struct kobject  const  *)kobj;
#line 381
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 381
  tmp___0 = shost_priv(tmp);
#line 381
  vha = (struct scsi_qla_host *)tmp___0;
#line 383
  ha = vha->hw;
#line 384
  start = 0U;
#line 385
  size = ha->optrom_size;
#line 387
  rval = (ssize_t )count;
#line 389
  if (off != 0LL) {
#line 390
    return (-22L);
  } else {

  }
#line 392
  tmp___1 = pci_channel_offline(ha->pdev);
#line 392
  tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
#line 392
  if (tmp___2 != 0L) {
#line 393
    return (-11L);
  } else {

  }
#line 395
  tmp___3 = sscanf((char const   *)buf, "%d:%x:%x", & val, & start, & size);
#line 395
  if (tmp___3 <= 0) {
#line 396
    return (-22L);
  } else {

  }
#line 397
  if (ha->optrom_size < start) {
#line 398
    return (-22L);
  } else {

  }
#line 400
  mutex_lock_nested(& ha->optrom_mutex, 0U);
#line 401
  switch (val) {
  case 0: ;
#line 403
  if (ha->optrom_state != 1 && ha->optrom_state != 2) {
#line 405
    rval = -22L;
#line 406
    goto out;
  } else {

  }
#line 408
  ha->optrom_state = 0;
#line 410
  ql_dbg(8388608U, vha, 28769, "Freeing flash region allocation -- 0x%x bytes.\n",
         ha->optrom_region_size);
#line 414
  vfree((void const   *)ha->optrom_buffer);
#line 415
  ha->optrom_buffer = (char *)0;
#line 416
  goto ldv_66124;
  case 1: ;
#line 418
  if (ha->optrom_state != 0) {
#line 419
    rval = -22L;
#line 420
    goto out;
  } else {

  }
#line 423
  ha->optrom_region_start = start;
#line 424
  ha->optrom_region_size = start + size > ha->optrom_size ? ha->optrom_size - start : size;
#line 427
  ha->optrom_state = 1;
#line 428
  tmp___4 = vmalloc((unsigned long )ha->optrom_region_size);
#line 428
  ha->optrom_buffer = (char *)tmp___4;
#line 429
  if ((unsigned long )ha->optrom_buffer == (unsigned long )((char *)0)) {
#line 430
    ql_log(1U, vha, 28770, "Unable to allocate memory for optrom retrieval (%x).\n",
           ha->optrom_region_size);
#line 434
    ha->optrom_state = 0;
#line 435
    rval = -12L;
#line 436
    goto out;
  } else {

  }
#line 439
  tmp___5 = qla2x00_wait_for_hba_online(vha);
#line 439
  if (tmp___5 != 0) {
#line 440
    ql_log(1U, vha, 28771, "HBA not online, failing NVRAM update.\n");
#line 442
    rval = -11L;
#line 443
    goto out;
  } else {

  }
#line 446
  ql_dbg(8388608U, vha, 28772, "Reading flash region -- 0x%x/0x%x.\n", ha->optrom_region_start,
         ha->optrom_region_size);
#line 450
  memset((void *)ha->optrom_buffer, 0, (size_t )ha->optrom_region_size);
#line 451
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)ha->optrom_buffer, ha->optrom_region_start,
                                  ha->optrom_region_size);
#line 453
  goto ldv_66124;
  case 2: ;
#line 455
  if (ha->optrom_state != 0) {
#line 456
    rval = -22L;
#line 457
    goto out;
  } else {

  }
#line 480
  valid = 0;
#line 481
  if (ha->optrom_size == 131072U && start == 0U) {
#line 482
    valid = 1;
  } else
#line 483
  if (ha->flt_region_boot * 4U == start || ha->flt_region_fw * 4U == start) {
#line 485
    valid = 1;
  } else
#line 486
  if ((((((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || ((ha->device_type & 512U) != 0U || (ha->device_type & 1024U) != 0U)) || (ha->device_type & 4096U) != 0U) || (ha->device_type & 2048U) != 0U) || ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U)) || (ha->device_type & 32768U) != 0U) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 489
    valid = 1;
  } else {

  }
#line 490
  if (valid == 0) {
#line 491
    ql_log(1U, vha, 28773, "Invalid start region 0x%x/0x%x.\n", start, size);
#line 493
    rval = -22L;
#line 494
    goto out;
  } else {

  }
#line 497
  ha->optrom_region_start = start;
#line 498
  ha->optrom_region_size = start + size > ha->optrom_size ? ha->optrom_size - start : size;
#line 501
  ha->optrom_state = 2;
#line 502
  tmp___6 = vmalloc((unsigned long )ha->optrom_region_size);
#line 502
  ha->optrom_buffer = (char *)tmp___6;
#line 503
  if ((unsigned long )ha->optrom_buffer == (unsigned long )((char *)0)) {
#line 504
    ql_log(1U, vha, 28774, "Unable to allocate memory for optrom update (%x)\n", ha->optrom_region_size);
#line 508
    ha->optrom_state = 0;
#line 509
    rval = -12L;
#line 510
    goto out;
  } else {

  }
#line 513
  ql_dbg(8388608U, vha, 28775, "Staging flash region write -- 0x%x/0x%x.\n", ha->optrom_region_start,
         ha->optrom_region_size);
#line 517
  memset((void *)ha->optrom_buffer, 0, (size_t )ha->optrom_region_size);
#line 518
  goto ldv_66124;
  case 3: ;
#line 520
  if (ha->optrom_state != 2) {
#line 521
    rval = -22L;
#line 522
    goto out;
  } else {

  }
#line 525
  tmp___7 = qla2x00_wait_for_hba_online(vha);
#line 525
  if (tmp___7 != 0) {
#line 526
    ql_log(1U, vha, 28776, "HBA not online, failing flash update.\n");
#line 528
    rval = -11L;
#line 529
    goto out;
  } else {

  }
#line 532
  ql_dbg(8388608U, vha, 28777, "Writing flash region -- 0x%x/0x%x.\n", ha->optrom_region_start,
         ha->optrom_region_size);
#line 536
  (*((ha->isp_ops)->write_optrom))(vha, (uint8_t *)ha->optrom_buffer, ha->optrom_region_start,
                                   ha->optrom_region_size);
#line 538
  goto ldv_66124;
  default: 
#line 540
  rval = -22L;
  }
  ldv_66124: ;
  out: 
#line 544
  mutex_unlock(& ha->optrom_mutex);
#line 545
  return (rval);
}
}
#line 548 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct bin_attribute sysfs_optrom_ctl_attr  =    {{"optrom_ctl", 128U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                        {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    0UL, 0, 0, & qla2x00_sysfs_write_optrom_ctl, 0};
#line 558 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_sysfs_read_vpd(struct file *filp , struct kobject *kobj , struct bin_attribute *bin_attr ,
                                      char *buf , loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  int tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 562
  __mptr = (struct kobject  const  *)kobj;
#line 562
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 562
  tmp___0 = shost_priv(tmp);
#line 562
  vha = (struct scsi_qla_host *)tmp___0;
#line 564
  ha = vha->hw;
#line 566
  tmp___1 = pci_channel_offline(ha->pdev);
#line 566
  tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
#line 566
  if (tmp___2 != 0L) {
#line 567
    return (-11L);
  } else {

  }
#line 569
  tmp___3 = capable(21);
#line 569
  if (tmp___3) {
#line 569
    tmp___4 = 0;
  } else {
#line 569
    tmp___4 = 1;
  }
#line 569
  if (tmp___4) {
#line 570
    return (-22L);
  } else {

  }
#line 572
  if (((ha->device_type & 8192U) != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 573
    (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)ha->vpd, ha->flt_region_vpd << 2,
                                    (uint32_t )ha->vpd_size);
  } else {

  }
#line 575
  tmp___5 = memory_read_from_buffer((void *)buf, count, & off, (void const   *)ha->vpd,
                                    (size_t )ha->vpd_size);
#line 575
  return (tmp___5);
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_sysfs_write_vpd(struct file *filp , struct kobject *kobj ,
                                       struct bin_attribute *bin_attr , char *buf ,
                                       loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  uint8_t *tmp_data ;
  int tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;

  {
#line 583
  __mptr = (struct kobject  const  *)kobj;
#line 583
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 583
  tmp___0 = shost_priv(tmp);
#line 583
  vha = (struct scsi_qla_host *)tmp___0;
#line 585
  ha = vha->hw;
#line 588
  tmp___1 = pci_channel_offline(ha->pdev);
#line 588
  tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
#line 588
  if (tmp___2 != 0L) {
#line 589
    return (0L);
  } else {

  }
#line 591
  tmp___3 = capable(21);
#line 591
  if (tmp___3) {
#line 591
    tmp___4 = 0;
  } else {
#line 591
    tmp___4 = 1;
  }
#line 591
  if (((tmp___4 || off != 0LL) || (size_t )ha->vpd_size != count) || (unsigned long )(ha->isp_ops)->write_nvram == (unsigned long )((int (*)(struct scsi_qla_host * ,
                                                                                                                                             uint8_t * ,
                                                                                                                                             uint32_t  ,
                                                                                                                                             uint32_t  ))0)) {
#line 593
    return (0L);
  } else {

  }
#line 595
  tmp___5 = qla2x00_wait_for_hba_online(vha);
#line 595
  if (tmp___5 != 0) {
#line 596
    ql_log(1U, vha, 28778, "HBA not online, failing VPD update.\n");
#line 598
    return (-11L);
  } else {

  }
#line 602
  (*((ha->isp_ops)->write_nvram))(vha, (uint8_t *)buf, (uint32_t )ha->vpd_base, (uint32_t )count);
#line 603
  (*((ha->isp_ops)->read_nvram))(vha, (uint8_t *)ha->vpd, (uint32_t )ha->vpd_base,
                                 (uint32_t )count);
#line 606
  if ((ha->device_type & 134217728U) == 0U) {
#line 607
    return (-22L);
  } else {

  }
#line 609
  tmp___6 = vmalloc(256UL);
#line 609
  tmp_data = (uint8_t *)tmp___6;
#line 610
  if ((unsigned long )tmp_data == (unsigned long )((uint8_t *)0U)) {
#line 611
    ql_log(1U, vha, 28779, "Unable to allocate memory for VPD information update.\n");
#line 613
    return (-12L);
  } else {

  }
#line 615
  (*((ha->isp_ops)->get_flash_version))(vha, (void *)tmp_data);
#line 616
  vfree((void const   *)tmp_data);
#line 618
  return ((ssize_t )count);
}
}
#line 621 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct bin_attribute sysfs_vpd_attr  =    {{"vpd", 384U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                 {(char)0}, {(char)0}, {(char)0}}}}, 0UL, 0, & qla2x00_sysfs_read_vpd,
    & qla2x00_sysfs_write_vpd, 0};
#line 632 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_sysfs_read_sfp(struct file *filp , struct kobject *kobj , struct bin_attribute *bin_attr ,
                                      char *buf , loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  uint16_t iter ;
  uint16_t addr ;
  uint16_t offset ;
  int rval ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 636
  __mptr = (struct kobject  const  *)kobj;
#line 636
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 636
  tmp___0 = shost_priv(tmp);
#line 636
  vha = (struct scsi_qla_host *)tmp___0;
#line 638
  ha = vha->hw;
#line 642
  tmp___1 = capable(21);
#line 642
  if (tmp___1) {
#line 642
    tmp___2 = 0;
  } else {
#line 642
    tmp___2 = 1;
  }
#line 642
  if ((tmp___2 || off != 0LL) || count != 512UL) {
#line 643
    return (0L);
  } else {

  }
#line 645
  if ((unsigned long )ha->sfp_data != (unsigned long )((void *)0)) {
#line 646
    goto do_read;
  } else {

  }
#line 648
  ha->sfp_data = dma_pool_alloc(ha->s_dma_pool, 208U, & ha->sfp_data_dma);
#line 650
  if ((unsigned long )ha->sfp_data == (unsigned long )((void *)0)) {
#line 651
    ql_log(1U, vha, 28780, "Unable to allocate memory for SFP read-data.\n");
#line 653
    return (0L);
  } else {

  }
  do_read: 
#line 657
  memset(ha->sfp_data, 0, 64UL);
#line 658
  addr = 160U;
#line 659
  iter = 0U;
#line 659
  offset = 0U;
#line 659
  goto ldv_66174;
  ldv_66173: ;
#line 661
  if ((unsigned int )iter == 4U) {
#line 663
    addr = 162U;
#line 664
    offset = 0U;
  } else {

  }
#line 667
  rval = qla2x00_read_sfp(vha, ha->sfp_data_dma, (uint8_t *)ha->sfp_data, (int )addr,
                          (int )offset, 64, 2);
#line 669
  if (rval != 0) {
#line 670
    ql_log(1U, vha, 28781, "Unable to read SFP data (%x/%x/%x).\n", rval, (int )addr,
           (int )offset);
#line 674
    return (-5L);
  } else {

  }
#line 676
  memcpy((void *)buf, (void const   *)ha->sfp_data, 64UL);
#line 677
  buf = buf + 64UL;
#line 660
  iter = (uint16_t )((int )iter + 1);
#line 660
  offset = (unsigned int )offset + 64U;
  ldv_66174: ;
#line 659
  if ((unsigned int )iter <= 7U) {
#line 661
    goto ldv_66173;
  } else {

  }

#line 680
  return ((ssize_t )count);
}
}
#line 683 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct bin_attribute sysfs_sfp_attr  =    {{"sfp", 384U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                 {(char)0}, {(char)0}, {(char)0}}}}, 512UL, 0, & qla2x00_sysfs_read_sfp,
    0, 0};
#line 693 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_sysfs_write_reset(struct file *filp , struct kobject *kobj ,
                                         struct bin_attribute *bin_attr , char *buf ,
                                         loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  struct scsi_qla_host *base_vha ;
  void *tmp___1 ;
  int type ;
  uint32_t idc_control ;
  uint8_t *tmp_data ;
  long tmp___2 ;
  uint32_t idc_control___0 ;
  int tmp___3 ;
  void *tmp___4 ;

  {
#line 697
  __mptr = (struct kobject  const  *)kobj;
#line 697
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 697
  tmp___0 = shost_priv(tmp);
#line 697
  vha = (struct scsi_qla_host *)tmp___0;
#line 699
  ha = vha->hw;
#line 700
  tmp___1 = pci_get_drvdata(ha->pdev);
#line 700
  base_vha = (struct scsi_qla_host *)tmp___1;
#line 703
  tmp_data = (uint8_t *)0U;
#line 704
  if (off != 0LL) {
#line 705
    return (-22L);
  } else {

  }
#line 707
  tmp___2 = simple_strtol((char const   *)buf, (char **)0, 10U);
#line 707
  type = (int )tmp___2;
#line 708
  switch (type) {
  case 131676: 
#line 710
  ql_log(2U, vha, 28782, "Issuing ISP reset.\n");
#line 713
  scsi_block_requests(vha->host);
#line 714
  if ((ha->device_type & 16384U) != 0U) {
#line 715
    ha->flags.isp82xx_no_md_cap = 1U;
#line 716
    qla82xx_idc_lock(ha);
#line 717
    qla82xx_set_reset_owner(vha);
#line 718
    qla82xx_idc_unlock(ha);
  } else
#line 719
  if ((ha->device_type & 262144U) != 0U) {
#line 720
    qla8044_idc_lock(ha);
#line 721
    idc_control = qla8044_rd_reg(ha, 14224UL);
#line 723
    qla8044_wr_reg(ha, 14224UL, idc_control | 2U);
#line 725
    qla82xx_set_reset_owner(vha);
#line 726
    qla8044_idc_unlock(ha);
  } else {
#line 728
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 729
    qla2xxx_wake_dpc(vha);
  }
#line 731
  qla2x00_wait_for_chip_reset(vha);
#line 732
  scsi_unblock_requests(vha->host);
#line 733
  goto ldv_66194;
  case 131677: ;
#line 735
  if ((ha->device_type & 8192U) == 0U && ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U)) {
#line 736
    return (-1L);
  } else {

  }
#line 738
  ql_log(2U, vha, 28783, "Issuing MPI reset.\n");
#line 741
  if ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 744
    qla83xx_idc_lock(vha, 0);
#line 745
    __qla83xx_get_idc_control(vha, & idc_control___0);
#line 746
    idc_control___0 = idc_control___0 | 2U;
#line 747
    __qla83xx_set_idc_control(vha, idc_control___0);
#line 748
    qla83xx_wr_reg(vha, 571483012U, 4U);
#line 750
    qla83xx_idc_audit(vha, 0);
#line 751
    qla83xx_idc_unlock(vha, 0);
#line 752
    goto ldv_66194;
  } else {
#line 755
    qla2x00_wait_for_hba_online(vha);
#line 758
    scsi_block_requests(vha->host);
#line 759
    tmp___3 = qla81xx_restart_mpi_firmware(vha);
#line 759
    if (tmp___3 != 0) {
#line 760
      ql_log(1U, vha, 28784, "MPI reset failed.\n");
    } else {

    }
#line 762
    scsi_unblock_requests(vha->host);
#line 763
    goto ldv_66194;
  }
  case 131678: ;
#line 766
  if (((ha->device_type & 16384U) == 0U && (ha->device_type & 262144U) == 0U) || (unsigned long )vha != (unsigned long )base_vha) {
#line 767
    ql_log(2U, vha, 28785, "FCoE ctx reset no supported.\n");
#line 769
    return (-1L);
  } else {

  }
#line 772
  ql_log(2U, vha, 28786, "Issuing FCoE ctx reset.\n");
#line 774
  set_bit(18L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 775
  qla2xxx_wake_dpc(vha);
#line 776
  qla2x00_wait_for_fcoe_ctx_reset(vha);
#line 777
  goto ldv_66194;
  case 131679: ;
#line 779
  if ((ha->device_type & 65536U) == 0U) {
#line 780
    return (-1L);
  } else {

  }
#line 781
  ql_log(2U, vha, 28860, "Disabling Reset by IDC control\n");
#line 783
  qla83xx_idc_lock(vha, 0);
#line 784
  __qla83xx_get_idc_control(vha, & idc_control);
#line 785
  idc_control = idc_control | 1U;
#line 786
  __qla83xx_set_idc_control(vha, idc_control);
#line 787
  qla83xx_idc_unlock(vha, 0);
#line 788
  goto ldv_66194;
  case 131680: ;
#line 790
  if ((ha->device_type & 65536U) == 0U) {
#line 791
    return (-1L);
  } else {

  }
#line 792
  ql_log(2U, vha, 28861, "Enabling Reset by IDC control\n");
#line 794
  qla83xx_idc_lock(vha, 0);
#line 795
  __qla83xx_get_idc_control(vha, & idc_control);
#line 796
  idc_control = idc_control & 4294967294U;
#line 797
  __qla83xx_set_idc_control(vha, idc_control);
#line 798
  qla83xx_idc_unlock(vha, 0);
#line 799
  goto ldv_66194;
  case 131681: 
#line 801
  ql_dbg(8388608U, vha, 28896, "Updating cache versions without reset ");
#line 804
  tmp___4 = vmalloc(256UL);
#line 804
  tmp_data = (uint8_t *)tmp___4;
#line 805
  if ((unsigned long )tmp_data == (unsigned long )((uint8_t *)0U)) {
#line 806
    ql_log(1U, vha, 28897, "Unable to allocate memory for VPD information update.\n");
#line 808
    return (-12L);
  } else {

  }
#line 810
  (*((ha->isp_ops)->get_flash_version))(vha, (void *)tmp_data);
#line 811
  vfree((void const   *)tmp_data);
#line 812
  goto ldv_66194;
  }
  ldv_66194: ;
#line 814
  return ((ssize_t )count);
}
}
#line 817 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct bin_attribute sysfs_reset_attr  =    {{"reset", 128U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                   {(char)0}, {(char)0}, {(char)0}}}}, 0UL, 0, 0,
    & qla2x00_sysfs_write_reset, 0};
#line 827 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_sysfs_read_xgmac_stats(struct file *filp , struct kobject *kobj ,
                                              struct bin_attribute *bin_attr , char *buf ,
                                              loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  int rval ;
  uint16_t actual_size ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 831
  __mptr = (struct kobject  const  *)kobj;
#line 831
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 831
  tmp___0 = shost_priv(tmp);
#line 831
  vha = (struct scsi_qla_host *)tmp___0;
#line 833
  ha = vha->hw;
#line 837
  tmp___1 = capable(21);
#line 837
  if (tmp___1) {
#line 837
    tmp___2 = 0;
  } else {
#line 837
    tmp___2 = 1;
  }
#line 837
  if ((tmp___2 || off != 0LL) || count > 4096UL) {
#line 838
    return (0L);
  } else {

  }
#line 840
  if ((unsigned long )ha->xgmac_data != (unsigned long )((void *)0)) {
#line 841
    goto do_read;
  } else {

  }
#line 843
  ha->xgmac_data = dma_alloc_attrs(& (ha->pdev)->dev, 4096UL, & ha->xgmac_data_dma,
                                   208U, (struct dma_attrs *)0);
#line 845
  if ((unsigned long )ha->xgmac_data == (unsigned long )((void *)0)) {
#line 846
    ql_log(1U, vha, 28790, "Unable to allocate memory for XGMAC read-data.\n");
#line 848
    return (0L);
  } else {

  }
  do_read: 
#line 852
  actual_size = 0U;
#line 853
  memset(ha->xgmac_data, 0, 4096UL);
#line 855
  rval = qla2x00_get_xgmac_stats(vha, ha->xgmac_data_dma, 4096, & actual_size);
#line 857
  if (rval != 0) {
#line 858
    ql_log(1U, vha, 28791, "Unable to read XGMAC data (%x).\n", rval);
#line 860
    count = 0UL;
  } else {

  }
#line 863
  count = count < (size_t )actual_size ? count : (size_t )actual_size;
#line 864
  memcpy((void *)buf, (void const   *)ha->xgmac_data, count);
#line 866
  return ((ssize_t )count);
}
}
#line 869 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct bin_attribute sysfs_xgmac_stats_attr  =    {{"xgmac_stats", 256U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                         {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    0UL, 0, & qla2x00_sysfs_read_xgmac_stats, 0, 0};
#line 879 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_sysfs_read_dcbx_tlv(struct file *filp , struct kobject *kobj ,
                                           struct bin_attribute *bin_attr , char *buf ,
                                           loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  int rval ;
  uint16_t actual_size ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 883
  __mptr = (struct kobject  const  *)kobj;
#line 883
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 883
  tmp___0 = shost_priv(tmp);
#line 883
  vha = (struct scsi_qla_host *)tmp___0;
#line 885
  ha = vha->hw;
#line 889
  tmp___1 = capable(21);
#line 889
  if (tmp___1) {
#line 889
    tmp___2 = 0;
  } else {
#line 889
    tmp___2 = 1;
  }
#line 889
  if ((tmp___2 || off != 0LL) || count > 4096UL) {
#line 890
    return (0L);
  } else {

  }
#line 892
  if ((unsigned long )ha->dcbx_tlv != (unsigned long )((void *)0)) {
#line 893
    goto do_read;
  } else {

  }
#line 895
  ha->dcbx_tlv = dma_alloc_attrs(& (ha->pdev)->dev, 4096UL, & ha->dcbx_tlv_dma, 208U,
                                 (struct dma_attrs *)0);
#line 897
  if ((unsigned long )ha->dcbx_tlv == (unsigned long )((void *)0)) {
#line 898
    ql_log(1U, vha, 28792, "Unable to allocate memory for DCBX TLV read-data.\n");
#line 900
    return (-12L);
  } else {

  }
  do_read: 
#line 904
  actual_size = 0U;
#line 905
  memset(ha->dcbx_tlv, 0, 4096UL);
#line 907
  rval = qla2x00_get_dcbx_params(vha, ha->dcbx_tlv_dma, 4096);
#line 909
  if (rval != 0) {
#line 910
    ql_log(1U, vha, 28793, "Unable to read DCBX TLV (%x).\n", rval);
#line 912
    return (-5L);
  } else {

  }
#line 915
  memcpy((void *)buf, (void const   *)ha->dcbx_tlv, count);
#line 917
  return ((ssize_t )count);
}
}
#line 920 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct bin_attribute sysfs_dcbx_tlv_attr  =    {{"dcbx_tlv", 256U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                      {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    0UL, 0, & qla2x00_sysfs_read_dcbx_tlv, 0, 0};
#line 933 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct sysfs_entry bin_file_entries[11U]  = 
#line 933
  {      {(char *)"fw_dump", & sysfs_fw_dump_attr, 0}, 
        {(char *)"fw_dump_template", & sysfs_fw_dump_template_attr, 39}, 
        {(char *)"nvram", & sysfs_nvram_attr, 0}, 
        {(char *)"optrom", & sysfs_optrom_attr, 0}, 
        {(char *)"optrom_ctl", & sysfs_optrom_ctl_attr, 0}, 
        {(char *)"vpd", & sysfs_vpd_attr, 1}, 
        {(char *)"sfp", & sysfs_sfp_attr, 1}, 
        {(char *)"reset", & sysfs_reset_attr, 0}, 
        {(char *)"xgmac_stats", & sysfs_xgmac_stats_attr, 3}, 
        {(char *)"dcbx_tlv", & sysfs_dcbx_tlv_attr, 3}, 
        {(char *)0, 0, 0}};
#line 948 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
void qla2x00_alloc_sysfs_attr(scsi_qla_host_t *vha ) 
{ 
  struct Scsi_Host *host ;
  struct sysfs_entry *iter ;
  int ret ;

  {
#line 950
  host = vha->host;
#line 954
  iter = (struct sysfs_entry *)(& bin_file_entries);
#line 954
  goto ldv_66247;
  ldv_66246: ;
#line 955
  if (iter->is4GBp_only != 0 && ((vha->hw)->device_type & 134217728U) == 0U) {
#line 956
    goto ldv_66245;
  } else {

  }
#line 957
  if (iter->is4GBp_only == 2 && ((vha->hw)->device_type & 2048U) == 0U) {
#line 958
    goto ldv_66245;
  } else {

  }
#line 959
  if (iter->is4GBp_only == 3 && (((((vha->hw)->device_type & 8192U) == 0U && ((vha->hw)->device_type & 16384U) == 0U) && ((vha->hw)->device_type & 65536U) == 0U) && ((vha->hw)->device_type & 262144U) == 0U)) {
#line 960
    goto ldv_66245;
  } else {

  }
#line 961
  if (iter->is4GBp_only == 39 && (((vha->hw)->device_type & 524288U) == 0U && ((vha->hw)->device_type & 1048576U) == 0U)) {
#line 962
    goto ldv_66245;
  } else {

  }
#line 964
  ret = sysfs_create_bin_file(& host->shost_gendev.kobj, (struct bin_attribute  const  *)iter->attr);
#line 966
  if (ret != 0) {
#line 967
    ql_log(1U, vha, 243, "Unable to create sysfs %s binary attribute (%d).\n", iter->name,
           ret);
  } else {
#line 971
    ql_dbg(1073741824U, vha, 244, "Successfully created sysfs %s binary attribure.\n",
           iter->name);
  }
  ldv_66245: 
#line 954
  iter = iter + 1;
  ldv_66247: ;
#line 954
  if ((unsigned long )iter->name != (unsigned long )((char *)0)) {
#line 956
    goto ldv_66246;
  } else {

  }

#line 961
  return;
}
}
#line 978 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
void qla2x00_free_sysfs_attr(scsi_qla_host_t *vha , bool stop_beacon ) 
{ 
  struct Scsi_Host *host ;
  struct sysfs_entry *iter ;
  struct qla_hw_data *ha ;

  {
#line 980
  host = vha->host;
#line 982
  ha = vha->hw;
#line 984
  iter = (struct sysfs_entry *)(& bin_file_entries);
#line 984
  goto ldv_66258;
  ldv_66257: ;
#line 985
  if (iter->is4GBp_only != 0 && (ha->device_type & 134217728U) == 0U) {
#line 986
    goto ldv_66256;
  } else {

  }
#line 987
  if (iter->is4GBp_only == 2 && (ha->device_type & 2048U) == 0U) {
#line 988
    goto ldv_66256;
  } else {

  }
#line 989
  if (iter->is4GBp_only == 3 && (((((vha->hw)->device_type & 8192U) == 0U && ((vha->hw)->device_type & 16384U) == 0U) && ((vha->hw)->device_type & 65536U) == 0U) && ((vha->hw)->device_type & 262144U) == 0U)) {
#line 990
    goto ldv_66256;
  } else {

  }
#line 991
  if (iter->is4GBp_only == 39 && (((vha->hw)->device_type & 524288U) == 0U && ((vha->hw)->device_type & 1048576U) == 0U)) {
#line 992
    goto ldv_66256;
  } else {

  }
#line 994
  sysfs_remove_bin_file(& host->shost_gendev.kobj, (struct bin_attribute  const  *)iter->attr);
  ldv_66256: 
#line 984
  iter = iter + 1;
  ldv_66258: ;
#line 984
  if ((unsigned long )iter->name != (unsigned long )((char *)0)) {
#line 986
    goto ldv_66257;
  } else {

  }

#line 998
  if ((int )stop_beacon && (unsigned int )ha->beacon_blink_led == 1U) {
#line 999
    (*((ha->isp_ops)->beacon_off))(vha);
  } else {

  }
#line 1000
  return;
}
}
#line 1005 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_drvr_version_show(struct device *dev , struct device_attribute *attr ,
                                         char *buf ) 
{ 
  int tmp ;

  {
#line 1008
  tmp = scnprintf(buf, 4096UL, "%s\n", (char *)(& qla2x00_version_str));
#line 1008
  return ((ssize_t )tmp);
}
}
#line 1012 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_fw_version_show(struct device *dev , struct device_attribute *attr ,
                                       char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  char fw_str[128U] ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1015
  __mptr = (struct device  const  *)dev;
#line 1015
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1015
  vha = (scsi_qla_host_t *)tmp;
#line 1016
  ha = vha->hw;
#line 1019
  tmp___0 = (*((ha->isp_ops)->fw_version_str))(vha, (char *)(& fw_str), 128UL);
#line 1019
  tmp___1 = scnprintf(buf, 4096UL, "%s\n", tmp___0);
#line 1019
  return ((ssize_t )tmp___1);
}
}
#line 1024 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_serial_num_show(struct device *dev , struct device_attribute *attr ,
                                       char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  uint32_t sn ;
  int tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 1027
  __mptr = (struct device  const  *)dev;
#line 1027
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1027
  vha = (scsi_qla_host_t *)tmp;
#line 1028
  ha = vha->hw;
#line 1031
  if (((vha->hw)->device_type & 131072U) != 0U) {
#line 1032
    tmp___0 = scnprintf(buf, 4096UL, "%s\n", (uint8_t *)(& (vha->hw)->mr.serial_num));
#line 1032
    return ((ssize_t )tmp___0);
  } else
#line 1034
  if ((ha->device_type & 134217728U) != 0U) {
#line 1035
    qla2xxx_get_vpd_field(vha, (char *)"SN", buf, 4095UL);
#line 1036
    tmp___1 = strcat(buf, "\n");
#line 1036
    tmp___2 = strlen((char const   *)tmp___1);
#line 1036
    return ((ssize_t )tmp___2);
  } else {

  }
#line 1039
  sn = (uint32_t )(((((int )ha->serial0 & 31) << 16) | ((int )ha->serial2 << 8)) | (int )ha->serial1);
#line 1040
  tmp___3 = scnprintf(buf, 4096UL, "%c%05d\n", sn / 100000U + 65U, sn % 100000U);
#line 1040
  return ((ssize_t )tmp___3);
}
}
#line 1045 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_isp_name_show(struct device *dev , struct device_attribute *attr ,
                                     char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1048
  __mptr = (struct device  const  *)dev;
#line 1048
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1048
  vha = (scsi_qla_host_t *)tmp;
#line 1049
  tmp___0 = scnprintf(buf, 4096UL, "ISP%04X\n", (int )((vha->hw)->pdev)->device);
#line 1049
  return ((ssize_t )tmp___0);
}
}
#line 1053 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_isp_id_show(struct device *dev , struct device_attribute *attr ,
                                   char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1056
  __mptr = (struct device  const  *)dev;
#line 1056
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1056
  vha = (scsi_qla_host_t *)tmp;
#line 1057
  ha = vha->hw;
#line 1059
  if (((vha->hw)->device_type & 131072U) != 0U) {
#line 1060
    tmp___0 = scnprintf(buf, 4096UL, "%s\n", (uint8_t *)(& (vha->hw)->mr.hw_version));
#line 1060
    return ((ssize_t )tmp___0);
  } else {

  }
#line 1063
  tmp___1 = scnprintf(buf, 4096UL, "%04x %04x %04x %04x\n", (int )ha->product_id[0],
                      (int )ha->product_id[1], (int )ha->product_id[2], (int )ha->product_id[3]);
#line 1063
  return ((ssize_t )tmp___1);
}
}
#line 1069 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_model_name_show(struct device *dev , struct device_attribute *attr ,
                                       char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1072
  __mptr = (struct device  const  *)dev;
#line 1072
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1072
  vha = (scsi_qla_host_t *)tmp;
#line 1074
  tmp___0 = scnprintf(buf, 4096UL, "%s\n", (uint8_t *)(& (vha->hw)->model_number));
#line 1074
  return ((ssize_t )tmp___0);
}
}
#line 1078 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_model_desc_show(struct device *dev , struct device_attribute *attr ,
                                       char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1081
  __mptr = (struct device  const  *)dev;
#line 1081
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1081
  vha = (scsi_qla_host_t *)tmp;
#line 1082
  tmp___0 = scnprintf(buf, 4096UL, "%s\n", (unsigned long )(& (vha->hw)->model_desc) != (unsigned long )((char (*)[80])0) ? (char *)(& (vha->hw)->model_desc) : (char *)"");
#line 1082
  return ((ssize_t )tmp___0);
}
}
#line 1087 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_pci_info_show(struct device *dev , struct device_attribute *attr ,
                                     char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  char pci_info[30U] ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1090
  __mptr = (struct device  const  *)dev;
#line 1090
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1090
  vha = (scsi_qla_host_t *)tmp;
#line 1093
  tmp___0 = (*(((vha->hw)->isp_ops)->pci_info_str))(vha, (char *)(& pci_info));
#line 1093
  tmp___1 = scnprintf(buf, 4096UL, "%s\n", tmp___0);
#line 1093
  return ((ssize_t )tmp___1);
}
}
#line 1098 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_link_state_show(struct device *dev , struct device_attribute *attr ,
                                       char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int len ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1101
  __mptr = (struct device  const  *)dev;
#line 1101
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1101
  vha = (scsi_qla_host_t *)tmp;
#line 1102
  ha = vha->hw;
#line 1103
  len = 0;
#line 1105
  tmp___7 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 1105
  if (tmp___7 == 2) {
#line 1108
    len = scnprintf(buf, 4096UL, "Link Down\n");
  } else {
#line 1105
    tmp___8 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 1105
    if (tmp___8 == 6) {
#line 1108
      len = scnprintf(buf, 4096UL, "Link Down\n");
    } else
#line 1105
    if ((vha->device_flags & 2U) != 0U) {
#line 1108
      len = scnprintf(buf, 4096UL, "Link Down\n");
    } else {
#line 1109
      tmp___5 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 1109
      if (tmp___5 != 5) {
#line 1111
        len = scnprintf(buf, 4096UL, "Unknown Link State\n");
      } else {
#line 1109
        tmp___6 = qla2x00_reset_active(vha);
#line 1109
        if (tmp___6 != 0) {
#line 1111
          len = scnprintf(buf, 4096UL, "Unknown Link State\n");
        } else {
#line 1113
          len = scnprintf(buf, 4096UL, "Link Up - ");
#line 1115
          switch ((int )ha->current_topology) {
          case 1: 
#line 1117
          tmp___0 = scnprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len,
                              "Loop\n");
#line 1117
          len = tmp___0 + len;
#line 1118
          goto ldv_66338;
          case 4: 
#line 1120
          tmp___1 = scnprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len,
                              "FL_Port\n");
#line 1120
          len = tmp___1 + len;
#line 1121
          goto ldv_66338;
          case 2: 
#line 1123
          tmp___2 = scnprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len,
                              "N_Port to N_Port\n");
#line 1123
          len = tmp___2 + len;
#line 1125
          goto ldv_66338;
          case 8: 
#line 1127
          tmp___3 = scnprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len,
                              "F_Port\n");
#line 1127
          len = tmp___3 + len;
#line 1128
          goto ldv_66338;
          default: 
#line 1130
          tmp___4 = scnprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len,
                              "Loop\n");
#line 1130
          len = tmp___4 + len;
#line 1131
          goto ldv_66338;
          }
          ldv_66338: ;
        }
      }
    }
  }
#line 1134
  return ((ssize_t )len);
}
}
#line 1138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_zio_show(struct device *dev , struct device_attribute *attr ,
                                char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int len ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1141
  __mptr = (struct device  const  *)dev;
#line 1141
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1141
  vha = (scsi_qla_host_t *)tmp;
#line 1142
  len = 0;
#line 1144
  switch ((int )(vha->hw)->zio_mode) {
  case 6: 
#line 1146
  tmp___0 = scnprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len, "Mode 6\n");
#line 1146
  len = tmp___0 + len;
#line 1147
  goto ldv_66353;
  case 0: 
#line 1149
  tmp___1 = scnprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len, "Disabled\n");
#line 1149
  len = tmp___1 + len;
#line 1150
  goto ldv_66353;
  }
  ldv_66353: ;
#line 1152
  return ((ssize_t )len);
}
}
#line 1156 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_zio_store(struct device *dev , struct device_attribute *attr ,
                                 char const   *buf , size_t count ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int val ;
  uint16_t zio_mode ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 1159
  __mptr = (struct device  const  *)dev;
#line 1159
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1159
  vha = (scsi_qla_host_t *)tmp;
#line 1160
  ha = vha->hw;
#line 1161
  val = 0;
#line 1164
  if ((ha->device_type & 268435456U) == 0U) {
#line 1165
    return (-524L);
  } else {

  }
#line 1167
  tmp___0 = sscanf(buf, "%d", & val);
#line 1167
  if (tmp___0 != 1) {
#line 1168
    return (-22L);
  } else {

  }
#line 1170
  if (val != 0) {
#line 1171
    zio_mode = 6U;
  } else {
#line 1173
    zio_mode = 0U;
  }
#line 1176
  if ((unsigned int )zio_mode != 0U || (unsigned int )ha->zio_mode != 0U) {
#line 1177
    ha->zio_mode = zio_mode;
#line 1178
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
  } else {

  }
#line 1180
  tmp___1 = strlen(buf);
#line 1180
  return ((ssize_t )tmp___1);
}
}
#line 1184 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_zio_timer_show(struct device *dev , struct device_attribute *attr ,
                                      char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1187
  __mptr = (struct device  const  *)dev;
#line 1187
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1187
  vha = (scsi_qla_host_t *)tmp;
#line 1189
  tmp___0 = scnprintf(buf, 4096UL, "%d us\n", (int )(vha->hw)->zio_timer * 100);
#line 1189
  return ((ssize_t )tmp___0);
}
}
#line 1193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_zio_timer_store(struct device *dev , struct device_attribute *attr ,
                                       char const   *buf , size_t count ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int val ;
  uint16_t zio_timer ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 1196
  __mptr = (struct device  const  *)dev;
#line 1196
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1196
  vha = (scsi_qla_host_t *)tmp;
#line 1197
  val = 0;
#line 1200
  tmp___0 = sscanf(buf, "%d", & val);
#line 1200
  if (tmp___0 != 1) {
#line 1201
    return (-22L);
  } else {

  }
#line 1202
  if (val > 25500 || val <= 99) {
#line 1203
    return (-34L);
  } else {

  }
#line 1205
  zio_timer = (unsigned short )(val / 100);
#line 1206
  (vha->hw)->zio_timer = zio_timer;
#line 1208
  tmp___1 = strlen(buf);
#line 1208
  return ((ssize_t )tmp___1);
}
}
#line 1212 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_beacon_show(struct device *dev , struct device_attribute *attr ,
                                   char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int len ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1215
  __mptr = (struct device  const  *)dev;
#line 1215
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1215
  vha = (scsi_qla_host_t *)tmp;
#line 1216
  len = 0;
#line 1218
  if ((unsigned int )(vha->hw)->beacon_blink_led != 0U) {
#line 1219
    tmp___0 = scnprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len, "Enabled\n");
#line 1219
    len = tmp___0 + len;
  } else {
#line 1221
    tmp___1 = scnprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len, "Disabled\n");
#line 1221
    len = tmp___1 + len;
  }
#line 1222
  return ((ssize_t )len);
}
}
#line 1226 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_beacon_store(struct device *dev , struct device_attribute *attr ,
                                    char const   *buf , size_t count ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int val ;
  int rval ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1229
  __mptr = (struct device  const  *)dev;
#line 1229
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1229
  vha = (scsi_qla_host_t *)tmp;
#line 1230
  ha = vha->hw;
#line 1231
  val = 0;
#line 1234
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 1235
    return (-1L);
  } else {

  }
#line 1237
  tmp___0 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1237
  if (tmp___0 != 0) {
#line 1238
    ql_log(1U, vha, 28794, "Abort ISP active -- ignoring beacon request.\n");
#line 1240
    return (-16L);
  } else {

  }
#line 1243
  tmp___1 = sscanf(buf, "%d", & val);
#line 1243
  if (tmp___1 != 1) {
#line 1244
    return (-22L);
  } else {

  }
#line 1246
  if (val != 0) {
#line 1247
    rval = (*((ha->isp_ops)->beacon_on))(vha);
  } else {
#line 1249
    rval = (*((ha->isp_ops)->beacon_off))(vha);
  }
#line 1251
  if (rval != 0) {
#line 1252
    count = 0UL;
  } else {

  }
#line 1254
  return ((ssize_t )count);
}
}
#line 1258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_optrom_bios_version_show(struct device *dev , struct device_attribute *attr ,
                                                char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int tmp___0 ;

  {
#line 1261
  __mptr = (struct device  const  *)dev;
#line 1261
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1261
  vha = (scsi_qla_host_t *)tmp;
#line 1262
  ha = vha->hw;
#line 1263
  tmp___0 = scnprintf(buf, 4096UL, "%d.%02d\n", (int )ha->bios_revision[1], (int )ha->bios_revision[0]);
#line 1263
  return ((ssize_t )tmp___0);
}
}
#line 1268 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_optrom_efi_version_show(struct device *dev , struct device_attribute *attr ,
                                               char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int tmp___0 ;

  {
#line 1271
  __mptr = (struct device  const  *)dev;
#line 1271
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1271
  vha = (scsi_qla_host_t *)tmp;
#line 1272
  ha = vha->hw;
#line 1273
  tmp___0 = scnprintf(buf, 4096UL, "%d.%02d\n", (int )ha->efi_revision[1], (int )ha->efi_revision[0]);
#line 1273
  return ((ssize_t )tmp___0);
}
}
#line 1278 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_optrom_fcode_version_show(struct device *dev , struct device_attribute *attr ,
                                                 char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int tmp___0 ;

  {
#line 1281
  __mptr = (struct device  const  *)dev;
#line 1281
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1281
  vha = (scsi_qla_host_t *)tmp;
#line 1282
  ha = vha->hw;
#line 1283
  tmp___0 = scnprintf(buf, 4096UL, "%d.%02d\n", (int )ha->fcode_revision[1], (int )ha->fcode_revision[0]);
#line 1283
  return ((ssize_t )tmp___0);
}
}
#line 1288 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_optrom_fw_version_show(struct device *dev , struct device_attribute *attr ,
                                              char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int tmp___0 ;

  {
#line 1291
  __mptr = (struct device  const  *)dev;
#line 1291
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1291
  vha = (scsi_qla_host_t *)tmp;
#line 1292
  ha = vha->hw;
#line 1293
  tmp___0 = scnprintf(buf, 4096UL, "%d.%02d.%02d %d\n", ha->fw_revision[0], ha->fw_revision[1],
                      ha->fw_revision[2], ha->fw_revision[3]);
#line 1293
  return ((ssize_t )tmp___0);
}
}
#line 1299 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_optrom_gold_fw_version_show(struct device *dev , struct device_attribute *attr ,
                                                   char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1302
  __mptr = (struct device  const  *)dev;
#line 1302
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1302
  vha = (scsi_qla_host_t *)tmp;
#line 1303
  ha = vha->hw;
#line 1305
  if (((ha->device_type & 8192U) == 0U && ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U)) && ((ha->device_type & 524288U) == 0U && (ha->device_type & 1048576U) == 0U)) {
#line 1306
    tmp___0 = scnprintf(buf, 4096UL, "\n");
#line 1306
    return ((ssize_t )tmp___0);
  } else {

  }
#line 1308
  tmp___1 = scnprintf(buf, 4096UL, "%d.%02d.%02d (%d)\n", ha->gold_fw_version[0],
                      ha->gold_fw_version[1], ha->gold_fw_version[2], ha->gold_fw_version[3]);
#line 1308
  return ((ssize_t )tmp___1);
}
}
#line 1314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_total_isp_aborts_show(struct device *dev , struct device_attribute *attr ,
                                             char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1317
  __mptr = (struct device  const  *)dev;
#line 1317
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1317
  vha = (scsi_qla_host_t *)tmp;
#line 1318
  tmp___0 = scnprintf(buf, 4096UL, "%d\n", vha->qla_stats.total_isp_aborts);
#line 1318
  return ((ssize_t )tmp___0);
}
}
#line 1323 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla24xx_84xx_fw_version_show(struct device *dev , struct device_attribute *attr ,
                                            char *buf ) 
{ 
  int rval ;
  uint16_t status[2U] ;
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1326
  rval = 0;
#line 1327
  status[0] = 0U;
#line 1327
  status[1] = 0U;
#line 1328
  __mptr = (struct device  const  *)dev;
#line 1328
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1328
  vha = (scsi_qla_host_t *)tmp;
#line 1329
  ha = vha->hw;
#line 1331
  if ((ha->device_type & 4096U) == 0U) {
#line 1332
    tmp___0 = scnprintf(buf, 4096UL, "\n");
#line 1332
    return ((ssize_t )tmp___0);
  } else {

  }
#line 1334
  if ((ha->cs84xx)->op_fw_version == 0U) {
#line 1335
    rval = qla84xx_verify_chip(vha, (uint16_t *)(& status));
  } else {

  }
#line 1337
  if (rval == 0 && (unsigned int )status[0] == 0U) {
#line 1338
    tmp___1 = scnprintf(buf, 4096UL, "%u\n", (ha->cs84xx)->op_fw_version);
#line 1338
    return ((ssize_t )tmp___1);
  } else {

  }
#line 1341
  tmp___2 = scnprintf(buf, 4096UL, "\n");
#line 1341
  return ((ssize_t )tmp___2);
}
}
#line 1345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_mpi_version_show(struct device *dev , struct device_attribute *attr ,
                                        char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1348
  __mptr = (struct device  const  *)dev;
#line 1348
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1348
  vha = (scsi_qla_host_t *)tmp;
#line 1349
  ha = vha->hw;
#line 1351
  if (((ha->device_type & 8192U) == 0U && (ha->device_type & 65536U) == 0U) && (ha->device_type & 262144U) == 0U) {
#line 1352
    tmp___0 = scnprintf(buf, 4096UL, "\n");
#line 1352
    return ((ssize_t )tmp___0);
  } else {

  }
#line 1354
  tmp___1 = scnprintf(buf, 4096UL, "%d.%02d.%02d (%x)\n", (int )ha->mpi_version[0],
                      (int )ha->mpi_version[1], (int )ha->mpi_version[2], ha->mpi_capabilities);
#line 1354
  return ((ssize_t )tmp___1);
}
}
#line 1360 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_phy_version_show(struct device *dev , struct device_attribute *attr ,
                                        char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1363
  __mptr = (struct device  const  *)dev;
#line 1363
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1363
  vha = (scsi_qla_host_t *)tmp;
#line 1364
  ha = vha->hw;
#line 1366
  if ((ha->device_type & 8192U) == 0U && (ha->device_type & 65536U) == 0U) {
#line 1367
    tmp___0 = scnprintf(buf, 4096UL, "\n");
#line 1367
    return ((ssize_t )tmp___0);
  } else {

  }
#line 1369
  tmp___1 = scnprintf(buf, 4096UL, "%d.%02d.%02d\n", (int )ha->phy_version[0], (int )ha->phy_version[1],
                      (int )ha->phy_version[2]);
#line 1369
  return ((ssize_t )tmp___1);
}
}
#line 1374 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_flash_block_size_show(struct device *dev , struct device_attribute *attr ,
                                             char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int tmp___0 ;

  {
#line 1377
  __mptr = (struct device  const  *)dev;
#line 1377
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1377
  vha = (scsi_qla_host_t *)tmp;
#line 1378
  ha = vha->hw;
#line 1380
  tmp___0 = scnprintf(buf, 4096UL, "0x%x\n", ha->fdt_block_size);
#line 1380
  return ((ssize_t )tmp___0);
}
}
#line 1384 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_vlan_id_show(struct device *dev , struct device_attribute *attr ,
                                    char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1387
  __mptr = (struct device  const  *)dev;
#line 1387
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1387
  vha = (scsi_qla_host_t *)tmp;
#line 1389
  if (((((vha->hw)->device_type & 8192U) == 0U && ((vha->hw)->device_type & 16384U) == 0U) && ((vha->hw)->device_type & 65536U) == 0U) && ((vha->hw)->device_type & 262144U) == 0U) {
#line 1390
    tmp___0 = scnprintf(buf, 4096UL, "\n");
#line 1390
    return ((ssize_t )tmp___0);
  } else {

  }
#line 1392
  tmp___1 = scnprintf(buf, 4096UL, "%d\n", (int )vha->fcoe_vlan_id);
#line 1392
  return ((ssize_t )tmp___1);
}
}
#line 1396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_vn_port_mac_address_show(struct device *dev , struct device_attribute *attr ,
                                                char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1399
  __mptr = (struct device  const  *)dev;
#line 1399
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1399
  vha = (scsi_qla_host_t *)tmp;
#line 1401
  if (((((vha->hw)->device_type & 8192U) == 0U && ((vha->hw)->device_type & 16384U) == 0U) && ((vha->hw)->device_type & 65536U) == 0U) && ((vha->hw)->device_type & 262144U) == 0U) {
#line 1402
    tmp___0 = scnprintf(buf, 4096UL, "\n");
#line 1402
    return ((ssize_t )tmp___0);
  } else {

  }
#line 1404
  tmp___1 = scnprintf(buf, 4096UL, "%pMR\n", (uint8_t *)(& vha->fcoe_vn_port_mac));
#line 1404
  return ((ssize_t )tmp___1);
}
}
#line 1408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_fabric_param_show(struct device *dev , struct device_attribute *attr ,
                                         char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1411
  __mptr = (struct device  const  *)dev;
#line 1411
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1411
  vha = (scsi_qla_host_t *)tmp;
#line 1413
  tmp___0 = scnprintf(buf, 4096UL, "%d\n", (int )(vha->hw)->switch_cap);
#line 1413
  return ((ssize_t )tmp___0);
}
}
#line 1417 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_thermal_temp_show(struct device *dev , struct device_attribute *attr ,
                                         char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  uint16_t temp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1420
  __mptr = (struct device  const  *)dev;
#line 1420
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1420
  vha = (scsi_qla_host_t *)tmp;
#line 1421
  temp = 0U;
#line 1423
  tmp___0 = qla2x00_reset_active(vha);
#line 1423
  if (tmp___0 != 0) {
#line 1424
    ql_log(1U, vha, 28892, "ISP reset active.\n");
#line 1425
    goto done;
  } else {

  }
#line 1428
  if (*((unsigned long *)vha->hw + 2UL) != 0UL) {
#line 1429
    ql_log(1U, vha, 28893, "PCI EEH busy.\n");
#line 1430
    goto done;
  } else {

  }
#line 1433
  tmp___2 = qla2x00_get_thermal_temp(vha, & temp);
#line 1433
  if (tmp___2 == 0) {
#line 1434
    tmp___1 = scnprintf(buf, 4096UL, "%d\n", (int )temp);
#line 1434
    return ((ssize_t )tmp___1);
  } else {

  }
  done: 
#line 1437
  tmp___3 = scnprintf(buf, 4096UL, "\n");
#line 1437
  return ((ssize_t )tmp___3);
}
}
#line 1441 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_fw_state_show(struct device *dev , struct device_attribute *attr ,
                                     char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int rval ;
  uint16_t state[6U] ;
  uint32_t pstate ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1444
  __mptr = (struct device  const  *)dev;
#line 1444
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1444
  vha = (scsi_qla_host_t *)tmp;
#line 1445
  rval = 258;
#line 1449
  if (((vha->hw)->device_type & 131072U) != 0U) {
#line 1450
    pstate = qlafx00_fw_state_show(dev, attr, buf);
#line 1451
    tmp___0 = scnprintf(buf, 4096UL, "0x%x\n", pstate);
#line 1451
    return ((ssize_t )tmp___0);
  } else {

  }
#line 1454
  tmp___1 = qla2x00_reset_active(vha);
#line 1454
  if (tmp___1 != 0) {
#line 1455
    ql_log(1U, vha, 28796, "ISP reset active.\n");
  } else
#line 1457
  if (*((unsigned long *)vha->hw + 2UL) == 0UL) {
#line 1458
    rval = qla2x00_get_firmware_state(vha, (uint16_t *)(& state));
  } else {

  }
#line 1459
  if (rval != 0) {
#line 1460
    memset((void *)(& state), -1, 12UL);
  } else {

  }
#line 1462
  tmp___2 = scnprintf(buf, 4096UL, "0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n", (int )state[0],
                      (int )state[1], (int )state[2], (int )state[3], (int )state[4],
                      (int )state[5]);
#line 1462
  return ((ssize_t )tmp___2);
}
}
#line 1467 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_diag_requests_show(struct device *dev , struct device_attribute *attr ,
                                          char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1470
  __mptr = (struct device  const  *)dev;
#line 1470
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1470
  vha = (scsi_qla_host_t *)tmp;
#line 1472
  if (((vha->hw)->device_type & 2048U) == 0U && ((vha->hw)->device_type & 32768U) == 0U) {
#line 1473
    tmp___0 = scnprintf(buf, 4096UL, "\n");
#line 1473
    return ((ssize_t )tmp___0);
  } else {

  }
#line 1475
  tmp___1 = scnprintf(buf, 4096UL, "%llu\n", vha->bidi_stats.io_count);
#line 1475
  return ((ssize_t )tmp___1);
}
}
#line 1479 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_diag_megabytes_show(struct device *dev , struct device_attribute *attr ,
                                           char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1482
  __mptr = (struct device  const  *)dev;
#line 1482
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1482
  vha = (scsi_qla_host_t *)tmp;
#line 1484
  if (((vha->hw)->device_type & 2048U) == 0U && ((vha->hw)->device_type & 32768U) == 0U) {
#line 1485
    tmp___0 = scnprintf(buf, 4096UL, "\n");
#line 1485
    return ((ssize_t )tmp___0);
  } else {

  }
#line 1487
  tmp___1 = scnprintf(buf, 4096UL, "%llu\n", vha->bidi_stats.transfer_bytes >> 20);
#line 1487
  return ((ssize_t )tmp___1);
}
}
#line 1492 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_fw_dump_size_show(struct device *dev , struct device_attribute *attr ,
                                         char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  uint32_t size ;
  int tmp___0 ;

  {
#line 1495
  __mptr = (struct device  const  *)dev;
#line 1495
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1495
  vha = (scsi_qla_host_t *)tmp;
#line 1496
  ha = vha->hw;
#line 1499
  if (ha->fw_dumped == 0) {
#line 1500
    size = 0U;
  } else
#line 1501
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1502
    size = ha->md_template_size + ha->md_dump_size;
  } else {
#line 1504
    size = ha->fw_dump_len;
  }
#line 1506
  tmp___0 = scnprintf(buf, 4096UL, "%d\n", size);
#line 1506
  return ((ssize_t )tmp___0);
}
}
#line 1510 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_allow_cna_fw_dump_show(struct device *dev , struct device_attribute *attr ,
                                              char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1513
  __mptr = (struct device  const  *)dev;
#line 1513
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1513
  vha = (scsi_qla_host_t *)tmp;
#line 1515
  if (((vha->hw)->device_type & 16384U) == 0U && ((vha->hw)->device_type & 262144U) == 0U) {
#line 1516
    tmp___0 = scnprintf(buf, 4096UL, "\n");
#line 1516
    return ((ssize_t )tmp___0);
  } else {
#line 1518
    tmp___1 = scnprintf(buf, 4096UL, "%s\n", (vha->hw)->allow_cna_fw_dump != 0 ? (char *)"true" : (char *)"false");
#line 1518
    return ((ssize_t )tmp___1);
  }
}
}
#line 1523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static ssize_t qla2x00_allow_cna_fw_dump_store(struct device *dev , struct device_attribute *attr ,
                                               char const   *buf , size_t count ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int val ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 1526
  __mptr = (struct device  const  *)dev;
#line 1526
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 1526
  vha = (scsi_qla_host_t *)tmp;
#line 1527
  val = 0;
#line 1529
  if (((vha->hw)->device_type & 16384U) == 0U && ((vha->hw)->device_type & 262144U) == 0U) {
#line 1530
    return (-22L);
  } else {

  }
#line 1532
  tmp___0 = sscanf(buf, "%d", & val);
#line 1532
  if (tmp___0 != 1) {
#line 1533
    return (-22L);
  } else {

  }
#line 1535
  (vha->hw)->allow_cna_fw_dump = val != 0;
#line 1537
  tmp___1 = strlen(buf);
#line 1537
  return ((ssize_t )tmp___1);
}
}
#line 1540 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_driver_version  =    {{"driver_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                            {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_drvr_version_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                              char const   * , size_t  ))0};
#line 1541 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_fw_version  =    {{"fw_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                        {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_fw_version_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                            char const   * , size_t  ))0};
#line 1542 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_serial_num  =    {{"serial_num", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                        {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_serial_num_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                            char const   * , size_t  ))0};
#line 1543 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_isp_name  =    {{"isp_name", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                      {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_isp_name_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                          char const   * , size_t  ))0};
#line 1544 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_isp_id  =    {{"isp_id", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                    {(char)0}, {(char)0}, {(char)0}}}}, & qla2x00_isp_id_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 1545 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_model_name  =    {{"model_name", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                        {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_model_name_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                            char const   * , size_t  ))0};
#line 1546 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_model_desc  =    {{"model_desc", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                        {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_model_desc_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                            char const   * , size_t  ))0};
#line 1547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_pci_info  =    {{"pci_info", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                      {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_pci_info_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                          char const   * , size_t  ))0};
#line 1548 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_link_state  =    {{"link_state", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                        {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_link_state_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                            char const   * , size_t  ))0};
#line 1549 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_zio  =    {{"zio", 420U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                 {(char)0}, {(char)0}, {(char)0}}}}, & qla2x00_zio_show,
    & qla2x00_zio_store};
#line 1551 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_zio_timer  =    {{"zio_timer", 420U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                       {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_zio_timer_show, & qla2x00_zio_timer_store};
#line 1553 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_beacon  =    {{"beacon", 420U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                    {(char)0}, {(char)0}, {(char)0}}}}, & qla2x00_beacon_show,
    & qla2x00_beacon_store};
#line 1555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_optrom_bios_version  =    {{"optrom_bios_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0},
                                                 {(char)0}, {(char)0}, {(char)0},
                                                 {(char)0}, {(char)0}}}}, & qla2x00_optrom_bios_version_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 1557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_optrom_efi_version  =    {{"optrom_efi_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                                {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_optrom_efi_version_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                                    char const   * , size_t  ))0};
#line 1559 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_optrom_fcode_version  =    {{"optrom_fcode_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0},
                                                  {(char)0}, {(char)0}, {(char)0},
                                                  {(char)0}, {(char)0}}}}, & qla2x00_optrom_fcode_version_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 1561 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_optrom_fw_version  =    {{"optrom_fw_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                               {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_optrom_fw_version_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                                   char const   * , size_t  ))0};
#line 1563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_optrom_gold_fw_version  =    {{"optrom_gold_fw_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0},
                                                    {(char)0}, {(char)0}, {(char)0},
                                                    {(char)0}, {(char)0}}}}, & qla2x00_optrom_gold_fw_version_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 1565 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_84xx_fw_version  =    {{"84xx_fw_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                             {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla24xx_84xx_fw_version_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                                 char const   * , size_t  ))0};
#line 1567 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_total_isp_aborts  =    {{"total_isp_aborts", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                              {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_total_isp_aborts_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                                  char const   * , size_t  ))0};
#line 1568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_mpi_version  =    {{"mpi_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                         {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_mpi_version_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                             char const   * , size_t  ))0};
#line 1569 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_phy_version  =    {{"phy_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                         {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_phy_version_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                             char const   * , size_t  ))0};
#line 1571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_flash_block_size  =    {{"flash_block_size", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                              {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_flash_block_size_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                                  char const   * , size_t  ))0};
#line 1572 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_vlan_id  =    {{"vlan_id", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                     {(char)0}, {(char)0}, {(char)0}}}}, & qla2x00_vlan_id_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 1574 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_vn_port_mac_address  =    {{"vn_port_mac_address", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0},
                                                 {(char)0}, {(char)0}, {(char)0},
                                                 {(char)0}, {(char)0}}}}, & qla2x00_vn_port_mac_address_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 1575 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_fabric_param  =    {{"fabric_param", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                          {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_fabric_param_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                              char const   * , size_t  ))0};
#line 1576 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_fw_state  =    {{"fw_state", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                      {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_fw_state_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                          char const   * , size_t  ))0};
#line 1577 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_thermal_temp  =    {{"thermal_temp", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                          {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_thermal_temp_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                              char const   * , size_t  ))0};
#line 1578 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_diag_requests  =    {{"diag_requests", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                           {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_diag_requests_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                               char const   * , size_t  ))0};
#line 1579 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_diag_megabytes  =    {{"diag_megabytes", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                            {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_diag_megabytes_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                                char const   * , size_t  ))0};
#line 1580 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_fw_dump_size  =    {{"fw_dump_size", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                          {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_fw_dump_size_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                              char const   * , size_t  ))0};
#line 1583 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct device_attribute dev_attr_allow_cna_fw_dump  =    {{"allow_cna_fw_dump", 420U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                               {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_allow_cna_fw_dump_show, & qla2x00_allow_cna_fw_dump_store};
#line 1585 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
struct device_attribute *qla2x00_host_attrs[32U]  = 
#line 1585
  {      & dev_attr_driver_version,      & dev_attr_fw_version,      & dev_attr_serial_num,      & dev_attr_isp_name, 
        & dev_attr_isp_id,      & dev_attr_model_name,      & dev_attr_model_desc,      & dev_attr_pci_info, 
        & dev_attr_link_state,      & dev_attr_zio,      & dev_attr_zio_timer,      & dev_attr_beacon, 
        & dev_attr_optrom_bios_version,      & dev_attr_optrom_efi_version,      & dev_attr_optrom_fcode_version,      & dev_attr_optrom_fw_version, 
        & dev_attr_84xx_fw_version,      & dev_attr_total_isp_aborts,      & dev_attr_mpi_version,      & dev_attr_phy_version, 
        & dev_attr_flash_block_size,      & dev_attr_vlan_id,      & dev_attr_vn_port_mac_address,      & dev_attr_fabric_param, 
        & dev_attr_fw_state,      & dev_attr_optrom_gold_fw_version,      & dev_attr_thermal_temp,      & dev_attr_diag_requests, 
        & dev_attr_diag_megabytes,      & dev_attr_fw_dump_size,      & dev_attr_allow_cna_fw_dump,      (struct device_attribute *)0};
#line 1623 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static void qla2x00_get_host_port_id(struct Scsi_Host *shost ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 1625
  tmp = shost_priv(shost);
#line 1625
  vha = (scsi_qla_host_t *)tmp;
#line 1627
  ((struct fc_host_attrs *)shost->shost_data)->port_id = (u32 )((((int )vha->d_id.b.domain << 16) | ((int )vha->d_id.b.area << 8)) | (int )vha->d_id.b.al_pa);
#line 1629
  return;
}
}
#line 1632 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static void qla2x00_get_host_speed(struct Scsi_Host *shost ) 
{ 
  struct qla_hw_data *ha ;
  void *tmp ;
  u32 speed ;

  {
#line 1634
  tmp = shost_priv(shost);
#line 1634
  ha = ((struct scsi_qla_host *)tmp)->hw;
#line 1636
  speed = 0U;
#line 1638
  if ((ha->device_type & 131072U) != 0U) {
#line 1639
    qlafx00_get_host_speed(shost);
#line 1640
    return;
  } else {

  }
#line 1643
  switch ((int )ha->link_data_rate) {
  case 0: 
#line 1645
  speed = 1U;
#line 1646
  goto ldv_67001;
  case 1: 
#line 1648
  speed = 2U;
#line 1649
  goto ldv_67001;
  case 3: 
#line 1651
  speed = 8U;
#line 1652
  goto ldv_67001;
  case 4: 
#line 1654
  speed = 16U;
#line 1655
  goto ldv_67001;
  case 19: 
#line 1657
  speed = 4U;
#line 1658
  goto ldv_67001;
  case 5: 
#line 1660
  speed = 32U;
#line 1661
  goto ldv_67001;
  case 6: 
#line 1663
  speed = 64U;
#line 1664
  goto ldv_67001;
  }
  ldv_67001: 
#line 1666
  ((struct fc_host_attrs *)shost->shost_data)->speed = speed;
#line 1667
  return;
}
}
#line 1670 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static void qla2x00_get_host_port_type(struct Scsi_Host *shost ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  uint32_t port_type ;

  {
#line 1672
  tmp = shost_priv(shost);
#line 1672
  vha = (scsi_qla_host_t *)tmp;
#line 1673
  port_type = 0U;
#line 1675
  if ((unsigned int )vha->vp_idx != 0U) {
#line 1676
    ((struct fc_host_attrs *)shost->shost_data)->port_type = 7;
#line 1677
    return;
  } else {

  }
#line 1679
  switch ((int )(vha->hw)->current_topology) {
  case 1: 
#line 1681
  port_type = 5U;
#line 1682
  goto ldv_67014;
  case 4: 
#line 1684
  port_type = 4U;
#line 1685
  goto ldv_67014;
  case 2: 
#line 1687
  port_type = 6U;
#line 1688
  goto ldv_67014;
  case 8: 
#line 1690
  port_type = 3U;
#line 1691
  goto ldv_67014;
  }
  ldv_67014: 
#line 1693
  ((struct fc_host_attrs *)shost->shost_data)->port_type = (enum fc_port_type )port_type;
#line 1694
  return;
}
}
#line 1697 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static void qla2x00_get_starget_node_name(struct scsi_target *starget ) 
{ 
  struct Scsi_Host *host ;
  struct Scsi_Host *tmp ;
  scsi_qla_host_t *vha ;
  void *tmp___0 ;
  fc_port_t *fcport ;
  u64 node_name ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1699
  tmp = dev_to_shost(starget->dev.parent);
#line 1699
  host = tmp;
#line 1700
  tmp___0 = shost_priv(host);
#line 1700
  vha = (scsi_qla_host_t *)tmp___0;
#line 1702
  node_name = 0ULL;
#line 1704
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 1704
  fcport = (fc_port_t *)__mptr;
#line 1704
  goto ldv_67031;
  ldv_67030: ;
#line 1705
  if ((unsigned long )fcport->rport != (unsigned long )((struct fc_rport *)0) && starget->id == (fcport->rport)->scsi_target_id) {
#line 1707
    node_name = wwn_to_u64((u8 *)(& fcport->node_name));
#line 1708
    goto ldv_67029;
  } else {

  }
#line 1704
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 1704
  fcport = (fc_port_t *)__mptr___0;
  ldv_67031: ;
#line 1704
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 1706
    goto ldv_67030;
  } else {

  }
  ldv_67029: 
#line 1712
  ((struct fc_starget_attrs *)(& starget->starget_data))->node_name = node_name;
#line 1713
  return;
}
}
#line 1716 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static void qla2x00_get_starget_port_name(struct scsi_target *starget ) 
{ 
  struct Scsi_Host *host ;
  struct Scsi_Host *tmp ;
  scsi_qla_host_t *vha ;
  void *tmp___0 ;
  fc_port_t *fcport ;
  u64 port_name ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1718
  tmp = dev_to_shost(starget->dev.parent);
#line 1718
  host = tmp;
#line 1719
  tmp___0 = shost_priv(host);
#line 1719
  vha = (scsi_qla_host_t *)tmp___0;
#line 1721
  port_name = 0ULL;
#line 1723
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 1723
  fcport = (fc_port_t *)__mptr;
#line 1723
  goto ldv_67045;
  ldv_67044: ;
#line 1724
  if ((unsigned long )fcport->rport != (unsigned long )((struct fc_rport *)0) && starget->id == (fcport->rport)->scsi_target_id) {
#line 1726
    port_name = wwn_to_u64((u8 *)(& fcport->port_name));
#line 1727
    goto ldv_67043;
  } else {

  }
#line 1723
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 1723
  fcport = (fc_port_t *)__mptr___0;
  ldv_67045: ;
#line 1723
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 1725
    goto ldv_67044;
  } else {

  }
  ldv_67043: 
#line 1731
  ((struct fc_starget_attrs *)(& starget->starget_data))->port_name = port_name;
#line 1732
  return;
}
}
#line 1735 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static void qla2x00_get_starget_port_id(struct scsi_target *starget ) 
{ 
  struct Scsi_Host *host ;
  struct Scsi_Host *tmp ;
  scsi_qla_host_t *vha ;
  void *tmp___0 ;
  fc_port_t *fcport ;
  uint32_t port_id ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1737
  tmp = dev_to_shost(starget->dev.parent);
#line 1737
  host = tmp;
#line 1738
  tmp___0 = shost_priv(host);
#line 1738
  vha = (scsi_qla_host_t *)tmp___0;
#line 1740
  port_id = 4294967295U;
#line 1742
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 1742
  fcport = (fc_port_t *)__mptr;
#line 1742
  goto ldv_67059;
  ldv_67058: ;
#line 1743
  if ((unsigned long )fcport->rport != (unsigned long )((struct fc_rport *)0) && starget->id == (fcport->rport)->scsi_target_id) {
#line 1745
    port_id = (uint32_t )((((int )fcport->d_id.b.domain << 16) | ((int )fcport->d_id.b.area << 8)) | (int )fcport->d_id.b.al_pa);
#line 1747
    goto ldv_67057;
  } else {

  }
#line 1742
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 1742
  fcport = (fc_port_t *)__mptr___0;
  ldv_67059: ;
#line 1742
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 1744
    goto ldv_67058;
  } else {

  }
  ldv_67057: 
#line 1751
  ((struct fc_starget_attrs *)(& starget->starget_data))->port_id = port_id;
#line 1752
  return;
}
}
#line 1755 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static void qla2x00_set_rport_loss_tmo(struct fc_rport *rport , uint32_t timeout ) 
{ 


  {
#line 1757
  if (timeout != 0U) {
#line 1758
    rport->dev_loss_tmo = timeout;
  } else {
#line 1760
    rport->dev_loss_tmo = 1U;
  }
#line 1761
  return;
}
}
#line 1764 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static void qla2x00_dev_loss_tmo_callbk(struct fc_rport *rport ) 
{ 
  struct Scsi_Host *host ;
  struct Scsi_Host *tmp ;
  fc_port_t *fcport ;
  unsigned long flags ;
  raw_spinlock_t *tmp___0 ;
  struct fc_rport *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 1766
  tmp = dev_to_shost(rport->dev.parent);
#line 1766
  host = tmp;
#line 1767
  fcport = *((fc_port_t **)rport->dd_data);
#line 1770
  if ((unsigned long )fcport == (unsigned long )((fc_port_t *)0)) {
#line 1771
    return;
  } else {

  }
#line 1775
  qla2x00_set_fcport_state___1(fcport, 2);
#line 1781
  tmp___0 = spinlock_check(host->host_lock);
#line 1781
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 1782
  tmp___1 = (struct fc_rport *)0;
#line 1782
  fcport->drport = tmp___1;
#line 1782
  fcport->rport = tmp___1;
#line 1783
  *((fc_port_t **)rport->dd_data) = (fc_port_t *)0;
#line 1784
  spin_unlock_irqrestore(host->host_lock, flags);
#line 1786
  tmp___2 = constant_test_bit(3L, (unsigned long const volatile   *)(& (fcport->vha)->dpc_flags));
#line 1786
  if (tmp___2 != 0) {
#line 1787
    return;
  } else {

  }
#line 1789
  tmp___3 = pci_channel_offline(((fcport->vha)->hw)->pdev);
#line 1789
  tmp___4 = ldv__builtin_expect(tmp___3 != 0, 0L);
#line 1789
  if (tmp___4 != 0L) {
#line 1790
    qla2x00_abort_all_cmds(fcport->vha, 65536);
#line 1791
    return;
  } else {

  }
#line 1793
  return;
}
}
#line 1796 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static void qla2x00_terminate_rport_io(struct fc_rport *rport ) 
{ 
  fc_port_t *fcport ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 1798
  fcport = *((fc_port_t **)rport->dd_data);
#line 1800
  if ((unsigned long )fcport == (unsigned long )((fc_port_t *)0)) {
#line 1801
    return;
  } else {

  }
#line 1803
  tmp = constant_test_bit(3L, (unsigned long const volatile   *)(& (fcport->vha)->dpc_flags));
#line 1803
  if (tmp != 0) {
#line 1804
    return;
  } else {

  }
#line 1806
  tmp___0 = pci_channel_offline(((fcport->vha)->hw)->pdev);
#line 1806
  tmp___1 = ldv__builtin_expect(tmp___0 != 0, 0L);
#line 1806
  if (tmp___1 != 0L) {
#line 1807
    qla2x00_abort_all_cmds(fcport->vha, 65536);
#line 1808
    return;
  } else {

  }
#line 1814
  if ((unsigned int )fcport->loop_id != 4096U) {
#line 1815
    if ((((fcport->vha)->hw)->device_type & 134217728U) != 0U) {
#line 1816
      (*((((fcport->vha)->hw)->isp_ops)->fabric_logout))(fcport->vha, (int )fcport->loop_id,
                                                         (int )fcport->d_id.b.domain,
                                                         (int )fcport->d_id.b.area,
                                                         (int )fcport->d_id.b.al_pa);
    } else {
#line 1820
      qla2x00_port_logout(fcport->vha, fcport);
    }
  } else {

  }
#line 1821
  return;
}
}
#line 1825 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static int qla2x00_issue_lip(struct Scsi_Host *shost ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 1827
  tmp = shost_priv(shost);
#line 1827
  vha = (scsi_qla_host_t *)tmp;
#line 1829
  if (((vha->hw)->device_type & 131072U) != 0U) {
#line 1830
    return (0);
  } else {

  }
#line 1832
  qla2x00_loop_reset(vha);
#line 1833
  return (0);
}
}
#line 1837 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static struct fc_host_statistics *qla2x00_get_fc_host_stats(struct Scsi_Host *shost ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  struct scsi_qla_host *base_vha ;
  void *tmp___0 ;
  int rval ;
  struct link_statistics *stats ;
  dma_addr_t stats_dma ;
  struct fc_host_statistics *pfc_host_stat ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  u64 tmp___7 ;
  uint32_t __base ;
  uint32_t __rem ;

  {
#line 1839
  tmp = shost_priv(shost);
#line 1839
  vha = (scsi_qla_host_t *)tmp;
#line 1840
  ha = vha->hw;
#line 1841
  tmp___0 = pci_get_drvdata(ha->pdev);
#line 1841
  base_vha = (struct scsi_qla_host *)tmp___0;
#line 1847
  pfc_host_stat = & vha->fc_host_stat;
#line 1848
  memset((void *)pfc_host_stat, -1, 232UL);
#line 1850
  if (((vha->hw)->device_type & 131072U) != 0U) {
#line 1851
    goto done;
  } else {

  }
#line 1853
  tmp___1 = constant_test_bit(15L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1853
  if (tmp___1 != 0) {
#line 1854
    goto done;
  } else {

  }
#line 1856
  tmp___2 = pci_channel_offline(ha->pdev);
#line 1856
  tmp___3 = ldv__builtin_expect(tmp___2 != 0, 0L);
#line 1856
  if (tmp___3 != 0L) {
#line 1857
    goto done;
  } else {

  }
#line 1859
  tmp___4 = qla2x00_reset_active(vha);
#line 1859
  if (tmp___4 != 0) {
#line 1860
    goto done;
  } else {

  }
#line 1862
  tmp___5 = dma_pool_alloc(ha->s_dma_pool, 208U, & stats_dma);
#line 1862
  stats = (struct link_statistics *)tmp___5;
#line 1863
  if ((unsigned long )stats == (unsigned long )((struct link_statistics *)0)) {
#line 1864
    ql_log(1U, vha, 28797, "Failed to allocate memory for stats.\n");
#line 1866
    goto done;
  } else {

  }
#line 1868
  memset((void *)stats, 0, 256UL);
#line 1870
  rval = 258;
#line 1871
  if ((ha->device_type & 134217728U) != 0U) {
#line 1872
    rval = qla24xx_get_isp_stats(base_vha, stats, stats_dma);
  } else {
#line 1873
    tmp___6 = atomic_read((atomic_t const   *)(& base_vha->loop_state));
#line 1873
    if (tmp___6 == 5 && (unsigned int )ha->dpc_active == 0U) {
#line 1876
      rval = qla2x00_get_link_status(base_vha, (int )base_vha->loop_id, stats, stats_dma);
    } else {

    }
  }
#line 1880
  if (rval != 0) {
#line 1881
    goto done_free;
  } else {

  }
#line 1883
  pfc_host_stat->link_failure_count = (u64 )stats->link_fail_cnt;
#line 1884
  pfc_host_stat->loss_of_sync_count = (u64 )stats->loss_sync_cnt;
#line 1885
  pfc_host_stat->loss_of_signal_count = (u64 )stats->loss_sig_cnt;
#line 1886
  pfc_host_stat->prim_seq_protocol_err_count = (u64 )stats->prim_seq_err_cnt;
#line 1887
  pfc_host_stat->invalid_tx_word_count = (u64 )stats->inval_xmit_word_cnt;
#line 1888
  pfc_host_stat->invalid_crc_count = (u64 )stats->inval_crc_cnt;
#line 1889
  if ((ha->device_type & 134217728U) != 0U) {
#line 1890
    pfc_host_stat->lip_count = (u64 )stats->lip_cnt;
#line 1891
    pfc_host_stat->tx_frames = (u64 )stats->tx_frames;
#line 1892
    pfc_host_stat->rx_frames = (u64 )stats->rx_frames;
#line 1893
    pfc_host_stat->dumped_frames = (u64 )stats->discarded_frames;
#line 1894
    pfc_host_stat->nos_count = (u64 )stats->nos_rcvd;
#line 1895
    pfc_host_stat->error_frames = (u64 )(stats->dropped_frames + stats->discarded_frames);
#line 1897
    pfc_host_stat->rx_words = vha->qla_stats.input_bytes;
#line 1898
    pfc_host_stat->tx_words = vha->qla_stats.output_bytes;
  } else {

  }
#line 1900
  pfc_host_stat->fcp_control_requests = (u64 )vha->qla_stats.control_requests;
#line 1901
  pfc_host_stat->fcp_input_requests = vha->qla_stats.input_requests;
#line 1902
  pfc_host_stat->fcp_output_requests = vha->qla_stats.output_requests;
#line 1903
  pfc_host_stat->fcp_input_megabytes = vha->qla_stats.input_bytes >> 20;
#line 1904
  pfc_host_stat->fcp_output_megabytes = vha->qla_stats.output_bytes >> 20;
#line 1905
  tmp___7 = get_jiffies_64();
#line 1905
  pfc_host_stat->seconds_since_last_reset = tmp___7 - vha->qla_stats.jiffies_at_last_reset;
#line 1907
  __base = 250U;
#line 1907
  __rem = (uint32_t )(pfc_host_stat->seconds_since_last_reset % (u64 )__base);
#line 1907
  pfc_host_stat->seconds_since_last_reset = pfc_host_stat->seconds_since_last_reset / (u64 )__base;
  done_free: 
#line 1910
  dma_pool_free(ha->s_dma_pool, (void *)stats, stats_dma);
  done: ;
#line 1912
  return (pfc_host_stat);
}
}
#line 1916 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static void qla2x00_reset_host_stats(struct Scsi_Host *shost ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 1918
  tmp = shost_priv(shost);
#line 1918
  vha = (scsi_qla_host_t *)tmp;
#line 1920
  memset((void *)(& vha->fc_host_stat), 0, 232UL);
#line 1922
  vha->qla_stats.jiffies_at_last_reset = get_jiffies_64();
#line 1923
  return;
}
}
#line 1926 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static void qla2x00_get_host_symbolic_name(struct Scsi_Host *shost ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 1928
  tmp = shost_priv(shost);
#line 1928
  vha = (scsi_qla_host_t *)tmp;
#line 1930
  qla2x00_get_sym_node_name(vha, (uint8_t *)(& ((struct fc_host_attrs *)shost->shost_data)->symbolic_name),
                            256UL);
#line 1931
  return;
}
}
#line 1935 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static void qla2x00_set_host_system_hostname(struct Scsi_Host *shost ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 1937
  tmp = shost_priv(shost);
#line 1937
  vha = (scsi_qla_host_t *)tmp;
#line 1939
  set_bit(12L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1940
  return;
}
}
#line 1943 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static void qla2x00_get_host_fabric_name(struct Scsi_Host *shost ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  uint8_t node_name[8U] ;
  u64 fabric_name ;
  u64 tmp___0 ;

  {
#line 1945
  tmp = shost_priv(shost);
#line 1945
  vha = (scsi_qla_host_t *)tmp;
#line 1946
  node_name[0] = 255U;
#line 1946
  node_name[1] = 255U;
#line 1946
  node_name[2] = 255U;
#line 1946
  node_name[3] = 255U;
#line 1946
  node_name[4] = 255U;
#line 1946
  node_name[5] = 255U;
#line 1946
  node_name[6] = 255U;
#line 1946
  node_name[7] = 255U;
#line 1948
  tmp___0 = wwn_to_u64((u8 *)(& node_name));
#line 1948
  fabric_name = tmp___0;
#line 1950
  if ((int )vha->device_flags & 1) {
#line 1951
    fabric_name = wwn_to_u64((u8 *)(& vha->fabric_node_name));
  } else {

  }
#line 1953
  ((struct fc_host_attrs *)shost->shost_data)->fabric_name = fabric_name;
#line 1954
  return;
}
}
#line 1957 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static void qla2x00_get_host_port_state(struct Scsi_Host *shost ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct scsi_qla_host *base_vha ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1959
  tmp = shost_priv(shost);
#line 1959
  vha = (scsi_qla_host_t *)tmp;
#line 1960
  tmp___0 = pci_get_drvdata((vha->hw)->pdev);
#line 1960
  base_vha = (struct scsi_qla_host *)tmp___0;
#line 1962
  if (*((unsigned long *)base_vha + 19UL) == 0UL) {
#line 1963
    ((struct fc_host_attrs *)shost->shost_data)->port_state = 3;
#line 1964
    return;
  } else {

  }
#line 1967
  tmp___1 = atomic_read((atomic_t const   *)(& base_vha->loop_state));
#line 1967
  switch (tmp___1) {
  case 4: 
#line 1969
  ((struct fc_host_attrs *)shost->shost_data)->port_state = 6;
#line 1970
  goto ldv_67120;
  case 2: 
#line 1972
  tmp___2 = constant_test_bit(4L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 1972
  if (tmp___2 != 0) {
#line 1973
    ((struct fc_host_attrs *)shost->shost_data)->port_state = 6;
  } else {
#line 1975
    ((struct fc_host_attrs *)shost->shost_data)->port_state = 7;
  }
#line 1976
  goto ldv_67120;
  case 6: 
#line 1978
  ((struct fc_host_attrs *)shost->shost_data)->port_state = 7;
#line 1979
  goto ldv_67120;
  case 5: 
#line 1981
  ((struct fc_host_attrs *)shost->shost_data)->port_state = 2;
#line 1982
  goto ldv_67120;
  default: 
#line 1984
  ((struct fc_host_attrs *)shost->shost_data)->port_state = 0;
#line 1985
  goto ldv_67120;
  }
  ldv_67120: ;
#line 1988
  return;
}
}
#line 1990 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static int qla24xx_vport_create(struct fc_vport *fc_vport , bool disable ) 
{ 
  int ret ;
  uint8_t qos ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  uint16_t options ;
  int cnt ;
  struct req_que *req ;
  int tmp___0 ;
  int tmp___1 ;
  int prot ;
  int guard ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1992
  ret = 0;
#line 1993
  qos = 0U;
#line 1994
  tmp = shost_priv(fc_vport->shost);
#line 1994
  base_vha = (scsi_qla_host_t *)tmp;
#line 1995
  vha = (scsi_qla_host_t *)0;
#line 1996
  ha = base_vha->hw;
#line 1997
  options = 0U;
#line 1999
  req = *(ha->req_q_map);
#line 2001
  ret = qla24xx_vport_create_req_sanity_check(fc_vport);
#line 2002
  if (ret != 0) {
#line 2003
    ql_log(1U, vha, 28798, "Vport sanity check failed, status %x\n", ret);
#line 2005
    return (ret);
  } else {

  }
#line 2008
  vha = qla24xx_create_vhost(fc_vport);
#line 2009
  if ((unsigned long )vha == (unsigned long )((scsi_qla_host_t *)0)) {
#line 2010
    ql_log(1U, vha, 28799, "Vport create host failed.\n");
#line 2011
    return (9);
  } else {

  }
#line 2013
  if ((int )disable) {
#line 2014
    atomic_set(& vha->vp_state, 0);
#line 2015
    fc_vport_set_state(fc_vport, 2);
  } else {
#line 2017
    atomic_set(& vha->vp_state, 2);
  }
#line 2020
  ql_log(2U, vha, 28800, "VP entry id %d assigned.\n", (int )vha->vp_idx);
#line 2024
  atomic_set(& vha->loop_state, 2);
#line 2025
  vha->vp_err_state = 1U;
#line 2026
  vha->vp_prev_err_state = 0U;
#line 2028
  tmp___0 = atomic_read((atomic_t const   *)(& base_vha->loop_state));
#line 2028
  if (tmp___0 == 2) {
#line 2028
    goto _L;
  } else {
#line 2028
    tmp___1 = atomic_read((atomic_t const   *)(& base_vha->loop_state));
#line 2028
    if (tmp___1 == 6) {
      _L: /* CIL Label */ 
#line 2031
      ql_dbg(8388608U, vha, 28801, "Vport loop state is not UP.\n");
#line 2033
      atomic_set(& vha->loop_state, 6);
#line 2034
      if (! disable) {
#line 2035
        fc_vport_set_state(fc_vport, 3);
      } else {

      }
    } else {

    }
  }
#line 2038
  if ((ha->device_type & 33554432U) != 0U && ql2xenabledif != 0) {
#line 2039
    if (((int )ha->fw_attributes & 16) != 0) {
#line 2040
      prot = 0;
#line 2041
      vha->flags.difdix_supported = 1U;
#line 2042
      ql_dbg(8388608U, vha, 28802, "Registered for DIF/DIX type 1 and 3 protection.\n");
#line 2044
      if (ql2xenabledif == 1) {
#line 2045
        prot = 8;
      } else {

      }
#line 2046
      scsi_host_set_prot(vha->host, (unsigned int )(prot | 119));
#line 2054
      guard = 1;
#line 2056
      if (((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) && ql2xenabledif > 1) {
#line 2058
        guard = guard | 2;
      } else {

      }
#line 2060
      scsi_host_set_guard(vha->host, (int )((unsigned char )guard));
    } else {
#line 2062
      vha->flags.difdix_supported = 0U;
    }
  } else {

  }
#line 2065
  tmp___2 = ldv_scsi_add_host_with_dma_183(vha->host, & fc_vport->dev, & (ha->pdev)->dev);
#line 2065
  if (tmp___2 != 0) {
#line 2067
    ql_dbg(8388608U, vha, 28803, "scsi_add_host failure for VP[%d].\n", (int )vha->vp_idx);
#line 2069
    goto vport_create_failed_2;
  } else {

  }
#line 2073
  ((struct fc_host_attrs *)(vha->host)->shost_data)->dev_loss_tmo = (u32 )ha->port_down_retry_count;
#line 2074
  ((struct fc_host_attrs *)(vha->host)->shost_data)->node_name = wwn_to_u64((u8 *)(& vha->node_name));
#line 2075
  ((struct fc_host_attrs *)(vha->host)->shost_data)->port_name = wwn_to_u64((u8 *)(& vha->port_name));
#line 2076
  ((struct fc_host_attrs *)(vha->host)->shost_data)->supported_classes = ((struct fc_host_attrs *)(base_vha->host)->shost_data)->supported_classes;
#line 2078
  ((struct fc_host_attrs *)(vha->host)->shost_data)->supported_speeds = ((struct fc_host_attrs *)(base_vha->host)->shost_data)->supported_speeds;
#line 2081
  qlt_vport_create(vha, ha);
#line 2082
  qla24xx_vport_disable(fc_vport, (int )disable);
#line 2084
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 2085
    req = *(ha->req_q_map + 1UL);
#line 2086
    ql_dbg(1048576U, vha, 49152, "Request queue %p attached with VP[%d], cpu affinity =%d\n",
           req, (int )vha->vp_idx, (int )ha->flags.cpu_affinity_enabled);
#line 2090
    goto vport_queue;
  } else
#line 2091
  if (ql2xmaxqueues == 1 || (unsigned long )ha->npiv_info == (unsigned long )((struct qla_npiv_entry *)0)) {
#line 2092
    goto vport_queue;
  } else {

  }
#line 2094
  cnt = 0;
#line 2094
  goto ldv_67143;
  ldv_67142: 
#line 2095
  tmp___3 = memcmp((void const   *)(& (ha->npiv_info + (unsigned long )cnt)->port_name),
                   (void const   *)(& vha->port_name), 8UL);
#line 2095
  if (tmp___3 == 0) {
#line 2095
    tmp___4 = memcmp((void const   *)(& (ha->npiv_info + (unsigned long )cnt)->node_name),
                     (void const   *)(& vha->node_name), 8UL);
#line 2095
    if (tmp___4 == 0) {
#line 2098
      qos = (ha->npiv_info + (unsigned long )cnt)->q_qos;
#line 2099
      goto ldv_67141;
    } else {

    }
  } else {

  }
#line 2094
  cnt = cnt + 1;
  ldv_67143: ;
#line 2094
  if ((int )ha->nvram_npiv_size > cnt) {
#line 2096
    goto ldv_67142;
  } else {

  }
  ldv_67141: ;
#line 2103
  if ((unsigned int )qos != 0U) {
#line 2104
    ret = qla25xx_create_req_que(ha, (int )options, (int )((uint8_t )vha->vp_idx),
                                 0, 0, (int )qos);
#line 2106
    if (ret == 0) {
#line 2107
      ql_log(1U, vha, 28804, "Can\'t create request queue for VP[%d]\n", (int )vha->vp_idx);
    } else {
#line 2111
      ql_dbg(1048576U, vha, 49153, "Request Que:%d Q0s: %d) created for VP[%d]\n",
             ret, (int )qos, (int )vha->vp_idx);
#line 2114
      ql_dbg(8388608U, vha, 28805, "Request Que:%d Q0s: %d) created for VP[%d]\n",
             ret, (int )qos, (int )vha->vp_idx);
#line 2117
      req = *(ha->req_q_map + (unsigned long )ret);
    }
  } else {

  }
  vport_queue: 
#line 2122
  vha->req = req;
#line 2123
  return (0);
  vport_create_failed_2: 
#line 2126
  qla24xx_disable_vp(vha);
#line 2127
  qla24xx_deallocate_vp_id(vha);
#line 2128
  scsi_host_put(vha->host);
#line 2129
  return (9);
}
}
#line 2133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static int qla24xx_vport_delete(struct fc_vport *fc_vport ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  uint16_t id ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
#line 2135
  vha = (scsi_qla_host_t *)fc_vport->dd_data;
#line 2136
  ha = vha->hw;
#line 2137
  id = vha->vp_idx;
#line 2139
  goto ldv_67151;
  ldv_67150: 
#line 2141
  msleep(1000U);
  ldv_67151: 
#line 2139
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 2139
  if (tmp != 0) {
#line 2141
    goto ldv_67150;
  } else {
#line 2139
    tmp___0 = constant_test_bit(13L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 2139
    if (tmp___0 != 0) {
#line 2141
      goto ldv_67150;
    } else {
#line 2144
      goto ldv_67152;
    }
  }
  ldv_67152: 
#line 2143
  qla24xx_disable_vp(vha);
#line 2145
  vha->flags.delete_progress = 1U;
#line 2147
  qlt_remove_target(ha, vha);
#line 2149
  fc_remove_host(vha->host);
#line 2151
  ldv_scsi_remove_host_184(vha->host);
#line 2154
  qla24xx_deallocate_vp_id(vha);
#line 2156
  if (vha->timer_active != 0U) {
#line 2157
    qla2x00_vp_stop_timer(vha);
#line 2158
    ql_dbg(8388608U, vha, 28806, "Timer for the VP[%d] has stopped\n", (int )vha->vp_idx);
  } else {

  }
#line 2162
  tmp___1 = atomic_read((atomic_t const   *)(& vha->vref_count));
#line 2162
  tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
#line 2162
  if (tmp___2 != 0L) {
#line 2162
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"),
                         "i" (2162), "i" (12UL));
    ldv_67153: ;
#line 2162
    goto ldv_67153;
  } else {

  }
#line 2164
  qla2x00_free_fcports(vha);
#line 2166
  mutex_lock_nested(& ha->vport_lock, 0U);
#line 2167
  ha->cur_vport_count = ha->cur_vport_count - 1;
#line 2168
  clear_bit((long )vha->vp_idx, (unsigned long volatile   *)(& ha->vp_idx_map));
#line 2169
  mutex_unlock(& ha->vport_lock);
#line 2171
  if ((unsigned int )(vha->req)->id != 0U && *((unsigned long *)ha + 2UL) == 0UL) {
#line 2172
    tmp___3 = qla25xx_delete_req_que(vha, vha->req);
#line 2172
    if (tmp___3 != 0) {
#line 2173
      ql_log(1U, vha, 28807, "Queue delete failed.\n");
    } else {

    }
  } else {

  }
#line 2177
  ql_log(2U, vha, 28808, "VP[%d] deleted.\n", (int )id);
#line 2178
  scsi_host_put(vha->host);
#line 2179
  return (0);
}
}
#line 2183 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
static int qla24xx_vport_disable(struct fc_vport *fc_vport , bool disable ) 
{ 
  scsi_qla_host_t *vha ;

  {
#line 2185
  vha = (scsi_qla_host_t *)fc_vport->dd_data;
#line 2187
  if ((int )disable) {
#line 2188
    qla24xx_disable_vp(vha);
  } else {
#line 2190
    qla24xx_enable_vp(vha);
  }
#line 2192
  return (0);
}
}
#line 2195 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
struct fc_function_template qla2xxx_transport_functions  = 
#line 2195
     {0, & qla2x00_set_rport_loss_tmo, & qla2x00_get_starget_node_name, & qla2x00_get_starget_port_name,
    & qla2x00_get_starget_port_id, & qla2x00_get_host_port_id, & qla2x00_get_host_port_type,
    & qla2x00_get_host_port_state, 0, & qla2x00_get_host_speed, & qla2x00_get_host_fabric_name,
    & qla2x00_get_host_symbolic_name, & qla2x00_set_host_system_hostname, & qla2x00_get_fc_host_stats,
    & qla2x00_reset_host_stats, & qla2x00_issue_lip, & qla2x00_dev_loss_tmo_callbk,
    & qla2x00_terminate_rport_io, 0, & qla24xx_vport_create, & qla24xx_vport_disable,
    & qla24xx_vport_delete, 0, 0, & qla24xx_bsg_request, & qla24xx_bsg_timeout, 8U,
    0U, 0U, (unsigned char)0, 1U, 1U, 1U, 1U, 1U, 1U, 1U, (unsigned char)0, 1U, (unsigned char)0,
    1U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U, 1U,
    1U, (unsigned char)0, 1U, 1U, 1U, 1U, (unsigned char)0};
#line 2243 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
struct fc_function_template qla2xxx_transport_vport_functions  = 
#line 2243
     {0, & qla2x00_set_rport_loss_tmo, & qla2x00_get_starget_node_name, & qla2x00_get_starget_port_name,
    & qla2x00_get_starget_port_id, & qla2x00_get_host_port_id, & qla2x00_get_host_port_type,
    & qla2x00_get_host_port_state, 0, & qla2x00_get_host_speed, & qla2x00_get_host_fabric_name,
    & qla2x00_get_host_symbolic_name, & qla2x00_set_host_system_hostname, & qla2x00_get_fc_host_stats,
    & qla2x00_reset_host_stats, & qla2x00_issue_lip, & qla2x00_dev_loss_tmo_callbk,
    & qla2x00_terminate_rport_io, 0, 0, 0, 0, 0, 0, & qla24xx_bsg_request, & qla24xx_bsg_timeout,
    8U, 0U, 0U, (unsigned char)0, 1U, 1U, 1U, 1U, 1U, 1U, 1U, (unsigned char)0, 1U,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, 1U, 1U, 1U, (unsigned char)0, 1U, 1U, 1U, 1U, (unsigned char)0};
#line 2288 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.c"
void qla2x00_init_host_attr(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  u32 speed ;

  {
#line 2290
  ha = vha->hw;
#line 2291
  speed = 0U;
#line 2293
  ((struct fc_host_attrs *)(vha->host)->shost_data)->dev_loss_tmo = (u32 )ha->port_down_retry_count;
#line 2294
  ((struct fc_host_attrs *)(vha->host)->shost_data)->node_name = wwn_to_u64((u8 *)(& vha->node_name));
#line 2295
  ((struct fc_host_attrs *)(vha->host)->shost_data)->port_name = wwn_to_u64((u8 *)(& vha->port_name));
#line 2296
  ((struct fc_host_attrs *)(vha->host)->shost_data)->supported_classes = (unsigned int )*((unsigned char *)ha + 3808UL) != 0U ? 12U : 8U;
#line 2298
  ((struct fc_host_attrs *)(vha->host)->shost_data)->max_npiv_vports = ha->max_npiv_vports;
#line 2299
  ((struct fc_host_attrs *)(vha->host)->shost_data)->npiv_vports_inuse = (u16 )ha->cur_vport_count;
#line 2301
  if ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 2302
    speed = 4U;
  } else
#line 2303
  if ((ha->device_type & 32768U) != 0U) {
#line 2304
    speed = 56U;
  } else
#line 2306
  if ((ha->device_type & 2048U) != 0U) {
#line 2307
    speed = 27U;
  } else
#line 2309
  if ((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || ((ha->device_type & 512U) != 0U || (ha->device_type & 1024U) != 0U)) || (ha->device_type & 4096U) != 0U) {
#line 2310
    speed = 11U;
  } else
#line 2312
  if (((((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 16U) != 0U) || (ha->device_type & 32U) != 0U) || (ha->device_type & 64U) != 0U) {
#line 2313
    speed = 3U;
  } else
#line 2314
  if ((ha->device_type & 131072U) != 0U) {
#line 2315
    speed = 27U;
  } else
#line 2317
  if ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) {
#line 2318
    speed = 112U;
  } else {
#line 2321
    speed = 1U;
  }
#line 2322
  ((struct fc_host_attrs *)(vha->host)->shost_data)->supported_speeds = speed;
#line 2323
  return;
}
}
#line 487 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
extern int ldv_probe_72(void) ;
#line 488
extern int ldv_probe_71(void) ;
#line 489
extern int ldv_release_72(void) ;
#line 490
extern int ldv_probe_68(void) ;
#line 491
extern int ldv_probe_66(void) ;
#line 492
extern int ldv_probe_69(void) ;
#line 493
extern int ldv_probe_74(void) ;
#line 494
extern int ldv_release_69(void) ;
#line 495
extern int ldv_release_68(void) ;
#line 496
extern int ldv_release_65(void) ;
#line 497
extern int ldv_probe_67(void) ;
#line 498
extern int ldv_release_67(void) ;
#line 499
extern int ldv_release_66(void) ;
#line 500
extern int ldv_release_74(void) ;
#line 501
extern int ldv_probe_65(void) ;
#line 502
extern int ldv_release_70(void) ;
#line 503
extern int ldv_release_71(void) ;
#line 504
extern int ldv_release_73(void) ;
#line 505
extern int ldv_probe_73(void) ;
#line 506
extern int ldv_probe_70(void) ;
#line 509 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_initialize_device_attribute_53(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 510
  tmp = ldv_init_zalloc(48UL);
#line 510
  dev_attr_beacon_group0 = (struct device_attribute *)tmp;
#line 511
  tmp___0 = ldv_init_zalloc(1416UL);
#line 511
  dev_attr_beacon_group1 = (struct device *)tmp___0;
#line 512
  return;
}
}
#line 514 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void choose_timer_22(struct timer_list *timer ) 
{ 


  {
#line 515
  LDV_IN_INTERRUPT = 2;
#line 516
  (*(timer->function))(timer->data);
#line 517
  LDV_IN_INTERRUPT = 1;
#line 518
  ldv_timer_state_22 = 2;
#line 519
  return;
}
}
#line 522 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_initialize_bin_attribute_69(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 523
  tmp = ldv_init_zalloc(296UL);
#line 523
  sysfs_vpd_attr_group0 = (struct kobject *)tmp;
#line 524
  tmp___0 = __VERIFIER_nondet_pointer();
#line 524
  sysfs_vpd_attr_group1 = (struct file *)tmp___0;
#line 525
  tmp___1 = ldv_init_zalloc(72UL);
#line 525
  sysfs_vpd_attr_group2 = (struct bin_attribute *)tmp___1;
#line 526
  return;
}
}
#line 528 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_initialize_fc_function_template_32(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 529
  tmp = ldv_init_zalloc(3816UL);
#line 529
  qla2xxx_transport_vport_functions_group0 = (struct Scsi_Host *)tmp;
#line 530
  tmp___0 = ldv_init_zalloc(1504UL);
#line 530
  qla2xxx_transport_vport_functions_group1 = (struct scsi_target *)tmp___0;
#line 531
  tmp___1 = ldv_init_zalloc(2208UL);
#line 531
  qla2xxx_transport_vport_functions_group2 = (struct fc_rport *)tmp___1;
#line 532
  tmp___2 = ldv_init_zalloc(184UL);
#line 532
  qla2xxx_transport_vport_functions_group3 = (struct fc_bsg_job *)tmp___2;
#line 533
  return;
}
}
#line 535 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void disable_suitable_timer_22(struct timer_list *timer ) 
{ 


  {
#line 536
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_22) {
#line 537
    ldv_timer_state_22 = 0;
#line 538
    return;
  } else {

  }
#line 540
  return;
}
}
#line 543 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_initialize_device_attribute_54(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 544
  tmp = ldv_init_zalloc(48UL);
#line 544
  dev_attr_zio_timer_group0 = (struct device_attribute *)tmp;
#line 545
  tmp___0 = ldv_init_zalloc(1416UL);
#line 545
  dev_attr_zio_timer_group1 = (struct device *)tmp___0;
#line 546
  return;
}
}
#line 548 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_initialize_bin_attribute_71(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 549
  tmp = ldv_init_zalloc(296UL);
#line 549
  sysfs_optrom_attr_group0 = (struct kobject *)tmp;
#line 550
  tmp___0 = __VERIFIER_nondet_pointer();
#line 550
  sysfs_optrom_attr_group1 = (struct file *)tmp___0;
#line 551
  tmp___1 = ldv_init_zalloc(72UL);
#line 551
  sysfs_optrom_attr_group2 = (struct bin_attribute *)tmp___1;
#line 552
  return;
}
}
#line 554 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_initialize_fc_function_template_33(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 555
  tmp = ldv_init_zalloc(3816UL);
#line 555
  qla2xxx_transport_functions_group0 = (struct Scsi_Host *)tmp;
#line 556
  tmp___0 = ldv_init_zalloc(1648UL);
#line 556
  qla2xxx_transport_functions_group2 = (struct fc_vport *)tmp___0;
#line 557
  tmp___1 = ldv_init_zalloc(1504UL);
#line 557
  qla2xxx_transport_functions_group1 = (struct scsi_target *)tmp___1;
#line 558
  tmp___2 = ldv_init_zalloc(2208UL);
#line 558
  qla2xxx_transport_functions_group3 = (struct fc_rport *)tmp___2;
#line 559
  tmp___3 = ldv_init_zalloc(184UL);
#line 559
  qla2xxx_transport_functions_group4 = (struct fc_bsg_job *)tmp___3;
#line 560
  return;
}
}
#line 562 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_initialize_bin_attribute_73(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 563
  tmp = ldv_init_zalloc(296UL);
#line 563
  sysfs_fw_dump_template_attr_group0 = (struct kobject *)tmp;
#line 564
  tmp___0 = __VERIFIER_nondet_pointer();
#line 564
  sysfs_fw_dump_template_attr_group1 = (struct file *)tmp___0;
#line 565
  tmp___1 = ldv_init_zalloc(72UL);
#line 565
  sysfs_fw_dump_template_attr_group2 = (struct bin_attribute *)tmp___1;
#line 566
  return;
}
}
#line 568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_initialize_bin_attribute_72(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 569
  tmp = ldv_init_zalloc(296UL);
#line 569
  sysfs_nvram_attr_group0 = (struct kobject *)tmp;
#line 570
  tmp___0 = __VERIFIER_nondet_pointer();
#line 570
  sysfs_nvram_attr_group1 = (struct file *)tmp___0;
#line 571
  tmp___1 = ldv_init_zalloc(72UL);
#line 571
  sysfs_nvram_attr_group2 = (struct bin_attribute *)tmp___1;
#line 572
  return;
}
}
#line 574 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void activate_pending_timer_22(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 574
  if ((unsigned long )ldv_timer_list_22 == (unsigned long )timer) {
#line 575
    if (ldv_timer_state_22 == 2 || pending_flag != 0) {
#line 576
      ldv_timer_list_22 = timer;
#line 577
      ldv_timer_list_22->data = data;
#line 578
      ldv_timer_state_22 = 1;
    } else {

    }
#line 580
    return;
  } else {

  }
#line 582
  reg_timer_22(timer);
#line 583
  ldv_timer_list_22->data = data;
#line 584
  return;
}
}
#line 587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_initialize_device_attribute_55(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 588
  tmp = ldv_init_zalloc(48UL);
#line 588
  dev_attr_zio_group0 = (struct device_attribute *)tmp;
#line 589
  tmp___0 = ldv_init_zalloc(1416UL);
#line 589
  dev_attr_zio_group1 = (struct device *)tmp___0;
#line 590
  return;
}
}
#line 592 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
int reg_timer_22(struct timer_list *timer ) 
{ 


  {
#line 593
  ldv_timer_list_22 = timer;
#line 594
  ldv_timer_state_22 = 1;
#line 595
  return (0);
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_initialize_bin_attribute_74(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 599
  tmp = ldv_init_zalloc(296UL);
#line 599
  sysfs_fw_dump_attr_group0 = (struct kobject *)tmp;
#line 600
  tmp___0 = __VERIFIER_nondet_pointer();
#line 600
  sysfs_fw_dump_attr_group1 = (struct file *)tmp___0;
#line 601
  tmp___1 = ldv_init_zalloc(72UL);
#line 601
  sysfs_fw_dump_attr_group2 = (struct bin_attribute *)tmp___1;
#line 602
  return;
}
}
#line 604 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_initialize_device_attribute_34(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 605
  tmp = ldv_init_zalloc(48UL);
#line 605
  dev_attr_allow_cna_fw_dump_group0 = (struct device_attribute *)tmp;
#line 606
  tmp___0 = ldv_init_zalloc(1416UL);
#line 606
  dev_attr_allow_cna_fw_dump_group1 = (struct device *)tmp___0;
#line 607
  return;
}
}
#line 609 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_67(void) 
{ 
  struct kobject *ldvarg335 ;
  void *tmp ;
  loff_t ldvarg336 ;
  char *ldvarg332 ;
  void *tmp___0 ;
  struct file *ldvarg333 ;
  void *tmp___1 ;
  struct bin_attribute *ldvarg334 ;
  void *tmp___2 ;
  size_t ldvarg331 ;
  int tmp___3 ;

  {
#line 610
  tmp = ldv_init_zalloc(296UL);
#line 610
  ldvarg335 = (struct kobject *)tmp;
#line 612
  tmp___0 = ldv_init_zalloc(1UL);
#line 612
  ldvarg332 = (char *)tmp___0;
#line 613
  tmp___1 = __VERIFIER_nondet_pointer();
#line 613
  ldvarg333 = (struct file *)tmp___1;
#line 614
  tmp___2 = ldv_init_zalloc(72UL);
#line 614
  ldvarg334 = (struct bin_attribute *)tmp___2;
#line 611
  ldv_memset((void *)(& ldvarg336), 0, 8UL);
#line 615
  ldv_memset((void *)(& ldvarg331), 0, 8UL);
#line 617
  tmp___3 = __VERIFIER_nondet_int();
#line 617
  switch (tmp___3) {
  case 0: ;
#line 620
  if (ldv_state_variable_67 == 2) {
#line 622
    qla2x00_sysfs_write_reset(ldvarg333, ldvarg335, ldvarg334, ldvarg332, ldvarg336,
                              ldvarg331);
#line 624
    ldv_state_variable_67 = 2;
  } else {

  }
#line 627
  goto ldv_67263;
  case 1: ;
#line 630
  if (ldv_state_variable_67 == 2) {
#line 632
    ldv_release_67();
#line 634
    ldv_state_variable_67 = 1;
#line 635
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 638
  goto ldv_67263;
  case 2: ;
#line 641
  if (ldv_state_variable_67 == 1) {
#line 643
    ldv_probe_67();
#line 645
    ldv_state_variable_67 = 2;
#line 646
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 649
  goto ldv_67263;
  default: 
#line 650
  ldv_stop();
  }
  ldv_67263: ;
#line 654
  return;
}
}
#line 656 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_33(void) 
{ 
  u32 ldvarg2 ;
  bool ldvarg0 ;
  bool ldvarg1 ;
  int tmp ;

  {
#line 657
  ldv_memset((void *)(& ldvarg2), 0, 4UL);
#line 658
  ldv_memset((void *)(& ldvarg0), 0, 1UL);
#line 659
  ldv_memset((void *)(& ldvarg1), 0, 1UL);
#line 661
  tmp = __VERIFIER_nondet_int();
#line 661
  switch (tmp) {
  case 0: ;
#line 664
  if (ldv_state_variable_33 == 1) {
#line 666
    qla2x00_issue_lip(qla2xxx_transport_functions_group0);
#line 668
    ldv_state_variable_33 = 1;
  } else {

  }
#line 671
  goto ldv_67274;
  case 1: ;
#line 674
  if (ldv_state_variable_33 == 1) {
#line 676
    qla2x00_set_rport_loss_tmo(qla2xxx_transport_functions_group3, ldvarg2);
#line 678
    ldv_state_variable_33 = 1;
  } else {

  }
#line 681
  goto ldv_67274;
  case 2: ;
#line 684
  if (ldv_state_variable_33 == 1) {
#line 686
    qla2x00_get_fc_host_stats(qla2xxx_transport_functions_group0);
#line 688
    ldv_state_variable_33 = 1;
  } else {

  }
#line 691
  goto ldv_67274;
  case 3: ;
#line 694
  if (ldv_state_variable_33 == 1) {
#line 696
    qla2x00_get_host_port_type(qla2xxx_transport_functions_group0);
#line 698
    ldv_state_variable_33 = 1;
  } else {

  }
#line 701
  goto ldv_67274;
  case 4: ;
#line 704
  if (ldv_state_variable_33 == 1) {
#line 706
    qla24xx_bsg_timeout(qla2xxx_transport_functions_group4);
#line 708
    ldv_state_variable_33 = 1;
  } else {

  }
#line 711
  goto ldv_67274;
  case 5: ;
#line 714
  if (ldv_state_variable_33 == 1) {
#line 716
    qla24xx_vport_delete(qla2xxx_transport_functions_group2);
#line 718
    ldv_state_variable_33 = 1;
  } else {

  }
#line 721
  goto ldv_67274;
  case 6: ;
#line 724
  if (ldv_state_variable_33 == 1) {
#line 726
    qla24xx_bsg_request(qla2xxx_transport_functions_group4);
#line 728
    ldv_state_variable_33 = 1;
  } else {

  }
#line 731
  goto ldv_67274;
  case 7: ;
#line 734
  if (ldv_state_variable_33 == 1) {
#line 736
    qla24xx_vport_disable(qla2xxx_transport_functions_group2, (int )ldvarg1);
#line 738
    ldv_state_variable_33 = 1;
  } else {

  }
#line 741
  goto ldv_67274;
  case 8: ;
#line 744
  if (ldv_state_variable_33 == 1) {
#line 746
    qla2x00_terminate_rport_io(qla2xxx_transport_functions_group3);
#line 748
    ldv_state_variable_33 = 1;
  } else {

  }
#line 751
  goto ldv_67274;
  case 9: ;
#line 754
  if (ldv_state_variable_33 == 1) {
#line 756
    qla2x00_get_host_port_state(qla2xxx_transport_functions_group0);
#line 758
    ldv_state_variable_33 = 1;
  } else {

  }
#line 761
  goto ldv_67274;
  case 10: ;
#line 764
  if (ldv_state_variable_33 == 1) {
#line 766
    qla2x00_get_starget_node_name(qla2xxx_transport_functions_group1);
#line 768
    ldv_state_variable_33 = 1;
  } else {

  }
#line 771
  goto ldv_67274;
  case 11: ;
#line 774
  if (ldv_state_variable_33 == 1) {
#line 776
    qla2x00_get_host_speed(qla2xxx_transport_functions_group0);
#line 778
    ldv_state_variable_33 = 1;
  } else {

  }
#line 781
  goto ldv_67274;
  case 12: ;
#line 784
  if (ldv_state_variable_33 == 1) {
#line 786
    qla2x00_get_starget_port_id(qla2xxx_transport_functions_group1);
#line 788
    ldv_state_variable_33 = 1;
  } else {

  }
#line 791
  goto ldv_67274;
  case 13: ;
#line 794
  if (ldv_state_variable_33 == 1) {
#line 796
    qla2x00_get_starget_port_name(qla2xxx_transport_functions_group1);
#line 798
    ldv_state_variable_33 = 1;
  } else {

  }
#line 801
  goto ldv_67274;
  case 14: ;
#line 804
  if (ldv_state_variable_33 == 1) {
#line 806
    qla2x00_dev_loss_tmo_callbk(qla2xxx_transport_functions_group3);
#line 808
    ldv_state_variable_33 = 1;
  } else {

  }
#line 811
  goto ldv_67274;
  case 15: ;
#line 814
  if (ldv_state_variable_33 == 1) {
#line 816
    qla2x00_reset_host_stats(qla2xxx_transport_functions_group0);
#line 818
    ldv_state_variable_33 = 1;
  } else {

  }
#line 821
  goto ldv_67274;
  case 16: ;
#line 824
  if (ldv_state_variable_33 == 1) {
#line 826
    qla2x00_get_host_symbolic_name(qla2xxx_transport_functions_group0);
#line 828
    ldv_state_variable_33 = 1;
  } else {

  }
#line 831
  goto ldv_67274;
  case 17: ;
#line 834
  if (ldv_state_variable_33 == 1) {
#line 836
    qla24xx_vport_create(qla2xxx_transport_functions_group2, (int )ldvarg0);
#line 838
    ldv_state_variable_33 = 1;
  } else {

  }
#line 841
  goto ldv_67274;
  case 18: ;
#line 844
  if (ldv_state_variable_33 == 1) {
#line 846
    qla2x00_set_host_system_hostname(qla2xxx_transport_functions_group0);
#line 848
    ldv_state_variable_33 = 1;
  } else {

  }
#line 851
  goto ldv_67274;
  case 19: ;
#line 854
  if (ldv_state_variable_33 == 1) {
#line 856
    qla2x00_get_host_fabric_name(qla2xxx_transport_functions_group0);
#line 858
    ldv_state_variable_33 = 1;
  } else {

  }
#line 861
  goto ldv_67274;
  case 20: ;
#line 864
  if (ldv_state_variable_33 == 1) {
#line 866
    qla2x00_get_host_port_id(qla2xxx_transport_functions_group0);
#line 868
    ldv_state_variable_33 = 1;
  } else {

  }
#line 871
  goto ldv_67274;
  default: 
#line 872
  ldv_stop();
  }
  ldv_67274: ;
#line 876
  return;
}
}
#line 878 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_32(void) 
{ 
  u32 ldvarg3 ;
  int tmp ;

  {
#line 879
  ldv_memset((void *)(& ldvarg3), 0, 4UL);
#line 881
  tmp = __VERIFIER_nondet_int();
#line 881
  switch (tmp) {
  case 0: ;
#line 884
  if (ldv_state_variable_32 == 1) {
#line 886
    qla2x00_issue_lip(qla2xxx_transport_vport_functions_group0);
#line 888
    ldv_state_variable_32 = 1;
  } else {

  }
#line 891
  goto ldv_67301;
  case 1: ;
#line 894
  if (ldv_state_variable_32 == 1) {
#line 896
    qla2x00_set_rport_loss_tmo(qla2xxx_transport_vport_functions_group2, ldvarg3);
#line 898
    ldv_state_variable_32 = 1;
  } else {

  }
#line 901
  goto ldv_67301;
  case 2: ;
#line 904
  if (ldv_state_variable_32 == 1) {
#line 906
    qla2x00_get_fc_host_stats(qla2xxx_transport_vport_functions_group0);
#line 908
    ldv_state_variable_32 = 1;
  } else {

  }
#line 911
  goto ldv_67301;
  case 3: ;
#line 914
  if (ldv_state_variable_32 == 1) {
#line 916
    qla2x00_get_host_port_type(qla2xxx_transport_vport_functions_group0);
#line 918
    ldv_state_variable_32 = 1;
  } else {

  }
#line 921
  goto ldv_67301;
  case 4: ;
#line 924
  if (ldv_state_variable_32 == 1) {
#line 926
    qla24xx_bsg_timeout(qla2xxx_transport_vport_functions_group3);
#line 928
    ldv_state_variable_32 = 1;
  } else {

  }
#line 931
  goto ldv_67301;
  case 5: ;
#line 934
  if (ldv_state_variable_32 == 1) {
#line 936
    qla24xx_bsg_request(qla2xxx_transport_vport_functions_group3);
#line 938
    ldv_state_variable_32 = 1;
  } else {

  }
#line 941
  goto ldv_67301;
  case 6: ;
#line 944
  if (ldv_state_variable_32 == 1) {
#line 946
    qla2x00_terminate_rport_io(qla2xxx_transport_vport_functions_group2);
#line 948
    ldv_state_variable_32 = 1;
  } else {

  }
#line 951
  goto ldv_67301;
  case 7: ;
#line 954
  if (ldv_state_variable_32 == 1) {
#line 956
    qla2x00_get_host_port_state(qla2xxx_transport_vport_functions_group0);
#line 958
    ldv_state_variable_32 = 1;
  } else {

  }
#line 961
  goto ldv_67301;
  case 8: ;
#line 964
  if (ldv_state_variable_32 == 1) {
#line 966
    qla2x00_get_starget_node_name(qla2xxx_transport_vport_functions_group1);
#line 968
    ldv_state_variable_32 = 1;
  } else {

  }
#line 971
  goto ldv_67301;
  case 9: ;
#line 974
  if (ldv_state_variable_32 == 1) {
#line 976
    qla2x00_get_host_speed(qla2xxx_transport_vport_functions_group0);
#line 978
    ldv_state_variable_32 = 1;
  } else {

  }
#line 981
  goto ldv_67301;
  case 10: ;
#line 984
  if (ldv_state_variable_32 == 1) {
#line 986
    qla2x00_get_starget_port_id(qla2xxx_transport_vport_functions_group1);
#line 988
    ldv_state_variable_32 = 1;
  } else {

  }
#line 991
  goto ldv_67301;
  case 11: ;
#line 994
  if (ldv_state_variable_32 == 1) {
#line 996
    qla2x00_get_starget_port_name(qla2xxx_transport_vport_functions_group1);
#line 998
    ldv_state_variable_32 = 1;
  } else {

  }
#line 1001
  goto ldv_67301;
  case 12: ;
#line 1004
  if (ldv_state_variable_32 == 1) {
#line 1006
    qla2x00_dev_loss_tmo_callbk(qla2xxx_transport_vport_functions_group2);
#line 1008
    ldv_state_variable_32 = 1;
  } else {

  }
#line 1011
  goto ldv_67301;
  case 13: ;
#line 1014
  if (ldv_state_variable_32 == 1) {
#line 1016
    qla2x00_reset_host_stats(qla2xxx_transport_vport_functions_group0);
#line 1018
    ldv_state_variable_32 = 1;
  } else {

  }
#line 1021
  goto ldv_67301;
  case 14: ;
#line 1024
  if (ldv_state_variable_32 == 1) {
#line 1026
    qla2x00_get_host_symbolic_name(qla2xxx_transport_vport_functions_group0);
#line 1028
    ldv_state_variable_32 = 1;
  } else {

  }
#line 1031
  goto ldv_67301;
  case 15: ;
#line 1034
  if (ldv_state_variable_32 == 1) {
#line 1036
    qla2x00_set_host_system_hostname(qla2xxx_transport_vport_functions_group0);
#line 1038
    ldv_state_variable_32 = 1;
  } else {

  }
#line 1041
  goto ldv_67301;
  case 16: ;
#line 1044
  if (ldv_state_variable_32 == 1) {
#line 1046
    qla2x00_get_host_fabric_name(qla2xxx_transport_vport_functions_group0);
#line 1048
    ldv_state_variable_32 = 1;
  } else {

  }
#line 1051
  goto ldv_67301;
  case 17: ;
#line 1054
  if (ldv_state_variable_32 == 1) {
#line 1056
    qla2x00_get_host_port_id(qla2xxx_transport_vport_functions_group0);
#line 1058
    ldv_state_variable_32 = 1;
  } else {

  }
#line 1061
  goto ldv_67301;
  default: 
#line 1062
  ldv_stop();
  }
  ldv_67301: ;
#line 1066
  return;
}
}
#line 1068 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_63(void) 
{ 
  struct device_attribute *ldvarg6 ;
  void *tmp ;
  char *ldvarg5 ;
  void *tmp___0 ;
  struct device *ldvarg4 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1069
  tmp = ldv_init_zalloc(48UL);
#line 1069
  ldvarg6 = (struct device_attribute *)tmp;
#line 1070
  tmp___0 = ldv_init_zalloc(1UL);
#line 1070
  ldvarg5 = (char *)tmp___0;
#line 1071
  tmp___1 = ldv_init_zalloc(1416UL);
#line 1071
  ldvarg4 = (struct device *)tmp___1;
#line 1073
  tmp___2 = __VERIFIER_nondet_int();
#line 1073
  switch (tmp___2) {
  case 0: ;
#line 1076
  if (ldv_state_variable_63 == 1) {
#line 1078
    qla2x00_fw_version_show(ldvarg4, ldvarg6, ldvarg5);
#line 1080
    ldv_state_variable_63 = 1;
  } else {

  }
#line 1083
  goto ldv_67327;
  default: 
#line 1084
  ldv_stop();
  }
  ldv_67327: ;
#line 1088
  return;
}
}
#line 1090 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_71(void) 
{ 
  loff_t ldvarg9 ;
  loff_t ldvarg12 ;
  size_t ldvarg10 ;
  size_t ldvarg7 ;
  char *ldvarg11 ;
  void *tmp ;
  char *ldvarg8 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1095
  tmp = ldv_init_zalloc(1UL);
#line 1095
  ldvarg11 = (char *)tmp;
#line 1096
  tmp___0 = ldv_init_zalloc(1UL);
#line 1096
  ldvarg8 = (char *)tmp___0;
#line 1091
  ldv_memset((void *)(& ldvarg9), 0, 8UL);
#line 1092
  ldv_memset((void *)(& ldvarg12), 0, 8UL);
#line 1093
  ldv_memset((void *)(& ldvarg10), 0, 8UL);
#line 1094
  ldv_memset((void *)(& ldvarg7), 0, 8UL);
#line 1098
  tmp___1 = __VERIFIER_nondet_int();
#line 1098
  switch (tmp___1) {
  case 0: ;
#line 1101
  if (ldv_state_variable_71 == 2) {
#line 1103
    qla2x00_sysfs_write_optrom(sysfs_optrom_attr_group1, sysfs_optrom_attr_group0,
                               sysfs_optrom_attr_group2, ldvarg11, ldvarg12, ldvarg10);
#line 1105
    ldv_state_variable_71 = 2;
  } else {

  }
#line 1108
  goto ldv_67339;
  case 1: ;
#line 1111
  if (ldv_state_variable_71 == 2) {
#line 1113
    qla2x00_sysfs_read_optrom(sysfs_optrom_attr_group1, sysfs_optrom_attr_group0,
                              sysfs_optrom_attr_group2, ldvarg8, ldvarg9, ldvarg7);
#line 1115
    ldv_state_variable_71 = 2;
  } else {

  }
#line 1118
  goto ldv_67339;
  case 2: ;
#line 1121
  if (ldv_state_variable_71 == 2) {
#line 1123
    ldv_release_71();
#line 1125
    ldv_state_variable_71 = 1;
#line 1126
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1129
  goto ldv_67339;
  case 3: ;
#line 1132
  if (ldv_state_variable_71 == 1) {
#line 1134
    ldv_probe_71();
#line 1136
    ldv_state_variable_71 = 2;
#line 1137
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1140
  goto ldv_67339;
  default: 
#line 1141
  ldv_stop();
  }
  ldv_67339: ;
#line 1145
  return;
}
}
#line 1147 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_70(void) 
{ 
  loff_t ldvarg342 ;
  struct file *ldvarg339 ;
  void *tmp ;
  struct bin_attribute *ldvarg340 ;
  void *tmp___0 ;
  size_t ldvarg337 ;
  char *ldvarg338 ;
  void *tmp___1 ;
  struct kobject *ldvarg341 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 1149
  tmp = __VERIFIER_nondet_pointer();
#line 1149
  ldvarg339 = (struct file *)tmp;
#line 1150
  tmp___0 = ldv_init_zalloc(72UL);
#line 1150
  ldvarg340 = (struct bin_attribute *)tmp___0;
#line 1152
  tmp___1 = ldv_init_zalloc(1UL);
#line 1152
  ldvarg338 = (char *)tmp___1;
#line 1153
  tmp___2 = ldv_init_zalloc(296UL);
#line 1153
  ldvarg341 = (struct kobject *)tmp___2;
#line 1148
  ldv_memset((void *)(& ldvarg342), 0, 8UL);
#line 1151
  ldv_memset((void *)(& ldvarg337), 0, 8UL);
#line 1155
  tmp___3 = __VERIFIER_nondet_int();
#line 1155
  switch (tmp___3) {
  case 0: ;
#line 1158
  if (ldv_state_variable_70 == 2) {
#line 1160
    qla2x00_sysfs_write_optrom_ctl(ldvarg339, ldvarg341, ldvarg340, ldvarg338, ldvarg342,
                                   ldvarg337);
#line 1162
    ldv_state_variable_70 = 2;
  } else {

  }
#line 1165
  goto ldv_67354;
  case 1: ;
#line 1168
  if (ldv_state_variable_70 == 2) {
#line 1170
    ldv_release_70();
#line 1172
    ldv_state_variable_70 = 1;
#line 1173
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1176
  goto ldv_67354;
  case 2: ;
#line 1179
  if (ldv_state_variable_70 == 1) {
#line 1181
    ldv_probe_70();
#line 1183
    ldv_state_variable_70 = 2;
#line 1184
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1187
  goto ldv_67354;
  default: 
#line 1188
  ldv_stop();
  }
  ldv_67354: ;
#line 1192
  return;
}
}
#line 1194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_68(void) 
{ 
  struct kobject *ldvarg347 ;
  void *tmp ;
  struct file *ldvarg345 ;
  void *tmp___0 ;
  char *ldvarg344 ;
  void *tmp___1 ;
  loff_t ldvarg348 ;
  size_t ldvarg343 ;
  struct bin_attribute *ldvarg346 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 1195
  tmp = ldv_init_zalloc(296UL);
#line 1195
  ldvarg347 = (struct kobject *)tmp;
#line 1196
  tmp___0 = __VERIFIER_nondet_pointer();
#line 1196
  ldvarg345 = (struct file *)tmp___0;
#line 1197
  tmp___1 = ldv_init_zalloc(1UL);
#line 1197
  ldvarg344 = (char *)tmp___1;
#line 1200
  tmp___2 = ldv_init_zalloc(72UL);
#line 1200
  ldvarg346 = (struct bin_attribute *)tmp___2;
#line 1198
  ldv_memset((void *)(& ldvarg348), 0, 8UL);
#line 1199
  ldv_memset((void *)(& ldvarg343), 0, 8UL);
#line 1202
  tmp___3 = __VERIFIER_nondet_int();
#line 1202
  switch (tmp___3) {
  case 0: ;
#line 1205
  if (ldv_state_variable_68 == 2) {
#line 1207
    qla2x00_sysfs_read_sfp(ldvarg345, ldvarg347, ldvarg346, ldvarg344, ldvarg348,
                           ldvarg343);
#line 1209
    ldv_state_variable_68 = 2;
  } else {

  }
#line 1212
  goto ldv_67368;
  case 1: ;
#line 1215
  if (ldv_state_variable_68 == 2) {
#line 1217
    ldv_release_68();
#line 1219
    ldv_state_variable_68 = 1;
#line 1220
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1223
  goto ldv_67368;
  case 2: ;
#line 1226
  if (ldv_state_variable_68 == 1) {
#line 1228
    ldv_probe_68();
#line 1230
    ldv_state_variable_68 = 2;
#line 1231
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1234
  goto ldv_67368;
  default: 
#line 1235
  ldv_stop();
  }
  ldv_67368: ;
#line 1239
  return;
}
}
#line 1241 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_72(void) 
{ 
  size_t ldvarg47 ;
  size_t ldvarg50 ;
  loff_t ldvarg49 ;
  loff_t ldvarg52 ;
  char *ldvarg51 ;
  void *tmp ;
  char *ldvarg48 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1246
  tmp = ldv_init_zalloc(1UL);
#line 1246
  ldvarg51 = (char *)tmp;
#line 1247
  tmp___0 = ldv_init_zalloc(1UL);
#line 1247
  ldvarg48 = (char *)tmp___0;
#line 1242
  ldv_memset((void *)(& ldvarg47), 0, 8UL);
#line 1243
  ldv_memset((void *)(& ldvarg50), 0, 8UL);
#line 1244
  ldv_memset((void *)(& ldvarg49), 0, 8UL);
#line 1245
  ldv_memset((void *)(& ldvarg52), 0, 8UL);
#line 1249
  tmp___1 = __VERIFIER_nondet_int();
#line 1249
  switch (tmp___1) {
  case 0: ;
#line 1252
  if (ldv_state_variable_72 == 2) {
#line 1254
    qla2x00_sysfs_write_nvram(sysfs_nvram_attr_group1, sysfs_nvram_attr_group0, sysfs_nvram_attr_group2,
                              ldvarg51, ldvarg52, ldvarg50);
#line 1256
    ldv_state_variable_72 = 2;
  } else {

  }
#line 1259
  goto ldv_67382;
  case 1: ;
#line 1262
  if (ldv_state_variable_72 == 2) {
#line 1264
    qla2x00_sysfs_read_nvram(sysfs_nvram_attr_group1, sysfs_nvram_attr_group0, sysfs_nvram_attr_group2,
                             ldvarg48, ldvarg49, ldvarg47);
#line 1266
    ldv_state_variable_72 = 2;
  } else {

  }
#line 1269
  goto ldv_67382;
  case 2: ;
#line 1272
  if (ldv_state_variable_72 == 2) {
#line 1274
    ldv_release_72();
#line 1276
    ldv_state_variable_72 = 1;
#line 1277
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1280
  goto ldv_67382;
  case 3: ;
#line 1283
  if (ldv_state_variable_72 == 1) {
#line 1285
    ldv_probe_72();
#line 1287
    ldv_state_variable_72 = 2;
#line 1288
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1291
  goto ldv_67382;
  default: 
#line 1292
  ldv_stop();
  }
  ldv_67382: ;
#line 1296
  return;
}
}
#line 1298 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_44(void) 
{ 
  struct device_attribute *ldvarg55 ;
  void *tmp ;
  struct device *ldvarg53 ;
  void *tmp___0 ;
  char *ldvarg54 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1299
  tmp = ldv_init_zalloc(48UL);
#line 1299
  ldvarg55 = (struct device_attribute *)tmp;
#line 1300
  tmp___0 = ldv_init_zalloc(1416UL);
#line 1300
  ldvarg53 = (struct device *)tmp___0;
#line 1301
  tmp___1 = ldv_init_zalloc(1UL);
#line 1301
  ldvarg54 = (char *)tmp___1;
#line 1303
  tmp___2 = __VERIFIER_nondet_int();
#line 1303
  switch (tmp___2) {
  case 0: ;
#line 1306
  if (ldv_state_variable_44 == 1) {
#line 1308
    qla2x00_phy_version_show(ldvarg53, ldvarg55, ldvarg54);
#line 1310
    ldv_state_variable_44 = 1;
  } else {

  }
#line 1313
  goto ldv_67394;
  default: 
#line 1314
  ldv_stop();
  }
  ldv_67394: ;
#line 1318
  return;
}
}
#line 1320 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_55(void) 
{ 
  char *ldvarg56 ;
  void *tmp ;
  char *ldvarg58 ;
  void *tmp___0 ;
  size_t ldvarg57 ;
  int tmp___1 ;

  {
#line 1321
  tmp = ldv_init_zalloc(1UL);
#line 1321
  ldvarg56 = (char *)tmp;
#line 1322
  tmp___0 = ldv_init_zalloc(1UL);
#line 1322
  ldvarg58 = (char *)tmp___0;
#line 1323
  ldv_memset((void *)(& ldvarg57), 0, 8UL);
#line 1325
  tmp___1 = __VERIFIER_nondet_int();
#line 1325
  switch (tmp___1) {
  case 0: ;
#line 1328
  if (ldv_state_variable_55 == 1) {
#line 1330
    qla2x00_zio_store(dev_attr_zio_group1, dev_attr_zio_group0, (char const   *)ldvarg58,
                      ldvarg57);
#line 1332
    ldv_state_variable_55 = 1;
  } else {

  }
#line 1335
  goto ldv_67403;
  case 1: ;
#line 1338
  if (ldv_state_variable_55 == 1) {
#line 1340
    qla2x00_zio_show(dev_attr_zio_group1, dev_attr_zio_group0, ldvarg56);
#line 1342
    ldv_state_variable_55 = 1;
  } else {

  }
#line 1345
  goto ldv_67403;
  default: 
#line 1346
  ldv_stop();
  }
  ldv_67403: ;
#line 1350
  return;
}
}
#line 1352 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_74(void) 
{ 
  size_t ldvarg99 ;
  char *ldvarg103 ;
  void *tmp ;
  char *ldvarg100 ;
  void *tmp___0 ;
  loff_t ldvarg101 ;
  size_t ldvarg102 ;
  loff_t ldvarg104 ;
  int tmp___1 ;

  {
#line 1354
  tmp = ldv_init_zalloc(1UL);
#line 1354
  ldvarg103 = (char *)tmp;
#line 1355
  tmp___0 = ldv_init_zalloc(1UL);
#line 1355
  ldvarg100 = (char *)tmp___0;
#line 1353
  ldv_memset((void *)(& ldvarg99), 0, 8UL);
#line 1356
  ldv_memset((void *)(& ldvarg101), 0, 8UL);
#line 1357
  ldv_memset((void *)(& ldvarg102), 0, 8UL);
#line 1358
  ldv_memset((void *)(& ldvarg104), 0, 8UL);
#line 1360
  tmp___1 = __VERIFIER_nondet_int();
#line 1360
  switch (tmp___1) {
  case 0: ;
#line 1363
  if (ldv_state_variable_74 == 2) {
#line 1365
    qla2x00_sysfs_write_fw_dump(sysfs_fw_dump_attr_group1, sysfs_fw_dump_attr_group0,
                                sysfs_fw_dump_attr_group2, ldvarg103, ldvarg104, ldvarg102);
#line 1367
    ldv_state_variable_74 = 2;
  } else {

  }
#line 1370
  goto ldv_67416;
  case 1: ;
#line 1373
  if (ldv_state_variable_74 == 2) {
#line 1375
    qla2x00_sysfs_read_fw_dump(sysfs_fw_dump_attr_group1, sysfs_fw_dump_attr_group0,
                               sysfs_fw_dump_attr_group2, ldvarg100, ldvarg101, ldvarg99);
#line 1377
    ldv_state_variable_74 = 2;
  } else {

  }
#line 1380
  goto ldv_67416;
  case 2: ;
#line 1383
  if (ldv_state_variable_74 == 2) {
#line 1385
    ldv_release_74();
#line 1387
    ldv_state_variable_74 = 1;
#line 1388
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1391
  goto ldv_67416;
  case 3: ;
#line 1394
  if (ldv_state_variable_74 == 1) {
#line 1396
    ldv_probe_74();
#line 1398
    ldv_state_variable_74 = 2;
#line 1399
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1402
  goto ldv_67416;
  default: 
#line 1403
  ldv_stop();
  }
  ldv_67416: ;
#line 1407
  return;
}
}
#line 1409 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_57(void) 
{ 
  struct device_attribute *ldvarg107 ;
  void *tmp ;
  struct device *ldvarg105 ;
  void *tmp___0 ;
  char *ldvarg106 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1410
  tmp = ldv_init_zalloc(48UL);
#line 1410
  ldvarg107 = (struct device_attribute *)tmp;
#line 1411
  tmp___0 = ldv_init_zalloc(1416UL);
#line 1411
  ldvarg105 = (struct device *)tmp___0;
#line 1412
  tmp___1 = ldv_init_zalloc(1UL);
#line 1412
  ldvarg106 = (char *)tmp___1;
#line 1414
  tmp___2 = __VERIFIER_nondet_int();
#line 1414
  switch (tmp___2) {
  case 0: ;
#line 1417
  if (ldv_state_variable_57 == 1) {
#line 1419
    qla2x00_pci_info_show(ldvarg105, ldvarg107, ldvarg106);
#line 1421
    ldv_state_variable_57 = 1;
  } else {

  }
#line 1424
  goto ldv_67428;
  default: 
#line 1425
  ldv_stop();
  }
  ldv_67428: ;
#line 1429
  return;
}
}
#line 1431 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_40(void) 
{ 
  struct device_attribute *ldvarg429 ;
  void *tmp ;
  struct device *ldvarg427 ;
  void *tmp___0 ;
  char *ldvarg428 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1432
  tmp = ldv_init_zalloc(48UL);
#line 1432
  ldvarg429 = (struct device_attribute *)tmp;
#line 1433
  tmp___0 = ldv_init_zalloc(1416UL);
#line 1433
  ldvarg427 = (struct device *)tmp___0;
#line 1434
  tmp___1 = ldv_init_zalloc(1UL);
#line 1434
  ldvarg428 = (char *)tmp___1;
#line 1436
  tmp___2 = __VERIFIER_nondet_int();
#line 1436
  switch (tmp___2) {
  case 0: ;
#line 1439
  if (ldv_state_variable_40 == 1) {
#line 1441
    qla2x00_fabric_param_show(ldvarg427, ldvarg429, ldvarg428);
#line 1443
    ldv_state_variable_40 = 1;
  } else {

  }
#line 1446
  goto ldv_67437;
  default: 
#line 1447
  ldv_stop();
  }
  ldv_67437: ;
#line 1451
  return;
}
}
#line 1453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_61(void) 
{ 
  char *ldvarg109 ;
  void *tmp ;
  struct device *ldvarg108 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg110 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1454
  tmp = ldv_init_zalloc(1UL);
#line 1454
  ldvarg109 = (char *)tmp;
#line 1455
  tmp___0 = ldv_init_zalloc(1416UL);
#line 1455
  ldvarg108 = (struct device *)tmp___0;
#line 1456
  tmp___1 = ldv_init_zalloc(48UL);
#line 1456
  ldvarg110 = (struct device_attribute *)tmp___1;
#line 1458
  tmp___2 = __VERIFIER_nondet_int();
#line 1458
  switch (tmp___2) {
  case 0: ;
#line 1461
  if (ldv_state_variable_61 == 1) {
#line 1463
    qla2x00_isp_name_show(ldvarg108, ldvarg110, ldvarg109);
#line 1465
    ldv_state_variable_61 = 1;
  } else {

  }
#line 1468
  goto ldv_67446;
  default: 
#line 1469
  ldv_stop();
  }
  ldv_67446: ;
#line 1473
  return;
}
}
#line 1475 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_69(void) 
{ 
  size_t ldvarg430 ;
  char *ldvarg434 ;
  void *tmp ;
  loff_t ldvarg432 ;
  loff_t ldvarg435 ;
  char *ldvarg431 ;
  void *tmp___0 ;
  size_t ldvarg433 ;
  int tmp___1 ;

  {
#line 1477
  tmp = ldv_init_zalloc(1UL);
#line 1477
  ldvarg434 = (char *)tmp;
#line 1480
  tmp___0 = ldv_init_zalloc(1UL);
#line 1480
  ldvarg431 = (char *)tmp___0;
#line 1476
  ldv_memset((void *)(& ldvarg430), 0, 8UL);
#line 1478
  ldv_memset((void *)(& ldvarg432), 0, 8UL);
#line 1479
  ldv_memset((void *)(& ldvarg435), 0, 8UL);
#line 1481
  ldv_memset((void *)(& ldvarg433), 0, 8UL);
#line 1483
  tmp___1 = __VERIFIER_nondet_int();
#line 1483
  switch (tmp___1) {
  case 0: ;
#line 1486
  if (ldv_state_variable_69 == 2) {
#line 1488
    qla2x00_sysfs_write_vpd(sysfs_vpd_attr_group1, sysfs_vpd_attr_group0, sysfs_vpd_attr_group2,
                            ldvarg434, ldvarg435, ldvarg433);
#line 1490
    ldv_state_variable_69 = 2;
  } else {

  }
#line 1493
  goto ldv_67458;
  case 1: ;
#line 1496
  if (ldv_state_variable_69 == 2) {
#line 1498
    qla2x00_sysfs_read_vpd(sysfs_vpd_attr_group1, sysfs_vpd_attr_group0, sysfs_vpd_attr_group2,
                           ldvarg431, ldvarg432, ldvarg430);
#line 1500
    ldv_state_variable_69 = 2;
  } else {

  }
#line 1503
  goto ldv_67458;
  case 2: ;
#line 1506
  if (ldv_state_variable_69 == 2) {
#line 1508
    ldv_release_69();
#line 1510
    ldv_state_variable_69 = 1;
#line 1511
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1514
  goto ldv_67458;
  case 3: ;
#line 1517
  if (ldv_state_variable_69 == 1) {
#line 1519
    ldv_probe_69();
#line 1521
    ldv_state_variable_69 = 2;
#line 1522
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1525
  goto ldv_67458;
  default: 
#line 1526
  ldv_stop();
  }
  ldv_67458: ;
#line 1530
  return;
}
}
#line 1532 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_59(void) 
{ 
  char *ldvarg437 ;
  void *tmp ;
  struct device *ldvarg436 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg438 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1533
  tmp = ldv_init_zalloc(1UL);
#line 1533
  ldvarg437 = (char *)tmp;
#line 1534
  tmp___0 = ldv_init_zalloc(1416UL);
#line 1534
  ldvarg436 = (struct device *)tmp___0;
#line 1535
  tmp___1 = ldv_init_zalloc(48UL);
#line 1535
  ldvarg438 = (struct device_attribute *)tmp___1;
#line 1537
  tmp___2 = __VERIFIER_nondet_int();
#line 1537
  switch (tmp___2) {
  case 0: ;
#line 1540
  if (ldv_state_variable_59 == 1) {
#line 1542
    qla2x00_model_name_show(ldvarg436, ldvarg438, ldvarg437);
#line 1544
    ldv_state_variable_59 = 1;
  } else {

  }
#line 1547
  goto ldv_67470;
  default: 
#line 1548
  ldv_stop();
  }
  ldv_67470: ;
#line 1552
  return;
}
}
#line 1554 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_49(void) 
{ 
  char *ldvarg440 ;
  void *tmp ;
  struct device *ldvarg439 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg441 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1555
  tmp = ldv_init_zalloc(1UL);
#line 1555
  ldvarg440 = (char *)tmp;
#line 1556
  tmp___0 = ldv_init_zalloc(1416UL);
#line 1556
  ldvarg439 = (struct device *)tmp___0;
#line 1557
  tmp___1 = ldv_init_zalloc(48UL);
#line 1557
  ldvarg441 = (struct device_attribute *)tmp___1;
#line 1559
  tmp___2 = __VERIFIER_nondet_int();
#line 1559
  switch (tmp___2) {
  case 0: ;
#line 1562
  if (ldv_state_variable_49 == 1) {
#line 1564
    qla2x00_optrom_fw_version_show(ldvarg439, ldvarg441, ldvarg440);
#line 1566
    ldv_state_variable_49 = 1;
  } else {

  }
#line 1569
  goto ldv_67479;
  default: 
#line 1570
  ldv_stop();
  }
  ldv_67479: ;
#line 1574
  return;
}
}
#line 1576 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_35(void) 
{ 
  struct device_attribute *ldvarg118 ;
  void *tmp ;
  char *ldvarg117 ;
  void *tmp___0 ;
  struct device *ldvarg116 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1577
  tmp = ldv_init_zalloc(48UL);
#line 1577
  ldvarg118 = (struct device_attribute *)tmp;
#line 1578
  tmp___0 = ldv_init_zalloc(1UL);
#line 1578
  ldvarg117 = (char *)tmp___0;
#line 1579
  tmp___1 = ldv_init_zalloc(1416UL);
#line 1579
  ldvarg116 = (struct device *)tmp___1;
#line 1581
  tmp___2 = __VERIFIER_nondet_int();
#line 1581
  switch (tmp___2) {
  case 0: ;
#line 1584
  if (ldv_state_variable_35 == 1) {
#line 1586
    qla2x00_fw_dump_size_show(ldvarg116, ldvarg118, ldvarg117);
#line 1588
    ldv_state_variable_35 = 1;
  } else {

  }
#line 1591
  goto ldv_67488;
  default: 
#line 1592
  ldv_stop();
  }
  ldv_67488: ;
#line 1596
  return;
}
}
#line 1598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_53(void) 
{ 
  char *ldvarg442 ;
  void *tmp ;
  size_t ldvarg443 ;
  char *ldvarg444 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1599
  tmp = ldv_init_zalloc(1UL);
#line 1599
  ldvarg442 = (char *)tmp;
#line 1601
  tmp___0 = ldv_init_zalloc(1UL);
#line 1601
  ldvarg444 = (char *)tmp___0;
#line 1600
  ldv_memset((void *)(& ldvarg443), 0, 8UL);
#line 1603
  tmp___1 = __VERIFIER_nondet_int();
#line 1603
  switch (tmp___1) {
  case 0: ;
#line 1606
  if (ldv_state_variable_53 == 1) {
#line 1608
    qla2x00_beacon_store(dev_attr_beacon_group1, dev_attr_beacon_group0, (char const   *)ldvarg444,
                         ldvarg443);
#line 1610
    ldv_state_variable_53 = 1;
  } else {

  }
#line 1613
  goto ldv_67497;
  case 1: ;
#line 1616
  if (ldv_state_variable_53 == 1) {
#line 1618
    qla2x00_beacon_show(dev_attr_beacon_group1, dev_attr_beacon_group0, ldvarg442);
#line 1620
    ldv_state_variable_53 = 1;
  } else {

  }
#line 1623
  goto ldv_67497;
  default: 
#line 1624
  ldv_stop();
  }
  ldv_67497: ;
#line 1628
  return;
}
}
#line 1630 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_48(void) 
{ 
  struct device_attribute *ldvarg155 ;
  void *tmp ;
  struct device *ldvarg153 ;
  void *tmp___0 ;
  char *ldvarg154 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1631
  tmp = ldv_init_zalloc(48UL);
#line 1631
  ldvarg155 = (struct device_attribute *)tmp;
#line 1632
  tmp___0 = ldv_init_zalloc(1416UL);
#line 1632
  ldvarg153 = (struct device *)tmp___0;
#line 1633
  tmp___1 = ldv_init_zalloc(1UL);
#line 1633
  ldvarg154 = (char *)tmp___1;
#line 1635
  tmp___2 = __VERIFIER_nondet_int();
#line 1635
  switch (tmp___2) {
  case 0: ;
#line 1638
  if (ldv_state_variable_48 == 1) {
#line 1640
    qla2x00_optrom_gold_fw_version_show(ldvarg153, ldvarg155, ldvarg154);
#line 1642
    ldv_state_variable_48 = 1;
  } else {

  }
#line 1645
  goto ldv_67507;
  default: 
#line 1646
  ldv_stop();
  }
  ldv_67507: ;
#line 1650
  return;
}
}
#line 1653 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_42(void) 
{ 
  struct device *ldvarg473 ;
  void *tmp ;
  struct device_attribute *ldvarg475 ;
  void *tmp___0 ;
  char *ldvarg474 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1654
  tmp = ldv_init_zalloc(1416UL);
#line 1654
  ldvarg473 = (struct device *)tmp;
#line 1655
  tmp___0 = ldv_init_zalloc(48UL);
#line 1655
  ldvarg475 = (struct device_attribute *)tmp___0;
#line 1656
  tmp___1 = ldv_init_zalloc(1UL);
#line 1656
  ldvarg474 = (char *)tmp___1;
#line 1658
  tmp___2 = __VERIFIER_nondet_int();
#line 1658
  switch (tmp___2) {
  case 0: ;
#line 1661
  if (ldv_state_variable_42 == 1) {
#line 1663
    qla2x00_vlan_id_show(ldvarg473, ldvarg475, ldvarg474);
#line 1665
    ldv_state_variable_42 = 1;
  } else {

  }
#line 1668
  goto ldv_67516;
  default: 
#line 1669
  ldv_stop();
  }
  ldv_67516: ;
#line 1673
  return;
}
}
#line 1675 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_46(void) 
{ 
  struct device *ldvarg476 ;
  void *tmp ;
  char *ldvarg477 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg478 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1676
  tmp = ldv_init_zalloc(1416UL);
#line 1676
  ldvarg476 = (struct device *)tmp;
#line 1677
  tmp___0 = ldv_init_zalloc(1UL);
#line 1677
  ldvarg477 = (char *)tmp___0;
#line 1678
  tmp___1 = ldv_init_zalloc(48UL);
#line 1678
  ldvarg478 = (struct device_attribute *)tmp___1;
#line 1680
  tmp___2 = __VERIFIER_nondet_int();
#line 1680
  switch (tmp___2) {
  case 0: ;
#line 1683
  if (ldv_state_variable_46 == 1) {
#line 1685
    qla2x00_total_isp_aborts_show(ldvarg476, ldvarg478, ldvarg477);
#line 1687
    ldv_state_variable_46 = 1;
  } else {

  }
#line 1690
  goto ldv_67525;
  default: 
#line 1691
  ldv_stop();
  }
  ldv_67525: ;
#line 1695
  return;
}
}
#line 1697 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_65(void) 
{ 
  char *ldvarg202 ;
  void *tmp ;
  size_t ldvarg201 ;
  loff_t ldvarg206 ;
  struct kobject *ldvarg205 ;
  void *tmp___0 ;
  struct file *ldvarg203 ;
  void *tmp___1 ;
  struct bin_attribute *ldvarg204 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 1698
  tmp = ldv_init_zalloc(1UL);
#line 1698
  ldvarg202 = (char *)tmp;
#line 1701
  tmp___0 = ldv_init_zalloc(296UL);
#line 1701
  ldvarg205 = (struct kobject *)tmp___0;
#line 1702
  tmp___1 = __VERIFIER_nondet_pointer();
#line 1702
  ldvarg203 = (struct file *)tmp___1;
#line 1703
  tmp___2 = ldv_init_zalloc(72UL);
#line 1703
  ldvarg204 = (struct bin_attribute *)tmp___2;
#line 1699
  ldv_memset((void *)(& ldvarg201), 0, 8UL);
#line 1700
  ldv_memset((void *)(& ldvarg206), 0, 8UL);
#line 1705
  tmp___3 = __VERIFIER_nondet_int();
#line 1705
  switch (tmp___3) {
  case 0: ;
#line 1708
  if (ldv_state_variable_65 == 2) {
#line 1710
    qla2x00_sysfs_read_dcbx_tlv(ldvarg203, ldvarg205, ldvarg204, ldvarg202, ldvarg206,
                                ldvarg201);
#line 1712
    ldv_state_variable_65 = 2;
  } else {

  }
#line 1715
  goto ldv_67537;
  case 1: ;
#line 1718
  if (ldv_state_variable_65 == 2) {
#line 1720
    ldv_release_65();
#line 1722
    ldv_state_variable_65 = 1;
#line 1723
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1726
  goto ldv_67537;
  case 2: ;
#line 1729
  if (ldv_state_variable_65 == 1) {
#line 1731
    ldv_probe_65();
#line 1733
    ldv_state_variable_65 = 2;
#line 1734
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1737
  goto ldv_67537;
  default: 
#line 1738
  ldv_stop();
  }
  ldv_67537: ;
#line 1742
  return;
}
}
#line 1744 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_50(void) 
{ 
  struct device *ldvarg207 ;
  void *tmp ;
  char *ldvarg208 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg209 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1745
  tmp = ldv_init_zalloc(1416UL);
#line 1745
  ldvarg207 = (struct device *)tmp;
#line 1746
  tmp___0 = ldv_init_zalloc(1UL);
#line 1746
  ldvarg208 = (char *)tmp___0;
#line 1747
  tmp___1 = ldv_init_zalloc(48UL);
#line 1747
  ldvarg209 = (struct device_attribute *)tmp___1;
#line 1749
  tmp___2 = __VERIFIER_nondet_int();
#line 1749
  switch (tmp___2) {
  case 0: ;
#line 1752
  if (ldv_state_variable_50 == 1) {
#line 1754
    qla2x00_optrom_fcode_version_show(ldvarg207, ldvarg209, ldvarg208);
#line 1756
    ldv_state_variable_50 = 1;
  } else {

  }
#line 1759
  goto ldv_67548;
  default: 
#line 1760
  ldv_stop();
  }
  ldv_67548: ;
#line 1764
  return;
}
}
#line 1766 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_39(void) 
{ 
  struct device *ldvarg210 ;
  void *tmp ;
  struct device_attribute *ldvarg212 ;
  void *tmp___0 ;
  char *ldvarg211 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1767
  tmp = ldv_init_zalloc(1416UL);
#line 1767
  ldvarg210 = (struct device *)tmp;
#line 1768
  tmp___0 = ldv_init_zalloc(48UL);
#line 1768
  ldvarg212 = (struct device_attribute *)tmp___0;
#line 1769
  tmp___1 = ldv_init_zalloc(1UL);
#line 1769
  ldvarg211 = (char *)tmp___1;
#line 1771
  tmp___2 = __VERIFIER_nondet_int();
#line 1771
  switch (tmp___2) {
  case 0: ;
#line 1774
  if (ldv_state_variable_39 == 1) {
#line 1776
    qla2x00_fw_state_show(ldvarg210, ldvarg212, ldvarg211);
#line 1778
    ldv_state_variable_39 = 1;
  } else {

  }
#line 1781
  goto ldv_67557;
  default: 
#line 1782
  ldv_stop();
  }
  ldv_67557: ;
#line 1786
  return;
}
}
#line 1788 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_64(void) 
{ 
  char *ldvarg214 ;
  void *tmp ;
  struct device_attribute *ldvarg215 ;
  void *tmp___0 ;
  struct device *ldvarg213 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1789
  tmp = ldv_init_zalloc(1UL);
#line 1789
  ldvarg214 = (char *)tmp;
#line 1790
  tmp___0 = ldv_init_zalloc(48UL);
#line 1790
  ldvarg215 = (struct device_attribute *)tmp___0;
#line 1791
  tmp___1 = ldv_init_zalloc(1416UL);
#line 1791
  ldvarg213 = (struct device *)tmp___1;
#line 1793
  tmp___2 = __VERIFIER_nondet_int();
#line 1793
  switch (tmp___2) {
  case 0: ;
#line 1796
  if (ldv_state_variable_64 == 1) {
#line 1798
    qla2x00_drvr_version_show(ldvarg213, ldvarg215, ldvarg214);
#line 1800
    ldv_state_variable_64 = 1;
  } else {

  }
#line 1803
  goto ldv_67566;
  default: 
#line 1804
  ldv_stop();
  }
  ldv_67566: ;
#line 1808
  return;
}
}
#line 1810 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_36(void) 
{ 
  struct device *ldvarg519 ;
  void *tmp ;
  char *ldvarg520 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg521 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1811
  tmp = ldv_init_zalloc(1416UL);
#line 1811
  ldvarg519 = (struct device *)tmp;
#line 1812
  tmp___0 = ldv_init_zalloc(1UL);
#line 1812
  ldvarg520 = (char *)tmp___0;
#line 1813
  tmp___1 = ldv_init_zalloc(48UL);
#line 1813
  ldvarg521 = (struct device_attribute *)tmp___1;
#line 1815
  tmp___2 = __VERIFIER_nondet_int();
#line 1815
  switch (tmp___2) {
  case 0: ;
#line 1818
  if (ldv_state_variable_36 == 1) {
#line 1820
    qla2x00_diag_megabytes_show(ldvarg519, ldvarg521, ldvarg520);
#line 1822
    ldv_state_variable_36 = 1;
  } else {

  }
#line 1825
  goto ldv_67575;
  default: 
#line 1826
  ldv_stop();
  }
  ldv_67575: ;
#line 1830
  return;
}
}
#line 1832 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_51(void) 
{ 
  struct device_attribute *ldvarg524 ;
  void *tmp ;
  struct device *ldvarg522 ;
  void *tmp___0 ;
  char *ldvarg523 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1833
  tmp = ldv_init_zalloc(48UL);
#line 1833
  ldvarg524 = (struct device_attribute *)tmp;
#line 1834
  tmp___0 = ldv_init_zalloc(1416UL);
#line 1834
  ldvarg522 = (struct device *)tmp___0;
#line 1835
  tmp___1 = ldv_init_zalloc(1UL);
#line 1835
  ldvarg523 = (char *)tmp___1;
#line 1837
  tmp___2 = __VERIFIER_nondet_int();
#line 1837
  switch (tmp___2) {
  case 0: ;
#line 1840
  if (ldv_state_variable_51 == 1) {
#line 1842
    qla2x00_optrom_efi_version_show(ldvarg522, ldvarg524, ldvarg523);
#line 1844
    ldv_state_variable_51 = 1;
  } else {

  }
#line 1847
  goto ldv_67584;
  default: 
#line 1848
  ldv_stop();
  }
  ldv_67584: ;
#line 1852
  return;
}
}
#line 1854 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_41(void) 
{ 
  struct device *ldvarg219 ;
  void *tmp ;
  struct device_attribute *ldvarg221 ;
  void *tmp___0 ;
  char *ldvarg220 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1855
  tmp = ldv_init_zalloc(1416UL);
#line 1855
  ldvarg219 = (struct device *)tmp;
#line 1856
  tmp___0 = ldv_init_zalloc(48UL);
#line 1856
  ldvarg221 = (struct device_attribute *)tmp___0;
#line 1857
  tmp___1 = ldv_init_zalloc(1UL);
#line 1857
  ldvarg220 = (char *)tmp___1;
#line 1859
  tmp___2 = __VERIFIER_nondet_int();
#line 1859
  switch (tmp___2) {
  case 0: ;
#line 1862
  if (ldv_state_variable_41 == 1) {
#line 1864
    qla2x00_vn_port_mac_address_show(ldvarg219, ldvarg221, ldvarg220);
#line 1866
    ldv_state_variable_41 = 1;
  } else {

  }
#line 1869
  goto ldv_67593;
  default: 
#line 1870
  ldv_stop();
  }
  ldv_67593: ;
#line 1874
  return;
}
}
#line 1876 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_58(void) 
{ 
  struct device *ldvarg216 ;
  void *tmp ;
  char *ldvarg217 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg218 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1877
  tmp = ldv_init_zalloc(1416UL);
#line 1877
  ldvarg216 = (struct device *)tmp;
#line 1878
  tmp___0 = ldv_init_zalloc(1UL);
#line 1878
  ldvarg217 = (char *)tmp___0;
#line 1879
  tmp___1 = ldv_init_zalloc(48UL);
#line 1879
  ldvarg218 = (struct device_attribute *)tmp___1;
#line 1881
  tmp___2 = __VERIFIER_nondet_int();
#line 1881
  switch (tmp___2) {
  case 0: ;
#line 1884
  if (ldv_state_variable_58 == 1) {
#line 1886
    qla2x00_model_desc_show(ldvarg216, ldvarg218, ldvarg217);
#line 1888
    ldv_state_variable_58 = 1;
  } else {

  }
#line 1891
  goto ldv_67602;
  default: 
#line 1892
  ldv_stop();
  }
  ldv_67602: ;
#line 1896
  return;
}
}
#line 1898 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_47(void) 
{ 
  struct device *ldvarg525 ;
  void *tmp ;
  struct device_attribute *ldvarg527 ;
  void *tmp___0 ;
  char *ldvarg526 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1899
  tmp = ldv_init_zalloc(1416UL);
#line 1899
  ldvarg525 = (struct device *)tmp;
#line 1900
  tmp___0 = ldv_init_zalloc(48UL);
#line 1900
  ldvarg527 = (struct device_attribute *)tmp___0;
#line 1901
  tmp___1 = ldv_init_zalloc(1UL);
#line 1901
  ldvarg526 = (char *)tmp___1;
#line 1903
  tmp___2 = __VERIFIER_nondet_int();
#line 1903
  switch (tmp___2) {
  case 0: ;
#line 1906
  if (ldv_state_variable_47 == 1) {
#line 1908
    qla24xx_84xx_fw_version_show(ldvarg525, ldvarg527, ldvarg526);
#line 1910
    ldv_state_variable_47 = 1;
  } else {

  }
#line 1913
  goto ldv_67611;
  default: 
#line 1914
  ldv_stop();
  }
  ldv_67611: ;
#line 1918
  return;
}
}
#line 1920 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_38(void) 
{ 
  struct device_attribute *ldvarg530 ;
  void *tmp ;
  struct device *ldvarg528 ;
  void *tmp___0 ;
  char *ldvarg529 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1921
  tmp = ldv_init_zalloc(48UL);
#line 1921
  ldvarg530 = (struct device_attribute *)tmp;
#line 1922
  tmp___0 = ldv_init_zalloc(1416UL);
#line 1922
  ldvarg528 = (struct device *)tmp___0;
#line 1923
  tmp___1 = ldv_init_zalloc(1UL);
#line 1923
  ldvarg529 = (char *)tmp___1;
#line 1925
  tmp___2 = __VERIFIER_nondet_int();
#line 1925
  switch (tmp___2) {
  case 0: ;
#line 1928
  if (ldv_state_variable_38 == 1) {
#line 1930
    qla2x00_thermal_temp_show(ldvarg528, ldvarg530, ldvarg529);
#line 1932
    ldv_state_variable_38 = 1;
  } else {

  }
#line 1935
  goto ldv_67620;
  default: 
#line 1936
  ldv_stop();
  }
  ldv_67620: ;
#line 1940
  return;
}
}
#line 1942 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_52(void) 
{ 
  char *ldvarg257 ;
  void *tmp ;
  struct device_attribute *ldvarg258 ;
  void *tmp___0 ;
  struct device *ldvarg256 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1943
  tmp = ldv_init_zalloc(1UL);
#line 1943
  ldvarg257 = (char *)tmp;
#line 1944
  tmp___0 = ldv_init_zalloc(48UL);
#line 1944
  ldvarg258 = (struct device_attribute *)tmp___0;
#line 1945
  tmp___1 = ldv_init_zalloc(1416UL);
#line 1945
  ldvarg256 = (struct device *)tmp___1;
#line 1947
  tmp___2 = __VERIFIER_nondet_int();
#line 1947
  switch (tmp___2) {
  case 0: ;
#line 1950
  if (ldv_state_variable_52 == 1) {
#line 1952
    qla2x00_optrom_bios_version_show(ldvarg256, ldvarg258, ldvarg257);
#line 1954
    ldv_state_variable_52 = 1;
  } else {

  }
#line 1957
  goto ldv_67629;
  default: 
#line 1958
  ldv_stop();
  }
  ldv_67629: ;
#line 1962
  return;
}
}
#line 1964 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_60(void) 
{ 
  char *ldvarg260 ;
  void *tmp ;
  struct device_attribute *ldvarg261 ;
  void *tmp___0 ;
  struct device *ldvarg259 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1965
  tmp = ldv_init_zalloc(1UL);
#line 1965
  ldvarg260 = (char *)tmp;
#line 1966
  tmp___0 = ldv_init_zalloc(48UL);
#line 1966
  ldvarg261 = (struct device_attribute *)tmp___0;
#line 1967
  tmp___1 = ldv_init_zalloc(1416UL);
#line 1967
  ldvarg259 = (struct device *)tmp___1;
#line 1969
  tmp___2 = __VERIFIER_nondet_int();
#line 1969
  switch (tmp___2) {
  case 0: ;
#line 1972
  if (ldv_state_variable_60 == 1) {
#line 1974
    qla2x00_isp_id_show(ldvarg259, ldvarg261, ldvarg260);
#line 1976
    ldv_state_variable_60 = 1;
  } else {

  }
#line 1979
  goto ldv_67638;
  default: 
#line 1980
  ldv_stop();
  }
  ldv_67638: ;
#line 1984
  return;
}
}
#line 1986 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_34(void) 
{ 
  size_t ldvarg532 ;
  char *ldvarg533 ;
  void *tmp ;
  char *ldvarg531 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1988
  tmp = ldv_init_zalloc(1UL);
#line 1988
  ldvarg533 = (char *)tmp;
#line 1989
  tmp___0 = ldv_init_zalloc(1UL);
#line 1989
  ldvarg531 = (char *)tmp___0;
#line 1987
  ldv_memset((void *)(& ldvarg532), 0, 8UL);
#line 1991
  tmp___1 = __VERIFIER_nondet_int();
#line 1991
  switch (tmp___1) {
  case 0: ;
#line 1994
  if (ldv_state_variable_34 == 1) {
#line 1996
    qla2x00_allow_cna_fw_dump_store(dev_attr_allow_cna_fw_dump_group1, dev_attr_allow_cna_fw_dump_group0,
                                    (char const   *)ldvarg533, ldvarg532);
#line 1998
    ldv_state_variable_34 = 1;
  } else {

  }
#line 2001
  goto ldv_67647;
  case 1: ;
#line 2004
  if (ldv_state_variable_34 == 1) {
#line 2006
    qla2x00_allow_cna_fw_dump_show(dev_attr_allow_cna_fw_dump_group1, dev_attr_allow_cna_fw_dump_group0,
                                   ldvarg531);
#line 2008
    ldv_state_variable_34 = 1;
  } else {

  }
#line 2011
  goto ldv_67647;
  default: 
#line 2012
  ldv_stop();
  }
  ldv_67647: ;
#line 2016
  return;
}
}
#line 2018 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_56(void) 
{ 
  struct device *ldvarg262 ;
  void *tmp ;
  char *ldvarg263 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg264 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 2019
  tmp = ldv_init_zalloc(1416UL);
#line 2019
  ldvarg262 = (struct device *)tmp;
#line 2020
  tmp___0 = ldv_init_zalloc(1UL);
#line 2020
  ldvarg263 = (char *)tmp___0;
#line 2021
  tmp___1 = ldv_init_zalloc(48UL);
#line 2021
  ldvarg264 = (struct device_attribute *)tmp___1;
#line 2023
  tmp___2 = __VERIFIER_nondet_int();
#line 2023
  switch (tmp___2) {
  case 0: ;
#line 2026
  if (ldv_state_variable_56 == 1) {
#line 2028
    qla2x00_link_state_show(ldvarg262, ldvarg264, ldvarg263);
#line 2030
    ldv_state_variable_56 = 1;
  } else {

  }
#line 2033
  goto ldv_67657;
  default: 
#line 2034
  ldv_stop();
  }
  ldv_67657: ;
#line 2038
  return;
}
}
#line 2040 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_73(void) 
{ 
  size_t ldvarg265 ;
  loff_t ldvarg270 ;
  size_t ldvarg268 ;
  loff_t ldvarg267 ;
  char *ldvarg269 ;
  void *tmp ;
  char *ldvarg266 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 2045
  tmp = ldv_init_zalloc(1UL);
#line 2045
  ldvarg269 = (char *)tmp;
#line 2046
  tmp___0 = ldv_init_zalloc(1UL);
#line 2046
  ldvarg266 = (char *)tmp___0;
#line 2041
  ldv_memset((void *)(& ldvarg265), 0, 8UL);
#line 2042
  ldv_memset((void *)(& ldvarg270), 0, 8UL);
#line 2043
  ldv_memset((void *)(& ldvarg268), 0, 8UL);
#line 2044
  ldv_memset((void *)(& ldvarg267), 0, 8UL);
#line 2048
  tmp___1 = __VERIFIER_nondet_int();
#line 2048
  switch (tmp___1) {
  case 0: ;
#line 2051
  if (ldv_state_variable_73 == 2) {
#line 2053
    qla2x00_sysfs_write_fw_dump_template(sysfs_fw_dump_template_attr_group1, sysfs_fw_dump_template_attr_group0,
                                         sysfs_fw_dump_template_attr_group2, ldvarg269,
                                         ldvarg270, ldvarg268);
#line 2055
    ldv_state_variable_73 = 2;
  } else {

  }
#line 2058
  goto ldv_67669;
  case 1: ;
#line 2061
  if (ldv_state_variable_73 == 2) {
#line 2063
    qla2x00_sysfs_read_fw_dump_template(sysfs_fw_dump_template_attr_group1, sysfs_fw_dump_template_attr_group0,
                                        sysfs_fw_dump_template_attr_group2, ldvarg266,
                                        ldvarg267, ldvarg265);
#line 2065
    ldv_state_variable_73 = 2;
  } else {

  }
#line 2068
  goto ldv_67669;
  case 2: ;
#line 2071
  if (ldv_state_variable_73 == 2) {
#line 2073
    ldv_release_73();
#line 2075
    ldv_state_variable_73 = 1;
#line 2076
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2079
  goto ldv_67669;
  case 3: ;
#line 2082
  if (ldv_state_variable_73 == 1) {
#line 2084
    ldv_probe_73();
#line 2086
    ldv_state_variable_73 = 2;
#line 2087
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 2090
  goto ldv_67669;
  default: 
#line 2091
  ldv_stop();
  }
  ldv_67669: ;
#line 2095
  return;
}
}
#line 2097 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_66(void) 
{ 
  struct bin_attribute *ldvarg274 ;
  void *tmp ;
  loff_t ldvarg276 ;
  struct file *ldvarg273 ;
  void *tmp___0 ;
  struct kobject *ldvarg275 ;
  void *tmp___1 ;
  size_t ldvarg271 ;
  char *ldvarg272 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 2098
  tmp = ldv_init_zalloc(72UL);
#line 2098
  ldvarg274 = (struct bin_attribute *)tmp;
#line 2100
  tmp___0 = __VERIFIER_nondet_pointer();
#line 2100
  ldvarg273 = (struct file *)tmp___0;
#line 2101
  tmp___1 = ldv_init_zalloc(296UL);
#line 2101
  ldvarg275 = (struct kobject *)tmp___1;
#line 2103
  tmp___2 = ldv_init_zalloc(1UL);
#line 2103
  ldvarg272 = (char *)tmp___2;
#line 2099
  ldv_memset((void *)(& ldvarg276), 0, 8UL);
#line 2102
  ldv_memset((void *)(& ldvarg271), 0, 8UL);
#line 2105
  tmp___3 = __VERIFIER_nondet_int();
#line 2105
  switch (tmp___3) {
  case 0: ;
#line 2108
  if (ldv_state_variable_66 == 2) {
#line 2110
    qla2x00_sysfs_read_xgmac_stats(ldvarg273, ldvarg275, ldvarg274, ldvarg272, ldvarg276,
                                   ldvarg271);
#line 2112
    ldv_state_variable_66 = 2;
  } else {

  }
#line 2115
  goto ldv_67684;
  case 1: ;
#line 2118
  if (ldv_state_variable_66 == 2) {
#line 2120
    ldv_release_66();
#line 2122
    ldv_state_variable_66 = 1;
#line 2123
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2126
  goto ldv_67684;
  case 2: ;
#line 2129
  if (ldv_state_variable_66 == 1) {
#line 2131
    ldv_probe_66();
#line 2133
    ldv_state_variable_66 = 2;
#line 2134
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 2137
  goto ldv_67684;
  default: 
#line 2138
  ldv_stop();
  }
  ldv_67684: ;
#line 2142
  return;
}
}
#line 2144 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_45(void) 
{ 
  struct device_attribute *ldvarg279 ;
  void *tmp ;
  struct device *ldvarg277 ;
  void *tmp___0 ;
  char *ldvarg278 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 2145
  tmp = ldv_init_zalloc(48UL);
#line 2145
  ldvarg279 = (struct device_attribute *)tmp;
#line 2146
  tmp___0 = ldv_init_zalloc(1416UL);
#line 2146
  ldvarg277 = (struct device *)tmp___0;
#line 2147
  tmp___1 = ldv_init_zalloc(1UL);
#line 2147
  ldvarg278 = (char *)tmp___1;
#line 2149
  tmp___2 = __VERIFIER_nondet_int();
#line 2149
  switch (tmp___2) {
  case 0: ;
#line 2152
  if (ldv_state_variable_45 == 1) {
#line 2154
    qla2x00_mpi_version_show(ldvarg277, ldvarg279, ldvarg278);
#line 2156
    ldv_state_variable_45 = 1;
  } else {

  }
#line 2159
  goto ldv_67695;
  default: 
#line 2160
  ldv_stop();
  }
  ldv_67695: ;
#line 2164
  return;
}
}
#line 2166 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_37(void) 
{ 
  char *ldvarg535 ;
  void *tmp ;
  struct device_attribute *ldvarg536 ;
  void *tmp___0 ;
  struct device *ldvarg534 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 2167
  tmp = ldv_init_zalloc(1UL);
#line 2167
  ldvarg535 = (char *)tmp;
#line 2168
  tmp___0 = ldv_init_zalloc(48UL);
#line 2168
  ldvarg536 = (struct device_attribute *)tmp___0;
#line 2169
  tmp___1 = ldv_init_zalloc(1416UL);
#line 2169
  ldvarg534 = (struct device *)tmp___1;
#line 2171
  tmp___2 = __VERIFIER_nondet_int();
#line 2171
  switch (tmp___2) {
  case 0: ;
#line 2174
  if (ldv_state_variable_37 == 1) {
#line 2176
    qla2x00_diag_requests_show(ldvarg534, ldvarg536, ldvarg535);
#line 2178
    ldv_state_variable_37 = 1;
  } else {

  }
#line 2181
  goto ldv_67704;
  default: 
#line 2182
  ldv_stop();
  }
  ldv_67704: ;
#line 2186
  return;
}
}
#line 2188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_43(void) 
{ 
  struct device *ldvarg537 ;
  void *tmp ;
  struct device_attribute *ldvarg539 ;
  void *tmp___0 ;
  char *ldvarg538 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 2189
  tmp = ldv_init_zalloc(1416UL);
#line 2189
  ldvarg537 = (struct device *)tmp;
#line 2190
  tmp___0 = ldv_init_zalloc(48UL);
#line 2190
  ldvarg539 = (struct device_attribute *)tmp___0;
#line 2191
  tmp___1 = ldv_init_zalloc(1UL);
#line 2191
  ldvarg538 = (char *)tmp___1;
#line 2193
  tmp___2 = __VERIFIER_nondet_int();
#line 2193
  switch (tmp___2) {
  case 0: ;
#line 2196
  if (ldv_state_variable_43 == 1) {
#line 2198
    qla2x00_flash_block_size_show(ldvarg537, ldvarg539, ldvarg538);
#line 2200
    ldv_state_variable_43 = 1;
  } else {

  }
#line 2203
  goto ldv_67713;
  default: 
#line 2204
  ldv_stop();
  }
  ldv_67713: ;
#line 2208
  return;
}
}
#line 2210 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_62(void) 
{ 
  char *ldvarg326 ;
  void *tmp ;
  struct device_attribute *ldvarg327 ;
  void *tmp___0 ;
  struct device *ldvarg325 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 2211
  tmp = ldv_init_zalloc(1UL);
#line 2211
  ldvarg326 = (char *)tmp;
#line 2212
  tmp___0 = ldv_init_zalloc(48UL);
#line 2212
  ldvarg327 = (struct device_attribute *)tmp___0;
#line 2213
  tmp___1 = ldv_init_zalloc(1416UL);
#line 2213
  ldvarg325 = (struct device *)tmp___1;
#line 2215
  tmp___2 = __VERIFIER_nondet_int();
#line 2215
  switch (tmp___2) {
  case 0: ;
#line 2218
  if (ldv_state_variable_62 == 1) {
#line 2220
    qla2x00_serial_num_show(ldvarg325, ldvarg327, ldvarg326);
#line 2222
    ldv_state_variable_62 = 1;
  } else {

  }
#line 2225
  goto ldv_67722;
  default: 
#line 2226
  ldv_stop();
  }
  ldv_67722: ;
#line 2230
  return;
}
}
#line 2232 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_54(void) 
{ 
  char *ldvarg328 ;
  void *tmp ;
  char *ldvarg330 ;
  void *tmp___0 ;
  size_t ldvarg329 ;
  int tmp___1 ;

  {
#line 2233
  tmp = ldv_init_zalloc(1UL);
#line 2233
  ldvarg328 = (char *)tmp;
#line 2234
  tmp___0 = ldv_init_zalloc(1UL);
#line 2234
  ldvarg330 = (char *)tmp___0;
#line 2235
  ldv_memset((void *)(& ldvarg329), 0, 8UL);
#line 2237
  tmp___1 = __VERIFIER_nondet_int();
#line 2237
  switch (tmp___1) {
  case 0: ;
#line 2240
  if (ldv_state_variable_54 == 1) {
#line 2242
    qla2x00_zio_timer_store(dev_attr_zio_timer_group1, dev_attr_zio_timer_group0,
                            (char const   *)ldvarg330, ldvarg329);
#line 2244
    ldv_state_variable_54 = 1;
  } else {

  }
#line 2247
  goto ldv_67731;
  case 1: ;
#line 2250
  if (ldv_state_variable_54 == 1) {
#line 2252
    qla2x00_zio_timer_show(dev_attr_zio_timer_group1, dev_attr_zio_timer_group0, ldvarg328);
#line 2254
    ldv_state_variable_54 = 1;
  } else {

  }
#line 2257
  goto ldv_67731;
  default: 
#line 2258
  ldv_stop();
  }
  ldv_67731: ;
#line 2262
  return;
}
}
#line 2287 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
bool ldv_queue_work_on_177(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 2291
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 2291
  ldv_func_res = tmp;
#line 2293
  activate_work_7(ldv_func_arg3, 2);
#line 2295
  return (ldv_func_res);
}
}
#line 2298 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
bool ldv_queue_delayed_work_on_178(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 2302
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 2302
  ldv_func_res = tmp;
#line 2304
  activate_work_7(& ldv_func_arg3->work, 2);
#line 2306
  return (ldv_func_res);
}
}
#line 2309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
bool ldv_queue_work_on_179(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 2313
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 2313
  ldv_func_res = tmp;
#line 2315
  activate_work_7(ldv_func_arg3, 2);
#line 2317
  return (ldv_func_res);
}
}
#line 2320 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_flush_workqueue_180(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 2323
  flush_workqueue(ldv_func_arg1);
#line 2325
  call_and_disable_all_7(2);
#line 2326
  return;
}
}
#line 2328 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
bool ldv_queue_delayed_work_on_181(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 2332
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 2332
  ldv_func_res = tmp;
#line 2334
  activate_work_7(& ldv_func_arg3->work, 2);
#line 2336
  return (ldv_func_res);
}
}
#line 2339 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
int ldv_scsi_add_host_with_dma_182(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 2343
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 2343
  ldv_func_res = tmp;
#line 2345
  if (ldv_func_res == 0) {
#line 2346
    ldv_state_variable_88 = 1;
#line 2346
    ldv_initialize_scsi_host_template_88();
  } else {

  }
#line 2350
  return (ldv_func_res);
}
}
#line 2353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
int ldv_scsi_add_host_with_dma_183(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 2357
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 2357
  ldv_func_res = tmp;
#line 2359
  if (ldv_func_res == 0) {
#line 2360
    ldv_state_variable_88 = 1;
#line 2360
    ldv_initialize_scsi_host_template_88();
  } else {

  }
#line 2364
  return (ldv_func_res);
}
}
#line 2367 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_scsi_remove_host_184(struct Scsi_Host *shost ) 
{ 


  {
#line 2370
  scsi_remove_host(shost);
#line 2372
  ldv_state_variable_88 = 0;
#line 2373
  return;
}
}
#line 232 "include/linux/timer.h"
int ldv_del_timer_sync_203(struct timer_list *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_197(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_199(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_198(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_201(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_200(struct workqueue_struct *ldv_func_arg1 ) ;
#line 357 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
void activate_work_6(struct work_struct *work , int state ) ;
#line 383
void activate_pending_timer_23(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 389
void choose_timer_23(struct timer_list *timer ) ;
#line 405
void invoke_work_6(void) ;
#line 427
int reg_timer_23(struct timer_list *timer ) ;
#line 431
void call_and_disable_all_6(int state ) ;
#line 433
void disable_suitable_timer_23(struct timer_list *timer ) ;
#line 457
void disable_work_6(struct work_struct *work ) ;
#line 482
void call_and_disable_work_6(struct work_struct *work ) ;
#line 795 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_202(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
#line 806 "include/scsi/scsi_transport_fc.h"
__inline static void u64_to_wwn(u64 inm , u8 *wwn ) 
{ 


  {
#line 808
  *wwn = (u8 )(inm >> 56);
#line 809
  *(wwn + 1UL) = (u8 )(inm >> 48);
#line 810
  *(wwn + 2UL) = (u8 )(inm >> 40);
#line 811
  *(wwn + 3UL) = (u8 )(inm >> 32);
#line 812
  *(wwn + 4UL) = (u8 )(inm >> 24);
#line 813
  *(wwn + 5UL) = (u8 )(inm >> 16);
#line 814
  *(wwn + 6UL) = (u8 )(inm >> 8);
#line 815
  *(wwn + 7UL) = (u8 )inm;
#line 816
  return;
}
}
#line 2041 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
static char const   * const  port_state_str___3[5U]  = {      "Unknown",      "UNCONFIGURED",      "DEAD",      "LOST", 
        "ONLINE"};
#line 159 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_set_fcport_state___2(fc_port_t *fcport , int state ) 
{ 
  int old_state ;

  {
#line 163
  old_state = atomic_read((atomic_t const   *)(& fcport->state));
#line 164
  atomic_set(& fcport->state, state);
#line 167
  if (old_state != 0 && old_state != state) {
#line 168
    ql_dbg(268435456U, fcport->vha, 8317, "FCPort state transitioned from %s to %s - portid=%02x%02x%02x.\n",
           port_state_str___3[old_state], port_state_str___3[state], (int )fcport->d_id.b.domain,
           (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
  } else {

  }
#line 174
  return;
}
}
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.c"
void qla2x00_vp_stop_timer(scsi_qla_host_t *vha ) 
{ 


  {
#line 23
  if ((unsigned int )vha->vp_idx != 0U && vha->timer_active != 0U) {
#line 24
    ldv_del_timer_sync_203(& vha->timer);
#line 25
    vha->timer_active = 0U;
  } else {

  }
#line 27
  return;
}
}
#line 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.c"
static uint32_t qla24xx_allocate_vp_id(scsi_qla_host_t *vha ) 
{ 
  uint32_t vp_id ;
  struct qla_hw_data *ha ;
  unsigned long flags ;
  unsigned long tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 33
  ha = vha->hw;
#line 37
  mutex_lock_nested(& ha->vport_lock, 0U);
#line 38
  tmp = find_first_zero_bit((unsigned long const   *)(& ha->vp_idx_map), (unsigned long )((int )ha->max_npiv_vports + 1));
#line 38
  vp_id = (uint32_t )tmp;
#line 39
  if ((uint32_t )ha->max_npiv_vports < vp_id) {
#line 40
    ql_dbg(262144U, vha, 40960, "vp_id %d is bigger than max-supported %d.\n", vp_id,
           (int )ha->max_npiv_vports);
#line 43
    mutex_unlock(& ha->vport_lock);
#line 44
    return (vp_id);
  } else {

  }
#line 47
  set_bit((long )vp_id, (unsigned long volatile   *)(& ha->vp_idx_map));
#line 48
  ha->num_vhosts = (uint16_t )((int )ha->num_vhosts + 1);
#line 49
  vha->vp_idx = (uint16_t )vp_id;
#line 51
  tmp___0 = spinlock_check(& ha->vport_slock);
#line 51
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 52
  list_add_tail(& vha->list, & ha->vp_list);
#line 54
  qlt_update_vp_map(vha, 1);
#line 56
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 58
  mutex_unlock(& ha->vport_lock);
#line 59
  return (vp_id);
}
}
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.c"
void qla24xx_deallocate_vp_id(scsi_qla_host_t *vha ) 
{ 
  uint16_t vp_id ;
  struct qla_hw_data *ha ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;

  {
#line 66
  ha = vha->hw;
#line 67
  flags = 0UL;
#line 69
  mutex_lock_nested(& ha->vport_lock, 0U);
#line 77
  tmp = spinlock_check(& ha->vport_slock);
#line 77
  flags = _raw_spin_lock_irqsave(tmp);
#line 78
  goto ldv_65965;
  ldv_65964: 
#line 79
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 81
  msleep(500U);
#line 83
  tmp___0 = spinlock_check(& ha->vport_slock);
#line 83
  flags = _raw_spin_lock_irqsave(tmp___0);
  ldv_65965: 
#line 78
  tmp___1 = atomic_read((atomic_t const   *)(& vha->vref_count));
#line 78
  if (tmp___1 != 0) {
#line 80
    goto ldv_65964;
  } else {

  }
#line 85
  list_del(& vha->list);
#line 86
  qlt_update_vp_map(vha, 3);
#line 87
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 89
  vp_id = vha->vp_idx;
#line 90
  ha->num_vhosts = (uint16_t )((int )ha->num_vhosts - 1);
#line 91
  clear_bit((long )vp_id, (unsigned long volatile   *)(& ha->vp_idx_map));
#line 93
  mutex_unlock(& ha->vport_lock);
#line 94
  return;
}
}
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.c"
static scsi_qla_host_t *qla24xx_find_vhost_by_name(struct qla_hw_data *ha , uint8_t *port_name ) 
{ 
  scsi_qla_host_t *vha ;
  struct scsi_qla_host *tvha ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 103
  tmp = spinlock_check(& ha->vport_slock);
#line 103
  flags = _raw_spin_lock_irqsave(tmp);
#line 105
  __mptr = (struct list_head  const  *)ha->vp_list.next;
#line 105
  vha = (scsi_qla_host_t *)__mptr;
#line 105
  __mptr___0 = (struct list_head  const  *)vha->list.next;
#line 105
  tvha = (scsi_qla_host_t *)__mptr___0;
#line 105
  goto ldv_65984;
  ldv_65983: 
#line 106
  tmp___0 = memcmp((void const   *)port_name, (void const   *)(& vha->port_name),
                   8UL);
#line 106
  if (tmp___0 == 0) {
#line 107
    spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 108
    return (vha);
  } else {

  }
#line 105
  vha = tvha;
#line 105
  __mptr___1 = (struct list_head  const  *)tvha->list.next;
#line 105
  tvha = (struct scsi_qla_host *)__mptr___1;
  ldv_65984: ;
#line 105
  if ((unsigned long )(& vha->list) != (unsigned long )(& ha->vp_list)) {
#line 107
    goto ldv_65983;
  } else {

  }
#line 111
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 112
  return ((scsi_qla_host_t *)0);
}
}
#line 129 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.c"
static void qla2x00_mark_vp_devices_dead(scsi_qla_host_t *vha ) 
{ 
  fc_port_t *fcport ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 139
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 139
  fcport = (fc_port_t *)__mptr;
#line 139
  goto ldv_65995;
  ldv_65994: 
#line 140
  ql_dbg(262144U, vha, 40961, "Marking port dead, loop_id=0x%04x : %x.\n", (int )fcport->loop_id,
         (int )(fcport->vha)->vp_idx);
#line 144
  qla2x00_mark_device_lost(vha, fcport, 0, 0);
#line 145
  qla2x00_set_fcport_state___2(fcport, 1);
#line 139
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 139
  fcport = (fc_port_t *)__mptr___0;
  ldv_65995: ;
#line 139
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 141
    goto ldv_65994;
  } else {

  }

#line 146
  return;
}
}
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.c"
int qla24xx_disable_vp(scsi_qla_host_t *vha ) 
{ 
  unsigned long flags ;
  int ret ;
  raw_spinlock_t *tmp ;

  {
#line 155
  ret = qla24xx_control_vp(vha, 11);
#line 156
  atomic_set(& vha->loop_state, 2);
#line 157
  atomic_set(& vha->loop_down_timer, 255);
#line 160
  tmp = spinlock_check(& (vha->hw)->vport_slock);
#line 160
  flags = _raw_spin_lock_irqsave(tmp);
#line 161
  qlt_update_vp_map(vha, 4);
#line 162
  spin_unlock_irqrestore(& (vha->hw)->vport_slock, flags);
#line 164
  qla2x00_mark_vp_devices_dead(vha);
#line 165
  atomic_set(& vha->vp_state, 2);
#line 166
  vha->flags.management_server_logged_in = 0U;
#line 167
  if (ret == 0) {
#line 168
    fc_vport_set_state(vha->fc_vport, 2);
  } else {
#line 170
    fc_vport_set_state(vha->fc_vport, 9);
#line 171
    return (-1);
  }
#line 173
  return (0);
}
}
#line 177 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.c"
int qla24xx_enable_vp(scsi_qla_host_t *vha ) 
{ 
  int ret ;
  struct qla_hw_data *ha ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 180
  ha = vha->hw;
#line 181
  tmp = pci_get_drvdata(ha->pdev);
#line 181
  base_vha = (scsi_qla_host_t *)tmp;
#line 184
  tmp___0 = atomic_read((atomic_t const   *)(& base_vha->loop_state));
#line 184
  if (tmp___0 == 2) {
#line 187
    vha->vp_err_state = 1U;
#line 188
    fc_vport_set_state(vha->fc_vport, 3);
#line 189
    goto enable_failed;
  } else {
#line 184
    tmp___1 = atomic_read((atomic_t const   *)(& base_vha->loop_state));
#line 184
    if (tmp___1 == 6) {
#line 187
      vha->vp_err_state = 1U;
#line 188
      fc_vport_set_state(vha->fc_vport, 3);
#line 189
      goto enable_failed;
    } else
#line 184
    if (((int )ha->current_topology & 8) == 0) {
#line 187
      vha->vp_err_state = 1U;
#line 188
      fc_vport_set_state(vha->fc_vport, 3);
#line 189
      goto enable_failed;
    } else {

    }
  }
#line 193
  mutex_lock_nested(& ha->vport_lock, 0U);
#line 194
  ret = qla24xx_modify_vp_config(vha);
#line 195
  mutex_unlock(& ha->vport_lock);
#line 197
  if (ret != 0) {
#line 198
    fc_vport_set_state(vha->fc_vport, 9);
#line 199
    goto enable_failed;
  } else {

  }
#line 202
  ql_dbg(4194304U, vha, 32794, "Virtual port with id: %d - Enabled.\n", (int )vha->vp_idx);
#line 204
  return (0);
  enable_failed: 
#line 207
  ql_dbg(4194304U, vha, 32795, "Virtual port with id: %d - Disabled.\n", (int )vha->vp_idx);
#line 209
  return (1);
}
}
#line 213 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.c"
static void qla24xx_configure_vp(scsi_qla_host_t *vha ) 
{ 
  struct fc_vport *fc_vport ;
  int ret ;
  int tmp ;

  {
#line 218
  fc_vport = vha->fc_vport;
#line 220
  ql_dbg(262144U, vha, 40962, "%s: change request #3.\n", "qla24xx_configure_vp");
#line 222
  ret = qla2x00_send_change_request(vha, 3, (int )vha->vp_idx);
#line 223
  if (ret != 0) {
#line 224
    ql_dbg(262144U, vha, 40963, "Failed to enable receiving of RSCN requests: 0x%x.\n",
           ret);
#line 226
    return;
  } else {
#line 229
    clear_bit(4L, (unsigned long volatile   *)(& vha->vp_flags));
  }
#line 232
  vha->flags.online = 1U;
#line 233
  tmp = qla24xx_configure_vhba(vha);
#line 233
  if (tmp != 0) {
#line 234
    return;
  } else {

  }
#line 236
  atomic_set(& vha->vp_state, 1);
#line 237
  fc_vport_set_state(fc_vport, 1);
#line 238
  return;
}
}
#line 241 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.c"
void qla2x00_alert_all_vps(struct rsp_que *rsp , uint16_t *mb ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  int i ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  raw_spinlock_t *tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 244
  ha = rsp->hw;
#line 245
  i = 0;
#line 248
  tmp = spinlock_check(& ha->vport_slock);
#line 248
  flags = _raw_spin_lock_irqsave(tmp);
#line 249
  __mptr = (struct list_head  const  *)ha->vp_list.next;
#line 249
  vha = (scsi_qla_host_t *)__mptr;
#line 249
  goto ldv_66046;
  ldv_66045: ;
#line 250
  if ((unsigned int )vha->vp_idx != 0U) {
#line 251
    atomic_inc(& vha->vref_count);
#line 252
    spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 254
    switch ((int )*mb) {
    case 32784: ;
    case 32785: ;
    case 32786: ;
    case 32787: ;
    case 32816: ;
    case 32822: ;
    case 32788: ;
    case 32789: 
#line 263
    ql_dbg(33554432U, vha, 20516, "Async_event for VP[%d], mb=0x%x vha=%p.\n", i,
           (int )*mb, vha);
#line 266
    qla2x00_async_event(vha, rsp, mb);
#line 267
    goto ldv_66041;
    }
    ldv_66041: 
#line 270
    tmp___0 = spinlock_check(& ha->vport_slock);
#line 270
    flags = _raw_spin_lock_irqsave(tmp___0);
#line 271
    atomic_dec(& vha->vref_count);
  } else {

  }
#line 273
  i = i + 1;
#line 249
  __mptr___0 = (struct list_head  const  *)vha->list.next;
#line 249
  vha = (scsi_qla_host_t *)__mptr___0;
  ldv_66046: ;
#line 249
  if ((unsigned long )(& vha->list) != (unsigned long )(& ha->vp_list)) {
#line 251
    goto ldv_66045;
  } else {

  }
#line 275
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 276
  return;
}
}
#line 279 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.c"
int qla2x00_vp_abort_isp(scsi_qla_host_t *vha ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 285
  tmp___0 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 285
  if (tmp___0 != 2) {
#line 286
    atomic_set(& vha->loop_state, 2);
#line 287
    qla2x00_mark_all_devices_lost(vha, 0);
  } else {
#line 289
    tmp = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 289
    if (tmp == 0) {
#line 290
      atomic_set(& vha->loop_down_timer, 255);
    } else {

    }
  }
#line 298
  tmp___1 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 298
  if (tmp___1 == 0) {
#line 299
    qla24xx_control_vp(vha, 11);
  } else {

  }
#line 301
  ql_dbg(4194304U, vha, 32797, "Scheduling enable of Vport %d.\n", (int )vha->vp_idx);
#line 303
  tmp___2 = qla24xx_enable_vp(vha);
#line 303
  return (tmp___2);
}
}
#line 307 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.c"
static int qla2x00_do_dpc_vp(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 309
  ha = vha->hw;
#line 310
  tmp = pci_get_drvdata(ha->pdev);
#line 310
  base_vha = (scsi_qla_host_t *)tmp;
#line 312
  ql_dbg(67141632U, vha, 16402, "Entering %s vp_flags: 0x%lx.\n", "qla2x00_do_dpc_vp",
         vha->vp_flags);
#line 315
  qla2x00_do_work(vha);
#line 318
  tmp___1 = constant_test_bit(5L, (unsigned long const volatile   *)(& base_vha->vp_flags));
#line 318
  if (tmp___1 != 0) {
#line 319
    tmp___0 = test_and_clear_bit(0L, (unsigned long volatile   *)(& vha->vp_flags));
#line 319
    if (tmp___0 != 0) {
#line 321
      ql_dbg(67108864U, vha, 16404, "Configure VP scheduled.\n");
#line 323
      qla24xx_configure_vp(vha);
#line 324
      ql_dbg(67108864U, vha, 16405, "Configure VP end.\n");
#line 326
      return (0);
    } else {

    }
  } else {

  }
#line 330
  tmp___2 = constant_test_bit(13L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 330
  if (tmp___2 != 0) {
#line 331
    ql_dbg(67108864U, vha, 16406, "FCPort update scheduled.\n");
#line 333
    qla2x00_update_fcports(vha);
#line 334
    clear_bit(13L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 335
    ql_dbg(67108864U, vha, 16407, "FCPort update end.\n");
  } else {

  }
#line 339
  tmp___3 = test_and_clear_bit(8L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 339
  if (tmp___3 != 0) {
#line 339
    tmp___4 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 339
    if (tmp___4 == 0) {
#line 339
      tmp___5 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 339
      if (tmp___5 != 2) {
#line 343
        ql_dbg(67108864U, vha, 16408, "Relogin needed scheduled.\n");
#line 345
        qla2x00_relogin(vha);
#line 346
        ql_dbg(67108864U, vha, 16409, "Relogin needed end.\n");
      } else {

      }
    } else {

    }
  } else {

  }
#line 350
  tmp___6 = test_and_clear_bit(0L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 350
  if (tmp___6 != 0) {
#line 350
    tmp___7 = test_and_set_bit(1L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 350
    if (tmp___7 == 0) {
#line 352
      clear_bit(1L, (unsigned long volatile   *)(& vha->dpc_flags));
    } else {

    }
  } else {

  }
#line 355
  tmp___9 = test_and_clear_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 355
  if (tmp___9 != 0) {
#line 356
    tmp___8 = test_and_set_bit(5L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 356
    if (tmp___8 == 0) {
#line 357
      ql_dbg(67108864U, vha, 16410, "Loop resync scheduled.\n");
#line 359
      qla2x00_loop_resync(vha);
#line 360
      clear_bit(5L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 361
      ql_dbg(67108864U, vha, 16411, "Loop resync end.\n");
    } else {

    }
  } else {

  }
#line 366
  ql_dbg(67141632U, vha, 16412, "Exiting %s.\n", "qla2x00_do_dpc_vp");
#line 368
  return (0);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.c"
void qla2x00_do_dpc_all_vps(scsi_qla_host_t *vha ) 
{ 
  int ret ;
  struct qla_hw_data *ha ;
  scsi_qla_host_t *vp ;
  unsigned long flags ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  struct list_head  const  *__mptr ;
  raw_spinlock_t *tmp___1 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 375
  ha = vha->hw;
#line 377
  flags = 0UL;
#line 379
  if ((unsigned int )vha->vp_idx != 0U) {
#line 380
    return;
  } else {

  }
#line 381
  tmp = list_empty((struct list_head  const  *)(& ha->vp_list));
#line 381
  if (tmp != 0) {
#line 382
    return;
  } else {

  }
#line 384
  clear_bit(14L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 386
  if (((int )ha->current_topology & 8) == 0) {
#line 387
    return;
  } else {

  }
#line 389
  tmp___0 = spinlock_check(& ha->vport_slock);
#line 389
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 390
  __mptr = (struct list_head  const  *)ha->vp_list.next;
#line 390
  vp = (scsi_qla_host_t *)__mptr;
#line 390
  goto ldv_66075;
  ldv_66074: ;
#line 391
  if ((unsigned int )vp->vp_idx != 0U) {
#line 392
    atomic_inc(& vp->vref_count);
#line 393
    spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 395
    ret = qla2x00_do_dpc_vp(vp);
#line 397
    tmp___1 = spinlock_check(& ha->vport_slock);
#line 397
    flags = _raw_spin_lock_irqsave(tmp___1);
#line 398
    atomic_dec(& vp->vref_count);
  } else {

  }
#line 390
  __mptr___0 = (struct list_head  const  *)vp->list.next;
#line 390
  vp = (scsi_qla_host_t *)__mptr___0;
  ldv_66075: ;
#line 390
  if ((unsigned long )(& vp->list) != (unsigned long )(& ha->vp_list)) {
#line 392
    goto ldv_66074;
  } else {

  }
#line 401
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 402
  return;
}
}
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.c"
int qla24xx_vport_create_req_sanity_check(struct fc_vport *fc_vport ) 
{ 
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  scsi_qla_host_t *vha ;
  uint8_t port_name[8U] ;
  int tmp___0 ;

  {
#line 407
  tmp = shost_priv(fc_vport->shost);
#line 407
  base_vha = (scsi_qla_host_t *)tmp;
#line 408
  ha = base_vha->hw;
#line 412
  if (fc_vport->roles != 2U) {
#line 413
    return (-38);
  } else {

  }
#line 416
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 417
    return (-38);
  } else {

  }
#line 420
  if (((int )ha->switch_cap & 1024) == 0) {
#line 421
    return (-95);
  } else {

  }
#line 424
  u64_to_wwn(fc_vport->port_name, (u8 *)(& port_name));
#line 425
  tmp___0 = memcmp((void const   *)(& port_name), (void const   *)(& base_vha->port_name),
                   8UL);
#line 425
  if (tmp___0 == 0) {
#line 426
    return (-76);
  } else {

  }
#line 427
  vha = qla24xx_find_vhost_by_name(ha, (uint8_t *)(& port_name));
#line 428
  if ((unsigned long )vha != (unsigned long )((scsi_qla_host_t *)0)) {
#line 429
    return (-76);
  } else {

  }
#line 432
  if ((int )ha->num_vhosts > (int )ha->max_npiv_vports) {
#line 433
    ql_dbg(262144U, vha, 40964, "num_vhosts %ud is bigger than max_npiv_vports %ud.\n",
           (int )ha->num_vhosts, (int )ha->max_npiv_vports);
#line 437
    return (-38);
  } else {

  }
#line 439
  return (0);
}
}
#line 443 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.c"
scsi_qla_host_t *qla24xx_create_vhost(struct fc_vport *fc_vport ) 
{ 
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  scsi_qla_host_t *vha ;
  struct scsi_host_template *sht ;
  struct Scsi_Host *host ;
  struct scsi_qla_host *tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 445
  tmp = shost_priv(fc_vport->shost);
#line 445
  base_vha = (scsi_qla_host_t *)tmp;
#line 446
  ha = base_vha->hw;
#line 448
  sht = & qla2xxx_driver_template;
#line 451
  tmp___0 = qla2x00_create_host(sht, ha);
#line 451
  vha = tmp___0;
#line 452
  if ((unsigned long )vha == (unsigned long )((scsi_qla_host_t *)0)) {
#line 453
    ql_log(1U, vha, 40965, "scsi_host_alloc() failed for vport.\n");
#line 455
    return ((scsi_qla_host_t *)0);
  } else {

  }
#line 458
  host = vha->host;
#line 459
  fc_vport->dd_data = (void *)vha;
#line 461
  u64_to_wwn(fc_vport->node_name, (u8 *)(& vha->node_name));
#line 462
  u64_to_wwn(fc_vport->port_name, (u8 *)(& vha->port_name));
#line 464
  vha->fc_vport = fc_vport;
#line 465
  vha->device_flags = 0U;
#line 466
  tmp___1 = qla24xx_allocate_vp_id(vha);
#line 466
  vha->vp_idx = (uint16_t )tmp___1;
#line 467
  if ((int )vha->vp_idx > (int )ha->max_npiv_vports) {
#line 468
    ql_dbg(262144U, vha, 40966, "Couldn\'t allocate vp_id.\n");
#line 470
    goto create_vhost_failed;
  } else {

  }
#line 472
  vha->mgmt_svr_loop_id = (unsigned int )vha->vp_idx + 10U;
#line 474
  vha->dpc_flags = 0UL;
#line 480
  set_bit(4L, (unsigned long volatile   *)(& vha->vp_flags));
#line 481
  atomic_set(& vha->loop_state, 2);
#line 482
  atomic_set(& vha->loop_down_timer, 255);
#line 484
  qla2x00_start_timer(vha, (void *)(& qla2x00_timer), 1UL);
#line 486
  vha->req = base_vha->req;
#line 487
  host->can_queue = (int )(base_vha->req)->length + 128;
#line 488
  host->cmd_per_lun = 3;
#line 489
  if ((ha->device_type & 33554432U) != 0U && ql2xenabledif != 0) {
#line 490
    host->max_cmd_len = 32U;
  } else {
#line 492
    host->max_cmd_len = 16U;
  }
#line 493
  host->max_channel = 0U;
#line 494
  host->max_lun = ql2xmaxlun;
#line 495
  host->unique_id = host->host_no;
#line 496
  host->max_id = (unsigned int )ha->max_fibre_devices;
#line 497
  host->transportt = qla2xxx_transport_vport_template;
#line 499
  ql_dbg(262144U, vha, 40967, "Detect vport hba %ld at address = %p.\n", vha->host_no,
         vha);
#line 503
  vha->flags.init_done = 1U;
#line 505
  mutex_lock_nested(& ha->vport_lock, 0U);
#line 506
  set_bit((long )vha->vp_idx, (unsigned long volatile   *)(& ha->vp_idx_map));
#line 507
  ha->cur_vport_count = ha->cur_vport_count + 1;
#line 508
  mutex_unlock(& ha->vport_lock);
#line 510
  return (vha);
  create_vhost_failed: ;
#line 513
  return ((scsi_qla_host_t *)0);
}
}
#line 517 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.c"
static void qla25xx_free_req_que(struct scsi_qla_host *vha , struct req_que *req ) 
{ 
  struct qla_hw_data *ha ;
  uint16_t que_id ;

  {
#line 519
  ha = vha->hw;
#line 520
  que_id = req->id;
#line 522
  dma_free_attrs(& (ha->pdev)->dev, (unsigned long )((int )req->length + 1) * 64UL,
                 (void *)req->ring, req->dma, (struct dma_attrs *)0);
#line 524
  req->ring = (request_t *)0;
#line 525
  req->dma = 0ULL;
#line 526
  if ((unsigned int )que_id != 0U) {
#line 527
    *(ha->req_q_map + (unsigned long )que_id) = (struct req_que *)0;
#line 528
    mutex_lock_nested(& ha->vport_lock, 0U);
#line 529
    clear_bit((long )que_id, (unsigned long volatile   *)(& ha->req_qid_map));
#line 530
    mutex_unlock(& ha->vport_lock);
  } else {

  }
#line 532
  kfree((void const   *)req->outstanding_cmds);
#line 533
  kfree((void const   *)req);
#line 534
  req = (struct req_que *)0;
#line 535
  return;
}
}
#line 538 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.c"
static void qla25xx_free_rsp_que(struct scsi_qla_host *vha , struct rsp_que *rsp ) 
{ 
  struct qla_hw_data *ha ;
  uint16_t que_id ;

  {
#line 540
  ha = vha->hw;
#line 541
  que_id = rsp->id;
#line 543
  if ((unsigned long )rsp->msix != (unsigned long )((struct qla_msix_entry *)0) && (rsp->msix)->have_irq != 0) {
#line 544
    free_irq((rsp->msix)->vector, (void *)rsp);
#line 545
    (rsp->msix)->have_irq = 0;
#line 546
    (rsp->msix)->rsp = (struct rsp_que *)0;
  } else {

  }
#line 548
  dma_free_attrs(& (ha->pdev)->dev, (unsigned long )((int )rsp->length + 1) * 64UL,
                 (void *)rsp->ring, rsp->dma, (struct dma_attrs *)0);
#line 550
  rsp->ring = (response_t *)0;
#line 551
  rsp->dma = 0ULL;
#line 552
  if ((unsigned int )que_id != 0U) {
#line 553
    *(ha->rsp_q_map + (unsigned long )que_id) = (struct rsp_que *)0;
#line 554
    mutex_lock_nested(& ha->vport_lock, 0U);
#line 555
    clear_bit((long )que_id, (unsigned long volatile   *)(& ha->rsp_qid_map));
#line 556
    mutex_unlock(& ha->vport_lock);
  } else {

  }
#line 558
  kfree((void const   *)rsp);
#line 559
  rsp = (struct rsp_que *)0;
#line 560
  return;
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.c"
int qla25xx_delete_req_que(struct scsi_qla_host *vha , struct req_que *req ) 
{ 
  int ret ;

  {
#line 565
  ret = -1;
#line 567
  if ((unsigned long )req != (unsigned long )((struct req_que *)0)) {
#line 568
    req->options = (uint16_t )((unsigned int )req->options | 1U);
#line 569
    ret = qla25xx_init_req_que(vha, req);
  } else {

  }
#line 571
  if (ret == 0) {
#line 572
    qla25xx_free_req_que(vha, req);
  } else {

  }
#line 574
  return (ret);
}
}
#line 578 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.c"
static int qla25xx_delete_rsp_que(struct scsi_qla_host *vha , struct rsp_que *rsp ) 
{ 
  int ret ;

  {
#line 580
  ret = -1;
#line 582
  if ((unsigned long )rsp != (unsigned long )((struct rsp_que *)0)) {
#line 583
    rsp->options = (uint16_t )((unsigned int )rsp->options | 1U);
#line 584
    ret = qla25xx_init_rsp_que(vha, rsp);
  } else {

  }
#line 586
  if (ret == 0) {
#line 587
    qla25xx_free_rsp_que(vha, rsp);
  } else {

  }
#line 589
  return (ret);
}
}
#line 594 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.c"
int qla25xx_delete_queues(struct scsi_qla_host *vha ) 
{ 
  int cnt ;
  int ret ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  struct qla_hw_data *ha ;

  {
#line 596
  ret = 0;
#line 597
  req = (struct req_que *)0;
#line 598
  rsp = (struct rsp_que *)0;
#line 599
  ha = vha->hw;
#line 602
  cnt = 1;
#line 602
  goto ldv_66124;
  ldv_66123: 
#line 603
  req = *(ha->req_q_map + (unsigned long )cnt);
#line 604
  if ((unsigned long )req != (unsigned long )((struct req_que *)0)) {
#line 605
    ret = qla25xx_delete_req_que(vha, req);
#line 606
    if (ret != 0) {
#line 607
      ql_log(1U, vha, 234, "Couldn\'t delete req que %d.\n", (int )req->id);
#line 610
      return (ret);
    } else {

    }
  } else {

  }
#line 602
  cnt = cnt + 1;
  ldv_66124: ;
#line 602
  if ((int )ha->max_req_queues > cnt) {
#line 604
    goto ldv_66123;
  } else {

  }
#line 616
  cnt = 1;
#line 616
  goto ldv_66127;
  ldv_66126: 
#line 617
  rsp = *(ha->rsp_q_map + (unsigned long )cnt);
#line 618
  if ((unsigned long )rsp != (unsigned long )((struct rsp_que *)0)) {
#line 619
    ret = qla25xx_delete_rsp_que(vha, rsp);
#line 620
    if (ret != 0) {
#line 621
      ql_log(1U, vha, 235, "Couldn\'t delete rsp que %d.\n", (int )rsp->id);
#line 624
      return (ret);
    } else {

    }
  } else {

  }
#line 616
  cnt = cnt + 1;
  ldv_66127: ;
#line 616
  if ((int )ha->max_rsp_queues > cnt) {
#line 618
    goto ldv_66126;
  } else {

  }

#line 628
  return (ret);
}
}
#line 632 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.c"
int qla25xx_create_req_que(struct qla_hw_data *ha , uint16_t options , uint8_t vp_idx ,
                           uint16_t rid , int rsp_que , uint8_t qos ) 
{ 
  int ret ;
  struct req_que *req ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  uint16_t que_id ;
  device_reg_t *reg ;
  uint32_t cnt ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 635
  ret = 0;
#line 636
  req = (struct req_que *)0;
#line 637
  tmp = pci_get_drvdata(ha->pdev);
#line 637
  base_vha = (struct scsi_qla_host *)tmp;
#line 638
  que_id = 0U;
#line 642
  tmp___0 = kzalloc(192UL, 208U);
#line 642
  req = (struct req_que *)tmp___0;
#line 643
  if ((unsigned long )req == (unsigned long )((struct req_que *)0)) {
#line 644
    ql_log(0U, base_vha, 217, "Failed to allocate memory for request queue.\n");
#line 646
    goto failed;
  } else {

  }
#line 649
  req->length = 2048U;
#line 650
  tmp___1 = dma_alloc_attrs(& (ha->pdev)->dev, (unsigned long )((int )req->length + 1) * 64UL,
                            & req->dma, 208U, (struct dma_attrs *)0);
#line 650
  req->ring = (request_t *)tmp___1;
#line 653
  if ((unsigned long )req->ring == (unsigned long )((request_t *)0)) {
#line 654
    ql_log(0U, base_vha, 218, "Failed to allocate memory for request_ring.\n");
#line 656
    goto que_failed;
  } else {

  }
#line 659
  ret = qla2x00_alloc_outstanding_cmds(ha, req);
#line 660
  if (ret != 0) {
#line 661
    goto que_failed;
  } else {

  }
#line 663
  mutex_lock_nested(& ha->vport_lock, 0U);
#line 664
  tmp___2 = find_first_zero_bit((unsigned long const   *)(& ha->req_qid_map), (unsigned long )ha->max_req_queues);
#line 664
  que_id = (uint16_t )tmp___2;
#line 665
  if ((int )((unsigned short )ha->max_req_queues) <= (int )que_id) {
#line 666
    mutex_unlock(& ha->vport_lock);
#line 667
    ql_log(1U, base_vha, 219, "No resources to create additional request queue.\n");
#line 669
    goto que_failed;
  } else {

  }
#line 671
  set_bit((long )que_id, (unsigned long volatile   *)(& ha->req_qid_map));
#line 672
  *(ha->req_q_map + (unsigned long )que_id) = req;
#line 673
  req->rid = rid;
#line 674
  req->vp_idx = (uint16_t )vp_idx;
#line 675
  req->qos = (uint16_t )qos;
#line 677
  ql_dbg(1048576U, base_vha, 49154, "queue_id=%d rid=%d vp_idx=%d qos=%d.\n", (int )que_id,
         (int )req->rid, (int )req->vp_idx, (int )req->qos);
#line 680
  ql_dbg(1073741824U, base_vha, 220, "queue_id=%d rid=%d vp_idx=%d qos=%d.\n", (int )que_id,
         (int )req->rid, (int )req->vp_idx, (int )req->qos);
#line 683
  if (rsp_que < 0) {
#line 684
    req->rsp = (struct rsp_que *)0;
  } else {
#line 686
    req->rsp = *(ha->rsp_q_map + (unsigned long )rsp_que);
  }
#line 688
  if ((unsigned int )((unsigned char )((int )req->rid >> 8)) != 0U) {
#line 689
    options = (uint16_t )((unsigned int )options | 16U);
  } else {

  }
#line 691
  if ((unsigned int )((unsigned char )req->rid) != 0U) {
#line 692
    options = (uint16_t )((unsigned int )options | 32U);
  } else {

  }
#line 693
  req->options = options;
#line 695
  ql_dbg(1048576U, base_vha, 49155, "options=0x%x.\n", (int )req->options);
#line 697
  ql_dbg(1073741824U, base_vha, 221, "options=0x%x.\n", (int )req->options);
#line 699
  cnt = 1U;
#line 699
  goto ldv_66146;
  ldv_66145: 
#line 700
  *(req->outstanding_cmds + (unsigned long )cnt) = (srb_t *)0;
#line 699
  cnt = cnt + 1U;
  ldv_66146: ;
#line 699
  if ((uint32_t )req->num_outstanding_cmds > cnt) {
#line 701
    goto ldv_66145;
  } else {

  }
#line 701
  req->current_outstanding_cmd = 1U;
#line 703
  req->ring_ptr = req->ring;
#line 704
  req->ring_index = 0U;
#line 705
  req->cnt = req->length;
#line 706
  req->id = que_id;
#line 707
  reg = ((unsigned int )ha->mqenable != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) ? ha->mqiobase + (unsigned long )((int )que_id * 4096) : ha->iobase;
#line 708
  req->req_q_in = & reg->isp25mq.req_q_in;
#line 709
  req->req_q_out = & reg->isp25mq.req_q_out;
#line 710
  req->max_q_depth = (*(ha->req_q_map))->max_q_depth;
#line 711
  req->out_ptr = (uint16_t *)req->ring + (unsigned long )req->length;
#line 712
  mutex_unlock(& ha->vport_lock);
#line 713
  ql_dbg(1048576U, base_vha, 49156, "ring_ptr=%p ring_index=%d, cnt=%d id=%d max_q_depth=%d.\n",
         req->ring_ptr, (int )req->ring_index, (int )req->cnt, (int )req->id, req->max_q_depth);
#line 718
  ql_dbg(1073741824U, base_vha, 222, "ring_ptr=%p ring_index=%d, cnt=%d id=%d max_q_depth=%d.\n",
         req->ring_ptr, (int )req->ring_index, (int )req->cnt, (int )req->id, req->max_q_depth);
#line 724
  ret = qla25xx_init_req_que(base_vha, req);
#line 725
  if (ret != 0) {
#line 726
    ql_log(0U, base_vha, 223, "%s failed.\n", "qla25xx_create_req_que");
#line 728
    mutex_lock_nested(& ha->vport_lock, 0U);
#line 729
    clear_bit((long )que_id, (unsigned long volatile   *)(& ha->req_qid_map));
#line 730
    mutex_unlock(& ha->vport_lock);
#line 731
    goto que_failed;
  } else {

  }
#line 734
  return ((int )req->id);
  que_failed: 
#line 737
  qla25xx_free_req_que(base_vha, req);
  failed: ;
#line 739
  return (0);
}
}
#line 742 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.c"
static void qla_do_work(struct work_struct *work ) 
{ 
  unsigned long flags ;
  struct rsp_que *rsp ;
  struct work_struct  const  *__mptr ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  raw_spinlock_t *tmp ;
  void *tmp___0 ;

  {
#line 745
  __mptr = (struct work_struct  const  *)work;
#line 745
  rsp = (struct rsp_que *)__mptr + 0xffffffffffffff98UL;
#line 747
  ha = rsp->hw;
#line 749
  tmp = spinlock_check(& (rsp->hw)->hardware_lock);
#line 749
  flags = _raw_spin_lock_irqsave(tmp);
#line 750
  tmp___0 = pci_get_drvdata(ha->pdev);
#line 750
  vha = (struct scsi_qla_host *)tmp___0;
#line 751
  qla24xx_process_response_queue(vha, rsp);
#line 752
  spin_unlock_irqrestore(& (rsp->hw)->hardware_lock, flags);
#line 753
  return;
}
}
#line 757 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.c"
int qla25xx_create_rsp_que(struct qla_hw_data *ha , uint16_t options , uint8_t vp_idx ,
                           uint16_t rid , int req ) 
{ 
  int ret ;
  struct rsp_que *rsp ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  uint16_t que_id ;
  device_reg_t *reg ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned long tmp___2 ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;

  {
#line 760
  ret = 0;
#line 761
  rsp = (struct rsp_que *)0;
#line 762
  tmp = pci_get_drvdata(ha->pdev);
#line 762
  base_vha = (struct scsi_qla_host *)tmp;
#line 763
  que_id = 0U;
#line 766
  tmp___0 = kzalloc(272UL, 208U);
#line 766
  rsp = (struct rsp_que *)tmp___0;
#line 767
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 768
    ql_log(1U, base_vha, 102, "Failed to allocate memory for response queue.\n");
#line 770
    goto failed;
  } else {

  }
#line 773
  rsp->length = 128U;
#line 774
  tmp___1 = dma_alloc_attrs(& (ha->pdev)->dev, (unsigned long )((int )rsp->length + 1) * 64UL,
                            & rsp->dma, 208U, (struct dma_attrs *)0);
#line 774
  rsp->ring = (response_t *)tmp___1;
#line 777
  if ((unsigned long )rsp->ring == (unsigned long )((response_t *)0)) {
#line 778
    ql_log(1U, base_vha, 225, "Failed to allocate memory for response ring.\n");
#line 780
    goto que_failed;
  } else {

  }
#line 783
  mutex_lock_nested(& ha->vport_lock, 0U);
#line 784
  tmp___2 = find_first_zero_bit((unsigned long const   *)(& ha->rsp_qid_map), (unsigned long )ha->max_rsp_queues);
#line 784
  que_id = (uint16_t )tmp___2;
#line 785
  if ((int )((unsigned short )ha->max_rsp_queues) <= (int )que_id) {
#line 786
    mutex_unlock(& ha->vport_lock);
#line 787
    ql_log(1U, base_vha, 226, "No resources to create additional request queue.\n");
#line 789
    goto que_failed;
  } else {

  }
#line 791
  set_bit((long )que_id, (unsigned long volatile   *)(& ha->rsp_qid_map));
#line 793
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 794
    rsp->msix = ha->msix_entries + ((unsigned long )que_id + 1UL);
  } else {
#line 796
    ql_log(1U, base_vha, 227, "MSIX not enabled.\n");
  }
#line 799
  *(ha->rsp_q_map + (unsigned long )que_id) = rsp;
#line 800
  rsp->rid = rid;
#line 801
  rsp->vp_idx = (uint16_t )vp_idx;
#line 802
  rsp->hw = ha;
#line 803
  ql_dbg(1073741824U, base_vha, 228, "queue_id=%d rid=%d vp_idx=%d hw=%p.\n", (int )que_id,
         (int )rsp->rid, (int )rsp->vp_idx, rsp->hw);
#line 807
  if ((unsigned int )((unsigned char )((int )rsp->rid >> 8)) != 0U) {
#line 808
    options = (uint16_t )((unsigned int )options | 16U);
  } else {

  }
#line 810
  if ((unsigned int )((unsigned char )rsp->rid) != 0U) {
#line 811
    options = (uint16_t )((unsigned int )options | 32U);
  } else {

  }
#line 813
  if (((ha->device_type & 8192U) == 0U && ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U)) && ((ha->device_type & 524288U) == 0U && (ha->device_type & 1048576U) == 0U)) {
#line 814
    options = (uint16_t )((unsigned int )options | 64U);
  } else {

  }
#line 816
  rsp->options = options;
#line 817
  rsp->id = que_id;
#line 818
  reg = ((unsigned int )ha->mqenable != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U) ? ha->mqiobase + (unsigned long )((int )que_id * 4096) : ha->iobase;
#line 819
  rsp->rsp_q_in = & reg->isp25mq.rsp_q_in;
#line 820
  rsp->rsp_q_out = & reg->isp25mq.rsp_q_out;
#line 821
  rsp->in_ptr = (uint16_t *)rsp->ring + (unsigned long )rsp->length;
#line 822
  mutex_unlock(& ha->vport_lock);
#line 823
  ql_dbg(1048576U, base_vha, 49163, "options=%x id=%d rsp_q_in=%p rsp_q_out=%p", (int )rsp->options,
         (int )rsp->id, rsp->rsp_q_in, rsp->rsp_q_out);
#line 827
  ql_dbg(1073741824U, base_vha, 229, "options=%x id=%d rsp_q_in=%p rsp_q_out=%p",
         (int )rsp->options, (int )rsp->id, rsp->rsp_q_in, rsp->rsp_q_out);
#line 832
  ret = qla25xx_request_irq(rsp);
#line 833
  if (ret != 0) {
#line 834
    goto que_failed;
  } else {

  }
#line 836
  ret = qla25xx_init_rsp_que(base_vha, rsp);
#line 837
  if (ret != 0) {
#line 838
    ql_log(0U, base_vha, 231, "%s failed.\n", "qla25xx_create_rsp_que");
#line 840
    mutex_lock_nested(& ha->vport_lock, 0U);
#line 841
    clear_bit((long )que_id, (unsigned long volatile   *)(& ha->rsp_qid_map));
#line 842
    mutex_unlock(& ha->vport_lock);
#line 843
    goto que_failed;
  } else {

  }
#line 845
  if (req >= 0) {
#line 846
    rsp->req = *(ha->req_q_map + (unsigned long )req);
  } else {
#line 848
    rsp->req = (struct req_que *)0;
  }
#line 850
  qla2x00_init_response_q_entries(rsp);
#line 851
  if ((unsigned long )(rsp->hw)->wq != (unsigned long )((struct workqueue_struct *)0)) {
#line 852
    __init_work(& rsp->q_work, 0);
#line 852
    __constr_expr_0.counter = 137438953408L;
#line 852
    rsp->q_work.data = __constr_expr_0;
#line 852
    lockdep_init_map(& rsp->q_work.lockdep_map, "(&rsp->q_work)", & __key, 0);
#line 852
    INIT_LIST_HEAD(& rsp->q_work.entry);
#line 852
    rsp->q_work.func = & qla_do_work;
  } else {

  }
#line 853
  return ((int )rsp->id);
  que_failed: 
#line 856
  qla25xx_free_rsp_que(base_vha, rsp);
  failed: ;
#line 858
  return (0);
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
void activate_work_6(struct work_struct *work , int state ) 
{ 


  {
#line 489
  if (ldv_work_6_0 == 0) {
#line 490
    ldv_work_struct_6_0 = work;
#line 491
    ldv_work_6_0 = state;
#line 492
    return;
  } else {

  }
#line 495
  if (ldv_work_6_1 == 0) {
#line 496
    ldv_work_struct_6_1 = work;
#line 497
    ldv_work_6_1 = state;
#line 498
    return;
  } else {

  }
#line 501
  if (ldv_work_6_2 == 0) {
#line 502
    ldv_work_struct_6_2 = work;
#line 503
    ldv_work_6_2 = state;
#line 504
    return;
  } else {

  }
#line 507
  if (ldv_work_6_3 == 0) {
#line 508
    ldv_work_struct_6_3 = work;
#line 509
    ldv_work_6_3 = state;
#line 510
    return;
  } else {

  }
#line 512
  return;
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
void activate_pending_timer_23(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 515
  if ((unsigned long )ldv_timer_list_23 == (unsigned long )timer) {
#line 516
    if (ldv_timer_state_23 == 2 || pending_flag != 0) {
#line 517
      ldv_timer_list_23 = timer;
#line 518
      ldv_timer_list_23->data = data;
#line 519
      ldv_timer_state_23 = 1;
    } else {

    }
#line 521
    return;
  } else {

  }
#line 523
  reg_timer_23(timer);
#line 524
  ldv_timer_list_23->data = data;
#line 525
  return;
}
}
#line 528 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
void choose_timer_23(struct timer_list *timer ) 
{ 


  {
#line 529
  LDV_IN_INTERRUPT = 2;
#line 530
  (*(timer->function))(timer->data);
#line 531
  LDV_IN_INTERRUPT = 1;
#line 532
  ldv_timer_state_23 = 2;
#line 533
  return;
}
}
#line 536 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
void invoke_work_6(void) 
{ 
  int tmp ;

  {
#line 538
  tmp = __VERIFIER_nondet_int();
#line 538
  switch (tmp) {
  case 0: ;
#line 540
  if (ldv_work_6_0 == 2 || ldv_work_6_0 == 3) {
#line 541
    ldv_work_6_0 = 4;
#line 542
    qla_do_work(ldv_work_struct_6_0);
#line 543
    ldv_work_6_0 = 1;
  } else {

  }
#line 546
  goto ldv_66196;
  case 1: ;
#line 548
  if (ldv_work_6_1 == 2 || ldv_work_6_1 == 3) {
#line 549
    ldv_work_6_1 = 4;
#line 550
    qla_do_work(ldv_work_struct_6_0);
#line 551
    ldv_work_6_1 = 1;
  } else {

  }
#line 554
  goto ldv_66196;
  case 2: ;
#line 556
  if (ldv_work_6_2 == 2 || ldv_work_6_2 == 3) {
#line 557
    ldv_work_6_2 = 4;
#line 558
    qla_do_work(ldv_work_struct_6_0);
#line 559
    ldv_work_6_2 = 1;
  } else {

  }
#line 562
  goto ldv_66196;
  case 3: ;
#line 564
  if (ldv_work_6_3 == 2 || ldv_work_6_3 == 3) {
#line 565
    ldv_work_6_3 = 4;
#line 566
    qla_do_work(ldv_work_struct_6_0);
#line 567
    ldv_work_6_3 = 1;
  } else {

  }
#line 570
  goto ldv_66196;
  default: 
#line 571
  ldv_stop();
  }
  ldv_66196: ;
#line 573
  return;
}
}
#line 577 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
int reg_timer_23(struct timer_list *timer ) 
{ 


  {
#line 578
  ldv_timer_list_23 = timer;
#line 579
  ldv_timer_state_23 = 1;
#line 580
  return (0);
}
}
#line 583 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
void call_and_disable_all_6(int state ) 
{ 


  {
#line 585
  if (ldv_work_6_0 == state) {
#line 586
    call_and_disable_work_6(ldv_work_struct_6_0);
  } else {

  }
#line 587
  if (ldv_work_6_1 == state) {
#line 588
    call_and_disable_work_6(ldv_work_struct_6_1);
  } else {

  }
#line 589
  if (ldv_work_6_2 == state) {
#line 590
    call_and_disable_work_6(ldv_work_struct_6_2);
  } else {

  }
#line 591
  if (ldv_work_6_3 == state) {
#line 592
    call_and_disable_work_6(ldv_work_struct_6_3);
  } else {

  }
#line 593
  return;
}
}
#line 596 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
void disable_suitable_timer_23(struct timer_list *timer ) 
{ 


  {
#line 597
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_23) {
#line 598
    ldv_timer_state_23 = 0;
#line 599
    return;
  } else {

  }
#line 601
  return;
}
}
#line 604 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
void disable_work_6(struct work_struct *work ) 
{ 


  {
#line 606
  if ((ldv_work_6_0 == 3 || ldv_work_6_0 == 2) && (unsigned long )ldv_work_struct_6_0 == (unsigned long )work) {
#line 608
    ldv_work_6_0 = 1;
  } else {

  }
#line 610
  if ((ldv_work_6_1 == 3 || ldv_work_6_1 == 2) && (unsigned long )ldv_work_struct_6_1 == (unsigned long )work) {
#line 612
    ldv_work_6_1 = 1;
  } else {

  }
#line 614
  if ((ldv_work_6_2 == 3 || ldv_work_6_2 == 2) && (unsigned long )ldv_work_struct_6_2 == (unsigned long )work) {
#line 616
    ldv_work_6_2 = 1;
  } else {

  }
#line 618
  if ((ldv_work_6_3 == 3 || ldv_work_6_3 == 2) && (unsigned long )ldv_work_struct_6_3 == (unsigned long )work) {
#line 620
    ldv_work_6_3 = 1;
  } else {

  }
#line 621
  return;
}
}
#line 625 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
void work_init_6(void) 
{ 


  {
#line 626
  ldv_work_6_0 = 0;
#line 627
  ldv_work_6_1 = 0;
#line 628
  ldv_work_6_2 = 0;
#line 629
  ldv_work_6_3 = 0;
#line 630
  return;
}
}
#line 633 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
void call_and_disable_work_6(struct work_struct *work ) 
{ 


  {
#line 636
  if ((ldv_work_6_0 == 2 || ldv_work_6_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_6_0) {
#line 638
    qla_do_work(work);
#line 639
    ldv_work_6_0 = 1;
#line 640
    return;
  } else {

  }
#line 642
  if ((ldv_work_6_1 == 2 || ldv_work_6_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_6_1) {
#line 644
    qla_do_work(work);
#line 645
    ldv_work_6_1 = 1;
#line 646
    return;
  } else {

  }
#line 648
  if ((ldv_work_6_2 == 2 || ldv_work_6_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_6_2) {
#line 650
    qla_do_work(work);
#line 651
    ldv_work_6_2 = 1;
#line 652
    return;
  } else {

  }
#line 654
  if ((ldv_work_6_3 == 2 || ldv_work_6_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_6_3) {
#line 656
    qla_do_work(work);
#line 657
    ldv_work_6_3 = 1;
#line 658
    return;
  } else {

  }
#line 660
  return;
}
}
#line 686 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
bool ldv_queue_work_on_197(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 690
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 690
  ldv_func_res = tmp;
#line 692
  activate_work_7(ldv_func_arg3, 2);
#line 694
  return (ldv_func_res);
}
}
#line 697 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
bool ldv_queue_delayed_work_on_198(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 701
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 701
  ldv_func_res = tmp;
#line 703
  activate_work_7(& ldv_func_arg3->work, 2);
#line 705
  return (ldv_func_res);
}
}
#line 708 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
bool ldv_queue_work_on_199(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 712
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 712
  ldv_func_res = tmp;
#line 714
  activate_work_7(ldv_func_arg3, 2);
#line 716
  return (ldv_func_res);
}
}
#line 719 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
void ldv_flush_workqueue_200(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 722
  flush_workqueue(ldv_func_arg1);
#line 724
  call_and_disable_all_7(2);
#line 725
  return;
}
}
#line 727 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
bool ldv_queue_delayed_work_on_201(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 731
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 731
  ldv_func_res = tmp;
#line 733
  activate_work_7(& ldv_func_arg3->work, 2);
#line 735
  return (ldv_func_res);
}
}
#line 738 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
int ldv_scsi_add_host_with_dma_202(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 742
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 742
  ldv_func_res = tmp;
#line 744
  if (ldv_func_res == 0) {
#line 745
    ldv_state_variable_88 = 1;
#line 745
    ldv_initialize_scsi_host_template_88();
  } else {

  }
#line 749
  return (ldv_func_res);
}
}
#line 752 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
int ldv_del_timer_sync_203(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 756
  tmp = del_timer_sync(ldv_func_arg1);
#line 756
  ldv_func_res = tmp;
#line 758
  disable_suitable_timer_21(ldv_func_arg1);
#line 760
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_215(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_217(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_216(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_219(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_218(struct workqueue_struct *ldv_func_arg1 ) ;
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
void disable_suitable_timer_24(struct timer_list *timer ) ;
#line 440
void choose_timer_24(struct timer_list *timer ) ;
#line 451
int reg_timer_24(struct timer_list *timer ) ;
#line 481
void activate_pending_timer_24(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 114 "include/linux/seq_file.h"
extern ssize_t seq_read(struct file * , char * , size_t  , loff_t * ) ;
#line 115
extern loff_t seq_lseek(struct file * , loff_t  , int  ) ;
#line 118
extern int seq_putc(struct seq_file * , char  ) ;
#line 119
extern int seq_puts(struct seq_file * , char const   * ) ;
#line 122
extern int seq_printf(struct seq_file * , char const   *  , ...) ;
#line 131
extern int single_open(struct file * , int (*)(struct seq_file * , void * ) , void * ) ;
#line 133
extern int single_release(struct inode * , struct file * ) ;
#line 795 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_220(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
#line 49 "include/linux/debugfs.h"
extern struct dentry *debugfs_create_file(char const   * , umode_t  , struct dentry * ,
                                          void * , struct file_operations  const  * ) ;
#line 58
extern struct dentry *debugfs_create_dir(char const   * , struct dentry * ) ;
#line 68
extern void debugfs_remove(struct dentry * ) ;
#line 12 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dfs.c"
static struct dentry *qla2x00_dfs_root  ;
#line 13 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dfs.c"
static atomic_t qla2x00_dfs_root_count  ;
#line 16 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dfs.c"
static int qla2x00_dfs_fce_show(struct seq_file *s , void *unused ) 
{ 
  scsi_qla_host_t *vha ;
  uint32_t cnt ;
  uint32_t *fce ;
  uint64_t fce_start ;
  struct qla_hw_data *ha ;
  uint32_t *tmp ;

  {
#line 18
  vha = (scsi_qla_host_t *)s->private;
#line 22
  ha = vha->hw;
#line 24
  mutex_lock_nested(& ha->fce_mutex, 0U);
#line 26
  seq_puts(s, "FCE Trace Buffer\n");
#line 27
  seq_printf(s, "In Pointer = %llx\n\n", ha->fce_wr);
#line 28
  seq_printf(s, "Base = %llx\n\n", ha->fce_dma);
#line 29
  seq_puts(s, "FCE Enable Registers\n");
#line 30
  seq_printf(s, "%08x %08x %08x %08x %08x %08x\n", (int )ha->fce_mb[0], (int )ha->fce_mb[2],
             (int )ha->fce_mb[3], (int )ha->fce_mb[4], (int )ha->fce_mb[5], (int )ha->fce_mb[6]);
#line 34
  fce = (uint32_t *)ha->fce;
#line 35
  fce_start = ha->fce_dma;
#line 36
  cnt = 0U;
#line 36
  goto ldv_65896;
  ldv_65895: ;
#line 37
  if ((cnt & 7U) == 0U) {
#line 38
    seq_printf(s, "\n%llx: ", (uint64_t )(cnt * 4U) + fce_start);
  } else {
#line 41
    seq_putc(s, 32);
  }
#line 42
  tmp = fce;
#line 42
  fce = fce + 1;
#line 42
  seq_printf(s, "%08x", *tmp);
#line 36
  cnt = cnt + 1U;
  ldv_65896: ;
#line 36
  if ((ha->fce_bufs * 1024U) / 4U > cnt) {
#line 38
    goto ldv_65895;
  } else {

  }
#line 45
  seq_puts(s, "\nEnd\n");
#line 47
  mutex_unlock(& ha->fce_mutex);
#line 49
  return (0);
}
}
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dfs.c"
static int qla2x00_dfs_fce_open(struct inode *inode , struct file *file ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  int rval ;
  int tmp ;

  {
#line 55
  vha = (scsi_qla_host_t *)inode->i_private;
#line 56
  ha = vha->hw;
#line 59
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 60
    goto out;
  } else {

  }
#line 62
  mutex_lock_nested(& ha->fce_mutex, 0U);
#line 65
  rval = qla2x00_disable_fce_trace(vha, & ha->fce_wr, & ha->fce_rd);
#line 66
  if (rval != 0) {
#line 67
    ql_dbg(8388608U, vha, 28764, "DebugFS: Unable to disable FCE (%d).\n", rval);
  } else {

  }
#line 70
  ha->flags.fce_enabled = 0U;
#line 72
  mutex_unlock(& ha->fce_mutex);
  out: 
#line 74
  tmp = single_open(file, & qla2x00_dfs_fce_show, (void *)vha);
#line 74
  return (tmp);
}
}
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dfs.c"
static int qla2x00_dfs_fce_release(struct inode *inode , struct file *file ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  int rval ;
  int tmp ;

  {
#line 80
  vha = (scsi_qla_host_t *)inode->i_private;
#line 81
  ha = vha->hw;
#line 84
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 85
    goto out;
  } else {

  }
#line 87
  mutex_lock_nested(& ha->fce_mutex, 0U);
#line 90
  ha->flags.fce_enabled = 1U;
#line 91
  memset(ha->fce, 0, (size_t )(ha->fce_bufs * 1024U));
#line 92
  rval = qla2x00_enable_fce_trace(vha, ha->fce_dma, (int )((uint16_t )ha->fce_bufs),
                                  (uint16_t *)(& ha->fce_mb), & ha->fce_bufs);
#line 94
  if (rval != 0) {
#line 95
    ql_dbg(8388608U, vha, 28685, "DebugFS: Unable to reinitialize FCE (%d).\n", rval);
#line 97
    ha->flags.fce_enabled = 0U;
  } else {

  }
#line 100
  mutex_unlock(& ha->fce_mutex);
  out: 
#line 102
  tmp = single_release(inode, file);
#line 102
  return (tmp);
}
}
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dfs.c"
static struct file_operations  const  dfs_fce_ops  = 
#line 105
     {0, & seq_lseek, & seq_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, & qla2x00_dfs_fce_open,
    0, & qla2x00_dfs_fce_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 113 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dfs.c"
int qla2x00_dfs_setup(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct lock_class_key __key ;

  {
#line 115
  ha = vha->hw;
#line 117
  if ((((ha->device_type & 2048U) == 0U && (ha->device_type & 8192U) == 0U) && ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U)) && ((ha->device_type & 524288U) == 0U && (ha->device_type & 1048576U) == 0U)) {
#line 119
    goto out;
  } else {

  }
#line 120
  if ((unsigned long )ha->fce == (unsigned long )((void *)0)) {
#line 121
    goto out;
  } else {

  }
#line 123
  if ((unsigned long )qla2x00_dfs_root != (unsigned long )((struct dentry *)0)) {
#line 124
    goto create_dir;
  } else {

  }
#line 126
  atomic_set(& qla2x00_dfs_root_count, 0);
#line 127
  qla2x00_dfs_root = debugfs_create_dir("qla2xxx", (struct dentry *)0);
#line 128
  if ((unsigned long )qla2x00_dfs_root == (unsigned long )((struct dentry *)0)) {
#line 129
    ql_log(1U, vha, 247, "Unable to create debugfs root directory.\n");
#line 131
    goto out;
  } else {

  }
  create_dir: ;
#line 135
  if ((unsigned long )ha->dfs_dir != (unsigned long )((struct dentry *)0)) {
#line 136
    goto create_nodes;
  } else {

  }
#line 138
  __mutex_init(& ha->fce_mutex, "&ha->fce_mutex", & __key);
#line 139
  ha->dfs_dir = debugfs_create_dir((char const   *)(& vha->host_str), qla2x00_dfs_root);
#line 140
  if ((unsigned long )ha->dfs_dir == (unsigned long )((struct dentry *)0)) {
#line 141
    ql_log(1U, vha, 248, "Unable to create debugfs ha directory.\n");
#line 143
    goto out;
  } else {

  }
#line 146
  atomic_inc(& qla2x00_dfs_root_count);
  create_nodes: 
#line 149
  ha->dfs_fce = debugfs_create_file("fce", 256, ha->dfs_dir, (void *)vha, & dfs_fce_ops);
#line 151
  if ((unsigned long )ha->dfs_fce == (unsigned long )((struct dentry *)0)) {
#line 152
    ql_log(1U, vha, 249, "Unable to create debugfs fce node.\n");
#line 154
    goto out;
  } else {

  }
  out: ;
#line 157
  return (0);
}
}
#line 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dfs.c"
int qla2x00_dfs_remove(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 163
  ha = vha->hw;
#line 164
  if ((unsigned long )ha->dfs_fce != (unsigned long )((struct dentry *)0)) {
#line 165
    debugfs_remove(ha->dfs_fce);
#line 166
    ha->dfs_fce = (struct dentry *)0;
  } else {

  }
#line 169
  if ((unsigned long )ha->dfs_dir != (unsigned long )((struct dentry *)0)) {
#line 170
    debugfs_remove(ha->dfs_dir);
#line 171
    ha->dfs_dir = (struct dentry *)0;
#line 172
    atomic_dec(& qla2x00_dfs_root_count);
  } else {

  }
#line 175
  tmp = atomic_read((atomic_t const   *)(& qla2x00_dfs_root_count));
#line 175
  if (tmp == 0 && (unsigned long )qla2x00_dfs_root != (unsigned long )((struct dentry *)0)) {
#line 177
    debugfs_remove(qla2x00_dfs_root);
#line 178
    qla2x00_dfs_root = (struct dentry *)0;
  } else {

  }
#line 181
  return (0);
}
}
#line 487 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
int ldv_retval_0  ;
#line 490 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
void disable_suitable_timer_24(struct timer_list *timer ) 
{ 


  {
#line 491
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_24) {
#line 492
    ldv_timer_state_24 = 0;
#line 493
    return;
  } else {

  }
#line 495
  return;
}
}
#line 498 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
void ldv_file_operations_31(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 499
  tmp = ldv_init_zalloc(1000UL);
#line 499
  dfs_fce_ops_group1 = (struct inode *)tmp;
#line 500
  tmp___0 = ldv_init_zalloc(504UL);
#line 500
  dfs_fce_ops_group2 = (struct file *)tmp___0;
#line 501
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
void choose_timer_24(struct timer_list *timer ) 
{ 


  {
#line 505
  LDV_IN_INTERRUPT = 2;
#line 506
  (*(timer->function))(timer->data);
#line 507
  LDV_IN_INTERRUPT = 1;
#line 508
  ldv_timer_state_24 = 2;
#line 509
  return;
}
}
#line 512 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
int reg_timer_24(struct timer_list *timer ) 
{ 


  {
#line 513
  ldv_timer_list_24 = timer;
#line 514
  ldv_timer_state_24 = 1;
#line 515
  return (0);
}
}
#line 518 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
void activate_pending_timer_24(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 518
  if ((unsigned long )ldv_timer_list_24 == (unsigned long )timer) {
#line 519
    if (ldv_timer_state_24 == 2 || pending_flag != 0) {
#line 520
      ldv_timer_list_24 = timer;
#line 521
      ldv_timer_list_24->data = data;
#line 522
      ldv_timer_state_24 = 1;
    } else {

    }
#line 524
    return;
  } else {

  }
#line 526
  reg_timer_24(timer);
#line 527
  ldv_timer_list_24->data = data;
#line 528
  return;
}
}
#line 532 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
void ldv_main_exported_31(void) 
{ 
  char *ldvarg115 ;
  void *tmp ;
  size_t ldvarg114 ;
  loff_t *ldvarg113 ;
  void *tmp___0 ;
  loff_t ldvarg112 ;
  int ldvarg111 ;
  int tmp___1 ;

  {
#line 533
  tmp = ldv_init_zalloc(1UL);
#line 533
  ldvarg115 = (char *)tmp;
#line 535
  tmp___0 = ldv_init_zalloc(8UL);
#line 535
  ldvarg113 = (loff_t *)tmp___0;
#line 534
  ldv_memset((void *)(& ldvarg114), 0, 8UL);
#line 536
  ldv_memset((void *)(& ldvarg112), 0, 8UL);
#line 537
  ldv_memset((void *)(& ldvarg111), 0, 4UL);
#line 539
  tmp___1 = __VERIFIER_nondet_int();
#line 539
  switch (tmp___1) {
  case 0: ;
#line 542
  if (ldv_state_variable_31 == 2) {
#line 544
    qla2x00_dfs_fce_release(dfs_fce_ops_group1, dfs_fce_ops_group2);
#line 545
    ldv_state_variable_31 = 1;
#line 546
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 549
  goto ldv_65954;
  case 1: ;
#line 552
  if (ldv_state_variable_31 == 1) {
#line 554
    ldv_retval_0 = qla2x00_dfs_fce_open(dfs_fce_ops_group1, dfs_fce_ops_group2);
#line 555
    if (ldv_retval_0 == 0) {
#line 556
      ldv_state_variable_31 = 2;
#line 557
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 561
  goto ldv_65954;
  case 2: ;
#line 564
  if (ldv_state_variable_31 == 2) {
#line 566
    seq_read(dfs_fce_ops_group2, ldvarg115, ldvarg114, ldvarg113);
#line 568
    ldv_state_variable_31 = 2;
  } else {

  }
#line 571
  goto ldv_65954;
  case 3: ;
#line 574
  if (ldv_state_variable_31 == 2) {
#line 576
    seq_lseek(dfs_fce_ops_group2, ldvarg112, ldvarg111);
#line 578
    ldv_state_variable_31 = 2;
  } else {

  }
#line 581
  goto ldv_65954;
  default: 
#line 582
  ldv_stop();
  }
  ldv_65954: ;
#line 586
  return;
}
}
#line 611 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
bool ldv_queue_work_on_215(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 615
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 615
  ldv_func_res = tmp;
#line 617
  activate_work_7(ldv_func_arg3, 2);
#line 619
  return (ldv_func_res);
}
}
#line 622 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
bool ldv_queue_delayed_work_on_216(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 626
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 626
  ldv_func_res = tmp;
#line 628
  activate_work_7(& ldv_func_arg3->work, 2);
#line 630
  return (ldv_func_res);
}
}
#line 633 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
bool ldv_queue_work_on_217(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 637
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 637
  ldv_func_res = tmp;
#line 639
  activate_work_7(ldv_func_arg3, 2);
#line 641
  return (ldv_func_res);
}
}
#line 644 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
void ldv_flush_workqueue_218(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 647
  flush_workqueue(ldv_func_arg1);
#line 649
  call_and_disable_all_7(2);
#line 650
  return;
}
}
#line 652 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
bool ldv_queue_delayed_work_on_219(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 656
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 656
  ldv_func_res = tmp;
#line 658
  activate_work_7(& ldv_func_arg3->work, 2);
#line 660
  return (ldv_func_res);
}
}
#line 663 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
int ldv_scsi_add_host_with_dma_220(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 667
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 667
  ldv_func_res = tmp;
#line 669
  if (ldv_func_res == 0) {
#line 670
    ldv_state_variable_88 = 1;
#line 670
    ldv_initialize_scsi_host_template_88();
  } else {

  }
#line 674
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_231(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_233(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_232(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_235(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_234(struct workqueue_struct *ldv_func_arg1 ) ;
#line 318 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
int reg_timer_25(struct timer_list *timer ) ;
#line 423
void activate_pending_timer_25(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 424
void choose_timer_25(struct timer_list *timer ) ;
#line 464
void disable_suitable_timer_25(struct timer_list *timer ) ;
#line 271 "include/linux/scatterlist.h"
extern size_t sg_copy_from_buffer(struct scatterlist * , unsigned int  , void const   * ,
                                  size_t  ) ;
#line 273
extern size_t sg_copy_to_buffer(struct scatterlist * , unsigned int  , void * , size_t  ) ;
#line 64 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_sg_attrs___0(struct device *dev , struct scatterlist *sg ,
                                            int nents , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 68
  tmp = get_dma_ops(dev);
#line 68
  ops = tmp;
#line 70
  tmp___0 = valid_dma_direction((int )dir);
#line 70
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 70
  if (tmp___1 != 0L) {
#line 70
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (70), "i" (12UL));
    ldv_26981: ;
#line 70
    goto ldv_26981;
  } else {

  }
#line 71
  debug_dma_unmap_sg(dev, sg, nents, (int )dir);
#line 72
  if ((unsigned long )ops->unmap_sg != (unsigned long )((void (*)(struct device * ,
                                                                  struct scatterlist * ,
                                                                  int  , enum dma_data_direction  ,
                                                                  struct dma_attrs * ))0)) {
#line 73
    (*(ops->unmap_sg))(dev, sg, nents, dir, attrs);
  } else {

  }
#line 74
  return;
}
}
#line 795 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_236(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
#line 677 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
void qla2x00_bsg_job_done(void *data , void *ptr , int res ) ;
#line 678
void qla2x00_bsg_sp_free(void *data , void *ptr ) ;
#line 15 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
void qla2x00_bsg_job_done(void *data , void *ptr , int res ) 
{ 
  srb_t *sp ;
  struct scsi_qla_host *vha ;
  struct fc_bsg_job *bsg_job ;

  {
#line 17
  sp = (srb_t *)ptr;
#line 18
  vha = (struct scsi_qla_host *)data;
#line 19
  bsg_job = sp->u.bsg_job;
#line 21
  (bsg_job->reply)->result = (uint32_t )res;
#line 22
  (*(bsg_job->job_done))(bsg_job);
#line 23
  (*(sp->free))((void *)vha, (void *)sp);
#line 24
  return;
}
}
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
void qla2x00_bsg_sp_free(void *data , void *ptr ) 
{ 
  srb_t *sp ;
  struct scsi_qla_host *vha ;
  struct fc_bsg_job *bsg_job ;
  struct qla_hw_data *ha ;
  struct qla_mt_iocb_rqst_fx00 *piocb_rqst ;

  {
#line 29
  sp = (srb_t *)ptr;
#line 30
  vha = (sp->fcport)->vha;
#line 31
  bsg_job = sp->u.bsg_job;
#line 32
  ha = vha->hw;
#line 35
  if ((unsigned int )sp->type == 11U) {
#line 36
    piocb_rqst = (struct qla_mt_iocb_rqst_fx00 *)(& (bsg_job->request)->rqst_data.h_vendor.vendor_cmd) + 1U;
#line 39
    if ((int )piocb_rqst->flags & 1) {
#line 40
      dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->request_payload.sg_list,
                             bsg_job->request_payload.sg_cnt, 1, (struct dma_attrs *)0);
    } else {

    }
#line 44
    if (((int )piocb_rqst->flags & 2) != 0) {
#line 45
      dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,
                             2, (struct dma_attrs *)0);
    } else {

    }
  } else {
#line 49
    dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->request_payload.sg_list, bsg_job->request_payload.sg_cnt,
                           1, (struct dma_attrs *)0);
#line 52
    dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,
                           2, (struct dma_attrs *)0);
  }
#line 56
  if (((unsigned int )sp->type == 5U || (unsigned int )sp->type == 11U) || (unsigned int )sp->type == 4U) {
#line 59
    kfree((void const   *)sp->fcport);
  } else {

  }
#line 60
  qla2x00_rel_sp(vha, sp);
#line 61
  return;
}
}
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
int qla24xx_fcp_prio_cfg_valid(scsi_qla_host_t *vha , struct qla_fcp_prio_cfg *pri_cfg ,
                               uint8_t flag ) 
{ 
  int i ;
  int ret ;
  int num_valid ;
  uint8_t *bcode ;
  struct qla_fcp_prio_entry *pri_entry ;
  uint32_t *bcode_val_ptr ;
  uint32_t bcode_val ;

  {
#line 72
  ret = 1;
#line 73
  num_valid = 0;
#line 74
  bcode = (uint8_t *)pri_cfg;
#line 75
  bcode_val_ptr = (uint32_t *)pri_cfg;
#line 76
  bcode_val = *bcode_val_ptr;
#line 78
  if (bcode_val == 4294967295U) {
#line 80
    ql_dbg(8388608U, vha, 28753, "No FCP Priority config data.\n");
#line 82
    return (0);
  } else {

  }
#line 85
  if ((((unsigned int )*bcode != 72U || (unsigned int )*(bcode + 1UL) != 81U) || (unsigned int )*(bcode + 2UL) != 79U) || (unsigned int )*(bcode + 3UL) != 83U) {
#line 88
    ql_dbg(8388608U, vha, 28754, "Invalid FCP Priority data header. bcode=0x%x.\n",
           bcode_val);
#line 91
    return (0);
  } else {

  }
#line 93
  if ((unsigned int )flag != 1U) {
#line 94
    return (ret);
  } else {

  }
#line 96
  pri_entry = (struct qla_fcp_prio_entry *)(& pri_cfg->entry);
#line 97
  i = 0;
#line 97
  goto ldv_65996;
  ldv_65995: ;
#line 98
  if (((int )pri_entry->flags & 2) != 0) {
#line 99
    num_valid = num_valid + 1;
  } else {

  }
#line 100
  pri_entry = pri_entry + 1;
#line 97
  i = i + 1;
  ldv_65996: ;
#line 97
  if ((int )pri_cfg->num_entries > i) {
#line 99
    goto ldv_65995;
  } else {

  }

#line 103
  if (num_valid == 0) {
#line 105
    ql_dbg(8388608U, vha, 28755, "No valid FCP Priority data entries.\n");
#line 107
    ret = 0;
  } else {
#line 110
    ql_dbg(8388608U, vha, 28756, "Valid FCP priority data. num entries = %d.\n", num_valid);
  }
#line 115
  return (ret);
}
}
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
static int qla24xx_proc_fcp_prio_cfg_cmd(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int ret ;
  uint32_t len ;
  uint32_t oper ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 121
  host = bsg_job->shost;
#line 122
  tmp = shost_priv(host);
#line 122
  vha = (scsi_qla_host_t *)tmp;
#line 123
  ha = vha->hw;
#line 124
  ret = 0;
#line 128
  if ((((((ha->device_type & 128U) == 0U && (ha->device_type & 256U) == 0U) && ((ha->device_type & 512U) == 0U && (ha->device_type & 1024U) == 0U)) && (ha->device_type & 4096U) == 0U) && (ha->device_type & 2048U) == 0U) && ((ha->device_type & 16384U) == 0U && (ha->device_type & 262144U) == 0U)) {
#line 129
    ret = -22;
#line 130
    goto exit_fcp_prio_cfg;
  } else {

  }
#line 134
  oper = (bsg_job->request)->rqst_data.h_vendor.vendor_cmd[1];
#line 137
  if ((unsigned long )ha->fcp_prio_cfg == (unsigned long )((struct qla_fcp_prio_cfg *)0) && oper != 3U) {
#line 138
    ret = -22;
#line 139
    goto exit_fcp_prio_cfg;
  } else {

  }
#line 141
  switch (oper) {
  case 0U: ;
#line 143
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 144
    ha->flags.fcp_prio_enabled = 0U;
#line 145
    (ha->fcp_prio_cfg)->attributes = (unsigned int )(ha->fcp_prio_cfg)->attributes & 254U;
#line 147
    qla24xx_update_all_fcp_prio(vha);
#line 148
    (bsg_job->reply)->result = 0U;
  } else {
#line 150
    ret = -22;
#line 151
    (bsg_job->reply)->result = 458752U;
#line 152
    goto exit_fcp_prio_cfg;
  }
#line 154
  goto ldv_66009;
  case 1U: ;
#line 157
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 158
    if ((unsigned long )ha->fcp_prio_cfg != (unsigned long )((struct qla_fcp_prio_cfg *)0)) {
#line 159
      ha->flags.fcp_prio_enabled = 1U;
#line 160
      (ha->fcp_prio_cfg)->attributes = (uint8_t )((unsigned int )(ha->fcp_prio_cfg)->attributes | 1U);
#line 162
      qla24xx_update_all_fcp_prio(vha);
#line 163
      (bsg_job->reply)->result = 0U;
    } else {
#line 165
      ret = -22;
#line 166
      (bsg_job->reply)->result = 458752U;
#line 167
      goto exit_fcp_prio_cfg;
    }
  } else {

  }
#line 170
  goto ldv_66009;
  case 2U: 
#line 173
  len = bsg_job->reply_payload.payload_len;
#line 174
  if (len == 0U || len > 32768U) {
#line 175
    ret = -22;
#line 176
    (bsg_job->reply)->result = 458752U;
#line 177
    goto exit_fcp_prio_cfg;
  } else {

  }
#line 180
  (bsg_job->reply)->result = 0U;
#line 181
  tmp___0 = sg_copy_from_buffer(bsg_job->reply_payload.sg_list, (unsigned int )bsg_job->reply_payload.sg_cnt,
                                (void const   *)ha->fcp_prio_cfg, (size_t )len);
#line 181
  (bsg_job->reply)->reply_payload_rcv_len = (uint32_t )tmp___0;
#line 187
  goto ldv_66009;
  case 3U: 
#line 190
  len = bsg_job->request_payload.payload_len;
#line 191
  if (len == 0U || len > 32768U) {
#line 192
    (bsg_job->reply)->result = 458752U;
#line 193
    ret = -22;
#line 194
    goto exit_fcp_prio_cfg;
  } else {

  }
#line 197
  if ((unsigned long )ha->fcp_prio_cfg == (unsigned long )((struct qla_fcp_prio_cfg *)0)) {
#line 198
    tmp___1 = vmalloc(32768UL);
#line 198
    ha->fcp_prio_cfg = (struct qla_fcp_prio_cfg *)tmp___1;
#line 199
    if ((unsigned long )ha->fcp_prio_cfg == (unsigned long )((struct qla_fcp_prio_cfg *)0)) {
#line 200
      ql_log(1U, vha, 28752, "Unable to allocate memory for fcp prio config data (%x).\n",
             32768);
#line 203
      (bsg_job->reply)->result = 458752U;
#line 204
      ret = -12;
#line 205
      goto exit_fcp_prio_cfg;
    } else {

    }
  } else {

  }
#line 209
  memset((void *)ha->fcp_prio_cfg, 0, 32768UL);
#line 210
  sg_copy_to_buffer(bsg_job->request_payload.sg_list, (unsigned int )bsg_job->request_payload.sg_cnt,
                    (void *)ha->fcp_prio_cfg, 32768UL);
#line 216
  tmp___2 = qla24xx_fcp_prio_cfg_valid(vha, ha->fcp_prio_cfg, 1);
#line 216
  if (tmp___2 == 0) {
#line 218
    (bsg_job->reply)->result = 458752U;
#line 219
    ret = -22;
#line 223
    vfree((void const   *)ha->fcp_prio_cfg);
#line 224
    ha->fcp_prio_cfg = (struct qla_fcp_prio_cfg *)0;
#line 225
    goto exit_fcp_prio_cfg;
  } else {

  }
#line 228
  ha->flags.fcp_prio_enabled = 0U;
#line 229
  if ((int )(ha->fcp_prio_cfg)->attributes & 1) {
#line 230
    ha->flags.fcp_prio_enabled = 1U;
  } else {

  }
#line 231
  qla24xx_update_all_fcp_prio(vha);
#line 232
  (bsg_job->reply)->result = 0U;
#line 233
  goto ldv_66009;
  default: 
#line 235
  ret = -22;
#line 236
  goto ldv_66009;
  }
  ldv_66009: ;
  exit_fcp_prio_cfg: ;
#line 239
  if (ret == 0) {
#line 240
    (*(bsg_job->job_done))(bsg_job);
  } else {

  }
#line 241
  return (ret);
}
}
#line 245 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
static int qla2x00_process_els(struct fc_bsg_job *bsg_job ) 
{ 
  struct fc_rport *rport ;
  fc_port_t *fcport ;
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  srb_t *sp ;
  char const   *type ;
  int req_sg_cnt ;
  int rsp_sg_cnt ;
  int rval ;
  uint16_t nextlid ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 248
  fcport = (fc_port_t *)0;
#line 255
  rval = 262144;
#line 256
  nextlid = 0U;
#line 258
  if ((bsg_job->request)->msgcode == 1073741825U) {
#line 259
    rport = bsg_job->rport;
#line 260
    fcport = *((fc_port_t **)rport->dd_data);
#line 261
    host = dev_to_shost(rport->dev.parent);
#line 262
    tmp = shost_priv(host);
#line 262
    vha = (scsi_qla_host_t *)tmp;
#line 263
    ha = vha->hw;
#line 264
    type = "FC_BSG_RPT_ELS";
  } else {
#line 266
    host = bsg_job->shost;
#line 267
    tmp___0 = shost_priv(host);
#line 267
    vha = (scsi_qla_host_t *)tmp___0;
#line 268
    ha = vha->hw;
#line 269
    type = "FC_BSG_HST_ELS_NOLOGIN";
  }
#line 272
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 273
    ql_log(1U, vha, 28677, "Host not online.\n");
#line 274
    rval = -5;
#line 275
    goto done;
  } else {

  }
#line 279
  if ((ha->device_type & 134217728U) == 0U) {
#line 280
    ql_dbg(8388608U, vha, 28673, "ELS passthru not supported for ISP23xx based adapters.\n");
#line 282
    rval = -1;
#line 283
    goto done;
  } else {

  }
#line 287
  if (bsg_job->request_payload.sg_cnt > 1 || bsg_job->reply_payload.sg_cnt > 1) {
#line 289
    ql_dbg(8388608U, vha, 28674, "Multiple SG\'s are not suppored for ELS requests, request_sg_cnt=%x reply_sg_cnt=%x.\n",
           bsg_job->request_payload.sg_cnt, bsg_job->reply_payload.sg_cnt);
#line 294
    rval = -1;
#line 295
    goto done;
  } else {

  }
#line 299
  if ((bsg_job->request)->msgcode == 1073741825U) {
#line 303
    tmp___1 = qla2x00_fabric_login(vha, fcport, & nextlid);
#line 303
    if (tmp___1 != 0) {
#line 304
      ql_dbg(8388608U, vha, 28675, "Failed to login port %06X for ELS passthru.\n",
             (int )fcport->d_id.b24);
#line 307
      rval = -5;
#line 308
      goto done;
    } else {

    }
  } else {
#line 316
    fcport = qla2x00_alloc_fcport(vha, 208U);
#line 317
    if ((unsigned long )fcport == (unsigned long )((fc_port_t *)0)) {
#line 318
      rval = -12;
#line 319
      goto done;
    } else {

    }
#line 323
    fcport->vha = vha;
#line 324
    fcport->d_id.b.al_pa = (bsg_job->request)->rqst_data.h_els.port_id[0];
#line 326
    fcport->d_id.b.area = (bsg_job->request)->rqst_data.h_els.port_id[1];
#line 328
    fcport->d_id.b.domain = (bsg_job->request)->rqst_data.h_els.port_id[2];
#line 330
    fcport->loop_id = (unsigned int )fcport->d_id.b.al_pa == 253U ? 2045U : 2046U;
  }
#line 335
  req_sg_cnt = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->request_payload.sg_list,
                                bsg_job->request_payload.sg_cnt, 1, (struct dma_attrs *)0);
#line 338
  if (req_sg_cnt == 0) {
#line 339
    rval = -12;
#line 340
    goto done_free_fcport;
  } else {

  }
#line 343
  rsp_sg_cnt = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list,
                                bsg_job->reply_payload.sg_cnt, 2, (struct dma_attrs *)0);
#line 345
  if (rsp_sg_cnt == 0) {
#line 346
    rval = -12;
#line 347
    goto done_free_fcport;
  } else {

  }
#line 350
  if (bsg_job->request_payload.sg_cnt != req_sg_cnt || bsg_job->reply_payload.sg_cnt != rsp_sg_cnt) {
#line 352
    ql_log(1U, vha, 28680, "dma mapping resulted in different sg counts, request_sg_cnt: %x dma_request_sg_cnt:%x reply_sg_cnt:%x dma_reply_sg_cnt:%x.\n",
           bsg_job->request_payload.sg_cnt, req_sg_cnt, bsg_job->reply_payload.sg_cnt,
           rsp_sg_cnt);
#line 357
    rval = -11;
#line 358
    goto done_unmap_sg;
  } else {

  }
#line 362
  sp = qla2x00_get_sp(vha, fcport, 208U);
#line 363
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 364
    rval = -12;
#line 365
    goto done_unmap_sg;
  } else {

  }
#line 368
  sp->type = (bsg_job->request)->msgcode == 1073741825U ? 3U : 4U;
#line 371
  sp->name = (bsg_job->request)->msgcode == 1073741825U ? (char *)"bsg_els_rpt" : (char *)"bsg_els_hst";
#line 374
  sp->u.bsg_job = bsg_job;
#line 375
  sp->free = & qla2x00_bsg_sp_free;
#line 376
  sp->done = & qla2x00_bsg_job_done;
#line 378
  ql_dbg(8388608U, vha, 28682, "bsg rqst type: %s els type: %x - loop-id=%x portid=%-2x%02x%02x.\n",
         type, (int )(bsg_job->request)->rqst_data.h_els.command_code, (int )fcport->loop_id,
         (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
#line 384
  rval = qla2x00_start_sp(sp);
#line 385
  if (rval != 0) {
#line 386
    ql_log(1U, vha, 28686, "qla2x00_start_sp failed = %d\n", rval);
#line 388
    qla2x00_rel_sp(vha, sp);
#line 389
    rval = -5;
#line 390
    goto done_unmap_sg;
  } else {

  }
#line 392
  return (rval);
  done_unmap_sg: 
#line 395
  dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->request_payload.sg_list, bsg_job->request_payload.sg_cnt,
                         1, (struct dma_attrs *)0);
#line 397
  dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,
                         2, (struct dma_attrs *)0);
#line 399
  goto done_free_fcport;
  done_free_fcport: ;
#line 402
  if ((bsg_job->request)->msgcode == 1073741825U) {
#line 403
    kfree((void const   *)fcport);
  } else {

  }
  done: ;
#line 405
  return (rval);
}
}
#line 409 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
__inline uint16_t qla24xx_calc_ct_iocbs(uint16_t dsds ) 
{ 
  uint16_t iocbs ;

  {
#line 413
  iocbs = 1U;
#line 414
  if ((unsigned int )dsds > 2U) {
#line 415
    iocbs = (int )((uint16_t )(((int )dsds + -2) / 5)) + (int )iocbs;
#line 416
    if (((int )dsds + -2) % 5 != 0) {
#line 417
      iocbs = (uint16_t )((int )iocbs + 1);
    } else {

    }
  } else {

  }
#line 419
  return (iocbs);
}
}
#line 423 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
static int qla2x00_process_ct(struct fc_bsg_job *bsg_job ) 
{ 
  srb_t *sp ;
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int rval ;
  int req_sg_cnt ;
  int rsp_sg_cnt ;
  uint16_t loop_id ;
  struct fc_port *fcport ;
  char *type ;
  fc_port_t *tmp___0 ;
  uint16_t tmp___1 ;

  {
#line 426
  host = bsg_job->shost;
#line 427
  tmp = shost_priv(host);
#line 427
  vha = (scsi_qla_host_t *)tmp;
#line 428
  ha = vha->hw;
#line 429
  rval = 262144;
#line 433
  type = (char *)"FC_BSG_HST_CT";
#line 435
  req_sg_cnt = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->request_payload.sg_list,
                                bsg_job->request_payload.sg_cnt, 1, (struct dma_attrs *)0);
#line 438
  if (req_sg_cnt == 0) {
#line 439
    ql_log(1U, vha, 28687, "dma_map_sg return %d for request\n", req_sg_cnt);
#line 441
    rval = -12;
#line 442
    goto done;
  } else {

  }
#line 445
  rsp_sg_cnt = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list,
                                bsg_job->reply_payload.sg_cnt, 2, (struct dma_attrs *)0);
#line 447
  if (rsp_sg_cnt == 0) {
#line 448
    ql_log(1U, vha, 28688, "dma_map_sg return %d for reply\n", rsp_sg_cnt);
#line 450
    rval = -12;
#line 451
    goto done;
  } else {

  }
#line 454
  if (bsg_job->request_payload.sg_cnt != req_sg_cnt || bsg_job->reply_payload.sg_cnt != rsp_sg_cnt) {
#line 456
    ql_log(1U, vha, 28689, "request_sg_cnt: %x dma_request_sg_cnt: %x reply_sg_cnt:%x dma_reply_sg_cnt: %x\n",
           bsg_job->request_payload.sg_cnt, req_sg_cnt, bsg_job->reply_payload.sg_cnt,
           rsp_sg_cnt);
#line 460
    rval = -11;
#line 461
    goto done_unmap_sg;
  } else {

  }
#line 464
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 465
    ql_log(1U, vha, 28690, "Host is not online.\n");
#line 467
    rval = -5;
#line 468
    goto done_unmap_sg;
  } else {

  }
#line 471
  loop_id = (uint16_t )((bsg_job->request)->rqst_data.h_ct.preamble_word1 >> 24);
#line 474
  switch ((int )loop_id) {
  case 252: 
#line 476
  loop_id = 2044U;
#line 477
  goto ldv_66051;
  case 250: 
#line 479
  loop_id = vha->mgmt_svr_loop_id;
#line 480
  goto ldv_66051;
  default: 
#line 482
  ql_dbg(8388608U, vha, 28691, "Unknown loop id: %x.\n", (int )loop_id);
#line 484
  rval = -22;
#line 485
  goto done_unmap_sg;
  }
  ldv_66051: 
#line 493
  tmp___0 = qla2x00_alloc_fcport(vha, 208U);
#line 493
  fcport = tmp___0;
#line 494
  if ((unsigned long )fcport == (unsigned long )((struct fc_port *)0)) {
#line 495
    ql_log(1U, vha, 28692, "Failed to allocate fcport.\n");
#line 497
    rval = -12;
#line 498
    goto done_unmap_sg;
  } else {

  }
#line 502
  fcport->vha = vha;
#line 503
  fcport->d_id.b.al_pa = (bsg_job->request)->rqst_data.h_ct.port_id[0];
#line 504
  fcport->d_id.b.area = (bsg_job->request)->rqst_data.h_ct.port_id[1];
#line 505
  fcport->d_id.b.domain = (bsg_job->request)->rqst_data.h_ct.port_id[2];
#line 506
  fcport->loop_id = loop_id;
#line 509
  sp = qla2x00_get_sp(vha, fcport, 208U);
#line 510
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 511
    ql_log(1U, vha, 28693, "qla2x00_get_sp failed.\n");
#line 513
    rval = -12;
#line 514
    goto done_free_fcport;
  } else {

  }
#line 517
  sp->type = 5U;
#line 518
  sp->name = (char *)"bsg_ct";
#line 519
  tmp___1 = qla24xx_calc_ct_iocbs((int )((uint16_t )req_sg_cnt) + (int )((uint16_t )rsp_sg_cnt));
#line 519
  sp->iocbs = (int )tmp___1;
#line 520
  sp->u.bsg_job = bsg_job;
#line 521
  sp->free = & qla2x00_bsg_sp_free;
#line 522
  sp->done = & qla2x00_bsg_job_done;
#line 524
  ql_dbg(8388608U, vha, 28694, "bsg rqst type: %s else type: %x - loop-id=%x portid=%02x%02x%02x.\n",
         type, (bsg_job->request)->rqst_data.h_ct.preamble_word2 >> 16, (int )fcport->loop_id,
         (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
#line 531
  rval = qla2x00_start_sp(sp);
#line 532
  if (rval != 0) {
#line 533
    ql_log(1U, vha, 28695, "qla2x00_start_sp failed=%d.\n", rval);
#line 535
    qla2x00_rel_sp(vha, sp);
#line 536
    rval = -5;
#line 537
    goto done_free_fcport;
  } else {

  }
#line 539
  return (rval);
  done_free_fcport: 
#line 542
  kfree((void const   *)fcport);
  done_unmap_sg: 
#line 544
  dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->request_payload.sg_list, bsg_job->request_payload.sg_cnt,
                         1, (struct dma_attrs *)0);
#line 546
  dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,
                         2, (struct dma_attrs *)0);
  done: ;
#line 549
  return (rval);
}
}
#line 554 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
__inline static int qla81xx_reset_loopback_mode(scsi_qla_host_t *vha , uint16_t *config ,
                                                int wait , int wait2 ) 
{ 
  int ret ;
  int rval ;
  uint16_t new_config[4U] ;
  struct qla_hw_data *ha ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 557
  ret = 0;
#line 558
  rval = 0;
#line 560
  ha = vha->hw;
#line 562
  if (((ha->device_type & 8192U) == 0U && (ha->device_type & 65536U) == 0U) && (ha->device_type & 262144U) == 0U) {
#line 563
    goto done_reset_internal;
  } else {

  }
#line 565
  memset((void *)(& new_config), 0, 8UL);
#line 566
  if (((int )*config & 14) >> 1 == 2 || ((int )*config & 14) >> 1 == 4) {
#line 570
    new_config[0] = (unsigned int )*config & 65521U;
#line 571
    ql_dbg(8388608U, vha, 28863, "new_config[0]=%02x\n", (int )new_config[0] & 14);
#line 573
    memcpy((void *)(& new_config) + 1U, (void const   *)config + 1U, 6UL);
#line 575
    ha->notify_dcbx_comp = wait;
#line 576
    ha->notify_lb_portup_comp = wait2;
#line 578
    ret = qla81xx_set_port_config(vha, (uint16_t *)(& new_config));
#line 579
    if (ret != 0) {
#line 580
      ql_log(1U, vha, 28709, "Set port config failed.\n");
#line 582
      ha->notify_dcbx_comp = 0;
#line 583
      ha->notify_lb_portup_comp = 0;
#line 584
      rval = -22;
#line 585
      goto done_reset_internal;
    } else {

    }
#line 589
    if (wait != 0) {
#line 589
      tmp = wait_for_completion_timeout(& ha->dcbx_comp, 5000UL);
#line 589
      if (tmp == 0UL) {
#line 591
        ql_dbg(8388608U, vha, 28710, "DCBX completion not received.\n");
#line 593
        ha->notify_dcbx_comp = 0;
#line 594
        ha->notify_lb_portup_comp = 0;
#line 595
        rval = -22;
#line 596
        goto done_reset_internal;
      } else {
#line 598
        ql_dbg(8388608U, vha, 28711, "DCBX completion received.\n");
      }
    } else {
#line 598
      ql_dbg(8388608U, vha, 28711, "DCBX completion received.\n");
    }
#line 601
    if (wait2 != 0) {
#line 601
      tmp___0 = wait_for_completion_timeout(& ha->lb_portup_comp, 2500UL);
#line 601
      if (tmp___0 == 0UL) {
#line 604
        ql_dbg(8388608U, vha, 28869, "Port up completion not received.\n");
#line 606
        ha->notify_lb_portup_comp = 0;
#line 607
        rval = -22;
#line 608
        goto done_reset_internal;
      } else {
#line 610
        ql_dbg(8388608U, vha, 28870, "Port up completion received.\n");
      }
    } else {
#line 610
      ql_dbg(8388608U, vha, 28870, "Port up completion received.\n");
    }
#line 613
    ha->notify_dcbx_comp = 0;
#line 614
    ha->notify_lb_portup_comp = 0;
  } else {

  }
  done_reset_internal: ;
#line 617
  return (rval);
}
}
#line 625 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
__inline static int qla81xx_set_loopback_mode(scsi_qla_host_t *vha , uint16_t *config ,
                                              uint16_t *new_config , uint16_t mode ) 
{ 
  int ret ;
  int rval ;
  unsigned long rem_tmo ;
  unsigned long current_tmo ;
  struct qla_hw_data *ha ;

  {
#line 628
  ret = 0;
#line 629
  rval = 0;
#line 630
  rem_tmo = 0UL;
#line 630
  current_tmo = 0UL;
#line 631
  ha = vha->hw;
#line 633
  if (((ha->device_type & 8192U) == 0U && (ha->device_type & 65536U) == 0U) && (ha->device_type & 262144U) == 0U) {
#line 634
    goto done_set_internal;
  } else {

  }
#line 636
  if ((unsigned int )mode == 241U) {
#line 637
    *new_config = (uint16_t )((unsigned int )*config | 4U);
  } else
#line 638
  if ((unsigned int )mode == 242U) {
#line 639
    *new_config = (uint16_t )((unsigned int )*config | 8U);
  } else {

  }
#line 640
  ql_dbg(8388608U, vha, 28862, "new_config[0]=%02x\n", (int )*new_config & 14);
#line 643
  memcpy((void *)new_config + 1U, (void const   *)config + 1U, 6UL);
#line 645
  ha->notify_dcbx_comp = 1;
#line 646
  ret = qla81xx_set_port_config(vha, new_config);
#line 647
  if (ret != 0) {
#line 648
    ql_log(1U, vha, 28705, "set port config failed.\n");
#line 650
    ha->notify_dcbx_comp = 0;
#line 651
    rval = -22;
#line 652
    goto done_set_internal;
  } else {

  }
#line 656
  current_tmo = 5000UL;
  ldv_66079: 
#line 658
  rem_tmo = wait_for_completion_timeout(& ha->dcbx_comp, current_tmo);
#line 660
  if (ha->idc_extend_tmo == 0U || rem_tmo != 0UL) {
#line 661
    ha->idc_extend_tmo = 0U;
#line 662
    goto ldv_66078;
  } else {

  }
#line 664
  current_tmo = (unsigned long )(ha->idc_extend_tmo * 250U);
#line 665
  ha->idc_extend_tmo = 0U;
#line 666
  goto ldv_66079;
  ldv_66078: ;
#line 668
  if (rem_tmo == 0UL) {
#line 669
    ql_dbg(8388608U, vha, 28706, "DCBX completion not received.\n");
#line 671
    ret = qla81xx_reset_loopback_mode(vha, new_config, 0, 0);
#line 676
    if (ret != 0) {
#line 677
      (*((ha->isp_ops)->fw_dump))(vha, 0);
#line 678
      set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
    } else {

    }
#line 680
    rval = -22;
  } else
#line 682
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 683
    ql_dbg(8388608U, vha, 28867, "Bad status in IDC Completion AEN\n");
#line 685
    rval = -22;
#line 686
    ha->flags.idc_compl_status = 0U;
  } else {
#line 688
    ql_dbg(8388608U, vha, 28707, "DCBX completion received.\n");
  }
#line 692
  ha->notify_dcbx_comp = 0;
#line 693
  ha->idc_extend_tmo = 0U;
  done_set_internal: ;
#line 696
  return (rval);
}
}
#line 700 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
static int qla2x00_process_loopback(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int rval ;
  uint8_t command_sent ;
  char *type ;
  struct msg_echo_lb elreq ;
  uint16_t response[32U] ;
  uint16_t config[4U] ;
  uint16_t new_config[4U] ;
  uint8_t *fw_sts_ptr ;
  uint8_t *req_data ;
  dma_addr_t req_data_dma ;
  uint32_t req_data_len ;
  uint8_t *rsp_data ;
  dma_addr_t rsp_data_dma ;
  uint32_t rsp_data_len ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int ret ;
  int tmp___6 ;

  {
#line 702
  host = bsg_job->shost;
#line 703
  tmp = shost_priv(host);
#line 703
  vha = (scsi_qla_host_t *)tmp;
#line 704
  ha = vha->hw;
#line 712
  req_data = (uint8_t *)0U;
#line 715
  rsp_data = (uint8_t *)0U;
#line 719
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 720
    ql_log(1U, vha, 28697, "Host is not online.\n");
#line 721
    return (-5);
  } else {

  }
#line 724
  tmp___0 = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->request_payload.sg_list,
                             bsg_job->request_payload.sg_cnt, 1, (struct dma_attrs *)0);
#line 724
  elreq.req_sg_cnt = (uint16_t )tmp___0;
#line 728
  if ((unsigned int )elreq.req_sg_cnt == 0U) {
#line 729
    ql_log(1U, vha, 28698, "dma_map_sg returned %d for request.\n", (int )elreq.req_sg_cnt);
#line 731
    return (-12);
  } else {

  }
#line 734
  tmp___1 = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,
                             2, (struct dma_attrs *)0);
#line 734
  elreq.rsp_sg_cnt = (uint16_t )tmp___1;
#line 738
  if ((unsigned int )elreq.rsp_sg_cnt == 0U) {
#line 739
    ql_log(1U, vha, 28699, "dma_map_sg returned %d for reply.\n", (int )elreq.rsp_sg_cnt);
#line 741
    rval = -12;
#line 742
    goto done_unmap_req_sg;
  } else {

  }
#line 745
  if ((int )elreq.req_sg_cnt != bsg_job->request_payload.sg_cnt || (int )elreq.rsp_sg_cnt != bsg_job->reply_payload.sg_cnt) {
#line 747
    ql_log(1U, vha, 28700, "dma mapping resulted in different sg counts, request_sg_cnt: %x dma_request_sg_cnt: %x reply_sg_cnt: %x dma_reply_sg_cnt: %x.\n",
           bsg_job->request_payload.sg_cnt, (int )elreq.req_sg_cnt, bsg_job->reply_payload.sg_cnt,
           (int )elreq.rsp_sg_cnt);
#line 753
    rval = -11;
#line 754
    goto done_unmap_sg;
  } else {

  }
#line 756
  rsp_data_len = bsg_job->request_payload.payload_len;
#line 756
  req_data_len = rsp_data_len;
#line 757
  tmp___2 = dma_alloc_attrs(& (ha->pdev)->dev, (size_t )req_data_len, & req_data_dma,
                            208U, (struct dma_attrs *)0);
#line 757
  req_data = (uint8_t *)tmp___2;
#line 759
  if ((unsigned long )req_data == (unsigned long )((uint8_t *)0U)) {
#line 760
    ql_log(1U, vha, 28701, "dma alloc failed for req_data.\n");
#line 762
    rval = -12;
#line 763
    goto done_unmap_sg;
  } else {

  }
#line 766
  tmp___3 = dma_alloc_attrs(& (ha->pdev)->dev, (size_t )rsp_data_len, & rsp_data_dma,
                            208U, (struct dma_attrs *)0);
#line 766
  rsp_data = (uint8_t *)tmp___3;
#line 768
  if ((unsigned long )rsp_data == (unsigned long )((uint8_t *)0U)) {
#line 769
    ql_log(1U, vha, 28676, "dma alloc failed for rsp_data.\n");
#line 771
    rval = -12;
#line 772
    goto done_free_dma_req;
  } else {

  }
#line 776
  sg_copy_to_buffer(bsg_job->request_payload.sg_list, (unsigned int )bsg_job->request_payload.sg_cnt,
                    (void *)req_data, (size_t )req_data_len);
#line 779
  elreq.send_dma = req_data_dma;
#line 780
  elreq.rcv_dma = rsp_data_dma;
#line 781
  elreq.transfer_size = req_data_len;
#line 783
  elreq.options = (uint16_t )(bsg_job->request)->rqst_data.h_vendor.vendor_cmd[1];
#line 784
  elreq.iteration_count = (bsg_job->request)->rqst_data.h_vendor.vendor_cmd[2];
#line 787
  tmp___6 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 787
  if ((tmp___6 == 5 && ((unsigned int )ha->current_topology == 8U || (((((ha->device_type & 8192U) != 0U || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) && *((uint32_t *)req_data) == 16U) && req_data_len == 252U))) && (unsigned int )elreq.options == 242U) {
#line 793
    type = (char *)"FC_BSG_HST_VENDOR_ECHO_DIAG";
#line 794
    ql_dbg(8388608U, vha, 28702, "BSG request type: %s.\n", type);
#line 796
    command_sent = 1U;
#line 797
    rval = qla2x00_echo_test(vha, & elreq, (uint16_t *)(& response));
  } else
#line 799
  if (((ha->device_type & 8192U) != 0U || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 800
    memset((void *)(& config), 0, 8UL);
#line 801
    memset((void *)(& new_config), 0, 8UL);
#line 803
    tmp___4 = qla81xx_get_port_config(vha, (uint16_t *)(& config));
#line 803
    if (tmp___4 != 0) {
#line 804
      ql_log(1U, vha, 28703, "Get port config failed.\n");
#line 806
      rval = -1;
#line 807
      goto done_free_dma_rsp;
    } else {

    }
#line 810
    if (((int )config[0] & 14) != 0) {
#line 811
      ql_dbg(8388608U, vha, 28868, "Loopback operation already in progress.\n");
#line 814
      rval = -11;
#line 815
      goto done_free_dma_rsp;
    } else {

    }
#line 818
    ql_dbg(8388608U, vha, 28864, "elreq.options=%04x\n", (int )elreq.options);
#line 821
    if ((unsigned int )elreq.options == 242U) {
#line 822
      if ((ha->device_type & 65536U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 823
        rval = qla81xx_set_loopback_mode(vha, (uint16_t *)(& config), (uint16_t *)(& new_config),
                                         (int )elreq.options);
      } else {
#line 826
        rval = qla81xx_reset_loopback_mode(vha, (uint16_t *)(& config), 1, 0);
      }
    } else {
#line 829
      rval = qla81xx_set_loopback_mode(vha, (uint16_t *)(& config), (uint16_t *)(& new_config),
                                       (int )elreq.options);
    }
#line 832
    if (rval != 0) {
#line 833
      rval = -1;
#line 834
      goto done_free_dma_rsp;
    } else {

    }
#line 837
    type = (char *)"FC_BSG_HST_VENDOR_LOOPBACK";
#line 838
    ql_dbg(8388608U, vha, 28712, "BSG request type: %s.\n", type);
#line 841
    command_sent = 0U;
#line 842
    rval = qla2x00_loopback_test(vha, & elreq, (uint16_t *)(& response));
#line 844
    if ((unsigned int )response[0] == 16389U && (unsigned int )response[1] == 23U) {
#line 846
      ql_log(1U, vha, 28713, "MBX command error, Aborting ISP.\n");
#line 848
      set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 849
      qla2xxx_wake_dpc(vha);
#line 850
      qla2x00_wait_for_chip_reset(vha);
#line 852
      if ((ha->device_type & 8192U) != 0U) {
#line 853
        tmp___5 = qla81xx_restart_mpi_firmware(vha);
#line 853
        if (tmp___5 != 0) {
#line 855
          ql_log(1U, vha, 28714, "MPI reset failed.\n");
        } else {

        }
      } else {

      }
#line 860
      rval = -5;
#line 861
      goto done_free_dma_rsp;
    } else {

    }
#line 864
    if ((unsigned int )new_config[0] != 0U) {
#line 870
      ret = qla81xx_reset_loopback_mode(vha, (uint16_t *)(& new_config), 0, 1);
#line 872
      if (ret != 0) {
#line 878
        (*((ha->isp_ops)->fw_dump))(vha, 0);
#line 879
        set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
      } else {

      }
    } else {

    }
  } else {
#line 886
    type = (char *)"FC_BSG_HST_VENDOR_LOOPBACK";
#line 887
    ql_dbg(8388608U, vha, 28715, "BSG request type: %s.\n", type);
#line 889
    command_sent = 0U;
#line 890
    rval = qla2x00_loopback_test(vha, & elreq, (uint16_t *)(& response));
  }
#line 894
  if (rval != 0) {
#line 895
    ql_log(1U, vha, 28716, "Vendor request %s failed.\n", type);
#line 898
    rval = 0;
#line 899
    (bsg_job->reply)->result = 458752U;
#line 900
    (bsg_job->reply)->reply_payload_rcv_len = 0U;
  } else {
#line 902
    ql_dbg(8388608U, vha, 28717, "Vendor request %s completed.\n", type);
#line 904
    (bsg_job->reply)->result = 0U;
#line 905
    sg_copy_from_buffer(bsg_job->reply_payload.sg_list, (unsigned int )bsg_job->reply_payload.sg_cnt,
                        (void const   *)rsp_data, (size_t )rsp_data_len);
  }
#line 910
  bsg_job->reply_len = 81U;
#line 912
  fw_sts_ptr = (uint8_t *)(bsg_job->req)->sense + 16UL;
#line 914
  memcpy((void *)fw_sts_ptr, (void const   *)(& response), 64UL);
#line 915
  fw_sts_ptr = fw_sts_ptr + 64UL;
#line 916
  *fw_sts_ptr = command_sent;
  done_free_dma_rsp: 
#line 919
  dma_free_attrs(& (ha->pdev)->dev, (size_t )rsp_data_len, (void *)rsp_data, rsp_data_dma,
                 (struct dma_attrs *)0);
  done_free_dma_req: 
#line 922
  dma_free_attrs(& (ha->pdev)->dev, (size_t )req_data_len, (void *)req_data, req_data_dma,
                 (struct dma_attrs *)0);
  done_unmap_sg: 
#line 925
  dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,
                         2, (struct dma_attrs *)0);
  done_unmap_req_sg: 
#line 929
  dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->request_payload.sg_list, bsg_job->request_payload.sg_cnt,
                         1, (struct dma_attrs *)0);
#line 932
  if (rval == 0) {
#line 933
    (*(bsg_job->job_done))(bsg_job);
  } else {

  }
#line 934
  return (rval);
}
}
#line 938 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
static int qla84xx_reset(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int rval ;
  uint32_t flag ;

  {
#line 940
  host = bsg_job->shost;
#line 941
  tmp = shost_priv(host);
#line 941
  vha = (scsi_qla_host_t *)tmp;
#line 942
  ha = vha->hw;
#line 943
  rval = 0;
#line 946
  if ((ha->device_type & 4096U) == 0U) {
#line 947
    ql_dbg(8388608U, vha, 28719, "Not 84xx, exiting.\n");
#line 948
    return (-22);
  } else {

  }
#line 951
  flag = (bsg_job->request)->rqst_data.h_vendor.vendor_cmd[1];
#line 953
  rval = qla84xx_reset_chip(vha, flag == 4U);
#line 955
  if (rval != 0) {
#line 956
    ql_log(1U, vha, 28720, "Vendor request 84xx reset failed.\n");
#line 958
    rval = 458752;
  } else {
#line 961
    ql_dbg(8388608U, vha, 28721, "Vendor request 84xx reset completed.\n");
#line 963
    (bsg_job->reply)->result = 0U;
#line 964
    (*(bsg_job->job_done))(bsg_job);
  }
#line 967
  return (rval);
}
}
#line 971 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
static int qla84xx_updatefw(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  struct verify_chip_entry_84xx *mn ;
  dma_addr_t mn_dma ;
  dma_addr_t fw_dma ;
  void *fw_buf ;
  int rval ;
  uint32_t sg_cnt ;
  uint32_t data_len ;
  uint16_t options ;
  uint32_t flag ;
  uint32_t fw_ver ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 973
  host = bsg_job->shost;
#line 974
  tmp = shost_priv(host);
#line 974
  vha = (scsi_qla_host_t *)tmp;
#line 975
  ha = vha->hw;
#line 976
  mn = (struct verify_chip_entry_84xx *)0;
#line 978
  fw_buf = (void *)0;
#line 979
  rval = 0;
#line 986
  if ((ha->device_type & 4096U) == 0U) {
#line 987
    ql_dbg(8388608U, vha, 28722, "Not 84xx, exiting.\n");
#line 989
    return (-22);
  } else {

  }
#line 992
  tmp___0 = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->request_payload.sg_list,
                             bsg_job->request_payload.sg_cnt, 1, (struct dma_attrs *)0);
#line 992
  sg_cnt = (uint32_t )tmp___0;
#line 994
  if (sg_cnt == 0U) {
#line 995
    ql_log(1U, vha, 28723, "dma_map_sg returned %d for request.\n", sg_cnt);
#line 997
    return (-12);
  } else {

  }
#line 1000
  if ((uint32_t )bsg_job->request_payload.sg_cnt != sg_cnt) {
#line 1001
    ql_log(1U, vha, 28724, "DMA mapping resulted in different sg counts, request_sg_cnt: %x dma_request_sg_cnt: %x.\n",
           bsg_job->request_payload.sg_cnt, sg_cnt);
#line 1005
    rval = -11;
#line 1006
    goto done_unmap_sg;
  } else {

  }
#line 1009
  data_len = bsg_job->request_payload.payload_len;
#line 1010
  fw_buf = dma_alloc_attrs(& (ha->pdev)->dev, (size_t )data_len, & fw_dma, 208U, (struct dma_attrs *)0);
#line 1012
  if ((unsigned long )fw_buf == (unsigned long )((void *)0)) {
#line 1013
    ql_log(1U, vha, 28725, "DMA alloc failed for fw_buf.\n");
#line 1015
    rval = -12;
#line 1016
    goto done_unmap_sg;
  } else {

  }
#line 1019
  sg_copy_to_buffer(bsg_job->request_payload.sg_list, (unsigned int )bsg_job->request_payload.sg_cnt,
                    fw_buf, (size_t )data_len);
#line 1022
  tmp___1 = dma_pool_alloc(ha->s_dma_pool, 208U, & mn_dma);
#line 1022
  mn = (struct verify_chip_entry_84xx *)tmp___1;
#line 1023
  if ((unsigned long )mn == (unsigned long )((struct verify_chip_entry_84xx *)0)) {
#line 1024
    ql_log(1U, vha, 28726, "DMA alloc failed for fw buffer.\n");
#line 1026
    rval = -12;
#line 1027
    goto done_free_fw_buf;
  } else {

  }
#line 1030
  flag = (bsg_job->request)->rqst_data.h_vendor.vendor_cmd[1];
#line 1031
  fw_ver = *((uint32_t *)fw_buf + 2UL);
#line 1033
  memset((void *)mn, 0, 64UL);
#line 1034
  mn->entry_type = 27U;
#line 1035
  mn->entry_count = 1U;
#line 1037
  options = 16386U;
#line 1038
  if (flag == 6U) {
#line 1039
    options = (uint16_t )((unsigned int )options | 8U);
  } else {

  }
#line 1041
  mn->options = options;
#line 1042
  mn->fw_ver = fw_ver;
#line 1043
  mn->fw_size = data_len;
#line 1044
  mn->fw_seq_size = data_len;
#line 1045
  mn->dseg_address[0] = (unsigned int )fw_dma;
#line 1046
  mn->dseg_address[1] = (unsigned int )(fw_dma >> 32ULL);
#line 1047
  mn->dseg_length = data_len;
#line 1048
  mn->data_seg_cnt = 1U;
#line 1050
  rval = qla2x00_issue_iocb_timeout(vha, (void *)mn, mn_dma, 0UL, 120U);
#line 1052
  if (rval != 0) {
#line 1053
    ql_log(1U, vha, 28727, "Vendor request 84xx updatefw failed.\n");
#line 1056
    rval = 458752;
  } else {
#line 1058
    ql_dbg(8388608U, vha, 28728, "Vendor request 84xx updatefw completed.\n");
#line 1061
    bsg_job->reply_len = 16U;
#line 1062
    (bsg_job->reply)->result = 0U;
  }
#line 1065
  dma_pool_free(ha->s_dma_pool, (void *)mn, mn_dma);
  done_free_fw_buf: 
#line 1068
  dma_free_attrs(& (ha->pdev)->dev, (size_t )data_len, fw_buf, fw_dma, (struct dma_attrs *)0);
  done_unmap_sg: 
#line 1071
  dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->request_payload.sg_list, bsg_job->request_payload.sg_cnt,
                         1, (struct dma_attrs *)0);
#line 1074
  if (rval == 0) {
#line 1075
    (*(bsg_job->job_done))(bsg_job);
  } else {

  }
#line 1076
  return (rval);
}
}
#line 1080 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
static int qla84xx_mgmt_cmd(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  struct access_chip_84xx *mn ;
  dma_addr_t mn_dma ;
  dma_addr_t mgmt_dma ;
  void *mgmt_b ;
  int rval ;
  struct qla_bsg_a84_mgmt *ql84_mgmt ;
  uint32_t sg_cnt ;
  uint32_t data_len ;
  uint32_t dma_direction ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1082
  host = bsg_job->shost;
#line 1083
  tmp = shost_priv(host);
#line 1083
  vha = (scsi_qla_host_t *)tmp;
#line 1084
  ha = vha->hw;
#line 1085
  mn = (struct access_chip_84xx *)0;
#line 1087
  mgmt_b = (void *)0;
#line 1088
  rval = 0;
#line 1091
  data_len = 0U;
#line 1092
  dma_direction = 3U;
#line 1094
  if ((ha->device_type & 4096U) == 0U) {
#line 1095
    ql_log(1U, vha, 28730, "Not 84xx, exiting.\n");
#line 1097
    return (-22);
  } else {

  }
#line 1100
  tmp___0 = dma_pool_alloc(ha->s_dma_pool, 208U, & mn_dma);
#line 1100
  mn = (struct access_chip_84xx *)tmp___0;
#line 1101
  if ((unsigned long )mn == (unsigned long )((struct access_chip_84xx *)0)) {
#line 1102
    ql_log(1U, vha, 28732, "DMA alloc failed for fw buffer.\n");
#line 1104
    return (-12);
  } else {

  }
#line 1107
  memset((void *)mn, 0, 64UL);
#line 1108
  mn->entry_type = 43U;
#line 1109
  mn->entry_count = 1U;
#line 1110
  ql84_mgmt = (struct qla_bsg_a84_mgmt *)bsg_job->request + 20U;
#line 1111
  switch ((int )ql84_mgmt->mgmt.cmd) {
  case 0: ;
  case 3: 
#line 1114
  tmp___1 = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,
                             2, (struct dma_attrs *)0);
#line 1114
  sg_cnt = (uint32_t )tmp___1;
#line 1117
  if (sg_cnt == 0U) {
#line 1118
    ql_log(1U, vha, 28733, "dma_map_sg returned %d for reply.\n", sg_cnt);
#line 1120
    rval = -12;
#line 1121
    goto exit_mgmt;
  } else {

  }
#line 1124
  dma_direction = 2U;
#line 1126
  if ((uint32_t )bsg_job->reply_payload.sg_cnt != sg_cnt) {
#line 1127
    ql_log(1U, vha, 28734, "DMA mapping resulted in different sg counts, reply_sg_cnt: %x dma_reply_sg_cnt: %x.\n",
           bsg_job->reply_payload.sg_cnt, sg_cnt);
#line 1131
    rval = -11;
#line 1132
    goto done_unmap_sg;
  } else {

  }
#line 1135
  data_len = bsg_job->reply_payload.payload_len;
#line 1137
  mgmt_b = dma_alloc_attrs(& (ha->pdev)->dev, (size_t )data_len, & mgmt_dma, 208U,
                           (struct dma_attrs *)0);
#line 1139
  if ((unsigned long )mgmt_b == (unsigned long )((void *)0)) {
#line 1140
    ql_log(1U, vha, 28735, "DMA alloc failed for mgmt_b.\n");
#line 1142
    rval = -12;
#line 1143
    goto done_unmap_sg;
  } else {

  }
#line 1146
  if ((unsigned int )ql84_mgmt->mgmt.cmd == 0U) {
#line 1147
    mn->options = 0U;
#line 1148
    mn->parameter1 = ql84_mgmt->mgmt.mgmtp.u.mem.start_addr;
  } else
#line 1152
  if ((unsigned int )ql84_mgmt->mgmt.cmd == 3U) {
#line 1153
    mn->options = 3U;
#line 1154
    mn->parameter1 = ql84_mgmt->mgmt.mgmtp.u.info.type;
#line 1157
    mn->parameter2 = ql84_mgmt->mgmt.mgmtp.u.info.context;
  } else {

  }
#line 1161
  goto ldv_66150;
  case 1: 
#line 1164
  tmp___2 = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->request_payload.sg_list,
                             bsg_job->request_payload.sg_cnt, 1, (struct dma_attrs *)0);
#line 1164
  sg_cnt = (uint32_t )tmp___2;
#line 1168
  if (sg_cnt == 0U) {
#line 1169
    ql_log(1U, vha, 28736, "dma_map_sg returned %d.\n", sg_cnt);
#line 1171
    rval = -12;
#line 1172
    goto exit_mgmt;
  } else {

  }
#line 1175
  dma_direction = 1U;
#line 1177
  if ((uint32_t )bsg_job->request_payload.sg_cnt != sg_cnt) {
#line 1178
    ql_log(1U, vha, 28737, "DMA mapping resulted in different sg counts, request_sg_cnt: %x dma_request_sg_cnt: %x.\n",
           bsg_job->request_payload.sg_cnt, sg_cnt);
#line 1182
    rval = -11;
#line 1183
    goto done_unmap_sg;
  } else {

  }
#line 1186
  data_len = bsg_job->request_payload.payload_len;
#line 1187
  mgmt_b = dma_alloc_attrs(& (ha->pdev)->dev, (size_t )data_len, & mgmt_dma, 208U,
                           (struct dma_attrs *)0);
#line 1189
  if ((unsigned long )mgmt_b == (unsigned long )((void *)0)) {
#line 1190
    ql_log(1U, vha, 28738, "DMA alloc failed for mgmt_b.\n");
#line 1192
    rval = -12;
#line 1193
    goto done_unmap_sg;
  } else {

  }
#line 1196
  sg_copy_to_buffer(bsg_job->request_payload.sg_list, (unsigned int )bsg_job->request_payload.sg_cnt,
                    mgmt_b, (size_t )data_len);
#line 1199
  mn->options = 1U;
#line 1200
  mn->parameter1 = ql84_mgmt->mgmt.mgmtp.u.mem.start_addr;
#line 1202
  goto ldv_66150;
  case 2: 
#line 1205
  mn->options = 2U;
#line 1206
  mn->parameter1 = ql84_mgmt->mgmt.mgmtp.u.config.id;
#line 1209
  mn->parameter2 = ql84_mgmt->mgmt.mgmtp.u.config.param0;
#line 1212
  mn->parameter3 = ql84_mgmt->mgmt.mgmtp.u.config.param1;
#line 1214
  goto ldv_66150;
  default: 
#line 1217
  rval = -5;
#line 1218
  goto exit_mgmt;
  }
  ldv_66150: ;
#line 1221
  if ((unsigned int )ql84_mgmt->mgmt.cmd != 2U) {
#line 1222
    mn->total_byte_cnt = ql84_mgmt->mgmt.len;
#line 1223
    mn->dseg_count = 1U;
#line 1224
    mn->dseg_address[0] = (unsigned int )mgmt_dma;
#line 1225
    mn->dseg_address[1] = (unsigned int )(mgmt_dma >> 32ULL);
#line 1226
    mn->dseg_length = ql84_mgmt->mgmt.len;
  } else {

  }
#line 1229
  rval = qla2x00_issue_iocb(vha, (void *)mn, mn_dma, 0UL);
#line 1231
  if (rval != 0) {
#line 1232
    ql_log(1U, vha, 28739, "Vendor request 84xx mgmt failed.\n");
#line 1235
    rval = 458752;
  } else {
#line 1238
    ql_dbg(8388608U, vha, 28740, "Vendor request 84xx mgmt completed.\n");
#line 1241
    bsg_job->reply_len = 16U;
#line 1242
    (bsg_job->reply)->result = 0U;
#line 1244
    if ((unsigned int )ql84_mgmt->mgmt.cmd == 0U || (unsigned int )ql84_mgmt->mgmt.cmd == 3U) {
#line 1246
      (bsg_job->reply)->reply_payload_rcv_len = bsg_job->reply_payload.payload_len;
#line 1249
      sg_copy_from_buffer(bsg_job->reply_payload.sg_list, (unsigned int )bsg_job->reply_payload.sg_cnt,
                          (void const   *)mgmt_b, (size_t )data_len);
    } else {

    }
  }
  done_unmap_sg: ;
#line 1256
  if ((unsigned long )mgmt_b != (unsigned long )((void *)0)) {
#line 1257
    dma_free_attrs(& (ha->pdev)->dev, (size_t )data_len, mgmt_b, mgmt_dma, (struct dma_attrs *)0);
  } else {

  }
#line 1259
  if (dma_direction == 1U) {
#line 1260
    dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->request_payload.sg_list, bsg_job->request_payload.sg_cnt,
                           1, (struct dma_attrs *)0);
  } else
#line 1262
  if (dma_direction == 2U) {
#line 1263
    dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,
                           2, (struct dma_attrs *)0);
  } else {

  }
  exit_mgmt: 
#line 1267
  dma_pool_free(ha->s_dma_pool, (void *)mn, mn_dma);
#line 1269
  if (rval == 0) {
#line 1270
    (*(bsg_job->job_done))(bsg_job);
  } else {

  }
#line 1271
  return (rval);
}
}
#line 1275 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
static int qla24xx_iidma(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int rval ;
  struct qla_port_param *port_param ;
  fc_port_t *fcport ;
  int found ;
  uint16_t mb[32U] ;
  uint8_t *rsp_ptr ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  struct list_head  const  *__mptr___0 ;
  int tmp___1 ;

  {
#line 1277
  host = bsg_job->shost;
#line 1278
  tmp = shost_priv(host);
#line 1278
  vha = (scsi_qla_host_t *)tmp;
#line 1279
  rval = 0;
#line 1280
  port_param = (struct qla_port_param *)0;
#line 1281
  fcport = (fc_port_t *)0;
#line 1282
  found = 0;
#line 1284
  rsp_ptr = (uint8_t *)0U;
#line 1286
  if (((vha->hw)->device_type & 67108864U) == 0U) {
#line 1287
    ql_log(2U, vha, 28742, "iiDMA not supported.\n");
#line 1288
    return (-22);
  } else {

  }
#line 1291
  port_param = (struct qla_port_param *)bsg_job->request + 20U;
#line 1292
  if ((unsigned int )port_param->fc_scsi_addr.dest_type != 2U) {
#line 1293
    ql_log(1U, vha, 28744, "Invalid destination type.\n");
#line 1295
    return (-22);
  } else {

  }
#line 1298
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 1298
  fcport = (fc_port_t *)__mptr;
#line 1298
  goto ldv_66172;
  ldv_66171: ;
#line 1299
  if ((unsigned int )fcport->port_type != 5U) {
#line 1300
    goto ldv_66169;
  } else {

  }
#line 1302
  tmp___0 = memcmp((void const   *)(& port_param->fc_scsi_addr.dest_addr.wwpn), (void const   *)(& fcport->port_name),
                   8UL);
#line 1302
  if (tmp___0 != 0) {
#line 1304
    goto ldv_66169;
  } else {

  }
#line 1306
  found = 1;
#line 1307
  goto ldv_66170;
  ldv_66169: 
#line 1298
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 1298
  fcport = (fc_port_t *)__mptr___0;
  ldv_66172: ;
#line 1298
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 1300
    goto ldv_66171;
  } else {

  }
  ldv_66170: ;
#line 1310
  if (found == 0) {
#line 1311
    ql_log(1U, vha, 28745, "Failed to find port.\n");
#line 1313
    return (-22);
  } else {

  }
#line 1316
  tmp___1 = atomic_read((atomic_t const   *)(& fcport->state));
#line 1316
  if (tmp___1 != 4) {
#line 1317
    ql_log(1U, vha, 28746, "Port is not online.\n");
#line 1319
    return (-22);
  } else {

  }
#line 1322
  if ((fcport->flags & 2U) != 0U) {
#line 1323
    ql_log(1U, vha, 28747, "Remote port not logged in flags = 0x%x.\n", fcport->flags);
#line 1325
    return (-22);
  } else {

  }
#line 1328
  if ((unsigned int )port_param->mode != 0U) {
#line 1329
    rval = qla2x00_set_idma_speed(vha, (int )fcport->loop_id, (int )port_param->speed,
                                  (uint16_t *)(& mb));
  } else {
#line 1332
    rval = qla2x00_get_idma_speed(vha, (int )fcport->loop_id, & port_param->speed,
                                  (uint16_t *)(& mb));
  }
#line 1335
  if (rval != 0) {
#line 1336
    ql_log(1U, vha, 28748, "iIDMA cmd failed for %8phN -- %04x %x %04x %04x.\n", (uint8_t *)(& fcport->port_name),
           rval, (int )fcport->fp_speed, (int )mb[0], (int )mb[1]);
#line 1340
    rval = 458752;
  } else {
#line 1342
    if ((unsigned int )port_param->mode == 0U) {
#line 1343
      bsg_job->reply_len = 36U;
#line 1346
      rsp_ptr = (uint8_t *)bsg_job->reply + 16UL;
#line 1349
      memcpy((void *)rsp_ptr, (void const   *)port_param, 20UL);
    } else {

    }
#line 1353
    (bsg_job->reply)->result = 0U;
#line 1354
    (*(bsg_job->job_done))(bsg_job);
  }
#line 1357
  return (rval);
}
}
#line 1361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
static int qla2x00_optrom_setup(struct fc_bsg_job *bsg_job , scsi_qla_host_t *vha ,
                                uint8_t is_update ) 
{ 
  uint32_t start ;
  int valid ;
  struct qla_hw_data *ha ;
  int tmp ;
  long tmp___0 ;
  void *tmp___1 ;

  {
#line 1364
  start = 0U;
#line 1365
  valid = 0;
#line 1366
  ha = vha->hw;
#line 1368
  tmp = pci_channel_offline(ha->pdev);
#line 1368
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 1368
  if (tmp___0 != 0L) {
#line 1369
    return (-22);
  } else {

  }
#line 1371
  start = (bsg_job->request)->rqst_data.h_vendor.vendor_cmd[1];
#line 1372
  if (ha->optrom_size < start) {
#line 1373
    ql_log(1U, vha, 28757, "start %d > optrom_size %d.\n", start, ha->optrom_size);
#line 1375
    return (-22);
  } else {

  }
#line 1378
  if (ha->optrom_state != 0) {
#line 1379
    ql_log(2U, vha, 28758, "optrom_state %d.\n", ha->optrom_state);
#line 1381
    return (-16);
  } else {

  }
#line 1384
  ha->optrom_region_start = start;
#line 1385
  ql_dbg(8388608U, vha, 28759, "is_update=%d.\n", (int )is_update);
#line 1386
  if ((unsigned int )is_update != 0U) {
#line 1387
    if (ha->optrom_size == 131072U && start == 0U) {
#line 1388
      valid = 1;
    } else
#line 1389
    if (ha->flt_region_boot * 4U == start || ha->flt_region_fw * 4U == start) {
#line 1391
      valid = 1;
    } else
#line 1392
    if ((((((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || ((ha->device_type & 512U) != 0U || (ha->device_type & 1024U) != 0U)) || (ha->device_type & 4096U) != 0U) || (ha->device_type & 2048U) != 0U) || ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U)) || (ha->device_type & 32768U) != 0U) || ((ha->device_type & 524288U) != 0U || (ha->device_type & 1048576U) != 0U)) {
#line 1394
      valid = 1;
    } else {

    }
#line 1395
    if (valid == 0) {
#line 1396
      ql_log(1U, vha, 28760, "Invalid start region 0x%x/0x%x.\n", start, bsg_job->request_payload.payload_len);
#line 1399
      return (-22);
    } else {

    }
#line 1402
    ha->optrom_region_size = bsg_job->request_payload.payload_len + start > ha->optrom_size ? ha->optrom_size - start : bsg_job->request_payload.payload_len;
#line 1406
    ha->optrom_state = 2;
  } else {
#line 1408
    ha->optrom_region_size = bsg_job->reply_payload.payload_len + start > ha->optrom_size ? ha->optrom_size - start : bsg_job->reply_payload.payload_len;
#line 1412
    ha->optrom_state = 1;
  }
#line 1415
  tmp___1 = vmalloc((unsigned long )ha->optrom_region_size);
#line 1415
  ha->optrom_buffer = (char *)tmp___1;
#line 1416
  if ((unsigned long )ha->optrom_buffer == (unsigned long )((char *)0)) {
#line 1417
    ql_log(1U, vha, 28761, "Read: Unable to allocate memory for optrom retrieval (%x)\n",
           ha->optrom_region_size);
#line 1421
    ha->optrom_state = 0;
#line 1422
    return (-12);
  } else {

  }
#line 1425
  memset((void *)ha->optrom_buffer, 0, (size_t )ha->optrom_region_size);
#line 1426
  return (0);
}
}
#line 1430 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
static int qla2x00_read_optrom(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int rval ;

  {
#line 1432
  host = bsg_job->shost;
#line 1433
  tmp = shost_priv(host);
#line 1433
  vha = (scsi_qla_host_t *)tmp;
#line 1434
  ha = vha->hw;
#line 1435
  rval = 0;
#line 1437
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1438
    return (-16);
  } else {

  }
#line 1440
  mutex_lock_nested(& ha->optrom_mutex, 0U);
#line 1441
  rval = qla2x00_optrom_setup(bsg_job, vha, 0);
#line 1442
  if (rval != 0) {
#line 1443
    mutex_unlock(& ha->optrom_mutex);
#line 1444
    return (rval);
  } else {

  }
#line 1447
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)ha->optrom_buffer, ha->optrom_region_start,
                                  ha->optrom_region_size);
#line 1450
  sg_copy_from_buffer(bsg_job->reply_payload.sg_list, (unsigned int )bsg_job->reply_payload.sg_cnt,
                      (void const   *)ha->optrom_buffer, (size_t )ha->optrom_region_size);
#line 1454
  (bsg_job->reply)->reply_payload_rcv_len = ha->optrom_region_size;
#line 1455
  (bsg_job->reply)->result = 0U;
#line 1456
  vfree((void const   *)ha->optrom_buffer);
#line 1457
  ha->optrom_buffer = (char *)0;
#line 1458
  ha->optrom_state = 0;
#line 1459
  mutex_unlock(& ha->optrom_mutex);
#line 1460
  (*(bsg_job->job_done))(bsg_job);
#line 1461
  return (rval);
}
}
#line 1465 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
static int qla2x00_update_optrom(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int rval ;

  {
#line 1467
  host = bsg_job->shost;
#line 1468
  tmp = shost_priv(host);
#line 1468
  vha = (scsi_qla_host_t *)tmp;
#line 1469
  ha = vha->hw;
#line 1470
  rval = 0;
#line 1472
  mutex_lock_nested(& ha->optrom_mutex, 0U);
#line 1473
  rval = qla2x00_optrom_setup(bsg_job, vha, 1);
#line 1474
  if (rval != 0) {
#line 1475
    mutex_unlock(& ha->optrom_mutex);
#line 1476
    return (rval);
  } else {

  }
#line 1480
  ha->flags.isp82xx_no_md_cap = 1U;
#line 1482
  sg_copy_to_buffer(bsg_job->request_payload.sg_list, (unsigned int )bsg_job->request_payload.sg_cnt,
                    (void *)ha->optrom_buffer, (size_t )ha->optrom_region_size);
#line 1486
  (*((ha->isp_ops)->write_optrom))(vha, (uint8_t *)ha->optrom_buffer, ha->optrom_region_start,
                                   ha->optrom_region_size);
#line 1489
  (bsg_job->reply)->result = 0U;
#line 1490
  vfree((void const   *)ha->optrom_buffer);
#line 1491
  ha->optrom_buffer = (char *)0;
#line 1492
  ha->optrom_state = 0;
#line 1493
  mutex_unlock(& ha->optrom_mutex);
#line 1494
  (*(bsg_job->job_done))(bsg_job);
#line 1495
  return (rval);
}
}
#line 1499 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
static int qla2x00_update_fru_versions(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int rval ;
  uint8_t bsg[256U] ;
  struct qla_image_version_list *list ;
  struct qla_image_version *image ;
  uint32_t count ;
  dma_addr_t sfp_dma ;
  void *sfp ;
  void *tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 1501
  host = bsg_job->shost;
#line 1502
  tmp = shost_priv(host);
#line 1502
  vha = (scsi_qla_host_t *)tmp;
#line 1503
  ha = vha->hw;
#line 1504
  rval = 0;
#line 1506
  list = (struct qla_image_version_list *)(& bsg);
#line 1510
  tmp___0 = dma_pool_alloc(ha->s_dma_pool, 208U, & sfp_dma);
#line 1510
  sfp = tmp___0;
#line 1511
  if ((unsigned long )sfp == (unsigned long )((void *)0)) {
#line 1512
    (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 17U;
#line 1514
    goto done;
  } else {

  }
#line 1517
  sg_copy_to_buffer(bsg_job->request_payload.sg_list, (unsigned int )bsg_job->request_payload.sg_cnt,
                    (void *)list, 256UL);
#line 1520
  image = (struct qla_image_version *)(& list->version);
#line 1521
  count = list->count;
#line 1522
  goto ldv_66211;
  ldv_66210: 
#line 1523
  memcpy(sfp, (void const   *)(& image->field_info), 36UL);
#line 1524
  rval = qla2x00_write_sfp(vha, sfp_dma, (uint8_t *)sfp, (int )image->field_address.device,
                           (int )image->field_address.offset, 36, (int )image->field_address.option);
#line 1527
  if (rval != 0) {
#line 1528
    (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 11U;
#line 1530
    goto dealloc;
  } else {

  }
#line 1532
  image = image + 1;
  ldv_66211: 
#line 1522
  tmp___1 = count;
#line 1522
  count = count - 1U;
#line 1522
  if (tmp___1 != 0U) {
#line 1524
    goto ldv_66210;
  } else {

  }
#line 1535
  (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 0U;
  dealloc: 
#line 1538
  dma_pool_free(ha->s_dma_pool, sfp, sfp_dma);
  done: 
#line 1541
  bsg_job->reply_len = 16U;
#line 1542
  (bsg_job->reply)->result = 0U;
#line 1543
  (*(bsg_job->job_done))(bsg_job);
#line 1545
  return (0);
}
}
#line 1549 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
static int qla2x00_read_fru_status(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int rval ;
  uint8_t bsg[256U] ;
  struct qla_status_reg *sr ;
  dma_addr_t sfp_dma ;
  uint8_t *sfp ;
  void *tmp___0 ;

  {
#line 1551
  host = bsg_job->shost;
#line 1552
  tmp = shost_priv(host);
#line 1552
  vha = (scsi_qla_host_t *)tmp;
#line 1553
  ha = vha->hw;
#line 1554
  rval = 0;
#line 1556
  sr = (struct qla_status_reg *)(& bsg);
#line 1558
  tmp___0 = dma_pool_alloc(ha->s_dma_pool, 208U, & sfp_dma);
#line 1558
  sfp = (uint8_t *)tmp___0;
#line 1559
  if ((unsigned long )sfp == (unsigned long )((uint8_t *)0U)) {
#line 1560
    (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 17U;
#line 1562
    goto done;
  } else {

  }
#line 1565
  sg_copy_to_buffer(bsg_job->request_payload.sg_list, (unsigned int )bsg_job->request_payload.sg_cnt,
                    (void *)sr, 14UL);
#line 1568
  rval = qla2x00_read_sfp(vha, sfp_dma, sfp, (int )sr->field_address.device, (int )sr->field_address.offset,
                          1, (int )sr->field_address.option);
#line 1571
  sr->status_reg = *sfp;
#line 1573
  if (rval != 0) {
#line 1574
    (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 11U;
#line 1576
    goto dealloc;
  } else {

  }
#line 1579
  sg_copy_from_buffer(bsg_job->reply_payload.sg_list, (unsigned int )bsg_job->reply_payload.sg_cnt,
                      (void const   *)sr, 14UL);
#line 1582
  (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 0U;
  dealloc: 
#line 1585
  dma_pool_free(ha->s_dma_pool, (void *)sfp, sfp_dma);
  done: 
#line 1588
  bsg_job->reply_len = 16U;
#line 1589
  (bsg_job->reply)->reply_payload_rcv_len = 14U;
#line 1590
  (bsg_job->reply)->result = 0U;
#line 1591
  (*(bsg_job->job_done))(bsg_job);
#line 1593
  return (0);
}
}
#line 1597 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
static int qla2x00_write_fru_status(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int rval ;
  uint8_t bsg[256U] ;
  struct qla_status_reg *sr ;
  dma_addr_t sfp_dma ;
  uint8_t *sfp ;
  void *tmp___0 ;

  {
#line 1599
  host = bsg_job->shost;
#line 1600
  tmp = shost_priv(host);
#line 1600
  vha = (scsi_qla_host_t *)tmp;
#line 1601
  ha = vha->hw;
#line 1602
  rval = 0;
#line 1604
  sr = (struct qla_status_reg *)(& bsg);
#line 1606
  tmp___0 = dma_pool_alloc(ha->s_dma_pool, 208U, & sfp_dma);
#line 1606
  sfp = (uint8_t *)tmp___0;
#line 1607
  if ((unsigned long )sfp == (unsigned long )((uint8_t *)0U)) {
#line 1608
    (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 17U;
#line 1610
    goto done;
  } else {

  }
#line 1613
  sg_copy_to_buffer(bsg_job->request_payload.sg_list, (unsigned int )bsg_job->request_payload.sg_cnt,
                    (void *)sr, 14UL);
#line 1616
  *sfp = sr->status_reg;
#line 1617
  rval = qla2x00_write_sfp(vha, sfp_dma, sfp, (int )sr->field_address.device, (int )sr->field_address.offset,
                           1, (int )sr->field_address.option);
#line 1621
  if (rval != 0) {
#line 1622
    (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 11U;
#line 1624
    goto dealloc;
  } else {

  }
#line 1627
  (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 0U;
  dealloc: 
#line 1630
  dma_pool_free(ha->s_dma_pool, (void *)sfp, sfp_dma);
  done: 
#line 1633
  bsg_job->reply_len = 16U;
#line 1634
  (bsg_job->reply)->result = 0U;
#line 1635
  (*(bsg_job->job_done))(bsg_job);
#line 1637
  return (0);
}
}
#line 1641 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
static int qla2x00_write_i2c(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int rval ;
  uint8_t bsg[256U] ;
  struct qla_i2c_access *i2c ;
  dma_addr_t sfp_dma ;
  uint8_t *sfp ;
  void *tmp___0 ;

  {
#line 1643
  host = bsg_job->shost;
#line 1644
  tmp = shost_priv(host);
#line 1644
  vha = (scsi_qla_host_t *)tmp;
#line 1645
  ha = vha->hw;
#line 1646
  rval = 0;
#line 1648
  i2c = (struct qla_i2c_access *)(& bsg);
#line 1650
  tmp___0 = dma_pool_alloc(ha->s_dma_pool, 208U, & sfp_dma);
#line 1650
  sfp = (uint8_t *)tmp___0;
#line 1651
  if ((unsigned long )sfp == (unsigned long )((uint8_t *)0U)) {
#line 1652
    (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 17U;
#line 1654
    goto done;
  } else {

  }
#line 1657
  sg_copy_to_buffer(bsg_job->request_payload.sg_list, (unsigned int )bsg_job->request_payload.sg_cnt,
                    (void *)i2c, 72UL);
#line 1660
  memcpy((void *)sfp, (void const   *)(& i2c->buffer), (size_t )i2c->length);
#line 1661
  rval = qla2x00_write_sfp(vha, sfp_dma, sfp, (int )i2c->device, (int )i2c->offset,
                           (int )i2c->length, (int )i2c->option);
#line 1664
  if (rval != 0) {
#line 1665
    (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 11U;
#line 1667
    goto dealloc;
  } else {

  }
#line 1670
  (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 0U;
  dealloc: 
#line 1673
  dma_pool_free(ha->s_dma_pool, (void *)sfp, sfp_dma);
  done: 
#line 1676
  bsg_job->reply_len = 16U;
#line 1677
  (bsg_job->reply)->result = 0U;
#line 1678
  (*(bsg_job->job_done))(bsg_job);
#line 1680
  return (0);
}
}
#line 1684 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
static int qla2x00_read_i2c(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int rval ;
  uint8_t bsg[256U] ;
  struct qla_i2c_access *i2c ;
  dma_addr_t sfp_dma ;
  uint8_t *sfp ;
  void *tmp___0 ;

  {
#line 1686
  host = bsg_job->shost;
#line 1687
  tmp = shost_priv(host);
#line 1687
  vha = (scsi_qla_host_t *)tmp;
#line 1688
  ha = vha->hw;
#line 1689
  rval = 0;
#line 1691
  i2c = (struct qla_i2c_access *)(& bsg);
#line 1693
  tmp___0 = dma_pool_alloc(ha->s_dma_pool, 208U, & sfp_dma);
#line 1693
  sfp = (uint8_t *)tmp___0;
#line 1694
  if ((unsigned long )sfp == (unsigned long )((uint8_t *)0U)) {
#line 1695
    (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 17U;
#line 1697
    goto done;
  } else {

  }
#line 1700
  sg_copy_to_buffer(bsg_job->request_payload.sg_list, (unsigned int )bsg_job->request_payload.sg_cnt,
                    (void *)i2c, 72UL);
#line 1703
  rval = qla2x00_read_sfp(vha, sfp_dma, sfp, (int )i2c->device, (int )i2c->offset,
                          (int )i2c->length, (int )i2c->option);
#line 1706
  if (rval != 0) {
#line 1707
    (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 11U;
#line 1709
    goto dealloc;
  } else {

  }
#line 1712
  memcpy((void *)(& i2c->buffer), (void const   *)sfp, (size_t )i2c->length);
#line 1713
  sg_copy_from_buffer(bsg_job->reply_payload.sg_list, (unsigned int )bsg_job->reply_payload.sg_cnt,
                      (void const   *)i2c, 72UL);
#line 1716
  (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 0U;
  dealloc: 
#line 1719
  dma_pool_free(ha->s_dma_pool, (void *)sfp, sfp_dma);
  done: 
#line 1722
  bsg_job->reply_len = 16U;
#line 1723
  (bsg_job->reply)->reply_payload_rcv_len = 72U;
#line 1724
  (bsg_job->reply)->result = 0U;
#line 1725
  (*(bsg_job->job_done))(bsg_job);
#line 1727
  return (0);
}
}
#line 1731 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
static int qla24xx_process_bidir_cmd(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  uint16_t thread_id ;
  uint32_t rval ;
  uint16_t req_sg_cnt ;
  uint16_t rsp_sg_cnt ;
  uint16_t nextlid ;
  uint32_t tot_dsds ;
  srb_t *sp ;
  uint32_t req_data_len ;
  uint32_t rsp_data_len ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1733
  host = bsg_job->shost;
#line 1734
  tmp = shost_priv(host);
#line 1734
  vha = (scsi_qla_host_t *)tmp;
#line 1735
  ha = vha->hw;
#line 1737
  rval = 0U;
#line 1738
  req_sg_cnt = 0U;
#line 1739
  rsp_sg_cnt = 0U;
#line 1740
  nextlid = 0U;
#line 1742
  sp = (srb_t *)0;
#line 1743
  req_data_len = 0U;
#line 1744
  rsp_data_len = 0U;
#line 1747
  if ((ha->device_type & 2048U) == 0U && (ha->device_type & 32768U) == 0U) {
#line 1748
    ql_log(1U, vha, 28832, "This adapter is not supported\n");
#line 1750
    rval = 27U;
#line 1751
    goto done;
  } else {

  }
#line 1754
  tmp___0 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1754
  if (tmp___0 != 0) {
#line 1757
    rval = 2U;
#line 1758
    goto done;
  } else {
#line 1754
    tmp___1 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1754
    if (tmp___1 != 0) {
#line 1757
      rval = 2U;
#line 1758
      goto done;
    } else {
#line 1754
      tmp___2 = constant_test_bit(10L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1754
      if (tmp___2 != 0) {
#line 1757
        rval = 2U;
#line 1758
        goto done;
      } else {

      }
    }
  }
#line 1762
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 1763
    ql_log(1U, vha, 28833, "Host is not online\n");
#line 1765
    rval = 22U;
#line 1766
    goto done;
  } else {

  }
#line 1770
  if ((vha->device_flags & 2U) != 0U) {
#line 1771
    ql_log(1U, vha, 28834, "Cable is unplugged...\n");
#line 1773
    rval = 28U;
#line 1774
    goto done;
  } else {

  }
#line 1778
  if ((unsigned int )ha->current_topology != 8U) {
#line 1779
    ql_log(1U, vha, 28835, "Host is not connected to the switch\n");
#line 1781
    rval = 28U;
#line 1782
    goto done;
  } else {

  }
#line 1786
  if ((unsigned int )ha->operating_mode != 1U) {
#line 1787
    ql_log(1U, vha, 28836, "Host is operating mode is not P2p\n");
#line 1789
    rval = 28U;
#line 1790
    goto done;
  } else {

  }
#line 1793
  thread_id = (uint16_t )(bsg_job->request)->rqst_data.h_vendor.vendor_cmd[1];
#line 1795
  mutex_lock_nested(& ha->selflogin_lock, 0U);
#line 1796
  if ((unsigned int )vha->self_login_loop_id == 0U) {
#line 1798
    vha->bidir_fcport.vha = vha;
#line 1799
    vha->bidir_fcport.d_id.b.al_pa = vha->d_id.b.al_pa;
#line 1800
    vha->bidir_fcport.d_id.b.area = vha->d_id.b.area;
#line 1801
    vha->bidir_fcport.d_id.b.domain = vha->d_id.b.domain;
#line 1802
    vha->bidir_fcport.loop_id = vha->loop_id;
#line 1804
    tmp___3 = qla2x00_fabric_login(vha, & vha->bidir_fcport, & nextlid);
#line 1804
    if (tmp___3 != 0) {
#line 1805
      ql_log(1U, vha, 28839, "Failed to login port %06X for bidirectional IOCB\n",
             (int )vha->bidir_fcport.d_id.b24);
#line 1808
      mutex_unlock(& ha->selflogin_lock);
#line 1809
      rval = 11U;
#line 1810
      goto done;
    } else {

    }
#line 1812
    vha->self_login_loop_id = (unsigned int )nextlid + 65535U;
  } else {

  }
#line 1816
  mutex_unlock(& ha->selflogin_lock);
#line 1818
  vha->bidir_fcport.loop_id = vha->self_login_loop_id;
#line 1820
  tmp___4 = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->request_payload.sg_list,
                             bsg_job->request_payload.sg_cnt, 1, (struct dma_attrs *)0);
#line 1820
  req_sg_cnt = (uint16_t )tmp___4;
#line 1825
  if ((unsigned int )req_sg_cnt == 0U) {
#line 1826
    rval = 17U;
#line 1827
    goto done;
  } else {

  }
#line 1830
  tmp___5 = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,
                             2, (struct dma_attrs *)0);
#line 1830
  rsp_sg_cnt = (uint16_t )tmp___5;
#line 1834
  if ((unsigned int )rsp_sg_cnt == 0U) {
#line 1835
    rval = 17U;
#line 1836
    goto done_unmap_req_sg;
  } else {

  }
#line 1839
  if ((int )req_sg_cnt != bsg_job->request_payload.sg_cnt || (int )rsp_sg_cnt != bsg_job->reply_payload.sg_cnt) {
#line 1841
    ql_dbg(8388608U, vha, 28841, "Dma mapping resulted in different sg counts [request_sg_cnt: %x dma_request_sg_cnt: %x reply_sg_cnt: %x dma_reply_sg_cnt: %x]\n",
           bsg_job->request_payload.sg_cnt, (int )req_sg_cnt, bsg_job->reply_payload.sg_cnt,
           (int )rsp_sg_cnt);
#line 1847
    rval = 17U;
#line 1848
    goto done_unmap_sg;
  } else {

  }
#line 1851
  if (req_data_len != rsp_data_len) {
#line 1852
    rval = 2U;
#line 1853
    ql_log(1U, vha, 28842, "req_data_len != rsp_data_len\n");
#line 1855
    goto done_unmap_sg;
  } else {

  }
#line 1858
  req_data_len = bsg_job->request_payload.payload_len;
#line 1859
  rsp_data_len = bsg_job->reply_payload.payload_len;
#line 1863
  sp = qla2x00_get_sp(vha, & vha->bidir_fcport, 208U);
#line 1864
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 1865
    ql_dbg(8388608U, vha, 28844, "Alloc SRB structure failed\n");
#line 1867
    rval = 17U;
#line 1868
    goto done_unmap_sg;
  } else {

  }
#line 1872
  sp->u.bsg_job = bsg_job;
#line 1873
  sp->free = & qla2x00_bsg_sp_free;
#line 1874
  sp->type = 9U;
#line 1875
  sp->done = & qla2x00_bsg_job_done;
#line 1878
  tot_dsds = (uint32_t )((int )rsp_sg_cnt + (int )req_sg_cnt);
#line 1880
  tmp___6 = qla2x00_start_bidir(sp, vha, tot_dsds);
#line 1880
  rval = (uint32_t )tmp___6;
#line 1881
  if (rval != 0U) {
#line 1882
    goto done_free_srb;
  } else {

  }
#line 1884
  return ((int )rval);
  done_free_srb: 
#line 1887
  mempool_free((void *)sp, ha->srb_mempool);
  done_unmap_sg: 
#line 1889
  dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,
                         2, (struct dma_attrs *)0);
  done_unmap_req_sg: 
#line 1893
  dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->request_payload.sg_list, bsg_job->request_payload.sg_cnt,
                         1, (struct dma_attrs *)0);
  done: 
#line 1901
  (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = rval;
#line 1902
  bsg_job->reply_len = 16U;
#line 1903
  (bsg_job->reply)->reply_payload_rcv_len = 0U;
#line 1904
  (bsg_job->reply)->result = 0U;
#line 1905
  (*(bsg_job->job_done))(bsg_job);
#line 1907
  return (0);
}
}
#line 1911 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
static int qlafx00_mgmt_cmd(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int rval ;
  struct qla_mt_iocb_rqst_fx00 *piocb_rqst ;
  srb_t *sp ;
  int req_sg_cnt ;
  int rsp_sg_cnt ;
  struct fc_port *fcport ;
  char *type ;
  fc_port_t *tmp___0 ;
  uint16_t tmp___1 ;

  {
#line 1913
  host = bsg_job->shost;
#line 1914
  tmp = shost_priv(host);
#line 1914
  vha = (scsi_qla_host_t *)tmp;
#line 1915
  ha = vha->hw;
#line 1916
  rval = 262144;
#line 1919
  req_sg_cnt = 0;
#line 1919
  rsp_sg_cnt = 0;
#line 1921
  type = (char *)"FC_BSG_HST_FX_MGMT";
#line 1924
  piocb_rqst = (struct qla_mt_iocb_rqst_fx00 *)(& (bsg_job->request)->rqst_data.h_vendor.vendor_cmd) + 1U;
#line 1928
  ql_dump_buffer(8421376U, vha, 28879, (uint8_t *)piocb_rqst, 32U);
#line 1931
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 1932
    ql_log(1U, vha, 28880, "Host is not online.\n");
#line 1934
    rval = -5;
#line 1935
    goto done;
  } else {

  }
#line 1938
  if ((int )piocb_rqst->flags & 1) {
#line 1939
    req_sg_cnt = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->request_payload.sg_list,
                                  bsg_job->request_payload.sg_cnt, 1, (struct dma_attrs *)0);
#line 1942
    if (req_sg_cnt == 0) {
#line 1943
      ql_log(1U, vha, 28871, "dma_map_sg return %d for request\n", req_sg_cnt);
#line 1945
      rval = -12;
#line 1946
      goto done;
    } else {

    }
  } else {

  }
#line 1950
  if (((int )piocb_rqst->flags & 2) != 0) {
#line 1951
    rsp_sg_cnt = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list,
                                  bsg_job->reply_payload.sg_cnt, 2, (struct dma_attrs *)0);
#line 1954
    if (rsp_sg_cnt == 0) {
#line 1955
      ql_log(1U, vha, 28872, "dma_map_sg return %d for reply\n", rsp_sg_cnt);
#line 1957
      rval = -12;
#line 1958
      goto done_unmap_req_sg;
    } else {

    }
  } else {

  }
#line 1962
  ql_dbg(8388608U, vha, 28873, "request_sg_cnt: %x dma_request_sg_cnt: %x reply_sg_cnt:%x dma_reply_sg_cnt: %x\n",
         bsg_job->request_payload.sg_cnt, req_sg_cnt, bsg_job->reply_payload.sg_cnt,
         rsp_sg_cnt);
#line 1972
  tmp___0 = qla2x00_alloc_fcport(vha, 208U);
#line 1972
  fcport = tmp___0;
#line 1973
  if ((unsigned long )fcport == (unsigned long )((struct fc_port *)0)) {
#line 1974
    ql_log(1U, vha, 28874, "Failed to allocate fcport.\n");
#line 1976
    rval = -12;
#line 1977
    goto done_unmap_rsp_sg;
  } else {

  }
#line 1981
  sp = qla2x00_get_sp(vha, fcport, 208U);
#line 1982
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 1983
    ql_log(1U, vha, 28875, "qla2x00_get_sp failed.\n");
#line 1985
    rval = -12;
#line 1986
    goto done_free_fcport;
  } else {

  }
#line 1990
  fcport->vha = vha;
#line 1991
  fcport->loop_id = (uint16_t )piocb_rqst->dataword;
#line 1993
  sp->type = 11U;
#line 1994
  sp->name = (char *)"bsg_fx_mgmt";
#line 1995
  tmp___1 = qla24xx_calc_ct_iocbs((int )((uint16_t )req_sg_cnt) + (int )((uint16_t )rsp_sg_cnt));
#line 1995
  sp->iocbs = (int )tmp___1;
#line 1996
  sp->u.bsg_job = bsg_job;
#line 1997
  sp->free = & qla2x00_bsg_sp_free;
#line 1998
  sp->done = & qla2x00_bsg_job_done;
#line 2000
  ql_dbg(8388608U, vha, 28876, "bsg rqst type: %s fx_mgmt_type: %x id=%x\n", type,
         (int )piocb_rqst->func_type, (int )fcport->loop_id);
#line 2004
  rval = qla2x00_start_sp(sp);
#line 2005
  if (rval != 0) {
#line 2006
    ql_log(1U, vha, 28877, "qla2x00_start_sp failed=%d.\n", rval);
#line 2008
    mempool_free((void *)sp, ha->srb_mempool);
#line 2009
    rval = -5;
#line 2010
    goto done_free_fcport;
  } else {

  }
#line 2012
  return (rval);
  done_free_fcport: 
#line 2015
  kfree((void const   *)fcport);
  done_unmap_rsp_sg: ;
#line 2018
  if (((int )piocb_rqst->flags & 2) != 0) {
#line 2019
    dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,
                           2, (struct dma_attrs *)0);
  } else {

  }
  done_unmap_req_sg: ;
#line 2023
  if ((int )piocb_rqst->flags & 1) {
#line 2024
    dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->request_payload.sg_list, bsg_job->request_payload.sg_cnt,
                           1, (struct dma_attrs *)0);
  } else {

  }
  done: ;
#line 2029
  return (rval);
}
}
#line 2033 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
static int qla26xx_serdes_op(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int rval ;
  struct qla_serdes_reg sr ;

  {
#line 2035
  host = bsg_job->shost;
#line 2036
  tmp = shost_priv(host);
#line 2036
  vha = (scsi_qla_host_t *)tmp;
#line 2037
  rval = 0;
#line 2040
  memset((void *)(& sr), 0, 6UL);
#line 2042
  sg_copy_to_buffer(bsg_job->request_payload.sg_list, (unsigned int )bsg_job->request_payload.sg_cnt,
                    (void *)(& sr), 6UL);
#line 2045
  switch ((int )sr.cmd) {
  case 2: 
#line 2047
  rval = qla2x00_write_serdes_word(vha, (int )sr.addr, (int )sr.val);
#line 2048
  (bsg_job->reply)->reply_payload_rcv_len = 0U;
#line 2049
  goto ldv_66309;
  case 1: 
#line 2051
  rval = qla2x00_read_serdes_word(vha, (int )sr.addr, & sr.val);
#line 2052
  sg_copy_from_buffer(bsg_job->reply_payload.sg_list, (unsigned int )bsg_job->reply_payload.sg_cnt,
                      (void const   *)(& sr), 6UL);
#line 2054
  (bsg_job->reply)->reply_payload_rcv_len = 6U;
#line 2055
  goto ldv_66309;
  default: 
#line 2057
  ql_dbg(8388608U, vha, 28812, "Unknown serdes cmd %x.\n", (int )sr.cmd);
#line 2059
  rval = -22;
#line 2060
  goto ldv_66309;
  }
  ldv_66309: 
#line 2063
  (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = rval != 0 ? 11U : 0U;
#line 2066
  bsg_job->reply_len = 16U;
#line 2067
  (bsg_job->reply)->result = 0U;
#line 2068
  (*(bsg_job->job_done))(bsg_job);
#line 2069
  return (0);
}
}
#line 2073 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
static int qla8044_serdes_op(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int rval ;
  struct qla_serdes_reg_ex sr ;

  {
#line 2075
  host = bsg_job->shost;
#line 2076
  tmp = shost_priv(host);
#line 2076
  vha = (scsi_qla_host_t *)tmp;
#line 2077
  rval = 0;
#line 2080
  memset((void *)(& sr), 0, 10UL);
#line 2082
  sg_copy_to_buffer(bsg_job->request_payload.sg_list, (unsigned int )bsg_job->request_payload.sg_cnt,
                    (void *)(& sr), 10UL);
#line 2085
  switch ((int )sr.cmd) {
  case 2: 
#line 2087
  rval = qla8044_write_serdes_word(vha, sr.addr, sr.val);
#line 2088
  (bsg_job->reply)->reply_payload_rcv_len = 0U;
#line 2089
  goto ldv_66320;
  case 1: 
#line 2091
  rval = qla8044_read_serdes_word(vha, sr.addr, & sr.val);
#line 2092
  sg_copy_from_buffer(bsg_job->reply_payload.sg_list, (unsigned int )bsg_job->reply_payload.sg_cnt,
                      (void const   *)(& sr), 10UL);
#line 2094
  (bsg_job->reply)->reply_payload_rcv_len = 10U;
#line 2095
  goto ldv_66320;
  default: 
#line 2097
  ql_dbg(8388608U, vha, 28879, "Unknown serdes cmd %x.\n", (int )sr.cmd);
#line 2099
  rval = -22;
#line 2100
  goto ldv_66320;
  }
  ldv_66320: 
#line 2103
  (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = rval != 0 ? 11U : 0U;
#line 2106
  bsg_job->reply_len = 16U;
#line 2107
  (bsg_job->reply)->result = 0U;
#line 2108
  (*(bsg_job->job_done))(bsg_job);
#line 2109
  return (0);
}
}
#line 2113 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
static int qla2x00_process_vendor_specific(struct fc_bsg_job *bsg_job ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 2115
  switch ((bsg_job->request)->rqst_data.h_vendor.vendor_cmd[0]) {
  case 1U: 
#line 2117
  tmp = qla2x00_process_loopback(bsg_job);
#line 2117
  return (tmp);
  case 2U: 
#line 2120
  tmp___0 = qla84xx_reset(bsg_job);
#line 2120
  return (tmp___0);
  case 3U: 
#line 2123
  tmp___1 = qla84xx_updatefw(bsg_job);
#line 2123
  return (tmp___1);
  case 4U: 
#line 2126
  tmp___2 = qla84xx_mgmt_cmd(bsg_job);
#line 2126
  return (tmp___2);
  case 5U: 
#line 2129
  tmp___3 = qla24xx_iidma(bsg_job);
#line 2129
  return (tmp___3);
  case 6U: 
#line 2132
  tmp___4 = qla24xx_proc_fcp_prio_cfg_cmd(bsg_job);
#line 2132
  return (tmp___4);
  case 7U: 
#line 2135
  tmp___5 = qla2x00_read_optrom(bsg_job);
#line 2135
  return (tmp___5);
  case 8U: 
#line 2138
  tmp___6 = qla2x00_update_optrom(bsg_job);
#line 2138
  return (tmp___6);
  case 11U: 
#line 2141
  tmp___7 = qla2x00_update_fru_versions(bsg_job);
#line 2141
  return (tmp___7);
  case 12U: 
#line 2144
  tmp___8 = qla2x00_read_fru_status(bsg_job);
#line 2144
  return (tmp___8);
  case 13U: 
#line 2147
  tmp___9 = qla2x00_write_fru_status(bsg_job);
#line 2147
  return (tmp___9);
  case 16U: 
#line 2150
  tmp___10 = qla2x00_write_i2c(bsg_job);
#line 2150
  return (tmp___10);
  case 17U: 
#line 2153
  tmp___11 = qla2x00_read_i2c(bsg_job);
#line 2153
  return (tmp___11);
  case 10U: 
#line 2156
  tmp___12 = qla24xx_process_bidir_cmd(bsg_job);
#line 2156
  return (tmp___12);
  case 18U: 
#line 2159
  tmp___13 = qlafx00_mgmt_cmd(bsg_job);
#line 2159
  return (tmp___13);
  case 19U: 
#line 2162
  tmp___14 = qla26xx_serdes_op(bsg_job);
#line 2162
  return (tmp___14);
  case 20U: 
#line 2165
  tmp___15 = qla8044_serdes_op(bsg_job);
#line 2165
  return (tmp___15);
  default: ;
#line 2168
  return (-38);
  }
}
}
#line 2173 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
int qla24xx_bsg_request(struct fc_bsg_job *bsg_job ) 
{ 
  int ret ;
  struct fc_rport *rport ;
  fc_port_t *fcport ;
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 2175
  ret = -22;
#line 2177
  fcport = (fc_port_t *)0;
#line 2182
  (bsg_job->reply)->reply_payload_rcv_len = 0U;
#line 2184
  if ((bsg_job->request)->msgcode == 1073741825U) {
#line 2185
    rport = bsg_job->rport;
#line 2186
    fcport = *((fc_port_t **)rport->dd_data);
#line 2187
    host = dev_to_shost(rport->dev.parent);
#line 2188
    tmp = shost_priv(host);
#line 2188
    vha = (scsi_qla_host_t *)tmp;
  } else {
#line 2190
    host = bsg_job->shost;
#line 2191
    tmp___0 = shost_priv(host);
#line 2191
    vha = (scsi_qla_host_t *)tmp___0;
  }
#line 2194
  tmp___1 = qla2x00_reset_active(vha);
#line 2194
  if (tmp___1 != 0) {
#line 2195
    ql_dbg(8388608U, vha, 28831, "BSG: ISP abort active/needed -- cmd=%d.\n", (bsg_job->request)->msgcode);
#line 2198
    return (-16);
  } else {

  }
#line 2201
  ql_dbg(8388608U, vha, 28672, "Entered %s msgcode=0x%x.\n", "qla24xx_bsg_request",
         (bsg_job->request)->msgcode);
#line 2204
  switch ((bsg_job->request)->msgcode) {
  case 1073741825U: ;
  case 2147483651U: 
#line 2207
  ret = qla2x00_process_els(bsg_job);
#line 2208
  goto ldv_66355;
  case 2147483652U: 
#line 2210
  ret = qla2x00_process_ct(bsg_job);
#line 2211
  goto ldv_66355;
  case 2147483903U: 
#line 2213
  ret = qla2x00_process_vendor_specific(bsg_job);
#line 2214
  goto ldv_66355;
  case 2147483649U: ;
  case 2147483650U: ;
  case 1073741826U: ;
  default: 
#line 2219
  ql_log(1U, vha, 28762, "Unsupported BSG request.\n");
#line 2220
  goto ldv_66355;
  }
  ldv_66355: ;
#line 2222
  return (ret);
}
}
#line 2226 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.c"
int qla24xx_bsg_timeout(struct fc_bsg_job *bsg_job ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  srb_t *sp ;
  int cnt ;
  int que ;
  unsigned long flags ;
  struct req_que *req ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;
  raw_spinlock_t *tmp___2 ;

  {
#line 2228
  tmp = shost_priv(bsg_job->shost);
#line 2228
  vha = (scsi_qla_host_t *)tmp;
#line 2229
  ha = vha->hw;
#line 2236
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 2236
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 2237
  que = 0;
#line 2237
  goto ldv_66384;
  ldv_66383: 
#line 2238
  req = *(ha->req_q_map + (unsigned long )que);
#line 2239
  if ((unsigned long )req == (unsigned long )((struct req_que *)0)) {
#line 2240
    goto ldv_66375;
  } else {

  }
#line 2242
  cnt = 1;
#line 2242
  goto ldv_66381;
  ldv_66380: 
#line 2243
  sp = *(req->outstanding_cmds + (unsigned long )cnt);
#line 2244
  if ((unsigned long )sp != (unsigned long )((srb_t *)0)) {
#line 2245
    if ((((unsigned int )sp->type == 5U || (unsigned int )sp->type == 4U) || (unsigned int )sp->type == 11U) && (unsigned long )sp->u.bsg_job == (unsigned long )bsg_job) {
#line 2249
      *(req->outstanding_cmds + (unsigned long )cnt) = (srb_t *)0;
#line 2250
      spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2251
      tmp___1 = (*((ha->isp_ops)->abort_command))(sp);
#line 2251
      if (tmp___1 != 0) {
#line 2252
        ql_log(1U, vha, 28809, "mbx abort_command failed.\n");
#line 2255
        (bsg_job->reply)->result = 4294967291U;
#line 2255
        (bsg_job->req)->errors = -5;
      } else {
#line 2258
        ql_dbg(8388608U, vha, 28810, "mbx abort_command success.\n");
#line 2261
        (bsg_job->reply)->result = 0U;
#line 2261
        (bsg_job->req)->errors = 0;
      }
#line 2264
      tmp___2 = spinlock_check(& ha->hardware_lock);
#line 2264
      flags = _raw_spin_lock_irqsave(tmp___2);
#line 2265
      goto done;
    } else {

    }
  } else {

  }
#line 2242
  cnt = cnt + 1;
  ldv_66381: ;
#line 2242
  if ((int )req->num_outstanding_cmds > cnt) {
#line 2244
    goto ldv_66380;
  } else {

  }

  ldv_66375: 
#line 2237
  que = que + 1;
  ldv_66384: ;
#line 2237
  if ((int )ha->max_req_queues > que) {
#line 2239
    goto ldv_66383;
  } else {

  }
#line 2270
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2271
  ql_log(2U, vha, 28811, "SRB not found to abort.\n");
#line 2272
  (bsg_job->reply)->result = 4294967290U;
#line 2272
  (bsg_job->req)->errors = -6;
#line 2273
  return (0);
  done: 
#line 2276
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2277
  (*(sp->free))((void *)vha, (void *)sp);
#line 2278
  return (0);
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
int reg_timer_25(struct timer_list *timer ) 
{ 


  {
#line 489
  ldv_timer_list_25 = timer;
#line 490
  ldv_timer_state_25 = 1;
#line 491
  return (0);
}
}
#line 494 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
void activate_pending_timer_25(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 494
  if ((unsigned long )ldv_timer_list_25 == (unsigned long )timer) {
#line 495
    if (ldv_timer_state_25 == 2 || pending_flag != 0) {
#line 496
      ldv_timer_list_25 = timer;
#line 497
      ldv_timer_list_25->data = data;
#line 498
      ldv_timer_state_25 = 1;
    } else {

    }
#line 500
    return;
  } else {

  }
#line 502
  reg_timer_25(timer);
#line 503
  ldv_timer_list_25->data = data;
#line 504
  return;
}
}
#line 507 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
void choose_timer_25(struct timer_list *timer ) 
{ 


  {
#line 508
  LDV_IN_INTERRUPT = 2;
#line 509
  (*(timer->function))(timer->data);
#line 510
  LDV_IN_INTERRUPT = 1;
#line 511
  ldv_timer_state_25 = 2;
#line 512
  return;
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
void disable_suitable_timer_25(struct timer_list *timer ) 
{ 


  {
#line 516
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_25) {
#line 517
    ldv_timer_state_25 = 0;
#line 518
    return;
  } else {

  }
#line 520
  return;
}
}
#line 546 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
bool ldv_queue_work_on_231(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 550
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 550
  ldv_func_res = tmp;
#line 552
  activate_work_7(ldv_func_arg3, 2);
#line 554
  return (ldv_func_res);
}
}
#line 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
bool ldv_queue_delayed_work_on_232(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 561
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 561
  ldv_func_res = tmp;
#line 563
  activate_work_7(& ldv_func_arg3->work, 2);
#line 565
  return (ldv_func_res);
}
}
#line 568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
bool ldv_queue_work_on_233(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 572
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 572
  ldv_func_res = tmp;
#line 574
  activate_work_7(ldv_func_arg3, 2);
#line 576
  return (ldv_func_res);
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
void ldv_flush_workqueue_234(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 582
  flush_workqueue(ldv_func_arg1);
#line 584
  call_and_disable_all_7(2);
#line 585
  return;
}
}
#line 587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
bool ldv_queue_delayed_work_on_235(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 591
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 591
  ldv_func_res = tmp;
#line 593
  activate_work_7(& ldv_func_arg3->work, 2);
#line 595
  return (ldv_func_res);
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
int ldv_scsi_add_host_with_dma_236(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 602
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 602
  ldv_func_res = tmp;
#line 604
  if (ldv_func_res == 0) {
#line 605
    ldv_state_variable_88 = 1;
#line 605
    ldv_initialize_scsi_host_template_88();
  } else {

  }
#line 609
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 154 "include/linux/printk.h"
extern int __printk_ratelimit(char const   * ) ;
#line 18 "include/linux/rwlock.h"
extern void __rwlock_init(rwlock_t * , char const   * , struct lock_class_key * ) ;
#line 18 "include/linux/rwlock_api_smp.h"
extern void _raw_read_lock(rwlock_t * ) ;
#line 26
extern unsigned long _raw_write_lock_irqsave(rwlock_t * ) ;
#line 30
extern void _raw_read_unlock(rwlock_t * ) ;
#line 40
extern void _raw_write_unlock_irqrestore(rwlock_t * , unsigned long  ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_247(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_249(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_248(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_251(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_250(struct workqueue_struct *ldv_func_arg1 ) ;
#line 56 "./arch/x86/include/asm/io.h"
__inline static unsigned char readb(void const volatile   *addr ) 
{ 
  unsigned char ret ;

  {
#line 56
  __asm__  volatile   ("movb %1,%0": "=q" (ret): "m" (*((unsigned char volatile   *)addr)): "memory");
#line 56
  return (ret);
}
}
#line 90 "./arch/x86/include/asm/io.h"
__inline static unsigned long readq(void const volatile   *addr ) 
{ 
  unsigned long ret ;

  {
#line 90
  __asm__  volatile   ("movq %1,%0": "=r" (ret): "m" (*((unsigned long volatile   *)addr)): "memory");
#line 90
  return (ret);
}
}
#line 91 "./arch/x86/include/asm/io.h"
__inline static void writeq(unsigned long val , void volatile   *addr ) 
{ 


  {
#line 91
  __asm__  volatile   ("movq %0,%1": : "r" (val), "m" (*((unsigned long volatile   *)addr)): "memory");
#line 92
  return;
}
}
#line 421 "include/linux/sched.h"
extern long schedule_timeout(long  ) ;
#line 336 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void choose_timer_26(struct timer_list *timer ) ;
#line 375
void activate_pending_timer_26(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 379
void disable_suitable_timer_26(struct timer_list *timer ) ;
#line 438
int reg_timer_26(struct timer_list *timer ) ;
#line 47 "include/linux/ratelimit.h"
extern int ___ratelimit(struct ratelimit_state * , char const   * ) ;
#line 1084 "include/linux/device.h"
extern void dev_err(struct device  const  * , char const   *  , ...) ;
#line 861 "include/linux/pci.h"
extern int pci_bus_read_config_dword(struct pci_bus * , unsigned int  , int  , u32 * ) ;
#line 889 "include/linux/pci.h"
__inline static int pci_read_config_dword(struct pci_dev  const  *dev , int where ,
                                          u32 *val ) 
{ 
  int tmp ;

  {
#line 892
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
#line 892
  return (tmp);
}
}
#line 908
extern int pcie_capability_read_word(struct pci_dev * , int  , u16 * ) ;
#line 975
extern int pci_set_mwi(struct pci_dev * ) ;
#line 1092
extern int pci_request_regions(struct pci_dev * , char const   * ) ;
#line 795 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_252(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
#line 1179 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
static int const   MD_MIU_TEST_AGT_RDDATA[4U]  = {      1090519208,      1090519212,      1090519224,      1090519228};
#line 652 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int qla82xx_pci_mem_read_2M(struct qla_hw_data *ha , u64 off , void *data , int size ) ;
#line 653
int qla82xx_pci_region_offset(struct pci_dev *pdev , int region ) ;
#line 700
uint32_t qla82xx_wait_for_state_change(scsi_qla_host_t *vha , uint32_t curr_state ) ;
#line 718
char *qdev_state(uint32_t dev_state ) ;
#line 738
int qla82xx_md_alloc(scsi_qla_host_t *vha ) ;
#line 740
int qla82xx_md_collect(scsi_qla_host_t *vha ) ;
#line 743
int qla82xx_validate_template_chksum(scsi_qla_host_t *vha ) ;
#line 764
void qla82xx_mbx_completion(scsi_qla_host_t *vha , uint16_t mb0 ) ;
#line 766
int qla8044_check_fw_alive(struct scsi_qla_host *vha ) ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static unsigned long crb_addr_xform[60U]  ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_crb_table_initialized  ;
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static void qla82xx_crb_addr_transform_setup(void) 
{ 


  {
#line 47
  crb_addr_xform[49] = 1078984704UL;
#line 48
  crb_addr_xform[40] = 1097859072UL;
#line 49
  crb_addr_xform[5] = 218103808UL;
#line 50
  crb_addr_xform[11] = 238026752UL;
#line 51
  crb_addr_xform[10] = 236978176UL;
#line 52
  crb_addr_xform[9] = 235929600UL;
#line 53
  crb_addr_xform[8] = 234881024UL;
#line 54
  crb_addr_xform[16] = 1883242496UL;
#line 55
  crb_addr_xform[15] = 1882193920UL;
#line 56
  crb_addr_xform[14] = 1881145344UL;
#line 57
  crb_addr_xform[13] = 1880096768UL;
#line 58
  crb_addr_xform[48] = 1894776832UL;
#line 59
  crb_addr_xform[47] = 148897792UL;
#line 60
  crb_addr_xform[46] = 147849216UL;
#line 61
  crb_addr_xform[45] = 1891631104UL;
#line 62
  crb_addr_xform[44] = 1890582528UL;
#line 63
  crb_addr_xform[43] = 1889533952UL;
#line 64
  crb_addr_xform[42] = 143654912UL;
#line 65
  crb_addr_xform[53] = 142606336UL;
#line 66
  crb_addr_xform[51] = 1108344832UL;
#line 67
  crb_addr_xform[29] = 1090519040UL;
#line 68
  crb_addr_xform[7] = 241172480UL;
#line 69
  crb_addr_xform[12] = 1879048192UL;
#line 70
  crb_addr_xform[22] = 876609536UL;
#line 71
  crb_addr_xform[21] = 877658112UL;
#line 72
  crb_addr_xform[20] = 875560960UL;
#line 73
  crb_addr_xform[19] = 874512384UL;
#line 74
  crb_addr_xform[18] = 873463808UL;
#line 75
  crb_addr_xform[17] = 872415232UL;
#line 76
  crb_addr_xform[28] = 1010827264UL;
#line 77
  crb_addr_xform[27] = 1011875840UL;
#line 78
  crb_addr_xform[26] = 1009778688UL;
#line 79
  crb_addr_xform[25] = 1008730112UL;
#line 80
  crb_addr_xform[24] = 1007681536UL;
#line 81
  crb_addr_xform[23] = 1006632960UL;
#line 82
  crb_addr_xform[1] = 1999634432UL;
#line 83
  crb_addr_xform[0] = 698351616UL;
#line 84
  crb_addr_xform[6] = 454033408UL;
#line 85
  crb_addr_xform[50] = 1107296256UL;
#line 86
  crb_addr_xform[31] = 219152384UL;
#line 87
  crb_addr_xform[2] = 693108736UL;
#line 88
  crb_addr_xform[3] = 709885952UL;
#line 89
  crb_addr_xform[37] = 209715200UL;
#line 90
  crb_addr_xform[36] = 208666624UL;
#line 91
  crb_addr_xform[35] = 207618048UL;
#line 92
  crb_addr_xform[34] = 1096810496UL;
#line 93
  crb_addr_xform[39] = 1972371456UL;
#line 94
  crb_addr_xform[38] = 1971322880UL;
#line 95
  crb_addr_xform[58] = 1904214016UL;
#line 96
  crb_addr_xform[56] = 1080033280UL;
#line 100
  crb_addr_xform[59] = 428867584UL;
#line 102
  qla82xx_crb_table_initialized = 1;
#line 103
  return;
}
}
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static struct crb_128M_2M_block_map crb_128M_2M_map[64U]  = 
#line 105
  {      {{{0U, 0U, 0U, 0U}}}, 
        {{{1U, 1048576U, 1056768U, 1179648U}, {1U, 1114112U, 1179648U, 1245184U}, {1U,
                                                                                1179648U,
                                                                                1187840U,
                                                                                1196032U},
       {1U, 1245184U, 1253376U, 1204224U}, {1U, 1310720U, 1318912U, 1212416U}, {1U,
                                                                                1376256U,
                                                                                1384448U,
                                                                                1220608U},
       {1U, 1441792U, 1507328U, 1114112U}, {1U, 1507328U, 1515520U, 1236992U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {1U, 1966080U, 1968128U, 1187840U}, {0U, 0U, 0U, 0U}}}, 
        {{{1U, 2097152U, 2162688U, 1572864U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{1U, 4194304U, 4198400U, 1478656U}}}, 
        {{{1U, 5242880U, 5308416U, 1310720U}}}, 
        {{{1U, 6291456U, 6356992U, 1835008U}}}, 
        {{{1U, 7340032U, 7356416U, 1802240U}}}, 
        {{{1U, 8388608U, 8396800U, 1507328U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {1U, 9371648U, 9379840U, 1515520U}}}, 
        {{{1U, 9437184U, 9445376U, 1523712U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {1U, 10420224U, 10428416U, 1531904U}}}, 
        {{{0U, 10485760U, 10493952U, 1540096U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                  0U,
                                                                                  0U,
                                                                                  0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {1U, 11468800U, 11476992U, 1548288U}}}, 
        {{{0U, 11534336U, 11542528U, 1556480U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                  0U,
                                                                                  0U,
                                                                                  0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {1U, 12517376U, 12525568U, 1564672U}}}, 
        {{{1U, 12582912U, 12599296U, 1916928U}}}, 
        {{{1U, 13631488U, 13647872U, 1720320U}}}, 
        {{{1U, 14680064U, 14696448U, 1703936U}}}, 
        {{{1U, 15728640U, 15732736U, 1458176U}}}, 
        {{{0U, 16777216U, 16793600U, 1736704U}}}, 
        {{{1U, 17825792U, 17829888U, 1441792U}}}, 
        {{{1U, 18874368U, 18878464U, 1445888U}}}, 
        {{{1U, 19922944U, 19927040U, 1449984U}}}, 
        {{{1U, 20971520U, 20975616U, 1454080U}}}, 
        {{{1U, 22020096U, 22024192U, 1462272U}}}, 
        {{{1U, 23068672U, 23072768U, 1466368U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{1U, 30408704U, 30474240U, 1638400U}}}, 
        {{{1U, 31457280U, 31461376U, 1482752U}}}, 
        {{{1U, 32505856U, 32571392U, 1376256U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{1U, 34603008U, 34611200U, 1179648U}, {1U, 34668544U, 34734080U, 1245184U},
       {1U, 34734080U, 34742272U, 1196032U}, {1U, 34799616U, 34807808U, 1204224U},
       {1U, 34865152U, 34873344U, 1212416U}, {1U, 34930688U, 34938880U, 1220608U},
       {1U, 34996224U, 35061760U, 1114112U}, {1U, 35061760U, 35069952U, 1236992U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}}}, 
        {{{1U, 35651584U, 35667968U, 1769472U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{1U, 41943040U, 41959424U, 1720320U}}}, 
        {{{1U, 42991616U, 42995712U, 1486848U}}}, 
        {{{1U, 44040192U, 44041216U, 1754112U}}}, 
        {{{1U, 45088768U, 45089792U, 1755136U}}}, 
        {{{1U, 46137344U, 46138368U, 1756160U}}}, 
        {{{1U, 47185920U, 47186944U, 1757184U}}}, 
        {{{1U, 48234496U, 48235520U, 1758208U}}}, 
        {{{1U, 49283072U, 49284096U, 1759232U}}}, 
        {{{1U, 50331648U, 50332672U, 1760256U}}}, 
        {{{0U, 51380224U, 51396608U, 1736704U}}}, 
        {{{1U, 52428800U, 52445184U, 1916928U}}}, 
        {{{1U, 53477376U, 53493760U, 1703936U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{1U, 55574528U, 55575552U, 1753088U}}}, 
        {{{1U, 56623104U, 56624128U, 1761280U}}}, 
        {{{1U, 57671680U, 57672704U, 1762304U}}}, 
        {{{1U, 58720256U, 58736640U, 1900544U}}}, 
        {{{1U, 59768832U, 59785216U, 1785856U}}}, 
        {{{1U, 60817408U, 60833792U, 1933312U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{1U, 63963136U, 63979520U, 1949696U}}}, 
        {{{1U, 65011712U, 65015808U, 1470464U}}}, 
        {{{1U, 66060288U, 66064384U, 1474560U}}}};
#line 265 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static unsigned int qla82xx_crb_hub_agt[64U]  = 
#line 265
  {      0U,      1907U,      661U,      677U, 
        0U,      208U,      433U,      230U, 
        224U,      225U,      226U,      227U, 
        1056U,      1047U,      1057U,      843U, 
        1029U,      832U,      833U,      834U, 
        835U,      837U,      836U,      960U, 
        961U,      962U,      963U,      0U, 
        964U,      1040U,      0U,      209U, 
        0U,      1907U,      1046U,      0U, 
        0U,      0U,      0U,      0U, 
        1047U,      0U,      137U,      1802U, 
        1803U,      1804U,      141U,      142U, 
        1807U,      1029U,      1056U,      1057U, 
        0U,      136U,      145U,      1810U, 
        1030U,      0U,      1816U,      409U, 
        425U,      0U,      838U,      0U};
#line 333 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static char *q_dev_state[8U]  = 
#line 333
  {      (char *)"Unknown",      (char *)"Cold",      (char *)"Initializing",      (char *)"Ready", 
        (char *)"Need Reset",      (char *)"Need Quiescent",      (char *)"Failed",      (char *)"Quiescent"};
#line 344 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
char *qdev_state(uint32_t dev_state ) 
{ 


  {
#line 346
  return (q_dev_state[dev_state]);
}
}
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static void qla82xx_pci_set_crbwindow_2M(struct qla_hw_data *ha , ulong *off ) 
{ 
  u32 win_read ;
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 358
  tmp = pci_get_drvdata(ha->pdev);
#line 358
  vha = (scsi_qla_host_t *)tmp;
#line 360
  ha->crb_win = (qla82xx_crb_hub_agt[(*off >> 20) & 63UL] << 20) | ((uint32_t )*off & 983040U);
#line 361
  writel(ha->crb_win, (void volatile   *)(ha->nx_pcibase + 1245280UL));
#line 367
  win_read = readl((void const volatile   *)(ha->nx_pcibase + 1245280UL));
#line 369
  if (ha->crb_win != win_read) {
#line 370
    ql_dbg(524288U, vha, 45056, "%s: Written crbwin (0x%x) != Read crbwin (0x%x), off=0x%lx.\n",
           "qla82xx_pci_set_crbwindow_2M", ha->crb_win, win_read, *off);
  } else {

  }
#line 375
  *off = (ulong )((((unsigned long long )*off & 65535ULL) + (unsigned long long )ha->nx_pcibase) + 1966080ULL);
#line 376
  return;
}
}
#line 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_pci_get_crb_addr_2M(struct qla_hw_data *ha , ulong *off ) 
{ 
  struct crb_128M_2M_sub_block_map *m ;

  {
#line 424
  if (*off > 167772159UL) {
#line 425
    return (-1);
  } else {

  }
#line 427
  if (*off > 75497471UL && *off <= 75499519UL) {
#line 428
    *off = (*off + ha->nx_pcibase) - 74450944UL;
#line 430
    return (0);
  } else {

  }
#line 433
  if (*off <= 100663295UL) {
#line 434
    return (-1);
  } else {

  }
#line 436
  *off = *off - 100663296UL;
#line 439
  m = (struct crb_128M_2M_sub_block_map *)(& crb_128M_2M_map[(*off >> 20) & 63UL].sub_block) + ((*off >> 16) & 15UL);
#line 441
  if ((m->valid != 0U && (ulong )m->start_128M <= *off) && (ulong )m->end_128M > *off) {
#line 442
    *off = ((*off + (ulong )m->start_2M) - (ulong )m->start_128M) + ha->nx_pcibase;
#line 443
    return (0);
  } else {

  }
#line 446
  return (1);
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_crb_win_lock(struct qla_hw_data *ha ) 
{ 
  int done ;
  int timeout ;

  {
#line 452
  done = 0;
#line 452
  timeout = 0;
#line 454
  goto ldv_65961;
  ldv_65960: 
#line 456
  done = qla82xx_rd_32(ha, 101826616UL);
#line 457
  if (done == 1) {
#line 458
    goto ldv_65959;
  } else {

  }
#line 459
  if (timeout > 99999999) {
#line 460
    return (-1);
  } else {

  }
#line 461
  timeout = timeout + 1;
  ldv_65961: ;
#line 454
  if (done == 0) {
#line 456
    goto ldv_65960;
  } else {

  }
  ldv_65959: 
#line 463
  qla82xx_wr_32(ha, 136323364UL, (u32 )ha->portnum);
#line 464
  return (0);
}
}
#line 468 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
int qla82xx_wr_32(struct qla_hw_data *ha , ulong off , u32 data ) 
{ 
  unsigned long flags ;
  int rv ;
  long tmp ;

  {
#line 470
  flags = 0UL;
#line 473
  rv = qla82xx_pci_get_crb_addr_2M(ha, & off);
#line 475
  tmp = ldv__builtin_expect(rv == -1, 0L);
#line 475
  if (tmp != 0L) {
#line 475
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"),
                         "i" (475), "i" (12UL));
    ldv_65969: ;
#line 475
    goto ldv_65969;
  } else {

  }
#line 477
  if (rv == 1) {
#line 478
    flags = _raw_write_lock_irqsave(& ha->hw_lock);
#line 479
    qla82xx_crb_win_lock(ha);
#line 480
    qla82xx_pci_set_crbwindow_2M(ha, & off);
  } else {

  }
#line 483
  writel(data, (void volatile   *)off);
#line 485
  if (rv == 1) {
#line 486
    qla82xx_rd_32(ha, 101826620UL);
#line 487
    _raw_write_unlock_irqrestore(& ha->hw_lock, flags);
  } else {

  }
#line 489
  return (0);
}
}
#line 493 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
int qla82xx_rd_32(struct qla_hw_data *ha , ulong off ) 
{ 
  unsigned long flags ;
  int rv ;
  u32 data ;
  long tmp ;

  {
#line 495
  flags = 0UL;
#line 499
  rv = qla82xx_pci_get_crb_addr_2M(ha, & off);
#line 501
  tmp = ldv__builtin_expect(rv == -1, 0L);
#line 501
  if (tmp != 0L) {
#line 501
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"),
                         "i" (501), "i" (12UL));
    ldv_65983: ;
#line 501
    goto ldv_65983;
  } else {

  }
#line 503
  if (rv == 1) {
#line 504
    flags = _raw_write_lock_irqsave(& ha->hw_lock);
#line 505
    qla82xx_crb_win_lock(ha);
#line 506
    qla82xx_pci_set_crbwindow_2M(ha, & off);
  } else {

  }
#line 508
  data = readl((void const volatile   *)off);
#line 510
  if (rv == 1) {
#line 511
    qla82xx_rd_32(ha, 101826620UL);
#line 512
    _raw_write_unlock_irqrestore(& ha->hw_lock, flags);
  } else {

  }
#line 514
  return ((int )data);
}
}
#line 518 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
int qla82xx_idc_lock(struct qla_hw_data *ha ) 
{ 
  int i ;
  int done ;
  int timeout ;
  int tmp ;

  {
#line 521
  done = 0;
#line 521
  timeout = 0;
#line 523
  goto ldv_66001;
  ldv_66000: 
#line 525
  done = qla82xx_rd_32(ha, 101826600UL);
#line 526
  if (done == 1) {
#line 527
    goto ldv_65996;
  } else {

  }
#line 528
  if (timeout > 99999999) {
#line 529
    return (-1);
  } else {

  }
#line 531
  timeout = timeout + 1;
#line 534
  tmp = preempt_count();
#line 534
  if (((unsigned long )tmp & 2096896UL) == 0UL) {
#line 535
    schedule();
  } else {
#line 537
    i = 0;
#line 537
    goto ldv_65998;
    ldv_65997: 
#line 538
    cpu_relax();
#line 537
    i = i + 1;
    ldv_65998: ;
#line 537
    if (i <= 19) {
#line 539
      goto ldv_65997;
    } else {

    }

  }
  ldv_66001: ;
#line 523
  if (done == 0) {
#line 525
    goto ldv_66000;
  } else {

  }
  ldv_65996: ;
#line 542
  return (0);
}
}
#line 545 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
void qla82xx_idc_unlock(struct qla_hw_data *ha ) 
{ 


  {
#line 547
  qla82xx_rd_32(ha, 101826604UL);
#line 548
  return;
}
}
#line 558 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static unsigned long qla82xx_pci_mem_bound_check(struct qla_hw_data *ha , unsigned long long addr ,
                                                 int size ) 
{ 


  {
#line 561
  if ((addr > 268435455ULL || ((unsigned long long )size + addr) - 1ULL > 268435455ULL) || (((size != 1 && size != 2) && size != 4) && size != 8)) {
#line 566
    return (0UL);
  } else {
#line 568
    return (1UL);
  }
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_pci_set_window_warning_count  ;
#line 574 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static unsigned long qla82xx_pci_set_window(struct qla_hw_data *ha , unsigned long long addr ) 
{ 
  int window ;
  u32 win_read ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;
  unsigned int temp1 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 578
  tmp = pci_get_drvdata(ha->pdev);
#line 578
  vha = (scsi_qla_host_t *)tmp;
#line 580
  if (addr <= 268435455ULL) {
#line 583
    window = (int )((unsigned int )((addr & 33292288ULL) >> 1) | ((unsigned int )(addr >> 25) & 1023U));
#line 584
    ha->ddr_mn_window = (uint32_t )window;
#line 585
    qla82xx_wr_32(ha, ha->mn_win_crb | 100663296UL, (u32 )window);
#line 587
    tmp___0 = qla82xx_rd_32(ha, ha->mn_win_crb | 100663296UL);
#line 587
    win_read = (u32 )tmp___0;
#line 589
    if (win_read << 17 != (u32 )window) {
#line 590
      ql_dbg(524288U, vha, 45059, "%s: Written MNwin (0x%x) != Read MNwin (0x%x).\n",
             "qla82xx_pci_set_window", window, win_read);
    } else {

    }
#line 594
    addr = addr & 262143ULL;
  } else
#line 595
  if (addr <= 8590983167ULL && addr > 8589934591ULL) {
#line 598
    if ((addr & 1046528ULL) == 1046528ULL) {
#line 599
      ql_log(1U, vha, 45060, "%s: QM access not handled.\n", "qla82xx_pci_set_window");
#line 601
      addr = 0xffffffffffffffffULL;
    } else {

    }
#line 603
    window = (int )((unsigned int )((addr & 33488896ULL) >> 1) | ((unsigned int )(addr >> 25) & 1023U));
#line 604
    ha->ddr_mn_window = (uint32_t )window;
#line 605
    qla82xx_wr_32(ha, ha->mn_win_crb | 100663296UL, (u32 )window);
#line 607
    tmp___1 = qla82xx_rd_32(ha, ha->mn_win_crb | 100663296UL);
#line 607
    win_read = (u32 )tmp___1;
#line 609
    temp1 = ((unsigned int )(window << 7) & 65535U) | ((unsigned int )window >> 17);
#line 611
    if (win_read != temp1) {
#line 612
      ql_log(1U, vha, 45061, "%s: Written OCMwin (0x%x) != Read OCMwin (0x%x).\n",
             "qla82xx_pci_set_window", temp1, win_read);
    } else {

    }
#line 616
    addr = (addr & 262143ULL) + 786432ULL;
  } else
#line 618
  if (addr <= 12952010751ULL && addr > 12884901887ULL) {
#line 621
    window = (int )addr & 268173312;
#line 622
    ha->qdr_sn_window = window;
#line 623
    qla82xx_wr_32(ha, ha->ms_win_crb | 100663296UL, (u32 )window);
#line 625
    tmp___2 = qla82xx_rd_32(ha, ha->ms_win_crb | 100663296UL);
#line 625
    win_read = (u32 )tmp___2;
#line 627
    if ((u32 )window != win_read) {
#line 628
      ql_log(1U, vha, 45062, "%s: Written MSwin (0x%x) != Read MSwin (0x%x).\n", "qla82xx_pci_set_window",
             window, win_read);
    } else {

    }
#line 632
    addr = (addr & 262143ULL) + 67108864ULL;
  } else {
#line 638
    tmp___3 = qla82xx_pci_set_window_warning_count;
#line 638
    qla82xx_pci_set_window_warning_count = qla82xx_pci_set_window_warning_count + 1;
#line 638
    if (tmp___3 <= 7 || ((unsigned int )qla82xx_pci_set_window_warning_count & 63U) == 0U) {
#line 640
      ql_log(1U, vha, 45063, "%s: Warning:%s Unknown address range!.\n", "qla82xx_pci_set_window",
             (char *)"qla2xxx");
    } else {

    }
#line 644
    addr = 0xffffffffffffffffULL;
  }
#line 646
  return ((unsigned long )addr);
}
}
#line 650 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_pci_is_same_window(struct qla_hw_data *ha , unsigned long long addr ) 
{ 
  int window ;
  unsigned long long qdr_max ;

  {
#line 656
  qdr_max = 12952010751ULL;
#line 659
  if (addr <= 268435455ULL) {
#line 661
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"),
                         "i" (661), "i" (12UL));
    ldv_66026: ;
#line 661
    goto ldv_66026;
  } else
#line 662
  if (addr <= 8590983167ULL && addr > 8589934591ULL) {
#line 664
    return (1);
  } else
#line 665
  if (addr <= 8595177471ULL && addr > 8594128895ULL) {
#line 667
    return (1);
  } else
#line 668
  if (addr <= qdr_max && addr > 12884901887ULL) {
#line 670
    window = (int )((addr - 12884901888ULL) >> 22) & 63;
#line 671
    if (ha->qdr_sn_window == window) {
#line 672
      return (1);
    } else {

    }
  } else {

  }
#line 674
  return (0);
}
}
#line 677 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_pci_mem_read_direct(struct qla_hw_data *ha , u64 off , void *data ,
                                       int size ) 
{ 
  unsigned long flags ;
  void *addr ;
  int ret ;
  u64 start ;
  uint8_t *mem_ptr ;
  unsigned long mem_base ;
  unsigned long mem_page ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  unsigned long tmp___4 ;

  {
#line 681
  addr = (void *)0;
#line 682
  ret = 0;
#line 684
  mem_ptr = (uint8_t *)0U;
#line 687
  tmp = pci_get_drvdata(ha->pdev);
#line 687
  vha = (scsi_qla_host_t *)tmp;
#line 689
  flags = _raw_write_lock_irqsave(& ha->hw_lock);
#line 695
  tmp___0 = qla82xx_pci_set_window(ha, off);
#line 695
  start = (u64 )tmp___0;
#line 696
  if (start == 0xffffffffffffffffULL) {
#line 698
    _raw_write_unlock_irqrestore(& ha->hw_lock, flags);
#line 699
    ql_log(0U, vha, 45064, "%s out of bound pci memory access, offset is 0x%llx.\n",
           (char *)"qla2xxx", off);
#line 703
    return (-1);
  } else {
#line 696
    tmp___1 = qla82xx_pci_is_same_window(ha, ((u64 )size + off) - 1ULL);
#line 696
    if (tmp___1 == 0) {
#line 698
      _raw_write_unlock_irqrestore(& ha->hw_lock, flags);
#line 699
      ql_log(0U, vha, 45064, "%s out of bound pci memory access, offset is 0x%llx.\n",
             (char *)"qla2xxx", off);
#line 703
      return (-1);
    } else {

    }
  }
#line 706
  _raw_write_unlock_irqrestore(& ha->hw_lock, flags);
#line 707
  mem_base = (unsigned long )(ha->pdev)->resource[0].start;
#line 708
  mem_page = (unsigned long )start & 0xfffffffffffff000UL;
#line 712
  if (((((u64 )size + start) - 1ULL) & 0xfffffffffffff000ULL) != (unsigned long long )mem_page) {
#line 713
    tmp___2 = ioremap((resource_size_t )(mem_base + mem_page), 8192UL);
#line 713
    mem_ptr = (uint8_t *)tmp___2;
  } else {
#line 715
    tmp___3 = ioremap((resource_size_t )(mem_base + mem_page), 4096UL);
#line 715
    mem_ptr = (uint8_t *)tmp___3;
  }
#line 716
  if ((unsigned long )mem_ptr == (unsigned long )((uint8_t *)0U)) {
#line 717
    *((u8 *)data) = 0U;
#line 718
    return (-1);
  } else {

  }
#line 720
  addr = (void *)mem_ptr;
#line 721
  addr = addr + (start & 4095ULL);
#line 722
  flags = _raw_write_lock_irqsave(& ha->hw_lock);
#line 724
  switch (size) {
  case 1: 
#line 726
  *((u8 *)data) = readb((void const volatile   *)addr);
#line 727
  goto ldv_66054;
  case 2: 
#line 729
  *((u16 *)data) = readw((void const volatile   *)addr);
#line 730
  goto ldv_66054;
  case 4: 
#line 732
  *((u32 *)data) = readl((void const volatile   *)addr);
#line 733
  goto ldv_66054;
  case 8: 
#line 735
  tmp___4 = readq((void const volatile   *)addr);
#line 735
  *((u64 *)data) = (u64 )tmp___4;
#line 736
  goto ldv_66054;
  default: 
#line 738
  ret = -1;
#line 739
  goto ldv_66054;
  }
  ldv_66054: 
#line 741
  _raw_write_unlock_irqrestore(& ha->hw_lock, flags);
#line 743
  if ((unsigned long )mem_ptr != (unsigned long )((uint8_t *)0U)) {
#line 744
    iounmap((void volatile   *)mem_ptr);
  } else {

  }
#line 745
  return (ret);
}
}
#line 749 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_pci_mem_write_direct(struct qla_hw_data *ha , u64 off , void *data ,
                                        int size ) 
{ 
  unsigned long flags ;
  void *addr ;
  int ret ;
  u64 start ;
  uint8_t *mem_ptr ;
  unsigned long mem_base ;
  unsigned long mem_page ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 753
  addr = (void *)0;
#line 754
  ret = 0;
#line 756
  mem_ptr = (uint8_t *)0U;
#line 759
  tmp = pci_get_drvdata(ha->pdev);
#line 759
  vha = (scsi_qla_host_t *)tmp;
#line 761
  flags = _raw_write_lock_irqsave(& ha->hw_lock);
#line 767
  tmp___0 = qla82xx_pci_set_window(ha, off);
#line 767
  start = (u64 )tmp___0;
#line 768
  if (start == 0xffffffffffffffffULL) {
#line 770
    _raw_write_unlock_irqrestore(& ha->hw_lock, flags);
#line 771
    ql_log(0U, vha, 45065, "%s out of bount memory access, offset is 0x%llx.\n", (char *)"qla2xxx",
           off);
#line 775
    return (-1);
  } else {
#line 768
    tmp___1 = qla82xx_pci_is_same_window(ha, ((u64 )size + off) - 1ULL);
#line 768
    if (tmp___1 == 0) {
#line 770
      _raw_write_unlock_irqrestore(& ha->hw_lock, flags);
#line 771
      ql_log(0U, vha, 45065, "%s out of bount memory access, offset is 0x%llx.\n",
             (char *)"qla2xxx", off);
#line 775
      return (-1);
    } else {

    }
  }
#line 778
  _raw_write_unlock_irqrestore(& ha->hw_lock, flags);
#line 779
  mem_base = (unsigned long )(ha->pdev)->resource[0].start;
#line 780
  mem_page = (unsigned long )start & 0xfffffffffffff000UL;
#line 784
  if (((((u64 )size + start) - 1ULL) & 0xfffffffffffff000ULL) != (unsigned long long )mem_page) {
#line 785
    tmp___2 = ioremap((resource_size_t )(mem_base + mem_page), 8192UL);
#line 785
    mem_ptr = (uint8_t *)tmp___2;
  } else {
#line 787
    tmp___3 = ioremap((resource_size_t )(mem_base + mem_page), 4096UL);
#line 787
    mem_ptr = (uint8_t *)tmp___3;
  }
#line 788
  if ((unsigned long )mem_ptr == (unsigned long )((uint8_t *)0U)) {
#line 789
    return (-1);
  } else {

  }
#line 791
  addr = (void *)mem_ptr;
#line 792
  addr = addr + (start & 4095ULL);
#line 793
  flags = _raw_write_lock_irqsave(& ha->hw_lock);
#line 795
  switch (size) {
  case 1: 
#line 797
  writeb((int )*((u8 *)data), (void volatile   *)addr);
#line 798
  goto ldv_66089;
  case 2: 
#line 800
  writew((int )*((u16 *)data), (void volatile   *)addr);
#line 801
  goto ldv_66089;
  case 4: 
#line 803
  writel(*((u32 *)data), (void volatile   *)addr);
#line 804
  goto ldv_66089;
  case 8: 
#line 806
  writeq((unsigned long )*((u64 *)data), (void volatile   *)addr);
#line 807
  goto ldv_66089;
  default: 
#line 809
  ret = -1;
#line 810
  goto ldv_66089;
  }
  ldv_66089: 
#line 812
  _raw_write_unlock_irqrestore(& ha->hw_lock, flags);
#line 813
  if ((unsigned long )mem_ptr != (unsigned long )((uint8_t *)0U)) {
#line 814
    iounmap((void volatile   *)mem_ptr);
  } else {

  }
#line 815
  return (ret);
}
}
#line 820 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static unsigned long qla82xx_decode_crb_addr(unsigned long addr ) 
{ 
  int i ;
  unsigned long base_addr ;
  unsigned long offset ;
  unsigned long pci_base ;

  {
#line 825
  if (qla82xx_crb_table_initialized == 0) {
#line 826
    qla82xx_crb_addr_transform_setup();
  } else {

  }
#line 828
  pci_base = 4294967295UL;
#line 829
  base_addr = addr & 4293918720UL;
#line 830
  offset = addr & 1048575UL;
#line 832
  i = 0;
#line 832
  goto ldv_66106;
  ldv_66105: ;
#line 833
  if (crb_addr_xform[i] == base_addr) {
#line 834
    pci_base = (unsigned long )(i << 20);
#line 835
    goto ldv_66104;
  } else {

  }
#line 832
  i = i + 1;
  ldv_66106: ;
#line 832
  if (i <= 59) {
#line 834
    goto ldv_66105;
  } else {

  }
  ldv_66104: ;
#line 838
  if (pci_base == 4294967295UL) {
#line 839
    return (pci_base);
  } else {

  }
#line 840
  return (pci_base + offset);
}
}
#line 843 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static long rom_max_timeout  =    100L;
#line 844 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static long qla82xx_rom_lock_timeout  =    100L;
#line 847 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_rom_lock(struct qla_hw_data *ha ) 
{ 
  int done ;
  int timeout ;
  uint32_t lock_owner ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;

  {
#line 849
  done = 0;
#line 849
  timeout = 0;
#line 850
  lock_owner = 0U;
#line 851
  tmp = pci_get_drvdata(ha->pdev);
#line 851
  vha = (scsi_qla_host_t *)tmp;
#line 853
  goto ldv_66119;
  ldv_66118: 
#line 855
  done = qla82xx_rd_32(ha, 101826576UL);
#line 856
  if (done == 1) {
#line 857
    goto ldv_66116;
  } else {

  }
#line 858
  if ((long )timeout >= qla82xx_rom_lock_timeout) {
#line 859
    tmp___0 = qla82xx_rd_32(ha, 136323328UL);
#line 859
    lock_owner = (uint32_t )tmp___0;
#line 860
    ql_dbg(524288U, vha, 45399, "%s: Simultaneous flash access by following ports, active port = %d: accessing port = %d",
           "qla82xx_rom_lock", (int )ha->portnum, lock_owner);
#line 863
    return (-1);
  } else {

  }
#line 865
  timeout = timeout + 1;
  ldv_66119: ;
#line 853
  if (done == 0) {
#line 855
    goto ldv_66118;
  } else {

  }
  ldv_66116: 
#line 867
  qla82xx_wr_32(ha, 136323328UL, (u32 )ha->portnum);
#line 868
  return (0);
}
}
#line 872 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static void qla82xx_rom_unlock(struct qla_hw_data *ha ) 
{ 


  {
#line 874
  qla82xx_wr_32(ha, 136323328UL, 4294967295U);
#line 875
  qla82xx_rd_32(ha, 101826580UL);
#line 876
  return;
}
}
#line 879 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_wait_rom_busy(struct qla_hw_data *ha ) 
{ 
  long timeout ;
  long done ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;

  {
#line 881
  timeout = 0L;
#line 882
  done = 0L;
#line 883
  tmp = pci_get_drvdata(ha->pdev);
#line 883
  vha = (scsi_qla_host_t *)tmp;
#line 885
  goto ldv_66130;
  ldv_66129: 
#line 886
  tmp___0 = qla82xx_rd_32(ha, 154140676UL);
#line 886
  done = (long )tmp___0;
#line 887
  done = done & 4L;
#line 888
  timeout = timeout + 1L;
#line 889
  if (timeout >= rom_max_timeout) {
#line 890
    ql_dbg(524288U, vha, 45066, "%s: Timeout reached waiting for rom busy.\n", (char *)"qla2xxx");
#line 893
    return (-1);
  } else {

  }
  ldv_66130: ;
#line 885
  if (done == 0L) {
#line 887
    goto ldv_66129;
  } else {

  }

#line 896
  return (0);
}
}
#line 900 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_wait_rom_done(struct qla_hw_data *ha ) 
{ 
  long timeout ;
  long done ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;

  {
#line 902
  timeout = 0L;
#line 903
  done = 0L;
#line 904
  tmp = pci_get_drvdata(ha->pdev);
#line 904
  vha = (scsi_qla_host_t *)tmp;
#line 906
  goto ldv_66139;
  ldv_66138: 
#line 907
  tmp___0 = qla82xx_rd_32(ha, 154140676UL);
#line 907
  done = (long )tmp___0;
#line 908
  done = done & 2L;
#line 909
  timeout = timeout + 1L;
#line 910
  if (timeout >= rom_max_timeout) {
#line 911
    ql_dbg(524288U, vha, 45067, "%s: Timeout reached waiting for rom done.\n", (char *)"qla2xxx");
#line 914
    return (-1);
  } else {

  }
  ldv_66139: ;
#line 906
  if (done == 0L) {
#line 908
    goto ldv_66138;
  } else {

  }

#line 917
  return (0);
}
}
#line 921 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_md_rw_32(struct qla_hw_data *ha , uint32_t off , u32 data , uint8_t flag ) 
{ 
  uint32_t off_value ;
  uint32_t rval ;

  {
#line 923
  rval = 0U;
#line 925
  writel(off & 4294901760U, (void volatile   *)(ha->nx_pcibase + 1245280UL));
#line 929
  readl((void const volatile   *)(ha->nx_pcibase + 1245280UL));
#line 930
  off_value = off & 65535U;
#line 932
  if ((unsigned int )flag != 0U) {
#line 933
    writel(data, (void volatile   *)(((unsigned long )off_value + ha->nx_pcibase) + 1966080UL));
  } else {
#line 937
    rval = readl((void const volatile   *)(((unsigned long )off_value + ha->nx_pcibase) + 1966080UL));
  }
#line 940
  return ((int )rval);
}
}
#line 944 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_do_rom_fast_read(struct qla_hw_data *ha , int addr , int *valp ) 
{ 


  {
#line 947
  qla82xx_md_rw_32(ha, 1108410416U, (unsigned int )addr & 4294901760U, 1);
#line 948
  *valp = qla82xx_md_rw_32(ha, (uint32_t )((addr & 65535) + 1108672512), 0U, 0);
#line 951
  return (0);
}
}
#line 955 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_rom_fast_read(struct qla_hw_data *ha , int addr , int *valp ) 
{ 
  int ret ;
  int loops ;
  uint32_t lock_owner ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 957
  loops = 0;
#line 958
  lock_owner = 0U;
#line 959
  tmp = pci_get_drvdata(ha->pdev);
#line 959
  vha = (scsi_qla_host_t *)tmp;
#line 961
  goto ldv_66164;
  ldv_66163: 
#line 962
  __const_udelay(429500UL);
#line 963
  schedule();
#line 964
  loops = loops + 1;
  ldv_66164: 
#line 961
  tmp___0 = qla82xx_rom_lock(ha);
#line 961
  if (tmp___0 != 0 && loops <= 49999) {
#line 963
    goto ldv_66163;
  } else {

  }

#line 966
  if (loops > 49999) {
#line 967
    tmp___1 = qla82xx_rd_32(ha, 136323328UL);
#line 967
    lock_owner = (uint32_t )tmp___1;
#line 968
    ql_log(0U, vha, 185, "Failed to acquire SEM2 lock, Lock Owner %u.\n", lock_owner);
#line 971
    return (-1);
  } else {

  }
#line 973
  ret = qla82xx_do_rom_fast_read(ha, addr, valp);
#line 974
  qla82xx_rom_unlock(ha);
#line 975
  return (ret);
}
}
#line 979 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_read_status_reg(struct qla_hw_data *ha , uint32_t *val ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 981
  tmp = pci_get_drvdata(ha->pdev);
#line 981
  vha = (scsi_qla_host_t *)tmp;
#line 982
  qla82xx_wr_32(ha, 154206212UL, 5U);
#line 983
  qla82xx_wait_rom_busy(ha);
#line 984
  tmp___0 = qla82xx_wait_rom_done(ha);
#line 984
  if (tmp___0 != 0) {
#line 985
    ql_log(1U, vha, 45068, "Error waiting for rom done.\n");
#line 987
    return (-1);
  } else {

  }
#line 989
  tmp___1 = qla82xx_rd_32(ha, 154206232UL);
#line 989
  *val = (uint32_t )tmp___1;
#line 990
  return (0);
}
}
#line 994 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_flash_wait_write_finish(struct qla_hw_data *ha ) 
{ 
  long timeout ;
  uint32_t done ;
  uint32_t val ;
  int ret ;
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 996
  timeout = 0L;
#line 997
  done = 1U;
#line 999
  ret = 0;
#line 1000
  tmp = pci_get_drvdata(ha->pdev);
#line 1000
  vha = (scsi_qla_host_t *)tmp;
#line 1002
  qla82xx_wr_32(ha, 154206224UL, 0U);
#line 1003
  goto ldv_66181;
  ldv_66180: 
#line 1004
  ret = qla82xx_read_status_reg(ha, & val);
#line 1005
  done = val & 1U;
#line 1006
  timeout = timeout + 1L;
#line 1007
  __const_udelay(42950UL);
#line 1008
  ___might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c",
                 1008, 0);
#line 1008
  _cond_resched();
#line 1009
  if (timeout > 49999L) {
#line 1010
    ql_log(1U, vha, 45069, "Timeout reached waiting for write finish.\n");
#line 1012
    return (-1);
  } else {

  }
  ldv_66181: ;
#line 1003
  if (done != 0U && ret == 0) {
#line 1005
    goto ldv_66180;
  } else {

  }

#line 1015
  return (ret);
}
}
#line 1019 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_flash_set_write_enable(struct qla_hw_data *ha ) 
{ 
  uint32_t val ;
  int tmp ;
  int tmp___0 ;

  {
#line 1022
  qla82xx_wait_rom_busy(ha);
#line 1023
  qla82xx_wr_32(ha, 154206224UL, 0U);
#line 1024
  qla82xx_wr_32(ha, 154206212UL, 6U);
#line 1025
  qla82xx_wait_rom_busy(ha);
#line 1026
  tmp = qla82xx_wait_rom_done(ha);
#line 1026
  if (tmp != 0) {
#line 1027
    return (-1);
  } else {

  }
#line 1028
  tmp___0 = qla82xx_read_status_reg(ha, & val);
#line 1028
  if (tmp___0 != 0) {
#line 1029
    return (-1);
  } else {

  }
#line 1030
  if ((val & 2U) == 0U) {
#line 1031
    return (-1);
  } else {

  }
#line 1032
  return (0);
}
}
#line 1036 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_write_status_reg(struct qla_hw_data *ha , uint32_t val ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1038
  tmp = pci_get_drvdata(ha->pdev);
#line 1038
  vha = (scsi_qla_host_t *)tmp;
#line 1039
  tmp___0 = qla82xx_flash_set_write_enable(ha);
#line 1039
  if (tmp___0 != 0) {
#line 1040
    return (-1);
  } else {

  }
#line 1041
  qla82xx_wr_32(ha, 154206220UL, val);
#line 1042
  qla82xx_wr_32(ha, 154206212UL, 1U);
#line 1043
  tmp___1 = qla82xx_wait_rom_done(ha);
#line 1043
  if (tmp___1 != 0) {
#line 1044
    ql_log(1U, vha, 45070, "Error waiting for rom done.\n");
#line 1046
    return (-1);
  } else {

  }
#line 1048
  tmp___2 = qla82xx_flash_wait_write_finish(ha);
#line 1048
  return (tmp___2);
}
}
#line 1052 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_write_disable_flash(struct qla_hw_data *ha ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1054
  tmp = pci_get_drvdata(ha->pdev);
#line 1054
  vha = (scsi_qla_host_t *)tmp;
#line 1055
  qla82xx_wr_32(ha, 154206212UL, 4U);
#line 1056
  tmp___0 = qla82xx_wait_rom_done(ha);
#line 1056
  if (tmp___0 != 0) {
#line 1057
    ql_log(1U, vha, 45071, "Error waiting for rom done.\n");
#line 1059
    return (-1);
  } else {

  }
#line 1061
  return (0);
}
}
#line 1065 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int ql82xx_rom_lock_d(struct qla_hw_data *ha ) 
{ 
  int loops ;
  uint32_t lock_owner ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1067
  loops = 0;
#line 1068
  lock_owner = 0U;
#line 1069
  tmp = pci_get_drvdata(ha->pdev);
#line 1069
  vha = (scsi_qla_host_t *)tmp;
#line 1071
  goto ldv_66204;
  ldv_66203: 
#line 1072
  __const_udelay(429500UL);
#line 1073
  ___might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c",
                 1073, 0);
#line 1073
  _cond_resched();
#line 1074
  loops = loops + 1;
  ldv_66204: 
#line 1071
  tmp___0 = qla82xx_rom_lock(ha);
#line 1071
  if (tmp___0 != 0 && loops <= 49999) {
#line 1073
    goto ldv_66203;
  } else {

  }

#line 1076
  if (loops > 49999) {
#line 1077
    tmp___1 = qla82xx_rd_32(ha, 136323328UL);
#line 1077
    lock_owner = (uint32_t )tmp___1;
#line 1078
    ql_log(1U, vha, 45072, "ROM lock failed, Lock Owner %u.\n", lock_owner);
#line 1080
    return (-1);
  } else {

  }
#line 1082
  return (0);
}
}
#line 1086 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_write_flash_dword(struct qla_hw_data *ha , uint32_t flashaddr ,
                                     uint32_t data ) 
{ 
  int ret ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1089
  ret = 0;
#line 1090
  tmp = pci_get_drvdata(ha->pdev);
#line 1090
  vha = (scsi_qla_host_t *)tmp;
#line 1092
  ret = ql82xx_rom_lock_d(ha);
#line 1093
  if (ret < 0) {
#line 1094
    ql_log(1U, vha, 45073, "ROM lock failed.\n");
#line 1096
    return (ret);
  } else {

  }
#line 1099
  tmp___0 = qla82xx_flash_set_write_enable(ha);
#line 1099
  if (tmp___0 != 0) {
#line 1100
    goto done_write;
  } else {

  }
#line 1102
  qla82xx_wr_32(ha, 154206220UL, data);
#line 1103
  qla82xx_wr_32(ha, 154206216UL, flashaddr);
#line 1104
  qla82xx_wr_32(ha, 154206224UL, 3U);
#line 1105
  qla82xx_wr_32(ha, 154206212UL, 2U);
#line 1106
  qla82xx_wait_rom_busy(ha);
#line 1107
  tmp___1 = qla82xx_wait_rom_done(ha);
#line 1107
  if (tmp___1 != 0) {
#line 1108
    ql_log(1U, vha, 45074, "Error waiting for rom done.\n");
#line 1110
    ret = -1;
#line 1111
    goto done_write;
  } else {

  }
#line 1114
  ret = qla82xx_flash_wait_write_finish(ha);
  done_write: 
#line 1117
  qla82xx_rom_unlock(ha);
#line 1118
  return (ret);
}
}
#line 1125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_pinit_from_rom(scsi_qla_host_t *vha ) 
{ 
  int addr ;
  int val ;
  int i ;
  struct crb_addr_pair *buf ;
  unsigned long off ;
  unsigned int offset ;
  unsigned int n ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;

  {
#line 1132
  ha = vha->hw;
#line 1140
  qla82xx_rom_lock(ha);
#line 1143
  qla82xx_wr_32(ha, 153092112UL, 0U);
#line 1144
  qla82xx_wr_32(ha, 153092116UL, 0U);
#line 1145
  qla82xx_wr_32(ha, 153092120UL, 0U);
#line 1146
  qla82xx_wr_32(ha, 153092124UL, 0U);
#line 1147
  qla82xx_wr_32(ha, 153092128UL, 0U);
#line 1148
  qla82xx_wr_32(ha, 153092132UL, 0U);
#line 1151
  qla82xx_wr_32(ha, 106954816UL, 255U);
#line 1153
  qla82xx_wr_32(ha, 107413504UL, 0U);
#line 1155
  qla82xx_wr_32(ha, 107479040UL, 0U);
#line 1157
  qla82xx_wr_32(ha, 107544576UL, 0U);
#line 1159
  qla82xx_wr_32(ha, 107610112UL, 0U);
#line 1161
  qla82xx_wr_32(ha, 107675648UL, 0U);
#line 1164
  val = qla82xx_rd_32(ha, 105910272UL);
#line 1165
  qla82xx_wr_32(ha, 105910272UL, (u32 )val & 4294967294U);
#line 1168
  qla82xx_wr_32(ha, 133174016UL, 1U);
#line 1171
  qla82xx_wr_32(ha, 142606336UL, 0U);
#line 1172
  qla82xx_wr_32(ha, 142606344UL, 0U);
#line 1173
  qla82xx_wr_32(ha, 142606352UL, 0U);
#line 1174
  qla82xx_wr_32(ha, 142606360UL, 0U);
#line 1175
  qla82xx_wr_32(ha, 142606592UL, 0U);
#line 1176
  qla82xx_wr_32(ha, 142606848UL, 0U);
#line 1179
  qla82xx_wr_32(ha, 118489148UL, 1U);
#line 1180
  qla82xx_wr_32(ha, 119537724UL, 1U);
#line 1181
  qla82xx_wr_32(ha, 120586300UL, 1U);
#line 1182
  qla82xx_wr_32(ha, 121634876UL, 1U);
#line 1183
  qla82xx_wr_32(ha, 116391996UL, 1U);
#line 1184
  msleep(20U);
#line 1187
  tmp = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1187
  if (tmp != 0) {
#line 1189
    qla82xx_wr_32(ha, 154140680UL, 4278190079U);
  } else {
#line 1191
    qla82xx_wr_32(ha, 154140680UL, 4294967295U);
  }
#line 1192
  qla82xx_rom_unlock(ha);
#line 1199
  tmp___0 = qla82xx_rom_fast_read(ha, 0, (int *)(& n));
#line 1199
  if (tmp___0 != 0 || n != 3405695742U) {
#line 1201
    ql_log(0U, vha, 110, "Error Reading crb_init area: n: %08x.\n", n);
#line 1203
    return (-1);
  } else {
#line 1199
    tmp___1 = qla82xx_rom_fast_read(ha, 4, (int *)(& n));
#line 1199
    if (tmp___1 != 0) {
#line 1201
      ql_log(0U, vha, 110, "Error Reading crb_init area: n: %08x.\n", n);
#line 1203
      return (-1);
    } else {

    }
  }
#line 1209
  offset = n & 65535U;
#line 1210
  n = n >> 16;
#line 1213
  if (n > 1023U) {
#line 1214
    ql_log(0U, vha, 113, "Card flash not initialized:n=0x%x.\n", n);
#line 1216
    return (-1);
  } else {

  }
#line 1219
  ql_log(2U, vha, 114, "%d CRB init values found in ROM.\n", n);
#line 1222
  tmp___2 = kmalloc((unsigned long )n * 16UL, 208U);
#line 1222
  buf = (struct crb_addr_pair___0 *)tmp___2;
#line 1223
  if ((unsigned long )buf == (unsigned long )((struct crb_addr_pair___0 *)0)) {
#line 1224
    ql_log(0U, vha, 268, "Unable to allocate memory.\n");
#line 1226
    return (-1);
  } else {

  }
#line 1229
  i = 0;
#line 1229
  goto ldv_66229;
  ldv_66228: 
#line 1230
  tmp___3 = qla82xx_rom_fast_read(ha, (int )(((unsigned int )(i * 2) + offset) * 4U),
                                  & val);
#line 1230
  if (tmp___3 != 0) {
#line 1232
    kfree((void const   *)buf);
#line 1233
    return (-1);
  } else {
#line 1230
    tmp___4 = qla82xx_rom_fast_read(ha, (int )((((unsigned int )(i * 2) + offset) + 1U) * 4U),
                                    & addr);
#line 1230
    if (tmp___4 != 0) {
#line 1232
      kfree((void const   *)buf);
#line 1233
      return (-1);
    } else {

    }
  }
#line 1236
  (buf + (unsigned long )i)->addr = (long )addr;
#line 1237
  (buf + (unsigned long )i)->data = (long )val;
#line 1229
  i = i + 1;
  ldv_66229: ;
#line 1229
  if ((unsigned int )i < n) {
#line 1231
    goto ldv_66228;
  } else {

  }
#line 1240
  i = 0;
#line 1240
  goto ldv_66233;
  ldv_66232: 
#line 1244
  tmp___5 = qla82xx_decode_crb_addr((unsigned long )(buf + (unsigned long )i)->addr);
#line 1244
  off = tmp___5 + 100663296UL;
#line 1251
  if (off == 136323580UL) {
#line 1252
    goto ldv_66231;
  } else {

  }
#line 1255
  if (off == 154140860UL) {
#line 1256
    goto ldv_66231;
  } else {

  }
#line 1259
  if (off == 154140872UL) {
#line 1260
    goto ldv_66231;
  } else {

  }
#line 1263
  if (off == 101785664UL) {
#line 1264
    goto ldv_66231;
  } else {

  }
#line 1266
  if (off == 101785672UL) {
#line 1267
    goto ldv_66231;
  } else {

  }
#line 1269
  if ((off & 267386880UL) == 161480704UL) {
#line 1270
    goto ldv_66231;
  } else {

  }
#line 1272
  if ((off & 267386880UL) == 102760448UL) {
#line 1273
    goto ldv_66231;
  } else {

  }
#line 1275
  if (off == 4294967295UL) {
#line 1276
    ql_log(0U, vha, 278, "Unknown addr: 0x%08lx.\n", (buf + (unsigned long )i)->addr);
#line 1278
    goto ldv_66231;
  } else {

  }
#line 1281
  qla82xx_wr_32(ha, off, (u32 )(buf + (unsigned long )i)->data);
#line 1286
  if (off == 154140680UL) {
#line 1287
    msleep(1000U);
  } else {

  }
#line 1292
  msleep(1U);
  ldv_66231: 
#line 1240
  i = i + 1;
  ldv_66233: ;
#line 1240
  if ((unsigned int )i < n) {
#line 1242
    goto ldv_66232;
  } else {

  }
#line 1295
  kfree((void const   *)buf);
#line 1298
  qla82xx_wr_32(ha, 122683628UL, 30U);
#line 1299
  qla82xx_wr_32(ha, 122683468UL, 8U);
#line 1300
  qla82xx_wr_32(ha, 123732044UL, 8U);
#line 1303
  qla82xx_wr_32(ha, 118489096UL, 0U);
#line 1304
  qla82xx_wr_32(ha, 118489100UL, 0U);
#line 1305
  qla82xx_wr_32(ha, 119537672UL, 0U);
#line 1306
  qla82xx_wr_32(ha, 119537676UL, 0U);
#line 1307
  qla82xx_wr_32(ha, 120586248UL, 0U);
#line 1308
  qla82xx_wr_32(ha, 120586252UL, 0U);
#line 1309
  qla82xx_wr_32(ha, 121634824UL, 0U);
#line 1310
  qla82xx_wr_32(ha, 121634828UL, 0U);
#line 1311
  return (0);
}
}
#line 1315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_pci_mem_write_2M(struct qla_hw_data *ha , u64 off , void *data ,
                                    int size ) 
{ 
  int i ;
  int j ;
  int ret ;
  int loop ;
  int sz[2U] ;
  int off0 ;
  int scale ;
  int shift_amount ;
  int startword ;
  uint32_t temp ;
  uint64_t off8 ;
  uint64_t mem_crb ;
  uint64_t tmpw ;
  uint64_t word[2U] ;
  int tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1318
  ret = 0;
#line 1321
  word[0] = 0ULL;
#line 1321
  word[1] = 0ULL;
#line 1326
  if (off > 12884901887ULL && off <= 12952010751ULL) {
#line 1327
    mem_crb = 131072000ULL;
  } else {
#line 1329
    mem_crb = 102760448ULL;
#line 1330
    tmp___0 = qla82xx_pci_mem_bound_check(ha, off, size);
#line 1330
    if (tmp___0 == 0UL) {
#line 1331
      tmp = qla82xx_pci_mem_write_direct(ha, off, data, size);
#line 1331
      return (tmp);
    } else {

    }
  }
#line 1335
  off0 = (int )off & 7;
#line 1336
  sz[0] = size < 8 - off0 ? size : 8 - off0;
#line 1337
  sz[1] = size - sz[0];
#line 1339
  off8 = off & 4294967280ULL;
#line 1340
  loop = (int )((unsigned int )((((off & 15ULL) + (u64 )size) - 1ULL) >> 4) + 1U);
#line 1341
  shift_amount = 4;
#line 1342
  scale = 2;
#line 1343
  startword = (int )((off & 15ULL) / 8ULL);
#line 1345
  i = 0;
#line 1345
  goto ldv_66256;
  ldv_66255: 
#line 1346
  tmp___1 = qla82xx_pci_mem_read_2M(ha, (uint64_t )(i << shift_amount) + off8, (void *)(& word) + (unsigned long )(i * scale),
                                    8);
#line 1346
  if (tmp___1 != 0) {
#line 1348
    return (-1);
  } else {

  }
#line 1345
  i = i + 1;
  ldv_66256: ;
#line 1345
  if (i < loop) {
#line 1347
    goto ldv_66255;
  } else {

  }

#line 1351
  switch (size) {
  case 1: 
#line 1353
  tmpw = (uint64_t )*((uint8_t *)data);
#line 1354
  goto ldv_66259;
  case 2: 
#line 1356
  tmpw = (uint64_t )*((uint16_t *)data);
#line 1357
  goto ldv_66259;
  case 4: 
#line 1359
  tmpw = (uint64_t )*((uint32_t *)data);
#line 1360
  goto ldv_66259;
  case 8: ;
  default: 
#line 1363
  tmpw = *((uint64_t *)data);
#line 1364
  goto ldv_66259;
  }
  ldv_66259: ;
#line 1367
  if (sz[0] == 8) {
#line 1368
    word[startword] = tmpw;
  } else {
#line 1370
    word[startword] = word[startword] & ~ (~ (0xffffffffffffffffULL << sz[0] * 8) << off0 * 8);
#line 1372
    word[startword] = word[startword] | (tmpw << off0 * 8);
  }
#line 1374
  if (sz[1] != 0) {
#line 1375
    word[startword + 1] = word[startword + 1] & ~ (0xffffffffffffffffULL << sz[1] * 8);
#line 1376
    word[startword + 1] = word[startword + 1] | (tmpw >> sz[0] * 8);
  } else {

  }
#line 1379
  i = 0;
#line 1379
  goto ldv_66270;
  ldv_66269: 
#line 1380
  temp = (uint32_t )(i << shift_amount) + (uint32_t )off8;
#line 1381
  qla82xx_wr_32(ha, (ulong )(mem_crb + 148ULL), temp);
#line 1382
  temp = 0U;
#line 1383
  qla82xx_wr_32(ha, (ulong )(mem_crb + 152ULL), temp);
#line 1384
  temp = (uint32_t )word[i * scale];
#line 1385
  qla82xx_wr_32(ha, (ulong )(mem_crb + 160ULL), temp);
#line 1386
  temp = (uint32_t )(word[i * scale] >> 32);
#line 1387
  qla82xx_wr_32(ha, (ulong )(mem_crb + 164ULL), temp);
#line 1388
  temp = (uint32_t )word[i * scale + 1];
#line 1389
  qla82xx_wr_32(ha, (ulong )(mem_crb + 176ULL), temp);
#line 1391
  temp = (uint32_t )(word[i * scale + 1] >> 32);
#line 1392
  qla82xx_wr_32(ha, (ulong )(mem_crb + 180ULL), temp);
#line 1395
  temp = 6U;
#line 1396
  qla82xx_wr_32(ha, (ulong )(mem_crb + 144ULL), temp);
#line 1397
  temp = 7U;
#line 1398
  qla82xx_wr_32(ha, (ulong )(mem_crb + 144ULL), temp);
#line 1400
  j = 0;
#line 1400
  goto ldv_66266;
  ldv_66265: 
#line 1401
  tmp___2 = qla82xx_rd_32(ha, (ulong )(mem_crb + 144ULL));
#line 1401
  temp = (uint32_t )tmp___2;
#line 1402
  if ((temp & 8U) == 0U) {
#line 1403
    goto ldv_66264;
  } else {

  }
#line 1400
  j = j + 1;
  ldv_66266: ;
#line 1400
  if (j <= 999) {
#line 1402
    goto ldv_66265;
  } else {

  }
  ldv_66264: ;
#line 1406
  if (j > 999) {
#line 1407
    tmp___3 = __printk_ratelimit("qla82xx_pci_mem_write_2M");
#line 1407
    if (tmp___3 != 0) {
#line 1408
      dev_err((struct device  const  *)(& (ha->pdev)->dev), "failed to write through agent.\n");
    } else {

    }
#line 1410
    ret = -1;
#line 1411
    goto ldv_66268;
  } else {

  }
#line 1379
  i = i + 1;
  ldv_66270: ;
#line 1379
  if (i < loop) {
#line 1381
    goto ldv_66269;
  } else {

  }
  ldv_66268: ;
#line 1415
  return (ret);
}
}
#line 1419 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_fw_load_from_flash(struct qla_hw_data *ha ) 
{ 
  int i ;
  long size ;
  long flashaddr ;
  long memaddr ;
  u64 data ;
  u32 high ;
  u32 low ;
  int tmp ;
  int tmp___0 ;

  {
#line 1422
  size = 0L;
#line 1423
  flashaddr = (long )(ha->flt_region_bootload << 2);
#line 1424
  memaddr = 65536L;
#line 1427
  size = 122880L;
#line 1429
  i = 0;
#line 1429
  goto ldv_66282;
  ldv_66281: 
#line 1430
  tmp = qla82xx_rom_fast_read(ha, (int )flashaddr, (int *)(& low));
#line 1430
  if (tmp != 0) {
#line 1432
    return (-1);
  } else {
#line 1430
    tmp___0 = qla82xx_rom_fast_read(ha, (int )((unsigned int )flashaddr + 4U), (int *)(& high));
#line 1430
    if (tmp___0 != 0) {
#line 1432
      return (-1);
    } else {

    }
  }
#line 1434
  data = ((unsigned long long )high << 32) | (unsigned long long )low;
#line 1435
  qla82xx_pci_mem_write_2M(ha, (u64 )memaddr, (void *)(& data), 8);
#line 1436
  flashaddr = flashaddr + 8L;
#line 1437
  memaddr = memaddr + 8L;
#line 1439
  if (((unsigned int )i & 4095U) == 0U) {
#line 1440
    msleep(1U);
  } else {

  }
#line 1429
  i = i + 1;
  ldv_66282: ;
#line 1429
  if ((long )i < size) {
#line 1431
    goto ldv_66281;
  } else {

  }
#line 1442
  __const_udelay(429500UL);
#line 1443
  _raw_read_lock(& ha->hw_lock);
#line 1444
  qla82xx_wr_32(ha, 118489112UL, 4128U);
#line 1445
  qla82xx_wr_32(ha, 154140680UL, 8388638U);
#line 1446
  _raw_read_unlock(& ha->hw_lock);
#line 1447
  return (0);
}
}
#line 1451 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
int qla82xx_pci_mem_read_2M(struct qla_hw_data *ha , u64 off , void *data , int size ) 
{ 
  int i ;
  int j ;
  int k ;
  int start ;
  int end ;
  int loop ;
  int sz[2U] ;
  int off0[2U] ;
  int shift_amount ;
  uint32_t temp ;
  uint64_t off8 ;
  uint64_t val ;
  uint64_t mem_crb ;
  uint64_t word[2U] ;
  int tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1454
  j = 0;
#line 1457
  word[0] = 0ULL;
#line 1457
  word[1] = 0ULL;
#line 1463
  if (off > 12884901887ULL && off <= 12952010751ULL) {
#line 1464
    mem_crb = 131072000ULL;
  } else {
#line 1466
    mem_crb = 102760448ULL;
#line 1467
    tmp___0 = qla82xx_pci_mem_bound_check(ha, off, size);
#line 1467
    if (tmp___0 == 0UL) {
#line 1468
      tmp = qla82xx_pci_mem_read_direct(ha, off, data, size);
#line 1468
      return (tmp);
    } else {

    }
  }
#line 1472
  off8 = off & 4294967280ULL;
#line 1473
  off0[0] = (int )off & 15;
#line 1474
  sz[0] = size < 16 - off0[0] ? size : 16 - off0[0];
#line 1475
  shift_amount = 4;
#line 1476
  loop = (((off0[0] + size) + -1) >> shift_amount) + 1;
#line 1477
  off0[1] = 0;
#line 1478
  sz[1] = size - sz[0];
#line 1480
  i = 0;
#line 1480
  goto ldv_66313;
  ldv_66312: 
#line 1481
  temp = (uint32_t )(i << shift_amount) + (uint32_t )off8;
#line 1482
  qla82xx_wr_32(ha, (ulong )(mem_crb + 148ULL), temp);
#line 1483
  temp = 0U;
#line 1484
  qla82xx_wr_32(ha, (ulong )(mem_crb + 152ULL), temp);
#line 1485
  temp = 2U;
#line 1486
  qla82xx_wr_32(ha, (ulong )(mem_crb + 144ULL), temp);
#line 1487
  temp = 3U;
#line 1488
  qla82xx_wr_32(ha, (ulong )(mem_crb + 144ULL), temp);
#line 1490
  j = 0;
#line 1490
  goto ldv_66306;
  ldv_66305: 
#line 1491
  tmp___1 = qla82xx_rd_32(ha, (ulong )(mem_crb + 144ULL));
#line 1491
  temp = (uint32_t )tmp___1;
#line 1492
  if ((temp & 8U) == 0U) {
#line 1493
    goto ldv_66304;
  } else {

  }
#line 1490
  j = j + 1;
  ldv_66306: ;
#line 1490
  if (j <= 999) {
#line 1492
    goto ldv_66305;
  } else {

  }
  ldv_66304: ;
#line 1496
  if (j > 999) {
#line 1497
    tmp___2 = __printk_ratelimit("qla82xx_pci_mem_read_2M");
#line 1497
    if (tmp___2 != 0) {
#line 1498
      dev_err((struct device  const  *)(& (ha->pdev)->dev), "failed to read through agent.\n");
    } else {

    }
#line 1500
    goto ldv_66308;
  } else {

  }
#line 1503
  start = off0[i] >> 2;
#line 1504
  end = ((off0[i] + sz[i]) + -1) >> 2;
#line 1505
  k = start;
#line 1505
  goto ldv_66310;
  ldv_66309: 
#line 1506
  tmp___3 = qla82xx_rd_32(ha, (ulong )((uint64_t )((k + 42) * 4) + mem_crb));
#line 1506
  temp = (uint32_t )tmp___3;
#line 1508
  word[i] = word[i] | ((unsigned long long )temp << (k & 1) * 32);
#line 1505
  k = k + 1;
  ldv_66310: ;
#line 1505
  if (k <= end) {
#line 1507
    goto ldv_66309;
  } else {

  }
#line 1480
  i = i + 1;
  ldv_66313: ;
#line 1480
  if (i < loop) {
#line 1482
    goto ldv_66312;
  } else {

  }
  ldv_66308: ;
#line 1512
  if (j > 999) {
#line 1513
    return (-1);
  } else {

  }
#line 1515
  if ((off0[0] & 7) == 0) {
#line 1516
    val = word[0];
  } else {
#line 1518
    val = ((word[0] >> off0[0] * 8) & ~ (0xffffffffffffffffULL << sz[0] * 8)) | ((word[1] & ~ (0xffffffffffffffffULL << sz[1] * 8)) << sz[0] * 8);
  }
#line 1522
  switch (size) {
  case 1: 
#line 1524
  *((uint8_t *)data) = (uint8_t )val;
#line 1525
  goto ldv_66315;
  case 2: 
#line 1527
  *((uint16_t *)data) = (uint16_t )val;
#line 1528
  goto ldv_66315;
  case 4: 
#line 1530
  *((uint32_t *)data) = (uint32_t )val;
#line 1531
  goto ldv_66315;
  case 8: 
#line 1533
  *((uint64_t *)data) = val;
#line 1534
  goto ldv_66315;
  }
  ldv_66315: ;
#line 1536
  return (0);
}
}
#line 1541 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static struct qla82xx_uri_table_desc *qla82xx_get_table_desc(u8 const   *unirom ,
                                                             int section ) 
{ 
  uint32_t i ;
  struct qla82xx_uri_table_desc *directory ;
  __le32 offset ;
  __le32 tab_type ;
  __le32 entries ;

  {
#line 1544
  directory = (struct qla82xx_uri_table_desc *)unirom;
#line 1548
  entries = directory->num_entries;
#line 1550
  i = 0U;
#line 1550
  goto ldv_66329;
  ldv_66328: 
#line 1551
  offset = directory->findex + directory->entry_size * i;
#line 1553
  tab_type = *((u32 *)unirom + ((unsigned long )offset + 8UL));
#line 1555
  if ((__le32 )section == tab_type) {
#line 1556
    return ((struct qla82xx_uri_table_desc *)unirom + (unsigned long )offset);
  } else {

  }
#line 1550
  i = i + 1U;
  ldv_66329: ;
#line 1550
  if (i < entries) {
#line 1552
    goto ldv_66328;
  } else {

  }

#line 1559
  return ((struct qla82xx_uri_table_desc *)0);
}
}
#line 1563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static struct qla82xx_uri_data_desc *qla82xx_get_data_desc(struct qla_hw_data *ha ,
                                                           u32 section , u32 idx_offset ) 
{ 
  u8 const   *unirom ;
  int idx ;
  struct qla82xx_uri_table_desc *tab_desc ;
  __le32 offset ;

  {
#line 1566
  unirom = ((ha->hablob)->fw)->data;
#line 1567
  idx = *((int *)unirom + ((unsigned long )ha->file_prd_off + (unsigned long )idx_offset));
#line 1568
  tab_desc = (struct qla82xx_uri_table_desc *)0;
#line 1571
  tab_desc = qla82xx_get_table_desc(unirom, (int )section);
#line 1572
  if ((unsigned long )tab_desc == (unsigned long )((struct qla82xx_uri_table_desc *)0)) {
#line 1573
    return ((struct qla82xx_uri_data_desc *)0);
  } else {

  }
#line 1575
  offset = tab_desc->findex + tab_desc->entry_size * (uint32_t )idx;
#line 1578
  return ((struct qla82xx_uri_data_desc *)unirom + (unsigned long )offset);
}
}
#line 1582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static u8 *qla82xx_get_bootld_offset(struct qla_hw_data *ha ) 
{ 
  u32 offset ;
  struct qla82xx_uri_data_desc *uri_desc ;

  {
#line 1584
  offset = 65536U;
#line 1585
  uri_desc = (struct qla82xx_uri_data_desc *)0;
#line 1587
  if ((unsigned int )ha->fw_type == 3U) {
#line 1588
    uri_desc = qla82xx_get_data_desc(ha, 6U, 27U);
#line 1590
    if ((unsigned long )uri_desc != (unsigned long )((struct qla82xx_uri_data_desc *)0)) {
#line 1591
      offset = uri_desc->findex;
    } else {

    }
  } else {

  }
#line 1594
  return ((u8 *)((ha->hablob)->fw)->data + (unsigned long )offset);
}
}
#line 1598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static __le32 qla82xx_get_fw_size(struct qla_hw_data *ha ) 
{ 
  struct qla82xx_uri_data_desc *uri_desc ;

  {
#line 1600
  uri_desc = (struct qla82xx_uri_data_desc *)0;
#line 1602
  if ((unsigned int )ha->fw_type == 3U) {
#line 1603
    uri_desc = qla82xx_get_data_desc(ha, 7U, 29U);
#line 1605
    if ((unsigned long )uri_desc != (unsigned long )((struct qla82xx_uri_data_desc *)0)) {
#line 1606
      return (uri_desc->size);
    } else {

    }
  } else {

  }
#line 1609
  return (*((u32 *)((ha->hablob)->fw)->data + 4097036U));
}
}
#line 1613 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static u8 *qla82xx_get_fw_offs(struct qla_hw_data *ha ) 
{ 
  u32 offset ;
  struct qla82xx_uri_data_desc *uri_desc ;

  {
#line 1615
  offset = 1048576U;
#line 1616
  uri_desc = (struct qla82xx_uri_data_desc *)0;
#line 1618
  if ((unsigned int )ha->fw_type == 3U) {
#line 1619
    uri_desc = qla82xx_get_data_desc(ha, 7U, 29U);
#line 1621
    if ((unsigned long )uri_desc != (unsigned long )((struct qla82xx_uri_data_desc *)0)) {
#line 1622
      offset = uri_desc->findex;
    } else {

    }
  } else {

  }
#line 1625
  return ((u8 *)((ha->hablob)->fw)->data + (unsigned long )offset);
}
}
#line 1629 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
int qla82xx_pci_region_offset(struct pci_dev *pdev , int region ) 
{ 
  unsigned long val ;
  u32 control ;

  {
#line 1631
  val = 0UL;
#line 1634
  switch (region) {
  case 0: 
#line 1636
  val = 0UL;
#line 1637
  goto ldv_66361;
  case 1: 
#line 1639
  pci_read_config_dword((struct pci_dev  const  *)pdev, 68, & control);
#line 1640
  val = (unsigned long )(control + 8192U);
#line 1641
  goto ldv_66361;
  }
  ldv_66361: ;
#line 1643
  return ((int )val);
}
}
#line 1648 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
int qla82xx_iospace_config(struct qla_hw_data *ha ) 
{ 
  uint32_t len ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  uint8_t tmp___2 ;

  {
#line 1650
  len = 0U;
#line 1652
  tmp = pci_request_regions(ha->pdev, "qla2xxx");
#line 1652
  if (tmp != 0) {
#line 1653
    ql_log_pci(0U, ha->pdev, 12, "Failed to reserver selected regions.\n");
#line 1655
    goto iospace_error_exit;
  } else {

  }
#line 1659
  if (((ha->pdev)->resource[0].flags & 512UL) == 0UL) {
#line 1660
    ql_log_pci(0U, ha->pdev, 13, "Region #0 not an MMIO resource, aborting.\n");
#line 1662
    goto iospace_error_exit;
  } else {

  }
#line 1665
  len = (ha->pdev)->resource[0].start != 0ULL || (ha->pdev)->resource[0].end != (ha->pdev)->resource[0].start ? ((uint32_t )(ha->pdev)->resource[0].end - (uint32_t )(ha->pdev)->resource[0].start) + 1U : 0U;
#line 1666
  tmp___0 = ioremap((ha->pdev)->resource[0].start, (unsigned long )len);
#line 1666
  ha->nx_pcibase = (unsigned long )tmp___0;
#line 1668
  if (ha->nx_pcibase == 0UL) {
#line 1669
    ql_log_pci(0U, ha->pdev, 14, "Cannot remap pcibase MMIO, aborting.\n");
#line 1671
    goto iospace_error_exit;
  } else {

  }
#line 1675
  if ((ha->device_type & 262144U) != 0U) {
#line 1676
    ha->iobase = (device_reg_t *)ha->nx_pcibase;
  } else
#line 1678
  if ((ha->device_type & 16384U) != 0U) {
#line 1679
    ha->iobase = (device_reg_t *)(((unsigned long )((ha->pdev)->devfn << 11) + ha->nx_pcibase) + 770048UL);
  } else {

  }
#line 1684
  if (ql2xdbwr == 0) {
#line 1685
    tmp___1 = ioremap((ha->pdev)->resource[4].start + (resource_size_t )((ha->pdev)->devfn << 12),
                      4UL);
#line 1685
    ha->nxdb_wr_ptr = (unsigned long )tmp___1;
#line 1688
    if (ha->nxdb_wr_ptr == 0UL) {
#line 1689
      ql_log_pci(0U, ha->pdev, 15, "Cannot remap MMIO, aborting.\n");
#line 1691
      goto iospace_error_exit;
    } else {

    }
#line 1697
    ha->nxdb_rd_ptr = (uint8_t *)(((unsigned long )((ha->pdev)->devfn * 8U) + ha->nx_pcibase) + 524288UL);
  } else {
#line 1700
    ha->nxdb_wr_ptr = (ha->pdev)->devfn == 6U ? 136323512UL : 136323516UL;
  }
#line 1705
  tmp___2 = 1U;
#line 1705
  ha->max_rsp_queues = tmp___2;
#line 1705
  ha->max_req_queues = tmp___2;
#line 1706
  ha->msix_count = (unsigned int )((uint16_t )ha->max_rsp_queues) + 1U;
#line 1707
  ql_dbg_pci(1048576U, ha->pdev, 49158, "nx_pci_base=%p iobase=%p max_req_queues=%d msix_count=%d.\n",
             (void *)ha->nx_pcibase, ha->iobase, (int )ha->max_req_queues, (int )ha->msix_count);
#line 1712
  ql_dbg_pci(1073741824U, ha->pdev, 16, "nx_pci_base=%p iobase=%p max_req_queues=%d msix_count=%d.\n",
             (void *)ha->nx_pcibase, ha->iobase, (int )ha->max_req_queues, (int )ha->msix_count);
#line 1717
  return (0);
  iospace_error_exit: ;
#line 1720
  return (-12);
}
}
#line 1734 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
int qla82xx_pci_config(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  int ret ;

  {
#line 1736
  ha = vha->hw;
#line 1739
  pci_set_master(ha->pdev);
#line 1740
  ret = pci_set_mwi(ha->pdev);
#line 1741
  ha->chip_revision = (uint16_t )(ha->pdev)->revision;
#line 1742
  ql_dbg(1073741824U, vha, 67, "Chip revision:%d.\n", (int )ha->chip_revision);
#line 1745
  return (0);
}
}
#line 1755 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
void qla82xx_reset_chip(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 1757
  ha = vha->hw;
#line 1758
  (*((ha->isp_ops)->disable_intrs))(ha);
#line 1759
  return;
}
}
#line 1761 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
void qla82xx_config_rings(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct device_reg_82xx *reg ;
  struct init_cb_81xx *icb ;
  struct req_que *req ;
  struct rsp_que *rsp ;

  {
#line 1763
  ha = vha->hw;
#line 1764
  reg = & (ha->iobase)->isp82;
#line 1766
  req = *(ha->req_q_map);
#line 1767
  rsp = *(ha->rsp_q_map);
#line 1770
  icb = (struct init_cb_81xx *)ha->init_cb;
#line 1771
  icb->request_q_outpointer = 0U;
#line 1772
  icb->response_q_inpointer = 0U;
#line 1773
  icb->request_q_length = req->length;
#line 1774
  icb->response_q_length = rsp->length;
#line 1775
  icb->request_q_address[0] = (unsigned int )req->dma;
#line 1776
  icb->request_q_address[1] = (unsigned int )(req->dma >> 32ULL);
#line 1777
  icb->response_q_address[0] = (unsigned int )rsp->dma;
#line 1778
  icb->response_q_address[1] = (unsigned int )(rsp->dma >> 32ULL);
#line 1780
  writel(0U, (void volatile   *)(& reg->req_q_out));
#line 1781
  writel(0U, (void volatile   *)(& reg->rsp_q_in));
#line 1782
  writel(0U, (void volatile   *)(& reg->rsp_q_out));
#line 1783
  return;
}
}
#line 1786 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_fw_load_from_blob(struct qla_hw_data *ha ) 
{ 
  u64 *ptr64 ;
  u32 i ;
  u32 flashaddr ;
  u32 size ;
  __le64 data ;
  u8 *tmp ;
  int tmp___0 ;
  __le32 tmp___1 ;
  u8 *tmp___2 ;
  int tmp___3 ;

  {
#line 1792
  size = 122880U;
#line 1794
  tmp = qla82xx_get_bootld_offset(ha);
#line 1794
  ptr64 = (u64 *)tmp;
#line 1795
  flashaddr = 65536U;
#line 1797
  i = 0U;
#line 1797
  goto ldv_66394;
  ldv_66393: 
#line 1798
  data = *(ptr64 + (unsigned long )i);
#line 1799
  tmp___0 = qla82xx_pci_mem_write_2M(ha, (u64 )flashaddr, (void *)(& data), 8);
#line 1799
  if (tmp___0 != 0) {
#line 1800
    return (-5);
  } else {

  }
#line 1801
  flashaddr = flashaddr + 8U;
#line 1797
  i = i + 1U;
  ldv_66394: ;
#line 1797
  if (i < size) {
#line 1799
    goto ldv_66393;
  } else {

  }
#line 1804
  flashaddr = 274432U;
#line 1805
  tmp___1 = qla82xx_get_fw_size(ha);
#line 1805
  size = tmp___1 / 8U;
#line 1806
  tmp___2 = qla82xx_get_fw_offs(ha);
#line 1806
  ptr64 = (u64 *)tmp___2;
#line 1808
  i = 0U;
#line 1808
  goto ldv_66397;
  ldv_66396: 
#line 1809
  data = *(ptr64 + (unsigned long )i);
#line 1811
  tmp___3 = qla82xx_pci_mem_write_2M(ha, (u64 )flashaddr, (void *)(& data), 8);
#line 1811
  if (tmp___3 != 0) {
#line 1812
    return (-5);
  } else {

  }
#line 1813
  flashaddr = flashaddr + 8U;
#line 1808
  i = i + 1U;
  ldv_66397: ;
#line 1808
  if (i < size) {
#line 1810
    goto ldv_66396;
  } else {

  }
#line 1815
  __const_udelay(429500UL);
#line 1822
  qla82xx_wr_32(ha, 136323580UL, 305419896U);
#line 1824
  _raw_read_lock(& ha->hw_lock);
#line 1825
  qla82xx_wr_32(ha, 118489112UL, 4128U);
#line 1826
  qla82xx_wr_32(ha, 154140680UL, 8388638U);
#line 1827
  _raw_read_unlock(& ha->hw_lock);
#line 1828
  return (0);
}
}
#line 1832 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_set_product_offset(struct qla_hw_data *ha ) 
{ 
  struct qla82xx_uri_table_desc *ptab_desc ;
  uint8_t const   *unirom ;
  uint32_t i ;
  __le32 entries ;
  __le32 flags ;
  __le32 file_chiprev ;
  __le32 offset ;
  uint8_t chiprev ;
  int mn_present ;
  uint32_t flagbit ;

  {
#line 1834
  ptab_desc = (struct qla82xx_uri_table_desc *)0;
#line 1835
  unirom = (uint8_t const   *)((ha->hablob)->fw)->data;
#line 1839
  chiprev = (uint8_t )ha->chip_revision;
#line 1841
  mn_present = 0;
#line 1844
  ptab_desc = qla82xx_get_table_desc(unirom, 0);
#line 1846
  if ((unsigned long )ptab_desc == (unsigned long )((struct qla82xx_uri_table_desc *)0)) {
#line 1847
    return (-1);
  } else {

  }
#line 1849
  entries = ptab_desc->num_entries;
#line 1851
  i = 0U;
#line 1851
  goto ldv_66413;
  ldv_66412: 
#line 1852
  offset = ptab_desc->findex + ptab_desc->entry_size * i;
#line 1854
  flags = (unsigned int )*((int *)unirom + ((unsigned long )offset + 11UL));
#line 1856
  file_chiprev = (unsigned int )*((int *)unirom + ((unsigned long )offset + 10UL));
#line 1859
  flagbit = mn_present != 0 ? 1U : 2U;
#line 1861
  if ((__le32 )chiprev == file_chiprev && (int )((unsigned long long )flags >> (int )flagbit) & 1) {
#line 1862
    ha->file_prd_off = offset;
#line 1863
    return (0);
  } else {

  }
#line 1851
  i = i + 1U;
  ldv_66413: ;
#line 1851
  if (i < entries) {
#line 1853
    goto ldv_66412;
  } else {

  }

#line 1866
  return (-1);
}
}
#line 1870 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_validate_firmware_blob(scsi_qla_host_t *vha , uint8_t fw_type ) 
{ 
  __le32 val ;
  uint32_t min_size ;
  struct qla_hw_data *ha ;
  struct firmware  const  *fw ;
  int tmp ;

  {
#line 1874
  ha = vha->hw;
#line 1875
  fw = (ha->hablob)->fw;
#line 1877
  ha->fw_type = fw_type;
#line 1879
  if ((unsigned int )fw_type == 3U) {
#line 1880
    tmp = qla82xx_set_product_offset(ha);
#line 1880
    if (tmp != 0) {
#line 1881
      return (-22);
    } else {

    }
#line 1883
    min_size = 819200U;
  } else {
#line 1885
    val = *((u32 *)fw->data + 16680U);
#line 1886
    if (val != 305419896U) {
#line 1887
      return (-22);
    } else {

    }
#line 1889
    min_size = 4194303U;
  }
#line 1892
  if ((unsigned long )fw->size < (unsigned long )min_size) {
#line 1893
    return (-22);
  } else {

  }
#line 1894
  return (0);
}
}
#line 1898 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_check_cmdpeg_state(struct qla_hw_data *ha ) 
{ 
  u32 val ;
  int retries ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1900
  val = 0U;
#line 1901
  retries = 60;
#line 1902
  tmp = pci_get_drvdata(ha->pdev);
#line 1902
  vha = (scsi_qla_host_t *)tmp;
  ldv_66434: 
#line 1905
  _raw_read_lock(& ha->hw_lock);
#line 1906
  tmp___0 = qla82xx_rd_32(ha, 136323664UL);
#line 1906
  val = (u32 )tmp___0;
#line 1907
  _raw_read_unlock(& ha->hw_lock);
#line 1909
  switch (val) {
  case 65281U: ;
  case 61455U: ;
#line 1912
  return (0);
  case 65535U: ;
#line 1914
  goto ldv_66432;
  default: ;
#line 1916
  goto ldv_66432;
  }
  ldv_66432: 
#line 1918
  ql_log(2U, vha, 168, "CRB_CMDPEG_STATE: 0x%x and retries:0x%x.\n", val, retries);
#line 1922
  msleep(500U);
#line 1924
  retries = retries - 1;
#line 1924
  if (retries != 0) {
#line 1926
    goto ldv_66434;
  } else {

  }
#line 1926
  ql_log(0U, vha, 169, "Cmd Peg initialization failed: 0x%x.\n", val);
#line 1929
  tmp___1 = qla82xx_rd_32(ha, 154140764UL);
#line 1929
  val = (u32 )tmp___1;
#line 1930
  _raw_read_lock(& ha->hw_lock);
#line 1931
  qla82xx_wr_32(ha, 136323664UL, 65535U);
#line 1932
  _raw_read_unlock(& ha->hw_lock);
#line 1933
  return (258);
}
}
#line 1937 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_check_rcvpeg_state(struct qla_hw_data *ha ) 
{ 
  u32 val ;
  int retries ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1939
  val = 0U;
#line 1940
  retries = 60;
#line 1941
  tmp = pci_get_drvdata(ha->pdev);
#line 1941
  vha = (scsi_qla_host_t *)tmp;
  ldv_66447: 
#line 1944
  _raw_read_lock(& ha->hw_lock);
#line 1945
  tmp___0 = qla82xx_rd_32(ha, 136323900UL);
#line 1945
  val = (u32 )tmp___0;
#line 1946
  _raw_read_unlock(& ha->hw_lock);
#line 1948
  switch (val) {
  case 65281U: ;
  case 61455U: ;
#line 1951
  return (0);
  case 65535U: ;
#line 1953
  goto ldv_66445;
  default: ;
#line 1955
  goto ldv_66445;
  }
  ldv_66445: 
#line 1957
  ql_log(2U, vha, 171, "CRB_RCVPEG_STATE: 0x%x and retries: 0x%x.\n", val, retries);
#line 1961
  msleep(500U);
#line 1963
  retries = retries - 1;
#line 1963
  if (retries != 0) {
#line 1965
    goto ldv_66447;
  } else {

  }
#line 1965
  ql_log(0U, vha, 172, "Rcv Peg initializatin failed: 0x%x.\n", val);
#line 1967
  _raw_read_lock(& ha->hw_lock);
#line 1968
  qla82xx_wr_32(ha, 136323900UL, 65535U);
#line 1969
  _raw_read_unlock(& ha->hw_lock);
#line 1970
  return (258);
}
}
#line 1974 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static struct qla82xx_legacy_intr_set legacy_intr[8U]  = 
#line 1974
  {      {128U, 101777688U, 101777704U, 101789696U}, 
        {256U, 101777760U, 101777776U, 101789700U}, 
        {512U, 101777764U, 101777780U, 101789704U}, 
        {1024U, 101777768U, 101777784U, 101789708U}, 
        {2048U, 101778272U, 101778288U, 101789712U}, 
        {4096U, 101778276U, 101778292U, 101789716U}, 
        {8192U, 101778280U, 101778296U, 101789720U}, 
        {16384U, 101778284U, 101778300U, 101789724U}};
#line 1983 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
void qla82xx_mbx_completion(scsi_qla_host_t *vha , uint16_t mb0 ) 
{ 
  uint16_t cnt ;
  uint16_t *wptr ;
  struct qla_hw_data *ha ;
  struct device_reg_82xx *reg ;

  {
#line 1987
  ha = vha->hw;
#line 1988
  reg = & (ha->iobase)->isp82;
#line 1989
  wptr = (uint16_t *)(& reg->mailbox_out) + 1UL;
#line 1992
  ha->flags.mbox_int = 1U;
#line 1993
  ha->mailbox_out[0] = mb0;
#line 1995
  cnt = 1U;
#line 1995
  goto ldv_66459;
  ldv_66458: 
#line 1996
  ha->mailbox_out[(int )cnt] = readw((void const volatile   *)wptr);
#line 1997
  wptr = wptr + 1;
#line 1995
  cnt = (uint16_t )((int )cnt + 1);
  ldv_66459: ;
#line 1995
  if ((int )((unsigned short )ha->mbx_count) > (int )cnt) {
#line 1997
    goto ldv_66458;
  } else {

  }

#line 2000
  if ((unsigned long )ha->mcp == (unsigned long )((mbx_cmd_t *)0)) {
#line 2001
    ql_dbg(33554432U, vha, 20563, "MBX pointer OLD_ERROR.\n");
  } else {

  }
#line 2003
  return;
}
}
#line 2016 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
irqreturn_t qla82xx_intr_handler(int irq , void *dev_id ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct rsp_que *rsp ;
  struct device_reg_82xx *reg ;
  int status ;
  int status1 ;
  unsigned long flags ;
  unsigned long iter ;
  uint32_t stat ;
  uint16_t mb[4U] ;
  raw_spinlock_t *tmp ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 2022
  status = 0;
#line 2022
  status1 = 0;
#line 2025
  stat = 0U;
#line 2028
  rsp = (struct rsp_que *)dev_id;
#line 2029
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 2030
    ql_log(2U, (scsi_qla_host_t *)0, 45139, "%s: NULL response queue pointer.\n",
           "qla82xx_intr_handler");
#line 2032
    return (0);
  } else {

  }
#line 2034
  ha = rsp->hw;
#line 2036
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 2037
    status = qla82xx_rd_32(ha, 101777664UL);
#line 2038
    if ((ha->nx_legacy_intr.int_vec_bit & (uint32_t )status) == 0U) {
#line 2039
      return (0);
    } else {

    }
#line 2041
    status1 = qla82xx_rd_32(ha, 101785708UL);
#line 2042
    if ((status1 & 768) != 512) {
#line 2043
      return (0);
    } else {

    }
  } else {

  }
#line 2047
  qla82xx_wr_32(ha, (ulong )ha->nx_legacy_intr.tgt_status_reg, 4294967295U);
#line 2050
  qla82xx_rd_32(ha, 101777664UL);
#line 2051
  qla82xx_rd_32(ha, 101777664UL);
#line 2053
  reg = & (ha->iobase)->isp82;
#line 2055
  tmp = spinlock_check(& ha->hardware_lock);
#line 2055
  flags = _raw_spin_lock_irqsave(tmp);
#line 2056
  tmp___0 = pci_get_drvdata(ha->pdev);
#line 2056
  vha = (scsi_qla_host_t *)tmp___0;
#line 2057
  iter = 1UL;
#line 2057
  goto ldv_66488;
  ldv_66487: 
#line 2059
  tmp___1 = readl((void const volatile   *)(& reg->host_int));
#line 2059
  if (tmp___1 != 0U) {
#line 2060
    stat = readl((void const volatile   *)(& reg->host_status));
#line 2062
    switch (stat & 255U) {
    case 1U: ;
    case 2U: ;
    case 16U: ;
    case 17U: 
#line 2067
    qla82xx_mbx_completion(vha, (int )((unsigned short )(stat >> 16)));
#line 2068
    status = status | 1;
#line 2069
    goto ldv_66483;
    case 18U: 
#line 2071
    mb[0] = (unsigned short )(stat >> 16);
#line 2072
    mb[1] = readw((void const volatile   *)(& reg->mailbox_out) + 1U);
#line 2073
    mb[2] = readw((void const volatile   *)(& reg->mailbox_out) + 2U);
#line 2074
    mb[3] = readw((void const volatile   *)(& reg->mailbox_out) + 3U);
#line 2075
    qla2x00_async_event(vha, rsp, (uint16_t *)(& mb));
#line 2076
    goto ldv_66483;
    case 19U: 
#line 2078
    qla24xx_process_response_queue(vha, rsp);
#line 2079
    goto ldv_66483;
    default: 
#line 2081
    ql_dbg(33554432U, vha, 20564, "Unrecognized interrupt type (%d).\n", stat & 255U);
#line 2084
    goto ldv_66483;
    }
    ldv_66483: ;
  } else {

  }
#line 2087
  writel(0U, (void volatile   *)(& reg->host_int));
  ldv_66488: 
#line 2057
  tmp___2 = iter;
#line 2057
  iter = iter - 1UL;
#line 2057
  if (tmp___2 != 0UL) {
#line 2059
    goto ldv_66487;
  } else {

  }
#line 2090
  qla2x00_handle_mbx_completion(ha, status);
#line 2091
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2093
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 2094
    qla82xx_wr_32(ha, (ulong )ha->nx_legacy_intr.tgt_mask_reg, 64511U);
  } else {

  }
#line 2096
  return (1);
}
}
#line 2100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
irqreturn_t qla82xx_msix_default(int irq , void *dev_id ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct rsp_que *rsp ;
  struct device_reg_82xx *reg ;
  int status ;
  unsigned long flags ;
  uint32_t stat ;
  uint32_t host_int ;
  uint16_t mb[4U] ;
  raw_spinlock_t *tmp ;
  void *tmp___0 ;
  bool tmp___1 ;

  {
#line 2106
  status = 0;
#line 2108
  stat = 0U;
#line 2109
  host_int = 0U;
#line 2112
  rsp = (struct rsp_que *)dev_id;
#line 2113
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 2114
    printk("\016%s(): NULL response queue pointer.\n", "qla82xx_msix_default");
#line 2116
    return (0);
  } else {

  }
#line 2118
  ha = rsp->hw;
#line 2120
  reg = & (ha->iobase)->isp82;
#line 2122
  tmp = spinlock_check(& ha->hardware_lock);
#line 2122
  flags = _raw_spin_lock_irqsave(tmp);
#line 2123
  tmp___0 = pci_get_drvdata(ha->pdev);
#line 2123
  vha = (scsi_qla_host_t *)tmp___0;
#line 2125
  host_int = readl((void const volatile   *)(& reg->host_int));
#line 2126
  tmp___1 = qla2x00_check_reg32_for_disconnect(vha, host_int);
#line 2126
  if ((int )tmp___1) {
#line 2127
    goto ldv_66507;
  } else {

  }
#line 2128
  if (host_int != 0U) {
#line 2129
    stat = readl((void const volatile   *)(& reg->host_status));
#line 2131
    switch (stat & 255U) {
    case 1U: ;
    case 2U: ;
    case 16U: ;
    case 17U: 
#line 2136
    qla82xx_mbx_completion(vha, (int )((unsigned short )(stat >> 16)));
#line 2137
    status = status | 1;
#line 2138
    goto ldv_66512;
    case 18U: 
#line 2140
    mb[0] = (unsigned short )(stat >> 16);
#line 2141
    mb[1] = readw((void const volatile   *)(& reg->mailbox_out) + 1U);
#line 2142
    mb[2] = readw((void const volatile   *)(& reg->mailbox_out) + 2U);
#line 2143
    mb[3] = readw((void const volatile   *)(& reg->mailbox_out) + 3U);
#line 2144
    qla2x00_async_event(vha, rsp, (uint16_t *)(& mb));
#line 2145
    goto ldv_66512;
    case 19U: 
#line 2147
    qla24xx_process_response_queue(vha, rsp);
#line 2148
    goto ldv_66512;
    default: 
#line 2150
    ql_dbg(33554432U, vha, 20545, "Unrecognized interrupt type (%d).\n", stat & 255U);
#line 2153
    goto ldv_66512;
    }
    ldv_66512: ;
  } else {

  }
#line 2156
  writel(0U, (void volatile   *)(& reg->host_int));
  ldv_66507: 
#line 2159
  qla2x00_handle_mbx_completion(ha, status);
#line 2160
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2162
  return (1);
}
}
#line 2166 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
irqreturn_t qla82xx_msix_rsp_q(int irq , void *dev_id ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct rsp_que *rsp ;
  struct device_reg_82xx *reg ;
  unsigned long flags ;
  uint32_t host_int ;
  raw_spinlock_t *tmp ;
  void *tmp___0 ;
  bool tmp___1 ;

  {
#line 2173
  host_int = 0U;
#line 2175
  rsp = (struct rsp_que *)dev_id;
#line 2176
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 2177
    printk("\016%s(): NULL response queue pointer.\n", "qla82xx_msix_rsp_q");
#line 2179
    return (0);
  } else {

  }
#line 2182
  ha = rsp->hw;
#line 2183
  reg = & (ha->iobase)->isp82;
#line 2184
  tmp = spinlock_check(& ha->hardware_lock);
#line 2184
  flags = _raw_spin_lock_irqsave(tmp);
#line 2185
  tmp___0 = pci_get_drvdata(ha->pdev);
#line 2185
  vha = (scsi_qla_host_t *)tmp___0;
#line 2186
  host_int = readl((void const volatile   *)(& reg->host_int));
#line 2187
  tmp___1 = qla2x00_check_reg32_for_disconnect(vha, host_int);
#line 2187
  if ((int )tmp___1) {
#line 2188
    goto out;
  } else {

  }
#line 2189
  qla24xx_process_response_queue(vha, rsp);
#line 2190
  writel(0U, (void volatile   *)(& reg->host_int));
  out: 
#line 2192
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2193
  return (1);
}
}
#line 2197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
void qla82xx_poll(int irq , void *dev_id ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct rsp_que *rsp ;
  struct device_reg_82xx *reg ;
  int status ;
  uint32_t stat ;
  uint32_t host_int ;
  uint16_t mb[4U] ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  void *tmp___0 ;
  bool tmp___1 ;

  {
#line 2203
  status = 0;
#line 2205
  host_int = 0U;
#line 2209
  rsp = (struct rsp_que *)dev_id;
#line 2210
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 2211
    printk("\016%s(): NULL response queue pointer.\n", "qla82xx_poll");
#line 2213
    return;
  } else {

  }
#line 2215
  ha = rsp->hw;
#line 2217
  reg = & (ha->iobase)->isp82;
#line 2218
  tmp = spinlock_check(& ha->hardware_lock);
#line 2218
  flags = _raw_spin_lock_irqsave(tmp);
#line 2219
  tmp___0 = pci_get_drvdata(ha->pdev);
#line 2219
  vha = (scsi_qla_host_t *)tmp___0;
#line 2221
  host_int = readl((void const volatile   *)(& reg->host_int));
#line 2222
  tmp___1 = qla2x00_check_reg32_for_disconnect(vha, host_int);
#line 2222
  if ((int )tmp___1) {
#line 2223
    goto out;
  } else {

  }
#line 2224
  if (host_int != 0U) {
#line 2225
    stat = readl((void const volatile   *)(& reg->host_status));
#line 2226
    switch (stat & 255U) {
    case 1U: ;
    case 2U: ;
    case 16U: ;
    case 17U: 
#line 2231
    qla82xx_mbx_completion(vha, (int )((unsigned short )(stat >> 16)));
#line 2232
    status = status | 1;
#line 2233
    goto ldv_66553;
    case 18U: 
#line 2235
    mb[0] = (unsigned short )(stat >> 16);
#line 2236
    mb[1] = readw((void const volatile   *)(& reg->mailbox_out) + 1U);
#line 2237
    mb[2] = readw((void const volatile   *)(& reg->mailbox_out) + 2U);
#line 2238
    mb[3] = readw((void const volatile   *)(& reg->mailbox_out) + 3U);
#line 2239
    qla2x00_async_event(vha, rsp, (uint16_t *)(& mb));
#line 2240
    goto ldv_66553;
    case 19U: 
#line 2242
    qla24xx_process_response_queue(vha, rsp);
#line 2243
    goto ldv_66553;
    default: 
#line 2245
    ql_dbg(524288U, vha, 45075, "Unrecognized interrupt type (%d).\n", stat * 255U);
#line 2248
    goto ldv_66553;
    }
    ldv_66553: 
#line 2250
    writel(0U, (void volatile   *)(& reg->host_int));
  } else {

  }
  out: 
#line 2253
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2254
  return;
}
}
#line 2257 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
void qla82xx_enable_intrs(struct qla_hw_data *ha ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 2259
  tmp = pci_get_drvdata(ha->pdev);
#line 2259
  vha = (scsi_qla_host_t *)tmp;
#line 2260
  qla82xx_mbx_intr_enable(vha);
#line 2261
  spin_lock_irq(& ha->hardware_lock);
#line 2262
  if ((ha->device_type & 262144U) != 0U) {
#line 2263
    qla8044_wr_reg(ha, 14536UL, 0U);
  } else {
#line 2265
    qla82xx_wr_32(ha, (ulong )ha->nx_legacy_intr.tgt_mask_reg, 64511U);
  }
#line 2266
  spin_unlock_irq(& ha->hardware_lock);
#line 2267
  ha->interrupts_on = 1U;
#line 2268
  return;
}
}
#line 2271 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
void qla82xx_disable_intrs(struct qla_hw_data *ha ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 2273
  tmp = pci_get_drvdata(ha->pdev);
#line 2273
  vha = (scsi_qla_host_t *)tmp;
#line 2274
  qla82xx_mbx_intr_disable(vha);
#line 2275
  spin_lock_irq(& ha->hardware_lock);
#line 2276
  if ((ha->device_type & 262144U) != 0U) {
#line 2277
    qla8044_wr_reg(ha, 14536UL, 1U);
  } else {
#line 2279
    qla82xx_wr_32(ha, (ulong )ha->nx_legacy_intr.tgt_mask_reg, 1024U);
  }
#line 2280
  spin_unlock_irq(& ha->hardware_lock);
#line 2281
  ha->interrupts_on = 0U;
#line 2282
  return;
}
}
#line 2284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
void qla82xx_init_flags(struct qla_hw_data *ha ) 
{ 
  struct qla82xx_legacy_intr_set *nx_legacy_intr ;
  struct lock_class_key __key ;

  {
#line 2289
  __rwlock_init(& ha->hw_lock, "&ha->hw_lock", & __key);
#line 2290
  ha->qdr_sn_window = -1;
#line 2291
  ha->ddr_mn_window = 4294967295U;
#line 2292
  ha->curr_window = 255U;
#line 2293
  ha->portnum = (unsigned int )((uint16_t )(ha->pdev)->devfn) & 7U;
#line 2294
  nx_legacy_intr = (struct qla82xx_legacy_intr_set *)(& legacy_intr) + (unsigned long )ha->portnum;
#line 2295
  ha->nx_legacy_intr.int_vec_bit = nx_legacy_intr->int_vec_bit;
#line 2296
  ha->nx_legacy_intr.tgt_status_reg = nx_legacy_intr->tgt_status_reg;
#line 2297
  ha->nx_legacy_intr.tgt_mask_reg = nx_legacy_intr->tgt_mask_reg;
#line 2298
  ha->nx_legacy_intr.pci_int_reg = nx_legacy_intr->pci_int_reg;
#line 2299
  return;
}
}
#line 2302 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
__inline void qla82xx_set_idc_version(scsi_qla_host_t *vha ) 
{ 
  int idc_ver ;
  uint32_t drv_active ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 2306
  ha = vha->hw;
#line 2308
  tmp = qla82xx_rd_32(ha, 136323384UL);
#line 2308
  drv_active = (uint32_t )tmp;
#line 2309
  if ((uint32_t )(1 << (int )ha->portnum * 4) == drv_active) {
#line 2310
    qla82xx_wr_32(ha, 136323444UL, 1U);
#line 2312
    ql_log(2U, vha, 45186, "IDC version updated to %d\n", 1);
  } else {
#line 2315
    idc_ver = qla82xx_rd_32(ha, 136323444UL);
#line 2316
    if (idc_ver != 1) {
#line 2317
      ql_log(2U, vha, 45187, "qla2xxx driver IDC version %d is not compatible with IDC version %d of the other drivers\n",
             1, idc_ver);
    } else {

    }
  }
#line 2320
  return;
}
}
#line 2325 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
void qla82xx_set_drv_active(scsi_qla_host_t *vha ) 
{ 
  uint32_t drv_active ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;

  {
#line 2328
  ha = vha->hw;
#line 2330
  tmp = qla82xx_rd_32(ha, 136323384UL);
#line 2330
  drv_active = (uint32_t )tmp;
#line 2333
  if (drv_active == 4294967295U) {
#line 2334
    qla82xx_wr_32(ha, 136323384UL, 0U);
#line 2336
    tmp___0 = qla82xx_rd_32(ha, 136323384UL);
#line 2336
    drv_active = (uint32_t )tmp___0;
  } else {

  }
#line 2338
  drv_active = (uint32_t )(1 << (int )ha->portnum * 4) | drv_active;
#line 2339
  qla82xx_wr_32(ha, 136323384UL, drv_active);
#line 2340
  return;
}
}
#line 2343 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
void qla82xx_clear_drv_active(struct qla_hw_data *ha ) 
{ 
  uint32_t drv_active ;
  int tmp ;

  {
#line 2347
  tmp = qla82xx_rd_32(ha, 136323384UL);
#line 2347
  drv_active = (uint32_t )tmp;
#line 2348
  drv_active = (uint32_t )(~ (1 << (int )ha->portnum * 4)) & drv_active;
#line 2349
  qla82xx_wr_32(ha, 136323384UL, drv_active);
#line 2350
  return;
}
}
#line 2353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
__inline static int qla82xx_need_reset(struct qla_hw_data *ha ) 
{ 
  uint32_t drv_state ;
  int rval ;
  int tmp ;

  {
#line 2358
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 2359
    return (1);
  } else {
#line 2361
    tmp = qla82xx_rd_32(ha, 136323396UL);
#line 2361
    drv_state = (uint32_t )tmp;
#line 2362
    rval = (int )((uint32_t )(1 << (int )ha->portnum * 4) & drv_state);
#line 2363
    return (rval);
  }
}
}
#line 2368 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
__inline static void qla82xx_set_rst_ready(struct qla_hw_data *ha ) 
{ 
  uint32_t drv_state ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2371
  tmp = pci_get_drvdata(ha->pdev);
#line 2371
  vha = (scsi_qla_host_t *)tmp;
#line 2373
  tmp___0 = qla82xx_rd_32(ha, 136323396UL);
#line 2373
  drv_state = (uint32_t )tmp___0;
#line 2376
  if (drv_state == 4294967295U) {
#line 2377
    qla82xx_wr_32(ha, 136323396UL, 0U);
#line 2378
    tmp___1 = qla82xx_rd_32(ha, 136323396UL);
#line 2378
    drv_state = (uint32_t )tmp___1;
  } else {

  }
#line 2380
  drv_state = (uint32_t )(1 << (int )ha->portnum * 4) | drv_state;
#line 2381
  ql_dbg(1073741824U, vha, 187, "drv_state = 0x%08x.\n", drv_state);
#line 2383
  qla82xx_wr_32(ha, 136323396UL, drv_state);
#line 2384
  return;
}
}
#line 2387 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
__inline static void qla82xx_clear_rst_ready(struct qla_hw_data *ha ) 
{ 
  uint32_t drv_state ;
  int tmp ;

  {
#line 2391
  tmp = qla82xx_rd_32(ha, 136323396UL);
#line 2391
  drv_state = (uint32_t )tmp;
#line 2392
  drv_state = (uint32_t )(~ (1 << (int )ha->portnum * 4)) & drv_state;
#line 2393
  qla82xx_wr_32(ha, 136323396UL, drv_state);
#line 2394
  return;
}
}
#line 2397 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
__inline static void qla82xx_set_qsnt_ready(struct qla_hw_data *ha ) 
{ 
  uint32_t qsnt_state ;
  int tmp ;

  {
#line 2401
  tmp = qla82xx_rd_32(ha, 136323396UL);
#line 2401
  qsnt_state = (uint32_t )tmp;
#line 2402
  qsnt_state = (uint32_t )(2 << (int )ha->portnum * 4) | qsnt_state;
#line 2403
  qla82xx_wr_32(ha, 136323396UL, qsnt_state);
#line 2404
  return;
}
}
#line 2407 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
void qla82xx_clear_qsnt_ready(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t qsnt_state ;
  int tmp ;

  {
#line 2409
  ha = vha->hw;
#line 2412
  tmp = qla82xx_rd_32(ha, 136323396UL);
#line 2412
  qsnt_state = (uint32_t )tmp;
#line 2413
  qsnt_state = (uint32_t )(~ (2 << (int )ha->portnum * 4)) & qsnt_state;
#line 2414
  qla82xx_wr_32(ha, 136323396UL, qsnt_state);
#line 2415
  return;
}
}
#line 2418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_load_fw(scsi_qla_host_t *vha ) 
{ 
  int rst ;
  struct fw_blob *blob ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;
  struct fw_blob *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 2422
  ha = vha->hw;
#line 2424
  tmp = qla82xx_pinit_from_rom(vha);
#line 2424
  if (tmp != 0) {
#line 2425
    ql_log(0U, vha, 159, "Error during CRB initialization.\n");
#line 2427
    return (258);
  } else {

  }
#line 2429
  __const_udelay(2147500UL);
#line 2432
  rst = qla82xx_rd_32(ha, 154140680UL);
#line 2433
  rst = rst & -285212673;
#line 2434
  qla82xx_wr_32(ha, 154140680UL, (u32 )rst);
#line 2441
  if (ql2xfwloadbin == 2) {
#line 2442
    goto try_blob_fw;
  } else {

  }
#line 2444
  ql_log(2U, vha, 160, "Attempting to load firmware from flash.\n");
#line 2447
  tmp___0 = qla82xx_fw_load_from_flash(ha);
#line 2447
  if (tmp___0 == 0) {
#line 2448
    ql_log(2U, vha, 161, "Firmware loaded successfully from flash.\n");
#line 2450
    return (0);
  } else {
#line 2452
    ql_log(1U, vha, 264, "Firmware load from flash failed.\n");
  }
  try_blob_fw: 
#line 2457
  ql_log(2U, vha, 162, "Attempting to load firmware from blob.\n");
#line 2461
  tmp___1 = qla2x00_request_firmware(vha);
#line 2461
  ha->hablob = tmp___1;
#line 2461
  blob = tmp___1;
#line 2462
  if ((unsigned long )blob == (unsigned long )((struct fw_blob *)0)) {
#line 2463
    ql_log(0U, vha, 163, "Firmware image not present.\n");
#line 2465
    goto fw_load_failed;
  } else {

  }
#line 2469
  tmp___3 = qla82xx_validate_firmware_blob(vha, 4);
#line 2469
  if (tmp___3 != 0) {
#line 2472
    tmp___2 = qla82xx_validate_firmware_blob(vha, 3);
#line 2472
    if (tmp___2 != 0) {
#line 2474
      ql_log(0U, vha, 164, "No valid firmware image found.\n");
#line 2476
      return (258);
    } else {

    }
  } else {

  }
#line 2480
  tmp___4 = qla82xx_fw_load_from_blob(ha);
#line 2480
  if (tmp___4 == 0) {
#line 2481
    ql_log(2U, vha, 165, "Firmware loaded successfully from binary blob.\n");
#line 2483
    return (0);
  } else {
#line 2485
    ql_log(0U, vha, 166, "Firmware load failed for binary blob.\n");
#line 2487
    blob->fw = (struct firmware  const  *)0;
#line 2488
    blob = (struct fw_blob *)0;
#line 2489
    goto fw_load_failed;
  }
#line 2491
  return (0);
  fw_load_failed: ;
#line 2494
  return (258);
}
}
#line 2498 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
int qla82xx_start_firmware(scsi_qla_host_t *vha ) 
{ 
  uint16_t lnk ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2501
  ha = vha->hw;
#line 2504
  qla82xx_wr_32(ha, 136323788UL, 1431655765U);
#line 2509
  qla82xx_wr_32(ha, 136323664UL, 0U);
#line 2510
  qla82xx_wr_32(ha, 136323900UL, 0U);
#line 2513
  qla82xx_wr_32(ha, 136323240UL, 0U);
#line 2514
  qla82xx_wr_32(ha, 136323244UL, 0U);
#line 2516
  tmp = qla82xx_load_fw(vha);
#line 2516
  if (tmp != 0) {
#line 2517
    ql_log(0U, vha, 167, "Error trying to start fw.\n");
#line 2519
    return (258);
  } else {

  }
#line 2523
  tmp___0 = qla82xx_check_cmdpeg_state(ha);
#line 2523
  if (tmp___0 != 0) {
#line 2524
    ql_log(0U, vha, 170, "Error during card handshake.\n");
#line 2526
    return (258);
  } else {

  }
#line 2530
  pcie_capability_read_word(ha->pdev, 18, & lnk);
#line 2531
  ha->link_width = ((int )lnk >> 4) & 63;
#line 2534
  tmp___1 = qla82xx_check_rcvpeg_state(ha);
#line 2534
  return (tmp___1);
}
}
#line 2538 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static uint32_t *qla82xx_read_flash_data(scsi_qla_host_t *vha , uint32_t *dwptr ,
                                         uint32_t faddr , uint32_t length ) 
{ 
  uint32_t i ;
  uint32_t val ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 2543
  ha = vha->hw;
#line 2546
  i = 0U;
#line 2546
  goto ldv_66632;
  ldv_66631: 
#line 2547
  tmp = qla82xx_rom_fast_read(ha, (int )faddr, (int *)(& val));
#line 2547
  if (tmp != 0) {
#line 2548
    ql_log(1U, vha, 262, "Do ROM fast read failed.\n");
#line 2550
    goto done_read;
  } else {

  }
#line 2552
  *(dwptr + (unsigned long )i) = val;
#line 2546
  i = i + 1U;
#line 2546
  faddr = faddr + 4U;
  ldv_66632: ;
#line 2546
  if (length / 4U > i) {
#line 2548
    goto ldv_66631;
  } else {

  }

  done_read: ;
#line 2555
  return (dwptr);
}
}
#line 2559 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_unprotect_flash(struct qla_hw_data *ha ) 
{ 
  int ret ;
  uint32_t val ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2563
  tmp = pci_get_drvdata(ha->pdev);
#line 2563
  vha = (scsi_qla_host_t *)tmp;
#line 2565
  ret = ql82xx_rom_lock_d(ha);
#line 2566
  if (ret < 0) {
#line 2567
    ql_log(1U, vha, 45076, "ROM Lock failed.\n");
#line 2569
    return (ret);
  } else {

  }
#line 2572
  ret = qla82xx_read_status_reg(ha, & val);
#line 2573
  if (ret < 0) {
#line 2574
    goto done_unprotect;
  } else {

  }
#line 2576
  val = val & 4294967235U;
#line 2577
  ret = qla82xx_write_status_reg(ha, val);
#line 2578
  if (ret < 0) {
#line 2579
    val = val | 60U;
#line 2580
    qla82xx_write_status_reg(ha, val);
  } else {

  }
#line 2583
  tmp___0 = qla82xx_write_disable_flash(ha);
#line 2583
  if (tmp___0 != 0) {
#line 2584
    ql_log(1U, vha, 45077, "Write disable failed.\n");
  } else {

  }
  done_unprotect: 
#line 2588
  qla82xx_rom_unlock(ha);
#line 2589
  return (ret);
}
}
#line 2593 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_protect_flash(struct qla_hw_data *ha ) 
{ 
  int ret ;
  uint32_t val ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2597
  tmp = pci_get_drvdata(ha->pdev);
#line 2597
  vha = (scsi_qla_host_t *)tmp;
#line 2599
  ret = ql82xx_rom_lock_d(ha);
#line 2600
  if (ret < 0) {
#line 2601
    ql_log(1U, vha, 45078, "ROM Lock failed.\n");
#line 2603
    return (ret);
  } else {

  }
#line 2606
  ret = qla82xx_read_status_reg(ha, & val);
#line 2607
  if (ret < 0) {
#line 2608
    goto done_protect;
  } else {

  }
#line 2610
  val = val | 60U;
#line 2612
  ret = qla82xx_write_status_reg(ha, val);
#line 2613
  if (ret < 0) {
#line 2614
    ql_log(1U, vha, 45079, "Write status register failed.\n");
  } else {

  }
#line 2617
  tmp___0 = qla82xx_write_disable_flash(ha);
#line 2617
  if (tmp___0 != 0) {
#line 2618
    ql_log(1U, vha, 45080, "Write disable failed.\n");
  } else {

  }
  done_protect: 
#line 2621
  qla82xx_rom_unlock(ha);
#line 2622
  return (ret);
}
}
#line 2626 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_erase_sector(struct qla_hw_data *ha , int addr ) 
{ 
  int ret ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2628
  ret = 0;
#line 2629
  tmp = pci_get_drvdata(ha->pdev);
#line 2629
  vha = (scsi_qla_host_t *)tmp;
#line 2631
  ret = ql82xx_rom_lock_d(ha);
#line 2632
  if (ret < 0) {
#line 2633
    ql_log(1U, vha, 45081, "ROM Lock failed.\n");
#line 2635
    return (ret);
  } else {

  }
#line 2638
  qla82xx_flash_set_write_enable(ha);
#line 2639
  qla82xx_wr_32(ha, 154206216UL, (u32 )addr);
#line 2640
  qla82xx_wr_32(ha, 154206224UL, 3U);
#line 2641
  qla82xx_wr_32(ha, 154206212UL, 216U);
#line 2643
  tmp___0 = qla82xx_wait_rom_done(ha);
#line 2643
  if (tmp___0 != 0) {
#line 2644
    ql_log(1U, vha, 45082, "Error waiting for rom done.\n");
#line 2646
    ret = -1;
#line 2647
    goto done;
  } else {

  }
#line 2649
  ret = qla82xx_flash_wait_write_finish(ha);
  done: 
#line 2651
  qla82xx_rom_unlock(ha);
#line 2652
  return (ret);
}
}
#line 2659 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
uint8_t *qla82xx_read_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                                  uint32_t length ) 
{ 


  {
#line 2662
  scsi_block_requests(vha->host);
#line 2663
  qla82xx_read_flash_data(vha, (uint32_t *)buf, offset, length);
#line 2664
  scsi_unblock_requests(vha->host);
#line 2665
  return (buf);
}
}
#line 2669 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_write_flash_data(struct scsi_qla_host *vha , uint32_t *dwptr ,
                                    uint32_t faddr , uint32_t dwords ) 
{ 
  int ret ;
  uint32_t liter ;
  uint32_t sec_mask ;
  uint32_t rest_addr ;
  dma_addr_t optrom_dma ;
  void *optrom ;
  int page_mode ;
  struct qla_hw_data *ha ;

  {
#line 2676
  optrom = (void *)0;
#line 2677
  page_mode = 0;
#line 2678
  ha = vha->hw;
#line 2680
  ret = -1;
#line 2683
  if ((page_mode != 0 && (faddr & 4095U) == 0U) && dwords > 1024U) {
#line 2685
    optrom = dma_alloc_attrs(& (ha->pdev)->dev, 4096UL, & optrom_dma, 208U, (struct dma_attrs *)0);
#line 2687
    if ((unsigned long )optrom == (unsigned long )((void *)0)) {
#line 2688
      ql_log(1U, vha, 45083, "Unable to allocate memory for optrom burst write (%x KB).\n",
             4);
    } else {

    }
  } else {

  }
#line 2695
  rest_addr = ha->fdt_block_size - 1U;
#line 2696
  sec_mask = ~ rest_addr;
#line 2698
  ret = qla82xx_unprotect_flash(ha);
#line 2699
  if (ret != 0) {
#line 2700
    ql_log(1U, vha, 45084, "Unable to unprotect flash for update.\n");
#line 2702
    goto write_done;
  } else {

  }
#line 2705
  liter = 0U;
#line 2705
  goto ldv_66679;
  ldv_66678: ;
#line 2707
  if ((faddr & rest_addr) == 0U) {
#line 2709
    ret = qla82xx_erase_sector(ha, (int )faddr);
#line 2710
    if (ret != 0) {
#line 2711
      ql_log(1U, vha, 45085, "Unable to erase sector: address=%x.\n", faddr);
#line 2714
      goto ldv_66676;
    } else {

    }
  } else {

  }
#line 2719
  if ((unsigned long )optrom != (unsigned long )((void *)0) && liter + 1024U <= dwords) {
#line 2721
    memcpy(optrom, (void const   *)dwptr, 4096UL);
#line 2723
    ret = qla2x00_load_ram(vha, optrom_dma, ha->flash_data_off | faddr, 1024U);
#line 2726
    if (ret != 0) {
#line 2727
      ql_log(1U, vha, 45086, "Unable to burst-write optrom segment (%x/%x/%llx).\n",
             ret, ha->flash_data_off | faddr, optrom_dma);
#line 2732
      ql_log(1U, vha, 45087, "Reverting to slow-write.\n");
#line 2735
      dma_free_attrs(& (ha->pdev)->dev, 4096UL, optrom, optrom_dma, (struct dma_attrs *)0);
#line 2737
      optrom = (void *)0;
    } else {
#line 2739
      liter = liter + 1023U;
#line 2740
      faddr = faddr + 1023U;
#line 2741
      dwptr = dwptr + 1023UL;
#line 2742
      goto ldv_66677;
    }
  } else {

  }
#line 2746
  ret = qla82xx_write_flash_dword(ha, faddr, *dwptr);
#line 2748
  if (ret != 0) {
#line 2749
    ql_dbg(524288U, vha, 45088, "Unable to program flash address=%x data=%x.\n", faddr,
           *dwptr);
#line 2752
    goto ldv_66676;
  } else {

  }
  ldv_66677: 
#line 2705
  liter = liter + 1U;
#line 2705
  faddr = faddr + 4U;
#line 2705
  dwptr = dwptr + 1;
  ldv_66679: ;
#line 2705
  if (liter < dwords) {
#line 2707
    goto ldv_66678;
  } else {

  }
  ldv_66676: 
#line 2756
  ret = qla82xx_protect_flash(ha);
#line 2757
  if (ret != 0) {
#line 2758
    ql_log(1U, vha, 45089, "Unable to protect flash after update.\n");
  } else {

  }
  write_done: ;
#line 2761
  if ((unsigned long )optrom != (unsigned long )((void *)0)) {
#line 2762
    dma_free_attrs(& (ha->pdev)->dev, 4096UL, optrom, optrom_dma, (struct dma_attrs *)0);
  } else {

  }
#line 2764
  return (ret);
}
}
#line 2768 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
int qla82xx_write_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                              uint32_t length ) 
{ 
  int rval ;

  {
#line 2774
  scsi_block_requests(vha->host);
#line 2775
  rval = qla82xx_write_flash_data(vha, (uint32_t *)buf, offset, length >> 2);
#line 2777
  scsi_unblock_requests(vha->host);
#line 2780
  if (rval != 0) {
#line 2781
    rval = 258;
  } else {
#line 2783
    rval = 0;
  }
#line 2784
  return (rval);
}
}
#line 2788 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
void qla82xx_start_iocbs(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct device_reg_82xx *reg ;
  uint32_t dbval ;
  unsigned int tmp ;

  {
#line 2790
  ha = vha->hw;
#line 2791
  req = *(ha->req_q_map);
#line 2796
  req->ring_index = (uint16_t )((int )req->ring_index + 1);
#line 2797
  if ((int )req->ring_index == (int )req->length) {
#line 2798
    req->ring_index = 0U;
#line 2799
    req->ring_ptr = req->ring;
  } else {
#line 2801
    req->ring_ptr = req->ring_ptr + 1;
  }
#line 2803
  reg = & (ha->iobase)->isp82;
#line 2804
  dbval = (uint32_t )(((int )ha->portnum << 5) | 4);
#line 2806
  dbval = ((uint32_t )((int )req->id << 8) | dbval) | (uint32_t )((int )req->ring_index << 16);
#line 2807
  if (ql2xdbwr != 0) {
#line 2808
    qla82xx_wr_32(ha, ha->nxdb_wr_ptr, dbval);
  } else {
#line 2810
    writel(dbval, (void volatile   *)ha->nxdb_wr_ptr);
#line 2811
    __asm__  volatile   ("sfence": : : "memory");
#line 2812
    goto ldv_66695;
    ldv_66694: 
#line 2813
    writel(dbval, (void volatile   *)ha->nxdb_wr_ptr);
#line 2815
    __asm__  volatile   ("sfence": : : "memory");
    ldv_66695: 
#line 2812
    tmp = readl((void const volatile   *)ha->nxdb_rd_ptr);
#line 2812
    if (tmp != dbval) {
#line 2814
      goto ldv_66694;
    } else {

    }

  }
#line 2820
  return;
}
}
#line 2821 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static void qla82xx_rom_lock_recovery(struct qla_hw_data *ha ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  uint32_t lock_owner ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2823
  tmp = pci_get_drvdata(ha->pdev);
#line 2823
  vha = (scsi_qla_host_t *)tmp;
#line 2824
  lock_owner = 0U;
#line 2826
  tmp___1 = qla82xx_rom_lock(ha);
#line 2826
  if (tmp___1 != 0) {
#line 2827
    tmp___0 = qla82xx_rd_32(ha, 136323328UL);
#line 2827
    lock_owner = (uint32_t )tmp___0;
#line 2829
    ql_log(2U, vha, 45090, "Resetting rom_lock, Lock Owner %u.\n", lock_owner);
  } else {

  }
#line 2837
  qla82xx_rom_unlock(ha);
#line 2838
  return;
}
}
#line 2852 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_device_bootstrap(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  int i ;
  uint32_t old_count ;
  uint32_t count ;
  struct qla_hw_data *ha ;
  int need_reset ;
  int tmp ;
  int tmp___0 ;

  {
#line 2854
  rval = 0;
#line 2857
  ha = vha->hw;
#line 2858
  need_reset = 0;
#line 2860
  need_reset = qla82xx_need_reset(ha);
#line 2862
  if (need_reset != 0) {
#line 2864
    if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 2865
      qla82xx_rom_lock_recovery(ha);
    } else {

    }
  } else {
#line 2867
    tmp = qla82xx_rd_32(ha, 136323248UL);
#line 2867
    old_count = (uint32_t )tmp;
#line 2868
    i = 0;
#line 2868
    goto ldv_66713;
    ldv_66712: 
#line 2869
    msleep(200U);
#line 2870
    tmp___0 = qla82xx_rd_32(ha, 136323248UL);
#line 2870
    count = (uint32_t )tmp___0;
#line 2871
    if (count != old_count) {
#line 2872
      rval = 0;
#line 2873
      goto dev_ready;
    } else {

    }
#line 2868
    i = i + 1;
    ldv_66713: ;
#line 2868
    if (i <= 9) {
#line 2870
      goto ldv_66712;
    } else {

    }
#line 2876
    qla82xx_rom_lock_recovery(ha);
  }
#line 2880
  ql_log(2U, vha, 158, "HW State: INITIALIZING.\n");
#line 2882
  qla82xx_wr_32(ha, 136323392UL, 2U);
#line 2884
  qla82xx_idc_unlock(ha);
#line 2885
  rval = qla82xx_start_firmware(vha);
#line 2886
  qla82xx_idc_lock(ha);
#line 2888
  if (rval != 0) {
#line 2889
    ql_log(0U, vha, 173, "HW State: FAILED.\n");
#line 2891
    qla82xx_clear_drv_active(ha);
#line 2892
    qla82xx_wr_32(ha, 136323392UL, 6U);
#line 2893
    return (rval);
  } else {

  }
  dev_ready: 
#line 2897
  ql_log(2U, vha, 174, "HW State: READY.\n");
#line 2899
  qla82xx_wr_32(ha, 136323392UL, 3U);
#line 2901
  return (0);
}
}
#line 2915 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static void qla82xx_need_qsnt_handler(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t dev_state ;
  uint32_t drv_state ;
  uint32_t drv_active ;
  unsigned long reset_timeout ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2917
  ha = vha->hw;
#line 2921
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 2923
    qla2x00_quiesce_io(vha);
  } else {

  }
#line 2927
  qla82xx_set_qsnt_ready(ha);
#line 2930
  reset_timeout = (unsigned long )jiffies + 7500UL;
#line 2932
  tmp = qla82xx_rd_32(ha, 136323396UL);
#line 2932
  drv_state = (uint32_t )tmp;
#line 2933
  tmp___0 = qla82xx_rd_32(ha, 136323384UL);
#line 2933
  drv_active = (uint32_t )tmp___0;
#line 2935
  drv_active = drv_active << 1;
#line 2937
  goto ldv_66730;
  ldv_66729: ;
#line 2939
  if ((long )((unsigned long )jiffies - reset_timeout) >= 0L) {
#line 2943
    ql_log(2U, vha, 45091, "%s : QUIESCENT TIMEOUT DRV_ACTIVE:%d DRV_STATE:%d.\n",
           (char *)"qla2xxx", drv_active, drv_state);
#line 2947
    qla82xx_wr_32(ha, 136323392UL, 3U);
#line 2949
    ql_log(2U, vha, 45093, "HW State: DEV_READY.\n");
#line 2951
    qla82xx_idc_unlock(ha);
#line 2952
    qla2x00_perform_loop_resync(vha);
#line 2953
    qla82xx_idc_lock(ha);
#line 2955
    qla82xx_clear_qsnt_ready(vha);
#line 2956
    return;
  } else {

  }
#line 2959
  qla82xx_idc_unlock(ha);
#line 2960
  msleep(1000U);
#line 2961
  qla82xx_idc_lock(ha);
#line 2963
  tmp___1 = qla82xx_rd_32(ha, 136323396UL);
#line 2963
  drv_state = (uint32_t )tmp___1;
#line 2964
  tmp___2 = qla82xx_rd_32(ha, 136323384UL);
#line 2964
  drv_active = (uint32_t )tmp___2;
#line 2965
  drv_active = drv_active << 1;
  ldv_66730: ;
#line 2937
  if (drv_state != drv_active) {
#line 2939
    goto ldv_66729;
  } else {

  }
#line 2967
  tmp___3 = qla82xx_rd_32(ha, 136323392UL);
#line 2967
  dev_state = (uint32_t )tmp___3;
#line 2969
  if (dev_state == 5U) {
#line 2970
    ql_log(2U, vha, 45094, "HW State: DEV_QUIESCENT.\n");
#line 2972
    qla82xx_wr_32(ha, 136323392UL, 7U);
  } else {

  }
#line 2974
  return;
}
}
#line 2987 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
uint32_t qla82xx_wait_for_state_change(scsi_qla_host_t *vha , uint32_t curr_state ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t dev_state ;
  int tmp ;

  {
#line 2989
  ha = vha->hw;
  ldv_66738: 
#line 2993
  msleep(1000U);
#line 2994
  qla82xx_idc_lock(ha);
#line 2995
  tmp = qla82xx_rd_32(ha, 136323392UL);
#line 2995
  dev_state = (uint32_t )tmp;
#line 2996
  qla82xx_idc_unlock(ha);
#line 2997
  if (dev_state == curr_state) {
#line 2999
    goto ldv_66738;
  } else {

  }

#line 2999
  return (dev_state);
}
}
#line 3003 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
void qla8xxx_dev_failed_handler(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 3005
  ha = vha->hw;
#line 3008
  ql_log(0U, vha, 184, "Disabling the board.\n");
#line 3011
  if ((ha->device_type & 16384U) != 0U) {
#line 3012
    qla82xx_clear_drv_active(ha);
#line 3013
    qla82xx_idc_unlock(ha);
  } else
#line 3014
  if ((ha->device_type & 262144U) != 0U) {
#line 3015
    qla8044_clear_drv_active(ha);
#line 3016
    qla8044_idc_unlock(ha);
  } else {

  }
#line 3020
  vha->device_flags = vha->device_flags | 32U;
#line 3021
  qla2x00_abort_all_cmds(vha, 65536);
#line 3022
  qla2x00_mark_all_devices_lost(vha, 0);
#line 3023
  vha->flags.online = 0U;
#line 3024
  vha->flags.init_done = 0U;
#line 3025
  return;
}
}
#line 3039 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static void qla82xx_need_reset_handler(scsi_qla_host_t *vha ) 
{ 
  uint32_t dev_state ;
  uint32_t drv_state ;
  uint32_t drv_active ;
  uint32_t active_mask ;
  unsigned long reset_timeout ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
#line 3042
  active_mask = 0U;
#line 3044
  ha = vha->hw;
#line 3045
  req = *(ha->req_q_map);
#line 3047
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 3048
    qla82xx_idc_unlock(ha);
#line 3049
    qla2x00_abort_isp_cleanup(vha);
#line 3050
    (*((ha->isp_ops)->get_flash_version))(vha, (void *)req->ring);
#line 3051
    (*((ha->isp_ops)->nvram_config))(vha);
#line 3052
    qla82xx_idc_lock(ha);
  } else {

  }
#line 3055
  tmp = qla82xx_rd_32(ha, 136323384UL);
#line 3055
  drv_active = (uint32_t )tmp;
#line 3056
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 3057
    ql_dbg(524288U, vha, 45096, "reset_acknowledged by 0x%x\n", (int )ha->portnum);
#line 3059
    qla82xx_set_rst_ready(ha);
  } else {
#line 3061
    active_mask = (uint32_t )(~ (1 << (int )ha->portnum * 4));
#line 3062
    drv_active = drv_active & active_mask;
#line 3063
    ql_dbg(524288U, vha, 45097, "active_mask: 0x%08x\n", active_mask);
  }
#line 3068
  reset_timeout = (unsigned long )(ha->fcoe_reset_timeout * 250U) + (unsigned long )jiffies;
#line 3070
  tmp___0 = qla82xx_rd_32(ha, 136323396UL);
#line 3070
  drv_state = (uint32_t )tmp___0;
#line 3071
  tmp___1 = qla82xx_rd_32(ha, 136323384UL);
#line 3071
  drv_active = (uint32_t )tmp___1;
#line 3072
  tmp___2 = qla82xx_rd_32(ha, 136323392UL);
#line 3072
  dev_state = (uint32_t )tmp___2;
#line 3074
  ql_dbg(524288U, vha, 45098, "drv_state: 0x%08x, drv_active: 0x%08x, dev_state: 0x%08x, active_mask: 0x%08x\n",
         drv_state, drv_active, dev_state, active_mask);
#line 3079
  goto ldv_66762;
  ldv_66761: ;
#line 3081
  if ((long )((unsigned long )jiffies - reset_timeout) >= 0L) {
#line 3082
    ql_log(1U, vha, 181, "Reset timeout.\n");
#line 3084
    goto ldv_66760;
  } else {

  }
#line 3086
  qla82xx_idc_unlock(ha);
#line 3087
  msleep(1000U);
#line 3088
  qla82xx_idc_lock(ha);
#line 3089
  tmp___3 = qla82xx_rd_32(ha, 136323396UL);
#line 3089
  drv_state = (uint32_t )tmp___3;
#line 3090
  tmp___4 = qla82xx_rd_32(ha, 136323384UL);
#line 3090
  drv_active = (uint32_t )tmp___4;
#line 3091
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 3092
    drv_active = drv_active & active_mask;
  } else {

  }
#line 3093
  tmp___5 = qla82xx_rd_32(ha, 136323392UL);
#line 3093
  dev_state = (uint32_t )tmp___5;
  ldv_66762: ;
#line 3079
  if (drv_state != drv_active && dev_state != 2U) {
#line 3082
    goto ldv_66761;
  } else {

  }
  ldv_66760: 
#line 3096
  ql_dbg(524288U, vha, 45099, "drv_state: 0x%08x, drv_active: 0x%08x, dev_state: 0x%08x, active_mask: 0x%08x\n",
         drv_state, drv_active, dev_state, active_mask);
#line 3101
  if (dev_state <= 7U) {
#line 3101
    tmp___6 = qdev_state(dev_state);
#line 3101
    tmp___7 = tmp___6;
  } else {
#line 3101
    tmp___7 = (char *)"Unknown";
  }
#line 3101
  ql_log(2U, vha, 182, "Device state is 0x%x = %s.\n", dev_state, tmp___7);
#line 3107
  if (dev_state != 2U && dev_state != 1U) {
#line 3109
    ql_log(2U, vha, 183, "HW State: COLD/RE-INIT.\n");
#line 3111
    qla82xx_wr_32(ha, 136323392UL, 1U);
#line 3112
    qla82xx_set_rst_ready(ha);
#line 3113
    if (ql2xmdenable != 0) {
#line 3114
      tmp___8 = qla82xx_md_collect(vha);
#line 3114
      if (tmp___8 != 0) {
#line 3115
        ql_log(1U, vha, 45100, "Minidump not collected.\n");
      } else {

      }
    } else {
#line 3118
      ql_log(1U, vha, 45135, "Minidump disabled.\n");
    }
  } else {

  }
#line 3121
  return;
}
}
#line 3124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
int qla82xx_check_md_needed(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  uint16_t fw_major_version ;
  uint16_t fw_minor_version ;
  uint16_t fw_subminor_version ;
  int rval ;

  {
#line 3126
  ha = vha->hw;
#line 3128
  rval = 0;
#line 3130
  fw_major_version = ha->fw_major_version;
#line 3131
  fw_minor_version = ha->fw_minor_version;
#line 3132
  fw_subminor_version = ha->fw_subminor_version;
#line 3134
  rval = qla2x00_get_fw_version(vha);
#line 3135
  if (rval != 0) {
#line 3136
    return (rval);
  } else {

  }
#line 3138
  if (ql2xmdenable != 0) {
#line 3139
    if (ha->fw_dumped == 0) {
#line 3140
      if ((((int )ha->fw_major_version != (int )fw_major_version || (int )ha->fw_minor_version != (int )fw_minor_version) || (int )ha->fw_subminor_version != (int )fw_subminor_version) || ha->prev_minidump_failed != 0) {
#line 3144
        ql_dbg(524288U, vha, 45101, "Firmware version differs Previous version: %d:%d:%d - New version: %d:%d:%d, prev_minidump_failed: %d.\n",
               (int )fw_major_version, (int )fw_minor_version, (int )fw_subminor_version,
               (int )ha->fw_major_version, (int )ha->fw_minor_version, (int )ha->fw_subminor_version,
               ha->prev_minidump_failed);
#line 3153
        qla82xx_md_free(vha);
#line 3155
        qla82xx_md_prep(vha);
      } else {

      }
    } else {
#line 3158
      ql_log(2U, vha, 45102, "Firmware dump available to retrieve\n");
    }
  } else {

  }
#line 3161
  return (rval);
}
}
#line 3166 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_check_fw_alive(scsi_qla_host_t *vha ) 
{ 
  uint32_t fw_heartbeat_counter ;
  int status ;
  int tmp ;

  {
#line 3169
  status = 0;
#line 3171
  tmp = qla82xx_rd_32(vha->hw, 136323248UL);
#line 3171
  fw_heartbeat_counter = (uint32_t )tmp;
#line 3174
  if (fw_heartbeat_counter == 4294967295U) {
#line 3175
    ql_dbg(16777216U, vha, 24579, "FW heartbeat counter is 0xffffffff, returning status=%d.\n",
           status);
#line 3178
    return (status);
  } else {

  }
#line 3180
  if ((uint32_t )vha->fw_heartbeat_counter == fw_heartbeat_counter) {
#line 3181
    vha->seconds_since_last_heartbeat = vha->seconds_since_last_heartbeat + 1;
#line 3183
    if (vha->seconds_since_last_heartbeat == 2) {
#line 3184
      vha->seconds_since_last_heartbeat = 0;
#line 3185
      status = 1;
    } else {

    }
  } else {
#line 3188
    vha->seconds_since_last_heartbeat = 0;
  }
#line 3189
  vha->fw_heartbeat_counter = (int )fw_heartbeat_counter;
#line 3190
  if (status != 0) {
#line 3191
    ql_dbg(16777216U, vha, 24580, "Returning status=%d.\n", status);
  } else {

  }
#line 3193
  return (status);
}
}
#line 3208 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
int qla82xx_device_state_handler(scsi_qla_host_t *vha ) 
{ 
  uint32_t dev_state ;
  uint32_t old_dev_state ;
  int rval ;
  unsigned long dev_init_timeout ;
  struct qla_hw_data *ha ;
  int loopcount ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 3212
  rval = 0;
#line 3214
  ha = vha->hw;
#line 3215
  loopcount = 0;
#line 3217
  qla82xx_idc_lock(ha);
#line 3218
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 3219
    qla82xx_set_drv_active(vha);
#line 3220
    qla82xx_set_idc_version(vha);
  } else {

  }
#line 3223
  tmp = qla82xx_rd_32(ha, 136323392UL);
#line 3223
  dev_state = (uint32_t )tmp;
#line 3224
  old_dev_state = dev_state;
#line 3225
  if (dev_state <= 7U) {
#line 3225
    tmp___0 = qdev_state(dev_state);
#line 3225
    tmp___1 = tmp___0;
  } else {
#line 3225
    tmp___1 = (char *)"Unknown";
  }
#line 3225
  ql_log(2U, vha, 155, "Device state is 0x%x = %s.\n", dev_state, tmp___1);
#line 3231
  dev_init_timeout = (unsigned long )(ha->fcoe_dev_init_timeout * 250U) + (unsigned long )jiffies;
  ldv_66803: ;
#line 3235
  if ((long )((unsigned long )jiffies - dev_init_timeout) >= 0L) {
#line 3236
    ql_log(0U, vha, 156, "Device init failed.\n");
#line 3238
    rval = 258;
#line 3239
    goto ldv_66791;
  } else {

  }
#line 3241
  tmp___2 = qla82xx_rd_32(ha, 136323392UL);
#line 3241
  dev_state = (uint32_t )tmp___2;
#line 3242
  if (old_dev_state != dev_state) {
#line 3243
    loopcount = 0;
#line 3244
    old_dev_state = dev_state;
  } else {

  }
#line 3246
  if (loopcount <= 4) {
#line 3247
    if (dev_state <= 7U) {
#line 3247
      tmp___3 = qdev_state(dev_state);
#line 3247
      tmp___4 = tmp___3;
    } else {
#line 3247
      tmp___4 = (char *)"Unknown";
    }
#line 3247
    ql_log(2U, vha, 157, "Device state is 0x%x = %s.\n", dev_state, tmp___4);
  } else {

  }
#line 3254
  switch (dev_state) {
  case 3U: 
#line 3256
  ha->flags.nic_core_reset_owner = 0U;
#line 3257
  goto rel_lock;
  case 1U: 
#line 3259
  rval = qla82xx_device_bootstrap(vha);
#line 3260
  goto ldv_66795;
  case 2U: 
#line 3262
  qla82xx_idc_unlock(ha);
#line 3263
  msleep(1000U);
#line 3264
  qla82xx_idc_lock(ha);
#line 3265
  goto ldv_66795;
  case 4U: ;
#line 3267
  if (ql2xdontresethba == 0) {
#line 3268
    qla82xx_need_reset_handler(vha);
  } else {
#line 3270
    qla82xx_idc_unlock(ha);
#line 3271
    msleep(1000U);
#line 3272
    qla82xx_idc_lock(ha);
  }
#line 3274
  dev_init_timeout = (unsigned long )(ha->fcoe_dev_init_timeout * 250U) + (unsigned long )jiffies;
#line 3276
  goto ldv_66795;
  case 5U: 
#line 3278
  qla82xx_need_qsnt_handler(vha);
#line 3280
  dev_init_timeout = (unsigned long )(ha->fcoe_dev_init_timeout * 250U) + (unsigned long )jiffies;
#line 3282
  goto ldv_66795;
  case 7U: ;
#line 3287
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 3288
    goto rel_lock;
  } else {

  }
#line 3290
  qla82xx_idc_unlock(ha);
#line 3291
  msleep(1000U);
#line 3292
  qla82xx_idc_lock(ha);
#line 3295
  dev_init_timeout = (unsigned long )(ha->fcoe_dev_init_timeout * 250U) + (unsigned long )jiffies;
#line 3297
  goto ldv_66795;
  case 6U: 
#line 3299
  qla8xxx_dev_failed_handler(vha);
#line 3300
  rval = 258;
#line 3301
  goto exit;
  default: 
#line 3303
  qla82xx_idc_unlock(ha);
#line 3304
  msleep(1000U);
#line 3305
  qla82xx_idc_lock(ha);
  }
  ldv_66795: 
#line 3307
  loopcount = loopcount + 1;
#line 3308
  goto ldv_66803;
  ldv_66791: ;
  rel_lock: 
#line 3310
  qla82xx_idc_unlock(ha);
  exit: ;
#line 3312
  return (rval);
}
}
#line 3315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_check_temp(scsi_qla_host_t *vha ) 
{ 
  uint32_t temp ;
  uint32_t temp_state ;
  uint32_t temp_val ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 3318
  ha = vha->hw;
#line 3320
  tmp = qla82xx_rd_32(ha, 136324020UL);
#line 3320
  temp = (uint32_t )tmp;
#line 3321
  temp_state = temp & 65535U;
#line 3322
  temp_val = temp >> 16;
#line 3324
  if (temp_state == 3U) {
#line 3325
    ql_log(1U, vha, 24590, "Device temperature %d degrees C exceeds  maximum allowed. Hardware has been shut down.\n",
           temp_val);
#line 3329
    return (1);
  } else
#line 3330
  if (temp_state == 2U) {
#line 3331
    ql_log(1U, vha, 24591, "Device temperature %d degrees C exceeds operating range. Immediate action needed.\n",
           temp_val);
  } else {

  }
#line 3336
  return (0);
}
}
#line 3339 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
int qla82xx_read_temperature(scsi_qla_host_t *vha ) 
{ 
  uint32_t temp ;
  int tmp ;

  {
#line 3343
  tmp = qla82xx_rd_32(vha->hw, 136324020UL);
#line 3343
  temp = (uint32_t )tmp;
#line 3344
  return ((int )(temp >> 16));
}
}
#line 3347 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
void qla82xx_clear_pending_mbx(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 3349
  ha = vha->hw;
#line 3351
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 3352
    ha->flags.mbox_int = 1U;
#line 3353
    ha->flags.mbox_busy = 0U;
#line 3354
    ql_log(1U, vha, 24592, "Doing premature completion of mbx command.\n");
#line 3356
    tmp = test_and_clear_bit(2L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 3356
    if (tmp != 0) {
#line 3357
      complete(& ha->mbx_intr_comp);
    } else {

    }
  } else {

  }
#line 3359
  return;
}
}
#line 3361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
void qla82xx_watchdog(scsi_qla_host_t *vha ) 
{ 
  uint32_t dev_state ;
  uint32_t halt_status ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 3364
  ha = vha->hw;
#line 3367
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 3368
    tmp = qla82xx_rd_32(ha, 136323392UL);
#line 3368
    dev_state = (uint32_t )tmp;
#line 3369
    tmp___11 = qla82xx_check_temp(vha);
#line 3369
    if (tmp___11 != 0) {
#line 3370
      set_bit(17L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3371
      ha->flags.isp82xx_fw_hung = 1U;
#line 3372
      qla82xx_clear_pending_mbx(vha);
    } else
#line 3373
    if (dev_state == 4U) {
#line 3373
      tmp___10 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3373
      if (tmp___10 == 0) {
#line 3375
        ql_log(1U, vha, 24577, "Adapter reset needed.\n");
#line 3377
        set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
      } else {
#line 3373
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 3378
    if (dev_state == 5U) {
#line 3378
      tmp___9 = constant_test_bit(20L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3378
      if (tmp___9 == 0) {
#line 3380
        ql_log(1U, vha, 24578, "Quiescent needed.\n");
#line 3382
        set_bit(20L, (unsigned long volatile   *)(& vha->dpc_flags));
      } else {
#line 3378
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 3383
    if (dev_state == 6U) {
#line 3383
      tmp___8 = constant_test_bit(17L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3383
      if (tmp___8 == 0) {
#line 3383
        if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 3386
          ql_log(1U, vha, 45141, "Adapter state is failed. Offlining.\n");
#line 3388
          set_bit(17L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3389
          ha->flags.isp82xx_fw_hung = 1U;
#line 3390
          qla82xx_clear_pending_mbx(vha);
        } else {
#line 3383
          goto _L___0;
        }
      } else {
#line 3383
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 3392
      tmp___7 = qla82xx_check_fw_alive(vha);
#line 3392
      if (tmp___7 != 0) {
#line 3393
        ql_dbg(16777216U, vha, 24593, "disabling pause transmit on port 0 & 1.\n");
#line 3395
        qla82xx_wr_32(ha, 106954904UL, 9U);
#line 3397
        tmp___0 = qla82xx_rd_32(ha, 136323240UL);
#line 3397
        halt_status = (uint32_t )tmp___0;
#line 3399
        tmp___1 = qla82xx_rd_32(ha, 116391996UL);
#line 3399
        tmp___2 = qla82xx_rd_32(ha, 121634876UL);
#line 3399
        tmp___3 = qla82xx_rd_32(ha, 120586300UL);
#line 3399
        tmp___4 = qla82xx_rd_32(ha, 119537724UL);
#line 3399
        tmp___5 = qla82xx_rd_32(ha, 118489148UL);
#line 3399
        tmp___6 = qla82xx_rd_32(ha, 136323244UL);
#line 3399
        ql_log(2U, vha, 24581, "dumping hw/fw registers:.\n  PEG_HALT_STATUS1: 0x%x, PEG_HALT_STATUS2: 0x%x,.\n  PEG_NET_0_PC: 0x%x, PEG_NET_1_PC: 0x%x,.\n  PEG_NET_2_PC: 0x%x, PEG_NET_3_PC: 0x%x,.\n  PEG_NET_4_PC: 0x%x.\n",
               halt_status, tmp___6, tmp___5, tmp___4, tmp___3, tmp___2, tmp___1);
#line 3416
        if ((halt_status & 536870656U) >> 8 == 103U) {
#line 3417
          ql_log(1U, vha, 45138, "Firmware aborted with error code 0x00006700. Device is being reset.\n");
        } else {

        }
#line 3421
        if ((int )halt_status < 0) {
#line 3422
          set_bit(17L, (unsigned long volatile   *)(& vha->dpc_flags));
        } else {
#line 3425
          ql_log(2U, vha, 24582, "Detect abort  needed.\n");
#line 3427
          set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
        }
#line 3430
        ha->flags.isp82xx_fw_hung = 1U;
#line 3431
        ql_log(1U, vha, 24583, "Firmware hung.\n");
#line 3432
        qla82xx_clear_pending_mbx(vha);
      } else {

      }
    }
  } else {

  }
#line 3435
  return;
}
}
#line 3438 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
int qla82xx_load_risc(scsi_qla_host_t *vha , uint32_t *srisc_addr ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;

  {
#line 3440
  rval = -1;
#line 3441
  ha = vha->hw;
#line 3443
  if ((ha->device_type & 16384U) != 0U) {
#line 3444
    rval = qla82xx_device_state_handler(vha);
  } else
#line 3445
  if ((ha->device_type & 262144U) != 0U) {
#line 3446
    qla8044_idc_lock(ha);
#line 3448
    qla83xx_reset_ownership(vha);
#line 3449
    qla8044_idc_unlock(ha);
#line 3450
    rval = qla8044_device_state_handler(vha);
  } else {

  }
#line 3452
  return (rval);
}
}
#line 3456 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
void qla82xx_set_reset_owner(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t dev_state ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 3458
  ha = vha->hw;
#line 3459
  dev_state = 0U;
#line 3461
  if ((ha->device_type & 16384U) != 0U) {
#line 3462
    tmp = qla82xx_rd_32(ha, 136323392UL);
#line 3462
    dev_state = (uint32_t )tmp;
  } else
#line 3463
  if ((ha->device_type & 262144U) != 0U) {
#line 3464
    tmp___0 = qla8044_rd_direct(vha, 4U);
#line 3464
    dev_state = (uint32_t )tmp___0;
  } else {

  }
#line 3466
  if (dev_state == 3U) {
#line 3467
    ql_log(2U, vha, 45103, "HW State: NEED RESET\n");
#line 3469
    if ((ha->device_type & 16384U) != 0U) {
#line 3470
      qla82xx_wr_32(ha, 136323392UL, 4U);
#line 3472
      ha->flags.nic_core_reset_owner = 1U;
#line 3473
      ql_dbg(524288U, vha, 45104, "reset_owner is 0x%x\n", (int )ha->portnum);
    } else
#line 3475
    if ((ha->device_type & 262144U) != 0U) {
#line 3476
      qla8044_wr_direct(vha, 4U, 4U);
    } else {

    }
  } else {
#line 3479
    if (dev_state <= 7U) {
#line 3479
      tmp___1 = qdev_state(dev_state);
#line 3479
      tmp___2 = tmp___1;
    } else {
#line 3479
      tmp___2 = (char *)"Unknown";
    }
#line 3479
    ql_log(2U, vha, 45105, "Device state is 0x%x = %s.\n", dev_state, tmp___2);
  }
#line 3483
  return;
}
}
#line 3496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
int qla82xx_abort_isp(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 3498
  rval = -1;
#line 3499
  ha = vha->hw;
#line 3501
  if ((vha->device_flags & 32U) != 0U) {
#line 3502
    ql_log(1U, vha, 32804, "Device in failed state, exiting.\n");
#line 3504
    return (0);
  } else {

  }
#line 3506
  ha->flags.nic_core_reset_hdlr_active = 1U;
#line 3508
  qla82xx_idc_lock(ha);
#line 3509
  qla82xx_set_reset_owner(vha);
#line 3510
  qla82xx_idc_unlock(ha);
#line 3512
  if ((ha->device_type & 16384U) != 0U) {
#line 3513
    rval = qla82xx_device_state_handler(vha);
  } else
#line 3514
  if ((ha->device_type & 262144U) != 0U) {
#line 3515
    qla8044_idc_lock(ha);
#line 3517
    qla83xx_reset_ownership(vha);
#line 3518
    qla8044_idc_unlock(ha);
#line 3519
    rval = qla8044_device_state_handler(vha);
  } else {

  }
#line 3522
  qla82xx_idc_lock(ha);
#line 3523
  qla82xx_clear_rst_ready(ha);
#line 3524
  qla82xx_idc_unlock(ha);
#line 3526
  if (rval == 0) {
#line 3527
    ha->flags.isp82xx_fw_hung = 0U;
#line 3528
    ha->flags.nic_core_reset_hdlr_active = 0U;
#line 3529
    qla82xx_restart_isp(vha);
  } else {

  }
#line 3532
  if (rval != 0) {
#line 3533
    vha->flags.online = 1U;
#line 3534
    tmp = constant_test_bit(10L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3534
    if (tmp != 0) {
#line 3535
      if (ha->isp_abort_cnt == 0U) {
#line 3536
        ql_log(1U, vha, 32807, "ISP error recover failed - board disabled.\n");
#line 3543
        (*((ha->isp_ops)->reset_adapter))(vha);
#line 3544
        vha->flags.online = 0U;
#line 3545
        clear_bit(10L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3547
        rval = 0;
      } else {
#line 3549
        ha->isp_abort_cnt = ha->isp_abort_cnt - 1U;
#line 3550
        ql_log(1U, vha, 32822, "ISP abort - retry remaining %d.\n", ha->isp_abort_cnt);
#line 3553
        rval = 258;
      }
    } else {
#line 3556
      ha->isp_abort_cnt = 5U;
#line 3557
      ql_dbg(4194304U, vha, 32809, "ISP error recovery - retrying (%d) more times.\n",
             ha->isp_abort_cnt);
#line 3560
      set_bit(10L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3561
      rval = 258;
    }
  } else {

  }
#line 3564
  return (rval);
}
}
#line 3580 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
int qla82xx_fcoe_ctx_reset(scsi_qla_host_t *vha ) 
{ 
  int rval ;

  {
#line 3582
  rval = 258;
#line 3584
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 3586
    qla2x00_abort_isp_cleanup(vha);
  } else {

  }
#line 3592
  qla2x00_try_to_stop_firmware(vha);
#line 3595
  rval = qla82xx_restart_isp(vha);
#line 3597
  return (rval);
}
}
#line 3612 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
int qla2x00_wait_for_fcoe_ctx_reset(scsi_qla_host_t *vha ) 
{ 
  int status ;
  unsigned long wait_reset ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 3614
  status = 258;
#line 3617
  wait_reset = (unsigned long )jiffies + 75000UL;
#line 3618
  goto ldv_66866;
  ldv_66865: 
#line 3622
  tmp = get_current();
#line 3622
  tmp->task_state_change = 0UL;
#line 3622
  __ret = 2L;
#line 3622
  switch (8UL) {
  case 1UL: 
#line 3622
  tmp___0 = get_current();
#line 3622
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                       "cc");
#line 3622
  goto ldv_66858;
  case 2UL: 
#line 3622
  tmp___1 = get_current();
#line 3622
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
#line 3622
  goto ldv_66858;
  case 4UL: 
#line 3622
  tmp___2 = get_current();
#line 3622
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
#line 3622
  goto ldv_66858;
  case 8UL: 
#line 3622
  tmp___3 = get_current();
#line 3622
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
#line 3622
  goto ldv_66858;
  default: 
#line 3622
  __xchg_wrong_size();
  }
  ldv_66858: 
#line 3623
  schedule_timeout(250L);
#line 3625
  tmp___4 = constant_test_bit(18L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3625
  if (tmp___4 == 0) {
#line 3625
    tmp___5 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3625
    if (tmp___5 == 0) {
#line 3627
      status = 0;
#line 3628
      goto ldv_66864;
    } else {

    }
  } else {

  }
  ldv_66866: 
#line 3618
  tmp___6 = constant_test_bit(18L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3620
  if (tmp___6 != 0) {
#line 3620
    goto _L;
  } else {
#line 3618
    tmp___7 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3620
    if (tmp___7 != 0) {
      _L: /* CIL Label */ 
#line 3620
      if ((long )((unsigned long )jiffies - wait_reset) < 0L) {
#line 3622
        goto ldv_66865;
      } else {
#line 3625
        goto ldv_66864;
      }
    } else {
#line 3625
      goto ldv_66864;
    }
  }
  ldv_66864: 
#line 3631
  ql_dbg(524288U, vha, 45095, "%s: status=%d.\n", "qla2x00_wait_for_fcoe_ctx_reset",
         status);
#line 3634
  return (status);
}
}
#line 3638 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
void qla82xx_chip_reset_cleanup(scsi_qla_host_t *vha ) 
{ 
  int i ;
  int fw_state ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  int cnt ;
  int que ;
  srb_t *sp ;
  struct req_que *req ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  int tmp___2 ;

  {
#line 3640
  fw_state = 0;
#line 3642
  ha = vha->hw;
#line 3648
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 3649
    i = 0;
#line 3649
    goto ldv_66877;
    ldv_66876: 
#line 3650
    msleep(1000U);
#line 3651
    if ((ha->device_type & 16384U) != 0U) {
#line 3652
      fw_state = qla82xx_check_fw_alive(vha);
    } else
#line 3653
    if ((ha->device_type & 262144U) != 0U) {
#line 3654
      fw_state = qla8044_check_fw_alive(vha);
    } else {

    }
#line 3655
    if (fw_state != 0) {
#line 3656
      ha->flags.isp82xx_fw_hung = 1U;
#line 3657
      qla82xx_clear_pending_mbx(vha);
#line 3658
      goto ldv_66875;
    } else {

    }
#line 3649
    i = i + 1;
    ldv_66877: ;
#line 3649
    if (i <= 1) {
#line 3651
      goto ldv_66876;
    } else {

    }
    ldv_66875: ;
  } else {

  }
#line 3662
  ql_dbg(1073741824U, vha, 176, "Entered %s fw_hung=%d.\n", "qla82xx_chip_reset_cleanup",
         (int )ha->flags.isp82xx_fw_hung);
#line 3667
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 3672
    tmp = spinlock_check(& ha->hardware_lock);
#line 3672
    flags = _raw_spin_lock_irqsave(tmp);
#line 3673
    que = 0;
#line 3673
    goto ldv_66894;
    ldv_66893: 
#line 3674
    req = *(ha->req_q_map + (unsigned long )que);
#line 3675
    if ((unsigned long )req == (unsigned long )((struct req_que *)0)) {
#line 3676
      goto ldv_66886;
    } else {

    }
#line 3677
    cnt = 1;
#line 3677
    goto ldv_66891;
    ldv_66890: 
#line 3678
    sp = *(req->outstanding_cmds + (unsigned long )cnt);
#line 3679
    if ((unsigned long )sp != (unsigned long )((srb_t *)0)) {
#line 3680
      if (((unsigned long )sp->u.scmd.ctx == (unsigned long )((void *)0) || ((int )sp->flags & 4096) != 0) && *((unsigned long *)ha + 2UL) == 0UL) {
#line 3684
        spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3686
        tmp___0 = (*((ha->isp_ops)->abort_command))(sp);
#line 3686
        if (tmp___0 != 0) {
#line 3687
          ql_log(2U, vha, 177, "mbx abort failed.\n");
        } else {
#line 3691
          ql_log(2U, vha, 178, "mbx abort success.\n");
        }
#line 3695
        tmp___1 = spinlock_check(& ha->hardware_lock);
#line 3695
        flags = _raw_spin_lock_irqsave(tmp___1);
      } else {

      }
    } else {

    }
#line 3677
    cnt = cnt + 1;
    ldv_66891: ;
#line 3677
    if ((int )req->num_outstanding_cmds > cnt) {
#line 3679
      goto ldv_66890;
    } else {

    }

    ldv_66886: 
#line 3673
    que = que + 1;
    ldv_66894: ;
#line 3673
    if ((int )ha->max_req_queues > que) {
#line 3675
      goto ldv_66893;
    } else {

    }
#line 3700
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3703
    tmp___2 = qla2x00_eh_wait_for_pending_commands(vha, 0U, 0ULL, 0);
#line 3703
    if (tmp___2 != 0) {
#line 3705
      ql_dbg(1073741824U, vha, 179, "Done wait for pending commands.\n");
    } else {

    }
  } else {

  }
#line 3708
  return;
}
}
#line 3714 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_minidump_process_control(scsi_qla_host_t *vha , qla82xx_md_entry_hdr_t *entry_hdr ,
                                            uint32_t **d_ptr ) 
{ 
  struct qla_hw_data *ha ;
  struct qla82xx_md_entry_crb *crb_entry ;
  uint32_t read_value ;
  uint32_t opcode ;
  uint32_t poll_time ;
  uint32_t addr ;
  uint32_t index ;
  uint32_t crb_addr ;
  unsigned long wtime ;
  struct qla82xx_md_template_hdr *tmplt_hdr ;
  uint32_t rval ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 3717
  ha = vha->hw;
#line 3723
  rval = 0U;
#line 3726
  tmplt_hdr = (struct qla82xx_md_template_hdr *)ha->md_tmplt_hdr;
#line 3727
  crb_entry = (struct qla82xx_md_entry_crb *)entry_hdr;
#line 3728
  crb_addr = crb_entry->addr;
#line 3730
  i = 0;
#line 3730
  goto ldv_66922;
  ldv_66921: 
#line 3731
  opcode = (uint32_t )crb_entry->crb_ctrl.opcode;
#line 3732
  if ((int )opcode & 1) {
#line 3733
    qla82xx_md_rw_32(ha, crb_addr, crb_entry->value_1, 1);
#line 3735
    opcode = opcode & 4294967294U;
  } else {

  }
#line 3738
  if ((opcode & 2U) != 0U) {
#line 3739
    tmp = qla82xx_md_rw_32(ha, crb_addr, 0U, 0);
#line 3739
    read_value = (uint32_t )tmp;
#line 3740
    qla82xx_md_rw_32(ha, crb_addr, read_value, 1);
#line 3741
    opcode = opcode & 4294967293U;
  } else {

  }
#line 3744
  if ((opcode & 4U) != 0U) {
#line 3745
    tmp___0 = qla82xx_md_rw_32(ha, crb_addr, 0U, 0);
#line 3745
    read_value = (uint32_t )tmp___0;
#line 3746
    read_value = crb_entry->value_2 & read_value;
#line 3747
    opcode = opcode & 4294967291U;
#line 3748
    if ((opcode & 8U) != 0U) {
#line 3749
      read_value = crb_entry->value_3 | read_value;
#line 3750
      opcode = opcode & 4294967287U;
    } else {

    }
#line 3752
    qla82xx_md_rw_32(ha, crb_addr, read_value, 1);
  } else {

  }
#line 3755
  if ((opcode & 8U) != 0U) {
#line 3756
    tmp___1 = qla82xx_md_rw_32(ha, crb_addr, 0U, 0);
#line 3756
    read_value = (uint32_t )tmp___1;
#line 3757
    read_value = crb_entry->value_3 | read_value;
#line 3758
    qla82xx_md_rw_32(ha, crb_addr, read_value, 1);
#line 3759
    opcode = opcode & 4294967287U;
  } else {

  }
#line 3762
  if ((opcode & 16U) != 0U) {
#line 3763
    poll_time = (uint32_t )crb_entry->crb_strd.poll_timeout;
#line 3764
    wtime = (unsigned long )poll_time + (unsigned long )jiffies;
#line 3765
    tmp___2 = qla82xx_md_rw_32(ha, crb_addr, 0U, 0);
#line 3765
    read_value = (uint32_t )tmp___2;
    ldv_66920: ;
#line 3768
    if ((crb_entry->value_2 & read_value) == crb_entry->value_1) {
#line 3770
      goto ldv_66913;
    } else
#line 3771
    if ((long )((unsigned long )jiffies - wtime) >= 0L) {
#line 3773
      rval = 258U;
#line 3774
      goto ldv_66913;
    } else {
#line 3776
      tmp___3 = qla82xx_md_rw_32(ha, crb_addr, 0U, 0);
#line 3776
      read_value = (uint32_t )tmp___3;
    }
#line 3778
    goto ldv_66920;
    ldv_66913: 
#line 3779
    opcode = opcode & 4294967279U;
  } else {

  }
#line 3782
  if ((opcode & 32U) != 0U) {
#line 3783
    if ((unsigned int )crb_entry->crb_strd.state_index_a != 0U) {
#line 3784
      index = (uint32_t )crb_entry->crb_strd.state_index_a;
#line 3785
      addr = tmplt_hdr->saved_state_array[index];
    } else {
#line 3787
      addr = crb_addr;
    }
#line 3789
    tmp___4 = qla82xx_md_rw_32(ha, addr, 0U, 0);
#line 3789
    read_value = (uint32_t )tmp___4;
#line 3790
    index = (uint32_t )crb_entry->crb_ctrl.state_index_v;
#line 3791
    tmplt_hdr->saved_state_array[index] = read_value;
#line 3792
    opcode = opcode & 4294967263U;
  } else {

  }
#line 3795
  if ((opcode & 64U) != 0U) {
#line 3796
    if ((unsigned int )crb_entry->crb_strd.state_index_a != 0U) {
#line 3797
      index = (uint32_t )crb_entry->crb_strd.state_index_a;
#line 3798
      addr = tmplt_hdr->saved_state_array[index];
    } else {
#line 3800
      addr = crb_addr;
    }
#line 3802
    if ((unsigned int )crb_entry->crb_ctrl.state_index_v != 0U) {
#line 3803
      index = (uint32_t )crb_entry->crb_ctrl.state_index_v;
#line 3804
      read_value = tmplt_hdr->saved_state_array[index];
    } else {
#line 3807
      read_value = crb_entry->value_1;
    }
#line 3809
    qla82xx_md_rw_32(ha, addr, read_value, 1);
#line 3810
    opcode = opcode & 4294967231U;
  } else {

  }
#line 3813
  if ((opcode & 128U) != 0U) {
#line 3814
    index = (uint32_t )crb_entry->crb_ctrl.state_index_v;
#line 3815
    read_value = tmplt_hdr->saved_state_array[index];
#line 3816
    read_value = read_value << (int )crb_entry->crb_ctrl.shl;
#line 3817
    read_value = read_value >> (int )crb_entry->crb_ctrl.shr;
#line 3818
    if (crb_entry->value_2 != 0U) {
#line 3819
      read_value = crb_entry->value_2 & read_value;
    } else {

    }
#line 3820
    read_value = crb_entry->value_3 | read_value;
#line 3821
    read_value = crb_entry->value_1 + read_value;
#line 3822
    tmplt_hdr->saved_state_array[index] = read_value;
#line 3823
    opcode = opcode & 4294967167U;
  } else {

  }
#line 3825
  crb_addr = (uint32_t )crb_entry->crb_strd.addr_stride + crb_addr;
#line 3730
  i = i + 1;
  ldv_66922: ;
#line 3730
  if ((uint32_t )i < crb_entry->op_count) {
#line 3732
    goto ldv_66921;
  } else {

  }

#line 3827
  return ((int )rval);
}
}
#line 3831 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static void qla82xx_minidump_process_rdocm(scsi_qla_host_t *vha , qla82xx_md_entry_hdr_t *entry_hdr ,
                                           uint32_t **d_ptr ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t r_addr ;
  uint32_t r_stride ;
  uint32_t loop_cnt ;
  uint32_t i ;
  uint32_t r_value ;
  struct qla82xx_md_entry_rdocm *ocm_hdr ;
  uint32_t *data_ptr ;
  uint32_t *tmp ;

  {
#line 3834
  ha = vha->hw;
#line 3837
  data_ptr = *d_ptr;
#line 3839
  ocm_hdr = (struct qla82xx_md_entry_rdocm *)entry_hdr;
#line 3840
  r_addr = ocm_hdr->read_addr;
#line 3841
  r_stride = ocm_hdr->read_addr_stride;
#line 3842
  loop_cnt = ocm_hdr->op_count;
#line 3844
  i = 0U;
#line 3844
  goto ldv_66938;
  ldv_66937: 
#line 3845
  r_value = readl((void const volatile   *)((unsigned long )r_addr + ha->nx_pcibase));
#line 3847
  tmp = data_ptr;
#line 3847
  data_ptr = data_ptr + 1;
#line 3847
  *tmp = r_value;
#line 3848
  r_addr = r_addr + r_stride;
#line 3844
  i = i + 1U;
  ldv_66938: ;
#line 3844
  if (i < loop_cnt) {
#line 3846
    goto ldv_66937;
  } else {

  }
#line 3850
  *d_ptr = data_ptr;
#line 3851
  return;
}
}
#line 3854 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static void qla82xx_minidump_process_rdmux(scsi_qla_host_t *vha , qla82xx_md_entry_hdr_t *entry_hdr ,
                                           uint32_t **d_ptr ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t r_addr ;
  uint32_t s_stride ;
  uint32_t s_addr ;
  uint32_t s_value ;
  uint32_t loop_cnt ;
  uint32_t i ;
  uint32_t r_value ;
  struct qla82xx_md_entry_mux *mux_hdr ;
  uint32_t *data_ptr ;
  int tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;

  {
#line 3857
  ha = vha->hw;
#line 3860
  data_ptr = *d_ptr;
#line 3862
  mux_hdr = (struct qla82xx_md_entry_mux *)entry_hdr;
#line 3863
  r_addr = mux_hdr->read_addr;
#line 3864
  s_addr = mux_hdr->select_addr;
#line 3865
  s_stride = mux_hdr->select_value_stride;
#line 3866
  s_value = mux_hdr->select_value;
#line 3867
  loop_cnt = mux_hdr->op_count;
#line 3869
  i = 0U;
#line 3869
  goto ldv_66956;
  ldv_66955: 
#line 3870
  qla82xx_md_rw_32(ha, s_addr, s_value, 1);
#line 3871
  tmp = qla82xx_md_rw_32(ha, r_addr, 0U, 0);
#line 3871
  r_value = (uint32_t )tmp;
#line 3872
  tmp___0 = data_ptr;
#line 3872
  data_ptr = data_ptr + 1;
#line 3872
  *tmp___0 = s_value;
#line 3873
  tmp___1 = data_ptr;
#line 3873
  data_ptr = data_ptr + 1;
#line 3873
  *tmp___1 = r_value;
#line 3874
  s_value = s_value + s_stride;
#line 3869
  i = i + 1U;
  ldv_66956: ;
#line 3869
  if (i < loop_cnt) {
#line 3871
    goto ldv_66955;
  } else {

  }
#line 3876
  *d_ptr = data_ptr;
#line 3877
  return;
}
}
#line 3880 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static void qla82xx_minidump_process_rdcrb(scsi_qla_host_t *vha , qla82xx_md_entry_hdr_t *entry_hdr ,
                                           uint32_t **d_ptr ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t r_addr ;
  uint32_t r_stride ;
  uint32_t loop_cnt ;
  uint32_t i ;
  uint32_t r_value ;
  struct qla82xx_md_entry_crb *crb_hdr ;
  uint32_t *data_ptr ;
  int tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;

  {
#line 3883
  ha = vha->hw;
#line 3886
  data_ptr = *d_ptr;
#line 3888
  crb_hdr = (struct qla82xx_md_entry_crb *)entry_hdr;
#line 3889
  r_addr = crb_hdr->addr;
#line 3890
  r_stride = (uint32_t )crb_hdr->crb_strd.addr_stride;
#line 3891
  loop_cnt = crb_hdr->op_count;
#line 3893
  i = 0U;
#line 3893
  goto ldv_66972;
  ldv_66971: 
#line 3894
  tmp = qla82xx_md_rw_32(ha, r_addr, 0U, 0);
#line 3894
  r_value = (uint32_t )tmp;
#line 3895
  tmp___0 = data_ptr;
#line 3895
  data_ptr = data_ptr + 1;
#line 3895
  *tmp___0 = r_addr;
#line 3896
  tmp___1 = data_ptr;
#line 3896
  data_ptr = data_ptr + 1;
#line 3896
  *tmp___1 = r_value;
#line 3897
  r_addr = r_addr + r_stride;
#line 3893
  i = i + 1U;
  ldv_66972: ;
#line 3893
  if (i < loop_cnt) {
#line 3895
    goto ldv_66971;
  } else {

  }
#line 3899
  *d_ptr = data_ptr;
#line 3900
  return;
}
}
#line 3903 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_minidump_process_l2tag(scsi_qla_host_t *vha , qla82xx_md_entry_hdr_t *entry_hdr ,
                                          uint32_t **d_ptr ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t addr ;
  uint32_t r_addr ;
  uint32_t c_addr ;
  uint32_t t_r_addr ;
  uint32_t i ;
  uint32_t k ;
  uint32_t loop_count ;
  uint32_t t_value ;
  uint32_t r_cnt ;
  uint32_t r_value ;
  unsigned long p_wait ;
  unsigned long w_time ;
  unsigned long p_mask ;
  uint32_t c_value_w ;
  uint32_t c_value_r ;
  struct qla82xx_md_entry_cache *cache_hdr ;
  int rval ;
  uint32_t *data_ptr ;
  int tmp ;
  int tmp___0 ;
  uint32_t *tmp___1 ;

  {
#line 3906
  ha = vha->hw;
#line 3912
  rval = 258;
#line 3913
  data_ptr = *d_ptr;
#line 3915
  cache_hdr = (struct qla82xx_md_entry_cache *)entry_hdr;
#line 3916
  loop_count = cache_hdr->op_count;
#line 3917
  r_addr = cache_hdr->read_addr;
#line 3918
  c_addr = cache_hdr->control_addr;
#line 3919
  c_value_w = (uint32_t )cache_hdr->cache_ctrl.write_value;
#line 3921
  t_r_addr = cache_hdr->tag_reg_addr;
#line 3922
  t_value = (uint32_t )cache_hdr->addr_ctrl.init_tag_value;
#line 3923
  r_cnt = (uint32_t )cache_hdr->read_ctrl.read_addr_cnt;
#line 3924
  p_wait = (unsigned long )cache_hdr->cache_ctrl.poll_wait;
#line 3925
  p_mask = (unsigned long )cache_hdr->cache_ctrl.poll_mask;
#line 3927
  i = 0U;
#line 3927
  goto ldv_67010;
  ldv_67009: 
#line 3928
  qla82xx_md_rw_32(ha, t_r_addr, t_value, 1);
#line 3929
  if (c_value_w != 0U) {
#line 3930
    qla82xx_md_rw_32(ha, c_addr, c_value_w, 1);
  } else {

  }
#line 3932
  if (p_mask != 0UL) {
#line 3933
    w_time = (unsigned long )jiffies + p_wait;
    ldv_67005: 
#line 3935
    tmp = qla82xx_md_rw_32(ha, c_addr, 0U, 0);
#line 3935
    c_value_r = (uint32_t )tmp;
#line 3936
    if (((unsigned long )c_value_r & p_mask) == 0UL) {
#line 3937
      goto ldv_66998;
    } else
#line 3938
    if ((long )((unsigned long )jiffies - w_time) >= 0L) {
#line 3940
      ql_dbg(524288U, vha, 45106, "c_value_r: 0x%x, poll_mask: 0x%lx, w_time: 0x%lx\n",
             c_value_r, p_mask, w_time);
#line 3944
      return (rval);
    } else {

    }
#line 3946
    goto ldv_67005;
    ldv_66998: ;
  } else {

  }
#line 3949
  addr = r_addr;
#line 3950
  k = 0U;
#line 3950
  goto ldv_67007;
  ldv_67006: 
#line 3951
  tmp___0 = qla82xx_md_rw_32(ha, addr, 0U, 0);
#line 3951
  r_value = (uint32_t )tmp___0;
#line 3952
  tmp___1 = data_ptr;
#line 3952
  data_ptr = data_ptr + 1;
#line 3952
  *tmp___1 = r_value;
#line 3953
  addr = (uint32_t )cache_hdr->read_ctrl.read_addr_stride + addr;
#line 3950
  k = k + 1U;
  ldv_67007: ;
#line 3950
  if (k < r_cnt) {
#line 3952
    goto ldv_67006;
  } else {

  }
#line 3955
  t_value = (uint32_t )cache_hdr->addr_ctrl.tag_value_stride + t_value;
#line 3927
  i = i + 1U;
  ldv_67010: ;
#line 3927
  if (i < loop_count) {
#line 3929
    goto ldv_67009;
  } else {

  }
#line 3957
  *d_ptr = data_ptr;
#line 3958
  return (0);
}
}
#line 3962 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static void qla82xx_minidump_process_l1cache(scsi_qla_host_t *vha , qla82xx_md_entry_hdr_t *entry_hdr ,
                                             uint32_t **d_ptr ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t addr ;
  uint32_t r_addr ;
  uint32_t c_addr ;
  uint32_t t_r_addr ;
  uint32_t i ;
  uint32_t k ;
  uint32_t loop_count ;
  uint32_t t_value ;
  uint32_t r_cnt ;
  uint32_t r_value ;
  uint32_t c_value_w ;
  struct qla82xx_md_entry_cache *cache_hdr ;
  uint32_t *data_ptr ;
  int tmp ;
  uint32_t *tmp___0 ;

  {
#line 3965
  ha = vha->hw;
#line 3970
  data_ptr = *d_ptr;
#line 3972
  cache_hdr = (struct qla82xx_md_entry_cache *)entry_hdr;
#line 3973
  loop_count = cache_hdr->op_count;
#line 3974
  r_addr = cache_hdr->read_addr;
#line 3975
  c_addr = cache_hdr->control_addr;
#line 3976
  c_value_w = (uint32_t )cache_hdr->cache_ctrl.write_value;
#line 3978
  t_r_addr = cache_hdr->tag_reg_addr;
#line 3979
  t_value = (uint32_t )cache_hdr->addr_ctrl.init_tag_value;
#line 3980
  r_cnt = (uint32_t )cache_hdr->read_ctrl.read_addr_cnt;
#line 3982
  i = 0U;
#line 3982
  goto ldv_67035;
  ldv_67034: 
#line 3983
  qla82xx_md_rw_32(ha, t_r_addr, t_value, 1);
#line 3984
  qla82xx_md_rw_32(ha, c_addr, c_value_w, 1);
#line 3985
  addr = r_addr;
#line 3986
  k = 0U;
#line 3986
  goto ldv_67032;
  ldv_67031: 
#line 3987
  tmp = qla82xx_md_rw_32(ha, addr, 0U, 0);
#line 3987
  r_value = (uint32_t )tmp;
#line 3988
  tmp___0 = data_ptr;
#line 3988
  data_ptr = data_ptr + 1;
#line 3988
  *tmp___0 = r_value;
#line 3989
  addr = (uint32_t )cache_hdr->read_ctrl.read_addr_stride + addr;
#line 3986
  k = k + 1U;
  ldv_67032: ;
#line 3986
  if (k < r_cnt) {
#line 3988
    goto ldv_67031;
  } else {

  }
#line 3991
  t_value = (uint32_t )cache_hdr->addr_ctrl.tag_value_stride + t_value;
#line 3982
  i = i + 1U;
  ldv_67035: ;
#line 3982
  if (i < loop_count) {
#line 3984
    goto ldv_67034;
  } else {

  }
#line 3993
  *d_ptr = data_ptr;
#line 3994
  return;
}
}
#line 3997 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static void qla82xx_minidump_process_queue(scsi_qla_host_t *vha , qla82xx_md_entry_hdr_t *entry_hdr ,
                                           uint32_t **d_ptr ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t s_addr ;
  uint32_t r_addr ;
  uint32_t r_stride ;
  uint32_t r_value ;
  uint32_t r_cnt ;
  uint32_t qid ;
  uint32_t i ;
  uint32_t k ;
  uint32_t loop_cnt ;
  struct qla82xx_md_entry_queue *q_hdr ;
  uint32_t *data_ptr ;
  int tmp ;
  uint32_t *tmp___0 ;

  {
#line 4000
  ha = vha->hw;
#line 4002
  qid = 0U;
#line 4005
  data_ptr = *d_ptr;
#line 4007
  q_hdr = (struct qla82xx_md_entry_queue *)entry_hdr;
#line 4008
  s_addr = q_hdr->select_addr;
#line 4009
  r_cnt = (uint32_t )q_hdr->rd_strd.read_addr_cnt;
#line 4010
  r_stride = (uint32_t )q_hdr->rd_strd.read_addr_stride;
#line 4011
  loop_cnt = q_hdr->op_count;
#line 4013
  i = 0U;
#line 4013
  goto ldv_67058;
  ldv_67057: 
#line 4014
  qla82xx_md_rw_32(ha, s_addr, qid, 1);
#line 4015
  r_addr = q_hdr->read_addr;
#line 4016
  k = 0U;
#line 4016
  goto ldv_67055;
  ldv_67054: 
#line 4017
  tmp = qla82xx_md_rw_32(ha, r_addr, 0U, 0);
#line 4017
  r_value = (uint32_t )tmp;
#line 4018
  tmp___0 = data_ptr;
#line 4018
  data_ptr = data_ptr + 1;
#line 4018
  *tmp___0 = r_value;
#line 4019
  r_addr = r_addr + r_stride;
#line 4016
  k = k + 1U;
  ldv_67055: ;
#line 4016
  if (k < r_cnt) {
#line 4018
    goto ldv_67054;
  } else {

  }
#line 4021
  qid = (uint32_t )q_hdr->q_strd.queue_id_stride + qid;
#line 4013
  i = i + 1U;
  ldv_67058: ;
#line 4013
  if (i < loop_cnt) {
#line 4015
    goto ldv_67057;
  } else {

  }
#line 4023
  *d_ptr = data_ptr;
#line 4024
  return;
}
}
#line 4027 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static void qla82xx_minidump_process_rdrom(scsi_qla_host_t *vha , qla82xx_md_entry_hdr_t *entry_hdr ,
                                           uint32_t **d_ptr ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t r_addr ;
  uint32_t r_value ;
  uint32_t i ;
  uint32_t loop_cnt ;
  struct qla82xx_md_entry_rdrom *rom_hdr ;
  uint32_t *data_ptr ;
  int tmp ;
  uint32_t *tmp___0 ;

  {
#line 4030
  ha = vha->hw;
#line 4034
  data_ptr = *d_ptr;
#line 4036
  rom_hdr = (struct qla82xx_md_entry_rdrom *)entry_hdr;
#line 4037
  r_addr = rom_hdr->read_addr;
#line 4038
  loop_cnt = rom_hdr->read_data_size / 4U;
#line 4040
  i = 0U;
#line 4040
  goto ldv_67073;
  ldv_67072: 
#line 4041
  qla82xx_md_rw_32(ha, 1108410416U, r_addr & 4294901760U, 1);
#line 4043
  tmp = qla82xx_md_rw_32(ha, (r_addr & 65535U) + 1108672512U, 0U, 0);
#line 4043
  r_value = (uint32_t )tmp;
#line 4046
  tmp___0 = data_ptr;
#line 4046
  data_ptr = data_ptr + 1;
#line 4046
  *tmp___0 = r_value;
#line 4047
  r_addr = r_addr + 4U;
#line 4040
  i = i + 1U;
  ldv_67073: ;
#line 4040
  if (i < loop_cnt) {
#line 4042
    goto ldv_67072;
  } else {

  }
#line 4049
  *d_ptr = data_ptr;
#line 4050
  return;
}
}
#line 4053 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static int qla82xx_minidump_process_rdmem(scsi_qla_host_t *vha , qla82xx_md_entry_hdr_t *entry_hdr ,
                                          uint32_t **d_ptr ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t r_addr ;
  uint32_t r_value ;
  uint32_t r_data ;
  uint32_t i ;
  uint32_t j ;
  uint32_t loop_cnt ;
  struct qla82xx_md_entry_rdmem *m_hdr ;
  unsigned long flags ;
  int rval ;
  uint32_t *data_ptr ;
  int tmp ;
  struct ratelimit_state _rs ;
  int tmp___0 ;
  int tmp___1 ;
  uint32_t *tmp___2 ;

  {
#line 4056
  ha = vha->hw;
#line 4061
  rval = 258;
#line 4062
  data_ptr = *d_ptr;
#line 4064
  m_hdr = (struct qla82xx_md_entry_rdmem *)entry_hdr;
#line 4065
  r_addr = m_hdr->read_addr;
#line 4066
  loop_cnt = m_hdr->read_data_size / 16U;
#line 4068
  if ((r_addr & 15U) != 0U) {
#line 4069
    ql_log(1U, vha, 45107, "Read addr 0x%x not 16 bytes aligned\n", r_addr);
#line 4071
    return (rval);
  } else {

  }
#line 4074
  if ((m_hdr->read_data_size & 15U) != 0U) {
#line 4075
    ql_log(1U, vha, 45108, "Read data[0x%x] not multiple of 16 bytes\n", m_hdr->read_data_size);
#line 4078
    return (rval);
  } else {

  }
#line 4081
  ql_dbg(524288U, vha, 45109, "[%s]: rdmem_addr: 0x%x, read_data_size: 0x%x, loop_cnt: 0x%x\n",
         "qla82xx_minidump_process_rdmem", r_addr, m_hdr->read_data_size, loop_cnt);
#line 4085
  flags = _raw_write_lock_irqsave(& ha->hw_lock);
#line 4086
  i = 0U;
#line 4086
  goto ldv_67107;
  ldv_67106: 
#line 4087
  qla82xx_md_rw_32(ha, 1090519188U, r_addr, 1);
#line 4088
  r_value = 0U;
#line 4089
  qla82xx_md_rw_32(ha, 1090519192U, r_value, 1);
#line 4090
  r_value = 2U;
#line 4091
  qla82xx_md_rw_32(ha, 1090519184U, r_value, 1);
#line 4092
  r_value = 3U;
#line 4093
  qla82xx_md_rw_32(ha, 1090519184U, r_value, 1);
#line 4095
  j = 0U;
#line 4095
  goto ldv_67097;
  ldv_67096: 
#line 4096
  tmp = qla82xx_md_rw_32(ha, 1090519184U, 0U, 0);
#line 4096
  r_value = (uint32_t )tmp;
#line 4098
  if ((r_value & 8U) == 0U) {
#line 4099
    goto ldv_67095;
  } else {

  }
#line 4095
  j = j + 1U;
  ldv_67097: ;
#line 4095
  if (j <= 999U) {
#line 4097
    goto ldv_67096;
  } else {

  }
  ldv_67095: ;
#line 4102
  if (j > 999U) {
#line 4103
    _rs.lock.raw_lock.val.counter = 0;
#line 4103
    _rs.lock.magic = 3735899821U;
#line 4103
    _rs.lock.owner_cpu = 4294967295U;
#line 4103
    _rs.lock.owner = (void *)-1;
#line 4103
    _rs.lock.dep_map.key = 0;
#line 4103
    _rs.lock.dep_map.class_cache[0] = 0;
#line 4103
    _rs.lock.dep_map.class_cache[1] = 0;
#line 4103
    _rs.lock.dep_map.name = "_rs.lock";
#line 4103
    _rs.lock.dep_map.cpu = 0;
#line 4103
    _rs.lock.dep_map.ip = 0UL;
#line 4103
    _rs.interval = 1250;
#line 4103
    _rs.burst = 10;
#line 4103
    _rs.printed = 0;
#line 4103
    _rs.missed = 0;
#line 4103
    _rs.begin = 0UL;
#line 4103
    tmp___0 = ___ratelimit(& _rs, "qla82xx_minidump_process_rdmem");
#line 4103
    if (tmp___0 != 0) {
#line 4103
      printk("\vfailed to read through agent\n");
    } else {

    }
#line 4105
    _raw_write_unlock_irqrestore(& ha->hw_lock, flags);
#line 4106
    return (rval);
  } else {

  }
#line 4109
  j = 0U;
#line 4109
  goto ldv_67104;
  ldv_67103: 
#line 4110
  tmp___1 = qla82xx_md_rw_32(ha, (uint32_t )MD_MIU_TEST_AGT_RDDATA[j], 0U, 0);
#line 4110
  r_data = (uint32_t )tmp___1;
#line 4112
  tmp___2 = data_ptr;
#line 4112
  data_ptr = data_ptr + 1;
#line 4112
  *tmp___2 = r_data;
#line 4109
  j = j + 1U;
  ldv_67104: ;
#line 4109
  if (j <= 3U) {
#line 4111
    goto ldv_67103;
  } else {

  }
#line 4114
  r_addr = r_addr + 16U;
#line 4086
  i = i + 1U;
  ldv_67107: ;
#line 4086
  if (i < loop_cnt) {
#line 4088
    goto ldv_67106;
  } else {

  }
#line 4116
  _raw_write_unlock_irqrestore(& ha->hw_lock, flags);
#line 4117
  *d_ptr = data_ptr;
#line 4118
  return (0);
}
}
#line 4122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
int qla82xx_validate_template_chksum(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  uint64_t chksum ;
  uint32_t *d_ptr ;
  int count ;
  uint32_t *tmp ;
  int tmp___0 ;

  {
#line 4124
  ha = vha->hw;
#line 4125
  chksum = 0ULL;
#line 4126
  d_ptr = (uint32_t *)ha->md_tmplt_hdr;
#line 4127
  count = (int )(ha->md_template_size / 4U);
#line 4129
  goto ldv_67120;
  ldv_67119: 
#line 4130
  tmp = d_ptr;
#line 4130
  d_ptr = d_ptr + 1;
#line 4130
  chksum = (uint64_t )*tmp + chksum;
  ldv_67120: 
#line 4129
  tmp___0 = count;
#line 4129
  count = count - 1;
#line 4129
  if (tmp___0 > 0) {
#line 4131
    goto ldv_67119;
  } else {

  }

#line 4131
  goto ldv_67123;
  ldv_67122: 
#line 4132
  chksum = (chksum & 4294967295ULL) + (chksum >> 32);
  ldv_67123: ;
#line 4131
  if (chksum >> 32 != 0ULL) {
#line 4133
    goto ldv_67122;
  } else {

  }

#line 4133
  return (~ ((int )chksum));
}
}
#line 4137 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
static void qla82xx_mark_entry_skipped(scsi_qla_host_t *vha , qla82xx_md_entry_hdr_t *entry_hdr ,
                                       int index ) 
{ 


  {
#line 4140
  entry_hdr->d_ctrl.driver_flags = (uint8_t )((unsigned int )entry_hdr->d_ctrl.driver_flags | 128U);
#line 4141
  ql_dbg(524288U, vha, 45110, "Skipping entry[%d]: ETYPE[0x%x]-ELEVEL[0x%x]\n", index,
         entry_hdr->entry_type, (int )entry_hdr->d_ctrl.entry_capture_mask);
#line 4146
  return;
}
}
#line 4149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
int qla82xx_md_collect(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  int no_entry_hdr ;
  qla82xx_md_entry_hdr_t *entry_hdr ;
  struct qla82xx_md_template_hdr *tmplt_hdr ;
  uint32_t *data_ptr ;
  uint32_t total_data_size ;
  uint32_t f_capture_mask ;
  uint32_t data_collected ;
  int i ;
  int rval ;
  int tmp ;

  {
#line 4151
  ha = vha->hw;
#line 4152
  no_entry_hdr = 0;
#line 4156
  total_data_size = 0U;
#line 4156
  data_collected = 0U;
#line 4157
  i = 0;
#line 4157
  rval = 258;
#line 4159
  tmplt_hdr = (struct qla82xx_md_template_hdr *)ha->md_tmplt_hdr;
#line 4160
  data_ptr = (uint32_t *)ha->md_dump;
#line 4162
  if (ha->fw_dumped != 0) {
#line 4163
    ql_log(1U, vha, 45111, "Firmware has been previously dumped (%p) -- ignoring request.\n",
           ha->fw_dump);
#line 4166
    goto md_failed;
  } else {

  }
#line 4169
  ha->fw_dumped = 0;
#line 4171
  if ((unsigned long )ha->md_tmplt_hdr == (unsigned long )((void *)0) || (unsigned long )ha->md_dump == (unsigned long )((void *)0)) {
#line 4172
    ql_log(1U, vha, 45112, "Memory not allocated for minidump capture\n");
#line 4174
    goto md_failed;
  } else {

  }
#line 4177
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 4178
    ql_log(1U, vha, 45140, "Forced reset from application, ignore minidump capture\n");
#line 4181
    ha->flags.isp82xx_no_md_cap = 0U;
#line 4182
    goto md_failed;
  } else {

  }
#line 4185
  tmp = qla82xx_validate_template_chksum(vha);
#line 4185
  if (tmp != 0) {
#line 4186
    ql_log(2U, vha, 45113, "Template checksum validation error\n");
#line 4188
    goto md_failed;
  } else {

  }
#line 4191
  no_entry_hdr = (int )tmplt_hdr->num_of_entries;
#line 4192
  ql_dbg(524288U, vha, 45114, "No of entry headers in Template: 0x%x\n", no_entry_hdr);
#line 4195
  ql_dbg(524288U, vha, 45115, "Capture Mask obtained: 0x%x\n", tmplt_hdr->capture_debug_level);
#line 4198
  f_capture_mask = tmplt_hdr->capture_debug_level & 255U;
#line 4201
  if ((f_capture_mask & 3U) != 3U) {
#line 4202
    ql_log(1U, vha, 45116, "Minimum required capture mask[0x%x] level not set\n",
           f_capture_mask);
#line 4205
    goto md_failed;
  } else {

  }
#line 4207
  tmplt_hdr->driver_capture_mask = (uint32_t )ql2xmdcapmask;
#line 4209
  tmplt_hdr->driver_info[0] = (uint32_t )vha->host_no;
#line 4210
  tmplt_hdr->driver_info[1] = 134676480U;
#line 4214
  total_data_size = ha->md_dump_size;
#line 4216
  ql_dbg(524288U, vha, 45117, "Total minidump data_size 0x%x to be captured\n", total_data_size);
#line 4220
  if (tmplt_hdr->entry_type != 99U) {
#line 4221
    ql_log(1U, vha, 45134, "Bad template header entry type: 0x%x obtained\n", tmplt_hdr->entry_type);
#line 4224
    goto md_failed;
  } else {

  }
#line 4227
  entry_hdr = (qla82xx_md_entry_hdr_t *)ha->md_tmplt_hdr + (unsigned long )tmplt_hdr->first_entry_offset;
#line 4231
  i = 0;
#line 4231
  goto ldv_67165;
  ldv_67164: ;
#line 4233
  if (data_collected > total_data_size) {
#line 4234
    ql_log(1U, vha, 45118, "More MiniDump data collected: [0x%x]\n", data_collected);
#line 4237
    goto md_failed;
  } else {

  }
#line 4240
  if (((int )entry_hdr->d_ctrl.entry_capture_mask & ql2xmdcapmask) == 0) {
#line 4242
    entry_hdr->d_ctrl.driver_flags = (uint8_t )((unsigned int )entry_hdr->d_ctrl.driver_flags | 128U);
#line 4244
    ql_dbg(524288U, vha, 45119, "Skipping entry[%d]: ETYPE[0x%x]-ELEVEL[0x%x]\n",
           i, entry_hdr->entry_type, (int )entry_hdr->d_ctrl.entry_capture_mask);
#line 4249
    goto skip_nxt_entry;
  } else {

  }
#line 4252
  ql_dbg(524288U, vha, 45120, "[%s]: data ptr[%d]: %p, entry_hdr: %p\nentry_type: 0x%x, captrue_mask: 0x%x\n",
         "qla82xx_md_collect", i, data_ptr, entry_hdr, entry_hdr->entry_type, (int )entry_hdr->d_ctrl.entry_capture_mask);
#line 4259
  ql_dbg(524288U, vha, 45121, "Data collected: [0x%x], Dump size left:[0x%x]\n", data_collected,
         ha->md_dump_size - data_collected);
#line 4265
  switch (entry_hdr->entry_type) {
  case 255U: 
#line 4267
  qla82xx_mark_entry_skipped(vha, entry_hdr, i);
#line 4268
  goto ldv_67147;
  case 98U: 
#line 4270
  rval = qla82xx_minidump_process_control(vha, entry_hdr, & data_ptr);
#line 4272
  if (rval != 0) {
#line 4273
    qla82xx_mark_entry_skipped(vha, entry_hdr, i);
#line 4274
    goto md_failed;
  } else {

  }
#line 4276
  goto ldv_67147;
  case 1U: 
#line 4278
  qla82xx_minidump_process_rdcrb(vha, entry_hdr, & data_ptr);
#line 4280
  goto ldv_67147;
  case 72U: 
#line 4282
  rval = qla82xx_minidump_process_rdmem(vha, entry_hdr, & data_ptr);
#line 4284
  if (rval != 0) {
#line 4285
    qla82xx_mark_entry_skipped(vha, entry_hdr, i);
#line 4286
    goto md_failed;
  } else {

  }
#line 4288
  goto ldv_67147;
  case 4U: ;
  case 71U: 
#line 4291
  qla82xx_minidump_process_rdrom(vha, entry_hdr, & data_ptr);
#line 4293
  goto ldv_67147;
  case 21U: ;
  case 22U: ;
  case 23U: ;
  case 24U: 
#line 4298
  rval = qla82xx_minidump_process_l2tag(vha, entry_hdr, & data_ptr);
#line 4300
  if (rval != 0) {
#line 4301
    qla82xx_mark_entry_skipped(vha, entry_hdr, i);
#line 4302
    goto md_failed;
  } else {

  }
#line 4304
  goto ldv_67147;
  case 11U: ;
  case 12U: 
#line 4307
  qla82xx_minidump_process_l1cache(vha, entry_hdr, & data_ptr);
#line 4309
  goto ldv_67147;
  case 6U: 
#line 4311
  qla82xx_minidump_process_rdocm(vha, entry_hdr, & data_ptr);
#line 4313
  goto ldv_67147;
  case 2U: 
#line 4315
  qla82xx_minidump_process_rdmux(vha, entry_hdr, & data_ptr);
#line 4317
  goto ldv_67147;
  case 3U: 
#line 4319
  qla82xx_minidump_process_queue(vha, entry_hdr, & data_ptr);
#line 4321
  goto ldv_67147;
  case 0U: ;
  default: 
#line 4324
  qla82xx_mark_entry_skipped(vha, entry_hdr, i);
#line 4325
  goto ldv_67147;
  }
  ldv_67147: 
#line 4328
  ql_dbg(524288U, vha, 45122, "[%s]: data ptr[%d]: %p\n", "qla82xx_md_collect", i,
         data_ptr);
#line 4331
  data_collected = (uint32_t )((long )data_ptr) - (uint32_t )((long )ha->md_dump);
  skip_nxt_entry: 
#line 4334
  entry_hdr = entry_hdr + (unsigned long )entry_hdr->entry_size;
#line 4231
  i = i + 1;
  ldv_67165: ;
#line 4231
  if (i < no_entry_hdr) {
#line 4233
    goto ldv_67164;
  } else {

  }

#line 4338
  if (data_collected != total_data_size) {
#line 4339
    ql_dbg(524288U, vha, 45123, "MiniDump data mismatch: Data collected: [0x%x],total_data_size:[0x%x]\n",
           data_collected, total_data_size);
#line 4343
    goto md_failed;
  } else {

  }
#line 4346
  ql_log(2U, vha, 45124, "Firmware dump saved to temp buffer (%ld/%p %ld/%p).\n",
         vha->host_no, ha->md_tmplt_hdr, vha->host_no, ha->md_dump);
#line 4349
  ha->fw_dumped = 1;
#line 4350
  qla2x00_post_uevent_work(vha, 0U);
  md_failed: ;
#line 4353
  return (rval);
}
}
#line 4357 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
int qla82xx_md_alloc(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  int i ;
  int k ;
  struct qla82xx_md_template_hdr *tmplt_hdr ;

  {
#line 4359
  ha = vha->hw;
#line 4363
  tmplt_hdr = (struct qla82xx_md_template_hdr *)ha->md_tmplt_hdr;
#line 4365
  if (ql2xmdcapmask <= 2 || ql2xmdcapmask > 127) {
#line 4366
    ql2xmdcapmask = (int )tmplt_hdr->capture_debug_level & 255;
#line 4367
    ql_log(2U, vha, 45125, "Forcing driver capture mask to firmware default capture mask: 0x%x.\n",
           ql2xmdcapmask);
  } else {

  }
#line 4372
  i = 2;
#line 4372
  k = 1;
#line 4372
  goto ldv_67175;
  ldv_67174: ;
#line 4373
  if ((i & ql2xmdcapmask) != 0) {
#line 4374
    ha->md_dump_size = ha->md_dump_size + tmplt_hdr->capture_size_array[k];
  } else {

  }
#line 4372
  i = i << 1;
#line 4372
  k = k + 1;
  ldv_67175: ;
#line 4372
  if ((i & 255) != 0) {
#line 4374
    goto ldv_67174;
  } else {

  }

#line 4377
  if ((unsigned long )ha->md_dump != (unsigned long )((void *)0)) {
#line 4378
    ql_log(1U, vha, 45126, "Firmware dump previously allocated.\n");
#line 4380
    return (1);
  } else {

  }
#line 4383
  ha->md_dump = vmalloc((unsigned long )ha->md_dump_size);
#line 4384
  if ((unsigned long )ha->md_dump == (unsigned long )((void *)0)) {
#line 4385
    ql_log(1U, vha, 45127, "Unable to allocate memory for Minidump size (0x%x).\n",
           ha->md_dump_size);
#line 4388
    return (1);
  } else {

  }
#line 4390
  return (0);
}
}
#line 4394 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
void qla82xx_md_free(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 4396
  ha = vha->hw;
#line 4399
  if ((unsigned long )ha->md_tmplt_hdr != (unsigned long )((void *)0)) {
#line 4400
    ql_log(2U, vha, 45128, "Free MiniDump template: %p, size (%d KB)\n", ha->md_tmplt_hdr,
           ha->md_template_size / 1024U);
#line 4403
    dma_free_attrs(& (ha->pdev)->dev, (size_t )ha->md_template_size, ha->md_tmplt_hdr,
                   ha->md_tmplt_hdr_dma, (struct dma_attrs *)0);
#line 4405
    ha->md_tmplt_hdr = (void *)0;
  } else {

  }
#line 4409
  if ((unsigned long )ha->md_dump != (unsigned long )((void *)0)) {
#line 4410
    ql_log(2U, vha, 45129, "Free MiniDump memory: %p, size (%d KB)\n", ha->md_dump,
           ha->md_dump_size / 1024U);
#line 4413
    vfree((void const   *)ha->md_dump);
#line 4414
    ha->md_dump_size = 0U;
#line 4415
    ha->md_dump = (void *)0;
  } else {

  }
#line 4417
  return;
}
}
#line 4420 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
void qla82xx_md_prep(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  int rval ;

  {
#line 4422
  ha = vha->hw;
#line 4426
  rval = qla82xx_md_get_template_size(vha);
#line 4427
  if (rval == 0) {
#line 4428
    ql_log(2U, vha, 45130, "MiniDump Template size obtained (%d KB)\n", ha->md_template_size / 1024U);
#line 4433
    if ((ha->device_type & 262144U) != 0U) {
#line 4434
      rval = qla8044_md_get_template(vha);
    } else {
#line 4436
      rval = qla82xx_md_get_template(vha);
    }
#line 4438
    if (rval == 0) {
#line 4439
      ql_dbg(524288U, vha, 45131, "MiniDump Template obtained\n");
#line 4443
      rval = qla82xx_md_alloc(vha);
#line 4444
      if (rval == 0) {
#line 4445
        ql_log(2U, vha, 45132, "MiniDump memory allocated (%d KB)\n", ha->md_dump_size / 1024U);
      } else {
#line 4449
        ql_log(2U, vha, 45133, "Free MiniDump template: %p, size: (%d KB)\n", ha->md_tmplt_hdr,
               ha->md_template_size / 1024U);
#line 4453
        dma_free_attrs(& (ha->pdev)->dev, (size_t )ha->md_template_size, ha->md_tmplt_hdr,
                       ha->md_tmplt_hdr_dma, (struct dma_attrs *)0);
#line 4456
        ha->md_tmplt_hdr = (void *)0;
      }
    } else {

    }
  } else {

  }
#line 4460
  return;
}
}
#line 4464 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
int qla82xx_beacon_on(struct scsi_qla_host *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;

  {
#line 4468
  ha = vha->hw;
#line 4469
  qla82xx_idc_lock(ha);
#line 4470
  rval = qla82xx_mbx_beacon_ctl(vha, 1);
#line 4472
  if (rval != 0) {
#line 4473
    ql_log(1U, vha, 45136, "mbx set led config failed in %s\n", "qla82xx_beacon_on");
#line 4475
    goto exit;
  } else {

  }
#line 4477
  ha->beacon_blink_led = 1U;
  exit: 
#line 4479
  qla82xx_idc_unlock(ha);
#line 4480
  return (rval);
}
}
#line 4484 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
int qla82xx_beacon_off(struct scsi_qla_host *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;

  {
#line 4488
  ha = vha->hw;
#line 4489
  qla82xx_idc_lock(ha);
#line 4490
  rval = qla82xx_mbx_beacon_ctl(vha, 0);
#line 4492
  if (rval != 0) {
#line 4493
    ql_log(1U, vha, 45137, "mbx set led config failed in %s\n", "qla82xx_beacon_off");
#line 4495
    goto exit;
  } else {

  }
#line 4497
  ha->beacon_blink_led = 0U;
  exit: 
#line 4499
  qla82xx_idc_unlock(ha);
#line 4500
  return (rval);
}
}
#line 4504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.c"
void qla82xx_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 4506
  ha = vha->hw;
#line 4508
  if (ha->allow_cna_fw_dump == 0) {
#line 4509
    return;
  } else {

  }
#line 4511
  scsi_block_requests(vha->host);
#line 4512
  ha->flags.isp82xx_no_md_cap = 1U;
#line 4513
  qla82xx_idc_lock(ha);
#line 4514
  qla82xx_set_reset_owner(vha);
#line 4515
  qla82xx_idc_unlock(ha);
#line 4516
  qla2x00_wait_for_chip_reset(vha);
#line 4517
  scsi_unblock_requests(vha->host);
#line 4518
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void choose_timer_26(struct timer_list *timer ) 
{ 


  {
#line 489
  LDV_IN_INTERRUPT = 2;
#line 490
  (*(timer->function))(timer->data);
#line 491
  LDV_IN_INTERRUPT = 1;
#line 492
  ldv_timer_state_26 = 2;
#line 493
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void activate_pending_timer_26(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 496
  if ((unsigned long )ldv_timer_list_26 == (unsigned long )timer) {
#line 497
    if (ldv_timer_state_26 == 2 || pending_flag != 0) {
#line 498
      ldv_timer_list_26 = timer;
#line 499
      ldv_timer_list_26->data = data;
#line 500
      ldv_timer_state_26 = 1;
    } else {

    }
#line 502
    return;
  } else {

  }
#line 504
  reg_timer_26(timer);
#line 505
  ldv_timer_list_26->data = data;
#line 506
  return;
}
}
#line 509 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void disable_suitable_timer_26(struct timer_list *timer ) 
{ 


  {
#line 510
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_26) {
#line 511
    ldv_timer_state_26 = 0;
#line 512
    return;
  } else {

  }
#line 514
  return;
}
}
#line 517 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int reg_timer_26(struct timer_list *timer ) 
{ 


  {
#line 518
  ldv_timer_list_26 = timer;
#line 519
  ldv_timer_state_26 = 1;
#line 520
  return (0);
}
}
#line 546 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
bool ldv_queue_work_on_247(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 550
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 550
  ldv_func_res = tmp;
#line 552
  activate_work_7(ldv_func_arg3, 2);
#line 554
  return (ldv_func_res);
}
}
#line 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
bool ldv_queue_delayed_work_on_248(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 561
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 561
  ldv_func_res = tmp;
#line 563
  activate_work_7(& ldv_func_arg3->work, 2);
#line 565
  return (ldv_func_res);
}
}
#line 568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
bool ldv_queue_work_on_249(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 572
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 572
  ldv_func_res = tmp;
#line 574
  activate_work_7(ldv_func_arg3, 2);
#line 576
  return (ldv_func_res);
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void ldv_flush_workqueue_250(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 582
  flush_workqueue(ldv_func_arg1);
#line 584
  call_and_disable_all_7(2);
#line 585
  return;
}
}
#line 587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
bool ldv_queue_delayed_work_on_251(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 591
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 591
  ldv_func_res = tmp;
#line 593
  activate_work_7(& ldv_func_arg3->work, 2);
#line 595
  return (ldv_func_res);
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int ldv_scsi_add_host_with_dma_252(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 602
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 602
  ldv_func_res = tmp;
#line 604
  if (ldv_func_res == 0) {
#line 605
    ldv_state_variable_88 = 1;
#line 605
    ldv_initialize_scsi_host_template_88();
  } else {

  }
#line 609
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 14 "include/asm-generic/bitops/find.h"
extern unsigned long find_next_bit(unsigned long const   * , unsigned long  , unsigned long  ) ;
#line 42
extern unsigned long find_first_bit(unsigned long const   * , unsigned long  ) ;
#line 67 "./arch/x86/include/asm/string_64.h"
extern int strcmp(char const   * , char const   * ) ;
#line 63 "include/linux/string.h"
extern char *strim(char * ) ;
#line 829 "./arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags___0(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 831
  __edi = __edi;
#line 831
  __esi = __esi;
#line 831
  __edx = __edx;
#line 831
  __ecx = __ecx;
#line 831
  __eax = __eax;
#line 831
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
#line 831
  if (tmp != 0L) {
#line 831
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (831), "i" (12UL));
    ldv_4860: ;
#line 831
    goto ldv_4860;
  } else {

  }
#line 831
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (43UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 831
  __ret = __eax;
#line 831
  return (__ret);
}
}
#line 834 "./arch/x86/include/asm/paravirt.h"
__inline static void arch_local_irq_restore___0(unsigned long f ) 
{ 
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 836
  __edi = __edi;
#line 836
  __esi = __esi;
#line 836
  __edx = __edx;
#line 836
  __ecx = __ecx;
#line 836
  __eax = __eax;
#line 836
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.restore_fl.func == (unsigned long )((void *)0),
                         0L);
#line 836
  if (tmp != 0L) {
#line 836
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (836), "i" (12UL));
    ldv_4870: ;
#line 836
    goto ldv_4870;
  } else {

  }
#line 836
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (44UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.restore_fl.func), [paravirt_clobber] "i" (1),
                       "D" (f): "memory", "cc");
#line 838
  return;
}
}
#line 839 "./arch/x86/include/asm/paravirt.h"
__inline static void arch_local_irq_disable___0(void) 
{ 
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 841
  __edi = __edi;
#line 841
  __esi = __esi;
#line 841
  __edx = __edx;
#line 841
  __ecx = __ecx;
#line 841
  __eax = __eax;
#line 841
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.irq_disable.func == (unsigned long )((void *)0),
                         0L);
#line 841
  if (tmp != 0L) {
#line 841
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (841), "i" (12UL));
    ldv_4879: ;
#line 841
    goto ldv_4879;
  } else {

  }
#line 841
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (45UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.irq_disable.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 843
  return;
}
}
#line 849 "./arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_irq_save___0(void) 
{ 
  unsigned long f ;

  {
#line 853
  f = arch_local_save_flags___0();
#line 854
  arch_local_irq_disable___0();
#line 855
  return (f);
}
}
#line 12 "include/linux/timekeeping.h"
extern void do_gettimeofday(struct timeval * ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_263(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_265(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_264(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_267(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_266(struct workqueue_struct *ldv_func_arg1 ) ;
#line 215 "./arch/x86/include/asm/io.h"
__inline static void memcpy_fromio(void *dst , void const volatile   *src , size_t count ) 
{ 


  {
#line 217
  memcpy(dst, (void const   *)src, count);
#line 218
  return;
}
}
#line 221 "./arch/x86/include/asm/io.h"
__inline static void memcpy_toio(void volatile   *dst , void const   *src , size_t count ) 
{ 


  {
#line 223
  memcpy((void *)dst, src, count);
#line 224
  return;
}
}
#line 326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
void choose_timer_27(struct timer_list *timer ) ;
#line 347
void activate_pending_timer_27(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 367
void disable_suitable_timer_27(struct timer_list *timer ) ;
#line 470
int reg_timer_27(struct timer_list *timer ) ;
#line 795 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_268(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
#line 2041 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_def.h"
static char const   * const  port_state_str___4[5U]  = {      "Unknown",      "UNCONFIGURED",      "DEAD",      "LOST", 
        "ONLINE"};
#line 48 "include/linux/delay.h"
extern void usleep_range(unsigned long  , unsigned long  ) ;
#line 58 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_poll___0(struct rsp_que *rsp ) 
{ 
  unsigned long flags ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 61
  ha = rsp->hw;
#line 62
  flags = arch_local_irq_save___0();
#line 62
  trace_hardirqs_off();
#line 63
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 64
    qla82xx_poll(0, (void *)rsp);
  } else {
#line 66
    (*((ha->isp_ops)->intr_handler))(0, (void *)rsp);
  }
#line 67
  tmp = arch_irqs_disabled_flags(flags);
#line 67
  if (tmp != 0) {
#line 67
    arch_local_irq_restore___0(flags);
#line 67
    trace_hardirqs_off();
  } else {
#line 67
    trace_hardirqs_on();
#line 67
    arch_local_irq_restore___0(flags);
  }
#line 69
  return;
}
}
#line 84 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void host_to_adap(uint8_t *src , uint8_t *dst , uint32_t bsize ) 
{ 
  uint32_t *isrc ;
  __le32 *odest ;
  uint32_t iter ;
  __le32 *tmp ;
  uint32_t *tmp___0 ;

  {
#line 86
  isrc = (uint32_t *)src;
#line 87
  odest = (__le32 *)dst;
#line 88
  iter = bsize >> 2;
#line 90
  goto ldv_65668;
  ldv_65667: 
#line 91
  tmp = odest;
#line 91
  odest = odest + 1;
#line 91
  tmp___0 = isrc;
#line 91
  isrc = isrc + 1;
#line 91
  *tmp = *tmp___0;
#line 90
  iter = iter - 1U;
  ldv_65668: ;
#line 90
  if (iter != 0U) {
#line 92
    goto ldv_65667;
  } else {

  }

#line 97
  return;
}
}
#line 159 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_set_fcport_state___3(fc_port_t *fcport , int state ) 
{ 
  int old_state ;

  {
#line 163
  old_state = atomic_read((atomic_t const   *)(& fcport->state));
#line 164
  atomic_set(& fcport->state, state);
#line 167
  if (old_state != 0 && old_state != state) {
#line 168
    ql_dbg(268435456U, fcport->vha, 8317, "FCPort state transitioned from %s to %s - portid=%02x%02x%02x.\n",
           port_state_str___4[old_state], port_state_str___4[state], (int )fcport->d_id.b.domain,
           (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
  } else {

  }
#line 174
  return;
}
}
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
static int qlafx00_mailbox_command(scsi_qla_host_t *vha , struct mbx_cmd_32 *mcp ) 
{ 
  int rval ;
  unsigned long flags ;
  device_reg_t *reg ;
  uint8_t abort_active ;
  uint8_t io_lock_on ;
  uint16_t command ;
  uint32_t *iptr ;
  uint32_t *optr ;
  uint32_t cnt ;
  uint32_t mboxes ;
  unsigned long wait_time ;
  struct qla_hw_data *ha ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  uint32_t *iptr2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 42
  flags = 0UL;
#line 46
  command = 0U;
#line 52
  ha = vha->hw;
#line 53
  tmp = pci_get_drvdata(ha->pdev);
#line 53
  base_vha = (scsi_qla_host_t *)tmp;
#line 55
  if ((ha->pdev)->error_state > 2U) {
#line 56
    ql_log(1U, vha, 4444, "error_state is greater than pci_channel_io_frozen, exiting.\n");
#line 59
    return (256);
  } else {

  }
#line 62
  if ((vha->device_flags & 32U) != 0U) {
#line 63
    ql_log(1U, vha, 4447, "Device in failed state, exiting.\n");
#line 65
    return (256);
  } else {

  }
#line 68
  reg = ha->iobase;
#line 69
  io_lock_on = (uint8_t )base_vha->flags.init_done;
#line 71
  rval = 0;
#line 72
  tmp___0 = constant_test_bit(3L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 72
  abort_active = (uint8_t )tmp___0;
#line 74
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 75
    ql_log(1U, vha, 4469, "Perm failure on EEH timeout MBX, exiting.\n");
#line 77
    return (256);
  } else {

  }
#line 80
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 82
    mcp->mb[0] = 16395U;
#line 83
    ql_log(1U, vha, 4470, "FW hung = %d.\n", (int )ha->flags.isp82xx_fw_hung);
#line 85
    rval = 258;
#line 86
    goto premature_exit;
  } else {

  }
#line 94
  tmp___1 = wait_for_completion_timeout(& ha->mbx_cmd_comp, (unsigned long )(mcp->tov * 250U));
#line 94
  if (tmp___1 == 0UL) {
#line 96
    ql_log(1U, vha, 4471, "Cmd access timeout, cmd=0x%x, Exiting.\n", mcp->mb[0]);
#line 99
    return (256);
  } else {

  }
#line 102
  ha->flags.mbox_busy = 1U;
#line 104
  ha->mcp32 = mcp;
#line 106
  ql_dbg(536870912U, vha, 4472, "Prepare to issue mbox cmd=0x%x.\n", mcp->mb[0]);
#line 109
  tmp___2 = spinlock_check(& ha->hardware_lock);
#line 109
  flags = _raw_spin_lock_irqsave(tmp___2);
#line 112
  optr = & reg->ispfx00.mailbox0;
#line 114
  iptr = (uint32_t *)(& mcp->mb);
#line 115
  command = (uint16_t )mcp->mb[0];
#line 116
  mboxes = mcp->out_mb;
#line 118
  cnt = 0U;
#line 118
  goto ldv_65998;
  ldv_65997: ;
#line 119
  if ((int )mboxes & 1) {
#line 120
    writel(*iptr, (void volatile   *)optr);
  } else {

  }
#line 122
  mboxes = mboxes >> 1;
#line 123
  optr = optr + 1;
#line 124
  iptr = iptr + 1;
#line 118
  cnt = cnt + 1U;
  ldv_65998: ;
#line 118
  if ((uint32_t )ha->mbx_count > cnt) {
#line 120
    goto ldv_65997;
  } else {

  }
#line 128
  ha->flags.mbox_int = 0U;
#line 129
  clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 131
  ql_dump_buffer(537001984U, vha, 4466, (uint8_t *)(& mcp->mb), 16U);
#line 133
  ql_dump_buffer(537001984U, vha, 4467, (uint8_t *)(& mcp->mb) + 16UL, 16U);
#line 135
  ql_dump_buffer(537001984U, vha, 4468, (uint8_t *)(& mcp->mb) + 32UL, 8U);
#line 139
  ql_dbg(536870912U, vha, 4473, "Going to unlock irq & waiting for interrupts. jiffies=%lx.\n",
         jiffies);
#line 144
  if (((unsigned int )abort_active == 0U && (unsigned int )io_lock_on != 0U) || ((ha->device_type & 8192U) != 0U && *((unsigned long *)ha + 2UL) != 0UL)) {
#line 145
    set_bit(2L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 147
    writel(ha->mbx_intr_code, (void volatile   *)ha->cregbase + 133636U);
#line 148
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 150
    wait_for_completion_timeout(& ha->mbx_intr_comp, (unsigned long )(mcp->tov * 250U));
  } else {
#line 152
    ql_dbg(536870912U, vha, 4396, "Cmd=%x Polling Mode.\n", (int )command);
#line 155
    writel(ha->mbx_intr_code, (void volatile   *)ha->cregbase + 133636U);
#line 156
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 158
    wait_time = (unsigned long )(mcp->tov * 250U) + (unsigned long )jiffies;
#line 159
    goto ldv_66008;
    ldv_66007: ;
#line 160
    if ((long )(wait_time - (unsigned long )jiffies) < 0L) {
#line 161
      goto ldv_66006;
    } else {

    }
#line 164
    qla2x00_poll___0(*(ha->rsp_q_map));
#line 166
    if (*((unsigned long *)ha + 2UL) == 0UL && ((ha->device_type & 2U) == 0U || (unsigned int )command != 11U)) {
#line 169
      usleep_range(10000UL, 11000UL);
    } else {

    }
    ldv_66008: ;
#line 159
    if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 161
      goto ldv_66007;
    } else {

    }
    ldv_66006: 
#line 171
    ql_dbg(536870912U, vha, 4397, "Waited %d sec.\n", (unsigned int )((((unsigned long )(mcp->tov * 250U) - wait_time) + (unsigned long )jiffies) / 250UL));
  }
#line 177
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 180
    ql_dbg(536870912U, vha, 4398, "Cmd=%x completed.\n", (int )command);
#line 184
    ha->flags.mbox_int = 0U;
#line 185
    clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 187
    if (ha->mailbox_out32[0] != 16384U) {
#line 188
      rval = 258;
    } else {

    }
#line 191
    iptr2 = (uint32_t *)(& mcp->mb);
#line 192
    iptr = (uint32_t *)(& ha->mailbox_out32);
#line 193
    mboxes = mcp->in_mb;
#line 194
    cnt = 0U;
#line 194
    goto ldv_66011;
    ldv_66010: ;
#line 195
    if ((int )mboxes & 1) {
#line 196
      *iptr2 = *iptr;
    } else {

    }
#line 198
    mboxes = mboxes >> 1;
#line 199
    iptr2 = iptr2 + 1;
#line 200
    iptr = iptr + 1;
#line 194
    cnt = cnt + 1U;
    ldv_66011: ;
#line 194
    if ((uint32_t )ha->mbx_count > cnt) {
#line 196
      goto ldv_66010;
    } else {

    }

  } else {
#line 204
    rval = 256;
  }
#line 207
  ha->flags.mbox_busy = 0U;
#line 210
  ha->mcp32 = (struct mbx_cmd_32 *)0;
#line 212
  if (((unsigned int )abort_active != 0U || (unsigned int )io_lock_on == 0U) && ((ha->device_type & 8192U) == 0U || *((unsigned long *)ha + 2UL) == 0UL)) {
#line 213
    ql_dbg(536870912U, vha, 4410, "checking for additional resp interrupt.\n");
#line 217
    qla2x00_poll___0(*(ha->rsp_q_map));
  } else {

  }
#line 220
  if (rval == 256 && mcp->mb[0] != 42U) {
#line 222
    if (((unsigned int )io_lock_on == 0U || ((int )mcp->flags & 4) != 0) || *((unsigned long *)ha + 2UL) != 0UL) {
#line 225
      ql_dbg(536870912U, vha, 4445, "Timeout, schedule isp_abort_needed.\n");
#line 228
      tmp___3 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 228
      if (tmp___3 == 0) {
#line 228
        tmp___4 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 228
        if (tmp___4 == 0) {
#line 228
          tmp___5 = constant_test_bit(10L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 228
          if (tmp___5 == 0) {
#line 232
            ql_log(2U, base_vha, 4446, "Mailbox cmd timeout occurred, cmd=0x%x, mb[0]=0x%x, eeh_busy=0x%x. Scheduling ISP abort.\n",
                   (int )command, mcp->mb[0], (int )ha->flags.eeh_busy);
#line 237
            set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 238
            qla2xxx_wake_dpc(vha);
          } else {

          }
        } else {

        }
      } else {

      }
    } else
#line 240
    if ((unsigned int )abort_active == 0U) {
#line 242
      ql_dbg(536870912U, vha, 4448, "Timeout, calling abort_isp.\n");
#line 245
      tmp___7 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 245
      if (tmp___7 == 0) {
#line 245
        tmp___8 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 245
        if (tmp___8 == 0) {
#line 245
          tmp___9 = constant_test_bit(10L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 245
          if (tmp___9 == 0) {
#line 249
            ql_log(2U, base_vha, 4449, "Mailbox cmd timeout occurred, cmd=0x%x, mb[0]=0x%x. Scheduling ISP abort ",
                   (int )command, mcp->mb[0]);
#line 254
            set_bit(3L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 255
            clear_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 256
            tmp___6 = (*((ha->isp_ops)->abort_isp))(vha);
#line 256
            if (tmp___6 != 0) {
#line 258
              set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
            } else {

            }
#line 261
            clear_bit(3L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 262
            ql_dbg(536870912U, vha, 4450, "Finished abort_isp.\n");
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
  premature_exit: 
#line 270
  complete(& ha->mbx_cmd_comp);
#line 272
  if (rval != 0) {
#line 273
    ql_log(1U, base_vha, 4451, "**** Failed mbx[0]=%x, mb[1]=%x, mb[2]=%x, mb[3]=%x, cmd=%x ****.\n",
           mcp->mb[0], mcp->mb[1], mcp->mb[2], mcp->mb[3], (int )command);
  } else {
#line 278
    ql_dbg(536870912U, base_vha, 4452, "Done %s.\n", "qlafx00_mailbox_command");
  }
#line 281
  return (rval);
}
}
#line 298 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
int qlafx00_driver_shutdown(scsi_qla_host_t *vha , int tmo ) 
{ 
  int rval ;
  struct mbx_cmd_32 mc ;
  struct mbx_cmd_32 *mcp ;

  {
#line 302
  mcp = & mc;
#line 304
  ql_dbg(536903680U, vha, 4454, "Entered %s.\n", "qlafx00_driver_shutdown");
#line 307
  mcp->mb[0] = 106U;
#line 308
  mcp->out_mb = 1U;
#line 309
  mcp->in_mb = 1U;
#line 310
  if (tmo != 0) {
#line 311
    mcp->tov = (uint32_t )tmo;
  } else {
#line 313
    mcp->tov = 30U;
  }
#line 314
  mcp->flags = 0U;
#line 315
  rval = qlafx00_mailbox_command(vha, mcp);
#line 317
  if (rval != 0) {
#line 318
    ql_dbg(536870912U, vha, 4455, "Failed=%x.\n", rval);
  } else {
#line 321
    ql_dbg(536903680U, vha, 4456, "Done %s.\n", "qlafx00_driver_shutdown");
  }
#line 325
  return (rval);
}
}
#line 344 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
static int qlafx00_get_firmware_state(scsi_qla_host_t *vha , uint32_t *states ) 
{ 
  int rval ;
  struct mbx_cmd_32 mc ;
  struct mbx_cmd_32 *mcp ;

  {
#line 348
  mcp = & mc;
#line 350
  ql_dbg(536903680U, vha, 4457, "Entered %s.\n", "qlafx00_get_firmware_state");
#line 353
  mcp->mb[0] = 105U;
#line 354
  mcp->out_mb = 1U;
#line 355
  mcp->in_mb = 3U;
#line 356
  mcp->tov = 30U;
#line 357
  mcp->flags = 0U;
#line 358
  rval = qlafx00_mailbox_command(vha, mcp);
#line 361
  *states = mcp->mb[1];
#line 363
  if (rval != 0) {
#line 364
    ql_dbg(536870912U, vha, 4458, "Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);
  } else {
#line 367
    ql_dbg(536903680U, vha, 4459, "Done %s.\n", "qlafx00_get_firmware_state");
  }
#line 370
  return (rval);
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
int qlafx00_init_firmware(scsi_qla_host_t *vha , uint16_t size ) 
{ 
  int rval ;
  struct mbx_cmd_32 mc ;
  struct mbx_cmd_32 *mcp ;
  struct qla_hw_data *ha ;

  {
#line 395
  mcp = & mc;
#line 396
  ha = vha->hw;
#line 398
  ql_dbg(536903680U, vha, 4460, "Entered %s.\n", "qlafx00_init_firmware");
#line 401
  mcp->mb[0] = 96U;
#line 403
  mcp->mb[1] = 0U;
#line 404
  mcp->mb[2] = (unsigned int )(ha->init_cb_dma >> 32ULL);
#line 405
  mcp->mb[3] = (unsigned int )ha->init_cb_dma;
#line 407
  mcp->out_mb = 15U;
#line 408
  mcp->in_mb = 1U;
#line 409
  mcp->buf_size = (long )size;
#line 410
  mcp->flags = 2U;
#line 411
  mcp->tov = 30U;
#line 412
  rval = qlafx00_mailbox_command(vha, mcp);
#line 414
  if (rval != 0) {
#line 415
    ql_dbg(536870912U, vha, 4461, "Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);
  } else {
#line 418
    ql_dbg(536903680U, vha, 4462, "Done %s.\n", "qlafx00_init_firmware");
  }
#line 421
  return (rval);
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
static int qlafx00_mbx_reg_test(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct mbx_cmd_32 mc ;
  struct mbx_cmd_32 *mcp ;

  {
#line 432
  mcp = & mc;
#line 434
  ql_dbg(536903680U, vha, 4463, "Entered %s.\n", "qlafx00_mbx_reg_test");
#line 438
  mcp->mb[0] = 6U;
#line 439
  mcp->mb[1] = 43690U;
#line 440
  mcp->mb[2] = 21845U;
#line 441
  mcp->mb[3] = 43605U;
#line 442
  mcp->mb[4] = 21930U;
#line 443
  mcp->mb[5] = 42405U;
#line 444
  mcp->mb[6] = 23130U;
#line 445
  mcp->mb[7] = 9509U;
#line 446
  mcp->mb[8] = 48059U;
#line 447
  mcp->mb[9] = 26214U;
#line 448
  mcp->mb[10] = 47974U;
#line 449
  mcp->mb[11] = 26299U;
#line 450
  mcp->mb[12] = 46774U;
#line 451
  mcp->mb[13] = 27499U;
#line 452
  mcp->mb[14] = 13878U;
#line 453
  mcp->mb[15] = 52428U;
#line 456
  mcp->out_mb = 65535U;
#line 458
  mcp->in_mb = 65535U;
#line 460
  mcp->buf_size = 0L;
#line 461
  mcp->flags = 2U;
#line 462
  mcp->tov = 30U;
#line 463
  rval = qlafx00_mailbox_command(vha, mcp);
#line 464
  if (rval == 0) {
#line 465
    if (((mcp->mb[17] != 43690U || mcp->mb[18] != 21845U) || mcp->mb[19] != 43605U) || mcp->mb[20] != 21930U) {
#line 467
      rval = 258;
    } else {

    }
#line 468
    if (((mcp->mb[21] != 42405U || mcp->mb[22] != 23130U) || mcp->mb[23] != 9509U) || mcp->mb[24] != 48059U) {
#line 470
      rval = 258;
    } else {

    }
#line 471
    if (((mcp->mb[25] != 26214U || mcp->mb[26] != 47974U) || mcp->mb[27] != 26299U) || mcp->mb[28] != 46774U) {
#line 473
      rval = 258;
    } else {

    }
#line 474
    if ((mcp->mb[29] != 27499U || mcp->mb[30] != 13878U) || mcp->mb[31] != 52428U) {
#line 476
      rval = 258;
    } else {

    }
  } else {

  }
#line 479
  if (rval != 0) {
#line 480
    ql_dbg(536870912U, vha, 4464, "Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);
  } else {
#line 483
    ql_dbg(536903680U, vha, 4465, "Done %s.\n", "qlafx00_mbx_reg_test");
  }
#line 486
  return (rval);
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
int qlafx00_pci_config(struct scsi_qla_host *vha ) 
{ 
  uint16_t w ;
  struct qla_hw_data *ha ;
  bool tmp ;

  {
#line 499
  ha = vha->hw;
#line 501
  pci_set_master(ha->pdev);
#line 502
  pci_try_set_mwi(ha->pdev);
#line 504
  pci_read_config_word((struct pci_dev  const  *)ha->pdev, 4, & w);
#line 505
  w = (uint16_t )((unsigned int )w | 320U);
#line 506
  w = (unsigned int )w & 64511U;
#line 507
  pci_write_config_word((struct pci_dev  const  *)ha->pdev, 4, (int )w);
#line 510
  tmp = pci_is_pcie(ha->pdev);
#line 510
  if ((int )tmp) {
#line 511
    pcie_set_readrq(ha->pdev, 2048);
  } else {

  }
#line 513
  ha->chip_revision = (uint16_t )(ha->pdev)->revision;
#line 515
  return (0);
}
}
#line 524 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
__inline static void qlafx00_soc_cpu_reset(scsi_qla_host_t *vha ) 
{ 
  unsigned long flags ;
  struct qla_hw_data *ha ;
  int i ;
  int core ;
  uint32_t cnt ;
  uint32_t reg_val ;
  raw_spinlock_t *tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 526
  flags = 0UL;
#line 527
  ha = vha->hw;
#line 532
  tmp = spinlock_check(& ha->hardware_lock);
#line 532
  flags = _raw_spin_lock_irqsave(tmp);
#line 534
  writel(0U, (void volatile   *)ha->cregbase + 524292U);
#line 535
  writel(0U, (void volatile   *)ha->cregbase + 532484U);
#line 538
  writel(2U, (void volatile   *)ha->cregbase + 395552U);
#line 539
  writel(2U, (void volatile   *)ha->cregbase + 395556U);
#line 540
  writel(2U, (void volatile   *)ha->cregbase + 985376U);
#line 541
  writel(2U, (void volatile   *)ha->cregbase + 985380U);
#line 544
  reg_val = readl((void const volatile   *)ha->cregbase + 395328U);
#line 545
  reg_val = reg_val & 4294963199U;
#line 546
  writel(reg_val, (void volatile   *)ha->cregbase + 395328U);
#line 548
  reg_val = readl((void const volatile   *)ha->cregbase + 395332U);
#line 549
  reg_val = reg_val & 4294963199U;
#line 550
  writel(reg_val, (void volatile   *)ha->cregbase + 395332U);
#line 552
  reg_val = readl((void const volatile   *)ha->cregbase + 395336U);
#line 553
  reg_val = reg_val & 4294963199U;
#line 554
  writel(reg_val, (void volatile   *)ha->cregbase + 395336U);
#line 556
  reg_val = readl((void const volatile   *)ha->cregbase + 395340U);
#line 557
  reg_val = reg_val & 4294963199U;
#line 558
  writel(reg_val, (void volatile   *)ha->cregbase + 395340U);
#line 560
  i = 0;
#line 560
  goto ldv_66065;
  ldv_66064: 
#line 561
  tmp___0 = readl((void const volatile   *)ha->cregbase + 851968U);
#line 561
  if ((tmp___0 & 268435456U) == 0U) {
#line 561
    tmp___1 = readl((void const volatile   *)ha->cregbase + 67072U);
#line 561
    if ((tmp___1 & 1U) == 0U) {
#line 563
      goto ldv_66063;
    } else {

    }
  } else {

  }
#line 564
  __const_udelay(429500UL);
#line 560
  i = i + 1;
  ldv_66065: ;
#line 560
  if (i <= 99999) {
#line 562
    goto ldv_66064;
  } else {

  }
  ldv_66063: 
#line 568
  i = 0;
#line 568
  goto ldv_66067;
  ldv_66066: 
#line 569
  writel(3841U, (void volatile   *)ha->cregbase + (unsigned long )((i + 16640) * 8));
#line 571
  writel(16843009U, (void volatile   *)ha->cregbase + (unsigned long )(i * 8 + 133124));
#line 568
  i = i + 1;
  ldv_66067: ;
#line 568
  if (i <= 3) {
#line 570
    goto ldv_66066;
  } else {

  }
#line 576
  writel(18809089U, (void volatile   *)ha->cregbase + 133184U);
#line 579
  writel(1U, (void volatile   *)ha->cregbase + 67088U);
#line 580
  writel(0U, (void volatile   *)ha->cregbase + 67072U);
#line 583
  i = 0;
#line 583
  goto ldv_66070;
  ldv_66069: 
#line 584
  writel(0U, (void volatile   *)ha->cregbase + (unsigned long )((i + 24707) * 4));
#line 583
  i = i + 1;
  ldv_66070: ;
#line 583
  if (i <= 4) {
#line 585
    goto ldv_66069;
  } else {

  }
#line 589
  i = 0;
#line 589
  goto ldv_66073;
  ldv_66072: 
#line 590
  writel(0U, (void volatile   *)ha->cregbase + (unsigned long )((i + 33472) * 4));
#line 589
  i = i + 1;
  ldv_66073: ;
#line 589
  if (i <= 114) {
#line 591
    goto ldv_66072;
  } else {

  }
#line 595
  core = 0;
#line 595
  goto ldv_66079;
  ldv_66078: 
#line 596
  i = 0;
#line 596
  goto ldv_66076;
  ldv_66075: 
#line 597
  writel(0U, (void volatile   *)ha->cregbase + (unsigned long )(((core * 64 + i) + 34324) * 4));
#line 596
  i = i + 1;
  ldv_66076: ;
#line 596
  if (i <= 7) {
#line 598
    goto ldv_66075;
  } else {

  }
#line 595
  core = core + 1;
  ldv_66079: ;
#line 595
  if (core <= 3) {
#line 597
    goto ldv_66078;
  } else {

  }
#line 601
  core = 0;
#line 601
  goto ldv_66082;
  ldv_66081: 
#line 602
  writel(1023U, (void volatile   *)ha->cregbase + (unsigned long )(core * 256 + 137396));
#line 601
  core = core + 1;
  ldv_66082: ;
#line 601
  if (core <= 3) {
#line 603
    goto ldv_66081;
  } else {

  }
#line 606
  writel(2U, (void volatile   *)ha->cregbase + 131584U);
#line 607
  writel(3U, (void volatile   *)ha->cregbase + 131588U);
#line 610
  writel(0U, (void volatile   *)ha->cregbase + 133184U);
#line 613
  writel(3840U, (void volatile   *)ha->cregbase + 133120U);
#line 615
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 618
  cnt = 10U;
#line 618
  goto ldv_66085;
  ldv_66084: 
#line 619
  msleep(1000U);
#line 620
  __asm__  volatile   ("": : : "memory");
#line 618
  cnt = cnt - 1U;
  ldv_66085: ;
#line 618
  if (cnt != 0U) {
#line 620
    goto ldv_66084;
  } else {

  }

#line 625
  return;
}
}
#line 631 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
void qlafx00_soft_reset(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  int tmp ;
  long tmp___0 ;

  {
#line 633
  ha = vha->hw;
#line 635
  tmp = pci_channel_offline(ha->pdev);
#line 635
  tmp___0 = ldv__builtin_expect((long )(tmp != 0 && *((unsigned long *)ha + 2UL) != 0UL),
                             0L);
#line 635
  if (tmp___0 != 0L) {
#line 637
    return;
  } else {

  }
#line 639
  (*((ha->isp_ops)->disable_intrs))(ha);
#line 640
  qlafx00_soc_cpu_reset(vha);
#line 641
  return;
}
}
#line 650 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
int qlafx00_chip_diag(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  struct req_que *req ;

  {
#line 652
  rval = 0;
#line 653
  ha = vha->hw;
#line 654
  req = *(ha->req_q_map);
#line 656
  ha->fw_transfer_size = (uint32_t )req->length * 64U;
#line 658
  rval = qlafx00_mbx_reg_test(vha);
#line 659
  if (rval != 0) {
#line 660
    ql_log(1U, vha, 4453, "Failed mailbox send register test\n");
  } else {
#line 664
    rval = 0;
  }
#line 666
  return (rval);
}
}
#line 670 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
void qlafx00_config_rings(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct device_reg_fx00 *reg ;

  {
#line 672
  ha = vha->hw;
#line 673
  reg = & (ha->iobase)->ispfx00;
#line 675
  writel(0U, (void volatile   *)(& reg->req_q_in));
#line 676
  writel(0U, (void volatile   *)(& reg->req_q_out));
#line 678
  writel(0U, (void volatile   *)(& reg->rsp_q_in));
#line 679
  writel(0U, (void volatile   *)(& reg->rsp_q_out));
#line 682
  readl((void const volatile   *)(& reg->rsp_q_out));
#line 683
  return;
}
}
#line 686 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
char *qlafx00_pci_info_str(struct scsi_qla_host *vha , char *str ) 
{ 
  struct qla_hw_data *ha ;
  bool tmp ;

  {
#line 688
  ha = vha->hw;
#line 690
  tmp = pci_is_pcie(ha->pdev);
#line 690
  if ((int )tmp) {
#line 691
    strcpy(str, "PCIe iSA");
#line 692
    return (str);
  } else {

  }
#line 694
  return (str);
}
}
#line 698 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
char *qlafx00_fw_version_str(struct scsi_qla_host *vha , char *str , size_t size ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 700
  ha = vha->hw;
#line 702
  snprintf(str, size, "%s", (uint8_t *)(& ha->mr.fw_version));
#line 703
  return (str);
}
}
#line 707 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
void qlafx00_enable_intrs(struct qla_hw_data *ha ) 
{ 
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  unsigned int tmp___0 ;

  {
#line 709
  flags = 0UL;
#line 711
  tmp = spinlock_check(& ha->hardware_lock);
#line 711
  flags = _raw_spin_lock_irqsave(tmp);
#line 712
  ha->interrupts_on = 1U;
#line 713
  tmp___0 = readl((void const volatile   *)ha->cregbase + 133896U);
#line 713
  writel(tmp___0 | 2147483648U, (void volatile   *)ha->cregbase + 133896U);
#line 714
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 715
  return;
}
}
#line 718 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
void qlafx00_disable_intrs(struct qla_hw_data *ha ) 
{ 
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  unsigned int tmp___0 ;

  {
#line 720
  flags = 0UL;
#line 722
  tmp = spinlock_check(& ha->hardware_lock);
#line 722
  flags = _raw_spin_lock_irqsave(tmp);
#line 723
  ha->interrupts_on = 0U;
#line 724
  tmp___0 = readl((void const volatile   *)ha->cregbase + 133896U);
#line 724
  writel(tmp___0 & 2147483647U, (void volatile   *)ha->cregbase + 133896U);
#line 725
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 726
  return;
}
}
#line 729 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
int qlafx00_abort_target(fc_port_t *fcport , uint64_t l , int tag ) 
{ 
  int tmp ;

  {
#line 731
  tmp = qla2x00_async_tm_cmd(fcport, 2U, (uint32_t )l, (uint32_t )tag);
#line 731
  return (tmp);
}
}
#line 735 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
int qlafx00_lun_reset(fc_port_t *fcport , uint64_t l , int tag ) 
{ 
  int tmp ;

  {
#line 737
  tmp = qla2x00_async_tm_cmd(fcport, 16U, (uint32_t )l, (uint32_t )tag);
#line 737
  return (tmp);
}
}
#line 741 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
int qlafx00_loop_reset(scsi_qla_host_t *vha ) 
{ 
  int ret ;
  struct fc_port *fcport ;
  struct qla_hw_data *ha ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 745
  ha = vha->hw;
#line 747
  if (ql2xtargetreset != 0) {
#line 748
    __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 748
    fcport = (struct fc_port *)__mptr;
#line 748
    goto ldv_66149;
    ldv_66148: ;
#line 749
    if ((unsigned int )fcport->port_type != 5U) {
#line 750
      goto ldv_66147;
    } else {

    }
#line 752
    ret = (*((ha->isp_ops)->target_reset))(fcport, 0ULL, 0);
#line 753
    if (ret != 0) {
#line 754
      ql_dbg(4194304U, vha, 32829, "Bus Reset failed: Reset=%d d_id=%x.\n", ret, (int )fcport->d_id.b24);
    } else {

    }
    ldv_66147: 
#line 748
    __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 748
    fcport = (struct fc_port *)__mptr___0;
    ldv_66149: ;
#line 748
    if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 750
      goto ldv_66148;
    } else {

    }

  } else {

  }
#line 760
  return (0);
}
}
#line 764 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
int qlafx00_iospace_config(struct qla_hw_data *ha ) 
{ 
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  void *tmp___6 ;
  char const   *tmp___7 ;
  uint8_t tmp___8 ;

  {
#line 766
  tmp___0 = pci_request_selected_regions(ha->pdev, ha->bars, "qla2xxx");
#line 766
  if (tmp___0 != 0) {
#line 768
    tmp = pci_name((struct pci_dev  const  *)ha->pdev);
#line 768
    ql_log_pci(0U, ha->pdev, 334, "Failed to reserve PIO/MMIO regions (%s), aborting.\n",
               tmp);
#line 771
    goto iospace_error_exit;
  } else {

  }
#line 775
  if (((ha->pdev)->resource[0].flags & 512UL) == 0UL) {
#line 776
    tmp___1 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 776
    ql_log_pci(1U, ha->pdev, 335, "Invalid pci I/O region size (%s).\n", tmp___1);
#line 779
    goto iospace_error_exit;
  } else {

  }
#line 781
  if (((ha->pdev)->resource[0].start == 0ULL && (ha->pdev)->resource[0].end == (ha->pdev)->resource[0].start) || ((ha->pdev)->resource[0].end - (ha->pdev)->resource[0].start) + 1ULL <= 1048575ULL) {
#line 782
    tmp___2 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 782
    ql_log_pci(1U, ha->pdev, 295, "Invalid PCI mem BAR0 region size (%s), aborting\n",
               tmp___2);
#line 785
    goto iospace_error_exit;
  } else {

  }
#line 788
  ha->cregbase = ioremap_nocache((ha->pdev)->resource[0].start, 1048576UL);
#line 790
  if ((unsigned long )ha->cregbase == (unsigned long )((void *)0)) {
#line 791
    tmp___3 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 791
    ql_log_pci(0U, ha->pdev, 296, "cannot remap MMIO (%s), aborting\n", tmp___3);
#line 793
    goto iospace_error_exit;
  } else {

  }
#line 796
  if (((ha->pdev)->resource[2].flags & 512UL) == 0UL) {
#line 797
    tmp___4 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 797
    ql_log_pci(1U, ha->pdev, 297, "region #2 not an MMIO resource (%s), aborting\n",
               tmp___4);
#line 800
    goto iospace_error_exit;
  } else {

  }
#line 802
  if (((ha->pdev)->resource[2].start == 0ULL && (ha->pdev)->resource[2].end == (ha->pdev)->resource[2].start) || ((ha->pdev)->resource[2].end - (ha->pdev)->resource[2].start) + 1ULL <= 131071ULL) {
#line 803
    tmp___5 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 803
    ql_log_pci(1U, ha->pdev, 298, "Invalid PCI mem BAR2 region size (%s), aborting\n",
               tmp___5);
#line 806
    goto iospace_error_exit;
  } else {

  }
#line 809
  tmp___6 = ioremap_nocache((ha->pdev)->resource[2].start, 131072UL);
#line 809
  ha->iobase = (device_reg_t *)tmp___6;
#line 811
  if ((unsigned long )ha->iobase == (unsigned long )((device_reg_t *)0)) {
#line 812
    tmp___7 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 812
    ql_log_pci(0U, ha->pdev, 299, "cannot remap MMIO (%s), aborting\n", tmp___7);
#line 814
    goto iospace_error_exit;
  } else {

  }
#line 818
  tmp___8 = 1U;
#line 818
  ha->max_rsp_queues = tmp___8;
#line 818
  ha->max_req_queues = tmp___8;
#line 820
  ql_log_pci(2U, ha->pdev, 300, "Bars 0x%x, iobase0 0x%p, iobase2 0x%p\n", ha->bars,
             ha->cregbase, ha->iobase);
#line 824
  return (0);
  iospace_error_exit: ;
#line 827
  return (-12);
}
}
#line 831 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
static void qlafx00_save_queue_ptrs(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct rsp_que *rsp ;

  {
#line 833
  ha = vha->hw;
#line 834
  req = *(ha->req_q_map);
#line 835
  rsp = *(ha->rsp_q_map);
#line 837
  req->length_fx00 = req->length;
#line 838
  req->ring_fx00 = req->ring;
#line 839
  req->dma_fx00 = req->dma;
#line 841
  rsp->length_fx00 = rsp->length;
#line 842
  rsp->ring_fx00 = rsp->ring;
#line 843
  rsp->dma_fx00 = rsp->dma;
#line 845
  ql_dbg(1073741824U, vha, 301, "req: %p, ring_fx00: %p, length_fx00: 0x%x,req->dma_fx00: 0x%llx\n",
         req, req->ring_fx00, (int )req->length_fx00, req->dma_fx00);
#line 850
  ql_dbg(1073741824U, vha, 302, "rsp: %p, ring_fx00: %p, length_fx00: 0x%x,rsp->dma_fx00: 0x%llx\n",
         rsp, rsp->ring_fx00, (int )rsp->length_fx00, rsp->dma_fx00);
#line 854
  return;
}
}
#line 857 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
static int qlafx00_config_queues(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  dma_addr_t bar2_hdl ;

  {
#line 859
  ha = vha->hw;
#line 860
  req = *(ha->req_q_map);
#line 861
  rsp = *(ha->rsp_q_map);
#line 862
  bar2_hdl = (ha->pdev)->resource[2].start;
#line 864
  req->length = (uint16_t )ha->req_que_len;
#line 865
  req->ring = (request_t *)ha->iobase + (unsigned long )ha->req_que_off;
#line 866
  req->dma = (dma_addr_t )ha->req_que_off + bar2_hdl;
#line 867
  if ((unsigned long )req->ring == (unsigned long )((request_t *)0) || (unsigned int )req->length == 0U) {
#line 868
    ql_log_pci(2U, ha->pdev, 303, "Unable to allocate memory for req_ring\n");
#line 870
    return (258);
  } else {

  }
#line 873
  ql_dbg(1073741824U, vha, 304, "req: %p req_ring pointer %p req len 0x%x req off 0x%x\n, req->dma: 0x%llx",
         req, req->ring, (int )req->length, ha->req_que_off, req->dma);
#line 879
  rsp->length = (uint16_t )ha->rsp_que_len;
#line 880
  rsp->ring = (response_t *)ha->iobase + (unsigned long )ha->rsp_que_off;
#line 881
  rsp->dma = (dma_addr_t )ha->rsp_que_off + bar2_hdl;
#line 882
  if ((unsigned long )rsp->ring == (unsigned long )((response_t *)0) || (unsigned int )rsp->length == 0U) {
#line 883
    ql_log_pci(2U, ha->pdev, 305, "Unable to allocate memory for rsp_ring\n");
#line 885
    return (258);
  } else {

  }
#line 888
  ql_dbg(1073741824U, vha, 306, "rsp: %p rsp_ring pointer %p rsp len 0x%x rsp off 0x%x, rsp->dma: 0x%llx\n",
         rsp, rsp->ring, (int )rsp->length, ha->rsp_que_off, rsp->dma);
#line 894
  return (0);
}
}
#line 898 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
static int qlafx00_init_fw_ready(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  unsigned long wtime ;
  uint16_t wait_time ;
  struct qla_hw_data *ha ;
  struct device_reg_fx00 *reg ;
  uint32_t aenmbx ;
  uint32_t aenmbx7 ;
  uint32_t pseudo_aen ;
  uint32_t state[5U] ;
  bool done ;
  unsigned int tmp ;

  {
#line 900
  rval = 0;
#line 903
  ha = vha->hw;
#line 904
  reg = & (ha->iobase)->ispfx00;
#line 905
  aenmbx7 = 0U;
#line 908
  done = 0;
#line 911
  wait_time = 30U;
#line 913
  pseudo_aen = readl((void const volatile   *)(& reg->pseudoaen));
#line 914
  if (pseudo_aen == 1U) {
#line 915
    aenmbx7 = readl((void const volatile   *)(& reg->initval7));
#line 916
    ha->mbx_intr_code = (uint32_t )((unsigned short )(aenmbx7 >> 16));
#line 917
    ha->rqstq_intr_code = (uint32_t )((unsigned short )aenmbx7);
#line 918
    rval = qlafx00_driver_shutdown(vha, 10);
#line 919
    if (rval != 0) {
#line 920
      qlafx00_soft_reset(vha);
    } else {

    }
  } else {

  }
#line 924
  wtime = (unsigned long )((int )wait_time * 250) + (unsigned long )jiffies;
  ldv_66197: 
#line 926
  aenmbx = readl((void const volatile   *)(& reg->aenmailbox0));
#line 927
  __asm__  volatile   ("": : : "memory");
#line 928
  ql_dbg(536870912U, vha, 307, "aenmbx: 0x%x\n", aenmbx);
#line 931
  switch (aenmbx) {
  case 32848U: ;
  case 32849U: ;
#line 934
  goto ldv_66183;
  case 32770U: ;
  case 32771U: ;
  case 32772U: ;
  case 33793U: 
#line 940
  qlafx00_soft_reset(vha);
#line 941
  goto ldv_66183;
  case 32864U: 
#line 945
  aenmbx7 = readl((void const volatile   *)(& reg->aenmailbox7));
#line 946
  ha->mbx_intr_code = (uint32_t )((unsigned short )(aenmbx7 >> 16));
#line 947
  ha->rqstq_intr_code = (uint32_t )((unsigned short )aenmbx7);
#line 948
  ha->req_que_off = readl((void const volatile   *)(& reg->aenmailbox1));
#line 949
  ha->rsp_que_off = readl((void const volatile   *)(& reg->aenmailbox3));
#line 950
  ha->req_que_len = readl((void const volatile   *)(& reg->aenmailbox5));
#line 951
  ha->rsp_que_len = readl((void const volatile   *)(& reg->aenmailbox6));
#line 952
  writel(0U, (void volatile   *)(& reg->aenmailbox0));
#line 953
  __readl((void const volatile   *)(& reg->aenmailbox0));
#line 954
  ql_dbg(1073741824U, vha, 308, "f/w returned mbx_intr_code: 0x%x, rqstq_intr_code: 0x%x\n",
         ha->mbx_intr_code, ha->rqstq_intr_code);
#line 958
  writel(4294967288U, (void volatile   *)ha->cregbase + 138096U);
#line 959
  rval = 0;
#line 960
  done = 1;
#line 961
  goto ldv_66183;
  default: ;
#line 964
  if ((aenmbx & 65280U) == 34048U) {
#line 965
    goto ldv_66183;
  } else {

  }
#line 983
  aenmbx7 = readl((void const volatile   *)(& reg->initval7));
#line 984
  ha->mbx_intr_code = (uint32_t )((unsigned short )(aenmbx7 >> 16));
#line 985
  ha->rqstq_intr_code = (uint32_t )((unsigned short )aenmbx7);
#line 986
  ha->req_que_off = readl((void const volatile   *)(& reg->initval1));
#line 987
  ha->rsp_que_off = readl((void const volatile   *)(& reg->initval3));
#line 988
  ha->req_que_len = readl((void const volatile   *)(& reg->initval5));
#line 989
  ha->rsp_que_len = readl((void const volatile   *)(& reg->initval6));
#line 990
  ql_dbg(1073741824U, vha, 309, "f/w returned mbx_intr_code: 0x%x, rqstq_intr_code: 0x%x\n",
         ha->mbx_intr_code, ha->rqstq_intr_code);
#line 994
  writel(4294967288U, (void volatile   *)ha->cregbase + 138096U);
#line 997
  rval = qlafx00_get_firmware_state(vha, (uint32_t *)(& state));
#line 998
  if (rval != 0) {
#line 1000
    goto ldv_66183;
  } else {

  }
#line 1003
  if (state[0] == 0U) {
#line 1007
    rval = 0;
#line 1008
    done = 1;
#line 1009
    goto ldv_66183;
  } else {

  }
#line 1016
  ql_dbg(1073741824U, vha, 310, "Sending Driver shutdown fw_state 0x%x\n", state[0]);
#line 1020
  rval = qlafx00_driver_shutdown(vha, 10);
#line 1021
  if (rval != 0) {
#line 1022
    rval = 258;
#line 1023
    goto ldv_66183;
  } else {

  }
#line 1025
  msleep(500U);
#line 1027
  wtime = (unsigned long )((int )wait_time * 250) + (unsigned long )jiffies;
#line 1028
  goto ldv_66183;
  }
  ldv_66183: ;
#line 1031
  if (! done) {
#line 1032
    if ((long )((unsigned long )jiffies - wtime) >= 0L) {
#line 1033
      tmp = readl((void const volatile   *)(& reg->aenmailbox7));
#line 1033
      ql_dbg(1073741824U, vha, 311, "Init f/w failed: aen[7]: 0x%x\n", tmp);
#line 1036
      rval = 258;
#line 1037
      done = 1;
#line 1038
      goto ldv_66196;
    } else {

    }
#line 1041
    msleep(500U);
  } else {

  }
#line 1043
  if (! done) {
#line 1045
    goto ldv_66197;
  } else {

  }
  ldv_66196: ;
#line 1045
  if (rval != 0) {
#line 1046
    ql_dbg(1073741824U, vha, 312, "%s **** FAILED ****.\n", "qlafx00_init_fw_ready");
  } else {
#line 1049
    ql_dbg(1073741824U, vha, 313, "%s **** SUCCESS ****.\n", "qlafx00_init_fw_ready");
  }
#line 1052
  return (rval);
}
}
#line 1062 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
int qlafx00_fw_ready(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  unsigned long wtime ;
  uint16_t wait_time ;
  uint32_t state[5U] ;

  {
#line 1069
  rval = 0;
#line 1071
  wait_time = 10U;
#line 1074
  wtime = (unsigned long )((int )wait_time * 250) + (unsigned long )jiffies;
#line 1077
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 1078
    ql_dbg(1073741824U, vha, 314, "Waiting for init to complete...\n");
  } else {

  }
  ldv_66213: 
#line 1082
  rval = qlafx00_get_firmware_state(vha, (uint32_t *)(& state));
#line 1084
  if (rval == 0) {
#line 1085
    if (state[0] == 4096U) {
#line 1086
      ql_dbg(1073741824U, vha, 315, "fw_state=%x\n", state[0]);
#line 1088
      rval = 0;
#line 1089
      goto ldv_66206;
    } else {

    }
  } else {

  }
#line 1092
  rval = 258;
#line 1094
  if ((long )((unsigned long )jiffies - wtime) >= 0L) {
#line 1095
    goto ldv_66206;
  } else {

  }
#line 1098
  msleep(500U);
#line 1100
  ql_dbg(1073741824U, vha, 316, "fw_state=%x curr time=%lx.\n", state[0], jiffies);
#line 1102
  goto ldv_66213;
  ldv_66206: ;
#line 1105
  if (rval != 0) {
#line 1106
    ql_dbg(1073741824U, vha, 317, "Firmware ready **** FAILED ****.\n");
  } else {
#line 1109
    ql_dbg(1073741824U, vha, 318, "Firmware ready **** SUCCESS ****.\n");
  }
#line 1112
  return (rval);
}
}
#line 1116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
static int qlafx00_find_all_targets(scsi_qla_host_t *vha , struct list_head *new_fcports ) 
{ 
  int rval ;
  uint16_t tgt_id ;
  fc_port_t *fcport ;
  fc_port_t *new_fcport ;
  int found ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  struct list_head  const  *__mptr ;
  int tmp___4 ;
  int tmp___5 ;
  u64 tmp___6 ;
  u64 tmp___7 ;
  int tmp___8 ;
  u64 tmp___9 ;
  u64 tmp___10 ;
  int tmp___11 ;
  struct list_head  const  *__mptr___0 ;
  unsigned long tmp___12 ;

  {
#line 1123
  ha = vha->hw;
#line 1125
  rval = 0;
#line 1127
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1127
  if (tmp == 0) {
#line 1128
    return (258);
  } else {

  }
#line 1130
  tmp___0 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 1130
  if (tmp___0 != 0) {
#line 1132
    atomic_set(& vha->loop_down_timer, 0);
#line 1133
    set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1134
    return (258);
  } else {
#line 1130
    tmp___1 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1130
    if (tmp___1 != 0) {
#line 1132
      atomic_set(& vha->loop_down_timer, 0);
#line 1133
      set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1134
      return (258);
    } else {
#line 1130
      tmp___2 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1130
      if (tmp___2 != 0) {
#line 1132
        atomic_set(& vha->loop_down_timer, 0);
#line 1133
        set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1134
        return (258);
      } else {

      }
    }
  }
#line 1137
  ql_dbg(1342177280U, vha, 8328, "Listing Target bit map...\n");
#line 1139
  ql_dump_buffer(1342177280U, vha, 8329, (uint8_t *)ha->gid_list, 32U);
#line 1143
  new_fcport = qla2x00_alloc_fcport(vha, 208U);
#line 1144
  if ((unsigned long )new_fcport == (unsigned long )((fc_port_t *)0)) {
#line 1145
    return (259);
  } else {

  }
#line 1147
  tmp___3 = find_first_bit((unsigned long const   *)ha->gid_list, 128UL);
#line 1147
  tgt_id = (uint16_t )tmp___3;
#line 1147
  goto ldv_66235;
  ldv_66234: 
#line 1151
  new_fcport->tgt_id = tgt_id;
#line 1152
  rval = qlafx00_fx_disc(vha, new_fcport, 128);
#line 1154
  if (rval != 0) {
#line 1155
    ql_log(1U, vha, 8330, "Target info scan failed -- assuming zero-entry result...\n");
#line 1158
    goto ldv_66224;
  } else {

  }
#line 1162
  found = 0;
#line 1163
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 1163
  fcport = (fc_port_t *)__mptr;
#line 1163
  goto ldv_66233;
  ldv_66232: 
#line 1164
  tmp___4 = memcmp((void const   *)(& new_fcport->port_name), (void const   *)(& fcport->port_name),
                   8UL);
#line 1164
  if (tmp___4 != 0) {
#line 1166
    goto ldv_66229;
  } else {

  }
#line 1168
  found = found + 1;
#line 1174
  if ((int )fcport->tgt_id == (int )new_fcport->tgt_id) {
#line 1174
    tmp___5 = atomic_read((atomic_t const   *)(& fcport->state));
#line 1174
    if (tmp___5 == 4) {
#line 1176
      goto ldv_66230;
    } else {

    }
  } else {

  }
#line 1181
  tmp___6 = wwn_to_u64((u8 *)(& fcport->port_name));
#line 1181
  tmp___7 = wwn_to_u64((u8 *)(& fcport->node_name));
#line 1181
  tmp___8 = atomic_read((atomic_t const   *)(& fcport->state));
#line 1181
  ql_dbg(1342177280U, vha, 8331, "TGT-ID Change(%s): Present tgt id: 0x%x state: 0x%x wwnn = %llx wwpn = %llx.\n",
         "qlafx00_find_all_targets", (int )fcport->tgt_id, tmp___8, tmp___7, tmp___6);
#line 1190
  tmp___9 = wwn_to_u64((u8 *)(& new_fcport->port_name));
#line 1190
  tmp___10 = wwn_to_u64((u8 *)(& new_fcport->node_name));
#line 1190
  ql_log(2U, vha, 8332, "TGT-ID Announce(%s): Discovered tgt id 0x%x wwnn = %llx wwpn = %llx.\n",
         "qlafx00_find_all_targets", (int )new_fcport->tgt_id, tmp___10, tmp___9);
#line 1199
  tmp___11 = atomic_read((atomic_t const   *)(& fcport->state));
#line 1199
  if (tmp___11 != 4) {
#line 1200
    fcport->old_tgt_id = fcport->tgt_id;
#line 1201
    fcport->tgt_id = new_fcport->tgt_id;
#line 1202
    ql_log(2U, vha, 8333, "TGT-ID: New fcport Added: %p\n", fcport);
#line 1204
    qla2x00_update_fcport(vha, fcport);
  } else {
#line 1206
    ql_log(2U, vha, 8334, " Existing TGT-ID %x did not get  offline event from firmware.\n",
           (int )fcport->old_tgt_id);
#line 1210
    qla2x00_mark_device_lost(vha, fcport, 0, 0);
#line 1211
    set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1212
    kfree((void const   *)new_fcport);
#line 1213
    return (rval);
  }
#line 1215
  goto ldv_66230;
  ldv_66229: 
#line 1163
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 1163
  fcport = (fc_port_t *)__mptr___0;
  ldv_66233: ;
#line 1163
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 1165
    goto ldv_66232;
  } else {

  }
  ldv_66230: ;
#line 1218
  if (found != 0) {
#line 1219
    goto ldv_66224;
  } else {

  }
#line 1222
  list_add_tail(& new_fcport->list, new_fcports);
#line 1225
  new_fcport = qla2x00_alloc_fcport(vha, 208U);
#line 1226
  if ((unsigned long )new_fcport == (unsigned long )((fc_port_t *)0)) {
#line 1227
    return (259);
  } else {

  }
  ldv_66224: 
#line 1147
  tmp___12 = find_next_bit((unsigned long const   *)ha->gid_list, 128UL, (unsigned long )((int )tgt_id + 1));
#line 1147
  tgt_id = (uint16_t )tmp___12;
  ldv_66235: ;
#line 1147
  if ((unsigned int )tgt_id <= 127U) {
#line 1149
    goto ldv_66234;
  } else {

  }
#line 1230
  kfree((void const   *)new_fcport);
#line 1231
  return (rval);
}
}
#line 1246 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
static int qlafx00_configure_all_targets(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  fc_port_t *fcport ;
  fc_port_t *rmptemp ;
  struct list_head new_fcports ;
  struct list_head  const  *__mptr ;
  int tmp ;
  int tmp___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  int tmp___1 ;
  u64 tmp___2 ;
  u64 tmp___3 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;
  struct list_head  const  *__mptr___5 ;
  struct list_head  const  *__mptr___6 ;

  {
#line 1250
  new_fcports.next = & new_fcports;
#line 1250
  new_fcports.prev = & new_fcports;
#line 1252
  rval = qlafx00_fx_disc(vha, & (vha->hw)->mr.fcport, 129);
#line 1254
  if (rval != 0) {
#line 1255
    set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1256
    return (rval);
  } else {

  }
#line 1259
  rval = qlafx00_find_all_targets(vha, & new_fcports);
#line 1260
  if (rval != 0) {
#line 1261
    set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1262
    return (rval);
  } else {

  }
#line 1268
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 1268
  fcport = (fc_port_t *)__mptr;
#line 1268
  goto ldv_66250;
  ldv_66249: 
#line 1269
  tmp = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1269
  if (tmp != 0) {
#line 1270
    goto ldv_66248;
  } else {

  }
#line 1272
  tmp___0 = atomic_read((atomic_t const   *)(& fcport->state));
#line 1272
  if (tmp___0 == 3) {
#line 1273
    if ((unsigned int )fcport->port_type != 4U) {
#line 1274
      qla2x00_mark_device_lost(vha, fcport, 0, 0);
    } else {

    }
  } else {

  }
#line 1268
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 1268
  fcport = (fc_port_t *)__mptr___0;
  ldv_66250: ;
#line 1268
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 1270
    goto ldv_66249;
  } else {

  }
  ldv_66248: 
#line 1281
  __mptr___1 = (struct list_head  const  *)new_fcports.next;
#line 1281
  fcport = (fc_port_t *)__mptr___1;
#line 1281
  __mptr___2 = (struct list_head  const  *)fcport->list.next;
#line 1281
  rmptemp = (fc_port_t *)__mptr___2;
#line 1281
  goto ldv_66259;
  ldv_66258: 
#line 1282
  tmp___1 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1282
  if (tmp___1 != 0) {
#line 1283
    goto ldv_66257;
  } else {

  }
#line 1285
  qla2x00_update_fcport(vha, fcport);
#line 1286
  list_move_tail(& fcport->list, & vha->vp_fcports);
#line 1287
  tmp___2 = wwn_to_u64((u8 *)(& fcport->port_name));
#line 1287
  tmp___3 = wwn_to_u64((u8 *)(& fcport->node_name));
#line 1287
  ql_log(2U, vha, 8335, "Attach new target id 0x%x wwnn = %llx wwpn = %llx.\n", (int )fcport->tgt_id,
         tmp___3, tmp___2);
#line 1281
  fcport = rmptemp;
#line 1281
  __mptr___3 = (struct list_head  const  *)rmptemp->list.next;
#line 1281
  rmptemp = (fc_port_t *)__mptr___3;
  ldv_66259: ;
#line 1281
  if ((unsigned long )(& fcport->list) != (unsigned long )(& new_fcports)) {
#line 1283
    goto ldv_66258;
  } else {

  }
  ldv_66257: 
#line 1296
  __mptr___4 = (struct list_head  const  *)new_fcports.next;
#line 1296
  fcport = (fc_port_t *)__mptr___4;
#line 1296
  __mptr___5 = (struct list_head  const  *)fcport->list.next;
#line 1296
  rmptemp = (fc_port_t *)__mptr___5;
#line 1296
  goto ldv_66267;
  ldv_66266: 
#line 1297
  list_del(& fcport->list);
#line 1298
  kfree((void const   *)fcport);
#line 1296
  fcport = rmptemp;
#line 1296
  __mptr___6 = (struct list_head  const  *)rmptemp->list.next;
#line 1296
  rmptemp = (fc_port_t *)__mptr___6;
  ldv_66267: ;
#line 1296
  if ((unsigned long )(& fcport->list) != (unsigned long )(& new_fcports)) {
#line 1298
    goto ldv_66266;
  } else {

  }

#line 1301
  return (rval);
}
}
#line 1317 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
int qlafx00_configure_devices(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  unsigned long flags ;
  unsigned long save_flags ;
  int tmp ;

  {
#line 1321
  rval = 0;
#line 1323
  flags = vha->dpc_flags;
#line 1323
  save_flags = flags;
#line 1325
  ql_dbg(268435456U, vha, 8336, "Configure devices -- dpc flags =0x%lx\n", flags);
#line 1328
  rval = qlafx00_configure_all_targets(vha);
#line 1330
  if (rval == 0) {
#line 1331
    tmp = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1331
    if (tmp != 0) {
#line 1332
      rval = 258;
    } else {
#line 1334
      atomic_set(& vha->loop_state, 5);
#line 1335
      ql_log(2U, vha, 8337, "Device Ready\n");
    }
  } else {

  }
#line 1340
  if (rval != 0) {
#line 1341
    ql_dbg(268435456U, vha, 8338, "%s *** FAILED ***.\n", "qlafx00_configure_devices");
  } else {
#line 1344
    ql_dbg(268435456U, vha, 8339, "%s: exiting normally.\n", "qlafx00_configure_devices");
  }
#line 1347
  return (rval);
}
}
#line 1351 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
static void qlafx00_abort_isp_cleanup(scsi_qla_host_t *vha , bool critemp ) 
{ 
  struct qla_hw_data *ha ;
  fc_port_t *fcport ;
  int tmp ;
  int tmp___0 ;
  struct list_head  const  *__mptr ;
  int tmp___1 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1353
  ha = vha->hw;
#line 1356
  vha->flags.online = 0U;
#line 1357
  ha->mr.fw_hbt_en = 0U;
#line 1359
  if (! critemp) {
#line 1360
    ha->flags.chip_reset_done = 0U;
#line 1361
    clear_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1362
    vha->qla_stats.total_isp_aborts = vha->qla_stats.total_isp_aborts + 1U;
#line 1363
    ql_log(2U, vha, 319, "Performing ISP error recovery - ha = %p.\n", ha);
#line 1365
    (*((ha->isp_ops)->reset_chip))(vha);
  } else {

  }
#line 1368
  tmp___0 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 1368
  if (tmp___0 != 2) {
#line 1369
    atomic_set(& vha->loop_state, 2);
#line 1370
    atomic_set(& vha->loop_down_timer, 615);
  } else {
#line 1373
    tmp = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 1373
    if (tmp == 0) {
#line 1374
      atomic_set(& vha->loop_down_timer, 615);
    } else {

    }
  }
#line 1379
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 1379
  fcport = (fc_port_t *)__mptr;
#line 1379
  goto ldv_66287;
  ldv_66286: 
#line 1380
  fcport->flags = 0U;
#line 1381
  tmp___1 = atomic_read((atomic_t const   *)(& fcport->state));
#line 1381
  if (tmp___1 == 4) {
#line 1382
    qla2x00_set_fcport_state___3(fcport, 3);
  } else {

  }
#line 1379
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 1379
  fcport = (fc_port_t *)__mptr___0;
  ldv_66287: ;
#line 1379
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 1381
    goto ldv_66286;
  } else {

  }

#line 1385
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 1386
    if ((int )critemp) {
#line 1387
      qla2x00_abort_all_cmds(vha, 65536);
    } else {
#line 1390
      qla2x00_abort_all_cmds(vha, 524288);
    }
  } else {

  }
#line 1394
  qla2x00_free_irqs(vha);
#line 1395
  if ((int )critemp) {
#line 1396
    set_bit(25L, (unsigned long volatile   *)(& vha->dpc_flags));
  } else {
#line 1398
    set_bit(23L, (unsigned long volatile   *)(& vha->dpc_flags));
  }
#line 1401
  writel(4294967288U, (void volatile   *)ha->cregbase + 138096U);
#line 1403
  ql_log(2U, vha, 320, "%s Done done - ha=%p.\n", "qlafx00_abort_isp_cleanup", ha);
#line 1405
  return;
}
}
#line 1417 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
void qlafx00_init_response_q_entries(struct rsp_que *rsp ) 
{ 
  uint16_t cnt ;
  response_t *pkt ;

  {
#line 1422
  rsp->ring_ptr = rsp->ring;
#line 1423
  rsp->ring_index = 0U;
#line 1424
  rsp->status_srb = (srb_t *)0;
#line 1425
  pkt = rsp->ring_ptr;
#line 1426
  cnt = 0U;
#line 1426
  goto ldv_66296;
  ldv_66295: 
#line 1427
  pkt->signature = 3735936685U;
#line 1428
  writel(3735936685U, (void volatile   *)(& pkt->signature));
#line 1430
  pkt = pkt + 1;
#line 1426
  cnt = (uint16_t )((int )cnt + 1);
  ldv_66296: ;
#line 1426
  if ((int )rsp->length > (int )cnt) {
#line 1428
    goto ldv_66295;
  } else {

  }

#line 1433
  return;
}
}
#line 1435 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
int qlafx00_rescan_isp(scsi_qla_host_t *vha ) 
{ 
  uint32_t status ;
  struct qla_hw_data *ha ;
  struct device_reg_fx00 *reg ;
  uint32_t aenmbx7 ;
  int tmp ;
  int tmp___0 ;

  {
#line 1437
  status = 258U;
#line 1438
  ha = vha->hw;
#line 1439
  reg = & (ha->iobase)->ispfx00;
#line 1442
  qla2x00_request_irqs(ha, *(ha->rsp_q_map));
#line 1444
  aenmbx7 = readl((void const volatile   *)(& reg->aenmailbox7));
#line 1445
  ha->mbx_intr_code = (uint32_t )((unsigned short )(aenmbx7 >> 16));
#line 1446
  ha->rqstq_intr_code = (uint32_t )((unsigned short )aenmbx7);
#line 1447
  ha->req_que_off = readl((void const volatile   *)(& reg->aenmailbox1));
#line 1448
  ha->rsp_que_off = readl((void const volatile   *)(& reg->aenmailbox3));
#line 1449
  ha->req_que_len = readl((void const volatile   *)(& reg->aenmailbox5));
#line 1450
  ha->rsp_que_len = readl((void const volatile   *)(& reg->aenmailbox6));
#line 1452
  ql_dbg(268435456U, vha, 8340, "fw returned mbx_intr_code: 0x%x, rqstq_intr_code: 0x%x  Req que offset 0x%x Rsp que offset 0x%x\n",
         ha->mbx_intr_code, ha->rqstq_intr_code, ha->req_que_off, ha->rsp_que_len);
#line 1459
  writel(4294967288U, (void volatile   *)ha->cregbase + 138096U);
#line 1461
  tmp = qla2x00_init_rings(vha);
#line 1461
  status = (uint32_t )tmp;
#line 1462
  if (status == 0U) {
#line 1463
    vha->flags.online = 1U;
#line 1466
    if ((vha->device_flags & 2U) != 0U) {
#line 1467
      status = 0U;
    } else {

    }
#line 1469
    tmp___0 = qlafx00_fx_disc(vha, & (vha->hw)->mr.fcport, 153);
#line 1469
    if (tmp___0 != 0) {
#line 1471
      ql_dbg(268435456U, vha, 8341, "failed to register host info\n");
    } else {

    }
  } else {

  }
#line 1474
  scsi_unblock_requests(vha->host);
#line 1475
  return ((int )status);
}
}
#line 1479 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
void qlafx00_timer_routine(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t fw_heart_beat ;
  uint32_t aenmbx0 ;
  struct device_reg_fx00 *reg ;
  uint32_t tempc ;
  int tmp ;
  int tmp___0 ;
  uint32_t data0 ;
  uint32_t data1 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 1481
  ha = vha->hw;
#line 1484
  reg = & (ha->iobase)->ispfx00;
#line 1488
  if ((unsigned int )ha->mr.fw_hbt_cnt != 0U) {
#line 1489
    ha->mr.fw_hbt_cnt = (uint8_t )((int )ha->mr.fw_hbt_cnt - 1);
  } else {
#line 1491
    if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 1491
      tmp = constant_test_bit(15L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1491
      if (tmp == 0) {
#line 1491
        tmp___0 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1491
        if (tmp___0 == 0) {
#line 1491
          if ((unsigned int )ha->mr.fw_hbt_en != 0U) {
#line 1495
            fw_heart_beat = readl((void const volatile   *)(& reg->fwheartbeat));
#line 1496
            if (ha->mr.old_fw_hbt_cnt != fw_heart_beat) {
#line 1497
              ha->mr.old_fw_hbt_cnt = fw_heart_beat;
#line 1498
              ha->mr.fw_hbt_miss_cnt = 0U;
            } else {
#line 1500
              ha->mr.fw_hbt_miss_cnt = (uint8_t )((int )ha->mr.fw_hbt_miss_cnt + 1);
#line 1501
              if ((unsigned int )ha->mr.fw_hbt_miss_cnt == 3U) {
#line 1503
                set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1505
                qla2xxx_wake_dpc(vha);
#line 1506
                ha->mr.fw_hbt_miss_cnt = 0U;
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
#line 1510
    ha->mr.fw_hbt_cnt = 6U;
  }
#line 1513
  tmp___1 = constant_test_bit(23L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1513
  if (tmp___1 != 0) {
#line 1515
    aenmbx0 = readl((void const volatile   *)(& reg->aenmailbox0));
#line 1516
    if ((unsigned int )ha->mr.fw_reset_timer_exp != 0U) {
#line 1517
      set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1518
      qla2xxx_wake_dpc(vha);
#line 1519
      ha->mr.fw_reset_timer_exp = 0U;
    } else
#line 1520
    if (aenmbx0 == 32864U) {
#line 1522
      set_bit(24L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1523
      clear_bit(23L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1524
      qla2xxx_wake_dpc(vha);
#line 1525
      ha->mr.fw_reset_timer_tick = 120U;
    } else
#line 1526
    if (aenmbx0 == 32849U && (unsigned int )ha->mr.fw_hbt_en == 0U) {
#line 1528
      ha->mr.fw_hbt_en = 1U;
    } else
#line 1529
    if ((unsigned int )ha->mr.fw_reset_timer_tick == 0U) {
#line 1530
      if (ha->mr.old_aenmbx0_state == aenmbx0) {
#line 1531
        ha->mr.fw_reset_timer_exp = 1U;
      } else {

      }
#line 1532
      ha->mr.fw_reset_timer_tick = 120U;
    } else
#line 1533
    if (aenmbx0 == 4294967295U) {
#line 1536
      data0 = readl((void const volatile   *)ha->cregbase + 262168U);
#line 1538
      data1 = readl((void const volatile   *)ha->cregbase + 268324U);
#line 1541
      data0 = data0 & 4294901760U;
#line 1542
      data1 = data1 & 65535U;
#line 1544
      writel(data0 | data1, (void volatile   *)ha->cregbase + 268324U);
    } else
#line 1547
    if ((aenmbx0 & 65280U) == 34304U) {
#line 1548
      ha->mr.fw_reset_timer_tick = 600U;
    } else
#line 1550
    if (aenmbx0 == 34050U) {
#line 1551
      ha->mr.fw_reset_timer_tick = 600U;
    } else {

    }
#line 1554
    if (ha->mr.old_aenmbx0_state != aenmbx0) {
#line 1555
      ha->mr.old_aenmbx0_state = aenmbx0;
#line 1556
      ha->mr.fw_reset_timer_tick = 120U;
    } else {

    }
#line 1558
    ha->mr.fw_reset_timer_tick = (uint16_t )((int )ha->mr.fw_reset_timer_tick - 1);
  } else {

  }
#line 1560
  tmp___3 = constant_test_bit(25L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1560
  if (tmp___3 != 0) {
#line 1565
    if ((unsigned int )ha->mr.fw_critemp_timer_tick == 0U) {
#line 1566
      tmp___2 = readl((void const volatile   *)ha->cregbase + 99524U);
#line 1566
      tempc = (3153000U - ((tmp___2 & 1022U) >> 1) * 10000U) / 13825U;
#line 1567
      ql_dbg(16777216U, vha, 24594, "ISPFx00(%s): Critical temp timer, current SOC temperature: %d\n",
             "qlafx00_timer_routine", tempc);
#line 1571
      if (ha->mr.critical_temperature > tempc) {
#line 1572
        set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1573
        clear_bit(25L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1575
        qla2xxx_wake_dpc(vha);
      } else {

      }
#line 1577
      ha->mr.fw_critemp_timer_tick = 60U;
    } else {
#line 1580
      ha->mr.fw_critemp_timer_tick = (uint16_t )((int )ha->mr.fw_critemp_timer_tick - 1);
    }
  } else {

  }
#line 1583
  if ((int )ha->mr.host_info_resend) {
#line 1588
    if ((unsigned int )ha->mr.hinfo_resend_timer_tick == 0U) {
#line 1589
      ha->mr.host_info_resend = 0;
#line 1590
      set_bit(26L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1591
      ha->mr.hinfo_resend_timer_tick = 60U;
#line 1593
      qla2xxx_wake_dpc(vha);
    } else {
#line 1595
      ha->mr.hinfo_resend_timer_tick = (uint8_t )((int )ha->mr.hinfo_resend_timer_tick - 1);
    }
  } else {

  }
#line 1596
  return;
}
}
#line 1612 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
int qlafx00_reset_initialize(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 1614
  ha = vha->hw;
#line 1616
  if ((vha->device_flags & 32U) != 0U) {
#line 1617
    ql_dbg(1073741824U, vha, 322, "Device in failed state\n");
#line 1619
    return (0);
  } else {

  }
#line 1622
  ha->flags.mr_reset_hdlr_active = 1U;
#line 1624
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 1625
    scsi_block_requests(vha->host);
#line 1626
    qlafx00_abort_isp_cleanup(vha, 0);
  } else {

  }
#line 1629
  ql_log(2U, vha, 323, "(%s): succeeded.\n", "qlafx00_reset_initialize");
#line 1631
  ha->flags.mr_reset_hdlr_active = 0U;
#line 1632
  return (0);
}
}
#line 1646 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
int qlafx00_abort_isp(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  int tmp ;
  long tmp___0 ;

  {
#line 1648
  ha = vha->hw;
#line 1650
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 1651
    tmp = pci_channel_offline(ha->pdev);
#line 1651
    tmp___0 = ldv__builtin_expect((long )(tmp != 0 && *((unsigned long *)ha + 2UL) != 0UL),
                               0L);
#line 1651
    if (tmp___0 != 0L) {
#line 1653
      clear_bit(10L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1654
      return (0);
    } else {

    }
#line 1657
    scsi_block_requests(vha->host);
#line 1658
    qlafx00_abort_isp_cleanup(vha, 0);
  } else {
#line 1660
    scsi_block_requests(vha->host);
#line 1661
    clear_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1662
    vha->qla_stats.total_isp_aborts = vha->qla_stats.total_isp_aborts + 1U;
#line 1663
    (*((ha->isp_ops)->reset_chip))(vha);
#line 1664
    set_bit(23L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1666
    writel(4294967288U, (void volatile   *)ha->cregbase + 138096U);
  }
#line 1669
  ql_log(2U, vha, 325, "(%s): succeeded.\n", "qlafx00_abort_isp");
#line 1672
  return (0);
}
}
#line 1676 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
__inline static fc_port_t *qlafx00_get_fcport(struct scsi_qla_host *vha , int tgt_id ) 
{ 
  fc_port_t *fcport ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1681
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 1681
  fcport = (fc_port_t *)__mptr;
#line 1681
  goto ldv_66336;
  ldv_66335: ;
#line 1682
  if ((int )fcport->tgt_id == tgt_id) {
#line 1683
    ql_dbg(33554432U, vha, 20594, "Matching fcport(%p) found with TGT-ID: 0x%x and Remote TGT_ID: 0x%x\n",
           fcport, (int )fcport->tgt_id, tgt_id);
#line 1687
    return (fcport);
  } else {

  }
#line 1681
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 1681
  fcport = (fc_port_t *)__mptr___0;
  ldv_66336: ;
#line 1681
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 1683
    goto ldv_66335;
  } else {

  }

#line 1690
  return ((fc_port_t *)0);
}
}
#line 1694 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
static void qlafx00_tgt_detach(struct scsi_qla_host *vha , int tgt_id ) 
{ 
  fc_port_t *fcport ;

  {
#line 1698
  ql_log(2U, vha, 20595, "Detach TGT-ID: 0x%x\n", tgt_id);
#line 1701
  fcport = qlafx00_get_fcport(vha, tgt_id);
#line 1702
  if ((unsigned long )fcport == (unsigned long )((fc_port_t *)0)) {
#line 1703
    return;
  } else {

  }
#line 1705
  qla2x00_mark_device_lost(vha, fcport, 0, 0);
#line 1707
  return;
}
}
#line 1711 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
int qlafx00_process_aen(struct scsi_qla_host *vha , struct qla_work_evt *evt ) 
{ 
  int rval ;
  uint32_t aen_code ;
  uint32_t aen_data ;
  u32 tmp ;

  {
#line 1713
  rval = 0;
#line 1716
  aen_code = 65535U;
#line 1717
  aen_data = evt->u.aenfx.evtcode;
#line 1719
  switch (evt->u.aenfx.evtcode) {
  case 32788U: ;
#line 1721
  if (evt->u.aenfx.mbx[1] == 0U) {
#line 1722
    if (evt->u.aenfx.mbx[2] == 1U) {
#line 1723
      if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 1724
        vha->flags.fw_tgt_reported = 1U;
      } else {

      }
#line 1725
      atomic_set(& vha->loop_down_timer, 0);
#line 1726
      atomic_set(& vha->loop_state, 3);
#line 1727
      set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1728
      qla2xxx_wake_dpc(vha);
    } else
#line 1729
    if (evt->u.aenfx.mbx[2] == 2U) {
#line 1730
      qlafx00_tgt_detach(vha, (int )evt->u.aenfx.mbx[3]);
    } else {

    }
  } else
#line 1732
  if (evt->u.aenfx.mbx[1] == 65535U) {
#line 1733
    if (evt->u.aenfx.mbx[2] == 1U) {
#line 1734
      if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 1735
        vha->flags.fw_tgt_reported = 1U;
      } else {

      }
#line 1736
      set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
    } else
#line 1737
    if (evt->u.aenfx.mbx[2] == 2U) {
#line 1738
      vha->device_flags = vha->device_flags | 2U;
#line 1739
      qla2x00_mark_all_devices_lost(vha, 1);
    } else {

    }
  } else {

  }
#line 1742
  goto ldv_66351;
  case 32785U: 
#line 1744
  aen_code = 2U;
#line 1745
  aen_data = 0U;
#line 1746
  goto ldv_66351;
  case 32786U: 
#line 1748
  aen_code = 3U;
#line 1749
  aen_data = 0U;
#line 1750
  goto ldv_66351;
  case 32775U: 
#line 1752
  ql_log(2U, vha, 20610, "Process critical temperature event aenmb[0]: %x\n", evt->u.aenfx.evtcode);
#line 1756
  scsi_block_requests(vha->host);
#line 1757
  qlafx00_abort_isp_cleanup(vha, 1);
#line 1758
  scsi_unblock_requests(vha->host);
#line 1759
  goto ldv_66351;
  }
  ldv_66351: 
#line 1762
  tmp = fc_get_event_number();
#line 1762
  fc_host_post_event(vha->host, tmp, (enum fc_host_event_code )aen_code, aen_data);
#line 1765
  return (rval);
}
}
#line 1769 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
static void qlafx00_update_host_attr(scsi_qla_host_t *vha , struct port_info_data *pinfo ) 
{ 
  u64 port_name ;
  u64 node_name ;

  {
#line 1771
  port_name = 0ULL;
#line 1771
  node_name = 0ULL;
#line 1773
  port_name = wwn_to_u64((u8 *)(& pinfo->port_name));
#line 1774
  node_name = wwn_to_u64((u8 *)(& pinfo->node_name));
#line 1776
  ((struct fc_host_attrs *)(vha->host)->shost_data)->node_name = node_name;
#line 1777
  ((struct fc_host_attrs *)(vha->host)->shost_data)->port_name = port_name;
#line 1778
  if ((unsigned int )pinfo->port_type == 0U) {
#line 1779
    (vha->hw)->current_topology = 8U;
  } else {

  }
#line 1780
  if ((unsigned int )pinfo->link_status == 17U) {
#line 1781
    atomic_set(& vha->loop_state, 5);
  } else
#line 1782
  if ((unsigned int )pinfo->link_status == 16U) {
#line 1783
    atomic_set(& vha->loop_state, 2);
  } else {

  }
#line 1784
  (vha->hw)->link_data_rate = (unsigned short )pinfo->link_config;
#line 1785
  return;
}
}
#line 1788 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
static void qla2x00_fxdisc_iocb_timeout(void *data ) 
{ 
  srb_t *sp ;
  struct srb_iocb *lio ;

  {
#line 1790
  sp = (srb_t *)data;
#line 1791
  lio = & sp->u.iocb_cmd;
#line 1793
  complete(& lio->u.fxiocb.fxiocb_comp);
#line 1794
  return;
}
}
#line 1797 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
static void qla2x00_fxdisc_sp_done(void *data , void *ptr , int res ) 
{ 
  srb_t *sp ;
  struct srb_iocb *lio ;

  {
#line 1799
  sp = (srb_t *)ptr;
#line 1800
  lio = & sp->u.iocb_cmd;
#line 1802
  complete(& lio->u.fxiocb.fxiocb_comp);
#line 1803
  return;
}
}
#line 1806 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
int qlafx00_fx_disc(scsi_qla_host_t *vha , fc_port_t *fcport , uint16_t fx_type ) 
{ 
  srb_t *sp ;
  struct srb_iocb *fdisc ;
  int rval ;
  struct qla_hw_data *ha ;
  struct host_system_info *phost_info ;
  struct register_host_info *preg_hsi ;
  struct new_utsname *p_sysid ;
  struct timeval tv ;
  int tmp ;
  struct config_info_data *pinfo ;
  struct port_info_data *pinfo___0 ;
  struct qlafx00_tgt_node_info *pinfo___1 ;
  struct qlafx00_tgt_node_info *pinfo___2 ;

  {
#line 1810
  rval = 258;
#line 1811
  ha = vha->hw;
#line 1814
  p_sysid = (struct new_utsname *)0;
#line 1817
  sp = qla2x00_get_sp(vha, fcport, 208U);
#line 1818
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 1819
    goto done;
  } else {

  }
#line 1821
  fdisc = & sp->u.iocb_cmd;
#line 1822
  switch ((int )fx_type) {
  case 1: 
#line 1824
  fdisc->u.fxiocb.flags = 2U;
#line 1826
  fdisc->u.fxiocb.rsp_len = 500U;
#line 1827
  goto ldv_66388;
  case 2: 
#line 1829
  fdisc->u.fxiocb.flags = 6U;
#line 1831
  fdisc->u.fxiocb.rsp_len = 304U;
#line 1832
  fdisc->u.fxiocb.req_data = (unsigned int )fcport->port_id;
#line 1833
  goto ldv_66388;
  case 128: 
#line 1835
  fdisc->u.fxiocb.flags = 6U;
#line 1837
  fdisc->u.fxiocb.rsp_len = 212U;
#line 1838
  fdisc->u.fxiocb.req_data = (unsigned int )fcport->tgt_id;
#line 1839
  goto ldv_66388;
  case 129: 
#line 1841
  fdisc->u.fxiocb.flags = 6U;
#line 1843
  fdisc->u.fxiocb.rsp_len = 128U;
#line 1844
  goto ldv_66388;
  case 153: 
#line 1846
  fdisc->u.fxiocb.flags = 1U;
#line 1847
  fdisc->u.fxiocb.req_len = 1036U;
#line 1848
  p_sysid = utsname();
#line 1849
  if ((unsigned long )p_sysid == (unsigned long )((struct new_utsname *)0)) {
#line 1850
    ql_log(1U, vha, 12348, "Not able to get the system information\n");
#line 1852
    goto done_free_sp;
  } else {

  }
#line 1854
  goto ldv_66388;
  case 255: ;
  default: ;
#line 1857
  goto ldv_66388;
  }
  ldv_66388: ;
#line 1860
  if ((int )fdisc->u.fxiocb.flags & 1) {
#line 1861
    fdisc->u.fxiocb.req_addr = dma_alloc_attrs(& (ha->pdev)->dev, (size_t )fdisc->u.fxiocb.req_len,
                                               & fdisc->u.fxiocb.req_dma_handle, 208U,
                                               (struct dma_attrs *)0);
#line 1864
    if ((unsigned long )fdisc->u.fxiocb.req_addr == (unsigned long )((void *)0)) {
#line 1865
      goto done_free_sp;
    } else {

    }
#line 1867
    if ((unsigned int )fx_type == 153U) {
#line 1868
      preg_hsi = (struct register_host_info *)fdisc->u.fxiocb.req_addr;
#line 1870
      phost_info = & preg_hsi->hsi;
#line 1871
      memset((void *)preg_hsi, 0, 1036UL);
#line 1872
      phost_info->os_type = 2U;
#line 1873
      strncpy((char *)(& phost_info->sysname), (char const   *)(& p_sysid->sysname),
              128UL);
#line 1875
      strncpy((char *)(& phost_info->nodename), (char const   *)(& p_sysid->nodename),
              64UL);
#line 1877
      tmp = strcmp((char const   *)(& phost_info->nodename), "(none)");
#line 1877
      if (tmp == 0) {
#line 1878
        ha->mr.host_info_resend = 1;
      } else {

      }
#line 1879
      strncpy((char *)(& phost_info->release), (char const   *)(& p_sysid->release),
              64UL);
#line 1881
      strncpy((char *)(& phost_info->version), (char const   *)(& p_sysid->version),
              64UL);
#line 1883
      strncpy((char *)(& phost_info->machine), (char const   *)(& p_sysid->machine),
              64UL);
#line 1885
      strncpy((char *)(& phost_info->domainname), (char const   *)(& p_sysid->domainname),
              64UL);
#line 1887
      strncpy((char *)(& phost_info->hostdriver), "8.07.00.18-k", 64UL);
#line 1889
      do_gettimeofday(& tv);
#line 1890
      preg_hsi->utc = (unsigned long long )tv.tv_sec;
#line 1891
      ql_dbg(1073741824U, vha, 329, "ISP%04X: Host registration with firmware\n",
             (int )(ha->pdev)->device);
#line 1894
      ql_dbg(1073741824U, vha, 330, "os_type = \'%d\', sysname = \'%s\', nodname = \'%s\'\n",
             phost_info->os_type, (char *)(& phost_info->sysname), (char *)(& phost_info->nodename));
#line 1899
      ql_dbg(1073741824U, vha, 331, "release = \'%s\', version = \'%s\'\n", (char *)(& phost_info->release),
             (char *)(& phost_info->version));
#line 1903
      ql_dbg(1073741824U, vha, 332, "machine = \'%s\' domainname = \'%s\', hostdriver = \'%s\'\n",
             (char *)(& phost_info->machine), (char *)(& phost_info->domainname),
             (char *)(& phost_info->hostdriver));
#line 1909
      ql_dump_buffer(1342177280U, vha, 333, (uint8_t *)phost_info, 772U);
    } else {

    }
  } else {

  }
#line 1915
  if (((int )fdisc->u.fxiocb.flags & 2) != 0) {
#line 1916
    fdisc->u.fxiocb.rsp_addr = dma_alloc_attrs(& (ha->pdev)->dev, (size_t )fdisc->u.fxiocb.rsp_len,
                                               & fdisc->u.fxiocb.rsp_dma_handle, 208U,
                                               (struct dma_attrs *)0);
#line 1919
    if ((unsigned long )fdisc->u.fxiocb.rsp_addr == (unsigned long )((void *)0)) {
#line 1920
      goto done_unmap_req;
    } else {

    }
  } else {

  }
#line 1923
  sp->type = 10U;
#line 1924
  sp->name = (char *)"fxdisc";
#line 1925
  qla2x00_init_timer(sp, 20UL);
#line 1926
  fdisc->timeout = & qla2x00_fxdisc_iocb_timeout;
#line 1927
  fdisc->u.fxiocb.req_func_type = fx_type;
#line 1928
  sp->done = & qla2x00_fxdisc_sp_done;
#line 1930
  rval = qla2x00_start_sp(sp);
#line 1931
  if (rval != 0) {
#line 1932
    goto done_unmap_dma;
  } else {

  }
#line 1934
  wait_for_completion(& fdisc->u.fxiocb.fxiocb_comp);
#line 1936
  if ((unsigned int )fx_type == 1U) {
#line 1937
    pinfo = (struct config_info_data *)fdisc->u.fxiocb.rsp_addr;
#line 1939
    strcpy((char *)(& (vha->hw)->model_number), (char const   *)(& pinfo->model_num));
#line 1940
    strcpy((char *)(& (vha->hw)->model_desc), (char const   *)(& pinfo->model_description));
#line 1941
    memcpy((void *)(& (vha->hw)->mr.symbolic_name), (void const   *)(& pinfo->symbolic_name),
             64UL);
#line 1943
    memcpy((void *)(& (vha->hw)->mr.serial_num), (void const   *)(& pinfo->serial_num),
             32UL);
#line 1945
    memcpy((void *)(& (vha->hw)->mr.hw_version), (void const   *)(& pinfo->hw_version),
             16UL);
#line 1947
    memcpy((void *)(& (vha->hw)->mr.fw_version), (void const   *)(& pinfo->fw_version),
             16UL);
#line 1949
    strim((char *)(& (vha->hw)->mr.fw_version));
#line 1950
    memcpy((void *)(& (vha->hw)->mr.uboot_version), (void const   *)(& pinfo->uboot_version),
             16UL);
#line 1952
    memcpy((void *)(& (vha->hw)->mr.fru_serial_num), (void const   *)(& pinfo->fru_serial_num),
             32UL);
#line 1954
    (vha->hw)->mr.critical_temperature = pinfo->nominal_temp_value != 0U ? pinfo->nominal_temp_value : 80U;
#line 1957
    ha->mr.extended_io_enabled = (pinfo->enabled_capabilities & 32U) != 0U;
  } else
#line 1959
  if ((unsigned int )fx_type == 2U) {
#line 1960
    pinfo___0 = (struct port_info_data *)fdisc->u.fxiocb.rsp_addr;
#line 1962
    memcpy((void *)(& vha->node_name), (void const   *)(& pinfo___0->node_name),
             8UL);
#line 1963
    memcpy((void *)(& vha->port_name), (void const   *)(& pinfo___0->port_name),
             8UL);
#line 1964
    vha->d_id.b.domain = pinfo___0->port_id[0];
#line 1965
    vha->d_id.b.area = pinfo___0->port_id[1];
#line 1966
    vha->d_id.b.al_pa = pinfo___0->port_id[2];
#line 1967
    qlafx00_update_host_attr(vha, pinfo___0);
#line 1968
    ql_dump_buffer(1073872896U, vha, 321, (uint8_t *)pinfo___0, 16U);
  } else
#line 1970
  if ((unsigned int )fx_type == 128U) {
#line 1971
    pinfo___1 = (struct qlafx00_tgt_node_info *)fdisc->u.fxiocb.rsp_addr;
#line 1973
    memcpy((void *)(& fcport->node_name), (void const   *)(& pinfo___1->tgt_node_wwnn),
             8UL);
#line 1974
    memcpy((void *)(& fcport->port_name), (void const   *)(& pinfo___1->tgt_node_wwpn),
             8UL);
#line 1975
    fcport->port_type = 5;
#line 1976
    ql_dump_buffer(1073872896U, vha, 324, (uint8_t *)pinfo___1, 16U);
  } else
#line 1978
  if ((unsigned int )fx_type == 129U) {
#line 1979
    pinfo___2 = (struct qlafx00_tgt_node_info *)fdisc->u.fxiocb.rsp_addr;
#line 1981
    ql_dump_buffer(1073872896U, vha, 326, (uint8_t *)pinfo___2, 16U);
#line 1983
    memcpy((void *)(vha->hw)->gid_list, (void const   *)pinfo___2, 128UL);
  } else
#line 1984
  if ((unsigned int )fx_type == 255U) {
#line 1985
    fdisc->u.fxiocb.result = fdisc->u.fxiocb.result == 104U ? 0U : 258U;
  } else {

  }
#line 1990
  rval = (int )fdisc->u.fxiocb.result;
  done_unmap_dma: ;
#line 1993
  if ((unsigned long )fdisc->u.fxiocb.rsp_addr != (unsigned long )((void *)0)) {
#line 1994
    dma_free_attrs(& (ha->pdev)->dev, (size_t )fdisc->u.fxiocb.rsp_len, fdisc->u.fxiocb.rsp_addr,
                   fdisc->u.fxiocb.rsp_dma_handle, (struct dma_attrs *)0);
  } else {

  }
  done_unmap_req: ;
#line 1998
  if ((unsigned long )fdisc->u.fxiocb.req_addr != (unsigned long )((void *)0)) {
#line 1999
    dma_free_attrs(& (ha->pdev)->dev, (size_t )fdisc->u.fxiocb.req_len, fdisc->u.fxiocb.req_addr,
                   fdisc->u.fxiocb.req_dma_handle, (struct dma_attrs *)0);
  } else {

  }
  done_free_sp: 
#line 2002
  (*(sp->free))((void *)vha, (void *)sp);
  done: ;
#line 2004
  return (rval);
}
}
#line 2018 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
int qlafx00_initialize_adapter(struct scsi_qla_host *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  uint32_t tempc ;
  unsigned int tmp ;

  {
#line 2021
  ha = vha->hw;
#line 2025
  vha->flags.online = 0U;
#line 2026
  ha->flags.chip_reset_done = 0U;
#line 2027
  vha->flags.reset_active = 0U;
#line 2028
  ha->flags.pci_channel_io_perm_failure = 0U;
#line 2029
  ha->flags.eeh_busy = 0U;
#line 2030
  atomic_set(& vha->loop_down_timer, 255);
#line 2031
  atomic_set(& vha->loop_state, 2);
#line 2032
  vha->device_flags = 2U;
#line 2033
  vha->dpc_flags = 0UL;
#line 2034
  vha->flags.management_server_logged_in = 0U;
#line 2035
  ha->isp_abort_cnt = 0U;
#line 2036
  ha->beacon_blink_led = 0U;
#line 2038
  set_bit(0L, (unsigned long volatile   *)(& ha->req_qid_map));
#line 2039
  set_bit(0L, (unsigned long volatile   *)(& ha->rsp_qid_map));
#line 2041
  ql_dbg(1073741824U, vha, 327, "Configuring PCI space...\n");
#line 2044
  rval = (*((ha->isp_ops)->pci_config))(vha);
#line 2045
  if (rval != 0) {
#line 2046
    ql_log(1U, vha, 328, "Unable to configure PCI space.\n");
#line 2048
    return (rval);
  } else {

  }
#line 2051
  rval = qlafx00_init_fw_ready(vha);
#line 2052
  if (rval != 0) {
#line 2053
    return (rval);
  } else {

  }
#line 2055
  qlafx00_save_queue_ptrs(vha);
#line 2057
  rval = qlafx00_config_queues(vha);
#line 2058
  if (rval != 0) {
#line 2059
    return (rval);
  } else {

  }
#line 2065
  rval = qla2x00_alloc_outstanding_cmds(ha, vha->req);
#line 2066
  if (rval != 0) {
#line 2067
    return (rval);
  } else {

  }
#line 2069
  rval = qla2x00_init_rings(vha);
#line 2070
  ha->flags.chip_reset_done = 1U;
#line 2072
  tmp = readl((void const volatile   *)ha->cregbase + 99524U);
#line 2072
  tempc = (3153000U - ((tmp & 1022U) >> 1) * 10000U) / 13825U;
#line 2073
  ql_dbg(1073741824U, vha, 338, "ISPFx00(%s): Critical temp timer, current SOC temperature: 0x%x\n",
         "qlafx00_initialize_adapter", tempc);
#line 2077
  return (rval);
}
}
#line 2081 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
uint32_t qlafx00_fw_state_show(struct device *dev , struct device_attribute *attr ,
                               char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int rval ;
  uint32_t state[1U] ;
  int tmp___0 ;

  {
#line 2084
  __mptr = (struct device  const  *)dev;
#line 2084
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL);
#line 2084
  vha = (scsi_qla_host_t *)tmp;
#line 2085
  rval = 258;
#line 2088
  tmp___0 = qla2x00_reset_active(vha);
#line 2088
  if (tmp___0 != 0) {
#line 2089
    ql_log(1U, vha, 28878, "ISP reset active.\n");
  } else
#line 2091
  if (*((unsigned long *)vha->hw + 2UL) == 0UL) {
#line 2092
    rval = qlafx00_get_firmware_state(vha, (uint32_t *)(& state));
  } else {

  }
#line 2094
  if (rval != 0) {
#line 2095
    memset((void *)(& state), -1, 4UL);
  } else {

  }
#line 2097
  return (state[0]);
}
}
#line 2101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
void qlafx00_get_host_speed(struct Scsi_Host *shost ) 
{ 
  struct qla_hw_data *ha ;
  void *tmp ;
  u32 speed ;

  {
#line 2103
  tmp = shost_priv(shost);
#line 2103
  ha = ((struct scsi_qla_host *)tmp)->hw;
#line 2105
  speed = 0U;
#line 2107
  switch ((int )ha->link_data_rate) {
  case 2: 
#line 2109
  speed = 2U;
#line 2110
  goto ldv_66425;
  case 4: 
#line 2112
  speed = 8U;
#line 2113
  goto ldv_66425;
  case 8: 
#line 2115
  speed = 16U;
#line 2116
  goto ldv_66425;
  case 10: 
#line 2118
  speed = 4U;
#line 2119
  goto ldv_66425;
  }
  ldv_66425: 
#line 2121
  ((struct fc_host_attrs *)shost->shost_data)->speed = speed;
#line 2122
  return;
}
}
#line 2127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
__inline static void qlafx00_handle_sense(srb_t *sp , uint8_t *sense_data , uint32_t par_sense_len ,
                                          uint32_t sense_len , struct rsp_que *rsp ,
                                          int res ) 
{ 
  struct scsi_qla_host *vha ;
  struct scsi_cmnd *cp ;
  uint32_t track_sense_len ;

  {
#line 2130
  vha = (sp->fcport)->vha;
#line 2131
  cp = sp->u.scmd.cmd;
#line 2134
  sp->u.scmd.fw_sense_length = sense_len;
#line 2136
  if (sense_len > 95U) {
#line 2137
    sense_len = 96U;
  } else {

  }
#line 2139
  sp->u.scmd.request_sense_length = sense_len;
#line 2140
  sp->u.scmd.request_sense_ptr = cp->sense_buffer;
#line 2141
  track_sense_len = sense_len;
#line 2143
  if (sense_len > par_sense_len) {
#line 2144
    sense_len = par_sense_len;
  } else {

  }
#line 2146
  memcpy((void *)cp->sense_buffer, (void const   *)sense_data, (size_t )sense_len);
#line 2148
  sp->u.scmd.fw_sense_length = sp->u.scmd.fw_sense_length - sense_len;
#line 2150
  sp->u.scmd.request_sense_ptr = cp->sense_buffer + (unsigned long )sense_len;
#line 2151
  track_sense_len = track_sense_len - sense_len;
#line 2152
  sp->u.scmd.request_sense_length = track_sense_len;
#line 2154
  ql_dbg(134217728U, vha, 12365, "sense_len=0x%x par_sense_len=0x%x track_sense_len=0x%x.\n",
         sense_len, par_sense_len, track_sense_len);
#line 2157
  if (sp->u.scmd.fw_sense_length != 0U) {
#line 2158
    rsp->status_srb = sp;
#line 2159
    cp->result = res;
  } else {

  }
#line 2162
  if (sense_len != 0U) {
#line 2163
    ql_dbg(134348800U, vha, 12345, "Check condition Sense data, nexus%ld:%d:%llu cmd=%p.\n",
           ((sp->fcport)->vha)->host_no, (cp->device)->id, (cp->device)->lun, cp);
#line 2167
    ql_dump_buffer(134348800U, vha, 12361, cp->sense_buffer, sense_len);
  } else {

  }
#line 2170
  return;
}
}
#line 2173 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
static void qlafx00_tm_iocb_entry(scsi_qla_host_t *vha , struct req_que *req , struct tsk_mgmt_entry_fx00 *pkt ,
                                  srb_t *sp , __le16 sstatus , __le16 cpstatus ) 
{ 
  struct srb_iocb *tmf ;

  {
#line 2179
  tmf = & sp->u.iocb_cmd;
#line 2180
  if ((unsigned int )cpstatus != 0U || ((int )sstatus & 256) != 0) {
#line 2182
    cpstatus = 1U;
  } else {

  }
#line 2183
  tmf->u.tmf.comp_status = cpstatus;
#line 2184
  (*(sp->done))((void *)vha, (void *)sp, 0);
#line 2185
  return;
}
}
#line 2188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
static void qlafx00_abort_iocb_entry(scsi_qla_host_t *vha , struct req_que *req ,
                                     struct abort_iocb_entry_fx00 *pkt ) 
{ 
  char func[9U] ;
  srb_t *sp ;
  struct srb_iocb *abt ;

  {
#line 2191
  func[0] = 'A';
#line 2191
  func[1] = 'B';
#line 2191
  func[2] = 'T';
#line 2191
  func[3] = '_';
#line 2191
  func[4] = 'I';
#line 2191
  func[5] = 'O';
#line 2191
  func[6] = 'C';
#line 2191
  func[7] = 'B';
#line 2191
  func[8] = '\000';
#line 2195
  sp = qla2x00_get_sp_from_handle(vha, (char const   *)(& func), req, (void *)pkt);
#line 2196
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 2197
    return;
  } else {

  }
#line 2199
  abt = & sp->u.iocb_cmd;
#line 2200
  abt->u.abt.comp_status = pkt->tgt_id_sts;
#line 2201
  (*(sp->done))((void *)vha, (void *)sp, 0);
#line 2202
  return;
}
}
#line 2205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
static void qlafx00_ioctl_iosb_entry(scsi_qla_host_t *vha , struct req_que *req ,
                                     struct ioctl_iocb_entry_fx00 *pkt ) 
{ 
  char func[10U] ;
  srb_t *sp ;
  struct fc_bsg_job *bsg_job ;
  struct srb_iocb *iocb_job ;
  int res ;
  struct qla_mt_iocb_rsp_fx00 fstatus ;
  uint8_t *fw_sts_ptr ;

  {
#line 2208
  func[0] = 'I';
#line 2208
  func[1] = 'O';
#line 2208
  func[2] = 'S';
#line 2208
  func[3] = 'B';
#line 2208
  func[4] = '_';
#line 2208
  func[5] = 'I';
#line 2208
  func[6] = 'O';
#line 2208
  func[7] = 'C';
#line 2208
  func[8] = 'B';
#line 2208
  func[9] = '\000';
#line 2216
  sp = qla2x00_get_sp_from_handle(vha, (char const   *)(& func), req, (void *)pkt);
#line 2217
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 2218
    return;
  } else {

  }
#line 2220
  if ((unsigned int )sp->type == 10U) {
#line 2221
    iocb_job = & sp->u.iocb_cmd;
#line 2222
    iocb_job->u.fxiocb.seq_number = pkt->seq_no;
#line 2223
    iocb_job->u.fxiocb.fw_flags = pkt->fw_iotcl_flags;
#line 2224
    iocb_job->u.fxiocb.result = pkt->status;
#line 2225
    if (((int )iocb_job->u.fxiocb.flags & 8) != 0) {
#line 2226
      iocb_job->u.fxiocb.req_data = pkt->dataword_r;
    } else {

    }
  } else {
#line 2229
    bsg_job = sp->u.bsg_job;
#line 2231
    memset((void *)(& fstatus), 0, 56UL);
#line 2233
    fstatus.reserved_1 = pkt->reserved_0;
#line 2234
    fstatus.func_type = pkt->comp_func_num;
#line 2235
    fstatus.ioctl_flags = pkt->fw_iotcl_flags;
#line 2236
    fstatus.ioctl_data = pkt->dataword_r;
#line 2237
    fstatus.adapid = pkt->adapid;
#line 2238
    fstatus.reserved_2 = pkt->dataword_r_extra;
#line 2239
    fstatus.res_count = (int32_t )pkt->residuallen;
#line 2240
    fstatus.status = pkt->status;
#line 2241
    fstatus.seq_number = pkt->seq_no;
#line 2242
    memcpy((void *)(& fstatus.reserved_3), (void const   *)(& pkt->reserved_2),
             20UL);
#line 2245
    fw_sts_ptr = (uint8_t *)(bsg_job->req)->sense + 16UL;
#line 2248
    memcpy((void *)fw_sts_ptr, (void const   *)(& fstatus), 56UL);
#line 2250
    bsg_job->reply_len = 73U;
#line 2253
    ql_dump_buffer(8421376U, (sp->fcport)->vha, 20608, (uint8_t *)pkt, 60U);
#line 2257
    ql_dump_buffer(8421376U, (sp->fcport)->vha, 20596, fw_sts_ptr, 56U);
#line 2261
    (bsg_job->reply)->result = 0U;
#line 2261
    res = 0;
#line 2262
    (bsg_job->reply)->reply_payload_rcv_len = bsg_job->reply_payload.payload_len;
  }
#line 2265
  (*(sp->done))((void *)vha, (void *)sp, res);
#line 2266
  return;
}
}
#line 2274 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
static void qlafx00_status_entry(scsi_qla_host_t *vha , struct rsp_que *rsp , void *pkt ) 
{ 
  srb_t *sp ;
  fc_port_t *fcport ;
  struct scsi_cmnd *cp ;
  struct sts_entry_fx00 *sts ;
  __le16 comp_status ;
  __le16 scsi_status ;
  uint16_t ox_id ;
  __le16 lscsi_status ;
  int32_t resid ;
  uint32_t sense_len ;
  uint32_t par_sense_len ;
  uint32_t rsp_info_len ;
  uint32_t resid_len ;
  uint32_t fw_resid_len ;
  uint8_t *rsp_info ;
  uint8_t *sense_data ;
  struct qla_hw_data *ha ;
  uint32_t hindex ;
  uint32_t handle ;
  uint16_t que ;
  struct req_que *req ;
  int logit ;
  int res ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;

  {
#line 2287
  rsp_info = (uint8_t *)0U;
#line 2287
  sense_data = (uint8_t *)0U;
#line 2288
  ha = vha->hw;
#line 2292
  logit = 1;
#line 2293
  res = 0;
#line 2295
  sts = (struct sts_entry_fx00 *)pkt;
#line 2297
  comp_status = sts->comp_status;
#line 2298
  scsi_status = (unsigned int )sts->scsi_status & 4095U;
#line 2299
  hindex = sts->handle;
#line 2300
  handle = (uint32_t )((unsigned short )hindex);
#line 2302
  que = (unsigned short )(hindex >> 16);
#line 2303
  req = *(ha->req_q_map + (unsigned long )que);
#line 2306
  if ((uint32_t )req->num_outstanding_cmds > handle) {
#line 2307
    sp = *(req->outstanding_cmds + (unsigned long )handle);
  } else {
#line 2309
    sp = (srb_t *)0;
  }
#line 2311
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 2312
    ql_dbg(134217728U, vha, 12340, "Invalid status handle (0x%x).\n", handle);
#line 2315
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2316
    qla2xxx_wake_dpc(vha);
#line 2317
    return;
  } else {

  }
#line 2320
  if ((unsigned int )sp->type == 7U) {
#line 2321
    *(req->outstanding_cmds + (unsigned long )handle) = (srb_t *)0;
#line 2322
    qlafx00_tm_iocb_entry(vha, req, (struct tsk_mgmt_entry_fx00 *)pkt, sp, (int )scsi_status,
                          (int )comp_status);
#line 2324
    return;
  } else {

  }
#line 2328
  if ((unsigned int )comp_status == 0U && (unsigned int )scsi_status == 0U) {
#line 2329
    qla2x00_process_completed_request(vha, req, handle);
#line 2330
    return;
  } else {

  }
#line 2333
  *(req->outstanding_cmds + (unsigned long )handle) = (srb_t *)0;
#line 2334
  cp = sp->u.scmd.cmd;
#line 2335
  if ((unsigned long )cp == (unsigned long )((struct scsi_cmnd *)0)) {
#line 2336
    ql_dbg(134217728U, vha, 12360, "Command already returned (0x%x/%p).\n", handle,
           sp);
#line 2340
    return;
  } else {

  }
#line 2343
  lscsi_status = (unsigned int )scsi_status & 254U;
#line 2345
  fcport = sp->fcport;
#line 2347
  ox_id = 0U;
#line 2348
  fw_resid_len = 0U;
#line 2348
  resid_len = fw_resid_len;
#line 2348
  rsp_info_len = resid_len;
#line 2348
  par_sense_len = rsp_info_len;
#line 2348
  sense_len = par_sense_len;
#line 2350
  if (((int )scsi_status & 512) != 0) {
#line 2351
    sense_len = sts->sense_len;
  } else {

  }
#line 2352
  if (((int )scsi_status & 3072) != 0) {
#line 2354
    resid_len = sts->residual_len;
  } else {

  }
#line 2355
  if ((unsigned int )comp_status == 21U) {
#line 2356
    fw_resid_len = sts->residual_len;
  } else {

  }
#line 2357
  sense_data = (uint8_t *)(& sts->data);
#line 2357
  rsp_info = sense_data;
#line 2358
  par_sense_len = 32U;
#line 2361
  if ((unsigned int )comp_status == 0U && ((int )scsi_status & 1024) != 0) {
#line 2363
    comp_status = 7U;
  } else {

  }
#line 2368
  switch ((int )comp_status) {
  case 0: ;
  case 28: ;
#line 2371
  if ((unsigned int )scsi_status == 0U) {
#line 2372
    res = 0;
#line 2373
    goto ldv_66499;
  } else {

  }
#line 2375
  if (((int )scsi_status & 3072) != 0) {
#line 2377
    resid = (int32_t )resid_len;
#line 2378
    scsi_set_resid(cp, resid);
#line 2380
    if ((unsigned int )lscsi_status == 0U) {
#line 2380
      tmp___0 = scsi_bufflen(cp);
#line 2380
      if (tmp___0 - (unsigned int )resid < cp->underflow) {
#line 2383
        tmp = scsi_bufflen(cp);
#line 2383
        ql_dbg(134217728U, fcport->vha, 12368, "Mid-layer underflow detected (0x%x of 0x%x bytes).\n",
               resid, tmp);
#line 2388
        res = 458752;
#line 2389
        goto ldv_66499;
      } else {

      }
    } else {

    }
  } else {

  }
#line 2392
  res = (int )lscsi_status;
#line 2394
  if ((unsigned int )lscsi_status == 40U) {
#line 2396
    ql_dbg(134217728U, fcport->vha, 12369, "QUEUE FULL detected.\n");
#line 2398
    goto ldv_66499;
  } else {

  }
#line 2400
  logit = 0;
#line 2401
  if ((unsigned int )lscsi_status != 2U) {
#line 2402
    goto ldv_66499;
  } else {

  }
#line 2404
  memset((void *)cp->sense_buffer, 0, 96UL);
#line 2405
  if (((int )scsi_status & 512) == 0) {
#line 2406
    goto ldv_66499;
  } else {

  }
#line 2408
  qlafx00_handle_sense(sp, sense_data, par_sense_len, sense_len, rsp, res);
#line 2410
  goto ldv_66499;
  case 21: ;
#line 2414
  if ((ha->device_type & 134217728U) != 0U || (ha->device_type & 131072U) != 0U) {
#line 2415
    resid = (int32_t )fw_resid_len;
  } else {
#line 2417
    resid = (int32_t )resid_len;
  }
#line 2418
  scsi_set_resid(cp, resid);
#line 2419
  if (((int )scsi_status & 2048) != 0) {
#line 2420
    if (((ha->device_type & 134217728U) != 0U || (ha->device_type & 131072U) != 0U) && fw_resid_len != resid_len) {
#line 2422
      tmp___1 = scsi_bufflen(cp);
#line 2422
      ql_dbg(134217728U, fcport->vha, 12370, "Dropped frame(s) detected (0x%x of 0x%x bytes).\n",
             resid, tmp___1);
#line 2427
      res = (int )lscsi_status | 458752;
#line 2429
      goto check_scsi_status;
    } else {

    }
#line 2432
    if ((unsigned int )lscsi_status == 0U) {
#line 2432
      tmp___3 = scsi_bufflen(cp);
#line 2432
      if (tmp___3 - (unsigned int )resid < cp->underflow) {
#line 2435
        tmp___2 = scsi_bufflen(cp);
#line 2435
        ql_dbg(134217728U, fcport->vha, 12371, "Mid-layer underflow detected (0x%x of 0x%x bytes, cp->underflow: 0x%x).\n",
               resid, tmp___2, cp->underflow);
#line 2441
        res = 458752;
#line 2442
        goto ldv_66499;
      } else {

      }
    } else {

    }
  } else
#line 2444
  if ((unsigned int )lscsi_status != 40U && (unsigned int )lscsi_status != 8U) {
#line 2452
    tmp___4 = scsi_bufflen(cp);
#line 2452
    ql_dbg(134217728U, fcport->vha, 12372, "Dropped frame(s) detected (0x%x of 0x%x bytes).\n",
           resid, tmp___4);
#line 2457
    res = (int )lscsi_status | 458752;
#line 2458
    goto check_scsi_status;
  } else {
#line 2460
    ql_dbg(134217728U, fcport->vha, 12373, "scsi_status: 0x%x, lscsi_status: 0x%x\n",
           (int )scsi_status, (int )lscsi_status);
  }
#line 2465
  res = (int )lscsi_status;
#line 2466
  logit = 0;
  check_scsi_status: ;
#line 2473
  if ((unsigned int )lscsi_status != 0U) {
#line 2474
    if ((unsigned int )lscsi_status == 40U) {
#line 2476
      ql_dbg(134217728U, fcport->vha, 12374, "QUEUE FULL detected.\n");
#line 2478
      logit = 1;
#line 2479
      goto ldv_66499;
    } else {

    }
#line 2481
    if ((unsigned int )lscsi_status != 2U) {
#line 2483
      goto ldv_66499;
    } else {

    }
#line 2485
    memset((void *)cp->sense_buffer, 0, 96UL);
#line 2486
    if (((int )scsi_status & 512) == 0) {
#line 2488
      goto ldv_66499;
    } else {

    }
#line 2490
    qlafx00_handle_sense(sp, sense_data, par_sense_len, sense_len, rsp, res);
  } else {

  }
#line 2493
  goto ldv_66499;
  case 41: ;
  case 42: ;
  case 43: ;
  case 1: ;
  case 40: ;
  case 6: ;
  case 4: 
#line 2508
  res = 917504;
#line 2510
  tmp___5 = atomic_read((atomic_t const   *)(& fcport->state));
#line 2510
  ql_dbg(134217728U, fcport->vha, 12375, "Port down status: port-state=0x%x.\n", tmp___5);
#line 2514
  tmp___6 = atomic_read((atomic_t const   *)(& fcport->state));
#line 2514
  if (tmp___6 == 4) {
#line 2515
    qla2x00_mark_device_lost(fcport->vha, fcport, 1, 1);
  } else {

  }
#line 2516
  goto ldv_66499;
  case 5: 
#line 2519
  res = 524288;
#line 2520
  goto ldv_66499;
  default: 
#line 2523
  res = 458752;
#line 2524
  goto ldv_66499;
  }
  ldv_66499: ;
#line 2527
  if (logit != 0) {
#line 2528
    tmp___7 = scsi_bufflen(cp);
#line 2528
    ql_dbg(134217728U, fcport->vha, 12376, "FCP command status: 0x%x-0x%x (0x%x) nexus=%ld:%d:%llu tgt_id: 0x%x lscsi_status: 0x%x cdb=%10phN len=0x%x rsp_info=0x%x resid=0x%x fw_resid=0x%x sense_len=0x%x, par_sense_len=0x%x, rsp_info_len=0x%x\n",
           (int )comp_status, (int )scsi_status, res, vha->host_no, (cp->device)->id,
           (cp->device)->lun, (int )fcport->tgt_id, (int )lscsi_status, cp->cmnd,
           tmp___7, rsp_info_len, resid_len, fw_resid_len, sense_len, par_sense_len,
           rsp_info_len);
  } else {

  }
#line 2539
  if ((unsigned long )rsp->status_srb == (unsigned long )((srb_t *)0)) {
#line 2540
    (*(sp->done))((void *)ha, (void *)sp, res);
  } else {

  }
#line 2541
  return;
}
}
#line 2551 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
static void qlafx00_status_cont_entry(struct rsp_que *rsp , sts_cont_entry_t *pkt ) 
{ 
  uint8_t sense_sz ;
  struct qla_hw_data *ha ;
  struct scsi_qla_host *vha ;
  void *tmp ;
  srb_t *sp ;
  struct scsi_cmnd *cp ;
  uint32_t sense_len ;
  uint8_t *sense_ptr ;

  {
#line 2553
  sense_sz = 0U;
#line 2554
  ha = rsp->hw;
#line 2555
  tmp = pci_get_drvdata(ha->pdev);
#line 2555
  vha = (struct scsi_qla_host *)tmp;
#line 2556
  sp = rsp->status_srb;
#line 2561
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 2562
    ql_dbg(134217728U, vha, 12343, "no SP, sp = %p\n", sp);
#line 2564
    return;
  } else {

  }
#line 2567
  if (sp->u.scmd.fw_sense_length == 0U) {
#line 2568
    ql_dbg(134217728U, vha, 12363, "no fw sense data, sp = %p\n", sp);
#line 2570
    return;
  } else {

  }
#line 2572
  cp = sp->u.scmd.cmd;
#line 2573
  if ((unsigned long )cp == (unsigned long )((struct scsi_cmnd *)0)) {
#line 2574
    ql_log(1U, vha, 12347, "cmd is NULL: already returned to OS (sp=%p).\n", sp);
#line 2577
    rsp->status_srb = (srb_t *)0;
#line 2578
    return;
  } else {

  }
#line 2581
  if (sp->u.scmd.request_sense_length == 0U) {
#line 2582
    ql_dbg(134217728U, vha, 12364, "no sense data, sp = %p\n", sp);
  } else {
#line 2585
    sense_len = sp->u.scmd.request_sense_length;
#line 2586
    sense_ptr = sp->u.scmd.request_sense_ptr;
#line 2587
    ql_dbg(134217728U, vha, 12367, "sp=%p sense_len=0x%x sense_ptr=%p.\n", sp, sense_len,
           sense_ptr);
#line 2591
    if (sense_len > 60U) {
#line 2592
      sense_sz = 60U;
    } else {
#line 2594
      sense_sz = (uint8_t )sense_len;
    }
#line 2597
    ql_dump_buffer(134348800U, vha, 12366, (uint8_t *)pkt, 64U);
#line 2599
    memcpy((void *)sense_ptr, (void const   *)(& pkt->data), (size_t )sense_sz);
#line 2600
    ql_dump_buffer(134348800U, vha, 12362, sense_ptr, (uint32_t )sense_sz);
#line 2603
    sense_len = sense_len - (uint32_t )sense_sz;
#line 2604
    sense_ptr = sense_ptr + (unsigned long )sense_sz;
#line 2606
    sp->u.scmd.request_sense_ptr = sense_ptr;
#line 2607
    sp->u.scmd.request_sense_length = sense_len;
  }
#line 2609
  sense_len = sp->u.scmd.fw_sense_length;
#line 2610
  sense_len = sense_len > 60U ? sense_len - 60U : 0U;
#line 2612
  sp->u.scmd.fw_sense_length = sense_len;
#line 2615
  if (sense_len == 0U) {
#line 2616
    rsp->status_srb = (srb_t *)0;
#line 2617
    (*(sp->done))((void *)ha, (void *)sp, cp->result);
  } else {

  }
#line 2619
  return;
}
}
#line 2626 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
static void qlafx00_multistatus_entry(struct scsi_qla_host *vha , struct rsp_que *rsp ,
                                      void *pkt ) 
{ 
  srb_t *sp ;
  struct multi_sts_entry_fx00 *stsmfx ;
  struct qla_hw_data *ha ;
  uint32_t handle ;
  uint32_t hindex ;
  uint32_t handle_count ;
  uint32_t i ;
  uint16_t que ;
  struct req_que *req ;
  __le32 *handle_ptr ;

  {
#line 2631
  ha = vha->hw;
#line 2637
  stsmfx = (struct multi_sts_entry_fx00 *)pkt;
#line 2639
  handle_count = (uint32_t )stsmfx->handle_count;
#line 2641
  if (handle_count > 15U) {
#line 2642
    ql_dbg(134217728U, vha, 12341, "Invalid handle count (0x%x).\n", handle_count);
#line 2644
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2645
    qla2xxx_wake_dpc(vha);
#line 2646
    return;
  } else {

  }
#line 2649
  handle_ptr = (__le32 *)(& stsmfx->handles);
#line 2651
  i = 0U;
#line 2651
  goto ldv_66538;
  ldv_66537: 
#line 2652
  hindex = *handle_ptr;
#line 2653
  handle = (uint32_t )((unsigned short )hindex);
#line 2654
  que = (unsigned short )(hindex >> 16);
#line 2655
  req = *(ha->req_q_map + (unsigned long )que);
#line 2658
  if ((uint32_t )req->num_outstanding_cmds > handle) {
#line 2659
    sp = *(req->outstanding_cmds + (unsigned long )handle);
  } else {
#line 2661
    sp = (srb_t *)0;
  }
#line 2663
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 2664
    ql_dbg(134217728U, vha, 12356, "Invalid status handle (0x%x).\n", handle);
#line 2666
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2667
    qla2xxx_wake_dpc(vha);
#line 2668
    return;
  } else {

  }
#line 2670
  qla2x00_process_completed_request(vha, req, handle);
#line 2671
  handle_ptr = handle_ptr + 1;
#line 2651
  i = i + 1U;
  ldv_66538: ;
#line 2651
  if (i < handle_count) {
#line 2653
    goto ldv_66537;
  } else {

  }

#line 2658
  return;
}
}
#line 2681 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
static void qlafx00_error_entry(scsi_qla_host_t *vha , struct rsp_que *rsp , struct sts_entry_fx00 *pkt ,
                                uint8_t estatus , uint8_t etype ) 
{ 
  srb_t *sp ;
  struct qla_hw_data *ha ;
  char func[11U] ;
  uint16_t que ;
  struct req_que *req ;
  int res ;

  {
#line 2685
  ha = vha->hw;
#line 2686
  func[0] = 'E';
#line 2686
  func[1] = 'R';
#line 2686
  func[2] = 'R';
#line 2686
  func[3] = 'O';
#line 2686
  func[4] = 'R';
#line 2686
  func[5] = '-';
#line 2686
  func[6] = 'I';
#line 2686
  func[7] = 'O';
#line 2686
  func[8] = 'C';
#line 2686
  func[9] = 'B';
#line 2686
  func[10] = '\000';
#line 2687
  que = 0U;
#line 2688
  req = (struct req_que *)0;
#line 2689
  res = 458752;
#line 2691
  ql_dbg(33554432U, vha, 20607, "type of error status in response: 0x%x\n", (int )estatus);
#line 2694
  req = *(ha->req_q_map + (unsigned long )que);
#line 2696
  sp = qla2x00_get_sp_from_handle(vha, (char const   *)(& func), req, (void *)pkt);
#line 2697
  if ((unsigned long )sp != (unsigned long )((srb_t *)0)) {
#line 2698
    (*(sp->done))((void *)ha, (void *)sp, res);
#line 2699
    return;
  } else {

  }
#line 2702
  set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2703
  qla2xxx_wake_dpc(vha);
#line 2704
  return;
}
}
#line 2711 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
static void qlafx00_process_response_queue(struct scsi_qla_host *vha , struct rsp_que *rsp ) 
{ 
  struct sts_entry_fx00 *pkt ;
  response_t *lptr ;
  uint16_t lreq_q_in ;
  uint16_t lreq_q_out ;
  unsigned int tmp ;

  {
#line 2716
  lreq_q_in = 0U;
#line 2717
  lreq_q_out = 0U;
#line 2719
  tmp = readl((void const volatile   *)rsp->rsp_q_in);
#line 2719
  lreq_q_in = (uint16_t )tmp;
#line 2720
  lreq_q_out = rsp->ring_index;
#line 2722
  goto ldv_66561;
  ldv_66569: 
#line 2723
  lptr = rsp->ring_ptr;
#line 2724
  memcpy_fromio((void *)(& rsp->rsp_pkt), (void const volatile   *)lptr, 64UL);
#line 2726
  pkt = (struct sts_entry_fx00 *)(& rsp->rsp_pkt);
#line 2728
  rsp->ring_index = (uint16_t )((int )rsp->ring_index + 1);
#line 2729
  lreq_q_out = (uint16_t )((int )lreq_q_out + 1);
#line 2730
  if ((int )rsp->ring_index == (int )rsp->length) {
#line 2731
    lreq_q_out = 0U;
#line 2732
    rsp->ring_index = 0U;
#line 2733
    rsp->ring_ptr = rsp->ring;
  } else {
#line 2735
    rsp->ring_ptr = rsp->ring_ptr + 1;
  }
#line 2738
  if ((unsigned int )pkt->entry_status != 0U && (unsigned int )pkt->entry_type != 12U) {
#line 2740
    qlafx00_error_entry(vha, rsp, pkt, (int )pkt->entry_status, (int )pkt->entry_type);
#line 2743
    goto ldv_66561;
  } else {

  }
#line 2746
  switch ((int )pkt->entry_type) {
  case 1: 
#line 2748
  qlafx00_status_entry(vha, rsp, (void *)pkt);
#line 2749
  goto ldv_66563;
  case 4: 
#line 2752
  qlafx00_status_cont_entry(rsp, (sts_cont_entry_t *)pkt);
#line 2753
  goto ldv_66563;
  case 13: 
#line 2756
  qlafx00_multistatus_entry(vha, rsp, (void *)pkt);
#line 2757
  goto ldv_66563;
  case 8: 
#line 2760
  qlafx00_abort_iocb_entry(vha, rsp->req, (struct abort_iocb_entry_fx00 *)pkt);
#line 2762
  goto ldv_66563;
  case 12: 
#line 2765
  qlafx00_ioctl_iosb_entry(vha, rsp->req, (struct ioctl_iocb_entry_fx00 *)pkt);
#line 2767
  goto ldv_66563;
  default: 
#line 2770
  ql_dbg(33554432U, vha, 20609, "Received unknown response pkt type %x entry status=%x.\n",
         (int )pkt->entry_type, (int )pkt->entry_status);
#line 2774
  goto ldv_66563;
  }
  ldv_66563: ;
  ldv_66561: ;
#line 2722
  if ((int )lreq_q_in != (int )lreq_q_out) {
#line 2724
    goto ldv_66569;
  } else {

  }
#line 2779
  writel((unsigned int )rsp->ring_index, (void volatile   *)rsp->rsp_q_out);
#line 2780
  return;
}
}
#line 2787 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
static void qlafx00_async_event(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct device_reg_fx00 *reg ;
  int data_size ;
  unsigned short tmp ;
  unsigned short tmp___0 ;
  unsigned short tmp___1 ;
  unsigned short tmp___2 ;
  unsigned short tmp___3 ;
  unsigned short tmp___4 ;
  unsigned short tmp___5 ;

  {
#line 2789
  ha = vha->hw;
#line 2791
  data_size = 1;
#line 2793
  reg = & (ha->iobase)->ispfx00;
#line 2795
  switch (ha->aenmb[0]) {
  case 32770U: 
#line 2797
  ql_log(1U, vha, 20601, "ISP System Error - mbx1=%x\n", ha->aenmb[0]);
#line 2799
  set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2800
  goto ldv_66578;
  case 32866U: 
#line 2803
  ql_dbg(33554432U, vha, 20598, "Asynchronous FW shutdown requested.\n");
#line 2805
  set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2806
  qla2xxx_wake_dpc(vha);
#line 2807
  goto ldv_66578;
  case 32788U: 
#line 2810
  ha->aenmb[1] = readl((void const volatile   *)(& reg->aenmailbox1));
#line 2811
  ha->aenmb[2] = readl((void const volatile   *)(& reg->aenmailbox2));
#line 2812
  ha->aenmb[3] = readl((void const volatile   *)(& reg->aenmailbox3));
#line 2813
  ql_dbg(33554432U, vha, 20599, "Asynchronous port Update received aenmb[0]: %x, aenmb[1]: %x, aenmb[2]: %x, aenmb[3]: %x\n",
         ha->aenmb[0], ha->aenmb[1], ha->aenmb[2], ha->aenmb[3]);
#line 2817
  data_size = 4;
#line 2818
  goto ldv_66578;
  case 32773U: 
#line 2821
  ql_log(2U, vha, 20613, "Asynchronous over temperature event received aenmb[0]: %x\n",
         ha->aenmb[0]);
#line 2825
  goto ldv_66578;
  case 32774U: 
#line 2828
  ql_log(2U, vha, 20614, "Asynchronous normal temperature event received aenmb[0]: %x\n",
         ha->aenmb[0]);
#line 2832
  goto ldv_66578;
  case 32775U: 
#line 2835
  ql_log(2U, vha, 20611, "Asynchronous critical temperature event received aenmb[0]: %x\n",
         ha->aenmb[0]);
#line 2839
  goto ldv_66578;
  default: 
#line 2842
  tmp = readw((void const volatile   *)(& reg->aenmailbox1));
#line 2842
  ha->aenmb[1] = (uint32_t )tmp;
#line 2843
  tmp___0 = readw((void const volatile   *)(& reg->aenmailbox2));
#line 2843
  ha->aenmb[2] = (uint32_t )tmp___0;
#line 2844
  tmp___1 = readw((void const volatile   *)(& reg->aenmailbox3));
#line 2844
  ha->aenmb[3] = (uint32_t )tmp___1;
#line 2845
  tmp___2 = readw((void const volatile   *)(& reg->aenmailbox4));
#line 2845
  ha->aenmb[4] = (uint32_t )tmp___2;
#line 2846
  tmp___3 = readw((void const volatile   *)(& reg->aenmailbox5));
#line 2846
  ha->aenmb[5] = (uint32_t )tmp___3;
#line 2847
  tmp___4 = readw((void const volatile   *)(& reg->aenmailbox6));
#line 2847
  ha->aenmb[6] = (uint32_t )tmp___4;
#line 2848
  tmp___5 = readw((void const volatile   *)(& reg->aenmailbox7));
#line 2848
  ha->aenmb[7] = (uint32_t )tmp___5;
#line 2849
  ql_dbg(33554432U, vha, 20600, "AEN:%04x %04x %04x %04x :%04x %04x %04x %04x\n",
         ha->aenmb[0], ha->aenmb[1], ha->aenmb[2], ha->aenmb[3], ha->aenmb[4], ha->aenmb[5],
         ha->aenmb[6], ha->aenmb[7]);
#line 2853
  goto ldv_66578;
  }
  ldv_66578: 
#line 2855
  qlafx00_post_aenfx_work(vha, ha->aenmb[0], (uint32_t *)(& ha->aenmb), data_size);
#line 2857
  return;
}
}
#line 2866 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
static void qlafx00_mbx_completion(scsi_qla_host_t *vha , uint32_t mb0 ) 
{ 
  uint16_t cnt ;
  uint32_t *wptr ;
  struct qla_hw_data *ha ;
  struct device_reg_fx00 *reg ;

  {
#line 2870
  ha = vha->hw;
#line 2871
  reg = & (ha->iobase)->ispfx00;
#line 2873
  if ((unsigned long )ha->mcp32 == (unsigned long )((struct mbx_cmd_32 *)0)) {
#line 2874
    ql_dbg(33554432U, vha, 20606, "MBX pointer OLD_ERROR.\n");
  } else {

  }
#line 2877
  ha->flags.mbox_int = 1U;
#line 2878
  ha->mailbox_out32[0] = mb0;
#line 2879
  wptr = & reg->mailbox17;
#line 2881
  cnt = 1U;
#line 2881
  goto ldv_66594;
  ldv_66593: 
#line 2882
  ha->mailbox_out32[(int )cnt] = readl((void const volatile   *)wptr);
#line 2883
  wptr = wptr + 1;
#line 2881
  cnt = (uint16_t )((int )cnt + 1);
  ldv_66594: ;
#line 2881
  if ((int )((unsigned short )ha->mbx_count) > (int )cnt) {
#line 2883
    goto ldv_66593;
  } else {

  }

#line 2888
  return;
}
}
#line 2897 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
irqreturn_t qlafx00_intr_handler(int irq , void *dev_id ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct device_reg_fx00 *reg ;
  int status ;
  unsigned long iter ;
  uint32_t stat ;
  uint32_t mb[8U] ;
  struct rsp_que *rsp ;
  unsigned long flags ;
  uint32_t clr_intr ;
  uint32_t intr_stat ;
  int tmp ;
  long tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  void *tmp___2 ;
  bool tmp___3 ;
  unsigned short tmp___4 ;
  unsigned short tmp___5 ;
  unsigned long tmp___6 ;

  {
#line 2908
  clr_intr = 0U;
#line 2909
  intr_stat = 0U;
#line 2911
  rsp = (struct rsp_que *)dev_id;
#line 2912
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 2913
    ql_log(2U, (scsi_qla_host_t *)0, 20605, "%s: NULL response queue pointer.\n",
           "qlafx00_intr_handler");
#line 2915
    return (0);
  } else {

  }
#line 2918
  ha = rsp->hw;
#line 2919
  reg = & (ha->iobase)->ispfx00;
#line 2920
  status = 0;
#line 2922
  tmp = pci_channel_offline(ha->pdev);
#line 2922
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 2922
  if (tmp___0 != 0L) {
#line 2923
    return (1);
  } else {

  }
#line 2925
  tmp___1 = spinlock_check(& ha->hardware_lock);
#line 2925
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 2926
  tmp___2 = pci_get_drvdata(ha->pdev);
#line 2926
  vha = (scsi_qla_host_t *)tmp___2;
#line 2927
  iter = 50UL;
#line 2927
  goto ldv_66617;
  ldv_66616: 
#line 2928
  stat = readl((void const volatile   *)ha->cregbase + 138096U);
#line 2929
  tmp___3 = qla2x00_check_reg32_for_disconnect(vha, stat);
#line 2929
  if ((int )tmp___3) {
#line 2930
    goto ldv_66615;
  } else {

  }
#line 2931
  intr_stat = stat & 7U;
#line 2932
  if (intr_stat == 0U) {
#line 2933
    goto ldv_66615;
  } else {

  }
#line 2935
  if ((int )stat & 1) {
#line 2936
    tmp___4 = readw((void const volatile   *)(& reg->mailbox16));
#line 2936
    mb[0] = (uint32_t )tmp___4;
#line 2937
    qlafx00_mbx_completion(vha, mb[0]);
#line 2938
    status = status | 1;
#line 2939
    clr_intr = clr_intr | 1U;
  } else {

  }
#line 2941
  if ((intr_stat & 4U) != 0U) {
#line 2942
    tmp___5 = readw((void const volatile   *)(& reg->aenmailbox0));
#line 2942
    ha->aenmb[0] = (uint32_t )tmp___5;
#line 2943
    qlafx00_async_event(vha);
#line 2944
    clr_intr = clr_intr | 4U;
  } else {

  }
#line 2946
  if ((intr_stat & 2U) != 0U) {
#line 2947
    qlafx00_process_response_queue(vha, rsp);
#line 2948
    clr_intr = clr_intr | 2U;
  } else {

  }
#line 2951
  writel(~ clr_intr, (void volatile   *)ha->cregbase + 138096U);
#line 2952
  readl((void const volatile   *)ha->cregbase + 138096U);
#line 2927
  clr_intr = 0U;
  ldv_66617: 
#line 2927
  tmp___6 = iter;
#line 2927
  iter = iter - 1UL;
#line 2927
  if (tmp___6 != 0UL) {
#line 2929
    goto ldv_66616;
  } else {

  }
  ldv_66615: 
#line 2955
  qla2x00_handle_mbx_completion(ha, status);
#line 2956
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2958
  return (1);
}
}
#line 2964 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
__inline static cont_a64_entry_t *qlafx00_prep_cont_type1_iocb(struct req_que *req ,
                                                               cont_a64_entry_t *lcont_pkt ) 
{ 
  cont_a64_entry_t *cont_pkt ;

  {
#line 2970
  req->ring_index = (uint16_t )((int )req->ring_index + 1);
#line 2971
  if ((int )req->ring_index == (int )req->length) {
#line 2972
    req->ring_index = 0U;
#line 2973
    req->ring_ptr = req->ring;
  } else {
#line 2975
    req->ring_ptr = req->ring_ptr + 1;
  }
#line 2978
  cont_pkt = (cont_a64_entry_t *)req->ring_ptr;
#line 2981
  lcont_pkt->entry_type = 3U;
#line 2983
  return (cont_pkt);
}
}
#line 2987 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
__inline static void qlafx00_build_scsi_iocbs(srb_t *sp , struct cmd_type_7_fx00 *cmd_pkt ,
                                              uint16_t tot_dsds , struct cmd_type_7_fx00 *lcmd_pkt ) 
{ 
  uint16_t avail_dsds ;
  __le32 *cur_dsd ;
  scsi_qla_host_t *vha ;
  struct scsi_cmnd *cmd ;
  struct scatterlist *sg ;
  int i ;
  int cont ;
  struct req_que *req ;
  cont_a64_entry_t lcont_pkt ;
  cont_a64_entry_t *cont_pkt ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  dma_addr_t sle_dma ;
  __le32 *tmp___2 ;
  __le32 *tmp___3 ;
  __le32 *tmp___4 ;

  {
#line 3000
  vha = (sp->fcport)->vha;
#line 3001
  req = vha->req;
#line 3003
  cmd = sp->u.scmd.cmd;
#line 3004
  cont = 0;
#line 3005
  cont_pkt = (cont_a64_entry_t *)0;
#line 3008
  lcmd_pkt->entry_type = 7U;
#line 3011
  tmp = scsi_bufflen(cmd);
#line 3011
  if (tmp == 0U || (unsigned int )cmd->sc_data_direction == 3U) {
#line 3012
    lcmd_pkt->byte_count = 0U;
#line 3013
    return;
  } else {

  }
#line 3017
  if ((unsigned int )cmd->sc_data_direction == 1U) {
#line 3018
    lcmd_pkt->cntrl_flags = 1U;
#line 3019
    tmp___0 = scsi_bufflen(cmd);
#line 3019
    vha->qla_stats.output_bytes = vha->qla_stats.output_bytes + (uint64_t )tmp___0;
  } else
#line 3020
  if ((unsigned int )cmd->sc_data_direction == 2U) {
#line 3021
    lcmd_pkt->cntrl_flags = 2U;
#line 3022
    tmp___1 = scsi_bufflen(cmd);
#line 3022
    vha->qla_stats.input_bytes = vha->qla_stats.input_bytes + (uint64_t )tmp___1;
  } else {

  }
#line 3026
  avail_dsds = 1U;
#line 3027
  cur_dsd = (__le32 *)(& lcmd_pkt->dseg_0_address);
#line 3030
  i = 0;
#line 3030
  sg = scsi_sglist(cmd);
#line 3030
  goto ldv_66641;
  ldv_66640: ;
#line 3034
  if ((unsigned int )avail_dsds == 0U) {
#line 3039
    memset((void *)(& lcont_pkt), 0, 64UL);
#line 3040
    cont_pkt = qlafx00_prep_cont_type1_iocb(req, & lcont_pkt);
#line 3042
    cur_dsd = (__le32 *)(& lcont_pkt.dseg_0_address);
#line 3043
    avail_dsds = 5U;
#line 3044
    cont = 1;
  } else {

  }
#line 3047
  sle_dma = sg->dma_address;
#line 3048
  tmp___2 = cur_dsd;
#line 3048
  cur_dsd = cur_dsd + 1;
#line 3048
  *tmp___2 = (unsigned int )sle_dma;
#line 3049
  tmp___3 = cur_dsd;
#line 3049
  cur_dsd = cur_dsd + 1;
#line 3049
  *tmp___3 = (unsigned int )(sle_dma >> 32ULL);
#line 3050
  tmp___4 = cur_dsd;
#line 3050
  cur_dsd = cur_dsd + 1;
#line 3050
  *tmp___4 = sg->dma_length;
#line 3051
  avail_dsds = (uint16_t )((int )avail_dsds - 1);
#line 3052
  if ((unsigned int )avail_dsds == 0U && cont == 1) {
#line 3053
    cont = 0;
#line 3054
    memcpy_toio((void volatile   *)cont_pkt, (void const   *)(& lcont_pkt), 64UL);
  } else {

  }
#line 3030
  i = i + 1;
#line 3030
  sg = sg_next(sg);
  ldv_66641: ;
#line 3030
  if ((int )tot_dsds > i) {
#line 3032
    goto ldv_66640;
  } else {

  }

#line 3059
  if ((unsigned int )avail_dsds != 0U && cont == 1) {
#line 3060
    memcpy_toio((void volatile   *)cont_pkt, (void const   *)(& lcont_pkt), 64UL);
  } else {

  }
#line 3061
  return;
}
}
#line 3072 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
int qlafx00_start_scsi(srb_t *sp ) 
{ 
  int ret ;
  int nseg ;
  unsigned long flags ;
  uint32_t index ;
  uint32_t handle ;
  uint16_t cnt ;
  uint16_t req_cnt ;
  uint16_t tot_dsds ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  struct scsi_cmnd *cmd ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct cmd_type_7_fx00 *cmd_pkt ;
  struct cmd_type_7_fx00 lcmd_pkt ;
  struct scsi_lun llun ;
  raw_spinlock_t *tmp ;
  unsigned int tmp___0 ;
  struct scatterlist *tmp___1 ;
  long tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 3081
  req = (struct req_que *)0;
#line 3082
  rsp = (struct rsp_que *)0;
#line 3083
  cmd = sp->u.scmd.cmd;
#line 3084
  vha = (sp->fcport)->vha;
#line 3085
  ha = vha->hw;
#line 3091
  ret = 0;
#line 3093
  rsp = *(ha->rsp_q_map);
#line 3094
  req = vha->req;
#line 3097
  tot_dsds = 0U;
#line 3100
  tmp = spinlock_check(& ha->hardware_lock);
#line 3100
  flags = _raw_spin_lock_irqsave(tmp);
#line 3103
  handle = req->current_outstanding_cmd;
#line 3104
  index = 1U;
#line 3104
  goto ldv_66667;
  ldv_66666: 
#line 3105
  handle = handle + 1U;
#line 3106
  if ((uint32_t )req->num_outstanding_cmds == handle) {
#line 3107
    handle = 1U;
  } else {

  }
#line 3108
  if ((unsigned long )*(req->outstanding_cmds + (unsigned long )handle) == (unsigned long )((srb_t *)0)) {
#line 3109
    goto ldv_66665;
  } else {

  }
#line 3104
  index = index + 1U;
  ldv_66667: ;
#line 3104
  if ((uint32_t )req->num_outstanding_cmds > index) {
#line 3106
    goto ldv_66666;
  } else {

  }
  ldv_66665: ;
#line 3111
  if ((uint32_t )req->num_outstanding_cmds == index) {
#line 3112
    goto queuing_error;
  } else {

  }
#line 3115
  tmp___3 = scsi_sg_count(cmd);
#line 3115
  if (tmp___3 != 0U) {
#line 3116
    tmp___0 = scsi_sg_count(cmd);
#line 3116
    tmp___1 = scsi_sglist(cmd);
#line 3116
    nseg = dma_map_sg_attrs(& (ha->pdev)->dev, tmp___1, (int )tmp___0, cmd->sc_data_direction,
                            (struct dma_attrs *)0);
#line 3118
    tmp___2 = ldv__builtin_expect(nseg == 0, 0L);
#line 3118
    if (tmp___2 != 0L) {
#line 3119
      goto queuing_error;
    } else {

    }
  } else {
#line 3121
    nseg = 0;
  }
#line 3123
  tot_dsds = (uint16_t )nseg;
#line 3124
  req_cnt = qla24xx_calc_iocbs(vha, (int )tot_dsds);
#line 3125
  if ((int )req->cnt < (int )req_cnt + 2) {
#line 3126
    tmp___4 = __readl((void const volatile   *)req->req_q_out);
#line 3126
    cnt = (uint16_t )tmp___4;
#line 3128
    if ((int )req->ring_index < (int )cnt) {
#line 3129
      req->cnt = (int )cnt - (int )req->ring_index;
    } else {
#line 3131
      req->cnt = (int )req->length + ((int )cnt - (int )req->ring_index);
    }
#line 3133
    if ((int )req->cnt < (int )req_cnt + 2) {
#line 3134
      goto queuing_error;
    } else {

    }
  } else {

  }
#line 3138
  req->current_outstanding_cmd = handle;
#line 3139
  *(req->outstanding_cmds + (unsigned long )handle) = sp;
#line 3140
  sp->handle = handle;
#line 3141
  cmd->host_scribble = (unsigned char *)((unsigned long )handle);
#line 3142
  req->cnt = (int )req->cnt - (int )req_cnt;
#line 3144
  cmd_pkt = (struct cmd_type_7_fx00 *)req->ring_ptr;
#line 3146
  memset((void *)(& lcmd_pkt), 0, 64UL);
#line 3148
  lcmd_pkt.handle = ((unsigned int )req->id << 16) | sp->handle;
#line 3149
  lcmd_pkt.reserved_0 = 0U;
#line 3150
  lcmd_pkt.port_path_ctrl = 0U;
#line 3151
  lcmd_pkt.reserved_1 = 0U;
#line 3152
  lcmd_pkt.dseg_count = tot_dsds;
#line 3153
  lcmd_pkt.tgt_idx = (sp->fcport)->tgt_id;
#line 3155
  int_to_scsilun((cmd->device)->lun, & llun);
#line 3156
  host_to_adap((uint8_t *)(& llun), (uint8_t *)(& lcmd_pkt.lun), 8U);
#line 3160
  host_to_adap(cmd->cmnd, (uint8_t *)(& lcmd_pkt.fcp_cdb), 16U);
#line 3161
  lcmd_pkt.byte_count = scsi_bufflen(cmd);
#line 3164
  qlafx00_build_scsi_iocbs(sp, cmd_pkt, (int )tot_dsds, & lcmd_pkt);
#line 3167
  lcmd_pkt.entry_count = (unsigned char )req_cnt;
#line 3170
  lcmd_pkt.entry_status = (unsigned char )rsp->id;
#line 3172
  ql_dump_buffer(134348800U, vha, 12334, cmd->cmnd, (uint32_t )cmd->cmd_len);
#line 3174
  ql_dump_buffer(134348800U, vha, 12338, (uint8_t *)(& lcmd_pkt), 64U);
#line 3177
  memcpy_toio((void volatile   *)cmd_pkt, (void const   *)(& lcmd_pkt), 64UL);
#line 3178
  __asm__  volatile   ("sfence": : : "memory");
#line 3181
  req->ring_index = (uint16_t )((int )req->ring_index + 1);
#line 3182
  if ((int )req->ring_index == (int )req->length) {
#line 3183
    req->ring_index = 0U;
#line 3184
    req->ring_ptr = req->ring;
  } else {
#line 3186
    req->ring_ptr = req->ring_ptr + 1;
  }
#line 3188
  sp->flags = (uint16_t )((unsigned int )sp->flags | 1U);
#line 3191
  writel((unsigned int )req->ring_index, (void volatile   *)req->req_q_in);
#line 3192
  writel(ha->rqstq_intr_code, (void volatile   *)ha->cregbase + 133636U);
#line 3194
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3195
  return (0);
  queuing_error: ;
#line 3198
  if ((unsigned int )tot_dsds != 0U) {
#line 3199
    scsi_dma_unmap(cmd);
  } else {

  }
#line 3201
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3203
  return (258);
}
}
#line 3207 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
void qlafx00_tm_iocb(srb_t *sp , struct tsk_mgmt_entry_fx00 *ptm_iocb ) 
{ 
  struct srb_iocb *fxio ;
  scsi_qla_host_t *vha ;
  struct req_que *req ;
  struct tsk_mgmt_entry_fx00 tm_iocb ;
  struct scsi_lun llun ;

  {
#line 3209
  fxio = & sp->u.iocb_cmd;
#line 3210
  vha = (sp->fcport)->vha;
#line 3211
  req = vha->req;
#line 3215
  memset((void *)(& tm_iocb), 0, 64UL);
#line 3216
  tm_iocb.entry_type = 5U;
#line 3217
  tm_iocb.entry_count = 1U;
#line 3218
  tm_iocb.handle = ((unsigned int )req->id << 16) | sp->handle;
#line 3219
  tm_iocb.reserved_0 = 0U;
#line 3220
  tm_iocb.tgt_id = (sp->fcport)->tgt_id;
#line 3221
  tm_iocb.control_flags = fxio->u.tmf.flags;
#line 3222
  if (tm_iocb.control_flags == 16U) {
#line 3223
    int_to_scsilun(fxio->u.tmf.lun, & llun);
#line 3224
    host_to_adap((uint8_t *)(& llun), (uint8_t *)(& tm_iocb.lun), 8U);
  } else {

  }
#line 3228
  memcpy((void *)ptm_iocb, (void const   *)(& tm_iocb), 64UL);
#line 3230
  __asm__  volatile   ("sfence": : : "memory");
#line 3231
  return;
}
}
#line 3234 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
void qlafx00_abort_iocb(srb_t *sp , struct abort_iocb_entry_fx00 *pabt_iocb ) 
{ 
  struct srb_iocb *fxio ;
  scsi_qla_host_t *vha ;
  struct req_que *req ;
  struct abort_iocb_entry_fx00 abt_iocb ;

  {
#line 3236
  fxio = & sp->u.iocb_cmd;
#line 3237
  vha = (sp->fcport)->vha;
#line 3238
  req = vha->req;
#line 3241
  memset((void *)(& abt_iocb), 0, 64UL);
#line 3242
  abt_iocb.entry_type = 8U;
#line 3243
  abt_iocb.entry_count = 1U;
#line 3244
  abt_iocb.handle = ((unsigned int )req->id << 16) | sp->handle;
#line 3245
  abt_iocb.abort_handle = ((unsigned int )req->id << 16) | fxio->u.abt.cmd_hndl;
#line 3247
  abt_iocb.tgt_id_sts = (sp->fcport)->tgt_id;
#line 3248
  abt_iocb.req_que_no = req->id;
#line 3250
  memcpy((void *)pabt_iocb, (void const   *)(& abt_iocb), 64UL);
#line 3252
  __asm__  volatile   ("sfence": : : "memory");
#line 3253
  return;
}
}
#line 3256 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.c"
void qlafx00_fxdisc_iocb(srb_t *sp , struct fxdisc_entry_fx00 *pfxiocb ) 
{ 
  struct srb_iocb *fxio ;
  struct qla_mt_iocb_rqst_fx00 *piocb_rqst ;
  struct fc_bsg_job *bsg_job ;
  struct fxdisc_entry_fx00 fx_iocb ;
  uint8_t entry_cnt ;
  struct scatterlist *sg ;
  int avail_dsds ;
  int tot_dsds ;
  cont_a64_entry_t lcont_pkt ;
  cont_a64_entry_t *cont_pkt ;
  __le32 *cur_dsd ;
  int index ;
  int cont ;
  dma_addr_t sle_dma ;
  __le32 *tmp ;
  __le32 *tmp___0 ;
  __le32 *tmp___1 ;
  int avail_dsds___0 ;
  int tot_dsds___0 ;
  cont_a64_entry_t lcont_pkt___0 ;
  cont_a64_entry_t *cont_pkt___0 ;
  __le32 *cur_dsd___0 ;
  int index___0 ;
  int cont___0 ;
  dma_addr_t sle_dma___0 ;
  __le32 *tmp___2 ;
  __le32 *tmp___3 ;
  __le32 *tmp___4 ;

  {
#line 3258
  fxio = & sp->u.iocb_cmd;
#line 3262
  entry_cnt = 1U;
#line 3264
  memset((void *)(& fx_iocb), 0, 64UL);
#line 3265
  fx_iocb.entry_type = 11U;
#line 3266
  fx_iocb.handle = sp->handle;
#line 3267
  fx_iocb.entry_count = entry_cnt;
#line 3269
  if ((unsigned int )sp->type == 10U) {
#line 3270
    fx_iocb.func_num = sp->u.iocb_cmd.u.fxiocb.req_func_type;
#line 3272
    fx_iocb.adapid = fxio->u.fxiocb.adapter_id;
#line 3273
    fx_iocb.adapid_hi = fxio->u.fxiocb.adapter_id_hi;
#line 3274
    fx_iocb.reserved_0 = fxio->u.fxiocb.reserved_0;
#line 3275
    fx_iocb.reserved_1 = fxio->u.fxiocb.reserved_1;
#line 3276
    fx_iocb.dataword_extra = fxio->u.fxiocb.req_data_extra;
#line 3278
    if ((int )fxio->u.fxiocb.flags & 1) {
#line 3279
      fx_iocb.req_dsdcnt = 1U;
#line 3280
      fx_iocb.req_xfrcnt = (unsigned short )fxio->u.fxiocb.req_len;
#line 3282
      fx_iocb.dseg_rq_address[0] = (unsigned int )fxio->u.fxiocb.req_dma_handle;
#line 3284
      fx_iocb.dseg_rq_address[1] = (unsigned int )(fxio->u.fxiocb.req_dma_handle >> 32ULL);
#line 3286
      fx_iocb.dseg_rq_len = fxio->u.fxiocb.req_len;
    } else {

    }
#line 3290
    if (((int )fxio->u.fxiocb.flags & 2) != 0) {
#line 3291
      fx_iocb.rsp_dsdcnt = 1U;
#line 3292
      fx_iocb.rsp_xfrcnt = (unsigned short )fxio->u.fxiocb.rsp_len;
#line 3294
      fx_iocb.dseg_rsp_address[0] = (unsigned int )fxio->u.fxiocb.rsp_dma_handle;
#line 3296
      fx_iocb.dseg_rsp_address[1] = (unsigned int )(fxio->u.fxiocb.rsp_dma_handle >> 32ULL);
#line 3298
      fx_iocb.dseg_rsp_len = fxio->u.fxiocb.rsp_len;
    } else {

    }
#line 3302
    if (((int )fxio->u.fxiocb.flags & 4) != 0) {
#line 3303
      fx_iocb.dataword = fxio->u.fxiocb.req_data;
    } else {

    }
#line 3305
    fx_iocb.flags = fxio->u.fxiocb.flags;
  } else {
#line 3308
    bsg_job = sp->u.bsg_job;
#line 3309
    piocb_rqst = (struct qla_mt_iocb_rqst_fx00 *)(& (bsg_job->request)->rqst_data.h_vendor.vendor_cmd) + 1U;
#line 3312
    fx_iocb.func_num = piocb_rqst->func_type;
#line 3313
    fx_iocb.adapid = piocb_rqst->adapid;
#line 3314
    fx_iocb.adapid_hi = piocb_rqst->adapid_hi;
#line 3315
    fx_iocb.reserved_0 = piocb_rqst->reserved_0;
#line 3316
    fx_iocb.reserved_1 = piocb_rqst->reserved_1;
#line 3317
    fx_iocb.dataword_extra = piocb_rqst->dataword_extra;
#line 3318
    fx_iocb.dataword = piocb_rqst->dataword;
#line 3319
    fx_iocb.req_xfrcnt = piocb_rqst->req_len;
#line 3320
    fx_iocb.rsp_xfrcnt = piocb_rqst->rsp_len;
#line 3322
    if ((int )piocb_rqst->flags & 1) {
#line 3325
      cont_pkt = (cont_a64_entry_t *)0;
#line 3327
      index = 0;
#line 3327
      cont = 0;
#line 3329
      fx_iocb.req_dsdcnt = (unsigned short )bsg_job->request_payload.sg_cnt;
#line 3331
      tot_dsds = bsg_job->request_payload.sg_cnt;
#line 3333
      cur_dsd = (__le32 *)(& fx_iocb.dseg_rq_address);
#line 3334
      avail_dsds = 1;
#line 3335
      index = 0;
#line 3335
      sg = bsg_job->request_payload.sg_list;
#line 3335
      goto ldv_66705;
      ldv_66704: ;
#line 3340
      if (avail_dsds == 0) {
#line 3345
        memset((void *)(& lcont_pkt), 0, 64UL);
#line 3347
        cont_pkt = qlafx00_prep_cont_type1_iocb(((sp->fcport)->vha)->req, & lcont_pkt);
#line 3351
        cur_dsd = (__le32 *)(& lcont_pkt.dseg_0_address);
#line 3353
        avail_dsds = 5;
#line 3354
        cont = 1;
#line 3355
        entry_cnt = (uint8_t )((int )entry_cnt + 1);
      } else {

      }
#line 3358
      sle_dma = sg->dma_address;
#line 3359
      tmp = cur_dsd;
#line 3359
      cur_dsd = cur_dsd + 1;
#line 3359
      *tmp = (unsigned int )sle_dma;
#line 3360
      tmp___0 = cur_dsd;
#line 3360
      cur_dsd = cur_dsd + 1;
#line 3360
      *tmp___0 = (unsigned int )(sle_dma >> 32ULL);
#line 3361
      tmp___1 = cur_dsd;
#line 3361
      cur_dsd = cur_dsd + 1;
#line 3361
      *tmp___1 = sg->dma_length;
#line 3362
      avail_dsds = avail_dsds - 1;
#line 3364
      if (avail_dsds == 0 && cont == 1) {
#line 3365
        cont = 0;
#line 3366
        memcpy_toio((void volatile   *)cont_pkt, (void const   *)(& lcont_pkt), 64UL);
#line 3369
        ql_dump_buffer(8421376U, (sp->fcport)->vha, 12354, (uint8_t *)(& lcont_pkt),
                       64U);
      } else {

      }
#line 3335
      index = index + 1;
#line 3335
      sg = sg_next(sg);
      ldv_66705: ;
#line 3335
      if (index < tot_dsds) {
#line 3337
        goto ldv_66704;
      } else {

      }

#line 3376
      if (avail_dsds != 0 && cont == 1) {
#line 3377
        memcpy_toio((void volatile   *)cont_pkt, (void const   *)(& lcont_pkt), 64UL);
#line 3379
        ql_dump_buffer(8421376U, (sp->fcport)->vha, 12355, (uint8_t *)(& lcont_pkt),
                       64U);
      } else {

      }
    } else {

    }
#line 3385
    if (((int )piocb_rqst->flags & 2) != 0) {
#line 3388
      cont_pkt___0 = (cont_a64_entry_t *)0;
#line 3390
      index___0 = 0;
#line 3390
      cont___0 = 0;
#line 3392
      fx_iocb.rsp_dsdcnt = (unsigned short )bsg_job->reply_payload.sg_cnt;
#line 3394
      tot_dsds___0 = bsg_job->reply_payload.sg_cnt;
#line 3395
      cur_dsd___0 = (__le32 *)(& fx_iocb.dseg_rsp_address);
#line 3396
      avail_dsds___0 = 1;
#line 3398
      index___0 = 0;
#line 3398
      sg = bsg_job->reply_payload.sg_list;
#line 3398
      goto ldv_66716;
      ldv_66715: ;
#line 3403
      if (avail_dsds___0 == 0) {
#line 3408
        memset((void *)(& lcont_pkt___0), 0, 64UL);
#line 3410
        cont_pkt___0 = qlafx00_prep_cont_type1_iocb(((sp->fcport)->vha)->req, & lcont_pkt___0);
#line 3414
        cur_dsd___0 = (__le32 *)(& lcont_pkt___0.dseg_0_address);
#line 3416
        avail_dsds___0 = 5;
#line 3417
        cont___0 = 1;
#line 3418
        entry_cnt = (uint8_t )((int )entry_cnt + 1);
      } else {

      }
#line 3421
      sle_dma___0 = sg->dma_address;
#line 3422
      tmp___2 = cur_dsd___0;
#line 3422
      cur_dsd___0 = cur_dsd___0 + 1;
#line 3422
      *tmp___2 = (unsigned int )sle_dma___0;
#line 3423
      tmp___3 = cur_dsd___0;
#line 3423
      cur_dsd___0 = cur_dsd___0 + 1;
#line 3423
      *tmp___3 = (unsigned int )(sle_dma___0 >> 32ULL);
#line 3424
      tmp___4 = cur_dsd___0;
#line 3424
      cur_dsd___0 = cur_dsd___0 + 1;
#line 3424
      *tmp___4 = sg->dma_length;
#line 3425
      avail_dsds___0 = avail_dsds___0 - 1;
#line 3427
      if (avail_dsds___0 == 0 && cont___0 == 1) {
#line 3428
        cont___0 = 0;
#line 3429
        memcpy_toio((void volatile   *)cont_pkt___0, (void const   *)(& lcont_pkt___0),
                    64UL);
#line 3432
        ql_dump_buffer(8421376U, (sp->fcport)->vha, 12357, (uint8_t *)(& lcont_pkt___0),
                       64U);
      } else {

      }
#line 3398
      index___0 = index___0 + 1;
#line 3398
      sg = sg_next(sg);
      ldv_66716: ;
#line 3398
      if (index___0 < tot_dsds___0) {
#line 3400
        goto ldv_66715;
      } else {

      }

#line 3439
      if (avail_dsds___0 != 0 && cont___0 == 1) {
#line 3440
        memcpy_toio((void volatile   *)cont_pkt___0, (void const   *)(& lcont_pkt___0),
                    64UL);
#line 3442
        ql_dump_buffer(8421376U, (sp->fcport)->vha, 12358, (uint8_t *)(& lcont_pkt___0),
                       64U);
      } else {

      }
    } else {

    }
#line 3448
    if (((int )piocb_rqst->flags & 4) != 0) {
#line 3449
      fx_iocb.dataword = piocb_rqst->dataword;
    } else {

    }
#line 3450
    fx_iocb.flags = piocb_rqst->flags;
#line 3451
    fx_iocb.entry_count = entry_cnt;
  }
#line 3454
  ql_dump_buffer(8421376U, (sp->fcport)->vha, 12359, (uint8_t *)(& fx_iocb), 64U);
#line 3458
  memcpy_toio((void volatile   *)pfxiocb, (void const   *)(& fx_iocb), 64UL);
#line 3460
  __asm__  volatile   ("sfence": : : "memory");
#line 3461
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
void choose_timer_27(struct timer_list *timer ) 
{ 


  {
#line 489
  LDV_IN_INTERRUPT = 2;
#line 490
  (*(timer->function))(timer->data);
#line 491
  LDV_IN_INTERRUPT = 1;
#line 492
  ldv_timer_state_27 = 2;
#line 493
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
void activate_pending_timer_27(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 496
  if ((unsigned long )ldv_timer_list_27 == (unsigned long )timer) {
#line 497
    if (ldv_timer_state_27 == 2 || pending_flag != 0) {
#line 498
      ldv_timer_list_27 = timer;
#line 499
      ldv_timer_list_27->data = data;
#line 500
      ldv_timer_state_27 = 1;
    } else {

    }
#line 502
    return;
  } else {

  }
#line 504
  reg_timer_27(timer);
#line 505
  ldv_timer_list_27->data = data;
#line 506
  return;
}
}
#line 509 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
void disable_suitable_timer_27(struct timer_list *timer ) 
{ 


  {
#line 510
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_27) {
#line 511
    ldv_timer_state_27 = 0;
#line 512
    return;
  } else {

  }
#line 514
  return;
}
}
#line 517 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
int reg_timer_27(struct timer_list *timer ) 
{ 


  {
#line 518
  ldv_timer_list_27 = timer;
#line 519
  ldv_timer_state_27 = 1;
#line 520
  return (0);
}
}
#line 546 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
bool ldv_queue_work_on_263(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 550
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 550
  ldv_func_res = tmp;
#line 552
  activate_work_7(ldv_func_arg3, 2);
#line 554
  return (ldv_func_res);
}
}
#line 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
bool ldv_queue_delayed_work_on_264(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 561
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 561
  ldv_func_res = tmp;
#line 563
  activate_work_7(& ldv_func_arg3->work, 2);
#line 565
  return (ldv_func_res);
}
}
#line 568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
bool ldv_queue_work_on_265(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 572
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 572
  ldv_func_res = tmp;
#line 574
  activate_work_7(ldv_func_arg3, 2);
#line 576
  return (ldv_func_res);
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
void ldv_flush_workqueue_266(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 582
  flush_workqueue(ldv_func_arg1);
#line 584
  call_and_disable_all_7(2);
#line 585
  return;
}
}
#line 587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
bool ldv_queue_delayed_work_on_267(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 591
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 591
  ldv_func_res = tmp;
#line 593
  activate_work_7(& ldv_func_arg3->work, 2);
#line 595
  return (ldv_func_res);
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
int ldv_scsi_add_host_with_dma_268(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 602
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 602
  ldv_func_res = tmp;
#line 604
  if (ldv_func_res == 0) {
#line 605
    ldv_state_variable_88 = 1;
#line 605
    ldv_initialize_scsi_host_template_88();
  } else {

  }
#line 609
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 292 "include/linux/jiffies.h"
extern unsigned long __msecs_to_jiffies(unsigned int const    ) ;
#line 354 "include/linux/jiffies.h"
__inline static unsigned long msecs_to_jiffies(unsigned int const   m ) 
{ 
  unsigned long tmp___0 ;

  {
#line 361
  tmp___0 = __msecs_to_jiffies(m);
#line 361
  return (tmp___0);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_279(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_281(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_280(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_283(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_282(struct workqueue_struct *ldv_func_arg1 ) ;
#line 325 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
void disable_suitable_timer_28(struct timer_list *timer ) ;
#line 411
int reg_timer_28(struct timer_list *timer ) ;
#line 463
void choose_timer_28(struct timer_list *timer ) ;
#line 467
void activate_pending_timer_28(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 8 "include/asm-generic/delay.h"
extern void __udelay(unsigned long  ) ;
#line 795 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_284(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
#line 1179 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx.h"
static int const   MD_MIU_TEST_AGT_RDDATA___0[4U]  = {      1090519208,      1090519212,      1090519224,      1090519228};
#line 536 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
static uint32_t const   qla8044_reg_tbl[14U]  = 
#line 536 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
  {      13480U,      13484U,      13488U,      14216U, 
        14212U,      14220U,      13640U,      14304U, 
        14208U,      13648U,      13652U,      13656U, 
        13904U,      14260U};
#line 758 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
void qla8044_get_minidump(struct scsi_qla_host *vha ) ;
#line 759
int qla8044_collect_md_data(struct scsi_qla_host *vha ) ;
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
uint32_t qla8044_rd_reg(struct qla_hw_data *ha , ulong addr ) 
{ 
  unsigned int tmp ;

  {
#line 22
  tmp = readl((void const volatile   *)(ha->nx_pcibase + addr));
#line 22
  return (tmp);
}
}
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
void qla8044_wr_reg(struct qla_hw_data *ha , ulong addr , uint32_t val ) 
{ 


  {
#line 28
  writel(val, (void volatile   *)(ha->nx_pcibase + addr));
#line 29
  return;
}
}
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
int qla8044_rd_direct(struct scsi_qla_host *vha , uint32_t const   crb_reg ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t tmp ;

  {
#line 35
  ha = vha->hw;
#line 37
  if ((unsigned int )crb_reg <= 13U) {
#line 38
    tmp = qla8044_rd_reg(ha, (ulong )qla8044_reg_tbl[crb_reg]);
#line 38
    return ((int )tmp);
  } else {
#line 40
    return (258);
  }
}
}
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
void qla8044_wr_direct(struct scsi_qla_host *vha , uint32_t const   crb_reg , uint32_t const   value ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 48
  ha = vha->hw;
#line 50
  if ((unsigned int )crb_reg <= 13U) {
#line 51
    qla8044_wr_reg(ha, (ulong )qla8044_reg_tbl[crb_reg], value);
  } else {

  }
#line 52
  return;
}
}
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_set_win_base(scsi_qla_host_t *vha , uint32_t addr ) 
{ 
  uint32_t val ;
  int ret_val ;
  struct qla_hw_data *ha ;

  {
#line 58
  ret_val = 0;
#line 59
  ha = vha->hw;
#line 61
  qla8044_wr_reg(ha, (ulong )(((int )ha->portnum + 3584) * 4), addr);
#line 62
  val = qla8044_rd_reg(ha, (ulong )(((int )ha->portnum + 3584) * 4));
#line 64
  if (val != addr) {
#line 65
    ql_log(1U, vha, 45191, "%s: Failed to set register window : addr written 0x%x, read 0x%x!\n",
           "qla8044_set_win_base", addr, val);
#line 69
    ret_val = 258;
  } else {

  }
#line 71
  return (ret_val);
}
}
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_rd_reg_indirect(scsi_qla_host_t *vha , uint32_t addr , uint32_t *data ) 
{ 
  int ret_val ;
  struct qla_hw_data *ha ;

  {
#line 77
  ret_val = 0;
#line 78
  ha = vha->hw;
#line 80
  ret_val = qla8044_set_win_base(vha, addr);
#line 81
  if (ret_val == 0) {
#line 82
    *data = qla8044_rd_reg(ha, 14576UL);
  } else {
#line 84
    ql_log(1U, vha, 45192, "%s: failed read of addr 0x%x!\n", "qla8044_rd_reg_indirect",
           addr);
  }
#line 86
  return (ret_val);
}
}
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_wr_reg_indirect(scsi_qla_host_t *vha , uint32_t addr , uint32_t data ) 
{ 
  int ret_val ;
  struct qla_hw_data *ha ;

  {
#line 92
  ret_val = 0;
#line 93
  ha = vha->hw;
#line 95
  ret_val = qla8044_set_win_base(vha, addr);
#line 96
  if (ret_val == 0) {
#line 97
    qla8044_wr_reg(ha, 14576UL, data);
  } else {
#line 99
    ql_log(1U, vha, 45193, "%s: failed wrt to addr 0x%x, data 0x%x\n", "qla8044_wr_reg_indirect",
           addr, data);
  }
#line 102
  return (ret_val);
}
}
#line 114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_read_write_crb_reg(struct scsi_qla_host *vha , uint32_t raddr ,
                                       uint32_t waddr ) 
{ 
  uint32_t value ;

  {
#line 119
  qla8044_rd_reg_indirect(vha, raddr, & value);
#line 120
  qla8044_wr_reg_indirect(vha, waddr, value);
#line 121
  return;
}
}
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_poll_wait_for_ready(struct scsi_qla_host *vha , uint32_t addr1 ,
                                       uint32_t mask ) 
{ 
  unsigned long timeout ;
  uint32_t temp ;
  unsigned long tmp ;

  {
#line 131
  tmp = msecs_to_jiffies(100U);
#line 131
  timeout = tmp + (unsigned long )jiffies;
  ldv_65968: 
#line 133
  qla8044_rd_reg_indirect(vha, addr1, & temp);
#line 134
  if ((temp & mask) != 0U) {
#line 135
    goto ldv_65961;
  } else {

  }
#line 136
  if ((long )((unsigned long )jiffies - timeout) >= 0L) {
#line 137
    ql_log(1U, vha, 45393, "Error in processing rdmdio entry\n");
#line 139
    return (-1);
  } else {

  }
#line 141
  goto ldv_65968;
  ldv_65961: ;
#line 143
  return (0);
}
}
#line 147 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static uint32_t qla8044_ipmdio_rd_reg(struct scsi_qla_host *vha , uint32_t addr1 ,
                                      uint32_t addr3 , uint32_t mask , uint32_t addr ) 
{ 
  uint32_t temp ;
  int ret ;

  {
#line 151
  ret = 0;
#line 153
  ret = qla8044_poll_wait_for_ready(vha, addr1, mask);
#line 154
  if (ret == -1) {
#line 155
    return (4294967295U);
  } else {

  }
#line 157
  temp = addr | 1073741824U;
#line 158
  qla8044_wr_reg_indirect(vha, addr1, temp);
#line 160
  ret = qla8044_poll_wait_for_ready(vha, addr1, mask);
#line 161
  if (ret == -1) {
#line 162
    return (0U);
  } else {

  }
#line 164
  qla8044_rd_reg_indirect(vha, addr3, (uint32_t *)(& ret));
#line 166
  return ((uint32_t )ret);
}
}
#line 171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_poll_wait_ipmdio_bus_idle(struct scsi_qla_host *vha , uint32_t addr1 ,
                                             uint32_t addr2 , uint32_t addr3 , uint32_t mask ) 
{ 
  unsigned long timeout ;
  uint32_t temp ;
  unsigned long tmp ;

  {
#line 178
  tmp = msecs_to_jiffies(100U);
#line 178
  timeout = tmp + (unsigned long )jiffies;
  ldv_65994: 
#line 180
  temp = qla8044_ipmdio_rd_reg(vha, addr1, addr3, mask, addr2);
#line 181
  if ((temp & 1U) == 0U) {
#line 182
    goto ldv_65987;
  } else {

  }
#line 183
  if ((long )((unsigned long )jiffies - timeout) >= 0L) {
#line 184
    ql_log(1U, vha, 45394, "Error in processing mdiobus idle\n");
#line 186
    return (-1);
  } else {

  }
#line 188
  goto ldv_65994;
  ldv_65987: ;
#line 190
  return (0);
}
}
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_ipmdio_wr_reg(struct scsi_qla_host *vha , uint32_t addr1 , uint32_t addr3 ,
                                 uint32_t mask , uint32_t addr , uint32_t value ) 
{ 
  int ret ;

  {
#line 197
  ret = 0;
#line 199
  ret = qla8044_poll_wait_for_ready(vha, addr1, mask);
#line 200
  if (ret == -1) {
#line 201
    return (-1);
  } else {

  }
#line 203
  qla8044_wr_reg_indirect(vha, addr3, value);
#line 204
  qla8044_wr_reg_indirect(vha, addr1, addr);
#line 206
  ret = qla8044_poll_wait_for_ready(vha, addr1, mask);
#line 207
  if (ret == -1) {
#line 208
    return (-1);
  } else {

  }
#line 210
  return (0);
}
}
#line 223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_rmw_crb_reg(struct scsi_qla_host *vha , uint32_t raddr , uint32_t waddr ,
                                struct qla8044_rmw *p_rmw_hdr ) 
{ 
  uint32_t value ;

  {
#line 228
  if ((unsigned int )p_rmw_hdr->index_a != 0U) {
#line 229
    value = vha->reset_tmplt.array[(int )p_rmw_hdr->index_a];
  } else {
#line 231
    qla8044_rd_reg_indirect(vha, raddr, & value);
  }
#line 232
  value = p_rmw_hdr->test_mask & value;
#line 233
  value = value << (int )p_rmw_hdr->shl;
#line 234
  value = value >> (int )p_rmw_hdr->shr;
#line 235
  value = p_rmw_hdr->or_value | value;
#line 236
  value = p_rmw_hdr->xor_value ^ value;
#line 237
  qla8044_wr_reg_indirect(vha, waddr, value);
#line 238
  return;
}
}
#line 242 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
__inline static void qla8044_set_qsnt_ready(struct scsi_qla_host *vha ) 
{ 
  uint32_t qsnt_state ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 245
  ha = vha->hw;
#line 247
  tmp = qla8044_rd_direct(vha, 5U);
#line 247
  qsnt_state = (uint32_t )tmp;
#line 248
  qsnt_state = (uint32_t )(1 << (int )ha->portnum) | qsnt_state;
#line 249
  qla8044_wr_direct(vha, 5U, qsnt_state);
#line 250
  ql_log(2U, vha, 45198, "%s(%ld): qsnt_state: 0x%08x\n", "qla8044_set_qsnt_ready",
         vha->host_no, qsnt_state);
#line 252
  return;
}
}
#line 255 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
void qla8044_clear_qsnt_ready(struct scsi_qla_host *vha ) 
{ 
  uint32_t qsnt_state ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 258
  ha = vha->hw;
#line 260
  tmp = qla8044_rd_direct(vha, 5U);
#line 260
  qsnt_state = (uint32_t )tmp;
#line 261
  qsnt_state = (uint32_t )(~ (1 << (int )ha->portnum)) & qsnt_state;
#line 262
  qla8044_wr_direct(vha, 5U, qsnt_state);
#line 263
  ql_log(2U, vha, 45199, "%s(%ld): qsnt_state: 0x%08x\n", "qla8044_clear_qsnt_ready",
         vha->host_no, qsnt_state);
#line 265
  return;
}
}
#line 294 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_lock_recovery(struct scsi_qla_host *vha ) 
{ 
  uint32_t lock ;
  uint32_t lockid ;
  struct qla_hw_data *ha ;

  {
#line 296
  lock = 0U;
#line 297
  ha = vha->hw;
#line 299
  lockid = qla8044_rd_reg(ha, 14236UL);
#line 302
  if ((lockid & 3U) != 0U) {
#line 303
    return (258);
  } else {

  }
#line 306
  qla8044_wr_reg(ha, 14236UL, (uint32_t )(((int )ha->portnum << 2) | 1));
#line 309
  msleep(200U);
#line 312
  lockid = qla8044_rd_reg(ha, 14236UL);
#line 313
  if ((lockid & 60U) != (uint32_t )((int )ha->portnum << 2)) {
#line 315
    return (258);
  } else {

  }
#line 317
  ql_dbg(524288U, vha, 45195, "%s:%d: IDC Lock recovery initiated\n", "qla8044_lock_recovery",
         (int )ha->portnum);
#line 321
  qla8044_wr_reg(ha, 14236UL, (uint32_t )(((int )ha->portnum << 2) | 2));
#line 326
  qla8044_wr_reg(ha, 13572UL, 255U);
#line 327
  qla8044_rd_reg(ha, 14444UL);
#line 330
  qla8044_wr_reg(ha, 14236UL, 0U);
#line 333
  lock = qla8044_rd_reg(ha, 14440UL);
#line 334
  if (lock != 0U) {
#line 335
    lockid = qla8044_rd_reg(ha, 13572UL);
#line 336
    lockid = ((lockid + 256U) & 4294967040U) | (uint32_t )ha->portnum;
#line 337
    qla8044_wr_reg(ha, 13572UL, lockid);
#line 338
    return (0);
  } else {
#line 340
    return (258);
  }
}
}
#line 344 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
int qla8044_idc_lock(struct qla_hw_data *ha ) 
{ 
  uint32_t ret_val ;
  uint32_t timeout ;
  uint32_t status ;
  uint32_t lock_id ;
  uint32_t lock_cnt ;
  uint32_t func_num ;
  uint32_t tmo_owner ;
  uint32_t first_owner ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;

  {
#line 346
  ret_val = 0U;
#line 346
  timeout = 0U;
#line 346
  status = 0U;
#line 347
  tmo_owner = 0U;
#line 347
  first_owner = 0U;
#line 348
  tmp = pci_get_drvdata(ha->pdev);
#line 348
  vha = (scsi_qla_host_t *)tmp;
#line 350
  goto ldv_66045;
  ldv_66044: 
#line 352
  status = qla8044_rd_reg(ha, 14440UL);
#line 354
  if (status != 0U) {
#line 357
    lock_id = qla8044_rd_reg(ha, 13572UL);
#line 358
    lock_id = ((lock_id + 256U) & 4294967040U) | (uint32_t )ha->portnum;
#line 359
    qla8044_wr_reg(ha, 13572UL, lock_id);
#line 360
    goto ldv_66042;
  } else {

  }
#line 363
  if (timeout == 0U) {
#line 364
    first_owner = qla8044_rd_reg(ha, 13572UL);
  } else {

  }
#line 366
  timeout = timeout + 1U;
#line 366
  if (timeout > 9U) {
#line 368
    tmo_owner = qla8044_rd_reg(ha, 13572UL);
#line 369
    func_num = tmo_owner & 255U;
#line 370
    lock_cnt = tmo_owner >> 8;
#line 371
    ql_log(1U, vha, 45332, "%s: Lock by func %d failed after 2s, lock held by func %d, lock count %d, first_owner %d\n",
           "qla8044_idc_lock", (int )ha->portnum, func_num, lock_cnt, first_owner & 255U);
#line 376
    if (first_owner != tmo_owner) {
#line 381
      ql_dbg(524288U, vha, 45333, "%s: %d: IDC lock failed\n", "qla8044_idc_lock",
             (int )ha->portnum);
#line 384
      timeout = 0U;
    } else {
#line 388
      tmp___0 = qla8044_lock_recovery(vha);
#line 388
      if (tmp___0 == 0) {
#line 390
        ret_val = 0U;
#line 391
        ql_dbg(524288U, vha, 45334, "%s:IDC lock Recovery by %dsuccessful...\n", "qla8044_idc_lock",
               (int )ha->portnum);
      } else {

      }
#line 400
      ql_dbg(524288U, vha, 45194, "%s: IDC lock Recovery by %d failed, Retrying timeout\n",
             "qla8044_idc_lock", (int )ha->portnum);
#line 404
      timeout = 0U;
    }
  } else {

  }
#line 407
  msleep(200U);
  ldv_66045: ;
#line 350
  if (status == 0U) {
#line 352
    goto ldv_66044;
  } else {

  }
  ldv_66042: ;
#line 409
  return ((int )ret_val);
}
}
#line 413 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
void qla8044_idc_unlock(struct qla_hw_data *ha ) 
{ 
  int id ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  uint32_t tmp___0 ;

  {
#line 416
  tmp = pci_get_drvdata(ha->pdev);
#line 416
  vha = (scsi_qla_host_t *)tmp;
#line 418
  tmp___0 = qla8044_rd_reg(ha, 13572UL);
#line 418
  id = (int )tmp___0;
#line 420
  if ((id & 255) != (int )ha->portnum) {
#line 421
    ql_log(1U, vha, 45336, "%s: IDC Unlock by %d failed, lock owner is %d!\n", "qla8044_idc_unlock",
           (int )ha->portnum, id & 255);
#line 424
    return;
  } else {

  }
#line 428
  qla8044_wr_reg(ha, 13572UL, (uint32_t )(id | 255));
#line 429
  qla8044_rd_reg(ha, 14444UL);
#line 430
  return;
}
}
#line 434 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_flash_lock(scsi_qla_host_t *vha ) 
{ 
  int lock_owner ;
  int timeout ;
  uint32_t lock_status ;
  int ret_val ;
  struct qla_hw_data *ha ;
  uint32_t tmp ;

  {
#line 437
  timeout = 0;
#line 438
  lock_status = 0U;
#line 439
  ret_val = 0;
#line 440
  ha = vha->hw;
#line 442
  goto ldv_66063;
  ldv_66062: 
#line 443
  lock_status = qla8044_rd_reg(ha, 14416UL);
#line 444
  if (lock_status != 0U) {
#line 445
    goto ldv_66060;
  } else {

  }
#line 447
  timeout = timeout + 1;
#line 447
  if (timeout > 499) {
#line 448
    tmp = qla8044_rd_reg(ha, 13568UL);
#line 448
    lock_owner = (int )tmp;
#line 450
    ql_log(1U, vha, 45331, "%s: Simultaneous flash access by following ports, active port = %d: accessing port = %d",
           "qla8044_flash_lock", (int )ha->portnum, lock_owner);
#line 453
    ret_val = 258;
#line 454
    goto ldv_66060;
  } else {

  }
#line 456
  msleep(20U);
  ldv_66063: ;
#line 442
  if (lock_status == 0U) {
#line 444
    goto ldv_66062;
  } else {

  }
  ldv_66060: 
#line 458
  qla8044_wr_reg(ha, 13568UL, (uint32_t )ha->portnum);
#line 459
  return (ret_val);
}
}
#line 463 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_flash_unlock(scsi_qla_host_t *vha ) 
{ 
  int ret_val ;
  struct qla_hw_data *ha ;
  uint32_t tmp ;

  {
#line 466
  ha = vha->hw;
#line 469
  qla8044_wr_reg(ha, 13568UL, 255U);
#line 470
  tmp = qla8044_rd_reg(ha, 14420UL);
#line 470
  ret_val = (int )tmp;
#line 471
  return;
}
}
#line 475 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_flash_lock_recovery(struct scsi_qla_host *vha ) 
{ 
  int tmp ;

  {
#line 478
  tmp = qla8044_flash_lock(vha);
#line 478
  if (tmp != 0) {
#line 480
    ql_log(1U, vha, 45344, "Resetting flash_lock\n");
  } else {

  }
#line 488
  qla8044_flash_unlock(vha);
#line 489
  return;
}
}
#line 495 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_read_flash_data(scsi_qla_host_t *vha , uint8_t *p_data , uint32_t flash_addr ,
                                   int u32_word_count ) 
{ 
  int i ;
  int ret_val ;
  uint32_t u32_word ;
  int tmp ;
  int tmp___0 ;

  {
#line 498
  ret_val = 0;
#line 501
  tmp = qla8044_flash_lock(vha);
#line 501
  if (tmp != 0) {
#line 502
    ret_val = 258;
#line 503
    goto exit_lock_error;
  } else {

  }
#line 506
  if ((flash_addr & 3U) != 0U) {
#line 507
    ql_log(1U, vha, 45335, "%s: Illegal addr = 0x%x\n", "qla8044_read_flash_data",
           flash_addr);
#line 509
    ret_val = 258;
#line 510
    goto exit_flash_read;
  } else {

  }
#line 513
  i = 0;
#line 513
  goto ldv_66085;
  ldv_66084: 
#line 514
  tmp___0 = qla8044_wr_reg_indirect(vha, 1108410416U, flash_addr & 4294901760U);
#line 514
  if (tmp___0 != 0) {
#line 516
    ql_log(1U, vha, 45337, "%s: failed to write addr 0x%x to FLASH_DIRECT_WINDOW\n! ",
           "qla8044_read_flash_data", flash_addr);
#line 520
    ret_val = 258;
#line 521
    goto exit_flash_read;
  } else {

  }
#line 524
  ret_val = qla8044_rd_reg_indirect(vha, (flash_addr & 65535U) | 1108672512U, & u32_word);
#line 527
  if (ret_val != 0) {
#line 528
    ql_log(1U, vha, 45196, "%s: failed to read addr 0x%x!\n", "qla8044_read_flash_data",
           flash_addr);
#line 531
    goto exit_flash_read;
  } else {

  }
#line 534
  *((uint32_t *)p_data) = u32_word;
#line 535
  p_data = p_data + 4UL;
#line 536
  flash_addr = flash_addr + 4U;
#line 513
  i = i + 1;
  ldv_66085: ;
#line 513
  if (i < u32_word_count) {
#line 515
    goto ldv_66084;
  } else {

  }

  exit_flash_read: 
#line 540
  qla8044_flash_unlock(vha);
  exit_lock_error: ;
#line 543
  return (ret_val);
}
}
#line 550 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
uint8_t *qla8044_read_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                                  uint32_t length ) 
{ 
  int tmp ;

  {
#line 553
  scsi_block_requests(vha->host);
#line 554
  tmp = qla8044_read_flash_data(vha, buf, offset, (int )(length / 4U));
#line 554
  if (tmp != 0) {
#line 556
    ql_log(1U, vha, 45197, "%s: Failed to read from flash\n", "qla8044_read_optrom_data");
  } else {

  }
#line 560
  scsi_unblock_requests(vha->host);
#line 561
  return (buf);
}
}
#line 565 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
__inline int qla8044_need_reset(struct scsi_qla_host *vha ) 
{ 
  uint32_t drv_state ;
  uint32_t drv_active ;
  int rval ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;

  {
#line 569
  ha = vha->hw;
#line 571
  tmp = qla8044_rd_direct(vha, 3U);
#line 571
  drv_active = (uint32_t )tmp;
#line 572
  tmp___0 = qla8044_rd_direct(vha, 5U);
#line 572
  drv_state = (uint32_t )tmp___0;
#line 574
  rval = (int )((uint32_t )(1 << (int )ha->portnum) & drv_state);
#line 576
  if (*((unsigned long *)ha + 2UL) != 0UL && drv_active != 0U) {
#line 577
    rval = 1;
  } else {

  }
#line 578
  return (rval);
}
}
#line 591 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_write_list(struct scsi_qla_host *vha , struct qla8044_reset_entry_hdr *p_hdr ) 
{ 
  struct qla8044_entry *p_entry ;
  uint32_t i ;

  {
#line 597
  p_entry = (struct qla8044_entry *)p_hdr + 8U;
#line 600
  i = 0U;
#line 600
  goto ldv_66108;
  ldv_66107: 
#line 601
  qla8044_wr_reg_indirect(vha, p_entry->arg1, p_entry->arg2);
#line 602
  if ((unsigned int )p_hdr->delay != 0U) {
#line 603
    __udelay((unsigned long )p_hdr->delay);
  } else {

  }
#line 600
  i = i + 1U;
#line 600
  p_entry = p_entry + 1;
  ldv_66108: ;
#line 600
  if ((uint32_t )p_hdr->count > i) {
#line 602
    goto ldv_66107;
  } else {

  }

#line 607
  return;
}
}
#line 617 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_read_write_list(struct scsi_qla_host *vha , struct qla8044_reset_entry_hdr *p_hdr ) 
{ 
  struct qla8044_entry *p_entry ;
  uint32_t i ;

  {
#line 623
  p_entry = (struct qla8044_entry *)p_hdr + 8U;
#line 626
  i = 0U;
#line 626
  goto ldv_66117;
  ldv_66116: 
#line 627
  qla8044_read_write_crb_reg(vha, p_entry->arg1, p_entry->arg2);
#line 629
  if ((unsigned int )p_hdr->delay != 0U) {
#line 630
    __udelay((unsigned long )p_hdr->delay);
  } else {

  }
#line 626
  i = i + 1U;
#line 626
  p_entry = p_entry + 1;
  ldv_66117: ;
#line 626
  if ((uint32_t )p_hdr->count > i) {
#line 628
    goto ldv_66116;
  } else {

  }

#line 633
  return;
}
}
#line 647 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_poll_reg(struct scsi_qla_host *vha , uint32_t addr , int duration ,
                            uint32_t test_mask , uint32_t test_result ) 
{ 
  uint32_t value ;
  int timeout_error ;
  uint8_t retries ;
  int ret_val ;
  uint8_t tmp ;

  {
#line 653
  ret_val = 0;
#line 655
  ret_val = qla8044_rd_reg_indirect(vha, addr, & value);
#line 656
  if (ret_val == 258) {
#line 657
    timeout_error = 1;
#line 658
    goto exit_poll_reg;
  } else {

  }
#line 662
  retries = (uint8_t )(duration / 10);
  ldv_66132: ;
#line 665
  if ((value & test_mask) != test_result) {
#line 666
    timeout_error = 1;
#line 667
    msleep((unsigned int )(duration / 10));
#line 668
    ret_val = qla8044_rd_reg_indirect(vha, addr, & value);
#line 669
    if (ret_val == 258) {
#line 670
      timeout_error = 1;
#line 671
      goto exit_poll_reg;
    } else {

    }
  } else {
#line 674
    timeout_error = 0;
#line 675
    goto ldv_66131;
  }
#line 677
  tmp = retries;
#line 677
  retries = (uint8_t )((int )retries - 1);
#line 677
  if ((unsigned int )tmp != 0U) {
#line 679
    goto ldv_66132;
  } else {

  }
  ldv_66131: ;
  exit_poll_reg: ;
#line 680
  if (timeout_error != 0) {
#line 681
    vha->reset_tmplt.seq_error = vha->reset_tmplt.seq_error + 1;
#line 682
    ql_log(0U, vha, 45200, "%s: Poll Failed: 0x%08x 0x%08x 0x%08x\n", "qla8044_poll_reg",
           value, test_mask, test_result);
  } else {

  }
#line 687
  return (timeout_error);
}
}
#line 700 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_poll_list(struct scsi_qla_host *vha , struct qla8044_reset_entry_hdr *p_hdr ) 
{ 
  long delay ;
  struct qla8044_entry *p_entry ;
  struct qla8044_poll *p_poll ;
  uint32_t i ;
  uint32_t value ;
  int tmp ;

  {
#line 709
  p_poll = (struct qla8044_poll *)p_hdr + 8U;
#line 715
  p_entry = (struct qla8044_entry *)p_poll + 8U;
#line 718
  delay = (long )p_hdr->delay;
#line 720
  if (delay == 0L) {
#line 721
    i = 0U;
#line 721
    goto ldv_66144;
    ldv_66143: 
#line 722
    qla8044_poll_reg(vha, p_entry->arg1, (int )delay, p_poll->test_mask, p_poll->test_value);
#line 721
    i = i + 1U;
#line 721
    p_entry = p_entry + 1;
    ldv_66144: ;
#line 721
    if ((uint32_t )p_hdr->count > i) {
#line 723
      goto ldv_66143;
    } else {

    }

  } else {
#line 725
    i = 0U;
#line 725
    goto ldv_66147;
    ldv_66146: ;
#line 726
    if (delay != 0L) {
#line 727
      tmp = qla8044_poll_reg(vha, p_entry->arg1, (int )delay, p_poll->test_mask, p_poll->test_value);
#line 727
      if (tmp != 0) {
#line 736
        qla8044_rd_reg_indirect(vha, p_entry->arg1, & value);
#line 738
        qla8044_rd_reg_indirect(vha, p_entry->arg2, & value);
      } else {

      }
    } else {

    }
#line 725
    i = i + 1U;
#line 725
    p_entry = p_entry + 1;
    ldv_66147: ;
#line 725
    if ((uint32_t )p_hdr->count > i) {
#line 727
      goto ldv_66146;
    } else {

    }

  }
#line 733
  return;
}
}
#line 756 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_poll_write_list(struct scsi_qla_host *vha , struct qla8044_reset_entry_hdr *p_hdr ) 
{ 
  long delay ;
  struct qla8044_quad_entry *p_entry ;
  struct qla8044_poll *p_poll ;
  uint32_t i ;
  int tmp ;

  {
#line 764
  p_poll = (struct qla8044_poll *)p_hdr + 8U;
#line 767
  p_entry = (struct qla8044_quad_entry *)p_poll + 8U;
#line 770
  delay = (long )p_hdr->delay;
#line 772
  i = 0U;
#line 772
  goto ldv_66159;
  ldv_66158: 
#line 773
  qla8044_wr_reg_indirect(vha, p_entry->dr_addr, p_entry->dr_value);
#line 775
  qla8044_wr_reg_indirect(vha, p_entry->ar_addr, p_entry->ar_value);
#line 777
  if (delay != 0L) {
#line 778
    tmp = qla8044_poll_reg(vha, p_entry->ar_addr, (int )delay, p_poll->test_mask,
                           p_poll->test_value);
#line 778
    if (tmp != 0) {
#line 782
      ql_dbg(524288U, vha, 45201, "%s: Timeout Error: poll list, ", "qla8044_poll_write_list");
#line 785
      ql_dbg(524288U, vha, 45202, "item_num %d, entry_num %d\n", i, vha->reset_tmplt.seq_index);
    } else {

    }
  } else {

  }
#line 772
  i = i + 1U;
#line 772
  p_entry = p_entry + 1;
  ldv_66159: ;
#line 772
  if ((uint32_t )p_hdr->count > i) {
#line 774
    goto ldv_66158;
  } else {

  }

#line 779
  return;
}
}
#line 803 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_read_modify_write(struct scsi_qla_host *vha , struct qla8044_reset_entry_hdr *p_hdr ) 
{ 
  struct qla8044_entry *p_entry ;
  struct qla8044_rmw *p_rmw_hdr ;
  uint32_t i ;

  {
#line 810
  p_rmw_hdr = (struct qla8044_rmw *)p_hdr + 8U;
#line 813
  p_entry = (struct qla8044_entry *)p_rmw_hdr + 16U;
#line 816
  i = 0U;
#line 816
  goto ldv_66169;
  ldv_66168: 
#line 817
  qla8044_rmw_crb_reg(vha, p_entry->arg1, p_entry->arg2, p_rmw_hdr);
#line 819
  if ((unsigned int )p_hdr->delay != 0U) {
#line 820
    __udelay((unsigned long )p_hdr->delay);
  } else {

  }
#line 816
  i = i + 1U;
#line 816
  p_entry = p_entry + 1;
  ldv_66169: ;
#line 816
  if ((uint32_t )p_hdr->count > i) {
#line 818
    goto ldv_66168;
  } else {

  }

#line 823
  return;
}
}
#line 833 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_pause(struct scsi_qla_host *vha , struct qla8044_reset_entry_hdr *p_hdr ) 
{ 
  unsigned long __ms ;
  unsigned long tmp ;

  {
#line 836
  if ((unsigned int )p_hdr->delay != 0U) {
#line 837
    __ms = (unsigned long )p_hdr->delay;
#line 837
    goto ldv_66177;
    ldv_66176: 
#line 837
    __const_udelay(4295000UL);
    ldv_66177: 
#line 837
    tmp = __ms;
#line 837
    __ms = __ms - 1UL;
#line 837
    if (tmp != 0UL) {
#line 839
      goto ldv_66176;
    } else {

    }

  } else {

  }
#line 846
  return;
}
}
#line 848 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_template_end(struct scsi_qla_host *vha , struct qla8044_reset_entry_hdr *p_hdr ) 
{ 


  {
#line 851
  vha->reset_tmplt.template_end = 1U;
#line 853
  if (vha->reset_tmplt.seq_error == 0) {
#line 854
    ql_dbg(524288U, vha, 45203, "%s: Reset sequence completed SUCCESSFULLY.\n", "qla8044_template_end");
  } else {
#line 857
    ql_log(0U, vha, 45204, "%s: Reset sequence completed with some timeout errors.\n",
           "qla8044_template_end");
  }
#line 860
  return;
}
}
#line 873 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_poll_read_list(struct scsi_qla_host *vha , struct qla8044_reset_entry_hdr *p_hdr ) 
{ 
  long delay ;
  int index ;
  struct qla8044_quad_entry *p_entry ;
  struct qla8044_poll *p_poll ;
  uint32_t i ;
  uint32_t value ;
  int tmp ;
  int tmp___0 ;

  {
#line 883
  p_poll = (struct qla8044_poll *)p_hdr + 8U;
#line 886
  p_entry = (struct qla8044_quad_entry *)p_poll + 8U;
#line 889
  delay = (long )p_hdr->delay;
#line 891
  i = 0U;
#line 891
  goto ldv_66196;
  ldv_66195: 
#line 892
  qla8044_wr_reg_indirect(vha, p_entry->ar_addr, p_entry->ar_value);
#line 894
  if (delay != 0L) {
#line 895
    tmp___0 = qla8044_poll_reg(vha, p_entry->ar_addr, (int )delay, p_poll->test_mask,
                               p_poll->test_value);
#line 895
    if (tmp___0 != 0) {
#line 897
      ql_dbg(524288U, vha, 45205, "%s: Timeout Error: poll list, ", "qla8044_poll_read_list");
#line 900
      ql_dbg(524288U, vha, 45206, "Item_num %d, entry_num %d\n", i, vha->reset_tmplt.seq_index);
    } else {
#line 905
      index = vha->reset_tmplt.array_index;
#line 906
      qla8044_rd_reg_indirect(vha, p_entry->dr_addr, & value);
#line 908
      tmp = index;
#line 908
      index = index + 1;
#line 908
      vha->reset_tmplt.array[tmp] = value;
#line 909
      if (index == 16) {
#line 910
        vha->reset_tmplt.array_index = 1;
      } else {

      }
    }
  } else {

  }
#line 891
  i = i + 1U;
#line 891
  p_entry = p_entry + 1;
  ldv_66196: ;
#line 891
  if ((uint32_t )p_hdr->count > i) {
#line 893
    goto ldv_66195;
  } else {

  }

#line 898
  return;
}
}
#line 928 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_process_reset_template(struct scsi_qla_host *vha , char *p_buff ) 
{ 
  int index ;
  int entries ;
  struct qla8044_reset_entry_hdr *p_hdr ;
  char *p_entry ;

  {
#line 933
  p_entry = p_buff;
#line 935
  vha->reset_tmplt.seq_end = 0U;
#line 936
  vha->reset_tmplt.template_end = 0U;
#line 937
  entries = (int )(vha->reset_tmplt.hdr)->entries;
#line 938
  index = vha->reset_tmplt.seq_index;
#line 940
  goto ldv_66220;
  ldv_66219: 
#line 941
  p_hdr = (struct qla8044_reset_entry_hdr *)p_entry;
#line 942
  switch ((int )p_hdr->cmd) {
  case 0: ;
#line 944
  goto ldv_66207;
  case 1: 
#line 946
  qla8044_write_list(vha, p_hdr);
#line 947
  goto ldv_66207;
  case 2: 
#line 949
  qla8044_read_write_list(vha, p_hdr);
#line 950
  goto ldv_66207;
  case 4: 
#line 952
  qla8044_poll_list(vha, p_hdr);
#line 953
  goto ldv_66207;
  case 8: 
#line 955
  qla8044_poll_write_list(vha, p_hdr);
#line 956
  goto ldv_66207;
  case 16: 
#line 958
  qla8044_read_modify_write(vha, p_hdr);
#line 959
  goto ldv_66207;
  case 32: 
#line 961
  qla8044_pause(vha, p_hdr);
#line 962
  goto ldv_66207;
  case 64: 
#line 964
  vha->reset_tmplt.seq_end = 1U;
#line 965
  goto ldv_66207;
  case 128: 
#line 967
  qla8044_template_end(vha, p_hdr);
#line 968
  goto ldv_66207;
  case 256: 
#line 970
  qla8044_poll_read_list(vha, p_hdr);
#line 971
  goto ldv_66207;
  default: 
#line 973
  ql_log(0U, vha, 45207, "%s: Unknown command ==> 0x%04x on entry = %d\n", "qla8044_process_reset_template",
         (int )p_hdr->cmd, index);
#line 976
  goto ldv_66207;
  }
  ldv_66207: 
#line 981
  p_entry = p_entry + (unsigned long )p_hdr->size;
#line 940
  index = index + 1;
  ldv_66220: ;
#line 940
  if ((unsigned int )vha->reset_tmplt.seq_end == 0U && index < entries) {
#line 942
    goto ldv_66219;
  } else {

  }
#line 983
  vha->reset_tmplt.seq_index = index;
#line 984
  return;
}
}
#line 987 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_process_init_seq(struct scsi_qla_host *vha ) 
{ 


  {
#line 989
  qla8044_process_reset_template(vha, (char *)vha->reset_tmplt.init_offset);
#line 991
  if ((unsigned int )vha->reset_tmplt.seq_end != 1U) {
#line 992
    ql_log(0U, vha, 45208, "%s: Abrupt INIT Sub-Sequence end.\n", "qla8044_process_init_seq");
  } else {

  }
#line 995
  return;
}
}
#line 998 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_process_stop_seq(struct scsi_qla_host *vha ) 
{ 


  {
#line 1000
  vha->reset_tmplt.seq_index = 0;
#line 1001
  qla8044_process_reset_template(vha, (char *)vha->reset_tmplt.stop_offset);
#line 1002
  if ((unsigned int )vha->reset_tmplt.seq_end != 1U) {
#line 1003
    ql_log(0U, vha, 45209, "%s: Abrupt STOP Sub-Sequence end.\n", "qla8044_process_stop_seq");
  } else {

  }
#line 1005
  return;
}
}
#line 1008 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_process_start_seq(struct scsi_qla_host *vha ) 
{ 


  {
#line 1010
  qla8044_process_reset_template(vha, (char *)vha->reset_tmplt.start_offset);
#line 1011
  if ((unsigned int )vha->reset_tmplt.template_end != 1U) {
#line 1012
    ql_log(0U, vha, 45210, "%s: Abrupt START Sub-Sequence end.\n", "qla8044_process_start_seq");
  } else {

  }
#line 1015
  return;
}
}
#line 1018 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_lockless_flash_read_u32(struct scsi_qla_host *vha , uint32_t flash_addr ,
                                           uint8_t *p_data , int u32_word_count ) 
{ 
  uint32_t i ;
  uint32_t u32_word ;
  uint32_t flash_offset ;
  uint32_t addr ;
  int ret_val ;

  {
#line 1024
  addr = flash_addr;
#line 1025
  ret_val = 0;
#line 1027
  flash_offset = addr & 65535U;
#line 1029
  if ((addr & 3U) != 0U) {
#line 1030
    ql_log(0U, vha, 45211, "%s: Illegal addr = 0x%x\n", "qla8044_lockless_flash_read_u32",
           addr);
#line 1032
    ret_val = 258;
#line 1033
    goto exit_lockless_read;
  } else {

  }
#line 1036
  ret_val = qla8044_wr_reg_indirect(vha, 1108410416U, addr);
#line 1039
  if (ret_val != 0) {
#line 1040
    ql_log(0U, vha, 45212, "%s: failed to write addr 0x%x to FLASH_DIRECT_WINDOW!\n",
           "qla8044_lockless_flash_read_u32", addr);
#line 1043
    goto exit_lockless_read;
  } else {

  }
#line 1047
  if ((unsigned long )flash_offset + (unsigned long )u32_word_count * 4UL > 65535UL) {
#line 1050
    i = 0U;
#line 1050
    goto ldv_66248;
    ldv_66247: 
#line 1051
    ret_val = qla8044_rd_reg_indirect(vha, (addr & 65535U) | 1108672512U, & u32_word);
#line 1053
    if (ret_val != 0) {
#line 1054
      ql_log(0U, vha, 45213, "%s: failed to read addr 0x%x!\n", "qla8044_lockless_flash_read_u32",
             addr);
#line 1057
      goto exit_lockless_read;
    } else {

    }
#line 1059
    *((uint32_t *)p_data) = u32_word;
#line 1060
    p_data = p_data + 4UL;
#line 1061
    addr = addr + 4U;
#line 1062
    flash_offset = flash_offset + 4U;
#line 1063
    if (flash_offset > 65535U) {
#line 1065
      ret_val = qla8044_wr_reg_indirect(vha, 1108410416U, addr);
#line 1067
      if (ret_val != 0) {
#line 1068
        ql_log(0U, vha, 45215, "%s: failed to write addr 0x%x to FLASH_DIRECT_WINDOW!\n",
               "qla8044_lockless_flash_read_u32", addr);
#line 1072
        goto exit_lockless_read;
      } else {

      }
#line 1074
      flash_offset = 0U;
    } else {

    }
#line 1050
    i = i + 1U;
    ldv_66248: ;
#line 1050
    if ((uint32_t )u32_word_count > i) {
#line 1052
      goto ldv_66247;
    } else {

    }

  } else {
#line 1079
    i = 0U;
#line 1079
    goto ldv_66251;
    ldv_66250: 
#line 1080
    ret_val = qla8044_rd_reg_indirect(vha, (addr & 65535U) | 1108672512U, & u32_word);
#line 1082
    if (ret_val != 0) {
#line 1083
      ql_log(0U, vha, 45216, "%s: failed to read addr 0x%x!\n", "qla8044_lockless_flash_read_u32",
             addr);
#line 1086
      goto exit_lockless_read;
    } else {

    }
#line 1088
    *((uint32_t *)p_data) = u32_word;
#line 1089
    p_data = p_data + 4UL;
#line 1090
    addr = addr + 4U;
#line 1079
    i = i + 1U;
    ldv_66251: ;
#line 1079
    if ((uint32_t )u32_word_count > i) {
#line 1081
      goto ldv_66250;
    } else {

    }

  }
  exit_lockless_read: ;
#line 1095
  return (ret_val);
}
}
#line 1109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_ms_mem_write_128b(struct scsi_qla_host *vha , uint64_t addr , uint32_t *data ,
                                     uint32_t count ) 
{ 
  int i ;
  int j ;
  int ret_val ;
  uint32_t agt_ctrl ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  uint32_t *tmp ;
  int tmp___0 ;
  uint32_t *tmp___1 ;
  int tmp___2 ;
  uint32_t *tmp___3 ;
  int tmp___4 ;
  uint32_t *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1112
  ret_val = 0;
#line 1115
  ha = vha->hw;
#line 1118
  if ((addr & 15ULL) != 0ULL) {
#line 1119
    ret_val = 258;
#line 1120
    goto exit_ms_mem_write;
  } else {

  }
#line 1122
  flags = _raw_write_lock_irqsave(& ha->hw_lock);
#line 1125
  ret_val = qla8044_wr_reg_indirect(vha, 1090519192U, 0U);
#line 1126
  if (ret_val == 258) {
#line 1127
    ql_log(0U, vha, 45217, "%s: write to AGT_ADDR_HI failed!\n", "qla8044_ms_mem_write_128b");
#line 1129
    goto exit_ms_mem_write_unlock;
  } else {

  }
#line 1132
  i = 0;
#line 1132
  goto ldv_66275;
  ldv_66274: ;
#line 1133
  if ((addr > 13019119615ULL || addr <= 12884901887ULL) && addr > 268435455ULL) {
#line 1137
    ret_val = 258;
#line 1138
    goto exit_ms_mem_write_unlock;
  } else {

  }
#line 1141
  ret_val = qla8044_wr_reg_indirect(vha, 1090519188U, (uint32_t )addr);
#line 1145
  tmp = data;
#line 1145
  data = data + 1;
#line 1145
  tmp___0 = qla8044_wr_reg_indirect(vha, 1090519200U, *tmp);
#line 1145
  ret_val = tmp___0 + ret_val;
#line 1147
  tmp___1 = data;
#line 1147
  data = data + 1;
#line 1147
  tmp___2 = qla8044_wr_reg_indirect(vha, 1090519204U, *tmp___1);
#line 1147
  ret_val = tmp___2 + ret_val;
#line 1149
  tmp___3 = data;
#line 1149
  data = data + 1;
#line 1149
  tmp___4 = qla8044_wr_reg_indirect(vha, 1090519216U, *tmp___3);
#line 1149
  ret_val = tmp___4 + ret_val;
#line 1151
  tmp___5 = data;
#line 1151
  data = data + 1;
#line 1151
  tmp___6 = qla8044_wr_reg_indirect(vha, 1090519220U, *tmp___5);
#line 1151
  ret_val = tmp___6 + ret_val;
#line 1153
  if (ret_val == 258) {
#line 1154
    ql_log(0U, vha, 45218, "%s: write to AGT_WRDATA failed!\n", "qla8044_ms_mem_write_128b");
#line 1157
    goto exit_ms_mem_write_unlock;
  } else {

  }
#line 1161
  ret_val = qla8044_wr_reg_indirect(vha, 1090519184U, 6U);
#line 1163
  tmp___7 = qla8044_wr_reg_indirect(vha, 1090519184U, 7U);
#line 1163
  ret_val = tmp___7 + ret_val;
#line 1165
  if (ret_val == 258) {
#line 1166
    ql_log(0U, vha, 45219, "%s: write to AGT_CTRL failed!\n", "qla8044_ms_mem_write_128b");
#line 1168
    goto exit_ms_mem_write_unlock;
  } else {

  }
#line 1171
  j = 0;
#line 1171
  goto ldv_66273;
  ldv_66272: 
#line 1172
  ret_val = qla8044_rd_reg_indirect(vha, 1090519184U, & agt_ctrl);
#line 1174
  if (ret_val == 258) {
#line 1175
    ql_log(0U, vha, 45220, "%s: failed to read MD_MIU_TEST_AGT_CTRL!\n", "qla8044_ms_mem_write_128b");
#line 1178
    goto exit_ms_mem_write_unlock;
  } else {

  }
#line 1180
  if ((agt_ctrl & 8U) == 0U) {
#line 1181
    goto ldv_66271;
  } else {

  }
#line 1171
  j = j + 1;
  ldv_66273: ;
#line 1171
  if (j <= 999) {
#line 1173
    goto ldv_66272;
  } else {

  }
  ldv_66271: ;
#line 1185
  if (j > 999) {
#line 1186
    ql_log(0U, vha, 45221, "%s: MS memory write failed!\n", "qla8044_ms_mem_write_128b");
#line 1189
    ret_val = 258;
#line 1190
    goto exit_ms_mem_write_unlock;
  } else {

  }
#line 1132
  i = i + 1;
#line 1132
  addr = addr + 16ULL;
  ldv_66275: ;
#line 1132
  if ((uint32_t )i < count) {
#line 1134
    goto ldv_66274;
  } else {

  }

  exit_ms_mem_write_unlock: 
#line 1195
  _raw_write_unlock_irqrestore(& ha->hw_lock, flags);
  exit_ms_mem_write: ;
#line 1198
  return (ret_val);
}
}
#line 1202 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_copy_bootloader(struct scsi_qla_host *vha ) 
{ 
  uint8_t *p_cache ;
  uint32_t src ;
  uint32_t count ;
  uint32_t size ;
  uint64_t dest ;
  int ret_val ;
  struct qla_hw_data *ha ;
  uint32_t tmp ;
  void *tmp___0 ;

  {
#line 1207
  ret_val = 0;
#line 1208
  ha = vha->hw;
#line 1210
  src = 65536U;
#line 1211
  tmp = qla8044_rd_reg(ha, 13660UL);
#line 1211
  dest = (uint64_t )tmp;
#line 1212
  size = qla8044_rd_reg(ha, 13664UL);
#line 1215
  if ((size & 15U) != 0U) {
#line 1216
    size = (size + 16U) & 4294967280U;
  } else {

  }
#line 1219
  count = size / 16U;
#line 1221
  tmp___0 = vmalloc((unsigned long )size);
#line 1221
  p_cache = (uint8_t *)tmp___0;
#line 1222
  if ((unsigned long )p_cache == (unsigned long )((uint8_t *)0U)) {
#line 1223
    ql_log(0U, vha, 45222, "%s: Failed to allocate memory for boot loader cache\n",
           "qla8044_copy_bootloader");
#line 1226
    ret_val = 258;
#line 1227
    goto exit_copy_bootloader;
  } else {

  }
#line 1230
  ret_val = qla8044_lockless_flash_read_u32(vha, src, p_cache, (int )(size / 4U));
#line 1232
  if (ret_val == 258) {
#line 1233
    ql_log(0U, vha, 45223, "%s: Error reading F/W from flash!!!\n", "qla8044_copy_bootloader");
#line 1235
    goto exit_copy_error;
  } else {

  }
#line 1237
  ql_dbg(524288U, vha, 45224, "%s: Read F/W from flash!\n", "qla8044_copy_bootloader");
#line 1241
  ret_val = qla8044_ms_mem_write_128b(vha, dest, (uint32_t *)p_cache, count);
#line 1243
  if (ret_val == 258) {
#line 1244
    ql_log(0U, vha, 45225, "%s: Error writing F/W to MS !!!\n", "qla8044_copy_bootloader");
#line 1246
    goto exit_copy_error;
  } else {

  }
#line 1248
  ql_dbg(524288U, vha, 45226, "%s: Wrote F/W (size %d) to MS !!!\n", "qla8044_copy_bootloader",
         size);
  exit_copy_error: 
#line 1253
  vfree((void const   *)p_cache);
  exit_copy_bootloader: ;
#line 1256
  return (ret_val);
}
}
#line 1260 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_restart(struct scsi_qla_host *vha ) 
{ 
  int ret_val ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 1262
  ret_val = 0;
#line 1263
  ha = vha->hw;
#line 1265
  qla8044_process_stop_seq(vha);
#line 1268
  if (ql2xmdenable != 0) {
#line 1269
    qla8044_get_minidump(vha);
  } else {
#line 1271
    ql_log(0U, vha, 45388, "Minidump disabled.\n");
  }
#line 1274
  qla8044_process_init_seq(vha);
#line 1276
  tmp = qla8044_copy_bootloader(vha);
#line 1276
  if (tmp != 0) {
#line 1277
    ql_log(0U, vha, 45227, "%s: Copy bootloader, firmware restart failed!\n", "qla8044_restart");
#line 1280
    ret_val = 258;
#line 1281
    goto exit_restart;
  } else {

  }
#line 1287
  qla8044_wr_reg(ha, 13820UL, 0U);
#line 1289
  qla8044_process_start_seq(vha);
  exit_restart: ;
#line 1292
  return (ret_val);
}
}
#line 1304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_check_cmd_peg_status(struct scsi_qla_host *vha ) 
{ 
  uint32_t val ;
  uint32_t ret_val ;
  int retries ;
  struct qla_hw_data *ha ;

  {
#line 1306
  ret_val = 258U;
#line 1307
  retries = 60;
#line 1308
  ha = vha->hw;
  ldv_66309: 
#line 1311
  val = qla8044_rd_reg(ha, 13904UL);
#line 1312
  if (val == 65281U) {
#line 1313
    ql_dbg(524288U, vha, 45228, "%s: Command Peg initialization complete! state=0x%x\n",
           "qla8044_check_cmd_peg_status", val);
#line 1316
    ret_val = 0U;
#line 1317
    goto ldv_66308;
  } else {

  }
#line 1319
  msleep(500U);
#line 1320
  retries = retries - 1;
#line 1320
  if (retries != 0) {
#line 1322
    goto ldv_66309;
  } else {

  }
  ldv_66308: ;
#line 1322
  return ((int )ret_val);
}
}
#line 1326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_start_firmware(struct scsi_qla_host *vha ) 
{ 
  int ret_val ;
  int tmp ;

  {
#line 1328
  ret_val = 0;
#line 1330
  tmp = qla8044_restart(vha);
#line 1330
  if (tmp != 0) {
#line 1331
    ql_log(0U, vha, 45229, "%s: Restart Error!!!, Need Reset!!!\n", "qla8044_start_firmware");
#line 1334
    ret_val = 258;
#line 1335
    goto exit_start_fw;
  } else {
#line 1337
    ql_dbg(524288U, vha, 45231, "%s: Restart done!\n", "qla8044_start_firmware");
  }
#line 1340
  ret_val = qla8044_check_cmd_peg_status(vha);
#line 1341
  if (ret_val != 0) {
#line 1342
    ql_log(0U, vha, 45232, "%s: Peg not initialized!\n", "qla8044_start_firmware");
#line 1344
    ret_val = 258;
  } else {

  }
  exit_start_fw: ;
#line 1348
  return (ret_val);
}
}
#line 1352 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
void qla8044_clear_drv_active(struct qla_hw_data *ha ) 
{ 
  uint32_t drv_active ;
  struct scsi_qla_host *vha ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1355
  tmp = pci_get_drvdata(ha->pdev);
#line 1355
  vha = (struct scsi_qla_host *)tmp;
#line 1357
  tmp___0 = qla8044_rd_direct(vha, 3U);
#line 1357
  drv_active = (uint32_t )tmp___0;
#line 1358
  drv_active = (uint32_t )(~ (1 << (int )ha->portnum)) & drv_active;
#line 1360
  ql_log(2U, vha, 45233, "%s(%ld): drv_active: 0x%08x\n", "qla8044_clear_drv_active",
         vha->host_no, drv_active);
#line 1364
  qla8044_wr_direct(vha, 3U, drv_active);
#line 1365
  return;
}
}
#line 1374 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_device_bootstrap(struct scsi_qla_host *vha ) 
{ 
  int rval ;
  int i ;
  uint32_t old_count ;
  uint32_t count ;
  int need_reset ;
  uint32_t idc_ctrl ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;

  {
#line 1376
  rval = 258;
#line 1378
  old_count = 0U;
#line 1378
  count = 0U;
#line 1379
  need_reset = 0;
#line 1381
  ha = vha->hw;
#line 1383
  need_reset = qla8044_need_reset(vha);
#line 1385
  if (need_reset == 0) {
#line 1386
    tmp = qla8044_rd_direct(vha, 2U);
#line 1386
    old_count = (uint32_t )tmp;
#line 1389
    i = 0;
#line 1389
    goto ldv_66334;
    ldv_66333: 
#line 1390
    msleep(200U);
#line 1392
    tmp___0 = qla8044_rd_direct(vha, 2U);
#line 1392
    count = (uint32_t )tmp___0;
#line 1394
    if (count != old_count) {
#line 1395
      rval = 0;
#line 1396
      goto dev_ready;
    } else {

    }
#line 1389
    i = i + 1;
    ldv_66334: ;
#line 1389
    if (i <= 9) {
#line 1391
      goto ldv_66333;
    } else {

    }
#line 1399
    qla8044_flash_lock_recovery(vha);
  } else
#line 1402
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1403
    qla8044_flash_lock_recovery(vha);
  } else {

  }
#line 1407
  ql_log(2U, vha, 45234, "%s: HW State: INITIALIZING\n", "qla8044_device_bootstrap");
#line 1409
  qla8044_wr_direct(vha, 4U, 2U);
#line 1412
  qla8044_idc_unlock(ha);
#line 1413
  rval = qla8044_start_firmware(vha);
#line 1414
  qla8044_idc_lock(ha);
#line 1416
  if (rval != 0) {
#line 1417
    ql_log(2U, vha, 45235, "%s: HW State: FAILED\n", "qla8044_device_bootstrap");
#line 1419
    qla8044_clear_drv_active(ha);
#line 1420
    qla8044_wr_direct(vha, 4U, 6U);
#line 1422
    return (rval);
  } else {

  }
#line 1427
  idc_ctrl = qla8044_rd_reg(ha, 14224UL);
#line 1428
  if ((idc_ctrl & 2U) != 0U) {
#line 1429
    qla8044_wr_reg(ha, 14224UL, idc_ctrl & 4294967293U);
#line 1431
    ha->fw_dumped = 0;
  } else {

  }
  dev_ready: 
#line 1435
  ql_log(2U, vha, 45236, "%s: HW State: READY\n", "qla8044_device_bootstrap");
#line 1437
  qla8044_wr_direct(vha, 4U, 3U);
#line 1439
  return (rval);
}
}
#line 1444 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_dump_reset_seq_hdr(struct scsi_qla_host *vha ) 
{ 
  u8 *phdr ;

  {
#line 1448
  if ((unsigned long )vha->reset_tmplt.buff == (unsigned long )((uint8_t *)0U)) {
#line 1449
    ql_log(0U, vha, 45237, "%s: Error Invalid reset_seq_template\n", "qla8044_dump_reset_seq_hdr");
#line 1451
    return;
  } else {

  }
#line 1454
  phdr = vha->reset_tmplt.buff;
#line 1455
  ql_dbg(524288U, vha, 45238, "Reset Template :\n\t0x%X 0x%X 0x%X 0x%X0x%X 0x%X 0x%X 0x%X 0x%X 0x%X\n\t0x%X 0x%X 0x%X 0x%X 0x%X 0x%X\n\n",
         (int )*phdr, (int )*(phdr + 1UL), (int )*(phdr + 2UL), (int )*(phdr + 3UL),
         (int )*(phdr + 4UL), (int )*(phdr + 5UL), (int )*(phdr + 6UL), (int )*(phdr + 7UL),
         (int )*(phdr + 8UL), (int )*(phdr + 9UL), (int )*(phdr + 10UL), (int )*(phdr + 11UL),
         (int )*(phdr + 12UL), (int )*(phdr + 13UL), (int )*(phdr + 14UL), (int )*(phdr + 15UL));
#line 1463
  return;
}
}
#line 1473 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_reset_seq_checksum_test(struct scsi_qla_host *vha ) 
{ 
  uint32_t sum ;
  uint16_t *buff ;
  int u16_count ;
  uint16_t *tmp ;
  int tmp___0 ;

  {
#line 1475
  sum = 0U;
#line 1476
  buff = (uint16_t *)vha->reset_tmplt.buff;
#line 1477
  u16_count = (int )((unsigned int )(vha->reset_tmplt.hdr)->size / 2U);
#line 1479
  goto ldv_66349;
  ldv_66348: 
#line 1480
  tmp = buff;
#line 1480
  buff = buff + 1;
#line 1480
  sum = (uint32_t )*tmp + sum;
  ldv_66349: 
#line 1479
  tmp___0 = u16_count;
#line 1479
  u16_count = u16_count - 1;
#line 1479
  if (tmp___0 > 0) {
#line 1481
    goto ldv_66348;
  } else {

  }

#line 1482
  goto ldv_66352;
  ldv_66351: 
#line 1483
  sum = (sum & 65535U) + (sum >> 16);
  ldv_66352: ;
#line 1482
  if (sum >> 16 != 0U) {
#line 1484
    goto ldv_66351;
  } else {

  }

#line 1486
  if (sum != 4294967295U) {
#line 1487
    return (0);
  } else {
#line 1489
    ql_log(0U, vha, 45239, "%s: Reset seq checksum failed\n", "qla8044_reset_seq_checksum_test");
#line 1491
    return (258);
  }
}
}
#line 1502 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
void qla8044_read_reset_template(struct scsi_qla_host *vha ) 
{ 
  uint8_t *p_buff ;
  uint32_t addr ;
  uint32_t tmplt_hdr_def_size ;
  uint32_t tmplt_hdr_size ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1507
  vha->reset_tmplt.seq_error = 0;
#line 1508
  tmp = vmalloc(8192UL);
#line 1508
  vha->reset_tmplt.buff = (uint8_t *)tmp;
#line 1509
  if ((unsigned long )vha->reset_tmplt.buff == (unsigned long )((uint8_t *)0U)) {
#line 1510
    ql_log(0U, vha, 45240, "%s: Failed to allocate reset template resources\n", "qla8044_read_reset_template");
#line 1513
    goto exit_read_reset_template;
  } else {

  }
#line 1516
  p_buff = vha->reset_tmplt.buff;
#line 1517
  addr = 5177344U;
#line 1519
  tmplt_hdr_def_size = 4U;
#line 1522
  ql_dbg(524288U, vha, 45241, "%s: Read template hdr size %d from Flash\n", "qla8044_read_reset_template",
         tmplt_hdr_def_size);
#line 1527
  tmp___0 = qla8044_read_flash_data(vha, p_buff, addr, (int )tmplt_hdr_def_size);
#line 1527
  if (tmp___0 != 0) {
#line 1528
    ql_log(0U, vha, 45242, "%s: Failed to read reset template\n", "qla8044_read_reset_template");
#line 1530
    goto exit_read_template_error;
  } else {

  }
#line 1533
  vha->reset_tmplt.hdr = (struct qla8044_reset_template_hdr *)vha->reset_tmplt.buff;
#line 1537
  tmplt_hdr_size = (unsigned int )(vha->reset_tmplt.hdr)->hdr_size / 4U;
#line 1538
  if (tmplt_hdr_size != tmplt_hdr_def_size || (unsigned int )(vha->reset_tmplt.hdr)->signature != 51966U) {
#line 1540
    ql_log(0U, vha, 45243, "%s: Template Header size invalid %d tmplt_hdr_def_size %d!!!\n",
           "qla8044_read_reset_template", tmplt_hdr_size, tmplt_hdr_def_size);
#line 1544
    goto exit_read_template_error;
  } else {

  }
#line 1547
  addr = (uint32_t )((int )(vha->reset_tmplt.hdr)->hdr_size + 5177344);
#line 1548
  p_buff = vha->reset_tmplt.buff + (unsigned long )(vha->reset_tmplt.hdr)->hdr_size;
#line 1549
  tmplt_hdr_def_size = (uint32_t )((unsigned long )((int )(vha->reset_tmplt.hdr)->size - (int )(vha->reset_tmplt.hdr)->hdr_size) / 4UL);
#line 1552
  ql_dbg(524288U, vha, 45244, "%s: Read rest of the template size %d\n", "qla8044_read_reset_template",
         (int )(vha->reset_tmplt.hdr)->size);
#line 1557
  tmp___1 = qla8044_read_flash_data(vha, p_buff, addr, (int )tmplt_hdr_def_size);
#line 1557
  if (tmp___1 != 0) {
#line 1558
    ql_log(0U, vha, 45245, "%s: Failed to read reset tempelate\n", "qla8044_read_reset_template");
#line 1560
    goto exit_read_template_error;
  } else {

  }
#line 1564
  tmp___2 = qla8044_reset_seq_checksum_test(vha);
#line 1564
  if (tmp___2 != 0) {
#line 1565
    ql_log(0U, vha, 45246, "%s: Reset Seq checksum failed!\n", "qla8044_read_reset_template");
#line 1567
    goto exit_read_template_error;
  } else {

  }
#line 1570
  ql_dbg(524288U, vha, 45247, "%s: Reset Seq checksum passed! Get stop, start and init seq offsets\n",
         "qla8044_read_reset_template");
#line 1575
  vha->reset_tmplt.init_offset = vha->reset_tmplt.buff + (unsigned long )(vha->reset_tmplt.hdr)->init_seq_offset;
#line 1578
  vha->reset_tmplt.start_offset = vha->reset_tmplt.buff + (unsigned long )(vha->reset_tmplt.hdr)->start_seq_offset;
#line 1581
  vha->reset_tmplt.stop_offset = vha->reset_tmplt.buff + (unsigned long )(vha->reset_tmplt.hdr)->hdr_size;
#line 1584
  qla8044_dump_reset_seq_hdr(vha);
#line 1586
  goto exit_read_reset_template;
  exit_read_template_error: 
#line 1589
  vfree((void const   *)vha->reset_tmplt.buff);
  exit_read_reset_template: ;
#line 1592
  return;
}
}
#line 1596 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
void qla8044_set_idc_dontreset(struct scsi_qla_host *vha ) 
{ 
  uint32_t idc_ctrl ;
  struct qla_hw_data *ha ;

  {
#line 1599
  ha = vha->hw;
#line 1601
  idc_ctrl = qla8044_rd_reg(ha, 14224UL);
#line 1602
  idc_ctrl = idc_ctrl | 1U;
#line 1603
  ql_dbg(524288U, vha, 45248, "%s: idc_ctrl = %d\n", "qla8044_set_idc_dontreset",
         idc_ctrl);
#line 1605
  qla8044_wr_reg(ha, 14224UL, idc_ctrl);
#line 1606
  return;
}
}
#line 1609 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
__inline void qla8044_set_rst_ready(struct scsi_qla_host *vha ) 
{ 
  uint32_t drv_state ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 1612
  ha = vha->hw;
#line 1614
  tmp = qla8044_rd_direct(vha, 5U);
#line 1614
  drv_state = (uint32_t )tmp;
#line 1618
  drv_state = (uint32_t )(1 << (int )ha->portnum) | drv_state;
#line 1620
  ql_log(2U, vha, 45249, "%s(%ld): drv_state: 0x%08x\n", "qla8044_set_rst_ready",
         vha->host_no, drv_state);
#line 1623
  qla8044_wr_direct(vha, 5U, drv_state);
#line 1624
  return;
}
}
#line 1633 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_need_reset_handler(struct scsi_qla_host *vha ) 
{ 
  uint32_t dev_state ;
  uint32_t drv_state ;
  uint32_t drv_active ;
  unsigned long reset_timeout ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1635
  dev_state = 0U;
#line 1637
  ha = vha->hw;
#line 1639
  ql_log(0U, vha, 45250, "%s: Performing ISP error recovery\n", "qla8044_need_reset_handler");
#line 1642
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 1643
    qla8044_idc_unlock(ha);
#line 1644
    qla2x00_abort_isp_cleanup(vha);
#line 1645
    (*((ha->isp_ops)->get_flash_version))(vha, (void *)(vha->req)->ring);
#line 1646
    (*((ha->isp_ops)->nvram_config))(vha);
#line 1647
    qla8044_idc_lock(ha);
  } else {

  }
#line 1650
  tmp = qla8044_rd_direct(vha, 4U);
#line 1650
  dev_state = (uint32_t )tmp;
#line 1652
  tmp___0 = qla8044_rd_direct(vha, 5U);
#line 1652
  drv_state = (uint32_t )tmp___0;
#line 1654
  tmp___1 = qla8044_rd_direct(vha, 3U);
#line 1654
  drv_active = (uint32_t )tmp___1;
#line 1657
  ql_log(2U, vha, 45253, "%s(%ld): drv_state = 0x%x, drv_active = 0x%x dev_state = 0x%x\n",
         "qla8044_need_reset_handler", vha->host_no, drv_state, drv_active, dev_state);
#line 1661
  qla8044_set_rst_ready(vha);
#line 1664
  reset_timeout = (unsigned long )(ha->fcoe_reset_timeout * 250U) + (unsigned long )jiffies;
  ldv_66393: ;
#line 1667
  if ((long )((unsigned long )jiffies - reset_timeout) >= 0L) {
#line 1668
    ql_log(2U, vha, 45252, "%s: Function %d: Reset Ack Timeout!, drv_state: 0x%08x, drv_active: 0x%08x\n",
           "qla8044_need_reset_handler", (int )ha->portnum, drv_state, drv_active);
#line 1671
    goto ldv_66392;
  } else {

  }
#line 1674
  qla8044_idc_unlock(ha);
#line 1675
  msleep(1000U);
#line 1676
  qla8044_idc_lock(ha);
#line 1678
  tmp___2 = qla8044_rd_direct(vha, 4U);
#line 1678
  dev_state = (uint32_t )tmp___2;
#line 1680
  tmp___3 = qla8044_rd_direct(vha, 5U);
#line 1680
  drv_state = (uint32_t )tmp___3;
#line 1682
  tmp___4 = qla8044_rd_direct(vha, 3U);
#line 1682
  drv_active = (uint32_t )tmp___4;
#line 1685
  if ((drv_state & drv_active) != drv_active && dev_state == 4U) {
#line 1687
    goto ldv_66393;
  } else {

  }
  ldv_66392: ;
#line 1688
  if (drv_state != drv_active) {
#line 1689
    ql_log(2U, vha, 45255, "%s(%ld): Function %d turning off drv_active of non-acking function 0x%x\n",
           "qla8044_need_reset_handler", vha->host_no, (int )ha->portnum, drv_active ^ drv_state);
#line 1693
    drv_active = drv_active & drv_state;
#line 1694
    qla8044_wr_direct(vha, 3U, drv_active);
  } else
#line 1701
  if (*((unsigned long *)ha + 2UL) != 0UL && dev_state == 4U) {
#line 1703
    ha->flags.nic_core_reset_owner = 0U;
#line 1704
    qla8044_device_bootstrap(vha);
#line 1705
    return;
  } else {

  }
#line 1710
  if (((uint32_t )(1 << (int )ha->portnum) & drv_active) == 0U) {
#line 1711
    ha->flags.nic_core_reset_owner = 0U;
#line 1712
    return;
  } else {

  }
#line 1719
  if (*((unsigned long *)ha + 2UL) != 0UL || (drv_state & drv_active) == 128U) {
#line 1721
    ha->flags.nic_core_reset_owner = 0U;
#line 1722
    qla8044_device_bootstrap(vha);
  } else {

  }
#line 1724
  return;
}
}
#line 1727 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_set_drv_active(struct scsi_qla_host *vha ) 
{ 
  uint32_t drv_active ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 1730
  ha = vha->hw;
#line 1732
  tmp = qla8044_rd_direct(vha, 3U);
#line 1732
  drv_active = (uint32_t )tmp;
#line 1736
  drv_active = (uint32_t )(1 << (int )ha->portnum) | drv_active;
#line 1738
  ql_log(2U, vha, 45256, "%s(%ld): drv_active: 0x%08x\n", "qla8044_set_drv_active",
         vha->host_no, drv_active);
#line 1741
  qla8044_wr_direct(vha, 3U, drv_active);
#line 1742
  return;
}
}
#line 1745 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_check_drv_active(struct scsi_qla_host *vha ) 
{ 
  uint32_t drv_active ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 1748
  ha = vha->hw;
#line 1750
  tmp = qla8044_rd_direct(vha, 3U);
#line 1750
  drv_active = (uint32_t )tmp;
#line 1751
  if (((uint32_t )(1 << (int )ha->portnum) & drv_active) != 0U) {
#line 1752
    return (0);
  } else {
#line 1754
    return (3);
  }
}
}
#line 1758 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_clear_idc_dontreset(struct scsi_qla_host *vha ) 
{ 
  uint32_t idc_ctrl ;
  struct qla_hw_data *ha ;

  {
#line 1761
  ha = vha->hw;
#line 1763
  idc_ctrl = qla8044_rd_reg(ha, 14224UL);
#line 1764
  idc_ctrl = idc_ctrl & 4294967294U;
#line 1765
  ql_log(2U, vha, 45257, "%s: idc_ctrl = %d\n", "qla8044_clear_idc_dontreset", idc_ctrl);
#line 1768
  qla8044_wr_reg(ha, 14224UL, idc_ctrl);
#line 1769
  return;
}
}
#line 1772 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_set_idc_ver(struct scsi_qla_host *vha ) 
{ 
  int idc_ver ;
  uint32_t drv_active ;
  int rval ;
  struct qla_hw_data *ha ;
  int tmp ;
  uint32_t tmp___0 ;

  {
#line 1776
  rval = 0;
#line 1777
  ha = vha->hw;
#line 1779
  tmp = qla8044_rd_direct(vha, 3U);
#line 1779
  drv_active = (uint32_t )tmp;
#line 1780
  if ((uint32_t )(1 << (int )ha->portnum) == drv_active) {
#line 1781
    idc_ver = qla8044_rd_direct(vha, 8U);
#line 1783
    idc_ver = idc_ver & -256;
#line 1784
    idc_ver = idc_ver | 1;
#line 1785
    qla8044_wr_direct(vha, 8U, (uint32_t const   )idc_ver);
#line 1787
    ql_log(2U, vha, 45258, "%s: IDC version updated to %d\n", "qla8044_set_idc_ver",
           idc_ver);
  } else {
#line 1791
    idc_ver = qla8044_rd_direct(vha, 8U);
#line 1793
    idc_ver = idc_ver & 255;
#line 1794
    if (idc_ver != 1) {
#line 1795
      ql_log(2U, vha, 45259, "%s: qla4xxx driver IDC version %d is not compatible with IDC version %d of other drivers!\n",
             "qla8044_set_idc_ver", 1, idc_ver);
#line 1801
      rval = 258;
#line 1802
      goto exit_set_idc_ver;
    } else {

    }
  }
#line 1807
  tmp___0 = qla8044_rd_reg(ha, 14232UL);
#line 1807
  idc_ver = (int )tmp___0;
#line 1808
  idc_ver = ~ (3 << (int )ha->portnum * 2) & idc_ver;
#line 1809
  idc_ver = idc_ver;
#line 1810
  qla8044_wr_reg(ha, 14232UL, (uint32_t )idc_ver);
  exit_set_idc_ver: ;
#line 1813
  return (rval);
}
}
#line 1817 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_update_idc_reg(struct scsi_qla_host *vha ) 
{ 
  uint32_t drv_active ;
  int rval ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 1820
  rval = 0;
#line 1821
  ha = vha->hw;
#line 1823
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 1824
    goto exit_update_idc_reg;
  } else {

  }
#line 1826
  qla8044_idc_lock(ha);
#line 1827
  qla8044_set_drv_active(vha);
#line 1829
  tmp = qla8044_rd_direct(vha, 3U);
#line 1829
  drv_active = (uint32_t )tmp;
#line 1834
  if ((uint32_t )(1 << (int )ha->portnum) == drv_active && ql2xdontresethba == 0) {
#line 1835
    qla8044_clear_idc_dontreset(vha);
  } else {

  }
#line 1837
  rval = qla8044_set_idc_ver(vha);
#line 1838
  if (rval == 258) {
#line 1839
    qla8044_clear_drv_active(ha);
  } else {

  }
#line 1840
  qla8044_idc_unlock(ha);
  exit_update_idc_reg: ;
#line 1843
  return (rval);
}
}
#line 1851 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_need_qsnt_handler(struct scsi_qla_host *vha ) 
{ 
  unsigned long qsnt_timeout ;
  uint32_t drv_state ;
  uint32_t drv_active ;
  uint32_t dev_state ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1855
  ha = vha->hw;
#line 1857
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 1858
    qla2x00_quiesce_io(vha);
  } else {
#line 1860
    return;
  }
#line 1862
  qla8044_set_qsnt_ready(vha);
#line 1865
  qsnt_timeout = (unsigned long )jiffies + 7500UL;
#line 1866
  tmp = qla8044_rd_direct(vha, 5U);
#line 1866
  drv_state = (uint32_t )tmp;
#line 1867
  tmp___0 = qla8044_rd_direct(vha, 3U);
#line 1867
  drv_active = (uint32_t )tmp___0;
#line 1871
  drv_active = drv_active << 1;
#line 1873
  goto ldv_66442;
  ldv_66441: ;
#line 1874
  if ((long )((unsigned long )jiffies - qsnt_timeout) >= 0L) {
#line 1878
    clear_bit(20L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1879
    qla8044_wr_direct(vha, 4U, 3U);
#line 1881
    qla8044_clear_qsnt_ready(vha);
#line 1882
    ql_log(2U, vha, 45260, "Timeout waiting for quiescent ack!!!\n");
#line 1884
    return;
  } else {

  }
#line 1886
  qla8044_idc_unlock(ha);
#line 1887
  msleep(1000U);
#line 1888
  qla8044_idc_lock(ha);
#line 1890
  tmp___1 = qla8044_rd_direct(vha, 5U);
#line 1890
  drv_state = (uint32_t )tmp___1;
#line 1892
  tmp___2 = qla8044_rd_direct(vha, 3U);
#line 1892
  drv_active = (uint32_t )tmp___2;
#line 1894
  drv_active = drv_active << 1;
  ldv_66442: ;
#line 1873
  if (drv_state != drv_active) {
#line 1875
    goto ldv_66441;
  } else {

  }
#line 1898
  tmp___3 = qla8044_rd_direct(vha, 4U);
#line 1898
  dev_state = (uint32_t )tmp___3;
#line 1900
  if (dev_state == 5U) {
#line 1901
    qla8044_wr_direct(vha, 4U, 7U);
#line 1903
    ql_log(2U, vha, 45261, "%s: HW State: QUIESCENT\n", "qla8044_need_qsnt_handler");
  } else {

  }
#line 1906
  return;
}
}
#line 1915 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
int qla8044_device_state_handler(struct scsi_qla_host *vha ) 
{ 
  uint32_t dev_state ;
  int rval ;
  unsigned long dev_init_timeout ;
  struct qla_hw_data *ha ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 1918
  rval = 0;
#line 1920
  ha = vha->hw;
#line 1922
  rval = qla8044_update_idc_reg(vha);
#line 1923
  if (rval == 258) {
#line 1924
    goto exit_error;
  } else {

  }
#line 1926
  tmp = qla8044_rd_direct(vha, 4U);
#line 1926
  dev_state = (uint32_t )tmp;
#line 1927
  if (dev_state <= 7U) {
#line 1927
    tmp___0 = qdev_state(dev_state);
#line 1927
    tmp___1 = tmp___0;
  } else {
#line 1927
    tmp___1 = (char *)"Unknown";
  }
#line 1927
  ql_dbg(524288U, vha, 45262, "Device state is 0x%x = %s\n", dev_state, tmp___1);
#line 1933
  dev_init_timeout = (unsigned long )(ha->fcoe_dev_init_timeout * 250U) + (unsigned long )jiffies;
#line 1935
  qla8044_idc_lock(ha);
  ldv_66469: ;
#line 1938
  if ((long )((unsigned long )jiffies - dev_init_timeout) >= 0L) {
#line 1939
    tmp___4 = qla8044_check_drv_active(vha);
#line 1939
    if (tmp___4 == 0) {
#line 1940
      if (dev_state <= 7U) {
#line 1940
        tmp___2 = qdev_state(dev_state);
#line 1940
        tmp___3 = tmp___2;
      } else {
#line 1940
        tmp___3 = (char *)"Unknown";
      }
#line 1940
      ql_log(1U, vha, 45263, "%s: Device Init Failed 0x%x = %s\n", (char *)"qla2xxx",
             dev_state, tmp___3);
#line 1945
      qla8044_wr_direct(vha, 4U, 6U);
    } else {

    }
  } else {

  }
#line 1951
  tmp___5 = qla8044_rd_direct(vha, 4U);
#line 1951
  dev_state = (uint32_t )tmp___5;
#line 1952
  if (dev_state <= 7U) {
#line 1952
    tmp___6 = qdev_state(dev_state);
#line 1952
    tmp___7 = tmp___6;
  } else {
#line 1952
    tmp___7 = (char *)"Unknown";
  }
#line 1952
  ql_log(2U, vha, 45264, "Device state is 0x%x = %s\n", dev_state, tmp___7);
#line 1958
  switch (dev_state) {
  case 3U: 
#line 1960
  ha->flags.nic_core_reset_owner = 0U;
#line 1961
  goto exit;
  case 1U: 
#line 1963
  rval = qla8044_device_bootstrap(vha);
#line 1964
  goto ldv_66462;
  case 2U: 
#line 1966
  qla8044_idc_unlock(ha);
#line 1967
  msleep(1000U);
#line 1968
  qla8044_idc_lock(ha);
#line 1969
  goto ldv_66462;
  case 4U: 
#line 1974
  qla8044_need_reset_handler(vha);
#line 1975
  goto ldv_66462;
  case 5U: 
#line 1978
  qla8044_need_qsnt_handler(vha);
#line 1981
  dev_init_timeout = (unsigned long )(ha->fcoe_reset_timeout * 250U) + (unsigned long )jiffies;
#line 1983
  goto ldv_66462;
  case 7U: 
#line 1985
  ql_log(2U, vha, 45265, "HW State: QUIESCENT\n");
#line 1988
  qla8044_idc_unlock(ha);
#line 1989
  msleep(1000U);
#line 1990
  qla8044_idc_lock(ha);
#line 1993
  dev_init_timeout = (unsigned long )(ha->fcoe_reset_timeout * 250U) + (unsigned long )jiffies;
#line 1995
  goto ldv_66462;
  case 6U: 
#line 1997
  ha->flags.nic_core_reset_owner = 0U;
#line 1998
  qla8044_idc_unlock(ha);
#line 1999
  qla8xxx_dev_failed_handler(vha);
#line 2000
  rval = 258;
#line 2001
  qla8044_idc_lock(ha);
#line 2002
  goto exit;
  default: 
#line 2004
  qla8044_idc_unlock(ha);
#line 2005
  qla8xxx_dev_failed_handler(vha);
#line 2006
  rval = 258;
#line 2007
  qla8044_idc_lock(ha);
#line 2008
  goto exit;
  }
  ldv_66462: ;
#line 2010
  goto ldv_66469;
  exit: 
#line 2012
  qla8044_idc_unlock(ha);
  exit_error: ;
#line 2015
  return (rval);
}
}
#line 2025 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_check_temp(struct scsi_qla_host *vha ) 
{ 
  uint32_t temp ;
  uint32_t temp_state ;
  uint32_t temp_val ;
  int status ;
  int tmp ;

  {
#line 2028
  status = 0;
#line 2030
  tmp = qla8044_rd_direct(vha, 13U);
#line 2030
  temp = (uint32_t )tmp;
#line 2031
  temp_state = temp & 65535U;
#line 2032
  temp_val = temp >> 16;
#line 2034
  if (temp_state == 3U) {
#line 2035
    ql_log(1U, vha, 45266, "Device temperature %d degrees C exceeds maximum allowed. Hardware has been shut down\n",
           temp_val);
#line 2039
    status = 258;
#line 2040
    return (status);
  } else
#line 2041
  if (temp_state == 2U) {
#line 2042
    ql_log(1U, vha, 45267, "Device temperature %d degrees C exceeds operating range. Immediate action needed.\n",
           temp_val);
  } else {

  }
#line 2047
  return (0);
}
}
#line 2050 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
int qla8044_read_temperature(scsi_qla_host_t *vha ) 
{ 
  uint32_t temp ;
  int tmp ;

  {
#line 2054
  tmp = qla8044_rd_direct(vha, 13U);
#line 2054
  temp = (uint32_t )tmp;
#line 2055
  return ((int )(temp >> 16));
}
}
#line 2065 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
int qla8044_check_fw_alive(struct scsi_qla_host *vha ) 
{ 
  uint32_t fw_heartbeat_counter ;
  uint32_t halt_status1 ;
  uint32_t halt_status2 ;
  int status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2069
  status = 0;
#line 2071
  tmp = qla8044_rd_direct(vha, 2U);
#line 2071
  fw_heartbeat_counter = (uint32_t )tmp;
#line 2075
  if (fw_heartbeat_counter == 4294967295U) {
#line 2076
    ql_dbg(524288U, vha, 45268, "scsi%ld: %s: Device in frozen state, QLA82XX_PEG_ALIVE_COUNTER is 0xffffffff\n",
           vha->host_no, "qla8044_check_fw_alive");
#line 2080
    return (status);
  } else {

  }
#line 2083
  if ((uint32_t )vha->fw_heartbeat_counter == fw_heartbeat_counter) {
#line 2084
    vha->seconds_since_last_heartbeat = vha->seconds_since_last_heartbeat + 1;
#line 2086
    if (vha->seconds_since_last_heartbeat == 2) {
#line 2087
      vha->seconds_since_last_heartbeat = 0;
#line 2088
      tmp___0 = qla8044_rd_direct(vha, 0U);
#line 2088
      halt_status1 = (uint32_t )tmp___0;
#line 2090
      tmp___1 = qla8044_rd_direct(vha, 1U);
#line 2090
      halt_status2 = (uint32_t )tmp___1;
#line 2093
      ql_log(2U, vha, 45269, "scsi(%ld): %s, ISP8044 Dumping hw/fw registers:\n PEG_HALT_STATUS1: 0x%x, PEG_HALT_STATUS2: 0x%x,\n",
             vha->host_no, "qla8044_check_fw_alive", halt_status1, halt_status2);
#line 2100
      status = 258;
    } else {

    }
  } else {
#line 2103
    vha->seconds_since_last_heartbeat = 0;
  }
#line 2105
  vha->fw_heartbeat_counter = (int )fw_heartbeat_counter;
#line 2106
  return (status);
}
}
#line 2110 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
void qla8044_watchdog(struct scsi_qla_host *vha ) 
{ 
  uint32_t dev_state ;
  uint32_t halt_status ;
  int halt_status_unrecoverable ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 2113
  halt_status_unrecoverable = 0;
#line 2114
  ha = vha->hw;
#line 2117
  tmp___5 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 2117
  if (tmp___5 == 0) {
#line 2117
    tmp___6 = constant_test_bit(18L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 2117
    if (tmp___6 == 0) {
#line 2119
      tmp = qla8044_rd_direct(vha, 4U);
#line 2119
      dev_state = (uint32_t )tmp;
#line 2121
      tmp___0 = qla8044_check_fw_alive(vha);
#line 2121
      if (tmp___0 != 0) {
#line 2122
        ha->flags.isp82xx_fw_hung = 1U;
#line 2123
        ql_log(1U, vha, 45322, "Firmware hung.\n");
#line 2125
        qla82xx_clear_pending_mbx(vha);
      } else {

      }
#line 2128
      tmp___4 = qla8044_check_temp(vha);
#line 2128
      if (tmp___4 != 0) {
#line 2129
        set_bit(17L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2130
        ha->flags.isp82xx_fw_hung = 1U;
#line 2131
        qla2xxx_wake_dpc(vha);
      } else
#line 2132
      if (dev_state == 4U) {
#line 2132
        tmp___3 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 2132
        if (tmp___3 == 0) {
#line 2134
          ql_log(2U, vha, 45270, "%s: HW State: NEED RESET!\n", "qla8044_watchdog");
#line 2137
          set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2138
          qla2xxx_wake_dpc(vha);
        } else {
#line 2132
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 2139
      if (dev_state == 5U) {
#line 2139
        tmp___2 = constant_test_bit(20L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 2139
        if (tmp___2 == 0) {
#line 2141
          ql_log(2U, vha, 45271, "%s: HW State: NEED QUIES detected!\n", "qla8044_watchdog");
#line 2144
          set_bit(20L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2145
          qla2xxx_wake_dpc(vha);
        } else {
#line 2139
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2148
      if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 2149
        tmp___1 = qla8044_rd_direct(vha, 0U);
#line 2149
        halt_status = (uint32_t )tmp___1;
#line 2151
        if ((halt_status & 1073741824U) != 0U) {
#line 2153
          ql_log(0U, vha, 45272, "%s: Firmware error detected device is being reset\n",
                 "qla8044_watchdog");
        } else
#line 2158
        if ((int )halt_status < 0) {
#line 2160
          halt_status_unrecoverable = 1;
        } else {

        }
#line 2166
        if (halt_status_unrecoverable != 0) {
#line 2167
          set_bit(17L, (unsigned long volatile   *)(& vha->dpc_flags));
        } else
#line 2170
        if (dev_state == 7U) {
#line 2172
          set_bit(18L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2174
          ql_log(2U, vha, 45273, "%s: FW CONTEXT Reset needed!\n", "qla8044_watchdog");
        } else {
#line 2178
          ql_log(2U, vha, 45274, "%s: detect abort needed\n", "qla8044_watchdog");
#line 2182
          set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
        }
#line 2186
        qla2xxx_wake_dpc(vha);
      } else {

      }
    } else {

    }
  } else {

  }
#line 2189
  return;
}
}
#line 2194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_minidump_process_control(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ) 
{ 
  struct qla8044_minidump_entry_crb *crb_entry ;
  uint32_t read_value ;
  uint32_t opcode ;
  uint32_t poll_time ;
  uint32_t addr ;
  uint32_t index ;
  uint32_t crb_addr ;
  uint32_t rval ;
  unsigned long wtime ;
  struct qla8044_minidump_template_hdr *tmplt_hdr ;
  int i ;
  struct qla_hw_data *ha ;

  {
#line 2199
  rval = 0U;
#line 2203
  ha = vha->hw;
#line 2205
  ql_dbg(524288U, vha, 45277, "Entering fn: %s\n", "qla8044_minidump_process_control");
#line 2206
  tmplt_hdr = (struct qla8044_minidump_template_hdr *)ha->md_tmplt_hdr;
#line 2208
  crb_entry = (struct qla8044_minidump_entry_crb *)entry_hdr;
#line 2210
  crb_addr = crb_entry->addr;
#line 2211
  i = 0;
#line 2211
  goto ldv_66523;
  ldv_66522: 
#line 2212
  opcode = (uint32_t )crb_entry->crb_ctrl.opcode;
#line 2214
  if ((int )opcode & 1) {
#line 2215
    qla8044_wr_reg_indirect(vha, crb_addr, crb_entry->value_1);
#line 2217
    opcode = opcode & 4294967294U;
  } else {

  }
#line 2220
  if ((opcode & 2U) != 0U) {
#line 2221
    qla8044_rd_reg_indirect(vha, crb_addr, & read_value);
#line 2222
    qla8044_wr_reg_indirect(vha, crb_addr, read_value);
#line 2223
    opcode = opcode & 4294967293U;
  } else {

  }
#line 2226
  if ((opcode & 4U) != 0U) {
#line 2227
    qla8044_rd_reg_indirect(vha, crb_addr, & read_value);
#line 2228
    read_value = crb_entry->value_2 & read_value;
#line 2229
    opcode = opcode & 4294967291U;
#line 2230
    if ((opcode & 8U) != 0U) {
#line 2231
      read_value = crb_entry->value_3 | read_value;
#line 2232
      opcode = opcode & 4294967287U;
    } else {

    }
#line 2234
    qla8044_wr_reg_indirect(vha, crb_addr, read_value);
  } else {

  }
#line 2236
  if ((opcode & 8U) != 0U) {
#line 2237
    qla8044_rd_reg_indirect(vha, crb_addr, & read_value);
#line 2238
    read_value = crb_entry->value_3 | read_value;
#line 2239
    qla8044_wr_reg_indirect(vha, crb_addr, read_value);
#line 2240
    opcode = opcode & 4294967287U;
  } else {

  }
#line 2242
  if ((opcode & 16U) != 0U) {
#line 2243
    poll_time = (uint32_t )crb_entry->crb_strd.poll_timeout;
#line 2244
    wtime = (unsigned long )poll_time + (unsigned long )jiffies;
#line 2245
    qla8044_rd_reg_indirect(vha, crb_addr, & read_value);
    ldv_66521: ;
#line 2248
    if ((crb_entry->value_2 & read_value) == crb_entry->value_1) {
#line 2250
      goto ldv_66514;
    } else
#line 2251
    if ((long )((unsigned long )jiffies - wtime) >= 0L) {
#line 2253
      rval = 258U;
#line 2254
      goto ldv_66514;
    } else {
#line 2256
      qla8044_rd_reg_indirect(vha, crb_addr, & read_value);
    }
#line 2259
    goto ldv_66521;
    ldv_66514: 
#line 2260
    opcode = opcode & 4294967279U;
  } else {

  }
#line 2263
  if ((opcode & 32U) != 0U) {
#line 2264
    if ((unsigned int )crb_entry->crb_strd.state_index_a != 0U) {
#line 2265
      index = (uint32_t )crb_entry->crb_strd.state_index_a;
#line 2266
      addr = tmplt_hdr->saved_state_array[index];
    } else {
#line 2268
      addr = crb_addr;
    }
#line 2271
    qla8044_rd_reg_indirect(vha, addr, & read_value);
#line 2272
    index = (uint32_t )crb_entry->crb_ctrl.state_index_v;
#line 2273
    tmplt_hdr->saved_state_array[index] = read_value;
#line 2274
    opcode = opcode & 4294967263U;
  } else {

  }
#line 2277
  if ((opcode & 64U) != 0U) {
#line 2278
    if ((unsigned int )crb_entry->crb_strd.state_index_a != 0U) {
#line 2279
      index = (uint32_t )crb_entry->crb_strd.state_index_a;
#line 2280
      addr = tmplt_hdr->saved_state_array[index];
    } else {
#line 2282
      addr = crb_addr;
    }
#line 2285
    if ((unsigned int )crb_entry->crb_ctrl.state_index_v != 0U) {
#line 2286
      index = (uint32_t )crb_entry->crb_ctrl.state_index_v;
#line 2287
      read_value = tmplt_hdr->saved_state_array[index];
    } else {
#line 2290
      read_value = crb_entry->value_1;
    }
#line 2293
    qla8044_wr_reg_indirect(vha, addr, read_value);
#line 2294
    opcode = opcode & 4294967231U;
  } else {

  }
#line 2297
  if ((opcode & 128U) != 0U) {
#line 2298
    index = (uint32_t )crb_entry->crb_ctrl.state_index_v;
#line 2299
    read_value = tmplt_hdr->saved_state_array[index];
#line 2300
    read_value = read_value << (int )crb_entry->crb_ctrl.shl;
#line 2301
    read_value = read_value >> (int )crb_entry->crb_ctrl.shr;
#line 2302
    if (crb_entry->value_2 != 0U) {
#line 2303
      read_value = crb_entry->value_2 & read_value;
    } else {

    }
#line 2304
    read_value = crb_entry->value_3 | read_value;
#line 2305
    read_value = crb_entry->value_1 + read_value;
#line 2306
    tmplt_hdr->saved_state_array[index] = read_value;
#line 2307
    opcode = opcode & 4294967167U;
  } else {

  }
#line 2309
  crb_addr = (uint32_t )crb_entry->crb_strd.addr_stride + crb_addr;
#line 2211
  i = i + 1;
  ldv_66523: ;
#line 2211
  if ((uint32_t )i < crb_entry->op_count) {
#line 2213
    goto ldv_66522;
  } else {

  }

#line 2311
  return ((int )rval);
}
}
#line 2315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_minidump_process_rdcrb(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                           uint32_t **d_ptr ) 
{ 
  uint32_t r_addr ;
  uint32_t r_stride ;
  uint32_t loop_cnt ;
  uint32_t i ;
  uint32_t r_value ;
  struct qla8044_minidump_entry_crb *crb_hdr ;
  uint32_t *data_ptr ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;

  {
#line 2320
  data_ptr = *d_ptr;
#line 2322
  ql_dbg(524288U, vha, 45278, "Entering fn: %s\n", "qla8044_minidump_process_rdcrb");
#line 2323
  crb_hdr = (struct qla8044_minidump_entry_crb *)entry_hdr;
#line 2324
  r_addr = crb_hdr->addr;
#line 2325
  r_stride = (uint32_t )crb_hdr->crb_strd.addr_stride;
#line 2326
  loop_cnt = crb_hdr->op_count;
#line 2328
  i = 0U;
#line 2328
  goto ldv_66539;
  ldv_66538: 
#line 2329
  qla8044_rd_reg_indirect(vha, r_addr, & r_value);
#line 2330
  tmp = data_ptr;
#line 2330
  data_ptr = data_ptr + 1;
#line 2330
  *tmp = r_addr;
#line 2331
  tmp___0 = data_ptr;
#line 2331
  data_ptr = data_ptr + 1;
#line 2331
  *tmp___0 = r_value;
#line 2332
  r_addr = r_addr + r_stride;
#line 2328
  i = i + 1U;
  ldv_66539: ;
#line 2328
  if (i < loop_cnt) {
#line 2330
    goto ldv_66538;
  } else {

  }
#line 2334
  *d_ptr = data_ptr;
#line 2335
  return;
}
}
#line 2338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_minidump_process_rdmem(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                          uint32_t **d_ptr ) 
{ 
  uint32_t r_addr ;
  uint32_t r_value ;
  uint32_t r_data ;
  uint32_t i ;
  uint32_t j ;
  uint32_t loop_cnt ;
  struct qla8044_minidump_entry_rdmem *m_hdr ;
  unsigned long flags ;
  uint32_t *data_ptr ;
  struct qla_hw_data *ha ;
  uint32_t *tmp ;

  {
#line 2345
  data_ptr = *d_ptr;
#line 2346
  ha = vha->hw;
#line 2348
  ql_dbg(524288U, vha, 45279, "Entering fn: %s\n", "qla8044_minidump_process_rdmem");
#line 2349
  m_hdr = (struct qla8044_minidump_entry_rdmem *)entry_hdr;
#line 2350
  r_addr = m_hdr->read_addr;
#line 2351
  loop_cnt = m_hdr->read_data_size / 16U;
#line 2353
  ql_dbg(524288U, vha, 45296, "[%s]: Read addr: 0x%x, read_data_size: 0x%x\n", "qla8044_minidump_process_rdmem",
         r_addr, m_hdr->read_data_size);
#line 2357
  if ((r_addr & 15U) != 0U) {
#line 2358
    ql_dbg(524288U, vha, 45297, "[%s]: Read addr 0x%x not 16 bytes aligned\n", "qla8044_minidump_process_rdmem",
           r_addr);
#line 2361
    return (258);
  } else {

  }
#line 2364
  if ((m_hdr->read_data_size & 15U) != 0U) {
#line 2365
    ql_dbg(524288U, vha, 45298, "[%s]: Read data[0x%x] not multiple of 16 bytes\n",
           "qla8044_minidump_process_rdmem", m_hdr->read_data_size);
#line 2368
    return (258);
  } else {

  }
#line 2371
  ql_dbg(524288U, vha, 45299, "[%s]: rdmem_addr: 0x%x, read_data_size: 0x%x, loop_cnt: 0x%x\n",
         "qla8044_minidump_process_rdmem", r_addr, m_hdr->read_data_size, loop_cnt);
#line 2375
  flags = _raw_write_lock_irqsave(& ha->hw_lock);
#line 2376
  i = 0U;
#line 2376
  goto ldv_66570;
  ldv_66569: 
#line 2377
  qla8044_wr_reg_indirect(vha, 1090519188U, r_addr);
#line 2378
  r_value = 0U;
#line 2379
  qla8044_wr_reg_indirect(vha, 1090519192U, r_value);
#line 2380
  r_value = 2U;
#line 2381
  qla8044_wr_reg_indirect(vha, 1090519184U, r_value);
#line 2382
  r_value = 3U;
#line 2383
  qla8044_wr_reg_indirect(vha, 1090519184U, r_value);
#line 2385
  j = 0U;
#line 2385
  goto ldv_66562;
  ldv_66561: 
#line 2386
  qla8044_rd_reg_indirect(vha, 1090519184U, & r_value);
#line 2388
  if ((r_value & 8U) == 0U) {
#line 2389
    goto ldv_66560;
  } else {

  }
#line 2385
  j = j + 1U;
  ldv_66562: ;
#line 2385
  if (j <= 999U) {
#line 2387
    goto ldv_66561;
  } else {

  }
  ldv_66560: ;
#line 2392
  if (j > 999U) {
#line 2393
    _raw_write_unlock_irqrestore(& ha->hw_lock, flags);
#line 2394
    return (0);
  } else {

  }
#line 2397
  j = 0U;
#line 2397
  goto ldv_66567;
  ldv_66566: 
#line 2398
  qla8044_rd_reg_indirect(vha, (uint32_t )MD_MIU_TEST_AGT_RDDATA___0[j], & r_data);
#line 2400
  tmp = data_ptr;
#line 2400
  data_ptr = data_ptr + 1;
#line 2400
  *tmp = r_data;
#line 2397
  j = j + 1U;
  ldv_66567: ;
#line 2397
  if (j <= 3U) {
#line 2399
    goto ldv_66566;
  } else {

  }
#line 2403
  r_addr = r_addr + 16U;
#line 2376
  i = i + 1U;
  ldv_66570: ;
#line 2376
  if (i < loop_cnt) {
#line 2378
    goto ldv_66569;
  } else {

  }
#line 2405
  _raw_write_unlock_irqrestore(& ha->hw_lock, flags);
#line 2407
  ql_dbg(524288U, vha, 45300, "Leaving fn: %s datacount: 0x%x\n", "qla8044_minidump_process_rdmem",
         loop_cnt * 16U);
#line 2411
  *d_ptr = data_ptr;
#line 2412
  return (0);
}
}
#line 2417 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static uint32_t qla8044_minidump_process_rdrom(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                               uint32_t **d_ptr ) 
{ 
  uint32_t fl_addr ;
  uint32_t u32_count ;
  uint32_t rval ;
  struct qla8044_minidump_entry_rdrom *rom_hdr ;
  uint32_t *data_ptr ;
  int tmp ;

  {
#line 2422
  data_ptr = *d_ptr;
#line 2424
  rom_hdr = (struct qla8044_minidump_entry_rdrom *)entry_hdr;
#line 2425
  fl_addr = rom_hdr->read_addr;
#line 2426
  u32_count = rom_hdr->read_data_size / 4U;
#line 2428
  ql_dbg(524288U, vha, 45301, "[%s]: fl_addr: 0x%x, count: 0x%x\n", "qla8044_minidump_process_rdrom",
         fl_addr, u32_count);
#line 2431
  tmp = qla8044_lockless_flash_read_u32(vha, fl_addr, (uint8_t *)data_ptr, (int )u32_count);
#line 2431
  rval = (uint32_t )tmp;
#line 2434
  if (rval != 0U) {
#line 2435
    ql_log(0U, vha, 45302, "%s: Flash Read Error,Count=%d\n", "qla8044_minidump_process_rdrom",
           u32_count);
#line 2437
    return (258U);
  } else {
#line 2439
    data_ptr = data_ptr + (unsigned long )u32_count;
#line 2440
    *d_ptr = data_ptr;
#line 2441
    return (0U);
  }
}
}
#line 2446 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_mark_entry_skipped(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                       int index ) 
{ 


  {
#line 2449
  entry_hdr->d_ctrl.driver_flags = (uint8_t )((unsigned int )entry_hdr->d_ctrl.driver_flags | 128U);
#line 2451
  ql_log(2U, vha, 45303, "scsi(%ld): Skipping entry[%d]: ETYPE[0x%x]-ELEVEL[0x%x]\n",
         vha->host_no, index, entry_hdr->entry_type, (int )entry_hdr->d_ctrl.entry_capture_mask);
#line 2455
  return;
}
}
#line 2458 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_minidump_process_l2tag(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                          uint32_t **d_ptr ) 
{ 
  uint32_t addr ;
  uint32_t r_addr ;
  uint32_t c_addr ;
  uint32_t t_r_addr ;
  uint32_t i ;
  uint32_t k ;
  uint32_t loop_count ;
  uint32_t t_value ;
  uint32_t r_cnt ;
  uint32_t r_value ;
  unsigned long p_wait ;
  unsigned long w_time ;
  unsigned long p_mask ;
  uint32_t c_value_w ;
  uint32_t c_value_r ;
  struct qla8044_minidump_entry_cache *cache_hdr ;
  int rval ;
  uint32_t *data_ptr ;
  uint32_t *tmp ;

  {
#line 2467
  rval = 258;
#line 2468
  data_ptr = *d_ptr;
#line 2470
  ql_dbg(524288U, vha, 45304, "Entering fn: %s\n", "qla8044_minidump_process_l2tag");
#line 2471
  cache_hdr = (struct qla8044_minidump_entry_cache *)entry_hdr;
#line 2473
  loop_count = cache_hdr->op_count;
#line 2474
  r_addr = cache_hdr->read_addr;
#line 2475
  c_addr = cache_hdr->control_addr;
#line 2476
  c_value_w = (uint32_t )cache_hdr->cache_ctrl.write_value;
#line 2478
  t_r_addr = cache_hdr->tag_reg_addr;
#line 2479
  t_value = (uint32_t )cache_hdr->addr_ctrl.init_tag_value;
#line 2480
  r_cnt = (uint32_t )cache_hdr->read_ctrl.read_addr_cnt;
#line 2481
  p_wait = (unsigned long )cache_hdr->cache_ctrl.poll_wait;
#line 2482
  p_mask = (unsigned long )cache_hdr->cache_ctrl.poll_mask;
#line 2484
  i = 0U;
#line 2484
  goto ldv_66627;
  ldv_66626: 
#line 2485
  qla8044_wr_reg_indirect(vha, t_r_addr, t_value);
#line 2486
  if (c_value_w != 0U) {
#line 2487
    qla8044_wr_reg_indirect(vha, c_addr, c_value_w);
  } else {

  }
#line 2489
  if (p_mask != 0UL) {
#line 2490
    w_time = (unsigned long )jiffies + p_wait;
    ldv_66622: 
#line 2492
    qla8044_rd_reg_indirect(vha, c_addr, & c_value_r);
#line 2494
    if (((unsigned long )c_value_r & p_mask) == 0UL) {
#line 2495
      goto ldv_66615;
    } else
#line 2496
    if ((long )((unsigned long )jiffies - w_time) >= 0L) {
#line 2498
      return (rval);
    } else {

    }
#line 2500
    goto ldv_66622;
    ldv_66615: ;
  } else {

  }
#line 2503
  addr = r_addr;
#line 2504
  k = 0U;
#line 2504
  goto ldv_66624;
  ldv_66623: 
#line 2505
  qla8044_rd_reg_indirect(vha, addr, & r_value);
#line 2506
  tmp = data_ptr;
#line 2506
  data_ptr = data_ptr + 1;
#line 2506
  *tmp = r_value;
#line 2507
  addr = (uint32_t )cache_hdr->read_ctrl.read_addr_stride + addr;
#line 2504
  k = k + 1U;
  ldv_66624: ;
#line 2504
  if (k < r_cnt) {
#line 2506
    goto ldv_66623;
  } else {

  }
#line 2509
  t_value = (uint32_t )cache_hdr->addr_ctrl.tag_value_stride + t_value;
#line 2484
  i = i + 1U;
  ldv_66627: ;
#line 2484
  if (i < loop_count) {
#line 2486
    goto ldv_66626;
  } else {

  }
#line 2511
  *d_ptr = data_ptr;
#line 2512
  return (0);
}
}
#line 2516 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_minidump_process_l1cache(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                             uint32_t **d_ptr ) 
{ 
  uint32_t addr ;
  uint32_t r_addr ;
  uint32_t c_addr ;
  uint32_t t_r_addr ;
  uint32_t i ;
  uint32_t k ;
  uint32_t loop_count ;
  uint32_t t_value ;
  uint32_t r_cnt ;
  uint32_t r_value ;
  uint32_t c_value_w ;
  struct qla8044_minidump_entry_cache *cache_hdr ;
  uint32_t *data_ptr ;
  uint32_t *tmp ;

  {
#line 2523
  data_ptr = *d_ptr;
#line 2525
  cache_hdr = (struct qla8044_minidump_entry_cache *)entry_hdr;
#line 2526
  loop_count = cache_hdr->op_count;
#line 2527
  r_addr = cache_hdr->read_addr;
#line 2528
  c_addr = cache_hdr->control_addr;
#line 2529
  c_value_w = (uint32_t )cache_hdr->cache_ctrl.write_value;
#line 2531
  t_r_addr = cache_hdr->tag_reg_addr;
#line 2532
  t_value = (uint32_t )cache_hdr->addr_ctrl.init_tag_value;
#line 2533
  r_cnt = (uint32_t )cache_hdr->read_ctrl.read_addr_cnt;
#line 2535
  i = 0U;
#line 2535
  goto ldv_66651;
  ldv_66650: 
#line 2536
  qla8044_wr_reg_indirect(vha, t_r_addr, t_value);
#line 2537
  qla8044_wr_reg_indirect(vha, c_addr, c_value_w);
#line 2538
  addr = r_addr;
#line 2539
  k = 0U;
#line 2539
  goto ldv_66648;
  ldv_66647: 
#line 2540
  qla8044_rd_reg_indirect(vha, addr, & r_value);
#line 2541
  tmp = data_ptr;
#line 2541
  data_ptr = data_ptr + 1;
#line 2541
  *tmp = r_value;
#line 2542
  addr = (uint32_t )cache_hdr->read_ctrl.read_addr_stride + addr;
#line 2539
  k = k + 1U;
  ldv_66648: ;
#line 2539
  if (k < r_cnt) {
#line 2541
    goto ldv_66647;
  } else {

  }
#line 2544
  t_value = (uint32_t )cache_hdr->addr_ctrl.tag_value_stride + t_value;
#line 2535
  i = i + 1U;
  ldv_66651: ;
#line 2535
  if (i < loop_count) {
#line 2537
    goto ldv_66650;
  } else {

  }
#line 2546
  *d_ptr = data_ptr;
#line 2547
  return;
}
}
#line 2550 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_minidump_process_rdocm(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                           uint32_t **d_ptr ) 
{ 
  uint32_t r_addr ;
  uint32_t r_stride ;
  uint32_t loop_cnt ;
  uint32_t i ;
  uint32_t r_value ;
  struct qla8044_minidump_entry_rdocm *ocm_hdr ;
  uint32_t *data_ptr ;
  struct qla_hw_data *ha ;
  uint32_t *tmp ;

  {
#line 2555
  data_ptr = *d_ptr;
#line 2556
  ha = vha->hw;
#line 2558
  ql_dbg(524288U, vha, 45305, "Entering fn: %s\n", "qla8044_minidump_process_rdocm");
#line 2560
  ocm_hdr = (struct qla8044_minidump_entry_rdocm *)entry_hdr;
#line 2561
  r_addr = ocm_hdr->read_addr;
#line 2562
  r_stride = ocm_hdr->read_addr_stride;
#line 2563
  loop_cnt = ocm_hdr->op_count;
#line 2565
  ql_dbg(524288U, vha, 45306, "[%s]: r_addr: 0x%x, r_stride: 0x%x, loop_cnt: 0x%x\n",
         "qla8044_minidump_process_rdocm", r_addr, r_stride, loop_cnt);
#line 2569
  i = 0U;
#line 2569
  goto ldv_66668;
  ldv_66667: 
#line 2570
  r_value = readl((void const volatile   *)((unsigned long )r_addr + ha->nx_pcibase));
#line 2571
  tmp = data_ptr;
#line 2571
  data_ptr = data_ptr + 1;
#line 2571
  *tmp = r_value;
#line 2572
  r_addr = r_addr + r_stride;
#line 2569
  i = i + 1U;
  ldv_66668: ;
#line 2569
  if (i < loop_cnt) {
#line 2571
    goto ldv_66667;
  } else {

  }
#line 2574
  ql_dbg(524288U, vha, 45307, "Leaving fn: %s datacount: 0x%lx\n", "qla8044_minidump_process_rdocm",
         (unsigned long )loop_cnt * 4UL);
#line 2577
  *d_ptr = data_ptr;
#line 2578
  return;
}
}
#line 2581 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_minidump_process_rdmux(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                           uint32_t **d_ptr ) 
{ 
  uint32_t r_addr ;
  uint32_t s_stride ;
  uint32_t s_addr ;
  uint32_t s_value ;
  uint32_t loop_cnt ;
  uint32_t i ;
  uint32_t r_value ;
  struct qla8044_minidump_entry_mux *mux_hdr ;
  uint32_t *data_ptr ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;

  {
#line 2587
  data_ptr = *d_ptr;
#line 2589
  ql_dbg(524288U, vha, 45308, "Entering fn: %s\n", "qla8044_minidump_process_rdmux");
#line 2591
  mux_hdr = (struct qla8044_minidump_entry_mux *)entry_hdr;
#line 2592
  r_addr = mux_hdr->read_addr;
#line 2593
  s_addr = mux_hdr->select_addr;
#line 2594
  s_stride = mux_hdr->select_value_stride;
#line 2595
  s_value = mux_hdr->select_value;
#line 2596
  loop_cnt = mux_hdr->op_count;
#line 2598
  i = 0U;
#line 2598
  goto ldv_66686;
  ldv_66685: 
#line 2599
  qla8044_wr_reg_indirect(vha, s_addr, s_value);
#line 2600
  qla8044_rd_reg_indirect(vha, r_addr, & r_value);
#line 2601
  tmp = data_ptr;
#line 2601
  data_ptr = data_ptr + 1;
#line 2601
  *tmp = s_value;
#line 2602
  tmp___0 = data_ptr;
#line 2602
  data_ptr = data_ptr + 1;
#line 2602
  *tmp___0 = r_value;
#line 2603
  s_value = s_value + s_stride;
#line 2598
  i = i + 1U;
  ldv_66686: ;
#line 2598
  if (i < loop_cnt) {
#line 2600
    goto ldv_66685;
  } else {

  }
#line 2605
  *d_ptr = data_ptr;
#line 2606
  return;
}
}
#line 2609 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_minidump_process_queue(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                           uint32_t **d_ptr ) 
{ 
  uint32_t s_addr ;
  uint32_t r_addr ;
  uint32_t r_stride ;
  uint32_t r_value ;
  uint32_t r_cnt ;
  uint32_t qid ;
  uint32_t i ;
  uint32_t k ;
  uint32_t loop_cnt ;
  struct qla8044_minidump_entry_queue *q_hdr ;
  uint32_t *data_ptr ;
  uint32_t *tmp ;

  {
#line 2614
  qid = 0U;
#line 2617
  data_ptr = *d_ptr;
#line 2619
  ql_dbg(524288U, vha, 45309, "Entering fn: %s\n", "qla8044_minidump_process_queue");
#line 2620
  q_hdr = (struct qla8044_minidump_entry_queue *)entry_hdr;
#line 2621
  s_addr = q_hdr->select_addr;
#line 2622
  r_cnt = (uint32_t )q_hdr->rd_strd.read_addr_cnt;
#line 2623
  r_stride = (uint32_t )q_hdr->rd_strd.read_addr_stride;
#line 2624
  loop_cnt = q_hdr->op_count;
#line 2626
  i = 0U;
#line 2626
  goto ldv_66709;
  ldv_66708: 
#line 2627
  qla8044_wr_reg_indirect(vha, s_addr, qid);
#line 2628
  r_addr = q_hdr->read_addr;
#line 2629
  k = 0U;
#line 2629
  goto ldv_66706;
  ldv_66705: 
#line 2630
  qla8044_rd_reg_indirect(vha, r_addr, & r_value);
#line 2631
  tmp = data_ptr;
#line 2631
  data_ptr = data_ptr + 1;
#line 2631
  *tmp = r_value;
#line 2632
  r_addr = r_addr + r_stride;
#line 2629
  k = k + 1U;
  ldv_66706: ;
#line 2629
  if (k < r_cnt) {
#line 2631
    goto ldv_66705;
  } else {

  }
#line 2634
  qid = (uint32_t )q_hdr->q_strd.queue_id_stride + qid;
#line 2626
  i = i + 1U;
  ldv_66709: ;
#line 2626
  if (i < loop_cnt) {
#line 2628
    goto ldv_66708;
  } else {

  }
#line 2636
  *d_ptr = data_ptr;
#line 2637
  return;
}
}
#line 2641 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static uint32_t qla8044_minidump_process_pollrd(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                                uint32_t **d_ptr ) 
{ 
  uint32_t r_addr ;
  uint32_t s_addr ;
  uint32_t s_value ;
  uint32_t r_value ;
  uint32_t poll_wait___0 ;
  uint32_t poll_mask ;
  uint16_t s_stride ;
  uint16_t i ;
  struct qla8044_minidump_entry_pollrd *pollrd_hdr ;
  uint32_t *data_ptr ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;

  {
#line 2648
  data_ptr = *d_ptr;
#line 2650
  pollrd_hdr = (struct qla8044_minidump_entry_pollrd *)entry_hdr;
#line 2651
  s_addr = pollrd_hdr->select_addr;
#line 2652
  r_addr = pollrd_hdr->read_addr;
#line 2653
  s_value = pollrd_hdr->select_value;
#line 2654
  s_stride = pollrd_hdr->select_value_stride;
#line 2656
  poll_wait___0 = pollrd_hdr->poll_wait;
#line 2657
  poll_mask = pollrd_hdr->poll_mask;
#line 2659
  i = 0U;
#line 2659
  goto ldv_66731;
  ldv_66730: 
#line 2660
  qla8044_wr_reg_indirect(vha, s_addr, s_value);
#line 2661
  poll_wait___0 = pollrd_hdr->poll_wait;
  ldv_66729: 
#line 2663
  qla8044_rd_reg_indirect(vha, s_addr, & r_value);
#line 2664
  if ((r_value & poll_mask) != 0U) {
#line 2665
    goto ldv_66726;
  } else {
#line 2667
    usleep_range(1000UL, 1100UL);
#line 2668
    poll_wait___0 = poll_wait___0 - 1U;
#line 2668
    if (poll_wait___0 == 0U) {
#line 2669
      ql_log(0U, vha, 45310, "%s: TIMEOUT\n", "qla8044_minidump_process_pollrd");
#line 2671
      goto error;
    } else {

    }
  }
#line 2674
  goto ldv_66729;
  ldv_66726: 
#line 2675
  qla8044_rd_reg_indirect(vha, r_addr, & r_value);
#line 2676
  tmp = data_ptr;
#line 2676
  data_ptr = data_ptr + 1;
#line 2676
  *tmp = s_value;
#line 2677
  tmp___0 = data_ptr;
#line 2677
  data_ptr = data_ptr + 1;
#line 2677
  *tmp___0 = r_value;
#line 2679
  s_value = (uint32_t )s_stride + s_value;
#line 2659
  i = (uint16_t )((int )i + 1);
  ldv_66731: ;
#line 2659
  if ((int )pollrd_hdr->op_count > (int )i) {
#line 2661
    goto ldv_66730;
  } else {

  }
#line 2681
  *d_ptr = data_ptr;
#line 2682
  return (0U);
  error: ;
#line 2685
  return (258U);
}
}
#line 2689 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_minidump_process_rdmux2(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                            uint32_t **d_ptr ) 
{ 
  uint32_t sel_val1 ;
  uint32_t sel_val2 ;
  uint32_t t_sel_val ;
  uint32_t data ;
  uint32_t i ;
  uint32_t sel_addr1 ;
  uint32_t sel_addr2 ;
  uint32_t sel_val_mask ;
  uint32_t read_addr ;
  struct qla8044_minidump_entry_rdmux2 *rdmux2_hdr ;
  uint32_t *data_ptr ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;

  {
#line 2695
  data_ptr = *d_ptr;
#line 2697
  rdmux2_hdr = (struct qla8044_minidump_entry_rdmux2 *)entry_hdr;
#line 2698
  sel_val1 = rdmux2_hdr->select_value_1;
#line 2699
  sel_val2 = rdmux2_hdr->select_value_2;
#line 2700
  sel_addr1 = rdmux2_hdr->select_addr_1;
#line 2701
  sel_addr2 = rdmux2_hdr->select_addr_2;
#line 2702
  sel_val_mask = rdmux2_hdr->select_value_mask;
#line 2703
  read_addr = rdmux2_hdr->read_addr;
#line 2705
  i = 0U;
#line 2705
  goto ldv_66750;
  ldv_66749: 
#line 2706
  qla8044_wr_reg_indirect(vha, sel_addr1, sel_val1);
#line 2707
  t_sel_val = sel_val1 & sel_val_mask;
#line 2708
  tmp = data_ptr;
#line 2708
  data_ptr = data_ptr + 1;
#line 2708
  *tmp = t_sel_val;
#line 2710
  qla8044_wr_reg_indirect(vha, sel_addr2, t_sel_val);
#line 2711
  qla8044_rd_reg_indirect(vha, read_addr, & data);
#line 2713
  tmp___0 = data_ptr;
#line 2713
  data_ptr = data_ptr + 1;
#line 2713
  *tmp___0 = data;
#line 2715
  qla8044_wr_reg_indirect(vha, sel_addr1, sel_val2);
#line 2716
  t_sel_val = sel_val2 & sel_val_mask;
#line 2717
  tmp___1 = data_ptr;
#line 2717
  data_ptr = data_ptr + 1;
#line 2717
  *tmp___1 = t_sel_val;
#line 2719
  qla8044_wr_reg_indirect(vha, sel_addr2, t_sel_val);
#line 2720
  qla8044_rd_reg_indirect(vha, read_addr, & data);
#line 2722
  tmp___2 = data_ptr;
#line 2722
  data_ptr = data_ptr + 1;
#line 2722
  *tmp___2 = data;
#line 2724
  sel_val1 = (uint32_t )rdmux2_hdr->select_value_stride + sel_val1;
#line 2725
  sel_val2 = (uint32_t )rdmux2_hdr->select_value_stride + sel_val2;
#line 2705
  i = i + 1U;
  ldv_66750: ;
#line 2705
  if (rdmux2_hdr->op_count > i) {
#line 2707
    goto ldv_66749;
  } else {

  }
#line 2728
  *d_ptr = data_ptr;
#line 2729
  return;
}
}
#line 2732 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static uint32_t qla8044_minidump_process_pollrdmwr(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                                   uint32_t **d_ptr ) 
{ 
  uint32_t poll_wait___0 ;
  uint32_t poll_mask ;
  uint32_t r_value ;
  uint32_t data ;
  uint32_t addr_1 ;
  uint32_t addr_2 ;
  uint32_t value_1 ;
  uint32_t value_2 ;
  struct qla8044_minidump_entry_pollrdmwr *poll_hdr ;
  uint32_t *data_ptr ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;

  {
#line 2739
  data_ptr = *d_ptr;
#line 2741
  poll_hdr = (struct qla8044_minidump_entry_pollrdmwr *)entry_hdr;
#line 2742
  addr_1 = poll_hdr->addr_1;
#line 2743
  addr_2 = poll_hdr->addr_2;
#line 2744
  value_1 = poll_hdr->value_1;
#line 2745
  value_2 = poll_hdr->value_2;
#line 2746
  poll_mask = poll_hdr->poll_mask;
#line 2748
  qla8044_wr_reg_indirect(vha, addr_1, value_1);
#line 2750
  poll_wait___0 = poll_hdr->poll_wait;
  ldv_66770: 
#line 2752
  qla8044_rd_reg_indirect(vha, addr_1, & r_value);
#line 2754
  if ((r_value & poll_mask) != 0U) {
#line 2755
    goto ldv_66767;
  } else {
#line 2757
    usleep_range(1000UL, 1100UL);
#line 2758
    poll_wait___0 = poll_wait___0 - 1U;
#line 2758
    if (poll_wait___0 == 0U) {
#line 2759
      ql_log(0U, vha, 45311, "%s: TIMEOUT\n", "qla8044_minidump_process_pollrdmwr");
#line 2761
      goto error;
    } else {

    }
  }
#line 2764
  goto ldv_66770;
  ldv_66767: 
#line 2766
  qla8044_rd_reg_indirect(vha, addr_2, & data);
#line 2767
  data = poll_hdr->modify_mask & data;
#line 2768
  qla8044_wr_reg_indirect(vha, addr_2, data);
#line 2769
  qla8044_wr_reg_indirect(vha, addr_1, value_2);
#line 2771
  poll_wait___0 = poll_hdr->poll_wait;
  ldv_66772: 
#line 2773
  qla8044_rd_reg_indirect(vha, addr_1, & r_value);
#line 2775
  if ((r_value & poll_mask) != 0U) {
#line 2776
    goto ldv_66771;
  } else {
#line 2778
    usleep_range(1000UL, 1100UL);
#line 2779
    poll_wait___0 = poll_wait___0 - 1U;
#line 2779
    if (poll_wait___0 == 0U) {
#line 2780
      ql_log(0U, vha, 45312, "%s: TIMEOUT2\n", "qla8044_minidump_process_pollrdmwr");
#line 2782
      goto error;
    } else {

    }
  }
#line 2785
  goto ldv_66772;
  ldv_66771: 
#line 2787
  tmp = data_ptr;
#line 2787
  data_ptr = data_ptr + 1;
#line 2787
  *tmp = addr_2;
#line 2788
  tmp___0 = data_ptr;
#line 2788
  data_ptr = data_ptr + 1;
#line 2788
  *tmp___0 = data;
#line 2790
  *d_ptr = data_ptr;
#line 2792
  return (0U);
  error: ;
#line 2795
  return (258U);
}
}
#line 2809 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_check_dma_engine_state(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  int rval ;
  uint32_t dma_eng_num ;
  uint32_t cmd_sts_and_cntrl ;
  uint64_t dma_base_addr ;
  struct qla8044_minidump_template_hdr *tmplt_hdr ;

  {
#line 2811
  ha = vha->hw;
#line 2812
  rval = 0;
#line 2813
  dma_eng_num = 0U;
#line 2813
  cmd_sts_and_cntrl = 0U;
#line 2814
  dma_base_addr = 0ULL;
#line 2815
  tmplt_hdr = (struct qla8044_minidump_template_hdr *)0;
#line 2817
  tmplt_hdr = (struct qla8044_minidump_template_hdr *)ha->md_tmplt_hdr;
#line 2818
  dma_eng_num = tmplt_hdr->saved_state_array[8];
#line 2820
  dma_base_addr = (uint64_t )((dma_eng_num + 30514U) * 65536U);
#line 2824
  rval = qla8044_rd_reg_indirect(vha, (uint32_t )dma_base_addr + 8U, & cmd_sts_and_cntrl);
#line 2827
  if (rval != 0) {
#line 2828
    return (258);
  } else {

  }
#line 2831
  if ((int )cmd_sts_and_cntrl < 0) {
#line 2832
    return (0);
  } else {

  }
#line 2834
  return (258);
}
}
#line 2838 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_start_pex_dma(struct scsi_qla_host *vha , struct qla8044_minidump_entry_rdmem_pex_dma *m_hdr ) 
{ 
  struct qla_hw_data *ha ;
  int rval ;
  int wait ;
  uint32_t dma_eng_num ;
  uint32_t cmd_sts_and_cntrl ;
  uint64_t dma_base_addr ;
  struct qla8044_minidump_template_hdr *tmplt_hdr ;

  {
#line 2841
  ha = vha->hw;
#line 2842
  rval = 0;
#line 2842
  wait = 0;
#line 2843
  dma_eng_num = 0U;
#line 2843
  cmd_sts_and_cntrl = 0U;
#line 2844
  dma_base_addr = 0ULL;
#line 2845
  tmplt_hdr = (struct qla8044_minidump_template_hdr *)0;
#line 2847
  tmplt_hdr = (struct qla8044_minidump_template_hdr *)ha->md_tmplt_hdr;
#line 2848
  dma_eng_num = tmplt_hdr->saved_state_array[8];
#line 2850
  dma_base_addr = (uint64_t )((dma_eng_num + 30514U) * 65536U);
#line 2853
  rval = qla8044_wr_reg_indirect(vha, (uint32_t )dma_base_addr, m_hdr->desc_card_addr);
#line 2856
  if (rval != 0) {
#line 2857
    goto error_exit;
  } else {

  }
#line 2859
  rval = qla8044_wr_reg_indirect(vha, (uint32_t )dma_base_addr + 4U, 0U);
#line 2861
  if (rval != 0) {
#line 2862
    goto error_exit;
  } else {

  }
#line 2864
  rval = qla8044_wr_reg_indirect(vha, (uint32_t )dma_base_addr + 8U, m_hdr->start_dma_cmd);
#line 2867
  if (rval != 0) {
#line 2868
    goto error_exit;
  } else {

  }
#line 2871
  wait = 0;
#line 2871
  goto ldv_66796;
  ldv_66795: 
#line 2872
  rval = qla8044_rd_reg_indirect(vha, (uint32_t )dma_base_addr + 8U, & cmd_sts_and_cntrl);
#line 2875
  if (rval != 0) {
#line 2876
    goto error_exit;
  } else {

  }
#line 2878
  if ((cmd_sts_and_cntrl & 2U) == 0U) {
#line 2879
    goto ldv_66794;
  } else {

  }
#line 2881
  __const_udelay(42950UL);
#line 2871
  wait = wait + 1;
  ldv_66796: ;
#line 2871
  if (wait <= 9999) {
#line 2873
    goto ldv_66795;
  } else {

  }
  ldv_66794: ;
#line 2885
  if (wait > 9999) {
#line 2886
    rval = 258;
#line 2887
    goto error_exit;
  } else {

  }
  error_exit: ;
#line 2891
  return (rval);
}
}
#line 2895 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_minidump_pex_dma_read(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                         uint32_t **d_ptr ) 
{ 
  struct qla_hw_data *ha ;
  int rval ;
  struct qla8044_minidump_entry_rdmem_pex_dma *m_hdr ;
  uint32_t chunk_size ;
  uint32_t read_size ;
  uint8_t *data_ptr ;
  void *rdmem_buffer ;
  dma_addr_t rdmem_dma ;
  struct qla8044_pex_dma_descriptor dma_desc ;

  {
#line 2898
  ha = vha->hw;
#line 2899
  rval = 0;
#line 2900
  m_hdr = (struct qla8044_minidump_entry_rdmem_pex_dma *)0;
#line 2902
  data_ptr = (uint8_t *)*d_ptr;
#line 2903
  rdmem_buffer = (void *)0;
#line 2907
  rval = qla8044_check_dma_engine_state(vha);
#line 2908
  if (rval != 0) {
#line 2909
    ql_dbg(524288U, vha, 45383, "DMA engine not available. Fallback to rdmem-read.\n");
#line 2911
    return (258);
  } else {

  }
#line 2914
  m_hdr = (struct qla8044_minidump_entry_rdmem_pex_dma *)entry_hdr;
#line 2916
  rdmem_buffer = dma_alloc_attrs(& (ha->pdev)->dev, 16384UL, & rdmem_dma, 208U, (struct dma_attrs *)0);
#line 2918
  if ((unsigned long )rdmem_buffer == (unsigned long )((void *)0)) {
#line 2919
    ql_dbg(524288U, vha, 45384, "Unable to allocate rdmem dma buffer\n");
#line 2921
    return (258);
  } else {

  }
#line 2932
  dma_desc.cmd.dma_desc_cmd = (unsigned int )m_hdr->dma_desc_cmd & 65295U;
#line 2933
  dma_desc.cmd.dma_desc_cmd = (unsigned int )dma_desc.cmd.dma_desc_cmd | (((unsigned int )((uint16_t )(ha->pdev)->devfn) & 7U) << 4U);
#line 2936
  dma_desc.dma_bus_addr = rdmem_dma;
#line 2937
  chunk_size = 16384U;
#line 2937
  dma_desc.cmd.read_data_size = chunk_size;
#line 2938
  read_size = 0U;
#line 2944
  goto ldv_66814;
  ldv_66813: ;
#line 2945
  if (m_hdr->read_data_size - read_size <= 16383U) {
#line 2947
    chunk_size = m_hdr->read_data_size - read_size;
#line 2948
    dma_desc.cmd.read_data_size = chunk_size;
  } else {

  }
#line 2951
  dma_desc.src_addr = (uint64_t )(m_hdr->read_addr + read_size);
#line 2954
  rval = qla8044_ms_mem_write_128b(vha, (uint64_t )m_hdr->desc_card_addr, (uint32_t *)(& dma_desc),
                                   3U);
#line 2957
  if (rval != 0) {
#line 2958
    ql_log(1U, vha, 45386, "%s: Error writing rdmem-dma-init to MS !!!\n", "qla8044_minidump_pex_dma_read");
#line 2961
    goto error_exit;
  } else {

  }
#line 2963
  ql_dbg(524288U, vha, 45387, "%s: Dma-descriptor: Instruct for rdmem dma (chunk_size 0x%x).\n",
         "qla8044_minidump_pex_dma_read", chunk_size);
#line 2968
  rval = qla8044_start_pex_dma(vha, m_hdr);
#line 2969
  if (rval != 0) {
#line 2970
    goto error_exit;
  } else {

  }
#line 2972
  memcpy((void *)data_ptr, (void const   *)rdmem_buffer, (size_t )chunk_size);
#line 2973
  data_ptr = data_ptr + (unsigned long )chunk_size;
#line 2974
  read_size = read_size + chunk_size;
  ldv_66814: ;
#line 2944
  if (m_hdr->read_data_size > read_size) {
#line 2946
    goto ldv_66813;
  } else {

  }
#line 2977
  *d_ptr = (uint32_t *)data_ptr;
  error_exit: ;
#line 2980
  if ((unsigned long )rdmem_buffer != (unsigned long )((void *)0)) {
#line 2981
    dma_free_attrs(& (ha->pdev)->dev, 16384UL, rdmem_buffer, rdmem_dma, (struct dma_attrs *)0);
  } else {

  }
#line 2984
  return (rval);
}
}
#line 2988 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static uint32_t qla8044_minidump_process_rddfe(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                               uint32_t **d_ptr ) 
{ 
  int loop_cnt ;
  uint32_t addr1 ;
  uint32_t addr2 ;
  uint32_t value ;
  uint32_t data ;
  uint32_t temp ;
  uint32_t wrVal ;
  uint8_t stride ;
  uint8_t stride2 ;
  uint16_t count ;
  uint32_t poll ;
  uint32_t mask ;
  uint32_t data_size ;
  uint32_t modify_mask ;
  uint32_t wait_count ;
  uint32_t *data_ptr ;
  struct qla8044_minidump_entry_rddfe *rddfe ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;

  {
#line 2996
  wait_count = 0U;
#line 2998
  data_ptr = *d_ptr;
#line 3001
  rddfe = (struct qla8044_minidump_entry_rddfe *)entry_hdr;
#line 3003
  addr1 = rddfe->addr_1;
#line 3004
  value = rddfe->value;
#line 3005
  stride = rddfe->stride;
#line 3006
  stride2 = rddfe->stride2;
#line 3007
  count = rddfe->count;
#line 3009
  poll = rddfe->poll;
#line 3010
  mask = rddfe->mask;
#line 3011
  modify_mask = rddfe->modify_mask;
#line 3012
  data_size = rddfe->data_size;
#line 3014
  addr2 = (uint32_t )stride + addr1;
#line 3016
  loop_cnt = 0;
#line 3016
  goto ldv_66850;
  ldv_66849: 
#line 3017
  qla8044_wr_reg_indirect(vha, addr1, value | 1073741824U);
#line 3019
  wait_count = 0U;
#line 3020
  goto ldv_66840;
  ldv_66839: 
#line 3021
  qla8044_rd_reg_indirect(vha, addr1, & temp);
#line 3022
  if ((temp & mask) != 0U) {
#line 3023
    goto ldv_66838;
  } else {

  }
#line 3024
  wait_count = wait_count + 1U;
  ldv_66840: ;
#line 3020
  if (wait_count < poll) {
#line 3022
    goto ldv_66839;
  } else {

  }
  ldv_66838: ;
#line 3027
  if (wait_count == poll) {
#line 3028
    ql_log(1U, vha, 45395, "%s: TIMEOUT\n", "qla8044_minidump_process_rddfe");
#line 3030
    goto error;
  } else {
#line 3032
    qla8044_rd_reg_indirect(vha, addr2, & temp);
#line 3033
    temp = temp & modify_mask;
#line 3034
    temp = (uint32_t )((loop_cnt << 16) | loop_cnt) | temp;
#line 3035
    wrVal = (temp << 16) | temp;
#line 3037
    qla8044_wr_reg_indirect(vha, addr2, wrVal);
#line 3038
    qla8044_wr_reg_indirect(vha, addr1, value);
#line 3040
    wait_count = 0U;
#line 3041
    goto ldv_66845;
    ldv_66844: 
#line 3042
    qla8044_rd_reg_indirect(vha, addr1, & temp);
#line 3043
    if ((temp & mask) != 0U) {
#line 3044
      goto ldv_66843;
    } else {

    }
#line 3045
    wait_count = wait_count + 1U;
    ldv_66845: ;
#line 3041
    if (wait_count < poll) {
#line 3043
      goto ldv_66844;
    } else {

    }
    ldv_66843: ;
#line 3047
    if (wait_count == poll) {
#line 3048
      ql_log(1U, vha, 45396, "%s: TIMEOUT\n", "qla8044_minidump_process_rddfe");
#line 3050
      goto error;
    } else {

    }
#line 3053
    qla8044_wr_reg_indirect(vha, addr1, (value | 1073741824U) + (uint32_t )stride2);
#line 3055
    wait_count = 0U;
#line 3056
    goto ldv_66848;
    ldv_66847: 
#line 3057
    qla8044_rd_reg_indirect(vha, addr1, & temp);
#line 3058
    if ((temp & mask) != 0U) {
#line 3059
      goto ldv_66846;
    } else {

    }
#line 3060
    wait_count = wait_count + 1U;
    ldv_66848: ;
#line 3056
    if (wait_count < poll) {
#line 3058
      goto ldv_66847;
    } else {

    }
    ldv_66846: ;
#line 3063
    if (wait_count == poll) {
#line 3064
      ql_log(1U, vha, 45397, "%s: TIMEOUT\n", "qla8044_minidump_process_rddfe");
#line 3066
      goto error;
    } else {

    }
#line 3069
    qla8044_rd_reg_indirect(vha, addr2, & data);
#line 3071
    tmp = data_ptr;
#line 3071
    data_ptr = data_ptr + 1;
#line 3071
    *tmp = wrVal;
#line 3072
    tmp___0 = data_ptr;
#line 3072
    data_ptr = data_ptr + 1;
#line 3072
    *tmp___0 = data;
  }
#line 3016
  loop_cnt = loop_cnt + 1;
  ldv_66850: ;
#line 3016
  if ((int )count > loop_cnt) {
#line 3018
    goto ldv_66849;
  } else {

  }
#line 3077
  *d_ptr = data_ptr;
#line 3078
  return (0U);
  error: ;
#line 3081
  return (4294967295U);
}
}
#line 3086 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static uint32_t qla8044_minidump_process_rdmdio(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                                uint32_t **d_ptr ) 
{ 
  int ret ;
  uint32_t addr1 ;
  uint32_t addr2 ;
  uint32_t value1 ;
  uint32_t value2 ;
  uint32_t data ;
  uint32_t selVal ;
  uint8_t stride1 ;
  uint8_t stride2 ;
  uint32_t addr3 ;
  uint32_t addr4 ;
  uint32_t addr5 ;
  uint32_t addr6 ;
  uint32_t addr7 ;
  uint16_t count ;
  uint16_t loop_cnt ;
  uint32_t poll ;
  uint32_t mask ;
  uint32_t *data_ptr ;
  struct qla8044_minidump_entry_rdmdio *rdmdio ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;

  {
#line 3089
  ret = 0;
#line 3095
  data_ptr = *d_ptr;
#line 3099
  rdmdio = (struct qla8044_minidump_entry_rdmdio *)entry_hdr;
#line 3101
  addr1 = rdmdio->addr_1;
#line 3102
  addr2 = rdmdio->addr_2;
#line 3103
  value1 = rdmdio->value_1;
#line 3104
  stride1 = rdmdio->stride_1;
#line 3105
  stride2 = rdmdio->stride_2;
#line 3106
  count = rdmdio->count;
#line 3108
  poll = rdmdio->poll;
#line 3109
  mask = rdmdio->mask;
#line 3110
  value2 = rdmdio->value_2;
#line 3112
  addr3 = (uint32_t )stride1 + addr1;
#line 3114
  loop_cnt = 0U;
#line 3114
  goto ldv_66879;
  ldv_66878: 
#line 3115
  ret = qla8044_poll_wait_ipmdio_bus_idle(vha, addr1, addr2, addr3, mask);
#line 3117
  if (ret == -1) {
#line 3118
    goto error;
  } else {

  }
#line 3120
  addr4 = addr2 - (uint32_t )stride1;
#line 3121
  ret = qla8044_ipmdio_wr_reg(vha, addr1, addr3, mask, addr4, value2);
#line 3123
  if (ret == -1) {
#line 3124
    goto error;
  } else {

  }
#line 3126
  addr5 = (uint32_t )((int )stride1 * -2) + addr2;
#line 3127
  ret = qla8044_ipmdio_wr_reg(vha, addr1, addr3, mask, addr5, value1);
#line 3129
  if (ret == -1) {
#line 3130
    goto error;
  } else {

  }
#line 3132
  addr6 = (uint32_t )((int )stride1 * -3) + addr2;
#line 3133
  ret = qla8044_ipmdio_wr_reg(vha, addr1, addr3, mask, addr6, 2U);
#line 3135
  if (ret == -1) {
#line 3136
    goto error;
  } else {

  }
#line 3138
  ret = qla8044_poll_wait_ipmdio_bus_idle(vha, addr1, addr2, addr3, mask);
#line 3140
  if (ret == -1) {
#line 3141
    goto error;
  } else {

  }
#line 3143
  addr7 = (uint32_t )((int )stride1 * -4) + addr2;
#line 3144
  data = qla8044_ipmdio_rd_reg(vha, addr1, addr3, mask, addr7);
#line 3145
  if (data == 4294967295U) {
#line 3146
    goto error;
  } else {

  }
#line 3148
  selVal = ((value2 << 18) | (value1 << 2)) | 2U;
#line 3150
  stride2 = rdmdio->stride_2;
#line 3151
  tmp = data_ptr;
#line 3151
  data_ptr = data_ptr + 1;
#line 3151
  *tmp = selVal;
#line 3152
  tmp___0 = data_ptr;
#line 3152
  data_ptr = data_ptr + 1;
#line 3152
  *tmp___0 = data;
#line 3154
  value1 = (uint32_t )stride2 + value1;
#line 3155
  *d_ptr = data_ptr;
#line 3114
  loop_cnt = (uint16_t )((int )loop_cnt + 1);
  ldv_66879: ;
#line 3114
  if ((int )loop_cnt < (int )count) {
#line 3116
    goto ldv_66878;
  } else {

  }

#line 3158
  return (0U);
  error: ;
#line 3161
  return (4294967295U);
}
}
#line 3164 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static uint32_t qla8044_minidump_process_pollwr(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                                uint32_t **d_ptr ) 
{ 
  uint32_t addr1 ;
  uint32_t addr2 ;
  uint32_t value1 ;
  uint32_t value2 ;
  uint32_t poll ;
  uint32_t mask ;
  uint32_t r_value ;
  uint32_t wait_count ;
  struct qla8044_minidump_entry_pollwr *pollwr_hdr ;

  {
#line 3168
  wait_count = 0U;
#line 3171
  pollwr_hdr = (struct qla8044_minidump_entry_pollwr *)entry_hdr;
#line 3172
  addr1 = pollwr_hdr->addr_1;
#line 3173
  addr2 = pollwr_hdr->addr_2;
#line 3174
  value1 = pollwr_hdr->value_1;
#line 3175
  value2 = pollwr_hdr->value_2;
#line 3177
  poll = pollwr_hdr->poll;
#line 3178
  mask = pollwr_hdr->mask;
#line 3180
  goto ldv_66897;
  ldv_66896: 
#line 3181
  qla8044_rd_reg_indirect(vha, addr1, & r_value);
#line 3183
  if ((r_value & poll) != 0U) {
#line 3184
    goto ldv_66895;
  } else {

  }
#line 3185
  wait_count = wait_count + 1U;
  ldv_66897: ;
#line 3180
  if (wait_count < poll) {
#line 3182
    goto ldv_66896;
  } else {

  }
  ldv_66895: ;
#line 3188
  if (wait_count == poll) {
#line 3189
    ql_log(1U, vha, 45398, "%s: TIMEOUT\n", "qla8044_minidump_process_pollwr");
#line 3190
    goto error;
  } else {

  }
#line 3193
  qla8044_wr_reg_indirect(vha, addr2, value2);
#line 3194
  qla8044_wr_reg_indirect(vha, addr1, value1);
#line 3196
  wait_count = 0U;
#line 3197
  goto ldv_66902;
  ldv_66901: 
#line 3198
  qla8044_rd_reg_indirect(vha, addr1, & r_value);
#line 3200
  if ((r_value & poll) != 0U) {
#line 3201
    goto ldv_66900;
  } else {

  }
#line 3202
  wait_count = wait_count + 1U;
  ldv_66902: ;
#line 3197
  if (wait_count < poll) {
#line 3199
    goto ldv_66901;
  } else {

  }
  ldv_66900: ;
#line 3205
  return (0U);
  error: ;
#line 3208
  return (4294967295U);
}
}
#line 3217 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
int qla8044_collect_md_data(struct scsi_qla_host *vha ) 
{ 
  int num_entry_hdr ;
  struct qla8044_minidump_entry_hdr *entry_hdr ;
  struct qla8044_minidump_template_hdr *tmplt_hdr ;
  uint32_t *data_ptr ;
  uint32_t data_collected ;
  uint32_t f_capture_mask ;
  int i ;
  int rval ;
  uint64_t now ;
  uint32_t timestamp ;
  uint32_t idc_control ;
  struct qla_hw_data *ha ;
  int tmp ;
  unsigned int tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;

  {
#line 3219
  num_entry_hdr = 0;
#line 3223
  data_collected = 0U;
#line 3224
  rval = 258;
#line 3227
  ha = vha->hw;
#line 3229
  if ((unsigned long )ha->md_dump == (unsigned long )((void *)0)) {
#line 3230
    ql_log(2U, vha, 45313, "%s(%ld) No buffer to dump\n", "qla8044_collect_md_data",
           vha->host_no);
#line 3233
    return (rval);
  } else {

  }
#line 3236
  if (ha->fw_dumped != 0) {
#line 3237
    ql_log(1U, vha, 45325, "Firmware has been previously dumped (%p) -- ignoring request.\n",
           ha->fw_dump);
#line 3240
    goto md_failed;
  } else {

  }
#line 3243
  ha->fw_dumped = 0;
#line 3245
  if ((unsigned long )ha->md_tmplt_hdr == (unsigned long )((void *)0) || (unsigned long )ha->md_dump == (unsigned long )((void *)0)) {
#line 3246
    ql_log(1U, vha, 45326, "Memory not allocated for minidump capture\n");
#line 3248
    goto md_failed;
  } else {

  }
#line 3251
  qla8044_idc_lock(ha);
#line 3252
  idc_control = qla8044_rd_reg(ha, 14224UL);
#line 3253
  if ((idc_control & 2U) != 0U) {
#line 3254
    ql_log(1U, vha, 45330, "Forced reset from application, ignore minidump capture\n");
#line 3257
    qla8044_wr_reg(ha, 14224UL, idc_control & 4294967293U);
#line 3259
    qla8044_idc_unlock(ha);
#line 3261
    goto md_failed;
  } else {

  }
#line 3263
  qla8044_idc_unlock(ha);
#line 3265
  tmp = qla82xx_validate_template_chksum(vha);
#line 3265
  if (tmp != 0) {
#line 3266
    ql_log(2U, vha, 45321, "Template checksum validation error\n");
#line 3268
    goto md_failed;
  } else {

  }
#line 3271
  tmplt_hdr = (struct qla8044_minidump_template_hdr *)ha->md_tmplt_hdr;
#line 3273
  data_ptr = (uint32_t *)ha->md_dump;
#line 3274
  num_entry_hdr = (int )tmplt_hdr->num_of_entries;
#line 3276
  ql_dbg(524288U, vha, 45338, "Capture Mask obtained: 0x%x\n", tmplt_hdr->capture_debug_level);
#line 3279
  f_capture_mask = tmplt_hdr->capture_debug_level & 255U;
#line 3282
  if ((f_capture_mask & 3U) != 3U) {
#line 3283
    ql_log(1U, vha, 45327, "Minimum required capture mask[0x%x] level not set\n",
           f_capture_mask);
  } else {

  }
#line 3288
  tmplt_hdr->driver_capture_mask = (uint32_t )ql2xmdcapmask;
#line 3289
  ql_log(2U, vha, 45314, "[%s]: starting data ptr: %p\n", "qla8044_collect_md_data",
         data_ptr);
#line 3292
  ql_log(2U, vha, 45323, "[%s]: no of entry headers in Template: 0x%x\n", "qla8044_collect_md_data",
         num_entry_hdr);
#line 3295
  ql_log(2U, vha, 45324, "[%s]: Total_data_size 0x%x, %d obtained\n", "qla8044_collect_md_data",
         ha->md_dump_size, ha->md_dump_size);
#line 3300
  now = get_jiffies_64();
#line 3301
  tmp___0 = jiffies_to_msecs((unsigned long const   )now);
#line 3301
  timestamp = tmp___0 / 1000U;
#line 3302
  tmplt_hdr->driver_timestamp = timestamp;
#line 3304
  entry_hdr = (struct qla8044_minidump_entry_hdr *)ha->md_tmplt_hdr + (unsigned long )tmplt_hdr->first_entry_offset;
#line 3306
  tmplt_hdr->saved_state_array[3] = tmplt_hdr->ocm_window_reg[(int )ha->portnum];
#line 3310
  i = 0;
#line 3310
  goto ldv_66948;
  ldv_66947: ;
#line 3311
  if (ha->md_dump_size < data_collected) {
#line 3312
    ql_log(2U, vha, 45315, "Data collected: [0x%x], Total Dump size: [0x%x]\n", data_collected,
           ha->md_dump_size);
#line 3316
    return (rval);
  } else {

  }
#line 3319
  if (((int )entry_hdr->d_ctrl.entry_capture_mask & ql2xmdcapmask) == 0) {
#line 3321
    entry_hdr->d_ctrl.driver_flags = (uint8_t )((unsigned int )entry_hdr->d_ctrl.driver_flags | 128U);
#line 3323
    goto skip_nxt_entry;
  } else {

  }
#line 3326
  ql_dbg(524288U, vha, 45316, "Data collected: [0x%x], Dump size left:[0x%x]\n", data_collected,
         ha->md_dump_size - data_collected);
#line 3334
  switch (entry_hdr->entry_type) {
  case 255U: 
#line 3336
  qla8044_mark_entry_skipped(vha, entry_hdr, i);
#line 3337
  goto ldv_66922;
  case 98U: 
#line 3339
  rval = qla8044_minidump_process_control(vha, entry_hdr);
#line 3341
  if (rval != 0) {
#line 3342
    qla8044_mark_entry_skipped(vha, entry_hdr, i);
#line 3343
    goto md_failed;
  } else {

  }
#line 3345
  goto ldv_66922;
  case 1U: 
#line 3347
  qla8044_minidump_process_rdcrb(vha, entry_hdr, & data_ptr);
#line 3349
  goto ldv_66922;
  case 72U: 
#line 3351
  rval = qla8044_minidump_pex_dma_read(vha, entry_hdr, & data_ptr);
#line 3353
  if (rval != 0) {
#line 3354
    rval = qla8044_minidump_process_rdmem(vha, entry_hdr, & data_ptr);
#line 3356
    if (rval != 0) {
#line 3357
      qla8044_mark_entry_skipped(vha, entry_hdr, i);
#line 3359
      goto md_failed;
    } else {

    }
  } else {

  }
#line 3362
  goto ldv_66922;
  case 4U: ;
  case 71U: 
#line 3365
  tmp___1 = qla8044_minidump_process_rdrom(vha, entry_hdr, & data_ptr);
#line 3365
  rval = (int )tmp___1;
#line 3367
  if (rval != 0) {
#line 3368
    qla8044_mark_entry_skipped(vha, entry_hdr, i);
  } else {

  }
#line 3371
  goto ldv_66922;
  case 21U: ;
  case 22U: ;
  case 23U: ;
  case 24U: 
#line 3376
  rval = qla8044_minidump_process_l2tag(vha, entry_hdr, & data_ptr);
#line 3378
  if (rval != 0) {
#line 3379
    qla8044_mark_entry_skipped(vha, entry_hdr, i);
#line 3380
    goto md_failed;
  } else {

  }
#line 3382
  goto ldv_66922;
  case 8U: ;
  case 9U: ;
  case 11U: ;
  case 12U: 
#line 3387
  qla8044_minidump_process_l1cache(vha, entry_hdr, & data_ptr);
#line 3389
  goto ldv_66922;
  case 6U: 
#line 3391
  qla8044_minidump_process_rdocm(vha, entry_hdr, & data_ptr);
#line 3393
  goto ldv_66922;
  case 2U: 
#line 3395
  qla8044_minidump_process_rdmux(vha, entry_hdr, & data_ptr);
#line 3397
  goto ldv_66922;
  case 3U: 
#line 3399
  qla8044_minidump_process_queue(vha, entry_hdr, & data_ptr);
#line 3401
  goto ldv_66922;
  case 35U: 
#line 3403
  tmp___2 = qla8044_minidump_process_pollrd(vha, entry_hdr, & data_ptr);
#line 3403
  rval = (int )tmp___2;
#line 3405
  if (rval != 0) {
#line 3406
    qla8044_mark_entry_skipped(vha, entry_hdr, i);
  } else {

  }
#line 3407
  goto ldv_66922;
  case 36U: 
#line 3409
  qla8044_minidump_process_rdmux2(vha, entry_hdr, & data_ptr);
#line 3411
  goto ldv_66922;
  case 37U: 
#line 3413
  tmp___3 = qla8044_minidump_process_pollrdmwr(vha, entry_hdr, & data_ptr);
#line 3413
  rval = (int )tmp___3;
#line 3415
  if (rval != 0) {
#line 3416
    qla8044_mark_entry_skipped(vha, entry_hdr, i);
  } else {

  }
#line 3417
  goto ldv_66922;
  case 38U: 
#line 3419
  tmp___4 = qla8044_minidump_process_rddfe(vha, entry_hdr, & data_ptr);
#line 3419
  rval = (int )tmp___4;
#line 3421
  if (rval != 0) {
#line 3422
    qla8044_mark_entry_skipped(vha, entry_hdr, i);
  } else {

  }
#line 3423
  goto ldv_66922;
  case 39U: 
#line 3425
  tmp___5 = qla8044_minidump_process_rdmdio(vha, entry_hdr, & data_ptr);
#line 3425
  rval = (int )tmp___5;
#line 3427
  if (rval != 0) {
#line 3428
    qla8044_mark_entry_skipped(vha, entry_hdr, i);
  } else {

  }
#line 3429
  goto ldv_66922;
  case 40U: 
#line 3431
  tmp___6 = qla8044_minidump_process_pollwr(vha, entry_hdr, & data_ptr);
#line 3431
  rval = (int )tmp___6;
#line 3433
  if (rval != 0) {
#line 3434
    qla8044_mark_entry_skipped(vha, entry_hdr, i);
  } else {

  }
#line 3435
  goto ldv_66922;
  case 0U: ;
  default: 
#line 3438
  qla8044_mark_entry_skipped(vha, entry_hdr, i);
#line 3439
  goto ldv_66922;
  }
  ldv_66922: 
#line 3442
  data_collected = (uint32_t )((long )data_ptr) - (uint32_t )((long )ha->md_dump);
  skip_nxt_entry: 
#line 3448
  entry_hdr = entry_hdr + (unsigned long )entry_hdr->entry_size;
#line 3310
  i = i + 1;
  ldv_66948: ;
#line 3310
  if (i < num_entry_hdr) {
#line 3312
    goto ldv_66947;
  } else {

  }

#line 3452
  if (ha->md_dump_size != data_collected) {
#line 3453
    ql_log(2U, vha, 45317, "Dump data mismatch: Data collected: [0x%x], total_data_size:[0x%x]\n",
           data_collected, ha->md_dump_size);
#line 3457
    rval = 258;
#line 3458
    goto md_failed;
  } else {

  }
#line 3461
  ql_log(2U, vha, 45328, "Firmware dump saved to temp buffer (%ld/%p %ld/%p).\n",
         vha->host_no, ha->md_tmplt_hdr, vha->host_no, ha->md_dump);
#line 3464
  ha->fw_dumped = 1;
#line 3465
  qla2x00_post_uevent_work(vha, 0U);
#line 3468
  ql_log(2U, vha, 45318, "Leaving fn: %s Last entry: 0x%x\n", "qla8044_collect_md_data",
         i);
  md_failed: ;
#line 3472
  return (rval);
}
}
#line 3476 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
void qla8044_get_minidump(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 3478
  ha = vha->hw;
#line 3480
  tmp = qla8044_collect_md_data(vha);
#line 3480
  if (tmp == 0) {
#line 3481
    ha->fw_dumped = 1;
#line 3482
    ha->prev_minidump_failed = 0;
  } else {
#line 3484
    ql_log(0U, vha, 45275, "%s: Unable to collect minidump\n", "qla8044_get_minidump");
#line 3487
    ha->prev_minidump_failed = 1;
  }
#line 3489
  return;
}
}
#line 3492 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_poll_flash_status_reg(struct scsi_qla_host *vha ) 
{ 
  uint32_t flash_status ;
  int retries ;
  int ret_val ;
  int tmp ;

  {
#line 3495
  retries = 2000;
#line 3496
  ret_val = 0;
#line 3498
  goto ldv_66964;
  ldv_66963: 
#line 3499
  ret_val = qla8044_rd_reg_indirect(vha, 1108344836U, & flash_status);
#line 3501
  if (ret_val != 0) {
#line 3502
    ql_log(1U, vha, 45372, "%s: Failed to read FLASH_STATUS reg.\n", "qla8044_poll_flash_status_reg");
#line 3505
    goto ldv_66962;
  } else {

  }
#line 3507
  if ((flash_status & 6U) == 6U) {
#line 3509
    goto ldv_66962;
  } else {

  }
#line 3510
  msleep(1U);
  ldv_66964: 
#line 3498
  tmp = retries;
#line 3498
  retries = retries - 1;
#line 3498
  if (tmp != 0) {
#line 3500
    goto ldv_66963;
  } else {

  }
  ldv_66962: ;
#line 3513
  if (retries == 0) {
#line 3514
    ret_val = 258;
  } else {

  }
#line 3516
  return (ret_val);
}
}
#line 3520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_write_flash_status_reg(struct scsi_qla_host *vha , uint32_t data ) 
{ 
  int ret_val ;
  uint32_t cmd ;

  {
#line 3523
  ret_val = 0;
#line 3526
  cmd = (vha->hw)->fdt_wrt_sts_reg_cmd;
#line 3528
  ret_val = qla8044_wr_reg_indirect(vha, 1108410376U, cmd | 16580864U);
#line 3530
  if (ret_val != 0) {
#line 3531
    ql_log(1U, vha, 45349, "%s: Failed to write to FLASH_ADDR.\n", "qla8044_write_flash_status_reg");
#line 3533
    goto exit_func;
  } else {

  }
#line 3536
  ret_val = qla8044_wr_reg_indirect(vha, 1108410380U, data);
#line 3537
  if (ret_val != 0) {
#line 3538
    ql_log(1U, vha, 45350, "%s: Failed to write to FLASH_WRDATA.\n", "qla8044_write_flash_status_reg");
#line 3540
    goto exit_func;
  } else {

  }
#line 3543
  ret_val = qla8044_wr_reg_indirect(vha, 1108410372U, 5U);
#line 3545
  if (ret_val != 0) {
#line 3546
    ql_log(1U, vha, 45351, "%s: Failed to write to FLASH_CONTROL.\n", "qla8044_write_flash_status_reg");
#line 3548
    goto exit_func;
  } else {

  }
#line 3551
  ret_val = qla8044_poll_flash_status_reg(vha);
#line 3552
  if (ret_val != 0) {
#line 3553
    ql_log(1U, vha, 45352, "%s: Error polling flash status reg.\n", "qla8044_write_flash_status_reg");
  } else {

  }
  exit_func: ;
#line 3557
  return (ret_val);
}
}
#line 3564 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_unprotect_flash(scsi_qla_host_t *vha ) 
{ 
  int ret_val ;
  struct qla_hw_data *ha ;

  {
#line 3567
  ha = vha->hw;
#line 3569
  ret_val = qla8044_write_flash_status_reg(vha, ha->fdt_wrt_enable);
#line 3570
  if (ret_val != 0) {
#line 3571
    ql_log(1U, vha, 45369, "%s: Write flash status failed.\n", "qla8044_unprotect_flash");
  } else {

  }
#line 3574
  return (ret_val);
}
}
#line 3581 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_protect_flash(scsi_qla_host_t *vha ) 
{ 
  int ret_val ;
  struct qla_hw_data *ha ;

  {
#line 3584
  ha = vha->hw;
#line 3586
  ret_val = qla8044_write_flash_status_reg(vha, ha->fdt_wrt_disable);
#line 3587
  if (ret_val != 0) {
#line 3588
    ql_log(1U, vha, 45371, "%s: Write flash status failed.\n", "qla8044_protect_flash");
  } else {

  }
#line 3591
  return (ret_val);
}
}
#line 3596 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_erase_flash_sector(struct scsi_qla_host *vha , uint32_t sector_start_addr ) 
{ 
  uint32_t reversed_addr ;
  int ret_val ;

  {
#line 3600
  ret_val = 0;
#line 3602
  ret_val = qla8044_poll_flash_status_reg(vha);
#line 3603
  if (ret_val != 0) {
#line 3604
    ql_log(1U, vha, 45358, "%s: Poll flash status after erase failed..\n", "qla8044_erase_flash_sector");
  } else {

  }
#line 3608
  reversed_addr = (((sector_start_addr & 255U) << 16) | (sector_start_addr & 65280U)) | ((sector_start_addr & 16711680U) >> 16);
#line 3612
  ret_val = qla8044_wr_reg_indirect(vha, 1108410380U, reversed_addr);
#line 3614
  if (ret_val != 0) {
#line 3615
    ql_log(1U, vha, 45359, "%s: Failed to write to FLASH_WRDATA.\n", "qla8044_erase_flash_sector");
  } else {

  }
#line 3618
  ret_val = qla8044_wr_reg_indirect(vha, 1108410376U, (vha->hw)->fdt_erase_cmd | 16581376U);
#line 3620
  if (ret_val != 0) {
#line 3621
    ql_log(1U, vha, 45360, "%s: Failed to write to FLASH_ADDR.\n", "qla8044_erase_flash_sector");
  } else {

  }
#line 3624
  ret_val = qla8044_wr_reg_indirect(vha, 1108410372U, 61U);
#line 3626
  if (ret_val != 0) {
#line 3627
    ql_log(1U, vha, 45361, "%s: Failed write to FLASH_CONTROL.\n", "qla8044_erase_flash_sector");
  } else {

  }
#line 3630
  ret_val = qla8044_poll_flash_status_reg(vha);
#line 3631
  if (ret_val != 0) {
#line 3632
    ql_log(1U, vha, 45362, "%s: Poll flash status failed.\n", "qla8044_erase_flash_sector");
  } else {

  }
#line 3637
  return (ret_val);
}
}
#line 3652 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_flash_write_u32(struct scsi_qla_host *vha , uint32_t addr , uint32_t *p_data ) 
{ 
  int ret_val ;

  {
#line 3655
  ret_val = 0;
#line 3657
  ret_val = qla8044_wr_reg_indirect(vha, 1108410376U, (addr >> 2) | 8388608U);
#line 3659
  if (ret_val != 0) {
#line 3660
    ql_log(1U, vha, 45364, "%s: Failed write to FLASH_ADDR.\n", "qla8044_flash_write_u32");
#line 3662
    goto exit_func;
  } else {

  }
#line 3664
  ret_val = qla8044_wr_reg_indirect(vha, 1108410380U, *p_data);
#line 3665
  if (ret_val != 0) {
#line 3666
    ql_log(1U, vha, 45365, "%s: Failed write to FLASH_WRDATA.\n", "qla8044_flash_write_u32");
#line 3668
    goto exit_func;
  } else {

  }
#line 3670
  ret_val = qla8044_wr_reg_indirect(vha, 1108410372U, 61U);
#line 3671
  if (ret_val != 0) {
#line 3672
    ql_log(1U, vha, 45366, "%s: Failed write to FLASH_CONTROL.\n", "qla8044_flash_write_u32");
#line 3674
    goto exit_func;
  } else {

  }
#line 3676
  ret_val = qla8044_poll_flash_status_reg(vha);
#line 3677
  if (ret_val != 0) {
#line 3678
    ql_log(1U, vha, 45367, "%s: Poll flash status failed.\n", "qla8044_flash_write_u32");
  } else {

  }
  exit_func: ;
#line 3683
  return (ret_val);
}
}
#line 3687 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_write_flash_buffer_mode(scsi_qla_host_t *vha , uint32_t *dwptr ,
                                           uint32_t faddr , uint32_t dwords ) 
{ 
  int ret ;
  uint32_t spi_val ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;

  {
#line 3690
  ret = 258;
#line 3693
  if (dwords <= 1U || dwords > 64U) {
#line 3695
    ql_dbg(8388608U, vha, 45347, "Got unsupported dwords = 0x%x.\n", dwords);
#line 3698
    return (258);
  } else {

  }
#line 3701
  qla8044_rd_reg_indirect(vha, 671670292U, & spi_val);
#line 3702
  qla8044_wr_reg_indirect(vha, 671670292U, spi_val | 4U);
#line 3704
  qla8044_wr_reg_indirect(vha, 1108410376U, 8388608U);
#line 3708
  tmp = dwptr;
#line 3708
  dwptr = dwptr + 1;
#line 3708
  ret = qla8044_wr_reg_indirect(vha, 1108410380U, *tmp);
#line 3710
  qla8044_wr_reg_indirect(vha, 1108410372U, 67U);
#line 3713
  ret = qla8044_poll_flash_status_reg(vha);
#line 3714
  if (ret != 0) {
#line 3715
    ql_log(1U, vha, 45348, "%s: Failed.\n", "qla8044_write_flash_buffer_mode");
#line 3717
    goto exit_func;
  } else {

  }
#line 3720
  dwords = dwords - 1U;
#line 3722
  qla8044_wr_reg_indirect(vha, 1108410376U, 8388609U);
#line 3727
  goto ldv_67011;
  ldv_67010: 
#line 3728
  tmp___0 = dwptr;
#line 3728
  dwptr = dwptr + 1;
#line 3728
  qla8044_wr_reg_indirect(vha, 1108410380U, *tmp___0);
#line 3729
  qla8044_wr_reg_indirect(vha, 1108410372U, 127U);
#line 3731
  ret = qla8044_poll_flash_status_reg(vha);
#line 3732
  if (ret != 0) {
#line 3733
    ql_log(1U, vha, 45353, "%s: Failed.\n", "qla8044_write_flash_buffer_mode");
#line 3735
    goto exit_func;
  } else {

  }
#line 3737
  dwords = dwords - 1U;
  ldv_67011: ;
#line 3727
  if (dwords != 1U) {
#line 3729
    goto ldv_67010;
  } else {

  }
#line 3740
  qla8044_wr_reg_indirect(vha, 1108410376U, (faddr >> 2) | 8388608U);
#line 3744
  tmp___1 = dwptr;
#line 3744
  dwptr = dwptr + 1;
#line 3744
  qla8044_wr_reg_indirect(vha, 1108410380U, *tmp___1);
#line 3745
  qla8044_wr_reg_indirect(vha, 1108410372U, 125U);
#line 3747
  ret = qla8044_poll_flash_status_reg(vha);
#line 3748
  if (ret != 0) {
#line 3749
    ql_log(1U, vha, 45354, "%s: Failed.\n", "qla8044_write_flash_buffer_mode");
#line 3751
    goto exit_func;
  } else {

  }
#line 3753
  qla8044_rd_reg_indirect(vha, 671670288U, & spi_val);
#line 3755
  if ((spi_val & 4U) != 0U) {
#line 3756
    ql_log(1U, vha, 45355, "%s: Failed.\n", "qla8044_write_flash_buffer_mode");
#line 3758
    spi_val = 0U;
#line 3760
    qla8044_rd_reg_indirect(vha, 671670292U, & spi_val);
#line 3762
    qla8044_wr_reg_indirect(vha, 671670292U, spi_val | 4U);
  } else {

  }
  exit_func: ;
#line 3766
  return (ret);
}
}
#line 3770 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_write_flash_dword_mode(scsi_qla_host_t *vha , uint32_t *dwptr ,
                                          uint32_t faddr , uint32_t dwords ) 
{ 
  int ret ;
  uint32_t liter ;

  {
#line 3773
  ret = 258;
#line 3776
  liter = 0U;
#line 3776
  goto ldv_67024;
  ldv_67023: 
#line 3777
  ret = qla8044_flash_write_u32(vha, faddr, dwptr);
#line 3778
  if (ret != 0) {
#line 3779
    ql_dbg(524288U, vha, 45377, "%s: flash address=%x data=%x.\n", "qla8044_write_flash_dword_mode",
           faddr, *dwptr);
#line 3782
    goto ldv_67022;
  } else {

  }
#line 3776
  liter = liter + 1U;
#line 3776
  faddr = faddr + 4U;
#line 3776
  dwptr = dwptr + 1;
  ldv_67024: ;
#line 3776
  if (liter < dwords) {
#line 3778
    goto ldv_67023;
  } else {

  }
  ldv_67022: ;
#line 3786
  return (ret);
}
}
#line 3790 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
int qla8044_write_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                              uint32_t length ) 
{ 
  int rval ;
  int i ;
  int burst_iter_count ;
  int dword_count ;
  int erase_sec_count ;
  uint32_t erase_offset ;
  uint8_t *p_cache ;
  uint8_t *p_src ;
  void *tmp ;

  {
#line 3793
  rval = 258;
#line 3798
  erase_offset = offset;
#line 3800
  tmp = kcalloc((size_t )length, 1UL, 208U);
#line 3800
  p_cache = (uint8_t *)tmp;
#line 3801
  if ((unsigned long )p_cache == (unsigned long )((uint8_t *)0U)) {
#line 3802
    return (258);
  } else {

  }
#line 3804
  memcpy((void *)p_cache, (void const   *)buf, (size_t )length);
#line 3805
  p_src = p_cache;
#line 3806
  dword_count = (int )(length / 4U);
#line 3810
  burst_iter_count = dword_count / 64;
#line 3811
  erase_sec_count = (int )(length / 65536U);
#line 3814
  scsi_block_requests(vha->host);
#line 3816
  qla8044_flash_lock(vha);
#line 3817
  qla8044_unprotect_flash(vha);
#line 3820
  i = 0;
#line 3820
  goto ldv_67041;
  ldv_67040: 
#line 3821
  rval = qla8044_erase_flash_sector(vha, erase_offset);
#line 3822
  ql_dbg(8388608U, vha, 45368, "Done erase of sector=0x%x.\n", erase_offset);
#line 3825
  if (rval != 0) {
#line 3826
    ql_log(1U, vha, 45345, "Failed to erase the sector having address: 0x%x.\n", erase_offset);
#line 3829
    goto out;
  } else {

  }
#line 3831
  erase_offset = erase_offset + 65536U;
#line 3820
  i = i + 1;
  ldv_67041: ;
#line 3820
  if (i < erase_sec_count) {
#line 3822
    goto ldv_67040;
  } else {

  }
#line 3833
  ql_dbg(8388608U, vha, 45375, "Got write for addr = 0x%x length=0x%x.\n", offset,
         length);
#line 3837
  i = 0;
#line 3837
  goto ldv_67044;
  ldv_67043: 
#line 3840
  rval = qla8044_write_flash_buffer_mode(vha, (uint32_t *)p_src, offset, 64U);
#line 3842
  if (rval != 0) {
#line 3844
    ql_log(1U, vha, 45346, "Failed to write flash in buffer mode, Reverting to slow-write.\n");
#line 3847
    rval = qla8044_write_flash_dword_mode(vha, (uint32_t *)p_src, offset, 64U);
  } else {

  }
#line 3851
  p_src = p_src + 256UL;
#line 3852
  offset = offset + 256U;
#line 3837
  i = i + 1;
  ldv_67044: ;
#line 3837
  if (i < burst_iter_count) {
#line 3839
    goto ldv_67043;
  } else {

  }
#line 3854
  ql_dbg(8388608U, vha, 45363, "Done writing.\n");
  out: 
#line 3858
  qla8044_protect_flash(vha);
#line 3859
  qla8044_flash_unlock(vha);
#line 3860
  scsi_unblock_requests(vha->host);
#line 3861
  kfree((void const   *)p_cache);
#line 3863
  return (rval);
}
}
#line 3879 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
irqreturn_t qla8044_intr_handler(int irq , void *dev_id ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct rsp_que *rsp ;
  struct device_reg_82xx *reg ;
  int status ;
  unsigned long flags ;
  unsigned long iter ;
  uint32_t stat ;
  uint16_t mb[4U] ;
  uint32_t leg_int_ptr ;
  uint32_t pf_bit ;
  void *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  unsigned int tmp___3 ;
  unsigned long tmp___4 ;

  {
#line 3885
  status = 0;
#line 3890
  leg_int_ptr = 0U;
#line 3892
  rsp = (struct rsp_que *)dev_id;
#line 3893
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 3894
    ql_log(2U, (scsi_qla_host_t *)0, 45379, "%s(): NULL response queue pointer\n",
           "qla8044_intr_handler");
#line 3896
    return (0);
  } else {

  }
#line 3898
  ha = rsp->hw;
#line 3899
  tmp = pci_get_drvdata(ha->pdev);
#line 3899
  vha = (scsi_qla_host_t *)tmp;
#line 3901
  tmp___0 = pci_channel_offline(ha->pdev);
#line 3901
  tmp___1 = ldv__builtin_expect(tmp___0 != 0, 0L);
#line 3901
  if (tmp___1 != 0L) {
#line 3902
    return (1);
  } else {

  }
#line 3904
  leg_int_ptr = qla8044_rd_reg(ha, 14528UL);
#line 3907
  if ((int )leg_int_ptr >= 0) {
#line 3908
    ql_dbg(524288U, vha, 45380, "%s: Legacy Interrupt Bit 31 not set, spurious interrupt!\n",
           "qla8044_intr_handler");
#line 3911
    return (0);
  } else {

  }
#line 3914
  pf_bit = (uint32_t )((int )ha->portnum << 16);
#line 3916
  if ((leg_int_ptr & 983040U) != pf_bit) {
#line 3917
    ql_dbg(524288U, vha, 45381, "%s: Incorrect function ID 0x%x in legacy interrupt register, ha->pf_bit = 0x%x\n",
           "qla8044_intr_handler", leg_int_ptr & 983040U, pf_bit);
#line 3922
    return (0);
  } else {

  }
#line 3929
  qla8044_wr_reg(ha, 14532UL, 0U);
  ldv_67063: 
#line 3931
  leg_int_ptr = qla8044_rd_reg(ha, 14528UL);
#line 3932
  if ((leg_int_ptr & 983040U) != pf_bit) {
#line 3933
    goto ldv_67062;
  } else {

  }
#line 3934
  if ((leg_int_ptr & 1073741824U) != 0U) {
#line 3936
    goto ldv_67063;
  } else {

  }
  ldv_67062: 
#line 3936
  reg = & (ha->iobase)->isp82;
#line 3937
  tmp___2 = spinlock_check(& ha->hardware_lock);
#line 3937
  flags = _raw_spin_lock_irqsave(tmp___2);
#line 3938
  iter = 1UL;
#line 3938
  goto ldv_67077;
  ldv_67076: 
#line 3940
  tmp___3 = readl((void const volatile   *)(& reg->host_int));
#line 3940
  if (tmp___3 != 0U) {
#line 3941
    stat = readl((void const volatile   *)(& reg->host_status));
#line 3942
    if ((stat & 32768U) == 0U) {
#line 3943
      goto ldv_67067;
    } else {

    }
#line 3945
    switch (stat & 255U) {
    case 1U: ;
    case 2U: ;
    case 16U: ;
    case 17U: 
#line 3950
    qla82xx_mbx_completion(vha, (int )((unsigned short )(stat >> 16)));
#line 3951
    status = status | 1;
#line 3952
    goto ldv_67072;
    case 18U: 
#line 3954
    mb[0] = (unsigned short )(stat >> 16);
#line 3955
    mb[1] = readw((void const volatile   *)(& reg->mailbox_out) + 1U);
#line 3956
    mb[2] = readw((void const volatile   *)(& reg->mailbox_out) + 2U);
#line 3957
    mb[3] = readw((void const volatile   *)(& reg->mailbox_out) + 3U);
#line 3958
    qla2x00_async_event(vha, rsp, (uint16_t *)(& mb));
#line 3959
    goto ldv_67072;
    case 19U: 
#line 3961
    qla24xx_process_response_queue(vha, rsp);
#line 3962
    goto ldv_67072;
    default: 
#line 3964
    ql_dbg(524288U, vha, 45382, "Unrecognized interrupt type (%d).\n", stat & 255U);
#line 3967
    goto ldv_67072;
    }
    ldv_67072: ;
  } else {

  }
#line 3970
  writel(0U, (void volatile   *)(& reg->host_int));
  ldv_67077: 
#line 3938
  tmp___4 = iter;
#line 3938
  iter = iter - 1UL;
#line 3938
  if (tmp___4 != 0UL) {
#line 3940
    goto ldv_67076;
  } else {

  }
  ldv_67067: 
#line 3973
  qla2x00_handle_mbx_completion(ha, status);
#line 3974
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3976
  return (1);
}
}
#line 3980 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static int qla8044_idc_dontreset(struct qla_hw_data *ha ) 
{ 
  uint32_t idc_ctrl ;

  {
#line 3984
  idc_ctrl = qla8044_rd_reg(ha, 14224UL);
#line 3985
  return ((int )idc_ctrl & 1);
}
}
#line 3989 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
static void qla8044_clear_rst_ready(scsi_qla_host_t *vha ) 
{ 
  uint32_t drv_state ;
  int tmp ;

  {
#line 3993
  tmp = qla8044_rd_direct(vha, 5U);
#line 3993
  drv_state = (uint32_t )tmp;
#line 4000
  drv_state = (uint32_t )(~ (1 << (int )(vha->hw)->portnum)) & drv_state;
#line 4002
  ql_dbg(524288U, vha, 45373, "drv_state: 0x%08x\n", drv_state);
#line 4004
  qla8044_wr_direct(vha, 5U, drv_state);
#line 4005
  return;
}
}
#line 4008 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
int qla8044_abort_isp(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  uint32_t dev_state ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;

  {
#line 4012
  ha = vha->hw;
#line 4014
  qla8044_idc_lock(ha);
#line 4015
  tmp = qla8044_rd_direct(vha, 4U);
#line 4015
  dev_state = (uint32_t )tmp;
#line 4017
  if (ql2xdontresethba != 0) {
#line 4018
    qla8044_set_idc_dontreset(vha);
  } else {

  }
#line 4026
  if (dev_state == 3U) {
#line 4029
    tmp___0 = qla8044_idc_dontreset(ha);
#line 4029
    if (tmp___0 == 1) {
#line 4030
      ql_dbg(524288U, vha, 45374, "Reset recovery disabled\n");
#line 4032
      rval = 258;
#line 4033
      goto exit_isp_reset;
    } else {

    }
#line 4036
    ql_dbg(524288U, vha, 45376, "HW State: NEED RESET\n");
#line 4038
    qla8044_wr_direct(vha, 4U, 4U);
  } else {

  }
#line 4045
  qla83xx_reset_ownership(vha);
#line 4047
  qla8044_idc_unlock(ha);
#line 4048
  rval = qla8044_device_state_handler(vha);
#line 4049
  qla8044_idc_lock(ha);
#line 4050
  qla8044_clear_rst_ready(vha);
  exit_isp_reset: 
#line 4053
  qla8044_idc_unlock(ha);
#line 4054
  if (rval == 0) {
#line 4055
    ha->flags.isp82xx_fw_hung = 0U;
#line 4056
    ha->flags.nic_core_reset_hdlr_active = 0U;
#line 4057
    rval = qla82xx_restart_isp(vha);
  } else {

  }
#line 4060
  return (rval);
}
}
#line 4064 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.c"
void qla8044_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 4066
  ha = vha->hw;
#line 4068
  if (ha->allow_cna_fw_dump == 0) {
#line 4069
    return;
  } else {

  }
#line 4071
  scsi_block_requests(vha->host);
#line 4072
  ha->flags.isp82xx_no_md_cap = 1U;
#line 4073
  qla8044_idc_lock(ha);
#line 4074
  qla82xx_set_reset_owner(vha);
#line 4075
  qla8044_idc_unlock(ha);
#line 4076
  qla2x00_wait_for_chip_reset(vha);
#line 4077
  scsi_unblock_requests(vha->host);
#line 4078
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
void disable_suitable_timer_28(struct timer_list *timer ) 
{ 


  {
#line 489
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_28) {
#line 490
    ldv_timer_state_28 = 0;
#line 491
    return;
  } else {

  }
#line 493
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
int reg_timer_28(struct timer_list *timer ) 
{ 


  {
#line 497
  ldv_timer_list_28 = timer;
#line 498
  ldv_timer_state_28 = 1;
#line 499
  return (0);
}
}
#line 502 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
void choose_timer_28(struct timer_list *timer ) 
{ 


  {
#line 503
  LDV_IN_INTERRUPT = 2;
#line 504
  (*(timer->function))(timer->data);
#line 505
  LDV_IN_INTERRUPT = 1;
#line 506
  ldv_timer_state_28 = 2;
#line 507
  return;
}
}
#line 510 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
void activate_pending_timer_28(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 510
  if ((unsigned long )ldv_timer_list_28 == (unsigned long )timer) {
#line 511
    if (ldv_timer_state_28 == 2 || pending_flag != 0) {
#line 512
      ldv_timer_list_28 = timer;
#line 513
      ldv_timer_list_28->data = data;
#line 514
      ldv_timer_state_28 = 1;
    } else {

    }
#line 516
    return;
  } else {

  }
#line 518
  reg_timer_28(timer);
#line 519
  ldv_timer_list_28->data = data;
#line 520
  return;
}
}
#line 546 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
bool ldv_queue_work_on_279(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 550
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 550
  ldv_func_res = tmp;
#line 552
  activate_work_7(ldv_func_arg3, 2);
#line 554
  return (ldv_func_res);
}
}
#line 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
bool ldv_queue_delayed_work_on_280(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 561
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 561
  ldv_func_res = tmp;
#line 563
  activate_work_7(& ldv_func_arg3->work, 2);
#line 565
  return (ldv_func_res);
}
}
#line 568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
bool ldv_queue_work_on_281(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 572
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 572
  ldv_func_res = tmp;
#line 574
  activate_work_7(ldv_func_arg3, 2);
#line 576
  return (ldv_func_res);
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
void ldv_flush_workqueue_282(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 582
  flush_workqueue(ldv_func_arg1);
#line 584
  call_and_disable_all_7(2);
#line 585
  return;
}
}
#line 587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
bool ldv_queue_delayed_work_on_283(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 591
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 591
  ldv_func_res = tmp;
#line 593
  activate_work_7(& ldv_func_arg3->work, 2);
#line 595
  return (ldv_func_res);
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
int ldv_scsi_add_host_with_dma_284(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 602
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 602
  ldv_func_res = tmp;
#line 604
  if (ldv_func_res == 0) {
#line 605
    ldv_state_variable_88 = 1;
#line 605
    ldv_initialize_scsi_host_template_88();
  } else {

  }
#line 609
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 314 "./arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 318
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 323
  return (oldbit);
}
}
#line 14 "./arch/x86/include/uapi/asm/swab.h"
__inline static __u64 __arch_swab64(__u64 val ) 
{ 


  {
#line 30
  __asm__  ("bswapq %0": "=r" (val): "0" (val));
#line 31
  return (val);
}
}
#line 68 "include/uapi/linux/swab.h"
__inline static __u64 __fswab64(__u64 val ) 
{ 
  __u64 tmp ;

  {
#line 73
  tmp = __arch_swab64(val);
#line 73
  return (tmp);
}
}
#line 55 "include/uapi/linux/byteorder/little_endian.h"
__inline static __u32 __le32_to_cpup(__le32 const   *p ) 
{ 


  {
#line 57
  return ((__u32 )*p);
}
}
#line 233 "include/linux/printk.h"
extern void dump_stack(void) ;
#line 45 "include/linux/dynamic_debug.h"
extern void __dynamic_pr_debug(struct _ddebug * , char const   *  , ...) ;
#line 178 "include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 44 "include/linux/string.h"
extern int strcasecmp(char const   * , char const   * ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 310 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 312
  _raw_spin_lock(& lock->__annonCompField18.rlock);
#line 313
  return;
}
}
#line 355 "include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 357
  _raw_spin_unlock(& lock->__annonCompField18.rlock);
#line 358
  return;
}
}
#line 149 "include/linux/wait.h"
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 926
extern long prepare_to_wait_event(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 927
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 88 "include/linux/timer.h"
extern void init_timer_key(struct timer_list * , unsigned int  , char const   * ,
                           struct lock_class_key * ) ;
#line 20 "include/linux/workqueue.h"
extern void delayed_work_timer_fn(unsigned long  ) ;
#line 424
void ldv_destroy_workqueue_302(struct workqueue_struct *ldv_func_arg1 ) ;
#line 437
bool ldv_queue_work_on_295(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 441
bool ldv_queue_work_on_297(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 447
bool ldv_queue_delayed_work_on_296(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 451
bool ldv_queue_delayed_work_on_299(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 459
void ldv_flush_workqueue_298(struct workqueue_struct *ldv_func_arg1 ) ;
#line 470
extern bool flush_delayed_work(struct delayed_work * ) ;
#line 473
bool ldv_flush_delayed_work_301(struct delayed_work *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work___1(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_295(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 483 "include/linux/workqueue.h"
__inline static bool queue_delayed_work(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                        unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 487
  tmp = ldv_queue_delayed_work_on_296(8192, wq, dwork, delay);
#line 487
  return (tmp);
}
}
#line 528 "include/linux/workqueue.h"
__inline static bool schedule_work___0(struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 530
  tmp = queue_work___1(system_wq, work);
#line 530
  return (tmp);
}
}
#line 557 "include/linux/workqueue.h"
__inline static void flush_scheduled_work(void) 
{ 


  {
#line 559
  ldv_flush_workqueue_298(system_wq);
#line 560
  return;
}
}
#line 585 "include/linux/workqueue.h"
__inline static bool schedule_delayed_work(struct delayed_work *dwork , unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 588
  tmp = queue_delayed_work(system_wq, dwork, delay);
#line 588
  return (tmp);
}
}
#line 41 "include/linux/kref.h"
__inline static void kref_get___0(struct kref *kref ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 47
  tmp = atomic_add_return(1, & kref->refcount);
#line 47
  __ret_warn_once = tmp <= 1;
#line 47
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 47
  if (tmp___2 != 0L) {
#line 47
    __ret_warn_on = ! __warned;
#line 47
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 47
    if (tmp___0 != 0L) {
#line 47
      warn_slowpath_null("include/linux/kref.h", 47);
    } else {

    }
#line 47
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 47
    if (tmp___1 != 0L) {
#line 47
      __warned = 1;
    } else {

    }
  } else {

  }
#line 47
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 49
  return;
}
}
#line 12 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 62 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv__builtin_trap(void) 
{ 


  {
#line 64
  ldv_error();
#line 65
  return;
}
}
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void call_and_disable_work_10(struct work_struct *work ) ;
#line 327
void invoke_work_8(void) ;
#line 344
void activate_pending_timer_29(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 345
void invoke_work_10(void) ;
#line 355
void call_and_disable_all_11(int state ) ;
#line 358
int reg_timer_29(struct timer_list *timer ) ;
#line 361
void call_and_disable_work_7(struct work_struct *work ) ;
#line 368
void call_and_disable_all_9(int state ) ;
#line 369
void call_and_disable_all_12(int state ) ;
#line 378
void call_and_disable_work_8(struct work_struct *work ) ;
#line 380
void invoke_work_11(void) ;
#line 385
void invoke_work_9(void) ;
#line 387
void disable_work_8(struct work_struct *work ) ;
#line 388
void activate_work_9(struct work_struct *work , int state ) ;
#line 399
void invoke_work_12(void) ;
#line 404
void call_and_disable_work_12(struct work_struct *work ) ;
#line 409
void activate_work_11(struct work_struct *work , int state ) ;
#line 413
void disable_work_11(struct work_struct *work ) ;
#line 414
void disable_work_12(struct work_struct *work ) ;
#line 425
void invoke_work_7(void) ;
#line 428
void call_and_disable_all_8(int state ) ;
#line 429
void call_and_disable_work_9(struct work_struct *work ) ;
#line 434
void activate_work_12(struct work_struct *work , int state ) ;
#line 437
void activate_work_8(struct work_struct *work , int state ) ;
#line 448
void disable_work_9(struct work_struct *work ) ;
#line 454
void disable_work_10(struct work_struct *work ) ;
#line 462
void activate_work_10(struct work_struct *work , int state ) ;
#line 466
void call_and_disable_work_11(struct work_struct *work ) ;
#line 473
void choose_timer_29(struct timer_list *timer ) ;
#line 478
void call_and_disable_all_10(int state ) ;
#line 484
void disable_suitable_timer_29(struct timer_list *timer ) ;
#line 120 "include/linux/scatterlist.h"
__inline static struct page *sg_page___3(struct scatterlist *sg ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 123
  tmp = ldv__builtin_expect(sg->sg_magic != 2271560481UL, 0L);
#line 123
  if (tmp != 0L) {
#line 123
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (123), "i" (12UL));
    ldv_31679: ;
#line 123
    goto ldv_31679;
  } else {

  }
#line 124
  tmp___0 = ldv__builtin_expect((long )((int )sg->page_link) & 1L, 0L);
#line 124
  if (tmp___0 != 0L) {
#line 124
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (124), "i" (12UL));
    ldv_31680: ;
#line 124
    goto ldv_31680;
  } else {

  }
#line 126
  return ((struct page *)(sg->page_link & 0xfffffffffffffffcUL));
}
}
#line 243 "include/linux/scatterlist.h"
__inline static void *sg_virt___2(struct scatterlist *sg ) 
{ 
  struct page *tmp ;
  void *tmp___0 ;

  {
#line 245
  tmp = sg_page___3(sg);
#line 245
  tmp___0 = lowmem_page_address((struct page  const  *)tmp);
#line 245
  return (tmp___0 + (unsigned long )sg->offset);
}
}
#line 46 "include/asm-generic/dma-mapping-common.h"
__inline static int dma_map_sg_attrs___2(struct device *dev , struct scatterlist *sg ,
                                         int nents , enum dma_data_direction dir ,
                                         struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int i ;
  int ents ;
  struct scatterlist *s ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 50
  tmp = get_dma_ops(dev);
#line 50
  ops = tmp;
#line 54
  i = 0;
#line 54
  s = sg;
#line 54
  goto ldv_35526;
  ldv_35525: 
#line 55
  tmp___0 = sg_virt___2(s);
#line 55
  kmemcheck_mark_initialized(tmp___0, s->length);
#line 54
  i = i + 1;
#line 54
  s = sg_next(s);
  ldv_35526: ;
#line 54
  if (i < nents) {
#line 56
    goto ldv_35525;
  } else {

  }
#line 56
  tmp___1 = valid_dma_direction((int )dir);
#line 56
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 56
  if (tmp___2 != 0L) {
#line 56
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (56), "i" (12UL));
    ldv_35528: ;
#line 56
    goto ldv_35528;
  } else {

  }
#line 57
  ents = (*(ops->map_sg))(dev, sg, nents, dir, attrs);
#line 58
  tmp___3 = ldv__builtin_expect(ents < 0, 0L);
#line 58
  if (tmp___3 != 0L) {
#line 58
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (58), "i" (12UL));
    ldv_35529: ;
#line 58
    goto ldv_35529;
  } else {

  }
#line 59
  debug_dma_map_sg(dev, sg, nents, ents, (int )dir);
#line 61
  return (ents);
}
}
#line 64 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_sg_attrs___1(struct device *dev , struct scatterlist *sg ,
                                            int nents , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 68
  tmp = get_dma_ops(dev);
#line 68
  ops = tmp;
#line 70
  tmp___0 = valid_dma_direction((int )dir);
#line 70
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 70
  if (tmp___1 != 0L) {
#line 70
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (70), "i" (12UL));
    ldv_35538: ;
#line 70
    goto ldv_35538;
  } else {

  }
#line 71
  debug_dma_unmap_sg(dev, sg, nents, (int )dir);
#line 72
  if ((unsigned long )ops->unmap_sg != (unsigned long )((void (*)(struct device * ,
                                                                  struct scatterlist * ,
                                                                  int  , enum dma_data_direction  ,
                                                                  struct dma_attrs * ))0)) {
#line 73
    (*(ops->unmap_sg))(dev, sg, nents, dir, attrs);
  } else {

  }
#line 74
  return;
}
}
#line 65 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_map_sg(struct pci_dev *hwdev , struct scatterlist *sg , int nents ,
                               int direction ) 
{ 
  int tmp ;

  {
#line 68
  tmp = dma_map_sg_attrs___2((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                             sg, nents, (enum dma_data_direction )direction, (struct dma_attrs *)0);
#line 68
  return (tmp);
}
}
#line 72 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_sg(struct pci_dev *hwdev , struct scatterlist *sg ,
                                  int nents , int direction ) 
{ 


  {
#line 75
  dma_unmap_sg_attrs___1((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                         sg, nents, (enum dma_data_direction )direction, (struct dma_attrs *)0);
#line 76
  return;
}
}
#line 12 "include/linux/unaligned/access_ok.h"
__inline static u32 get_unaligned_le32(void const   *p ) 
{ 
  __u32 tmp ;

  {
#line 14
  tmp = __le32_to_cpup((__le32 const   *)p);
#line 14
  return (tmp);
}
}
#line 62 "include/linux/unaligned/access_ok.h"
__inline static void put_unaligned_be64(u64 val , void *p ) 
{ 
  __u64 tmp ;

  {
#line 64
  tmp = __fswab64(val);
#line 64
  *((__be64 *)p) = tmp;
#line 65
  return;
}
}
#line 31 "include/scsi/scsi_common.h"
extern u64 scsilun_to_int(struct scsi_lun * ) ;
#line 795 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_300(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
#line 65 "include/linux/percpu_ida.h"
extern int percpu_ida_alloc(struct percpu_ida * , int  ) ;
#line 66
extern void percpu_ida_free(struct percpu_ida * , unsigned int  ) ;
#line 1041 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
int qlt_lport_register(void *target_lport_ptr , u64 phys_wwpn , u64 npiv_wwpn , u64 npiv_wwnn ,
                       int (*callback)(struct scsi_qla_host * , void * , u64  , u64  ) ) ;
#line 1043
void qlt_lport_deregister(struct scsi_qla_host *vha ) ;
#line 1044
void qlt_unreg_sess(struct qla_tgt_sess *sess ) ;
#line 1068 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_target.h"
__inline static void qla_reverse_ini_mode(struct scsi_qla_host *ha ) 
{ 


  {
#line 1070
  if ((int )(ha->host)->active_mode & 1) {
#line 1071
    (ha->host)->active_mode = (unsigned int )(ha->host)->active_mode & 2U;
  } else {
#line 1073
    (ha->host)->active_mode = (unsigned char )((unsigned int )(ha->host)->active_mode | 1U);
  }
#line 1074
  return;
}
}
#line 1080
int qlt_rdy_to_xfer(struct qla_tgt_cmd *cmd ) ;
#line 1081
int qlt_xmit_response(struct qla_tgt_cmd *cmd , int xmit_type , uint8_t scsi_status ) ;
#line 1082
void qlt_xmit_tm_rsp(struct qla_tgt_mgmt_cmd *mcmd ) ;
#line 1083
void qlt_free_mcmd(struct qla_tgt_mgmt_cmd *mcmd ) ;
#line 1084
void qlt_free_cmd(struct qla_tgt_cmd *cmd ) ;
#line 1086
void qlt_enable_vha(struct scsi_qla_host *vha ) ;
#line 1107
int qlt_stop_phase1(struct qla_tgt *tgt ) ;
#line 1108
void qlt_stop_phase2(struct qla_tgt *tgt ) ;
#line 1111
int qlt_free_qfull_cmds(struct scsi_qla_host *vha ) ;
#line 132 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_clean_dsd_pool___0(struct qla_hw_data *ha , srb_t *sp ,
                                                struct qla_tgt_cmd *tc ) 
{ 
  struct dsd_dma *dsd_ptr ;
  struct dsd_dma *tdsd_ptr ;
  struct crc_context *ctx ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 138
  if ((unsigned long )sp != (unsigned long )((srb_t *)0)) {
#line 139
    ctx = (struct crc_context *)sp->u.scmd.ctx;
  } else
#line 140
  if ((unsigned long )tc != (unsigned long )((struct qla_tgt_cmd *)0)) {
#line 141
    ctx = tc->ctx;
  } else {
#line 143
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/qla2xxx/qla_inline.h"),
                         "i" (143), "i" (12UL));
    ldv_66028: ;
#line 143
    goto ldv_66028;
#line 144
    return;
  }
#line 148
  __mptr = (struct list_head  const  *)ctx->dsd_list.next;
#line 148
  dsd_ptr = (struct dsd_dma *)__mptr;
#line 148
  __mptr___0 = (struct list_head  const  *)dsd_ptr->list.next;
#line 148
  tdsd_ptr = (struct dsd_dma *)__mptr___0;
#line 148
  goto ldv_66036;
  ldv_66035: 
#line 150
  dma_pool_free(ha->dl_dma_pool, dsd_ptr->dsd_addr, dsd_ptr->dsd_list_dma);
#line 152
  list_del(& dsd_ptr->list);
#line 153
  kfree((void const   *)dsd_ptr);
#line 148
  dsd_ptr = tdsd_ptr;
#line 148
  __mptr___1 = (struct list_head  const  *)tdsd_ptr->list.next;
#line 148
  tdsd_ptr = (struct dsd_dma *)__mptr___1;
  ldv_66036: ;
#line 148
  if ((unsigned long )(& dsd_ptr->list) != (unsigned long )(& ctx->dsd_list)) {
#line 150
    goto ldv_66035;
  } else {

  }
#line 155
  INIT_LIST_HEAD(& ctx->dsd_list);
#line 156
  return;
}
}
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static int ql2xtgt_tape_enable  ;
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static char *qlini_mode  =    (char *)"enabled";
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
int ql2x_ini_mode  =    0;
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static int temp_sam_status  =    8;
#line 102
static void qlt_24xx_atio_pkt(struct scsi_qla_host *vha , struct atio_from_isp *atio ) ;
#line 104
static void qlt_response_pkt(struct scsi_qla_host *vha , response_t *pkt ) ;
#line 105
static int qlt_issue_task_mgmt(struct qla_tgt_sess *sess , uint32_t lun , int fn ,
                               void *iocb , int flags ) ;
#line 107
static void qlt_send_term_exchange(struct scsi_qla_host *vha , struct qla_tgt_cmd *cmd ,
                                   struct atio_from_isp *atio , int ha_locked ) ;
#line 109
static void qlt_reject_free_srr_imm(struct scsi_qla_host *vha , struct qla_tgt_srr_imm *imm ,
                                    int ha_locked ) ;
#line 111
static void qlt_abort_cmd_on_host_reset(struct scsi_qla_host *vha , struct qla_tgt_cmd *cmd ) ;
#line 113
static void qlt_alloc_qfull_cmd(struct scsi_qla_host *vha , struct atio_from_isp *atio ,
                                uint16_t status , int qfull ) ;
#line 115
static void qlt_disable_vha(struct scsi_qla_host *vha ) ;
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static struct kmem_cache *qla_tgt_mgmt_cmd_cachep  ;
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static mempool_t *qla_tgt_mgmt_cmd_mempool  ;
#line 121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static struct workqueue_struct *qla_tgt_wq  ;
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static struct mutex qla_tgt_mutex  =    {{1}, {{{{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "qla_tgt_mutex.wait_lock",
                                                          0, 0UL}}}}, {& qla_tgt_mutex.wait_list,
                                                                       & qla_tgt_mutex.wait_list},
    0, (void *)(& qla_tgt_mutex), {0, {0, 0}, "qla_tgt_mutex", 0, 0UL}};
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static struct list_head qla_tgt_glist  =    {& qla_tgt_glist, & qla_tgt_glist};
#line 126 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static struct qla_tgt_sess *qlt_find_sess_by_port_name(struct qla_tgt *tgt , uint8_t const   *port_name ) 
{ 
  struct qla_tgt_sess *sess ;
  struct list_head  const  *__mptr ;
  int tmp ;
  struct list_head  const  *__mptr___0 ;

  {
#line 132
  __mptr = (struct list_head  const  *)tgt->sess_list.next;
#line 132
  sess = (struct qla_tgt_sess *)__mptr + 0xffffffffffffffd8UL;
#line 132
  goto ldv_66182;
  ldv_66181: 
#line 133
  tmp = memcmp((void const   *)(& sess->port_name), (void const   *)port_name, 8UL);
#line 133
  if (tmp == 0) {
#line 134
    return (sess);
  } else {

  }
#line 132
  __mptr___0 = (struct list_head  const  *)sess->sess_list_entry.next;
#line 132
  sess = (struct qla_tgt_sess *)__mptr___0 + 0xffffffffffffffd8UL;
  ldv_66182: ;
#line 132
  if ((unsigned long )(& sess->sess_list_entry) != (unsigned long )(& tgt->sess_list)) {
#line 134
    goto ldv_66181;
  } else {

  }

#line 137
  return ((struct qla_tgt_sess *)0);
}
}
#line 141 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
__inline static int qlt_issue_marker(struct scsi_qla_host *vha , int vha_locked ) 
{ 
  int rc ;
  int tmp ;
  long tmp___0 ;

  {
#line 144
  tmp___0 = ldv__builtin_expect((unsigned int )vha->marker_needed != 0U, 0L);
#line 144
  if (tmp___0 != 0L) {
#line 145
    tmp = qla2x00_issue_marker(vha, vha_locked);
#line 145
    rc = tmp;
#line 146
    if (rc != 0) {
#line 147
      ql_dbg(16384U, vha, 57405, "qla_target(%d): issue_marker() failed\n", (int )vha->vp_idx);
    } else {

    }
#line 151
    return (rc);
  } else {

  }
#line 153
  return (0);
}
}
#line 157 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
__inline static struct scsi_qla_host *qlt_find_host_by_d_id(struct scsi_qla_host *vha ,
                                                            uint8_t *d_id ) 
{ 
  struct qla_hw_data *ha ;
  uint8_t vp_idx ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 160
  ha = vha->hw;
#line 163
  if ((int )vha->d_id.b.area != (int )*(d_id + 1UL) || (int )vha->d_id.b.domain != (int )*d_id) {
#line 164
    return ((struct scsi_qla_host *)0);
  } else {

  }
#line 166
  if ((int )vha->d_id.b.al_pa == (int )*(d_id + 2UL)) {
#line 167
    return (vha);
  } else {

  }
#line 169
  tmp = ldv__builtin_expect((unsigned long )ha->tgt.tgt_vp_map == (unsigned long )((struct qla_tgt_vp_map *)0),
                         0L);
#line 169
  if (tmp != 0L) {
#line 169
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"),
                         "i" (169), "i" (12UL));
    ldv_66195: ;
#line 169
    goto ldv_66195;
  } else {

  }
#line 170
  vp_idx = (ha->tgt.tgt_vp_map + (unsigned long )*(d_id + 2UL))->idx;
#line 171
  tmp___0 = variable_test_bit((long )vp_idx, (unsigned long const volatile   *)(& ha->vp_idx_map));
#line 171
  tmp___1 = ldv__builtin_expect(tmp___0 != 0, 1L);
#line 171
  if (tmp___1 != 0L) {
#line 172
    return ((ha->tgt.tgt_vp_map + (unsigned long )vp_idx)->vha);
  } else {

  }
#line 174
  return ((struct scsi_qla_host *)0);
}
}
#line 178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
__inline static struct scsi_qla_host *qlt_find_host_by_vp_idx(struct scsi_qla_host *vha ,
                                                              uint16_t vp_idx ) 
{ 
  struct qla_hw_data *ha ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 181
  ha = vha->hw;
#line 183
  if ((int )vha->vp_idx == (int )vp_idx) {
#line 184
    return (vha);
  } else {

  }
#line 186
  tmp = ldv__builtin_expect((unsigned long )ha->tgt.tgt_vp_map == (unsigned long )((struct qla_tgt_vp_map *)0),
                         0L);
#line 186
  if (tmp != 0L) {
#line 186
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"),
                         "i" (186), "i" (12UL));
    ldv_66201: ;
#line 186
    goto ldv_66201;
  } else {

  }
#line 187
  tmp___0 = variable_test_bit((long )vp_idx, (unsigned long const volatile   *)(& ha->vp_idx_map));
#line 187
  tmp___1 = ldv__builtin_expect(tmp___0 != 0, 1L);
#line 187
  if (tmp___1 != 0L) {
#line 188
    return ((ha->tgt.tgt_vp_map + (unsigned long )vp_idx)->vha);
  } else {

  }
#line 190
  return ((struct scsi_qla_host *)0);
}
}
#line 193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
__inline static void qlt_incr_num_pend_cmds(struct scsi_qla_host *vha ) 
{ 
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 197
  tmp = spinlock_check(& (vha->hw)->tgt.q_full_lock);
#line 197
  flags = _raw_spin_lock_irqsave(tmp);
#line 199
  (vha->hw)->tgt.num_pend_cmds = (vha->hw)->tgt.num_pend_cmds + 1U;
#line 200
  if ((vha->hw)->tgt.num_pend_cmds > (vha->hw)->qla_stats.stat_max_pend_cmds) {
#line 201
    (vha->hw)->qla_stats.stat_max_pend_cmds = (vha->hw)->tgt.num_pend_cmds;
  } else {

  }
#line 203
  spin_unlock_irqrestore(& (vha->hw)->tgt.q_full_lock, flags);
#line 204
  return;
}
}
#line 205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
__inline static void qlt_decr_num_pend_cmds(struct scsi_qla_host *vha ) 
{ 
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 209
  tmp = spinlock_check(& (vha->hw)->tgt.q_full_lock);
#line 209
  flags = _raw_spin_lock_irqsave(tmp);
#line 210
  (vha->hw)->tgt.num_pend_cmds = (vha->hw)->tgt.num_pend_cmds - 1U;
#line 211
  spin_unlock_irqrestore(& (vha->hw)->tgt.q_full_lock, flags);
#line 212
  return;
}
}
#line 214 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_24xx_atio_pkt_all_vps(struct scsi_qla_host *vha , struct atio_from_isp *atio ) 
{ 
  __u16 tmp ;
  struct scsi_qla_host *host ;
  struct scsi_qla_host *tmp___0 ;
  long tmp___1 ;
  struct scsi_qla_host *host___0 ;
  struct imm_ntfy_from_isp *entry ;
  long tmp___2 ;

  {
#line 217
  tmp = __fswab16((int )atio->u.isp24.fcp_hdr.ox_id);
#line 217
  ql_dbg(16384U, vha, 57458, "%s: qla_target(%d): type %x ox_id %04x\n", "qlt_24xx_atio_pkt_all_vps",
         (int )vha->vp_idx, (int )atio->u.raw.entry_type, (int )tmp);
#line 222
  switch ((int )atio->u.raw.entry_type) {
  case 6: 
#line 225
  tmp___0 = qlt_find_host_by_d_id(vha, (uint8_t *)(& atio->u.isp24.fcp_hdr.d_id));
#line 225
  host = tmp___0;
#line 227
  tmp___1 = ldv__builtin_expect((unsigned long )host == (unsigned long )((struct scsi_qla_host *)0),
                             0L);
#line 227
  if (tmp___1 != 0L) {
#line 228
    ql_dbg(16384U, vha, 57406, "qla_target(%d): Received ATIO_TYPE7 with unknown d_id %x:%x:%x\n",
           (int )vha->vp_idx, (int )atio->u.isp24.fcp_hdr.d_id[0], (int )atio->u.isp24.fcp_hdr.d_id[1],
           (int )atio->u.isp24.fcp_hdr.d_id[2]);
#line 234
    goto ldv_66223;
  } else {

  }
#line 236
  qlt_24xx_atio_pkt(host, atio);
#line 237
  goto ldv_66223;
  case 13: 
#line 242
  host___0 = vha;
#line 243
  entry = (struct imm_ntfy_from_isp *)atio;
#line 246
  if ((unsigned int )entry->u.isp24.vp_index != 255U && (unsigned int )entry->u.isp24.nport_handle != 65535U) {
#line 248
    host___0 = qlt_find_host_by_vp_idx(vha, (int )entry->u.isp24.vp_index);
#line 250
    tmp___2 = ldv__builtin_expect((unsigned long )host___0 == (unsigned long )((struct scsi_qla_host *)0),
                               0L);
#line 250
    if (tmp___2 != 0L) {
#line 251
      ql_dbg(16384U, vha, 57407, "qla_target(%d): Received ATIO (IMMED_NOTIFY_TYPE) with unknown vp_index %d\n",
             (int )vha->vp_idx, (int )entry->u.isp24.vp_index);
#line 256
      goto ldv_66223;
    } else {

    }
  } else {

  }
#line 259
  qlt_24xx_atio_pkt(host___0, atio);
#line 260
  goto ldv_66223;
  default: 
#line 264
  ql_dbg(16384U, vha, 57408, "qla_target(%d): Received unknown ATIO atio type %x\n",
         (int )vha->vp_idx, (int )atio->u.raw.entry_type);
#line 267
  goto ldv_66223;
  }
  ldv_66223: ;
#line 270
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_response_pkt_all_vps(struct scsi_qla_host *vha , response_t *pkt ) 
{ 
  struct ctio7_from_24xx *entry ;
  struct scsi_qla_host *host ;
  struct scsi_qla_host *tmp ;
  long tmp___0 ;
  struct scsi_qla_host *host___0 ;
  struct imm_ntfy_from_isp *entry___0 ;
  long tmp___1 ;
  struct scsi_qla_host *host___1 ;
  struct nack_to_isp *entry___1 ;
  long tmp___2 ;
  struct abts_recv_from_24xx *entry___2 ;
  struct scsi_qla_host *host___2 ;
  struct scsi_qla_host *tmp___3 ;
  long tmp___4 ;
  struct abts_resp_to_24xx *entry___3 ;
  struct scsi_qla_host *host___3 ;
  struct scsi_qla_host *tmp___5 ;
  long tmp___6 ;

  {
#line 275
  switch ((int )pkt->entry_type) {
  case 122: 
#line 277
  ql_dbg(16384U, vha, 57459, "qla_target(%d):%s: CRC2 Response pkt\n", (int )vha->vp_idx,
         "qlt_response_pkt_all_vps");
  case 18: 
#line 282
  entry = (struct ctio7_from_24xx *)pkt;
#line 283
  tmp = qlt_find_host_by_vp_idx(vha, (int )entry->vp_index);
#line 283
  host = tmp;
#line 285
  tmp___0 = ldv__builtin_expect((unsigned long )host == (unsigned long )((struct scsi_qla_host *)0),
                             0L);
#line 285
  if (tmp___0 != 0L) {
#line 286
    ql_dbg(16384U, vha, 57409, "qla_target(%d): Response pkt (CTIO_TYPE7) received, with unknown vp_index %d\n",
           (int )vha->vp_idx, (int )entry->vp_index);
#line 290
    goto ldv_66237;
  } else {

  }
#line 292
  qlt_response_pkt(host, pkt);
#line 293
  goto ldv_66237;
  case 13: 
#line 298
  host___0 = vha;
#line 299
  entry___0 = (struct imm_ntfy_from_isp *)pkt;
#line 302
  host___0 = qlt_find_host_by_vp_idx(vha, (int )entry___0->u.isp24.vp_index);
#line 303
  tmp___1 = ldv__builtin_expect((unsigned long )host___0 == (unsigned long )((struct scsi_qla_host *)0),
                             0L);
#line 303
  if (tmp___1 != 0L) {
#line 304
    ql_dbg(16384U, vha, 57410, "qla_target(%d): Response pkt (IMMED_NOTIFY_TYPE) received, with unknown vp_index %d\n",
           (int )vha->vp_idx, (int )entry___0->u.isp24.vp_index);
#line 308
    goto ldv_66237;
  } else {

  }
#line 310
  qlt_response_pkt(host___0, pkt);
#line 311
  goto ldv_66237;
  case 14: 
#line 316
  host___1 = vha;
#line 317
  entry___1 = (struct nack_to_isp *)pkt;
#line 319
  if ((unsigned int )entry___1->u.isp24.vp_index != 255U) {
#line 320
    host___1 = qlt_find_host_by_vp_idx(vha, (int )entry___1->u.isp24.vp_index);
#line 322
    tmp___2 = ldv__builtin_expect((unsigned long )host___1 == (unsigned long )((struct scsi_qla_host *)0),
                               0L);
#line 322
    if (tmp___2 != 0L) {
#line 323
      ql_dbg(16384U, vha, 57411, "qla_target(%d): Response pkt (NOTIFY_ACK_TYPE) received, with unknown vp_index %d\n",
             (int )vha->vp_idx, (int )entry___1->u.isp24.vp_index);
#line 329
      goto ldv_66237;
    } else {

    }
  } else {

  }
#line 332
  qlt_response_pkt(host___1, pkt);
#line 333
  goto ldv_66237;
  case 84: 
#line 338
  entry___2 = (struct abts_recv_from_24xx *)pkt;
#line 340
  tmp___3 = qlt_find_host_by_vp_idx(vha, (int )entry___2->vp_index);
#line 340
  host___2 = tmp___3;
#line 342
  tmp___4 = ldv__builtin_expect((unsigned long )host___2 == (unsigned long )((struct scsi_qla_host *)0),
                             0L);
#line 342
  if (tmp___4 != 0L) {
#line 343
    ql_dbg(16384U, vha, 57412, "qla_target(%d): Response pkt (ABTS_RECV_24XX) received, with unknown vp_index %d\n",
           (int )vha->vp_idx, (int )entry___2->vp_index);
#line 347
    goto ldv_66237;
  } else {

  }
#line 349
  qlt_response_pkt(host___2, pkt);
#line 350
  goto ldv_66237;
  case 85: 
#line 355
  entry___3 = (struct abts_resp_to_24xx *)pkt;
#line 357
  tmp___5 = qlt_find_host_by_vp_idx(vha, (int )entry___3->vp_index);
#line 357
  host___3 = tmp___5;
#line 359
  tmp___6 = ldv__builtin_expect((unsigned long )host___3 == (unsigned long )((struct scsi_qla_host *)0),
                             0L);
#line 359
  if (tmp___6 != 0L) {
#line 360
    ql_dbg(16384U, vha, 57413, "qla_target(%d): Response pkt (ABTS_RECV_24XX) received, with unknown vp_index %d\n",
           (int )vha->vp_idx, (int )entry___3->vp_index);
#line 364
    goto ldv_66237;
  } else {

  }
#line 366
  qlt_response_pkt(host___3, pkt);
#line 367
  goto ldv_66237;
  default: 
#line 371
  qlt_response_pkt(vha, pkt);
#line 372
  goto ldv_66237;
  }
  ldv_66237: ;
#line 376
  return;
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_free_session_done(struct work_struct *work ) 
{ 
  struct qla_tgt_sess *sess ;
  struct work_struct  const  *__mptr ;
  struct qla_tgt *tgt ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  long tmp ;

  {
#line 379
  __mptr = (struct work_struct  const  *)work;
#line 379
  sess = (struct qla_tgt_sess *)__mptr + 0xffffffffffffffa8UL;
#line 381
  tgt = sess->tgt;
#line 382
  vha = sess->vha;
#line 383
  ha = vha->hw;
#line 385
  tmp = ldv__builtin_expect((unsigned long )tgt == (unsigned long )((struct qla_tgt *)0),
                         0L);
#line 385
  if (tmp != 0L) {
#line 385
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"),
                         "i" (385), "i" (12UL));
    ldv_66260: ;
#line 385
    goto ldv_66260;
  } else {

  }
#line 389
  if ((unsigned long )sess->se_sess != (unsigned long )((struct se_session *)0)) {
#line 390
    (*((ha->tgt.tgt_ops)->free_session))(sess);
  } else {

  }
#line 392
  ql_dbg(8192U, vha, 61441, "Unregistration of sess %p finished\n", sess);
#line 395
  kfree((void const   *)sess);
#line 400
  tgt->sess_count = tgt->sess_count - 1;
#line 401
  if (tgt->sess_count == 0) {
#line 402
    __wake_up(& tgt->waitQ, 3U, 0, (void *)0);
  } else {

  }
#line 403
  return;
}
}
#line 406 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_unreg_sess(struct qla_tgt_sess *sess ) 
{ 
  struct scsi_qla_host *vha ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;

  {
#line 408
  vha = sess->vha;
#line 410
  (*(((vha->hw)->tgt.tgt_ops)->clear_nacl_from_fcport_map))(sess);
#line 412
  list_del(& sess->sess_list_entry);
#line 413
  if ((unsigned int )*((unsigned char *)sess + 8UL) != 0U) {
#line 414
    list_del(& sess->del_list_entry);
  } else {

  }
#line 416
  __init_work(& sess->free_work, 0);
#line 416
  __constr_expr_0.counter = 137438953408L;
#line 416
  sess->free_work.data = __constr_expr_0;
#line 416
  lockdep_init_map(& sess->free_work.lockdep_map, "(&sess->free_work)", & __key, 0);
#line 416
  INIT_LIST_HEAD(& sess->free_work.entry);
#line 416
  sess->free_work.func = & qlt_free_session_done;
#line 417
  schedule_work___0(& sess->free_work);
#line 418
  return;
}
}
#line 419 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static char const   __kstrtab_qlt_unreg_sess[15U]  = 
#line 419
  {      'q',      'l',      't',      '_', 
        'u',      'n',      'r',      'e', 
        'g',      '_',      's',      'e', 
        's',      's',      '\000'};
#line 419
struct kernel_symbol  const  __ksymtab_qlt_unreg_sess ;
#line 419 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
struct kernel_symbol  const  __ksymtab_qlt_unreg_sess  =    {(unsigned long )(& qlt_unreg_sess), (char const   *)(& __kstrtab_qlt_unreg_sess)};
#line 422 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static int qlt_reset(struct scsi_qla_host *vha , void *iocb , int mcmd ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt_sess *sess ;
  uint32_t unpacked_lun ;
  uint32_t lun ;
  uint16_t loop_id ;
  int res ;
  struct imm_ntfy_from_isp *n ;
  struct atio_from_isp *a ;
  u64 tmp ;
  int tmp___0 ;

  {
#line 424
  ha = vha->hw;
#line 425
  sess = (struct qla_tgt_sess *)0;
#line 426
  lun = 0U;
#line 428
  res = 0;
#line 429
  n = (struct imm_ntfy_from_isp *)iocb;
#line 430
  a = (struct atio_from_isp *)iocb;
#line 432
  loop_id = n->u.isp24.nport_handle;
#line 433
  if ((unsigned int )loop_id == 65535U) {

  } else {
#line 463
    sess = (*((ha->tgt.tgt_ops)->find_sess_by_loop_id))(vha, (int )loop_id);
  }
#line 466
  ql_dbg(16384U, vha, 57344, "Using sess for qla_tgt_reset: %p\n", sess);
#line 468
  if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 469
    res = -3;
#line 470
    return (res);
  } else {

  }
#line 473
  ql_dbg(16384U, vha, 57415, "scsi(%ld): resetting (session %p from port %8phC mcmd %x, loop_id %d)\n",
         vha->host_no, sess, (uint8_t *)(& sess->port_name), mcmd, (int )loop_id);
#line 478
  lun = (uint32_t )a->u.isp24.fcp_cmnd.lun;
#line 479
  tmp = scsilun_to_int((struct scsi_lun *)(& lun));
#line 479
  unpacked_lun = (uint32_t )tmp;
#line 481
  tmp___0 = qlt_issue_task_mgmt(sess, unpacked_lun, mcmd, iocb, 1);
#line 481
  return (tmp___0);
}
}
#line 486 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_schedule_sess_for_deletion(struct qla_tgt_sess *sess , bool immediate ) 
{ 
  struct qla_tgt *tgt ;
  uint32_t dev_loss_tmo ;

  {
#line 489
  tgt = sess->tgt;
#line 490
  dev_loss_tmo = (uint32_t )((tgt->ha)->port_down_retry_count + 5);
#line 492
  if ((unsigned int )*((unsigned char *)sess + 8UL) != 0U) {
#line 493
    return;
  } else {

  }
#line 495
  ql_dbg(16384U, sess->vha, 57345, "Scheduling sess %p for deletion\n", sess);
#line 497
  list_add_tail(& sess->del_list_entry, & tgt->del_sess_list);
#line 498
  sess->deleted = 1U;
#line 500
  if ((int )immediate) {
#line 501
    dev_loss_tmo = 0U;
  } else {

  }
#line 503
  sess->expires = (unsigned long )(dev_loss_tmo * 250U) + (unsigned long )jiffies;
#line 505
  ql_dbg(16384U, sess->vha, 57416, "qla_target(%d): session for port %8phC (loop ID %d) scheduled for deletion in %u secs (expires: %lu) immed: %d\n",
         (int )(sess->vha)->vp_idx, (uint8_t *)(& sess->port_name), (int )sess->loop_id,
         dev_loss_tmo, sess->expires, (int )immediate);
#line 511
  if ((int )immediate) {
#line 512
    schedule_delayed_work(& tgt->sess_del_work, 0UL);
  } else {
#line 514
    schedule_delayed_work(& tgt->sess_del_work, sess->expires - (unsigned long )jiffies);
  }
#line 516
  return;
}
}
#line 519 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_clear_tgt_db(struct qla_tgt *tgt ) 
{ 
  struct qla_tgt_sess *sess ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 523
  __mptr = (struct list_head  const  *)tgt->sess_list.next;
#line 523
  sess = (struct qla_tgt_sess *)__mptr + 0xffffffffffffffd8UL;
#line 523
  goto ldv_66302;
  ldv_66301: 
#line 524
  qlt_schedule_sess_for_deletion(sess, 1);
#line 523
  __mptr___0 = (struct list_head  const  *)sess->sess_list_entry.next;
#line 523
  sess = (struct qla_tgt_sess *)__mptr___0 + 0xffffffffffffffd8UL;
  ldv_66302: ;
#line 523
  if ((unsigned long )(& sess->sess_list_entry) != (unsigned long )(& tgt->sess_list)) {
#line 525
    goto ldv_66301;
  } else {

  }

#line 530
  return;
}
}
#line 529 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static int qla24xx_get_loop_id(struct scsi_qla_host *vha , uint8_t const   *s_id ,
                               uint16_t *loop_id ) 
{ 
  struct qla_hw_data *ha ;
  dma_addr_t gid_list_dma ;
  struct gid_list_info *gid_list ;
  char *id_iter ;
  int res ;
  int rc ;
  int i ;
  uint16_t entries ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  struct gid_list_info *gid ;
  int tmp___2 ;

  {
#line 532
  ha = vha->hw;
#line 539
  tmp = qla2x00_gid_list_size(ha);
#line 539
  tmp___0 = dma_alloc_attrs(& (ha->pdev)->dev, (size_t )tmp, & gid_list_dma, 208U,
                            (struct dma_attrs *)0);
#line 539
  gid_list = (struct gid_list_info *)tmp___0;
#line 541
  if ((unsigned long )gid_list == (unsigned long )((struct gid_list_info *)0)) {
#line 542
    tmp___1 = qla2x00_gid_list_size(ha);
#line 542
    ql_dbg(8192U, vha, 61508, "qla_target(%d): DMA Alloc failed of %u\n", (int )vha->vp_idx,
           tmp___1);
#line 545
    return (-12);
  } else {

  }
#line 549
  rc = qla2x00_get_id_list(vha, (void *)gid_list, gid_list_dma, & entries);
#line 550
  if (rc != 0) {
#line 551
    ql_dbg(8192U, vha, 61509, "qla_target(%d): get_id_list() failed: %x\n", (int )vha->vp_idx,
           rc);
#line 554
    res = -1;
#line 555
    goto out_free_id_list;
  } else {

  }
#line 558
  id_iter = (char *)gid_list;
#line 559
  res = -1;
#line 560
  i = 0;
#line 560
  goto ldv_66321;
  ldv_66320: 
#line 561
  gid = (struct gid_list_info *)id_iter;
#line 562
  if (((int )gid->al_pa == (int )((unsigned char )*(s_id + 2UL)) && (int )gid->area == (int )((unsigned char )*(s_id + 1UL))) && (int )gid->domain == (int )((unsigned char )*s_id)) {
#line 565
    *loop_id = gid->loop_id;
#line 566
    res = 0;
#line 567
    goto ldv_66319;
  } else {

  }
#line 569
  id_iter = id_iter + (unsigned long )ha->gid_list_info_size;
#line 560
  i = i + 1;
  ldv_66321: ;
#line 560
  if ((int )entries > i) {
#line 562
    goto ldv_66320;
  } else {

  }
  ldv_66319: ;
  out_free_id_list: 
#line 573
  tmp___2 = qla2x00_gid_list_size(ha);
#line 573
  dma_free_attrs(& (ha->pdev)->dev, (size_t )tmp___2, (void *)gid_list, gid_list_dma,
                 (struct dma_attrs *)0);
#line 575
  return (res);
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_undelete_sess(struct qla_tgt_sess *sess ) 
{ 
  long tmp ;

  {
#line 581
  tmp = ldv__builtin_expect((unsigned int )*((unsigned char *)sess + 8UL) == 0U, 0L);
#line 581
  if (tmp != 0L) {
#line 581
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"),
                         "i" (581), "i" (12UL));
    ldv_66325: ;
#line 581
    goto ldv_66325;
  } else {

  }
#line 583
  list_del(& sess->del_list_entry);
#line 584
  sess->deleted = 0U;
#line 585
  return;
}
}
#line 587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_del_sess_work_fn(struct delayed_work *work ) 
{ 
  struct qla_tgt *tgt ;
  struct delayed_work  const  *__mptr ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct qla_tgt_sess *sess ;
  unsigned long flags ;
  unsigned long elapsed ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr___0 ;
  int tmp___0 ;

  {
#line 589
  __mptr = (struct delayed_work  const  *)work;
#line 589
  tgt = (struct qla_tgt *)__mptr + 0xffffffffffffffb0UL;
#line 591
  vha = tgt->vha;
#line 592
  ha = vha->hw;
#line 596
  tmp = spinlock_check(& ha->hardware_lock);
#line 596
  flags = _raw_spin_lock_irqsave(tmp);
#line 597
  goto ldv_66350;
  ldv_66349: 
#line 598
  __mptr___0 = (struct list_head  const  *)tgt->del_sess_list.next;
#line 598
  sess = (struct qla_tgt_sess *)__mptr___0 + 0xffffffffffffffc0UL;
#line 600
  elapsed = jiffies;
#line 601
  if ((long )(elapsed - sess->expires) >= 0L) {
#line 602
    qlt_undelete_sess(sess);
#line 604
    ql_dbg(8192U, vha, 61444, "Timeout: sess %p about to be deleted\n", sess);
#line 607
    (*((ha->tgt.tgt_ops)->shutdown_sess))(sess);
#line 608
    (*((ha->tgt.tgt_ops)->put_sess))(sess);
  } else {
#line 610
    schedule_delayed_work(& tgt->sess_del_work, sess->expires - elapsed);
#line 612
    goto ldv_66348;
  }
  ldv_66350: 
#line 597
  tmp___0 = list_empty((struct list_head  const  *)(& tgt->del_sess_list));
#line 597
  if (tmp___0 == 0) {
#line 599
    goto ldv_66349;
  } else {

  }
  ldv_66348: 
#line 615
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 616
  return;
}
}
#line 622 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static struct qla_tgt_sess *qlt_create_sess(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                            bool local ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt_sess *sess ;
  unsigned long flags ;
  unsigned char be_sid[3U] ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  struct list_head  const  *__mptr___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  raw_spinlock_t *tmp___3 ;

  {
#line 627
  ha = vha->hw;
#line 633
  tmp = spinlock_check(& ha->hardware_lock);
#line 633
  flags = _raw_spin_lock_irqsave(tmp);
#line 634
  __mptr = (struct list_head  const  *)(vha->vha_tgt.qla_tgt)->sess_list.next;
#line 634
  sess = (struct qla_tgt_sess *)__mptr + 0xffffffffffffffd8UL;
#line 634
  goto ldv_66368;
  ldv_66367: 
#line 636
  tmp___0 = memcmp((void const   *)(& sess->port_name), (void const   *)(& fcport->port_name),
                   8UL);
#line 636
  if (tmp___0 == 0) {
#line 637
    ql_dbg(8192U, vha, 61445, "Double sess %p found (s_id %x:%x:%x, loop_id %d), updating to d_id %x:%x:%x, loop_id %d",
           sess, (int )sess->s_id.b.domain, (int )sess->s_id.b.al_pa, (int )sess->s_id.b.area,
           (int )sess->loop_id, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.al_pa,
           (int )fcport->d_id.b.area, (int )fcport->loop_id);
#line 646
    if ((unsigned int )*((unsigned char *)sess + 8UL) != 0U) {
#line 647
      qlt_undelete_sess(sess);
    } else {

    }
#line 649
    kref_get___0(& (sess->se_sess)->sess_kref);
#line 650
    (*((ha->tgt.tgt_ops)->update_sess))(sess, fcport->d_id, (int )fcport->loop_id,
                                        (fcport->flags & 16U) != 0U);
#line 653
    if ((unsigned int )*((unsigned char *)sess + 8UL) != 0U && ! local) {
#line 654
      sess->local = 0U;
    } else {

    }
#line 655
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 657
    return (sess);
  } else {

  }
#line 634
  __mptr___0 = (struct list_head  const  *)sess->sess_list_entry.next;
#line 634
  sess = (struct qla_tgt_sess *)__mptr___0 + 0xffffffffffffffd8UL;
  ldv_66368: ;
#line 634
  if ((unsigned long )(& sess->sess_list_entry) != (unsigned long )(& (vha->vha_tgt.qla_tgt)->sess_list)) {
#line 636
    goto ldv_66367;
  } else {

  }
#line 660
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 662
  tmp___1 = kzalloc(168UL, 208U);
#line 662
  sess = (struct qla_tgt_sess *)tmp___1;
#line 663
  if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 664
    ql_dbg(8192U, vha, 61514, "qla_target(%u): session allocation failed, all commands from port %8phC will be refused",
           (int )vha->vp_idx, (uint8_t *)(& fcport->port_name));
#line 669
    return ((struct qla_tgt_sess *)0);
  } else {

  }
#line 671
  sess->tgt = vha->vha_tgt.qla_tgt;
#line 672
  sess->vha = vha;
#line 673
  sess->s_id = fcport->d_id;
#line 674
  sess->loop_id = fcport->loop_id;
#line 675
  sess->local = (unsigned char )local;
#line 677
  ql_dbg(8192U, vha, 61446, "Adding sess %p to tgt %p via ->check_initiator_node_acl()\n",
         sess, vha->vha_tgt.qla_tgt);
#line 681
  be_sid[0] = sess->s_id.b.domain;
#line 682
  be_sid[1] = sess->s_id.b.area;
#line 683
  be_sid[2] = sess->s_id.b.al_pa;
#line 690
  tmp___2 = (*((ha->tgt.tgt_ops)->check_initiator_node_acl))(vha, (unsigned char *)(& fcport->port_name),
                                                             (void *)sess, (uint8_t *)(& be_sid),
                                                             (int )fcport->loop_id);
#line 690
  if (tmp___2 < 0) {
#line 692
    kfree((void const   *)sess);
#line 693
    return ((struct qla_tgt_sess *)0);
  } else {

  }
#line 699
  kref_get___0(& (sess->se_sess)->sess_kref);
#line 701
  sess->conf_compl_supported = 0U;
#line 703
  memcpy((void *)(& sess->port_name), (void const   *)(& fcport->port_name), 8UL);
#line 705
  tmp___3 = spinlock_check(& ha->hardware_lock);
#line 705
  flags = _raw_spin_lock_irqsave(tmp___3);
#line 706
  list_add_tail(& sess->sess_list_entry, & (vha->vha_tgt.qla_tgt)->sess_list);
#line 707
  (vha->vha_tgt.qla_tgt)->sess_count = (vha->vha_tgt.qla_tgt)->sess_count + 1;
#line 708
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 710
  ql_dbg(8192U, vha, 61515, "qla_target(%d): %ssession for wwn %8phC (loop_id %d, s_id %x:%x:%x, confirmed completion %ssupported) added\n",
         (int )vha->vp_idx, (int )local ? (char *)"local " : (char *)"", (uint8_t *)(& fcport->port_name),
         (int )fcport->loop_id, (int )sess->s_id.b.domain, (int )sess->s_id.b.area,
         (int )sess->s_id.b.al_pa, (unsigned int )*((unsigned char *)sess + 8UL) != 0U ? (char *)"" : (char *)"not ");
#line 717
  return (sess);
}
}
#line 723 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_fc_port_added(struct scsi_qla_host *vha , fc_port_t *fcport ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt *tgt ;
  struct qla_tgt_sess *sess ;
  unsigned long flags ;
  bool tmp ;
  raw_spinlock_t *tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
#line 725
  ha = vha->hw;
#line 726
  tgt = vha->vha_tgt.qla_tgt;
#line 730
  if ((unsigned long )(vha->hw)->tgt.tgt_ops == (unsigned long )((struct qla_tgt_func_tmpl *)0)) {
#line 731
    return;
  } else {

  }
#line 733
  if ((unsigned long )tgt == (unsigned long )((struct qla_tgt *)0) || (unsigned int )fcport->port_type != 4U) {
#line 734
    return;
  } else {

  }
#line 736
  tmp = qla_ini_mode_enabled(vha);
#line 736
  if ((int )tmp) {
#line 737
    return;
  } else {

  }
#line 739
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 739
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 740
  if (tgt->tgt_stop != 0) {
#line 741
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 742
    return;
  } else {

  }
#line 744
  sess = qlt_find_sess_by_port_name(tgt, (uint8_t const   *)(& fcport->port_name));
#line 745
  if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 746
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 748
    mutex_lock_nested(& vha->vha_tgt.tgt_mutex, 0U);
#line 749
    sess = qlt_create_sess(vha, fcport, 0);
#line 750
    mutex_unlock(& vha->vha_tgt.tgt_mutex);
#line 752
    tmp___1 = spinlock_check(& ha->hardware_lock);
#line 752
    flags = _raw_spin_lock_irqsave(tmp___1);
  } else {
#line 754
    kref_get___0(& (sess->se_sess)->sess_kref);
#line 756
    if ((unsigned int )*((unsigned char *)sess + 8UL) != 0U) {
#line 757
      qlt_undelete_sess(sess);
#line 759
      ql_dbg(8192U, vha, 61516, "qla_target(%u): %ssession for port %8phC (loop ID %d) reappeared\n",
             (int )vha->vp_idx, (unsigned int )*((unsigned char *)sess + 8UL) != 0U ? (char *)"local " : (char *)"",
             (uint8_t *)(& sess->port_name), (int )sess->loop_id);
#line 765
      ql_dbg(8192U, vha, 61447, "Reappeared sess %p\n", sess);
    } else {

    }
#line 768
    (*((ha->tgt.tgt_ops)->update_sess))(sess, fcport->d_id, (int )fcport->loop_id,
                                        (fcport->flags & 16U) != 0U);
  }
#line 772
  if ((unsigned long )sess != (unsigned long )((struct qla_tgt_sess *)0) && (unsigned int )*((unsigned char *)sess + 8UL) != 0U) {
#line 773
    ql_dbg(8192U, vha, 61517, "qla_target(%u): local session for port %8phC (loop ID %d) became global\n",
           (int )vha->vp_idx, (uint8_t *)(& fcport->port_name), (int )sess->loop_id);
#line 777
    sess->local = 0U;
  } else {

  }
#line 779
  (*((ha->tgt.tgt_ops)->put_sess))(sess);
#line 780
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 781
  return;
}
}
#line 783 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_fc_port_deleted(struct scsi_qla_host *vha , fc_port_t *fcport ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt *tgt ;
  struct qla_tgt_sess *sess ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 785
  ha = vha->hw;
#line 786
  tgt = vha->vha_tgt.qla_tgt;
#line 790
  if ((unsigned long )(vha->hw)->tgt.tgt_ops == (unsigned long )((struct qla_tgt_func_tmpl *)0)) {
#line 791
    return;
  } else {

  }
#line 793
  if ((unsigned long )tgt == (unsigned long )((struct qla_tgt *)0) || (unsigned int )fcport->port_type != 4U) {
#line 794
    return;
  } else {

  }
#line 796
  tmp = spinlock_check(& ha->hardware_lock);
#line 796
  flags = _raw_spin_lock_irqsave(tmp);
#line 797
  if (tgt->tgt_stop != 0) {
#line 798
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 799
    return;
  } else {

  }
#line 801
  sess = qlt_find_sess_by_port_name(tgt, (uint8_t const   *)(& fcport->port_name));
#line 802
  if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 803
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 804
    return;
  } else {

  }
#line 807
  ql_dbg(8192U, vha, 61448, "qla_tgt_fc_port_deleted %p", sess);
#line 809
  sess->local = 1U;
#line 810
  qlt_schedule_sess_for_deletion(sess, 0);
#line 811
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 812
  return;
}
}
#line 814 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
__inline static int test_tgt_sess_count(struct qla_tgt *tgt ) 
{ 
  struct qla_hw_data *ha ;
  unsigned long flags ;
  int res ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;

  {
#line 816
  ha = tgt->ha;
#line 823
  tmp = spinlock_check(& ha->hardware_lock);
#line 823
  flags = _raw_spin_lock_irqsave(tmp);
#line 824
  tmp___0 = list_empty((struct list_head  const  *)(& tgt->sess_list));
#line 824
  ql_dbg(16384U, tgt->vha, 57346, "tgt %p, empty(sess_list)=%d sess_count=%d\n", tgt,
         tmp___0, tgt->sess_count);
#line 827
  res = tgt->sess_count == 0;
#line 828
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 830
  return (res);
}
}
#line 834 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
int qlt_stop_phase1(struct qla_tgt *tgt ) 
{ 
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  unsigned long flags ;
  struct Scsi_Host *sh ;
  struct fc_host_attrs *fc_host ;
  bool npiv_vports ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  wait_queue_t __wait ;
  long __ret ;
  long __int ;
  long tmp___6 ;
  int tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;
  wait_queue_t __wait___0 ;
  long __ret___0 ;
  long __int___0 ;
  long tmp___10 ;
  int tmp___11 ;

  {
#line 836
  vha = tgt->vha;
#line 837
  ha = tgt->ha;
#line 840
  mutex_lock_nested(& qla_tgt_mutex, 0U);
#line 841
  if ((unsigned long )vha->fc_vport == (unsigned long )((struct fc_vport *)0)) {
#line 842
    sh = vha->host;
#line 843
    fc_host = (struct fc_host_attrs *)sh->shost_data;
#line 846
    tmp = spinlock_check(sh->host_lock);
#line 846
    flags = _raw_spin_lock_irqsave(tmp);
#line 847
    npiv_vports = (unsigned int )fc_host->npiv_vports_inuse != 0U;
#line 848
    spin_unlock_irqrestore(sh->host_lock, flags);
#line 850
    if ((int )npiv_vports) {
#line 851
      mutex_unlock(& qla_tgt_mutex);
#line 852
      return (-1);
    } else {

    }
  } else {

  }
#line 855
  if (tgt->tgt_stop != 0 || tgt->tgt_stopped != 0) {
#line 856
    ql_dbg(8192U, vha, 61518, "Already in tgt->tgt_stop or tgt_stopped state\n");
#line 858
    mutex_unlock(& qla_tgt_mutex);
#line 859
    return (-1);
  } else {

  }
#line 862
  ql_dbg(16384U, vha, 57347, "Stopping target for host %ld(%p)\n", vha->host_no, vha);
#line 868
  mutex_lock_nested(& vha->vha_tgt.tgt_mutex, 0U);
#line 869
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 869
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 870
  tgt->tgt_stop = 1;
#line 871
  qlt_clear_tgt_db(tgt);
#line 872
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 873
  mutex_unlock(& vha->vha_tgt.tgt_mutex);
#line 874
  mutex_unlock(& qla_tgt_mutex);
#line 876
  ldv_flush_delayed_work_301(& tgt->sess_del_work);
#line 878
  ql_dbg(8192U, vha, 61449, "Waiting for sess works (tgt %p)", tgt);
#line 880
  tmp___1 = spinlock_check(& tgt->sess_work_lock);
#line 880
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 881
  goto ldv_66429;
  ldv_66428: 
#line 882
  spin_unlock_irqrestore(& tgt->sess_work_lock, flags);
#line 883
  flush_scheduled_work();
#line 884
  tmp___2 = spinlock_check(& tgt->sess_work_lock);
#line 884
  flags = _raw_spin_lock_irqsave(tmp___2);
  ldv_66429: 
#line 881
  tmp___3 = list_empty((struct list_head  const  *)(& tgt->sess_works_list));
#line 881
  if (tmp___3 == 0) {
#line 883
    goto ldv_66428;
  } else {

  }
#line 886
  spin_unlock_irqrestore(& tgt->sess_work_lock, flags);
#line 888
  tmp___4 = list_empty((struct list_head  const  *)(& tgt->sess_list));
#line 888
  ql_dbg(8192U, vha, 61450, "Waiting for tgt %p: list_empty(sess_list)=%d sess_count=%d\n",
         tgt, tmp___4, tgt->sess_count);
#line 893
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c",
                893, 0);
#line 893
  tmp___5 = test_tgt_sess_count(tgt);
#line 893
  if (tmp___5 != 0) {
#line 893
    goto ldv_66431;
  } else {

  }
#line 893
  __ret = 0L;
#line 893
  INIT_LIST_HEAD(& __wait.task_list);
#line 893
  __wait.flags = 0U;
  ldv_66437: 
#line 893
  tmp___6 = prepare_to_wait_event(& tgt->waitQ, & __wait, 2);
#line 893
  __int = tmp___6;
#line 893
  tmp___7 = test_tgt_sess_count(tgt);
#line 893
  if (tmp___7 != 0) {
#line 893
    goto ldv_66436;
  } else {

  }
#line 893
  schedule();
#line 893
  goto ldv_66437;
  ldv_66436: 
#line 893
  finish_wait(& tgt->waitQ, & __wait);

  ldv_66431: ;
#line 896
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 896
    tmp___8 = qla_tgt_mode_enabled(vha);
#line 896
    if ((int )tmp___8) {
#line 897
      qlt_disable_vha(vha);
    } else {

    }
  } else {

  }
#line 900
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c",
                900, 0);
#line 900
  tmp___9 = test_tgt_sess_count(tgt);
#line 900
  if (tmp___9 != 0) {
#line 900
    goto ldv_66439;
  } else {

  }
#line 900
  __ret___0 = 0L;
#line 900
  INIT_LIST_HEAD(& __wait___0.task_list);
#line 900
  __wait___0.flags = 0U;
  ldv_66445: 
#line 900
  tmp___10 = prepare_to_wait_event(& tgt->waitQ, & __wait___0, 2);
#line 900
  __int___0 = tmp___10;
#line 900
  tmp___11 = test_tgt_sess_count(tgt);
#line 900
  if (tmp___11 != 0) {
#line 900
    goto ldv_66444;
  } else {

  }
#line 900
  schedule();
#line 900
  goto ldv_66445;
  ldv_66444: 
#line 900
  finish_wait(& tgt->waitQ, & __wait___0);

  ldv_66439: ;
#line 901
  return (0);
}
}
#line 903 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static char const   __kstrtab_qlt_stop_phase1[16U]  = 
#line 903
  {      'q',      'l',      't',      '_', 
        's',      't',      'o',      'p', 
        '_',      'p',      'h',      'a', 
        's',      'e',      '1',      '\000'};
#line 903
struct kernel_symbol  const  __ksymtab_qlt_stop_phase1 ;
#line 903 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
struct kernel_symbol  const  __ksymtab_qlt_stop_phase1  =    {(unsigned long )(& qlt_stop_phase1), (char const   *)(& __kstrtab_qlt_stop_phase1)};
#line 906 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_stop_phase2(struct qla_tgt *tgt ) 
{ 
  struct qla_hw_data *ha ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  unsigned long flags ;
  raw_spinlock_t *tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
#line 908
  ha = tgt->ha;
#line 909
  tmp = pci_get_drvdata(ha->pdev);
#line 909
  vha = (scsi_qla_host_t *)tmp;
#line 912
  if (tgt->tgt_stopped != 0) {
#line 913
    ql_dbg(8192U, vha, 61519, "Already in tgt->tgt_stopped state\n");
#line 915
    dump_stack();
#line 916
    return;
  } else {

  }
#line 919
  ql_dbg(8192U, vha, 61451, "Waiting for %d IRQ commands to complete (tgt %p)", tgt->irq_cmd_count,
         tgt);
#line 923
  mutex_lock_nested(& vha->vha_tgt.tgt_mutex, 0U);
#line 924
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 924
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 925
  goto ldv_66467;
  ldv_66466: 
#line 926
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 927
  __const_udelay(8590UL);
#line 928
  tmp___1 = spinlock_check(& ha->hardware_lock);
#line 928
  flags = _raw_spin_lock_irqsave(tmp___1);
  ldv_66467: ;
#line 925
  if (tgt->irq_cmd_count != 0) {
#line 927
    goto ldv_66466;
  } else {

  }
#line 930
  tgt->tgt_stop = 0;
#line 931
  tgt->tgt_stopped = 1;
#line 932
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 933
  mutex_unlock(& vha->vha_tgt.tgt_mutex);
#line 935
  ql_dbg(8192U, vha, 61452, "Stop of tgt %p finished", tgt);
#line 936
  return;
}
}
#line 938 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static char const   __kstrtab_qlt_stop_phase2[16U]  = 
#line 938
  {      'q',      'l',      't',      '_', 
        's',      't',      'o',      'p', 
        '_',      'p',      'h',      'a', 
        's',      'e',      '2',      '\000'};
#line 938
struct kernel_symbol  const  __ksymtab_qlt_stop_phase2 ;
#line 938 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
struct kernel_symbol  const  __ksymtab_qlt_stop_phase2  =    {(unsigned long )(& qlt_stop_phase2), (char const   *)(& __kstrtab_qlt_stop_phase2)};
#line 941 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_release(struct qla_tgt *tgt ) 
{ 
  scsi_qla_host_t *vha ;

  {
#line 943
  vha = tgt->vha;
#line 945
  if ((unsigned long )vha->vha_tgt.qla_tgt != (unsigned long )((struct qla_tgt *)0) && tgt->tgt_stopped == 0) {
#line 946
    qlt_stop_phase2(tgt);
  } else {

  }
#line 948
  vha->vha_tgt.qla_tgt = (struct qla_tgt *)0;
#line 950
  ql_dbg(8192U, vha, 61453, "Release of tgt %p finished\n", tgt);
#line 953
  kfree((void const   *)tgt);
#line 954
  return;
}
}
#line 957 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static int qlt_sched_sess_work(struct qla_tgt *tgt , int type , void const   *param ,
                               unsigned int param_size ) 
{ 
  struct qla_tgt_sess_work_param *prm ;
  unsigned long flags ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 963
  tmp = kzalloc(88UL, 32U);
#line 963
  prm = (struct qla_tgt_sess_work_param *)tmp;
#line 964
  if ((unsigned long )prm == (unsigned long )((struct qla_tgt_sess_work_param *)0)) {
#line 965
    ql_dbg(8192U, tgt->vha, 61520, "qla_target(%d): Unable to create session work, command will be refused",
           0);
#line 968
    return (-12);
  } else {

  }
#line 971
  ql_dbg(8192U, tgt->vha, 61454, "Scheduling work (type %d, prm %p) to find session for param %p (size %d, tgt %p)\n",
         type, prm, param, param_size, tgt);
#line 976
  prm->type = type;
#line 977
  memcpy((void *)(& prm->__annonCompField127.tm_iocb), param, (size_t )param_size);
#line 979
  tmp___0 = spinlock_check(& tgt->sess_work_lock);
#line 979
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 980
  list_add_tail(& prm->sess_works_list_entry, & tgt->sess_works_list);
#line 981
  spin_unlock_irqrestore(& tgt->sess_work_lock, flags);
#line 983
  schedule_work___0(& tgt->sess_work);
#line 985
  return (0);
}
}
#line 991 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_send_notify_ack(struct scsi_qla_host *vha , struct imm_ntfy_from_isp *ntfy ,
                                uint32_t add_flags , uint16_t resp_code , int resp_code_valid ,
                                uint16_t srr_flags , uint16_t srr_reject_code , uint8_t srr_explan ) 
{ 
  struct qla_hw_data *ha ;
  request_t *pkt ;
  struct nack_to_isp *nack ;
  int tmp ;
  void *tmp___0 ;

  {
#line 996
  ha = vha->hw;
#line 1000
  ql_dbg(16384U, vha, 57348, "Sending NOTIFY_ACK (ha=%p)\n", ha);
#line 1003
  tmp = qlt_issue_marker(vha, 1);
#line 1003
  if (tmp != 0) {
#line 1004
    return;
  } else {

  }
#line 1006
  tmp___0 = qla2x00_alloc_iocbs(vha, (srb_t *)0);
#line 1006
  pkt = (request_t *)tmp___0;
#line 1007
  if ((unsigned long )pkt == (unsigned long )((request_t *)0)) {
#line 1008
    ql_dbg(16384U, vha, 57417, "qla_target(%d): %s failed: unable to allocate request packet\n",
           (int )vha->vp_idx, "qlt_send_notify_ack");
#line 1011
    return;
  } else {

  }
#line 1014
  if ((unsigned long )vha->vha_tgt.qla_tgt != (unsigned long )((struct qla_tgt *)0)) {
#line 1015
    (vha->vha_tgt.qla_tgt)->notify_ack_expected = (vha->vha_tgt.qla_tgt)->notify_ack_expected + 1;
  } else {

  }
#line 1017
  pkt->entry_type = 14U;
#line 1018
  pkt->entry_count = 1U;
#line 1020
  nack = (struct nack_to_isp *)pkt;
#line 1021
  nack->ox_id = ntfy->ox_id;
#line 1023
  nack->u.isp24.nport_handle = ntfy->u.isp24.nport_handle;
#line 1024
  if ((unsigned int )ntfy->u.isp24.status == 70U) {
#line 1025
    nack->u.isp24.flags = (unsigned int )ntfy->u.isp24.flags & 1U;
  } else {

  }
#line 1028
  nack->u.isp24.srr_rx_id = ntfy->u.isp24.srr_rx_id;
#line 1029
  nack->u.isp24.status = ntfy->u.isp24.status;
#line 1030
  nack->u.isp24.status_subcode = ntfy->u.isp24.status_subcode;
#line 1031
  nack->u.isp24.fw_handle = ntfy->u.isp24.fw_handle;
#line 1032
  nack->u.isp24.exchange_address = ntfy->u.isp24.exchange_address;
#line 1033
  nack->u.isp24.srr_rel_offs = ntfy->u.isp24.srr_rel_offs;
#line 1034
  nack->u.isp24.srr_ui = ntfy->u.isp24.srr_ui;
#line 1035
  nack->u.isp24.srr_flags = srr_flags;
#line 1036
  nack->u.isp24.srr_reject_code = (uint8_t )srr_reject_code;
#line 1037
  nack->u.isp24.srr_reject_code_expl = srr_explan;
#line 1038
  nack->u.isp24.vp_index = ntfy->u.isp24.vp_index;
#line 1040
  ql_dbg(16384U, vha, 57349, "qla_target(%d): Sending 24xx Notify Ack %d\n", (int )vha->vp_idx,
         (int )nack->u.isp24.status);
#line 1045
  __asm__  volatile   ("sfence": : : "memory");
#line 1046
  qla2x00_start_iocbs(vha, vha->req);
#line 1047
  return;
}
}
#line 1052 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_24xx_send_abts_resp(struct scsi_qla_host *vha , struct abts_recv_from_24xx *abts ,
                                    uint32_t status , bool ids_reversed ) 
{ 
  struct qla_hw_data *ha ;
  struct abts_resp_to_24xx *resp ;
  uint32_t f_ctl ;
  uint8_t *p ;
  int tmp ;
  void *tmp___0 ;
  uint8_t *tmp___1 ;
  uint8_t *tmp___2 ;

  {
#line 1056
  ha = vha->hw;
#line 1061
  ql_dbg(16384U, vha, 57350, "Sending task mgmt ABTS response (ha=%p, atio=%p, status=%x\n",
         ha, abts, status);
#line 1066
  tmp = qlt_issue_marker(vha, 1);
#line 1066
  if (tmp != 0) {
#line 1067
    return;
  } else {

  }
#line 1069
  tmp___0 = qla2x00_alloc_iocbs_ready(vha, (srb_t *)0);
#line 1069
  resp = (struct abts_resp_to_24xx *)tmp___0;
#line 1070
  if ((unsigned long )resp == (unsigned long )((struct abts_resp_to_24xx *)0)) {
#line 1071
    ql_dbg(16384U, vha, 57418, "qla_target(%d): %s failed: unable to allocate request packet",
           (int )vha->vp_idx, "qlt_24xx_send_abts_resp");
#line 1074
    return;
  } else {

  }
#line 1077
  resp->entry_type = 85U;
#line 1078
  resp->entry_count = 1U;
#line 1079
  resp->nport_handle = abts->nport_handle;
#line 1080
  resp->vp_index = (uint8_t )vha->vp_idx;
#line 1081
  resp->sof_type = abts->sof_type;
#line 1082
  resp->exchange_address = abts->exchange_address;
#line 1083
  resp->fcp_hdr_le = abts->fcp_hdr_le;
#line 1084
  f_ctl = 10027008U;
#line 1087
  p = (uint8_t *)(& f_ctl);
#line 1088
  tmp___1 = p;
#line 1088
  p = p + 1;
#line 1088
  resp->fcp_hdr_le.f_ctl[0] = *tmp___1;
#line 1089
  tmp___2 = p;
#line 1089
  p = p + 1;
#line 1089
  resp->fcp_hdr_le.f_ctl[1] = *tmp___2;
#line 1090
  resp->fcp_hdr_le.f_ctl[2] = *p;
#line 1091
  if ((int )ids_reversed) {
#line 1092
    resp->fcp_hdr_le.d_id[0] = abts->fcp_hdr_le.d_id[0];
#line 1093
    resp->fcp_hdr_le.d_id[1] = abts->fcp_hdr_le.d_id[1];
#line 1094
    resp->fcp_hdr_le.d_id[2] = abts->fcp_hdr_le.d_id[2];
#line 1095
    resp->fcp_hdr_le.s_id[0] = abts->fcp_hdr_le.s_id[0];
#line 1096
    resp->fcp_hdr_le.s_id[1] = abts->fcp_hdr_le.s_id[1];
#line 1097
    resp->fcp_hdr_le.s_id[2] = abts->fcp_hdr_le.s_id[2];
  } else {
#line 1099
    resp->fcp_hdr_le.d_id[0] = abts->fcp_hdr_le.s_id[0];
#line 1100
    resp->fcp_hdr_le.d_id[1] = abts->fcp_hdr_le.s_id[1];
#line 1101
    resp->fcp_hdr_le.d_id[2] = abts->fcp_hdr_le.s_id[2];
#line 1102
    resp->fcp_hdr_le.s_id[0] = abts->fcp_hdr_le.d_id[0];
#line 1103
    resp->fcp_hdr_le.s_id[1] = abts->fcp_hdr_le.d_id[1];
#line 1104
    resp->fcp_hdr_le.s_id[2] = abts->fcp_hdr_le.d_id[2];
  }
#line 1106
  resp->exchange_addr_to_abort = abts->exchange_addr_to_abort;
#line 1107
  if (status == 0U) {
#line 1108
    resp->fcp_hdr_le.r_ctl = 132U;
#line 1109
    resp->payload.ba_acct.seq_id_valid = 0U;
#line 1110
    resp->payload.ba_acct.low_seq_cnt = 0U;
#line 1111
    resp->payload.ba_acct.high_seq_cnt = 65535U;
#line 1112
    resp->payload.ba_acct.ox_id = abts->fcp_hdr_le.ox_id;
#line 1113
    resp->payload.ba_acct.rx_id = abts->fcp_hdr_le.rx_id;
  } else {
#line 1115
    resp->fcp_hdr_le.r_ctl = 133U;
#line 1116
    resp->payload.ba_rjt.reason_code = 9U;
  }
#line 1121
  (vha->vha_tgt.qla_tgt)->abts_resp_expected = (vha->vha_tgt.qla_tgt)->abts_resp_expected + 1;
#line 1124
  __asm__  volatile   ("sfence": : : "memory");
#line 1125
  qla2x00_start_iocbs(vha, vha->req);
#line 1126
  return;
}
}
#line 1131 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_24xx_retry_term_exchange(struct scsi_qla_host *vha , struct abts_resp_from_24xx_fw *entry ) 
{ 
  struct ctio7_to_24xx *ctio ;
  int tmp ;
  void *tmp___0 ;

  {
#line 1136
  ql_dbg(16384U, vha, 57351, "Sending retry TERM EXCH CTIO7 (ha=%p)\n", vha->hw);
#line 1139
  tmp = qlt_issue_marker(vha, 1);
#line 1139
  if (tmp != 0) {
#line 1140
    return;
  } else {

  }
#line 1142
  tmp___0 = qla2x00_alloc_iocbs_ready(vha, (srb_t *)0);
#line 1142
  ctio = (struct ctio7_to_24xx *)tmp___0;
#line 1143
  if ((unsigned long )ctio == (unsigned long )((struct ctio7_to_24xx *)0)) {
#line 1144
    ql_dbg(16384U, vha, 57419, "qla_target(%d): %s failed: unable to allocate request packet\n",
           (int )vha->vp_idx, "qlt_24xx_retry_term_exchange");
#line 1147
    return;
  } else {

  }
#line 1155
  ctio->entry_type = 18U;
#line 1156
  ctio->entry_count = 1U;
#line 1157
  ctio->nport_handle = entry->nport_handle;
#line 1158
  ctio->handle = 4294967295U;
#line 1159
  ctio->timeout = 10U;
#line 1160
  ctio->vp_index = (uint8_t )vha->vp_idx;
#line 1161
  ctio->initiator_id[0] = entry->fcp_hdr_le.d_id[0];
#line 1162
  ctio->initiator_id[1] = entry->fcp_hdr_le.d_id[1];
#line 1163
  ctio->initiator_id[2] = entry->fcp_hdr_le.d_id[2];
#line 1164
  ctio->exchange_addr = entry->exchange_addr_to_abort;
#line 1165
  ctio->u.status1.flags = 16448U;
#line 1168
  ctio->u.status1.ox_id = entry->fcp_hdr_le.ox_id;
#line 1171
  __asm__  volatile   ("sfence": : : "memory");
#line 1172
  qla2x00_start_iocbs(vha, vha->req);
#line 1174
  qlt_24xx_send_abts_resp(vha, (struct abts_recv_from_24xx *)entry, 0U, 1);
#line 1175
  return;
}
}
#line 1179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static int __qlt_24xx_handle_abts(struct scsi_qla_host *vha , struct abts_recv_from_24xx *abts ,
                                  struct qla_tgt_sess *sess ) 
{ 
  struct qla_hw_data *ha ;
  struct se_session *se_sess ;
  struct qla_tgt_mgmt_cmd *mcmd ;
  struct se_cmd *se_cmd ;
  u32 lun ;
  int rc ;
  bool found_lun ;
  struct list_head  const  *__mptr ;
  struct qla_tgt_cmd *cmd ;
  struct se_cmd  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  void *tmp ;

  {
#line 1182
  ha = vha->hw;
#line 1183
  se_sess = sess->se_sess;
#line 1186
  lun = 0U;
#line 1188
  found_lun = 0;
#line 1190
  spin_lock(& se_sess->sess_cmd_lock);
#line 1191
  __mptr = (struct list_head  const  *)se_sess->sess_cmd_list.next;
#line 1191
  se_cmd = (struct se_cmd *)__mptr + 0xffffffffffffff70UL;
#line 1191
  goto ldv_66543;
  ldv_66542: 
#line 1193
  __mptr___0 = (struct se_cmd  const  *)se_cmd;
#line 1193
  cmd = (struct qla_tgt_cmd *)__mptr___0;
#line 1194
  if (se_cmd->tag == (u64 )abts->exchange_addr_to_abort) {
#line 1195
    lun = cmd->unpacked_lun;
#line 1196
    found_lun = 1;
#line 1197
    goto ldv_66541;
  } else {

  }
#line 1191
  __mptr___1 = (struct list_head  const  *)se_cmd->se_cmd_list.next;
#line 1191
  se_cmd = (struct se_cmd *)__mptr___1 + 0xffffffffffffff70UL;
  ldv_66543: ;
#line 1191
  if ((unsigned long )(& se_cmd->se_cmd_list) != (unsigned long )(& se_sess->sess_cmd_list)) {
#line 1193
    goto ldv_66542;
  } else {

  }
  ldv_66541: 
#line 1200
  spin_unlock(& se_sess->sess_cmd_lock);
#line 1202
  if (! found_lun) {
#line 1203
    return (-2);
  } else {

  }
#line 1205
  ql_dbg(8192U, vha, 61455, "qla_target(%d): task abort (tag=%d)\n", (int )vha->vp_idx,
         abts->exchange_addr_to_abort);
#line 1209
  tmp = mempool_alloc(qla_tgt_mgmt_cmd_mempool, 32U);
#line 1209
  mcmd = (struct qla_tgt_mgmt_cmd *)tmp;
#line 1210
  if ((unsigned long )mcmd == (unsigned long )((struct qla_tgt_mgmt_cmd *)0)) {
#line 1211
    ql_dbg(8192U, vha, 61521, "qla_target(%d): %s: Allocation of ABORT cmd failed",
           (int )vha->vp_idx, "__qlt_24xx_handle_abts");
#line 1214
    return (-12);
  } else {

  }
#line 1216
  memset((void *)mcmd, 0, 1000UL);
#line 1218
  mcmd->sess = sess;
#line 1219
  memcpy((void *)(& mcmd->orig_iocb.abts), (void const   *)abts, 64UL);
#line 1220
  mcmd->reset_count = (vha->hw)->chip_reset;
#line 1222
  rc = (*((ha->tgt.tgt_ops)->handle_tmr))(mcmd, lun, 1, abts->exchange_addr_to_abort);
#line 1224
  if (rc != 0) {
#line 1225
    ql_dbg(8192U, vha, 61522, "qla_target(%d):  tgt_ops->handle_tmr() failed: %d",
           (int )vha->vp_idx, rc);
#line 1228
    mempool_free((void *)mcmd, qla_tgt_mgmt_cmd_mempool);
#line 1229
    return (-14);
  } else {

  }
#line 1232
  return (0);
}
}
#line 1238 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_24xx_handle_abts(struct scsi_qla_host *vha , struct abts_recv_from_24xx *abts ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt_sess *sess ;
  uint32_t tag ;
  uint8_t s_id[3U] ;
  int rc ;

  {
#line 1241
  ha = vha->hw;
#line 1243
  tag = abts->exchange_addr_to_abort;
#line 1247
  if ((int )abts->fcp_hdr_le.parameter & 1) {
#line 1248
    ql_dbg(8192U, vha, 61523, "qla_target(%d): ABTS: Abort Sequence not supported\n",
           (int )vha->vp_idx);
#line 1251
    qlt_24xx_send_abts_resp(vha, abts, 4U, 0);
#line 1252
    return;
  } else {

  }
#line 1255
  if (tag == 4294967295U) {
#line 1256
    ql_dbg(8192U, vha, 61456, "qla_target(%d): ABTS: Unknown Exchange Address received\n",
           (int )vha->vp_idx);
#line 1259
    qlt_24xx_send_abts_resp(vha, abts, 4U, 0);
#line 1260
    return;
  } else {

  }
#line 1263
  ql_dbg(8192U, vha, 61457, "qla_target(%d): task abort (s_id=%x:%x:%x, tag=%d, param=%x)\n",
         (int )vha->vp_idx, (int )abts->fcp_hdr_le.s_id[2], (int )abts->fcp_hdr_le.s_id[1],
         (int )abts->fcp_hdr_le.s_id[0], tag, abts->fcp_hdr_le.parameter);
#line 1269
  s_id[0] = abts->fcp_hdr_le.s_id[2];
#line 1270
  s_id[1] = abts->fcp_hdr_le.s_id[1];
#line 1271
  s_id[2] = abts->fcp_hdr_le.s_id[0];
#line 1273
  sess = (*((ha->tgt.tgt_ops)->find_sess_by_s_id))(vha, (uint8_t const   *)(& s_id));
#line 1274
  if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 1275
    ql_dbg(8192U, vha, 61458, "qla_target(%d): task abort for non-existant session\n",
           (int )vha->vp_idx);
#line 1278
    rc = qlt_sched_sess_work(vha->vha_tgt.qla_tgt, 1, (void const   *)abts, 64U);
#line 1280
    if (rc != 0) {
#line 1281
      qlt_24xx_send_abts_resp(vha, abts, 4U, 0);
    } else {

    }
#line 1284
    return;
  } else {

  }
#line 1287
  rc = __qlt_24xx_handle_abts(vha, abts, sess);
#line 1288
  if (rc != 0) {
#line 1289
    ql_dbg(8192U, vha, 61524, "qla_target(%d): __qlt_24xx_handle_abts() failed: %d\n",
           (int )vha->vp_idx, rc);
#line 1292
    qlt_24xx_send_abts_resp(vha, abts, 4U, 0);
#line 1293
    return;
  } else {

  }
#line 1295
  return;
}
}
#line 1300 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_24xx_send_task_mgmt_ctio(struct scsi_qla_host *ha , struct qla_tgt_mgmt_cmd *mcmd ,
                                         uint32_t resp_code ) 
{ 
  struct atio_from_isp *atio ;
  struct ctio7_to_24xx *ctio ;
  uint16_t temp ;
  int tmp ;
  void *tmp___0 ;
  __u16 tmp___1 ;

  {
#line 1303
  atio = & mcmd->orig_iocb.atio;
#line 1307
  ql_dbg(16384U, ha, 57352, "Sending task mgmt CTIO7 (ha=%p, atio=%p, resp_code=%x\n",
         ha, atio, resp_code);
#line 1312
  tmp = qlt_issue_marker(ha, 1);
#line 1312
  if (tmp != 0) {
#line 1313
    return;
  } else {

  }
#line 1315
  tmp___0 = qla2x00_alloc_iocbs(ha, (srb_t *)0);
#line 1315
  ctio = (struct ctio7_to_24xx *)tmp___0;
#line 1316
  if ((unsigned long )ctio == (unsigned long )((struct ctio7_to_24xx *)0)) {
#line 1317
    ql_dbg(16384U, ha, 57420, "qla_target(%d): %s failed: unable to allocate request packet\n",
           (int )ha->vp_idx, "qlt_24xx_send_task_mgmt_ctio");
#line 1320
    return;
  } else {

  }
#line 1323
  ctio->entry_type = 18U;
#line 1324
  ctio->entry_count = 1U;
#line 1325
  ctio->handle = 4294967295U;
#line 1326
  ctio->nport_handle = (mcmd->sess)->loop_id;
#line 1327
  ctio->timeout = 10U;
#line 1328
  ctio->vp_index = (uint8_t )ha->vp_idx;
#line 1329
  ctio->initiator_id[0] = atio->u.isp24.fcp_hdr.s_id[2];
#line 1330
  ctio->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];
#line 1331
  ctio->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];
#line 1332
  ctio->exchange_addr = atio->u.isp24.exchange_addr;
#line 1333
  ctio->u.status1.flags = (uint16_t )((int )((short )((int )atio->u.isp24.attr << 9)) | -32704);
#line 1336
  tmp___1 = __fswab16((int )atio->u.isp24.fcp_hdr.ox_id);
#line 1336
  temp = tmp___1;
#line 1337
  ctio->u.status1.ox_id = temp;
#line 1338
  ctio->u.status1.scsi_status = 256U;
#line 1340
  ctio->u.status1.response_len = 8U;
#line 1341
  ctio->u.status1.sense_data[0] = (uint8_t )resp_code;
#line 1344
  __asm__  volatile   ("sfence": : : "memory");
#line 1345
  qla2x00_start_iocbs(ha, ha->req);
#line 1346
  return;
}
}
#line 1348 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_free_mcmd(struct qla_tgt_mgmt_cmd *mcmd ) 
{ 


  {
#line 1350
  mempool_free((void *)mcmd, qla_tgt_mgmt_cmd_mempool);
#line 1351
  return;
}
}
#line 1352 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static char const   __kstrtab_qlt_free_mcmd[14U]  = 
#line 1352
  {      'q',      'l',      't',      '_', 
        'f',      'r',      'e',      'e', 
        '_',      'm',      'c',      'm', 
        'd',      '\000'};
#line 1352
struct kernel_symbol  const  __ksymtab_qlt_free_mcmd ;
#line 1352 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
struct kernel_symbol  const  __ksymtab_qlt_free_mcmd  =    {(unsigned long )(& qlt_free_mcmd), (char const   *)(& __kstrtab_qlt_free_mcmd)};
#line 1355 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_xmit_tm_rsp(struct qla_tgt_mgmt_cmd *mcmd ) 
{ 
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1357
  vha = (mcmd->sess)->vha;
#line 1358
  ha = vha->hw;
#line 1361
  ql_dbg(8192U, vha, 61459, "TM response mcmd (%p) status %#x state %#x", mcmd, (int )mcmd->fc_tm_rsp,
         mcmd->flags);
#line 1365
  tmp = spinlock_check(& ha->hardware_lock);
#line 1365
  flags = _raw_spin_lock_irqsave(tmp);
#line 1367
  tmp___1 = qla2x00_reset_active(vha);
#line 1367
  if (tmp___1 != 0 || mcmd->reset_count != ha->chip_reset) {
#line 1372
    tmp___0 = qla2x00_reset_active(vha);
#line 1372
    ql_dbg(33554432U, vha, 57600, "RESET-TMR active/old-count/new-count = %d/%d/%d.\n",
           tmp___0, mcmd->reset_count, ha->chip_reset);
#line 1376
    (*((ha->tgt.tgt_ops)->free_mcmd))(mcmd);
#line 1377
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1378
    return;
  } else {

  }
#line 1381
  if (mcmd->flags == 1U) {
#line 1382
    qlt_send_notify_ack(vha, & mcmd->orig_iocb.imm_ntfy, 0U, 0, 0, 0, 0, 0);
  } else
#line 1385
  if ((unsigned int )(mcmd->se_cmd.se_tmr_req)->function == 1U) {
#line 1386
    qlt_24xx_send_abts_resp(vha, & mcmd->orig_iocb.abts, (uint32_t )mcmd->fc_tm_rsp,
                            0);
  } else {
#line 1389
    qlt_24xx_send_task_mgmt_ctio(vha, mcmd, (uint32_t )mcmd->fc_tm_rsp);
  }
#line 1400
  (*((ha->tgt.tgt_ops)->free_mcmd))(mcmd);
#line 1401
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1402
  return;
}
}
#line 1403 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static char const   __kstrtab_qlt_xmit_tm_rsp[16U]  = 
#line 1403
  {      'q',      'l',      't',      '_', 
        'x',      'm',      'i',      't', 
        '_',      't',      'm',      '_', 
        'r',      's',      'p',      '\000'};
#line 1403
struct kernel_symbol  const  __ksymtab_qlt_xmit_tm_rsp ;
#line 1403 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
struct kernel_symbol  const  __ksymtab_qlt_xmit_tm_rsp  =    {(unsigned long )(& qlt_xmit_tm_rsp), (char const   *)(& __kstrtab_qlt_xmit_tm_rsp)};
#line 1406 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static int qlt_pci_map_calc_cnt(struct qla_tgt_prm *prm ) 
{ 
  struct qla_tgt_cmd *cmd ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 1408
  cmd = prm->cmd;
#line 1410
  tmp = ldv__builtin_expect(cmd->sg_cnt == 0, 0L);
#line 1410
  if (tmp != 0L) {
#line 1410
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"),
                         "i" (1410), "i" (12UL));
    ldv_66593: ;
#line 1410
    goto ldv_66593;
  } else {

  }
#line 1412
  prm->sg = cmd->sg;
#line 1413
  prm->seg_cnt = pci_map_sg(((prm->tgt)->ha)->pdev, cmd->sg, cmd->sg_cnt, (int )cmd->dma_data_direction);
#line 1415
  tmp___0 = ldv__builtin_expect(prm->seg_cnt == 0, 0L);
#line 1415
  if (tmp___0 != 0L) {
#line 1416
    goto out_err;
  } else {

  }
#line 1418
  (prm->cmd)->sg_mapped = 1U;
#line 1420
  if ((unsigned int )cmd->se_cmd.prot_op == 0U) {
#line 1425
    if (prm->seg_cnt > (prm->tgt)->datasegs_per_cmd) {
#line 1426
      prm->req_cnt = prm->req_cnt + (((prm->seg_cnt - (prm->tgt)->datasegs_per_cmd) + (prm->tgt)->datasegs_per_cont) + -1) / (prm->tgt)->datasegs_per_cont;
    } else {

    }
  } else {
#line 1431
    if ((unsigned int )cmd->se_cmd.prot_op == 1U || (unsigned int )cmd->se_cmd.prot_op == 8U) {
#line 1433
      prm->seg_cnt = (int )((((uint32_t )cmd->bufflen + cmd->blk_sz) - 1U) / cmd->blk_sz);
#line 1434
      prm->tot_dsds = (uint16_t )prm->seg_cnt;
    } else {
#line 1436
      prm->tot_dsds = (uint16_t )prm->seg_cnt;
    }
#line 1438
    if (cmd->prot_sg_cnt != 0U) {
#line 1439
      prm->prot_sg = cmd->prot_sg;
#line 1440
      tmp___1 = pci_map_sg(((prm->tgt)->ha)->pdev, cmd->prot_sg, (int )cmd->prot_sg_cnt,
                           (int )cmd->dma_data_direction);
#line 1440
      prm->prot_seg_cnt = (uint16_t )tmp___1;
#line 1443
      tmp___2 = ldv__builtin_expect((unsigned int )prm->prot_seg_cnt == 0U, 0L);
#line 1443
      if (tmp___2 != 0L) {
#line 1444
        goto out_err;
      } else {

      }
#line 1446
      if ((unsigned int )cmd->se_cmd.prot_op == 1U || (unsigned int )cmd->se_cmd.prot_op == 8U) {
#line 1449
        prm->prot_seg_cnt = (uint16_t )((((uint32_t )cmd->bufflen + cmd->blk_sz) - 1U) / cmd->blk_sz);
#line 1451
        prm->tot_dsds = (int )prm->tot_dsds + (int )prm->prot_seg_cnt;
      } else {
#line 1453
        prm->tot_dsds = (int )prm->tot_dsds + (int )prm->prot_seg_cnt;
      }
    } else {

    }
  }
#line 1457
  return (0);
  out_err: 
#line 1460
  ql_dbg(16384U, (prm->cmd)->vha, 57421, "qla_target(%d): PCI mapping failed: sg_cnt=%d",
         0, (prm->cmd)->sg_cnt);
#line 1463
  return (-1);
}
}
#line 1466 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_unmap_sg(struct scsi_qla_host *vha , struct qla_tgt_cmd *cmd ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 1468
  ha = vha->hw;
#line 1470
  if ((unsigned int )*((unsigned char *)cmd + 1104UL) == 0U) {
#line 1471
    return;
  } else {

  }
#line 1473
  pci_unmap_sg(ha->pdev, cmd->sg, cmd->sg_cnt, (int )cmd->dma_data_direction);
#line 1474
  cmd->sg_mapped = 0U;
#line 1476
  if (cmd->prot_sg_cnt != 0U) {
#line 1477
    pci_unmap_sg(ha->pdev, cmd->prot_sg, (int )cmd->prot_sg_cnt, (int )cmd->dma_data_direction);
  } else {

  }
#line 1480
  if ((unsigned int )*((unsigned char *)cmd + 1104UL) != 0U) {
#line 1481
    qla2x00_clean_dsd_pool___0(ha, (srb_t *)0, cmd);
  } else {

  }
#line 1483
  if ((unsigned long )cmd->ctx != (unsigned long )((struct crc_context *)0)) {
#line 1484
    dma_pool_free(ha->dl_dma_pool, (void *)cmd->ctx, (cmd->ctx)->crc_ctx_dma);
  } else {

  }
#line 1485
  return;
}
}
#line 1487 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static int qlt_check_reserve_free_req(struct scsi_qla_host *vha , uint32_t req_cnt ) 
{ 
  uint32_t cnt ;
  uint32_t cnt_in ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  long tmp___1 ;

  {
#line 1492
  if ((uint32_t )(vha->req)->cnt < req_cnt + 2U) {
#line 1493
    tmp = readl((void const volatile   *)(vha->req)->req_q_out);
#line 1493
    cnt = (uint32_t )((unsigned short )tmp);
#line 1494
    tmp___0 = readl((void const volatile   *)(vha->req)->req_q_in);
#line 1494
    cnt_in = (uint32_t )((unsigned short )tmp___0);
#line 1496
    if ((uint32_t )(vha->req)->ring_index < cnt) {
#line 1497
      (vha->req)->cnt = (int )((uint16_t )cnt) - (int )(vha->req)->ring_index;
    } else {
#line 1499
      (vha->req)->cnt = (int )(vha->req)->length + ((int )((uint16_t )cnt) - (int )(vha->req)->ring_index);
    }
  } else {

  }
#line 1503
  tmp___1 = ldv__builtin_expect((uint32_t )(vha->req)->cnt < req_cnt + 2U, 0L);
#line 1503
  if (tmp___1 != 0L) {
#line 1504
    ql_dbg(134217728U, vha, 12378, "qla_target(%d): There is no room in the request ring: vha->req->ring_index=%d, vha->req->cnt=%d, req_cnt=%d Req-out=%d Req-in=%d Req-Length=%d\n",
           (int )vha->vp_idx, (int )(vha->req)->ring_index, (int )(vha->req)->cnt,
           req_cnt, cnt, cnt_in, (int )(vha->req)->length);
#line 1508
    return (-11);
  } else {

  }
#line 1510
  (vha->req)->cnt = (int )(vha->req)->cnt - (int )((uint16_t )req_cnt);
#line 1512
  return (0);
}
}
#line 1518 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
__inline static void *qlt_get_req_pkt(struct scsi_qla_host *vha ) 
{ 


  {
#line 1521
  (vha->req)->ring_index = (uint16_t )((int )(vha->req)->ring_index + 1);
#line 1522
  if ((int )(vha->req)->ring_index == (int )(vha->req)->length) {
#line 1523
    (vha->req)->ring_index = 0U;
#line 1524
    (vha->req)->ring_ptr = (vha->req)->ring;
  } else {
#line 1526
    (vha->req)->ring_ptr = (vha->req)->ring_ptr + 1;
  }
#line 1528
  return ((void *)(vha->req)->ring_ptr);
}
}
#line 1532 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
__inline static uint32_t qlt_make_handle(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t h ;

  {
#line 1534
  ha = vha->hw;
#line 1537
  h = (uint32_t )ha->tgt.current_handle;
  ldv_66615: 
#line 1540
  h = h + 1U;
#line 1541
  if (h > 1024U) {
#line 1542
    h = 1U;
  } else {

  }
#line 1543
  if ((uint32_t )ha->tgt.current_handle == h) {
#line 1544
    ql_dbg(134217728U, vha, 12379, "qla_target(%d): Ran out of empty cmd slots in ha %p\n",
           (int )vha->vp_idx, ha);
#line 1547
    h = 0U;
#line 1548
    goto ldv_66614;
  } else {

  }
#line 1552
  if ((h == 0U || h == 3758096383U) || (unsigned long )ha->tgt.cmds[h - 1U] != (unsigned long )((struct qla_tgt_cmd *)0)) {
#line 1554
    goto ldv_66615;
  } else {

  }
  ldv_66614: ;
#line 1554
  if (h != 0U) {
#line 1555
    ha->tgt.current_handle = (uint16_t )h;
  } else {

  }
#line 1557
  return (h);
}
}
#line 1561 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static int qlt_24xx_build_ctio_pkt(struct qla_tgt_prm *prm , struct scsi_qla_host *vha ) 
{ 
  uint32_t h ;
  struct ctio7_to_24xx *pkt ;
  struct qla_hw_data *ha ;
  struct atio_from_isp *atio ;
  uint16_t temp ;
  long tmp ;
  __u16 tmp___0 ;

  {
#line 1566
  ha = vha->hw;
#line 1567
  atio = & (prm->cmd)->atio;
#line 1570
  pkt = (struct ctio7_to_24xx *)(vha->req)->ring_ptr;
#line 1571
  prm->pkt = (void *)pkt;
#line 1572
  memset((void *)pkt, 0, 64UL);
#line 1574
  pkt->entry_type = 18U;
#line 1575
  pkt->entry_count = (unsigned char )prm->req_cnt;
#line 1576
  pkt->vp_index = (uint8_t )vha->vp_idx;
#line 1578
  h = qlt_make_handle(vha);
#line 1579
  tmp = ldv__builtin_expect(h == 0U, 0L);
#line 1579
  if (tmp != 0L) {
#line 1585
    return (-11);
  } else {
#line 1587
    ha->tgt.cmds[h - 1U] = prm->cmd;
  }
#line 1589
  pkt->handle = h | 536870912U;
#line 1590
  pkt->nport_handle = (prm->cmd)->loop_id;
#line 1591
  pkt->timeout = 10U;
#line 1592
  pkt->initiator_id[0] = atio->u.isp24.fcp_hdr.s_id[2];
#line 1593
  pkt->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];
#line 1594
  pkt->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];
#line 1595
  pkt->exchange_addr = atio->u.isp24.exchange_addr;
#line 1596
  pkt->u.status0.flags = (__le16 )((int )((short )pkt->u.status0.flags) | (int )((short )((int )atio->u.isp24.attr << 9)));
#line 1597
  tmp___0 = __fswab16((int )atio->u.isp24.fcp_hdr.ox_id);
#line 1597
  temp = tmp___0;
#line 1598
  pkt->u.status0.ox_id = temp;
#line 1599
  pkt->u.status0.relative_offset = (unsigned int )(prm->cmd)->offset;
#line 1601
  return (0);
}
}
#line 1608 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_load_cont_data_segments(struct qla_tgt_prm *prm , struct scsi_qla_host *vha ) 
{ 
  int cnt ;
  uint32_t *dword_ptr ;
  int enable_64bit_addressing ;
  cont_a64_entry_t *cont_pkt64 ;
  void *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;

  {
#line 1613
  enable_64bit_addressing = (int )(prm->tgt)->tgt_enable_64bit_addr;
#line 1616
  goto ldv_66637;
  ldv_66636: 
#line 1617
  tmp = qlt_get_req_pkt(vha);
#line 1617
  cont_pkt64 = (cont_a64_entry_t *)tmp;
#line 1627
  memset((void *)cont_pkt64, 0, 64UL);
#line 1629
  cont_pkt64->entry_count = 1U;
#line 1630
  cont_pkt64->sys_define = 0U;
#line 1632
  if (enable_64bit_addressing != 0) {
#line 1633
    cont_pkt64->entry_type = 10U;
#line 1634
    dword_ptr = (uint32_t *)(& cont_pkt64->dseg_0_address);
  } else {
#line 1637
    cont_pkt64->entry_type = 2U;
#line 1638
    dword_ptr = & ((cont_entry_t *)cont_pkt64)->dseg_0_address;
  }
#line 1644
  cnt = 0;
#line 1644
  goto ldv_66634;
  ldv_66633: 
#line 1647
  tmp___0 = dword_ptr;
#line 1647
  dword_ptr = dword_ptr + 1;
#line 1647
  *tmp___0 = (unsigned int )(prm->sg)->dma_address;
#line 1650
  if (enable_64bit_addressing != 0) {
#line 1651
    tmp___1 = dword_ptr;
#line 1651
    dword_ptr = dword_ptr + 1;
#line 1651
    *tmp___1 = (unsigned int )((prm->sg)->dma_address >> 32ULL);
  } else {

  }
#line 1656
  tmp___2 = dword_ptr;
#line 1656
  dword_ptr = dword_ptr + 1;
#line 1656
  *tmp___2 = (prm->sg)->dma_length;
#line 1658
  prm->sg = sg_next(prm->sg);
#line 1646
  cnt = cnt + 1;
#line 1646
  prm->seg_cnt = prm->seg_cnt - 1;
  ldv_66634: ;
#line 1644
  if ((prm->tgt)->datasegs_per_cont > cnt && prm->seg_cnt != 0) {
#line 1647
    goto ldv_66633;
  } else {

  }

  ldv_66637: ;
#line 1616
  if (prm->seg_cnt > 0) {
#line 1618
    goto ldv_66636;
  } else {

  }

#line 1623
  return;
}
}
#line 1667 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_load_data_segments(struct qla_tgt_prm *prm , struct scsi_qla_host *vha ) 
{ 
  int cnt ;
  uint32_t *dword_ptr ;
  int enable_64bit_addressing ;
  struct ctio7_to_24xx *pkt24 ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;

  {
#line 1672
  enable_64bit_addressing = (int )(prm->tgt)->tgt_enable_64bit_addr;
#line 1673
  pkt24 = (struct ctio7_to_24xx *)prm->pkt;
#line 1675
  pkt24->u.status0.transfer_length = (unsigned int )(prm->cmd)->bufflen;
#line 1678
  dword_ptr = (uint32_t *)(& pkt24->u.status0.dseg_0_address);
#line 1681
  if (prm->seg_cnt != 0) {
#line 1682
    pkt24->dseg_count = (unsigned short )prm->seg_cnt;
  } else {

  }
#line 1684
  if (prm->seg_cnt == 0) {
#line 1686
    tmp = dword_ptr;
#line 1686
    dword_ptr = dword_ptr + 1;
#line 1686
    *tmp = 0U;
#line 1687
    *dword_ptr = 0U;
#line 1688
    return;
  } else {

  }
#line 1694
  cnt = 0;
#line 1694
  goto ldv_66648;
  ldv_66647: 
#line 1697
  tmp___0 = dword_ptr;
#line 1697
  dword_ptr = dword_ptr + 1;
#line 1697
  *tmp___0 = (unsigned int )(prm->sg)->dma_address;
#line 1699
  if (enable_64bit_addressing != 0) {
#line 1700
    tmp___1 = dword_ptr;
#line 1700
    dword_ptr = dword_ptr + 1;
#line 1700
    *tmp___1 = (unsigned int )((prm->sg)->dma_address >> 32ULL);
  } else {

  }
#line 1704
  tmp___2 = dword_ptr;
#line 1704
  dword_ptr = dword_ptr + 1;
#line 1704
  *tmp___2 = (prm->sg)->dma_length;
#line 1706
  prm->sg = sg_next(prm->sg);
#line 1696
  cnt = cnt + 1;
#line 1696
  prm->seg_cnt = prm->seg_cnt - 1;
  ldv_66648: ;
#line 1694
  if ((prm->tgt)->datasegs_per_cmd > cnt && prm->seg_cnt != 0) {
#line 1697
    goto ldv_66647;
  } else {

  }
#line 1709
  qlt_load_cont_data_segments(prm, vha);
#line 1710
  return;
}
}
#line 1712 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
__inline static int qlt_has_data(struct qla_tgt_cmd *cmd ) 
{ 


  {
#line 1714
  return (cmd->bufflen > 0);
}
}
#line 1720 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static int qlt_pre_xmit_response(struct qla_tgt_cmd *cmd , struct qla_tgt_prm *prm ,
                                 int xmit_type , uint8_t scsi_status , uint32_t *full_req_cnt ) 
{ 
  struct qla_tgt *tgt ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct se_cmd *se_cmd ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1724
  tgt = cmd->tgt;
#line 1725
  vha = tgt->vha;
#line 1726
  ha = vha->hw;
#line 1727
  se_cmd = & cmd->se_cmd;
#line 1729
  tmp = ldv__builtin_expect((unsigned int )*((unsigned char *)cmd + 1104UL) != 0U, 0L);
#line 1729
  if (tmp != 0L) {
#line 1730
    ql_dbg(8192U, vha, 61460, "qla_target(%d): terminating exchange for aborted cmd=%p (se_cmd=%p, tag=%lld)",
           (int )vha->vp_idx, cmd, se_cmd, se_cmd->tag);
#line 1734
    cmd->state = 4;
#line 1735
    cmd->cmd_flags = cmd->cmd_flags | 64U;
#line 1737
    qlt_send_term_exchange(vha, cmd, & cmd->atio, 0);
#line 1740
    return (5911);
  } else {

  }
#line 1743
  prm->cmd = cmd;
#line 1744
  prm->tgt = tgt;
#line 1745
  prm->rq_result = (uint16_t )scsi_status;
#line 1746
  prm->sense_buffer = (unsigned char *)(& cmd->sense_buffer);
#line 1747
  prm->sense_buffer_len = 96;
#line 1748
  prm->sg = (struct scatterlist *)0;
#line 1749
  prm->seg_cnt = -1;
#line 1750
  prm->req_cnt = 1;
#line 1751
  prm->add_status_pkt = 0;
#line 1754
  tmp___0 = qlt_issue_marker(vha, 0);
#line 1754
  if (tmp___0 != 0) {
#line 1755
    return (-14);
  } else {

  }
#line 1757
  if (xmit_type & 1) {
#line 1757
    tmp___2 = qlt_has_data(cmd);
#line 1757
    if (tmp___2 != 0) {
#line 1758
      tmp___1 = qlt_pci_map_calc_cnt(prm);
#line 1758
      if (tmp___1 != 0) {
#line 1759
        return (-11);
      } else {

      }
    } else {

    }
  } else {

  }
#line 1762
  *full_req_cnt = (uint32_t )prm->req_cnt;
#line 1764
  if ((se_cmd->se_cmd_flags & 8192U) != 0U) {
#line 1765
    prm->residual = (int )se_cmd->residual_count;
#line 1766
    ql_dbg(134250496U, vha, 12380, "Residual underflow: %d (tag %lld, op %x, bufflen %d, rq_result %x)\n",
           prm->residual, se_cmd->tag, (unsigned long )se_cmd->t_task_cdb != (unsigned long )((unsigned char *)0U) ? (int )*(se_cmd->t_task_cdb) : 0,
           cmd->bufflen, (int )prm->rq_result);
#line 1771
    prm->rq_result = (uint16_t )((unsigned int )prm->rq_result | 2048U);
  } else
#line 1772
  if ((se_cmd->se_cmd_flags & 4096U) != 0U) {
#line 1773
    prm->residual = (int )se_cmd->residual_count;
#line 1774
    ql_dbg(134217728U, vha, 12381, "Residual overflow: %d (tag %lld, op %x, bufflen %d, rq_result %x)\n",
           prm->residual, se_cmd->tag, (unsigned long )se_cmd->t_task_cdb != (unsigned long )((unsigned char *)0U) ? (int )*(se_cmd->t_task_cdb) : 0,
           cmd->bufflen, (int )prm->rq_result);
#line 1778
    prm->rq_result = (uint16_t )((unsigned int )prm->rq_result | 1024U);
  } else {

  }
#line 1781
  if ((xmit_type & 2) != 0) {
#line 1786
    tmp___3 = qlt_has_data(cmd);
#line 1786
    if (tmp___3 != 0) {
#line 1787
      if (((unsigned long )prm->sense_buffer != (unsigned long )((unsigned char *)0U) && ((int )*((uint8_t const   *)prm->sense_buffer) & 112) == 112) || ((ha->device_type & 134217728U) != 0U && (unsigned int )prm->rq_result != 0U)) {
#line 1790
        prm->add_status_pkt = 1;
#line 1791
        *full_req_cnt = *full_req_cnt + 1U;
      } else {

      }
    } else {

    }
  } else {

  }
#line 1796
  return (0);
}
}
#line 1799 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
__inline static int qlt_need_explicit_conf(struct qla_hw_data *ha , struct qla_tgt_cmd *cmd ,
                                           int sending_sense ) 
{ 


  {
#line 1802
  if ((unsigned int )*((unsigned char *)ha + 3808UL) != 0U) {
#line 1803
    return (0);
  } else {

  }
#line 1805
  if (sending_sense != 0) {
#line 1806
    return ((int )cmd->conf_compl_supported);
  } else {
#line 1808
    return ((unsigned int )*((unsigned char *)ha + 3808UL) != 0U && (unsigned int )*((unsigned char *)cmd + 1104UL) != 0U);
  }
}
}
#line 1897 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
__inline static void qlt_check_srr_debug(struct qla_tgt_cmd *cmd , int *xmit_type ) 
{ 


  {
#line 1899
  return;
}
}
#line 1901 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_24xx_init_ctio_to_isp(struct ctio7_to_24xx *ctio , struct qla_tgt_prm *prm ) 
{ 
  uint32_t __min1 ;
  uint32_t __min2 ;
  int tmp ;
  int i ;
  int tmp___0 ;
  __u32 tmp___1 ;

  {
#line 1904
  __min1 = (uint32_t )prm->sense_buffer_len;
#line 1904
  __min2 = 24U;
#line 1904
  prm->sense_buffer_len = (int )(__min1 < __min2 ? __min1 : __min2);
#line 1906
  ctio->u.status0.flags = (__le16 )((unsigned int )ctio->u.status0.flags | 32768U);
#line 1908
  tmp = qlt_need_explicit_conf((prm->tgt)->ha, prm->cmd, 0);
#line 1908
  if (tmp != 0) {
#line 1909
    ctio->u.status0.flags = (__le16 )((unsigned int )ctio->u.status0.flags | 8224U);
  } else {

  }
#line 1913
  ctio->u.status0.residual = (unsigned int )prm->residual;
#line 1914
  ctio->u.status0.scsi_status = prm->rq_result;
#line 1915
  if ((unsigned long )prm->sense_buffer != (unsigned long )((unsigned char *)0U) && ((int )*((uint8_t const   *)prm->sense_buffer) & 112) == 112) {
#line 1918
    tmp___0 = qlt_need_explicit_conf((prm->tgt)->ha, prm->cmd, 1);
#line 1918
    if (tmp___0 != 0) {
#line 1919
      if ((unsigned int )(prm->cmd)->se_cmd.scsi_status != 0U) {
#line 1920
        ql_dbg(16384U, (prm->cmd)->vha, 57367, "Skipping EXPLICIT_CONFORM and CTIO7_FLAGS_CONFORM_REQ for FCP READ w/ non GOOD status\n");
#line 1924
        goto skip_explict_conf;
      } else {

      }
#line 1926
      ctio->u.status1.flags = (uint16_t )((unsigned int )ctio->u.status1.flags | 8224U);
    } else {

    }
    skip_explict_conf: 
#line 1931
    ctio->u.status1.flags = ctio->u.status1.flags;
#line 1933
    ctio->u.status1.flags = (uint16_t )((unsigned int )ctio->u.status1.flags | 64U);
#line 1935
    ctio->u.status1.scsi_status = (uint16_t )((unsigned int )ctio->u.status1.scsi_status | 512U);
#line 1937
    ctio->u.status1.sense_length = (unsigned short )prm->sense_buffer_len;
#line 1939
    i = 0;
#line 1939
    goto ldv_66683;
    ldv_66682: 
#line 1940
    tmp___1 = __fswab32(*((uint32_t *)prm->sense_buffer + (unsigned long )i));
#line 1940
    *((uint32_t *)(& ctio->u.status1.sense_data) + (unsigned long )i) = tmp___1;
#line 1939
    i = i + 1;
    ldv_66683: ;
#line 1939
    if (prm->sense_buffer_len / 4 > i) {
#line 1941
      goto ldv_66682;
    } else {

    }

  } else {
#line 1955
    ctio->u.status1.flags = ctio->u.status1.flags;
#line 1957
    ctio->u.status1.flags = (uint16_t )((unsigned int )ctio->u.status1.flags | 64U);
#line 1959
    ctio->u.status1.sense_length = 0U;
#line 1960
    memset((void *)(& ctio->u.status1.sense_data), 0, 24UL);
  }
#line 1962
  return;
}
}
#line 1971 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
__inline static int qlt_hba_err_chk_enabled(struct se_cmd *se_cmd ) 
{ 


  {
#line 1980
  switch ((unsigned int )se_cmd->prot_op) {
  case 2U: ;
  case 4U: ;
#line 1983
  if (ql2xenablehba_err_chk > 0) {
#line 1984
    return (1);
  } else {

  }
#line 1985
  goto ldv_66690;
  case 32U: ;
  case 16U: ;
#line 1988
  if (ql2xenablehba_err_chk > 1) {
#line 1989
    return (1);
  } else {

  }
#line 1990
  goto ldv_66690;
  case 1U: ;
  case 8U: ;
#line 1993
  return (1);
  default: ;
#line 1995
  goto ldv_66690;
  }
  ldv_66690: ;
#line 1997
  return (0);
}
}
#line 2005 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
__inline static void qlt_set_t10dif_tags(struct se_cmd *se_cmd , struct crc_context *ctx ) 
{ 
  uint32_t lba ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  uint8_t tmp___2 ;
  uint8_t tmp___3 ;
  uint8_t tmp___4 ;

  {
#line 2007
  lba = (uint32_t )se_cmd->t_task_lba;
#line 2013
  ctx->app_tag = 0U;
#line 2014
  ctx->app_tag_mask[0] = 0U;
#line 2015
  ctx->app_tag_mask[1] = 0U;
#line 2017
  switch ((unsigned int )se_cmd->prot_type) {
  case 0U: 
#line 2023
  ctx->ref_tag = lba;
#line 2025
  tmp = qlt_hba_err_chk_enabled(se_cmd);
#line 2025
  if (tmp == 0) {
#line 2026
    goto ldv_66702;
  } else {

  }
#line 2029
  ctx->ref_tag_mask[0] = 255U;
#line 2030
  ctx->ref_tag_mask[1] = 255U;
#line 2031
  ctx->ref_tag_mask[2] = 255U;
#line 2032
  ctx->ref_tag_mask[3] = 255U;
#line 2033
  goto ldv_66702;
  case 1U: 
#line 2039
  ctx->ref_tag = lba;
#line 2041
  tmp___0 = qlt_hba_err_chk_enabled(se_cmd);
#line 2041
  if (tmp___0 == 0) {
#line 2042
    goto ldv_66702;
  } else {

  }
#line 2045
  ctx->ref_tag_mask[0] = 255U;
#line 2046
  ctx->ref_tag_mask[1] = 255U;
#line 2047
  ctx->ref_tag_mask[2] = 255U;
#line 2048
  ctx->ref_tag_mask[3] = 255U;
#line 2049
  goto ldv_66702;
  case 2U: 
#line 2055
  ctx->ref_tag = lba;
#line 2057
  tmp___1 = qlt_hba_err_chk_enabled(se_cmd);
#line 2057
  if (tmp___1 == 0) {
#line 2058
    goto ldv_66702;
  } else {

  }
#line 2061
  ctx->ref_tag_mask[0] = 255U;
#line 2062
  ctx->ref_tag_mask[1] = 255U;
#line 2063
  ctx->ref_tag_mask[2] = 255U;
#line 2064
  ctx->ref_tag_mask[3] = 255U;
#line 2065
  goto ldv_66702;
  case 3U: 
#line 2069
  tmp___4 = 0U;
#line 2069
  ctx->ref_tag_mask[3] = tmp___4;
#line 2069
  tmp___3 = tmp___4;
#line 2069
  ctx->ref_tag_mask[2] = tmp___3;
#line 2069
  tmp___2 = tmp___3;
#line 2069
  ctx->ref_tag_mask[1] = tmp___2;
#line 2069
  ctx->ref_tag_mask[0] = tmp___2;
#line 2071
  goto ldv_66702;
  }
  ldv_66702: ;
#line 2074
  return;
}
}
#line 2077 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
__inline static int qlt_build_ctio_crc2_pkt(struct qla_tgt_prm *prm , scsi_qla_host_t *vha ) 
{ 
  uint32_t *cur_dsd ;
  int sgc ;
  uint32_t transfer_length ;
  uint32_t data_bytes ;
  uint32_t dif_bytes ;
  uint8_t bundling ;
  uint8_t *clr_ptr ;
  struct crc_context *crc_ctx_pkt ;
  struct qla_hw_data *ha ;
  struct ctio_crc2_to_fw *pkt ;
  dma_addr_t crc_ctx_dma ;
  uint16_t fw_prot_opts ;
  struct qla_tgt_cmd *cmd ;
  struct se_cmd *se_cmd ;
  uint32_t h ;
  struct atio_from_isp *atio ;
  uint16_t t16 ;
  int tmp ;
  long tmp___0 ;
  __u16 tmp___1 ;
  struct crc_context *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 2081
  transfer_length = 0U;
#line 2084
  bundling = 1U;
#line 2086
  crc_ctx_pkt = (struct crc_context *)0;
#line 2090
  fw_prot_opts = 0U;
#line 2091
  cmd = prm->cmd;
#line 2092
  se_cmd = & cmd->se_cmd;
#line 2094
  atio = & (prm->cmd)->atio;
#line 2097
  sgc = 0;
#line 2098
  ha = vha->hw;
#line 2100
  pkt = (struct ctio_crc2_to_fw *)(vha->req)->ring_ptr;
#line 2101
  prm->pkt = (void *)pkt;
#line 2102
  memset((void *)pkt, 0, 64UL);
#line 2104
  ql_dbg(16384U, vha, 57457, "qla_target(%d):%s: se_cmd[%p] CRC2 prot_op[0x%x] cmd prot sg:cnt[%p:%x] lba[%llu]\n",
         (int )vha->vp_idx, "qlt_build_ctio_crc2_pkt", se_cmd, (unsigned int )se_cmd->prot_op,
         prm->prot_sg, (int )prm->prot_seg_cnt, se_cmd->t_task_lba);
#line 2109
  if ((unsigned int )se_cmd->prot_op == 1U || (unsigned int )se_cmd->prot_op == 8U) {
#line 2111
    bundling = 0U;
  } else {

  }
#line 2114
  data_bytes = (uint32_t )cmd->bufflen;
#line 2115
  dif_bytes = (data_bytes / cmd->blk_sz) * 8U;
#line 2117
  switch ((unsigned int )se_cmd->prot_op) {
  case 1U: ;
  case 8U: 
#line 2120
  transfer_length = data_bytes;
#line 2121
  data_bytes = data_bytes + dif_bytes;
#line 2122
  goto ldv_66730;
  case 4U: ;
  case 2U: ;
  case 16U: ;
  case 32U: 
#line 2128
  transfer_length = data_bytes + dif_bytes;
#line 2129
  goto ldv_66730;
  default: 
#line 2132
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"),
                       "i" (2132), "i" (12UL));
  ldv_66736: ;
#line 2132
  goto ldv_66736;
  }
  ldv_66730: 
#line 2136
  tmp = qlt_hba_err_chk_enabled(se_cmd);
#line 2136
  if (tmp == 0) {
#line 2137
    fw_prot_opts = (uint16_t )((unsigned int )fw_prot_opts | 16U);
  } else
#line 2139
  if ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 2140
    if ((unsigned int )se_cmd->prot_type == 1U || (unsigned int )se_cmd->prot_type == 2U) {
#line 2142
      fw_prot_opts = (uint16_t )((unsigned int )fw_prot_opts | 1024U);
    } else
#line 2143
    if ((unsigned int )se_cmd->prot_type == 3U) {
#line 2144
      fw_prot_opts = (uint16_t )((unsigned int )fw_prot_opts | 2048U);
    } else {

    }
  } else {

  }
#line 2147
  switch ((unsigned int )se_cmd->prot_op) {
  case 1U: ;
  case 2U: 
#line 2150
  fw_prot_opts = fw_prot_opts;
#line 2151
  goto ldv_66739;
  case 4U: ;
  case 8U: 
#line 2154
  fw_prot_opts = (uint16_t )((unsigned int )fw_prot_opts | 1U);
#line 2155
  goto ldv_66739;
  case 16U: ;
  case 32U: 
#line 2158
  fw_prot_opts = (uint16_t )((unsigned int )fw_prot_opts | 2U);
#line 2160
  goto ldv_66739;
  default: 
#line 2162
  fw_prot_opts = (uint16_t )((unsigned int )fw_prot_opts | 2U);
#line 2163
  goto ldv_66739;
  }
  ldv_66739: 
#line 2169
  pkt->entry_type = 122U;
#line 2170
  pkt->entry_count = 1U;
#line 2171
  pkt->vp_index = (uint8_t )vha->vp_idx;
#line 2173
  h = qlt_make_handle(vha);
#line 2174
  tmp___0 = ldv__builtin_expect(h == 0U, 0L);
#line 2174
  if (tmp___0 != 0L) {
#line 2180
    return (-11);
  } else {
#line 2182
    ha->tgt.cmds[h - 1U] = prm->cmd;
  }
#line 2185
  pkt->handle = h | 536870912U;
#line 2186
  pkt->nport_handle = (prm->cmd)->loop_id;
#line 2187
  pkt->timeout = 10U;
#line 2188
  pkt->initiator_id[0] = atio->u.isp24.fcp_hdr.s_id[2];
#line 2189
  pkt->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];
#line 2190
  pkt->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];
#line 2191
  pkt->exchange_addr = atio->u.isp24.exchange_addr;
#line 2194
  tmp___1 = __fswab16((int )atio->u.isp24.fcp_hdr.ox_id);
#line 2194
  t16 = tmp___1;
#line 2195
  pkt->ox_id = t16;
#line 2197
  t16 = (int )((uint16_t )atio->u.isp24.attr) << 9U;
#line 2198
  pkt->flags = (__le16 )((int )pkt->flags | (int )t16);
#line 2199
  pkt->relative_offset = (unsigned int )(prm->cmd)->offset;
#line 2202
  if ((unsigned int )cmd->dma_data_direction == 1U) {
#line 2203
    pkt->flags = 2U;
  } else
#line 2204
  if ((unsigned int )cmd->dma_data_direction == 2U) {
#line 2205
    pkt->flags = 1U;
  } else {

  }
#line 2208
  pkt->dseg_count = prm->tot_dsds;
#line 2210
  pkt->transfer_length = transfer_length;
#line 2216
  tmp___3 = dma_pool_alloc(ha->dl_dma_pool, 32U, & crc_ctx_dma);
#line 2216
  tmp___2 = (struct crc_context *)tmp___3;
#line 2216
  cmd->ctx = tmp___2;
#line 2216
  crc_ctx_pkt = tmp___2;
#line 2219
  if ((unsigned long )crc_ctx_pkt == (unsigned long )((struct crc_context *)0)) {
#line 2220
    goto crc_queuing_error;
  } else {

  }
#line 2223
  clr_ptr = (uint8_t *)crc_ctx_pkt;
#line 2224
  memset((void *)clr_ptr, 0, 360UL);
#line 2226
  crc_ctx_pkt->crc_ctx_dma = crc_ctx_dma;
#line 2227
  INIT_LIST_HEAD(& crc_ctx_pkt->dsd_list);
#line 2230
  crc_ctx_pkt->handle = pkt->handle;
#line 2232
  qlt_set_t10dif_tags(se_cmd, crc_ctx_pkt);
#line 2234
  pkt->crc_context_address[0] = (unsigned int )crc_ctx_dma;
#line 2235
  pkt->crc_context_address[1] = (unsigned int )(crc_ctx_dma >> 32ULL);
#line 2236
  pkt->crc_context_len = 64U;
#line 2239
  if ((unsigned int )bundling == 0U) {
#line 2240
    cur_dsd = (uint32_t *)(& crc_ctx_pkt->u.nobundling.data_address);
  } else {
#line 2246
    fw_prot_opts = (uint16_t )((unsigned int )fw_prot_opts | 256U);
#line 2247
    crc_ctx_pkt->u.bundling.dif_byte_count = dif_bytes;
#line 2248
    crc_ctx_pkt->u.bundling.dseg_count = (int )prm->tot_dsds - (int )prm->prot_seg_cnt;
#line 2250
    cur_dsd = (uint32_t *)(& crc_ctx_pkt->u.bundling.data_address);
  }
#line 2254
  crc_ctx_pkt->blk_size = (unsigned short )cmd->blk_sz;
#line 2255
  crc_ctx_pkt->prot_opts = fw_prot_opts;
#line 2256
  crc_ctx_pkt->byte_count = data_bytes;
#line 2257
  crc_ctx_pkt->guard_seed = 0U;
#line 2261
  pkt->flags = (__le16 )((unsigned int )pkt->flags | 4U);
#line 2263
  if ((unsigned int )bundling == 0U && (unsigned int )prm->prot_seg_cnt != 0U) {
#line 2264
    tmp___4 = qla24xx_walk_and_build_sglist_no_difb(ha, (srb_t *)0, cur_dsd, (int )prm->tot_dsds,
                                                    cmd);
#line 2264
    if (tmp___4 != 0) {
#line 2266
      goto crc_queuing_error;
    } else {

    }
  } else {
#line 2267
    tmp___5 = qla24xx_walk_and_build_sglist(ha, (srb_t *)0, cur_dsd, (int )prm->tot_dsds - (int )prm->prot_seg_cnt,
                                            cmd);
#line 2267
    if (tmp___5 != 0) {
#line 2269
      goto crc_queuing_error;
    } else {

    }
  }
#line 2271
  if ((unsigned int )bundling != 0U && (unsigned int )prm->prot_seg_cnt != 0U) {
#line 2273
    pkt->add_flags = (uint8_t )((unsigned int )pkt->add_flags | 8U);
#line 2275
    cur_dsd = (uint32_t *)(& crc_ctx_pkt->u.bundling.dif_address);
#line 2276
    tmp___6 = qla24xx_walk_and_build_prot_sglist(ha, (srb_t *)0, cur_dsd, (int )prm->prot_seg_cnt,
                                                 cmd);
#line 2276
    if (tmp___6 != 0) {
#line 2278
      goto crc_queuing_error;
    } else {

    }
  } else {

  }
#line 2280
  return (0);
  crc_queuing_error: ;
#line 2285
  return (258);
}
}
#line 2293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
int qlt_xmit_response(struct qla_tgt_cmd *cmd , int xmit_type , uint8_t scsi_status ) 
{ 
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct ctio7_to_24xx *pkt ;
  struct qla_tgt_prm prm ;
  uint32_t full_req_cnt ;
  unsigned long flags ;
  int res ;
  long tmp ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  struct ctio7_to_24xx *ctio ;
  void *tmp___6 ;
  struct _ddebug descriptor ;
  long tmp___7 ;
  int tmp___8 ;

  {
#line 2296
  vha = cmd->vha;
#line 2297
  ha = vha->hw;
#line 2300
  full_req_cnt = 0U;
#line 2301
  flags = 0UL;
#line 2304
  memset((void *)(& prm), 0, 80UL);
#line 2305
  qlt_check_srr_debug(cmd, & xmit_type);
#line 2307
  ql_dbg(16384U, cmd->vha, 57368, "is_send_status=%d, cmd->bufflen=%d, cmd->sg_cnt=%d, cmd->dma_data_direction=%d se_cmd[%p]\n",
         (xmit_type & 2) != 0, cmd->bufflen, cmd->sg_cnt, (unsigned int )cmd->dma_data_direction,
         & cmd->se_cmd);
#line 2313
  res = qlt_pre_xmit_response(cmd, & prm, xmit_type, (int )scsi_status, & full_req_cnt);
#line 2315
  tmp = ldv__builtin_expect(res != 0, 0L);
#line 2315
  if (tmp != 0L) {
#line 2316
    if (res == 5911) {
#line 2317
      return (0);
    } else {

    }
#line 2319
    return (res);
  } else {

  }
#line 2322
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 2322
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 2324
  tmp___2 = qla2x00_reset_active(vha);
#line 2324
  if (tmp___2 != 0 || cmd->reset_count != ha->chip_reset) {
#line 2329
    cmd->state = 3;
#line 2330
    qlt_abort_cmd_on_host_reset(cmd->vha, cmd);
#line 2331
    tmp___1 = qla2x00_reset_active(vha);
#line 2331
    ql_dbg(33554432U, vha, 57601, "RESET-RSP active/old-count/new-count = %d/%d/%d.\n",
           tmp___1, cmd->reset_count, ha->chip_reset);
#line 2335
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2336
    return (0);
  } else {

  }
#line 2340
  res = qlt_check_reserve_free_req(vha, full_req_cnt);
#line 2341
  tmp___3 = ldv__builtin_expect(res != 0, 0L);
#line 2341
  if (tmp___3 != 0L) {
#line 2342
    goto out_unmap_unlock;
  } else {

  }
#line 2344
  if ((unsigned int )cmd->se_cmd.prot_op != 0U && xmit_type & 1) {
#line 2345
    res = qlt_build_ctio_crc2_pkt(& prm, vha);
  } else {
#line 2347
    res = qlt_24xx_build_ctio_pkt(& prm, vha);
  }
#line 2348
  tmp___4 = ldv__builtin_expect(res != 0, 0L);
#line 2348
  if (tmp___4 != 0L) {
#line 2349
    goto out_unmap_unlock;
  } else {

  }
#line 2352
  pkt = (struct ctio7_to_24xx *)prm.pkt;
#line 2354
  tmp___8 = qlt_has_data(cmd);
#line 2354
  if (tmp___8 != 0 && xmit_type & 1) {
#line 2355
    pkt->u.status0.flags = (__le16 )((unsigned int )pkt->u.status0.flags | 2U);
#line 2359
    if ((unsigned int )cmd->se_cmd.prot_op == 0U) {
#line 2360
      qlt_load_data_segments(& prm, vha);
    } else {

    }
#line 2362
    if (prm.add_status_pkt == 0) {
#line 2363
      if ((xmit_type & 2) != 0) {
#line 2364
        pkt->u.status0.scsi_status = prm.rq_result;
#line 2366
        pkt->u.status0.residual = (unsigned int )prm.residual;
#line 2368
        pkt->u.status0.flags = (__le16 )((unsigned int )pkt->u.status0.flags | 32768U);
#line 2370
        tmp___5 = qlt_need_explicit_conf(ha, cmd, 0);
#line 2370
        if (tmp___5 != 0) {
#line 2371
          pkt->u.status0.flags = (__le16 )((unsigned int )pkt->u.status0.flags | 8224U);
        } else {

        }
      } else {

      }
    } else {
#line 2384
      tmp___6 = qlt_get_req_pkt(vha);
#line 2384
      ctio = (struct ctio7_to_24xx *)tmp___6;
#line 2387
      ql_dbg(134217728U, vha, 12382, "Building additional status packet 0x%p.\n",
             ctio);
#line 2395
      memcpy((void *)ctio, (void const   *)pkt, 64UL);
#line 2397
      ctio->entry_count = 1U;
#line 2398
      ctio->entry_type = 18U;
#line 2399
      ctio->dseg_count = 0U;
#line 2400
      ctio->u.status1.flags = (unsigned int )ctio->u.status1.flags & 65533U;
#line 2404
      pkt->handle = pkt->handle | 1073741824U;
#line 2405
      pkt->u.status0.flags = (__le16 )((unsigned int )pkt->u.status0.flags | 256U);
#line 2412
      qlt_24xx_init_ctio_to_isp(ctio, & prm);
#line 2414
      descriptor.modname = "qla2xxx";
#line 2414
      descriptor.function = "qlt_xmit_response";
#line 2414
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c";
#line 2414
      descriptor.format = "Status CTIO7: %p\n";
#line 2414
      descriptor.lineno = 2414U;
#line 2414
      descriptor.flags = 0U;
#line 2414
      tmp___7 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 2414
      if (tmp___7 != 0L) {
#line 2414
        __dynamic_pr_debug(& descriptor, "Status CTIO7: %p\n", ctio);
      } else {

      }
    }
  } else {
#line 2417
    qlt_24xx_init_ctio_to_isp(pkt, & prm);
  }
#line 2420
  cmd->state = 3;
#line 2421
  cmd->cmd_sent_to_fw = 1U;
#line 2424
  __asm__  volatile   ("sfence": : : "memory");
#line 2425
  qla2x00_start_iocbs(vha, vha->req);
#line 2426
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2428
  return (0);
  out_unmap_unlock: 
#line 2431
  qlt_unmap_sg(vha, cmd);
#line 2432
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2434
  return (res);
}
}
#line 2436 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static char const   __kstrtab_qlt_xmit_response[18U]  = 
#line 2436
  {      'q',      'l',      't',      '_', 
        'x',      'm',      'i',      't', 
        '_',      'r',      'e',      's', 
        'p',      'o',      'n',      's', 
        'e',      '\000'};
#line 2436
struct kernel_symbol  const  __ksymtab_qlt_xmit_response ;
#line 2436 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
struct kernel_symbol  const  __ksymtab_qlt_xmit_response  =    {(unsigned long )(& qlt_xmit_response), (char const   *)(& __kstrtab_qlt_xmit_response)};
#line 2438 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
int qlt_rdy_to_xfer(struct qla_tgt_cmd *cmd ) 
{ 
  struct ctio7_to_24xx *pkt ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct qla_tgt *tgt ;
  struct qla_tgt_prm prm ;
  unsigned long flags ;
  int res ;
  int tmp ;
  int tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 2441
  vha = cmd->vha;
#line 2442
  ha = vha->hw;
#line 2443
  tgt = cmd->tgt;
#line 2446
  res = 0;
#line 2448
  memset((void *)(& prm), 0, 80UL);
#line 2449
  prm.cmd = cmd;
#line 2450
  prm.tgt = tgt;
#line 2451
  prm.sg = (struct scatterlist *)0;
#line 2452
  prm.req_cnt = 1;
#line 2455
  tmp = qlt_issue_marker(vha, 0);
#line 2455
  if (tmp != 0) {
#line 2456
    return (-5);
  } else {

  }
#line 2459
  tmp___0 = qlt_pci_map_calc_cnt(& prm);
#line 2459
  if (tmp___0 != 0) {
#line 2460
    return (-11);
  } else {

  }
#line 2462
  tmp___1 = spinlock_check(& ha->hardware_lock);
#line 2462
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 2464
  tmp___3 = qla2x00_reset_active(vha);
#line 2464
  if (tmp___3 != 0 || cmd->reset_count != ha->chip_reset) {
#line 2469
    cmd->state = 1;
#line 2470
    qlt_abort_cmd_on_host_reset(cmd->vha, cmd);
#line 2471
    tmp___2 = qla2x00_reset_active(vha);
#line 2471
    ql_dbg(33554432U, vha, 57602, "RESET-XFR active/old-count/new-count = %d/%d/%d.\n",
           tmp___2, cmd->reset_count, ha->chip_reset);
#line 2475
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2476
    return (0);
  } else {

  }
#line 2480
  res = qlt_check_reserve_free_req(vha, (uint32_t )prm.req_cnt);
#line 2481
  if (res != 0) {
#line 2482
    goto out_unlock_free_unmap;
  } else {

  }
#line 2483
  if ((unsigned int )cmd->se_cmd.prot_op != 0U) {
#line 2484
    res = qlt_build_ctio_crc2_pkt(& prm, vha);
  } else {
#line 2486
    res = qlt_24xx_build_ctio_pkt(& prm, vha);
  }
#line 2488
  tmp___4 = ldv__builtin_expect(res != 0, 0L);
#line 2488
  if (tmp___4 != 0L) {
#line 2489
    goto out_unlock_free_unmap;
  } else {

  }
#line 2490
  pkt = (struct ctio7_to_24xx *)prm.pkt;
#line 2491
  pkt->u.status0.flags = (__le16 )((unsigned int )pkt->u.status0.flags | 1U);
#line 2494
  if ((unsigned int )cmd->se_cmd.prot_op == 0U) {
#line 2495
    qlt_load_data_segments(& prm, vha);
  } else {

  }
#line 2497
  cmd->state = 1;
#line 2498
  cmd->cmd_sent_to_fw = 1U;
#line 2501
  __asm__  volatile   ("sfence": : : "memory");
#line 2502
  qla2x00_start_iocbs(vha, vha->req);
#line 2503
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2505
  return (res);
  out_unlock_free_unmap: 
#line 2508
  qlt_unmap_sg(vha, cmd);
#line 2509
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2511
  return (res);
}
}
#line 2513 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static char const   __kstrtab_qlt_rdy_to_xfer[16U]  = 
#line 2513
  {      'q',      'l',      't',      '_', 
        'r',      'd',      'y',      '_', 
        't',      'o',      '_',      'x', 
        'f',      'e',      'r',      '\000'};
#line 2513
struct kernel_symbol  const  __ksymtab_qlt_rdy_to_xfer ;
#line 2513 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
struct kernel_symbol  const  __ksymtab_qlt_rdy_to_xfer  =    {(unsigned long )(& qlt_rdy_to_xfer), (char const   *)(& __kstrtab_qlt_rdy_to_xfer)};
#line 2521 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
__inline static int qlt_handle_dif_error(struct scsi_qla_host *vha , struct qla_tgt_cmd *cmd ,
                                         struct ctio_crc_from_fw *sts ) 
{ 
  uint8_t *ap ;
  uint8_t *ep ;
  uint32_t e_ref_tag ;
  uint32_t a_ref_tag ;
  uint16_t e_app_tag ;
  uint16_t a_app_tag ;
  uint16_t e_guard ;
  uint16_t a_guard ;
  uint64_t lba ;
  __u16 tmp ;
  __u16 tmp___0 ;
  __u32 tmp___1 ;
  __u16 tmp___2 ;
  __u16 tmp___3 ;
  __u32 tmp___4 ;
  uint32_t blocks_done ;
  uint32_t i ;
  uint32_t j ;
  uint32_t k ;
  uint32_t num_ent ;
  struct scatterlist *sg ;
  struct scatterlist *sgl ;

  {
#line 2524
  ap = (uint8_t *)(& sts->actual_dif);
#line 2525
  ep = (uint8_t *)(& sts->expected_dif);
#line 2529
  lba = cmd->se_cmd.t_task_lba;
#line 2531
  tmp = __fswab16((int )*((uint16_t *)ap));
#line 2531
  a_guard = tmp;
#line 2532
  tmp___0 = __fswab16((int )*((uint16_t *)ap + 2U));
#line 2532
  a_app_tag = tmp___0;
#line 2533
  tmp___1 = __fswab32(*((uint32_t *)ap + 4U));
#line 2533
  a_ref_tag = tmp___1;
#line 2535
  tmp___2 = __fswab16((int )*((uint16_t *)ep));
#line 2535
  e_guard = tmp___2;
#line 2536
  tmp___3 = __fswab16((int )*((uint16_t *)ep + 2U));
#line 2536
  e_app_tag = tmp___3;
#line 2537
  tmp___4 = __fswab32(*((uint32_t *)ep + 4U));
#line 2537
  e_ref_tag = tmp___4;
#line 2539
  ql_dbg(16384U, vha, 57461, "iocb(s) %p Returned STATUS.\n", sts);
#line 2542
  ql_dbg(16384U, vha, 61557, "dif check TGT cdb 0x%x lba 0x%llx: [Actual|Expected] Ref Tag[0x%x|0x%x], App Tag [0x%x|0x%x], Guard [0x%x|0x%x]\n",
         (int )cmd->atio.u.isp24.fcp_cmnd.cdb[0], lba, a_ref_tag, e_ref_tag, (int )a_app_tag,
         (int )e_app_tag, (int )a_guard, (int )e_guard);
#line 2552
  if ((unsigned int )a_app_tag == 65535U && ((unsigned int )cmd->se_cmd.prot_type != 3U || a_ref_tag == 4294967295U)) {
#line 2558
    blocks_done = (e_ref_tag - (uint32_t )lba) + 1U;
#line 2559
    cmd->se_cmd.bad_sector = (sector_t )e_ref_tag;
#line 2560
    cmd->se_cmd.pi_err = 0U;
#line 2561
    ql_dbg(16384U, vha, 61556, "need to return scsi good\n");
#line 2565
    if (cmd->prot_sg_cnt != 0U) {
#line 2566
      j = 0U;
#line 2566
      k = 0U;
#line 2570
      sgl = cmd->prot_sg;
#line 2573
      i = 0U;
#line 2573
      sg = sgl;
#line 2573
      goto ldv_66819;
      ldv_66818: 
#line 2574
      num_ent = sg->dma_length / 8U;
#line 2575
      if (k + num_ent < blocks_done) {
#line 2576
        k = k + num_ent;
#line 2577
        goto ldv_66816;
      } else {

      }
#line 2579
      j = (blocks_done - k) - 1U;
#line 2580
      k = blocks_done;
#line 2581
      goto ldv_66817;
      ldv_66816: 
#line 2573
      i = i + 1U;
#line 2573
      sg = sg_next(sg);
      ldv_66819: ;
#line 2573
      if (cmd->prot_sg_cnt > i) {
#line 2575
        goto ldv_66818;
      } else {

      }
      ldv_66817: ;
#line 2584
      if (k != blocks_done) {
#line 2585
        ql_log(1U, vha, 61558, "unexpected tag values tag:lba=%u:%llu)\n", e_ref_tag,
               lba);
#line 2588
        goto out;
      } else {

      }
    } else {

    }
#line 2606
    return (0);
  } else {

  }
#line 2610
  if ((int )e_guard != (int )a_guard) {
#line 2611
    cmd->se_cmd.pi_err = 21U;
#line 2612
    cmd->se_cmd.bad_sector = (sector_t )cmd->se_cmd.t_task_lba;
#line 2614
    ql_log(1U, vha, 57462, "Guard ERR: cdb 0x%x lba 0x%llx: [Actual|Expected] Ref Tag[0x%x|0x%x], App Tag [0x%x|0x%x], Guard [0x%x|0x%x] cmd=%p\n",
           (int )cmd->atio.u.isp24.fcp_cmnd.cdb[0], lba, a_ref_tag, e_ref_tag, (int )a_app_tag,
           (int )e_app_tag, (int )a_guard, (int )e_guard, cmd);
#line 2619
    goto out;
  } else {

  }
#line 2623
  if (e_ref_tag != a_ref_tag) {
#line 2624
    cmd->se_cmd.pi_err = 23U;
#line 2625
    cmd->se_cmd.bad_sector = (sector_t )e_ref_tag;
#line 2627
    ql_log(1U, vha, 57463, "Ref Tag ERR: cdb 0x%x lba 0x%llx: [Actual|Expected] Ref Tag[0x%x|0x%x], App Tag [0x%x|0x%x], Guard [0x%x|0x%x] cmd=%p\n",
           (int )cmd->atio.u.isp24.fcp_cmnd.cdb[0], lba, a_ref_tag, e_ref_tag, (int )a_app_tag,
           (int )e_app_tag, (int )a_guard, (int )e_guard, cmd);
#line 2632
    goto out;
  } else {

  }
#line 2636
  if ((int )e_app_tag != (int )a_app_tag) {
#line 2637
    cmd->se_cmd.pi_err = 22U;
#line 2638
    cmd->se_cmd.bad_sector = (sector_t )cmd->se_cmd.t_task_lba;
#line 2640
    ql_log(1U, vha, 57464, "App Tag ERR: cdb 0x%x lba 0x%llx: [Actual|Expected] Ref Tag[0x%x|0x%x], App Tag [0x%x|0x%x], Guard [0x%x|0x%x] cmd=%p\n",
           (int )cmd->atio.u.isp24.fcp_cmnd.cdb[0], lba, a_ref_tag, e_ref_tag, (int )a_app_tag,
           (int )e_app_tag, (int )a_guard, (int )e_guard, cmd);
#line 2645
    goto out;
  } else {

  }
  out: ;
#line 2648
  return (1);
}
}
#line 2654 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static int __qlt_send_term_exchange(struct scsi_qla_host *vha , struct qla_tgt_cmd *cmd ,
                                    struct atio_from_isp *atio ) 
{ 
  struct ctio7_to_24xx *ctio24 ;
  struct qla_hw_data *ha ;
  request_t *pkt ;
  int ret ;
  uint16_t temp ;
  void *tmp ;
  __u16 tmp___0 ;

  {
#line 2659
  ha = vha->hw;
#line 2661
  ret = 0;
#line 2664
  ql_dbg(16384U, vha, 57372, "Sending TERM EXCH CTIO (ha=%p)\n", ha);
#line 2666
  tmp = qla2x00_alloc_iocbs_ready(vha, (srb_t *)0);
#line 2666
  pkt = (request_t *)tmp;
#line 2667
  if ((unsigned long )pkt == (unsigned long )((request_t *)0)) {
#line 2668
    ql_dbg(16384U, vha, 57424, "qla_target(%d): %s failed: unable to allocate request packet\n",
           (int )vha->vp_idx, "__qlt_send_term_exchange");
#line 2671
    return (-12);
  } else {

  }
#line 2674
  if ((unsigned long )cmd != (unsigned long )((struct qla_tgt_cmd *)0)) {
#line 2675
    if (cmd->state <= 2) {
#line 2676
      ql_dbg(16384U, vha, 57425, "qla_target(%d): Terminating cmd %p with incorrect state %d\n",
             (int )vha->vp_idx, cmd, cmd->state);
    } else {
#line 2681
      ret = 1;
    }
  } else {

  }
#line 2684
  pkt->entry_count = 1U;
#line 2685
  pkt->handle = 4294967295U;
#line 2687
  ctio24 = (struct ctio7_to_24xx *)pkt;
#line 2688
  ctio24->entry_type = 18U;
#line 2689
  ctio24->nport_handle = (unsigned long )cmd != (unsigned long )((struct qla_tgt_cmd *)0) ? cmd->loop_id : 65535U;
#line 2690
  ctio24->timeout = 10U;
#line 2691
  ctio24->vp_index = (uint8_t )vha->vp_idx;
#line 2692
  ctio24->initiator_id[0] = atio->u.isp24.fcp_hdr.s_id[2];
#line 2693
  ctio24->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];
#line 2694
  ctio24->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];
#line 2695
  ctio24->exchange_addr = atio->u.isp24.exchange_addr;
#line 2696
  ctio24->u.status1.flags = (uint16_t )((int )((short )((int )atio->u.isp24.attr << 9)) | 16448);
#line 2699
  tmp___0 = __fswab16((int )atio->u.isp24.fcp_hdr.ox_id);
#line 2699
  temp = tmp___0;
#line 2700
  ctio24->u.status1.ox_id = temp;
#line 2703
  ctio24->u.status1.residual = get_unaligned_le32((void const   *)(& atio->u.isp24.fcp_cmnd.add_cdb) + (unsigned long )atio->u.isp24.fcp_cmnd.add_cdb_len);
#line 2706
  if (ctio24->u.status1.residual != 0U) {
#line 2707
    ctio24->u.status1.scsi_status = (uint16_t )((unsigned int )ctio24->u.status1.scsi_status | 2048U);
  } else {

  }
#line 2710
  __asm__  volatile   ("sfence": : : "memory");
#line 2711
  qla2x00_start_iocbs(vha, vha->req);
#line 2712
  return (ret);
}
}
#line 2715 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_send_term_exchange(struct scsi_qla_host *vha , struct qla_tgt_cmd *cmd ,
                                   struct atio_from_isp *atio , int ha_locked ) 
{ 
  unsigned long flags ;
  int rc ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;

  {
#line 2721
  tmp = qlt_issue_marker(vha, ha_locked);
#line 2721
  if (tmp < 0) {
#line 2722
    return;
  } else {

  }
#line 2724
  if (ha_locked != 0) {
#line 2725
    rc = __qlt_send_term_exchange(vha, cmd, atio);
#line 2726
    if (rc == -12) {
#line 2727
      qlt_alloc_qfull_cmd(vha, atio, 0, 0);
    } else {

    }
#line 2728
    goto done;
  } else {

  }
#line 2730
  tmp___0 = spinlock_check(& (vha->hw)->hardware_lock);
#line 2730
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 2731
  rc = __qlt_send_term_exchange(vha, cmd, atio);
#line 2732
  if (rc == -12) {
#line 2733
    qlt_alloc_qfull_cmd(vha, atio, 0, 0);
  } else {

  }
#line 2734
  spin_unlock_irqrestore(& (vha->hw)->hardware_lock, flags);
  done: ;
#line 2737
  if ((unsigned long )cmd != (unsigned long )((struct qla_tgt_cmd *)0) && (cmd->state != 4 || (unsigned int )*((unsigned char *)cmd + 1105UL) == 0U)) {
#line 2739
    if (ha_locked == 0) {
#line 2739
      tmp___1 = preempt_count();
#line 2739
      if (((unsigned long )tmp___1 & 2096896UL) == 0UL) {
#line 2740
        msleep(250U);
      } else {

      }
    } else {

    }
#line 2742
    qlt_unmap_sg(vha, cmd);
#line 2743
    (*(((vha->hw)->tgt.tgt_ops)->free_cmd))(cmd);
  } else {

  }
#line 2745
  return;
}
}
#line 2748 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_init_term_exchange(struct scsi_qla_host *vha ) 
{ 
  struct list_head free_list ;
  struct qla_tgt_cmd *cmd ;
  struct qla_tgt_cmd *tcmd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  int tmp ;

  {
#line 2753
  (vha->hw)->tgt.leak_exchg_thresh_hold = (uint32_t )((int )((unsigned int )(vha->hw)->fw_xcb_count / 100U) * 75);
#line 2756
  tcmd = (struct qla_tgt_cmd *)0;
#line 2756
  cmd = tcmd;
#line 2757
  tmp = list_empty((struct list_head  const  *)(& (vha->hw)->tgt.q_full_list));
#line 2757
  if (tmp == 0) {
#line 2758
    INIT_LIST_HEAD(& free_list);
#line 2759
    list_splice_init(& (vha->hw)->tgt.q_full_list, & free_list);
#line 2761
    __mptr = (struct list_head  const  *)free_list.next;
#line 2761
    cmd = (struct qla_tgt_cmd *)__mptr + 0xfffffffffffffb70UL;
#line 2761
    __mptr___0 = (struct list_head  const  *)cmd->cmd_list.next;
#line 2761
    tcmd = (struct qla_tgt_cmd *)__mptr___0 + 0xfffffffffffffb70UL;
#line 2761
    goto ldv_66857;
    ldv_66856: 
#line 2762
    list_del(& cmd->cmd_list);
#line 2766
    qlt_free_cmd(cmd);
#line 2767
    (vha->hw)->tgt.num_qfull_cmds_alloc = (vha->hw)->tgt.num_qfull_cmds_alloc - 1U;
#line 2761
    cmd = tcmd;
#line 2761
    __mptr___1 = (struct list_head  const  *)tcmd->cmd_list.next;
#line 2761
    tcmd = (struct qla_tgt_cmd *)__mptr___1 + 0xfffffffffffffb70UL;
    ldv_66857: ;
#line 2761
    if ((unsigned long )(& cmd->cmd_list) != (unsigned long )(& free_list)) {
#line 2763
      goto ldv_66856;
    } else {

    }

  } else {

  }
#line 2770
  (vha->hw)->tgt.num_qfull_cmds_dropped = 0U;
#line 2771
  return;
}
}
#line 2773 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_chk_exch_leak_thresh_hold(struct scsi_qla_host *vha ) 
{ 
  uint32_t total_leaked ;

  {
#line 2777
  total_leaked = (vha->hw)->tgt.num_qfull_cmds_dropped;
#line 2779
  if ((vha->hw)->tgt.leak_exchg_thresh_hold != 0U && (vha->hw)->tgt.leak_exchg_thresh_hold < total_leaked) {
#line 2782
    ql_dbg(16384U, vha, 57465, "Chip reset due to exchange starvation: %d/%d.\n",
           total_leaked, (int )(vha->hw)->fw_xcb_count);
#line 2786
    if (((vha->hw)->device_type & 16384U) != 0U || ((vha->hw)->device_type & 262144U) != 0U) {
#line 2787
      set_bit(18L, (unsigned long volatile   *)(& vha->dpc_flags));
    } else {
#line 2789
      set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
    }
#line 2790
    qla2xxx_wake_dpc(vha);
  } else {

  }
#line 2792
  return;
}
}
#line 2795 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_free_cmd(struct qla_tgt_cmd *cmd ) 
{ 
  struct qla_tgt_sess *sess ;
  __u16 tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int __ret_warn_on ;
  long tmp___3 ;

  {
#line 2797
  sess = cmd->sess;
#line 2799
  tmp = __fswab16((int )cmd->atio.u.isp24.fcp_hdr.ox_id);
#line 2799
  ql_dbg(16384U, cmd->vha, 57460, "%s: se_cmd[%p] ox_id %04x\n", "qlt_free_cmd", & cmd->se_cmd,
         (int )tmp);
#line 2804
  tmp___0 = ldv__builtin_expect((unsigned int )*((unsigned char *)cmd + 1105UL) != 0U,
                             0L);
#line 2804
  if (tmp___0 != 0L) {
#line 2804
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"),
                         "i" (2804), "i" (12UL));
    ldv_66868: ;
#line 2804
    goto ldv_66868;
  } else {

  }
#line 2806
  if ((unsigned int )*((unsigned char *)cmd + 1104UL) == 0U) {
#line 2807
    qlt_decr_num_pend_cmds(cmd->vha);
  } else {

  }
#line 2809
  tmp___1 = ldv__builtin_expect((unsigned int )*((unsigned char *)cmd + 1104UL) != 0U,
                             0L);
#line 2809
  if (tmp___1 != 0L) {
#line 2809
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"),
                         "i" (2809), "i" (12UL));
    ldv_66869: ;
#line 2809
    goto ldv_66869;
  } else {

  }
#line 2810
  cmd->jiffies_at_free = get_jiffies_64();
#line 2811
  tmp___2 = ldv__builtin_expect((unsigned int )*((unsigned char *)cmd + 1104UL) != 0U,
                             0L);
#line 2811
  if (tmp___2 != 0L) {
#line 2812
    kfree((void const   *)cmd->sg);
  } else {

  }
#line 2814
  if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0) || (unsigned long )sess->se_sess == (unsigned long )((struct se_session *)0)) {
#line 2815
    __ret_warn_on = 1;
#line 2815
    tmp___3 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 2815
    if (tmp___3 != 0L) {
#line 2815
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c",
                         2815);
    } else {

    }
#line 2815
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 2816
    return;
  } else {

  }
#line 2818
  cmd->jiffies_at_free = get_jiffies_64();
#line 2819
  percpu_ida_free(& (sess->se_sess)->sess_tag_pool, cmd->se_cmd.map_tag);
#line 2820
  return;
}
}
#line 2821 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static char const   __kstrtab_qlt_free_cmd[13U]  = 
#line 2821
  {      'q',      'l',      't',      '_', 
        'f',      'r',      'e',      'e', 
        '_',      'c',      'm',      'd', 
        '\000'};
#line 2821
struct kernel_symbol  const  __ksymtab_qlt_free_cmd ;
#line 2821 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
struct kernel_symbol  const  __ksymtab_qlt_free_cmd  =    {(unsigned long )(& qlt_free_cmd), (char const   *)(& __kstrtab_qlt_free_cmd)};
#line 2824 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static int qlt_prepare_srr_ctio(struct scsi_qla_host *vha , struct qla_tgt_cmd *cmd ,
                                void *ctio ) 
{ 
  struct qla_tgt_srr_ctio *sc ;
  struct qla_tgt *tgt ;
  struct qla_tgt_srr_imm *imm ;
  void *tmp ;
  int found ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct qla_tgt_srr_imm *ti ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;

  {
#line 2828
  tgt = vha->vha_tgt.qla_tgt;
#line 2831
  tgt->ctio_srr_id = tgt->ctio_srr_id + 1;
#line 2832
  cmd->cmd_flags = cmd->cmd_flags | 32768U;
#line 2834
  ql_dbg(8192U, vha, 61465, "qla_target(%d): CTIO with SRR status received\n", (int )vha->vp_idx);
#line 2837
  if ((unsigned long )ctio == (unsigned long )((void *)0)) {
#line 2838
    ql_dbg(8192U, vha, 61525, "qla_target(%d): SRR CTIO, but ctio is NULL\n", (int )vha->vp_idx);
#line 2841
    return (-22);
  } else {

  }
#line 2844
  tmp = kzalloc(32UL, 32U);
#line 2844
  sc = (struct qla_tgt_srr_ctio *)tmp;
#line 2845
  if ((unsigned long )sc != (unsigned long )((struct qla_tgt_srr_ctio *)0)) {
#line 2846
    sc->cmd = cmd;
#line 2848
    spin_lock(& tgt->srr_lock);
#line 2849
    sc->srr_id = tgt->ctio_srr_id;
#line 2850
    list_add_tail(& sc->srr_list_entry, & tgt->srr_ctio_list);
#line 2852
    ql_dbg(8192U, vha, 61466, "CTIO SRR %p added (id %d)\n", sc, sc->srr_id);
#line 2854
    if (tgt->imm_srr_id == tgt->ctio_srr_id) {
#line 2855
      found = 0;
#line 2856
      __mptr = (struct list_head  const  *)tgt->srr_imm_list.next;
#line 2856
      imm = (struct qla_tgt_srr_imm *)__mptr;
#line 2856
      goto ldv_66894;
      ldv_66893: ;
#line 2858
      if (imm->srr_id == sc->srr_id) {
#line 2859
        found = 1;
#line 2860
        goto ldv_66892;
      } else {

      }
#line 2856
      __mptr___0 = (struct list_head  const  *)imm->srr_list_entry.next;
#line 2856
      imm = (struct qla_tgt_srr_imm *)__mptr___0;
      ldv_66894: ;
#line 2856
      if ((unsigned long )(& imm->srr_list_entry) != (unsigned long )(& tgt->srr_imm_list)) {
#line 2858
        goto ldv_66893;
      } else {

      }
      ldv_66892: ;
#line 2863
      if (found != 0) {
#line 2864
        ql_dbg(8192U, vha, 61467, "Scheduling srr work\n");
#line 2866
        schedule_work___0(& tgt->srr_work);
      } else {
#line 2868
        ql_dbg(8192U, vha, 61526, "qla_target(%d): imm_srr_id == ctio_srr_id (%d), but there is no corresponding SRR IMM, deleting CTIO SRR %p\n",
               (int )vha->vp_idx, tgt->ctio_srr_id, sc);
#line 2874
        list_del(& sc->srr_list_entry);
#line 2875
        spin_unlock(& tgt->srr_lock);
#line 2877
        kfree((void const   *)sc);
#line 2878
        return (-22);
      }
    } else {

    }
#line 2881
    spin_unlock(& tgt->srr_lock);
  } else {
#line 2885
    ql_dbg(8192U, vha, 61527, "qla_target(%d): Unable to allocate SRR CTIO entry\n",
           (int )vha->vp_idx);
#line 2888
    spin_lock(& tgt->srr_lock);
#line 2889
    __mptr___1 = (struct list_head  const  *)tgt->srr_imm_list.next;
#line 2889
    imm = (struct qla_tgt_srr_imm *)__mptr___1;
#line 2889
    __mptr___2 = (struct list_head  const  *)imm->srr_list_entry.next;
#line 2889
    ti = (struct qla_tgt_srr_imm *)__mptr___2;
#line 2889
    goto ldv_66903;
    ldv_66902: ;
#line 2891
    if (imm->srr_id == tgt->ctio_srr_id) {
#line 2892
      ql_dbg(8192U, vha, 61468, "IMM SRR %p deleted (id %d)\n", imm, imm->srr_id);
#line 2895
      list_del(& imm->srr_list_entry);
#line 2896
      qlt_reject_free_srr_imm(vha, imm, 1);
    } else {

    }
#line 2889
    imm = ti;
#line 2889
    __mptr___3 = (struct list_head  const  *)ti->srr_list_entry.next;
#line 2889
    ti = (struct qla_tgt_srr_imm *)__mptr___3;
    ldv_66903: ;
#line 2889
    if ((unsigned long )(& imm->srr_list_entry) != (unsigned long )(& tgt->srr_imm_list)) {
#line 2891
      goto ldv_66902;
    } else {

    }
#line 2899
    spin_unlock(& tgt->srr_lock);
#line 2901
    return (-12);
  }
#line 2904
  return (0);
}
}
#line 2910 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static int qlt_term_ctio_exchange(struct scsi_qla_host *vha , void *ctio , struct qla_tgt_cmd *cmd ,
                                  uint32_t status ) 
{ 
  int term ;
  struct ctio7_from_24xx *c ;

  {
#line 2913
  term = 0;
#line 2915
  if ((unsigned long )ctio != (unsigned long )((void *)0)) {
#line 2916
    c = (struct ctio7_from_24xx *)ctio;
#line 2917
    term = ((int )c->flags & 16384) == 0;
  } else {
#line 2920
    term = 1;
  }
#line 2922
  if (term != 0) {
#line 2923
    qlt_send_term_exchange(vha, cmd, & cmd->atio, 1);
  } else {

  }
#line 2925
  return (term);
}
}
#line 2929 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
__inline static struct qla_tgt_cmd *qlt_get_cmd(struct scsi_qla_host *vha , uint32_t handle ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt_cmd *cmd ;

  {
#line 2932
  ha = vha->hw;
#line 2934
  handle = handle - 1U;
#line 2935
  if ((unsigned long )ha->tgt.cmds[handle] != (unsigned long )((struct qla_tgt_cmd *)0)) {
#line 2936
    cmd = ha->tgt.cmds[handle];
#line 2937
    ha->tgt.cmds[handle] = (struct qla_tgt_cmd *)0;
#line 2938
    return (cmd);
  } else {
#line 2940
    return ((struct qla_tgt_cmd *)0);
  }
}
}
#line 2944 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static struct qla_tgt_cmd *qlt_ctio_to_cmd(struct scsi_qla_host *vha , uint32_t handle ,
                                           void *ctio ) 
{ 
  struct qla_tgt_cmd *cmd ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 2947
  cmd = (struct qla_tgt_cmd *)0;
#line 2950
  handle = handle & 2684354559U;
#line 2953
  if (handle != 0U) {
#line 2954
    tmp = ldv__builtin_expect(handle == 3758096383U, 0L);
#line 2954
    if (tmp != 0L) {
#line 2955
      return ((struct qla_tgt_cmd *)0);
    } else {

    }
#line 2958
    tmp___0 = ldv__builtin_expect(handle > 1024U, 0L);
#line 2958
    if (tmp___0 != 0L) {
#line 2959
      ql_dbg(16384U, vha, 57426, "qla_target(%d): Wrong handle %x received\n", (int )vha->vp_idx,
             handle);
#line 2962
      return ((struct qla_tgt_cmd *)0);
    } else {

    }
#line 2964
    cmd = qlt_get_cmd(vha, handle);
#line 2965
    tmp___1 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct qla_tgt_cmd *)0),
                               0L);
#line 2965
    if (tmp___1 != 0L) {
#line 2966
      ql_dbg(16384U, vha, 57427, "qla_target(%d): Suspicious: unable to find the command with handle %x\n",
             (int )vha->vp_idx, handle);
#line 2970
      return ((struct qla_tgt_cmd *)0);
    } else {

    }
  } else
#line 2972
  if ((unsigned long )ctio != (unsigned long )((void *)0)) {
#line 2974
    ql_dbg(16384U, vha, 57428, "qla_target(%d): Wrong CTIO received: QLA24xx doesn\'t support NULL handles\n",
           (int )vha->vp_idx);
#line 2977
    return ((struct qla_tgt_cmd *)0);
  } else {

  }
#line 2980
  return (cmd);
}
}
#line 2985 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_abort_cmd_on_host_reset(struct scsi_qla_host *vha , struct qla_tgt_cmd *cmd ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t handle ;

  {
#line 2987
  ha = vha->hw;
#line 2990
  if ((unsigned int )*((unsigned char *)cmd + 1104UL) != 0U) {
#line 2991
    qlt_unmap_sg(vha, cmd);
  } else {

  }
#line 2993
  handle = qlt_make_handle(vha);
#line 2996
  if (cmd->state == 3) {
#line 2997
    ql_dbg(134217728U, vha, 65280, "HOST-ABORT: handle=%d, state=PROCESSED.\n", handle);
  } else
#line 2999
  if (cmd->state == 1) {
#line 3000
    cmd->write_data_transferred = 0U;
#line 3001
    cmd->state = 2;
#line 3003
    ql_dbg(134217728U, vha, 65281, "HOST-ABORT: handle=%d, state=DATA_IN.\n", handle);
#line 3006
    (*((ha->tgt.tgt_ops)->handle_data))(cmd);
#line 3007
    return;
  } else
#line 3008
  if (cmd->state == 4) {
#line 3009
    ql_dbg(134217728U, vha, 65282, "HOST-ABORT: handle=%d, state=ABORTED.\n", handle);
  } else {
#line 3012
    ql_dbg(134217728U, vha, 65283, "HOST-ABORT: handle=%d, state=BAD(%d).\n", handle,
           cmd->state);
#line 3015
    dump_stack();
  }
#line 3018
  cmd->cmd_flags = cmd->cmd_flags | 4096U;
#line 3019
  (*((ha->tgt.tgt_ops)->free_cmd))(cmd);
#line 3020
  return;
}
}
#line 3023 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_host_reset_handler(struct qla_hw_data *ha ) 
{ 
  struct qla_tgt_cmd *cmd ;
  unsigned long flags ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  scsi_qla_host_t *vha ;
  struct qla_tgt *tgt ;
  uint32_t i ;
  bool tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
#line 3027
  tmp = pci_get_drvdata(ha->pdev);
#line 3027
  base_vha = (scsi_qla_host_t *)tmp;
#line 3028
  vha = (scsi_qla_host_t *)0;
#line 3029
  tgt = base_vha->vha_tgt.qla_tgt;
#line 3032
  if ((unsigned long )(base_vha->hw)->tgt.tgt_ops == (unsigned long )((struct qla_tgt_func_tmpl *)0)) {
#line 3033
    return;
  } else {

  }
#line 3035
  if ((unsigned long )tgt == (unsigned long )((struct qla_tgt *)0)) {
#line 3036
    ql_dbg(8192U, vha, 61443, "Target mode disabled\n");
#line 3038
    return;
  } else {
#line 3035
    tmp___0 = qla_ini_mode_enabled(base_vha);
#line 3035
    if ((int )tmp___0) {
#line 3036
      ql_dbg(8192U, vha, 61443, "Target mode disabled\n");
#line 3038
      return;
    } else {

    }
  }
#line 3041
  ql_dbg(8192U, vha, 65296, "HOST-ABORT-HNDLR: base_vha->dpc_flags=%lx.\n", base_vha->dpc_flags);
#line 3045
  tmp___1 = spinlock_check(& ha->hardware_lock);
#line 3045
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 3046
  i = 1U;
#line 3046
  goto ldv_66945;
  ldv_66944: 
#line 3047
  cmd = qlt_get_cmd(base_vha, i);
#line 3048
  if ((unsigned long )cmd == (unsigned long )((struct qla_tgt_cmd *)0)) {
#line 3049
    goto ldv_66943;
  } else {

  }
#line 3051
  vha = cmd->vha;
#line 3052
  qlt_abort_cmd_on_host_reset(vha, cmd);
  ldv_66943: 
#line 3046
  i = i + 1U;
  ldv_66945: ;
#line 3046
  if (i <= 1024U) {
#line 3048
    goto ldv_66944;
  } else {

  }
#line 3054
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3055
  return;
}
}
#line 3061 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_do_ctio_completion(struct scsi_qla_host *vha , uint32_t handle , uint32_t status ,
                                   void *ctio ) 
{ 
  struct qla_hw_data *ha ;
  struct se_cmd *se_cmd ;
  struct target_core_fabric_ops  const  *tfo ;
  struct qla_tgt_cmd *cmd ;
  int tmp ;
  struct ctio_crc_from_fw *crc ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int rx_status ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 3064
  ha = vha->hw;
#line 3069
  if ((handle & 1073741824U) != 0U) {
#line 3071
    if (status != 1U) {
#line 3072
      ql_dbg(8192U, vha, 61469, "Intermediate CTIO received (status %x)\n", status);
    } else {

    }
#line 3076
    return;
  } else {

  }
#line 3079
  cmd = qlt_ctio_to_cmd(vha, handle, ctio);
#line 3080
  if ((unsigned long )cmd == (unsigned long )((struct qla_tgt_cmd *)0)) {
#line 3081
    return;
  } else {

  }
#line 3083
  se_cmd = & cmd->se_cmd;
#line 3084
  tfo = se_cmd->se_tfo;
#line 3085
  cmd->cmd_sent_to_fw = 0U;
#line 3087
  qlt_unmap_sg(vha, cmd);
#line 3089
  tmp___2 = ldv__builtin_expect(status != 1U, 0L);
#line 3089
  if (tmp___2 != 0L) {
#line 3090
    switch (status & 65535U) {
    case 14U: ;
    case 23U: ;
    case 2U: ;
    case 11U: ;
    case 8U: 
#line 3098
    ql_dbg(8192U, vha, 61528, "qla_target(%d): CTIO with status %#x received, state %x, se_cmd %p, (LIP_RESET=e, ABORTED=2, TARGET_RESET=17, TIMEOUT=b, INVALID_RX_ID=8)\n",
           (int )vha->vp_idx, status, cmd->state, se_cmd);
#line 3104
    goto ldv_66962;
    case 41U: ;
    case 40U: 
#line 3108
    ql_dbg(8192U, vha, 61529, "qla_target(%d): CTIO with PORT LOGGED OUT (29) or PORT UNAVAILABLE (28) status %x received (state %x, se_cmd %p)\n",
           (int )vha->vp_idx, status, cmd->state, se_cmd);
#line 3113
    goto ldv_66962;
    case 69U: 
#line 3116
    ql_dbg(8192U, vha, 61530, "qla_target(%d): CTIO with SRR_RECEIVED status %x received (state %x, se_cmd %p)\n",
           (int )vha->vp_idx, status, cmd->state, se_cmd);
#line 3120
    tmp = qlt_prepare_srr_ctio(vha, cmd, ctio);
#line 3120
    if (tmp != 0) {
#line 3121
      goto ldv_66962;
    } else {
#line 3123
      return;
    }
    case 12U: 
#line 3126
    crc = (struct ctio_crc_from_fw *)ctio;
#line 3128
    ql_dbg(8192U, vha, 61555, "qla_target(%d): CTIO with DIF_ERROR status %x received (state %x, se_cmd %p) actual_dif[0x%llx] expect_dif[0x%llx]\n",
           (int )vha->vp_idx, status, cmd->state, se_cmd, *((u64 *)(& crc->actual_dif)),
           *((u64 *)(& crc->expected_dif)));
#line 3134
    tmp___0 = qlt_handle_dif_error(vha, cmd, (struct ctio_crc_from_fw *)ctio);
#line 3134
    if (tmp___0 != 0) {
#line 3135
      if (cmd->state == 1) {
#line 3137
        goto skip_term;
      } else {
#line 3143
        cmd->state = 3;
#line 3144
        (*((ha->tgt.tgt_ops)->handle_dif_err))(cmd);
#line 3145
        return;
      }
    } else {
#line 3151
      status = 0U;
#line 3152
      goto skip_term;
    }
    default: 
#line 3157
    ql_dbg(8192U, vha, 61531, "qla_target(%d): CTIO with error status 0x%x received (state %x, se_cmd %p\n",
           (int )vha->vp_idx, status, cmd->state, se_cmd);
#line 3160
    goto ldv_66962;
    }
    ldv_66962: ;
#line 3170
    if (cmd->state != 1 && cmd->state != 4) {
#line 3172
      cmd->cmd_flags = cmd->cmd_flags | 8192U;
#line 3173
      tmp___1 = qlt_term_ctio_exchange(vha, ctio, cmd, status);
#line 3173
      if (tmp___1 != 0) {
#line 3174
        return;
      } else {

      }
    } else {

    }
  } else {

  }
  skip_term: ;
#line 3179
  if (cmd->state == 3) {

  } else
#line 3181
  if (cmd->state == 1) {
#line 3182
    rx_status = 0;
#line 3184
    cmd->state = 2;
#line 3186
    tmp___3 = ldv__builtin_expect(status != 1U, 0L);
#line 3186
    if (tmp___3 != 0L) {
#line 3187
      rx_status = -5;
    } else {
#line 3189
      cmd->write_data_transferred = 1U;
    }
#line 3191
    (*((ha->tgt.tgt_ops)->handle_data))(cmd);
#line 3192
    return;
  } else
#line 3193
  if (cmd->state == 4) {
#line 3194
    ql_dbg(8192U, vha, 61470, "Aborted command %p (tag %lld) finished\n", cmd, se_cmd->tag);
  } else {
#line 3197
    ql_dbg(8192U, vha, 61532, "qla_target(%d): A command in state (%d) should not return a CTIO complete\n",
           (int )vha->vp_idx, cmd->state);
  }
#line 3202
  tmp___4 = ldv__builtin_expect(status != 1U, 0L);
#line 3202
  if (tmp___4 != 0L && cmd->state != 4) {
#line 3204
    ql_dbg(8192U, vha, 61471, "Finishing failed CTIO\n");
#line 3205
    dump_stack();
  } else {

  }
#line 3209
  (*((ha->tgt.tgt_ops)->free_cmd))(cmd);
#line 3210
  return;
}
}
#line 3212 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
__inline static int qlt_get_fcp_task_attr(struct scsi_qla_host *vha , uint8_t task_codes ) 
{ 
  int fcp_task_attr ;

  {
#line 3217
  switch ((int )task_codes) {
  case 0: 
#line 3219
  fcp_task_attr = 32;
#line 3220
  goto ldv_66977;
  case 1: 
#line 3222
  fcp_task_attr = 33;
#line 3223
  goto ldv_66977;
  case 2: 
#line 3225
  fcp_task_attr = 34;
#line 3226
  goto ldv_66977;
  case 4: 
#line 3228
  fcp_task_attr = 36;
#line 3229
  goto ldv_66977;
  case 5: 
#line 3231
  fcp_task_attr = 32;
#line 3232
  goto ldv_66977;
  default: 
#line 3234
  ql_dbg(8192U, vha, 61533, "qla_target: unknown task code %x, use ORDERED instead\n",
         (int )task_codes);
#line 3237
  fcp_task_attr = 34;
#line 3238
  goto ldv_66977;
  }
  ldv_66977: ;
#line 3241
  return (fcp_task_attr);
}
}
#line 3244
static struct qla_tgt_sess *qlt_make_local_sess(struct scsi_qla_host *vha , uint8_t *s_id ) ;
#line 3249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void __qlt_do_work(struct qla_tgt_cmd *cmd ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct qla_tgt *tgt ;
  struct qla_tgt_sess *sess ;
  struct atio_from_isp *atio ;
  unsigned char *cdb ;
  unsigned long flags ;
  uint32_t data_length ;
  int ret ;
  int fcp_task_attr ;
  int data_dir ;
  int bidi ;
  u64 tmp ;
  u32 tmp___0 ;
  __u32 tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  raw_spinlock_t *tmp___3 ;

  {
#line 3251
  vha = cmd->vha;
#line 3252
  ha = vha->hw;
#line 3253
  tgt = vha->vha_tgt.qla_tgt;
#line 3254
  sess = cmd->sess;
#line 3255
  atio = & cmd->atio;
#line 3259
  bidi = 0;
#line 3261
  cmd->cmd_in_wq = 0U;
#line 3262
  cmd->cmd_flags = cmd->cmd_flags | 2U;
#line 3263
  if (tgt->tgt_stop != 0) {
#line 3264
    goto out_term;
  } else {

  }
#line 3266
  cdb = (unsigned char *)(& atio->u.isp24.fcp_cmnd.cdb);
#line 3267
  cmd->se_cmd.tag = (u64 )atio->u.isp24.exchange_addr;
#line 3268
  tmp = scsilun_to_int((struct scsi_lun *)(& atio->u.isp24.fcp_cmnd.lun));
#line 3268
  cmd->unpacked_lun = (uint32_t )tmp;
#line 3271
  if ((unsigned int )*((unsigned char *)atio + 43UL) != 0U && (unsigned int )*((unsigned char *)atio + 43UL) != 0U) {
#line 3273
    bidi = 1;
#line 3274
    data_dir = 1;
  } else
#line 3275
  if ((unsigned int )*((unsigned char *)atio + 43UL) != 0U) {
#line 3276
    data_dir = 2;
  } else
#line 3277
  if ((unsigned int )*((unsigned char *)atio + 43UL) != 0U) {
#line 3278
    data_dir = 1;
  } else {
#line 3280
    data_dir = 3;
  }
#line 3282
  fcp_task_attr = qlt_get_fcp_task_attr(vha, (int )atio->u.isp24.fcp_cmnd.task_attr);
#line 3284
  tmp___0 = get_unaligned_le32((void const   *)(& atio->u.isp24.fcp_cmnd.add_cdb) + (unsigned long )atio->u.isp24.fcp_cmnd.add_cdb_len);
#line 3284
  tmp___1 = __fswab32(tmp___0);
#line 3284
  data_length = tmp___1;
#line 3288
  ret = (*((ha->tgt.tgt_ops)->handle_cmd))(vha, cmd, cdb, data_length, fcp_task_attr,
                                           data_dir, bidi);
#line 3290
  if (ret != 0) {
#line 3291
    goto out_term;
  } else {

  }
#line 3295
  tmp___2 = spinlock_check(& ha->hardware_lock);
#line 3295
  flags = _raw_spin_lock_irqsave(tmp___2);
#line 3296
  (*((ha->tgt.tgt_ops)->put_sess))(sess);
#line 3297
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3298
  return;
  out_term: 
#line 3301
  ql_dbg(134217728U, vha, 12384, "Terminating work cmd %p", cmd);
#line 3306
  cmd->cmd_flags = cmd->cmd_flags | 4U;
#line 3307
  tmp___3 = spinlock_check(& ha->hardware_lock);
#line 3307
  flags = _raw_spin_lock_irqsave(tmp___3);
#line 3308
  qlt_send_term_exchange(vha, (struct qla_tgt_cmd *)0, & cmd->atio, 1);
#line 3310
  qlt_decr_num_pend_cmds(vha);
#line 3311
  percpu_ida_free(& (sess->se_sess)->sess_tag_pool, cmd->se_cmd.map_tag);
#line 3312
  (*((ha->tgt.tgt_ops)->put_sess))(sess);
#line 3313
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3314
  return;
}
}
#line 3316 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_do_work(struct work_struct *work ) 
{ 
  struct qla_tgt_cmd *cmd ;
  struct work_struct  const  *__mptr ;

  {
#line 3318
  __mptr = (struct work_struct  const  *)work;
#line 3318
  cmd = (struct qla_tgt_cmd *)__mptr + 0xfffffffffffffc60UL;
#line 3320
  __qlt_do_work(cmd);
#line 3321
  return;
}
}
#line 3323 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static struct qla_tgt_cmd *qlt_get_tag(scsi_qla_host_t *vha , struct qla_tgt_sess *sess ,
                                       struct atio_from_isp *atio ) 
{ 
  struct se_session *se_sess ;
  struct qla_tgt_cmd *cmd ;
  int tag ;

  {
#line 3327
  se_sess = sess->se_sess;
#line 3331
  tag = percpu_ida_alloc(& se_sess->sess_tag_pool, 0);
#line 3332
  if (tag < 0) {
#line 3333
    return ((struct qla_tgt_cmd *)0);
  } else {

  }
#line 3335
  cmd = (struct qla_tgt_cmd *)se_sess->sess_cmd_map + (unsigned long )tag;
#line 3336
  memset((void *)cmd, 0, 1296UL);
#line 3338
  memcpy((void *)(& cmd->atio), (void const   *)atio, 64UL);
#line 3339
  cmd->state = 0;
#line 3340
  cmd->tgt = vha->vha_tgt.qla_tgt;
#line 3341
  qlt_incr_num_pend_cmds(vha);
#line 3342
  cmd->vha = vha;
#line 3343
  cmd->se_cmd.map_tag = (unsigned int )tag;
#line 3344
  cmd->sess = sess;
#line 3345
  cmd->loop_id = sess->loop_id;
#line 3346
  cmd->conf_compl_supported = sess->conf_compl_supported;
#line 3348
  return (cmd);
}
}
#line 3351
static void qlt_send_busy(struct scsi_qla_host *vha , struct atio_from_isp *atio ,
                          uint16_t status ) ;
#line 3354 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_create_sess_from_atio(struct work_struct *work ) 
{ 
  struct qla_tgt_sess_op *op ;
  struct work_struct  const  *__mptr ;
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct qla_tgt_sess *sess ;
  struct qla_tgt_cmd *cmd ;
  unsigned long flags ;
  uint8_t *s_id ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 3356
  __mptr = (struct work_struct  const  *)work;
#line 3356
  op = (struct qla_tgt_sess_op *)__mptr + 0xffffffffffffffb8UL;
#line 3358
  vha = op->vha;
#line 3359
  ha = vha->hw;
#line 3363
  s_id = (uint8_t *)(& op->atio.u.isp24.fcp_hdr.s_id);
#line 3365
  ql_dbg(8192U, vha, 61474, "qla_target(%d): Unable to find wwn login (s_id %x:%x:%x), trying to create it manually\n",
         (int )vha->vp_idx, (int )*s_id, (int )*(s_id + 1UL), (int )*(s_id + 2UL));
#line 3370
  if ((unsigned int )op->atio.u.raw.entry_count > 1U) {
#line 3371
    ql_dbg(8192U, vha, 61475, "Dropping multy entry atio %p\n", & op->atio);
#line 3373
    goto out_term;
  } else {

  }
#line 3376
  mutex_lock_nested(& vha->vha_tgt.tgt_mutex, 0U);
#line 3377
  sess = qlt_make_local_sess(vha, s_id);
#line 3379
  mutex_unlock(& vha->vha_tgt.tgt_mutex);
#line 3381
  if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 3382
    goto out_term;
  } else {

  }
#line 3388
  cmd = qlt_get_tag(vha, sess, & op->atio);
#line 3389
  if ((unsigned long )cmd == (unsigned long )((struct qla_tgt_cmd *)0)) {
#line 3390
    tmp = spinlock_check(& ha->hardware_lock);
#line 3390
    flags = _raw_spin_lock_irqsave(tmp);
#line 3391
    qlt_send_busy(vha, & op->atio, 8);
#line 3392
    (*((ha->tgt.tgt_ops)->put_sess))(sess);
#line 3393
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3394
    kfree((void const   *)op);
#line 3395
    return;
  } else {

  }
#line 3401
  __qlt_do_work(cmd);
#line 3402
  kfree((void const   *)op);
#line 3403
  return;
  out_term: 
#line 3406
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 3406
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 3407
  qlt_send_term_exchange(vha, (struct qla_tgt_cmd *)0, & op->atio, 1);
#line 3408
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3409
  kfree((void const   *)op);
#line 3410
  return;
}
}
#line 3414 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static int qlt_handle_cmd_for_atio(struct scsi_qla_host *vha , struct atio_from_isp *atio ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt *tgt ;
  struct qla_tgt_sess *sess ;
  struct qla_tgt_cmd *cmd ;
  long tmp ;
  struct qla_tgt_sess_op *op ;
  void *tmp___0 ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  long tmp___1 ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_1 ;

  {
#line 3417
  ha = vha->hw;
#line 3418
  tgt = vha->vha_tgt.qla_tgt;
#line 3422
  tmp = ldv__builtin_expect(tgt->tgt_stop != 0, 0L);
#line 3422
  if (tmp != 0L) {
#line 3423
    ql_dbg(134217728U, vha, 12385, "New command while device %p is shutting down\n",
           tgt);
#line 3425
    return (-14);
  } else {

  }
#line 3428
  sess = (*((ha->tgt.tgt_ops)->find_sess_by_s_id))(vha, (uint8_t const   *)(& atio->u.isp24.fcp_hdr.s_id));
#line 3429
  tmp___1 = ldv__builtin_expect((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0),
                             0L);
#line 3429
  if (tmp___1 != 0L) {
#line 3430
    tmp___0 = kzalloc(152UL, 32U);
#line 3430
    op = (struct qla_tgt_sess_op *)tmp___0;
#line 3432
    if ((unsigned long )op == (unsigned long )((struct qla_tgt_sess_op *)0)) {
#line 3433
      return (-12);
    } else {

    }
#line 3435
    memcpy((void *)(& op->atio), (void const   *)atio, 64UL);
#line 3436
    op->vha = vha;
#line 3437
    __init_work(& op->work, 0);
#line 3437
    __constr_expr_0.counter = 137438953408L;
#line 3437
    op->work.data = __constr_expr_0;
#line 3437
    lockdep_init_map(& op->work.lockdep_map, "(&op->work)", & __key, 0);
#line 3437
    INIT_LIST_HEAD(& op->work.entry);
#line 3437
    op->work.func = & qlt_create_sess_from_atio;
#line 3438
    queue_work___1(qla_tgt_wq, & op->work);
#line 3439
    return (0);
  } else {

  }
#line 3444
  kref_get___0(& (sess->se_sess)->sess_kref);
#line 3446
  cmd = qlt_get_tag(vha, sess, atio);
#line 3447
  if ((unsigned long )cmd == (unsigned long )((struct qla_tgt_cmd *)0)) {
#line 3448
    ql_dbg(134217728U, vha, 12386, "qla_target(%d): Allocation of cmd failed\n", (int )vha->vp_idx);
#line 3450
    (*((ha->tgt.tgt_ops)->put_sess))(sess);
#line 3451
    return (-12);
  } else {

  }
#line 3454
  cmd->cmd_flags = 0U;
#line 3455
  cmd->jiffies_at_alloc = get_jiffies_64();
#line 3457
  cmd->reset_count = (vha->hw)->chip_reset;
#line 3459
  cmd->cmd_in_wq = 1U;
#line 3460
  cmd->cmd_flags = cmd->cmd_flags | 1U;
#line 3461
  __init_work(& cmd->work, 0);
#line 3461
  __constr_expr_1.counter = 137438953408L;
#line 3461
  cmd->work.data = __constr_expr_1;
#line 3461
  lockdep_init_map(& cmd->work.lockdep_map, "(&cmd->work)", & __key___0, 0);
#line 3461
  INIT_LIST_HEAD(& cmd->work.entry);
#line 3461
  cmd->work.func = & qlt_do_work;
#line 3462
  queue_work___1(qla_tgt_wq, & cmd->work);
#line 3463
  return (0);
}
}
#line 3468 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static int qlt_issue_task_mgmt(struct qla_tgt_sess *sess , uint32_t lun , int fn ,
                               void *iocb , int flags ) 
{ 
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct qla_tgt_mgmt_cmd *mcmd ;
  int res ;
  uint8_t tmr_func ;
  void *tmp ;

  {
#line 3471
  vha = sess->vha;
#line 3472
  ha = vha->hw;
#line 3477
  tmp = mempool_alloc(qla_tgt_mgmt_cmd_mempool, 32U);
#line 3477
  mcmd = (struct qla_tgt_mgmt_cmd *)tmp;
#line 3478
  if ((unsigned long )mcmd == (unsigned long )((struct qla_tgt_mgmt_cmd *)0)) {
#line 3479
    ql_dbg(4096U, vha, 65545, "qla_target(%d): Allocation of management command failed, some commands and their data could leak\n",
           (int )vha->vp_idx);
#line 3483
    return (-12);
  } else {

  }
#line 3485
  memset((void *)mcmd, 0, 1000UL);
#line 3486
  mcmd->sess = sess;
#line 3488
  if ((unsigned long )iocb != (unsigned long )((void *)0)) {
#line 3489
    memcpy((void *)(& mcmd->orig_iocb.imm_ntfy), (void const   *)iocb, 64UL);
  } else {

  }
#line 3492
  mcmd->tmr_func = (uint8_t )fn;
#line 3493
  mcmd->flags = (unsigned int )flags;
#line 3494
  mcmd->reset_count = (vha->hw)->chip_reset;
#line 3496
  switch (fn) {
  case 64: 
#line 3498
  ql_dbg(4096U, vha, 65536, "qla_target(%d): CLEAR_ACA received\n", (int )(sess->vha)->vp_idx);
#line 3500
  tmr_func = 3U;
#line 3501
  goto ldv_67071;
  case 32: 
#line 3504
  ql_dbg(4096U, vha, 65537, "qla_target(%d): TARGET_RESET received\n", (int )(sess->vha)->vp_idx);
#line 3507
  tmr_func = 6U;
#line 3508
  goto ldv_67071;
  case 16: 
#line 3511
  ql_dbg(4096U, vha, 65538, "qla_target(%d): LUN_RESET received\n", (int )(sess->vha)->vp_idx);
#line 3513
  tmr_func = 5U;
#line 3514
  goto ldv_67071;
  case 4: 
#line 3517
  ql_dbg(4096U, vha, 65539, "qla_target(%d): CLEAR_TS received\n", (int )(sess->vha)->vp_idx);
#line 3519
  tmr_func = 4U;
#line 3520
  goto ldv_67071;
  case 2: 
#line 3523
  ql_dbg(4096U, vha, 65540, "qla_target(%d): ABORT_TS received\n", (int )(sess->vha)->vp_idx);
#line 3525
  tmr_func = 2U;
#line 3526
  goto ldv_67071;
  default: 
#line 3556
  ql_dbg(4096U, vha, 65546, "qla_target(%d): Unknown task mgmt fn 0x%x\n", (int )(sess->vha)->vp_idx,
         fn);
#line 3559
  mempool_free((void *)mcmd, qla_tgt_mgmt_cmd_mempool);
#line 3560
  return (-38);
  }
  ldv_67071: 
#line 3563
  res = (*((ha->tgt.tgt_ops)->handle_tmr))(mcmd, lun, (int )tmr_func, 0U);
#line 3564
  if (res != 0) {
#line 3565
    ql_dbg(4096U, vha, 65547, "qla_target(%d): tgt.tgt_ops->handle_tmr() failed: %d\n",
           (int )(sess->vha)->vp_idx, res);
#line 3568
    mempool_free((void *)mcmd, qla_tgt_mgmt_cmd_mempool);
#line 3569
    return (-14);
  } else {

  }
#line 3572
  return (0);
}
}
#line 3576 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static int qlt_handle_task_mgmt(struct scsi_qla_host *vha , void *iocb ) 
{ 
  struct atio_from_isp *a ;
  struct qla_hw_data *ha ;
  struct qla_tgt *tgt ;
  struct qla_tgt_sess *sess ;
  uint32_t lun ;
  uint32_t unpacked_lun ;
  int lun_size ;
  int fn ;
  u64 tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 3578
  a = (struct atio_from_isp *)iocb;
#line 3579
  ha = vha->hw;
#line 3585
  tgt = vha->vha_tgt.qla_tgt;
#line 3587
  lun = (uint32_t )a->u.isp24.fcp_cmnd.lun;
#line 3588
  lun_size = 8;
#line 3589
  fn = (int )a->u.isp24.fcp_cmnd.task_mgmt_flags;
#line 3590
  sess = (*((ha->tgt.tgt_ops)->find_sess_by_s_id))(vha, (uint8_t const   *)(& a->u.isp24.fcp_hdr.s_id));
#line 3592
  tmp = scsilun_to_int((struct scsi_lun *)(& lun));
#line 3592
  unpacked_lun = (uint32_t )tmp;
#line 3594
  if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 3595
    ql_dbg(8192U, vha, 61476, "qla_target(%d): task mgmt fn 0x%x for non-existant session\n",
           (int )vha->vp_idx, fn);
#line 3598
    tmp___0 = qlt_sched_sess_work(tgt, 2, (void const   *)iocb, 64U);
#line 3598
    return (tmp___0);
  } else {

  }
#line 3602
  tmp___1 = qlt_issue_task_mgmt(sess, unpacked_lun, fn, iocb, 0);
#line 3602
  return (tmp___1);
}
}
#line 3606 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static int __qlt_abort_task(struct scsi_qla_host *vha , struct imm_ntfy_from_isp *iocb ,
                            struct qla_tgt_sess *sess ) 
{ 
  struct atio_from_isp *a ;
  struct qla_hw_data *ha ;
  struct qla_tgt_mgmt_cmd *mcmd ;
  uint32_t lun ;
  uint32_t unpacked_lun ;
  int rc ;
  void *tmp ;
  u64 tmp___0 ;

  {
#line 3609
  a = (struct atio_from_isp *)iocb;
#line 3610
  ha = vha->hw;
#line 3615
  tmp = mempool_alloc(qla_tgt_mgmt_cmd_mempool, 32U);
#line 3615
  mcmd = (struct qla_tgt_mgmt_cmd *)tmp;
#line 3616
  if ((unsigned long )mcmd == (unsigned long )((struct qla_tgt_mgmt_cmd *)0)) {
#line 3617
    ql_dbg(8192U, vha, 61535, "qla_target(%d): %s: Allocation of ABORT cmd failed\n",
           (int )vha->vp_idx, "__qlt_abort_task");
#line 3620
    return (-12);
  } else {

  }
#line 3622
  memset((void *)mcmd, 0, 1000UL);
#line 3624
  mcmd->sess = sess;
#line 3625
  memcpy((void *)(& mcmd->orig_iocb.imm_ntfy), (void const   *)iocb, 64UL);
#line 3628
  lun = (uint32_t )a->u.isp24.fcp_cmnd.lun;
#line 3629
  tmp___0 = scsilun_to_int((struct scsi_lun *)(& lun));
#line 3629
  unpacked_lun = (uint32_t )tmp___0;
#line 3630
  mcmd->reset_count = (vha->hw)->chip_reset;
#line 3632
  rc = (*((ha->tgt.tgt_ops)->handle_tmr))(mcmd, unpacked_lun, 1, (uint32_t )iocb->u.isp2x.seq_id);
#line 3634
  if (rc != 0) {
#line 3635
    ql_dbg(8192U, vha, 61536, "qla_target(%d): tgt_ops->handle_tmr() failed: %d\n",
           (int )vha->vp_idx, rc);
#line 3638
    mempool_free((void *)mcmd, qla_tgt_mgmt_cmd_mempool);
#line 3639
    return (-14);
  } else {

  }
#line 3642
  return (0);
}
}
#line 3646 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static int qlt_abort_task(struct scsi_qla_host *vha , struct imm_ntfy_from_isp *iocb ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt_sess *sess ;
  int loop_id ;
  int tmp ;
  int tmp___0 ;

  {
#line 3649
  ha = vha->hw;
#line 3653
  loop_id = (int )ha->device_type < 0 ? (int )((struct atio_from_isp *)iocb)->u.isp2x.target.extended : (int )((struct atio_from_isp *)iocb)->u.isp2x.target.id.standard;
#line 3655
  sess = (*((ha->tgt.tgt_ops)->find_sess_by_loop_id))(vha, (int )((uint16_t const   )loop_id));
#line 3656
  if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 3657
    ql_dbg(8192U, vha, 61477, "qla_target(%d): task abort for unexisting session\n",
           (int )vha->vp_idx);
#line 3660
    tmp = qlt_sched_sess_work(vha->vha_tgt.qla_tgt, 1, (void const   *)iocb, 64U);
#line 3660
    return (tmp);
  } else {

  }
#line 3664
  tmp___0 = __qlt_abort_task(vha, iocb, sess);
#line 3664
  return (tmp___0);
}
}
#line 3670 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static int qlt_24xx_handle_els(struct scsi_qla_host *vha , struct imm_ntfy_from_isp *iocb ) 
{ 
  int res ;
  struct qla_tgt *tgt ;

  {
#line 3673
  res = 0;
#line 3675
  ql_dbg(8192U, vha, 61478, "qla_target(%d): Port ID: 0x%3phC ELS opcode: 0x%02x\n",
         (int )vha->vp_idx, (uint8_t *)(& iocb->u.isp24.port_id), (int )iocb->u.isp24.status_subcode);
#line 3679
  switch ((int )iocb->u.isp24.status_subcode) {
  case 3: ;
  case 4: ;
  case 32: ;
  case 5: ;
  case 33: 
#line 3685
  res = qlt_reset(vha, (void *)iocb, 65533);
#line 3686
  goto ldv_67118;
  case 80: ;
  case 82: 
#line 3690
  tgt = vha->vha_tgt.qla_tgt;
#line 3691
  if ((unsigned int )*((unsigned char *)tgt + 32UL) != 0U) {
#line 3692
    qlt_send_notify_ack(vha, & tgt->link_reinit_iocb, 0U, 0, 0, 0, 0, 0);
#line 3694
    tgt->link_reinit_iocb_pending = 0U;
  } else {

  }
#line 3696
  res = 1;
#line 3697
  goto ldv_67118;
  default: 
#line 3701
  ql_dbg(8192U, vha, 61537, "qla_target(%d): Unsupported ELS command %x received\n",
         (int )vha->vp_idx, (int )iocb->u.isp24.status_subcode);
#line 3704
  res = qlt_reset(vha, (void *)iocb, 65533);
#line 3705
  goto ldv_67118;
  }
  ldv_67118: ;
#line 3708
  return (res);
}
}
#line 3711 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static int qlt_set_data_offset(struct qla_tgt_cmd *cmd , uint32_t offset ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 3718
  descriptor.modname = "qla2xxx";
#line 3718
  descriptor.function = "qlt_set_data_offset";
#line 3718
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c";
#line 3718
  descriptor.format = "Rejecting non zero SRR rel_offs: %u\n";
#line 3718
  descriptor.lineno = 3718U;
#line 3718
  descriptor.flags = 0U;
#line 3718
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 3718
  if (tmp != 0L) {
#line 3718
    __dynamic_pr_debug(& descriptor, "Rejecting non zero SRR rel_offs: %u\n", offset);
  } else {

  }
#line 3719
  return (-1);
}
}
#line 3815 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
__inline static int qlt_srr_adjust_data(struct qla_tgt_cmd *cmd , uint32_t srr_rel_offs ,
                                        int *xmit_type ) 
{ 
  int res ;
  int rel_offs ;

  {
#line 3818
  res = 0;
#line 3820
  rel_offs = (int )(srr_rel_offs - (uint32_t )cmd->offset);
#line 3821
  ql_dbg(8192U, cmd->vha, 61479, "srr_rel_offs=%d, rel_offs=%d", srr_rel_offs, rel_offs);
#line 3824
  *xmit_type = 3;
#line 3826
  if (rel_offs < 0) {
#line 3827
    ql_dbg(8192U, cmd->vha, 61538, "qla_target(%d): SRR rel_offs (%d) < 0", (int )(cmd->vha)->vp_idx,
           rel_offs);
#line 3830
    res = -1;
  } else
#line 3831
  if (cmd->bufflen == rel_offs) {
#line 3832
    *xmit_type = 2;
  } else
#line 3833
  if (rel_offs > 0) {
#line 3834
    res = qlt_set_data_offset(cmd, (uint32_t )rel_offs);
  } else {

  }
#line 3836
  return (res);
}
}
#line 3840 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_handle_srr(struct scsi_qla_host *vha , struct qla_tgt_srr_ctio *sctio ,
                           struct qla_tgt_srr_imm *imm ) 
{ 
  struct imm_ntfy_from_isp *ntfy ;
  struct qla_hw_data *ha ;
  struct qla_tgt_cmd *cmd ;
  struct se_cmd *se_cmd ;
  unsigned long flags ;
  int xmit_type ;
  int resp ;
  uint32_t offset ;
  uint16_t srr_ui ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  raw_spinlock_t *tmp___4 ;
  int tmp___5 ;
  raw_spinlock_t *tmp___6 ;

  {
#line 3843
  ntfy = & imm->imm_ntfy;
#line 3845
  ha = vha->hw;
#line 3846
  cmd = sctio->cmd;
#line 3847
  se_cmd = & cmd->se_cmd;
#line 3849
  xmit_type = 0;
#line 3849
  resp = 0;
#line 3853
  offset = ntfy->u.isp24.srr_rel_offs;
#line 3854
  srr_ui = ntfy->u.isp24.srr_ui;
#line 3856
  ql_dbg(8192U, vha, 61480, "SRR cmd %p, srr_ui %x\n", cmd, (int )srr_ui);
#line 3859
  switch ((int )srr_ui) {
  case 7: 
#line 3861
  tmp = spinlock_check(& ha->hardware_lock);
#line 3861
  flags = _raw_spin_lock_irqsave(tmp);
#line 3862
  qlt_send_notify_ack(vha, ntfy, 0U, 0, 0, 0, 0, 0);
#line 3864
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3865
  xmit_type = 2;
#line 3866
  resp = 1;
#line 3867
  goto ldv_67154;
  case 1: ;
#line 3869
  if ((unsigned long )cmd->sg == (unsigned long )((struct scatterlist *)0) || cmd->sg_cnt == 0) {
#line 3870
    ql_dbg(8192U, vha, 61539, "Unable to process SRR_IU_DATA_IN due to missing cmd->sg, state: %d\n",
           cmd->state);
#line 3873
    dump_stack();
#line 3874
    goto out_reject;
  } else {

  }
#line 3876
  if ((unsigned int )se_cmd->scsi_status != 0U) {
#line 3877
    ql_dbg(16384U, vha, 57386, "Rejecting SRR_IU_DATA_IN with non GOOD scsi_status\n");
#line 3880
    goto out_reject;
  } else {

  }
#line 3882
  cmd->bufflen = (int )se_cmd->data_length;
#line 3884
  tmp___2 = qlt_has_data(cmd);
#line 3884
  if (tmp___2 != 0) {
#line 3885
    tmp___0 = qlt_srr_adjust_data(cmd, offset, & xmit_type);
#line 3885
    if (tmp___0 != 0) {
#line 3886
      goto out_reject;
    } else {

    }
#line 3887
    tmp___1 = spinlock_check(& ha->hardware_lock);
#line 3887
    flags = _raw_spin_lock_irqsave(tmp___1);
#line 3888
    qlt_send_notify_ack(vha, ntfy, 0U, 0, 0, 0, 0, 0);
#line 3890
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3891
    resp = 1;
  } else {
#line 3893
    ql_dbg(8192U, vha, 61540, "qla_target(%d): SRR for in data for cmd without them (tag %lld, SCSI status %d), reject",
           (int )vha->vp_idx, se_cmd->tag, (int )cmd->se_cmd.scsi_status);
#line 3897
    goto out_reject;
  }
#line 3899
  goto ldv_67154;
  case 5: ;
#line 3901
  if ((unsigned long )cmd->sg == (unsigned long )((struct scatterlist *)0) || cmd->sg_cnt == 0) {
#line 3902
    ql_dbg(8192U, vha, 61541, "Unable to process SRR_IU_DATA_OUT due to missing cmd->sg\n");
#line 3905
    dump_stack();
#line 3906
    goto out_reject;
  } else {

  }
#line 3908
  if ((unsigned int )se_cmd->scsi_status != 0U) {
#line 3909
    ql_dbg(16384U, vha, 57387, "Rejecting SRR_IU_DATA_OUT with non GOOD scsi_status\n");
#line 3912
    goto out_reject;
  } else {

  }
#line 3914
  cmd->bufflen = (int )se_cmd->data_length;
#line 3916
  tmp___5 = qlt_has_data(cmd);
#line 3916
  if (tmp___5 != 0) {
#line 3917
    tmp___3 = qlt_srr_adjust_data(cmd, offset, & xmit_type);
#line 3917
    if (tmp___3 != 0) {
#line 3918
      goto out_reject;
    } else {

    }
#line 3919
    tmp___4 = spinlock_check(& ha->hardware_lock);
#line 3919
    flags = _raw_spin_lock_irqsave(tmp___4);
#line 3920
    qlt_send_notify_ack(vha, ntfy, 0U, 0, 0, 0, 0, 0);
#line 3922
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3923
    if (xmit_type & 1) {
#line 3924
      cmd->cmd_flags = cmd->cmd_flags | 256U;
#line 3925
      qlt_rdy_to_xfer(cmd);
    } else {

    }
  } else {
#line 3928
    ql_dbg(8192U, vha, 61542, "qla_target(%d): SRR for out data for cmd without them (tag %lld, SCSI status %d), reject",
           (int )vha->vp_idx, se_cmd->tag, (int )cmd->se_cmd.scsi_status);
#line 3931
    goto out_reject;
  }
#line 3933
  goto ldv_67154;
  default: 
#line 3935
  ql_dbg(8192U, vha, 61543, "qla_target(%d): Unknown srr_ui value %x", (int )vha->vp_idx,
         (int )srr_ui);
#line 3938
  goto out_reject;
  }
  ldv_67154: ;
#line 3942
  if (resp != 0) {
#line 3943
    cmd->cmd_flags = cmd->cmd_flags | 128U;
#line 3944
    qlt_xmit_response(cmd, xmit_type, (int )se_cmd->scsi_status);
  } else {

  }
#line 3947
  return;
  out_reject: 
#line 3950
  tmp___6 = spinlock_check(& ha->hardware_lock);
#line 3950
  flags = _raw_spin_lock_irqsave(tmp___6);
#line 3951
  qlt_send_notify_ack(vha, ntfy, 0U, 0, 0, 1, 9, 0);
#line 3955
  if (cmd->state == 1) {
#line 3956
    cmd->state = 2;
#line 3957
    dump_stack();
  } else {
#line 3959
    cmd->cmd_flags = cmd->cmd_flags | 512U;
#line 3960
    qlt_send_term_exchange(vha, cmd, & cmd->atio, 1);
  }
#line 3962
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3963
  return;
}
}
#line 3965 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_reject_free_srr_imm(struct scsi_qla_host *vha , struct qla_tgt_srr_imm *imm ,
                                    int ha_locked ) 
{ 
  struct qla_hw_data *ha ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 3968
  ha = vha->hw;
#line 3969
  flags = 0UL;
#line 3971
  if (ha_locked == 0) {
#line 3972
    tmp = spinlock_check(& ha->hardware_lock);
#line 3972
    flags = _raw_spin_lock_irqsave(tmp);
  } else {

  }
#line 3974
  qlt_send_notify_ack(vha, & imm->imm_ntfy, 0U, 0, 0, 1, 9, 0);
#line 3979
  if (ha_locked == 0) {
#line 3980
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
  } else {

  }
#line 3982
  kfree((void const   *)imm);
#line 3983
  return;
}
}
#line 3985 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_handle_srr_work(struct work_struct *work ) 
{ 
  struct qla_tgt *tgt ;
  struct work_struct  const  *__mptr ;
  struct scsi_qla_host *vha ;
  struct qla_tgt_srr_ctio *sctio ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr___0 ;
  struct qla_tgt_srr_imm *imm ;
  struct qla_tgt_srr_imm *i ;
  struct qla_tgt_srr_imm *ti ;
  struct qla_tgt_cmd *cmd ;
  struct se_cmd *se_cmd ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;

  {
#line 3987
  __mptr = (struct work_struct  const  *)work;
#line 3987
  tgt = (struct qla_tgt *)__mptr + 0xfffffffffffffd10UL;
#line 3988
  vha = tgt->vha;
#line 3992
  ql_dbg(8192U, vha, 61481, "Entering SRR work (tgt %p)\n", tgt);
  restart: 
#line 3996
  tmp = spinlock_check(& tgt->srr_lock);
#line 3996
  flags = _raw_spin_lock_irqsave(tmp);
#line 3997
  __mptr___0 = (struct list_head  const  *)tgt->srr_ctio_list.next;
#line 3997
  sctio = (struct qla_tgt_srr_ctio *)__mptr___0;
#line 3997
  goto ldv_67211;
  ldv_67210: 
#line 4002
  imm = (struct qla_tgt_srr_imm *)0;
#line 4003
  __mptr___1 = (struct list_head  const  *)tgt->srr_imm_list.next;
#line 4003
  i = (struct qla_tgt_srr_imm *)__mptr___1;
#line 4003
  __mptr___2 = (struct list_head  const  *)i->srr_list_entry.next;
#line 4003
  ti = (struct qla_tgt_srr_imm *)__mptr___2;
#line 4003
  goto ldv_67207;
  ldv_67206: ;
#line 4005
  if (i->srr_id == sctio->srr_id) {
#line 4006
    list_del(& i->srr_list_entry);
#line 4007
    if ((unsigned long )imm != (unsigned long )((struct qla_tgt_srr_imm *)0)) {
#line 4008
      ql_dbg(8192U, vha, 61544, "qla_target(%d): There must be only one IMM SRR per CTIO SRR (IMM SRR %p, id %d, CTIO %p\n",
             (int )vha->vp_idx, i, i->srr_id, sctio);
#line 4013
      qlt_reject_free_srr_imm(tgt->vha, i, 0);
    } else {
#line 4015
      imm = i;
    }
  } else {

  }
#line 4003
  i = ti;
#line 4003
  __mptr___3 = (struct list_head  const  *)ti->srr_list_entry.next;
#line 4003
  ti = (struct qla_tgt_srr_imm *)__mptr___3;
  ldv_67207: ;
#line 4003
  if ((unsigned long )(& i->srr_list_entry) != (unsigned long )(& tgt->srr_imm_list)) {
#line 4005
    goto ldv_67206;
  } else {

  }
#line 4019
  ql_dbg(8192U, vha, 61482, "IMM SRR %p, CTIO SRR %p (id %d)\n", imm, sctio, sctio->srr_id);
#line 4023
  if ((unsigned long )imm == (unsigned long )((struct qla_tgt_srr_imm *)0)) {
#line 4024
    ql_dbg(8192U, vha, 61483, "Not found matching IMM for SRR CTIO (id %d)\n", sctio->srr_id);
#line 4027
    goto ldv_67209;
  } else {
#line 4029
    list_del(& sctio->srr_list_entry);
  }
#line 4031
  spin_unlock_irqrestore(& tgt->srr_lock, flags);
#line 4033
  cmd = sctio->cmd;
#line 4039
  cmd->offset = 0;
#line 4040
  if ((unsigned int )*((unsigned char *)cmd + 1104UL) != 0U) {
#line 4041
    kfree((void const   *)cmd->sg);
#line 4042
    cmd->sg = (struct scatterlist *)0;
#line 4043
    cmd->free_sg = 0U;
  } else {

  }
#line 4045
  se_cmd = & cmd->se_cmd;
#line 4047
  cmd->sg_cnt = (int )se_cmd->t_data_nents;
#line 4048
  cmd->sg = se_cmd->t_data_sg;
#line 4050
  ql_dbg(8192U, vha, 61484, "SRR cmd %p (se_cmd %p, tag %lld, op %x), sg_cnt=%d, offset=%d",
         cmd, & cmd->se_cmd, se_cmd->tag, (unsigned long )se_cmd->t_task_cdb != (unsigned long )((unsigned char *)0U) ? (int )*(se_cmd->t_task_cdb) : 0,
         cmd->sg_cnt, cmd->offset);
#line 4055
  qlt_handle_srr(vha, sctio, imm);
#line 4057
  kfree((void const   *)imm);
#line 4058
  kfree((void const   *)sctio);
#line 4059
  goto restart;
  ldv_67209: 
#line 3997
  __mptr___4 = (struct list_head  const  *)sctio->srr_list_entry.next;
#line 3997
  sctio = (struct qla_tgt_srr_ctio *)__mptr___4;
  ldv_67211: ;
#line 3997
  if ((unsigned long )(& sctio->srr_list_entry) != (unsigned long )(& tgt->srr_ctio_list)) {
#line 3999
    goto ldv_67210;
  } else {

  }
#line 4061
  spin_unlock_irqrestore(& tgt->srr_lock, flags);
#line 4062
  return;
}
}
#line 4065 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_prepare_srr_imm(struct scsi_qla_host *vha , struct imm_ntfy_from_isp *iocb ) 
{ 
  struct qla_tgt_srr_imm *imm ;
  struct qla_tgt *tgt ;
  struct qla_tgt_srr_ctio *sctio ;
  void *tmp ;
  int found ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct qla_tgt_srr_ctio *ts ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;

  {
#line 4069
  tgt = vha->vha_tgt.qla_tgt;
#line 4072
  tgt->imm_srr_id = tgt->imm_srr_id + 1;
#line 4074
  ql_log(1U, vha, 61485, "qla_target(%d): SRR received\n", (int )vha->vp_idx);
#line 4077
  tmp = kzalloc(88UL, 32U);
#line 4077
  imm = (struct qla_tgt_srr_imm *)tmp;
#line 4078
  if ((unsigned long )imm != (unsigned long )((struct qla_tgt_srr_imm *)0)) {
#line 4079
    memcpy((void *)(& imm->imm_ntfy), (void const   *)iocb, 64UL);
#line 4082
    spin_lock(& tgt->srr_lock);
#line 4083
    imm->srr_id = tgt->imm_srr_id;
#line 4084
    list_add_tail(& imm->srr_list_entry, & tgt->srr_imm_list);
#line 4086
    ql_dbg(8192U, vha, 61486, "IMM NTFY SRR %p added (id %d, ui %x)\n", imm, imm->srr_id,
           (int )iocb->u.isp24.srr_ui);
#line 4089
    if (tgt->imm_srr_id == tgt->ctio_srr_id) {
#line 4090
      found = 0;
#line 4091
      __mptr = (struct list_head  const  *)tgt->srr_ctio_list.next;
#line 4091
      sctio = (struct qla_tgt_srr_ctio *)__mptr;
#line 4091
      goto ldv_67227;
      ldv_67226: ;
#line 4093
      if (sctio->srr_id == imm->srr_id) {
#line 4094
        found = 1;
#line 4095
        goto ldv_67225;
      } else {

      }
#line 4091
      __mptr___0 = (struct list_head  const  *)sctio->srr_list_entry.next;
#line 4091
      sctio = (struct qla_tgt_srr_ctio *)__mptr___0;
      ldv_67227: ;
#line 4091
      if ((unsigned long )(& sctio->srr_list_entry) != (unsigned long )(& tgt->srr_ctio_list)) {
#line 4093
        goto ldv_67226;
      } else {

      }
      ldv_67225: ;
#line 4098
      if (found != 0) {
#line 4099
        ql_dbg(8192U, vha, 61487, "%s", (char *)"Scheduling srr work\n");
#line 4101
        schedule_work___0(& tgt->srr_work);
      } else {
#line 4103
        ql_dbg(8192U, vha, 61488, "qla_target(%d): imm_srr_id == ctio_srr_id (%d), but there is no corresponding SRR CTIO, deleting IMM SRR %p\n",
               (int )vha->vp_idx, tgt->ctio_srr_id, imm);
#line 4109
        list_del(& imm->srr_list_entry);
#line 4111
        kfree((void const   *)imm);
#line 4113
        spin_unlock(& tgt->srr_lock);
#line 4114
        goto out_reject;
      }
    } else {

    }
#line 4117
    spin_unlock(& tgt->srr_lock);
  } else {
#line 4121
    ql_dbg(8192U, vha, 61545, "qla_target(%d): Unable to allocate SRR IMM entry, SRR request will be rejected\n",
           (int )vha->vp_idx);
#line 4126
    spin_lock(& tgt->srr_lock);
#line 4127
    __mptr___1 = (struct list_head  const  *)tgt->srr_ctio_list.next;
#line 4127
    sctio = (struct qla_tgt_srr_ctio *)__mptr___1;
#line 4127
    __mptr___2 = (struct list_head  const  *)sctio->srr_list_entry.next;
#line 4127
    ts = (struct qla_tgt_srr_ctio *)__mptr___2;
#line 4127
    goto ldv_67237;
    ldv_67236: ;
#line 4129
    if (sctio->srr_id == tgt->imm_srr_id) {
#line 4130
      ql_dbg(8192U, vha, 61489, "CTIO SRR %p deleted (id %d)\n", sctio, sctio->srr_id);
#line 4133
      list_del(& sctio->srr_list_entry);
#line 4134
      qlt_send_term_exchange(vha, sctio->cmd, & (sctio->cmd)->atio, 1);
#line 4136
      kfree((void const   *)sctio);
    } else {

    }
#line 4127
    sctio = ts;
#line 4127
    __mptr___3 = (struct list_head  const  *)ts->srr_list_entry.next;
#line 4127
    ts = (struct qla_tgt_srr_ctio *)__mptr___3;
    ldv_67237: ;
#line 4127
    if ((unsigned long )(& sctio->srr_list_entry) != (unsigned long )(& tgt->srr_ctio_list)) {
#line 4129
      goto ldv_67236;
    } else {

    }
#line 4139
    spin_unlock(& tgt->srr_lock);
#line 4140
    goto out_reject;
  }
#line 4143
  return;
  out_reject: 
#line 4146
  qlt_send_notify_ack(vha, iocb, 0U, 0, 0, 1, 9, 0);
#line 4147
  return;
}
}
#line 4155 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_handle_imm_notify(struct scsi_qla_host *vha , struct imm_ntfy_from_isp *iocb ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t add_flags ;
  int send_notify_ack ;
  uint16_t status ;
  int tmp ;
  struct qla_tgt *tgt ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 4158
  ha = vha->hw;
#line 4159
  add_flags = 0U;
#line 4160
  send_notify_ack = 1;
#line 4163
  status = iocb->u.isp2x.status;
#line 4164
  switch ((int )status) {
  case 14: 
#line 4167
  ql_dbg(8192U, vha, 61490, "qla_target(%d): LIP reset (loop %#x), subcode %x\n",
         (int )vha->vp_idx, (int )iocb->u.isp24.nport_handle, (int )iocb->u.isp24.status_subcode);
#line 4172
  tmp = qlt_reset(vha, (void *)iocb, 65534);
#line 4172
  if (tmp == 0) {
#line 4173
    send_notify_ack = 0;
  } else {

  }
#line 4174
  goto ldv_67248;
  case 15: 
#line 4179
  tgt = vha->vha_tgt.qla_tgt;
#line 4180
  ql_dbg(8192U, vha, 61491, "qla_target(%d): LINK REINIT (loop %#x, subcode %x)\n",
         (int )vha->vp_idx, (int )iocb->u.isp24.nport_handle, (int )iocb->u.isp24.status_subcode);
#line 4185
  if ((unsigned int )*((unsigned char *)tgt + 32UL) != 0U) {
#line 4186
    qlt_send_notify_ack(vha, & tgt->link_reinit_iocb, 0U, 0, 0, 0, 0, 0);
  } else {

  }
#line 4189
  memcpy((void *)(& tgt->link_reinit_iocb), (void const   *)iocb, 64UL);
#line 4190
  tgt->link_reinit_iocb_pending = 1U;
#line 4195
  send_notify_ack = 0;
#line 4196
  goto ldv_67248;
  case 41: 
#line 4200
  ql_dbg(8192U, vha, 61492, "qla_target(%d): Port logout (loop %#x, subcode %x)\n",
         (int )vha->vp_idx, (int )iocb->u.isp24.nport_handle, (int )iocb->u.isp24.status_subcode);
#line 4206
  tmp___0 = qlt_reset(vha, (void *)iocb, 65533);
#line 4206
  if (tmp___0 == 0) {
#line 4207
    send_notify_ack = 0;
  } else {

  }
#line 4209
  goto ldv_67248;
  case 45: 
#line 4212
  ql_dbg(8192U, vha, 61493, "qla_target(%d): Global TPRLO (%x)\n", (int )vha->vp_idx,
         (int )status);
#line 4214
  tmp___1 = qlt_reset(vha, (void *)iocb, 65532);
#line 4214
  if (tmp___1 == 0) {
#line 4215
    send_notify_ack = 0;
  } else {

  }
#line 4217
  goto ldv_67248;
  case 42: 
#line 4220
  ql_dbg(8192U, vha, 61494, "qla_target(%d): Port config changed (%x)\n", (int )vha->vp_idx,
         (int )status);
#line 4223
  tmp___2 = qlt_reset(vha, (void *)iocb, 65534);
#line 4223
  if (tmp___2 == 0) {
#line 4224
    send_notify_ack = 0;
  } else {

  }
#line 4226
  goto ldv_67248;
  case 46: 
#line 4229
  ql_dbg(8192U, vha, 61546, "qla_target(%d): Link failure detected\n", (int )vha->vp_idx);
#line 4233
  tmp___3 = qlt_reset(vha, (void *)iocb, 65532);
#line 4233
  if (tmp___3 == 0) {
#line 4234
    send_notify_ack = 0;
  } else {

  }
#line 4235
  goto ldv_67248;
  case 22: 
#line 4238
  ql_dbg(8192U, vha, 61547, "qla_target(%d): Cannot provide requested capability (IOCB overflowed the immediate notify resource count)\n",
         (int )vha->vp_idx);
#line 4242
  goto ldv_67248;
  case 32: 
#line 4245
  ql_dbg(8192U, vha, 61495, "qla_target(%d): Abort Task (S %08x I %#x -> L %#x)\n",
         (int )vha->vp_idx, (int )iocb->u.isp2x.seq_id, (int )ha->device_type < 0 ? (int )((struct atio_from_isp *)iocb)->u.isp2x.target.extended : (int )((struct atio_from_isp *)iocb)->u.isp2x.target.id.standard,
         (int )iocb->u.isp2x.lun);
#line 4251
  tmp___4 = qlt_abort_task(vha, iocb);
#line 4251
  if (tmp___4 == 0) {
#line 4252
    send_notify_ack = 0;
  } else {

  }
#line 4253
  goto ldv_67248;
  case 52: 
#line 4256
  ql_dbg(8192U, vha, 61548, "qla_target(%d): Out of resources, host %ld\n", (int )vha->vp_idx,
         vha->host_no);
#line 4259
  goto ldv_67248;
  case 54: 
#line 4262
  ql_dbg(8192U, vha, 61496, "qla_target(%d): Immediate notify task %x\n", (int )vha->vp_idx,
         (int )iocb->u.isp2x.task_flags);
#line 4265
  tmp___5 = qlt_handle_task_mgmt(vha, (void *)iocb);
#line 4265
  if (tmp___5 == 0) {
#line 4266
    send_notify_ack = 0;
  } else {

  }
#line 4267
  goto ldv_67248;
  case 70: 
#line 4270
  tmp___6 = qlt_24xx_handle_els(vha, iocb);
#line 4270
  if (tmp___6 == 0) {
#line 4271
    send_notify_ack = 0;
  } else {

  }
#line 4272
  goto ldv_67248;
  case 69: 
#line 4275
  qlt_prepare_srr_imm(vha, iocb);
#line 4276
  send_notify_ack = 0;
#line 4277
  goto ldv_67248;
  default: 
#line 4280
  ql_dbg(8192U, vha, 61549, "qla_target(%d): Received unknown immediate notify status %x\n",
         (int )vha->vp_idx, (int )status);
#line 4283
  goto ldv_67248;
  }
  ldv_67248: ;
#line 4286
  if (send_notify_ack != 0) {
#line 4287
    qlt_send_notify_ack(vha, iocb, add_flags, 0, 0, 0, 0, 0);
  } else {

  }
#line 4288
  return;
}
}
#line 4294 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static int __qlt_send_busy(struct scsi_qla_host *vha , struct atio_from_isp *atio ,
                           uint16_t status ) 
{ 
  struct ctio7_to_24xx *ctio24 ;
  struct qla_hw_data *ha ;
  request_t *pkt ;
  struct qla_tgt_sess *sess ;
  void *tmp ;
  __u16 tmp___0 ;

  {
#line 4298
  ha = vha->hw;
#line 4300
  sess = (struct qla_tgt_sess *)0;
#line 4302
  sess = (*((ha->tgt.tgt_ops)->find_sess_by_s_id))(vha, (uint8_t const   *)(& atio->u.isp24.fcp_hdr.s_id));
#line 4304
  if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 4305
    qlt_send_term_exchange(vha, (struct qla_tgt_cmd *)0, atio, 1);
#line 4306
    return (0);
  } else {

  }
#line 4310
  tmp = qla2x00_alloc_iocbs(vha, (srb_t *)0);
#line 4310
  pkt = (request_t *)tmp;
#line 4311
  if ((unsigned long )pkt == (unsigned long )((request_t *)0)) {
#line 4312
    ql_dbg(134217728U, vha, 12387, "qla_target(%d): %s failed: unable to allocate request packet",
           (int )vha->vp_idx, "__qlt_send_busy");
#line 4315
    return (-12);
  } else {

  }
#line 4318
  pkt->entry_count = 1U;
#line 4319
  pkt->handle = 4294967295U;
#line 4321
  ctio24 = (struct ctio7_to_24xx *)pkt;
#line 4322
  ctio24->entry_type = 18U;
#line 4323
  ctio24->nport_handle = sess->loop_id;
#line 4324
  ctio24->timeout = 10U;
#line 4325
  ctio24->vp_index = (uint8_t )vha->vp_idx;
#line 4326
  ctio24->initiator_id[0] = atio->u.isp24.fcp_hdr.s_id[2];
#line 4327
  ctio24->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];
#line 4328
  ctio24->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];
#line 4329
  ctio24->exchange_addr = atio->u.isp24.exchange_addr;
#line 4330
  ctio24->u.status1.flags = (uint16_t )((int )((short )((int )atio->u.isp24.attr << 9)) | -32448);
#line 4338
  tmp___0 = __fswab16((int )atio->u.isp24.fcp_hdr.ox_id);
#line 4338
  ctio24->u.status1.ox_id = tmp___0;
#line 4339
  ctio24->u.status1.scsi_status = status;
#line 4341
  __asm__  volatile   ("sfence": : : "memory");
#line 4342
  qla2x00_start_iocbs(vha, vha->req);
#line 4343
  return (0);
}
}
#line 4352 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_alloc_qfull_cmd(struct scsi_qla_host *vha , struct atio_from_isp *atio ,
                                uint16_t status , int qfull ) 
{ 
  struct qla_tgt *tgt ;
  struct qla_hw_data *ha ;
  struct qla_tgt_sess *sess ;
  struct se_session *se_sess ;
  struct qla_tgt_cmd *cmd ;
  int tag ;
  long tmp ;

  {
#line 4355
  tgt = vha->vha_tgt.qla_tgt;
#line 4356
  ha = vha->hw;
#line 4362
  tmp = ldv__builtin_expect(tgt->tgt_stop != 0, 0L);
#line 4362
  if (tmp != 0L) {
#line 4363
    ql_dbg(134217728U, vha, 12298, "New command while device %p is shutting down\n",
           tgt);
#line 4365
    return;
  } else {

  }
#line 4368
  if ((vha->hw)->tgt.num_qfull_cmds_alloc + 1U > 8192U) {
#line 4369
    (vha->hw)->tgt.num_qfull_cmds_dropped = (vha->hw)->tgt.num_qfull_cmds_dropped + 1U;
#line 4370
    if ((vha->hw)->tgt.num_qfull_cmds_dropped > (vha->hw)->qla_stats.stat_max_qfull_cmds_dropped) {
#line 4372
      (vha->hw)->qla_stats.stat_max_qfull_cmds_dropped = (vha->hw)->tgt.num_qfull_cmds_dropped;
    } else {

    }
#line 4375
    ql_dbg(134217728U, vha, 12392, "qla_target(%d): %s: QFull CMD dropped[%d]\n",
           (int )vha->vp_idx, "qlt_alloc_qfull_cmd", (vha->hw)->tgt.num_qfull_cmds_dropped);
#line 4380
    qlt_chk_exch_leak_thresh_hold(vha);
#line 4381
    return;
  } else {

  }
#line 4384
  sess = (*((ha->tgt.tgt_ops)->find_sess_by_s_id))(vha, (uint8_t const   *)(& atio->u.isp24.fcp_hdr.s_id));
#line 4386
  if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 4387
    return;
  } else {

  }
#line 4389
  se_sess = sess->se_sess;
#line 4391
  tag = percpu_ida_alloc(& se_sess->sess_tag_pool, 0);
#line 4392
  if (tag < 0) {
#line 4393
    return;
  } else {

  }
#line 4395
  cmd = (struct qla_tgt_cmd *)se_sess->sess_cmd_map + (unsigned long )tag;
#line 4396
  if ((unsigned long )cmd == (unsigned long )((struct qla_tgt_cmd *)0)) {
#line 4397
    ql_dbg(134217728U, vha, 12297, "qla_target(%d): %s: Allocation of cmd failed\n",
           (int )vha->vp_idx, "qlt_alloc_qfull_cmd");
#line 4401
    (vha->hw)->tgt.num_qfull_cmds_dropped = (vha->hw)->tgt.num_qfull_cmds_dropped + 1U;
#line 4402
    if ((vha->hw)->tgt.num_qfull_cmds_dropped > (vha->hw)->qla_stats.stat_max_qfull_cmds_dropped) {
#line 4404
      (vha->hw)->qla_stats.stat_max_qfull_cmds_dropped = (vha->hw)->tgt.num_qfull_cmds_dropped;
    } else {

    }
#line 4407
    qlt_chk_exch_leak_thresh_hold(vha);
#line 4408
    return;
  } else {

  }
#line 4411
  memset((void *)cmd, 0, 1296UL);
#line 4413
  qlt_incr_num_pend_cmds(vha);
#line 4414
  INIT_LIST_HEAD(& cmd->cmd_list);
#line 4415
  memcpy((void *)(& cmd->atio), (void const   *)atio, 64UL);
#line 4417
  cmd->tgt = vha->vha_tgt.qla_tgt;
#line 4418
  cmd->vha = vha;
#line 4419
  cmd->reset_count = (vha->hw)->chip_reset;
#line 4420
  cmd->q_full = 1U;
#line 4422
  if (qfull != 0) {
#line 4423
    cmd->q_full = 1U;
#line 4425
    cmd->state = (int )status;
  } else {
#line 4427
    cmd->term_exchg = 1U;
  }
#line 4429
  list_add_tail(& cmd->cmd_list, & (vha->hw)->tgt.q_full_list);
#line 4431
  (vha->hw)->tgt.num_qfull_cmds_alloc = (vha->hw)->tgt.num_qfull_cmds_alloc + 1U;
#line 4432
  if ((vha->hw)->tgt.num_qfull_cmds_alloc > (vha->hw)->qla_stats.stat_max_qfull_cmds_alloc) {
#line 4434
    (vha->hw)->qla_stats.stat_max_qfull_cmds_alloc = (vha->hw)->tgt.num_qfull_cmds_alloc;
  } else {

  }
#line 4436
  return;
}
}
#line 4439 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
int qlt_free_qfull_cmds(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  unsigned long flags ;
  struct qla_tgt_cmd *cmd ;
  struct qla_tgt_cmd *tcmd ;
  struct list_head free_list ;
  int rc ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  __u16 tmp___2 ;
  __u16 tmp___3 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;

  {
#line 4441
  ha = vha->hw;
#line 4445
  rc = 0;
#line 4447
  tmp = list_empty((struct list_head  const  *)(& ha->tgt.q_full_list));
#line 4447
  if (tmp != 0) {
#line 4448
    return (0);
  } else {

  }
#line 4450
  INIT_LIST_HEAD(& free_list);
#line 4452
  tmp___0 = spinlock_check(& (vha->hw)->hardware_lock);
#line 4452
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 4454
  tmp___1 = list_empty((struct list_head  const  *)(& ha->tgt.q_full_list));
#line 4454
  if (tmp___1 != 0) {
#line 4455
    spin_unlock_irqrestore(& (vha->hw)->hardware_lock, flags);
#line 4456
    return (0);
  } else {

  }
#line 4459
  __mptr = (struct list_head  const  *)ha->tgt.q_full_list.next;
#line 4459
  cmd = (struct qla_tgt_cmd *)__mptr + 0xfffffffffffffb70UL;
#line 4459
  __mptr___0 = (struct list_head  const  *)cmd->cmd_list.next;
#line 4459
  tcmd = (struct qla_tgt_cmd *)__mptr___0 + 0xfffffffffffffb70UL;
#line 4459
  goto ldv_67306;
  ldv_67305: ;
#line 4460
  if ((unsigned int )*((unsigned char *)cmd + 1104UL) != 0U) {
#line 4462
    rc = __qlt_send_busy(vha, & cmd->atio, (int )((uint16_t )cmd->state));
  } else
#line 4463
  if ((unsigned int )*((unsigned char *)cmd + 1104UL) != 0U) {
#line 4464
    rc = __qlt_send_term_exchange(vha, (struct qla_tgt_cmd *)0, & cmd->atio);
  } else {

  }
#line 4466
  if (rc == -12) {
#line 4467
    goto ldv_67303;
  } else {

  }
#line 4469
  if ((unsigned int )*((unsigned char *)cmd + 1104UL) != 0U) {
#line 4470
    tmp___2 = __fswab16((int )cmd->atio.u.isp24.fcp_hdr.ox_id);
#line 4470
    ql_dbg(134217728U, vha, 12294, "%s: busy sent for ox_id[%04x]\n", "qlt_free_qfull_cmds",
           (int )tmp___2);
  } else
#line 4473
  if ((unsigned int )*((unsigned char *)cmd + 1104UL) != 0U) {
#line 4474
    tmp___3 = __fswab16((int )cmd->atio.u.isp24.fcp_hdr.ox_id);
#line 4474
    ql_dbg(134217728U, vha, 12295, "%s: Term exchg sent for ox_id[%04x]\n", "qlt_free_qfull_cmds",
           (int )tmp___3);
  } else {
#line 4478
    ql_dbg(134217728U, vha, 12296, "%s: Unexpected cmd in QFull list %p\n", "qlt_free_qfull_cmds",
           cmd);
  }
#line 4482
  list_del(& cmd->cmd_list);
#line 4483
  list_add_tail(& cmd->cmd_list, & free_list);
#line 4486
  (vha->hw)->tgt.num_qfull_cmds_alloc = (vha->hw)->tgt.num_qfull_cmds_alloc - 1U;
#line 4459
  cmd = tcmd;
#line 4459
  __mptr___1 = (struct list_head  const  *)tcmd->cmd_list.next;
#line 4459
  tcmd = (struct qla_tgt_cmd *)__mptr___1 + 0xfffffffffffffb70UL;
  ldv_67306: ;
#line 4459
  if ((unsigned long )(& cmd->cmd_list) != (unsigned long )(& ha->tgt.q_full_list)) {
#line 4461
    goto ldv_67305;
  } else {

  }
  ldv_67303: 
#line 4488
  spin_unlock_irqrestore(& (vha->hw)->hardware_lock, flags);
#line 4490
  cmd = (struct qla_tgt_cmd *)0;
#line 4492
  __mptr___2 = (struct list_head  const  *)free_list.next;
#line 4492
  cmd = (struct qla_tgt_cmd *)__mptr___2 + 0xfffffffffffffb70UL;
#line 4492
  __mptr___3 = (struct list_head  const  *)cmd->cmd_list.next;
#line 4492
  tcmd = (struct qla_tgt_cmd *)__mptr___3 + 0xfffffffffffffb70UL;
#line 4492
  goto ldv_67314;
  ldv_67313: 
#line 4493
  list_del(& cmd->cmd_list);
#line 4497
  qlt_free_cmd(cmd);
#line 4492
  cmd = tcmd;
#line 4492
  __mptr___4 = (struct list_head  const  *)tcmd->cmd_list.next;
#line 4492
  tcmd = (struct qla_tgt_cmd *)__mptr___4 + 0xfffffffffffffb70UL;
  ldv_67314: ;
#line 4492
  if ((unsigned long )(& cmd->cmd_list) != (unsigned long )(& free_list)) {
#line 4494
    goto ldv_67313;
  } else {

  }

#line 4499
  return (rc);
}
}
#line 4503 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_send_busy(struct scsi_qla_host *vha , struct atio_from_isp *atio ,
                          uint16_t status ) 
{ 
  int rc ;

  {
#line 4506
  rc = 0;
#line 4508
  rc = __qlt_send_busy(vha, atio, (int )status);
#line 4509
  if (rc == -12) {
#line 4510
    qlt_alloc_qfull_cmd(vha, atio, (int )status, 1);
  } else {

  }
#line 4511
  return;
}
}
#line 4514 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static int qlt_chk_qfull_thresh_hold(struct scsi_qla_host *vha , struct atio_from_isp *atio ) 
{ 
  struct qla_hw_data *ha ;
  uint16_t status ;

  {
#line 4517
  ha = vha->hw;
#line 4520
  if (ha->tgt.num_pend_cmds < (uint32_t )((int )((unsigned int )ha->fw_xcb_count / 100U) * 90)) {
#line 4521
    return (0);
  } else {

  }
#line 4523
  status = (uint16_t )temp_sam_status;
#line 4524
  qlt_send_busy(vha, atio, (int )status);
#line 4525
  return (1);
}
}
#line 4530 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_24xx_atio_pkt(struct scsi_qla_host *vha , struct atio_from_isp *atio ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt *tgt ;
  int rc ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 4533
  ha = vha->hw;
#line 4534
  tgt = vha->vha_tgt.qla_tgt;
#line 4537
  tmp = ldv__builtin_expect((unsigned long )tgt == (unsigned long )((struct qla_tgt *)0),
                         0L);
#line 4537
  if (tmp != 0L) {
#line 4538
    ql_dbg(134217728U, vha, 12388, "ATIO pkt, but no tgt (ha %p)", ha);
#line 4540
    return;
  } else {

  }
#line 4547
  tgt->irq_cmd_count = tgt->irq_cmd_count + 1;
#line 4549
  switch ((int )atio->u.raw.entry_type) {
  case 6: 
#line 4551
  tmp___0 = ldv__builtin_expect(atio->u.isp24.exchange_addr == 4294967295U, 0L);
#line 4551
  if (tmp___0 != 0L) {
#line 4553
    ql_dbg(134217728U, vha, 12389, "qla_target(%d): ATIO_TYPE7 received with UNKNOWN exchange address, sending QUEUE_FULL\n",
           (int )vha->vp_idx);
#line 4557
    qlt_send_busy(vha, atio, 40);
#line 4558
    goto ldv_67336;
  } else {

  }
#line 4563
  tmp___1 = ldv__builtin_expect((unsigned int )atio->u.isp24.fcp_cmnd.task_mgmt_flags == 0U,
                             1L);
#line 4563
  if (tmp___1 != 0L) {
#line 4564
    rc = qlt_chk_qfull_thresh_hold(vha, atio);
#line 4565
    if (rc != 0) {
#line 4566
      tgt->irq_cmd_count = tgt->irq_cmd_count - 1;
#line 4567
      return;
    } else {

    }
#line 4569
    rc = qlt_handle_cmd_for_atio(vha, atio);
  } else {
#line 4571
    rc = qlt_handle_task_mgmt(vha, (void *)atio);
  }
#line 4573
  tmp___2 = ldv__builtin_expect(rc != 0, 0L);
#line 4573
  if (tmp___2 != 0L) {
#line 4574
    if (rc == -3) {
#line 4576
      qlt_send_busy(vha, atio, 8);
    } else
#line 4581
    if (tgt->tgt_stop != 0) {
#line 4582
      ql_dbg(16384U, vha, 57433, "qla_target: Unable to send command to target for req, ignoring.\n");
    } else {
#line 4587
      ql_dbg(16384U, vha, 57434, "qla_target(%d): Unable to send command to target, sending BUSY status.\n",
             (int )vha->vp_idx);
#line 4591
      qlt_send_busy(vha, atio, 8);
    }
  } else {

  }
#line 4595
  goto ldv_67336;
  case 13: 
#line 4599
  tmp___3 = ldv__builtin_expect((unsigned int )atio->u.isp2x.entry_status != 0U, 0L);
#line 4599
  if (tmp___3 != 0L) {
#line 4600
    ql_dbg(16384U, vha, 57435, "qla_target(%d): Received ATIO packet %x with error status %x\n",
           (int )vha->vp_idx, (int )atio->u.raw.entry_type, (int )atio->u.isp2x.entry_status);
#line 4605
    goto ldv_67336;
  } else {

  }
#line 4607
  ql_dbg(16384U, vha, 57390, "%s", (char *)"IMMED_NOTIFY ATIO");
#line 4608
  qlt_handle_imm_notify(vha, (struct imm_ntfy_from_isp *)atio);
#line 4609
  goto ldv_67336;
  default: 
#line 4613
  ql_dbg(16384U, vha, 57436, "qla_target(%d): Received unknown ATIO atio type %x\n",
         (int )vha->vp_idx, (int )atio->u.raw.entry_type);
#line 4616
  goto ldv_67336;
  }
  ldv_67336: 
#line 4619
  tgt->irq_cmd_count = tgt->irq_cmd_count - 1;
#line 4620
  return;
}
}
#line 4624 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_response_pkt(struct scsi_qla_host *vha , response_t *pkt ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt *tgt ;
  long tmp ;
  struct ctio7_from_24xx *entry ;
  struct atio_from_isp *atio ;
  int rc ;
  long tmp___0 ;
  struct ctio_to_2xxx *entry___0 ;
  struct ctio_to_2xxx *entry___1 ;
  struct nack_to_isp *entry___2 ;
  struct abts_resp_from_24xx_fw *entry___3 ;

  {
#line 4626
  ha = vha->hw;
#line 4627
  tgt = vha->vha_tgt.qla_tgt;
#line 4629
  tmp = ldv__builtin_expect((unsigned long )tgt == (unsigned long )((struct qla_tgt *)0),
                         0L);
#line 4629
  if (tmp != 0L) {
#line 4630
    ql_dbg(16384U, vha, 57437, "qla_target(%d): Response pkt %x received, but no tgt (ha %p)\n",
           (int )vha->vp_idx, (int )pkt->entry_type, ha);
#line 4633
    return;
  } else {

  }
#line 4641
  tgt->irq_cmd_count = tgt->irq_cmd_count + 1;
#line 4643
  switch ((int )pkt->entry_type) {
  case 122: ;
  case 18: 
#line 4647
  entry = (struct ctio7_from_24xx *)pkt;
#line 4648
  qlt_do_ctio_completion(vha, entry->handle, (uint32_t )((int )entry->status | ((int )pkt->entry_status << 16)),
                         (void *)entry);
#line 4651
  goto ldv_67348;
  case 22: 
#line 4656
  atio = (struct atio_from_isp *)pkt;
#line 4658
  if ((unsigned int )atio->u.isp2x.status != 61U) {
#line 4660
    ql_dbg(16384U, vha, 57438, "qla_target(%d): ATIO with error status %x received\n",
           (int )vha->vp_idx, (int )atio->u.isp2x.status);
#line 4664
    goto ldv_67348;
  } else {

  }
#line 4667
  rc = qlt_chk_qfull_thresh_hold(vha, atio);
#line 4668
  if (rc != 0) {
#line 4669
    tgt->irq_cmd_count = tgt->irq_cmd_count - 1;
#line 4670
    return;
  } else {

  }
#line 4673
  rc = qlt_handle_cmd_for_atio(vha, atio);
#line 4674
  tmp___0 = ldv__builtin_expect(rc != 0, 0L);
#line 4674
  if (tmp___0 != 0L) {
#line 4675
    if (rc == -3) {
#line 4677
      qlt_send_busy(vha, atio, 0);
    } else
#line 4682
    if (tgt->tgt_stop != 0) {
#line 4683
      ql_dbg(16384U, vha, 57439, "qla_target: Unable to send command to target, sending TERM EXCHANGE for rsp\n");
#line 4687
      qlt_send_term_exchange(vha, (struct qla_tgt_cmd *)0, atio, 1);
    } else {
#line 4690
      ql_dbg(16384U, vha, 57440, "qla_target(%d): Unable to send command to target, sending BUSY status\n",
             (int )vha->vp_idx);
#line 4694
      qlt_send_busy(vha, atio, 0);
    }
  } else {

  }
#line 4699
  goto ldv_67348;
  case 23: 
#line 4703
  entry___0 = (struct ctio_to_2xxx *)pkt;
#line 4704
  qlt_do_ctio_completion(vha, entry___0->handle, (uint32_t )((int )entry___0->status | ((int )pkt->entry_status << 16)),
                         (void *)entry___0);
#line 4707
  goto ldv_67348;
  case 31: 
#line 4712
  entry___1 = (struct ctio_to_2xxx *)pkt;
#line 4713
  qlt_do_ctio_completion(vha, entry___1->handle, (uint32_t )((int )entry___1->status | ((int )pkt->entry_status << 16)),
                         (void *)entry___1);
#line 4716
  goto ldv_67348;
  case 13: 
#line 4720
  ql_dbg(16384U, vha, 57397, "%s", (char *)"IMMED_NOTIFY\n");
#line 4721
  qlt_handle_imm_notify(vha, (struct imm_ntfy_from_isp *)pkt);
#line 4722
  goto ldv_67348;
  case 14: ;
#line 4725
  if (tgt->notify_ack_expected > 0) {
#line 4726
    entry___2 = (struct nack_to_isp *)pkt;
#line 4727
    ql_dbg(16384U, vha, 57398, "NOTIFY_ACK seq %08x status %x\n", (int )entry___2->u.isp2x.seq_id,
           (int )entry___2->u.isp2x.status);
#line 4731
    tgt->notify_ack_expected = tgt->notify_ack_expected - 1;
#line 4732
    if ((unsigned int )entry___2->u.isp2x.status != 1U) {
#line 4734
      ql_dbg(16384U, vha, 57441, "qla_target(%d): NOTIFY_ACK failed %x\n", (int )vha->vp_idx,
             (int )entry___2->u.isp2x.status);
    } else {

    }
  } else {
#line 4740
    ql_dbg(16384U, vha, 57442, "qla_target(%d): Unexpected NOTIFY_ACK received\n",
           (int )vha->vp_idx);
  }
#line 4744
  goto ldv_67348;
  case 84: 
#line 4747
  ql_dbg(16384U, vha, 57399, "ABTS_RECV_24XX: instance %d\n", (int )vha->vp_idx);
#line 4749
  qlt_24xx_handle_abts(vha, (struct abts_recv_from_24xx *)pkt);
#line 4750
  goto ldv_67348;
  case 85: ;
#line 4753
  if (tgt->abts_resp_expected > 0) {
#line 4754
    entry___3 = (struct abts_resp_from_24xx_fw *)pkt;
#line 4756
    ql_dbg(16384U, vha, 57400, "ABTS_RESP_24XX: compl_status %x\n", (int )entry___3->compl_status);
#line 4759
    tgt->abts_resp_expected = tgt->abts_resp_expected - 1;
#line 4760
    if ((unsigned int )entry___3->compl_status != 0U) {
#line 4762
      if (entry___3->error_subcode1 == 30U && entry___3->error_subcode2 == 0U) {
#line 4779
        qlt_24xx_retry_term_exchange(vha, entry___3);
      } else {
#line 4782
        ql_dbg(16384U, vha, 57443, "qla_target(%d): ABTS_RESP_24XX failed %x (subcode %x:%x)",
               (int )vha->vp_idx, (int )entry___3->compl_status, entry___3->error_subcode1,
               entry___3->error_subcode2);
      }
    } else {

    }
  } else {
#line 4790
    ql_dbg(16384U, vha, 57444, "qla_target(%d): Unexpected ABTS_RESP_24XX received\n",
           (int )vha->vp_idx);
  }
#line 4794
  goto ldv_67348;
  default: 
#line 4797
  ql_dbg(16384U, vha, 57445, "qla_target(%d): Received unknown response pkt type %x\n",
         (int )vha->vp_idx, (int )pkt->entry_type);
#line 4800
  goto ldv_67348;
  }
  ldv_67348: 
#line 4803
  tgt->irq_cmd_count = tgt->irq_cmd_count - 1;
#line 4804
  return;
}
}
#line 4809 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_async_event(uint16_t code , struct scsi_qla_host *vha , uint16_t *mailbox ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt *tgt ;
  int login_code ;
  long tmp ;

  {
#line 4812
  ha = vha->hw;
#line 4813
  tgt = vha->vha_tgt.qla_tgt;
#line 4816
  if ((unsigned long )ha->tgt.tgt_ops == (unsigned long )((struct qla_tgt_func_tmpl *)0)) {
#line 4817
    return;
  } else {

  }
#line 4819
  tmp = ldv__builtin_expect((unsigned long )tgt == (unsigned long )((struct qla_tgt *)0),
                         0L);
#line 4819
  if (tmp != 0L) {
#line 4820
    ql_dbg(16384U, vha, 57402, "ASYNC EVENT %#x, but no tgt (ha %p)\n", (int )code,
           ha);
#line 4822
    return;
  } else {

  }
#line 4825
  if (((unsigned int )code == 32816U || (unsigned int )code == 32822U) && (int )ha->device_type & 1) {
#line 4827
    return;
  } else {

  }
#line 4833
  tgt->irq_cmd_count = tgt->irq_cmd_count + 1;
#line 4835
  switch ((int )code) {
  case 32769: ;
  case 32770: ;
  case 32771: ;
  case 32772: 
#line 4840
  ql_dbg(8192U, vha, 61498, "qla_target(%d): System error async event %#x occurred",
         (int )vha->vp_idx, (int )code);
#line 4843
  goto ldv_67375;
  case 32773: 
#line 4845
  set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4846
  goto ldv_67375;
  case 32785: 
#line 4850
  ql_dbg(8192U, vha, 61499, "qla_target(%d): Async LOOP_UP occurred (m[0]=%x, m[1]=%x, m[2]=%x, m[3]=%x)",
         (int )vha->vp_idx, (int )*mailbox, (int )*(mailbox + 1UL), (int )*(mailbox + 2UL),
         (int )*(mailbox + 3UL));
#line 4855
  if ((unsigned int )*((unsigned char *)tgt + 32UL) != 0U) {
#line 4856
    qlt_send_notify_ack(vha, & tgt->link_reinit_iocb, 0U, 0, 0, 0, 0, 0);
#line 4858
    tgt->link_reinit_iocb_pending = 0U;
  } else {

  }
#line 4860
  goto ldv_67375;
  case 32784: ;
  case 32786: ;
  case 32787: ;
  case 32789: 
#line 4867
  ql_dbg(8192U, vha, 61500, "qla_target(%d): Async event %#x occurred (m[0]=%x, m[1]=%x, m[2]=%x, m[3]=%x)",
         (int )vha->vp_idx, (int )code, (int )*mailbox, (int )*(mailbox + 1UL), (int )*(mailbox + 2UL),
         (int )*(mailbox + 3UL));
#line 4872
  goto ldv_67375;
  case 32788: 
#line 4875
  ql_dbg(8192U, vha, 61501, "qla_target(%d): Port update async event %#x occurred: updating the ports database (m[0]=%x, m[1]=%x, m[2]=%x, m[3]=%x)",
         (int )vha->vp_idx, (int )code, (int )*mailbox, (int )*(mailbox + 1UL), (int )*(mailbox + 2UL),
         (int )*(mailbox + 3UL));
#line 4882
  login_code = (int )*(mailbox + 2UL);
#line 4883
  if (login_code == 4) {
#line 4884
    ql_dbg(8192U, vha, 61502, "Async MB 2: Got PLOGI Complete\n");
  } else
#line 4886
  if (login_code == 7) {
#line 4887
    ql_dbg(8192U, vha, 61503, "Async MB 2: Port Logged Out\n");
  } else {

  }
#line 4889
  goto ldv_67375;
  default: ;
#line 4892
  goto ldv_67375;
  }
  ldv_67375: 
#line 4895
  tgt->irq_cmd_count = tgt->irq_cmd_count - 1;
#line 4896
  return;
}
}
#line 4898 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static fc_port_t *qlt_get_port_database(struct scsi_qla_host *vha , uint16_t loop_id ) 
{ 
  fc_port_t *fcport ;
  int rc ;
  void *tmp ;

  {
#line 4904
  tmp = kzalloc(136UL, 208U);
#line 4904
  fcport = (fc_port_t *)tmp;
#line 4905
  if ((unsigned long )fcport == (unsigned long )((fc_port_t *)0)) {
#line 4906
    ql_dbg(8192U, vha, 61551, "qla_target(%d): Allocation of tmp FC port failed",
           (int )vha->vp_idx);
#line 4909
    return ((fc_port_t *)0);
  } else {

  }
#line 4912
  fcport->loop_id = loop_id;
#line 4914
  rc = qla2x00_get_port_database(vha, fcport, 0);
#line 4915
  if (rc != 0) {
#line 4916
    ql_dbg(8192U, vha, 61552, "qla_target(%d): Failed to retrieve fcport information -- get_port_database() returned %x (loop_id=0x%04x)",
           (int )vha->vp_idx, rc, (int )loop_id);
#line 4920
    kfree((void const   *)fcport);
#line 4921
    return ((fc_port_t *)0);
  } else {

  }
#line 4924
  return (fcport);
}
}
#line 4928 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static struct qla_tgt_sess *qlt_make_local_sess(struct scsi_qla_host *vha , uint8_t *s_id ) 
{ 
  struct qla_tgt_sess *sess ;
  fc_port_t *fcport ;
  int rc ;
  int global_resets ;
  uint16_t loop_id ;
  int tmp ;
  int tmp___0 ;

  {
#line 4931
  sess = (struct qla_tgt_sess *)0;
#line 4932
  fcport = (fc_port_t *)0;
#line 4934
  loop_id = 0U;
  retry: 
#line 4937
  global_resets = atomic_read((atomic_t const   *)(& (vha->vha_tgt.qla_tgt)->tgt_global_resets_count));
#line 4940
  rc = qla24xx_get_loop_id(vha, (uint8_t const   *)s_id, & loop_id);
#line 4941
  if (rc != 0) {
#line 4942
    if ((unsigned int )*s_id == 255U && (unsigned int )*(s_id + 1UL) == 252U) {
#line 4948
      ql_dbg(8192U, vha, 61506, "Unable to find initiator with S_ID %x:%x:%x", (int )*s_id,
             (int )*(s_id + 1UL), (int )*(s_id + 2UL));
    } else {
#line 4952
      ql_dbg(8192U, vha, 61553, "qla_target(%d): Unable to find initiator with S_ID %x:%x:%x",
             (int )vha->vp_idx, (int )*s_id, (int )*(s_id + 1UL), (int )*(s_id + 2UL));
    }
#line 4957
    return ((struct qla_tgt_sess *)0);
  } else {

  }
#line 4960
  fcport = qlt_get_port_database(vha, (int )loop_id);
#line 4961
  if ((unsigned long )fcport == (unsigned long )((fc_port_t *)0)) {
#line 4962
    return ((struct qla_tgt_sess *)0);
  } else {

  }
#line 4964
  tmp___0 = atomic_read((atomic_t const   *)(& (vha->vha_tgt.qla_tgt)->tgt_global_resets_count));
#line 4964
  if (tmp___0 != global_resets) {
#line 4966
    tmp = atomic_read((atomic_t const   *)(& (vha->vha_tgt.qla_tgt)->tgt_global_resets_count));
#line 4966
    ql_dbg(8192U, vha, 61507, "qla_target(%d): global reset during session discovery (counter was %d, new %d), retrying",
           (int )vha->vp_idx, global_resets, tmp);
#line 4972
    goto retry;
  } else {

  }
#line 4975
  sess = qlt_create_sess(vha, fcport, 1);
#line 4977
  kfree((void const   *)fcport);
#line 4978
  return (sess);
}
}
#line 4981 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_abort_work(struct qla_tgt *tgt , struct qla_tgt_sess_work_param *prm ) 
{ 
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct qla_tgt_sess *sess ;
  unsigned long flags ;
  uint32_t be_s_id ;
  uint8_t s_id[3U] ;
  int rc ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 4984
  vha = tgt->vha;
#line 4985
  ha = vha->hw;
#line 4986
  sess = (struct qla_tgt_sess *)0;
#line 4992
  tmp = spinlock_check(& ha->hardware_lock);
#line 4992
  flags = _raw_spin_lock_irqsave(tmp);
#line 4994
  if (tgt->tgt_stop != 0) {
#line 4995
    goto out_term;
  } else {

  }
#line 4997
  s_id[0] = prm->__annonCompField127.abts.fcp_hdr_le.s_id[2];
#line 4998
  s_id[1] = prm->__annonCompField127.abts.fcp_hdr_le.s_id[1];
#line 4999
  s_id[2] = prm->__annonCompField127.abts.fcp_hdr_le.s_id[0];
#line 5001
  sess = (*((ha->tgt.tgt_ops)->find_sess_by_s_id))(vha, (uint8_t const   *)(& be_s_id));
#line 5003
  if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 5004
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 5006
    mutex_lock_nested(& vha->vha_tgt.tgt_mutex, 0U);
#line 5007
    sess = qlt_make_local_sess(vha, (uint8_t *)(& s_id));
#line 5009
    mutex_unlock(& vha->vha_tgt.tgt_mutex);
#line 5011
    tmp___0 = spinlock_check(& ha->hardware_lock);
#line 5011
    flags = _raw_spin_lock_irqsave(tmp___0);
#line 5012
    if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 5013
      goto out_term;
    } else {

    }
  } else {
#line 5015
    kref_get___0(& (sess->se_sess)->sess_kref);
  }
#line 5018
  if (tgt->tgt_stop != 0) {
#line 5019
    goto out_term;
  } else {

  }
#line 5021
  rc = __qlt_24xx_handle_abts(vha, & prm->__annonCompField127.abts, sess);
#line 5022
  if (rc != 0) {
#line 5023
    goto out_term;
  } else {

  }
#line 5025
  (*((ha->tgt.tgt_ops)->put_sess))(sess);
#line 5026
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 5027
  return;
  out_term: 
#line 5030
  qlt_24xx_send_abts_resp(vha, & prm->__annonCompField127.abts, 4U, 0);
#line 5031
  if ((unsigned long )sess != (unsigned long )((struct qla_tgt_sess *)0)) {
#line 5032
    (*((ha->tgt.tgt_ops)->put_sess))(sess);
  } else {

  }
#line 5033
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 5034
  return;
}
}
#line 5036 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_tmr_work(struct qla_tgt *tgt , struct qla_tgt_sess_work_param *prm ) 
{ 
  struct atio_from_isp *a ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct qla_tgt_sess *sess ;
  unsigned long flags ;
  uint8_t *s_id ;
  int rc ;
  uint32_t lun ;
  uint32_t unpacked_lun ;
  int lun_size ;
  int fn ;
  void *iocb ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;
  u64 tmp___1 ;

  {
#line 5039
  a = & prm->__annonCompField127.tm_iocb2;
#line 5040
  vha = tgt->vha;
#line 5041
  ha = vha->hw;
#line 5042
  sess = (struct qla_tgt_sess *)0;
#line 5044
  s_id = (uint8_t *)0U;
#line 5050
  tmp = spinlock_check(& ha->hardware_lock);
#line 5050
  flags = _raw_spin_lock_irqsave(tmp);
#line 5052
  if (tgt->tgt_stop != 0) {
#line 5053
    goto out_term;
  } else {

  }
#line 5055
  s_id = (uint8_t *)(& prm->__annonCompField127.tm_iocb2.u.isp24.fcp_hdr.s_id);
#line 5056
  sess = (*((ha->tgt.tgt_ops)->find_sess_by_s_id))(vha, (uint8_t const   *)s_id);
#line 5057
  if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 5058
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 5060
    mutex_lock_nested(& vha->vha_tgt.tgt_mutex, 0U);
#line 5061
    sess = qlt_make_local_sess(vha, s_id);
#line 5063
    mutex_unlock(& vha->vha_tgt.tgt_mutex);
#line 5065
    tmp___0 = spinlock_check(& ha->hardware_lock);
#line 5065
    flags = _raw_spin_lock_irqsave(tmp___0);
#line 5066
    if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 5067
      goto out_term;
    } else {

    }
  } else {
#line 5069
    kref_get___0(& (sess->se_sess)->sess_kref);
  }
#line 5072
  iocb = (void *)a;
#line 5073
  lun = (uint32_t )a->u.isp24.fcp_cmnd.lun;
#line 5074
  lun_size = 4;
#line 5075
  fn = (int )a->u.isp24.fcp_cmnd.task_mgmt_flags;
#line 5076
  tmp___1 = scsilun_to_int((struct scsi_lun *)(& lun));
#line 5076
  unpacked_lun = (uint32_t )tmp___1;
#line 5078
  rc = qlt_issue_task_mgmt(sess, unpacked_lun, fn, iocb, 0);
#line 5079
  if (rc != 0) {
#line 5080
    goto out_term;
  } else {

  }
#line 5082
  (*((ha->tgt.tgt_ops)->put_sess))(sess);
#line 5083
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 5084
  return;
  out_term: 
#line 5087
  qlt_send_term_exchange(vha, (struct qla_tgt_cmd *)0, & prm->__annonCompField127.tm_iocb2,
                         1);
#line 5088
  if ((unsigned long )sess != (unsigned long )((struct qla_tgt_sess *)0)) {
#line 5089
    (*((ha->tgt.tgt_ops)->put_sess))(sess);
  } else {

  }
#line 5090
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 5091
  return;
}
}
#line 5093 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_sess_work_fn(struct work_struct *work ) 
{ 
  struct qla_tgt *tgt ;
  struct work_struct  const  *__mptr ;
  struct scsi_qla_host *vha ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  struct qla_tgt_sess_work_param *prm ;
  struct list_head  const  *__mptr___0 ;
  long tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  int tmp___2 ;

  {
#line 5095
  __mptr = (struct work_struct  const  *)work;
#line 5095
  tgt = (struct qla_tgt *)__mptr + 0xfffffffffffffe78UL;
#line 5096
  vha = tgt->vha;
#line 5099
  ql_dbg(8192U, vha, 61440, "Sess work (tgt %p)", tgt);
#line 5101
  tmp = spinlock_check(& tgt->sess_work_lock);
#line 5101
  flags = _raw_spin_lock_irqsave(tmp);
#line 5102
  goto ldv_67464;
  ldv_67463: 
#line 5103
  __mptr___0 = (struct list_head  const  *)tgt->sess_works_list.next;
#line 5103
  prm = (struct qla_tgt_sess_work_param *)__mptr___0;
#line 5111
  list_del(& prm->sess_works_list_entry);
#line 5113
  spin_unlock_irqrestore(& tgt->sess_work_lock, flags);
#line 5115
  switch (prm->type) {
  case 1: 
#line 5117
  qlt_abort_work(tgt, prm);
#line 5118
  goto ldv_67456;
  case 2: 
#line 5120
  qlt_tmr_work(tgt, prm);
#line 5121
  goto ldv_67456;
  default: 
#line 5123
  tmp___0 = ldv__builtin_expect(1L, 0L);
#line 5123
  if (tmp___0 != 0L) {
#line 5123
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"),
                         "i" (5123), "i" (12UL));
    ldv_67459: ;
#line 5123
    goto ldv_67459;
  } else {

  }
#line 5124
  goto ldv_67456;
  }
  ldv_67456: 
#line 5127
  tmp___1 = spinlock_check(& tgt->sess_work_lock);
#line 5127
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 5129
  kfree((void const   *)prm);
  ldv_67464: 
#line 5102
  tmp___2 = list_empty((struct list_head  const  *)(& tgt->sess_works_list));
#line 5102
  if (tmp___2 == 0) {
#line 5104
    goto ldv_67463;
  } else {

  }
#line 5131
  spin_unlock_irqrestore(& tgt->sess_work_lock, flags);
#line 5132
  return;
}
}
#line 5135 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
int qlt_add_target(struct qla_hw_data *ha , struct scsi_qla_host *base_vha ) 
{ 
  struct qla_tgt *tgt ;
  long tmp ;
  void *tmp___0 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  struct lock_class_key __key___3 ;
  atomic_long_t __constr_expr_1 ;
  struct lock_class_key __key___4 ;
  struct lock_class_key __key___5 ;
  atomic_long_t __constr_expr_2 ;
  int _min1 ;
  int _min2 ;

  {
#line 5139
  if (ql2x_ini_mode == 2) {
#line 5140
    return (0);
  } else {

  }
#line 5142
  if ((unsigned int )ha->tgt.atio_q_length == 0U) {
#line 5143
    ql_log(1U, base_vha, 57456, "This adapter does not support target mode.\n");
#line 5145
    return (0);
  } else {

  }
#line 5148
  ql_dbg(16384U, base_vha, 57403, "Registering target for host %ld(%p).\n", base_vha->host_no,
         ha);
#line 5151
  tmp = ldv__builtin_expect((unsigned long )base_vha->vha_tgt.qla_tgt != (unsigned long )((struct qla_tgt *)0),
                         0L);
#line 5151
  if (tmp != 0L) {
#line 5151
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"),
                         "i" (5151), "i" (12UL));
    ldv_67471: ;
#line 5151
    goto ldv_67471;
  } else {

  }
#line 5153
  tmp___0 = kzalloc(856UL, 208U);
#line 5153
  tgt = (struct qla_tgt *)tmp___0;
#line 5154
  if ((unsigned long )tgt == (unsigned long )((struct qla_tgt *)0)) {
#line 5155
    ql_dbg(16384U, base_vha, 57446, "Unable to allocate struct qla_tgt\n");
#line 5157
    return (-12);
  } else {

  }
#line 5160
  if (((int )((base_vha->host)->hostt)->supported_mode & 2) == 0) {
#line 5161
    ((base_vha->host)->hostt)->supported_mode = (unsigned char )((unsigned int )((base_vha->host)->hostt)->supported_mode | 2U);
  } else {

  }
#line 5163
  tgt->ha = ha;
#line 5164
  tgt->vha = base_vha;
#line 5165
  __init_waitqueue_head(& tgt->waitQ, "&tgt->waitQ", & __key);
#line 5166
  INIT_LIST_HEAD(& tgt->sess_list);
#line 5167
  INIT_LIST_HEAD(& tgt->del_sess_list);
#line 5168
  __init_work(& tgt->sess_del_work.work, 0);
#line 5168
  __constr_expr_0.counter = 137438953408L;
#line 5168
  tgt->sess_del_work.work.data = __constr_expr_0;
#line 5168
  lockdep_init_map(& tgt->sess_del_work.work.lockdep_map, "(&(&tgt->sess_del_work)->work)",
                   & __key___0, 0);
#line 5168
  INIT_LIST_HEAD(& tgt->sess_del_work.work.entry);
#line 5168
  tgt->sess_del_work.work.func = (void (*)(struct work_struct * ))(& qlt_del_sess_work_fn);
#line 5168
  init_timer_key(& tgt->sess_del_work.timer, 2097152U, "(&(&tgt->sess_del_work)->timer)",
                 & __key___1);
#line 5168
  tgt->sess_del_work.timer.function = & delayed_work_timer_fn;
#line 5168
  tgt->sess_del_work.timer.data = (unsigned long )(& tgt->sess_del_work);
#line 5170
  spinlock_check(& tgt->sess_work_lock);
#line 5170
  __raw_spin_lock_init(& tgt->sess_work_lock.__annonCompField18.rlock, "&(&tgt->sess_work_lock)->rlock",
                       & __key___2);
#line 5171
  __init_work(& tgt->sess_work, 0);
#line 5171
  __constr_expr_1.counter = 137438953408L;
#line 5171
  tgt->sess_work.data = __constr_expr_1;
#line 5171
  lockdep_init_map(& tgt->sess_work.lockdep_map, "(&tgt->sess_work)", & __key___3,
                   0);
#line 5171
  INIT_LIST_HEAD(& tgt->sess_work.entry);
#line 5171
  tgt->sess_work.func = & qlt_sess_work_fn;
#line 5172
  INIT_LIST_HEAD(& tgt->sess_works_list);
#line 5173
  spinlock_check(& tgt->srr_lock);
#line 5173
  __raw_spin_lock_init(& tgt->srr_lock.__annonCompField18.rlock, "&(&tgt->srr_lock)->rlock",
                       & __key___4);
#line 5174
  INIT_LIST_HEAD(& tgt->srr_ctio_list);
#line 5175
  INIT_LIST_HEAD(& tgt->srr_imm_list);
#line 5176
  __init_work(& tgt->srr_work, 0);
#line 5176
  __constr_expr_2.counter = 137438953408L;
#line 5176
  tgt->srr_work.data = __constr_expr_2;
#line 5176
  lockdep_init_map(& tgt->srr_work.lockdep_map, "(&tgt->srr_work)", & __key___5, 0);
#line 5176
  INIT_LIST_HEAD(& tgt->srr_work.entry);
#line 5176
  tgt->srr_work.func = & qlt_handle_srr_work;
#line 5177
  atomic_set(& tgt->tgt_global_resets_count, 0);
#line 5179
  base_vha->vha_tgt.qla_tgt = tgt;
#line 5181
  ql_dbg(16384U, base_vha, 57447, "qla_target(%d): using 64 Bit PCI addressing", (int )base_vha->vp_idx);
#line 5184
  tgt->tgt_enable_64bit_addr = 1U;
#line 5186
  _min1 = 1270;
#line 5186
  _min2 = (int )(base_vha->req)->length + -3 > 0 ? (int )(base_vha->req)->length * 5 + -19 : 0;
#line 5186
  tgt->sg_tablesize = _min1 < _min2 ? _min1 : _min2;
#line 5187
  tgt->datasegs_per_cmd = 1;
#line 5188
  tgt->datasegs_per_cont = 5;
#line 5190
  if ((unsigned long )base_vha->fc_vport != (unsigned long )((struct fc_vport *)0)) {
#line 5191
    return (0);
  } else {

  }
#line 5193
  mutex_lock_nested(& qla_tgt_mutex, 0U);
#line 5194
  list_add_tail(& tgt->tgt_list_entry, & qla_tgt_glist);
#line 5195
  mutex_unlock(& qla_tgt_mutex);
#line 5197
  return (0);
}
}
#line 5201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
int qlt_remove_target(struct qla_hw_data *ha , struct scsi_qla_host *vha ) 
{ 


  {
#line 5203
  if ((unsigned long )vha->vha_tgt.qla_tgt == (unsigned long )((struct qla_tgt *)0)) {
#line 5204
    return (0);
  } else {

  }
#line 5206
  if ((unsigned long )vha->fc_vport != (unsigned long )((struct fc_vport *)0)) {
#line 5207
    qlt_release(vha->vha_tgt.qla_tgt);
#line 5208
    return (0);
  } else {

  }
#line 5212
  qlt_init_term_exchange(vha);
#line 5214
  mutex_lock_nested(& qla_tgt_mutex, 0U);
#line 5215
  list_del(& (vha->vha_tgt.qla_tgt)->tgt_list_entry);
#line 5216
  mutex_unlock(& qla_tgt_mutex);
#line 5218
  ql_dbg(16384U, vha, 57404, "Unregistering target for host %ld(%p)", vha->host_no,
         ha);
#line 5220
  qlt_release(vha->vha_tgt.qla_tgt);
#line 5222
  return (0);
}
}
#line 5225 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_lport_dump(struct scsi_qla_host *vha , u64 wwpn , unsigned char *b ) 
{ 
  int i ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;
  struct _ddebug descriptor___3 ;
  long tmp___3 ;
  struct _ddebug descriptor___4 ;
  long tmp___4 ;
  struct _ddebug descriptor___5 ;
  long tmp___5 ;
  struct _ddebug descriptor___6 ;
  long tmp___6 ;
  struct _ddebug descriptor___7 ;
  long tmp___7 ;

  {
#line 5230
  descriptor.modname = "qla2xxx";
#line 5230
  descriptor.function = "qlt_lport_dump";
#line 5230
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c";
#line 5230
  descriptor.format = "qla2xxx HW vha->node_name: ";
#line 5230
  descriptor.lineno = 5230U;
#line 5230
  descriptor.flags = 0U;
#line 5230
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 5230
  if (tmp != 0L) {
#line 5230
    __dynamic_pr_debug(& descriptor, "qla2xxx HW vha->node_name: ");
  } else {

  }
#line 5231
  i = 0;
#line 5231
  goto ldv_67500;
  ldv_67499: 
#line 5232
  descriptor___0.modname = "qla2xxx";
#line 5232
  descriptor___0.function = "qlt_lport_dump";
#line 5232
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c";
#line 5232
  descriptor___0.format = "%02x ";
#line 5232
  descriptor___0.lineno = 5232U;
#line 5232
  descriptor___0.flags = 0U;
#line 5232
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 5232
  if (tmp___0 != 0L) {
#line 5232
    __dynamic_pr_debug(& descriptor___0, "%02x ", (int )vha->node_name[i]);
  } else {

  }
#line 5231
  i = i + 1;
  ldv_67500: ;
#line 5231
  if (i <= 7) {
#line 5233
    goto ldv_67499;
  } else {

  }
#line 5233
  descriptor___1.modname = "qla2xxx";
#line 5233
  descriptor___1.function = "qlt_lport_dump";
#line 5233
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c";
#line 5233
  descriptor___1.format = "\n";
#line 5233
  descriptor___1.lineno = 5233U;
#line 5233
  descriptor___1.flags = 0U;
#line 5233
  tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 5233
  if (tmp___1 != 0L) {
#line 5233
    __dynamic_pr_debug(& descriptor___1, "\n");
  } else {

  }
#line 5234
  descriptor___2.modname = "qla2xxx";
#line 5234
  descriptor___2.function = "qlt_lport_dump";
#line 5234
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c";
#line 5234
  descriptor___2.format = "qla2xxx HW vha->port_name: ";
#line 5234
  descriptor___2.lineno = 5234U;
#line 5234
  descriptor___2.flags = 0U;
#line 5234
  tmp___2 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
#line 5234
  if (tmp___2 != 0L) {
#line 5234
    __dynamic_pr_debug(& descriptor___2, "qla2xxx HW vha->port_name: ");
  } else {

  }
#line 5235
  i = 0;
#line 5235
  goto ldv_67506;
  ldv_67505: 
#line 5236
  descriptor___3.modname = "qla2xxx";
#line 5236
  descriptor___3.function = "qlt_lport_dump";
#line 5236
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c";
#line 5236
  descriptor___3.format = "%02x ";
#line 5236
  descriptor___3.lineno = 5236U;
#line 5236
  descriptor___3.flags = 0U;
#line 5236
  tmp___3 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
#line 5236
  if (tmp___3 != 0L) {
#line 5236
    __dynamic_pr_debug(& descriptor___3, "%02x ", (int )vha->port_name[i]);
  } else {

  }
#line 5235
  i = i + 1;
  ldv_67506: ;
#line 5235
  if (i <= 7) {
#line 5237
    goto ldv_67505;
  } else {

  }
#line 5237
  descriptor___4.modname = "qla2xxx";
#line 5237
  descriptor___4.function = "qlt_lport_dump";
#line 5237
  descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c";
#line 5237
  descriptor___4.format = "\n";
#line 5237
  descriptor___4.lineno = 5237U;
#line 5237
  descriptor___4.flags = 0U;
#line 5237
  tmp___4 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
#line 5237
  if (tmp___4 != 0L) {
#line 5237
    __dynamic_pr_debug(& descriptor___4, "\n");
  } else {

  }
#line 5239
  descriptor___5.modname = "qla2xxx";
#line 5239
  descriptor___5.function = "qlt_lport_dump";
#line 5239
  descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c";
#line 5239
  descriptor___5.format = "qla2xxx passed configfs WWPN: ";
#line 5239
  descriptor___5.lineno = 5239U;
#line 5239
  descriptor___5.flags = 0U;
#line 5239
  tmp___5 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
#line 5239
  if (tmp___5 != 0L) {
#line 5239
    __dynamic_pr_debug(& descriptor___5, "qla2xxx passed configfs WWPN: ");
  } else {

  }
#line 5240
  put_unaligned_be64(wwpn, (void *)b);
#line 5241
  i = 0;
#line 5241
  goto ldv_67512;
  ldv_67511: 
#line 5242
  descriptor___6.modname = "qla2xxx";
#line 5242
  descriptor___6.function = "qlt_lport_dump";
#line 5242
  descriptor___6.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c";
#line 5242
  descriptor___6.format = "%02x ";
#line 5242
  descriptor___6.lineno = 5242U;
#line 5242
  descriptor___6.flags = 0U;
#line 5242
  tmp___6 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
#line 5242
  if (tmp___6 != 0L) {
#line 5242
    __dynamic_pr_debug(& descriptor___6, "%02x ", (int )*(b + (unsigned long )i));
  } else {

  }
#line 5241
  i = i + 1;
  ldv_67512: ;
#line 5241
  if (i <= 7) {
#line 5243
    goto ldv_67511;
  } else {

  }
#line 5243
  descriptor___7.modname = "qla2xxx";
#line 5243
  descriptor___7.function = "qlt_lport_dump";
#line 5243
  descriptor___7.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c";
#line 5243
  descriptor___7.format = "\n";
#line 5243
  descriptor___7.lineno = 5243U;
#line 5243
  descriptor___7.flags = 0U;
#line 5243
  tmp___7 = ldv__builtin_expect((long )descriptor___7.flags & 1L, 0L);
#line 5243
  if (tmp___7 != 0L) {
#line 5243
    __dynamic_pr_debug(& descriptor___7, "\n");
  } else {

  }
#line 5245
  return;
}
}
#line 5254 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
int qlt_lport_register(void *target_lport_ptr , u64 phys_wwpn , u64 npiv_wwpn , u64 npiv_wwnn ,
                       int (*callback)(struct scsi_qla_host * , void * , u64  , u64  ) ) 
{ 
  struct qla_tgt *tgt ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct Scsi_Host *host ;
  unsigned long flags ;
  int rc ;
  u8 b[8U] ;
  struct list_head  const  *__mptr ;
  raw_spinlock_t *tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  struct Scsi_Host *tmp___2 ;
  int tmp___3 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 5266
  mutex_lock_nested(& qla_tgt_mutex, 0U);
#line 5267
  __mptr = (struct list_head  const  *)qla_tgt_glist.next;
#line 5267
  tgt = (struct qla_tgt *)__mptr + 0xfffffffffffffcb8UL;
#line 5267
  goto ldv_67545;
  ldv_67544: 
#line 5268
  vha = tgt->vha;
#line 5269
  ha = vha->hw;
#line 5271
  host = vha->host;
#line 5272
  if ((unsigned long )host == (unsigned long )((struct Scsi_Host *)0)) {
#line 5273
    goto ldv_67537;
  } else {

  }
#line 5275
  if (((int )(host->hostt)->supported_mode & 2) == 0) {
#line 5276
    goto ldv_67537;
  } else {

  }
#line 5278
  tmp = spinlock_check(& ha->hardware_lock);
#line 5278
  flags = _raw_spin_lock_irqsave(tmp);
#line 5279
  if ((npiv_wwpn == 0ULL || npiv_wwnn == 0ULL) && ((int )host->active_mode & 2) != 0) {
#line 5280
    descriptor.modname = "qla2xxx";
#line 5280
    descriptor.function = "qlt_lport_register";
#line 5280
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c";
#line 5280
    descriptor.format = "MODE_TARGET already active on qla2xxx(%d)\n";
#line 5280
    descriptor.lineno = 5281U;
#line 5280
    descriptor.flags = 0U;
#line 5280
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 5280
    if (tmp___0 != 0L) {
#line 5280
      __dynamic_pr_debug(& descriptor, "MODE_TARGET already active on qla2xxx(%d)\n",
                         host->host_no);
    } else {

    }
#line 5282
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 5283
    goto ldv_67537;
  } else {

  }
#line 5285
  if (tgt->tgt_stop != 0) {
#line 5286
    descriptor___0.modname = "qla2xxx";
#line 5286
    descriptor___0.function = "qlt_lport_register";
#line 5286
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c";
#line 5286
    descriptor___0.format = "MODE_TARGET in shutdown on qla2xxx(%d)\n";
#line 5286
    descriptor___0.lineno = 5287U;
#line 5286
    descriptor___0.flags = 0U;
#line 5286
    tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 5286
    if (tmp___1 != 0L) {
#line 5286
      __dynamic_pr_debug(& descriptor___0, "MODE_TARGET in shutdown on qla2xxx(%d)\n",
                         host->host_no);
    } else {

    }
#line 5288
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 5289
    goto ldv_67537;
  } else {

  }
#line 5291
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 5293
  tmp___2 = scsi_host_get(host);
#line 5293
  if ((unsigned long )tmp___2 == (unsigned long )((struct Scsi_Host *)0)) {
#line 5294
    ql_dbg(16384U, vha, 57448, "Unable to scsi_host_get() for qla2xxx scsi_host\n");
#line 5297
    goto ldv_67537;
  } else {

  }
#line 5299
  qlt_lport_dump(vha, phys_wwpn, (unsigned char *)(& b));
#line 5301
  tmp___3 = memcmp((void const   *)(& vha->port_name), (void const   *)(& b), 8UL);
#line 5301
  if (tmp___3 != 0) {
#line 5302
    scsi_host_put(host);
#line 5303
    goto ldv_67537;
  } else {

  }
#line 5305
  rc = (*callback)(vha, target_lport_ptr, npiv_wwpn, npiv_wwnn);
#line 5306
  if (rc != 0) {
#line 5307
    scsi_host_put(host);
  } else {

  }
#line 5309
  mutex_unlock(& qla_tgt_mutex);
#line 5310
  return (rc);
  ldv_67537: 
#line 5267
  __mptr___0 = (struct list_head  const  *)tgt->tgt_list_entry.next;
#line 5267
  tgt = (struct qla_tgt *)__mptr___0 + 0xfffffffffffffcb8UL;
  ldv_67545: ;
#line 5267
  if ((unsigned long )(& tgt->tgt_list_entry) != (unsigned long )(& qla_tgt_glist)) {
#line 5269
    goto ldv_67544;
  } else {

  }
#line 5312
  mutex_unlock(& qla_tgt_mutex);
#line 5314
  return (-19);
}
}
#line 5316 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static char const   __kstrtab_qlt_lport_register[19U]  = 
#line 5316
  {      'q',      'l',      't',      '_', 
        'l',      'p',      'o',      'r', 
        't',      '_',      'r',      'e', 
        'g',      'i',      's',      't', 
        'e',      'r',      '\000'};
#line 5316
struct kernel_symbol  const  __ksymtab_qlt_lport_register ;
#line 5316 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
struct kernel_symbol  const  __ksymtab_qlt_lport_register  =    {(unsigned long )(& qlt_lport_register), (char const   *)(& __kstrtab_qlt_lport_register)};
#line 5323 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_lport_deregister(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct Scsi_Host *sh ;

  {
#line 5325
  ha = vha->hw;
#line 5326
  sh = vha->host;
#line 5330
  vha->vha_tgt.target_lport_ptr = (void *)0;
#line 5331
  ha->tgt.tgt_ops = (struct qla_tgt_func_tmpl *)0;
#line 5335
  scsi_host_put(sh);
#line 5336
  return;
}
}
#line 5337 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static char const   __kstrtab_qlt_lport_deregister[21U]  = 
#line 5337
  {      'q',      'l',      't',      '_', 
        'l',      'p',      'o',      'r', 
        't',      '_',      'd',      'e', 
        'r',      'e',      'g',      'i', 
        's',      't',      'e',      'r', 
        '\000'};
#line 5337
struct kernel_symbol  const  __ksymtab_qlt_lport_deregister ;
#line 5337 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
struct kernel_symbol  const  __ksymtab_qlt_lport_deregister  =    {(unsigned long )(& qlt_lport_deregister), (char const   *)(& __kstrtab_qlt_lport_deregister)};
#line 5340 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_set_mode(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 5342
  ha = vha->hw;
#line 5344
  switch (ql2x_ini_mode) {
  case 1: ;
  case 0: 
#line 5347
  (vha->host)->active_mode = 2U;
#line 5348
  goto ldv_67576;
  case 2: 
#line 5350
  (vha->host)->active_mode = (unsigned char )((unsigned int )(vha->host)->active_mode | 2U);
#line 5351
  goto ldv_67576;
  default: ;
#line 5353
  goto ldv_67576;
  }
  ldv_67576: ;
#line 5356
  if ((unsigned int )*((unsigned char *)ha + 3808UL) != 0U) {
#line 5357
    qla_reverse_ini_mode(vha);
  } else {

  }
#line 5358
  return;
}
}
#line 5361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_clear_mode(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 5363
  ha = vha->hw;
#line 5365
  switch (ql2x_ini_mode) {
  case 1: 
#line 5367
  (vha->host)->active_mode = 0U;
#line 5368
  goto ldv_67584;
  case 0: 
#line 5370
  (vha->host)->active_mode = 1U;
#line 5371
  goto ldv_67584;
  case 2: 
#line 5373
  (vha->host)->active_mode = (unsigned int )(vha->host)->active_mode & 1U;
#line 5374
  goto ldv_67584;
  default: ;
#line 5376
  goto ldv_67584;
  }
  ldv_67584: ;
#line 5379
  if ((unsigned int )*((unsigned char *)ha + 3808UL) != 0U) {
#line 5380
    qla_reverse_ini_mode(vha);
  } else {

  }
#line 5381
  return;
}
}
#line 5389 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_enable_vha(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt *tgt ;
  unsigned long flags ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 5391
  ha = vha->hw;
#line 5392
  tgt = vha->vha_tgt.qla_tgt;
#line 5394
  tmp = pci_get_drvdata(ha->pdev);
#line 5394
  base_vha = (scsi_qla_host_t *)tmp;
#line 5396
  if ((unsigned long )tgt == (unsigned long )((struct qla_tgt *)0)) {
#line 5397
    ql_dbg(16384U, vha, 57449, "Unable to locate qla_tgt pointer from struct qla_hw_data\n");
#line 5400
    dump_stack();
#line 5401
    return;
  } else {

  }
#line 5404
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 5404
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 5405
  tgt->tgt_stopped = 0;
#line 5406
  qlt_set_mode(vha);
#line 5407
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 5409
  if ((unsigned int )vha->vp_idx != 0U) {
#line 5410
    qla24xx_disable_vp(vha);
#line 5411
    qla24xx_enable_vp(vha);
  } else {
#line 5413
    set_bit(2L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5414
    qla2xxx_wake_dpc(base_vha);
#line 5415
    qla2x00_wait_for_hba_online(base_vha);
  }
#line 5417
  return;
}
}
#line 5418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static char const   __kstrtab_qlt_enable_vha[15U]  = 
#line 5418
  {      'q',      'l',      't',      '_', 
        'e',      'n',      'a',      'b', 
        'l',      'e',      '_',      'v', 
        'h',      'a',      '\000'};
#line 5418
struct kernel_symbol  const  __ksymtab_qlt_enable_vha ;
#line 5418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
struct kernel_symbol  const  __ksymtab_qlt_enable_vha  =    {(unsigned long )(& qlt_enable_vha), (char const   *)(& __kstrtab_qlt_enable_vha)};
#line 5425 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static void qlt_disable_vha(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt *tgt ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 5427
  ha = vha->hw;
#line 5428
  tgt = vha->vha_tgt.qla_tgt;
#line 5431
  if ((unsigned long )tgt == (unsigned long )((struct qla_tgt *)0)) {
#line 5432
    ql_dbg(16384U, vha, 57450, "Unable to locate qla_tgt pointer from struct qla_hw_data\n");
#line 5435
    dump_stack();
#line 5436
    return;
  } else {

  }
#line 5439
  tmp = spinlock_check(& ha->hardware_lock);
#line 5439
  flags = _raw_spin_lock_irqsave(tmp);
#line 5440
  qlt_clear_mode(vha);
#line 5441
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 5443
  set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 5444
  qla2xxx_wake_dpc(vha);
#line 5445
  qla2x00_wait_for_hba_online(vha);
#line 5446
  return;
}
}
#line 5454 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_vport_create(struct scsi_qla_host *vha , struct qla_hw_data *ha ) 
{ 
  bool tmp ;
  int tmp___0 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;

  {
#line 5456
  tmp = qla_tgt_mode_enabled(vha);
#line 5456
  if (tmp) {
#line 5456
    tmp___0 = 0;
  } else {
#line 5456
    tmp___0 = 1;
  }
#line 5456
  if (tmp___0) {
#line 5457
    return;
  } else {

  }
#line 5459
  vha->vha_tgt.qla_tgt = (struct qla_tgt *)0;
#line 5461
  __mutex_init(& vha->vha_tgt.tgt_mutex, "&vha->vha_tgt.tgt_mutex", & __key);
#line 5462
  __mutex_init(& vha->vha_tgt.tgt_host_action_mutex, "&vha->vha_tgt.tgt_host_action_mutex",
               & __key___0);
#line 5464
  qlt_clear_mode(vha);
#line 5472
  ha->tgt.atio_q_length = 4096U;
#line 5474
  qlt_add_target(ha, vha);
#line 5475
  return;
}
}
#line 5478 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_rff_id(struct scsi_qla_host *vha , struct ct_sns_req *ct_req ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 5483
  tmp___1 = qla_tgt_mode_enabled(vha);
#line 5483
  if ((int )tmp___1) {
#line 5484
    tmp = qla_ini_mode_enabled(vha);
#line 5484
    if ((int )tmp) {
#line 5485
      ct_req->req.rff_id.fc4_feature = 3U;
    } else {
#line 5487
      ct_req->req.rff_id.fc4_feature = 1U;
    }
  } else {
#line 5488
    tmp___0 = qla_ini_mode_enabled(vha);
#line 5488
    if ((int )tmp___0) {
#line 5489
      ct_req->req.rff_id.fc4_feature = 2U;
    } else {

    }
  }
#line 5490
  return;
}
}
#line 5503 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_init_atio_q_entries(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  uint16_t cnt ;
  struct atio_from_isp *pkt ;
  bool tmp ;
  int tmp___0 ;

  {
#line 5505
  ha = vha->hw;
#line 5507
  pkt = (struct atio_from_isp *)ha->tgt.atio_ring;
#line 5509
  tmp = qla_tgt_mode_enabled(vha);
#line 5509
  if (tmp) {
#line 5509
    tmp___0 = 0;
  } else {
#line 5509
    tmp___0 = 1;
  }
#line 5509
  if (tmp___0) {
#line 5510
    return;
  } else {

  }
#line 5512
  cnt = 0U;
#line 5512
  goto ldv_67631;
  ldv_67630: 
#line 5513
  pkt->u.raw.signature = 3735936685U;
#line 5514
  pkt = pkt + 1;
#line 5512
  cnt = (uint16_t )((int )cnt + 1);
  ldv_67631: ;
#line 5512
  if ((int )ha->tgt.atio_q_length > (int )cnt) {
#line 5514
    goto ldv_67630;
  } else {

  }

#line 5519
  return;
}
}
#line 5524 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_24xx_process_atio_queue(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct atio_from_isp *pkt ;
  int cnt ;
  int i ;

  {
#line 5526
  ha = vha->hw;
#line 5530
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 5531
    return;
  } else {

  }
#line 5533
  goto ldv_67644;
  ldv_67643: 
#line 5534
  pkt = (struct atio_from_isp *)ha->tgt.atio_ring_ptr;
#line 5535
  cnt = (int )pkt->u.raw.entry_count;
#line 5537
  qlt_24xx_atio_pkt_all_vps(vha, pkt);
#line 5539
  i = 0;
#line 5539
  goto ldv_67641;
  ldv_67640: 
#line 5540
  ha->tgt.atio_ring_index = (uint16_t )((int )ha->tgt.atio_ring_index + 1);
#line 5541
  if ((int )ha->tgt.atio_ring_index == (int )ha->tgt.atio_q_length) {
#line 5542
    ha->tgt.atio_ring_index = 0U;
#line 5543
    ha->tgt.atio_ring_ptr = ha->tgt.atio_ring;
  } else {
#line 5545
    ha->tgt.atio_ring_ptr = ha->tgt.atio_ring_ptr + 1;
  }
#line 5547
  pkt->u.raw.signature = 3735936685U;
#line 5548
  pkt = (struct atio_from_isp *)ha->tgt.atio_ring_ptr;
#line 5539
  i = i + 1;
  ldv_67641: ;
#line 5539
  if (i < cnt) {
#line 5541
    goto ldv_67640;
  } else {

  }
#line 5550
  __asm__  volatile   ("sfence": : : "memory");
  ldv_67644: ;
#line 5533
  if ((ha->tgt.atio_ring_ptr)->signature != 3735936685U) {
#line 5535
    goto ldv_67643;
  } else {

  }
#line 5554
  writel((unsigned int )ha->tgt.atio_ring_index, (void volatile   *)(vha->hw)->tgt.atio_q_out);
#line 5555
  return;
}
}
#line 5558 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_24xx_config_rings(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_msix_entry *msix ;
  struct init_cb_24xx *icb ;

  {
#line 5560
  ha = vha->hw;
#line 5561
  if (ql2x_ini_mode == 2) {
#line 5562
    return;
  } else {

  }
#line 5564
  writel(0U, (void volatile   *)(vha->hw)->tgt.atio_q_in);
#line 5565
  writel(0U, (void volatile   *)(vha->hw)->tgt.atio_q_out);
#line 5566
  readl((void const volatile   *)(vha->hw)->tgt.atio_q_out);
#line 5568
  if ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 5569
    msix = ha->msix_entries + 2UL;
#line 5570
    icb = (struct init_cb_24xx *)ha->init_cb;
#line 5572
    icb->msix_atio = msix->entry;
#line 5573
    ql_dbg(1073741824U, vha, 61554, "Registering ICB vector 0x%x for atio que.\n",
           (int )msix->entry);
  } else {

  }
#line 5577
  return;
}
}
#line 5580 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_24xx_config_nvram_stage1(struct scsi_qla_host *vha , struct nvram_24xx *nv ) 
{ 
  struct qla_hw_data *ha ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 5582
  ha = vha->hw;
#line 5584
  tmp___1 = qla_tgt_mode_enabled(vha);
#line 5584
  if ((int )tmp___1) {
#line 5585
    if (ha->tgt.saved_set == 0) {
#line 5587
      ha->tgt.saved_exchange_count = nv->exchange_count;
#line 5588
      ha->tgt.saved_firmware_options_1 = nv->firmware_options_1;
#line 5590
      ha->tgt.saved_firmware_options_2 = nv->firmware_options_2;
#line 5592
      ha->tgt.saved_firmware_options_3 = nv->firmware_options_3;
#line 5594
      ha->tgt.saved_set = 1;
    } else {

    }
#line 5597
    nv->exchange_count = 65535U;
#line 5600
    nv->firmware_options_1 = nv->firmware_options_1 | 16U;
#line 5603
    tmp = qla_ini_mode_enabled(vha);
#line 5603
    if (tmp) {
#line 5603
      tmp___0 = 0;
    } else {
#line 5603
      tmp___0 = 1;
    }
#line 5603
    if (tmp___0) {
#line 5604
      nv->firmware_options_1 = nv->firmware_options_1 | 32U;
    } else {

    }
#line 5607
    nv->firmware_options_1 = nv->firmware_options_1 & 4294959103U;
#line 5609
    nv->firmware_options_1 = nv->firmware_options_1 & 4294966783U;
#line 5610
    if (ql2xtgt_tape_enable != 0) {
#line 5612
      nv->firmware_options_2 = nv->firmware_options_2 | 4096U;
    } else {
#line 5615
      nv->firmware_options_2 = nv->firmware_options_2 & 4294963199U;
    }
#line 5618
    nv->host_p = nv->host_p & 4294966271U;
#line 5620
    nv->firmware_options_2 = nv->firmware_options_2 | 16384U;
  } else {
#line 5622
    if (ha->tgt.saved_set != 0) {
#line 5623
      nv->exchange_count = ha->tgt.saved_exchange_count;
#line 5624
      nv->firmware_options_1 = ha->tgt.saved_firmware_options_1;
#line 5626
      nv->firmware_options_2 = ha->tgt.saved_firmware_options_2;
#line 5628
      nv->firmware_options_3 = ha->tgt.saved_firmware_options_3;
    } else {

    }
#line 5631
    return;
  }
#line 5635
  nv->firmware_options_3 = nv->firmware_options_3 | 576U;
#line 5637
  if ((unsigned int )*((unsigned char *)ha + 3808UL) != 0U) {
#line 5638
    if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 5639
      ((struct fc_host_attrs *)(vha->host)->shost_data)->supported_classes = 12U;
    } else {

    }
#line 5642
    nv->firmware_options_2 = nv->firmware_options_2 | 256U;
  } else {
#line 5644
    if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 5645
      ((struct fc_host_attrs *)(vha->host)->shost_data)->supported_classes = 8U;
    } else {

    }
#line 5647
    nv->firmware_options_2 = nv->firmware_options_2 & 4294967039U;
  }
#line 5649
  return;
}
}
#line 5652 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_24xx_config_nvram_stage2(struct scsi_qla_host *vha , struct init_cb_24xx *icb ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 5655
  ha = vha->hw;
#line 5657
  if ((unsigned int )*((unsigned char *)ha + 3808UL) != 0U) {
#line 5658
    memcpy((void *)(& icb->node_name), (void const   *)(& ha->tgt.tgt_node_name),
             8UL);
#line 5659
    icb->firmware_options_1 = icb->firmware_options_1 | 16384U;
  } else {

  }
#line 5661
  return;
}
}
#line 5664 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_81xx_config_nvram_stage1(struct scsi_qla_host *vha , struct nvram_81xx *nv ) 
{ 
  struct qla_hw_data *ha ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 5666
  ha = vha->hw;
#line 5668
  if (ql2x_ini_mode == 2) {
#line 5669
    return;
  } else {

  }
#line 5671
  tmp___1 = qla_tgt_mode_enabled(vha);
#line 5671
  if ((int )tmp___1) {
#line 5672
    if (ha->tgt.saved_set == 0) {
#line 5674
      ha->tgt.saved_exchange_count = nv->exchange_count;
#line 5675
      ha->tgt.saved_firmware_options_1 = nv->firmware_options_1;
#line 5677
      ha->tgt.saved_firmware_options_2 = nv->firmware_options_2;
#line 5679
      ha->tgt.saved_firmware_options_3 = nv->firmware_options_3;
#line 5681
      ha->tgt.saved_set = 1;
    } else {

    }
#line 5684
    nv->exchange_count = 65535U;
#line 5687
    nv->firmware_options_1 = nv->firmware_options_1 | 16U;
#line 5690
    tmp = qla_ini_mode_enabled(vha);
#line 5690
    if (tmp) {
#line 5690
      tmp___0 = 0;
    } else {
#line 5690
      tmp___0 = 1;
    }
#line 5690
    if (tmp___0) {
#line 5691
      nv->firmware_options_1 = nv->firmware_options_1 | 32U;
    } else {

    }
#line 5695
    nv->firmware_options_1 = nv->firmware_options_1 & 4294959103U;
#line 5697
    nv->firmware_options_1 = nv->firmware_options_1 & 4294966783U;
#line 5698
    if (ql2xtgt_tape_enable != 0) {
#line 5700
      nv->firmware_options_2 = nv->firmware_options_2 | 4096U;
    } else {
#line 5703
      nv->firmware_options_2 = nv->firmware_options_2 & 4294963199U;
    }
#line 5706
    nv->host_p = nv->host_p & 4294966271U;
#line 5708
    nv->firmware_options_2 = nv->firmware_options_2 | 16384U;
  } else {
#line 5710
    if (ha->tgt.saved_set != 0) {
#line 5711
      nv->exchange_count = ha->tgt.saved_exchange_count;
#line 5712
      nv->firmware_options_1 = ha->tgt.saved_firmware_options_1;
#line 5714
      nv->firmware_options_2 = ha->tgt.saved_firmware_options_2;
#line 5716
      nv->firmware_options_3 = ha->tgt.saved_firmware_options_3;
    } else {

    }
#line 5719
    return;
  }
#line 5723
  nv->firmware_options_3 = nv->firmware_options_3 | 576U;
#line 5725
  if ((unsigned int )*((unsigned char *)ha + 3808UL) != 0U) {
#line 5726
    if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 5727
      ((struct fc_host_attrs *)(vha->host)->shost_data)->supported_classes = 12U;
    } else {

    }
#line 5730
    nv->firmware_options_2 = nv->firmware_options_2 | 256U;
  } else {
#line 5732
    if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 5733
      ((struct fc_host_attrs *)(vha->host)->shost_data)->supported_classes = 8U;
    } else {

    }
#line 5735
    nv->firmware_options_2 = nv->firmware_options_2 & 4294967039U;
  }
#line 5737
  return;
}
}
#line 5740 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_81xx_config_nvram_stage2(struct scsi_qla_host *vha , struct init_cb_81xx *icb ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 5743
  ha = vha->hw;
#line 5745
  if (ql2x_ini_mode == 2) {
#line 5746
    return;
  } else {

  }
#line 5748
  if ((unsigned int )*((unsigned char *)ha + 3808UL) != 0U) {
#line 5749
    memcpy((void *)(& icb->node_name), (void const   *)(& ha->tgt.tgt_node_name),
             8UL);
#line 5750
    icb->firmware_options_1 = icb->firmware_options_1 | 16384U;
  } else {

  }
#line 5752
  return;
}
}
#line 5755 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_83xx_iospace_config(struct qla_hw_data *ha ) 
{ 


  {
#line 5757
  if (ql2x_ini_mode == 2) {
#line 5758
    return;
  } else {

  }
#line 5760
  ha->msix_count = (unsigned int )ha->msix_count + 1U;
#line 5761
  return;
}
}
#line 5764 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
int qlt_24xx_process_response_error(struct scsi_qla_host *vha , struct sts_entry_24xx *pkt ) 
{ 


  {
#line 5767
  switch ((int )pkt->entry_type) {
  case 84: ;
  case 85: ;
  case 18: ;
  case 14: ;
  case 122: ;
#line 5773
  return (1);
  default: ;
#line 5775
  return (0);
  }
}
}
#line 5780 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_modify_vp_config(struct scsi_qla_host *vha , struct vp_config_entry_24xx *vpmod ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 5783
  tmp = qla_tgt_mode_enabled(vha);
#line 5783
  if ((int )tmp) {
#line 5784
    vpmod->options_idx1 = (unsigned int )vpmod->options_idx1 & 223U;
  } else {

  }
#line 5786
  tmp___0 = qla_ini_mode_enabled(vha);
#line 5786
  if (tmp___0) {
#line 5786
    tmp___1 = 0;
  } else {
#line 5786
    tmp___1 = 1;
  }
#line 5786
  if (tmp___1) {
#line 5787
    vpmod->options_idx1 = (unsigned int )vpmod->options_idx1 & 239U;
  } else {

  }
#line 5788
  return;
}
}
#line 5791 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_probe_one_stage1(struct scsi_qla_host *base_vha , struct qla_hw_data *ha ) 
{ 
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;

  {
#line 5793
  if (ql2x_ini_mode == 2) {
#line 5794
    return;
  } else {

  }
#line 5796
  if ((unsigned int )ha->mqenable != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) {
#line 5797
    (base_vha->hw)->tgt.atio_q_in = & (ha->mqiobase)->isp25mq.atio_q_in;
#line 5798
    (base_vha->hw)->tgt.atio_q_out = & (ha->mqiobase)->isp25mq.atio_q_out;
  } else {
#line 5800
    (base_vha->hw)->tgt.atio_q_in = & (ha->iobase)->isp24.atio_q_in;
#line 5801
    (base_vha->hw)->tgt.atio_q_out = & (ha->iobase)->isp24.atio_q_out;
  }
#line 5804
  __mutex_init(& base_vha->vha_tgt.tgt_mutex, "&base_vha->vha_tgt.tgt_mutex", & __key);
#line 5805
  __mutex_init(& base_vha->vha_tgt.tgt_host_action_mutex, "&base_vha->vha_tgt.tgt_host_action_mutex",
               & __key___0);
#line 5806
  qlt_clear_mode(base_vha);
#line 5807
  return;
}
}
#line 5810 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
irqreturn_t qla83xx_msix_atio_q(int irq , void *dev_id ) 
{ 
  struct rsp_que *rsp ;
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  unsigned long flags ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 5817
  rsp = (struct rsp_que *)dev_id;
#line 5818
  ha = rsp->hw;
#line 5819
  tmp = pci_get_drvdata(ha->pdev);
#line 5819
  vha = (scsi_qla_host_t *)tmp;
#line 5821
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 5821
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 5823
  qlt_24xx_process_atio_queue(vha);
#line 5824
  qla24xx_process_response_queue(vha, rsp);
#line 5826
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 5828
  return (1);
}
}
#line 5832 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
int qlt_mem_alloc(struct qla_hw_data *ha ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 5834
  if (ql2x_ini_mode == 2) {
#line 5835
    return (0);
  } else {

  }
#line 5837
  tmp = kzalloc(4096UL, 208U);
#line 5837
  ha->tgt.tgt_vp_map = (struct qla_tgt_vp_map *)tmp;
#line 5839
  if ((unsigned long )ha->tgt.tgt_vp_map == (unsigned long )((struct qla_tgt_vp_map *)0)) {
#line 5840
    return (-12);
  } else {

  }
#line 5842
  tmp___0 = dma_alloc_attrs(& (ha->pdev)->dev, (unsigned long )((int )ha->tgt.atio_q_length + 1) * 64UL,
                            & ha->tgt.atio_dma, 208U, (struct dma_attrs *)0);
#line 5842
  ha->tgt.atio_ring = (struct atio *)tmp___0;
#line 5845
  if ((unsigned long )ha->tgt.atio_ring == (unsigned long )((struct atio *)0)) {
#line 5846
    kfree((void const   *)ha->tgt.tgt_vp_map);
#line 5847
    return (-12);
  } else {

  }
#line 5849
  return (0);
}
}
#line 5853 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_mem_free(struct qla_hw_data *ha ) 
{ 


  {
#line 5855
  if (ql2x_ini_mode == 2) {
#line 5856
    return;
  } else {

  }
#line 5858
  if ((unsigned long )ha->tgt.atio_ring != (unsigned long )((struct atio *)0)) {
#line 5859
    dma_free_attrs(& (ha->pdev)->dev, (unsigned long )((int )ha->tgt.atio_q_length + 1) * 64UL,
                   (void *)ha->tgt.atio_ring, ha->tgt.atio_dma, (struct dma_attrs *)0);
  } else {

  }
#line 5863
  kfree((void const   *)ha->tgt.tgt_vp_map);
#line 5864
  return;
}
}
#line 5868 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_update_vp_map(struct scsi_qla_host *vha , int cmd ) 
{ 


  {
#line 5870
  if (ql2x_ini_mode == 2) {
#line 5871
    return;
  } else {

  }
#line 5873
  switch (cmd) {
  case 1: 
#line 5875
  ((vha->hw)->tgt.tgt_vp_map + (unsigned long )vha->vp_idx)->vha = vha;
#line 5876
  goto ldv_67717;
  case 2: 
#line 5878
  ((vha->hw)->tgt.tgt_vp_map + (unsigned long )vha->d_id.b.al_pa)->idx = (uint8_t )vha->vp_idx;
#line 5879
  goto ldv_67717;
  case 3: 
#line 5881
  ((vha->hw)->tgt.tgt_vp_map + (unsigned long )vha->vp_idx)->vha = (scsi_qla_host_t *)0;
#line 5882
  goto ldv_67717;
  case 4: 
#line 5884
  ((vha->hw)->tgt.tgt_vp_map + (unsigned long )vha->d_id.b.al_pa)->idx = 0U;
#line 5885
  goto ldv_67717;
  }
  ldv_67717: ;
#line 5888
  return;
}
}
#line 5889 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
static int qlt_parse_ini_mode(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 5891
  tmp___1 = strcasecmp((char const   *)qlini_mode, "exclusive");
#line 5891
  if (tmp___1 == 0) {
#line 5892
    ql2x_ini_mode = 0;
  } else {
#line 5893
    tmp___0 = strcasecmp((char const   *)qlini_mode, "disabled");
#line 5893
    if (tmp___0 == 0) {
#line 5894
      ql2x_ini_mode = 1;
    } else {
#line 5895
      tmp = strcasecmp((char const   *)qlini_mode, "enabled");
#line 5895
      if (tmp == 0) {
#line 5896
        ql2x_ini_mode = 2;
      } else {
#line 5898
        return (0);
      }
    }
  }
#line 5900
  return (1);
}
}
#line 5903 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
int qlt_init(void) 
{ 
  int ret ;
  int tmp ;
  struct lock_class_key __key ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp___0 ;

  {
#line 5907
  tmp = qlt_parse_ini_mode();
#line 5907
  if (tmp == 0) {
#line 5908
    ql_log(0U, (scsi_qla_host_t *)0, 57451, "qlt_parse_ini_mode() failed\n");
#line 5910
    return (-22);
  } else {

  }
#line 5913
  if (ql2x_ini_mode == 2) {
#line 5914
    return (0);
  } else {

  }
#line 5916
  qla_tgt_mgmt_cmd_cachep = kmem_cache_create("qla_tgt_mgmt_cmd_cachep", 1000UL, 8UL,
                                              0UL, (void (*)(void * ))0);
#line 5919
  if ((unsigned long )qla_tgt_mgmt_cmd_cachep == (unsigned long )((struct kmem_cache *)0)) {
#line 5920
    ql_log(0U, (scsi_qla_host_t *)0, 57453, "kmem_cache_create for qla_tgt_mgmt_cmd_cachep failed\n");
#line 5922
    return (-12);
  } else {

  }
#line 5925
  qla_tgt_mgmt_cmd_mempool = mempool_create(25, & mempool_alloc_slab, & mempool_free_slab,
                                            (void *)qla_tgt_mgmt_cmd_cachep);
#line 5927
  if ((unsigned long )qla_tgt_mgmt_cmd_mempool == (unsigned long )((mempool_t *)0)) {
#line 5928
    ql_log(0U, (scsi_qla_host_t *)0, 57454, "mempool_create for qla_tgt_mgmt_cmd_mempool failed\n");
#line 5930
    ret = -12;
#line 5931
    goto out_mgmt_cmd_cachep;
  } else {

  }
#line 5934
  __lock_name = "\"qla_tgt_wq\"";
#line 5934
  tmp___0 = __alloc_workqueue_key("qla_tgt_wq", 0U, 0, & __key, __lock_name);
#line 5934
  qla_tgt_wq = tmp___0;
#line 5935
  if ((unsigned long )qla_tgt_wq == (unsigned long )((struct workqueue_struct *)0)) {
#line 5936
    ql_log(0U, (scsi_qla_host_t *)0, 57455, "alloc_workqueue for qla_tgt_wq failed\n");
#line 5938
    ret = -12;
#line 5939
    goto out_cmd_mempool;
  } else {

  }
#line 5944
  return (ql2x_ini_mode == 1);
  out_cmd_mempool: 
#line 5947
  mempool_destroy(qla_tgt_mgmt_cmd_mempool);
  out_mgmt_cmd_cachep: 
#line 5949
  kmem_cache_destroy(qla_tgt_mgmt_cmd_cachep);
#line 5950
  return (ret);
}
}
#line 5953 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.c"
void qlt_exit(void) 
{ 


  {
#line 5955
  if (ql2x_ini_mode == 2) {
#line 5956
    return;
  } else {

  }
#line 5958
  ldv_destroy_workqueue_302(qla_tgt_wq);
#line 5959
  mempool_destroy(qla_tgt_mgmt_cmd_mempool);
#line 5960
  kmem_cache_destroy(qla_tgt_mgmt_cmd_cachep);
#line 5961
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void call_and_disable_work_10(struct work_struct *work ) 
{ 


  {
#line 491
  if ((ldv_work_10_0 == 2 || ldv_work_10_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_10_0) {
#line 493
    ldv__builtin_trap();
#line 494
    ldv_work_10_0 = 1;
#line 495
    return;
  } else {

  }
#line 497
  if ((ldv_work_10_1 == 2 || ldv_work_10_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_10_1) {
#line 499
    ldv__builtin_trap();
#line 500
    ldv_work_10_1 = 1;
#line 501
    return;
  } else {

  }
#line 503
  if ((ldv_work_10_2 == 2 || ldv_work_10_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_10_2) {
#line 505
    ldv__builtin_trap();
#line 506
    ldv_work_10_2 = 1;
#line 507
    return;
  } else {

  }
#line 509
  if ((ldv_work_10_3 == 2 || ldv_work_10_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_10_3) {
#line 511
    ldv__builtin_trap();
#line 512
    ldv_work_10_3 = 1;
#line 513
    return;
  } else {

  }
#line 515
  return;
}
}
#line 518 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void work_init_9(void) 
{ 


  {
#line 519
  ldv_work_9_0 = 0;
#line 520
  ldv_work_9_1 = 0;
#line 521
  ldv_work_9_2 = 0;
#line 522
  ldv_work_9_3 = 0;
#line 523
  return;
}
}
#line 526 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void invoke_work_8(void) 
{ 
  int tmp ;

  {
#line 528
  tmp = __VERIFIER_nondet_int();
#line 528
  switch (tmp) {
  case 0: ;
#line 530
  if (ldv_work_8_0 == 2 || ldv_work_8_0 == 3) {
#line 531
    ldv_work_8_0 = 4;
#line 532
    qlt_create_sess_from_atio(ldv_work_struct_8_0);
#line 533
    ldv_work_8_0 = 1;
  } else {

  }
#line 536
  goto ldv_67754;
  case 1: ;
#line 538
  if (ldv_work_8_1 == 2 || ldv_work_8_1 == 3) {
#line 539
    ldv_work_8_1 = 4;
#line 540
    qlt_create_sess_from_atio(ldv_work_struct_8_0);
#line 541
    ldv_work_8_1 = 1;
  } else {

  }
#line 544
  goto ldv_67754;
  case 2: ;
#line 546
  if (ldv_work_8_2 == 2 || ldv_work_8_2 == 3) {
#line 547
    ldv_work_8_2 = 4;
#line 548
    qlt_create_sess_from_atio(ldv_work_struct_8_0);
#line 549
    ldv_work_8_2 = 1;
  } else {

  }
#line 552
  goto ldv_67754;
  case 3: ;
#line 554
  if (ldv_work_8_3 == 2 || ldv_work_8_3 == 3) {
#line 555
    ldv_work_8_3 = 4;
#line 556
    qlt_create_sess_from_atio(ldv_work_struct_8_0);
#line 557
    ldv_work_8_3 = 1;
  } else {

  }
#line 560
  goto ldv_67754;
  default: 
#line 561
  ldv_stop();
  }
  ldv_67754: ;
#line 563
  return;
}
}
#line 567 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void disable_work_7(struct work_struct *work ) 
{ 


  {
#line 569
  if ((ldv_work_7_0 == 3 || ldv_work_7_0 == 2) && (unsigned long )ldv_work_struct_7_0 == (unsigned long )work) {
#line 571
    ldv_work_7_0 = 1;
  } else {

  }
#line 573
  if ((ldv_work_7_1 == 3 || ldv_work_7_1 == 2) && (unsigned long )ldv_work_struct_7_1 == (unsigned long )work) {
#line 575
    ldv_work_7_1 = 1;
  } else {

  }
#line 577
  if ((ldv_work_7_2 == 3 || ldv_work_7_2 == 2) && (unsigned long )ldv_work_struct_7_2 == (unsigned long )work) {
#line 579
    ldv_work_7_2 = 1;
  } else {

  }
#line 581
  if ((ldv_work_7_3 == 3 || ldv_work_7_3 == 2) && (unsigned long )ldv_work_struct_7_3 == (unsigned long )work) {
#line 583
    ldv_work_7_3 = 1;
  } else {

  }
#line 584
  return;
}
}
#line 588 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void activate_pending_timer_29(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 588
  if ((unsigned long )ldv_timer_list_29 == (unsigned long )timer) {
#line 589
    if (ldv_timer_state_29 == 2 || pending_flag != 0) {
#line 590
      ldv_timer_list_29 = timer;
#line 591
      ldv_timer_list_29->data = data;
#line 592
      ldv_timer_state_29 = 1;
    } else {

    }
#line 594
    return;
  } else {

  }
#line 596
  reg_timer_29(timer);
#line 597
  ldv_timer_list_29->data = data;
#line 598
  return;
}
}
#line 601 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void invoke_work_10(void) 
{ 
  int tmp ;

  {
#line 603
  tmp = __VERIFIER_nondet_int();
#line 603
  switch (tmp) {
  case 0: ;
#line 605
  if (ldv_work_10_0 == 2 || ldv_work_10_0 == 3) {
#line 606
    ldv_work_10_0 = 4;
#line 607
    ldv__builtin_trap();
#line 608
    ldv_work_10_0 = 1;
  } else {

  }
#line 611
  goto ldv_67774;
  case 1: ;
#line 613
  if (ldv_work_10_1 == 2 || ldv_work_10_1 == 3) {
#line 614
    ldv_work_10_1 = 4;
#line 615
    ldv__builtin_trap();
#line 616
    ldv_work_10_1 = 1;
  } else {

  }
#line 619
  goto ldv_67774;
  case 2: ;
#line 621
  if (ldv_work_10_2 == 2 || ldv_work_10_2 == 3) {
#line 622
    ldv_work_10_2 = 4;
#line 623
    ldv__builtin_trap();
#line 624
    ldv_work_10_2 = 1;
  } else {

  }
#line 627
  goto ldv_67774;
  case 3: ;
#line 629
  if (ldv_work_10_3 == 2 || ldv_work_10_3 == 3) {
#line 630
    ldv_work_10_3 = 4;
#line 631
    ldv__builtin_trap();
#line 632
    ldv_work_10_3 = 1;
  } else {

  }
#line 635
  goto ldv_67774;
  default: 
#line 636
  ldv_stop();
  }
  ldv_67774: ;
#line 638
  return;
}
}
#line 642 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void call_and_disable_all_11(int state ) 
{ 


  {
#line 644
  if (ldv_work_11_0 == state) {
#line 645
    call_and_disable_work_11(ldv_work_struct_11_0);
  } else {

  }
#line 646
  if (ldv_work_11_1 == state) {
#line 647
    call_and_disable_work_11(ldv_work_struct_11_1);
  } else {

  }
#line 648
  if (ldv_work_11_2 == state) {
#line 649
    call_and_disable_work_11(ldv_work_struct_11_2);
  } else {

  }
#line 650
  if (ldv_work_11_3 == state) {
#line 651
    call_and_disable_work_11(ldv_work_struct_11_3);
  } else {

  }
#line 652
  return;
}
}
#line 655 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
int reg_timer_29(struct timer_list *timer ) 
{ 


  {
#line 656
  ldv_timer_list_29 = timer;
#line 657
  ldv_timer_state_29 = 1;
#line 658
  return (0);
}
}
#line 661 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void call_and_disable_work_7(struct work_struct *work ) 
{ 


  {
#line 664
  if ((ldv_work_7_0 == 2 || ldv_work_7_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_7_0) {
#line 666
    qlt_free_session_done(work);
#line 667
    ldv_work_7_0 = 1;
#line 668
    return;
  } else {

  }
#line 670
  if ((ldv_work_7_1 == 2 || ldv_work_7_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_7_1) {
#line 672
    qlt_free_session_done(work);
#line 673
    ldv_work_7_1 = 1;
#line 674
    return;
  } else {

  }
#line 676
  if ((ldv_work_7_2 == 2 || ldv_work_7_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_7_2) {
#line 678
    qlt_free_session_done(work);
#line 679
    ldv_work_7_2 = 1;
#line 680
    return;
  } else {

  }
#line 682
  if ((ldv_work_7_3 == 2 || ldv_work_7_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_7_3) {
#line 684
    qlt_free_session_done(work);
#line 685
    ldv_work_7_3 = 1;
#line 686
    return;
  } else {

  }
#line 688
  return;
}
}
#line 691 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void work_init_8(void) 
{ 


  {
#line 692
  ldv_work_8_0 = 0;
#line 693
  ldv_work_8_1 = 0;
#line 694
  ldv_work_8_2 = 0;
#line 695
  ldv_work_8_3 = 0;
#line 696
  return;
}
}
#line 699 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void call_and_disable_all_9(int state ) 
{ 


  {
#line 701
  if (ldv_work_9_0 == state) {
#line 702
    call_and_disable_work_9(ldv_work_struct_9_0);
  } else {

  }
#line 703
  if (ldv_work_9_1 == state) {
#line 704
    call_and_disable_work_9(ldv_work_struct_9_1);
  } else {

  }
#line 705
  if (ldv_work_9_2 == state) {
#line 706
    call_and_disable_work_9(ldv_work_struct_9_2);
  } else {

  }
#line 707
  if (ldv_work_9_3 == state) {
#line 708
    call_and_disable_work_9(ldv_work_struct_9_3);
  } else {

  }
#line 709
  return;
}
}
#line 712 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void call_and_disable_all_12(int state ) 
{ 


  {
#line 714
  if (ldv_work_12_0 == state) {
#line 715
    call_and_disable_work_12(ldv_work_struct_12_0);
  } else {

  }
#line 716
  if (ldv_work_12_1 == state) {
#line 717
    call_and_disable_work_12(ldv_work_struct_12_1);
  } else {

  }
#line 718
  if (ldv_work_12_2 == state) {
#line 719
    call_and_disable_work_12(ldv_work_struct_12_2);
  } else {

  }
#line 720
  if (ldv_work_12_3 == state) {
#line 721
    call_and_disable_work_12(ldv_work_struct_12_3);
  } else {

  }
#line 722
  return;
}
}
#line 725 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void work_init_10(void) 
{ 


  {
#line 726
  ldv_work_10_0 = 0;
#line 727
  ldv_work_10_1 = 0;
#line 728
  ldv_work_10_2 = 0;
#line 729
  ldv_work_10_3 = 0;
#line 730
  return;
}
}
#line 733 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void call_and_disable_work_8(struct work_struct *work ) 
{ 


  {
#line 736
  if ((ldv_work_8_0 == 2 || ldv_work_8_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_8_0) {
#line 738
    qlt_create_sess_from_atio(work);
#line 739
    ldv_work_8_0 = 1;
#line 740
    return;
  } else {

  }
#line 742
  if ((ldv_work_8_1 == 2 || ldv_work_8_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_8_1) {
#line 744
    qlt_create_sess_from_atio(work);
#line 745
    ldv_work_8_1 = 1;
#line 746
    return;
  } else {

  }
#line 748
  if ((ldv_work_8_2 == 2 || ldv_work_8_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_8_2) {
#line 750
    qlt_create_sess_from_atio(work);
#line 751
    ldv_work_8_2 = 1;
#line 752
    return;
  } else {

  }
#line 754
  if ((ldv_work_8_3 == 2 || ldv_work_8_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_8_3) {
#line 756
    qlt_create_sess_from_atio(work);
#line 757
    ldv_work_8_3 = 1;
#line 758
    return;
  } else {

  }
#line 760
  return;
}
}
#line 763 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void invoke_work_11(void) 
{ 
  int tmp ;

  {
#line 765
  tmp = __VERIFIER_nondet_int();
#line 765
  switch (tmp) {
  case 0: ;
#line 767
  if (ldv_work_11_0 == 2 || ldv_work_11_0 == 3) {
#line 768
    ldv_work_11_0 = 4;
#line 769
    qlt_sess_work_fn(ldv_work_struct_11_0);
#line 770
    ldv_work_11_0 = 1;
  } else {

  }
#line 773
  goto ldv_67816;
  case 1: ;
#line 775
  if (ldv_work_11_1 == 2 || ldv_work_11_1 == 3) {
#line 776
    ldv_work_11_1 = 4;
#line 777
    qlt_sess_work_fn(ldv_work_struct_11_0);
#line 778
    ldv_work_11_1 = 1;
  } else {

  }
#line 781
  goto ldv_67816;
  case 2: ;
#line 783
  if (ldv_work_11_2 == 2 || ldv_work_11_2 == 3) {
#line 784
    ldv_work_11_2 = 4;
#line 785
    qlt_sess_work_fn(ldv_work_struct_11_0);
#line 786
    ldv_work_11_2 = 1;
  } else {

  }
#line 789
  goto ldv_67816;
  case 3: ;
#line 791
  if (ldv_work_11_3 == 2 || ldv_work_11_3 == 3) {
#line 792
    ldv_work_11_3 = 4;
#line 793
    qlt_sess_work_fn(ldv_work_struct_11_0);
#line 794
    ldv_work_11_3 = 1;
  } else {

  }
#line 797
  goto ldv_67816;
  default: 
#line 798
  ldv_stop();
  }
  ldv_67816: ;
#line 800
  return;
}
}
#line 804 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void invoke_work_9(void) 
{ 
  int tmp ;

  {
#line 806
  tmp = __VERIFIER_nondet_int();
#line 806
  switch (tmp) {
  case 0: ;
#line 808
  if (ldv_work_9_0 == 2 || ldv_work_9_0 == 3) {
#line 809
    ldv_work_9_0 = 4;
#line 810
    qlt_do_work(ldv_work_struct_9_0);
#line 811
    ldv_work_9_0 = 1;
  } else {

  }
#line 814
  goto ldv_67827;
  case 1: ;
#line 816
  if (ldv_work_9_1 == 2 || ldv_work_9_1 == 3) {
#line 817
    ldv_work_9_1 = 4;
#line 818
    qlt_do_work(ldv_work_struct_9_0);
#line 819
    ldv_work_9_1 = 1;
  } else {

  }
#line 822
  goto ldv_67827;
  case 2: ;
#line 824
  if (ldv_work_9_2 == 2 || ldv_work_9_2 == 3) {
#line 825
    ldv_work_9_2 = 4;
#line 826
    qlt_do_work(ldv_work_struct_9_0);
#line 827
    ldv_work_9_2 = 1;
  } else {

  }
#line 830
  goto ldv_67827;
  case 3: ;
#line 832
  if (ldv_work_9_3 == 2 || ldv_work_9_3 == 3) {
#line 833
    ldv_work_9_3 = 4;
#line 834
    qlt_do_work(ldv_work_struct_9_0);
#line 835
    ldv_work_9_3 = 1;
  } else {

  }
#line 838
  goto ldv_67827;
  default: 
#line 839
  ldv_stop();
  }
  ldv_67827: ;
#line 841
  return;
}
}
#line 845 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void disable_work_8(struct work_struct *work ) 
{ 


  {
#line 847
  if ((ldv_work_8_0 == 3 || ldv_work_8_0 == 2) && (unsigned long )ldv_work_struct_8_0 == (unsigned long )work) {
#line 849
    ldv_work_8_0 = 1;
  } else {

  }
#line 851
  if ((ldv_work_8_1 == 3 || ldv_work_8_1 == 2) && (unsigned long )ldv_work_struct_8_1 == (unsigned long )work) {
#line 853
    ldv_work_8_1 = 1;
  } else {

  }
#line 855
  if ((ldv_work_8_2 == 3 || ldv_work_8_2 == 2) && (unsigned long )ldv_work_struct_8_2 == (unsigned long )work) {
#line 857
    ldv_work_8_2 = 1;
  } else {

  }
#line 859
  if ((ldv_work_8_3 == 3 || ldv_work_8_3 == 2) && (unsigned long )ldv_work_struct_8_3 == (unsigned long )work) {
#line 861
    ldv_work_8_3 = 1;
  } else {

  }
#line 862
  return;
}
}
#line 866 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void activate_work_9(struct work_struct *work , int state ) 
{ 


  {
#line 867
  if (ldv_work_9_0 == 0) {
#line 868
    ldv_work_struct_9_0 = work;
#line 869
    ldv_work_9_0 = state;
#line 870
    return;
  } else {

  }
#line 873
  if (ldv_work_9_1 == 0) {
#line 874
    ldv_work_struct_9_1 = work;
#line 875
    ldv_work_9_1 = state;
#line 876
    return;
  } else {

  }
#line 879
  if (ldv_work_9_2 == 0) {
#line 880
    ldv_work_struct_9_2 = work;
#line 881
    ldv_work_9_2 = state;
#line 882
    return;
  } else {

  }
#line 885
  if (ldv_work_9_3 == 0) {
#line 886
    ldv_work_struct_9_3 = work;
#line 887
    ldv_work_9_3 = state;
#line 888
    return;
  } else {

  }
#line 890
  return;
}
}
#line 893 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void call_and_disable_all_7(int state ) 
{ 


  {
#line 895
  if (ldv_work_7_0 == state) {
#line 896
    call_and_disable_work_7(ldv_work_struct_7_0);
  } else {

  }
#line 897
  if (ldv_work_7_1 == state) {
#line 898
    call_and_disable_work_7(ldv_work_struct_7_1);
  } else {

  }
#line 899
  if (ldv_work_7_2 == state) {
#line 900
    call_and_disable_work_7(ldv_work_struct_7_2);
  } else {

  }
#line 901
  if (ldv_work_7_3 == state) {
#line 902
    call_and_disable_work_7(ldv_work_struct_7_3);
  } else {

  }
#line 903
  return;
}
}
#line 906 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void invoke_work_12(void) 
{ 
  int tmp ;

  {
#line 908
  tmp = __VERIFIER_nondet_int();
#line 908
  switch (tmp) {
  case 0: ;
#line 910
  if (ldv_work_12_0 == 2 || ldv_work_12_0 == 3) {
#line 911
    ldv_work_12_0 = 4;
#line 912
    qlt_handle_srr_work(ldv_work_struct_12_0);
#line 913
    ldv_work_12_0 = 1;
  } else {

  }
#line 916
  goto ldv_67848;
  case 1: ;
#line 918
  if (ldv_work_12_1 == 2 || ldv_work_12_1 == 3) {
#line 919
    ldv_work_12_1 = 4;
#line 920
    qlt_handle_srr_work(ldv_work_struct_12_0);
#line 921
    ldv_work_12_1 = 1;
  } else {

  }
#line 924
  goto ldv_67848;
  case 2: ;
#line 926
  if (ldv_work_12_2 == 2 || ldv_work_12_2 == 3) {
#line 927
    ldv_work_12_2 = 4;
#line 928
    qlt_handle_srr_work(ldv_work_struct_12_0);
#line 929
    ldv_work_12_2 = 1;
  } else {

  }
#line 932
  goto ldv_67848;
  case 3: ;
#line 934
  if (ldv_work_12_3 == 2 || ldv_work_12_3 == 3) {
#line 935
    ldv_work_12_3 = 4;
#line 936
    qlt_handle_srr_work(ldv_work_struct_12_0);
#line 937
    ldv_work_12_3 = 1;
  } else {

  }
#line 940
  goto ldv_67848;
  default: 
#line 941
  ldv_stop();
  }
  ldv_67848: ;
#line 943
  return;
}
}
#line 947 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void call_and_disable_work_12(struct work_struct *work ) 
{ 


  {
#line 950
  if ((ldv_work_12_0 == 2 || ldv_work_12_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_12_0) {
#line 952
    qlt_handle_srr_work(work);
#line 953
    ldv_work_12_0 = 1;
#line 954
    return;
  } else {

  }
#line 956
  if ((ldv_work_12_1 == 2 || ldv_work_12_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_12_1) {
#line 958
    qlt_handle_srr_work(work);
#line 959
    ldv_work_12_1 = 1;
#line 960
    return;
  } else {

  }
#line 962
  if ((ldv_work_12_2 == 2 || ldv_work_12_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_12_2) {
#line 964
    qlt_handle_srr_work(work);
#line 965
    ldv_work_12_2 = 1;
#line 966
    return;
  } else {

  }
#line 968
  if ((ldv_work_12_3 == 2 || ldv_work_12_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_12_3) {
#line 970
    qlt_handle_srr_work(work);
#line 971
    ldv_work_12_3 = 1;
#line 972
    return;
  } else {

  }
#line 974
  return;
}
}
#line 977 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void work_init_11(void) 
{ 


  {
#line 978
  ldv_work_11_0 = 0;
#line 979
  ldv_work_11_1 = 0;
#line 980
  ldv_work_11_2 = 0;
#line 981
  ldv_work_11_3 = 0;
#line 982
  return;
}
}
#line 985 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void activate_work_11(struct work_struct *work , int state ) 
{ 


  {
#line 986
  if (ldv_work_11_0 == 0) {
#line 987
    ldv_work_struct_11_0 = work;
#line 988
    ldv_work_11_0 = state;
#line 989
    return;
  } else {

  }
#line 992
  if (ldv_work_11_1 == 0) {
#line 993
    ldv_work_struct_11_1 = work;
#line 994
    ldv_work_11_1 = state;
#line 995
    return;
  } else {

  }
#line 998
  if (ldv_work_11_2 == 0) {
#line 999
    ldv_work_struct_11_2 = work;
#line 1000
    ldv_work_11_2 = state;
#line 1001
    return;
  } else {

  }
#line 1004
  if (ldv_work_11_3 == 0) {
#line 1005
    ldv_work_struct_11_3 = work;
#line 1006
    ldv_work_11_3 = state;
#line 1007
    return;
  } else {

  }
#line 1009
  return;
}
}
#line 1012 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void disable_work_11(struct work_struct *work ) 
{ 


  {
#line 1014
  if ((ldv_work_11_0 == 3 || ldv_work_11_0 == 2) && (unsigned long )ldv_work_struct_11_0 == (unsigned long )work) {
#line 1016
    ldv_work_11_0 = 1;
  } else {

  }
#line 1018
  if ((ldv_work_11_1 == 3 || ldv_work_11_1 == 2) && (unsigned long )ldv_work_struct_11_1 == (unsigned long )work) {
#line 1020
    ldv_work_11_1 = 1;
  } else {

  }
#line 1022
  if ((ldv_work_11_2 == 3 || ldv_work_11_2 == 2) && (unsigned long )ldv_work_struct_11_2 == (unsigned long )work) {
#line 1024
    ldv_work_11_2 = 1;
  } else {

  }
#line 1026
  if ((ldv_work_11_3 == 3 || ldv_work_11_3 == 2) && (unsigned long )ldv_work_struct_11_3 == (unsigned long )work) {
#line 1028
    ldv_work_11_3 = 1;
  } else {

  }
#line 1029
  return;
}
}
#line 1033 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void disable_work_12(struct work_struct *work ) 
{ 


  {
#line 1035
  if ((ldv_work_12_0 == 3 || ldv_work_12_0 == 2) && (unsigned long )ldv_work_struct_12_0 == (unsigned long )work) {
#line 1037
    ldv_work_12_0 = 1;
  } else {

  }
#line 1039
  if ((ldv_work_12_1 == 3 || ldv_work_12_1 == 2) && (unsigned long )ldv_work_struct_12_1 == (unsigned long )work) {
#line 1041
    ldv_work_12_1 = 1;
  } else {

  }
#line 1043
  if ((ldv_work_12_2 == 3 || ldv_work_12_2 == 2) && (unsigned long )ldv_work_struct_12_2 == (unsigned long )work) {
#line 1045
    ldv_work_12_2 = 1;
  } else {

  }
#line 1047
  if ((ldv_work_12_3 == 3 || ldv_work_12_3 == 2) && (unsigned long )ldv_work_struct_12_3 == (unsigned long )work) {
#line 1049
    ldv_work_12_3 = 1;
  } else {

  }
#line 1050
  return;
}
}
#line 1054 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void work_init_7(void) 
{ 


  {
#line 1055
  ldv_work_7_0 = 0;
#line 1056
  ldv_work_7_1 = 0;
#line 1057
  ldv_work_7_2 = 0;
#line 1058
  ldv_work_7_3 = 0;
#line 1059
  return;
}
}
#line 1062 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void invoke_work_7(void) 
{ 
  int tmp ;

  {
#line 1064
  tmp = __VERIFIER_nondet_int();
#line 1064
  switch (tmp) {
  case 0: ;
#line 1066
  if (ldv_work_7_0 == 2 || ldv_work_7_0 == 3) {
#line 1067
    ldv_work_7_0 = 4;
#line 1068
    qlt_free_session_done(ldv_work_struct_7_0);
#line 1069
    ldv_work_7_0 = 1;
  } else {

  }
#line 1072
  goto ldv_67880;
  case 1: ;
#line 1074
  if (ldv_work_7_1 == 2 || ldv_work_7_1 == 3) {
#line 1075
    ldv_work_7_1 = 4;
#line 1076
    qlt_free_session_done(ldv_work_struct_7_0);
#line 1077
    ldv_work_7_1 = 1;
  } else {

  }
#line 1080
  goto ldv_67880;
  case 2: ;
#line 1082
  if (ldv_work_7_2 == 2 || ldv_work_7_2 == 3) {
#line 1083
    ldv_work_7_2 = 4;
#line 1084
    qlt_free_session_done(ldv_work_struct_7_0);
#line 1085
    ldv_work_7_2 = 1;
  } else {

  }
#line 1088
  goto ldv_67880;
  case 3: ;
#line 1090
  if (ldv_work_7_3 == 2 || ldv_work_7_3 == 3) {
#line 1091
    ldv_work_7_3 = 4;
#line 1092
    qlt_free_session_done(ldv_work_struct_7_0);
#line 1093
    ldv_work_7_3 = 1;
  } else {

  }
#line 1096
  goto ldv_67880;
  default: 
#line 1097
  ldv_stop();
  }
  ldv_67880: ;
#line 1099
  return;
}
}
#line 1103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void call_and_disable_all_8(int state ) 
{ 


  {
#line 1105
  if (ldv_work_8_0 == state) {
#line 1106
    call_and_disable_work_8(ldv_work_struct_8_0);
  } else {

  }
#line 1107
  if (ldv_work_8_1 == state) {
#line 1108
    call_and_disable_work_8(ldv_work_struct_8_1);
  } else {

  }
#line 1109
  if (ldv_work_8_2 == state) {
#line 1110
    call_and_disable_work_8(ldv_work_struct_8_2);
  } else {

  }
#line 1111
  if (ldv_work_8_3 == state) {
#line 1112
    call_and_disable_work_8(ldv_work_struct_8_3);
  } else {

  }
#line 1113
  return;
}
}
#line 1116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void call_and_disable_work_9(struct work_struct *work ) 
{ 


  {
#line 1119
  if ((ldv_work_9_0 == 2 || ldv_work_9_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_9_0) {
#line 1121
    qlt_do_work(work);
#line 1122
    ldv_work_9_0 = 1;
#line 1123
    return;
  } else {

  }
#line 1125
  if ((ldv_work_9_1 == 2 || ldv_work_9_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_9_1) {
#line 1127
    qlt_do_work(work);
#line 1128
    ldv_work_9_1 = 1;
#line 1129
    return;
  } else {

  }
#line 1131
  if ((ldv_work_9_2 == 2 || ldv_work_9_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_9_2) {
#line 1133
    qlt_do_work(work);
#line 1134
    ldv_work_9_2 = 1;
#line 1135
    return;
  } else {

  }
#line 1137
  if ((ldv_work_9_3 == 2 || ldv_work_9_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_9_3) {
#line 1139
    qlt_do_work(work);
#line 1140
    ldv_work_9_3 = 1;
#line 1141
    return;
  } else {

  }
#line 1143
  return;
}
}
#line 1146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void activate_work_12(struct work_struct *work , int state ) 
{ 


  {
#line 1147
  if (ldv_work_12_0 == 0) {
#line 1148
    ldv_work_struct_12_0 = work;
#line 1149
    ldv_work_12_0 = state;
#line 1150
    return;
  } else {

  }
#line 1153
  if (ldv_work_12_1 == 0) {
#line 1154
    ldv_work_struct_12_1 = work;
#line 1155
    ldv_work_12_1 = state;
#line 1156
    return;
  } else {

  }
#line 1159
  if (ldv_work_12_2 == 0) {
#line 1160
    ldv_work_struct_12_2 = work;
#line 1161
    ldv_work_12_2 = state;
#line 1162
    return;
  } else {

  }
#line 1165
  if (ldv_work_12_3 == 0) {
#line 1166
    ldv_work_struct_12_3 = work;
#line 1167
    ldv_work_12_3 = state;
#line 1168
    return;
  } else {

  }
#line 1170
  return;
}
}
#line 1173 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void activate_work_8(struct work_struct *work , int state ) 
{ 


  {
#line 1174
  if (ldv_work_8_0 == 0) {
#line 1175
    ldv_work_struct_8_0 = work;
#line 1176
    ldv_work_8_0 = state;
#line 1177
    return;
  } else {

  }
#line 1180
  if (ldv_work_8_1 == 0) {
#line 1181
    ldv_work_struct_8_1 = work;
#line 1182
    ldv_work_8_1 = state;
#line 1183
    return;
  } else {

  }
#line 1186
  if (ldv_work_8_2 == 0) {
#line 1187
    ldv_work_struct_8_2 = work;
#line 1188
    ldv_work_8_2 = state;
#line 1189
    return;
  } else {

  }
#line 1192
  if (ldv_work_8_3 == 0) {
#line 1193
    ldv_work_struct_8_3 = work;
#line 1194
    ldv_work_8_3 = state;
#line 1195
    return;
  } else {

  }
#line 1197
  return;
}
}
#line 1200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void disable_work_9(struct work_struct *work ) 
{ 


  {
#line 1202
  if ((ldv_work_9_0 == 3 || ldv_work_9_0 == 2) && (unsigned long )ldv_work_struct_9_0 == (unsigned long )work) {
#line 1204
    ldv_work_9_0 = 1;
  } else {

  }
#line 1206
  if ((ldv_work_9_1 == 3 || ldv_work_9_1 == 2) && (unsigned long )ldv_work_struct_9_1 == (unsigned long )work) {
#line 1208
    ldv_work_9_1 = 1;
  } else {

  }
#line 1210
  if ((ldv_work_9_2 == 3 || ldv_work_9_2 == 2) && (unsigned long )ldv_work_struct_9_2 == (unsigned long )work) {
#line 1212
    ldv_work_9_2 = 1;
  } else {

  }
#line 1214
  if ((ldv_work_9_3 == 3 || ldv_work_9_3 == 2) && (unsigned long )ldv_work_struct_9_3 == (unsigned long )work) {
#line 1216
    ldv_work_9_3 = 1;
  } else {

  }
#line 1217
  return;
}
}
#line 1221 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void disable_work_10(struct work_struct *work ) 
{ 


  {
#line 1223
  if ((ldv_work_10_0 == 3 || ldv_work_10_0 == 2) && (unsigned long )ldv_work_struct_10_0 == (unsigned long )work) {
#line 1225
    ldv_work_10_0 = 1;
  } else {

  }
#line 1227
  if ((ldv_work_10_1 == 3 || ldv_work_10_1 == 2) && (unsigned long )ldv_work_struct_10_1 == (unsigned long )work) {
#line 1229
    ldv_work_10_1 = 1;
  } else {

  }
#line 1231
  if ((ldv_work_10_2 == 3 || ldv_work_10_2 == 2) && (unsigned long )ldv_work_struct_10_2 == (unsigned long )work) {
#line 1233
    ldv_work_10_2 = 1;
  } else {

  }
#line 1235
  if ((ldv_work_10_3 == 3 || ldv_work_10_3 == 2) && (unsigned long )ldv_work_struct_10_3 == (unsigned long )work) {
#line 1237
    ldv_work_10_3 = 1;
  } else {

  }
#line 1238
  return;
}
}
#line 1242 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void work_init_12(void) 
{ 


  {
#line 1243
  ldv_work_12_0 = 0;
#line 1244
  ldv_work_12_1 = 0;
#line 1245
  ldv_work_12_2 = 0;
#line 1246
  ldv_work_12_3 = 0;
#line 1247
  return;
}
}
#line 1250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void activate_work_10(struct work_struct *work , int state ) 
{ 


  {
#line 1251
  if (ldv_work_10_0 == 0) {
#line 1252
    ldv_work_struct_10_0 = work;
#line 1253
    ldv_work_10_0 = state;
#line 1254
    return;
  } else {

  }
#line 1257
  if (ldv_work_10_1 == 0) {
#line 1258
    ldv_work_struct_10_1 = work;
#line 1259
    ldv_work_10_1 = state;
#line 1260
    return;
  } else {

  }
#line 1263
  if (ldv_work_10_2 == 0) {
#line 1264
    ldv_work_struct_10_2 = work;
#line 1265
    ldv_work_10_2 = state;
#line 1266
    return;
  } else {

  }
#line 1269
  if (ldv_work_10_3 == 0) {
#line 1270
    ldv_work_struct_10_3 = work;
#line 1271
    ldv_work_10_3 = state;
#line 1272
    return;
  } else {

  }
#line 1274
  return;
}
}
#line 1277 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void call_and_disable_work_11(struct work_struct *work ) 
{ 


  {
#line 1280
  if ((ldv_work_11_0 == 2 || ldv_work_11_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_11_0) {
#line 1282
    qlt_sess_work_fn(work);
#line 1283
    ldv_work_11_0 = 1;
#line 1284
    return;
  } else {

  }
#line 1286
  if ((ldv_work_11_1 == 2 || ldv_work_11_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_11_1) {
#line 1288
    qlt_sess_work_fn(work);
#line 1289
    ldv_work_11_1 = 1;
#line 1290
    return;
  } else {

  }
#line 1292
  if ((ldv_work_11_2 == 2 || ldv_work_11_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_11_2) {
#line 1294
    qlt_sess_work_fn(work);
#line 1295
    ldv_work_11_2 = 1;
#line 1296
    return;
  } else {

  }
#line 1298
  if ((ldv_work_11_3 == 2 || ldv_work_11_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_11_3) {
#line 1300
    qlt_sess_work_fn(work);
#line 1301
    ldv_work_11_3 = 1;
#line 1302
    return;
  } else {

  }
#line 1304
  return;
}
}
#line 1307 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void activate_work_7(struct work_struct *work , int state ) 
{ 


  {
#line 1308
  if (ldv_work_7_0 == 0) {
#line 1309
    ldv_work_struct_7_0 = work;
#line 1310
    ldv_work_7_0 = state;
#line 1311
    return;
  } else {

  }
#line 1314
  if (ldv_work_7_1 == 0) {
#line 1315
    ldv_work_struct_7_1 = work;
#line 1316
    ldv_work_7_1 = state;
#line 1317
    return;
  } else {

  }
#line 1320
  if (ldv_work_7_2 == 0) {
#line 1321
    ldv_work_struct_7_2 = work;
#line 1322
    ldv_work_7_2 = state;
#line 1323
    return;
  } else {

  }
#line 1326
  if (ldv_work_7_3 == 0) {
#line 1327
    ldv_work_struct_7_3 = work;
#line 1328
    ldv_work_7_3 = state;
#line 1329
    return;
  } else {

  }
#line 1331
  return;
}
}
#line 1334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void choose_timer_29(struct timer_list *timer ) 
{ 


  {
#line 1335
  LDV_IN_INTERRUPT = 2;
#line 1336
  (*(timer->function))(timer->data);
#line 1337
  LDV_IN_INTERRUPT = 1;
#line 1338
  ldv_timer_state_29 = 2;
#line 1339
  return;
}
}
#line 1342 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void call_and_disable_all_10(int state ) 
{ 


  {
#line 1344
  if (ldv_work_10_0 == state) {
#line 1345
    call_and_disable_work_10(ldv_work_struct_10_0);
  } else {

  }
#line 1346
  if (ldv_work_10_1 == state) {
#line 1347
    call_and_disable_work_10(ldv_work_struct_10_1);
  } else {

  }
#line 1348
  if (ldv_work_10_2 == state) {
#line 1349
    call_and_disable_work_10(ldv_work_struct_10_2);
  } else {

  }
#line 1350
  if (ldv_work_10_3 == state) {
#line 1351
    call_and_disable_work_10(ldv_work_struct_10_3);
  } else {

  }
#line 1352
  return;
}
}
#line 1355 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void disable_suitable_timer_29(struct timer_list *timer ) 
{ 


  {
#line 1356
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_29) {
#line 1357
    ldv_timer_state_29 = 0;
#line 1358
    return;
  } else {

  }
#line 1360
  return;
}
}
#line 1386 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
bool ldv_queue_work_on_295(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 1390
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1390
  ldv_func_res = tmp;
#line 1392
  activate_work_7(ldv_func_arg3, 2);
#line 1394
  return (ldv_func_res);
}
}
#line 1397 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
bool ldv_queue_delayed_work_on_296(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 1401
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1401
  ldv_func_res = tmp;
#line 1403
  activate_work_7(& ldv_func_arg3->work, 2);
#line 1405
  return (ldv_func_res);
}
}
#line 1408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
bool ldv_queue_work_on_297(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 1412
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1412
  ldv_func_res = tmp;
#line 1414
  activate_work_7(ldv_func_arg3, 2);
#line 1416
  return (ldv_func_res);
}
}
#line 1419 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void ldv_flush_workqueue_298(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1422
  flush_workqueue(ldv_func_arg1);
#line 1424
  call_and_disable_all_7(2);
#line 1425
  return;
}
}
#line 1427 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
bool ldv_queue_delayed_work_on_299(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 1431
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1431
  ldv_func_res = tmp;
#line 1433
  activate_work_7(& ldv_func_arg3->work, 2);
#line 1435
  return (ldv_func_res);
}
}
#line 1438 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
int ldv_scsi_add_host_with_dma_300(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 1442
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 1442
  ldv_func_res = tmp;
#line 1444
  if (ldv_func_res == 0) {
#line 1445
    ldv_state_variable_88 = 1;
#line 1445
    ldv_initialize_scsi_host_template_88();
  } else {

  }
#line 1449
  return (ldv_func_res);
}
}
#line 1452 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
bool ldv_flush_delayed_work_301(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___14 ldv_func_res ;
  bool tmp ;

  {
#line 1456
  tmp = flush_delayed_work(ldv_func_arg1);
#line 1456
  ldv_func_res = tmp;
#line 1458
  call_and_disable_work_7(& ldv_func_arg1->work);
#line 1460
  return (ldv_func_res);
}
}
#line 1463 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void ldv_destroy_workqueue_302(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1466
  destroy_workqueue(ldv_func_arg1);
#line 1468
  call_and_disable_all_7(2);
#line 1469
  return;
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_315(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_317(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_316(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_319(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_318(struct workqueue_struct *ldv_func_arg1 ) ;
#line 330 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.o.c.prepared"
void disable_suitable_timer_30(struct timer_list *timer ) ;
#line 416
void choose_timer_30(struct timer_list *timer ) ;
#line 419
int reg_timer_30(struct timer_list *timer ) ;
#line 460
void activate_pending_timer_30(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 795 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_320(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
#line 11 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static uint32_t const   ql27xx_fwdt_default_template[351U]  = 
#line 11 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
  {      1660944384U,      2751463424U,      2080702464U,      0U, 
        805306368U,      16777216U,      0U,      3225448116U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      67174400U,      335544320U,      0U, 
        33554432U,      1140850688U,      151060480U,      268435456U, 
        0U,      33554432U,      16842752U,      469762048U, 
        0U,      33554432U,      6291456U,      0U, 
        3221225472U,      16842752U,      469762048U,      0U, 
        33554432U,      6291456U,      0U,      3422552064U, 
        16842752U,      469762048U,      0U,      33554432U, 
        274726912U,      0U,      3556769792U,      16842752U, 
        469762048U,      0U,      33554432U,      1880031232U, 
        96U,      4026531840U,      65536U,      402653184U, 
        0U,      33554432U,      7340032U,      68157632U, 
        65536U,      402653184U,      0U,      33554432U, 
        275775488U,      68157632U,      65536U,      402653184U, 
        0U,      33554432U,      1081081856U,      68157632U, 
        16842752U,      469762048U,      0U,      33554432U, 
        8126464U,      16777216U,      3221225472U,      65536U, 
        402653184U,      0U,      33554432U,      8126464U, 
        67305668U,      65536U,      402653184U,      0U, 
        33554432U,      8126464U,      67174592U,      16842752U, 
        469762048U,      0U,      33554432U,      8126464U, 
        0U,      3221225472U,      65536U,      402653184U, 
        0U,      33554432U,      8126464U,      69206016U, 
        184614912U,      402653184U,      0U,      33554432U, 
        201326592U,      0U,      33619968U,      536870912U, 
        0U,      33554432U,      1880031232U,      67174652U, 
        4026531840U,      176U,      33619968U,      536870912U, 
        0U,      33554432U,      1880031232U,      67174652U, 
        4026531840U,      4272U,      33619968U,      536870912U, 
        0U,      33554432U,      1880031232U,      67174652U, 
        4026531840U,      8368U,      33619968U,      536870912U, 
        0U,      33554432U,      1880031232U,      67174652U, 
        4026531840U,      12464U,      33619968U,      536870912U, 
        0U,      33554432U,      1880031232U,      67174652U, 
        4026531840U,      16560U,      33619968U,      536870912U, 
        0U,      33554432U,      1880031232U,      67174652U, 
        4026531840U,      20656U,      33619968U,      536870912U, 
        0U,      33554432U,      1880031232U,      67174652U, 
        4026531840U,      24752U,      33619968U,      536870912U, 
        0U,      33554432U,      1880031232U,      67174652U, 
        4026531840U,      28848U,      33619968U,      536870912U, 
        0U,      33554432U,      1880031232U,      67174652U, 
        4026531840U,      32944U,      33619968U,      536870912U, 
        0U,      33554432U,      1880031232U,      67174652U, 
        4026531840U,      37040U,      33619968U,      536870912U, 
        0U,      33554432U,      1880031232U,      67174652U, 
        4026531840U,      41136U,      65536U,      402653184U, 
        0U,      33554432U,      167772160U,      67174592U, 
        65536U,      402653184U,      0U,      33554432U, 
        167772160U,      69206144U,      65536U,      402653184U, 
        0U,      33554432U,      12451840U,      68157632U, 
        65536U,      402653184U,      0U,      33554432U, 
        280887296U,      68157632U,      65536U,      402653184U, 
        0U,      33554432U,      549322752U,      68157632U, 
        65536U,      402653184U,      0U,      33554432U, 
        817758208U,      68157632U,      65536U,      402653184U, 
        0U,      33554432U,      11534336U,      68157632U, 
        65536U,      402653184U,      0U,      33554432U, 
        279969792U,      68157632U,      65536U,      402653184U, 
        0U,      33554432U,      548405248U,      68157632U, 
        65536U,      402653184U,      0U,      33554432U, 
        816840704U,      68157632U,      65536U,      402653184U, 
        0U,      33554432U,      3145728U,      68157632U, 
        65536U,      402653184U,      0U,      33554432U, 
        271581184U,      68157632U,      65536U,      402653184U, 
        0U,      33554432U,      540016640U,      68157632U, 
        65536U,      402653184U,      0U,      33554432U, 
        808452096U,      68157632U,      167837696U,      268435456U, 
        0U,      33554432U,      100728832U,      469762048U, 
        0U,      33554432U,      16777216U,      512U, 
        4280484352U,      100728832U,      469762048U,      0U, 
        33554432U,      33554432U,      4096U,      0U, 
        117506048U,      402653184U,      0U,      33554432U, 
        0U,      16777216U,      117506048U,      402653184U, 
        0U,      33554432U,      0U,      33554432U, 
        117506048U,      402653184U,      0U,      33554432U, 
        0U,      50331648U,      218169344U,      335544320U, 
        0U,      33554432U,      0U,      4278190080U, 
        268435456U,      0U,      128U};
#line 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
__inline static void *qla27xx_isp_reg(struct scsi_qla_host *vha ) 
{ 


  {
#line 105
  return ((void *)(& ((vha->hw)->iobase)->isp24));
}
}
#line 109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
__inline static void qla27xx_insert16(uint16_t value , void *buf , ulong *len ) 
{ 


  {
#line 111
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 112
    buf = buf + *len;
#line 113
    *((__le16 *)buf) = value;
  } else {

  }
#line 115
  *len = *len + 2UL;
#line 116
  return;
}
}
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
__inline static void qla27xx_insert32(uint32_t value , void *buf , ulong *len ) 
{ 


  {
#line 121
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 122
    buf = buf + *len;
#line 123
    *((__le32 *)buf) = value;
  } else {

  }
#line 125
  *len = *len + 4UL;
#line 126
  return;
}
}
#line 129 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
__inline static void qla27xx_insertbuf(void *mem , ulong size , void *buf , ulong *len ) 
{ 


  {
#line 132
  if (((unsigned long )buf != (unsigned long )((void *)0) && (unsigned long )mem != (unsigned long )((void *)0)) && size != 0UL) {
#line 133
    buf = buf + *len;
#line 134
    memcpy(buf, (void const   *)mem, size);
  } else {

  }
#line 136
  *len = *len + size;
#line 137
  return;
}
}
#line 140 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
__inline static void qla27xx_read8(void *window , void *buf , ulong *len ) 
{ 
  uint8_t value ;

  {
#line 142
  value = 255U;
#line 144
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 145
    value = readb((void const volatile   *)window);
  } else {

  }
#line 147
  qla27xx_insert32((uint32_t )value, buf, len);
#line 148
  return;
}
}
#line 151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
__inline static void qla27xx_read16(void *window , void *buf , ulong *len ) 
{ 
  uint16_t value ;

  {
#line 153
  value = 65535U;
#line 155
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 156
    value = readw((void const volatile   *)window);
  } else {

  }
#line 158
  qla27xx_insert32((uint32_t )value, buf, len);
#line 159
  return;
}
}
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
__inline static void qla27xx_read32(void *window , void *buf , ulong *len ) 
{ 
  uint32_t value ;

  {
#line 164
  value = 4294967295U;
#line 166
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 167
    value = readl((void const volatile   *)window);
  } else {

  }
#line 169
  qla27xx_insert32(value, buf, len);
#line 170
  return;
}
}
#line 172 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
__inline static void (*qla27xx_read_vector(uint width ))(void * , void * , ulong * ) 
{ 


  {
#line 174
  return (width != 1U ? (width == 2U ? & qla27xx_read16 : & qla27xx_read32) : & qla27xx_read8);
}
}
#line 181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
__inline static void qla27xx_read_reg(struct device_reg_24xx *reg , uint offset ,
                                      void *buf , ulong *len ) 
{ 
  void *window ;

  {
#line 184
  window = (void *)reg + (unsigned long )offset;
#line 186
  qla27xx_read32(window, buf, len);
#line 187
  return;
}
}
#line 190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
__inline static void qla27xx_write_reg(struct device_reg_24xx *reg , uint offset ,
                                       uint32_t data , void *buf ) 
{ 
  void *window ;

  {
#line 193
  window = (void *)reg + (unsigned long )offset;
#line 195
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 196
    writel(data, (void volatile   *)window);
  } else {

  }
#line 197
  return;
}
}
#line 201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
__inline static void qla27xx_read_window(struct device_reg_24xx *reg , uint32_t addr ,
                                         uint offset , uint count , uint width , void *buf ,
                                         ulong *len ) 
{ 
  void *window ;
  void (*readn)(void * , void * , ulong * ) ;
  void (*tmp)(void * , void * , ulong * ) ;
  uint tmp___0 ;

  {
#line 205
  window = (void *)reg + (unsigned long )offset;
#line 206
  tmp = qla27xx_read_vector(width);
#line 206
  readn = tmp;
#line 208
  qla27xx_write_reg(reg, 84U, addr, buf);
#line 209
  goto ldv_65956;
  ldv_65955: 
#line 210
  qla27xx_insert32(addr, buf, len);
#line 211
  (*readn)(window, buf, len);
#line 212
  window = window + (unsigned long )width;
#line 213
  addr = addr + 1U;
  ldv_65956: 
#line 209
  tmp___0 = count;
#line 209
  count = count - 1U;
#line 209
  if (tmp___0 != 0U) {
#line 211
    goto ldv_65955;
  } else {

  }

#line 216
  return;
}
}
#line 218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
__inline static void qla27xx_skip_entry(struct qla27xx_fwdt_entry *ent , void *buf ) 
{ 


  {
#line 220
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 221
    ent->hdr.driver_flags = (uint8_t )((unsigned int )ent->hdr.driver_flags | 128U);
  } else {

  }
#line 222
  ql_dbg(98304U, (scsi_qla_host_t *)0, 53265, "Skipping entry %d\n", ent->hdr.entry_type);
#line 224
  return;
}
}
#line 227 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static int qla27xx_fwdt_entry_t0(struct scsi_qla_host *vha , struct qla27xx_fwdt_entry *ent ,
                                 void *buf , ulong *len ) 
{ 


  {
#line 230
  ql_dbg(65536U, vha, 53504, "%s: nop [%lx]\n", "qla27xx_fwdt_entry_t0", *len);
#line 232
  qla27xx_skip_entry(ent, buf);
#line 234
  return (0);
}
}
#line 238 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static int qla27xx_fwdt_entry_t255(struct scsi_qla_host *vha , struct qla27xx_fwdt_entry *ent ,
                                   void *buf , ulong *len ) 
{ 


  {
#line 241
  ql_dbg(65536U, vha, 53759, "%s: end [%lx]\n", "qla27xx_fwdt_entry_t255", *len);
#line 243
  qla27xx_skip_entry(ent, buf);
#line 246
  return (1);
}
}
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static int qla27xx_fwdt_entry_t256(struct scsi_qla_host *vha , struct qla27xx_fwdt_entry *ent ,
                                   void *buf , ulong *len ) 
{ 
  struct device_reg_24xx *reg ;
  void *tmp ;

  {
#line 253
  tmp = qla27xx_isp_reg(vha);
#line 253
  reg = (struct device_reg_24xx *)tmp;
#line 255
  ql_dbg(65536U, vha, 53760, "%s: rdio t1 [%lx]\n", "qla27xx_fwdt_entry_t256", *len);
#line 257
  qla27xx_read_window(reg, ent->__annonCompField128.t256.base_addr, (uint )ent->__annonCompField128.t256.pci_offset,
                      (uint )ent->__annonCompField128.t256.reg_count, (uint )ent->__annonCompField128.t256.reg_width,
                      buf, len);
#line 260
  return (0);
}
}
#line 264 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static int qla27xx_fwdt_entry_t257(struct scsi_qla_host *vha , struct qla27xx_fwdt_entry *ent ,
                                   void *buf , ulong *len ) 
{ 
  struct device_reg_24xx *reg ;
  void *tmp ;

  {
#line 267
  tmp = qla27xx_isp_reg(vha);
#line 267
  reg = (struct device_reg_24xx *)tmp;
#line 269
  ql_dbg(65536U, vha, 53761, "%s: wrio t1 [%lx]\n", "qla27xx_fwdt_entry_t257", *len);
#line 271
  qla27xx_write_reg(reg, 84U, ent->__annonCompField128.t257.base_addr, buf);
#line 272
  qla27xx_write_reg(reg, (uint )ent->__annonCompField128.t257.pci_offset, ent->__annonCompField128.t257.write_data,
                    buf);
#line 274
  return (0);
}
}
#line 278 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static int qla27xx_fwdt_entry_t258(struct scsi_qla_host *vha , struct qla27xx_fwdt_entry *ent ,
                                   void *buf , ulong *len ) 
{ 
  struct device_reg_24xx *reg ;
  void *tmp ;

  {
#line 281
  tmp = qla27xx_isp_reg(vha);
#line 281
  reg = (struct device_reg_24xx *)tmp;
#line 283
  ql_dbg(65536U, vha, 53762, "%s: rdio t2 [%lx]\n", "qla27xx_fwdt_entry_t258", *len);
#line 285
  qla27xx_write_reg(reg, (uint )ent->__annonCompField128.t258.banksel_offset, ent->__annonCompField128.t258.bank,
                    buf);
#line 286
  qla27xx_read_window(reg, ent->__annonCompField128.t258.base_addr, (uint )ent->__annonCompField128.t258.pci_offset,
                      (uint )ent->__annonCompField128.t258.reg_count, (uint )ent->__annonCompField128.t258.reg_width,
                      buf, len);
#line 289
  return (0);
}
}
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static int qla27xx_fwdt_entry_t259(struct scsi_qla_host *vha , struct qla27xx_fwdt_entry *ent ,
                                   void *buf , ulong *len ) 
{ 
  struct device_reg_24xx *reg ;
  void *tmp ;

  {
#line 296
  tmp = qla27xx_isp_reg(vha);
#line 296
  reg = (struct device_reg_24xx *)tmp;
#line 298
  ql_dbg(65536U, vha, 53763, "%s: wrio t2 [%lx]\n", "qla27xx_fwdt_entry_t259", *len);
#line 300
  qla27xx_write_reg(reg, 84U, ent->__annonCompField128.t259.base_addr, buf);
#line 301
  qla27xx_write_reg(reg, (uint )ent->__annonCompField128.t259.banksel_offset, ent->__annonCompField128.t259.bank,
                    buf);
#line 302
  qla27xx_write_reg(reg, (uint )ent->__annonCompField128.t259.pci_offset, ent->__annonCompField128.t259.write_data,
                    buf);
#line 304
  return (0);
}
}
#line 308 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static int qla27xx_fwdt_entry_t260(struct scsi_qla_host *vha , struct qla27xx_fwdt_entry *ent ,
                                   void *buf , ulong *len ) 
{ 
  struct device_reg_24xx *reg ;
  void *tmp ;

  {
#line 311
  tmp = qla27xx_isp_reg(vha);
#line 311
  reg = (struct device_reg_24xx *)tmp;
#line 313
  ql_dbg(65536U, vha, 53764, "%s: rdpci [%lx]\n", "qla27xx_fwdt_entry_t260", *len);
#line 315
  qla27xx_insert32((uint32_t )ent->__annonCompField128.t260.pci_offset, buf, len);
#line 316
  qla27xx_read_reg(reg, (uint )ent->__annonCompField128.t260.pci_offset, buf, len);
#line 318
  return (0);
}
}
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static int qla27xx_fwdt_entry_t261(struct scsi_qla_host *vha , struct qla27xx_fwdt_entry *ent ,
                                   void *buf , ulong *len ) 
{ 
  struct device_reg_24xx *reg ;
  void *tmp ;

  {
#line 325
  tmp = qla27xx_isp_reg(vha);
#line 325
  reg = (struct device_reg_24xx *)tmp;
#line 327
  ql_dbg(65536U, vha, 53765, "%s: wrpci [%lx]\n", "qla27xx_fwdt_entry_t261", *len);
#line 329
  qla27xx_write_reg(reg, (uint )ent->__annonCompField128.t261.pci_offset, ent->__annonCompField128.t261.write_data,
                    buf);
#line 331
  return (0);
}
}
#line 335 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static int qla27xx_fwdt_entry_t262(struct scsi_qla_host *vha , struct qla27xx_fwdt_entry *ent ,
                                   void *buf , ulong *len ) 
{ 
  ulong dwords ;
  ulong start ;
  ulong end ;

  {
#line 342
  ql_dbg(65536U, vha, 53766, "%s: rdram(%x) [%lx]\n", "qla27xx_fwdt_entry_t262", (int )ent->__annonCompField128.t262.ram_area,
         *len);
#line 344
  start = (ulong )ent->__annonCompField128.t262.start_addr;
#line 345
  end = (ulong )ent->__annonCompField128.t262.end_addr;
#line 347
  if ((unsigned int )ent->__annonCompField128.t262.ram_area == 1U) {

  } else
#line 349
  if ((unsigned int )ent->__annonCompField128.t262.ram_area == 2U) {
#line 350
    end = (ulong )(vha->hw)->fw_memory_size;
#line 351
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 352
      ent->__annonCompField128.t262.end_addr = (uint32_t )end;
    } else {

    }
  } else
#line 353
  if ((unsigned int )ent->__annonCompField128.t262.ram_area == 3U) {
#line 354
    start = (ulong )(vha->hw)->fw_shared_ram_start;
#line 355
    end = (ulong )(vha->hw)->fw_shared_ram_end;
#line 356
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 357
      ent->__annonCompField128.t262.start_addr = (uint32_t )start;
#line 358
      ent->__annonCompField128.t262.end_addr = (uint32_t )end;
    } else {

    }
  } else {
#line 361
    ql_dbg(65536U, vha, 53282, "%s: unknown area %x\n", "qla27xx_fwdt_entry_t262",
           (int )ent->__annonCompField128.t262.ram_area);
#line 363
    qla27xx_skip_entry(ent, buf);
#line 364
    goto done;
  }
#line 367
  if (end < start || end == 0UL) {
#line 368
    ql_dbg(65536U, vha, 53283, "%s: unusable range (start=%x end=%x)\n", "qla27xx_fwdt_entry_t262",
           ent->__annonCompField128.t262.end_addr, ent->__annonCompField128.t262.start_addr);
#line 371
    qla27xx_skip_entry(ent, buf);
#line 372
    goto done;
  } else {

  }
#line 375
  dwords = (end - start) + 1UL;
#line 376
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 377
    buf = buf + *len;
#line 378
    qla24xx_dump_ram(vha->hw, (uint32_t )start, (uint32_t *)buf, (uint32_t )dwords,
                     & buf);
  } else {

  }
#line 380
  *len = *len + dwords * 4UL;
  done: ;
#line 382
  return (0);
}
}
#line 386 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static int qla27xx_fwdt_entry_t263(struct scsi_qla_host *vha , struct qla27xx_fwdt_entry *ent ,
                                   void *buf , ulong *len ) 
{ 
  uint count ;
  uint i ;
  uint length ;
  struct req_que *req ;
  struct rsp_que *rsp ;

  {
#line 389
  count = 0U;
#line 393
  ql_dbg(65536U, vha, 53767, "%s: getq(%x) [%lx]\n", "qla27xx_fwdt_entry_t263", (int )ent->__annonCompField128.t263.queue_type,
         *len);
#line 395
  if ((unsigned int )ent->__annonCompField128.t263.queue_type == 1U) {
#line 396
    i = 0U;
#line 396
    goto ldv_66047;
    ldv_66046: 
#line 397
    req = *((vha->hw)->req_q_map + (unsigned long )i);
#line 398
    if ((unsigned long )req != (unsigned long )((struct req_que *)0) || (unsigned long )buf == (unsigned long )((void *)0)) {
#line 399
      length = (unsigned long )req != (unsigned long )((struct req_que *)0) ? (uint )req->length : 2048U;
#line 401
      qla27xx_insert16((int )((uint16_t )i), buf, len);
#line 402
      qla27xx_insert16((int )((uint16_t )length), buf, len);
#line 403
      qla27xx_insertbuf((unsigned long )req != (unsigned long )((struct req_que *)0) ? (void *)req->ring : (void *)0,
                        (unsigned long )length * 64UL, buf, len);
#line 405
      count = count + 1U;
    } else {

    }
#line 396
    i = i + 1U;
    ldv_66047: ;
#line 396
    if ((uint )(vha->hw)->max_req_queues > i) {
#line 398
      goto ldv_66046;
    } else {

    }

  } else
#line 408
  if ((unsigned int )ent->__annonCompField128.t263.queue_type == 2U) {
#line 409
    i = 0U;
#line 409
    goto ldv_66051;
    ldv_66050: 
#line 410
    rsp = *((vha->hw)->rsp_q_map + (unsigned long )i);
#line 411
    if ((unsigned long )rsp != (unsigned long )((struct rsp_que *)0) || (unsigned long )buf == (unsigned long )((void *)0)) {
#line 412
      length = (unsigned long )rsp != (unsigned long )((struct rsp_que *)0) ? (uint )rsp->length : 128U;
#line 414
      qla27xx_insert16((int )((uint16_t )i), buf, len);
#line 415
      qla27xx_insert16((int )((uint16_t )length), buf, len);
#line 416
      qla27xx_insertbuf((unsigned long )rsp != (unsigned long )((struct rsp_que *)0) ? (void *)rsp->ring : (void *)0,
                        (unsigned long )length * 64UL, buf, len);
#line 418
      count = count + 1U;
    } else {

    }
#line 409
    i = i + 1U;
    ldv_66051: ;
#line 409
    if ((uint )(vha->hw)->max_rsp_queues > i) {
#line 411
      goto ldv_66050;
    } else {

    }

  } else {
#line 422
    ql_dbg(65536U, vha, 53286, "%s: unknown queue %x\n", "qla27xx_fwdt_entry_t263",
           (int )ent->__annonCompField128.t263.queue_type);
#line 424
    qla27xx_skip_entry(ent, buf);
  }
#line 427
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 428
    ent->__annonCompField128.t263.num_queues = count;
  } else {

  }
#line 430
  return (0);
}
}
#line 434 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static int qla27xx_fwdt_entry_t264(struct scsi_qla_host *vha , struct qla27xx_fwdt_entry *ent ,
                                   void *buf , ulong *len ) 
{ 


  {
#line 437
  ql_dbg(65536U, vha, 53768, "%s: getfce [%lx]\n", "qla27xx_fwdt_entry_t264", *len);
#line 439
  if ((unsigned long )(vha->hw)->fce != (unsigned long )((void *)0)) {
#line 440
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 441
      ent->__annonCompField128.t264.fce_trace_size = 65536U;
#line 442
      ent->__annonCompField128.t264.write_pointer = (vha->hw)->fce_wr;
#line 443
      ent->__annonCompField128.t264.base_pointer = (vha->hw)->fce_dma;
#line 444
      ent->__annonCompField128.t264.fce_enable_mb0 = (uint32_t )(vha->hw)->fce_mb[0];
#line 445
      ent->__annonCompField128.t264.fce_enable_mb2 = (uint32_t )(vha->hw)->fce_mb[2];
#line 446
      ent->__annonCompField128.t264.fce_enable_mb3 = (uint32_t )(vha->hw)->fce_mb[3];
#line 447
      ent->__annonCompField128.t264.fce_enable_mb4 = (uint32_t )(vha->hw)->fce_mb[4];
#line 448
      ent->__annonCompField128.t264.fce_enable_mb5 = (uint32_t )(vha->hw)->fce_mb[5];
#line 449
      ent->__annonCompField128.t264.fce_enable_mb6 = (uint32_t )(vha->hw)->fce_mb[6];
    } else {

    }
#line 451
    qla27xx_insertbuf((vha->hw)->fce, 65536UL, buf, len);
  } else {
#line 453
    ql_dbg(65536U, vha, 53287, "%s: missing fce\n", "qla27xx_fwdt_entry_t264");
#line 455
    qla27xx_skip_entry(ent, buf);
  }
#line 458
  return (0);
}
}
#line 462 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static int qla27xx_fwdt_entry_t265(struct scsi_qla_host *vha , struct qla27xx_fwdt_entry *ent ,
                                   void *buf , ulong *len ) 
{ 
  struct device_reg_24xx *reg ;
  void *tmp ;

  {
#line 465
  tmp = qla27xx_isp_reg(vha);
#line 465
  reg = (struct device_reg_24xx *)tmp;
#line 467
  ql_dbg(65536U, vha, 53769, "%s: pause risc [%lx]\n", "qla27xx_fwdt_entry_t265",
         *len);
#line 469
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 470
    qla24xx_pause_risc(reg, vha->hw);
  } else {

  }
#line 472
  return (0);
}
}
#line 476 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static int qla27xx_fwdt_entry_t266(struct scsi_qla_host *vha , struct qla27xx_fwdt_entry *ent ,
                                   void *buf , ulong *len ) 
{ 


  {
#line 479
  ql_dbg(65536U, vha, 53770, "%s: reset risc [%lx]\n", "qla27xx_fwdt_entry_t266",
         *len);
#line 481
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 482
    qla24xx_soft_reset(vha->hw);
  } else {

  }
#line 484
  return (0);
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static int qla27xx_fwdt_entry_t267(struct scsi_qla_host *vha , struct qla27xx_fwdt_entry *ent ,
                                   void *buf , ulong *len ) 
{ 
  struct device_reg_24xx *reg ;
  void *tmp ;

  {
#line 491
  tmp = qla27xx_isp_reg(vha);
#line 491
  reg = (struct device_reg_24xx *)tmp;
#line 493
  ql_dbg(65536U, vha, 53771, "%s: dis intr [%lx]\n", "qla27xx_fwdt_entry_t267", *len);
#line 495
  qla27xx_write_reg(reg, (uint )ent->__annonCompField128.t267.pci_offset, ent->__annonCompField128.t267.data,
                    buf);
#line 497
  return (0);
}
}
#line 501 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static int qla27xx_fwdt_entry_t268(struct scsi_qla_host *vha , struct qla27xx_fwdt_entry *ent ,
                                   void *buf , ulong *len ) 
{ 


  {
#line 504
  ql_dbg(65536U, vha, 53772, "%s: gethb(%x) [%lx]\n", "qla27xx_fwdt_entry_t268", (int )ent->__annonCompField128.t268.buf_type,
         *len);
#line 506
  if ((unsigned int )ent->__annonCompField128.t268.buf_type == 1U) {
#line 507
    if ((unsigned long )(vha->hw)->eft != (unsigned long )((void *)0)) {
#line 508
      if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 509
        ent->__annonCompField128.t268.buf_size = 65536U;
#line 510
        ent->__annonCompField128.t268.start_addr = (vha->hw)->eft_dma;
      } else {

      }
#line 512
      qla27xx_insertbuf((vha->hw)->eft, 65536UL, buf, len);
    } else {
#line 514
      ql_dbg(65536U, vha, 53288, "%s: missing eft\n", "qla27xx_fwdt_entry_t268");
#line 516
      qla27xx_skip_entry(ent, buf);
    }
  } else {
#line 519
    ql_dbg(65536U, vha, 53291, "%s: unknown buffer %x\n", "qla27xx_fwdt_entry_t268",
           (int )ent->__annonCompField128.t268.buf_type);
#line 521
    qla27xx_skip_entry(ent, buf);
  }
#line 524
  return (0);
}
}
#line 528 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static int qla27xx_fwdt_entry_t269(struct scsi_qla_host *vha , struct qla27xx_fwdt_entry *ent ,
                                   void *buf , ulong *len ) 
{ 


  {
#line 531
  ql_dbg(65536U, vha, 53773, "%s: scratch [%lx]\n", "qla27xx_fwdt_entry_t269", *len);
#line 533
  qla27xx_insert32(2863311530U, buf, len);
#line 534
  qla27xx_insert32(3149642683U, buf, len);
#line 535
  qla27xx_insert32(3435973836U, buf, len);
#line 536
  qla27xx_insert32(3722304989U, buf, len);
#line 537
  qla27xx_insert32((uint32_t )*len + 4U, buf, len);
#line 538
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 539
    ent->__annonCompField128.t269.scratch_size = 20U;
  } else {

  }
#line 541
  return (0);
}
}
#line 545 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static int qla27xx_fwdt_entry_t270(struct scsi_qla_host *vha , struct qla27xx_fwdt_entry *ent ,
                                   void *buf , ulong *len ) 
{ 
  struct device_reg_24xx *reg ;
  void *tmp ;
  ulong dwords ;
  ulong addr ;
  ulong tmp___0 ;

  {
#line 548
  tmp = qla27xx_isp_reg(vha);
#line 548
  reg = (struct device_reg_24xx *)tmp;
#line 549
  dwords = (ulong )ent->__annonCompField128.t270.count;
#line 550
  addr = (ulong )ent->__annonCompField128.t270.addr;
#line 552
  ql_dbg(65536U, vha, 53774, "%s: rdremreg [%lx]\n", "qla27xx_fwdt_entry_t270", *len);
#line 554
  qla27xx_write_reg(reg, 84U, 64U, buf);
#line 555
  goto ldv_66108;
  ldv_66107: 
#line 556
  qla27xx_write_reg(reg, 192U, (uint32_t )addr | 2147483648U, buf);
#line 557
  qla27xx_insert32((uint32_t )addr, buf, len);
#line 558
  qla27xx_read_reg(reg, 196U, buf, len);
#line 559
  addr = addr + 4UL;
  ldv_66108: 
#line 555
  tmp___0 = dwords;
#line 555
  dwords = dwords - 1UL;
#line 555
  if (tmp___0 != 0UL) {
#line 557
    goto ldv_66107;
  } else {

  }

#line 562
  return (0);
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static int qla27xx_fwdt_entry_t271(struct scsi_qla_host *vha , struct qla27xx_fwdt_entry *ent ,
                                   void *buf , ulong *len ) 
{ 
  struct device_reg_24xx *reg ;
  void *tmp ;
  ulong addr ;
  ulong data ;

  {
#line 569
  tmp = qla27xx_isp_reg(vha);
#line 569
  reg = (struct device_reg_24xx *)tmp;
#line 570
  addr = (ulong )ent->__annonCompField128.t271.addr;
#line 571
  data = (ulong )ent->__annonCompField128.t271.data;
#line 573
  ql_dbg(65536U, vha, 53775, "%s: wrremreg [%lx]\n", "qla27xx_fwdt_entry_t271", *len);
#line 575
  qla27xx_write_reg(reg, 84U, 64U, buf);
#line 576
  qla27xx_write_reg(reg, 196U, (uint32_t )data, buf);
#line 577
  qla27xx_write_reg(reg, 192U, (uint32_t )addr, buf);
#line 579
  return (0);
}
}
#line 583 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static int qla27xx_fwdt_entry_t272(struct scsi_qla_host *vha , struct qla27xx_fwdt_entry *ent ,
                                   void *buf , ulong *len ) 
{ 
  ulong dwords ;
  ulong start ;

  {
#line 586
  dwords = (ulong )ent->__annonCompField128.t272.count;
#line 587
  start = (ulong )ent->__annonCompField128.t272.addr;
#line 589
  ql_dbg(65536U, vha, 53776, "%s: rdremram [%lx]\n", "qla27xx_fwdt_entry_t272", *len);
#line 591
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 592
    ql_dbg(65536U, vha, 53292, "%s: @%lx -> (%lx dwords)\n", "qla27xx_fwdt_entry_t272",
           start, dwords);
#line 594
    buf = buf + *len;
#line 595
    qla27xx_dump_mpi_ram(vha->hw, (uint32_t )start, (uint32_t *)buf, (uint32_t )dwords,
                         & buf);
  } else {

  }
#line 597
  *len = *len + dwords * 4UL;
#line 599
  return (0);
}
}
#line 603 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static int qla27xx_fwdt_entry_t273(struct scsi_qla_host *vha , struct qla27xx_fwdt_entry *ent ,
                                   void *buf , ulong *len ) 
{ 
  ulong dwords ;
  ulong addr ;
  uint32_t value ;
  int tmp ;
  ulong tmp___0 ;

  {
#line 606
  dwords = (ulong )ent->__annonCompField128.t273.count;
#line 607
  addr = (ulong )ent->__annonCompField128.t273.addr;
#line 610
  ql_dbg(65536U, vha, 53777, "%s: pcicfg [%lx]\n", "qla27xx_fwdt_entry_t273", *len);
#line 612
  goto ldv_66140;
  ldv_66139: 
#line 613
  value = 4294967295U;
#line 614
  tmp = pci_read_config_dword((struct pci_dev  const  *)(vha->hw)->pdev, (int )addr,
                              & value);
#line 614
  if (tmp != 0) {
#line 615
    ql_dbg(65536U, vha, 53293, "%s: failed pcicfg read at %lx\n", "qla27xx_fwdt_entry_t273",
           addr);
  } else {

  }
#line 617
  qla27xx_insert32((uint32_t )addr, buf, len);
#line 618
  qla27xx_insert32(value, buf, len);
#line 619
  addr = addr + 4UL;
  ldv_66140: 
#line 612
  tmp___0 = dwords;
#line 612
  dwords = dwords - 1UL;
#line 612
  if (tmp___0 != 0UL) {
#line 614
    goto ldv_66139;
  } else {

  }

#line 622
  return (0);
}
}
#line 626 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static int qla27xx_fwdt_entry_t274(struct scsi_qla_host *vha , struct qla27xx_fwdt_entry *ent ,
                                   void *buf , ulong *len ) 
{ 
  uint count ;
  uint i ;
  struct req_que *req ;
  struct rsp_que *rsp ;

  {
#line 629
  count = 0U;
#line 632
  ql_dbg(65536U, vha, 53778, "%s: getqsh(%x) [%lx]\n", "qla27xx_fwdt_entry_t274",
         (int )ent->__annonCompField128.t274.queue_type, *len);
#line 634
  if ((unsigned int )ent->__annonCompField128.t274.queue_type == 1U) {
#line 635
    i = 0U;
#line 635
    goto ldv_66153;
    ldv_66152: 
#line 636
    req = *((vha->hw)->req_q_map + (unsigned long )i);
#line 637
    if ((unsigned long )req != (unsigned long )((struct req_que *)0) || (unsigned long )buf == (unsigned long )((void *)0)) {
#line 638
      qla27xx_insert16((int )((uint16_t )i), buf, len);
#line 639
      qla27xx_insert16(1, buf, len);
#line 640
      qla27xx_insert32((unsigned long )req != (unsigned long )((struct req_que *)0) && (unsigned long )req->out_ptr != (unsigned long )((uint16_t *)0U) ? (uint32_t )*(req->out_ptr) : 0U,
                       buf, len);
#line 642
      count = count + 1U;
    } else {

    }
#line 635
    i = i + 1U;
    ldv_66153: ;
#line 635
    if ((uint )(vha->hw)->max_req_queues > i) {
#line 637
      goto ldv_66152;
    } else {

    }

  } else
#line 645
  if ((unsigned int )ent->__annonCompField128.t274.queue_type == 2U) {
#line 646
    i = 0U;
#line 646
    goto ldv_66157;
    ldv_66156: 
#line 647
    rsp = *((vha->hw)->rsp_q_map + (unsigned long )i);
#line 648
    if ((unsigned long )rsp != (unsigned long )((struct rsp_que *)0) || (unsigned long )buf == (unsigned long )((void *)0)) {
#line 649
      qla27xx_insert16((int )((uint16_t )i), buf, len);
#line 650
      qla27xx_insert16(1, buf, len);
#line 651
      qla27xx_insert32((unsigned long )rsp != (unsigned long )((struct rsp_que *)0) && (unsigned long )rsp->in_ptr != (unsigned long )((uint16_t *)0U) ? (uint32_t )*(rsp->in_ptr) : 0U,
                       buf, len);
#line 653
      count = count + 1U;
    } else {

    }
#line 646
    i = i + 1U;
    ldv_66157: ;
#line 646
    if ((uint )(vha->hw)->max_rsp_queues > i) {
#line 648
      goto ldv_66156;
    } else {

    }

  } else {
#line 657
    ql_dbg(65536U, vha, 53295, "%s: unknown queue %x\n", "qla27xx_fwdt_entry_t274",
           (int )ent->__annonCompField128.t274.queue_type);
#line 659
    qla27xx_skip_entry(ent, buf);
  }
#line 662
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 663
    ent->__annonCompField128.t274.num_queues = count;
  } else {

  }
#line 665
  if (count == 0U) {
#line 666
    qla27xx_skip_entry(ent, buf);
  } else {

  }
#line 668
  return (0);
}
}
#line 672 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static int qla27xx_fwdt_entry_t275(struct scsi_qla_host *vha , struct qla27xx_fwdt_entry *ent ,
                                   void *buf , ulong *len ) 
{ 
  ulong offset ;

  {
#line 675
  offset = 20UL;
#line 677
  ql_dbg(65536U, vha, 53779, "%s: buffer(%x) [%lx]\n", "qla27xx_fwdt_entry_t275",
         ent->__annonCompField128.t275.length, *len);
#line 679
  if (ent->__annonCompField128.t275.length == 0U) {
#line 680
    ql_dbg(65536U, vha, 53280, "%s: buffer zero length\n", "qla27xx_fwdt_entry_t275");
#line 682
    qla27xx_skip_entry(ent, buf);
#line 683
    goto done;
  } else {

  }
#line 685
  if ((ulong )ent->__annonCompField128.t275.length + offset > (ulong )ent->hdr.entry_size) {
#line 686
    ql_dbg(65536U, vha, 53296, "%s: buffer overflow\n", "qla27xx_fwdt_entry_t275");
#line 688
    qla27xx_skip_entry(ent, buf);
#line 689
    goto done;
  } else {

  }
#line 692
  qla27xx_insertbuf((void *)(& ent->__annonCompField128.t275.buffer), (ulong )ent->__annonCompField128.t275.length,
                    buf, len);
  done: ;
#line 694
  return (0);
}
}
#line 698 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static int qla27xx_fwdt_entry_other(struct scsi_qla_host *vha , struct qla27xx_fwdt_entry *ent ,
                                    void *buf , ulong *len ) 
{ 


  {
#line 701
  ql_dbg(65536U, vha, 54015, "%s: type %x [%lx]\n", "qla27xx_fwdt_entry_other", ent->hdr.entry_type,
         *len);
#line 703
  qla27xx_skip_entry(ent, buf);
#line 705
  return (0);
}
}
#line 717 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static struct qla27xx_fwdt_entry_call ql27xx_fwdt_entry_call_list[23U]  = 
#line 717
  {      {0U, & qla27xx_fwdt_entry_t0}, 
        {255U, & qla27xx_fwdt_entry_t255}, 
        {256U, & qla27xx_fwdt_entry_t256}, 
        {257U, & qla27xx_fwdt_entry_t257}, 
        {258U, & qla27xx_fwdt_entry_t258}, 
        {259U, & qla27xx_fwdt_entry_t259}, 
        {260U, & qla27xx_fwdt_entry_t260}, 
        {261U, & qla27xx_fwdt_entry_t261}, 
        {262U, & qla27xx_fwdt_entry_t262}, 
        {263U, & qla27xx_fwdt_entry_t263}, 
        {264U, & qla27xx_fwdt_entry_t264}, 
        {265U, & qla27xx_fwdt_entry_t265}, 
        {266U, & qla27xx_fwdt_entry_t266}, 
        {267U, & qla27xx_fwdt_entry_t267}, 
        {268U, & qla27xx_fwdt_entry_t268}, 
        {269U, & qla27xx_fwdt_entry_t269}, 
        {270U, & qla27xx_fwdt_entry_t270}, 
        {271U, & qla27xx_fwdt_entry_t271}, 
        {272U, & qla27xx_fwdt_entry_t272}, 
        {273U, & qla27xx_fwdt_entry_t273}, 
        {274U, & qla27xx_fwdt_entry_t274}, 
        {275U, & qla27xx_fwdt_entry_t275}, 
        {4294967295U, & qla27xx_fwdt_entry_other}};
#line 743 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
__inline static int (*qla27xx_find_entry(uint type ))(struct scsi_qla_host * , struct qla27xx_fwdt_entry * ,
                                                      void * , ulong * ) 
{ 
  struct qla27xx_fwdt_entry_call *list ;

  {
#line 746
  list = (struct qla27xx_fwdt_entry_call *)(& ql27xx_fwdt_entry_call_list);
#line 748
  goto ldv_66192;
  ldv_66191: 
#line 749
  list = list + 1;
  ldv_66192: ;
#line 748
  if (list->type < type) {
#line 750
    goto ldv_66191;
  } else {

  }

#line 751
  if (list->type == type) {
#line 752
    return (list->call);
  } else {

  }
#line 753
  return (& qla27xx_fwdt_entry_other);
}
}
#line 757 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
__inline static void *qla27xx_next_entry(void *p ) 
{ 
  struct qla27xx_fwdt_entry *ent ;

  {
#line 759
  ent = (struct qla27xx_fwdt_entry *)p;
#line 761
  return (p + (unsigned long )ent->hdr.entry_size);
}
}
#line 765 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static void qla27xx_walk_template(struct scsi_qla_host *vha , struct qla27xx_fwdt_template *tmp ,
                                  void *buf , ulong *len ) 
{ 
  struct qla27xx_fwdt_entry *ent ;
  ulong count ;
  int (*tmp___0)(struct scsi_qla_host * , struct qla27xx_fwdt_entry * , void * , ulong * ) ;
  int tmp___1 ;
  void *tmp___2 ;
  ulong tmp___3 ;

  {
#line 768
  ent = (struct qla27xx_fwdt_entry *)tmp + (unsigned long )tmp->entry_offset;
#line 769
  count = (ulong )tmp->entry_count;
#line 771
  ql_dbg(65536U, vha, 53274, "%s: entry count %lx\n", "qla27xx_walk_template", count);
#line 773
  goto ldv_66209;
  ldv_66208: 
#line 774
  tmp___0 = qla27xx_find_entry(ent->hdr.entry_type);
#line 774
  tmp___1 = (*tmp___0)(vha, ent, buf, len);
#line 774
  if (tmp___1 != 0) {
#line 775
    goto ldv_66207;
  } else {

  }
#line 776
  tmp___2 = qla27xx_next_entry((void *)ent);
#line 776
  ent = (struct qla27xx_fwdt_entry *)tmp___2;
  ldv_66209: 
#line 773
  tmp___3 = count;
#line 773
  count = count - 1UL;
#line 773
  if (tmp___3 != 0UL) {
#line 775
    goto ldv_66208;
  } else {

  }
  ldv_66207: ;
#line 779
  if (count != 0UL) {
#line 780
    ql_dbg(65536U, vha, 53272, "%s: residual count (%lx)\n", "qla27xx_walk_template",
           count);
  } else {

  }
#line 783
  if (ent->hdr.entry_type != 255U) {
#line 784
    ql_dbg(65536U, vha, 53273, "%s: missing end (%lx)\n", "qla27xx_walk_template",
           count);
  } else {

  }
#line 787
  ql_dbg(65536U, vha, 53275, "%s: len=%lx\n", "qla27xx_walk_template", *len);
#line 790
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 791
    ql_log(1U, vha, 53269, "Firmware dump saved to temp buffer (%ld/%p)\n", vha->host_no,
           (vha->hw)->fw_dump);
#line 794
    qla2x00_post_uevent_work(vha, 0U);
  } else {

  }
#line 796
  return;
}
}
#line 799 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static void qla27xx_time_stamp(struct qla27xx_fwdt_template *tmp ) 
{ 


  {
#line 801
  tmp->capture_timestamp = (uint32_t )jiffies;
#line 802
  return;
}
}
#line 805 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static void qla27xx_driver_info(struct qla27xx_fwdt_template *tmp ) 
{ 
  uint8_t v[6U] ;
  int rval ;

  {
#line 807
  v[0] = 0U;
#line 807
  v[1] = 0U;
#line 807
  v[2] = 0U;
#line 807
  v[3] = 0U;
#line 807
  v[4] = 0U;
#line 807
  v[5] = 0U;
#line 808
  rval = 0;
#line 810
  rval = sscanf((char const   *)(& qla2x00_version_str), "%hhu.%hhu.%hhu.%hhu.%hhu.%hhu",
                (uint8_t *)(& v), (uint8_t *)(& v) + 1UL, (uint8_t *)(& v) + 2UL,
                (uint8_t *)(& v) + 3UL, (uint8_t *)(& v) + 4UL, (uint8_t *)(& v) + 5UL);
#line 813
  tmp->driver_info[0] = (uint32_t )(((((int )v[3] << 24) | ((int )v[2] << 16)) | ((int )v[1] << 8)) | (int )v[0]);
#line 814
  tmp->driver_info[1] = (uint32_t )(((int )v[5] << 8) | (int )v[4]);
#line 815
  tmp->driver_info[2] = 305419896U;
#line 816
  return;
}
}
#line 819 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static void qla27xx_firmware_info(struct qla27xx_fwdt_template *tmp , struct scsi_qla_host *vha ) 
{ 


  {
#line 822
  tmp->firmware_version[0] = (uint32_t )(vha->hw)->fw_major_version;
#line 823
  tmp->firmware_version[1] = (uint32_t )(vha->hw)->fw_minor_version;
#line 824
  tmp->firmware_version[2] = (uint32_t )(vha->hw)->fw_subminor_version;
#line 825
  tmp->firmware_version[3] = (uint32_t )(((int )(vha->hw)->fw_attributes_h << 16) | (int )(vha->hw)->fw_attributes);
#line 827
  tmp->firmware_version[4] = (uint32_t )(((int )(vha->hw)->fw_attributes_ext[1] << 16) | (int )(vha->hw)->fw_attributes_ext[0]);
#line 829
  return;
}
}
#line 832 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static void ql27xx_edit_template(struct scsi_qla_host *vha , struct qla27xx_fwdt_template *tmp ) 
{ 


  {
#line 835
  qla27xx_time_stamp(tmp);
#line 836
  qla27xx_driver_info(tmp);
#line 837
  qla27xx_firmware_info(tmp, vha);
#line 838
  return;
}
}
#line 841 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
__inline static uint32_t qla27xx_template_checksum(void *p , ulong size ) 
{ 
  uint32_t *buf ;
  uint64_t sum ;
  uint32_t *tmp ;
  ulong tmp___0 ;

  {
#line 843
  buf = (uint32_t *)p;
#line 844
  sum = 0ULL;
#line 846
  size = size / 4UL;
#line 848
  goto ldv_66233;
  ldv_66232: 
#line 849
  tmp = buf;
#line 849
  buf = buf + 1;
#line 849
  sum = (uint64_t )*tmp + sum;
  ldv_66233: 
#line 848
  tmp___0 = size;
#line 848
  size = size - 1UL;
#line 848
  if (tmp___0 != 0UL) {
#line 850
    goto ldv_66232;
  } else {

  }
#line 851
  sum = (sum & 4294967295ULL) + (sum >> 32);
#line 853
  return (~ ((uint32_t )sum));
}
}
#line 857 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
__inline static int qla27xx_verify_template_checksum(struct qla27xx_fwdt_template *tmp ) 
{ 
  uint32_t tmp___0 ;

  {
#line 859
  tmp___0 = qla27xx_template_checksum((void *)tmp, (ulong )tmp->template_size);
#line 859
  return (tmp___0 == 0U);
}
}
#line 863 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
__inline static int qla27xx_verify_template_header(struct qla27xx_fwdt_template *tmp ) 
{ 


  {
#line 865
  return (tmp->template_type == 99U);
}
}
#line 869 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
static void qla27xx_execute_fwdt_template(struct scsi_qla_host *vha ) 
{ 
  struct qla27xx_fwdt_template *tmp ;
  ulong len ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 871
  tmp = (struct qla27xx_fwdt_template *)(vha->hw)->fw_dump_template;
#line 874
  tmp___1 = qla27xx_fwdt_template_valid((void *)tmp);
#line 874
  if (tmp___1 != 0) {
#line 875
    len = (ulong )tmp->template_size;
#line 876
    tmp___0 = memcpy((void *)(vha->hw)->fw_dump, (void const   *)tmp, len);
#line 876
    tmp = (struct qla27xx_fwdt_template *)tmp___0;
#line 877
    ql27xx_edit_template(vha, tmp);
#line 878
    qla27xx_walk_template(vha, tmp, (void *)tmp, & len);
#line 879
    (vha->hw)->fw_dump_len = (uint32_t )len;
#line 880
    (vha->hw)->fw_dumped = 1;
  } else {

  }
#line 882
  return;
}
}
#line 885 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
ulong qla27xx_fwdt_calculate_dump_size(struct scsi_qla_host *vha ) 
{ 
  struct qla27xx_fwdt_template *tmp ;
  ulong len ;
  int tmp___0 ;

  {
#line 887
  tmp = (struct qla27xx_fwdt_template *)(vha->hw)->fw_dump_template;
#line 888
  len = 0UL;
#line 890
  tmp___0 = qla27xx_fwdt_template_valid((void *)tmp);
#line 890
  if (tmp___0 != 0) {
#line 891
    len = (ulong )tmp->template_size;
#line 892
    qla27xx_walk_template(vha, tmp, (void *)0, & len);
  } else {

  }
#line 895
  return (len);
}
}
#line 899 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
ulong qla27xx_fwdt_template_size(void *p ) 
{ 
  struct qla27xx_fwdt_template *tmp ;

  {
#line 901
  tmp = (struct qla27xx_fwdt_template *)p;
#line 903
  return ((ulong )tmp->template_size);
}
}
#line 907 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
ulong qla27xx_fwdt_template_default_size(void) 
{ 


  {
#line 909
  return (1404UL);
}
}
#line 913 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
void const   *qla27xx_fwdt_template_default(void) 
{ 


  {
#line 915
  return ((void const   *)(& ql27xx_fwdt_default_template));
}
}
#line 919 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
int qla27xx_fwdt_template_valid(void *p ) 
{ 
  struct qla27xx_fwdt_template *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 921
  tmp = (struct qla27xx_fwdt_template *)p;
#line 923
  tmp___0 = qla27xx_verify_template_header(tmp);
#line 923
  if (tmp___0 == 0) {
#line 924
    ql_log(1U, (scsi_qla_host_t *)0, 53276, "%s: template type %x\n", "qla27xx_fwdt_template_valid",
           tmp->template_type);
#line 926
    return (0);
  } else {

  }
#line 929
  tmp___1 = qla27xx_verify_template_checksum(tmp);
#line 929
  if (tmp___1 == 0) {
#line 930
    ql_log(1U, (scsi_qla_host_t *)0, 53277, "%s: failed template checksum\n", "qla27xx_fwdt_template_valid");
#line 932
    return (0);
  } else {

  }
#line 935
  return (1);
}
}
#line 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.c"
void qla27xx_fwdump(scsi_qla_host_t *vha , int hardware_locked ) 
{ 
  ulong flags ;
  raw_spinlock_t *tmp ;

  {
#line 941
  flags = 0UL;
#line 943
  if (hardware_locked == 0) {
#line 944
    tmp = spinlock_check(& (vha->hw)->hardware_lock);
#line 944
    flags = _raw_spin_lock_irqsave(tmp);
  } else {

  }
#line 946
  if ((unsigned long )(vha->hw)->fw_dump == (unsigned long )((struct qla2xxx_fw_dump *)0)) {
#line 947
    ql_log(1U, vha, 53278, "fwdump buffer missing.\n");
  } else
#line 948
  if ((unsigned long )(vha->hw)->fw_dump_template == (unsigned long )((void *)0)) {
#line 949
    ql_log(1U, vha, 53279, "fwdump template missing.\n");
  } else
#line 950
  if ((vha->hw)->fw_dumped != 0) {
#line 951
    ql_log(1U, vha, 54016, "Firmware has been previously dumped (%p), -- ignoring request\n",
           (vha->hw)->fw_dump);
  } else {
#line 955
    qla27xx_execute_fwdt_template(vha);
  }
#line 957
  if (hardware_locked == 0) {
#line 958
    spin_unlock_irqrestore(& (vha->hw)->hardware_lock, flags);
  } else {

  }
#line 959
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.o.c.prepared"
void disable_suitable_timer_30(struct timer_list *timer ) 
{ 


  {
#line 489
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_30) {
#line 490
    ldv_timer_state_30 = 0;
#line 491
    return;
  } else {

  }
#line 493
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.o.c.prepared"
void choose_timer_30(struct timer_list *timer ) 
{ 


  {
#line 497
  LDV_IN_INTERRUPT = 2;
#line 498
  (*(timer->function))(timer->data);
#line 499
  LDV_IN_INTERRUPT = 1;
#line 500
  ldv_timer_state_30 = 2;
#line 501
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.o.c.prepared"
int reg_timer_30(struct timer_list *timer ) 
{ 


  {
#line 505
  ldv_timer_list_30 = timer;
#line 506
  ldv_timer_state_30 = 1;
#line 507
  return (0);
}
}
#line 510 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.o.c.prepared"
void activate_pending_timer_30(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 510
  if ((unsigned long )ldv_timer_list_30 == (unsigned long )timer) {
#line 511
    if (ldv_timer_state_30 == 2 || pending_flag != 0) {
#line 512
      ldv_timer_list_30 = timer;
#line 513
      ldv_timer_list_30->data = data;
#line 514
      ldv_timer_state_30 = 1;
    } else {

    }
#line 516
    return;
  } else {

  }
#line 518
  reg_timer_30(timer);
#line 519
  ldv_timer_list_30->data = data;
#line 520
  return;
}
}
#line 546 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.o.c.prepared"
bool ldv_queue_work_on_315(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 550
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 550
  ldv_func_res = tmp;
#line 552
  activate_work_7(ldv_func_arg3, 2);
#line 554
  return (ldv_func_res);
}
}
#line 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.o.c.prepared"
bool ldv_queue_delayed_work_on_316(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 561
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 561
  ldv_func_res = tmp;
#line 563
  activate_work_7(& ldv_func_arg3->work, 2);
#line 565
  return (ldv_func_res);
}
}
#line 568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.o.c.prepared"
bool ldv_queue_work_on_317(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 572
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 572
  ldv_func_res = tmp;
#line 574
  activate_work_7(ldv_func_arg3, 2);
#line 576
  return (ldv_func_res);
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.o.c.prepared"
void ldv_flush_workqueue_318(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 582
  flush_workqueue(ldv_func_arg1);
#line 584
  call_and_disable_all_7(2);
#line 585
  return;
}
}
#line 587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.o.c.prepared"
bool ldv_queue_delayed_work_on_319(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 591
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 591
  ldv_func_res = tmp;
#line 593
  activate_work_7(& ldv_func_arg3->work, 2);
#line 595
  return (ldv_func_res);
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/qla2xxx/qla_tmpl.o.c.prepared"
int ldv_scsi_add_host_with_dma_320(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 602
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 602
  ldv_func_res = tmp;
#line 604
  if (ldv_func_res == 0) {
#line 605
    ldv_state_variable_88 = 1;
#line 605
    ldv_initialize_scsi_host_template_88();
  } else {

  }
#line 609
  return (ldv_func_res);
}
}
#line 8 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *memset(void * , int  , size_t  ) ;
#line 7 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err(void const   *ptr ) 
{ 


  {
#line 10
  return ((unsigned long )ptr > 2012UL);
}
}
#line 14 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 17
  return ((void *)(2012L - error));
}
}
#line 21 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 24
  return ((long )(2012UL - (unsigned long )ptr));
}
}
#line 28 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 31
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 31
    tmp___0 = 1;
  } else {
#line 31
    tmp = ldv_is_err(ptr);
#line 31
    if ((int )tmp) {
#line 31
      tmp___0 = 1;
    } else {
#line 31
      tmp___0 = 0;
    }
  }
#line 31
  return ((bool )tmp___0);
}
}
#line 7 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
int ldv_module_refcounter  =    1;
#line 10 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_module_get(struct module *module ) 
{ 


  {
#line 13
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 15
    ldv_module_refcounter = ldv_module_refcounter + 1;
  } else {

  }
#line 16
  return;
}
}
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
int ldv_try_module_get(struct module *module ) 
{ 
  int module_get_succeeded ;

  {
#line 25
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 28
    module_get_succeeded = ldv_undef_int();
#line 30
    if (module_get_succeeded == 1) {
#line 32
      ldv_module_refcounter = ldv_module_refcounter + 1;
#line 34
      return (1);
    } else {
#line 39
      return (0);
    }
  } else {

  }
#line 41
  return (0);
}
}
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_module_put(struct module *module ) 
{ 


  {
#line 48
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 50
    if (ldv_module_refcounter <= 1) {
#line 50
      ldv_error();
    } else {

    }
#line 52
    ldv_module_refcounter = ldv_module_refcounter - 1;
  } else {

  }
#line 54
  return;
}
}
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_module_put_and_exit(void) 
{ 


  {
#line 59
  ldv_module_put((struct module *)1);
  LDV_STOP: ;
#line 61
  goto LDV_STOP;
}
}
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
unsigned int ldv_module_refcount(void) 
{ 


  {
#line 68
  return ((unsigned int )(ldv_module_refcounter + -1));
}
}
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6010/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 75
  if (ldv_module_refcounter != 1) {
#line 75
    ldv_error();
  } else {

  }
#line 79
  return;
}
}
