extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 40 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 229 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 107 "include/linux/types.h"
typedef __u16 uint16_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 152 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 162 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 167 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 67 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 220 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 361
struct page;
#line 361 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 372
struct file;
#line 385
struct seq_file;
#line 423
struct thread_struct;
#line 425
struct mm_struct;
#line 426
struct task_struct;
#line 427
struct cpumask;
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};
#line 33 "include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;
#line 34 "include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 131 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 420 "include/linux/printk.h"
struct file_operations;
#line 432
struct completion;
#line 687 "include/linux/list.h"
struct lockdep_map;
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_15 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
#line 328 "include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 15 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 652 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 260 "./arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_25 {
   u64 rip ;
   u64 rdp ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_26 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_24 {
   struct __anonstruct____missing_field_name_25 __annonCompField11 ;
   struct __anonstruct____missing_field_name_26 __annonCompField12 ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_27 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_24 __annonCompField13 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_27 __annonCompField14 ;
};
#line 66 "./arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 155 "./arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 161 "./arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};
#line 179 "./arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
};
#line 193 "./arch/x86/include/asm/fpu/types.h"
struct fpu {
   union fpregs_state state ;
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
};
#line 170 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 369
struct perf_event;
#line 370 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct fpu fpu ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 28 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
   unsigned int pin_count ;
};
#line 546 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_31 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion____missing_field_name_30 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_31 __annonCompField16 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_30 __annonCompField17 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_32 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_32 rwlock_t;
#line 13 "include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 39 "include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
struct timespec;
#line 187
struct compat_timespec;
#line 188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
struct __anonstruct_futex_34 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
struct __anonstruct_nanosleep_35 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 188
struct pollfd;
#line 188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
struct __anonstruct_poll_36 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
union __anonunion____missing_field_name_33 {
   struct __anonstruct_futex_34 futex ;
   struct __anonstruct_nanosleep_35 nanosleep ;
   struct __anonstruct_poll_36 poll ;
};
#line 188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_33 __annonCompField18 ;
};
#line 426 "include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 52 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 404 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 404 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
#line 598 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 13 "include/uapi/linux/time.h"
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
#line 437 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 106 "include/linux/debugobjects.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 238 "include/linux/timer.h"
struct hrtimer;
#line 239
enum hrtimer_restart;
#line 38 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 1170 "include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 296 "include/linux/rcupdate.h"
struct notifier_block;
#line 1120 "include/linux/rcupdate.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 41 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 838 "include/uapi/linux/sysctl.h"
struct nsproxy;
#line 259 "include/linux/timer.h"
struct workqueue_struct;
#line 260
struct work_struct;
#line 54 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 107 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 616
struct vm_area_struct;
#line 95 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_48 {
   unsigned long bits[16U] ;
};
#line 95 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_48 nodemask_t;
#line 796 "include/linux/mmzone.h"
struct rw_semaphore;
#line 797 "include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 51 "include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 64 "./arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 172 "./arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 336
struct wake_irq;
#line 338 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 615 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
   int (*activate)(struct device * ) ;
   void (*sync)(struct device * ) ;
   void (*dismiss)(struct device * ) ;
};
#line 133 "./arch/x86/include/asm/topology.h"
struct pci_bus;
#line 24 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_113 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_113 mm_context_t;
#line 1281 "include/linux/mmzone.h"
struct llist_node;
#line 1281 "include/linux/mmzone.h"
struct llist_head {
   struct llist_node *first ;
};
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 60 "include/linux/kmemleak.h"
struct kmem_cache;
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 33
struct inode;
#line 34
struct dentry;
#line 35
struct user_namespace;
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_146 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_147 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_145 {
   struct __anonstruct____missing_field_name_146 __annonCompField33 ;
   struct __anonstruct____missing_field_name_147 __annonCompField34 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_145 __annonCompField35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134
struct mem_cgroup;
#line 31 "include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_148 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_150 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_154 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_153 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_154 __annonCompField38 ;
   int units ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_152 {
   union __anonunion____missing_field_name_153 __annonCompField39 ;
   atomic_t _count ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_151 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_152 __annonCompField40 ;
   unsigned int active ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_149 {
   union __anonunion____missing_field_name_150 __annonCompField37 ;
   union __anonunion____missing_field_name_151 __annonCompField41 ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_156 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_157 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_155 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_156 __annonCompField43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_157 __annonCompField44 ;
   pgtable_t pmd_huge_pte ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_158 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_148 __annonCompField36 ;
   struct __anonstruct____missing_field_name_149 __annonCompField42 ;
   union __anonunion____missing_field_name_155 __annonCompField45 ;
   union __anonunion____missing_field_name_158 __annonCompField46 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 266 "include/linux/mm_types.h"
struct __anonstruct_shared_159 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 266
struct anon_vma;
#line 266
struct vm_operations_struct;
#line 266
struct mempolicy;
#line 266 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_159 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 334 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 340 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 353 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 361 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 366
struct kioctx_table;
#line 367
struct linux_binfmt;
#line 367
struct mmu_notifier_mm;
#line 367 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_161 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_161 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_162 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_162 kgid_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 78 "include/uapi/linux/shm.h"
struct user_struct;
#line 26 "include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_163 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_163 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_165 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_166 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_167 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_168 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_170 {
   void *_lower ;
   void *_upper ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_169 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_170 _addr_bnd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_171 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_172 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_164 {
   int _pad[28U] ;
   struct __anonstruct__kill_165 _kill ;
   struct __anonstruct__timer_166 _timer ;
   struct __anonstruct__rt_167 _rt ;
   struct __anonstruct__sigchld_168 _sigchld ;
   struct __anonstruct__sigfault_169 _sigfault ;
   struct __anonstruct__sigpoll_171 _sigpoll ;
   struct __anonstruct__sigsys_172 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_164 _sifields ;
};
#line 113 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 443
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 450
struct pid_namespace;
#line 450 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 53 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 20 "include/linux/rtmutex.h"
struct rt_mutex {
   raw_spinlock_t wait_lock ;
   struct rb_root waiters ;
   struct rb_node *waiters_leftmost ;
   struct task_struct *owner ;
   int save_state ;
   char const   *name ;
   char const   *file ;
   int line ;
   void *magic ;
};
#line 40
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 123 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};
#line 156 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned char in_hrtirq : 1 ;
   unsigned char hres_active : 1 ;
   unsigned char hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 466 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct cred;
#line 38
struct key_type;
#line 42 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_179 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_180 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct____missing_field_name_182 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_181 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_182 __annonCompField49 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_183 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_185 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_184 {
   union __anonunion_payload_185 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_179 __annonCompField47 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_180 __annonCompField48 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_181 __annonCompField50 ;
   union __anonunion_type_data_183 type_data ;
   union __anonunion____missing_field_name_184 __annonCompField51 ;
};
#line 358
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 90 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 369 "include/linux/cred.h"
union __anonunion____missing_field_name_186 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 369 "include/linux/cred.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_186 __annonCompField52 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct percpu_ref;
#line 55 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 68 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
#line 27 "include/linux/percpu-rwsem.h"
struct cgroup;
#line 28
struct cgroup_root;
#line 29
struct cgroup_subsys;
#line 30
struct cgroup_taskset;
#line 31
struct kernfs_node;
#line 32
struct kernfs_ops;
#line 33
struct kernfs_open_file;
#line 75 "include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 124 "include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 197 "include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
#line 270
struct kernfs_root;
#line 270 "include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 306 "include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 388 "include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
#line 128 "include/linux/sched.h"
struct futex_pi_state;
#line 129
struct robust_list_head;
#line 130
struct bio_list;
#line 131
struct fs_struct;
#line 132
struct perf_event_context;
#line 133
struct blk_plug;
#line 135
struct nameidata;
#line 188
struct cfs_rq;
#line 189
struct task_group;
#line 477 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 516 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 524 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 531 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 543 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 563 "include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
#line 584 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};
#line 620
struct autogroup;
#line 621
struct tty_struct;
#line 621
struct taskstats;
#line 621
struct tty_audit_buf;
#line 621 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 790 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 833
struct backing_dev_info;
#line 834
struct reclaim_state;
#line 835 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 849 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 897 "include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};
#line 1126
struct io_context;
#line 1160
struct pipe_inode_info;
#line 1162 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1169 "include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};
#line 1194 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1229 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1261
struct rt_rq;
#line 1261 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1277 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1343 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1769
struct sched_class;
#line 1769
struct files_struct;
#line 1769
struct compat_robust_list_head;
#line 1769
struct numa_group;
#line 1769 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char sched_migrated : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned char brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
};
#line 599 "include/linux/slab.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
struct fb_var_screeninfo;
#line 173
struct drm_connector;
#line 176
struct fb_info;
#line 177
struct drm_encoder;
#line 178
struct gma_clock_t;
#line 179
struct drm_device;
#line 188
struct drm_crtc;
#line 189
struct drm_file;
#line 194
struct drm_framebuffer;
#line 226
struct drm_display_mode;
#line 261
struct i2c_adapter;
#line 135 "./arch/x86/include/uapi/asm/stat.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "include/linux/elf.h"
struct iattr;
#line 54
struct super_block;
#line 55
struct file_system_type;
#line 56
struct kernfs_open_node;
#line 57
struct kernfs_iattrs;
#line 80 "include/linux/elf.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 96 "include/linux/kernfs.h"
union __anonunion____missing_field_name_209 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 96 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_209 __annonCompField56 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 138 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 155 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 171 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 188 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 477
struct sock;
#line 478
struct kobject;
#line 479
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 485 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 59 "include/linux/kobject_ns.h"
struct bin_attribute;
#line 60 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 82 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 155 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 509 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct kernel_param;
#line 227 "include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_210 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct module *mod ;
   struct kernel_param_ops  const  *ops ;
   u16 const   perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_210 __annonCompField57 ;
};
#line 83 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 89 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 469 "include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};
#line 211 "include/linux/rbtree_latch.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 47 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 73
struct exception_table_entry;
#line 206
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 213 "include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
#line 220
struct module_sect_attrs;
#line 220
struct module_notes_attrs;
#line 220
struct tracepoint;
#line 220
struct trace_event_call;
#line 220
struct trace_enum_map;
#line 220 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 93 "include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
#line 27 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 64 "include/linux/page_ext.h"
struct file_ra_state;
#line 65
struct writeback_control;
#line 66
struct bdi_writeback;
#line 207 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 239 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*pfn_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_node;
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_220 {
   spinlock_t lock ;
   int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion____missing_field_name_219 {
   struct __anonstruct____missing_field_name_220 __annonCompField58 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_219 __annonCompField59 ;
};
#line 50 "include/linux/lockref.h"
struct path;
#line 51
struct vfsmount;
#line 52 "include/linux/lockref.h"
struct __anonstruct____missing_field_name_222 {
   u32 hash ;
   u32 len ;
};
#line 52 "include/linux/lockref.h"
union __anonunion____missing_field_name_221 {
   struct __anonstruct____missing_field_name_222 __annonCompField60 ;
   u64 hash_len ;
};
#line 52 "include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_221 __annonCompField61 ;
   unsigned char const   *name ;
};
#line 90 "include/linux/dcache.h"
struct dentry_operations;
#line 90 "include/linux/dcache.h"
union __anonunion_d_u_223 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
#line 90 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_223 d_u ;
};
#line 142 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
   struct inode *(*d_select_inode)(struct dentry * , unsigned int  ) ;
};
#line 585 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 27 "include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 32 "include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
#line 37 "include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
#line 47 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
#line 58 "include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_227 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "include/linux/radix-tree.h"
union __anonunion____missing_field_name_226 {
   struct __anonstruct____missing_field_name_227 __annonCompField62 ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_226 __annonCompField63 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "./include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 47
struct block_device;
#line 60 "include/uapi/linux/fs.h"
struct export_operations;
#line 63
struct kiocb;
#line 64
struct poll_table_struct;
#line 65
struct kstatfs;
#line 66
struct swap_info_struct;
#line 67
struct iov_iter;
#line 74 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 212 "./include/uapi/linux/dqblk_xfs.h"
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "include/linux/projid.h"
struct __anonstruct_kprojid_t_231 {
   projid_t val ;
};
#line 23 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_231 kprojid_t;
#line 166 "include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 66 "include/linux/quota.h"
typedef long long qsize_t;
#line 67 "include/linux/quota.h"
union __anonunion____missing_field_name_232 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 67 "include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_232 __annonCompField65 ;
   enum quota_type type ;
};
#line 184 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 206
struct quota_format_type;
#line 207 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 272 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 299 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 310 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
   int (*get_projid)(struct inode * , kprojid_t * ) ;
};
#line 325 "include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 348 "include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
#line 394 "include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};
#line 405 "include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};
#line 418 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*set_info)(struct super_block * , int  , struct qc_info * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_state)(struct super_block * , struct qc_state * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 432 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 496 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops  const  *ops[3U] ;
};
#line 526 "include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb * , long  , long  ) ;
   void *private ;
   int ki_flags ;
};
#line 365 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 422 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 442
struct request_queue;
#line 443
struct hd_struct;
#line 443
struct gendisk;
#line 443 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 559
struct posix_acl;
#line 560
struct inode_operations;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_235 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_236 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 560
struct file_lock_context;
#line 560
struct cdev;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_237 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};
#line 560 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_235 __annonCompField66 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_236 __annonCompField67 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_237 __annonCompField68 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 806 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 814 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 837 "include/linux/fs.h"
union __anonunion_f_u_238 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 837 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_238 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 922 "include/linux/fs.h"
typedef void *fl_owner_t;
#line 923
struct file_lock;
#line 924 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 930 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t  ) ;
   void (*lm_put_owner)(fl_owner_t  ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
#line 951
struct nlm_lockowner;
#line 952 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_240 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_239 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_240 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_239 fl_u ;
};
#line 1004 "include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1062 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1240 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1271
struct super_operations;
#line 1271
struct xattr_handler;
#line 1271
struct mtd_info;
#line 1271 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
#line 1510 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1524
struct dir_context;
#line 1549 "include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1556 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1617 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   char const   *(*follow_link)(struct dentry * , void ** ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct inode * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1671 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
#line 1910 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 6 "./include/uapi/asm-generic/termbits.h"
typedef unsigned char cc_t;
#line 7 "./include/uapi/asm-generic/termbits.h"
typedef unsigned int speed_t;
#line 8 "./include/uapi/asm-generic/termbits.h"
typedef unsigned int tcflag_t;
#line 30 "./include/uapi/asm-generic/termbits.h"
struct ktermios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[19U] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 41 "./include/uapi/asm-generic/termbits.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 93 "include/asm-generic/termios.h"
struct termiox {
   __u16 x_hflag ;
   __u16 x_cflag ;
   __u16 x_rflag[5U] ;
   __u16 x_sflag ;
};
#line 16 "./include/uapi/linux/termios.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
#line 32 "include/linux/cdev.h"
struct tty_driver;
#line 33
struct serial_icounter_struct;
#line 34 "include/linux/cdev.h"
struct tty_operations {
   struct tty_struct *(*lookup)(struct tty_driver * , struct inode * , int  ) ;
   int (*install)(struct tty_driver * , struct tty_struct * ) ;
   void (*remove)(struct tty_driver * , struct tty_struct * ) ;
   int (*open)(struct tty_struct * , struct file * ) ;
   void (*close)(struct tty_struct * , struct file * ) ;
   void (*shutdown)(struct tty_struct * ) ;
   void (*cleanup)(struct tty_struct * ) ;
   int (*write)(struct tty_struct * , unsigned char const   * , int  ) ;
   int (*put_char)(struct tty_struct * , unsigned char  ) ;
   void (*flush_chars)(struct tty_struct * ) ;
   int (*write_room)(struct tty_struct * ) ;
   int (*chars_in_buffer)(struct tty_struct * ) ;
   int (*ioctl)(struct tty_struct * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct tty_struct * , unsigned int  , unsigned long  ) ;
   void (*set_termios)(struct tty_struct * , struct ktermios * ) ;
   void (*throttle)(struct tty_struct * ) ;
   void (*unthrottle)(struct tty_struct * ) ;
   void (*stop)(struct tty_struct * ) ;
   void (*start)(struct tty_struct * ) ;
   void (*hangup)(struct tty_struct * ) ;
   int (*break_ctl)(struct tty_struct * , int  ) ;
   void (*flush_buffer)(struct tty_struct * ) ;
   void (*set_ldisc)(struct tty_struct * ) ;
   void (*wait_until_sent)(struct tty_struct * , int  ) ;
   void (*send_xchar)(struct tty_struct * , char  ) ;
   int (*tiocmget)(struct tty_struct * ) ;
   int (*tiocmset)(struct tty_struct * , unsigned int  , unsigned int  ) ;
   int (*resize)(struct tty_struct * , struct winsize * ) ;
   int (*set_termiox)(struct tty_struct * , struct termiox * ) ;
   int (*get_icount)(struct tty_struct * , struct serial_icounter_struct * ) ;
   int (*poll_init)(struct tty_driver * , int  , char * ) ;
   int (*poll_get_char)(struct tty_driver * , int  ) ;
   void (*poll_put_char)(struct tty_driver * , int  , char  ) ;
   struct file_operations  const  *proc_fops ;
};
#line 295 "include/linux/tty_driver.h"
struct proc_dir_entry;
#line 295
struct tty_port;
#line 295 "include/linux/tty_driver.h"
struct tty_driver {
   int magic ;
   struct kref kref ;
   struct cdev *cdevs ;
   struct module *owner ;
   char const   *driver_name ;
   char const   *name ;
   int name_base ;
   int major ;
   int minor_start ;
   unsigned int num ;
   short type ;
   short subtype ;
   struct ktermios init_termios ;
   unsigned long flags ;
   struct proc_dir_entry *proc_entry ;
   struct tty_driver *other ;
   struct tty_struct **ttys ;
   struct tty_port **ports ;
   struct ktermios **termios ;
   void *driver_state ;
   struct tty_operations  const  *ops ;
   struct list_head tty_drivers ;
};
#line 362 "include/linux/tty_driver.h"
struct ld_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   unsigned int wait_readers ;
   struct list_head read_wait ;
   struct list_head write_wait ;
   struct lockdep_map dep_map ;
};
#line 170 "include/linux/tty_ldisc.h"
struct tty_ldisc_ops {
   int magic ;
   char *name ;
   int num ;
   int flags ;
   int (*open)(struct tty_struct * ) ;
   void (*close)(struct tty_struct * ) ;
   void (*flush_buffer)(struct tty_struct * ) ;
   ssize_t (*chars_in_buffer)(struct tty_struct * ) ;
   ssize_t (*read)(struct tty_struct * , struct file * , unsigned char * , size_t  ) ;
   ssize_t (*write)(struct tty_struct * , struct file * , unsigned char const   * ,
                    size_t  ) ;
   int (*ioctl)(struct tty_struct * , struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct tty_struct * , struct file * , unsigned int  , unsigned long  ) ;
   void (*set_termios)(struct tty_struct * , struct ktermios * ) ;
   unsigned int (*poll)(struct tty_struct * , struct file * , struct poll_table_struct * ) ;
   int (*hangup)(struct tty_struct * ) ;
   void (*receive_buf)(struct tty_struct * , unsigned char const   * , char * , int  ) ;
   void (*write_wakeup)(struct tty_struct * ) ;
   void (*dcd_change)(struct tty_struct * , unsigned int  ) ;
   void (*fasync)(struct tty_struct * , int  ) ;
   int (*receive_buf2)(struct tty_struct * , unsigned char const   * , char * , int  ) ;
   struct module *owner ;
   int refcount ;
};
#line 220 "include/linux/tty_ldisc.h"
struct tty_ldisc {
   struct tty_ldisc_ops *ops ;
   struct tty_struct *tty ;
};
#line 230 "include/linux/tty_ldisc.h"
union __anonunion____missing_field_name_241 {
   struct tty_buffer *next ;
   struct llist_node free ;
};
#line 230 "include/linux/tty_ldisc.h"
struct tty_buffer {
   union __anonunion____missing_field_name_241 __annonCompField69 ;
   int used ;
   int size ;
   int commit ;
   int read ;
   int flags ;
   unsigned long data[0U] ;
};
#line 82 "include/linux/tty.h"
struct tty_bufhead {
   struct tty_buffer *head ;
   struct work_struct work ;
   struct mutex lock ;
   atomic_t priority ;
   struct tty_buffer sentinel ;
   struct llist_head free ;
   atomic_t mem_used ;
   int mem_limit ;
   struct tty_buffer *tail ;
};
#line 94 "include/linux/tty.h"
struct tty_port_operations {
   int (*carrier_raised)(struct tty_port * ) ;
   void (*dtr_rts)(struct tty_port * , int  ) ;
   void (*shutdown)(struct tty_port * ) ;
   int (*activate)(struct tty_port * , struct tty_struct * ) ;
   void (*destruct)(struct tty_port * ) ;
};
#line 220 "include/linux/tty.h"
struct tty_port {
   struct tty_bufhead buf ;
   struct tty_struct *tty ;
   struct tty_struct *itty ;
   struct tty_port_operations  const  *ops ;
   spinlock_t lock ;
   int blocked_open ;
   int count ;
   wait_queue_head_t open_wait ;
   wait_queue_head_t close_wait ;
   wait_queue_head_t delta_msr_wait ;
   unsigned long flags ;
   unsigned char console : 1 ;
   unsigned char low_latency : 1 ;
   struct mutex mutex ;
   struct mutex buf_mutex ;
   unsigned char *xmit_buf ;
   unsigned int close_delay ;
   unsigned int closing_wait ;
   int drain_delay ;
   struct kref kref ;
};
#line 245 "include/linux/tty.h"
struct tty_struct {
   int magic ;
   struct kref kref ;
   struct device *dev ;
   struct tty_driver *driver ;
   struct tty_operations  const  *ops ;
   int index ;
   struct ld_semaphore ldisc_sem ;
   struct tty_ldisc *ldisc ;
   struct mutex atomic_write_lock ;
   struct mutex legacy_mutex ;
   struct mutex throttle_mutex ;
   struct rw_semaphore termios_rwsem ;
   struct mutex winsize_mutex ;
   spinlock_t ctrl_lock ;
   spinlock_t flow_lock ;
   struct ktermios termios ;
   struct ktermios termios_locked ;
   struct termiox *termiox ;
   char name[64U] ;
   struct pid *pgrp ;
   struct pid *session ;
   unsigned long flags ;
   int count ;
   struct winsize winsize ;
   unsigned char stopped : 1 ;
   unsigned char flow_stopped : 1 ;
   unsigned long unused : 62 ;
   int hw_stopped ;
   unsigned char ctrl_status ;
   unsigned char packet : 1 ;
   unsigned long unused_ctrl : 55 ;
   unsigned int receive_room ;
   int flow_change ;
   struct tty_struct *link ;
   struct fasync_struct *fasync ;
   int alt_speed ;
   wait_queue_head_t write_wait ;
   wait_queue_head_t read_wait ;
   struct work_struct hangup_work ;
   void *disc_data ;
   void *driver_data ;
   struct list_head tty_files ;
   int closing ;
   unsigned char *write_buf ;
   int write_cnt ;
   struct work_struct SAK_work ;
   struct tty_port *port ;
};
#line 405
struct class;
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 14 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 474 "include/linux/mod_devicetable.h"
struct platform_device_id {
   char name[20U] ;
   kernel_ulong_t driver_data ;
};
#line 650
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 187
struct pinctrl;
#line 188
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 48 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 48 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 11 "./arch/x86/include/asm/device.h"
struct pdev_archdata {

};
#line 14
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct subsys_private;
#line 18
struct bus_type;
#line 19
struct device_node;
#line 20
struct fwnode_handle;
#line 21
struct iommu_ops;
#line 22
struct iommu_group;
#line 61 "include/linux/device.h"
struct device_attribute;
#line 61 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 139
struct device_type;
#line 197
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
} ;
#line 203 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 353
struct class_attribute;
#line 353 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 446 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 514 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 542 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 674 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 683
struct dma_coherent_mem;
#line 683
struct cma;
#line 683 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 829 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 1273
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
} ;
#line 1280 "include/linux/device.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};
#line 32 "include/linux/of.h"
typedef u32 phandle;
#line 34 "include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};
#line 44 "include/linux/of.h"
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char const   *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};
#line 1084 "include/linux/of.h"
struct i2c_msg {
   __u16 addr ;
   __u16 flags ;
   __u16 len ;
   __u8 *buf ;
};
#line 82 "include/uapi/linux/i2c.h"
union i2c_smbus_data {
   __u8 byte ;
   __u16 word ;
   __u8 block[34U] ;
};
#line 39 "include/linux/i2c.h"
struct i2c_algorithm;
#line 40
struct i2c_client;
#line 43
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 196 "include/linux/i2c.h"
struct i2c_client {
   unsigned short flags ;
   unsigned short addr ;
   char name[20U] ;
   struct i2c_adapter *adapter ;
   struct device dev ;
   int irq ;
   struct list_head detected ;
   int (*slave_cb)(struct i2c_client * , enum i2c_slave_event  , u8 * ) ;
};
#line 251
enum i2c_slave_event {
    I2C_SLAVE_READ_REQUESTED = 0,
    I2C_SLAVE_WRITE_REQUESTED = 1,
    I2C_SLAVE_READ_PROCESSED = 2,
    I2C_SLAVE_WRITE_RECEIVED = 3,
    I2C_SLAVE_STOP = 4
} ;
#line 359 "include/linux/i2c.h"
struct i2c_algorithm {
   int (*master_xfer)(struct i2c_adapter * , struct i2c_msg * , int  ) ;
   int (*smbus_xfer)(struct i2c_adapter * , u16  , unsigned short  , char  , u8  ,
                     int  , union i2c_smbus_data * ) ;
   u32 (*functionality)(struct i2c_adapter * ) ;
   int (*reg_slave)(struct i2c_client * ) ;
   int (*unreg_slave)(struct i2c_client * ) ;
};
#line 411 "include/linux/i2c.h"
struct i2c_bus_recovery_info {
   int (*recover_bus)(struct i2c_adapter * ) ;
   int (*get_scl)(struct i2c_adapter * ) ;
   void (*set_scl)(struct i2c_adapter * , int  ) ;
   int (*get_sda)(struct i2c_adapter * ) ;
   void (*prepare_recovery)(struct i2c_adapter * ) ;
   void (*unprepare_recovery)(struct i2c_adapter * ) ;
   int scl_gpio ;
   int sda_gpio ;
};
#line 451 "include/linux/i2c.h"
struct i2c_adapter_quirks {
   u64 flags ;
   int max_num_msgs ;
   u16 max_write_len ;
   u16 max_read_len ;
   u16 max_comb_1st_msg_len ;
   u16 max_comb_2nd_msg_len ;
};
#line 481 "include/linux/i2c.h"
struct i2c_adapter {
   struct module *owner ;
   unsigned int class ;
   struct i2c_algorithm  const  *algo ;
   void *algo_data ;
   struct rt_mutex bus_lock ;
   int timeout ;
   int retries ;
   struct device dev ;
   int nr ;
   char name[48U] ;
   struct completion dev_released ;
   struct mutex userspace_clients_lock ;
   struct list_head userspace_clients ;
   struct i2c_bus_recovery_info *bus_recovery_info ;
   struct i2c_adapter_quirks  const  *quirks ;
};
#line 640 "include/linux/i2c.h"
struct fb_fix_screeninfo {
   char id[16U] ;
   unsigned long smem_start ;
   __u32 smem_len ;
   __u32 type ;
   __u32 type_aux ;
   __u32 visual ;
   __u16 xpanstep ;
   __u16 ypanstep ;
   __u16 ywrapstep ;
   __u32 line_length ;
   unsigned long mmio_start ;
   __u32 mmio_len ;
   __u32 accel ;
   __u16 capabilities ;
   __u16 reserved[2U] ;
};
#line 176 "include/uapi/linux/fb.h"
struct fb_bitfield {
   __u32 offset ;
   __u32 length ;
   __u32 msb_right ;
};
#line 192 "include/uapi/linux/fb.h"
struct fb_var_screeninfo {
   __u32 xres ;
   __u32 yres ;
   __u32 xres_virtual ;
   __u32 yres_virtual ;
   __u32 xoffset ;
   __u32 yoffset ;
   __u32 bits_per_pixel ;
   __u32 grayscale ;
   struct fb_bitfield red ;
   struct fb_bitfield green ;
   struct fb_bitfield blue ;
   struct fb_bitfield transp ;
   __u32 nonstd ;
   __u32 activate ;
   __u32 height ;
   __u32 width ;
   __u32 accel_flags ;
   __u32 pixclock ;
   __u32 left_margin ;
   __u32 right_margin ;
   __u32 upper_margin ;
   __u32 lower_margin ;
   __u32 hsync_len ;
   __u32 vsync_len ;
   __u32 sync ;
   __u32 vmode ;
   __u32 rotate ;
   __u32 colorspace ;
   __u32 reserved[4U] ;
};
#line 279 "include/uapi/linux/fb.h"
struct fb_cmap {
   __u32 start ;
   __u32 len ;
   __u16 *red ;
   __u16 *green ;
   __u16 *blue ;
   __u16 *transp ;
};
#line 335 "include/uapi/linux/fb.h"
struct fb_copyarea {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 sx ;
   __u32 sy ;
};
#line 348 "include/uapi/linux/fb.h"
struct fb_fillrect {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 color ;
   __u32 rop ;
};
#line 357 "include/uapi/linux/fb.h"
struct fb_image {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 fg_color ;
   __u32 bg_color ;
   __u8 depth ;
   char const   *data ;
   struct fb_cmap cmap ;
};
#line 369 "include/uapi/linux/fb.h"
struct fbcurpos {
   __u16 x ;
   __u16 y ;
};
#line 385 "include/uapi/linux/fb.h"
struct fb_cursor {
   __u16 set ;
   __u16 enable ;
   __u16 rop ;
   char const   *mask ;
   struct fbcurpos hot ;
   struct fb_image image ;
};
#line 399
enum backlight_type {
    BACKLIGHT_RAW = 1,
    BACKLIGHT_PLATFORM = 2,
    BACKLIGHT_FIRMWARE = 3,
    BACKLIGHT_TYPE_MAX = 4
} ;
#line 411
struct backlight_device;
#line 412 "include/uapi/linux/fb.h"
struct backlight_ops {
   unsigned int options ;
   int (*update_status)(struct backlight_device * ) ;
   int (*get_brightness)(struct backlight_device * ) ;
   int (*check_fb)(struct backlight_device * , struct fb_info * ) ;
};
#line 65 "include/linux/backlight.h"
struct backlight_properties {
   int brightness ;
   int max_brightness ;
   int power ;
   int fb_blank ;
   enum backlight_type type ;
   unsigned int state ;
};
#line 84 "include/linux/backlight.h"
struct backlight_device {
   struct backlight_properties props ;
   struct mutex update_lock ;
   struct mutex ops_lock ;
   struct backlight_ops  const  *ops ;
   struct notifier_block fb_notif ;
   struct list_head entry ;
   struct device dev ;
   bool fb_bl_on[32U] ;
   int use_count ;
};
#line 167 "include/linux/backlight.h"
struct fb_chroma {
   __u32 redx ;
   __u32 greenx ;
   __u32 bluex ;
   __u32 whitex ;
   __u32 redy ;
   __u32 greeny ;
   __u32 bluey ;
   __u32 whitey ;
};
#line 61 "include/linux/fb.h"
struct fb_videomode;
#line 61 "include/linux/fb.h"
struct fb_monspecs {
   struct fb_chroma chroma ;
   struct fb_videomode *modedb ;
   __u8 manufacturer[4U] ;
   __u8 monitor[14U] ;
   __u8 serial_no[14U] ;
   __u8 ascii[14U] ;
   __u32 modedb_len ;
   __u32 model ;
   __u32 serial ;
   __u32 year ;
   __u32 week ;
   __u32 hfmin ;
   __u32 hfmax ;
   __u32 dclkmin ;
   __u32 dclkmax ;
   __u16 input ;
   __u16 dpms ;
   __u16 signal ;
   __u16 vfmin ;
   __u16 vfmax ;
   __u16 gamma ;
   unsigned char gtf : 1 ;
   __u16 misc ;
   __u8 version ;
   __u8 revision ;
   __u8 max_x ;
   __u8 max_y ;
};
#line 170 "include/linux/fb.h"
struct fb_blit_caps {
   u32 x ;
   u32 y ;
   u32 len ;
   u32 flags ;
};
#line 181 "include/linux/fb.h"
struct fb_pixmap {
   u8 *addr ;
   u32 size ;
   u32 offset ;
   u32 buf_align ;
   u32 scan_align ;
   u32 access_align ;
   u32 flags ;
   u32 blit_x ;
   u32 blit_y ;
   void (*writeio)(struct fb_info * , void * , void * , unsigned int  ) ;
   void (*readio)(struct fb_info * , void * , void * , unsigned int  ) ;
};
#line 210 "include/linux/fb.h"
struct fb_deferred_io {
   unsigned long delay ;
   struct mutex lock ;
   struct list_head pagelist ;
   void (*first_io)(struct fb_info * ) ;
   void (*deferred_io)(struct fb_info * , struct list_head * ) ;
};
#line 221 "include/linux/fb.h"
struct fb_ops {
   struct module *owner ;
   int (*fb_open)(struct fb_info * , int  ) ;
   int (*fb_release)(struct fb_info * , int  ) ;
   ssize_t (*fb_read)(struct fb_info * , char * , size_t  , loff_t * ) ;
   ssize_t (*fb_write)(struct fb_info * , char const   * , size_t  , loff_t * ) ;
   int (*fb_check_var)(struct fb_var_screeninfo * , struct fb_info * ) ;
   int (*fb_set_par)(struct fb_info * ) ;
   int (*fb_setcolreg)(unsigned int  , unsigned int  , unsigned int  , unsigned int  ,
                       unsigned int  , struct fb_info * ) ;
   int (*fb_setcmap)(struct fb_cmap * , struct fb_info * ) ;
   int (*fb_blank)(int  , struct fb_info * ) ;
   int (*fb_pan_display)(struct fb_var_screeninfo * , struct fb_info * ) ;
   void (*fb_fillrect)(struct fb_info * , struct fb_fillrect  const  * ) ;
   void (*fb_copyarea)(struct fb_info * , struct fb_copyarea  const  * ) ;
   void (*fb_imageblit)(struct fb_info * , struct fb_image  const  * ) ;
   int (*fb_cursor)(struct fb_info * , struct fb_cursor * ) ;
   void (*fb_rotate)(struct fb_info * , int  ) ;
   int (*fb_sync)(struct fb_info * ) ;
   int (*fb_ioctl)(struct fb_info * , unsigned int  , unsigned long  ) ;
   int (*fb_compat_ioctl)(struct fb_info * , unsigned int  , unsigned long  ) ;
   int (*fb_mmap)(struct fb_info * , struct vm_area_struct * ) ;
   void (*fb_get_caps)(struct fb_info * , struct fb_blit_caps * , struct fb_var_screeninfo * ) ;
   void (*fb_destroy)(struct fb_info * ) ;
   int (*fb_debug_enter)(struct fb_info * ) ;
   int (*fb_debug_leave)(struct fb_info * ) ;
};
#line 309 "include/linux/fb.h"
struct fb_tilemap {
   __u32 width ;
   __u32 height ;
   __u32 depth ;
   __u32 length ;
   __u8 const   *data ;
};
#line 325 "include/linux/fb.h"
struct fb_tilerect {
   __u32 sx ;
   __u32 sy ;
   __u32 width ;
   __u32 height ;
   __u32 index ;
   __u32 fg ;
   __u32 bg ;
   __u32 rop ;
};
#line 337 "include/linux/fb.h"
struct fb_tilearea {
   __u32 sx ;
   __u32 sy ;
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
};
#line 346 "include/linux/fb.h"
struct fb_tileblit {
   __u32 sx ;
   __u32 sy ;
   __u32 width ;
   __u32 height ;
   __u32 fg ;
   __u32 bg ;
   __u32 length ;
   __u32 *indices ;
};
#line 357 "include/linux/fb.h"
struct fb_tilecursor {
   __u32 sx ;
   __u32 sy ;
   __u32 mode ;
   __u32 shape ;
   __u32 fg ;
   __u32 bg ;
};
#line 366 "include/linux/fb.h"
struct fb_tile_ops {
   void (*fb_settile)(struct fb_info * , struct fb_tilemap * ) ;
   void (*fb_tilecopy)(struct fb_info * , struct fb_tilearea * ) ;
   void (*fb_tilefill)(struct fb_info * , struct fb_tilerect * ) ;
   void (*fb_tileblit)(struct fb_info * , struct fb_tileblit * ) ;
   void (*fb_tilecursor)(struct fb_info * , struct fb_tilecursor * ) ;
   int (*fb_get_tilemax)(struct fb_info * ) ;
};
#line 385 "include/linux/fb.h"
struct aperture {
   resource_size_t base ;
   resource_size_t size ;
};
#line 504 "include/linux/fb.h"
struct apertures_struct {
   unsigned int count ;
   struct aperture ranges[0U] ;
};
#line 505 "include/linux/fb.h"
struct fb_info {
   atomic_t count ;
   int node ;
   int flags ;
   struct mutex lock ;
   struct mutex mm_lock ;
   struct fb_var_screeninfo var ;
   struct fb_fix_screeninfo fix ;
   struct fb_monspecs monspecs ;
   struct work_struct queue ;
   struct fb_pixmap pixmap ;
   struct fb_pixmap sprite ;
   struct fb_cmap cmap ;
   struct list_head modelist ;
   struct fb_videomode *mode ;
   struct backlight_device *bl_dev ;
   struct mutex bl_curve_mutex ;
   u8 bl_curve[128U] ;
   struct delayed_work deferred_work ;
   struct fb_deferred_io *fbdefio ;
   struct fb_ops *fbops ;
   struct device *device ;
   struct device *dev ;
   int class_flag ;
   struct fb_tile_ops *tileops ;
   char *screen_base ;
   unsigned long screen_size ;
   void *pseudo_palette ;
   u32 state ;
   void *fbcon_par ;
   void *par ;
   struct apertures_struct *apertures ;
   bool skip_vt_switch ;
};
#line 764 "include/linux/fb.h"
struct fb_videomode {
   char const   *name ;
   u32 refresh ;
   u32 xres ;
   u32 yres ;
   u32 pixclock ;
   u32 left_margin ;
   u32 right_margin ;
   u32 upper_margin ;
   u32 lower_margin ;
   u32 hsync_len ;
   u32 vsync_len ;
   u32 sync ;
   u32 vmode ;
   u32 flag ;
};
#line 193 "include/linux/console.h"
enum chipset_type {
    NOT_SUPPORTED = 0,
    SUPPORTED = 1
} ;
#line 198 "include/linux/console.h"
struct agp_version {
   u16 major ;
   u16 minor ;
};
#line 44 "include/linux/agp_backend.h"
struct agp_kern_info {
   struct agp_version version ;
   struct pci_dev *device ;
   enum chipset_type chipset ;
   unsigned long mode ;
   unsigned long aper_base ;
   size_t aper_size ;
   int max_memory ;
   int current_memory ;
   bool cant_use_aperture ;
   unsigned long page_mask ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 58
struct agp_bridge_data;
#line 59
struct scatterlist;
#line 119 "include/linux/agp_backend.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 21 "include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 380 "include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 70 "include/linux/resource_ext.h"
struct hotplug_slot;
#line 70 "include/linux/resource_ext.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 110 "include/linux/pci.h"
typedef int pci_power_t;
#line 137 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 138
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 163 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 190 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 247
struct pcie_link_state;
#line 248
struct pci_vpd;
#line 249
struct pci_sriov;
#line 250
struct pci_ats;
#line 251
struct pci_driver;
#line 251 "include/linux/pci.h"
union __anonunion____missing_field_name_254 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 251 "include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned char ignore_hotplug : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char no_64bit_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   unsigned char irq_managed : 1 ;
   unsigned char has_secondary_link : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group  const  **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion____missing_field_name_254 __annonCompField77 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};
#line 440
struct pci_ops;
#line 440
struct msi_controller;
#line 440 "include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
#line 563 "include/linux/pci.h"
struct pci_ops {
   void *(*map_bus)(struct pci_bus * , unsigned int  , int  ) ;
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 591 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 605 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 615 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*reset_notify)(struct pci_dev * , bool  ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 648 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 1908
struct mfd_cell;
#line 1909 "include/linux/pci.h"
struct platform_device {
   char const   *name ;
   int id ;
   bool id_auto ;
   struct device dev ;
   u32 num_resources ;
   struct resource *resource ;
   struct platform_device_id  const  *id_entry ;
   char *driver_override ;
   struct mfd_cell *mfd_cell ;
   struct pdev_archdata archdata ;
};
#line 338 "include/linux/platform_device.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 32 "include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 74 "include/uapi/drm/drm.h"
typedef unsigned int drm_magic_t;
#line 75 "include/uapi/drm/drm.h"
struct drm_clip_rect {
   unsigned short x1 ;
   unsigned short y1 ;
   unsigned short x2 ;
   unsigned short y2 ;
};
#line 110 "include/uapi/drm/drm.h"
struct drm_hw_lock {
   unsigned int volatile   lock ;
   char padding[60U] ;
};
#line 337 "./include/uapi/drm/drm_mode.h"
struct drm_mode_fb_cmd2 {
   __u32 fb_id ;
   __u32 width ;
   __u32 height ;
   __u32 pixel_format ;
   __u32 flags ;
   __u32 handles[4U] ;
   __u32 pitches[4U] ;
   __u32 offsets[4U] ;
   __u64 modifier[4U] ;
};
#line 508 "./include/uapi/drm/drm_mode.h"
struct drm_mode_create_dumb {
   uint32_t height ;
   uint32_t width ;
   uint32_t bpp ;
   uint32_t flags ;
   uint32_t handle ;
   uint32_t pitch ;
   uint64_t size ;
};
#line 580 "./include/uapi/drm/drm_mode.h"
struct drm_event {
   __u32 type ;
   __u32 length ;
};
#line 819 "include/uapi/drm/drm.h"
struct drm_event_vblank {
   struct drm_event base ;
   __u64 user_data ;
   __u32 tv_sec ;
   __u32 tv_usec ;
   __u32 sequence ;
   __u32 reserved ;
};
#line 831 "include/uapi/drm/drm.h"
struct drm_agp_head {
   struct agp_kern_info agp_info ;
   struct list_head memory ;
   unsigned long mode ;
   struct agp_bridge_data *bridge ;
   int enabled ;
   int acquired ;
   unsigned long base ;
   int agp_mtrr ;
   int cant_use_aperture ;
   unsigned long page_mask ;
};
#line 76 "include/linux/hdmi.h"
enum hdmi_picture_aspect {
    HDMI_PICTURE_ASPECT_NONE = 0,
    HDMI_PICTURE_ASPECT_4_3 = 1,
    HDMI_PICTURE_ASPECT_16_9 = 2,
    HDMI_PICTURE_ASPECT_RESERVED = 3
} ;
#line 334 "include/linux/hdmi.h"
struct ww_class {
   atomic_long_t stamp ;
   struct lock_class_key acquire_key ;
   struct lock_class_key mutex_key ;
   char const   *acquire_name ;
   char const   *mutex_name ;
};
#line 26 "include/linux/ww_mutex.h"
struct ww_mutex;
#line 26 "include/linux/ww_mutex.h"
struct ww_acquire_ctx {
   struct task_struct *task ;
   unsigned long stamp ;
   unsigned int acquired ;
   unsigned int done_acquire ;
   struct ww_class *ww_class ;
   struct ww_mutex *contending_lock ;
   struct lockdep_map dep_map ;
   unsigned int deadlock_inject_interval ;
   unsigned int deadlock_inject_countdown ;
};
#line 43 "include/linux/ww_mutex.h"
struct ww_mutex {
   struct mutex base ;
   struct ww_acquire_ctx *ctx ;
   struct ww_class *ww_class ;
};
#line 377
struct drm_modeset_lock;
#line 378 "include/linux/ww_mutex.h"
struct drm_modeset_acquire_ctx {
   struct ww_acquire_ctx ww_ctx ;
   struct drm_modeset_lock *contended ;
   struct list_head locked ;
   bool trylock_only ;
};
#line 63 "include/drm/drm_modeset_lock.h"
struct drm_modeset_lock {
   struct ww_mutex mutex ;
   struct list_head head ;
};
#line 127
struct drm_plane;
#line 143
struct drm_mode_set;
#line 144
struct drm_object_properties;
#line 145
struct fence;
#line 146 "include/drm/drm_modeset_lock.h"
struct drm_mode_object {
   uint32_t id ;
   uint32_t type ;
   struct drm_object_properties *properties ;
};
#line 63 "include/drm/drm_crtc.h"
struct drm_property;
#line 63 "include/drm/drm_crtc.h"
struct drm_object_properties {
   int count ;
   int atomic_count ;
   struct drm_property *properties[24U] ;
   uint64_t values[24U] ;
};
#line 87
enum drm_connector_force {
    DRM_FORCE_UNSPECIFIED = 0,
    DRM_FORCE_OFF = 1,
    DRM_FORCE_ON = 2,
    DRM_FORCE_ON_DIGITAL = 3
} ;
#line 94
enum drm_mode_status {
    MODE_OK = 0,
    MODE_HSYNC = 1,
    MODE_VSYNC = 2,
    MODE_H_ILLEGAL = 3,
    MODE_V_ILLEGAL = 4,
    MODE_BAD_WIDTH = 5,
    MODE_NOMODE = 6,
    MODE_NO_INTERLACE = 7,
    MODE_NO_DBLESCAN = 8,
    MODE_NO_VSCAN = 9,
    MODE_MEM = 10,
    MODE_VIRTUAL_X = 11,
    MODE_VIRTUAL_Y = 12,
    MODE_MEM_VIRT = 13,
    MODE_NOCLOCK = 14,
    MODE_CLOCK_HIGH = 15,
    MODE_CLOCK_LOW = 16,
    MODE_CLOCK_RANGE = 17,
    MODE_BAD_HVALUE = 18,
    MODE_BAD_VVALUE = 19,
    MODE_BAD_VSCAN = 20,
    MODE_HSYNC_NARROW = 21,
    MODE_HSYNC_WIDE = 22,
    MODE_HBLANK_NARROW = 23,
    MODE_HBLANK_WIDE = 24,
    MODE_VSYNC_NARROW = 25,
    MODE_VSYNC_WIDE = 26,
    MODE_VBLANK_NARROW = 27,
    MODE_VBLANK_WIDE = 28,
    MODE_PANEL = 29,
    MODE_INTERLACE_WIDTH = 30,
    MODE_ONE_WIDTH = 31,
    MODE_ONE_HEIGHT = 32,
    MODE_ONE_SIZE = 33,
    MODE_NO_REDUCED = 34,
    MODE_NO_STEREO = 35,
    MODE_UNVERIFIED = -3,
    MODE_BAD = -2,
    MODE_ERROR = -1
} ;
#line 136 "include/drm/drm_crtc.h"
struct drm_display_mode {
   struct list_head head ;
   struct drm_mode_object base ;
   char name[32U] ;
   enum drm_mode_status status ;
   unsigned int type ;
   int clock ;
   int hdisplay ;
   int hsync_start ;
   int hsync_end ;
   int htotal ;
   int hskew ;
   int vdisplay ;
   int vsync_start ;
   int vsync_end ;
   int vtotal ;
   int vscan ;
   unsigned int flags ;
   int width_mm ;
   int height_mm ;
   int crtc_clock ;
   int crtc_hdisplay ;
   int crtc_hblank_start ;
   int crtc_hblank_end ;
   int crtc_hsync_start ;
   int crtc_hsync_end ;
   int crtc_htotal ;
   int crtc_hskew ;
   int crtc_vdisplay ;
   int crtc_vblank_start ;
   int crtc_vblank_end ;
   int crtc_vsync_start ;
   int crtc_vsync_end ;
   int crtc_vtotal ;
   int *private ;
   int private_flags ;
   int vrefresh ;
   int hsync ;
   enum hdmi_picture_aspect picture_aspect_ratio ;
};
#line 151 "include/drm/drm_modes.h"
struct drm_cmdline_mode {
   bool specified ;
   bool refresh_specified ;
   bool bpp_specified ;
   int xres ;
   int yres ;
   int bpp ;
   int refresh ;
   bool rb ;
   bool interlace ;
   bool cvt ;
   bool margins ;
   enum drm_connector_force force ;
};
#line 244
enum drm_connector_status {
    connector_status_connected = 1,
    connector_status_disconnected = 2,
    connector_status_unknown = 3
} ;
#line 250
enum subpixel_order {
    SubPixelUnknown = 0,
    SubPixelHorizontalRGB = 1,
    SubPixelHorizontalBGR = 2,
    SubPixelVerticalRGB = 3,
    SubPixelVerticalBGR = 4,
    SubPixelNone = 5
} ;
#line 259 "include/drm/drm_modes.h"
struct drm_display_info {
   char name[32U] ;
   unsigned int width_mm ;
   unsigned int height_mm ;
   unsigned int min_vfreq ;
   unsigned int max_vfreq ;
   unsigned int min_hfreq ;
   unsigned int max_hfreq ;
   unsigned int pixel_clock ;
   unsigned int bpc ;
   enum subpixel_order subpixel_order ;
   u32 color_formats ;
   u32 const   *bus_formats ;
   unsigned int num_bus_formats ;
   u8 edid_hdmi_dc_modes ;
   u8 cea_rev ;
};
#line 150 "include/drm/drm_crtc.h"
struct drm_tile_group {
   struct kref refcount ;
   struct drm_device *dev ;
   int id ;
   u8 group_data[8U] ;
};
#line 158 "include/drm/drm_crtc.h"
struct drm_framebuffer_funcs {
   void (*destroy)(struct drm_framebuffer * ) ;
   int (*create_handle)(struct drm_framebuffer * , struct drm_file * , unsigned int * ) ;
   int (*dirty)(struct drm_framebuffer * , struct drm_file * , unsigned int  , unsigned int  ,
                struct drm_clip_rect * , unsigned int  ) ;
};
#line 179 "include/drm/drm_crtc.h"
struct drm_framebuffer {
   struct drm_device *dev ;
   struct kref refcount ;
   struct list_head head ;
   struct drm_mode_object base ;
   struct drm_framebuffer_funcs  const  *funcs ;
   unsigned int pitches[4U] ;
   unsigned int offsets[4U] ;
   uint64_t modifier[4U] ;
   unsigned int width ;
   unsigned int height ;
   unsigned int depth ;
   int bits_per_pixel ;
   int flags ;
   uint32_t pixel_format ;
   struct list_head filp_head ;
   void *helper_private ;
};
#line 216 "include/drm/drm_crtc.h"
struct drm_property_blob {
   struct drm_mode_object base ;
   struct drm_device *dev ;
   struct kref refcount ;
   struct list_head head_global ;
   struct list_head head_file ;
   size_t length ;
   unsigned char data[] ;
};
#line 232 "include/drm/drm_crtc.h"
struct drm_property {
   struct list_head head ;
   struct drm_mode_object base ;
   uint32_t flags ;
   char name[32U] ;
   uint32_t num_values ;
   uint64_t *values ;
   struct drm_device *dev ;
   struct list_head enum_list ;
};
#line 244
struct drm_pending_vblank_event;
#line 245
struct drm_bridge;
#line 246
struct drm_atomic_state;
#line 247 "include/drm/drm_crtc.h"
struct drm_crtc_state {
   struct drm_crtc *crtc ;
   bool enable ;
   bool active ;
   bool planes_changed ;
   bool mode_changed ;
   bool active_changed ;
   u32 plane_mask ;
   u32 last_vblank_count ;
   struct drm_display_mode adjusted_mode ;
   struct drm_display_mode mode ;
   struct drm_property_blob *mode_blob ;
   struct drm_pending_vblank_event *event ;
   struct drm_atomic_state *state ;
};
#line 309 "include/drm/drm_crtc.h"
struct drm_crtc_funcs {
   void (*save)(struct drm_crtc * ) ;
   void (*restore)(struct drm_crtc * ) ;
   void (*reset)(struct drm_crtc * ) ;
   int (*cursor_set)(struct drm_crtc * , struct drm_file * , uint32_t  , uint32_t  ,
                     uint32_t  ) ;
   int (*cursor_set2)(struct drm_crtc * , struct drm_file * , uint32_t  , uint32_t  ,
                      uint32_t  , int32_t  , int32_t  ) ;
   int (*cursor_move)(struct drm_crtc * , int  , int  ) ;
   void (*gamma_set)(struct drm_crtc * , u16 * , u16 * , u16 * , uint32_t  , uint32_t  ) ;
   void (*destroy)(struct drm_crtc * ) ;
   int (*set_config)(struct drm_mode_set * ) ;
   int (*page_flip)(struct drm_crtc * , struct drm_framebuffer * , struct drm_pending_vblank_event * ,
                    uint32_t  ) ;
   int (*set_property)(struct drm_crtc * , struct drm_property * , uint64_t  ) ;
   struct drm_crtc_state *(*atomic_duplicate_state)(struct drm_crtc * ) ;
   void (*atomic_destroy_state)(struct drm_crtc * , struct drm_crtc_state * ) ;
   int (*atomic_set_property)(struct drm_crtc * , struct drm_crtc_state * , struct drm_property * ,
                              uint64_t  ) ;
   int (*atomic_get_property)(struct drm_crtc * , struct drm_crtc_state  const  * ,
                              struct drm_property * , uint64_t * ) ;
};
#line 390 "include/drm/drm_crtc.h"
struct drm_crtc {
   struct drm_device *dev ;
   struct device_node *port ;
   struct list_head head ;
   struct drm_modeset_lock mutex ;
   struct drm_mode_object base ;
   struct drm_plane *primary ;
   struct drm_plane *cursor ;
   int cursor_x ;
   int cursor_y ;
   bool enabled ;
   struct drm_display_mode mode ;
   struct drm_display_mode hwmode ;
   bool invert_dimensions ;
   int x ;
   int y ;
   struct drm_crtc_funcs  const  *funcs ;
   uint32_t gamma_size ;
   uint16_t *gamma_store ;
   int framedur_ns ;
   int linedur_ns ;
   int pixeldur_ns ;
   void const   *helper_private ;
   struct drm_object_properties properties ;
   struct drm_crtc_state *state ;
   struct drm_modeset_acquire_ctx *acquire_ctx ;
};
#line 487 "include/drm/drm_crtc.h"
struct drm_connector_state {
   struct drm_connector *connector ;
   struct drm_crtc *crtc ;
   struct drm_encoder *best_encoder ;
   struct drm_atomic_state *state ;
};
#line 504 "include/drm/drm_crtc.h"
struct drm_connector_funcs {
   void (*dpms)(struct drm_connector * , int  ) ;
   void (*save)(struct drm_connector * ) ;
   void (*restore)(struct drm_connector * ) ;
   void (*reset)(struct drm_connector * ) ;
   enum drm_connector_status (*detect)(struct drm_connector * , bool  ) ;
   int (*fill_modes)(struct drm_connector * , uint32_t  , uint32_t  ) ;
   int (*set_property)(struct drm_connector * , struct drm_property * , uint64_t  ) ;
   void (*destroy)(struct drm_connector * ) ;
   void (*force)(struct drm_connector * ) ;
   struct drm_connector_state *(*atomic_duplicate_state)(struct drm_connector * ) ;
   void (*atomic_destroy_state)(struct drm_connector * , struct drm_connector_state * ) ;
   int (*atomic_set_property)(struct drm_connector * , struct drm_connector_state * ,
                              struct drm_property * , uint64_t  ) ;
   int (*atomic_get_property)(struct drm_connector * , struct drm_connector_state  const  * ,
                              struct drm_property * , uint64_t * ) ;
};
#line 557 "include/drm/drm_crtc.h"
struct drm_encoder_funcs {
   void (*reset)(struct drm_encoder * ) ;
   void (*destroy)(struct drm_encoder * ) ;
};
#line 572 "include/drm/drm_crtc.h"
struct drm_encoder {
   struct drm_device *dev ;
   struct list_head head ;
   struct drm_mode_object base ;
   char *name ;
   int encoder_type ;
   uint32_t possible_crtcs ;
   uint32_t possible_clones ;
   struct drm_crtc *crtc ;
   struct drm_bridge *bridge ;
   struct drm_encoder_funcs  const  *funcs ;
   void const   *helper_private ;
};
#line 607 "include/drm/drm_crtc.h"
struct drm_connector {
   struct drm_device *dev ;
   struct device *kdev ;
   struct device_attribute *attr ;
   struct list_head head ;
   struct drm_mode_object base ;
   char *name ;
   int connector_type ;
   int connector_type_id ;
   bool interlace_allowed ;
   bool doublescan_allowed ;
   bool stereo_allowed ;
   struct list_head modes ;
   enum drm_connector_status status ;
   struct list_head probed_modes ;
   struct drm_display_info display_info ;
   struct drm_connector_funcs  const  *funcs ;
   struct drm_property_blob *edid_blob_ptr ;
   struct drm_object_properties properties ;
   struct drm_property_blob *path_blob_ptr ;
   struct drm_property_blob *tile_blob_ptr ;
   uint8_t polled ;
   int dpms ;
   void const   *helper_private ;
   struct drm_cmdline_mode cmdline_mode ;
   enum drm_connector_force force ;
   bool override_edid ;
   uint32_t encoder_ids[3U] ;
   struct drm_encoder *encoder ;
   uint8_t eld[128U] ;
   bool dvi_dual ;
   int max_tmds_clock ;
   bool latency_present[2U] ;
   int video_latency[2U] ;
   int audio_latency[2U] ;
   int null_edid_counter ;
   unsigned int bad_edid_counter ;
   bool edid_corrupt ;
   struct dentry *debugfs_entry ;
   struct drm_connector_state *state ;
   bool has_tile ;
   struct drm_tile_group *tile_group ;
   bool tile_is_single_monitor ;
   uint8_t num_h_tile ;
   uint8_t num_v_tile ;
   uint8_t tile_h_loc ;
   uint8_t tile_v_loc ;
   uint16_t tile_h_size ;
   uint16_t tile_v_size ;
   struct list_head destroy_list ;
};
#line 749 "include/drm/drm_crtc.h"
struct drm_plane_state {
   struct drm_plane *plane ;
   struct drm_crtc *crtc ;
   struct drm_framebuffer *fb ;
   struct fence *fence ;
   int32_t crtc_x ;
   int32_t crtc_y ;
   uint32_t crtc_w ;
   uint32_t crtc_h ;
   uint32_t src_x ;
   uint32_t src_y ;
   uint32_t src_h ;
   uint32_t src_w ;
   unsigned int rotation ;
   struct drm_atomic_state *state ;
};
#line 788 "include/drm/drm_crtc.h"
struct drm_plane_funcs {
   int (*update_plane)(struct drm_plane * , struct drm_crtc * , struct drm_framebuffer * ,
                       int  , int  , unsigned int  , unsigned int  , uint32_t  , uint32_t  ,
                       uint32_t  , uint32_t  ) ;
   int (*disable_plane)(struct drm_plane * ) ;
   void (*destroy)(struct drm_plane * ) ;
   void (*reset)(struct drm_plane * ) ;
   int (*set_property)(struct drm_plane * , struct drm_property * , uint64_t  ) ;
   struct drm_plane_state *(*atomic_duplicate_state)(struct drm_plane * ) ;
   void (*atomic_destroy_state)(struct drm_plane * , struct drm_plane_state * ) ;
   int (*atomic_set_property)(struct drm_plane * , struct drm_plane_state * , struct drm_property * ,
                              uint64_t  ) ;
   int (*atomic_get_property)(struct drm_plane * , struct drm_plane_state  const  * ,
                              struct drm_property * , uint64_t * ) ;
};
#line 828
enum drm_plane_type {
    DRM_PLANE_TYPE_OVERLAY = 0,
    DRM_PLANE_TYPE_PRIMARY = 1,
    DRM_PLANE_TYPE_CURSOR = 2
} ;
#line 834 "include/drm/drm_crtc.h"
struct drm_plane {
   struct drm_device *dev ;
   struct list_head head ;
   struct drm_modeset_lock mutex ;
   struct drm_mode_object base ;
   uint32_t possible_crtcs ;
   uint32_t *format_types ;
   uint32_t format_count ;
   bool format_default ;
   struct drm_crtc *crtc ;
   struct drm_framebuffer *fb ;
   struct drm_framebuffer *old_fb ;
   struct drm_plane_funcs  const  *funcs ;
   struct drm_object_properties properties ;
   enum drm_plane_type type ;
   void const   *helper_private ;
   struct drm_plane_state *state ;
};
#line 884 "include/drm/drm_crtc.h"
struct drm_bridge_funcs {
   int (*attach)(struct drm_bridge * ) ;
   bool (*mode_fixup)(struct drm_bridge * , struct drm_display_mode  const  * , struct drm_display_mode * ) ;
   void (*disable)(struct drm_bridge * ) ;
   void (*post_disable)(struct drm_bridge * ) ;
   void (*mode_set)(struct drm_bridge * , struct drm_display_mode * , struct drm_display_mode * ) ;
   void (*pre_enable)(struct drm_bridge * ) ;
   void (*enable)(struct drm_bridge * ) ;
};
#line 908 "include/drm/drm_crtc.h"
struct drm_bridge {
   struct drm_device *dev ;
   struct drm_encoder *encoder ;
   struct drm_bridge *next ;
   struct device_node *of_node ;
   struct list_head list ;
   struct drm_bridge_funcs  const  *funcs ;
   void *driver_private ;
};
#line 932 "include/drm/drm_crtc.h"
struct drm_atomic_state {
   struct drm_device *dev ;
   bool allow_modeset ;
   bool legacy_cursor_update ;
   struct drm_plane **planes ;
   struct drm_plane_state **plane_states ;
   struct drm_crtc **crtcs ;
   struct drm_crtc_state **crtc_states ;
   int num_connector ;
   struct drm_connector **connectors ;
   struct drm_connector_state **connector_states ;
   struct drm_modeset_acquire_ctx *acquire_ctx ;
};
#line 961 "include/drm/drm_crtc.h"
struct drm_mode_set {
   struct drm_framebuffer *fb ;
   struct drm_crtc *crtc ;
   struct drm_display_mode *mode ;
   uint32_t x ;
   uint32_t y ;
   struct drm_connector **connectors ;
   size_t num_connectors ;
};
#line 989 "include/drm/drm_crtc.h"
struct drm_mode_config_funcs {
   struct drm_framebuffer *(*fb_create)(struct drm_device * , struct drm_file * ,
                                        struct drm_mode_fb_cmd2 * ) ;
   void (*output_poll_changed)(struct drm_device * ) ;
   int (*atomic_check)(struct drm_device * , struct drm_atomic_state * ) ;
   int (*atomic_commit)(struct drm_device * , struct drm_atomic_state * , bool  ) ;
   struct drm_atomic_state *(*atomic_state_alloc)(struct drm_device * ) ;
   void (*atomic_state_clear)(struct drm_atomic_state * ) ;
   void (*atomic_state_free)(struct drm_atomic_state * ) ;
};
#line 1019 "include/drm/drm_crtc.h"
struct drm_mode_group {
   uint32_t num_crtcs ;
   uint32_t num_encoders ;
   uint32_t num_connectors ;
   uint32_t *id_list ;
};
#line 1042 "include/drm/drm_crtc.h"
struct drm_mode_config {
   struct mutex mutex ;
   struct drm_modeset_lock connection_mutex ;
   struct drm_modeset_acquire_ctx *acquire_ctx ;
   struct mutex idr_mutex ;
   struct idr crtc_idr ;
   struct idr tile_idr ;
   struct mutex fb_lock ;
   int num_fb ;
   struct list_head fb_list ;
   int num_connector ;
   struct list_head connector_list ;
   int num_encoder ;
   struct list_head encoder_list ;
   int num_overlay_plane ;
   int num_total_plane ;
   struct list_head plane_list ;
   int num_crtc ;
   struct list_head crtc_list ;
   struct list_head property_list ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   struct drm_mode_config_funcs  const  *funcs ;
   resource_size_t fb_base ;
   bool poll_enabled ;
   bool poll_running ;
   bool delayed_event ;
   struct delayed_work output_poll_work ;
   struct mutex blob_lock ;
   struct list_head property_blob_list ;
   struct drm_property *edid_property ;
   struct drm_property *dpms_property ;
   struct drm_property *path_property ;
   struct drm_property *tile_property ;
   struct drm_property *plane_type_property ;
   struct drm_property *rotation_property ;
   struct drm_property *prop_src_x ;
   struct drm_property *prop_src_y ;
   struct drm_property *prop_src_w ;
   struct drm_property *prop_src_h ;
   struct drm_property *prop_crtc_x ;
   struct drm_property *prop_crtc_y ;
   struct drm_property *prop_crtc_w ;
   struct drm_property *prop_crtc_h ;
   struct drm_property *prop_fb_id ;
   struct drm_property *prop_crtc_id ;
   struct drm_property *prop_active ;
   struct drm_property *prop_mode_id ;
   struct drm_property *dvi_i_subconnector_property ;
   struct drm_property *dvi_i_select_subconnector_property ;
   struct drm_property *tv_subconnector_property ;
   struct drm_property *tv_select_subconnector_property ;
   struct drm_property *tv_mode_property ;
   struct drm_property *tv_left_margin_property ;
   struct drm_property *tv_right_margin_property ;
   struct drm_property *tv_top_margin_property ;
   struct drm_property *tv_bottom_margin_property ;
   struct drm_property *tv_brightness_property ;
   struct drm_property *tv_contrast_property ;
   struct drm_property *tv_flicker_reduction_property ;
   struct drm_property *tv_overscan_property ;
   struct drm_property *tv_saturation_property ;
   struct drm_property *tv_hue_property ;
   struct drm_property *scaling_mode_property ;
   struct drm_property *aspect_ratio_property ;
   struct drm_property *dirty_info_property ;
   struct drm_property *suggested_x_property ;
   struct drm_property *suggested_y_property ;
   uint32_t preferred_depth ;
   uint32_t prefer_shadow ;
   bool async_page_flip ;
   bool allow_fb_modifiers ;
   uint32_t cursor_width ;
   uint32_t cursor_height ;
};
#line 46 "include/drm/drm_hashtab.h"
struct drm_open_hash {
   struct hlist_head *table ;
   u8 order ;
};
#line 72 "include/drm/drm_mem_util.h"
struct drm_mm;
#line 72 "include/drm/drm_mem_util.h"
struct drm_mm_node {
   struct list_head node_list ;
   struct list_head hole_stack ;
   unsigned char hole_follows : 1 ;
   unsigned char scanned_block : 1 ;
   unsigned char scanned_prev_free : 1 ;
   unsigned char scanned_next_free : 1 ;
   unsigned char scanned_preceeds_hole : 1 ;
   unsigned char allocated : 1 ;
   unsigned long color ;
   u64 start ;
   u64 size ;
   struct drm_mm *mm ;
};
#line 75 "include/drm/drm_mm.h"
struct drm_mm {
   struct list_head hole_stack ;
   struct drm_mm_node head_node ;
   unsigned char scan_check_range : 1 ;
   unsigned int scan_alignment ;
   unsigned long scan_color ;
   u64 scan_size ;
   u64 scan_hit_start ;
   u64 scan_hit_end ;
   unsigned int scanned_blocks ;
   u64 scan_start ;
   u64 scan_end ;
   struct drm_mm_node *prev_scanned_node ;
   void (*color_adjust)(struct drm_mm_node * , unsigned long  , u64 * , u64 * ) ;
};
#line 39 "include/drm/drm_vma_manager.h"
struct drm_vma_offset_node {
   rwlock_t vm_lock ;
   struct drm_mm_node vm_node ;
   struct rb_node vm_rb ;
   struct rb_root vm_files ;
};
#line 46 "include/drm/drm_vma_manager.h"
struct drm_vma_offset_manager {
   rwlock_t vm_lock ;
   struct rb_root vm_addr_space_rb ;
   struct drm_mm vm_addr_space_mm ;
};
#line 256
struct drm_local_map;
#line 257
struct drm_device_dma;
#line 259
struct drm_gem_object;
#line 260
struct reservation_object;
#line 261
struct dma_buf_attachment;
#line 236 "include/drm/drmP.h"
typedef int drm_ioctl_t(struct drm_device * , void * , struct drm_file * );
#line 240 "include/drm/drmP.h"
struct drm_ioctl_desc {
   unsigned int cmd ;
   int flags ;
   drm_ioctl_t *func ;
   char const   *name ;
};
#line 258 "include/drm/drmP.h"
struct drm_pending_event {
   struct drm_event *event ;
   struct list_head link ;
   struct drm_file *file_priv ;
   pid_t pid ;
   void (*destroy)(struct drm_pending_event * ) ;
};
#line 281 "include/drm/drmP.h"
struct drm_prime_file_private {
   struct list_head head ;
   struct mutex lock ;
};
#line 287
struct drm_minor;
#line 287
struct drm_master;
#line 287 "include/drm/drmP.h"
struct drm_file {
   unsigned char authenticated : 1 ;
   unsigned char is_master : 1 ;
   unsigned char stereo_allowed : 1 ;
   unsigned char universal_planes : 1 ;
   unsigned char atomic : 1 ;
   struct pid *pid ;
   kuid_t uid ;
   drm_magic_t magic ;
   struct list_head lhead ;
   struct drm_minor *minor ;
   unsigned long lock_count ;
   struct idr object_idr ;
   spinlock_t table_lock ;
   struct file *filp ;
   void *driver_priv ;
   struct drm_master *master ;
   struct list_head fbs ;
   struct mutex fbs_lock ;
   struct list_head blobs ;
   wait_queue_head_t event_wait ;
   struct list_head event_list ;
   int event_space ;
   struct drm_prime_file_private prime ;
};
#line 339 "include/drm/drmP.h"
struct drm_lock_data {
   struct drm_hw_lock *hw_lock ;
   struct drm_file *file_priv ;
   wait_queue_head_t lock_queue ;
   unsigned long lock_time ;
   spinlock_t spinlock ;
   uint32_t kernel_waiters ;
   uint32_t user_waiters ;
   int idle_has_lock ;
};
#line 354 "include/drm/drmP.h"
struct drm_master {
   struct kref refcount ;
   struct drm_minor *minor ;
   char *unique ;
   int unique_len ;
   struct idr magic_map ;
   struct drm_lock_data lock ;
   void *driver_priv ;
};
#line 375
struct dma_buf;
#line 375 "include/drm/drmP.h"
struct drm_driver {
   int (*load)(struct drm_device * , unsigned long  ) ;
   int (*firstopen)(struct drm_device * ) ;
   int (*open)(struct drm_device * , struct drm_file * ) ;
   void (*preclose)(struct drm_device * , struct drm_file * ) ;
   void (*postclose)(struct drm_device * , struct drm_file * ) ;
   void (*lastclose)(struct drm_device * ) ;
   int (*unload)(struct drm_device * ) ;
   int (*suspend)(struct drm_device * , pm_message_t  ) ;
   int (*resume)(struct drm_device * ) ;
   int (*dma_ioctl)(struct drm_device * , void * , struct drm_file * ) ;
   int (*dma_quiescent)(struct drm_device * ) ;
   int (*context_dtor)(struct drm_device * , int  ) ;
   int (*set_busid)(struct drm_device * , struct drm_master * ) ;
   u32 (*get_vblank_counter)(struct drm_device * , int  ) ;
   int (*enable_vblank)(struct drm_device * , int  ) ;
   void (*disable_vblank)(struct drm_device * , int  ) ;
   int (*device_is_agp)(struct drm_device * ) ;
   int (*get_scanout_position)(struct drm_device * , int  , unsigned int  , int * ,
                               int * , ktime_t * , ktime_t * ) ;
   int (*get_vblank_timestamp)(struct drm_device * , int  , int * , struct timeval * ,
                               unsigned int  ) ;
   irqreturn_t (*irq_handler)(int  , void * ) ;
   void (*irq_preinstall)(struct drm_device * ) ;
   int (*irq_postinstall)(struct drm_device * ) ;
   void (*irq_uninstall)(struct drm_device * ) ;
   int (*master_create)(struct drm_device * , struct drm_master * ) ;
   void (*master_destroy)(struct drm_device * , struct drm_master * ) ;
   int (*master_set)(struct drm_device * , struct drm_file * , bool  ) ;
   void (*master_drop)(struct drm_device * , struct drm_file * , bool  ) ;
   int (*debugfs_init)(struct drm_minor * ) ;
   void (*debugfs_cleanup)(struct drm_minor * ) ;
   void (*gem_free_object)(struct drm_gem_object * ) ;
   int (*gem_open_object)(struct drm_gem_object * , struct drm_file * ) ;
   void (*gem_close_object)(struct drm_gem_object * , struct drm_file * ) ;
   int (*prime_handle_to_fd)(struct drm_device * , struct drm_file * , uint32_t  ,
                             uint32_t  , int * ) ;
   int (*prime_fd_to_handle)(struct drm_device * , struct drm_file * , int  , uint32_t * ) ;
   struct dma_buf *(*gem_prime_export)(struct drm_device * , struct drm_gem_object * ,
                                       int  ) ;
   struct drm_gem_object *(*gem_prime_import)(struct drm_device * , struct dma_buf * ) ;
   int (*gem_prime_pin)(struct drm_gem_object * ) ;
   void (*gem_prime_unpin)(struct drm_gem_object * ) ;
   struct reservation_object *(*gem_prime_res_obj)(struct drm_gem_object * ) ;
   struct sg_table *(*gem_prime_get_sg_table)(struct drm_gem_object * ) ;
   struct drm_gem_object *(*gem_prime_import_sg_table)(struct drm_device * , struct dma_buf_attachment * ,
                                                       struct sg_table * ) ;
   void *(*gem_prime_vmap)(struct drm_gem_object * ) ;
   void (*gem_prime_vunmap)(struct drm_gem_object * , void * ) ;
   int (*gem_prime_mmap)(struct drm_gem_object * , struct vm_area_struct * ) ;
   void (*vgaarb_irq)(struct drm_device * , bool  ) ;
   int (*dumb_create)(struct drm_file * , struct drm_device * , struct drm_mode_create_dumb * ) ;
   int (*dumb_map_offset)(struct drm_file * , struct drm_device * , uint32_t  , uint64_t * ) ;
   int (*dumb_destroy)(struct drm_file * , struct drm_device * , uint32_t  ) ;
   struct vm_operations_struct  const  *gem_vm_ops ;
   int major ;
   int minor ;
   int patchlevel ;
   char *name ;
   char *desc ;
   char *date ;
   u32 driver_features ;
   int dev_priv_size ;
   struct drm_ioctl_desc  const  *ioctls ;
   int num_ioctls ;
   struct file_operations  const  *fops ;
   struct list_head legacy_dev_list ;
};
#line 661 "include/drm/drmP.h"
struct drm_minor {
   int index ;
   int type ;
   struct device *kdev ;
   struct drm_device *dev ;
   struct dentry *debugfs_root ;
   struct list_head debugfs_list ;
   struct mutex debugfs_lock ;
   struct drm_master *master ;
   struct drm_mode_group mode_group ;
};
#line 680 "include/drm/drmP.h"
struct drm_pending_vblank_event {
   struct drm_pending_event base ;
   int pipe ;
   struct drm_event_vblank event ;
};
#line 687 "include/drm/drmP.h"
struct drm_vblank_crtc {
   struct drm_device *dev ;
   wait_queue_head_t queue ;
   struct timer_list disable_timer ;
   unsigned long count ;
   struct timeval time[2U] ;
   atomic_t refcount ;
   u32 last ;
   u32 last_wait ;
   unsigned int inmodeset ;
   int crtc ;
   bool enabled ;
};
#line 706
struct virtio_device;
#line 706
struct drm_sg_mem;
#line 706 "include/drm/drmP.h"
struct __anonstruct_sigdata_258 {
   int context ;
   struct drm_hw_lock *lock ;
};
#line 706 "include/drm/drmP.h"
struct drm_device {
   struct list_head legacy_dev_list ;
   int if_version ;
   struct kref ref ;
   struct device *dev ;
   struct drm_driver *driver ;
   void *dev_private ;
   struct drm_minor *control ;
   struct drm_minor *primary ;
   struct drm_minor *render ;
   atomic_t unplugged ;
   struct inode *anon_inode ;
   char *unique ;
   struct mutex struct_mutex ;
   struct mutex master_mutex ;
   int open_count ;
   spinlock_t buf_lock ;
   int buf_use ;
   atomic_t buf_alloc ;
   struct list_head filelist ;
   struct list_head maplist ;
   struct drm_open_hash map_hash ;
   struct list_head ctxlist ;
   struct mutex ctxlist_mutex ;
   struct idr ctx_idr ;
   struct list_head vmalist ;
   struct drm_device_dma *dma ;
   long volatile   context_flag ;
   int last_context ;
   bool irq_enabled ;
   int irq ;
   bool vblank_disable_allowed ;
   bool vblank_disable_immediate ;
   struct drm_vblank_crtc *vblank ;
   spinlock_t vblank_time_lock ;
   spinlock_t vbl_lock ;
   u32 max_vblank_count ;
   struct list_head vblank_event_list ;
   spinlock_t event_lock ;
   struct drm_agp_head *agp ;
   struct pci_dev *pdev ;
   struct platform_device *platformdev ;
   struct virtio_device *virtdev ;
   struct drm_sg_mem *sg ;
   unsigned int num_crtcs ;
   sigset_t sigmask ;
   struct __anonstruct_sigdata_258 sigdata ;
   struct drm_local_map *agp_buffer_map ;
   unsigned int agp_buffer_token ;
   struct drm_mode_config mode_config ;
   struct mutex object_name_lock ;
   struct idr object_name_idr ;
   struct drm_vma_offset_manager *vma_offset_manager ;
   int switch_power_state ;
};
#line 1097 "include/drm/drmP.h"
struct i2c_algo_bit_data {
   void *data ;
   void (*setsda)(void * , int  ) ;
   void (*setscl)(void * , int  ) ;
   int (*getsda)(void * ) ;
   int (*getscl)(void * ) ;
   int (*pre_xfer)(struct i2c_adapter * ) ;
   void (*post_xfer)(struct i2c_adapter * ) ;
   int udelay ;
   int timeout ;
};
#line 54 "include/linux/i2c-algo-bit.h"
enum mode_set_atomic {
    LEAVE_ATOMIC_MODE_SET = 0,
    ENTER_ATOMIC_MODE_SET = 1
} ;
#line 59 "include/linux/i2c-algo-bit.h"
struct drm_crtc_helper_funcs {
   void (*dpms)(struct drm_crtc * , int  ) ;
   void (*prepare)(struct drm_crtc * ) ;
   void (*commit)(struct drm_crtc * ) ;
   bool (*mode_fixup)(struct drm_crtc * , struct drm_display_mode  const  * , struct drm_display_mode * ) ;
   int (*mode_set)(struct drm_crtc * , struct drm_display_mode * , struct drm_display_mode * ,
                   int  , int  , struct drm_framebuffer * ) ;
   void (*mode_set_nofb)(struct drm_crtc * ) ;
   int (*mode_set_base)(struct drm_crtc * , int  , int  , struct drm_framebuffer * ) ;
   int (*mode_set_base_atomic)(struct drm_crtc * , struct drm_framebuffer * , int  ,
                               int  , enum mode_set_atomic  ) ;
   void (*load_lut)(struct drm_crtc * ) ;
   void (*disable)(struct drm_crtc * ) ;
   void (*enable)(struct drm_crtc * ) ;
   int (*atomic_check)(struct drm_crtc * , struct drm_crtc_state * ) ;
   void (*atomic_begin)(struct drm_crtc * ) ;
   void (*atomic_flush)(struct drm_crtc * ) ;
};
#line 282 "include/linux/pm_runtime.h"
struct gma_clock_t {
   int n ;
   int m1 ;
   int m2 ;
   int p1 ;
   int p2 ;
   int dot ;
   int vco ;
   int m ;
   int p ;
};
#line 38 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/gma_display.h"
struct gma_range_t {
   int min ;
   int max ;
};
#line 42 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/gma_display.h"
struct gma_p2_t {
   int dot_limit ;
   int p2_slow ;
   int p2_fast ;
};
#line 47 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/gma_display.h"
struct gma_limit_t {
   struct gma_range_t dot ;
   struct gma_range_t vco ;
   struct gma_range_t n ;
   struct gma_range_t m ;
   struct gma_range_t m1 ;
   struct gma_range_t m2 ;
   struct gma_range_t p ;
   struct gma_range_t p1 ;
   struct gma_p2_t p2 ;
   bool (*find_pll)(struct gma_limit_t  const  * , struct drm_crtc * , int  , int  ,
                    struct gma_clock_t * ) ;
};
#line 53 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/gma_display.h"
struct gma_clock_funcs {
   void (*clock)(int  , struct gma_clock_t * ) ;
   struct gma_limit_t  const  *(*limit)(struct drm_crtc * , int  ) ;
   bool (*pll_is_valid)(struct drm_crtc * , struct gma_limit_t  const  * , struct gma_clock_t * ) ;
};
#line 86 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
struct psb_intel_mode_device {
   size_t (*bo_offset)(struct drm_device * , void * ) ;
   int backlight_duty_cycle ;
   bool panel_wants_dither ;
   struct drm_display_mode *panel_fixed_mode ;
   struct drm_display_mode *panel_fixed_mode2 ;
   struct drm_display_mode *vbt_mode ;
   uint32_t saveBLC_PWM_CTL ;
};
#line 110 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
struct psb_intel_i2c_chan {
   struct drm_device *drm_dev ;
   u32 reg ;
   struct i2c_adapter adapter ;
   struct i2c_algo_bit_data algo ;
   u8 slave_addr ;
};
#line 164
struct gtt_range;
#line 137 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct child_device_config {
   u16 handle ;
   u16 device_type ;
   u8 device_id[10U] ;
   u16 addin_offset ;
   u8 dvo_port ;
   u8 i2c_pin ;
   u8 slave_addr ;
   u8 ddc_pin ;
   u16 edid_ptr ;
   u8 dvo_cfg ;
   u8 dvo2_port ;
   u8 i2c2_pin ;
   u8 slave2_addr ;
   u8 ddc2_pin ;
   u8 capabilities ;
   u8 dvo_wiring ;
   u8 dvo2_wiring ;
   u16 extended_type ;
   u8 dvo_function ;
};
#line 260 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct bdb_lvds_backlight {
   unsigned char type : 2 ;
   unsigned char pol : 1 ;
   unsigned char gpio : 3 ;
   unsigned char gmbus : 2 ;
   u16 freq ;
   u8 minbrightness ;
   u8 i2caddr ;
   u8 brightnesscmd ;
};
#line 440 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct edp_power_seq {
   u16 t1_t3 ;
   u16 t8 ;
   u16 t9 ;
   u16 t10 ;
   u16 t11_t12 ;
};
#line 482 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct drm_gem_object {
   struct kref refcount ;
   unsigned int handle_count ;
   struct drm_device *dev ;
   struct file *filp ;
   struct drm_vma_offset_node vma_node ;
   size_t size ;
   int name ;
   uint32_t read_domains ;
   uint32_t write_domain ;
   uint32_t pending_read_domains ;
   uint32_t pending_write_domain ;
   struct dma_buf *dma_buf ;
   struct dma_buf_attachment *import_attach ;
};
#line 182 "include/drm/drm_gem.h"
struct psb_gtt {
   uint32_t gatt_start ;
   uint32_t mmu_gatt_start ;
   uint32_t gtt_start ;
   uint32_t gtt_phys_start ;
   unsigned int gtt_pages ;
   unsigned int gatt_pages ;
   unsigned long stolen_size ;
   unsigned long vram_stolen_size ;
   struct rw_semaphore sem ;
};
#line 42 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/gtt.h"
struct gtt_range {
   struct resource resource ;
   u32 offset ;
   struct drm_gem_object gem ;
   int in_gart ;
   bool stolen ;
   bool mmapping ;
   struct page **pages ;
   int npage ;
   int roll ;
};
#line 31 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/opregion.h"
struct oaktrail_timing_info {
   u16 pixel_clock ;
   u8 hactive_lo ;
   u8 hblank_lo ;
   unsigned char hblank_hi : 4 ;
   unsigned char hactive_hi : 4 ;
   u8 vactive_lo ;
   u8 vblank_lo ;
   unsigned char vblank_hi : 4 ;
   unsigned char vactive_hi : 4 ;
   u8 hsync_offset_lo ;
   u8 hsync_pulse_width_lo ;
   unsigned char vsync_pulse_width_lo : 4 ;
   unsigned char vsync_offset_lo : 4 ;
   unsigned char vsync_pulse_width_hi : 2 ;
   unsigned char vsync_offset_hi : 2 ;
   unsigned char hsync_pulse_width_hi : 2 ;
   unsigned char hsync_offset_hi : 2 ;
   u8 width_mm_lo ;
   u8 height_mm_lo ;
   unsigned char height_mm_hi : 4 ;
   unsigned char width_mm_hi : 4 ;
   u8 hborder ;
   u8 vborder ;
   unsigned char unknown0 : 1 ;
   unsigned char hsync_positive : 1 ;
   unsigned char vsync_positive : 1 ;
   unsigned char separate_sync : 2 ;
   unsigned char stereo : 1 ;
   unsigned char unknown6 : 1 ;
   unsigned char interlaced : 1 ;
};
#line 199 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/oaktrail.h"
struct oaktrail_gct_data {
   u8 bpi ;
   u8 pt ;
   struct oaktrail_timing_info DTD ;
   u32 Panel_Port_Control ;
   u32 PP_On_Sequencing ;
   u32 PP_Off_Sequencing ;
   u32 PP_Cycle_Delay ;
   u16 Panel_Backlight_Inverter_Descriptor ;
   u16 Panel_MIPI_Display_Descriptor ;
};
#line 211
struct hdmi_i2c_dev;
#line 211 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/oaktrail.h"
struct oaktrail_hdmi_dev {
   struct pci_dev *dev ;
   void *regs ;
   unsigned int mmio ;
   unsigned int mmio_len ;
   int dpms_mode ;
   struct hdmi_i2c_dev *i2c_dev ;
   u32 saveDPLL_CTRL ;
   u32 saveDPLL_DIV_CTRL ;
   u32 saveDPLL_ADJUST ;
   u32 saveDPLL_UPDATE ;
   u32 saveDPLL_CLK_ENABLE ;
   u32 savePCH_HTOTAL_B ;
   u32 savePCH_HBLANK_B ;
   u32 savePCH_HSYNC_B ;
   u32 savePCH_VTOTAL_B ;
   u32 savePCH_VBLANK_B ;
   u32 savePCH_VSYNC_B ;
   u32 savePCH_PIPEBCONF ;
   u32 savePCH_PIPEBSRC ;
};
#line 256
struct psb_mmu_pd;
#line 256 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/oaktrail.h"
struct psb_mmu_driver {
   struct rw_semaphore sem ;
   spinlock_t lock ;
   atomic_t needs_tlbflush ;
   atomic_t *msvdx_mmu_invaldc ;
   struct psb_mmu_pd *default_pd ;
   uint32_t bif_ctrl ;
   int has_clflush ;
   int clflush_add ;
   unsigned long clflush_mask ;
   struct drm_device *dev ;
};
#line 39 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/mmu.h"
struct psb_mmu_pt {
   struct psb_mmu_pd *pd ;
   uint32_t index ;
   uint32_t count ;
   struct page *p ;
   uint32_t *v ;
};
#line 49 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/mmu.h"
struct psb_mmu_pd {
   struct psb_mmu_driver *driver ;
   int hw_context ;
   struct psb_mmu_pt **tables ;
   struct page *p ;
   struct page *dummy_pt ;
   struct page *dummy_page ;
   uint32_t pd_mask ;
   uint32_t invalid_pde ;
   uint32_t invalid_pte ;
};
#line 96
struct opregion_header;
#line 97
struct opregion_acpi;
#line 98
struct opregion_swsci;
#line 99
struct opregion_asle;
#line 100 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/mmu.h"
struct psb_intel_opregion {
   struct opregion_header *header ;
   struct opregion_acpi *acpi ;
   struct opregion_swsci *swsci ;
   struct opregion_asle *asle ;
   void *vbt ;
   u32 *lid_state ;
   struct work_struct asle_work ;
};
#line 259 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct sdvo_device_mapping {
   u8 initialized ;
   u8 dvo_port ;
   u8 slave_addr ;
   u8 dvo_wiring ;
   u8 i2c_pin ;
   u8 i2c_speed ;
   u8 ddc_pin ;
};
#line 269 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct intel_gmbus {
   struct i2c_adapter adapter ;
   struct i2c_adapter *force_bit ;
   u32 reg0 ;
};
#line 275 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct psb_offset {
   u32 fp0 ;
   u32 fp1 ;
   u32 cntr ;
   u32 conf ;
   u32 src ;
   u32 dpll ;
   u32 dpll_md ;
   u32 htotal ;
   u32 hblank ;
   u32 hsync ;
   u32 vtotal ;
   u32 vblank ;
   u32 vsync ;
   u32 stride ;
   u32 size ;
   u32 pos ;
   u32 surf ;
   u32 addr ;
   u32 base ;
   u32 status ;
   u32 linoff ;
   u32 tileoff ;
   u32 palette ;
};
#line 302 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct psb_pipe {
   u32 fp0 ;
   u32 fp1 ;
   u32 cntr ;
   u32 conf ;
   u32 src ;
   u32 dpll ;
   u32 dpll_md ;
   u32 htotal ;
   u32 hblank ;
   u32 hsync ;
   u32 vtotal ;
   u32 vblank ;
   u32 vsync ;
   u32 stride ;
   u32 size ;
   u32 pos ;
   u32 base ;
   u32 surf ;
   u32 addr ;
   u32 status ;
   u32 linoff ;
   u32 tileoff ;
   u32 palette[256U] ;
};
#line 336 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct psb_state {
   uint32_t saveVCLK_DIVISOR_VGA0 ;
   uint32_t saveVCLK_DIVISOR_VGA1 ;
   uint32_t saveVCLK_POST_DIV ;
   uint32_t saveVGACNTRL ;
   uint32_t saveADPA ;
   uint32_t saveLVDS ;
   uint32_t saveDVOA ;
   uint32_t saveDVOB ;
   uint32_t saveDVOC ;
   uint32_t savePP_ON ;
   uint32_t savePP_OFF ;
   uint32_t savePP_CONTROL ;
   uint32_t savePP_CYCLE ;
   uint32_t savePFIT_CONTROL ;
   uint32_t saveCLOCKGATING ;
   uint32_t saveDSPARB ;
   uint32_t savePFIT_AUTO_RATIOS ;
   uint32_t savePFIT_PGM_RATIOS ;
   uint32_t savePP_ON_DELAYS ;
   uint32_t savePP_OFF_DELAYS ;
   uint32_t savePP_DIVISOR ;
   uint32_t saveBCLRPAT_A ;
   uint32_t saveBCLRPAT_B ;
   uint32_t savePERF_MODE ;
   uint32_t saveDSPFW1 ;
   uint32_t saveDSPFW2 ;
   uint32_t saveDSPFW3 ;
   uint32_t saveDSPFW4 ;
   uint32_t saveDSPFW5 ;
   uint32_t saveDSPFW6 ;
   uint32_t saveCHICKENBIT ;
   uint32_t saveDSPACURSOR_CTRL ;
   uint32_t saveDSPBCURSOR_CTRL ;
   uint32_t saveDSPACURSOR_BASE ;
   uint32_t saveDSPBCURSOR_BASE ;
   uint32_t saveDSPACURSOR_POS ;
   uint32_t saveDSPBCURSOR_POS ;
   uint32_t saveOV_OVADD ;
   uint32_t saveOV_OGAMC0 ;
   uint32_t saveOV_OGAMC1 ;
   uint32_t saveOV_OGAMC2 ;
   uint32_t saveOV_OGAMC3 ;
   uint32_t saveOV_OGAMC4 ;
   uint32_t saveOV_OGAMC5 ;
   uint32_t saveOVC_OVADD ;
   uint32_t saveOVC_OGAMC0 ;
   uint32_t saveOVC_OGAMC1 ;
   uint32_t saveOVC_OGAMC2 ;
   uint32_t saveOVC_OGAMC3 ;
   uint32_t saveOVC_OGAMC4 ;
   uint32_t saveOVC_OGAMC5 ;
   uint32_t saveHISTOGRAM_INT_CONTROL_REG ;
   uint32_t saveHISTOGRAM_LOGIC_CONTROL_REG ;
   uint32_t savePWM_CONTROL_LOGIC ;
};
#line 395 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct medfield_state {
   uint32_t saveMIPI ;
   uint32_t saveMIPI_C ;
   uint32_t savePFIT_CONTROL ;
   uint32_t savePFIT_PGM_RATIOS ;
   uint32_t saveHDMIPHYMISCCTL ;
   uint32_t saveHDMIB_CONTROL ;
};
#line 405 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct cdv_state {
   uint32_t saveDSPCLK_GATE_D ;
   uint32_t saveRAMCLK_GATE_D ;
   uint32_t saveDSPARB ;
   uint32_t saveDSPFW[6U] ;
   uint32_t saveADPA ;
   uint32_t savePP_CONTROL ;
   uint32_t savePFIT_PGM_RATIOS ;
   uint32_t saveLVDS ;
   uint32_t savePFIT_CONTROL ;
   uint32_t savePP_ON_DELAYS ;
   uint32_t savePP_OFF_DELAYS ;
   uint32_t savePP_CYCLE ;
   uint32_t saveVGACNTRL ;
   uint32_t saveIER ;
   uint32_t saveIMR ;
   u8 saveLBB ;
};
#line 424 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
union __anonunion____missing_field_name_264 {
   struct psb_state psb ;
   struct medfield_state mdfld ;
   struct cdv_state cdv ;
};
#line 424 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct psb_save_area {
   struct psb_pipe pipe[3U] ;
   uint32_t saveBSM ;
   uint32_t saveVBT ;
   union __anonunion____missing_field_name_264 __annonCompField80 ;
   uint32_t saveBLC_PWM_CTL2 ;
   uint32_t saveBLC_PWM_CTL ;
};
#line 437
struct psb_ops;
#line 438
struct psb_gtt_mm;
#line 438 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct __anonstruct_edp_265 {
   int rate ;
   int lanes ;
   int preemphasis ;
   int vswing ;
   bool initialized ;
   bool support ;
   int bpp ;
   struct edp_power_seq pps ;
};
#line 438 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct drm_psb_private {
   struct drm_device *dev ;
   struct pci_dev *aux_pdev ;
   struct pci_dev *lpc_pdev ;
   struct psb_ops  const  *ops ;
   struct psb_offset  const  *regmap ;
   struct child_device_config *child_dev ;
   int child_dev_num ;
   struct psb_gtt gtt ;
   struct psb_gtt_mm *gtt_mm ;
   struct page *scratch_page ;
   u32 *gtt_map ;
   uint32_t stolen_base ;
   u8 *vram_addr ;
   unsigned long vram_stolen_size ;
   int gtt_initialized ;
   u16 gmch_ctrl ;
   u32 pge_ctl ;
   struct mutex gtt_mutex ;
   struct resource *gtt_mem ;
   struct psb_mmu_driver *mmu ;
   struct psb_mmu_pd *pf_pd ;
   uint8_t *sgx_reg ;
   uint8_t *vdc_reg ;
   uint8_t *aux_reg ;
   uint16_t lpc_gpio_base ;
   uint32_t gatt_free_offset ;
   uint32_t vdc_irq_mask ;
   uint32_t pipestat[3U] ;
   spinlock_t irqmask_lock ;
   bool suspended ;
   bool display_power ;
   int display_count ;
   struct psb_intel_mode_device mode_dev ;
   bool modeset ;
   struct drm_crtc *plane_to_crtc_mapping[3U] ;
   struct drm_crtc *pipe_to_crtc_mapping[3U] ;
   uint32_t num_pipe ;
   uint32_t ospm_base ;
   u32 fuse_reg_value ;
   u32 video_device_fuse ;
   uint8_t platform_rev_id ;
   struct intel_gmbus *gmbus ;
   uint8_t *gmbus_reg ;
   int crt_ddc_pin ;
   struct sdvo_device_mapping sdvo_mappings[2U] ;
   u32 hotplug_supported_mask ;
   struct drm_property *broadcast_rgb_property ;
   struct drm_property *force_audio_property ;
   int backlight_duty_cycle ;
   bool panel_wants_dither ;
   struct drm_display_mode *panel_fixed_mode ;
   struct drm_display_mode *lfp_lvds_vbt_mode ;
   struct drm_display_mode *sdvo_lvds_vbt_mode ;
   struct bdb_lvds_backlight *lvds_bl ;
   struct psb_intel_i2c_chan *lvds_i2c_bus ;
   unsigned char int_tv_support : 1 ;
   unsigned char lvds_dither : 1 ;
   unsigned char lvds_vbt : 1 ;
   unsigned char int_crt_support : 1 ;
   unsigned char lvds_use_ssc : 1 ;
   int lvds_ssc_freq ;
   bool is_lvds_on ;
   bool is_mipi_on ;
   u32 mipi_ctrl_display ;
   unsigned int core_freq ;
   uint32_t iLVDS_enable ;
   int rpm_enabled ;
   bool has_gct ;
   struct oaktrail_gct_data gct_data ;
   struct oaktrail_hdmi_dev *hdmi_priv ;
   struct psb_save_area regs ;
   uint32_t msi_addr ;
   uint32_t msi_data ;
   struct work_struct hotplug_work ;
   spinlock_t lid_lock ;
   struct timer_list lid_timer ;
   struct psb_intel_opregion opregion ;
   u32 lid_last_state ;
   uint32_t apm_reg ;
   uint16_t apm_base ;
   struct backlight_device *backlight_device ;
   struct drm_property *backlight_property ;
   bool backlight_enabled ;
   int backlight_level ;
   uint32_t blc_adj1 ;
   uint32_t blc_adj2 ;
   void *fbdev ;
   spinlock_t lock_2d ;
   int brightness ;
   int brightness_adjusted ;
   bool dsr_enable ;
   u32 dsr_fb_update ;
   bool dpi_panel_on[3U] ;
   void *dsi_configs[2U] ;
   u32 bpp ;
   u32 bpp2 ;
   u32 pipeconf[3U] ;
   u32 dspcntr[3U] ;
   int mdfld_panel_id ;
   bool dplla_96mhz ;
   struct __anonstruct_edp_265 edp ;
   uint8_t panel_type ;
};
#line 621 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct psb_ops {
   char const   *name ;
   unsigned char accel_2d : 1 ;
   int pipes ;
   int crtcs ;
   int sgx_offset ;
   int hdmi_mask ;
   int lvds_mask ;
   int sdvo_mask ;
   int cursor_needs_phys ;
   struct drm_crtc_helper_funcs  const  *crtc_helper ;
   struct drm_crtc_funcs  const  *crtc_funcs ;
   struct gma_clock_funcs  const  *clock_funcs ;
   int (*chip_setup)(struct drm_device * ) ;
   void (*chip_teardown)(struct drm_device * ) ;
   void (*errata)(struct drm_device * ) ;
   int (*output_init)(struct drm_device * ) ;
   int (*hotplug)(struct drm_device * ) ;
   void (*hotplug_enable)(struct drm_device * , bool  ) ;
   void (*init_pm)(struct drm_device * ) ;
   int (*save_regs)(struct drm_device * ) ;
   int (*restore_regs)(struct drm_device * ) ;
   int (*power_up)(struct drm_device * ) ;
   int (*power_down)(struct drm_device * ) ;
   void (*update_wm)(struct drm_device * , struct drm_crtc * ) ;
   void (*disable_sr)(struct drm_device * ) ;
   void (*lvds_bl_power)(struct drm_device * , bool  ) ;
   int i2c_bus ;
};
#line 897
struct drm_fb_helper;
#line 898 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct drm_fb_offset {
   int x ;
   int y ;
};
#line 40 "include/drm/drm_fb_helper.h"
struct drm_fb_helper_crtc {
   struct drm_mode_set mode_set ;
   struct drm_display_mode *desired_mode ;
   int x ;
   int y ;
};
#line 46 "include/drm/drm_fb_helper.h"
struct drm_fb_helper_surface_size {
   u32 fb_width ;
   u32 fb_height ;
   u32 surface_width ;
   u32 surface_height ;
   u32 surface_bpp ;
   u32 surface_depth ;
};
#line 74 "include/drm/drm_fb_helper.h"
struct drm_fb_helper_funcs {
   void (*gamma_set)(struct drm_crtc * , u16  , u16  , u16  , int  ) ;
   void (*gamma_get)(struct drm_crtc * , u16 * , u16 * , u16 * , int  ) ;
   int (*fb_probe)(struct drm_fb_helper * , struct drm_fb_helper_surface_size * ) ;
   bool (*initial_config)(struct drm_fb_helper * , struct drm_fb_helper_crtc ** ,
                          struct drm_display_mode ** , struct drm_fb_offset * , bool * ,
                          int  , int  ) ;
};
#line 98 "include/drm/drm_fb_helper.h"
struct drm_fb_helper_connector {
   struct drm_connector *connector ;
};
#line 106 "include/drm/drm_fb_helper.h"
struct drm_fb_helper {
   struct drm_framebuffer *fb ;
   struct drm_device *dev ;
   int crtc_count ;
   struct drm_fb_helper_crtc *crtc_info ;
   int connector_count ;
   int connector_info_alloc_count ;
   struct drm_fb_helper_connector **connector_info ;
   struct drm_fb_helper_funcs  const  *funcs ;
   struct fb_info *fbdev ;
   u32 pseudo_palette[17U] ;
   struct list_head kernel_fb_list ;
   bool delayed_hotplug ;
};
#line 160 "include/drm/drm_fb_helper.h"
struct psb_framebuffer {
   struct drm_framebuffer base ;
   struct address_space *addr_space ;
   struct fb_info *fbdev ;
   struct gtt_range *gtt ;
};
#line 36 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/framebuffer.h"
struct psb_fbdev {
   struct drm_fb_helper psb_fb_helper ;
   struct psb_framebuffer pfb ;
};
#line 430 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
typedef bool ldv_func_ret_type;
#line 441 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
typedef bool ldv_func_ret_type___0;
#line 452 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
typedef bool ldv_func_ret_type___1;
#line 471 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
typedef bool ldv_func_ret_type___2;
#line 522 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
typedef int ldv_func_ret_type___3;
#line 573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
typedef int ldv_func_ret_type___4;
#line 584 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
typedef int ldv_func_ret_type___5;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 98 "./arch/x86/include/asm/desc_defs.h"
enum page_cache_mode {
    _PAGE_CACHE_MODE_WB = 0,
    _PAGE_CACHE_MODE_WC = 1,
    _PAGE_CACHE_MODE_UC_MINUS = 2,
    _PAGE_CACHE_MODE_UC = 3,
    _PAGE_CACHE_MODE_WT = 4,
    _PAGE_CACHE_MODE_WP = 5,
    _PAGE_CACHE_MODE_NUM = 8
} ;
#line 716 "./arch/x86/include/asm/paravirt_types.h"
struct cpuinfo_x86;
#line 234 "include/linux/printk.h"
struct _ddebug {
   char const   *modname ;
   char const   *function ;
   char const   *filename ;
   char const   *format ;
   unsigned int lineno : 18 ;
   unsigned char flags ;
};
#line 81 "./arch/x86/include/asm/processor.h"
struct cpuinfo_x86 {
   __u8 x86 ;
   __u8 x86_vendor ;
   __u8 x86_model ;
   __u8 x86_mask ;
   int x86_tlbsize ;
   __u8 x86_virt_bits ;
   __u8 x86_phys_bits ;
   __u8 x86_coreid_bits ;
   __u32 extended_cpuid_level ;
   int cpuid_level ;
   __u32 x86_capability[14U] ;
   char x86_vendor_id[16U] ;
   char x86_model_id[64U] ;
   int x86_cache_size ;
   int x86_cache_alignment ;
   int x86_cache_max_rmid ;
   int x86_cache_occ_scale ;
   int x86_power ;
   unsigned long loops_per_jiffy ;
   u16 x86_max_cores ;
   u16 apicid ;
   u16 initial_apicid ;
   u16 x86_clflush_size ;
   u16 booted_cores ;
   u16 phys_proc_id ;
   u16 cpu_core_id ;
   u8 compute_unit_id ;
   u16 cpu_index ;
   u32 microcode ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 119 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
struct gma_encoder {
   struct drm_encoder base ;
   int type ;
   bool needs_tv_clock ;
   void (*hot_plug)(struct gma_encoder * ) ;
   int crtc_mask ;
   int clone_mask ;
   u32 ddi_select ;
   void *dev_priv ;
   struct psb_intel_i2c_chan *i2c_bus ;
   struct psb_intel_i2c_chan *ddc_bus ;
};
#line 139 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
struct gma_connector {
   struct drm_connector base ;
   struct gma_encoder *encoder ;
};
#line 144 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
struct psb_intel_crtc_state {
   uint32_t saveDSPCNTR ;
   uint32_t savePIPECONF ;
   uint32_t savePIPESRC ;
   uint32_t saveDPLL ;
   uint32_t saveFP0 ;
   uint32_t saveFP1 ;
   uint32_t saveHTOTAL ;
   uint32_t saveHBLANK ;
   uint32_t saveHSYNC ;
   uint32_t saveVTOTAL ;
   uint32_t saveVBLANK ;
   uint32_t saveVSYNC ;
   uint32_t saveDSPSTRIDE ;
   uint32_t saveDSPSIZE ;
   uint32_t saveDSPPOS ;
   uint32_t saveDSPBASE ;
   uint32_t savePalette[256U] ;
};
#line 164
struct psb_intel_framebuffer;
#line 164 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
struct gma_crtc {
   struct drm_crtc base ;
   int pipe ;
   int plane ;
   uint32_t cursor_addr ;
   struct gtt_range *cursor_gt ;
   u8 lut_r[256U] ;
   u8 lut_g[256U] ;
   u8 lut_b[256U] ;
   u8 lut_adj[256U] ;
   struct psb_intel_framebuffer *fbdev_fb ;
   struct drm_mode_set mode_set ;
   struct drm_gem_object *cursor_obj ;
   struct drm_display_mode saved_mode ;
   struct drm_display_mode saved_adjusted_mode ;
   struct psb_intel_mode_device *mode_dev ;
   u32 mode_flags ;
   bool active ;
   struct psb_intel_crtc_state *crtc_state ;
   struct gma_clock_funcs  const  *clock_funcs ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 1097 "include/drm/drmP.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 104 "include/linux/swap.h"
struct reclaim_state {
   unsigned long reclaimed_slab ;
};
#line 112 "include/linux/swap.h"
struct swap_extent {
   struct list_head list ;
   unsigned long start_page ;
   unsigned long nr_pages ;
   sector_t start_block ;
};
#line 148 "include/linux/swap.h"
struct swap_cluster_info {
   unsigned int data : 24 ;
   unsigned char flags ;
};
#line 190 "include/linux/swap.h"
struct percpu_cluster {
   struct swap_cluster_info index ;
   unsigned int next ;
};
#line 202 "include/linux/swap.h"
struct swap_info_struct {
   unsigned long flags ;
   short prio ;
   struct plist_node list ;
   struct plist_node avail_list ;
   signed char type ;
   unsigned int max ;
   unsigned char *swap_map ;
   struct swap_cluster_info *cluster_info ;
   struct swap_cluster_info free_cluster_head ;
   struct swap_cluster_info free_cluster_tail ;
   unsigned int lowest_bit ;
   unsigned int highest_bit ;
   unsigned int pages ;
   unsigned int inuse_pages ;
   unsigned int cluster_next ;
   unsigned int cluster_nr ;
   struct percpu_cluster *percpu_cluster ;
   struct swap_extent *curr_swap_extent ;
   struct swap_extent first_swap_extent ;
   struct block_device *bdev ;
   struct file *swap_file ;
   unsigned int old_block_size ;
   unsigned long *frontswap_map ;
   atomic_t frontswap_pages ;
   spinlock_t lock ;
   struct work_struct discard_work ;
   struct swap_cluster_info discard_cluster_head ;
   struct swap_cluster_info discard_cluster_tail ;
};
#line 453 "include/linux/swap.h"
union __anonunion_v_268 {
   short preferred_node ;
   nodemask_t nodes ;
};
#line 453 "include/linux/swap.h"
union __anonunion_w_269 {
   nodemask_t cpuset_mems_allowed ;
   nodemask_t user_nodemask ;
};
#line 453 "include/linux/swap.h"
struct mempolicy {
   atomic_t refcnt ;
   unsigned short mode ;
   unsigned short flags ;
   union __anonunion_v_268 v ;
   union __anonunion_w_269 w ;
};
#line 198 "include/linux/mempolicy.h"
struct xattr_handler {
   char const   *prefix ;
   int flags ;
   size_t (*list)(struct dentry * , char * , size_t  , char const   * , size_t  ,
                  int  ) ;
   int (*get)(struct dentry * , char const   * , void * , size_t  , int  ) ;
   int (*set)(struct dentry * , char const   * , void const   * , size_t  , int  ,
              int  ) ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 760 "include/drm/drm_dp_helper.h"
struct vbt_header {
   u8 signature[20U] ;
   u16 version ;
   u16 header_size ;
   u16 vbt_size ;
   u8 vbt_checksum ;
   u8 reserved0 ;
   u32 bdb_offset ;
   u32 aim_offset[4U] ;
};
#line 38 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct bdb_header {
   u8 signature[16U] ;
   u16 version ;
   u16 header_size ;
   u16 bdb_size ;
};
#line 65 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct bdb_general_features {
   unsigned char panel_fitting : 2 ;
   unsigned char flexaim : 1 ;
   unsigned char msg_enable : 1 ;
   unsigned char clear_screen : 3 ;
   unsigned char color_flip : 1 ;
   unsigned char download_ext_vbt : 1 ;
   unsigned char enable_ssc : 1 ;
   unsigned char ssc_freq : 1 ;
   unsigned char enable_lfp_on_override : 1 ;
   unsigned char disable_ssc_ddt : 1 ;
   unsigned char rsvd8 : 3 ;
   unsigned char disable_smooth_vision : 1 ;
   unsigned char single_dvi : 1 ;
   unsigned char rsvd9 : 6 ;
   u8 legacy_monitor_detect ;
   unsigned char int_crt_support : 1 ;
   unsigned char int_tv_support : 1 ;
   unsigned char int_efp_support : 1 ;
   unsigned char dp_ssc_enb : 1 ;
   unsigned char dp_ssc_freq : 1 ;
   unsigned char rsvd11 : 3 ;
};
#line 217 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct bdb_general_definitions {
   u8 crt_ddc_gmbus_pin ;
   unsigned char dpms_acpi : 1 ;
   unsigned char skip_boot_crt_detect : 1 ;
   unsigned char dpms_aim : 1 ;
   unsigned char rsvd1 : 5 ;
   u8 boot_display[2U] ;
   u8 child_dev_size ;
   struct child_device_config devices[0U] ;
};
#line 246 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct bdb_lvds_options {
   u8 panel_type ;
   u8 rsvd1 ;
   unsigned char pfit_mode : 2 ;
   unsigned char pfit_text_mode_enhanced : 1 ;
   unsigned char pfit_gfx_mode_enhanced : 1 ;
   unsigned char pfit_ratio_auto : 1 ;
   unsigned char pixel_dither : 1 ;
   unsigned char lvds_edid : 1 ;
   unsigned char rsvd2 : 1 ;
   u8 rsvd4 ;
};
#line 287 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct lvds_fp_timing {
   u16 x_res ;
   u16 y_res ;
   u32 lvds_reg ;
   u32 lvds_reg_val ;
   u32 pp_on_reg ;
   u32 pp_on_reg_val ;
   u32 pp_off_reg ;
   u32 pp_off_reg_val ;
   u32 pp_cycle_reg ;
   u32 pp_cycle_reg_val ;
   u32 pfit_reg ;
   u32 pfit_reg_val ;
   u16 terminator ;
};
#line 304 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct lvds_dvo_timing {
   u16 clock ;
   u8 hactive_lo ;
   u8 hblank_lo ;
   unsigned char hblank_hi : 4 ;
   unsigned char hactive_hi : 4 ;
   u8 vactive_lo ;
   u8 vblank_lo ;
   unsigned char vblank_hi : 4 ;
   unsigned char vactive_hi : 4 ;
   u8 hsync_off_lo ;
   u8 hsync_pulse_width ;
   unsigned char vsync_pulse_width : 4 ;
   unsigned char vsync_off : 4 ;
   unsigned char rsvd0 : 6 ;
   unsigned char hsync_off_hi : 2 ;
   u8 h_image ;
   u8 v_image ;
   u8 max_hv ;
   u8 h_border ;
   u8 v_border ;
   unsigned char rsvd1 : 3 ;
   unsigned char digital : 2 ;
   unsigned char vsync_positive : 1 ;
   unsigned char hsync_positive : 1 ;
   unsigned char rsvd2 : 1 ;
};
#line 332 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct lvds_pnp_id {
   u16 mfg_name ;
   u16 product_code ;
   u32 serial ;
   u8 mfg_week ;
   u8 mfg_year ;
};
#line 340 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct bdb_lvds_lfp_data_entry {
   struct lvds_fp_timing fp_timing ;
   struct lvds_dvo_timing dvo_timing ;
   struct lvds_pnp_id pnp_id ;
};
#line 346 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct bdb_lvds_lfp_data {
   struct bdb_lvds_lfp_data_entry data[16U] ;
};
#line 379 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct bdb_sdvo_lvds_options {
   u8 panel_backlight ;
   u8 h40_set_panel_type ;
   u8 panel_type ;
   u8 ssc_clk_freq ;
   u16 als_low_trip ;
   u16 als_high_trip ;
   u8 sclalarcoeff_tab_row_num ;
   u8 sclalarcoeff_tab_row_size ;
   u8 coefficient[8U] ;
   u8 panel_misc_bits_1 ;
   u8 panel_misc_bits_2 ;
   u8 panel_misc_bits_3 ;
   u8 panel_misc_bits_4 ;
};
#line 395 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct bdb_driver_features {
   unsigned char boot_dev_algorithm : 1 ;
   unsigned char block_display_switch : 1 ;
   unsigned char allow_display_switch : 1 ;
   unsigned char hotplug_dvo : 1 ;
   unsigned char dual_view_zoom : 1 ;
   unsigned char int15h_hook : 1 ;
   unsigned char sprite_in_clone : 1 ;
   unsigned char primary_lfp_id : 1 ;
   u16 boot_mode_x ;
   u16 boot_mode_y ;
   u8 boot_mode_bpp ;
   u8 boot_mode_refresh ;
   unsigned char enable_lfp_primary : 1 ;
   unsigned char selective_mode_pruning : 1 ;
   unsigned char dual_frequency : 1 ;
   unsigned char render_clock_freq : 1 ;
   unsigned char nt_clone_support : 1 ;
   unsigned char power_scheme_ui : 1 ;
   unsigned char sprite_display_assign : 1 ;
   unsigned char cui_aspect_scaling : 1 ;
   unsigned char preserve_aspect_ratio : 1 ;
   unsigned char sdvo_device_power_down : 1 ;
   unsigned char crt_hotplug : 1 ;
   unsigned char lvds_config : 2 ;
   unsigned char tv_hotplug : 1 ;
   unsigned char hdmi_config : 2 ;
   unsigned char static_display : 1 ;
   unsigned char reserved2 : 7 ;
   u16 legacy_crt_max_x ;
   u16 legacy_crt_max_y ;
   u8 legacy_crt_max_refresh ;
   u8 hdmi_termination ;
   u8 custom_vbt_version ;
};
#line 465 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct edp_link_params {
   unsigned char rate : 4 ;
   unsigned char lanes : 4 ;
   unsigned char preemphasis : 4 ;
   unsigned char vswing : 4 ;
};
#line 472 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct bdb_edp {
   struct edp_power_seq power_seqs[16U] ;
   u32 color_depth ;
   u32 sdrrs_msa_timing_delay ;
   struct edp_link_params link_params[16U] ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.c"
struct intel_gpio {
   struct i2c_adapter adapter ;
   struct i2c_algo_bit_data algo ;
   struct drm_psb_private *dev_priv ;
   u32 reg ;
};
#line 43 "./arch/x86/include/asm/desc_defs.h"
struct gate_struct64 {
   u16 offset_low ;
   u16 segment ;
   unsigned char ist : 3 ;
   unsigned char zero0 : 5 ;
   unsigned char type : 5 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   u16 offset_middle ;
   u32 offset_high ;
   u32 zero1 ;
};
#line 81 "./arch/x86/include/asm/desc_defs.h"
typedef struct gate_struct64 gate_desc;
#line 84 "./arch/x86/include/asm/desc_defs.h"
struct desc_ptr {
   unsigned short size ;
   unsigned long address ;
};
#line 424 "./arch/x86/include/asm/pgtable_types.h"
struct tss_struct;
#line 102 "./arch/x86/include/asm/paravirt_types.h"
struct pv_cpu_ops {
   unsigned long (*get_debugreg)(int  ) ;
   void (*set_debugreg)(int  , unsigned long  ) ;
   void (*clts)(void) ;
   unsigned long (*read_cr0)(void) ;
   void (*write_cr0)(unsigned long  ) ;
   unsigned long (*read_cr4_safe)(void) ;
   unsigned long (*read_cr4)(void) ;
   void (*write_cr4)(unsigned long  ) ;
   unsigned long (*read_cr8)(void) ;
   void (*write_cr8)(unsigned long  ) ;
   void (*load_tr_desc)(void) ;
   void (*load_gdt)(struct desc_ptr  const  * ) ;
   void (*load_idt)(struct desc_ptr  const  * ) ;
   void (*store_idt)(struct desc_ptr * ) ;
   void (*set_ldt)(void const   * , unsigned int  ) ;
   unsigned long (*store_tr)(void) ;
   void (*load_tls)(struct thread_struct * , unsigned int  ) ;
   void (*load_gs_index)(unsigned int  ) ;
   void (*write_ldt_entry)(struct desc_struct * , int  , void const   * ) ;
   void (*write_gdt_entry)(struct desc_struct * , int  , void const   * , int  ) ;
   void (*write_idt_entry)(gate_desc * , int  , gate_desc const   * ) ;
   void (*alloc_ldt)(struct desc_struct * , unsigned int  ) ;
   void (*free_ldt)(struct desc_struct * , unsigned int  ) ;
   void (*load_sp0)(struct tss_struct * , struct thread_struct * ) ;
   void (*set_iopl_mask)(unsigned int  ) ;
   void (*wbinvd)(void) ;
   void (*io_delay)(void) ;
   void (*cpuid)(unsigned int * , unsigned int * , unsigned int * , unsigned int * ) ;
   u64 (*read_msr)(unsigned int  , int * ) ;
   int (*write_msr)(unsigned int  , unsigned int  , unsigned int  ) ;
   u64 (*read_tsc)(void) ;
   u64 (*read_pmc)(int  ) ;
   unsigned long long (*read_tscp)(unsigned int * ) ;
   void (*usergs_sysret64)(void) ;
   void (*usergs_sysret32)(void) ;
   void (*iret)(void) ;
   void (*swapgs)(void) ;
   void (*start_context_switch)(struct task_struct * ) ;
   void (*end_context_switch)(struct task_struct * ) ;
};
#line 213 "./arch/x86/include/asm/processor.h"
struct x86_hw_tss {
   u32 reserved1 ;
   u64 sp0 ;
   u64 sp1 ;
   u64 sp2 ;
   u64 reserved2 ;
   u64 ist[7U] ;
   u32 reserved3 ;
   u32 reserved4 ;
   u16 reserved5 ;
   u16 io_bitmap_base ;
};
#line 275 "./arch/x86/include/asm/processor.h"
struct tss_struct {
   struct x86_hw_tss x86_tss ;
   unsigned long io_bitmap[1025U] ;
   unsigned long SYSENTER_stack[64U] ;
};
#line 72 "./arch/x86/include/asm/preempt.h"
typedef int pao_T__;
#line 77 "./arch/x86/include/asm/preempt.h"
typedef int pao_T_____0;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 114 "include/drm/drm_crtc_helper.h"
struct drm_encoder_helper_funcs {
   void (*dpms)(struct drm_encoder * , int  ) ;
   void (*save)(struct drm_encoder * ) ;
   void (*restore)(struct drm_encoder * ) ;
   bool (*mode_fixup)(struct drm_encoder * , struct drm_display_mode  const  * , struct drm_display_mode * ) ;
   void (*prepare)(struct drm_encoder * ) ;
   void (*commit)(struct drm_encoder * ) ;
   void (*mode_set)(struct drm_encoder * , struct drm_display_mode * , struct drm_display_mode * ) ;
   struct drm_crtc *(*get_crtc)(struct drm_encoder * ) ;
   enum drm_connector_status (*detect)(struct drm_encoder * , struct drm_connector * ) ;
   void (*disable)(struct drm_encoder * ) ;
   void (*enable)(struct drm_encoder * ) ;
   int (*atomic_check)(struct drm_encoder * , struct drm_crtc_state * , struct drm_connector_state * ) ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 163 "include/drm/drm_crtc_helper.h"
struct drm_connector_helper_funcs {
   int (*get_modes)(struct drm_connector * ) ;
   enum drm_mode_status (*mode_valid)(struct drm_connector * , struct drm_display_mode * ) ;
   struct drm_encoder *(*best_encoder)(struct drm_connector * ) ;
};
#line 596 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_reg.h"
struct psb_intel_lvds_priv {
   uint32_t savePP_ON ;
   uint32_t savePP_OFF ;
   uint32_t saveLVDS ;
   uint32_t savePP_CONTROL ;
   uint32_t savePP_CYCLE ;
   uint32_t savePFIT_CONTROL ;
   uint32_t savePFIT_PGM_RATIOS ;
   uint32_t saveBLC_PWM_CTL ;
   struct psb_intel_i2c_chan *i2c_bus ;
   struct psb_intel_i2c_chan *ddc_bus ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 1331 "include/drm/drm_crtc.h"
struct edid;
#line 32 "include/uapi/linux/types.h"
typedef __u16 __le16;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 1097 "include/drm/drmP.h"
struct est_timings {
   u8 t1 ;
   u8 t2 ;
   u8 mfg_rsvd ;
};
#line 44 "include/drm/drm_edid.h"
struct std_timing {
   u8 hsize ;
   u8 vfreq_aspect ;
};
#line 57 "include/drm/drm_edid.h"
struct detailed_pixel_timing {
   u8 hactive_lo ;
   u8 hblank_lo ;
   u8 hactive_hblank_hi ;
   u8 vactive_lo ;
   u8 vblank_lo ;
   u8 vactive_vblank_hi ;
   u8 hsync_offset_lo ;
   u8 hsync_pulse_width_lo ;
   u8 vsync_offset_pulse_width_lo ;
   u8 hsync_vsync_offset_pulse_width_hi ;
   u8 width_mm_lo ;
   u8 height_mm_lo ;
   u8 width_height_mm_hi ;
   u8 hborder ;
   u8 vborder ;
   u8 misc ;
};
#line 83 "include/drm/drm_edid.h"
struct detailed_data_string {
   u8 str[13U] ;
};
#line 88 "include/drm/drm_edid.h"
struct __anonstruct_gtf2_259 {
   u8 reserved ;
   u8 hfreq_start_khz ;
   u8 c ;
   __le16 m ;
   u8 k ;
   u8 j ;
};
#line 88 "include/drm/drm_edid.h"
struct __anonstruct_cvt_260 {
   u8 version ;
   u8 data1 ;
   u8 data2 ;
   u8 supported_aspects ;
   u8 flags ;
   u8 supported_scalings ;
   u8 preferred_refresh ;
};
#line 88 "include/drm/drm_edid.h"
union __anonunion_formula_258 {
   struct __anonstruct_gtf2_259 gtf2 ;
   struct __anonstruct_cvt_260 cvt ;
};
#line 88 "include/drm/drm_edid.h"
struct detailed_data_monitor_range {
   u8 min_vfreq ;
   u8 max_vfreq ;
   u8 min_hfreq_khz ;
   u8 max_hfreq_khz ;
   u8 pixel_clock_mhz ;
   u8 flags ;
   union __anonunion_formula_258 formula ;
};
#line 116 "include/drm/drm_edid.h"
struct detailed_data_wpindex {
   u8 white_yx_lo ;
   u8 white_x_hi ;
   u8 white_y_hi ;
   u8 gamma ;
};
#line 130 "include/drm/drm_edid.h"
struct cvt_timing {
   u8 code[3U] ;
};
#line 134 "include/drm/drm_edid.h"
union __anonunion_data_261 {
   struct detailed_data_string str ;
   struct detailed_data_monitor_range range ;
   struct detailed_data_wpindex color ;
   struct std_timing timings[6U] ;
   struct cvt_timing cvt[4U] ;
};
#line 134 "include/drm/drm_edid.h"
struct detailed_non_pixel {
   u8 pad1 ;
   u8 type ;
   u8 pad2 ;
   union __anonunion_data_261 data ;
};
#line 149 "include/drm/drm_edid.h"
union __anonunion_data_262 {
   struct detailed_pixel_timing pixel_data ;
   struct detailed_non_pixel other_data ;
};
#line 149 "include/drm/drm_edid.h"
struct detailed_timing {
   __le16 pixel_clock ;
   union __anonunion_data_262 data ;
};
#line 167 "include/drm/drm_edid.h"
struct edid {
   u8 header[8U] ;
   u8 mfg_id[2U] ;
   u8 prod_code[2U] ;
   u32 serial ;
   u8 mfg_week ;
   u8 mfg_year ;
   u8 version ;
   u8 revision ;
   u8 input ;
   u8 width_cm ;
   u8 height_cm ;
   u8 gamma ;
   u8 features ;
   u8 red_green_lo ;
   u8 black_white_lo ;
   u8 red_x ;
   u8 red_y ;
   u8 green_x ;
   u8 green_y ;
   u8 blue_x ;
   u8 blue_y ;
   u8 white_x ;
   u8 white_y ;
   struct est_timings established_timings ;
   struct std_timing standard_timings[8U] ;
   struct detailed_timing detailed_timings[4U] ;
   u8 extensions ;
   u8 checksum ;
};
#line 897 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct psb_intel_sdvo_caps {
   u8 vendor_id ;
   u8 device_id ;
   u8 device_rev_id ;
   u8 sdvo_version_major ;
   u8 sdvo_version_minor ;
   unsigned char sdvo_inputs_mask : 2 ;
   unsigned char smooth_scaling : 1 ;
   unsigned char sharp_scaling : 1 ;
   unsigned char up_scaling : 1 ;
   unsigned char down_scaling : 1 ;
   unsigned char stall_support : 1 ;
   unsigned char pad : 1 ;
   u16 output_flags ;
};
#line 63 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_sdvo_regs.h"
struct __anonstruct_part1_270 {
   u16 clock ;
   u8 h_active ;
   u8 h_blank ;
   u8 h_high ;
   u8 v_active ;
   u8 v_blank ;
   u8 v_high ;
};
#line 63 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_sdvo_regs.h"
struct __anonstruct_part2_271 {
   u8 h_sync_off ;
   u8 h_sync_width ;
   u8 v_sync_off_width ;
   u8 sync_off_width_high ;
   u8 dtd_flags ;
   u8 sdvo_flags ;
   u8 v_sync_off_high ;
   u8 reserved ;
};
#line 63 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_sdvo_regs.h"
struct psb_intel_sdvo_dtd {
   struct __anonstruct_part1_270 part1 ;
   struct __anonstruct_part2_271 part2 ;
};
#line 93 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_sdvo_regs.h"
struct psb_intel_sdvo_pixel_clock_range {
   u16 min ;
   u16 max ;
};
#line 98 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_sdvo_regs.h"
struct psb_intel_sdvo_preferred_input_timing_args {
   u16 clock ;
   u16 width ;
   u16 height ;
   unsigned char interlace : 1 ;
   unsigned char scaled : 1 ;
   unsigned char pad : 6 ;
};
#line 107 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_sdvo_regs.h"
struct psb_intel_sdvo_get_trained_inputs_response {
   unsigned char input0_trained : 1 ;
   unsigned char input1_trained : 1 ;
   unsigned char pad : 6 ;
};
#line 161 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_sdvo_regs.h"
struct psb_intel_sdvo_in_out_map {
   u16 in0 ;
   u16 in1 ;
};
#line 218 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_sdvo_regs.h"
struct psb_intel_sdvo_set_target_input_args {
   unsigned char target_1 : 1 ;
   unsigned char pad : 7 ;
};
#line 231 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_sdvo_regs.h"
struct psb_intel_sdvo_tv_format {
   unsigned char ntsc_m : 1 ;
   unsigned char ntsc_j : 1 ;
   unsigned char ntsc_443 : 1 ;
   unsigned char pal_b : 1 ;
   unsigned char pal_d : 1 ;
   unsigned char pal_g : 1 ;
   unsigned char pal_h : 1 ;
   unsigned char pal_i : 1 ;
   unsigned char pal_m : 1 ;
   unsigned char pal_n : 1 ;
   unsigned char pal_nc : 1 ;
   unsigned char pal_60 : 1 ;
   unsigned char secam_b : 1 ;
   unsigned char secam_d : 1 ;
   unsigned char secam_g : 1 ;
   unsigned char secam_k : 1 ;
   unsigned char secam_k1 : 1 ;
   unsigned char secam_l : 1 ;
   unsigned char secam_60 : 1 ;
   unsigned char hdtv_std_smpte_240m_1080i_59 : 1 ;
   unsigned char hdtv_std_smpte_240m_1080i_60 : 1 ;
   unsigned char hdtv_std_smpte_260m_1080i_59 : 1 ;
   unsigned char hdtv_std_smpte_260m_1080i_60 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080i_50 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080i_59 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080i_60 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_23 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_24 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_25 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_29 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_30 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_50 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_59 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_60 : 1 ;
   unsigned char hdtv_std_smpte_295m_1080i_50 : 1 ;
   unsigned char hdtv_std_smpte_295m_1080p_50 : 1 ;
   unsigned char hdtv_std_smpte_296m_720p_59 : 1 ;
   unsigned char hdtv_std_smpte_296m_720p_60 : 1 ;
   unsigned char hdtv_std_smpte_296m_720p_50 : 1 ;
   unsigned char hdtv_std_smpte_293m_480p_59 : 1 ;
   unsigned char hdtv_std_smpte_170m_480i_59 : 1 ;
   unsigned char hdtv_std_iturbt601_576i_50 : 1 ;
   unsigned char hdtv_std_iturbt601_576p_50 : 1 ;
   unsigned char hdtv_std_eia_7702a_480i_60 : 1 ;
   unsigned char hdtv_std_eia_7702a_480p_60 : 1 ;
   unsigned char pad : 3 ;
};
#line 369 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_sdvo_regs.h"
struct psb_intel_sdvo_sdtv_resolution_request {
   unsigned char ntsc_m : 1 ;
   unsigned char ntsc_j : 1 ;
   unsigned char ntsc_443 : 1 ;
   unsigned char pal_b : 1 ;
   unsigned char pal_d : 1 ;
   unsigned char pal_g : 1 ;
   unsigned char pal_h : 1 ;
   unsigned char pal_i : 1 ;
   unsigned char pal_m : 1 ;
   unsigned char pal_n : 1 ;
   unsigned char pal_nc : 1 ;
   unsigned char pal_60 : 1 ;
   unsigned char secam_b : 1 ;
   unsigned char secam_d : 1 ;
   unsigned char secam_g : 1 ;
   unsigned char secam_k : 1 ;
   unsigned char secam_k1 : 1 ;
   unsigned char secam_l : 1 ;
   unsigned char secam_60 : 1 ;
   unsigned char pad : 5 ;
};
#line 579 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_sdvo_regs.h"
struct psb_intel_sdvo_enhancements_reply {
   unsigned char flicker_filter : 1 ;
   unsigned char flicker_filter_adaptive : 1 ;
   unsigned char flicker_filter_2d : 1 ;
   unsigned char saturation : 1 ;
   unsigned char hue : 1 ;
   unsigned char brightness : 1 ;
   unsigned char contrast : 1 ;
   unsigned char overscan_h : 1 ;
   unsigned char overscan_v : 1 ;
   unsigned char hpos : 1 ;
   unsigned char vpos : 1 ;
   unsigned char sharpness : 1 ;
   unsigned char dot_crawl : 1 ;
   unsigned char dither : 1 ;
   unsigned char tv_chroma_filter : 1 ;
   unsigned char tv_luma_filter : 1 ;
};
#line 670 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_sdvo_regs.h"
struct psb_intel_sdvo_encode {
   u8 dvi_rev ;
   u8 hdmi_rev ;
};
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
struct psb_intel_sdvo {
   struct gma_encoder base ;
   struct i2c_adapter *i2c ;
   u8 slave_addr ;
   struct i2c_adapter ddc ;
   int sdvo_reg ;
   uint16_t controlled_output ;
   struct psb_intel_sdvo_caps caps ;
   int pixel_clock_min ;
   int pixel_clock_max ;
   uint16_t attached_output ;
   uint32_t color_range ;
   bool is_tv ;
   int tv_format_index ;
   bool is_hdmi ;
   bool has_hdmi_monitor ;
   bool has_hdmi_audio ;
   bool is_lvds ;
   struct drm_display_mode *sdvo_lvds_fixed_mode ;
   uint8_t ddc_bus ;
   struct psb_intel_sdvo_dtd input_dtd ;
   uint32_t saveSDVO ;
};
#line 141 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
struct psb_intel_sdvo_connector {
   struct gma_connector base ;
   uint16_t output_flag ;
   int force_audio ;
   u8 tv_format_supported[19U] ;
   int format_supported_num ;
   struct drm_property *tv_format ;
   struct drm_property *left ;
   struct drm_property *right ;
   struct drm_property *top ;
   struct drm_property *bottom ;
   struct drm_property *hpos ;
   struct drm_property *vpos ;
   struct drm_property *contrast ;
   struct drm_property *saturation ;
   struct drm_property *hue ;
   struct drm_property *sharpness ;
   struct drm_property *flicker_filter ;
   struct drm_property *flicker_filter_adaptive ;
   struct drm_property *flicker_filter_2d ;
   struct drm_property *tv_chroma_filter ;
   struct drm_property *tv_luma_filter ;
   struct drm_property *dot_crawl ;
   struct drm_property *brightness ;
   u32 left_margin ;
   u32 right_margin ;
   u32 top_margin ;
   u32 bottom_margin ;
   u32 max_hscan ;
   u32 max_vscan ;
   u32 max_hpos ;
   u32 cur_hpos ;
   u32 max_vpos ;
   u32 cur_vpos ;
   u32 cur_brightness ;
   u32 max_brightness ;
   u32 cur_contrast ;
   u32 max_contrast ;
   u32 cur_saturation ;
   u32 max_saturation ;
   u32 cur_hue ;
   u32 max_hue ;
   u32 cur_sharpness ;
   u32 max_sharpness ;
   u32 cur_flicker_filter ;
   u32 max_flicker_filter ;
   u32 cur_flicker_filter_adaptive ;
   u32 max_flicker_filter_adaptive ;
   u32 cur_flicker_filter_2d ;
   u32 max_flicker_filter_2d ;
   u32 cur_tv_chroma_filter ;
   u32 max_tv_chroma_filter ;
   u32 cur_tv_luma_filter ;
   u32 max_tv_luma_filter ;
   u32 cur_dot_crawl ;
   u32 max_dot_crawl ;
};
#line 278 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
struct _sdvo_cmd_name {
   u8 cmd ;
   char const   *name ;
};
#line 2448 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
union __anonunion_enhancements_280 {
   struct psb_intel_sdvo_enhancements_reply reply ;
   uint16_t response ;
};
#line 243 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 659 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
typedef int ldv_func_ret_type___7;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 54 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/oaktrail.h"
struct gct_r10_timing_info {
   u16 pixel_clock ;
   unsigned char hactive_lo ;
   unsigned char hactive_hi : 4 ;
   unsigned char hblank_lo ;
   unsigned char hblank_hi : 4 ;
   unsigned char hsync_offset_lo ;
   unsigned char hsync_offset_hi : 2 ;
   unsigned char hsync_pulse_width_lo ;
   unsigned char hsync_pulse_width_hi : 2 ;
   unsigned char hsync_positive : 1 ;
   unsigned char rsvd_1 : 3 ;
   u8 vactive_lo ;
   unsigned char vactive_hi : 4 ;
   unsigned char vblank_lo ;
   unsigned char vblank_hi : 4 ;
   unsigned char vsync_offset_lo : 4 ;
   unsigned char vsync_offset_hi : 2 ;
   unsigned char vsync_pulse_width_lo : 4 ;
   unsigned char vsync_pulse_width_hi : 2 ;
   unsigned char vsync_positive : 1 ;
   unsigned char rsvd_2 : 3 ;
};
#line 78 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/oaktrail.h"
struct oaktrail_panel_descriptor_v1 {
   u32 Panel_Port_Control ;
   u32 Panel_Power_On_Sequencing ;
   u32 Panel_Power_Off_Sequencing ;
   u32 Panel_Power_Cycle_Delay_and_Reference_Divisor ;
   struct oaktrail_timing_info DTD ;
   u16 Panel_Backlight_Inverter_Descriptor ;
   u16 Panel_MIPI_Display_Descriptor ;
};
#line 92 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/oaktrail.h"
struct oaktrail_panel_descriptor_v2 {
   u32 Panel_Port_Control ;
   u32 Panel_Power_On_Sequencing ;
   u32 Panel_Power_Off_Sequencing ;
   u8 Panel_Power_Cycle_Delay_and_Reference_Divisor ;
   struct oaktrail_timing_info DTD ;
   u16 Panel_Backlight_Inverter_Descriptor ;
   u8 Panel_Initial_Brightness ;
   u16 Panel_MIPI_Display_Descriptor ;
};
#line 122 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/oaktrail.h"
struct __anonstruct_panelrx_258 {
   unsigned char NumberOfLanes : 2 ;
   unsigned char MaxLaneFreq : 3 ;
   unsigned char SupportedVideoTransferMode : 2 ;
   unsigned char HSClkBehavior : 1 ;
   unsigned char DuoDisplaySupport : 1 ;
   unsigned char ECC_ChecksumCapabilities : 1 ;
   unsigned char BidirectionalCommunication : 1 ;
   unsigned char Rsvd : 5 ;
};
#line 122 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/oaktrail.h"
union oaktrail_panel_rx {
   struct __anonstruct_panelrx_258 panelrx ;
   u16 panel_receiver ;
};
#line 155 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/oaktrail.h"
struct __anonstruct_PD_260 {
   unsigned char PanelType : 4 ;
   unsigned char BootPanelIndex : 2 ;
   unsigned char BootMIPI_DSI_RxIndex : 2 ;
};
#line 155 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/oaktrail.h"
union __anonunion____missing_field_name_259 {
   struct __anonstruct_PD_260 PD ;
   u8 PanelDescriptor ;
};
#line 155 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/oaktrail.h"
struct gct_r0 {
   union __anonunion____missing_field_name_259 __annonCompField77 ;
   struct oaktrail_panel_descriptor_v1 panel[4U] ;
   union oaktrail_panel_rx panelrx[4U] ;
};
#line 172 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/oaktrail.h"
struct __anonstruct_PD_262 {
   unsigned char PanelType : 4 ;
   unsigned char BootPanelIndex : 2 ;
   unsigned char BootMIPI_DSI_RxIndex : 2 ;
};
#line 172 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/oaktrail.h"
union __anonunion____missing_field_name_261 {
   struct __anonstruct_PD_262 PD ;
   u8 PanelDescriptor ;
};
#line 172 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/oaktrail.h"
struct gct_r1 {
   union __anonunion____missing_field_name_261 __annonCompField78 ;
   struct oaktrail_panel_descriptor_v2 panel[4U] ;
   union oaktrail_panel_rx panelrx[4U] ;
};
#line 189 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/oaktrail.h"
struct gct_r10 {
   struct gct_r10_timing_info DTD ;
   u16 Panel_MIPI_Display_Descriptor ;
   u16 Panel_MIPI_Receiver_Descriptor ;
   u16 Panel_Backlight_Inverter_Descriptor ;
   u8 Panel_Initial_Brightness ;
   u32 MIPI_Ctlr_Init_ptr ;
   u32 MIPI_Panel_Init_ptr ;
};
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c"
struct mid_vbt_header {
   u32 signature ;
   u8 revision ;
};
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c"
struct vbt_r0 {
   struct mid_vbt_header vbt_header ;
   u8 size ;
   u8 checksum ;
};
#line 131 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c"
struct vbt_r10 {
   struct mid_vbt_header vbt_header ;
   u8 checksum ;
   u16 size ;
   u8 panel_count ;
   u8 primary_panel_idx ;
   u8 secondary_panel_idx ;
   u8 __reserved[5U] ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 161 "include/acpi/actypes.h"
typedef u64 acpi_size;
#line 163 "include/acpi/actypes.h"
typedef u64 acpi_physical_address;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 596 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_reg.h"
struct opregion_header {
   u8 signature[16U] ;
   u32 size ;
   u32 opregion_ver ;
   u8 bios_ver[32U] ;
   u8 vbios_ver[16U] ;
   u8 driver_ver[16U] ;
   u32 mboxes ;
   u8 reserved[164U] ;
};
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.c"
struct opregion_acpi {
   u32 drdy ;
   u32 csts ;
   u32 cevt ;
   u8 rsvd1[20U] ;
   u32 didl[8U] ;
   u32 cpdl[8U] ;
   u32 cadl[8U] ;
   u32 nadl[8U] ;
   u32 aslp ;
   u32 tidx ;
   u32 chpd ;
   u32 clid ;
   u32 cdck ;
   u32 sxsw ;
   u32 evts ;
   u32 cnot ;
   u32 nrdy ;
   u8 rsvd2[60U] ;
};
#line 76 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.c"
struct opregion_swsci {

};
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.c"
struct opregion_asle {
   u32 ardy ;
   u32 aslc ;
   u32 tche ;
   u32 alsi ;
   u32 bclp ;
   u32 pfit ;
   u32 cblv ;
   u16 bclm[20U] ;
   u32 cpfm ;
   u32 epfm ;
   u8 plut[74U] ;
   u32 pfmb ;
   u8 rsvd[102U] ;
};
#line 786 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
typedef bool ldv_func_ret_type___8;
#line 91 "include/linux/types.h"
typedef unsigned int uint;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 31 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/cdv_device.h"
struct mdfld_hdmi_i2c;
#line 31 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/cdv_device.h"
struct mid_intel_hdmi_priv {
   u32 hdmi_reg ;
   u32 save_HDMIB ;
   bool has_hdmi_sink ;
   bool has_hdmi_audio ;
   bool hdmi_device_connected ;
   struct mdfld_hdmi_i2c *i2c_bus ;
   struct i2c_adapter *hdmi_i2c_adapter ;
   struct drm_device *dev ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 31 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/cdv_device.h"
struct cdv_intel_lvds_priv {
   uint32_t savePP_ON ;
   uint32_t savePP_OFF ;
   uint32_t saveLVDS ;
   uint32_t savePP_CONTROL ;
   uint32_t savePP_CYCLE ;
   uint32_t savePFIT_CONTROL ;
   uint32_t savePFIT_PGM_RATIOS ;
   uint32_t saveBLC_PWM_CTL ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 596 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_reg.h"
struct i2c_algo_dp_aux_data {
   bool running ;
   u16 address ;
   int (*aux_ch)(struct i2c_adapter * , int  , uint8_t  , uint8_t * ) ;
};
#line 234 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
struct cdv_intel_dp {
   uint32_t output_reg ;
   uint32_t DP ;
   uint8_t link_configuration[9U] ;
   bool has_audio ;
   int force_audio ;
   uint32_t color_range ;
   uint8_t link_bw ;
   uint8_t lane_count ;
   uint8_t dpcd[4U] ;
   struct gma_encoder *encoder ;
   struct i2c_adapter adapter ;
   struct i2c_algo_dp_aux_data algo ;
   uint8_t train_set[4U] ;
   uint8_t link_status[6U] ;
   int panel_power_up_delay ;
   int panel_power_down_delay ;
   int panel_power_cycle_delay ;
   int backlight_on_delay ;
   int backlight_off_delay ;
   struct drm_display_mode *panel_fixed_mode ;
   bool panel_on ;
};
#line 280 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
struct ddi_regoff {
   uint32_t PreEmph1 ;
   uint32_t PreEmph2 ;
   uint32_t VSwing1 ;
   uint32_t VSwing2 ;
   uint32_t VSwing3 ;
   uint32_t VSwing4 ;
   uint32_t VSwing5 ;
};
#line 944 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
struct cdv_intel_dp_m_n {
   uint32_t tu ;
   uint32_t gmch_m ;
   uint32_t gmch_n ;
   uint32_t link_m ;
   uint32_t link_n ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 897 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct intel_range {
   int min ;
   int max ;
};
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
struct oaktrail_hdmi_limit {
   struct intel_range vco ;
   struct intel_range np ;
   struct intel_range nr ;
   struct intel_range nf ;
};
#line 104 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
struct oaktrail_hdmi_clock {
   int np ;
   int nr ;
   int nf ;
   int dot ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 897 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct hdmi_i2c_dev {
   struct i2c_adapter *adap ;
   struct mutex i2c_lock ;
   struct completion complete ;
   int status ;
   struct i2c_msg *msg ;
   int buf_offset ;
};
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 57 "./arch/x86/include/asm/string_64.h"
extern void *memset(void * , int  , size_t  ) ;
#line 561 "./arch/x86/include/asm/processor.h"
__inline static void rep_nop(void) 
{ 


  {
#line 563
  __asm__  volatile   ("rep; nop": : : "memory");
#line 564
  return;
}
}
#line 566 "./arch/x86/include/asm/processor.h"
__inline static void cpu_relax(void) 
{ 


  {
#line 568
  rep_nop();
#line 569
  return;
}
}
#line 173 "include/linux/mutex.h"
extern int mutex_trylock(struct mutex * ) ;
#line 176
int ldv_mutex_trylock_15(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_22(struct mutex *ldv_func_arg1 ) ;
#line 182
extern void mutex_unlock(struct mutex * ) ;
#line 185
void ldv_mutex_unlock_11(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_12(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_16(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_18(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_19(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_25(struct mutex *ldv_func_arg1 ) ;
#line 6 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t  ) ;
#line 7
extern void *calloc(size_t  , size_t  ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int  ) ;
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
#line 53
  tmp = calloc(1UL, size);
#line 53
  p = tmp;
#line 54
  __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 55
  return (p);
}
}
#line 58 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
#line 59
  tmp = memset(s, c, n);
#line 59
  return (tmp);
}
}
#line 62 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 63
  tmp = __VERIFIER_nondet_int();
#line 63
  return (tmp);
}
}
#line 66 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 67
  tmp = __VERIFIER_nondet_pointer();
#line 67
  return (tmp);
}
}
#line 70 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 71
  tmp = __VERIFIER_nondet_ulong();
#line 71
  return (tmp);
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 54
  return (exp);
}
}
#line 16 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
extern int mutex_lock_interruptible(struct mutex * ) ;
#line 19
int ldv_mutex_lock_interruptible_21(struct mutex *ldv_func_arg1 ) ;
#line 22
extern void mutex_lock(struct mutex * ) ;
#line 25
void ldv_mutex_lock_10(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_13(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_14(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_17(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_20(struct mutex *ldv_func_arg1 ) ;
#line 43
int ldv_mutex_lock_interruptible_base_of_ww_mutex(struct mutex *lock ) ;
#line 46
void ldv_mutex_lock_base_of_ww_mutex(struct mutex *lock ) ;
#line 47
int ldv_mutex_trylock_base_of_ww_mutex(struct mutex *lock ) ;
#line 85
void ldv_mutex_lock_i_mutex_of_inode(struct mutex *lock ) ;
#line 89
void ldv_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) ;
#line 98
void ldv_mutex_lock_lock(struct mutex *lock ) ;
#line 102
void ldv_mutex_unlock_lock(struct mutex *lock ) ;
#line 115
void ldv_mutex_unlock_lock_of_fb_info(struct mutex *lock ) ;
#line 124
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) ;
#line 125
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) ;
#line 128
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) ;
#line 167
void ldv_mutex_unlock_struct_mutex_of_drm_device(struct mutex *lock ) ;
#line 176
void ldv_mutex_lock_update_lock_of_backlight_device(struct mutex *lock ) ;
#line 180
void ldv_mutex_unlock_update_lock_of_backlight_device(struct mutex *lock ) ;
#line 34 "include/linux/spinlock_api_smp.h"
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
#line 45
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 299 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 301
  return (& lock->__annonCompField17.rlock);
}
}
#line 370 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 372
  _raw_spin_unlock_irqrestore(& lock->__annonCompField17.rlock, flags);
#line 373
  return;
}
}
#line 78 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 429 "include/linux/workqueue.h"
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
#line 433
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 439
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
#line 443
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 452
extern void flush_workqueue(struct workqueue_struct * ) ;
#line 455
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) ;
#line 31 "include/asm-generic/iomap.h"
extern unsigned int ioread32(void * ) ;
#line 37
extern void iowrite32(u32  , void * ) ;
#line 219 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
int ldv_irq_1_3  =    0;
#line 235 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 238 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
int ldv_irq_1_1  =    0;
#line 277 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
int ldv_timer_state_4  =    0;
#line 291 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
int ldv_irq_1_0  =    0;
#line 316 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
int ldv_irq_1_2  =    0;
#line 340
void call_and_disable_all_2(int state ) ;
#line 373
void activate_work_2(struct work_struct *work , int state ) ;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 600 "include/linux/fb.h"
extern void cfb_copyarea(struct fb_info * , struct fb_copyarea  const  * ) ;
#line 52 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/power.h"
bool gma_power_begin(struct drm_device *dev , bool force_on ) ;
#line 53
void gma_power_end(struct drm_device *dev ) ;
#line 705 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
void psbfb_copyarea(struct fb_info *info , struct fb_copyarea  const  *region ) ;
#line 707
int psbfb_sync(struct fb_info *info ) ;
#line 708
void psb_spank(struct drm_psb_private *dev_priv ) ;
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.c"
void psb_spank(struct drm_psb_private *dev_priv ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 53
  iowrite32(127U, (void *)dev_priv->sgx_reg + 128U);
#line 57
  ioread32((void *)dev_priv->sgx_reg + 128U);
#line 59
  msleep(1U);
#line 61
  iowrite32(0U, (void *)dev_priv->sgx_reg + 128U);
#line 62
  __asm__  volatile   ("sfence": : : "memory");
#line 63
  tmp = ioread32((void *)dev_priv->sgx_reg + 3072U);
#line 63
  iowrite32(tmp | 16U, (void *)dev_priv->sgx_reg + 3072U);
#line 65
  __asm__  volatile   ("sfence": : : "memory");
#line 66
  ioread32((void *)dev_priv->sgx_reg + 3072U);
#line 68
  msleep(1U);
#line 69
  tmp___0 = ioread32((void *)dev_priv->sgx_reg + 3072U);
#line 69
  iowrite32(tmp___0 & 4294967279U, (void *)dev_priv->sgx_reg + 3072U);
#line 71
  ioread32((void *)dev_priv->sgx_reg + 3072U);
#line 72
  iowrite32(dev_priv->gtt.gatt_start, (void *)dev_priv->sgx_reg + 3208U);
#line 73
  return;
}
}
#line 83 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.c"
static int psb_2d_wait_available(struct drm_psb_private *dev_priv , unsigned int size ) 
{ 
  uint32_t avail ;
  unsigned int tmp ;
  unsigned long t ;

  {
#line 86
  tmp = ioread32((void *)dev_priv->sgx_reg + 3608U);
#line 86
  avail = tmp;
#line 87
  t = (unsigned long )jiffies + 250UL;
#line 89
  goto ldv_43072;
  ldv_43071: 
#line 90
  avail = ioread32((void *)dev_priv->sgx_reg + 3608U);
#line 91
  if ((long )(t - (unsigned long )jiffies) < 0L) {
#line 92
    psb_spank(dev_priv);
#line 93
    return (-5);
  } else {

  }
  ldv_43072: ;
#line 89
  if (avail < size) {
#line 91
    goto ldv_43071;
  } else {

  }

#line 96
  return (0);
}
}
#line 108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.c"
static int psbfb_2d_submit(struct drm_psb_private *dev_priv , uint32_t *cmdbuf , unsigned int size ) 
{ 
  int ret ;
  int i ;
  unsigned int submit_size ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  uint32_t *tmp___0 ;

  {
#line 111
  ret = 0;
#line 116
  tmp = spinlock_check(& dev_priv->lock_2d);
#line 116
  flags = _raw_spin_lock_irqsave(tmp);
#line 117
  goto ldv_43091;
  ldv_43090: 
#line 118
  submit_size = 96U < size ? 96U : size;
#line 119
  size = size - submit_size;
#line 120
  ret = psb_2d_wait_available(dev_priv, submit_size);
#line 121
  if (ret != 0) {
#line 122
    goto ldv_43086;
  } else {

  }
#line 124
  submit_size = submit_size << 2;
#line 126
  i = 0;
#line 126
  goto ldv_43088;
  ldv_43087: 
#line 127
  tmp___0 = cmdbuf;
#line 127
  cmdbuf = cmdbuf + 1;
#line 127
  iowrite32(*tmp___0, (void *)dev_priv->sgx_reg + (unsigned long )(i + 16384));
#line 126
  i = i + 4;
  ldv_43088: ;
#line 126
  if ((unsigned int )i < submit_size) {
#line 128
    goto ldv_43087;
  } else {

  }
#line 129
  ioread32((void *)(dev_priv->sgx_reg + ((unsigned long )(i + 16384) + 0xfffffffffffffffcUL)));
  ldv_43091: ;
#line 117
  if (size != 0U) {
#line 119
    goto ldv_43090;
  } else {

  }
  ldv_43086: 
#line 131
  spin_unlock_irqrestore(& dev_priv->lock_2d, flags);
#line 132
  return (ret);
}
}
#line 144 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.c"
static u32 psb_accel_2d_copy_direction(int xdir , int ydir ) 
{ 


  {
#line 146
  if (xdir < 0) {
#line 147
    return (ydir < 0 ? 8388608U : 16777216U);
  } else {
#line 150
    return (ydir < 0 ? 25165824U : 0U);
  }
}
}
#line 172 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.c"
static int psb_accel_2d_copy(struct drm_psb_private *dev_priv , uint32_t src_offset ,
                             uint32_t src_stride , uint32_t src_format , uint32_t dst_offset ,
                             uint32_t dst_stride , uint32_t dst_format , uint16_t src_x ,
                             uint16_t src_y , uint16_t dst_x , uint16_t dst_y , uint16_t size_x ,
                             uint16_t size_y ) 
{ 
  uint32_t blit_cmd ;
  uint32_t buffer[10U] ;
  uint32_t *buf ;
  uint32_t direction ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t *tmp___6 ;
  uint32_t *tmp___7 ;
  uint32_t *tmp___8 ;
  int tmp___9 ;

  {
#line 185
  buf = (uint32_t *)(& buffer);
#line 187
  direction = psb_accel_2d_copy_direction((int )src_x - (int )dst_x, (int )src_y - (int )dst_y);
#line 190
  if (direction == 8388608U || direction == 16777216U) {
#line 192
    src_x = (unsigned int )((int )size_x + (int )src_x) + 65535U;
#line 193
    dst_x = (unsigned int )((int )size_x + (int )dst_x) + 65535U;
  } else {

  }
#line 195
  if (direction == 8388608U || direction == 25165824U) {
#line 197
    src_y = (unsigned int )((int )size_y + (int )src_y) + 65535U;
#line 198
    dst_y = (unsigned int )((int )size_y + (int )dst_y) + 65535U;
  } else {

  }
#line 201
  blit_cmd = direction | 2147601612U;
#line 208
  tmp = buf;
#line 208
  buf = buf + 1;
#line 208
  *tmp = 1879048192U;
#line 209
  tmp___0 = buf;
#line 209
  buf = buf + 1;
#line 209
  *tmp___0 = (dst_format | dst_stride) | 2684354560U;
#line 212
  tmp___1 = buf;
#line 212
  buf = buf + 1;
#line 212
  *tmp___1 = dst_offset;
#line 213
  tmp___2 = buf;
#line 213
  buf = buf + 1;
#line 213
  *tmp___2 = (src_format | src_stride) | 2415919104U;
#line 216
  tmp___3 = buf;
#line 216
  buf = buf + 1;
#line 216
  *tmp___3 = src_offset;
#line 217
  tmp___4 = buf;
#line 217
  buf = buf + 1;
#line 217
  *tmp___4 = (uint32_t )((((int )src_x << 12) | 805306368) | (int )src_y);
#line 220
  tmp___5 = buf;
#line 220
  buf = buf + 1;
#line 220
  *tmp___5 = blit_cmd;
#line 221
  tmp___6 = buf;
#line 221
  buf = buf + 1;
#line 221
  *tmp___6 = (uint32_t )(((int )dst_x << 12) | (int )dst_y);
#line 224
  tmp___7 = buf;
#line 224
  buf = buf + 1;
#line 224
  *tmp___7 = (uint32_t )(((int )size_x << 12) | (int )size_y);
#line 227
  tmp___8 = buf;
#line 227
  buf = buf + 1;
#line 227
  *tmp___8 = 4026531840U;
#line 229
  tmp___9 = psbfb_2d_submit(dev_priv, (uint32_t *)(& buffer), (unsigned int )(((long )buf - (long )(& buffer)) / 4L));
#line 229
  return (tmp___9);
}
}
#line 239 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.c"
static void psbfb_copyarea_accel(struct fb_info *info , struct fb_copyarea  const  *a ) 
{ 
  struct psb_fbdev *fbdev ;
  struct psb_framebuffer *psbfb ;
  struct drm_device *dev ;
  struct drm_framebuffer *fb ;
  struct drm_psb_private *dev_priv ;
  uint32_t offset ;
  uint32_t stride ;
  uint32_t src_format ;
  uint32_t dst_format ;
  bool tmp ;
  int tmp___0 ;

  {
#line 242
  fbdev = (struct psb_fbdev *)info->par;
#line 243
  psbfb = & fbdev->pfb;
#line 244
  dev = psbfb->base.dev;
#line 245
  fb = fbdev->psb_fb_helper.fb;
#line 246
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 252
  if ((unsigned long )fb == (unsigned long )((struct drm_framebuffer *)0)) {
#line 253
    return;
  } else {

  }
#line 255
  offset = (psbfb->gtt)->offset;
#line 256
  stride = fb->pitches[0];
#line 258
  switch (fb->depth) {
  case 8U: 
#line 260
  src_format = 196608U;
#line 261
  dst_format = 196608U;
#line 262
  goto ldv_43129;
  case 15U: 
#line 264
  src_format = 262144U;
#line 265
  dst_format = 262144U;
#line 266
  goto ldv_43129;
  case 16U: 
#line 268
  src_format = 327680U;
#line 269
  dst_format = 327680U;
#line 270
  goto ldv_43129;
  case 24U: ;
  case 32U: 
#line 274
  src_format = 393216U;
#line 275
  dst_format = 393216U;
#line 276
  goto ldv_43129;
  default: 
#line 279
  cfb_copyarea(info, a);
#line 280
  return;
  }
  ldv_43129: 
#line 283
  tmp = gma_power_begin(dev, 0);
#line 283
  if (tmp) {
#line 283
    tmp___0 = 0;
  } else {
#line 283
    tmp___0 = 1;
  }
#line 283
  if (tmp___0) {
#line 284
    cfb_copyarea(info, a);
#line 285
    return;
  } else {

  }
#line 287
  psb_accel_2d_copy(dev_priv, offset, stride, src_format, offset, stride, dst_format,
                    (int )((uint16_t )a->sx), (int )((uint16_t )a->sy), (int )((uint16_t )a->dx),
                    (int )((uint16_t )a->dy), (int )((uint16_t )a->width), (int )((uint16_t )a->height));
#line 291
  gma_power_end(dev);
#line 292
  return;
}
}
#line 302 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.c"
void psbfb_copyarea(struct fb_info *info , struct fb_copyarea  const  *region ) 
{ 
  long tmp ;

  {
#line 305
  tmp = ldv__builtin_expect(info->state != 0U, 0L);
#line 305
  if (tmp != 0L) {
#line 306
    return;
  } else {

  }
#line 309
  if (((unsigned int )region->width == 8U || (unsigned int )region->height == 8U) || (info->flags & 2) != 0) {
#line 311
    return;
  } else {

  }
#line 313
  psbfb_copyarea_accel(info, region);
#line 314
  return;
}
}
#line 323 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.c"
int psbfb_sync(struct fb_info *info ) 
{ 
  struct psb_fbdev *fbdev ;
  struct psb_framebuffer *psbfb ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  unsigned long _end___0 ;
  int busy ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;

  {
#line 325
  fbdev = (struct psb_fbdev *)info->par;
#line 326
  psbfb = & fbdev->pfb;
#line 327
  dev = psbfb->base.dev;
#line 328
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 329
  _end___0 = (unsigned long )jiffies + 250UL;
#line 330
  busy = 0;
#line 333
  tmp = spinlock_check(& dev_priv->lock_2d);
#line 333
  flags = _raw_spin_lock_irqsave(tmp);
#line 338
  tmp___0 = ioread32((void *)dev_priv->sgx_reg + 3608U);
#line 338
  if (tmp___0 == 128U) {
#line 338
    tmp___1 = ioread32((void *)dev_priv->sgx_reg + 3588U);
#line 338
    if ((tmp___1 & 16777216U) == 0U) {
#line 340
      goto out;
    } else {

    }
  } else {

  }
  ldv_43159: 
#line 343
  tmp___2 = ioread32((void *)dev_priv->sgx_reg + 3608U);
#line 343
  busy = tmp___2 != 128U;
#line 344
  cpu_relax();
#line 345
  if (busy != 0 && (long )((unsigned long )jiffies - _end___0) < 0L) {
#line 347
    goto ldv_43159;
  } else {

  }

#line 347
  if (busy != 0) {
#line 348
    tmp___3 = ioread32((void *)dev_priv->sgx_reg + 3608U);
#line 348
    busy = tmp___3 != 128U;
  } else {

  }
#line 349
  if (busy != 0) {
#line 350
    goto out;
  } else {

  }
  ldv_43167: 
#line 353
  tmp___4 = ioread32((void *)dev_priv->sgx_reg + 3588U);
#line 353
  busy = (tmp___4 & 16777216U) != 0U;
#line 355
  cpu_relax();
#line 356
  if (busy != 0 && (long )((unsigned long )jiffies - _end___0) < 0L) {
#line 358
    goto ldv_43167;
  } else {

  }

#line 357
  if (busy != 0) {
#line 358
    tmp___5 = ioread32((void *)dev_priv->sgx_reg + 3588U);
#line 358
    busy = (tmp___5 & 16777216U) != 0U;
  } else {

  }
  out: 
#line 362
  spin_unlock_irqrestore(& dev_priv->lock_2d, flags);
#line 363
  return (busy != 0 ? -16 : 0);
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 432
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 432
  ldv_func_res = tmp;
#line 434
  activate_work_2(ldv_func_arg3, 2);
#line 436
  return (ldv_func_res);
}
}
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 443
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 443
  ldv_func_res = tmp;
#line 445
  activate_work_2(& ldv_func_arg3->work, 2);
#line 447
  return (ldv_func_res);
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 454
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 454
  ldv_func_res = tmp;
#line 456
  activate_work_2(ldv_func_arg3, 2);
#line 458
  return (ldv_func_res);
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 464
  flush_workqueue(ldv_func_arg1);
#line 466
  call_and_disable_all_2(2);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 473
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 473
  ldv_func_res = tmp;
#line 475
  activate_work_2(& ldv_func_arg3->work, 2);
#line 477
  return (ldv_func_res);
}
}
#line 480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
void ldv_mutex_lock_10(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 483
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 485
  mutex_lock(ldv_func_arg1);
#line 486
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
void ldv_mutex_unlock_11(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 491
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 493
  mutex_unlock(ldv_func_arg1);
#line 494
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
void ldv_mutex_unlock_12(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 499
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 501
  mutex_unlock(ldv_func_arg1);
#line 502
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
void ldv_mutex_lock_13(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 507
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 509
  mutex_lock(ldv_func_arg1);
#line 510
  return;
}
}
#line 512 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
void ldv_mutex_lock_14(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 515
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 517
  mutex_lock(ldv_func_arg1);
#line 518
  return;
}
}
#line 520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
int ldv_mutex_trylock_15(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 524
  tmp = mutex_trylock(ldv_func_arg1);
#line 524
  ldv_func_res = tmp;
#line 526
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 526
  return (tmp___0);
#line 528
  return (ldv_func_res);
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
void ldv_mutex_unlock_16(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 534
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 536
  mutex_unlock(ldv_func_arg1);
#line 537
  return;
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
void ldv_mutex_lock_17(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 542
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 544
  mutex_lock(ldv_func_arg1);
#line 545
  return;
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
void ldv_mutex_unlock_18(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 550
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 552
  mutex_unlock(ldv_func_arg1);
#line 553
  return;
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
void ldv_mutex_unlock_19(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 558
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 560
  mutex_unlock(ldv_func_arg1);
#line 561
  return;
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
void ldv_mutex_lock_20(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 566
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 568
  mutex_lock(ldv_func_arg1);
#line 569
  return;
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
int ldv_mutex_lock_interruptible_21(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 575
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 575
  ldv_func_res = tmp;
#line 577
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 577
  return (tmp___0);
#line 579
  return (ldv_func_res);
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
int ldv_mutex_trylock_22(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 586
  tmp = mutex_trylock(ldv_func_arg1);
#line 586
  ldv_func_res = tmp;
#line 588
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 588
  return (tmp___0);
#line 590
  return (ldv_func_res);
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
void ldv_mutex_unlock_25(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 617
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 619
  mutex_unlock(ldv_func_arg1);
#line 620
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_58(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_67(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_56(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_59(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_60(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_63(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_64(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_70(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
int ldv_mutex_lock_interruptible_66(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_55(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_57(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_61(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_62(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_65(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_50(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_52(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_51(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_54(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_53(struct workqueue_struct *ldv_func_arg1 ) ;
#line 721 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
int gma_backlight_init(struct drm_device *dev ) ;
#line 722
void gma_backlight_exit(struct drm_device *dev ) ;
#line 723
void gma_backlight_disable(struct drm_device *dev ) ;
#line 724
void gma_backlight_enable(struct drm_device *dev ) ;
#line 725
void gma_backlight_set(struct drm_device *dev , int v ) ;
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.c"
void gma_backlight_enable(struct drm_device *dev ) 
{ 


  {
#line 39
  return;
}
}
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.c"
void gma_backlight_disable(struct drm_device *dev ) 
{ 


  {
#line 51
  return;
}
}
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.c"
void gma_backlight_set(struct drm_device *dev , int v ) 
{ 


  {
#line 63
  return;
}
}
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.c"
int gma_backlight_init(struct drm_device *dev ) 
{ 


  {
#line 80
  return (0);
}
}
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.c"
void gma_backlight_exit(struct drm_device *dev ) 
{ 


  {
#line 86
  return;
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
bool ldv_queue_work_on_50(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 432
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 432
  ldv_func_res = tmp;
#line 434
  activate_work_2(ldv_func_arg3, 2);
#line 436
  return (ldv_func_res);
}
}
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
bool ldv_queue_delayed_work_on_51(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 443
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 443
  ldv_func_res = tmp;
#line 445
  activate_work_2(& ldv_func_arg3->work, 2);
#line 447
  return (ldv_func_res);
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
bool ldv_queue_work_on_52(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 454
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 454
  ldv_func_res = tmp;
#line 456
  activate_work_2(ldv_func_arg3, 2);
#line 458
  return (ldv_func_res);
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
void ldv_flush_workqueue_53(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 464
  flush_workqueue(ldv_func_arg1);
#line 466
  call_and_disable_all_2(2);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
bool ldv_queue_delayed_work_on_54(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 473
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 473
  ldv_func_res = tmp;
#line 475
  activate_work_2(& ldv_func_arg3->work, 2);
#line 477
  return (ldv_func_res);
}
}
#line 480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
void ldv_mutex_lock_55(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 483
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 485
  mutex_lock(ldv_func_arg1);
#line 486
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
void ldv_mutex_unlock_56(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 491
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 493
  mutex_unlock(ldv_func_arg1);
#line 494
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
void ldv_mutex_lock_57(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 499
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 501
  mutex_lock(ldv_func_arg1);
#line 502
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
int ldv_mutex_trylock_58(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 508
  tmp = mutex_trylock(ldv_func_arg1);
#line 508
  ldv_func_res = tmp;
#line 510
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 510
  return (tmp___0);
#line 512
  return (ldv_func_res);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
void ldv_mutex_unlock_59(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 518
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 520
  mutex_unlock(ldv_func_arg1);
#line 521
  return;
}
}
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
void ldv_mutex_unlock_60(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 526
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 528
  mutex_unlock(ldv_func_arg1);
#line 529
  return;
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
void ldv_mutex_lock_61(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 534
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 536
  mutex_lock(ldv_func_arg1);
#line 537
  return;
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
void ldv_mutex_lock_62(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 542
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 544
  mutex_lock(ldv_func_arg1);
#line 545
  return;
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
void ldv_mutex_unlock_63(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 550
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 552
  mutex_unlock(ldv_func_arg1);
#line 553
  return;
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
void ldv_mutex_unlock_64(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 558
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 560
  mutex_unlock(ldv_func_arg1);
#line 561
  return;
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
void ldv_mutex_lock_65(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 566
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 568
  mutex_lock(ldv_func_arg1);
#line 569
  return;
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
int ldv_mutex_lock_interruptible_66(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 575
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 575
  ldv_func_res = tmp;
#line 577
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 577
  return (tmp___0);
#line 579
  return (ldv_func_res);
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
int ldv_mutex_trylock_67(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 586
  tmp = mutex_trylock(ldv_func_arg1);
#line 586
  ldv_func_res = tmp;
#line 588
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 588
  return (tmp___0);
#line 590
  return (ldv_func_res);
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
void ldv_mutex_unlock_70(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 617
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 619
  mutex_unlock(ldv_func_arg1);
#line 620
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 307 "./arch/x86/include/asm/pgtable_types.h"
extern uint16_t __cachemode2pte_tbl[8U] ;
#line 319 "./arch/x86/include/asm/pgtable_types.h"
__inline static unsigned long cachemode2protval(enum page_cache_mode pcm ) 
{ 
  long tmp ;

  {
#line 321
  tmp = ldv__builtin_expect((unsigned int )pcm == 0U, 1L);
#line 321
  if (tmp != 0L) {
#line 322
    return (0UL);
  } else {

  }
#line 323
  return ((unsigned long )__cachemode2pte_tbl[(unsigned int )pcm]);
}
}
#line 53 "include/linux/dynamic_debug.h"
extern void __dynamic_dev_dbg(struct _ddebug * , struct device  const  * , char const   * 
                              , ...) ;
#line 5 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void *ldv_err_ptr(long error ) ;
#line 65 "./arch/x86/include/asm/string_64.h"
extern char *strcpy(char * , char const   * ) ;
#line 71 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 23 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) ;
#line 155 "./arch/x86/include/asm/processor.h"
extern struct cpuinfo_x86 boot_cpu_data ;
#line 79 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_sub_and_test(int i , atomic_t *v ) 
{ 
  char c ;

  {
#line 81
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; subl %2, %0; sete %1": "+m" (v->counter),
                       "=qm" (c): "er" (i): "memory");
#line 81
  return ((int )((signed char )c) != 0);
}
}
#line 333 "include/linux/lockdep.h"
extern void lock_acquire(struct lockdep_map * , unsigned int  , int  , int  , int  ,
                         struct lockdep_map * , unsigned long  ) ;
#line 337
extern void lock_release(struct lockdep_map * , int  , unsigned long  ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_105(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_112(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_101(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_102(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_106(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_108(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_109(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_115(struct mutex *ldv_func_arg1 ) ;
#line 209
void ldv_mutex_unlock_117(struct mutex *ldv_func_arg1 ) ;
#line 213
void ldv_mutex_unlock_118(struct mutex *ldv_func_arg1 ) ;
#line 217
void ldv_mutex_unlock_120(struct mutex *ldv_func_arg1 ) ;
#line 22 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
int ldv_mutex_lock_interruptible_111(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_100(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_103(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_104(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_107(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_110(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_116(struct mutex *ldv_func_arg1 ) ;
#line 49
void ldv_mutex_lock_119(struct mutex *ldv_func_arg1 ) ;
#line 171
void ldv_mutex_lock_struct_mutex_of_drm_device(struct mutex *lock ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_95(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_97(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_96(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_99(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_98(struct workqueue_struct *ldv_func_arg1 ) ;
#line 143 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 289
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 418 "include/linux/slab.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 435
  tmp___2 = __kmalloc(size, flags);
#line 435
  return (tmp___2);
}
}
#line 581 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 583
  tmp = kmalloc(size, flags | 32768U);
#line 583
  return (tmp);
}
}
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
struct fb_var_screeninfo *psbfb_roll_ops_group0 ;
#line 176
struct fb_info *psbfb_ops_group0 ;
#line 186
int ldv_state_variable_54 ;
#line 188
struct drm_crtc *psb_fb_helper_funcs_group0 ;
#line 195
struct drm_device *psb_mode_funcs_group0 ;
#line 204
int ref_cnt ;
#line 217
int ldv_state_variable_55 ;
#line 221
int ldv_state_variable_59 ;
#line 239
int ldv_state_variable_58 ;
#line 241
int ldv_state_variable_56 ;
#line 250
struct drm_framebuffer *psb_fb_funcs_group0 ;
#line 253
int ldv_state_variable_60 ;
#line 259
struct fb_info *psbfb_roll_ops_group1 ;
#line 262
struct vm_area_struct *psbfb_vm_ops_group0 ;
#line 293
struct fb_info *psbfb_unaccel_ops_group0 ;
#line 310
int ldv_state_variable_57 ;
#line 345
void ldv_initialize_fb_ops_57(void) ;
#line 348
void ldv_initialize_drm_mode_config_funcs_54(void) ;
#line 360
void ldv_initialize_vm_operations_struct_59(void) ;
#line 366
void ldv_initialize_drm_fb_helper_funcs_55(void) ;
#line 370
void ldv_initialize_fb_ops_56(void) ;
#line 383
void ldv_initialize_fb_ops_58(void) ;
#line 386
void ldv_initialize_drm_framebuffer_funcs_60(void) ;
#line 68 "include/linux/kref.h"
__inline static int kref_sub(struct kref *kref , unsigned int count , void (*release)(struct kref * ) ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
#line 71
  __ret_warn_on = (unsigned long )release == (unsigned long )((void (*)(struct kref * ))0);
#line 71
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 71
  if (tmp != 0L) {
#line 71
    warn_slowpath_null("include/linux/kref.h", 71);
  } else {

  }
#line 71
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 73
  tmp___0 = atomic_sub_and_test((int )count, & kref->refcount);
#line 73
  if (tmp___0 != 0) {
#line 74
    (*release)(kref);
#line 75
    return (1);
  } else {

  }
#line 77
  return (0);
}
}
#line 97 "include/linux/kref.h"
__inline static int kref_put(struct kref *kref , void (*release)(struct kref * ) ) 
{ 
  int tmp ;

  {
#line 99
  tmp = kref_sub(kref, 1U, release);
#line 99
  return (tmp);
}
}
#line 170
__inline static int ldv_kref_put_mutex_114(struct kref *kref , void (*release)(struct kref * ) ,
                                           struct mutex *lock ) ;
#line 2017 "include/linux/mm.h"
extern int vm_insert_mixed(struct vm_area_struct * , unsigned long  , unsigned long  ) ;
#line 1084 "include/linux/device.h"
extern void dev_err(struct device  const  * , char const   *  , ...) ;
#line 509 "include/linux/fb.h"
__inline static struct apertures_struct *alloc_apertures(unsigned int max_num ) 
{ 
  struct apertures_struct *a ;
  void *tmp ;

  {
#line 510
  tmp = kzalloc((unsigned long )max_num * 16UL + 8UL, 208U);
#line 510
  a = (struct apertures_struct *)tmp;
#line 512
  if ((unsigned long )a == (unsigned long )((struct apertures_struct *)0)) {
#line 513
    return ((struct apertures_struct *)0);
  } else {

  }
#line 514
  a->count = max_num;
#line 515
  return (a);
}
}
#line 599
extern void cfb_fillrect(struct fb_info * , struct fb_fillrect  const  * ) ;
#line 601
extern void cfb_imageblit(struct fb_info * , struct fb_image  const  * ) ;
#line 615
extern int unregister_framebuffer(struct fb_info * ) ;
#line 686
extern struct fb_info *framebuffer_alloc(size_t  , struct device * ) ;
#line 687
extern void framebuffer_release(struct fb_info * ) ;
#line 755
extern int fb_alloc_cmap(struct fb_cmap * , int  , int  ) ;
#line 757
extern void fb_dealloc_cmap(struct fb_cmap * ) ;
#line 861 "include/linux/pci.h"
extern int pci_bus_read_config_dword(struct pci_bus * , unsigned int  , int  , u32 * ) ;
#line 889 "include/linux/pci.h"
__inline static int pci_read_config_dword(struct pci_dev  const  *dev , int where ,
                                          u32 *val ) 
{ 
  int tmp ;

  {
#line 892
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
#line 892
  return (tmp);
}
}
#line 1335 "include/drm/drm_crtc.h"
extern void drm_mode_config_init(struct drm_device * ) ;
#line 1337
extern void drm_mode_config_cleanup(struct drm_device * ) ;
#line 1371
extern int drm_framebuffer_init(struct drm_device * , struct drm_framebuffer * , struct drm_framebuffer_funcs  const  * ) ;
#line 1379
extern void drm_framebuffer_cleanup(struct drm_framebuffer * ) ;
#line 1380
extern void drm_framebuffer_unregister_private(struct drm_framebuffer * ) ;
#line 1396
extern struct drm_property *drm_property_create_range(struct drm_device * , int  ,
                                                      char const   * , uint64_t  ,
                                                      uint64_t  ) ;
#line 1420
extern int drm_mode_create_scaling_mode_property(struct drm_device * ) ;
#line 1460
extern uint32_t drm_mode_legacy_fb_format(uint32_t  , uint32_t  ) ;
#line 1527
extern void drm_fb_get_bpp_depth(uint32_t  , unsigned int * , int * ) ;
#line 125 "include/drm/drm_fb_helper.h"
extern void drm_fb_helper_prepare(struct drm_device * , struct drm_fb_helper * , struct drm_fb_helper_funcs  const  * ) ;
#line 127
extern int drm_fb_helper_init(struct drm_device * , struct drm_fb_helper * , int  ,
                              int  ) ;
#line 130
extern void drm_fb_helper_fini(struct drm_fb_helper * ) ;
#line 131
extern int drm_fb_helper_blank(int  , struct fb_info * ) ;
#line 134
extern int drm_fb_helper_set_par(struct fb_info * ) ;
#line 135
extern int drm_fb_helper_check_var(struct fb_var_screeninfo * , struct fb_info * ) ;
#line 139
extern void drm_fb_helper_fill_var(struct fb_info * , struct drm_fb_helper * , uint32_t  ,
                                   uint32_t  ) ;
#line 141
extern void drm_fb_helper_fill_fix(struct fb_info * , uint32_t  , uint32_t  ) ;
#line 146
extern int drm_fb_helper_hotplug_event(struct drm_fb_helper * ) ;
#line 147
extern int drm_fb_helper_initial_config(struct drm_fb_helper * , int  ) ;
#line 148
extern int drm_fb_helper_single_add_all_connectors(struct drm_fb_helper * ) ;
#line 181 "include/drm/drm_crtc_helper.h"
extern void drm_helper_disable_unused_functions(struct drm_device * ) ;
#line 194
extern void drm_helper_mode_fill_fb_struct(struct drm_framebuffer * , struct drm_mode_fb_cmd2 * ) ;
#line 232
extern void drm_kms_helper_poll_fini(struct drm_device * ) ;
#line 212 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
void psb_intel_crtc_init(struct drm_device *dev , int pipe , struct psb_intel_mode_device *mode_dev ) ;
#line 234 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
__inline static struct gma_encoder *gma_attached_encoder(struct drm_connector *connector ) 
{ 
  struct drm_connector  const  *__mptr ;

  {
#line 237
  __mptr = (struct drm_connector  const  *)connector;
#line 237
  return (((struct gma_connector *)__mptr)->encoder);
}
}
#line 125 "include/drm/drm_gem.h"
extern void drm_gem_object_free(struct kref * ) ;
#line 128
extern void drm_gem_private_object_init(struct drm_device * , struct drm_gem_object * ,
                                        size_t  ) ;
#line 143 "include/drm/drm_gem.h"
__inline static void drm_gem_object_unreference(struct drm_gem_object *obj ) 
{ 


  {
#line 145
  if ((unsigned long )obj != (unsigned long )((struct drm_gem_object *)0)) {
#line 146
    kref_put(& obj->refcount, & drm_gem_object_free);
  } else {

  }
#line 147
  return;
}
}
#line 150 "include/drm/drm_gem.h"
__inline static void drm_gem_object_unreference_unlocked(struct drm_gem_object *obj ) 
{ 
  struct drm_device *dev ;
  int tmp ;

  {
#line 154
  if ((unsigned long )obj == (unsigned long )((struct drm_gem_object *)0)) {
#line 155
    return;
  } else {

  }
#line 157
  dev = obj->dev;
#line 158
  tmp = ldv_kref_put_mutex_114(& obj->refcount, & drm_gem_object_free, & dev->struct_mutex);
#line 158
  if (tmp != 0) {
#line 159
    ldv_mutex_unlock_115(& dev->struct_mutex);
  } else {
#line 161
    lock_acquire(& dev->struct_mutex.dep_map, 0U, 0, 0, 1, (struct lockdep_map *)0,
                 0UL);
#line 161
    lock_release(& dev->struct_mutex.dep_map, 0, 0UL);
  }
#line 163
  return;
}
}
#line 164
extern int drm_gem_handle_create(struct drm_file * , struct drm_gem_object * , u32 * ) ;
#line 178
extern struct drm_gem_object *drm_gem_object_lookup(struct drm_device * , struct drm_file * ,
                                                    u32  ) ;
#line 56 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/gtt.h"
struct gtt_range *psb_gtt_alloc_range(struct drm_device *dev , int len , char const   *name ,
                                      int backed , u32 align ) ;
#line 60
void psb_gtt_free_range(struct drm_device *dev , struct gtt_range *gt ) ;
#line 63
void psb_gtt_roll(struct drm_device *dev , struct gtt_range *r , int roll ) ;
#line 716 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
void psb_modeset_init(struct drm_device *dev ) ;
#line 717
void psb_modeset_cleanup(struct drm_device *dev ) ;
#line 718
int psb_fbdev_init(struct drm_device *dev ) ;
#line 44 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/framebuffer.h"
int gma_connector_clones(struct drm_device *dev , int type_mask ) ;
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static void psb_user_framebuffer_destroy(struct drm_framebuffer *fb ) ;
#line 44
static int psb_user_framebuffer_create_handle(struct drm_framebuffer *fb , struct drm_file *file_priv ,
                                              unsigned int *handle ) ;
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static struct drm_framebuffer_funcs  const  psb_fb_funcs  =    {& psb_user_framebuffer_destroy, & psb_user_framebuffer_create_handle, 0};
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static int psbfb_setcolreg(unsigned int regno , unsigned int red , unsigned int green ,
                           unsigned int blue , unsigned int transp , struct fb_info *info ) 
{ 
  struct psb_fbdev *fbdev ;
  struct drm_framebuffer *fb ;
  uint32_t v ;

  {
#line 59
  fbdev = (struct psb_fbdev *)info->par;
#line 60
  fb = fbdev->psb_fb_helper.fb;
#line 63
  if ((unsigned long )fb == (unsigned long )((struct drm_framebuffer *)0)) {
#line 64
    return (-12);
  } else {

  }
#line 66
  if (regno > 255U) {
#line 67
    return (1);
  } else {

  }
#line 69
  red = (((red << (int )info->var.red.length) - red) + 32767U) >> 16;
#line 70
  blue = (((blue << (int )info->var.blue.length) - blue) + 32767U) >> 16;
#line 71
  green = (((green << (int )info->var.green.length) - green) + 32767U) >> 16;
#line 72
  transp = (((transp << (int )info->var.transp.length) - transp) + 32767U) >> 16;
#line 74
  v = (((red << (int )info->var.red.offset) | (green << (int )info->var.green.offset)) | (blue << (int )info->var.blue.offset)) | (transp << (int )info->var.transp.offset);
#line 79
  if (regno <= 15U) {
#line 80
    switch (fb->bits_per_pixel) {
    case 16: 
#line 82
    *((uint32_t *)info->pseudo_palette + (unsigned long )regno) = v;
#line 83
    goto ldv_43123;
    case 24: ;
    case 32: 
#line 86
    *((uint32_t *)info->pseudo_palette + (unsigned long )regno) = v;
#line 87
    goto ldv_43123;
    }
    ldv_43123: ;
  } else {

  }
#line 91
  return (0);
}
}
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static int psbfb_pan(struct fb_var_screeninfo *var , struct fb_info *info ) 
{ 
  struct psb_fbdev *fbdev ;
  struct psb_framebuffer *psbfb ;
  struct drm_device *dev ;
  int pages ;

  {
#line 96
  fbdev = (struct psb_fbdev *)info->par;
#line 97
  psbfb = & fbdev->pfb;
#line 98
  dev = psbfb->base.dev;
#line 105
  if ((psbfb->gtt)->npage != 0) {
#line 108
    pages = (int )(info->fix.line_length >> 12);
#line 109
    psb_gtt_roll(dev, psbfb->gtt, (int )(var->yoffset * (__u32 )pages));
  } else {

  }
#line 111
  return (0);
}
}
#line 114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static int psbfb_vm_fault(struct vm_area_struct *vma , struct vm_fault *vmf ) 
{ 
  struct psb_framebuffer *psbfb ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  int page_num ;
  int i ;
  unsigned long address ;
  int ret ;
  unsigned long pfn ;
  unsigned long phys_addr ;
  pgprot_t __constr_expr_0 ;
  unsigned long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 116
  psbfb = (struct psb_framebuffer *)vma->vm_private_data;
#line 117
  dev = psbfb->base.dev;
#line 118
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 124
  phys_addr = (unsigned long )dev_priv->stolen_base + (unsigned long )(psbfb->gtt)->offset;
#line 127
  page_num = (int )((vma->vm_end - vma->vm_start) >> 12);
#line 128
  address = (unsigned long )vmf->virtual_address - (vmf->pgoff << 12);
#line 130
  if ((unsigned int )boot_cpu_data.x86 > 3U) {
#line 130
    tmp = cachemode2protval(2);
#line 130
    __constr_expr_0.pgprot = vma->vm_page_prot.pgprot | tmp;
#line 130
    vma->vm_page_prot = __constr_expr_0;
  } else {
#line 130
    vma->vm_page_prot = vma->vm_page_prot;
  }
#line 132
  i = 0;
#line 132
  goto ldv_43150;
  ldv_43149: 
#line 133
  pfn = phys_addr >> 12;
#line 135
  ret = vm_insert_mixed(vma, address, pfn);
#line 136
  tmp___1 = ldv__builtin_expect((long )(ret == -16 || (ret != 0 && i > 0)), 0L);
#line 136
  if (tmp___1 != 0L) {
#line 137
    goto ldv_43148;
  } else {
#line 138
    tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 138
    if (tmp___0 != 0L) {
#line 139
      ret = ret == -12 ? 1 : 2;
#line 140
      return (ret);
    } else {

    }
  }
#line 142
  address = address + 4096UL;
#line 143
  phys_addr = phys_addr + 4096UL;
#line 132
  i = i + 1;
  ldv_43150: ;
#line 132
  if (i < page_num) {
#line 134
    goto ldv_43149;
  } else {

  }
  ldv_43148: ;
#line 145
  return (256);
}
}
#line 148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static void psbfb_vm_open(struct vm_area_struct *vma ) 
{ 


  {
#line 150
  return;
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static void psbfb_vm_close(struct vm_area_struct *vma ) 
{ 


  {
#line 154
  return;
}
}
#line 156 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static struct vm_operations_struct  const  psbfb_vm_ops  = 
#line 156
     {& psbfb_vm_open, & psbfb_vm_close, & psbfb_vm_fault, 0, 0, 0, 0, 0, 0, 0, 0};
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static int psbfb_mmap(struct fb_info *info , struct vm_area_struct *vma ) 
{ 
  struct psb_fbdev *fbdev ;
  struct psb_framebuffer *psbfb ;

  {
#line 164
  fbdev = (struct psb_fbdev *)info->par;
#line 165
  psbfb = & fbdev->pfb;
#line 167
  if (vma->vm_pgoff != 0UL) {
#line 168
    return (-22);
  } else {

  }
#line 169
  if (vma->vm_pgoff > 4503599627370495UL) {
#line 170
    return (-22);
  } else {

  }
#line 172
  if ((unsigned long )psbfb->addr_space == (unsigned long )((struct address_space *)0)) {
#line 173
    psbfb->addr_space = (vma->vm_file)->f_mapping;
  } else {

  }
#line 179
  vma->vm_ops = & psbfb_vm_ops;
#line 180
  vma->vm_private_data = (void *)psbfb;
#line 181
  vma->vm_flags = vma->vm_flags | 335822848UL;
#line 182
  return (0);
}
}
#line 185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static int psbfb_ioctl(struct fb_info *info , unsigned int cmd , unsigned long arg ) 
{ 


  {
#line 188
  return (-25);
}
}
#line 191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static struct fb_ops psbfb_ops  = 
#line 191
     {& __this_module, 0, 0, 0, 0, & drm_fb_helper_check_var, & drm_fb_helper_set_par,
    & psbfb_setcolreg, 0, & drm_fb_helper_blank, 0, & cfb_fillrect, & psbfb_copyarea,
    & cfb_imageblit, 0, 0, & psbfb_sync, & psbfb_ioctl, 0, & psbfb_mmap, 0, 0, 0,
    0};
#line 205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static struct fb_ops psbfb_roll_ops  = 
#line 205
     {& __this_module, 0, 0, 0, 0, & drm_fb_helper_check_var, & drm_fb_helper_set_par,
    & psbfb_setcolreg, 0, & drm_fb_helper_blank, & psbfb_pan, & cfb_fillrect, & cfb_copyarea,
    & cfb_imageblit, 0, 0, 0, & psbfb_ioctl, 0, & psbfb_mmap, 0, 0, 0, 0};
#line 219 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static struct fb_ops psbfb_unaccel_ops  = 
#line 219
     {& __this_module, 0, 0, 0, 0, & drm_fb_helper_check_var, & drm_fb_helper_set_par,
    & psbfb_setcolreg, 0, & drm_fb_helper_blank, 0, & cfb_fillrect, & cfb_copyarea,
    & cfb_imageblit, 0, 0, 0, & psbfb_ioctl, 0, & psbfb_mmap, 0, 0, 0, 0};
#line 242 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static int psb_framebuffer_init(struct drm_device *dev , struct psb_framebuffer *fb ,
                                struct drm_mode_fb_cmd2 *mode_cmd , struct gtt_range *gt ) 
{ 
  u32 bpp ;
  u32 depth ;
  int ret ;

  {
#line 250
  drm_fb_get_bpp_depth(mode_cmd->pixel_format, & depth, (int *)(& bpp));
#line 252
  if ((mode_cmd->pitches[0] & 63U) != 0U) {
#line 253
    return (-22);
  } else {

  }
#line 254
  switch (bpp) {
  case 8U: ;
  case 16U: ;
  case 24U: ;
  case 32U: ;
#line 259
  goto ldv_43185;
  default: ;
#line 261
  return (-22);
  }
  ldv_43185: 
#line 263
  drm_helper_mode_fill_fb_struct(& fb->base, mode_cmd);
#line 264
  fb->gtt = gt;
#line 265
  ret = drm_framebuffer_init(dev, & fb->base, & psb_fb_funcs);
#line 266
  if (ret != 0) {
#line 267
    dev_err((struct device  const  *)dev->dev, "framebuffer init failed: %d\n", ret);
#line 268
    return (ret);
  } else {

  }
#line 270
  return (0);
}
}
#line 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static struct drm_framebuffer *psb_framebuffer_create(struct drm_device *dev , struct drm_mode_fb_cmd2 *mode_cmd ,
                                                      struct gtt_range *gt ) 
{ 
  struct psb_framebuffer *fb ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 293
  tmp = kzalloc(192UL, 208U);
#line 293
  fb = (struct psb_framebuffer *)tmp;
#line 294
  if ((unsigned long )fb == (unsigned long )((struct psb_framebuffer *)0)) {
#line 295
    tmp___0 = ERR_PTR(-12L);
#line 295
    return ((struct drm_framebuffer *)tmp___0);
  } else {

  }
#line 297
  ret = psb_framebuffer_init(dev, fb, mode_cmd, gt);
#line 298
  if (ret != 0) {
#line 299
    kfree((void const   *)fb);
#line 300
    tmp___1 = ERR_PTR((long )ret);
#line 300
    return ((struct drm_framebuffer *)tmp___1);
  } else {

  }
#line 302
  return (& fb->base);
}
}
#line 318 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static struct gtt_range *psbfb_alloc(struct drm_device *dev , int aligned_size ) 
{ 
  struct gtt_range *backing ;

  {
#line 322
  backing = psb_gtt_alloc_range(dev, aligned_size, "fb", 1, 4096U);
#line 323
  if ((unsigned long )backing != (unsigned long )((struct gtt_range *)0)) {
#line 324
    drm_gem_private_object_init(dev, & backing->gem, (size_t )aligned_size);
#line 325
    return (backing);
  } else {

  }
#line 327
  return ((struct gtt_range *)0);
}
}
#line 337 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static int psbfb_create(struct psb_fbdev *fbdev , struct drm_fb_helper_surface_size *sizes ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct fb_info *info ;
  struct drm_framebuffer *fb ;
  struct psb_framebuffer *psbfb ;
  struct drm_mode_fb_cmd2 mode_cmd ;
  struct device *device ;
  int size ;
  int ret ;
  struct gtt_range *backing ;
  u32 bpp ;
  u32 depth ;
  int gtt_roll ;
  int pitch_lines ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 340
  dev = fbdev->psb_fb_helper.dev;
#line 341
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 344
  psbfb = & fbdev->pfb;
#line 346
  device = & (dev->pdev)->dev;
#line 351
  gtt_roll = 0;
#line 352
  pitch_lines = 0;
#line 354
  mode_cmd.width = sizes->surface_width;
#line 355
  mode_cmd.height = sizes->surface_height;
#line 356
  bpp = sizes->surface_bpp;
#line 357
  depth = sizes->surface_depth;
#line 360
  if (bpp == 24U) {
#line 361
    bpp = 32U;
  } else {

  }
  ldv_43217: 
#line 369
  mode_cmd.pitches[0] = ((mode_cmd.width * ((bpp + 7U) / 8U) + (__u32 )(4096 >> pitch_lines)) - 1U) & - ((unsigned int )(4096 >> pitch_lines));
#line 371
  size = (int )(mode_cmd.pitches[0] * mode_cmd.height);
#line 372
  size = (size + 4095) & -4096;
#line 375
  backing = psbfb_alloc(dev, size);
#line 377
  if (pitch_lines != 0) {
#line 378
    pitch_lines = pitch_lines * 2;
  } else {
#line 380
    pitch_lines = 1;
  }
#line 381
  gtt_roll = gtt_roll + 1;
#line 382
  if ((unsigned long )backing == (unsigned long )((struct gtt_range *)0) && pitch_lines <= 16) {
#line 384
    goto ldv_43217;
  } else {

  }
#line 385
  pitch_lines = pitch_lines / 2;
#line 387
  if ((unsigned long )backing == (unsigned long )((struct gtt_range *)0)) {
#line 394
    gtt_roll = 0;
#line 395
    pitch_lines = 64;
#line 397
    mode_cmd.pitches[0] = (mode_cmd.width * ((bpp + 7U) / 8U) + 63U) & 4294967232U;
#line 399
    size = (int )(mode_cmd.pitches[0] * mode_cmd.height);
#line 400
    size = (size + 4095) & -4096;
#line 403
    backing = psbfb_alloc(dev, size);
#line 404
    if ((unsigned long )backing == (unsigned long )((struct gtt_range *)0)) {
#line 405
      return (-12);
    } else {

    }
  } else {

  }
#line 408
  memset((void *)dev_priv->vram_addr + (unsigned long )backing->offset, 0, (size_t )size);
#line 410
  ldv_mutex_lock_116(& dev->struct_mutex);
#line 412
  info = framebuffer_alloc(0UL, device);
#line 413
  if ((unsigned long )info == (unsigned long )((struct fb_info *)0)) {
#line 414
    ret = -12;
#line 415
    goto out_err1;
  } else {

  }
#line 417
  info->par = (void *)fbdev;
#line 419
  mode_cmd.pixel_format = drm_mode_legacy_fb_format(bpp, depth);
#line 421
  ret = psb_framebuffer_init(dev, psbfb, & mode_cmd, backing);
#line 422
  if (ret != 0) {
#line 423
    goto out_unref;
  } else {

  }
#line 425
  fb = & psbfb->base;
#line 426
  psbfb->fbdev = info;
#line 428
  fbdev->psb_fb_helper.fb = fb;
#line 429
  fbdev->psb_fb_helper.fbdev = info;
#line 431
  drm_fb_helper_fill_fix(info, fb->pitches[0], fb->depth);
#line 432
  strcpy((char *)(& info->fix.id), "psbdrmfb");
#line 434
  info->flags = 1;
#line 435
  if ((unsigned int )*((unsigned char *)dev_priv->ops + 8UL) != 0U && pitch_lines > 8) {
#line 436
    info->fbops = & psbfb_ops;
  } else
#line 437
  if (gtt_roll != 0) {
#line 438
    info->fbops = & psbfb_roll_ops;
#line 439
    info->flags = info->flags | 8192;
  } else {
#line 441
    info->fbops = & psbfb_unaccel_ops;
  }
#line 443
  ret = fb_alloc_cmap(& info->cmap, 256, 0);
#line 444
  if (ret != 0) {
#line 445
    ret = -12;
#line 446
    goto out_unref;
  } else {

  }
#line 449
  info->fix.smem_start = (unsigned long )dev->mode_config.fb_base;
#line 450
  info->fix.smem_len = (__u32 )size;
#line 451
  info->fix.ywrapstep = (__u16 )gtt_roll;
#line 452
  info->fix.ypanstep = 0U;
#line 455
  info->screen_base = (char *)dev_priv->vram_addr + (unsigned long )backing->offset;
#line 456
  info->screen_size = (unsigned long )size;
#line 458
  if (dev_priv->gtt.stolen_size != 0UL) {
#line 459
    info->apertures = alloc_apertures(1U);
#line 460
    if ((unsigned long )info->apertures == (unsigned long )((struct apertures_struct *)0)) {
#line 461
      ret = -12;
#line 462
      goto out_unref;
    } else {

    }
#line 464
    (info->apertures)->ranges[0].base = dev->mode_config.fb_base;
#line 465
    (info->apertures)->ranges[0].size = (resource_size_t )dev_priv->gtt.stolen_size;
  } else {

  }
#line 468
  drm_fb_helper_fill_var(info, & fbdev->psb_fb_helper, sizes->fb_width, sizes->fb_height);
#line 471
  info->fix.mmio_start = (unsigned long )(dev->pdev)->resource[0].start;
#line 472
  info->fix.mmio_len = (dev->pdev)->resource[0].start != 0ULL || (dev->pdev)->resource[0].end != (dev->pdev)->resource[0].start ? ((__u32 )(dev->pdev)->resource[0].end - (__u32 )(dev->pdev)->resource[0].start) + 1U : 0U;
#line 476
  descriptor.modname = "gma500_gfx";
#line 476
  descriptor.function = "psbfb_create";
#line 476
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c";
#line 476
  descriptor.format = "allocated %dx%d fb\n";
#line 476
  descriptor.lineno = 477U;
#line 476
  descriptor.flags = 0U;
#line 476
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 476
  if (tmp != 0L) {
#line 476
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "allocated %dx%d fb\n",
                      psbfb->base.width, psbfb->base.height);
  } else {

  }
#line 479
  ldv_mutex_unlock_117(& dev->struct_mutex);
#line 480
  return (0);
  out_unref: ;
#line 482
  if ((int )backing->stolen) {
#line 483
    psb_gtt_free_range(dev, backing);
  } else {
#line 485
    drm_gem_object_unreference(& backing->gem);
  }
  out_err1: 
#line 487
  ldv_mutex_unlock_118(& dev->struct_mutex);
#line 488
  psb_gtt_free_range(dev, backing);
#line 489
  return (ret);
}
}
#line 500 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static struct drm_framebuffer *psb_user_framebuffer_create(struct drm_device *dev ,
                                                           struct drm_file *filp ,
                                                           struct drm_mode_fb_cmd2 *cmd ) 
{ 
  struct gtt_range *r ;
  struct drm_gem_object *obj ;
  void *tmp ;
  struct drm_gem_object  const  *__mptr ;
  struct drm_framebuffer *tmp___0 ;

  {
#line 511
  obj = drm_gem_object_lookup(dev, filp, cmd->handles[0]);
#line 512
  if ((unsigned long )obj == (unsigned long )((struct drm_gem_object *)0)) {
#line 513
    tmp = ERR_PTR(-2L);
#line 513
    return ((struct drm_framebuffer *)tmp);
  } else {

  }
#line 516
  __mptr = (struct drm_gem_object  const  *)obj;
#line 516
  r = (struct gtt_range *)__mptr + 0xffffffffffffffc0UL;
#line 517
  tmp___0 = psb_framebuffer_create(dev, cmd, r);
#line 517
  return (tmp___0);
}
}
#line 520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static void psbfb_gamma_set(struct drm_crtc *crtc , u16 red , u16 green , u16 blue ,
                            int regno ) 
{ 
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;

  {
#line 523
  __mptr = (struct drm_crtc  const  *)crtc;
#line 523
  gma_crtc = (struct gma_crtc *)__mptr;
#line 525
  gma_crtc->lut_r[regno] = (u8 )((int )red >> 8);
#line 526
  gma_crtc->lut_g[regno] = (u8 )((int )green >> 8);
#line 527
  gma_crtc->lut_b[regno] = (u8 )((int )blue >> 8);
#line 528
  return;
}
}
#line 530 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static void psbfb_gamma_get(struct drm_crtc *crtc , u16 *red , u16 *green , u16 *blue ,
                            int regno ) 
{ 
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;

  {
#line 533
  __mptr = (struct drm_crtc  const  *)crtc;
#line 533
  gma_crtc = (struct gma_crtc *)__mptr;
#line 535
  *red = (int )((u16 )gma_crtc->lut_r[regno]) << 8U;
#line 536
  *green = (int )((u16 )gma_crtc->lut_g[regno]) << 8U;
#line 537
  *blue = (int )((u16 )gma_crtc->lut_b[regno]) << 8U;
#line 538
  return;
}
}
#line 540 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static int psbfb_probe(struct drm_fb_helper *helper , struct drm_fb_helper_surface_size *sizes ) 
{ 
  struct psb_fbdev *psb_fbdev ;
  struct drm_fb_helper  const  *__mptr ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  int bytespp ;
  int tmp ;

  {
#line 544
  __mptr = (struct drm_fb_helper  const  *)helper;
#line 544
  psb_fbdev = (struct psb_fbdev *)__mptr;
#line 545
  dev = psb_fbdev->psb_fb_helper.dev;
#line 546
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 549
  bytespp = (int )(sizes->surface_bpp / 8U);
#line 550
  if (bytespp == 3) {
#line 551
    bytespp = 4;
  } else {

  }
#line 556
  if ((unsigned long )(((sizes->fb_width * (u32 )bytespp + 63U) & 4294967232U) * sizes->fb_height) > dev_priv->vram_stolen_size) {
#line 558
    sizes->surface_bpp = 16U;
#line 559
    sizes->surface_depth = 16U;
  } else {

  }
#line 562
  tmp = psbfb_create(psb_fbdev, sizes);
#line 562
  return (tmp);
}
}
#line 565 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static struct drm_fb_helper_funcs  const  psb_fb_helper_funcs  =    {& psbfb_gamma_set, & psbfb_gamma_get, & psbfb_probe, 0};
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static int psb_fbdev_destroy(struct drm_device *dev , struct psb_fbdev *fbdev ) 
{ 
  struct fb_info *info ;
  struct psb_framebuffer *psbfb ;

  {
#line 574
  psbfb = & fbdev->pfb;
#line 576
  if ((unsigned long )fbdev->psb_fb_helper.fbdev != (unsigned long )((struct fb_info *)0)) {
#line 577
    info = fbdev->psb_fb_helper.fbdev;
#line 578
    unregister_framebuffer(info);
#line 579
    if (info->cmap.len != 0U) {
#line 580
      fb_dealloc_cmap(& info->cmap);
    } else {

    }
#line 581
    framebuffer_release(info);
  } else {

  }
#line 583
  drm_fb_helper_fini(& fbdev->psb_fb_helper);
#line 584
  drm_framebuffer_unregister_private(& psbfb->base);
#line 585
  drm_framebuffer_cleanup(& psbfb->base);
#line 587
  if ((unsigned long )psbfb->gtt != (unsigned long )((struct gtt_range *)0)) {
#line 588
    drm_gem_object_unreference(& (psbfb->gtt)->gem);
  } else {

  }
#line 589
  return (0);
}
}
#line 592 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
int psb_fbdev_init(struct drm_device *dev ) 
{ 
  struct psb_fbdev *fbdev ;
  struct drm_psb_private *dev_priv ;
  int ret ;
  void *tmp ;

  {
#line 595
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 598
  tmp = kzalloc(352UL, 208U);
#line 598
  fbdev = (struct psb_fbdev *)tmp;
#line 599
  if ((unsigned long )fbdev == (unsigned long )((struct psb_fbdev *)0)) {
#line 600
    dev_err((struct device  const  *)dev->dev, "no memory\n");
#line 601
    return (-12);
  } else {

  }
#line 604
  dev_priv->fbdev = (void *)fbdev;
#line 606
  drm_fb_helper_prepare(dev, & fbdev->psb_fb_helper, & psb_fb_helper_funcs);
#line 608
  ret = drm_fb_helper_init(dev, & fbdev->psb_fb_helper, (dev_priv->ops)->crtcs, 4);
#line 610
  if (ret != 0) {
#line 611
    goto free;
  } else {

  }
#line 613
  ret = drm_fb_helper_single_add_all_connectors(& fbdev->psb_fb_helper);
#line 614
  if (ret != 0) {
#line 615
    goto fini;
  } else {

  }
#line 618
  drm_helper_disable_unused_functions(dev);
#line 620
  ret = drm_fb_helper_initial_config(& fbdev->psb_fb_helper, 32);
#line 621
  if (ret != 0) {
#line 622
    goto fini;
  } else {

  }
#line 624
  return (0);
  fini: 
#line 627
  drm_fb_helper_fini(& fbdev->psb_fb_helper);
  free: 
#line 629
  kfree((void const   *)fbdev);
#line 630
  return (ret);
}
}
#line 633 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static void psb_fbdev_fini(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 635
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 637
  if ((unsigned long )dev_priv->fbdev == (unsigned long )((void *)0)) {
#line 638
    return;
  } else {

  }
#line 640
  psb_fbdev_destroy(dev, (struct psb_fbdev *)dev_priv->fbdev);
#line 641
  kfree((void const   *)dev_priv->fbdev);
#line 642
  dev_priv->fbdev = (void *)0;
#line 643
  return;
}
}
#line 645 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static void psbfb_output_poll_changed(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_fbdev *fbdev ;

  {
#line 647
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 648
  fbdev = (struct psb_fbdev *)dev_priv->fbdev;
#line 649
  drm_fb_helper_hotplug_event(& fbdev->psb_fb_helper);
#line 650
  return;
}
}
#line 662 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static int psb_user_framebuffer_create_handle(struct drm_framebuffer *fb , struct drm_file *file_priv ,
                                              unsigned int *handle ) 
{ 
  struct psb_framebuffer *psbfb ;
  struct drm_framebuffer  const  *__mptr ;
  struct gtt_range *r ;
  int tmp ;

  {
#line 666
  __mptr = (struct drm_framebuffer  const  *)fb;
#line 666
  psbfb = (struct psb_framebuffer *)__mptr;
#line 667
  r = psbfb->gtt;
#line 668
  tmp = drm_gem_handle_create(file_priv, & r->gem, handle);
#line 668
  return (tmp);
}
}
#line 678 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static void psb_user_framebuffer_destroy(struct drm_framebuffer *fb ) 
{ 
  struct psb_framebuffer *psbfb ;
  struct drm_framebuffer  const  *__mptr ;
  struct gtt_range *r ;

  {
#line 680
  __mptr = (struct drm_framebuffer  const  *)fb;
#line 680
  psbfb = (struct psb_framebuffer *)__mptr;
#line 681
  r = psbfb->gtt;
#line 684
  drm_framebuffer_cleanup(fb);
#line 686
  drm_gem_object_unreference_unlocked(& r->gem);
#line 687
  kfree((void const   *)fb);
#line 688
  return;
}
}
#line 690 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static struct drm_mode_config_funcs  const  psb_mode_funcs  =    {& psb_user_framebuffer_create, & psbfb_output_poll_changed, 0, 0, 0, 0, 0};
#line 695 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static int psb_create_backlight_property(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct drm_property *backlight ;

  {
#line 697
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 700
  if ((unsigned long )dev_priv->backlight_property != (unsigned long )((struct drm_property *)0)) {
#line 701
    return (0);
  } else {

  }
#line 703
  backlight = drm_property_create_range(dev, 0, "backlight", 0ULL, 100ULL);
#line 705
  dev_priv->backlight_property = backlight;
#line 707
  return (0);
}
}
#line 710 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
static void psb_setup_outputs(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct drm_connector *connector ;
  struct list_head  const  *__mptr ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct drm_encoder *encoder ;
  int crtc_mask ;
  int clone_mask ;
  int tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 712
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 715
  drm_mode_create_scaling_mode_property(dev);
#line 716
  psb_create_backlight_property(dev);
#line 718
  (*((dev_priv->ops)->output_init))(dev);
#line 720
  __mptr = (struct list_head  const  *)dev->mode_config.connector_list.next;
#line 720
  connector = (struct drm_connector *)__mptr + 0xffffffffffffffe8UL;
#line 720
  goto ldv_43331;
  ldv_43330: 
#line 722
  tmp = gma_attached_encoder(connector);
#line 722
  gma_encoder = tmp;
#line 723
  encoder = & gma_encoder->base;
#line 724
  crtc_mask = 0;
#line 724
  clone_mask = 0;
#line 727
  switch (gma_encoder->type) {
  case 1: 
#line 729
  crtc_mask = 1;
#line 730
  clone_mask = 2;
#line 731
  goto ldv_43322;
  case 3: 
#line 733
  crtc_mask = (dev_priv->ops)->sdvo_mask;
#line 734
  clone_mask = 8;
#line 735
  goto ldv_43322;
  case 4: 
#line 737
  crtc_mask = (dev_priv->ops)->lvds_mask;
#line 738
  clone_mask = 16;
#line 739
  goto ldv_43322;
  case 7: 
#line 741
  crtc_mask = 1;
#line 742
  clone_mask = 128;
#line 743
  goto ldv_43322;
  case 8: 
#line 745
  crtc_mask = 4;
#line 746
  clone_mask = 256;
#line 747
  goto ldv_43322;
  case 6: 
#line 749
  crtc_mask = (dev_priv->ops)->hdmi_mask;
#line 750
  clone_mask = 64;
#line 751
  goto ldv_43322;
  case 9: 
#line 753
  crtc_mask = 3;
#line 754
  clone_mask = 512;
#line 755
  goto ldv_43322;
  case 10: 
#line 757
  crtc_mask = 2;
#line 758
  clone_mask = 1024;
  }
  ldv_43322: 
#line 760
  encoder->possible_crtcs = (uint32_t )crtc_mask;
#line 761
  tmp___0 = gma_connector_clones(dev, clone_mask);
#line 761
  encoder->possible_clones = (uint32_t )tmp___0;
#line 720
  __mptr___0 = (struct list_head  const  *)connector->head.next;
#line 720
  connector = (struct drm_connector *)__mptr___0 + 0xffffffffffffffe8UL;
  ldv_43331: ;
#line 720
  if ((unsigned long )(& connector->head) != (unsigned long )(& dev->mode_config.connector_list)) {
#line 722
    goto ldv_43330;
  } else {

  }

#line 727
  return;
}
}
#line 766 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
void psb_modeset_init(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  int i ;

  {
#line 768
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 769
  mode_dev = & dev_priv->mode_dev;
#line 772
  drm_mode_config_init(dev);
#line 774
  dev->mode_config.min_width = 0;
#line 775
  dev->mode_config.min_height = 0;
#line 777
  dev->mode_config.funcs = & psb_mode_funcs;
#line 781
  pci_read_config_dword((struct pci_dev  const  *)dev->pdev, 92, (u32 *)(& dev->mode_config.fb_base));
#line 785
  i = 0;
#line 785
  goto ldv_43340;
  ldv_43339: 
#line 786
  psb_intel_crtc_init(dev, i, mode_dev);
#line 785
  i = i + 1;
  ldv_43340: ;
#line 785
  if ((uint32_t )i < dev_priv->num_pipe) {
#line 787
    goto ldv_43339;
  } else {

  }
#line 788
  dev->mode_config.max_width = 4096;
#line 789
  dev->mode_config.max_height = 4096;
#line 791
  psb_setup_outputs(dev);
#line 793
  if ((unsigned long )(dev_priv->ops)->errata != (unsigned long )((void (*/* const  */)(struct drm_device * ))0)) {
#line 794
    (*((dev_priv->ops)->errata))(dev);
  } else {

  }
#line 796
  dev_priv->modeset = 1;
#line 797
  return;
}
}
#line 799 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c"
void psb_modeset_cleanup(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 801
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 802
  if ((int )dev_priv->modeset) {
#line 803
    ldv_mutex_lock_119(& dev->struct_mutex);
#line 805
    drm_kms_helper_poll_fini(dev);
#line 806
    psb_fbdev_fini(dev);
#line 807
    drm_mode_config_cleanup(dev);
#line 809
    ldv_mutex_unlock_120(& dev->struct_mutex);
  } else {

  }
#line 811
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
extern int ldv_probe_60(void) ;
#line 407 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_initialize_fb_ops_57(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 408
  tmp = ldv_init_zalloc(160UL);
#line 408
  psbfb_roll_ops_group0 = (struct fb_var_screeninfo *)tmp;
#line 409
  tmp___0 = ldv_init_zalloc(1608UL);
#line 409
  psbfb_roll_ops_group1 = (struct fb_info *)tmp___0;
#line 410
  return;
}
}
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_initialize_drm_mode_config_funcs_54(void) 
{ 
  void *tmp ;

  {
#line 413
  tmp = ldv_init_zalloc(3320UL);
#line 413
  psb_mode_funcs_group0 = (struct drm_device *)tmp;
#line 414
  return;
}
}
#line 416 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_initialize_vm_operations_struct_59(void) 
{ 
  void *tmp ;

  {
#line 417
  tmp = ldv_init_zalloc(184UL);
#line 417
  psbfb_vm_ops_group0 = (struct vm_area_struct *)tmp;
#line 418
  return;
}
}
#line 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_initialize_drm_fb_helper_funcs_55(void) 
{ 
  void *tmp ;

  {
#line 421
  tmp = ldv_init_zalloc(1160UL);
#line 421
  psb_fb_helper_funcs_group0 = (struct drm_crtc *)tmp;
#line 422
  return;
}
}
#line 424 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_initialize_fb_ops_56(void) 
{ 
  void *tmp ;

  {
#line 425
  tmp = ldv_init_zalloc(1608UL);
#line 425
  psbfb_unaccel_ops_group0 = (struct fb_info *)tmp;
#line 426
  return;
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_initialize_fb_ops_58(void) 
{ 
  void *tmp ;

  {
#line 429
  tmp = ldv_init_zalloc(1608UL);
#line 429
  psbfb_ops_group0 = (struct fb_info *)tmp;
#line 430
  return;
}
}
#line 432 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_initialize_drm_framebuffer_funcs_60(void) 
{ 
  void *tmp ;

  {
#line 433
  tmp = ldv_init_zalloc(168UL);
#line 433
  psb_fb_funcs_group0 = (struct drm_framebuffer *)tmp;
#line 434
  return;
}
}
#line 436 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_main_exported_59(void) 
{ 
  struct vm_fault *ldvarg82 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 437
  tmp = ldv_init_zalloc(56UL);
#line 437
  ldvarg82 = (struct vm_fault *)tmp;
#line 439
  tmp___0 = __VERIFIER_nondet_int();
#line 439
  switch (tmp___0) {
  case 0: ;
#line 442
  if (ldv_state_variable_59 == 1) {
#line 444
    psbfb_vm_fault(psbfb_vm_ops_group0, ldvarg82);
#line 446
    ldv_state_variable_59 = 1;
  } else {

  }
#line 449
  if (ldv_state_variable_59 == 2) {
#line 451
    psbfb_vm_fault(psbfb_vm_ops_group0, ldvarg82);
#line 453
    ldv_state_variable_59 = 2;
  } else {

  }
#line 456
  goto ldv_43374;
  case 1: ;
#line 459
  if (ldv_state_variable_59 == 2) {
#line 461
    psbfb_vm_close(psbfb_vm_ops_group0);
#line 462
    ldv_state_variable_59 = 1;
  } else {

  }
#line 465
  goto ldv_43374;
  case 2: ;
#line 468
  if (ldv_state_variable_59 == 1) {
#line 470
    psbfb_vm_open(psbfb_vm_ops_group0);
#line 471
    ldv_state_variable_59 = 2;
#line 472
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 475
  goto ldv_43374;
  default: 
#line 476
  ldv_stop();
  }
  ldv_43374: ;
#line 480
  return;
}
}
#line 482 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_main_exported_60(void) 
{ 
  unsigned int *ldvarg190 ;
  void *tmp ;
  struct drm_file *ldvarg191 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 483
  tmp = ldv_init_zalloc(4UL);
#line 483
  ldvarg190 = (unsigned int *)tmp;
#line 484
  tmp___0 = ldv_init_zalloc(744UL);
#line 484
  ldvarg191 = (struct drm_file *)tmp___0;
#line 486
  tmp___1 = __VERIFIER_nondet_int();
#line 486
  switch (tmp___1) {
  case 0: ;
#line 489
  if (ldv_state_variable_60 == 2) {
#line 491
    psb_user_framebuffer_destroy(psb_fb_funcs_group0);
#line 493
    ldv_state_variable_60 = 1;
#line 494
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 497
  goto ldv_43384;
  case 1: ;
#line 500
  if (ldv_state_variable_60 == 2) {
#line 502
    psb_user_framebuffer_create_handle(psb_fb_funcs_group0, ldvarg191, ldvarg190);
#line 504
    ldv_state_variable_60 = 2;
  } else {

  }
#line 507
  if (ldv_state_variable_60 == 1) {
#line 509
    psb_user_framebuffer_create_handle(psb_fb_funcs_group0, ldvarg191, ldvarg190);
#line 511
    ldv_state_variable_60 = 1;
  } else {

  }
#line 514
  goto ldv_43384;
  case 2: ;
#line 517
  if (ldv_state_variable_60 == 1) {
#line 519
    ldv_probe_60();
#line 521
    ldv_state_variable_60 = 2;
#line 522
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 525
  goto ldv_43384;
  default: 
#line 526
  ldv_stop();
  }
  ldv_43384: ;
#line 530
  return;
}
}
#line 532 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_main_exported_57(void) 
{ 
  unsigned int ldvarg66 ;
  unsigned int ldvarg64 ;
  int ldvarg61 ;
  unsigned int ldvarg65 ;
  unsigned long ldvarg62 ;
  struct fb_image *ldvarg69 ;
  void *tmp ;
  unsigned int ldvarg68 ;
  struct vm_area_struct *ldvarg71 ;
  void *tmp___0 ;
  struct fb_fillrect *ldvarg60 ;
  void *tmp___1 ;
  unsigned int ldvarg67 ;
  struct fb_copyarea *ldvarg70 ;
  void *tmp___2 ;
  unsigned int ldvarg63 ;
  int tmp___3 ;

  {
#line 538
  tmp = ldv_init_zalloc(80UL);
#line 538
  ldvarg69 = (struct fb_image *)tmp;
#line 540
  tmp___0 = ldv_init_zalloc(184UL);
#line 540
  ldvarg71 = (struct vm_area_struct *)tmp___0;
#line 541
  tmp___1 = ldv_init_zalloc(24UL);
#line 541
  ldvarg60 = (struct fb_fillrect *)tmp___1;
#line 543
  tmp___2 = ldv_init_zalloc(24UL);
#line 543
  ldvarg70 = (struct fb_copyarea *)tmp___2;
#line 533
  ldv_memset((void *)(& ldvarg66), 0, 4UL);
#line 534
  ldv_memset((void *)(& ldvarg64), 0, 4UL);
#line 535
  ldv_memset((void *)(& ldvarg61), 0, 4UL);
#line 536
  ldv_memset((void *)(& ldvarg65), 0, 4UL);
#line 537
  ldv_memset((void *)(& ldvarg62), 0, 8UL);
#line 539
  ldv_memset((void *)(& ldvarg68), 0, 4UL);
#line 542
  ldv_memset((void *)(& ldvarg67), 0, 4UL);
#line 544
  ldv_memset((void *)(& ldvarg63), 0, 4UL);
#line 546
  tmp___3 = __VERIFIER_nondet_int();
#line 546
  switch (tmp___3) {
  case 0: ;
#line 549
  if (ldv_state_variable_57 == 1) {
#line 551
    psbfb_mmap(psbfb_roll_ops_group1, ldvarg71);
#line 553
    ldv_state_variable_57 = 1;
  } else {

  }
#line 556
  goto ldv_43404;
  case 1: ;
#line 559
  if (ldv_state_variable_57 == 1) {
#line 561
    psbfb_pan(psbfb_roll_ops_group0, psbfb_roll_ops_group1);
#line 563
    ldv_state_variable_57 = 1;
  } else {

  }
#line 566
  goto ldv_43404;
  case 2: ;
#line 569
  if (ldv_state_variable_57 == 1) {
#line 571
    cfb_copyarea(psbfb_roll_ops_group1, (struct fb_copyarea  const  *)ldvarg70);
#line 573
    ldv_state_variable_57 = 1;
  } else {

  }
#line 576
  goto ldv_43404;
  case 3: ;
#line 579
  if (ldv_state_variable_57 == 1) {
#line 581
    cfb_imageblit(psbfb_roll_ops_group1, (struct fb_image  const  *)ldvarg69);
#line 583
    ldv_state_variable_57 = 1;
  } else {

  }
#line 586
  goto ldv_43404;
  case 4: ;
#line 589
  if (ldv_state_variable_57 == 1) {
#line 591
    drm_fb_helper_set_par(psbfb_roll_ops_group1);
#line 593
    ldv_state_variable_57 = 1;
  } else {

  }
#line 596
  goto ldv_43404;
  case 5: ;
#line 599
  if (ldv_state_variable_57 == 1) {
#line 601
    psbfb_setcolreg(ldvarg65, ldvarg67, ldvarg66, ldvarg64, ldvarg68, psbfb_roll_ops_group1);
#line 603
    ldv_state_variable_57 = 1;
  } else {

  }
#line 606
  goto ldv_43404;
  case 6: ;
#line 609
  if (ldv_state_variable_57 == 1) {
#line 611
    psbfb_ioctl(psbfb_roll_ops_group1, ldvarg63, ldvarg62);
#line 613
    ldv_state_variable_57 = 1;
  } else {

  }
#line 616
  goto ldv_43404;
  case 7: ;
#line 619
  if (ldv_state_variable_57 == 1) {
#line 621
    drm_fb_helper_blank(ldvarg61, psbfb_roll_ops_group1);
#line 623
    ldv_state_variable_57 = 1;
  } else {

  }
#line 626
  goto ldv_43404;
  case 8: ;
#line 629
  if (ldv_state_variable_57 == 1) {
#line 631
    drm_fb_helper_check_var(psbfb_roll_ops_group0, psbfb_roll_ops_group1);
#line 633
    ldv_state_variable_57 = 1;
  } else {

  }
#line 636
  goto ldv_43404;
  case 9: ;
#line 639
  if (ldv_state_variable_57 == 1) {
#line 641
    cfb_fillrect(psbfb_roll_ops_group1, (struct fb_fillrect  const  *)ldvarg60);
#line 643
    ldv_state_variable_57 = 1;
  } else {

  }
#line 646
  goto ldv_43404;
  default: 
#line 647
  ldv_stop();
  }
  ldv_43404: ;
#line 651
  return;
}
}
#line 653 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_main_exported_56(void) 
{ 
  unsigned int ldvarg201 ;
  struct fb_copyarea *ldvarg206 ;
  void *tmp ;
  unsigned int ldvarg199 ;
  unsigned long ldvarg198 ;
  struct fb_image *ldvarg205 ;
  void *tmp___0 ;
  int ldvarg197 ;
  struct fb_var_screeninfo *ldvarg196 ;
  void *tmp___1 ;
  unsigned int ldvarg202 ;
  struct fb_fillrect *ldvarg195 ;
  void *tmp___2 ;
  struct vm_area_struct *ldvarg207 ;
  void *tmp___3 ;
  unsigned int ldvarg200 ;
  unsigned int ldvarg203 ;
  unsigned int ldvarg204 ;
  int tmp___4 ;

  {
#line 655
  tmp = ldv_init_zalloc(24UL);
#line 655
  ldvarg206 = (struct fb_copyarea *)tmp;
#line 658
  tmp___0 = ldv_init_zalloc(80UL);
#line 658
  ldvarg205 = (struct fb_image *)tmp___0;
#line 660
  tmp___1 = ldv_init_zalloc(160UL);
#line 660
  ldvarg196 = (struct fb_var_screeninfo *)tmp___1;
#line 662
  tmp___2 = ldv_init_zalloc(24UL);
#line 662
  ldvarg195 = (struct fb_fillrect *)tmp___2;
#line 663
  tmp___3 = ldv_init_zalloc(184UL);
#line 663
  ldvarg207 = (struct vm_area_struct *)tmp___3;
#line 654
  ldv_memset((void *)(& ldvarg201), 0, 4UL);
#line 656
  ldv_memset((void *)(& ldvarg199), 0, 4UL);
#line 657
  ldv_memset((void *)(& ldvarg198), 0, 8UL);
#line 659
  ldv_memset((void *)(& ldvarg197), 0, 4UL);
#line 661
  ldv_memset((void *)(& ldvarg202), 0, 4UL);
#line 664
  ldv_memset((void *)(& ldvarg200), 0, 4UL);
#line 665
  ldv_memset((void *)(& ldvarg203), 0, 4UL);
#line 666
  ldv_memset((void *)(& ldvarg204), 0, 4UL);
#line 668
  tmp___4 = __VERIFIER_nondet_int();
#line 668
  switch (tmp___4) {
  case 0: ;
#line 671
  if (ldv_state_variable_56 == 1) {
#line 673
    psbfb_mmap(psbfb_unaccel_ops_group0, ldvarg207);
#line 675
    ldv_state_variable_56 = 1;
  } else {

  }
#line 678
  goto ldv_43432;
  case 1: ;
#line 681
  if (ldv_state_variable_56 == 1) {
#line 683
    cfb_copyarea(psbfb_unaccel_ops_group0, (struct fb_copyarea  const  *)ldvarg206);
#line 685
    ldv_state_variable_56 = 1;
  } else {

  }
#line 688
  goto ldv_43432;
  case 2: ;
#line 691
  if (ldv_state_variable_56 == 1) {
#line 693
    cfb_imageblit(psbfb_unaccel_ops_group0, (struct fb_image  const  *)ldvarg205);
#line 695
    ldv_state_variable_56 = 1;
  } else {

  }
#line 698
  goto ldv_43432;
  case 3: ;
#line 701
  if (ldv_state_variable_56 == 1) {
#line 703
    drm_fb_helper_set_par(psbfb_unaccel_ops_group0);
#line 705
    ldv_state_variable_56 = 1;
  } else {

  }
#line 708
  goto ldv_43432;
  case 4: ;
#line 711
  if (ldv_state_variable_56 == 1) {
#line 713
    psbfb_setcolreg(ldvarg201, ldvarg203, ldvarg202, ldvarg200, ldvarg204, psbfb_unaccel_ops_group0);
#line 715
    ldv_state_variable_56 = 1;
  } else {

  }
#line 718
  goto ldv_43432;
  case 5: ;
#line 721
  if (ldv_state_variable_56 == 1) {
#line 723
    psbfb_ioctl(psbfb_unaccel_ops_group0, ldvarg199, ldvarg198);
#line 725
    ldv_state_variable_56 = 1;
  } else {

  }
#line 728
  goto ldv_43432;
  case 6: ;
#line 731
  if (ldv_state_variable_56 == 1) {
#line 733
    drm_fb_helper_blank(ldvarg197, psbfb_unaccel_ops_group0);
#line 735
    ldv_state_variable_56 = 1;
  } else {

  }
#line 738
  goto ldv_43432;
  case 7: ;
#line 741
  if (ldv_state_variable_56 == 1) {
#line 743
    drm_fb_helper_check_var(ldvarg196, psbfb_unaccel_ops_group0);
#line 745
    ldv_state_variable_56 = 1;
  } else {

  }
#line 748
  goto ldv_43432;
  case 8: ;
#line 751
  if (ldv_state_variable_56 == 1) {
#line 753
    cfb_fillrect(psbfb_unaccel_ops_group0, (struct fb_fillrect  const  *)ldvarg195);
#line 755
    ldv_state_variable_56 = 1;
  } else {

  }
#line 758
  goto ldv_43432;
  default: 
#line 759
  ldv_stop();
  }
  ldv_43432: ;
#line 763
  return;
}
}
#line 765 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_main_exported_58(void) 
{ 
  struct fb_var_screeninfo *ldvarg160 ;
  void *tmp ;
  unsigned long ldvarg162 ;
  int ldvarg161 ;
  struct fb_image *ldvarg169 ;
  void *tmp___0 ;
  unsigned int ldvarg166 ;
  struct fb_fillrect *ldvarg159 ;
  void *tmp___1 ;
  unsigned int ldvarg165 ;
  unsigned int ldvarg163 ;
  unsigned int ldvarg168 ;
  struct vm_area_struct *ldvarg171 ;
  void *tmp___2 ;
  struct fb_copyarea *ldvarg170 ;
  void *tmp___3 ;
  unsigned int ldvarg164 ;
  unsigned int ldvarg167 ;
  int tmp___4 ;

  {
#line 766
  tmp = ldv_init_zalloc(160UL);
#line 766
  ldvarg160 = (struct fb_var_screeninfo *)tmp;
#line 769
  tmp___0 = ldv_init_zalloc(80UL);
#line 769
  ldvarg169 = (struct fb_image *)tmp___0;
#line 771
  tmp___1 = ldv_init_zalloc(24UL);
#line 771
  ldvarg159 = (struct fb_fillrect *)tmp___1;
#line 775
  tmp___2 = ldv_init_zalloc(184UL);
#line 775
  ldvarg171 = (struct vm_area_struct *)tmp___2;
#line 776
  tmp___3 = ldv_init_zalloc(24UL);
#line 776
  ldvarg170 = (struct fb_copyarea *)tmp___3;
#line 767
  ldv_memset((void *)(& ldvarg162), 0, 8UL);
#line 768
  ldv_memset((void *)(& ldvarg161), 0, 4UL);
#line 770
  ldv_memset((void *)(& ldvarg166), 0, 4UL);
#line 772
  ldv_memset((void *)(& ldvarg165), 0, 4UL);
#line 773
  ldv_memset((void *)(& ldvarg163), 0, 4UL);
#line 774
  ldv_memset((void *)(& ldvarg168), 0, 4UL);
#line 777
  ldv_memset((void *)(& ldvarg164), 0, 4UL);
#line 778
  ldv_memset((void *)(& ldvarg167), 0, 4UL);
#line 780
  tmp___4 = __VERIFIER_nondet_int();
#line 780
  switch (tmp___4) {
  case 0: ;
#line 783
  if (ldv_state_variable_58 == 1) {
#line 785
    psbfb_mmap(psbfb_ops_group0, ldvarg171);
#line 787
    ldv_state_variable_58 = 1;
  } else {

  }
#line 790
  goto ldv_43459;
  case 1: ;
#line 793
  if (ldv_state_variable_58 == 1) {
#line 795
    psbfb_copyarea(psbfb_ops_group0, (struct fb_copyarea  const  *)ldvarg170);
#line 797
    ldv_state_variable_58 = 1;
  } else {

  }
#line 800
  goto ldv_43459;
  case 2: ;
#line 803
  if (ldv_state_variable_58 == 1) {
#line 805
    psbfb_sync(psbfb_ops_group0);
#line 807
    ldv_state_variable_58 = 1;
  } else {

  }
#line 810
  goto ldv_43459;
  case 3: ;
#line 813
  if (ldv_state_variable_58 == 1) {
#line 815
    cfb_imageblit(psbfb_ops_group0, (struct fb_image  const  *)ldvarg169);
#line 817
    ldv_state_variable_58 = 1;
  } else {

  }
#line 820
  goto ldv_43459;
  case 4: ;
#line 823
  if (ldv_state_variable_58 == 1) {
#line 825
    drm_fb_helper_set_par(psbfb_ops_group0);
#line 827
    ldv_state_variable_58 = 1;
  } else {

  }
#line 830
  goto ldv_43459;
  case 5: ;
#line 833
  if (ldv_state_variable_58 == 1) {
#line 835
    psbfb_setcolreg(ldvarg165, ldvarg167, ldvarg166, ldvarg164, ldvarg168, psbfb_ops_group0);
#line 837
    ldv_state_variable_58 = 1;
  } else {

  }
#line 840
  goto ldv_43459;
  case 6: ;
#line 843
  if (ldv_state_variable_58 == 1) {
#line 845
    psbfb_ioctl(psbfb_ops_group0, ldvarg163, ldvarg162);
#line 847
    ldv_state_variable_58 = 1;
  } else {

  }
#line 850
  goto ldv_43459;
  case 7: ;
#line 853
  if (ldv_state_variable_58 == 1) {
#line 855
    drm_fb_helper_blank(ldvarg161, psbfb_ops_group0);
#line 857
    ldv_state_variable_58 = 1;
  } else {

  }
#line 860
  goto ldv_43459;
  case 8: ;
#line 863
  if (ldv_state_variable_58 == 1) {
#line 865
    drm_fb_helper_check_var(ldvarg160, psbfb_ops_group0);
#line 867
    ldv_state_variable_58 = 1;
  } else {

  }
#line 870
  goto ldv_43459;
  case 9: ;
#line 873
  if (ldv_state_variable_58 == 1) {
#line 875
    cfb_fillrect(psbfb_ops_group0, (struct fb_fillrect  const  *)ldvarg159);
#line 877
    ldv_state_variable_58 = 1;
  } else {

  }
#line 880
  goto ldv_43459;
  default: 
#line 881
  ldv_stop();
  }
  ldv_43459: ;
#line 885
  return;
}
}
#line 887 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_main_exported_55(void) 
{ 
  u16 *ldvarg34 ;
  void *tmp ;
  struct drm_fb_helper *ldvarg28 ;
  void *tmp___0 ;
  struct drm_fb_helper_surface_size *ldvarg29 ;
  void *tmp___1 ;
  u16 *ldvarg36 ;
  void *tmp___2 ;
  int ldvarg37 ;
  u16 ldvarg30 ;
  int ldvarg33 ;
  u16 ldvarg31 ;
  u16 ldvarg32 ;
  u16 *ldvarg35 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
#line 888
  tmp = ldv_init_zalloc(2UL);
#line 888
  ldvarg34 = (u16 *)tmp;
#line 889
  tmp___0 = ldv_init_zalloc(160UL);
#line 889
  ldvarg28 = (struct drm_fb_helper *)tmp___0;
#line 890
  tmp___1 = ldv_init_zalloc(24UL);
#line 890
  ldvarg29 = (struct drm_fb_helper_surface_size *)tmp___1;
#line 891
  tmp___2 = ldv_init_zalloc(2UL);
#line 891
  ldvarg36 = (u16 *)tmp___2;
#line 897
  tmp___3 = ldv_init_zalloc(2UL);
#line 897
  ldvarg35 = (u16 *)tmp___3;
#line 892
  ldv_memset((void *)(& ldvarg37), 0, 4UL);
#line 893
  ldv_memset((void *)(& ldvarg30), 0, 2UL);
#line 894
  ldv_memset((void *)(& ldvarg33), 0, 4UL);
#line 895
  ldv_memset((void *)(& ldvarg31), 0, 2UL);
#line 896
  ldv_memset((void *)(& ldvarg32), 0, 2UL);
#line 899
  tmp___4 = __VERIFIER_nondet_int();
#line 899
  switch (tmp___4) {
  case 0: ;
#line 902
  if (ldv_state_variable_55 == 1) {
#line 904
    psbfb_gamma_get(psb_fb_helper_funcs_group0, ldvarg36, ldvarg35, ldvarg34, ldvarg37);
#line 906
    ldv_state_variable_55 = 1;
  } else {

  }
#line 909
  goto ldv_43484;
  case 1: ;
#line 912
  if (ldv_state_variable_55 == 1) {
#line 914
    psbfb_gamma_set(psb_fb_helper_funcs_group0, (int )ldvarg32, (int )ldvarg31, (int )ldvarg30,
                    ldvarg33);
#line 916
    ldv_state_variable_55 = 1;
  } else {

  }
#line 919
  goto ldv_43484;
  case 2: ;
#line 922
  if (ldv_state_variable_55 == 1) {
#line 924
    psbfb_probe(ldvarg28, ldvarg29);
#line 926
    ldv_state_variable_55 = 1;
  } else {

  }
#line 929
  goto ldv_43484;
  default: 
#line 930
  ldv_stop();
  }
  ldv_43484: ;
#line 934
  return;
}
}
#line 936 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_main_exported_54(void) 
{ 
  struct drm_mode_fb_cmd2 *ldvarg214 ;
  void *tmp ;
  struct drm_file *ldvarg215 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 937
  tmp = ldv_init_zalloc(104UL);
#line 937
  ldvarg214 = (struct drm_mode_fb_cmd2 *)tmp;
#line 938
  tmp___0 = ldv_init_zalloc(744UL);
#line 938
  ldvarg215 = (struct drm_file *)tmp___0;
#line 940
  tmp___1 = __VERIFIER_nondet_int();
#line 940
  switch (tmp___1) {
  case 0: ;
#line 943
  if (ldv_state_variable_54 == 1) {
#line 945
    psb_user_framebuffer_create(psb_mode_funcs_group0, ldvarg215, ldvarg214);
#line 947
    ldv_state_variable_54 = 1;
  } else {

  }
#line 950
  goto ldv_43494;
  case 1: ;
#line 953
  if (ldv_state_variable_54 == 1) {
#line 955
    psbfb_output_poll_changed(psb_mode_funcs_group0);
#line 957
    ldv_state_variable_54 = 1;
  } else {

  }
#line 960
  goto ldv_43494;
  default: 
#line 961
  ldv_stop();
  }
  ldv_43494: ;
#line 965
  return;
}
}
#line 966 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
__inline static void *ERR_PTR(long error ) 
{ 
  void *tmp ;

  {
#line 969
  tmp = ldv_err_ptr(error);
#line 969
  return (tmp);
}
}
#line 990 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
bool ldv_queue_work_on_95(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 994
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 994
  ldv_func_res = tmp;
#line 996
  activate_work_2(ldv_func_arg3, 2);
#line 998
  return (ldv_func_res);
}
}
#line 1001 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
bool ldv_queue_delayed_work_on_96(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 1005
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1005
  ldv_func_res = tmp;
#line 1007
  activate_work_2(& ldv_func_arg3->work, 2);
#line 1009
  return (ldv_func_res);
}
}
#line 1012 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
bool ldv_queue_work_on_97(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 1016
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1016
  ldv_func_res = tmp;
#line 1018
  activate_work_2(ldv_func_arg3, 2);
#line 1020
  return (ldv_func_res);
}
}
#line 1023 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_flush_workqueue_98(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1026
  flush_workqueue(ldv_func_arg1);
#line 1028
  call_and_disable_all_2(2);
#line 1029
  return;
}
}
#line 1031 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
bool ldv_queue_delayed_work_on_99(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 1035
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1035
  ldv_func_res = tmp;
#line 1037
  activate_work_2(& ldv_func_arg3->work, 2);
#line 1039
  return (ldv_func_res);
}
}
#line 1042 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_mutex_lock_100(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1045
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1047
  mutex_lock(ldv_func_arg1);
#line 1048
  return;
}
}
#line 1050 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_mutex_unlock_101(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1053
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1055
  mutex_unlock(ldv_func_arg1);
#line 1056
  return;
}
}
#line 1058 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_mutex_unlock_102(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1061
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 1063
  mutex_unlock(ldv_func_arg1);
#line 1064
  return;
}
}
#line 1066 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_mutex_lock_103(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1069
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 1071
  mutex_lock(ldv_func_arg1);
#line 1072
  return;
}
}
#line 1074 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_mutex_lock_104(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1077
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 1079
  mutex_lock(ldv_func_arg1);
#line 1080
  return;
}
}
#line 1082 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
int ldv_mutex_trylock_105(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1086
  tmp = mutex_trylock(ldv_func_arg1);
#line 1086
  ldv_func_res = tmp;
#line 1088
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 1088
  return (tmp___0);
#line 1090
  return (ldv_func_res);
}
}
#line 1093 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_mutex_unlock_106(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1096
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 1098
  mutex_unlock(ldv_func_arg1);
#line 1099
  return;
}
}
#line 1101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_mutex_lock_107(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1104
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 1106
  mutex_lock(ldv_func_arg1);
#line 1107
  return;
}
}
#line 1109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_mutex_unlock_108(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1112
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 1114
  mutex_unlock(ldv_func_arg1);
#line 1115
  return;
}
}
#line 1117 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_mutex_unlock_109(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1120
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 1122
  mutex_unlock(ldv_func_arg1);
#line 1123
  return;
}
}
#line 1125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_mutex_lock_110(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1128
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 1130
  mutex_lock(ldv_func_arg1);
#line 1131
  return;
}
}
#line 1133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
int ldv_mutex_lock_interruptible_111(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1137
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 1137
  ldv_func_res = tmp;
#line 1139
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 1139
  return (tmp___0);
#line 1141
  return (ldv_func_res);
}
}
#line 1144 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
int ldv_mutex_trylock_112(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1148
  tmp = mutex_trylock(ldv_func_arg1);
#line 1148
  ldv_func_res = tmp;
#line 1150
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 1150
  return (tmp___0);
#line 1152
  return (ldv_func_res);
}
}
#line 1166 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
__inline static int ldv_kref_put_mutex_114(struct kref *kref , void (*release)(struct kref * ) ,
                                           struct mutex *lock ) 
{ 


  {
#line 1170
  ldv_mutex_lock_struct_mutex_of_drm_device(lock);
#line 1171
  drm_gem_object_free(kref);
#line 1172
  return (1);
}
}
#line 1176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_mutex_unlock_115(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1179
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 1181
  mutex_unlock(ldv_func_arg1);
#line 1182
  return;
}
}
#line 1184 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_mutex_lock_116(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1187
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 1189
  mutex_lock(ldv_func_arg1);
#line 1190
  return;
}
}
#line 1192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_mutex_unlock_117(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1195
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 1197
  mutex_unlock(ldv_func_arg1);
#line 1198
  return;
}
}
#line 1200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_mutex_unlock_118(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1203
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 1205
  mutex_unlock(ldv_func_arg1);
#line 1206
  return;
}
}
#line 1208 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_mutex_lock_119(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1211
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 1213
  mutex_lock(ldv_func_arg1);
#line 1214
  return;
}
}
#line 1216 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_mutex_unlock_120(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1219
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 1221
  mutex_unlock(ldv_func_arg1);
#line 1222
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_158(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_167(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_156(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_159(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_160(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_163(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_164(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_170(struct mutex *ldv_func_arg1 ) ;
#line 209
void ldv_mutex_unlock_172(struct mutex *ldv_func_arg1 ) ;
#line 213
void ldv_mutex_unlock_174(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.o.c.prepared"
int ldv_mutex_lock_interruptible_166(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_155(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_157(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_161(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_162(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_165(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_171(struct mutex *ldv_func_arg1 ) ;
#line 49
void ldv_mutex_lock_173(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_150(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_152(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_151(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_154(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_153(struct workqueue_struct *ldv_func_arg1 ) ;
#line 2015 "include/linux/mm.h"
extern int vm_insert_pfn(struct vm_area_struct * , unsigned long  , unsigned long  ) ;
#line 76 "include/linux/pagemap.h"
__inline static void mapping_set_gfp_mask(struct address_space *m , gfp_t mask ) 
{ 


  {
#line 78
  m->flags = (m->flags & 0xfffffffffe000000UL) | (unsigned long )mask;
#line 80
  return;
}
}
#line 213 "include/drm/drm_vma_manager.h"
__inline static __u64 drm_vma_node_offset_addr(struct drm_vma_offset_node *node ) 
{ 


  {
#line 215
  return (node->vm_node.start << 12);
}
}
#line 124 "include/drm/drm_gem.h"
extern void drm_gem_object_release(struct drm_gem_object * ) ;
#line 126
extern int drm_gem_object_init(struct drm_device * , struct drm_gem_object * , size_t  ) ;
#line 170
extern void drm_gem_free_mmap_offset(struct drm_gem_object * ) ;
#line 171
extern int drm_gem_create_mmap_offset(struct drm_gem_object * ) ;
#line 61 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/gtt.h"
int psb_gtt_pin(struct gtt_range *gt ) ;
#line 744 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
void psb_gem_free_object(struct drm_gem_object *obj ) ;
#line 745
int psb_gem_get_aperture(struct drm_device *dev , void *data , struct drm_file *file ) ;
#line 747
int psb_gem_dumb_create(struct drm_file *file , struct drm_device *dev , struct drm_mode_create_dumb *args ) ;
#line 749
int psb_gem_dumb_map_gtt(struct drm_file *file , struct drm_device *dev , uint32_t handle ,
                         uint64_t *offset ) ;
#line 751
int psb_gem_fault(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.c"
void psb_gem_free_object(struct drm_gem_object *obj ) 
{ 
  struct gtt_range *gtt ;
  struct drm_gem_object  const  *__mptr ;

  {
#line 34
  __mptr = (struct drm_gem_object  const  *)obj;
#line 34
  gtt = (struct gtt_range *)__mptr + 0xffffffffffffffc0UL;
#line 37
  drm_gem_free_mmap_offset(obj);
#line 38
  drm_gem_object_release(obj);
#line 41
  psb_gtt_free_range(obj->dev, gtt);
#line 42
  return;
}
}
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.c"
int psb_gem_get_aperture(struct drm_device *dev , void *data , struct drm_file *file ) 
{ 


  {
#line 47
  return (-22);
}
}
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.c"
int psb_gem_dumb_map_gtt(struct drm_file *file , struct drm_device *dev , uint32_t handle ,
                         uint64_t *offset ) 
{ 
  int ret ;
  struct drm_gem_object *obj ;

  {
#line 62
  ret = 0;
#line 65
  ldv_mutex_lock_171(& dev->struct_mutex);
#line 68
  obj = drm_gem_object_lookup(dev, file, handle);
#line 69
  if ((unsigned long )obj == (unsigned long )((struct drm_gem_object *)0)) {
#line 70
    ret = -2;
#line 71
    goto unlock;
  } else {

  }
#line 76
  ret = drm_gem_create_mmap_offset(obj);
#line 77
  if (ret != 0) {
#line 78
    goto out;
  } else {

  }
#line 79
  *offset = drm_vma_node_offset_addr(& obj->vma_node);
  out: 
#line 81
  drm_gem_object_unreference(obj);
  unlock: 
#line 83
  ldv_mutex_unlock_172(& dev->struct_mutex);
#line 84
  return (ret);
}
}
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.c"
int psb_gem_create(struct drm_file *file , struct drm_device *dev , u64 size , u32 *handlep ,
                   int stolen , u32 align ) 
{ 
  struct gtt_range *r ;
  int ret ;
  u32 handle ;
  unsigned long __y ;
  int tmp ;

  {
#line 105
  __y = 4096UL;
#line 105
  size = ((((unsigned long long )__y + size) - 1ULL) / (unsigned long long )__y) * (unsigned long long )__y;
#line 109
  r = psb_gtt_alloc_range(dev, (int )size, "gem", 0, 4096U);
#line 110
  if ((unsigned long )r == (unsigned long )((struct gtt_range *)0)) {
#line 111
    dev_err((struct device  const  *)dev->dev, "no memory for %lld byte GEM object\n",
            size);
#line 112
    return (-28);
  } else {

  }
#line 115
  tmp = drm_gem_object_init(dev, & r->gem, (size_t )size);
#line 115
  if (tmp != 0) {
#line 116
    psb_gtt_free_range(dev, r);
#line 118
    dev_err((struct device  const  *)dev->dev, "GEM init failed for %lld\n", size);
#line 119
    return (-12);
  } else {

  }
#line 122
  mapping_set_gfp_mask((r->gem.filp)->f_mapping, 212U);
#line 124
  ret = drm_gem_handle_create(file, & r->gem, & handle);
#line 125
  if (ret != 0) {
#line 126
    dev_err((struct device  const  *)dev->dev, "GEM handle failed for %p, %lld\n",
            & r->gem, size);
#line 128
    drm_gem_object_release(& r->gem);
#line 129
    psb_gtt_free_range(dev, r);
#line 130
    return (ret);
  } else {

  }
#line 133
  drm_gem_object_unreference(& r->gem);
#line 134
  *handlep = handle;
#line 135
  return (0);
}
}
#line 148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.c"
int psb_gem_dumb_create(struct drm_file *file , struct drm_device *dev , struct drm_mode_create_dumb *args ) 
{ 
  int tmp ;

  {
#line 151
  args->pitch = (args->width * ((args->bpp + 7U) / 8U) + 63U) & 4294967232U;
#line 152
  args->size = (uint64_t )(args->pitch * args->height);
#line 153
  tmp = psb_gem_create(file, dev, args->size, & args->handle, 0, 4096U);
#line 153
  return (tmp);
}
}
#line 174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.c"
int psb_gem_fault(struct vm_area_struct *vma , struct vm_fault *vmf ) 
{ 
  struct drm_gem_object *obj ;
  struct gtt_range *r ;
  int ret ;
  unsigned long pfn ;
  unsigned long page_offset___0 ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct drm_gem_object  const  *__mptr ;

  {
#line 184
  obj = (struct drm_gem_object *)vma->vm_private_data;
#line 185
  dev = obj->dev;
#line 186
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 188
  __mptr = (struct drm_gem_object  const  *)obj;
#line 188
  r = (struct gtt_range *)__mptr + 0xffffffffffffffc0UL;
#line 192
  ldv_mutex_lock_173(& dev->struct_mutex);
#line 196
  if (! r->mmapping) {
#line 197
    ret = psb_gtt_pin(r);
#line 198
    if (ret < 0) {
#line 199
      dev_err((struct device  const  *)dev->dev, "gma500: pin failed: %d\n", ret);
#line 200
      goto fail;
    } else {

    }
#line 202
    r->mmapping = 1;
  } else {

  }
#line 207
  page_offset___0 = ((unsigned long )vmf->virtual_address - vma->vm_start) >> 12;
#line 211
  if ((int )r->stolen) {
#line 212
    pfn = (unsigned long )((dev_priv->stolen_base + r->offset) >> 12);
  } else {
#line 214
    pfn = (unsigned long )(((long )*(r->pages + page_offset___0) + 24189255811072L) / 64L);
  }
#line 215
  ret = vm_insert_pfn(vma, (unsigned long )vmf->virtual_address, pfn);
  fail: 
#line 218
  ldv_mutex_unlock_174(& dev->struct_mutex);
#line 219
  switch (ret) {
  case 0: ;
  case -512: ;
  case -4: ;
#line 223
  return (256);
  case -12: ;
#line 225
  return (1);
  default: ;
#line 227
  return (2);
  }
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.o.c.prepared"
bool ldv_queue_work_on_150(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 432
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 432
  ldv_func_res = tmp;
#line 434
  activate_work_2(ldv_func_arg3, 2);
#line 436
  return (ldv_func_res);
}
}
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.o.c.prepared"
bool ldv_queue_delayed_work_on_151(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 443
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 443
  ldv_func_res = tmp;
#line 445
  activate_work_2(& ldv_func_arg3->work, 2);
#line 447
  return (ldv_func_res);
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.o.c.prepared"
bool ldv_queue_work_on_152(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 454
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 454
  ldv_func_res = tmp;
#line 456
  activate_work_2(ldv_func_arg3, 2);
#line 458
  return (ldv_func_res);
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.o.c.prepared"
void ldv_flush_workqueue_153(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 464
  flush_workqueue(ldv_func_arg1);
#line 466
  call_and_disable_all_2(2);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.o.c.prepared"
bool ldv_queue_delayed_work_on_154(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 473
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 473
  ldv_func_res = tmp;
#line 475
  activate_work_2(& ldv_func_arg3->work, 2);
#line 477
  return (ldv_func_res);
}
}
#line 480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.o.c.prepared"
void ldv_mutex_lock_155(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 483
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 485
  mutex_lock(ldv_func_arg1);
#line 486
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.o.c.prepared"
void ldv_mutex_unlock_156(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 491
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 493
  mutex_unlock(ldv_func_arg1);
#line 494
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.o.c.prepared"
void ldv_mutex_lock_157(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 499
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 501
  mutex_lock(ldv_func_arg1);
#line 502
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.o.c.prepared"
int ldv_mutex_trylock_158(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 508
  tmp = mutex_trylock(ldv_func_arg1);
#line 508
  ldv_func_res = tmp;
#line 510
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 510
  return (tmp___0);
#line 512
  return (ldv_func_res);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.o.c.prepared"
void ldv_mutex_unlock_159(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 518
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 520
  mutex_unlock(ldv_func_arg1);
#line 521
  return;
}
}
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.o.c.prepared"
void ldv_mutex_unlock_160(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 526
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 528
  mutex_unlock(ldv_func_arg1);
#line 529
  return;
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.o.c.prepared"
void ldv_mutex_lock_161(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 534
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 536
  mutex_lock(ldv_func_arg1);
#line 537
  return;
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.o.c.prepared"
void ldv_mutex_lock_162(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 542
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 544
  mutex_lock(ldv_func_arg1);
#line 545
  return;
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.o.c.prepared"
void ldv_mutex_unlock_163(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 550
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 552
  mutex_unlock(ldv_func_arg1);
#line 553
  return;
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.o.c.prepared"
void ldv_mutex_unlock_164(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 558
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 560
  mutex_unlock(ldv_func_arg1);
#line 561
  return;
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.o.c.prepared"
void ldv_mutex_lock_165(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 566
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 568
  mutex_lock(ldv_func_arg1);
#line 569
  return;
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.o.c.prepared"
int ldv_mutex_lock_interruptible_166(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 575
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 575
  ldv_func_res = tmp;
#line 577
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 577
  return (tmp___0);
#line 579
  return (ldv_func_res);
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.o.c.prepared"
int ldv_mutex_trylock_167(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 586
  tmp = mutex_trylock(ldv_func_arg1);
#line 586
  ldv_func_res = tmp;
#line 588
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 588
  return (tmp___0);
#line 590
  return (ldv_func_res);
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.o.c.prepared"
void ldv_mutex_unlock_170(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 617
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 619
  mutex_unlock(ldv_func_arg1);
#line 620
  return;
}
}
#line 622 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.o.c.prepared"
void ldv_mutex_lock_171(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 625
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 627
  mutex_lock(ldv_func_arg1);
#line 628
  return;
}
}
#line 630 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.o.c.prepared"
void ldv_mutex_unlock_172(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 633
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 635
  mutex_unlock(ldv_func_arg1);
#line 636
  return;
}
}
#line 638 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.o.c.prepared"
void ldv_mutex_lock_173(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 641
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 643
  mutex_lock(ldv_func_arg1);
#line 644
  return;
}
}
#line 646 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gem.o.c.prepared"
void ldv_mutex_unlock_174(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 649
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 651
  mutex_unlock(ldv_func_arg1);
#line 652
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 3 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
bool ldv_is_err(void const   *ptr ) ;
#line 6
long ldv_ptr_err(void const   *ptr ) ;
#line 32 "include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 119 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 176
int ldv_mutex_trylock_211(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_220(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_209(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_212(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_213(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_216(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_217(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_223(struct mutex *ldv_func_arg1 ) ;
#line 209
void ldv_mutex_unlock_225(struct mutex *ldv_func_arg1 ) ;
#line 213
void ldv_mutex_unlock_227(struct mutex *ldv_func_arg1 ) ;
#line 217
void ldv_mutex_unlock_229(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
int ldv_mutex_lock_interruptible_219(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_208(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_210(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_214(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_215(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_218(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_224(struct mutex *ldv_func_arg1 ) ;
#line 49
void ldv_mutex_lock_226(struct mutex *ldv_func_arg1 ) ;
#line 53
void ldv_mutex_lock_228(struct mutex *ldv_func_arg1 ) ;
#line 71
void ldv_mutex_lock_gtt_mutex_of_drm_psb_private(struct mutex *lock ) ;
#line 75
void ldv_mutex_unlock_gtt_mutex_of_drm_psb_private(struct mutex *lock ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_203(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_205(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_204(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_207(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_206(struct workqueue_struct *ldv_func_arg1 ) ;
#line 84 "include/linux/rwsem.h"
extern void __init_rwsem(struct rw_semaphore * , char const   * , struct lock_class_key * ) ;
#line 143 "include/linux/ioport.h"
extern int release_resource(struct resource * ) ;
#line 152
extern int allocate_resource(struct resource * , struct resource * , resource_size_t  ,
                             resource_size_t  , resource_size_t  , resource_size_t  ,
                             resource_size_t (*)(void * , struct resource  const  * ,
                                                 resource_size_t  , resource_size_t  ) ,
                             void * ) ;
#line 181 "./arch/x86/include/asm/io.h"
extern void *ioremap_nocache(resource_size_t  , unsigned long  ) ;
#line 195
extern void iounmap(void volatile   * ) ;
#line 329
extern void *ioremap_wc(resource_size_t  , unsigned long  ) ;
#line 58 "./arch/x86/include/asm/cacheflush.h"
extern int set_pages_array_wc(struct page ** , int  ) ;
#line 60
extern int set_pages_array_wb(struct page ** , int  ) ;
#line 859 "include/linux/pci.h"
extern int pci_bus_read_config_word(struct pci_bus * , unsigned int  , int  , u16 * ) ;
#line 865
extern int pci_bus_write_config_word(struct pci_bus * , unsigned int  , int  , u16  ) ;
#line 885 "include/linux/pci.h"
__inline static int pci_read_config_word(struct pci_dev  const  *dev , int where ,
                                         u16 *val ) 
{ 
  int tmp ;

  {
#line 887
  tmp = pci_bus_read_config_word(dev->bus, dev->devfn, where, val);
#line 887
  return (tmp);
}
}
#line 898 "include/linux/pci.h"
__inline static int pci_write_config_word(struct pci_dev  const  *dev , int where ,
                                          u16 val ) 
{ 
  int tmp ;

  {
#line 900
  tmp = pci_bus_write_config_word(dev->bus, dev->devfn, where, (int )val);
#line 900
  return (tmp);
}
}
#line 130 "include/drm/drmP.h"
extern void drm_ut_debug_printk(char const   * , char const   *  , ...) ;
#line 133
extern void drm_err(char const   *  , ...) ;
#line 980
extern unsigned int drm_debug ;
#line 174 "include/drm/drm_gem.h"
extern struct page **drm_gem_get_pages(struct drm_gem_object * ) ;
#line 175
extern void drm_gem_put_pages(struct drm_gem_object * , struct page ** , bool  , bool  ) ;
#line 40 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/gtt.h"
int psb_gtt_init(struct drm_device *dev , int resume ) ;
#line 41
void psb_gtt_takedown(struct drm_device *dev ) ;
#line 62
void psb_gtt_unpin(struct gtt_range *gt ) ;
#line 65
int psb_gtt_restore(struct drm_device *dev ) ;
#line 67 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/mmu.h"
struct psb_mmu_pd *psb_mmu_get_default_pd(struct psb_mmu_driver *driver___0 ) ;
#line 84
int psb_mmu_insert_pages(struct psb_mmu_pd *pd , struct page **pages , unsigned long address ,
                         uint32_t num_pages , uint32_t desired_tile_stride , uint32_t hw_tile_stride ,
                         int type ) ;
#line 88
void psb_mmu_remove_pages(struct psb_mmu_pd *pd , unsigned long address , uint32_t num_pages ,
                          uint32_t desired_tile_stride , uint32_t hw_tile_stride ) ;
#line 20 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/blitter.h"
int gma_blt_wait_idle(struct drm_psb_private *dev_priv ) ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c"
__inline static uint32_t psb_gtt_mask_pte(uint32_t pfn , int type ) 
{ 
  uint32_t mask ;
  long tmp ;

  {
#line 41
  mask = 1U;
#line 45
  tmp = ldv__builtin_expect((pfn & 4293918720U) != 0U, 0L);
#line 45
  if (tmp != 0L) {
#line 45
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c"),
                         "i" (45), "i" (12UL));
    ldv_43085: ;
#line 45
    goto ldv_43085;
  } else {

  }
#line 47
  if (type & 1) {
#line 48
    mask = mask | 8U;
  } else {

  }
#line 49
  if ((type & 2) != 0) {
#line 50
    mask = mask | 4U;
  } else {

  }
#line 51
  if ((type & 4) != 0) {
#line 52
    mask = mask | 2U;
  } else {

  }
#line 54
  return ((pfn << 12) | mask);
}
}
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c"
static u32 *psb_gtt_entry(struct drm_device *dev , struct gtt_range *r ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned long offset ;

  {
#line 67
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 70
  offset = (unsigned long )(r->resource.start - (dev_priv->gtt_mem)->start);
#line 72
  return (dev_priv->gtt_map + (offset >> 12));
}
}
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c"
static int psb_gtt_insert(struct drm_device *dev , struct gtt_range *r , int resume ) 
{ 
  u32 *gtt_slot ;
  u32 pte ;
  struct page **pages ;
  int i ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;
  u32 *tmp___1 ;
  u32 *tmp___2 ;

  {
#line 92
  if ((unsigned long )r->pages == (unsigned long )((struct page **)0)) {
#line 93
    __ret_warn_on = 1;
#line 93
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 93
    if (tmp != 0L) {
#line 93
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c",
                         93);
    } else {

    }
#line 93
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 94
    return (-22);
  } else {

  }
#line 97
  __ret_warn_on___0 = (int )r->stolen;
#line 97
  tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 97
  if (tmp___0 != 0L) {
#line 97
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c",
                       97);
  } else {

  }
#line 97
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 99
  gtt_slot = psb_gtt_entry(dev, r);
#line 100
  pages = r->pages;
#line 102
  if (resume == 0) {
#line 104
    set_pages_array_wc(pages, r->npage);
  } else {

  }
#line 108
  i = r->roll;
#line 108
  goto ldv_43106;
  ldv_43105: 
#line 109
  pte = psb_gtt_mask_pte((uint32_t )(((long )*(r->pages + (unsigned long )i) + 24189255811072L) / 64L),
                         1);
#line 111
  tmp___1 = gtt_slot;
#line 111
  gtt_slot = gtt_slot + 1;
#line 111
  iowrite32(pte, (void *)tmp___1);
#line 108
  i = i + 1;
  ldv_43106: ;
#line 108
  if (r->npage > i) {
#line 110
    goto ldv_43105;
  } else {

  }
#line 113
  i = 0;
#line 113
  goto ldv_43109;
  ldv_43108: 
#line 114
  pte = psb_gtt_mask_pte((uint32_t )(((long )*(r->pages + (unsigned long )i) + 24189255811072L) / 64L),
                         1);
#line 116
  tmp___2 = gtt_slot;
#line 116
  gtt_slot = gtt_slot + 1;
#line 116
  iowrite32(pte, (void *)tmp___2);
#line 113
  i = i + 1;
  ldv_43109: ;
#line 113
  if (r->roll > i) {
#line 115
    goto ldv_43108;
  } else {

  }
#line 119
  ioread32((void *)gtt_slot + 0xffffffffffffffffUL);
#line 121
  return (0);
}
}
#line 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c"
void psb_gtt_remove(struct drm_device *dev , struct gtt_range *r ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 *gtt_slot ;
  u32 pte ;
  int i ;
  int __ret_warn_on ;
  long tmp ;
  u32 *tmp___0 ;

  {
#line 135
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 140
  __ret_warn_on = (int )r->stolen;
#line 140
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 140
  if (tmp != 0L) {
#line 140
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c",
                       140);
  } else {

  }
#line 140
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 142
  gtt_slot = psb_gtt_entry(dev, r);
#line 143
  pte = psb_gtt_mask_pte((uint32_t )(((long )dev_priv->scratch_page + 24189255811072L) / 64L),
                         1);
#line 146
  i = 0;
#line 146
  goto ldv_43122;
  ldv_43121: 
#line 147
  tmp___0 = gtt_slot;
#line 147
  gtt_slot = gtt_slot + 1;
#line 147
  iowrite32(pte, (void *)tmp___0);
#line 146
  i = i + 1;
  ldv_43122: ;
#line 146
  if (r->npage > i) {
#line 148
    goto ldv_43121;
  } else {

  }
#line 148
  ioread32((void *)gtt_slot + 0xffffffffffffffffUL);
#line 149
  set_pages_array_wb(r->pages, r->npage);
#line 150
  return;
}
}
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c"
void psb_gtt_roll(struct drm_device *dev , struct gtt_range *r , int roll ) 
{ 
  u32 *gtt_slot ;
  u32 pte ;
  int i ;
  int __ret_warn_on ;
  long tmp ;
  u32 *tmp___0 ;
  u32 *tmp___1 ;

  {
#line 168
  if (r->npage <= roll) {
#line 169
    __ret_warn_on = 1;
#line 169
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 169
    if (tmp != 0L) {
#line 169
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c",
                         169);
    } else {

    }
#line 169
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 170
    return;
  } else {

  }
#line 173
  r->roll = roll;
#line 177
  if (! r->stolen && r->in_gart == 0) {
#line 178
    return;
  } else {

  }
#line 180
  gtt_slot = psb_gtt_entry(dev, r);
#line 182
  i = r->roll;
#line 182
  goto ldv_43135;
  ldv_43134: 
#line 183
  pte = psb_gtt_mask_pte((uint32_t )(((long )*(r->pages + (unsigned long )i) + 24189255811072L) / 64L),
                         1);
#line 185
  tmp___0 = gtt_slot;
#line 185
  gtt_slot = gtt_slot + 1;
#line 185
  iowrite32(pte, (void *)tmp___0);
#line 182
  i = i + 1;
  ldv_43135: ;
#line 182
  if (r->npage > i) {
#line 184
    goto ldv_43134;
  } else {

  }
#line 187
  i = 0;
#line 187
  goto ldv_43138;
  ldv_43137: 
#line 188
  pte = psb_gtt_mask_pte((uint32_t )(((long )*(r->pages + (unsigned long )i) + 24189255811072L) / 64L),
                         1);
#line 190
  tmp___1 = gtt_slot;
#line 190
  gtt_slot = gtt_slot + 1;
#line 190
  iowrite32(pte, (void *)tmp___1);
#line 187
  i = i + 1;
  ldv_43138: ;
#line 187
  if (r->roll > i) {
#line 189
    goto ldv_43137;
  } else {

  }
#line 192
  ioread32((void *)gtt_slot + 0xffffffffffffffffUL);
#line 193
  return;
}
}
#line 203 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c"
static int psb_gtt_attach_pages(struct gtt_range *gt ) 
{ 
  struct page **pages ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  bool tmp___1 ;

  {
#line 207
  __ret_warn_on = (unsigned long )gt->pages != (unsigned long )((struct page **)0);
#line 207
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 207
  if (tmp != 0L) {
#line 207
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c",
                       207);
  } else {

  }
#line 207
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 209
  pages = drm_gem_get_pages(& gt->gem);
#line 210
  tmp___1 = IS_ERR((void const   *)pages);
#line 210
  if ((int )tmp___1) {
#line 211
    tmp___0 = PTR_ERR((void const   *)pages);
#line 211
    return ((int )tmp___0);
  } else {

  }
#line 213
  gt->npage = (int )(gt->gem.size / 4096UL);
#line 214
  gt->pages = pages;
#line 216
  return (0);
}
}
#line 228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c"
static void psb_gtt_detach_pages(struct gtt_range *gt ) 
{ 


  {
#line 230
  drm_gem_put_pages(& gt->gem, gt->pages, 1, 0);
#line 231
  gt->pages = (struct page **)0;
#line 232
  return;
}
}
#line 244 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c"
int psb_gtt_pin(struct gtt_range *gt ) 
{ 
  int ret ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  u32 gpu_base ;
  struct psb_mmu_pd *tmp ;

  {
#line 246
  ret = 0;
#line 247
  dev = gt->gem.dev;
#line 248
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 249
  gpu_base = dev_priv->gtt.gatt_start;
#line 251
  ldv_mutex_lock_224(& dev_priv->gtt_mutex);
#line 253
  if (gt->in_gart == 0 && ! gt->stolen) {
#line 254
    ret = psb_gtt_attach_pages(gt);
#line 255
    if (ret < 0) {
#line 256
      goto out;
    } else {

    }
#line 257
    ret = psb_gtt_insert(dev, gt, 0);
#line 258
    if (ret < 0) {
#line 259
      psb_gtt_detach_pages(gt);
#line 260
      goto out;
    } else {

    }
#line 262
    tmp = psb_mmu_get_default_pd(dev_priv->mmu);
#line 262
    psb_mmu_insert_pages(tmp, gt->pages, (unsigned long )(gt->offset + gpu_base),
                         (uint32_t )gt->npage, 0U, 0U, 1);
  } else {

  }
#line 266
  gt->in_gart = gt->in_gart + 1;
  out: 
#line 268
  ldv_mutex_unlock_225(& dev_priv->gtt_mutex);
#line 269
  return (ret);
}
}
#line 283 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c"
void psb_gtt_unpin(struct gtt_range *gt ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  u32 gpu_base ;
  int ret ;
  int __ret_warn_on ;
  long tmp ;
  struct psb_mmu_pd *tmp___0 ;

  {
#line 285
  dev = gt->gem.dev;
#line 286
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 287
  gpu_base = dev_priv->gtt.gatt_start;
#line 291
  ldv_mutex_lock_226(& dev_priv->gtt_mutex);
#line 294
  ret = gma_blt_wait_idle(dev_priv);
#line 295
  if (ret != 0) {
#line 296
    drm_err("Failed to idle the blitter, unpin failed!");
#line 297
    goto out;
  } else {

  }
#line 300
  __ret_warn_on = gt->in_gart == 0;
#line 300
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 300
  if (tmp != 0L) {
#line 300
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c",
                       300);
  } else {

  }
#line 300
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 302
  gt->in_gart = gt->in_gart - 1;
#line 303
  if (gt->in_gart == 0 && ! gt->stolen) {
#line 304
    tmp___0 = psb_mmu_get_default_pd(dev_priv->mmu);
#line 304
    psb_mmu_remove_pages(tmp___0, (unsigned long )(gt->offset + gpu_base), (uint32_t )gt->npage,
                         0U, 0U);
#line 306
    psb_gtt_remove(dev, gt);
#line 307
    psb_gtt_detach_pages(gt);
  } else {

  }
  out: 
#line 311
  ldv_mutex_unlock_227(& dev_priv->gtt_mutex);
#line 312
  return;
}
}
#line 332 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c"
struct gtt_range *psb_gtt_alloc_range(struct drm_device *dev , int len , char const   *name ,
                                      int backed , u32 align ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct gtt_range *gt ;
  struct resource *r ;
  int ret ;
  unsigned long start ;
  unsigned long end ;
  void *tmp ;

  {
#line 335
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 337
  r = dev_priv->gtt_mem;
#line 341
  if (backed != 0) {
#line 343
    start = (unsigned long )r->start;
#line 344
    end = (unsigned long )((r->start + (unsigned long long )dev_priv->gtt.stolen_size) - 1ULL);
  } else {
#line 347
    start = (unsigned long )(r->start + (unsigned long long )dev_priv->gtt.stolen_size);
#line 348
    end = (unsigned long )r->end;
  }
#line 351
  tmp = kzalloc(336UL, 208U);
#line 351
  gt = (struct gtt_range *)tmp;
#line 352
  if ((unsigned long )gt == (unsigned long )((struct gtt_range *)0)) {
#line 353
    return ((struct gtt_range *)0);
  } else {

  }
#line 354
  gt->resource.name = name;
#line 355
  gt->stolen = backed != 0;
#line 356
  gt->in_gart = backed;
#line 357
  gt->roll = 0;
#line 359
  gt->gem.dev = dev;
#line 360
  ret = allocate_resource(dev_priv->gtt_mem, & gt->resource, (resource_size_t )len,
                          (resource_size_t )start, (resource_size_t )end, (resource_size_t )align,
                          (resource_size_t (*)(void * , struct resource  const  * ,
                                               resource_size_t  , resource_size_t  ))0,
                          (void *)0);
#line 362
  if (ret == 0) {
#line 363
    gt->offset = (u32 )gt->resource.start - (u32 )r->start;
#line 364
    return (gt);
  } else {

  }
#line 366
  kfree((void const   *)gt);
#line 367
  return ((struct gtt_range *)0);
}
}
#line 378 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c"
void psb_gtt_free_range(struct drm_device *dev , struct gtt_range *gt ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
#line 381
  if ((int )gt->mmapping) {
#line 382
    psb_gtt_unpin(gt);
#line 383
    gt->mmapping = 0;
  } else {

  }
#line 385
  __ret_warn_on = gt->in_gart != 0 && ! gt->stolen;
#line 385
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 385
  if (tmp != 0L) {
#line 385
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c",
                       385);
  } else {

  }
#line 385
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 386
  release_resource(& gt->resource);
#line 387
  kfree((void const   *)gt);
#line 388
  return;
}
}
#line 390 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c"
static void psb_gtt_alloc(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct lock_class_key __key ;

  {
#line 392
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 393
  __init_rwsem(& dev_priv->gtt.sem, "&dev_priv->gtt.sem", & __key);
#line 395
  return;
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c"
void psb_gtt_takedown(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 398
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 400
  if ((unsigned long )dev_priv->gtt_map != (unsigned long )((u32 *)0U)) {
#line 401
    iounmap((void volatile   *)dev_priv->gtt_map);
#line 402
    dev_priv->gtt_map = (u32 *)0U;
  } else {

  }
#line 404
  if (dev_priv->gtt_initialized != 0) {
#line 405
    pci_write_config_word((struct pci_dev  const  *)dev->pdev, 82, (int )dev_priv->gmch_ctrl);
#line 407
    iowrite32(dev_priv->pge_ctl, (void *)dev_priv->vdc_reg + 8224U);
#line 408
    ioread32((void *)dev_priv->vdc_reg + 8224U);
  } else {

  }
#line 410
  if ((unsigned long )dev_priv->vram_addr != (unsigned long )((u8 *)0U)) {
#line 411
    iounmap((void volatile   *)dev_priv->gtt_map);
  } else {

  }
#line 412
  return;
}
}
#line 414 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c"
int psb_gtt_init(struct drm_device *dev , int resume ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned int gtt_pages ;
  unsigned long stolen_size ;
  unsigned long vram_stolen_size ;
  unsigned int i ;
  unsigned int num_pages ;
  unsigned int pfn_base ;
  struct psb_gtt *pg ;
  int ret ;
  uint32_t pte ;
  struct lock_class_key __key ;
  struct _ddebug descriptor ;
  long tmp ;
  struct resource fudge ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  struct _ddebug descriptor___2 ;
  long tmp___4 ;

  {
#line 416
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 423
  ret = 0;
#line 426
  if (resume == 0) {
#line 427
    __mutex_init(& dev_priv->gtt_mutex, "&dev_priv->gtt_mutex", & __key);
#line 428
    psb_gtt_alloc(dev);
  } else {

  }
#line 431
  pg = & dev_priv->gtt;
#line 434
  pci_read_config_word((struct pci_dev  const  *)dev->pdev, 82, & dev_priv->gmch_ctrl);
#line 435
  pci_write_config_word((struct pci_dev  const  *)dev->pdev, 82, (int )((unsigned int )dev_priv->gmch_ctrl | 4U));
#line 438
  dev_priv->pge_ctl = ioread32((void *)dev_priv->vdc_reg + 8224U);
#line 439
  iowrite32(dev_priv->pge_ctl | 1U, (void *)dev_priv->vdc_reg + 8224U);
#line 440
  ioread32((void *)dev_priv->vdc_reg + 8224U);
#line 443
  dev_priv->gtt_initialized = 1;
#line 445
  pg->gtt_phys_start = dev_priv->pge_ctl & 4294963200U;
#line 453
  pg->mmu_gatt_start = 3758096384U;
#line 455
  pg->gtt_start = (uint32_t )(dev->pdev)->resource[3].start;
#line 456
  gtt_pages = (dev->pdev)->resource[3].start != 0ULL || (dev->pdev)->resource[3].end != (dev->pdev)->resource[3].start ? (unsigned int )((((dev->pdev)->resource[3].end - (dev->pdev)->resource[3].start) + 1ULL) >> 12) : 0U;
#line 459
  if (pg->gtt_start == 0U || gtt_pages == 0U) {
#line 460
    descriptor.modname = "gma500_gfx";
#line 460
    descriptor.function = "psb_gtt_init";
#line 460
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c";
#line 460
    descriptor.format = "GTT PCI BAR not initialized.\n";
#line 460
    descriptor.lineno = 460U;
#line 460
    descriptor.flags = 0U;
#line 460
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 460
    if (tmp != 0L) {
#line 460
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "GTT PCI BAR not initialized.\n");
    } else {

    }
#line 461
    gtt_pages = 64U;
#line 462
    pg->gtt_start = dev_priv->pge_ctl;
  } else {

  }
#line 465
  pg->gatt_start = (uint32_t )(dev->pdev)->resource[2].start;
#line 466
  pg->gatt_pages = (dev->pdev)->resource[2].start != 0ULL || (dev->pdev)->resource[2].end != (dev->pdev)->resource[2].start ? (unsigned int )((((dev->pdev)->resource[2].end - (dev->pdev)->resource[2].start) + 1ULL) >> 12) : 0U;
#line 468
  dev_priv->gtt_mem = (struct resource *)(& (dev->pdev)->resource) + 2UL;
#line 470
  if (pg->gatt_pages == 0U || pg->gatt_start == 0U) {
#line 475
    descriptor___0.modname = "gma500_gfx";
#line 475
    descriptor___0.function = "psb_gtt_init";
#line 475
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c";
#line 475
    descriptor___0.format = "GATT PCI BAR not initialized.\n";
#line 475
    descriptor___0.lineno = 475U;
#line 475
    descriptor___0.flags = 0U;
#line 475
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 475
    if (tmp___0 != 0L) {
#line 475
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)dev->dev, "GATT PCI BAR not initialized.\n");
    } else {

    }
#line 476
    pg->gatt_start = 1073741824U;
#line 477
    pg->gatt_pages = 32768U;
#line 482
    fudge.start = 1073741824ULL;
#line 483
    fudge.end = 1207959551ULL;
#line 484
    fudge.name = "fudge";
#line 485
    fudge.flags = 512UL;
#line 486
    dev_priv->gtt_mem = & fudge;
  } else {

  }
#line 489
  pci_read_config_dword((struct pci_dev  const  *)dev->pdev, 92, & dev_priv->stolen_base);
#line 490
  vram_stolen_size = (unsigned long )(pg->gtt_phys_start - dev_priv->stolen_base) - 4096UL;
#line 493
  stolen_size = vram_stolen_size;
#line 495
  descriptor___1.modname = "gma500_gfx";
#line 495
  descriptor___1.function = "psb_gtt_init";
#line 495
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c";
#line 495
  descriptor___1.format = "Stolen memory base 0x%x, size %luK\n";
#line 495
  descriptor___1.lineno = 496U;
#line 495
  descriptor___1.flags = 0U;
#line 495
  tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 495
  if (tmp___1 != 0L) {
#line 495
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)dev->dev, "Stolen memory base 0x%x, size %luK\n",
                      dev_priv->stolen_base, vram_stolen_size / 1024UL);
  } else {

  }
#line 498
  if ((resume != 0 && pg->gtt_pages != gtt_pages) && pg->stolen_size != stolen_size) {
#line 500
    dev_err((struct device  const  *)dev->dev, "GTT resume error.\n");
#line 501
    ret = -22;
#line 502
    goto out_err;
  } else {

  }
#line 505
  pg->gtt_pages = gtt_pages;
#line 506
  pg->stolen_size = stolen_size;
#line 507
  dev_priv->vram_stolen_size = vram_stolen_size;
#line 512
  if (resume == 0) {
#line 513
    tmp___2 = ioremap_nocache((resource_size_t )pg->gtt_phys_start, (unsigned long )(gtt_pages << 12));
#line 513
    dev_priv->gtt_map = (u32 *)tmp___2;
  } else {

  }
#line 515
  if ((unsigned long )dev_priv->gtt_map == (unsigned long )((u32 *)0U)) {
#line 516
    dev_err((struct device  const  *)dev->dev, "Failure to map gtt.\n");
#line 517
    ret = -12;
#line 518
    goto out_err;
  } else {

  }
#line 521
  if (resume == 0) {
#line 522
    tmp___3 = ioremap_wc((resource_size_t )dev_priv->stolen_base, stolen_size);
#line 522
    dev_priv->vram_addr = (u8 *)tmp___3;
  } else {

  }
#line 525
  if ((unsigned long )dev_priv->vram_addr == (unsigned long )((u8 *)0U)) {
#line 526
    dev_err((struct device  const  *)dev->dev, "Failure to map stolen base.\n");
#line 527
    ret = -12;
#line 528
    goto out_err;
  } else {

  }
#line 535
  pfn_base = dev_priv->stolen_base >> 12;
#line 536
  num_pages = (unsigned int )(vram_stolen_size >> 12);
#line 537
  descriptor___2.modname = "gma500_gfx";
#line 537
  descriptor___2.function = "psb_gtt_init";
#line 537
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c";
#line 537
  descriptor___2.format = "Set up %d stolen pages starting at 0x%08x, GTT offset %dK\n";
#line 537
  descriptor___2.lineno = 538U;
#line 537
  descriptor___2.flags = 0U;
#line 537
  tmp___4 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
#line 537
  if (tmp___4 != 0L) {
#line 537
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)dev->dev, "Set up %d stolen pages starting at 0x%08x, GTT offset %dK\n",
                      num_pages, pfn_base << 12, 0);
  } else {

  }
#line 539
  i = 0U;
#line 539
  goto ldv_43218;
  ldv_43217: 
#line 540
  pte = psb_gtt_mask_pte(pfn_base + i, 1);
#line 541
  iowrite32(pte, (void *)dev_priv->gtt_map + (unsigned long )i);
#line 539
  i = i + 1U;
  ldv_43218: ;
#line 539
  if (i < num_pages) {
#line 541
    goto ldv_43217;
  } else {

  }
#line 548
  pfn_base = (unsigned int )(((long )dev_priv->scratch_page + 24189255811072L) / 64L);
#line 549
  pte = psb_gtt_mask_pte(pfn_base, 1);
#line 550
  goto ldv_43221;
  ldv_43220: 
#line 551
  iowrite32(pte, (void *)dev_priv->gtt_map + (unsigned long )i);
#line 550
  i = i + 1U;
  ldv_43221: ;
#line 550
  if (i < gtt_pages) {
#line 552
    goto ldv_43220;
  } else {

  }
#line 553
  ioread32((void *)(dev_priv->gtt_map + ((unsigned long )i + 0xffffffffffffffffUL)));
#line 554
  return (0);
  out_err: 
#line 557
  psb_gtt_takedown(dev);
#line 558
  return (ret);
}
}
#line 561 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c"
int psb_gtt_restore(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct resource *r ;
  struct gtt_range *range ;
  unsigned int restored ;
  unsigned int total ;
  unsigned int size ;
  struct resource  const  *__mptr ;
  long tmp ;

  {
#line 563
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 564
  r = (dev_priv->gtt_mem)->child;
#line 566
  restored = 0U;
#line 566
  total = 0U;
#line 566
  size = 0U;
#line 569
  ldv_mutex_lock_228(& dev_priv->gtt_mutex);
#line 570
  psb_gtt_init(dev, 1);
#line 572
  goto ldv_43235;
  ldv_43234: 
#line 573
  __mptr = (struct resource  const  *)r;
#line 573
  range = (struct gtt_range *)__mptr;
#line 574
  if ((unsigned long )range->pages != (unsigned long )((struct page **)0)) {
#line 575
    psb_gtt_insert(dev, range, 1);
#line 576
    size = ((unsigned int )range->resource.end - (unsigned int )range->resource.start) + size;
#line 577
    restored = restored + 1U;
  } else {

  }
#line 579
  r = r->sibling;
#line 580
  total = total + 1U;
  ldv_43235: ;
#line 572
  if ((unsigned long )r != (unsigned long )((struct resource *)0)) {
#line 574
    goto ldv_43234;
  } else {

  }
#line 582
  ldv_mutex_unlock_229(& dev_priv->gtt_mutex);
#line 583
  tmp = ldv__builtin_expect((drm_debug & 2U) != 0U, 0L);
#line 583
  if (tmp != 0L) {
#line 583
    drm_ut_debug_printk("psb_gtt_restore", "Restored %u of %u gtt ranges (%u KB)",
                        restored, total, size / 1024U);
  } else {

  }
#line 586
  return (0);
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
__inline static long PTR_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
#line 413
  tmp = ldv_ptr_err(ptr);
#line 413
  return (tmp);
}
}
#line 416 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
__inline static bool IS_ERR(void const   *ptr ) 
{ 
  bool tmp ;

  {
#line 419
  tmp = ldv_is_err(ptr);
#line 419
  return (tmp);
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
bool ldv_queue_work_on_203(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 432
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 432
  ldv_func_res = tmp;
#line 434
  activate_work_2(ldv_func_arg3, 2);
#line 436
  return (ldv_func_res);
}
}
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
bool ldv_queue_delayed_work_on_204(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 443
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 443
  ldv_func_res = tmp;
#line 445
  activate_work_2(& ldv_func_arg3->work, 2);
#line 447
  return (ldv_func_res);
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
bool ldv_queue_work_on_205(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 454
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 454
  ldv_func_res = tmp;
#line 456
  activate_work_2(ldv_func_arg3, 2);
#line 458
  return (ldv_func_res);
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
void ldv_flush_workqueue_206(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 464
  flush_workqueue(ldv_func_arg1);
#line 466
  call_and_disable_all_2(2);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
bool ldv_queue_delayed_work_on_207(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 473
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 473
  ldv_func_res = tmp;
#line 475
  activate_work_2(& ldv_func_arg3->work, 2);
#line 477
  return (ldv_func_res);
}
}
#line 480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
void ldv_mutex_lock_208(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 483
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 485
  mutex_lock(ldv_func_arg1);
#line 486
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
void ldv_mutex_unlock_209(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 491
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 493
  mutex_unlock(ldv_func_arg1);
#line 494
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
void ldv_mutex_lock_210(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 499
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 501
  mutex_lock(ldv_func_arg1);
#line 502
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
int ldv_mutex_trylock_211(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 508
  tmp = mutex_trylock(ldv_func_arg1);
#line 508
  ldv_func_res = tmp;
#line 510
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 510
  return (tmp___0);
#line 512
  return (ldv_func_res);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
void ldv_mutex_unlock_212(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 518
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 520
  mutex_unlock(ldv_func_arg1);
#line 521
  return;
}
}
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
void ldv_mutex_unlock_213(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 526
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 528
  mutex_unlock(ldv_func_arg1);
#line 529
  return;
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
void ldv_mutex_lock_214(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 534
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 536
  mutex_lock(ldv_func_arg1);
#line 537
  return;
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
void ldv_mutex_lock_215(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 542
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 544
  mutex_lock(ldv_func_arg1);
#line 545
  return;
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
void ldv_mutex_unlock_216(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 550
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 552
  mutex_unlock(ldv_func_arg1);
#line 553
  return;
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
void ldv_mutex_unlock_217(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 558
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 560
  mutex_unlock(ldv_func_arg1);
#line 561
  return;
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
void ldv_mutex_lock_218(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 566
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 568
  mutex_lock(ldv_func_arg1);
#line 569
  return;
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
int ldv_mutex_lock_interruptible_219(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 575
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 575
  ldv_func_res = tmp;
#line 577
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 577
  return (tmp___0);
#line 579
  return (ldv_func_res);
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
int ldv_mutex_trylock_220(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 586
  tmp = mutex_trylock(ldv_func_arg1);
#line 586
  ldv_func_res = tmp;
#line 588
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 588
  return (tmp___0);
#line 590
  return (ldv_func_res);
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
void ldv_mutex_unlock_223(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 617
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 619
  mutex_unlock(ldv_func_arg1);
#line 620
  return;
}
}
#line 622 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
void ldv_mutex_lock_224(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 625
  ldv_mutex_lock_gtt_mutex_of_drm_psb_private(ldv_func_arg1);
#line 627
  mutex_lock(ldv_func_arg1);
#line 628
  return;
}
}
#line 630 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
void ldv_mutex_unlock_225(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 633
  ldv_mutex_unlock_gtt_mutex_of_drm_psb_private(ldv_func_arg1);
#line 635
  mutex_unlock(ldv_func_arg1);
#line 636
  return;
}
}
#line 638 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
void ldv_mutex_lock_226(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 641
  ldv_mutex_lock_gtt_mutex_of_drm_psb_private(ldv_func_arg1);
#line 643
  mutex_lock(ldv_func_arg1);
#line 644
  return;
}
}
#line 646 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
void ldv_mutex_unlock_227(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 649
  ldv_mutex_unlock_gtt_mutex_of_drm_psb_private(ldv_func_arg1);
#line 651
  mutex_unlock(ldv_func_arg1);
#line 652
  return;
}
}
#line 654 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
void ldv_mutex_lock_228(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 657
  ldv_mutex_lock_gtt_mutex_of_drm_psb_private(ldv_func_arg1);
#line 659
  mutex_lock(ldv_func_arg1);
#line 660
  return;
}
}
#line 662 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
void ldv_mutex_unlock_229(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 665
  ldv_mutex_unlock_gtt_mutex_of_drm_psb_private(ldv_func_arg1);
#line 667
  mutex_unlock(ldv_func_arg1);
#line 668
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 30 "./arch/x86/include/asm/string_64.h"
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 63
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 121 "include/linux/string.h"
extern void *kmemdup(void const   * , size_t  , gfp_t  ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_268(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_277(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_266(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_269(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_270(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_273(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_274(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_280(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
int ldv_mutex_lock_interruptible_276(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_265(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_267(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_271(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_272(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_275(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_260(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_262(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_261(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_264(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_263(struct workqueue_struct *ldv_func_arg1 ) ;
#line 525 "include/linux/slab.h"
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 527
  if (size != 0UL && 0xffffffffffffffffUL / size < n) {
#line 528
    return ((void *)0);
  } else {

  }
#line 529
  tmp = __kmalloc(n * size, flags);
#line 529
  return (tmp);
}
}
#line 538 "include/linux/slab.h"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 540
  tmp = kmalloc_array(n, size, flags | 32768U);
#line 540
  return (tmp);
}
}
#line 1018 "include/linux/pci.h"
extern void *pci_map_rom(struct pci_dev * , size_t * ) ;
#line 1019
extern void pci_unmap_rom(struct pci_dev * , void * ) ;
#line 190 "include/drm/drm_modes.h"
extern void drm_mode_debug_printmodeline(struct drm_display_mode  const  * ) ;
#line 213
extern void drm_mode_set_name(struct drm_display_mode * ) ;
#line 480 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/intel_bios.h"
int psb_intel_init_bios(struct drm_device *dev ) ;
#line 481
void psb_intel_destroy_bios(struct drm_device *dev ) ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.c"
static void *find_section(struct bdb_header *bdb , int section_id ) 
{ 
  u8 *base ;
  int index ;
  u16 total ;
  u16 current_size ;
  u8 current_id ;

  {
#line 34
  base = (u8 *)bdb;
#line 35
  index = 0;
#line 40
  index = (int )bdb->header_size + index;
#line 41
  total = bdb->bdb_size;
#line 44
  goto ldv_41904;
  ldv_41903: 
#line 45
  current_id = *(base + (unsigned long )index);
#line 46
  index = index + 1;
#line 47
  current_size = *((u16 *)base + (unsigned long )index);
#line 48
  index = index + 2;
#line 49
  if ((int )current_id == section_id) {
#line 50
    return ((void *)base + (unsigned long )index);
  } else {

  }
#line 51
  index = (int )current_size + index;
  ldv_41904: ;
#line 44
  if ((int )total > index) {
#line 46
    goto ldv_41903;
  } else {

  }

#line 54
  return ((void *)0);
}
}
#line 58 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.c"
static void parse_edp(struct drm_psb_private *dev_priv , struct bdb_header *bdb ) 
{ 
  struct bdb_edp *edp ;
  struct edp_power_seq *edp_pps ;
  struct edp_link_params *edp_link_params ;
  uint8_t panel_type ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 65
  tmp = find_section(bdb, 27);
#line 65
  edp = (struct bdb_edp *)tmp;
#line 67
  dev_priv->edp.bpp = 18;
#line 68
  if ((unsigned long )edp == (unsigned long )((struct bdb_edp *)0)) {
#line 69
    if ((int )dev_priv->edp.support) {
#line 70
      tmp___0 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 70
      if (tmp___0 != 0L) {
#line 70
        drm_ut_debug_printk("parse_edp", "No eDP BDB found but eDP panel supported, assume %dbpp panel color depth.\n",
                            dev_priv->edp.bpp);
      } else {

      }
    } else {

    }
#line 73
    return;
  } else {

  }
#line 76
  panel_type = dev_priv->panel_type;
#line 77
  switch ((edp->color_depth >> (int )panel_type * 2) & 3U) {
  case 0U: 
#line 79
  dev_priv->edp.bpp = 18;
#line 80
  goto ldv_41916;
  case 1U: 
#line 82
  dev_priv->edp.bpp = 24;
#line 83
  goto ldv_41916;
  case 2U: 
#line 85
  dev_priv->edp.bpp = 30;
#line 86
  goto ldv_41916;
  }
  ldv_41916: 
#line 90
  edp_pps = (struct edp_power_seq *)(& edp->power_seqs) + (unsigned long )panel_type;
#line 91
  edp_link_params = (struct edp_link_params *)(& edp->link_params) + (unsigned long )panel_type;
#line 93
  dev_priv->edp.pps = *edp_pps;
#line 95
  tmp___1 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 95
  if (tmp___1 != 0L) {
#line 95
    drm_ut_debug_printk("parse_edp", "EDP timing in vbt t1_t3 %d t8 %d t9 %d t10 %d t11_t12 %d\n",
                        (int )dev_priv->edp.pps.t1_t3, (int )dev_priv->edp.pps.t8,
                        (int )dev_priv->edp.pps.t9, (int )dev_priv->edp.pps.t10, (int )dev_priv->edp.pps.t11_t12);
  } else {

  }
#line 100
  dev_priv->edp.rate = (unsigned int )*((unsigned char *)edp_link_params + 0UL) != 0U ? 10 : 6;
#line 102
  switch ((int )edp_link_params->lanes) {
  case 0: 
#line 104
  dev_priv->edp.lanes = 1;
#line 105
  goto ldv_41920;
  case 1: 
#line 107
  dev_priv->edp.lanes = 2;
#line 108
  goto ldv_41920;
  case 3: ;
  default: 
#line 111
  dev_priv->edp.lanes = 4;
#line 112
  goto ldv_41920;
  }
  ldv_41920: 
#line 114
  tmp___2 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 114
  if (tmp___2 != 0L) {
#line 114
    drm_ut_debug_printk("parse_edp", "VBT reports EDP: Lane_count %d, Lane_rate %d, Bpp %d\n",
                        dev_priv->edp.lanes, dev_priv->edp.rate, dev_priv->edp.bpp);
  } else {

  }
#line 117
  switch ((int )edp_link_params->preemphasis) {
  case 0: 
#line 119
  dev_priv->edp.preemphasis = 0;
#line 120
  goto ldv_41925;
  case 1: 
#line 122
  dev_priv->edp.preemphasis = 8;
#line 123
  goto ldv_41925;
  case 2: 
#line 125
  dev_priv->edp.preemphasis = 16;
#line 126
  goto ldv_41925;
  case 3: 
#line 128
  dev_priv->edp.preemphasis = 24;
#line 129
  goto ldv_41925;
  }
  ldv_41925: ;
#line 131
  switch ((int )edp_link_params->vswing) {
  case 0: 
#line 133
  dev_priv->edp.vswing = 0;
#line 134
  goto ldv_41930;
  case 1: 
#line 136
  dev_priv->edp.vswing = 1;
#line 137
  goto ldv_41930;
  case 2: 
#line 139
  dev_priv->edp.vswing = 2;
#line 140
  goto ldv_41930;
  case 3: 
#line 142
  dev_priv->edp.vswing = 3;
#line 143
  goto ldv_41930;
  }
  ldv_41930: 
#line 145
  tmp___3 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 145
  if (tmp___3 != 0L) {
#line 145
    drm_ut_debug_printk("parse_edp", "VBT reports EDP: VSwing  %d, Preemph %d\n",
                        dev_priv->edp.vswing, dev_priv->edp.preemphasis);
  } else {

  }
#line 146
  return;
}
}
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.c"
static u16 get_blocksize(void *p ) 
{ 
  u16 *block_ptr ;
  u16 block_size ;

  {
#line 154
  block_ptr = (u16 *)p + 0xfffffffffffffffeUL;
#line 155
  block_size = *block_ptr;
#line 156
  return (block_size);
}
}
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.c"
static void fill_detail_timing_data(struct drm_display_mode *panel_fixed_mode , struct lvds_dvo_timing *dvo_timing ) 
{ 


  {
#line 162
  panel_fixed_mode->hdisplay = ((int )dvo_timing->hactive_hi << 8) | (int )dvo_timing->hactive_lo;
#line 164
  panel_fixed_mode->hsync_start = panel_fixed_mode->hdisplay + (((int )dvo_timing->hsync_off_hi << 8) | (int )dvo_timing->hsync_off_lo);
#line 166
  panel_fixed_mode->hsync_end = panel_fixed_mode->hsync_start + (int )dvo_timing->hsync_pulse_width;
#line 168
  panel_fixed_mode->htotal = panel_fixed_mode->hdisplay + (((int )dvo_timing->hblank_hi << 8) | (int )dvo_timing->hblank_lo);
#line 171
  panel_fixed_mode->vdisplay = ((int )dvo_timing->vactive_hi << 8) | (int )dvo_timing->vactive_lo;
#line 173
  panel_fixed_mode->vsync_start = panel_fixed_mode->vdisplay + (int )dvo_timing->vsync_off;
#line 175
  panel_fixed_mode->vsync_end = panel_fixed_mode->vsync_start + (int )dvo_timing->vsync_pulse_width;
#line 177
  panel_fixed_mode->vtotal = panel_fixed_mode->vdisplay + (((int )dvo_timing->vblank_hi << 8) | (int )dvo_timing->vblank_lo);
#line 179
  panel_fixed_mode->clock = (int )dvo_timing->clock * 10;
#line 180
  panel_fixed_mode->type = 8U;
#line 182
  if ((unsigned int )*((unsigned char *)dvo_timing + 17UL) != 0U) {
#line 183
    panel_fixed_mode->flags = panel_fixed_mode->flags | 1U;
  } else {
#line 185
    panel_fixed_mode->flags = panel_fixed_mode->flags | 2U;
  }
#line 187
  if ((unsigned int )*((unsigned char *)dvo_timing + 17UL) != 0U) {
#line 188
    panel_fixed_mode->flags = panel_fixed_mode->flags | 4U;
  } else {
#line 190
    panel_fixed_mode->flags = panel_fixed_mode->flags | 8U;
  }
#line 193
  if (panel_fixed_mode->hsync_end > panel_fixed_mode->htotal) {
#line 194
    panel_fixed_mode->htotal = panel_fixed_mode->hsync_end + 1;
  } else {

  }
#line 195
  if (panel_fixed_mode->vsync_end > panel_fixed_mode->vtotal) {
#line 196
    panel_fixed_mode->vtotal = panel_fixed_mode->vsync_end + 1;
  } else {

  }
#line 198
  drm_mode_set_name(panel_fixed_mode);
#line 199
  return;
}
}
#line 201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.c"
static void parse_backlight_data(struct drm_psb_private *dev_priv , struct bdb_header *bdb ) 
{ 
  struct bdb_lvds_backlight *vbt_lvds_bl ;
  struct bdb_lvds_backlight *lvds_bl ;
  u8 p_type ;
  void *bl_start ;
  struct bdb_lvds_options *lvds_opts ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 204
  vbt_lvds_bl = (struct bdb_lvds_backlight *)0;
#line 206
  p_type = 0U;
#line 207
  bl_start = (void *)0;
#line 208
  tmp = find_section(bdb, 40);
#line 208
  lvds_opts = (struct bdb_lvds_options *)tmp;
#line 211
  dev_priv->lvds_bl = (struct bdb_lvds_backlight *)0;
#line 213
  if ((unsigned long )lvds_opts != (unsigned long )((struct bdb_lvds_options *)0)) {
#line 214
    p_type = lvds_opts->panel_type;
  } else {
#line 216
    return;
  }
#line 218
  bl_start = find_section(bdb, 43);
#line 219
  vbt_lvds_bl = (struct bdb_lvds_backlight *)bl_start + ((unsigned long )p_type + 1UL);
#line 221
  tmp___0 = kmemdup((void const   *)vbt_lvds_bl, 6UL, 208U);
#line 221
  lvds_bl = (struct bdb_lvds_backlight *)tmp___0;
#line 222
  if ((unsigned long )lvds_bl == (unsigned long )((struct bdb_lvds_backlight *)0)) {
#line 223
    dev_err((struct device  const  *)(dev_priv->dev)->dev, "out of memory for backlight data\n");
#line 224
    return;
  } else {

  }
#line 226
  dev_priv->lvds_bl = lvds_bl;
#line 227
  return;
}
}
#line 230 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.c"
static void parse_lfp_panel_data(struct drm_psb_private *dev_priv , struct bdb_header *bdb ) 
{ 
  struct bdb_lvds_options *lvds_options ;
  struct bdb_lvds_lfp_data *lvds_lfp_data ;
  struct bdb_lvds_lfp_data_entry *entry ;
  struct lvds_dvo_timing *dvo_timing ;
  struct drm_display_mode *panel_fixed_mode ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  struct _ddebug descriptor ;
  long tmp___2 ;

  {
#line 240
  dev_priv->lvds_dither = 0U;
#line 241
  dev_priv->lvds_vbt = 0U;
#line 243
  tmp = find_section(bdb, 40);
#line 243
  lvds_options = (struct bdb_lvds_options *)tmp;
#line 244
  if ((unsigned long )lvds_options == (unsigned long )((struct bdb_lvds_options *)0)) {
#line 245
    return;
  } else {

  }
#line 247
  dev_priv->lvds_dither = lvds_options->pixel_dither;
#line 248
  dev_priv->panel_type = lvds_options->panel_type;
#line 250
  if ((unsigned int )lvds_options->panel_type == 255U) {
#line 251
    return;
  } else {

  }
#line 253
  tmp___0 = find_section(bdb, 42);
#line 253
  lvds_lfp_data = (struct bdb_lvds_lfp_data *)tmp___0;
#line 254
  if ((unsigned long )lvds_lfp_data == (unsigned long )((struct bdb_lvds_lfp_data *)0)) {
#line 255
    return;
  } else {

  }
#line 258
  entry = (struct bdb_lvds_lfp_data_entry *)(& lvds_lfp_data->data) + (unsigned long )lvds_options->panel_type;
#line 259
  dvo_timing = & entry->dvo_timing;
#line 261
  tmp___1 = kzalloc(208UL, 208U);
#line 261
  panel_fixed_mode = (struct drm_display_mode *)tmp___1;
#line 263
  if ((unsigned long )panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 264
    dev_err((struct device  const  *)(dev_priv->dev)->dev, "out of memory for fixed panel mode\n");
#line 265
    return;
  } else {

  }
#line 268
  dev_priv->lvds_vbt = 1U;
#line 269
  fill_detail_timing_data(panel_fixed_mode, dvo_timing);
#line 271
  if (panel_fixed_mode->htotal > 0 && panel_fixed_mode->vtotal > 0) {
#line 272
    dev_priv->lfp_lvds_vbt_mode = panel_fixed_mode;
#line 273
    drm_mode_debug_printmodeline((struct drm_display_mode  const  *)panel_fixed_mode);
  } else {
#line 275
    descriptor.modname = "gma500_gfx";
#line 275
    descriptor.function = "parse_lfp_panel_data";
#line 275
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.c";
#line 275
    descriptor.format = "ignoring invalid LVDS VBT\n";
#line 275
    descriptor.lineno = 275U;
#line 275
    descriptor.flags = 0U;
#line 275
    tmp___2 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 275
    if (tmp___2 != 0L) {
#line 275
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)(dev_priv->dev)->dev,
                        "ignoring invalid LVDS VBT\n");
    } else {

    }
#line 276
    dev_priv->lvds_vbt = 0U;
#line 277
    kfree((void const   *)panel_fixed_mode);
  }
#line 279
  return;
}
}
#line 283 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.c"
static void parse_sdvo_panel_data(struct drm_psb_private *dev_priv , struct bdb_header *bdb ) 
{ 
  struct bdb_sdvo_lvds_options *sdvo_lvds_options ;
  struct lvds_dvo_timing *dvo_timing ;
  struct drm_display_mode *panel_fixed_mode ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 290
  dev_priv->sdvo_lvds_vbt_mode = (struct drm_display_mode *)0;
#line 292
  tmp = find_section(bdb, 22);
#line 292
  sdvo_lvds_options = (struct bdb_sdvo_lvds_options *)tmp;
#line 293
  if ((unsigned long )sdvo_lvds_options == (unsigned long )((struct bdb_sdvo_lvds_options *)0)) {
#line 294
    return;
  } else {

  }
#line 296
  tmp___0 = find_section(bdb, 23);
#line 296
  dvo_timing = (struct lvds_dvo_timing *)tmp___0;
#line 297
  if ((unsigned long )dvo_timing == (unsigned long )((struct lvds_dvo_timing *)0)) {
#line 298
    return;
  } else {

  }
#line 300
  tmp___1 = kzalloc(208UL, 208U);
#line 300
  panel_fixed_mode = (struct drm_display_mode *)tmp___1;
#line 302
  if ((unsigned long )panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 303
    return;
  } else {

  }
#line 305
  fill_detail_timing_data(panel_fixed_mode, dvo_timing + (unsigned long )sdvo_lvds_options->panel_type);
#line 308
  dev_priv->sdvo_lvds_vbt_mode = panel_fixed_mode;
#line 310
  return;
}
}
#line 313 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.c"
static void parse_general_features(struct drm_psb_private *dev_priv , struct bdb_header *bdb ) 
{ 
  struct bdb_general_features *general ;
  void *tmp ;

  {
#line 319
  dev_priv->int_tv_support = 1U;
#line 320
  dev_priv->int_crt_support = 1U;
#line 322
  tmp = find_section(bdb, 1);
#line 322
  general = (struct bdb_general_features *)tmp;
#line 323
  if ((unsigned long )general != (unsigned long )((struct bdb_general_features *)0)) {
#line 324
    dev_priv->int_tv_support = general->int_tv_support;
#line 325
    dev_priv->int_crt_support = general->int_crt_support;
#line 326
    dev_priv->lvds_use_ssc = general->enable_ssc;
#line 328
    if ((unsigned int )*((unsigned char *)dev_priv + 864UL) != 0U) {
#line 329
      dev_priv->lvds_ssc_freq = (unsigned int )*((unsigned char *)general + 1UL) != 0U ? 100 : 96;
    } else {

    }
  } else {

  }
#line 332
  return;
}
}
#line 336 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.c"
static void parse_sdvo_device_mapping(struct drm_psb_private *dev_priv , struct bdb_header *bdb ) 
{ 
  struct sdvo_device_mapping *p_mapping ;
  struct bdb_general_definitions *p_defs ;
  struct child_device_config *p_child ;
  int i ;
  int child_device_num ;
  int count ;
  u16 block_size ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;

  {
#line 345
  tmp = find_section(bdb, 2);
#line 345
  p_defs = (struct bdb_general_definitions *)tmp;
#line 346
  if ((unsigned long )p_defs == (unsigned long )((struct bdb_general_definitions *)0)) {
#line 347
    tmp___0 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 347
    if (tmp___0 != 0L) {
#line 347
      drm_ut_debug_printk("parse_sdvo_device_mapping", "No general definition block is found, unable to construct sdvo mapping.\n");
    } else {

    }
#line 348
    return;
  } else {

  }
#line 355
  if ((unsigned int )p_defs->child_dev_size != 33U) {
#line 357
    tmp___1 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 357
    if (tmp___1 != 0L) {
#line 357
      drm_ut_debug_printk("parse_sdvo_device_mapping", "different child size is found. Invalid.\n");
    } else {

    }
#line 358
    return;
  } else {

  }
#line 361
  block_size = get_blocksize((void *)p_defs);
#line 363
  child_device_num = (int )(((unsigned long )block_size - 5UL) / 33UL);
#line 365
  count = 0;
#line 366
  i = 0;
#line 366
  goto ldv_41989;
  ldv_41988: 
#line 367
  p_child = (struct child_device_config *)(& p_defs->devices) + (unsigned long )i;
#line 368
  if ((unsigned int )p_child->device_type == 0U) {
#line 370
    goto ldv_41987;
  } else {

  }
#line 372
  if ((unsigned int )p_child->slave_addr != 112U && (unsigned int )p_child->slave_addr != 114U) {
#line 378
    goto ldv_41987;
  } else {

  }
#line 380
  if ((unsigned int )p_child->dvo_port != 1U && (unsigned int )p_child->dvo_port != 2U) {
#line 383
    tmp___2 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 383
    if (tmp___2 != 0L) {
#line 383
      drm_ut_debug_printk("parse_sdvo_device_mapping", "Incorrect SDVO port. Skip it\n");
    } else {

    }
#line 384
    goto ldv_41987;
  } else {

  }
#line 386
  tmp___3 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 386
  if (tmp___3 != 0L) {
#line 386
    drm_ut_debug_printk("parse_sdvo_device_mapping", "the SDVO device with slave addr %2x is found on %s port\n",
                        (int )p_child->slave_addr, (unsigned int )p_child->dvo_port == 1U ? (char *)"SDVOB" : (char *)"SDVOC");
  } else {

  }
#line 391
  p_mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings) + ((unsigned long )p_child->dvo_port + 0xffffffffffffffffUL);
#line 392
  if ((unsigned int )p_mapping->initialized == 0U) {
#line 393
    p_mapping->dvo_port = p_child->dvo_port;
#line 394
    p_mapping->slave_addr = p_child->slave_addr;
#line 395
    p_mapping->dvo_wiring = p_child->dvo_wiring;
#line 396
    p_mapping->ddc_pin = p_child->ddc_pin;
#line 397
    p_mapping->i2c_pin = p_child->i2c_pin;
#line 398
    p_mapping->initialized = 1U;
#line 399
    tmp___4 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 399
    if (tmp___4 != 0L) {
#line 399
      drm_ut_debug_printk("parse_sdvo_device_mapping", "SDVO device: dvo=%x, addr=%x, wiring=%d, ddc_pin=%d, i2c_pin=%d\n",
                          (int )p_mapping->dvo_port, (int )p_mapping->slave_addr,
                          (int )p_mapping->dvo_wiring, (int )p_mapping->ddc_pin, (int )p_mapping->i2c_pin);
    } else {

    }
  } else {
#line 406
    tmp___5 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 406
    if (tmp___5 != 0L) {
#line 406
      drm_ut_debug_printk("parse_sdvo_device_mapping", "Maybe one SDVO port is shared by two SDVO device.\n");
    } else {

    }
  }
#line 409
  if ((unsigned int )p_child->slave2_addr != 0U) {
#line 412
    tmp___6 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 412
    if (tmp___6 != 0L) {
#line 412
      drm_ut_debug_printk("parse_sdvo_device_mapping", "there exists the slave2_addr. Maybe this is a SDVO device with multiple inputs.\n");
    } else {

    }
  } else {

  }
#line 415
  count = count + 1;
  ldv_41987: 
#line 366
  i = i + 1;
  ldv_41989: ;
#line 366
  if (i < child_device_num) {
#line 368
    goto ldv_41988;
  } else {

  }

#line 418
  if (count == 0) {
#line 420
    tmp___7 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 420
    if (tmp___7 != 0L) {
#line 420
      drm_ut_debug_printk("parse_sdvo_device_mapping", "No SDVO device info is found in VBT\n");
    } else {

    }
  } else {

  }
#line 422
  return;
}
}
#line 427 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.c"
static void parse_driver_features(struct drm_psb_private *dev_priv , struct bdb_header *bdb ) 
{ 
  struct bdb_driver_features *driver___0 ;
  void *tmp ;

  {
#line 432
  tmp = find_section(bdb, 12);
#line 432
  driver___0 = (struct bdb_driver_features *)tmp;
#line 433
  if ((unsigned long )driver___0 == (unsigned long )((struct bdb_driver_features *)0)) {
#line 434
    return;
  } else {

  }
#line 436
  if ((unsigned int )*((unsigned char *)driver___0 + 8UL) == 24U) {
#line 437
    dev_priv->edp.support = 1;
  } else {

  }
#line 440
  if ((unsigned int )*((unsigned char *)driver___0 + 0UL) != 0U) {
#line 441
    dev_priv->dplla_96mhz = 1;
  } else {
#line 443
    dev_priv->dplla_96mhz = 0;
  }
#line 444
  return;
}
}
#line 447 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.c"
static void parse_device_mapping(struct drm_psb_private *dev_priv , struct bdb_header *bdb ) 
{ 
  struct bdb_general_definitions *p_defs ;
  struct child_device_config *p_child ;
  struct child_device_config *child_dev_ptr ;
  int i ;
  int child_device_num ;
  int count ;
  u16 block_size ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;

  {
#line 455
  tmp = find_section(bdb, 2);
#line 455
  p_defs = (struct bdb_general_definitions *)tmp;
#line 456
  if ((unsigned long )p_defs == (unsigned long )((struct bdb_general_definitions *)0)) {
#line 457
    tmp___0 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 457
    if (tmp___0 != 0L) {
#line 457
      drm_ut_debug_printk("parse_device_mapping", "No general definition block is found, no devices defined.\n");
    } else {

    }
#line 458
    return;
  } else {

  }
#line 465
  if ((unsigned int )p_defs->child_dev_size != 33U) {
#line 467
    tmp___1 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 467
    if (tmp___1 != 0L) {
#line 467
      drm_ut_debug_printk("parse_device_mapping", "different child size is found. Invalid.\n");
    } else {

    }
#line 468
    return;
  } else {

  }
#line 471
  block_size = get_blocksize((void *)p_defs);
#line 473
  child_device_num = (int )(((unsigned long )block_size - 5UL) / 33UL);
#line 475
  count = 0;
#line 477
  i = 0;
#line 477
  goto ldv_42010;
  ldv_42009: 
#line 478
  p_child = (struct child_device_config *)(& p_defs->devices) + (unsigned long )i;
#line 479
  if ((unsigned int )p_child->device_type == 0U) {
#line 481
    goto ldv_42008;
  } else {

  }
#line 483
  count = count + 1;
  ldv_42008: 
#line 477
  i = i + 1;
  ldv_42010: ;
#line 477
  if (i < child_device_num) {
#line 479
    goto ldv_42009;
  } else {

  }

#line 485
  if (count == 0) {
#line 486
    tmp___2 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 486
    if (tmp___2 != 0L) {
#line 486
      drm_ut_debug_printk("parse_device_mapping", "no child dev is parsed from VBT\n");
    } else {

    }
#line 487
    return;
  } else {

  }
#line 489
  tmp___3 = kcalloc((size_t )count, 33UL, 208U);
#line 489
  dev_priv->child_dev = (struct child_device_config *)tmp___3;
#line 490
  if ((unsigned long )dev_priv->child_dev == (unsigned long )((struct child_device_config *)0)) {
#line 491
    tmp___4 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 491
    if (tmp___4 != 0L) {
#line 491
      drm_ut_debug_printk("parse_device_mapping", "No memory space for child devices\n");
    } else {

    }
#line 492
    return;
  } else {

  }
#line 495
  dev_priv->child_dev_num = count;
#line 496
  count = 0;
#line 497
  i = 0;
#line 497
  goto ldv_42014;
  ldv_42013: 
#line 498
  p_child = (struct child_device_config *)(& p_defs->devices) + (unsigned long )i;
#line 499
  if ((unsigned int )p_child->device_type == 0U) {
#line 501
    goto ldv_42012;
  } else {

  }
#line 503
  child_dev_ptr = dev_priv->child_dev + (unsigned long )count;
#line 504
  count = count + 1;
#line 505
  memcpy((void *)child_dev_ptr, (void const   *)p_child, 33UL);
  ldv_42012: 
#line 497
  i = i + 1;
  ldv_42014: ;
#line 497
  if (i < child_device_num) {
#line 499
    goto ldv_42013;
  } else {

  }

#line 508
  return;
}
}
#line 526 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.c"
int psb_intel_init_bios(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct pci_dev *pdev ;
  struct vbt_header *vbt ;
  struct bdb_header *bdb ;
  u8 *bios ;
  size_t size ;
  int i ;
  struct vbt_header *vbt___0 ;
  long tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 528
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 529
  pdev = dev->pdev;
#line 530
  vbt = (struct vbt_header *)0;
#line 531
  bdb = (struct bdb_header *)0;
#line 532
  bios = (u8 *)0U;
#line 537
  dev_priv->panel_type = 255U;
#line 540
  if ((unsigned long )dev_priv->opregion.vbt != (unsigned long )((void *)0)) {
#line 541
    vbt___0 = (struct vbt_header *)dev_priv->opregion.vbt;
#line 542
    tmp___0 = memcmp((void const   *)(& vbt___0->signature), (void const   *)"$VBT",
                     4UL);
#line 542
    if (tmp___0 == 0) {
#line 543
      tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 543
      if (tmp != 0L) {
#line 543
        drm_ut_debug_printk("psb_intel_init_bios", "Using VBT from OpRegion: %20s\n",
                            (u8 *)(& vbt___0->signature));
      } else {

      }
#line 545
      bdb = (struct bdb_header *)vbt___0 + (unsigned long )vbt___0->bdb_offset;
    } else {
#line 547
      dev_priv->opregion.vbt = (void *)0;
    }
  } else {

  }
#line 550
  if ((unsigned long )bdb == (unsigned long )((struct bdb_header *)0)) {
#line 551
    tmp___1 = pci_map_rom(pdev, & size);
#line 551
    bios = (u8 *)tmp___1;
#line 552
    if ((unsigned long )bios == (unsigned long )((u8 *)0U)) {
#line 553
      return (-1);
    } else {

    }
#line 556
    i = 0;
#line 556
    goto ldv_42030;
    ldv_42029: 
#line 557
    tmp___2 = memcmp((void const   *)bios + (unsigned long )i, (void const   *)"$VBT",
                     4UL);
#line 557
    if (tmp___2 == 0) {
#line 558
      vbt = (struct vbt_header *)bios + (unsigned long )i;
#line 559
      goto ldv_42028;
    } else {

    }
#line 556
    i = i + 1;
    ldv_42030: ;
#line 556
    if ((size_t )(i + 4) < size) {
#line 558
      goto ldv_42029;
    } else {

    }
    ldv_42028: ;
#line 563
    if ((unsigned long )vbt == (unsigned long )((struct vbt_header *)0)) {
#line 564
      dev_err((struct device  const  *)dev->dev, "VBT signature missing\n");
#line 565
      pci_unmap_rom(pdev, (void *)bios);
#line 566
      return (-1);
    } else {

    }
#line 568
    bdb = (struct bdb_header *)(bios + ((unsigned long )i + (unsigned long )vbt->bdb_offset));
  } else {

  }
#line 572
  parse_general_features(dev_priv, bdb);
#line 573
  parse_driver_features(dev_priv, bdb);
#line 574
  parse_lfp_panel_data(dev_priv, bdb);
#line 575
  parse_sdvo_panel_data(dev_priv, bdb);
#line 576
  parse_sdvo_device_mapping(dev_priv, bdb);
#line 577
  parse_device_mapping(dev_priv, bdb);
#line 578
  parse_backlight_data(dev_priv, bdb);
#line 579
  parse_edp(dev_priv, bdb);
#line 581
  if ((unsigned long )bios != (unsigned long )((u8 *)0U)) {
#line 582
    pci_unmap_rom(pdev, (void *)bios);
  } else {

  }
#line 584
  return (0);
}
}
#line 590 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.c"
void psb_intel_destroy_bios(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 592
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 594
  kfree((void const   *)dev_priv->sdvo_lvds_vbt_mode);
#line 595
  kfree((void const   *)dev_priv->lfp_lvds_vbt_mode);
#line 596
  kfree((void const   *)dev_priv->lvds_bl);
#line 597
  return;
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
bool ldv_queue_work_on_260(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 432
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 432
  ldv_func_res = tmp;
#line 434
  activate_work_2(ldv_func_arg3, 2);
#line 436
  return (ldv_func_res);
}
}
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
bool ldv_queue_delayed_work_on_261(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 443
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 443
  ldv_func_res = tmp;
#line 445
  activate_work_2(& ldv_func_arg3->work, 2);
#line 447
  return (ldv_func_res);
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
bool ldv_queue_work_on_262(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 454
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 454
  ldv_func_res = tmp;
#line 456
  activate_work_2(ldv_func_arg3, 2);
#line 458
  return (ldv_func_res);
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
void ldv_flush_workqueue_263(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 464
  flush_workqueue(ldv_func_arg1);
#line 466
  call_and_disable_all_2(2);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
bool ldv_queue_delayed_work_on_264(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 473
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 473
  ldv_func_res = tmp;
#line 475
  activate_work_2(& ldv_func_arg3->work, 2);
#line 477
  return (ldv_func_res);
}
}
#line 480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
void ldv_mutex_lock_265(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 483
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 485
  mutex_lock(ldv_func_arg1);
#line 486
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
void ldv_mutex_unlock_266(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 491
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 493
  mutex_unlock(ldv_func_arg1);
#line 494
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
void ldv_mutex_lock_267(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 499
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 501
  mutex_lock(ldv_func_arg1);
#line 502
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
int ldv_mutex_trylock_268(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 508
  tmp = mutex_trylock(ldv_func_arg1);
#line 508
  ldv_func_res = tmp;
#line 510
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 510
  return (tmp___0);
#line 512
  return (ldv_func_res);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
void ldv_mutex_unlock_269(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 518
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 520
  mutex_unlock(ldv_func_arg1);
#line 521
  return;
}
}
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
void ldv_mutex_unlock_270(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 526
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 528
  mutex_unlock(ldv_func_arg1);
#line 529
  return;
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
void ldv_mutex_lock_271(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 534
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 536
  mutex_lock(ldv_func_arg1);
#line 537
  return;
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
void ldv_mutex_lock_272(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 542
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 544
  mutex_lock(ldv_func_arg1);
#line 545
  return;
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
void ldv_mutex_unlock_273(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 550
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 552
  mutex_unlock(ldv_func_arg1);
#line 553
  return;
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
void ldv_mutex_unlock_274(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 558
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 560
  mutex_unlock(ldv_func_arg1);
#line 561
  return;
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
void ldv_mutex_lock_275(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 566
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 568
  mutex_lock(ldv_func_arg1);
#line 569
  return;
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
int ldv_mutex_lock_interruptible_276(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 575
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 575
  ldv_func_res = tmp;
#line 577
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 577
  return (tmp___0);
#line 579
  return (ldv_func_res);
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
int ldv_mutex_trylock_277(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 586
  tmp = mutex_trylock(ldv_func_arg1);
#line 586
  ldv_func_res = tmp;
#line 588
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 588
  return (tmp___0);
#line 590
  return (ldv_func_res);
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
void ldv_mutex_unlock_280(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 617
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 619
  mutex_unlock(ldv_func_arg1);
#line 620
  return;
}
}
#line 405 "include/linux/kernel.h"
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_313(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_322(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_311(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_314(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_315(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_318(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_319(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_325(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
int ldv_mutex_lock_interruptible_321(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_310(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_312(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_316(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_317(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_320(struct mutex *ldv_func_arg1 ) ;
#line 365 "include/linux/jiffies.h"
extern unsigned long __usecs_to_jiffies(unsigned int const    ) ;
#line 408 "include/linux/jiffies.h"
__inline static unsigned long usecs_to_jiffies(unsigned int const   u ) 
{ 
  unsigned long tmp___1 ;

  {
#line 415
  tmp___1 = __usecs_to_jiffies(u);
#line 415
  return (tmp___1);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_305(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_307(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_306(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_309(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_308(struct workqueue_struct *ldv_func_arg1 ) ;
#line 868 "include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
#line 870
  dev->driver_data = data;
#line 871
  return;
}
}
#line 528 "include/linux/i2c.h"
__inline static void i2c_set_adapdata(struct i2c_adapter *dev , void *data ) 
{ 


  {
#line 530
  dev_set_drvdata(& dev->dev, data);
#line 531
  return;
}
}
#line 580
extern void i2c_del_adapter(struct i2c_adapter * ) ;
#line 51 "include/linux/i2c-algo-bit.h"
extern int i2c_bit_add_bus(struct i2c_adapter * ) ;
#line 10 "include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 205 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
struct psb_intel_i2c_chan *psb_intel_i2c_create(struct drm_device *dev , u32 const   reg ,
                                                char const   *name ) ;
#line 207
void psb_intel_i2c_destroy(struct psb_intel_i2c_chan *chan ) ;
#line 823 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
__inline static uint32_t REGISTER_READ(struct drm_device *dev , uint32_t reg ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned int tmp ;

  {
#line 825
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 826
  tmp = ioread32((void *)dev_priv->vdc_reg + (unsigned long )reg);
#line 826
  return (tmp);
}
}
#line 854 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
__inline static void REGISTER_WRITE(struct drm_device *dev , uint32_t reg , uint32_t val ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 857
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 858
  iowrite32(val, (void *)dev_priv->vdc_reg + (unsigned long )reg);
#line 859
  return;
}
}
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.c"
static int get_clock(void *data ) 
{ 
  struct psb_intel_i2c_chan *chan ;
  struct drm_device *dev ;
  u32 val ;

  {
#line 35
  chan = (struct psb_intel_i2c_chan *)data;
#line 36
  dev = chan->drm_dev;
#line 39
  val = REGISTER_READ(dev, chan->reg);
#line 40
  return ((val & 16U) != 0U);
}
}
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.c"
static int get_data(void *data ) 
{ 
  struct psb_intel_i2c_chan *chan ;
  struct drm_device *dev ;
  u32 val ;

  {
#line 45
  chan = (struct psb_intel_i2c_chan *)data;
#line 46
  dev = chan->drm_dev;
#line 49
  val = REGISTER_READ(dev, chan->reg);
#line 50
  return ((val & 4096U) != 0U);
}
}
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.c"
static void set_clock(void *data , int state_high ) 
{ 
  struct psb_intel_i2c_chan *chan ;
  struct drm_device *dev ;
  u32 reserved ;
  u32 clock_bits ;
  uint32_t tmp ;

  {
#line 55
  chan = (struct psb_intel_i2c_chan *)data;
#line 56
  dev = chan->drm_dev;
#line 57
  reserved = 0U;
#line 60
  tmp = REGISTER_READ(dev, chan->reg);
#line 60
  reserved = tmp & 8224U;
#line 64
  if (state_high != 0) {
#line 65
    clock_bits = 1U;
  } else {
#line 67
    clock_bits = 7U;
  }
#line 69
  REGISTER_WRITE(dev, chan->reg, reserved | clock_bits);
#line 70
  __const_udelay(85900UL);
#line 72
  return;
}
}
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.c"
static void set_data(void *data , int state_high ) 
{ 
  struct psb_intel_i2c_chan *chan ;
  struct drm_device *dev ;
  u32 reserved ;
  u32 data_bits ;
  uint32_t tmp ;

  {
#line 75
  chan = (struct psb_intel_i2c_chan *)data;
#line 76
  dev = chan->drm_dev;
#line 77
  reserved = 0U;
#line 80
  tmp = REGISTER_READ(dev, chan->reg);
#line 80
  reserved = tmp & 8224U;
#line 84
  if (state_high != 0) {
#line 85
    data_bits = 256U;
  } else {
#line 87
    data_bits = 1792U;
  }
#line 91
  REGISTER_WRITE(dev, chan->reg, reserved | data_bits);
#line 92
  __const_udelay(85900UL);
#line 94
  return;
}
}
#line 116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.c"
struct psb_intel_i2c_chan *psb_intel_i2c_create(struct drm_device *dev , u32 const   reg ,
                                                char const   *name ) 
{ 
  struct psb_intel_i2c_chan *chan ;
  void *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 121
  tmp = kzalloc(2024UL, 208U);
#line 121
  chan = (struct psb_intel_i2c_chan *)tmp;
#line 122
  if ((unsigned long )chan == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 123
    goto out_free;
  } else {

  }
#line 125
  chan->drm_dev = dev;
#line 126
  chan->reg = reg;
#line 127
  snprintf((char *)(& chan->adapter.name), 20UL, "intel drm %s", name);
#line 128
  chan->adapter.owner = & __this_module;
#line 129
  chan->adapter.algo_data = (void *)(& chan->algo);
#line 130
  chan->adapter.dev.parent = & (dev->pdev)->dev;
#line 131
  chan->algo.setsda = & set_data;
#line 132
  chan->algo.setscl = & set_clock;
#line 133
  chan->algo.getsda = & get_data;
#line 134
  chan->algo.getscl = & get_clock;
#line 135
  chan->algo.udelay = 20;
#line 136
  tmp___0 = usecs_to_jiffies(2200U);
#line 136
  chan->algo.timeout = (int )tmp___0;
#line 137
  chan->algo.data = (void *)chan;
#line 139
  i2c_set_adapdata(& chan->adapter, (void *)chan);
#line 141
  tmp___1 = i2c_bit_add_bus(& chan->adapter);
#line 141
  if (tmp___1 != 0) {
#line 142
    goto out_free;
  } else {

  }
#line 145
  set_data((void *)chan, 1);
#line 146
  set_clock((void *)chan, 1);
#line 147
  __const_udelay(85900UL);
#line 149
  return (chan);
  out_free: 
#line 152
  kfree((void const   *)chan);
#line 153
  return ((struct psb_intel_i2c_chan *)0);
}
}
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.c"
void psb_intel_i2c_destroy(struct psb_intel_i2c_chan *chan ) 
{ 


  {
#line 164
  if ((unsigned long )chan == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 165
    return;
  } else {

  }
#line 167
  i2c_del_adapter(& chan->adapter);
#line 168
  kfree((void const   *)chan);
#line 169
  return;
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
bool ldv_queue_work_on_305(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 432
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 432
  ldv_func_res = tmp;
#line 434
  activate_work_2(ldv_func_arg3, 2);
#line 436
  return (ldv_func_res);
}
}
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
bool ldv_queue_delayed_work_on_306(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 443
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 443
  ldv_func_res = tmp;
#line 445
  activate_work_2(& ldv_func_arg3->work, 2);
#line 447
  return (ldv_func_res);
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
bool ldv_queue_work_on_307(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 454
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 454
  ldv_func_res = tmp;
#line 456
  activate_work_2(ldv_func_arg3, 2);
#line 458
  return (ldv_func_res);
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
void ldv_flush_workqueue_308(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 464
  flush_workqueue(ldv_func_arg1);
#line 466
  call_and_disable_all_2(2);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
bool ldv_queue_delayed_work_on_309(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 473
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 473
  ldv_func_res = tmp;
#line 475
  activate_work_2(& ldv_func_arg3->work, 2);
#line 477
  return (ldv_func_res);
}
}
#line 480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
void ldv_mutex_lock_310(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 483
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 485
  mutex_lock(ldv_func_arg1);
#line 486
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
void ldv_mutex_unlock_311(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 491
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 493
  mutex_unlock(ldv_func_arg1);
#line 494
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
void ldv_mutex_lock_312(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 499
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 501
  mutex_lock(ldv_func_arg1);
#line 502
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
int ldv_mutex_trylock_313(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 508
  tmp = mutex_trylock(ldv_func_arg1);
#line 508
  ldv_func_res = tmp;
#line 510
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 510
  return (tmp___0);
#line 512
  return (ldv_func_res);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
void ldv_mutex_unlock_314(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 518
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 520
  mutex_unlock(ldv_func_arg1);
#line 521
  return;
}
}
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
void ldv_mutex_unlock_315(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 526
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 528
  mutex_unlock(ldv_func_arg1);
#line 529
  return;
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
void ldv_mutex_lock_316(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 534
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 536
  mutex_lock(ldv_func_arg1);
#line 537
  return;
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
void ldv_mutex_lock_317(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 542
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 544
  mutex_lock(ldv_func_arg1);
#line 545
  return;
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
void ldv_mutex_unlock_318(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 550
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 552
  mutex_unlock(ldv_func_arg1);
#line 553
  return;
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
void ldv_mutex_unlock_319(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 558
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 560
  mutex_unlock(ldv_func_arg1);
#line 561
  return;
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
void ldv_mutex_lock_320(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 566
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 568
  mutex_lock(ldv_func_arg1);
#line 569
  return;
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
int ldv_mutex_lock_interruptible_321(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 575
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 575
  ldv_func_res = tmp;
#line 577
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 577
  return (tmp___0);
#line 579
  return (ldv_func_res);
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
int ldv_mutex_trylock_322(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 586
  tmp = mutex_trylock(ldv_func_arg1);
#line 586
  ldv_func_res = tmp;
#line 588
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 588
  return (tmp___0);
#line 590
  return (ldv_func_res);
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
void ldv_mutex_unlock_325(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 617
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 619
  mutex_unlock(ldv_func_arg1);
#line 620
  return;
}
}
#line 142 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 87 "./arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 295 "include/linux/percpu-defs.h"
extern void __bad_size_call_parameter(void) ;
#line 25 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 
  int __var ;

  {
#line 27
  __var = 0;
#line 27
  return ((int )*((int const volatile   *)(& v->counter)));
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_358(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_367(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_356(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_359(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_360(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_363(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_364(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_370(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
int ldv_mutex_lock_interruptible_366(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_355(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_357(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_361(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_362(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_365(struct mutex *ldv_func_arg1 ) ;
#line 8 "./arch/x86/include/asm/preempt.h"
extern int __preempt_count ;
#line 20 "./arch/x86/include/asm/preempt.h"
__inline static int preempt_count(void) 
{ 
  int pfo_ret__ ;

  {
#line 22
  switch (4UL) {
  case 1UL: 
#line 22
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6715;
  case 2UL: 
#line 22
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6715;
  case 4UL: 
#line 22
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6715;
  case 8UL: 
#line 22
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6715;
  default: 
#line 22
  __bad_percpu_size();
  }
  ldv_6715: ;
#line 22
  return (pfo_ret__ & 2147483647);
}
}
#line 292 "include/linux/jiffies.h"
extern unsigned long __msecs_to_jiffies(unsigned int const    ) ;
#line 354 "include/linux/jiffies.h"
__inline static unsigned long msecs_to_jiffies(unsigned int const   m ) 
{ 
  unsigned long tmp___0 ;

  {
#line 361
  tmp___0 = __msecs_to_jiffies(m);
#line 361
  return (tmp___0);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_350(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_352(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_351(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_354(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_353(struct workqueue_struct *ldv_func_arg1 ) ;
#line 38 "./arch/x86/include/asm/smp.h"
extern int cpu_number ;
#line 312 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
struct i2c_adapter *gmbus_algorithm_group0 ;
#line 318
int ldv_state_variable_53 ;
#line 395
void ldv_initialize_i2c_algorithm_53(void) ;
#line 579 "include/linux/i2c.h"
extern int i2c_add_adapter(struct i2c_adapter * ) ;
#line 318 "include/linux/kgdb.h"
extern atomic_t kgdb_active ;
#line 264 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
void gma_intel_i2c_reset(struct drm_device *dev ) ;
#line 265
int gma_intel_setup_gmbus(struct drm_device *dev ) ;
#line 266
void gma_intel_gmbus_set_speed(struct i2c_adapter *adapter , int speed ) ;
#line 267
void gma_intel_gmbus_force_bit(struct i2c_adapter *adapter , bool force_bit ) ;
#line 268
void gma_intel_teardown_gmbus(struct drm_device *dev ) ;
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.c"
__inline static struct intel_gmbus *to_intel_gmbus(struct i2c_adapter *i2c ) 
{ 
  struct i2c_adapter  const  *__mptr ;

  {
#line 64
  __mptr = (struct i2c_adapter  const  *)i2c;
#line 64
  return ((struct intel_gmbus *)__mptr);
}
}
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.c"
void gma_intel_i2c_reset(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 77
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 78
  iowrite32(0U, (void *)dev_priv->gmbus_reg + 20736U);
#line 79
  return;
}
}
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.c"
static void intel_i2c_quirk_set(struct drm_psb_private *dev_priv , bool enable ) 
{ 


  {
#line 83
  return;
}
}
#line 102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.c"
static u32 get_reserved(struct intel_gpio *gpio ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 reserved ;
  unsigned int tmp ;

  {
#line 104
  dev_priv = gpio->dev_priv;
#line 105
  reserved = 0U;
#line 108
  tmp = ioread32((void *)dev_priv->gmbus_reg + (unsigned long )gpio->reg);
#line 108
  reserved = tmp & 8224U;
#line 112
  return (reserved);
}
}
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.c"
static int get_clock___0(void *data ) 
{ 
  struct intel_gpio *gpio ;
  struct drm_psb_private *dev_priv ;
  u32 reserved ;
  u32 tmp ;
  unsigned int tmp___0 ;

  {
#line 117
  gpio = (struct intel_gpio *)data;
#line 118
  dev_priv = gpio->dev_priv;
#line 119
  tmp = get_reserved(gpio);
#line 119
  reserved = tmp;
#line 120
  iowrite32(reserved | 1U, (void *)dev_priv->gmbus_reg + (unsigned long )gpio->reg);
#line 121
  iowrite32(reserved, (void *)dev_priv->gmbus_reg + (unsigned long )gpio->reg);
#line 122
  tmp___0 = ioread32((void *)dev_priv->gmbus_reg + (unsigned long )gpio->reg);
#line 122
  return ((tmp___0 & 16U) != 0U);
}
}
#line 125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.c"
static int get_data___0(void *data ) 
{ 
  struct intel_gpio *gpio ;
  struct drm_psb_private *dev_priv ;
  u32 reserved ;
  u32 tmp ;
  unsigned int tmp___0 ;

  {
#line 127
  gpio = (struct intel_gpio *)data;
#line 128
  dev_priv = gpio->dev_priv;
#line 129
  tmp = get_reserved(gpio);
#line 129
  reserved = tmp;
#line 130
  iowrite32(reserved | 256U, (void *)dev_priv->gmbus_reg + (unsigned long )gpio->reg);
#line 131
  iowrite32(reserved, (void *)dev_priv->gmbus_reg + (unsigned long )gpio->reg);
#line 132
  tmp___0 = ioread32((void *)dev_priv->gmbus_reg + (unsigned long )gpio->reg);
#line 132
  return ((tmp___0 & 4096U) != 0U);
}
}
#line 135 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.c"
static void set_clock___0(void *data , int state_high ) 
{ 
  struct intel_gpio *gpio ;
  struct drm_psb_private *dev_priv ;
  u32 reserved ;
  u32 tmp ;
  u32 clock_bits ;

  {
#line 137
  gpio = (struct intel_gpio *)data;
#line 138
  dev_priv = gpio->dev_priv;
#line 139
  tmp = get_reserved(gpio);
#line 139
  reserved = tmp;
#line 142
  if (state_high != 0) {
#line 143
    clock_bits = 1U;
  } else {
#line 145
    clock_bits = 7U;
  }
#line 148
  iowrite32(reserved | clock_bits, (void *)dev_priv->gmbus_reg + (unsigned long )gpio->reg);
#line 149
  ioread32((void *)dev_priv->gmbus_reg + (unsigned long )gpio->reg);
#line 150
  return;
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.c"
static void set_data___0(void *data , int state_high ) 
{ 
  struct intel_gpio *gpio ;
  struct drm_psb_private *dev_priv ;
  u32 reserved ;
  u32 tmp ;
  u32 data_bits ;

  {
#line 154
  gpio = (struct intel_gpio *)data;
#line 155
  dev_priv = gpio->dev_priv;
#line 156
  tmp = get_reserved(gpio);
#line 156
  reserved = tmp;
#line 159
  if (state_high != 0) {
#line 160
    data_bits = 256U;
  } else {
#line 162
    data_bits = 1792U;
  }
#line 165
  iowrite32(reserved | data_bits, (void *)dev_priv->gmbus_reg + (unsigned long )gpio->reg);
#line 166
  ioread32((void *)dev_priv->gmbus_reg + (unsigned long )gpio->reg);
#line 167
  return;
}
}
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.c"
static struct i2c_adapter *intel_gpio_create(struct drm_psb_private *dev_priv , u32 pin ) 
{ 
  int map_pin_to_reg[8U] ;
  struct intel_gpio *gpio ;
  void *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 172
  map_pin_to_reg[0] = 0;
#line 172
  map_pin_to_reg[1] = 20500;
#line 172
  map_pin_to_reg[2] = 20496;
#line 172
  map_pin_to_reg[3] = 20504;
#line 172
  map_pin_to_reg[4] = 20508;
#line 172
  map_pin_to_reg[5] = 20512;
#line 172
  map_pin_to_reg[6] = 0;
#line 172
  map_pin_to_reg[7] = 20516;
#line 184
  if (pin > 7U || map_pin_to_reg[pin] == 0) {
#line 185
    return ((struct i2c_adapter *)0);
  } else {

  }
#line 187
  tmp = kzalloc(2016UL, 208U);
#line 187
  gpio = (struct intel_gpio *)tmp;
#line 188
  if ((unsigned long )gpio == (unsigned long )((struct intel_gpio *)0)) {
#line 189
    return ((struct i2c_adapter *)0);
  } else {

  }
#line 191
  gpio->reg = (u32 )map_pin_to_reg[pin];
#line 192
  gpio->dev_priv = dev_priv;
#line 194
  snprintf((char *)(& gpio->adapter.name), 48UL, "gma500 GPIO%c", (int )*("?BACDE?F" + pin));
#line 196
  gpio->adapter.owner = & __this_module;
#line 197
  gpio->adapter.algo_data = (void *)(& gpio->algo);
#line 198
  gpio->adapter.dev.parent = & ((dev_priv->dev)->pdev)->dev;
#line 199
  gpio->algo.setsda = & set_data___0;
#line 200
  gpio->algo.setscl = & set_clock___0;
#line 201
  gpio->algo.getsda = & get_data___0;
#line 202
  gpio->algo.getscl = & get_clock___0;
#line 203
  gpio->algo.udelay = 20;
#line 204
  tmp___0 = usecs_to_jiffies(2200U);
#line 204
  gpio->algo.timeout = (int )tmp___0;
#line 205
  gpio->algo.data = (void *)gpio;
#line 207
  tmp___1 = i2c_bit_add_bus(& gpio->adapter);
#line 207
  if (tmp___1 != 0) {
#line 208
    goto out_free;
  } else {

  }
#line 210
  return (& gpio->adapter);
  out_free: 
#line 213
  kfree((void const   *)gpio);
#line 214
  return ((struct i2c_adapter *)0);
}
}
#line 218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.c"
static int intel_i2c_quirk_xfer(struct drm_psb_private *dev_priv , struct i2c_adapter *adapter ,
                                struct i2c_msg *msgs , int num ) 
{ 
  struct intel_gpio *gpio ;
  struct i2c_adapter  const  *__mptr ;
  int ret ;

  {
#line 223
  __mptr = (struct i2c_adapter  const  *)adapter;
#line 223
  gpio = (struct intel_gpio *)__mptr;
#line 228
  gma_intel_i2c_reset(dev_priv->dev);
#line 230
  intel_i2c_quirk_set(dev_priv, 1);
#line 231
  set_data___0((void *)gpio, 1);
#line 232
  set_clock___0((void *)gpio, 1);
#line 233
  __const_udelay(85900UL);
#line 235
  ret = (*((adapter->algo)->master_xfer))(adapter, msgs, num);
#line 237
  set_data___0((void *)gpio, 1);
#line 238
  set_clock___0((void *)gpio, 1);
#line 239
  intel_i2c_quirk_set(dev_priv, 0);
#line 241
  return (ret);
}
}
#line 245 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.c"
static int gmbus_xfer(struct i2c_adapter *adapter , struct i2c_msg *msgs , int num ) 
{ 
  struct intel_gmbus *bus ;
  struct i2c_adapter  const  *__mptr ;
  struct drm_psb_private *dev_priv ;
  int i ;
  int reg_offset ;
  int tmp ;
  u16 len ;
  u8 *buf ;
  u32 val ;
  u32 loop ;
  unsigned long timeout__ ;
  unsigned long tmp___0 ;
  int ret__ ;
  int tmp___1 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  u8 *tmp___5 ;
  u32 val___0 ;
  u32 loop___0 ;
  u8 *tmp___6 ;
  unsigned long timeout_____0 ;
  unsigned long tmp___7 ;
  int ret_____0 ;
  int tmp___8 ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;
  int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  u8 *tmp___12 ;
  unsigned long timeout_____1 ;
  unsigned long tmp___13 ;
  int ret_____1 ;
  int tmp___14 ;
  int pscr_ret_____1 ;
  void const   *__vpp_verify___1 ;
  int pfo_ret_____7 ;
  int pfo_ret_____8 ;
  int pfo_ret_____9 ;
  int pfo_ret_____10 ;
  int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  int tmp___18 ;

  {
#line 249
  __mptr = (struct i2c_adapter  const  *)adapter;
#line 249
  bus = (struct intel_gmbus *)__mptr;
#line 252
  dev_priv = (struct drm_psb_private *)adapter->algo_data;
#line 255
  if ((unsigned long )bus->force_bit != (unsigned long )((struct i2c_adapter *)0)) {
#line 256
    tmp = intel_i2c_quirk_xfer(dev_priv, bus->force_bit, msgs, num);
#line 256
    return (tmp);
  } else {

  }
#line 259
  reg_offset = 0;
#line 261
  iowrite32(bus->reg0, (void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20736));
#line 263
  i = 0;
#line 263
  goto ldv_42154;
  ldv_42153: 
#line 264
  len = (msgs + (unsigned long )i)->len;
#line 265
  buf = (msgs + (unsigned long )i)->buf;
#line 267
  if ((int )(msgs + (unsigned long )i)->flags & 1) {
#line 268
    iowrite32((u32 )((((i + 1 == num ? 167772160 : 33554432) | ((int )len << 16)) | ((int )(msgs + (unsigned long )i)->addr << 1)) | 1073741825),
              (void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20740));
#line 274
    ioread32((void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20744));
    ldv_42036: 
#line 276
    loop = 0U;
#line 278
    tmp___0 = msecs_to_jiffies(50U);
#line 278
    timeout__ = tmp___0 + (unsigned long )jiffies;
#line 278
    ret__ = 0;
#line 278
    goto ldv_42030;
    ldv_42029: ;
#line 278
    if ((long )(timeout__ - (unsigned long )jiffies) < 0L) {
#line 278
      ret__ = -110;
#line 278
      goto ldv_41987;
    } else {

    }
#line 278
    tmp___1 = preempt_count();
#line 279
    if (tmp___1 == 0) {
#line 278
      __vpp_verify = (void const   *)0;
#line 278
      switch (4UL) {
      case 1UL: ;
#line 279
      switch (4UL) {
      case 1UL: 
#line 279
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 279
      goto ldv_41993;
      case 2UL: 
#line 279
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 279
      goto ldv_41993;
      case 4UL: 
#line 279
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 279
      goto ldv_41993;
      case 8UL: 
#line 279
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 279
      goto ldv_41993;
      default: 
#line 279
      __bad_percpu_size();
      }
      ldv_41993: 
#line 279
      pscr_ret__ = pfo_ret__;
#line 279
      goto ldv_41999;
      case 2UL: ;
#line 279
      switch (4UL) {
      case 1UL: 
#line 279
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 279
      goto ldv_42003;
      case 2UL: 
#line 279
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 279
      goto ldv_42003;
      case 4UL: 
#line 279
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 279
      goto ldv_42003;
      case 8UL: 
#line 279
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 279
      goto ldv_42003;
      default: 
#line 279
      __bad_percpu_size();
      }
      ldv_42003: 
#line 279
      pscr_ret__ = pfo_ret_____0;
#line 279
      goto ldv_41999;
      case 4UL: ;
#line 279
      switch (4UL) {
      case 1UL: 
#line 279
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 279
      goto ldv_42012;
      case 2UL: 
#line 279
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 279
      goto ldv_42012;
      case 4UL: 
#line 279
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 279
      goto ldv_42012;
      case 8UL: 
#line 279
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 279
      goto ldv_42012;
      default: 
#line 279
      __bad_percpu_size();
      }
      ldv_42012: 
#line 279
      pscr_ret__ = pfo_ret_____1;
#line 279
      goto ldv_41999;
      case 8UL: ;
#line 279
      switch (4UL) {
      case 1UL: 
#line 279
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 279
      goto ldv_42021;
      case 2UL: 
#line 279
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 279
      goto ldv_42021;
      case 4UL: 
#line 279
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 279
      goto ldv_42021;
      case 8UL: 
#line 279
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 279
      goto ldv_42021;
      default: 
#line 279
      __bad_percpu_size();
      }
      ldv_42021: 
#line 279
      pscr_ret__ = pfo_ret_____2;
#line 279
      goto ldv_41999;
      default: 
#line 279
      __bad_size_call_parameter();
#line 279
      goto ldv_41999;
      }
      ldv_41999: 
#line 279
      tmp___2 = atomic_read((atomic_t const   *)(& kgdb_active));
#line 279
      if (pscr_ret__ != tmp___2) {
#line 279
        msleep(1U);
      } else {

      }
    } else {

    }
    ldv_42030: 
#line 278
    tmp___3 = ioread32((void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20744));
#line 278
    if ((tmp___3 & 3072U) == 0U) {
#line 280
      goto ldv_42029;
    } else {

    }
    ldv_41987: ;
#line 279
    if (ret__ != 0) {
#line 280
      goto timeout;
    } else {

    }
#line 281
    tmp___4 = ioread32((void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20744));
#line 281
    if ((tmp___4 & 1024U) != 0U) {
#line 282
      goto clear_err;
    } else {

    }
#line 284
    val = ioread32((void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20748));
    ldv_42034: 
#line 286
    tmp___5 = buf;
#line 286
    buf = buf + 1;
#line 286
    *tmp___5 = (u8 )val;
#line 287
    val = val >> 8;
#line 288
    len = (u16 )((int )len - 1);
#line 288
    if ((unsigned int )len != 0U) {
#line 288
      loop = loop + 1U;
#line 288
      if (loop <= 3U) {
#line 290
        goto ldv_42034;
      } else {
#line 293
        goto ldv_42035;
      }
    } else {

    }
    ldv_42035: ;
#line 289
    if ((unsigned int )len != 0U) {
#line 291
      goto ldv_42036;
    } else {

    }

  } else {
#line 293
    loop___0 = 0U;
#line 293
    val___0 = loop___0;
    ldv_42040: 
#line 295
    tmp___6 = buf;
#line 295
    buf = buf + 1;
#line 295
    val___0 = (u32 )((int )*tmp___6 << (int )(loop___0 * 8U)) | val___0;
#line 296
    len = (u16 )((int )len - 1);
#line 296
    if ((unsigned int )len != 0U) {
#line 296
      loop___0 = loop___0 + 1U;
#line 296
      if (loop___0 <= 3U) {
#line 298
        goto ldv_42040;
      } else {
#line 301
        goto ldv_42041;
      }
    } else {

    }
    ldv_42041: 
#line 298
    iowrite32(val___0, (void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20748));
#line 299
    iowrite32((u32 )((((i + 1 == num ? 134217728 : 33554432) | ((int )(msgs + (unsigned long )i)->len << 16)) | ((int )(msgs + (unsigned long )i)->addr << 1)) | 1073741824),
              (void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20740));
#line 304
    ioread32((void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20744));
#line 306
    goto ldv_42098;
    ldv_42097: 
#line 307
    tmp___7 = msecs_to_jiffies(50U);
#line 307
    timeout_____0 = tmp___7 + (unsigned long )jiffies;
#line 307
    ret_____0 = 0;
#line 307
    goto ldv_42093;
    ldv_42092: ;
#line 307
    if ((long )(timeout_____0 - (unsigned long )jiffies) < 0L) {
#line 307
      ret_____0 = -110;
#line 307
      goto ldv_42050;
    } else {

    }
#line 307
    tmp___8 = preempt_count();
#line 308
    if (tmp___8 == 0) {
#line 307
      __vpp_verify___0 = (void const   *)0;
#line 307
      switch (4UL) {
      case 1UL: ;
#line 308
      switch (4UL) {
      case 1UL: 
#line 308
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 308
      goto ldv_42056;
      case 2UL: 
#line 308
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 308
      goto ldv_42056;
      case 4UL: 
#line 308
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 308
      goto ldv_42056;
      case 8UL: 
#line 308
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 308
      goto ldv_42056;
      default: 
#line 308
      __bad_percpu_size();
      }
      ldv_42056: 
#line 308
      pscr_ret_____0 = pfo_ret_____3;
#line 308
      goto ldv_42062;
      case 2UL: ;
#line 308
      switch (4UL) {
      case 1UL: 
#line 308
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 308
      goto ldv_42066;
      case 2UL: 
#line 308
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 308
      goto ldv_42066;
      case 4UL: 
#line 308
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 308
      goto ldv_42066;
      case 8UL: 
#line 308
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 308
      goto ldv_42066;
      default: 
#line 308
      __bad_percpu_size();
      }
      ldv_42066: 
#line 308
      pscr_ret_____0 = pfo_ret_____4;
#line 308
      goto ldv_42062;
      case 4UL: ;
#line 308
      switch (4UL) {
      case 1UL: 
#line 308
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 308
      goto ldv_42075;
      case 2UL: 
#line 308
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 308
      goto ldv_42075;
      case 4UL: 
#line 308
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 308
      goto ldv_42075;
      case 8UL: 
#line 308
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 308
      goto ldv_42075;
      default: 
#line 308
      __bad_percpu_size();
      }
      ldv_42075: 
#line 308
      pscr_ret_____0 = pfo_ret_____5;
#line 308
      goto ldv_42062;
      case 8UL: ;
#line 308
      switch (4UL) {
      case 1UL: 
#line 308
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 308
      goto ldv_42084;
      case 2UL: 
#line 308
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 308
      goto ldv_42084;
      case 4UL: 
#line 308
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 308
      goto ldv_42084;
      case 8UL: 
#line 308
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 308
      goto ldv_42084;
      default: 
#line 308
      __bad_percpu_size();
      }
      ldv_42084: 
#line 308
      pscr_ret_____0 = pfo_ret_____6;
#line 308
      goto ldv_42062;
      default: 
#line 308
      __bad_size_call_parameter();
#line 308
      goto ldv_42062;
      }
      ldv_42062: 
#line 308
      tmp___9 = atomic_read((atomic_t const   *)(& kgdb_active));
#line 308
      if (pscr_ret_____0 != tmp___9) {
#line 308
        msleep(1U);
      } else {

      }
    } else {

    }
    ldv_42093: 
#line 307
    tmp___10 = ioread32((void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20744));
#line 307
    if ((tmp___10 & 3072U) == 0U) {
#line 309
      goto ldv_42092;
    } else {

    }
    ldv_42050: ;
#line 308
    if (ret_____0 != 0) {
#line 309
      goto timeout;
    } else {

    }
#line 310
    tmp___11 = ioread32((void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20744));
#line 310
    if ((tmp___11 & 1024U) != 0U) {
#line 312
      goto clear_err;
    } else {

    }
#line 314
    loop___0 = 0U;
#line 314
    val___0 = loop___0;
    ldv_42095: 
#line 316
    tmp___12 = buf;
#line 316
    buf = buf + 1;
#line 316
    val___0 = (u32 )((int )*tmp___12 << (int )(loop___0 * 8U)) | val___0;
#line 317
    len = (u16 )((int )len - 1);
#line 317
    if ((unsigned int )len != 0U) {
#line 317
      loop___0 = loop___0 + 1U;
#line 317
      if (loop___0 <= 3U) {
#line 319
        goto ldv_42095;
      } else {
#line 322
        goto ldv_42096;
      }
    } else {

    }
    ldv_42096: 
#line 319
    iowrite32(val___0, (void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20748));
#line 320
    ioread32((void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20744));
    ldv_42098: ;
#line 306
    if ((unsigned int )len != 0U) {
#line 308
      goto ldv_42097;
    } else {

    }

  }
#line 324
  if (i + 1 < num) {
#line 324
    tmp___13 = msecs_to_jiffies(50U);
#line 324
    timeout_____1 = tmp___13 + (unsigned long )jiffies;
#line 324
    ret_____1 = 0;
#line 324
    goto ldv_42151;
    ldv_42150: ;
#line 324
    if ((long )(timeout_____1 - (unsigned long )jiffies) < 0L) {
#line 324
      ret_____1 = -110;
#line 324
      goto ldv_42108;
    } else {

    }
#line 324
    tmp___14 = preempt_count();
#line 324
    if (tmp___14 == 0) {
#line 324
      __vpp_verify___1 = (void const   *)0;
#line 324
      switch (4UL) {
      case 1UL: ;
#line 324
      switch (4UL) {
      case 1UL: 
#line 324
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____7): "m" (cpu_number));
#line 324
      goto ldv_42114;
      case 2UL: 
#line 324
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 324
      goto ldv_42114;
      case 4UL: 
#line 324
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 324
      goto ldv_42114;
      case 8UL: 
#line 324
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 324
      goto ldv_42114;
      default: 
#line 324
      __bad_percpu_size();
      }
      ldv_42114: 
#line 324
      pscr_ret_____1 = pfo_ret_____7;
#line 324
      goto ldv_42120;
      case 2UL: ;
#line 324
      switch (4UL) {
      case 1UL: 
#line 324
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____8): "m" (cpu_number));
#line 324
      goto ldv_42124;
      case 2UL: 
#line 324
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 324
      goto ldv_42124;
      case 4UL: 
#line 324
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 324
      goto ldv_42124;
      case 8UL: 
#line 324
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 324
      goto ldv_42124;
      default: 
#line 324
      __bad_percpu_size();
      }
      ldv_42124: 
#line 324
      pscr_ret_____1 = pfo_ret_____8;
#line 324
      goto ldv_42120;
      case 4UL: ;
#line 324
      switch (4UL) {
      case 1UL: 
#line 324
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____9): "m" (cpu_number));
#line 324
      goto ldv_42133;
      case 2UL: 
#line 324
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 324
      goto ldv_42133;
      case 4UL: 
#line 324
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 324
      goto ldv_42133;
      case 8UL: 
#line 324
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 324
      goto ldv_42133;
      default: 
#line 324
      __bad_percpu_size();
      }
      ldv_42133: 
#line 324
      pscr_ret_____1 = pfo_ret_____9;
#line 324
      goto ldv_42120;
      case 8UL: ;
#line 324
      switch (4UL) {
      case 1UL: 
#line 324
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____10): "m" (cpu_number));
#line 324
      goto ldv_42142;
      case 2UL: 
#line 324
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 324
      goto ldv_42142;
      case 4UL: 
#line 324
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 324
      goto ldv_42142;
      case 8UL: 
#line 324
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 324
      goto ldv_42142;
      default: 
#line 324
      __bad_percpu_size();
      }
      ldv_42142: 
#line 324
      pscr_ret_____1 = pfo_ret_____10;
#line 324
      goto ldv_42120;
      default: 
#line 324
      __bad_size_call_parameter();
#line 324
      goto ldv_42120;
      }
      ldv_42120: 
#line 324
      tmp___15 = atomic_read((atomic_t const   *)(& kgdb_active));
#line 324
      if (pscr_ret_____1 != tmp___15) {
#line 324
        msleep(1U);
      } else {

      }
    } else {

    }
    ldv_42151: 
#line 324
    tmp___16 = ioread32((void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20744));
#line 324
    if ((tmp___16 & 17408U) == 0U) {
#line 326
      goto ldv_42150;
    } else {

    }
    ldv_42108: ;
#line 324
    if (ret_____1 != 0) {
#line 325
      goto timeout;
    } else {

    }
  } else {

  }
#line 326
  tmp___17 = ioread32((void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20744));
#line 326
  if ((tmp___17 & 1024U) != 0U) {
#line 327
    goto clear_err;
  } else {

  }
#line 263
  i = i + 1;
  ldv_42154: ;
#line 263
  if (i < num) {
#line 265
    goto ldv_42153;
  } else {

  }

#line 330
  goto done;
  clear_err: 
#line 337
  iowrite32(2147483648U, (void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20740));
#line 338
  iowrite32(0U, (void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20740));
  done: 
#line 344
  iowrite32(0U, (void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20736));
#line 345
  return (i);
  timeout: 
#line 348
  printk("\016[drm] GMBUS timed out, falling back to bit banging on pin %d [%s]\n",
         bus->reg0 & 255U, (char *)(& bus->adapter.name));
#line 350
  iowrite32(0U, (void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20736));
#line 353
  bus->force_bit = intel_gpio_create(dev_priv, bus->reg0 & 255U);
#line 354
  if ((unsigned long )bus->force_bit == (unsigned long )((struct i2c_adapter *)0)) {
#line 355
    return (-12);
  } else {

  }
#line 357
  tmp___18 = intel_i2c_quirk_xfer(dev_priv, bus->force_bit, msgs, num);
#line 357
  return (tmp___18);
}
}
#line 360 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.c"
static u32 gmbus_func(struct i2c_adapter *adapter ) 
{ 
  struct intel_gmbus *bus ;
  struct i2c_adapter  const  *__mptr ;

  {
#line 362
  __mptr = (struct i2c_adapter  const  *)adapter;
#line 362
  bus = (struct intel_gmbus *)__mptr;
#line 366
  if ((unsigned long )bus->force_bit != (unsigned long )((struct i2c_adapter *)0)) {
#line 367
    (*(((bus->force_bit)->algo)->functionality))(bus->force_bit);
  } else {

  }
#line 369
  return (268402697U);
}
}
#line 375 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.c"
static struct i2c_algorithm  const  gmbus_algorithm  =    {& gmbus_xfer, 0, & gmbus_func, 0, 0};
#line 384 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.c"
int gma_intel_setup_gmbus(struct drm_device *dev ) 
{ 
  char const   *names[8U] ;
  struct drm_psb_private *dev_priv ;
  int ret ;
  int i ;
  void *tmp ;
  struct intel_gmbus *bus ;
  struct intel_gmbus *bus___0 ;

  {
#line 386
  names[0] = "disabled";
#line 386
  names[1] = "ssc";
#line 386
  names[2] = "vga";
#line 386
  names[3] = "panel";
#line 386
  names[4] = "dpc";
#line 386
  names[5] = "dpb";
#line 386
  names[6] = "reserved";
#line 386
  names[7] = "dpd";
#line 396
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 399
  tmp = kcalloc(8UL, 1952UL, 208U);
#line 399
  dev_priv->gmbus = (struct intel_gmbus *)tmp;
#line 401
  if ((unsigned long )dev_priv->gmbus == (unsigned long )((struct intel_gmbus *)0)) {
#line 402
    return (-12);
  } else {

  }
#line 404
  if (((int )(dev->pdev)->device & 65520) == 16640) {
#line 405
    dev_priv->gmbus_reg = dev_priv->aux_reg;
  } else {
#line 407
    dev_priv->gmbus_reg = dev_priv->vdc_reg;
  }
#line 409
  i = 0;
#line 409
  goto ldv_42174;
  ldv_42173: 
#line 410
  bus = dev_priv->gmbus + (unsigned long )i;
#line 412
  bus->adapter.owner = & __this_module;
#line 413
  bus->adapter.class = 8U;
#line 414
  snprintf((char *)(& bus->adapter.name), 48UL, "gma500 gmbus %s", names[i]);
#line 419
  bus->adapter.dev.parent = & (dev->pdev)->dev;
#line 420
  bus->adapter.algo_data = (void *)dev_priv;
#line 422
  bus->adapter.algo = & gmbus_algorithm;
#line 423
  ret = i2c_add_adapter(& bus->adapter);
#line 424
  if (ret != 0) {
#line 425
    goto err;
  } else {

  }
#line 428
  bus->reg0 = (u32 )i;
#line 431
  bus->force_bit = intel_gpio_create(dev_priv, (u32 )i);
#line 409
  i = i + 1;
  ldv_42174: ;
#line 409
  if (i <= 7) {
#line 411
    goto ldv_42173;
  } else {

  }
#line 434
  gma_intel_i2c_reset(dev_priv->dev);
#line 436
  return (0);
  err: ;
#line 439
  goto ldv_42178;
  ldv_42177: 
#line 440
  bus___0 = dev_priv->gmbus + (unsigned long )i;
#line 441
  i2c_del_adapter(& bus___0->adapter);
  ldv_42178: 
#line 439
  i = i - 1;
#line 439
  if (i != 0) {
#line 441
    goto ldv_42177;
  } else {

  }
#line 443
  kfree((void const   *)dev_priv->gmbus);
#line 444
  dev_priv->gmbus = (struct intel_gmbus *)0;
#line 445
  return (ret);
}
}
#line 448 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.c"
void gma_intel_gmbus_set_speed(struct i2c_adapter *adapter , int speed ) 
{ 
  struct intel_gmbus *bus ;
  struct intel_gmbus *tmp ;

  {
#line 450
  tmp = to_intel_gmbus(adapter);
#line 450
  bus = tmp;
#line 458
  bus->reg0 = (bus->reg0 & 4294966527U) | (u32 )(speed << 8);
#line 459
  return;
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.c"
void gma_intel_gmbus_force_bit(struct i2c_adapter *adapter , bool force_bit ) 
{ 
  struct intel_gmbus *bus ;
  struct intel_gmbus *tmp ;
  struct drm_psb_private *dev_priv ;

  {
#line 463
  tmp = to_intel_gmbus(adapter);
#line 463
  bus = tmp;
#line 465
  if ((int )force_bit) {
#line 466
    if ((unsigned long )bus->force_bit == (unsigned long )((struct i2c_adapter *)0)) {
#line 467
      dev_priv = (struct drm_psb_private *)adapter->algo_data;
#line 468
      bus->force_bit = intel_gpio_create(dev_priv, bus->reg0 & 255U);
    } else {

    }
  } else
#line 472
  if ((unsigned long )bus->force_bit != (unsigned long )((struct i2c_adapter *)0)) {
#line 473
    i2c_del_adapter(bus->force_bit);
#line 474
    kfree((void const   *)bus->force_bit);
#line 475
    bus->force_bit = (struct i2c_adapter *)0;
  } else {

  }
#line 477
  return;
}
}
#line 480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.c"
void gma_intel_teardown_gmbus(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  int i ;
  struct intel_gmbus *bus ;

  {
#line 482
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 485
  if ((unsigned long )dev_priv->gmbus == (unsigned long )((struct intel_gmbus *)0)) {
#line 486
    return;
  } else {

  }
#line 488
  i = 0;
#line 488
  goto ldv_42198;
  ldv_42197: 
#line 489
  bus = dev_priv->gmbus + (unsigned long )i;
#line 490
  if ((unsigned long )bus->force_bit != (unsigned long )((struct i2c_adapter *)0)) {
#line 491
    i2c_del_adapter(bus->force_bit);
#line 492
    kfree((void const   *)bus->force_bit);
  } else {

  }
#line 494
  i2c_del_adapter(& bus->adapter);
#line 488
  i = i + 1;
  ldv_42198: ;
#line 488
  if (i <= 7) {
#line 490
    goto ldv_42197;
  } else {

  }
#line 497
  dev_priv->gmbus_reg = (uint8_t *)0U;
#line 498
  kfree((void const   *)dev_priv->gmbus);
#line 499
  dev_priv->gmbus = (struct intel_gmbus *)0;
#line 500
  return;
}
}
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
void ldv_initialize_i2c_algorithm_53(void) 
{ 
  void *tmp ;

  {
#line 406
  tmp = ldv_init_zalloc(1936UL);
#line 406
  gmbus_algorithm_group0 = (struct i2c_adapter *)tmp;
#line 407
  return;
}
}
#line 409 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
void ldv_main_exported_53(void) 
{ 
  struct i2c_msg *ldvarg109 ;
  void *tmp ;
  int ldvarg108 ;
  int tmp___0 ;

  {
#line 410
  tmp = ldv_init_zalloc(16UL);
#line 410
  ldvarg109 = (struct i2c_msg *)tmp;
#line 411
  ldv_memset((void *)(& ldvarg108), 0, 4UL);
#line 413
  tmp___0 = __VERIFIER_nondet_int();
#line 413
  switch (tmp___0) {
  case 0: ;
#line 416
  if (ldv_state_variable_53 == 1) {
#line 418
    gmbus_xfer(gmbus_algorithm_group0, ldvarg109, ldvarg108);
#line 420
    ldv_state_variable_53 = 1;
  } else {

  }
#line 423
  goto ldv_42209;
  case 1: ;
#line 426
  if (ldv_state_variable_53 == 1) {
#line 428
    gmbus_func(gmbus_algorithm_group0);
#line 430
    ldv_state_variable_53 = 1;
  } else {

  }
#line 433
  goto ldv_42209;
  default: 
#line 434
  ldv_stop();
  }
  ldv_42209: ;
#line 438
  return;
}
}
#line 463 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
bool ldv_queue_work_on_350(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 467
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 467
  ldv_func_res = tmp;
#line 469
  activate_work_2(ldv_func_arg3, 2);
#line 471
  return (ldv_func_res);
}
}
#line 474 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
bool ldv_queue_delayed_work_on_351(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 478
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 478
  ldv_func_res = tmp;
#line 480
  activate_work_2(& ldv_func_arg3->work, 2);
#line 482
  return (ldv_func_res);
}
}
#line 485 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
bool ldv_queue_work_on_352(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 489
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 489
  ldv_func_res = tmp;
#line 491
  activate_work_2(ldv_func_arg3, 2);
#line 493
  return (ldv_func_res);
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
void ldv_flush_workqueue_353(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 499
  flush_workqueue(ldv_func_arg1);
#line 501
  call_and_disable_all_2(2);
#line 502
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
bool ldv_queue_delayed_work_on_354(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 508
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 508
  ldv_func_res = tmp;
#line 510
  activate_work_2(& ldv_func_arg3->work, 2);
#line 512
  return (ldv_func_res);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
void ldv_mutex_lock_355(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 518
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 520
  mutex_lock(ldv_func_arg1);
#line 521
  return;
}
}
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
void ldv_mutex_unlock_356(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 526
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 528
  mutex_unlock(ldv_func_arg1);
#line 529
  return;
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
void ldv_mutex_lock_357(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 534
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 536
  mutex_lock(ldv_func_arg1);
#line 537
  return;
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
int ldv_mutex_trylock_358(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 543
  tmp = mutex_trylock(ldv_func_arg1);
#line 543
  ldv_func_res = tmp;
#line 545
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 545
  return (tmp___0);
#line 547
  return (ldv_func_res);
}
}
#line 550 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
void ldv_mutex_unlock_359(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 553
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 555
  mutex_unlock(ldv_func_arg1);
#line 556
  return;
}
}
#line 558 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
void ldv_mutex_unlock_360(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 561
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 563
  mutex_unlock(ldv_func_arg1);
#line 564
  return;
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
void ldv_mutex_lock_361(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 569
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 571
  mutex_lock(ldv_func_arg1);
#line 572
  return;
}
}
#line 574 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
void ldv_mutex_lock_362(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 577
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 579
  mutex_lock(ldv_func_arg1);
#line 580
  return;
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
void ldv_mutex_unlock_363(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 585
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 587
  mutex_unlock(ldv_func_arg1);
#line 588
  return;
}
}
#line 590 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
void ldv_mutex_unlock_364(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 593
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 595
  mutex_unlock(ldv_func_arg1);
#line 596
  return;
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
void ldv_mutex_lock_365(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 601
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 603
  mutex_lock(ldv_func_arg1);
#line 604
  return;
}
}
#line 606 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
int ldv_mutex_lock_interruptible_366(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 610
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 610
  ldv_func_res = tmp;
#line 612
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 612
  return (tmp___0);
#line 614
  return (ldv_func_res);
}
}
#line 617 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
int ldv_mutex_trylock_367(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 621
  tmp = mutex_trylock(ldv_func_arg1);
#line 621
  ldv_func_res = tmp;
#line 623
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 623
  return (tmp___0);
#line 625
  return (ldv_func_res);
}
}
#line 649 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
void ldv_mutex_unlock_370(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 652
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 654
  mutex_unlock(ldv_func_arg1);
#line 655
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 368 "./arch/x86/include/asm/paravirt_types.h"
extern struct pv_cpu_ops pv_cpu_ops ;
#line 308 "./arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 310
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
#line 178 "include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 10 "./arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "./arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2696;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2696;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2696;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2696;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_2696: ;
#line 14
  return (pfo_ret__);
}
}
#line 37 "./arch/x86/include/asm/page_64.h"
extern void clear_page(void * ) ;
#line 29 "./arch/x86/include/asm/paravirt.h"
__inline static void __cpuid(unsigned int *eax , unsigned int *ebx , unsigned int *ecx ,
                             unsigned int *edx ) 
{ 
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 32
  __edi = __edi;
#line 32
  __esi = __esi;
#line 32
  __edx = __edx;
#line 32
  __ecx = __ecx;
#line 32
  __eax = __eax;
#line 32
  tmp = ldv__builtin_expect((unsigned long )pv_cpu_ops.cpuid == (unsigned long )((void (*)(unsigned int * ,
                                                                                        unsigned int * ,
                                                                                        unsigned int * ,
                                                                                        unsigned int * ))0),
                         0L);
#line 32
  if (tmp != 0L) {
#line 32
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (32), "i" (12UL));
    ldv_3804: ;
#line 32
    goto ldv_3804;
  } else {

  }
#line 32
  __asm__  volatile   ("771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n": "=D" (__edi),
                       "=S" (__esi), "=d" (__edx), "=c" (__ecx): [paravirt_typenum] "i" (31UL),
                       [paravirt_opptr] "i" (& pv_cpu_ops.cpuid), [paravirt_clobber] "i" (511),
                       "D" ((unsigned long )eax), "S" ((unsigned long )ebx), "d" ((unsigned long )ecx),
                       "c" ((unsigned long )edx): "memory", "cc", "rax", "r8", "r9",
                       "r10", "r11");
#line 34
  return;
}
}
#line 502 "./arch/x86/include/asm/processor.h"
__inline static void cpuid(unsigned int op , unsigned int *eax , unsigned int *ebx ,
                           unsigned int *ecx , unsigned int *edx ) 
{ 


  {
#line 506
  *eax = op;
#line 507
  *ecx = 0U;
#line 508
  __cpuid(eax, ebx, ecx, edx);
#line 509
  return;
}
}
#line 37 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 39
  v->counter = i;
#line 40
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_403(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_412(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_401(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_404(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_405(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_408(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_409(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_415(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
int ldv_mutex_lock_interruptible_411(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_400(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_402(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_406(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_407(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_410(struct mutex *ldv_func_arg1 ) ;
#line 70 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add(int val ) 
{ 
  int pao_ID__ ;

  {
#line 72
  pao_ID__ = 0;
#line 72
  switch (4UL) {
  case 1UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (val));
  }
#line 72
  goto ldv_6772;
  case 2UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6772;
  case 4UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6772;
  case 8UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (val));
  }
#line 72
  goto ldv_6772;
  default: 
#line 72
  __bad_percpu_size();
  }
  ldv_6772: ;
#line 74
  return;
}
}
#line 75 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub(int val ) 
{ 
  int pao_ID__ ;

  {
#line 77
  pao_ID__ = 0;
#line 77
  switch (4UL) {
  case 1UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (- val));
  }
#line 77
  goto ldv_6784;
  case 2UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6784;
  case 4UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6784;
  case 8UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (- val));
  }
#line 77
  goto ldv_6784;
  default: 
#line 77
  __bad_percpu_size();
  }
  ldv_6784: ;
#line 79
  return;
}
}
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 310 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 312
  _raw_spin_lock(& lock->__annonCompField17.rlock);
#line 313
  return;
}
}
#line 355 "include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 357
  _raw_spin_unlock(& lock->__annonCompField17.rlock);
#line 358
  return;
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_395(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_397(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_396(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_399(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_398(struct workqueue_struct *ldv_func_arg1 ) ;
#line 108 "include/linux/rwsem.h"
extern void down_read(struct rw_semaphore * ) ;
#line 118
extern void down_write(struct rw_semaphore * ) ;
#line 128
extern void up_read(struct rw_semaphore * ) ;
#line 133
extern void up_write(struct rw_semaphore * ) ;
#line 322 "include/linux/gfp.h"
extern struct page *alloc_pages_current(gfp_t  , unsigned int  ) ;
#line 325 "include/linux/gfp.h"
__inline static struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ 
  struct page *tmp ;

  {
#line 327
  tmp = alloc_pages_current(gfp_mask, order);
#line 327
  return (tmp);
}
}
#line 366
extern void __free_pages(struct page * , unsigned int  ) ;
#line 924 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 926
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
#line 7 "include/linux/uaccess.h"
__inline static void pagefault_disabled_inc(void) 
{ 
  struct task_struct *tmp ;

  {
#line 9
  tmp = get_current();
#line 9
  tmp->pagefault_disabled = tmp->pagefault_disabled + 1;
#line 10
  return;
}
}
#line 12 "include/linux/uaccess.h"
__inline static void pagefault_disabled_dec(void) 
{ 
  struct task_struct *tmp ;
  int __ret_warn_on ;
  struct task_struct *tmp___0 ;
  long tmp___1 ;

  {
#line 14
  tmp = get_current();
#line 14
  tmp->pagefault_disabled = tmp->pagefault_disabled - 1;
#line 15
  tmp___0 = get_current();
#line 15
  __ret_warn_on = tmp___0->pagefault_disabled < 0;
#line 15
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 15
  if (tmp___1 != 0L) {
#line 15
    warn_slowpath_null("include/linux/uaccess.h", 15);
  } else {

  }
#line 15
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 17
  return;
}
}
#line 25 "include/linux/uaccess.h"
__inline static void pagefault_disable(void) 
{ 


  {
#line 27
  pagefault_disabled_inc();
#line 32
  __asm__  volatile   ("": : : "memory");
#line 33
  return;
}
}
#line 35 "include/linux/uaccess.h"
__inline static void pagefault_enable(void) 
{ 


  {
#line 41
  __asm__  volatile   ("": : : "memory");
#line 42
  pagefault_disabled_dec();
#line 43
  return;
}
}
#line 56 "include/linux/highmem.h"
__inline static void *kmap(struct page *page ) 
{ 
  void *tmp ;

  {
#line 58
  __might_sleep("include/linux/highmem.h", 58, 0);
#line 59
  tmp = lowmem_page_address((struct page  const  *)page);
#line 59
  return (tmp);
}
}
#line 62 "include/linux/highmem.h"
__inline static void kunmap(struct page *page ) 
{ 


  {
#line 64
  return;
}
}
#line 66 "include/linux/highmem.h"
__inline static void *kmap_atomic(struct page *page ) 
{ 
  void *tmp ;

  {
#line 68
  __preempt_count_add(1);
#line 68
  __asm__  volatile   ("": : : "memory");
#line 69
  pagefault_disable();
#line 70
  tmp = lowmem_page_address((struct page  const  *)page);
#line 70
  return (tmp);
}
}
#line 74 "include/linux/highmem.h"
__inline static void __kunmap_atomic(void *addr ) 
{ 


  {
#line 76
  pagefault_enable();
#line 77
  __asm__  volatile   ("": : : "memory");
#line 77
  __preempt_count_sub(1);
#line 78
  return;
}
}
#line 71 "include/linux/vmalloc.h"
extern void *vmalloc_user(unsigned long  ) ;
#line 83
extern void vfree(void const   * ) ;
#line 62 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/mmu.h"
struct psb_mmu_driver *psb_mmu_driver_init(struct drm_device *dev , int trap_pagefaults ,
                                           int invalid_type , atomic_t *msvdx_mmu_invaldc ) ;
#line 66
void psb_mmu_driver_takedown(struct psb_mmu_driver *driver___0 ) ;
#line 69
struct psb_mmu_pd *psb_mmu_alloc_pd(struct psb_mmu_driver *driver___0 , int trap_pagefaults ,
                                    int invalid_type ) ;
#line 72
void psb_mmu_free_pagedir(struct psb_mmu_pd *pd ) ;
#line 73
void psb_mmu_flush(struct psb_mmu_driver *driver___0 ) ;
#line 74
void psb_mmu_remove_pfn_sequence(struct psb_mmu_pd *pd , unsigned long address , uint32_t num_pages ) ;
#line 77
int psb_mmu_insert_pfn_sequence(struct psb_mmu_pd *pd , uint32_t start_pfn , unsigned long address ,
                                uint32_t num_pages , int type ) ;
#line 81
int psb_mmu_virtual_to_pfn(struct psb_mmu_pd *pd , uint32_t virtual , unsigned long *pfn ) ;
#line 83
void psb_mmu_set_pd_context(struct psb_mmu_pd *pd , int hw_context ) ;
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
__inline static uint32_t psb_mmu_pt_index(uint32_t offset ) 
{ 


  {
#line 53
  return ((offset >> 12) & 1023U);
}
}
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
__inline static uint32_t psb_mmu_pd_index(uint32_t offset ) 
{ 


  {
#line 58
  return (offset >> 22);
}
}
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
__inline static void psb_clflush(void *addr ) 
{ 


  {
#line 64
  __asm__  volatile   ("clflush (%0)\n": : "r" (addr): "memory");
#line 65
  return;
}
}
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
__inline static void psb_mmu_clflush(struct psb_mmu_driver *driver___0 , void *addr ) 
{ 


  {
#line 69
  if (driver___0->has_clflush == 0) {
#line 70
    return;
  } else {

  }
#line 72
  __asm__  volatile   ("mfence": : : "memory");
#line 73
  psb_clflush(addr);
#line 74
  __asm__  volatile   ("mfence": : : "memory");
#line 75
  return;
}
}
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
static void psb_mmu_flush_pd_locked(struct psb_mmu_driver *driver___0 , int force ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  uint32_t val ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 86
  dev = driver___0->dev;
#line 87
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 89
  tmp___0 = atomic_read((atomic_t const   *)(& driver___0->needs_tlbflush));
#line 89
  if (tmp___0 != 0 || force != 0) {
#line 90
    tmp = ioread32((void *)dev_priv->sgx_reg + 3072U);
#line 90
    val = tmp;
#line 91
    iowrite32(val | 8U, (void *)dev_priv->sgx_reg + 3072U);
#line 94
    __asm__  volatile   ("sfence": : : "memory");
#line 95
    iowrite32(val & 4294967287U, (void *)dev_priv->sgx_reg + 3072U);
#line 96
    ioread32((void *)dev_priv->sgx_reg + 3072U);
#line 97
    if ((unsigned long )driver___0->msvdx_mmu_invaldc != (unsigned long )((atomic_t *)0)) {
#line 98
      atomic_set(driver___0->msvdx_mmu_invaldc, 1);
    } else {

    }
  } else {

  }
#line 100
  atomic_set(& driver___0->needs_tlbflush, 0);
#line 101
  return;
}
}
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
void psb_mmu_flush(struct psb_mmu_driver *driver___0 ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  uint32_t val ;
  int tmp ;

  {
#line 114
  dev = driver___0->dev;
#line 115
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 118
  down_write(& driver___0->sem);
#line 119
  val = ioread32((void *)dev_priv->sgx_reg + 3072U);
#line 120
  tmp = atomic_read((atomic_t const   *)(& driver___0->needs_tlbflush));
#line 120
  if (tmp != 0) {
#line 121
    iowrite32(val | 8U, (void *)dev_priv->sgx_reg + 3072U);
  } else {
#line 123
    iowrite32(val | 4U, (void *)dev_priv->sgx_reg + 3072U);
  }
#line 127
  __asm__  volatile   ("sfence": : : "memory");
#line 128
  iowrite32(val & 4294967283U, (void *)dev_priv->sgx_reg + 3072U);
#line 130
  ioread32((void *)dev_priv->sgx_reg + 3072U);
#line 132
  atomic_set(& driver___0->needs_tlbflush, 0);
#line 133
  if ((unsigned long )driver___0->msvdx_mmu_invaldc != (unsigned long )((atomic_t *)0)) {
#line 134
    atomic_set(driver___0->msvdx_mmu_invaldc, 1);
  } else {

  }
#line 135
  up_write(& driver___0->sem);
#line 136
  return;
}
}
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
void psb_mmu_set_pd_context(struct psb_mmu_pd *pd , int hw_context ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  uint32_t offset ;

  {
#line 140
  dev = (pd->driver)->dev;
#line 141
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 142
  offset = hw_context != 0 ? (uint32_t )((hw_context + 782) * 4) : 3204U;
#line 145
  down_write(& (pd->driver)->sem);
#line 146
  iowrite32((u32 )(((long )pd->p + 24189255811072L) / 64L) << 12U, (void *)dev_priv->sgx_reg + (unsigned long )offset);
#line 147
  __asm__  volatile   ("sfence": : : "memory");
#line 148
  psb_mmu_flush_pd_locked(pd->driver, 1);
#line 149
  pd->hw_context = hw_context;
#line 150
  up_write(& (pd->driver)->sem);
#line 151
  return;
}
}
#line 154 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
__inline static unsigned long psb_pd_addr_end(unsigned long addr , unsigned long end ) 
{ 


  {
#line 157
  addr = (addr + 4194304UL) & 0xffffffffffc00000UL;
#line 158
  return (addr < end ? addr : end);
}
}
#line 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
__inline static uint32_t psb_mmu_mask_pte(uint32_t pfn , int type ) 
{ 
  uint32_t mask ;

  {
#line 163
  mask = 1U;
#line 165
  if (type & 1) {
#line 166
    mask = mask | 8U;
  } else {

  }
#line 167
  if ((type & 2) != 0) {
#line 168
    mask = mask | 4U;
  } else {

  }
#line 169
  if ((type & 4) != 0) {
#line 170
    mask = mask | 2U;
  } else {

  }
#line 172
  return ((pfn << 12) | mask);
}
}
#line 175 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
struct psb_mmu_pd *psb_mmu_alloc_pd(struct psb_mmu_driver *driver___0 , int trap_pagefaults ,
                                    int invalid_type ) 
{ 
  struct psb_mmu_pd *pd ;
  void *tmp ;
  uint32_t *v ;
  int i ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 178
  tmp = kmalloc(64UL, 208U);
#line 178
  pd = (struct psb_mmu_pd *)tmp;
#line 182
  if ((unsigned long )pd == (unsigned long )((struct psb_mmu_pd *)0)) {
#line 183
    return ((struct psb_mmu_pd *)0);
  } else {

  }
#line 185
  pd->p = alloc_pages(4U, 0U);
#line 186
  if ((unsigned long )pd->p == (unsigned long )((struct page *)0)) {
#line 187
    goto out_err1;
  } else {

  }
#line 188
  pd->dummy_pt = alloc_pages(4U, 0U);
#line 189
  if ((unsigned long )pd->dummy_pt == (unsigned long )((struct page *)0)) {
#line 190
    goto out_err2;
  } else {

  }
#line 191
  pd->dummy_page = alloc_pages(4U, 0U);
#line 192
  if ((unsigned long )pd->dummy_page == (unsigned long )((struct page *)0)) {
#line 193
    goto out_err3;
  } else {

  }
#line 195
  if (trap_pagefaults == 0) {
#line 196
    pd->invalid_pde = psb_mmu_mask_pte((uint32_t )(((long )pd->dummy_pt + 24189255811072L) / 64L),
                                       invalid_type);
#line 198
    pd->invalid_pte = psb_mmu_mask_pte((uint32_t )(((long )pd->dummy_page + 24189255811072L) / 64L),
                                       invalid_type);
  } else {
#line 201
    pd->invalid_pde = 0U;
#line 202
    pd->invalid_pte = 0U;
  }
#line 205
  tmp___0 = kmap(pd->dummy_pt);
#line 205
  v = (uint32_t *)tmp___0;
#line 206
  i = 0;
#line 206
  goto ldv_41920;
  ldv_41919: 
#line 207
  *(v + (unsigned long )i) = pd->invalid_pte;
#line 206
  i = i + 1;
  ldv_41920: ;
#line 206
  if ((unsigned int )i <= 1023U) {
#line 208
    goto ldv_41919;
  } else {

  }
#line 209
  kunmap(pd->dummy_pt);
#line 211
  tmp___1 = kmap(pd->p);
#line 211
  v = (uint32_t *)tmp___1;
#line 212
  i = 0;
#line 212
  goto ldv_41923;
  ldv_41922: 
#line 213
  *(v + (unsigned long )i) = pd->invalid_pde;
#line 212
  i = i + 1;
  ldv_41923: ;
#line 212
  if ((unsigned int )i <= 1023U) {
#line 214
    goto ldv_41922;
  } else {

  }
#line 215
  kunmap(pd->p);
#line 217
  tmp___2 = kmap(pd->dummy_page);
#line 217
  clear_page(tmp___2);
#line 218
  kunmap(pd->dummy_page);
#line 220
  tmp___3 = vmalloc_user(8192UL);
#line 220
  pd->tables = (struct psb_mmu_pt **)tmp___3;
#line 221
  if ((unsigned long )pd->tables == (unsigned long )((struct psb_mmu_pt **)0)) {
#line 222
    goto out_err4;
  } else {

  }
#line 224
  pd->hw_context = -1;
#line 225
  pd->pd_mask = 1U;
#line 226
  pd->driver = driver___0;
#line 228
  return (pd);
  out_err4: 
#line 231
  __free_pages(pd->dummy_page, 0U);
  out_err3: 
#line 233
  __free_pages(pd->dummy_pt, 0U);
  out_err2: 
#line 235
  __free_pages(pd->p, 0U);
  out_err1: 
#line 237
  kfree((void const   *)pd);
#line 238
  return ((struct psb_mmu_pd *)0);
}
}
#line 241 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
static void psb_mmu_free_pt(struct psb_mmu_pt *pt ) 
{ 


  {
#line 243
  __free_pages(pt->p, 0U);
#line 244
  kfree((void const   *)pt);
#line 245
  return;
}
}
#line 247 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
void psb_mmu_free_pagedir(struct psb_mmu_pd *pd ) 
{ 
  struct psb_mmu_driver *driver___0 ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_mmu_pt *pt ;
  int i ;

  {
#line 249
  driver___0 = pd->driver;
#line 250
  dev = driver___0->dev;
#line 251
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 255
  down_write(& driver___0->sem);
#line 256
  if (pd->hw_context != -1) {
#line 257
    iowrite32(0U, (void *)dev_priv->sgx_reg + (unsigned long )((pd->hw_context + 801) * 4));
#line 258
    psb_mmu_flush_pd_locked(driver___0, 1);
  } else {

  }
#line 264
  i = 0;
#line 264
  goto ldv_41938;
  ldv_41937: 
#line 265
  pt = *(pd->tables + (unsigned long )i);
#line 266
  if ((unsigned long )pt != (unsigned long )((struct psb_mmu_pt *)0)) {
#line 267
    psb_mmu_free_pt(pt);
  } else {

  }
#line 264
  i = i + 1;
  ldv_41938: ;
#line 264
  if (i <= 1023) {
#line 266
    goto ldv_41937;
  } else {

  }
#line 270
  vfree((void const   *)pd->tables);
#line 271
  __free_pages(pd->dummy_page, 0U);
#line 272
  __free_pages(pd->dummy_pt, 0U);
#line 273
  __free_pages(pd->p, 0U);
#line 274
  kfree((void const   *)pd);
#line 275
  up_write(& driver___0->sem);
#line 276
  return;
}
}
#line 278 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
static struct psb_mmu_pt *psb_mmu_alloc_pt(struct psb_mmu_pd *pd ) 
{ 
  struct psb_mmu_pt *pt ;
  void *tmp ;
  void *v ;
  uint32_t clflush_add ;
  uint32_t clflush_count ;
  spinlock_t *lock ;
  uint8_t *clf ;
  uint32_t *ptes ;
  int i ;
  uint32_t *tmp___0 ;

  {
#line 280
  tmp = kmalloc(32UL, 208U);
#line 280
  pt = (struct psb_mmu_pt *)tmp;
#line 282
  clflush_add = (uint32_t )((pd->driver)->clflush_add >> 12);
#line 283
  clflush_count = 4096U / clflush_add;
#line 284
  lock = & (pd->driver)->lock;
#line 289
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
#line 290
    return ((struct psb_mmu_pt *)0);
  } else {

  }
#line 292
  pt->p = alloc_pages(4U, 0U);
#line 293
  if ((unsigned long )pt->p == (unsigned long )((struct page *)0)) {
#line 294
    kfree((void const   *)pt);
#line 295
    return ((struct psb_mmu_pt *)0);
  } else {

  }
#line 298
  spin_lock(lock);
#line 300
  v = kmap_atomic(pt->p);
#line 301
  clf = (uint8_t *)v;
#line 302
  ptes = (uint32_t *)v;
#line 303
  i = 0;
#line 303
  goto ldv_41952;
  ldv_41951: 
#line 304
  tmp___0 = ptes;
#line 304
  ptes = ptes + 1;
#line 304
  *tmp___0 = pd->invalid_pte;
#line 303
  i = i + 1;
  ldv_41952: ;
#line 303
  if ((unsigned int )i <= 1023U) {
#line 305
    goto ldv_41951;
  } else {

  }

#line 307
  if ((pd->driver)->has_clflush != 0 && pd->hw_context != -1) {
#line 308
    __asm__  volatile   ("mfence": : : "memory");
#line 309
    i = 0;
#line 309
    goto ldv_41955;
    ldv_41954: 
#line 310
    psb_clflush((void *)clf);
#line 311
    clf = clf + (unsigned long )clflush_add;
#line 309
    i = i + 1;
    ldv_41955: ;
#line 309
    if ((uint32_t )i < clflush_count) {
#line 311
      goto ldv_41954;
    } else {

    }
#line 313
    __asm__  volatile   ("mfence": : : "memory");
  } else {

  }
#line 316
  __kunmap_atomic(v);
#line 317
  spin_unlock(lock);
#line 319
  pt->count = 0U;
#line 320
  pt->pd = pd;
#line 321
  pt->index = 0U;
#line 323
  return (pt);
}
}
#line 326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
struct psb_mmu_pt *psb_mmu_pt_alloc_map_lock(struct psb_mmu_pd *pd , unsigned long addr ) 
{ 
  uint32_t index ;
  uint32_t tmp ;
  struct psb_mmu_pt *pt ;
  uint32_t *v ;
  spinlock_t *lock ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 329
  tmp = psb_mmu_pd_index((uint32_t )addr);
#line 329
  index = tmp;
#line 332
  lock = & (pd->driver)->lock;
#line 334
  spin_lock(lock);
#line 335
  pt = *(pd->tables + (unsigned long )index);
#line 336
  goto ldv_41965;
  ldv_41966: 
#line 337
  spin_unlock(lock);
#line 338
  pt = psb_mmu_alloc_pt(pd);
#line 339
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
#line 340
    return ((struct psb_mmu_pt *)0);
  } else {

  }
#line 341
  spin_lock(lock);
#line 343
  if ((unsigned long )*(pd->tables + (unsigned long )index) != (unsigned long )((struct psb_mmu_pt *)0)) {
#line 344
    spin_unlock(lock);
#line 345
    psb_mmu_free_pt(pt);
#line 346
    spin_lock(lock);
#line 347
    pt = *(pd->tables + (unsigned long )index);
#line 348
    goto ldv_41965;
  } else {

  }
#line 351
  tmp___0 = kmap_atomic(pd->p);
#line 351
  v = (uint32_t *)tmp___0;
#line 352
  *(pd->tables + (unsigned long )index) = pt;
#line 353
  *(v + (unsigned long )index) = ((uint32_t )(((long )pt->p + 24189255811072L) / 64L) << 12U) | pd->pd_mask;
#line 354
  pt->index = index;
#line 355
  __kunmap_atomic((void *)v);
#line 357
  if (pd->hw_context != -1) {
#line 358
    psb_mmu_clflush(pd->driver, (void *)v + (unsigned long )index);
#line 359
    atomic_set(& (pd->driver)->needs_tlbflush, 1);
  } else {

  }
  ldv_41965: ;
#line 336
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
#line 338
    goto ldv_41966;
  } else {

  }
#line 362
  tmp___1 = kmap_atomic(pt->p);
#line 362
  pt->v = (uint32_t *)tmp___1;
#line 363
  return (pt);
}
}
#line 366 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
static struct psb_mmu_pt *psb_mmu_pt_map_lock(struct psb_mmu_pd *pd , unsigned long addr ) 
{ 
  uint32_t index ;
  uint32_t tmp ;
  struct psb_mmu_pt *pt ;
  spinlock_t *lock ;
  void *tmp___0 ;

  {
#line 369
  tmp = psb_mmu_pd_index((uint32_t )addr);
#line 369
  index = tmp;
#line 371
  lock = & (pd->driver)->lock;
#line 373
  spin_lock(lock);
#line 374
  pt = *(pd->tables + (unsigned long )index);
#line 375
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
#line 376
    spin_unlock(lock);
#line 377
    return ((struct psb_mmu_pt *)0);
  } else {

  }
#line 379
  tmp___0 = kmap_atomic(pt->p);
#line 379
  pt->v = (uint32_t *)tmp___0;
#line 380
  return (pt);
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
static void psb_mmu_pt_unmap_unlock(struct psb_mmu_pt *pt ) 
{ 
  struct psb_mmu_pd *pd ;
  uint32_t *v ;
  void *tmp ;

  {
#line 385
  pd = pt->pd;
#line 388
  __kunmap_atomic((void *)pt->v);
#line 389
  if (pt->count == 0U) {
#line 390
    tmp = kmap_atomic(pd->p);
#line 390
    v = (uint32_t *)tmp;
#line 391
    *(v + (unsigned long )pt->index) = pd->invalid_pde;
#line 392
    *(pd->tables + (unsigned long )pt->index) = (struct psb_mmu_pt *)0;
#line 394
    if (pd->hw_context != -1) {
#line 395
      psb_mmu_clflush(pd->driver, (void *)v + (unsigned long )pt->index);
#line 396
      atomic_set(& (pd->driver)->needs_tlbflush, 1);
    } else {

    }
#line 398
    __kunmap_atomic((void *)pt->v);
#line 399
    spin_unlock(& (pd->driver)->lock);
#line 400
    psb_mmu_free_pt(pt);
#line 401
    return;
  } else {

  }
#line 403
  spin_unlock(& (pd->driver)->lock);
#line 404
  return;
}
}
#line 406 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
__inline static void psb_mmu_set_pte(struct psb_mmu_pt *pt , unsigned long addr ,
                                     uint32_t pte ) 
{ 
  uint32_t tmp ;

  {
#line 409
  tmp = psb_mmu_pt_index((uint32_t )addr);
#line 409
  *(pt->v + (unsigned long )tmp) = pte;
#line 410
  return;
}
}
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
__inline static void psb_mmu_invalidate_pte(struct psb_mmu_pt *pt , unsigned long addr ) 
{ 
  uint32_t tmp ;

  {
#line 415
  tmp = psb_mmu_pt_index((uint32_t )addr);
#line 415
  *(pt->v + (unsigned long )tmp) = (pt->pd)->invalid_pte;
#line 416
  return;
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
struct psb_mmu_pd *psb_mmu_get_default_pd(struct psb_mmu_driver *driver___0 ) 
{ 
  struct psb_mmu_pd *pd ;

  {
#line 422
  down_read(& driver___0->sem);
#line 423
  pd = driver___0->default_pd;
#line 424
  up_read(& driver___0->sem);
#line 426
  return (pd);
}
}
#line 430 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
uint32_t psb_get_default_pd_addr(struct psb_mmu_driver *driver___0 ) 
{ 
  struct psb_mmu_pd *pd ;

  {
#line 434
  pd = psb_mmu_get_default_pd(driver___0);
#line 435
  return ((uint32_t )(((long )pd->p + 24189255811072L) / 64L) << 12U);
}
}
#line 438 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
void psb_mmu_driver_takedown(struct psb_mmu_driver *driver___0 ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;

  {
#line 440
  dev = driver___0->dev;
#line 441
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 443
  iowrite32(driver___0->bif_ctrl, (void *)dev_priv->sgx_reg + 3072U);
#line 444
  psb_mmu_free_pagedir(driver___0->default_pd);
#line 445
  kfree((void const   *)driver___0);
#line 446
  return;
}
}
#line 448 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
struct psb_mmu_driver *psb_mmu_driver_init(struct drm_device *dev , int trap_pagefaults ,
                                           int invalid_type , atomic_t *msvdx_mmu_invaldc ) 
{ 
  struct psb_mmu_driver *driver___0 ;
  struct drm_psb_private *dev_priv ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  uint32_t tfms ;
  uint32_t misc ;
  uint32_t cap0 ;
  uint32_t cap4 ;
  uint32_t clflush_size ;
  int tmp___0 ;

  {
#line 454
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 456
  tmp = kmalloc(288UL, 208U);
#line 456
  driver___0 = (struct psb_mmu_driver *)tmp;
#line 458
  if ((unsigned long )driver___0 == (unsigned long )((struct psb_mmu_driver *)0)) {
#line 459
    return ((struct psb_mmu_driver *)0);
  } else {

  }
#line 461
  driver___0->dev = dev;
#line 462
  driver___0->default_pd = psb_mmu_alloc_pd(driver___0, trap_pagefaults, invalid_type);
#line 464
  if ((unsigned long )driver___0->default_pd == (unsigned long )((struct psb_mmu_pd *)0)) {
#line 465
    goto out_err1;
  } else {

  }
#line 467
  spinlock_check(& driver___0->lock);
#line 467
  __raw_spin_lock_init(& driver___0->lock.__annonCompField17.rlock, "&(&driver->lock)->rlock",
                       & __key);
#line 468
  __init_rwsem(& driver___0->sem, "&driver->sem", & __key___0);
#line 469
  down_write(& driver___0->sem);
#line 470
  atomic_set(& driver___0->needs_tlbflush, 1);
#line 471
  driver___0->msvdx_mmu_invaldc = msvdx_mmu_invaldc;
#line 473
  driver___0->bif_ctrl = ioread32((void *)dev_priv->sgx_reg + 3072U);
#line 474
  iowrite32(driver___0->bif_ctrl | 16U, (void *)dev_priv->sgx_reg + 3072U);
#line 476
  iowrite32(driver___0->bif_ctrl & 4294967279U, (void *)dev_priv->sgx_reg + 3072U);
#line 479
  driver___0->has_clflush = 0;
#line 482
  tmp___0 = constant_test_bit(19L, (unsigned long const volatile   *)(& boot_cpu_data.x86_capability));
#line 482
  if (tmp___0 != 0) {
#line 490
    cpuid(1U, & tfms, & misc, & cap0, & cap4);
#line 491
    clflush_size = ((misc >> 8) & 255U) * 8U;
#line 492
    driver___0->has_clflush = 1;
#line 493
    driver___0->clflush_add = (int )(((unsigned long )clflush_size * 4096UL) / 4UL);
#line 495
    driver___0->clflush_mask = (unsigned long )(driver___0->clflush_add + -1);
#line 496
    driver___0->clflush_mask = ~ driver___0->clflush_mask;
  } else {

  }
#line 500
  up_write(& driver___0->sem);
#line 501
  return (driver___0);
  out_err1: 
#line 504
  kfree((void const   *)driver___0);
#line 505
  return ((struct psb_mmu_driver *)0);
}
}
#line 509 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
static void psb_mmu_flush_ptes(struct psb_mmu_pd *pd , unsigned long address , uint32_t num_pages ,
                               uint32_t desired_tile_stride , uint32_t hw_tile_stride ) 
{ 
  struct psb_mmu_pt *pt ;
  uint32_t rows ;
  uint32_t i ;
  unsigned long addr ;
  unsigned long end ;
  unsigned long next ;
  unsigned long add ;
  unsigned long row_add ;
  unsigned long clflush_add ;
  unsigned long clflush_mask ;
  uint32_t tmp ;

  {
#line 514
  rows = 1U;
#line 521
  clflush_add = (unsigned long )(pd->driver)->clflush_add;
#line 522
  clflush_mask = (pd->driver)->clflush_mask;
#line 524
  if ((pd->driver)->has_clflush == 0) {
#line 525
    return;
  } else {

  }
#line 527
  if (hw_tile_stride != 0U) {
#line 528
    rows = num_pages / desired_tile_stride;
  } else {
#line 530
    desired_tile_stride = num_pages;
  }
#line 532
  add = (unsigned long )(desired_tile_stride << 12);
#line 533
  row_add = (unsigned long )(hw_tile_stride << 12);
#line 534
  __asm__  volatile   ("mfence": : : "memory");
#line 535
  i = 0U;
#line 535
  goto ldv_42041;
  ldv_42040: 
#line 537
  addr = address;
#line 538
  end = addr + add;
  ldv_42038: 
#line 541
  next = psb_pd_addr_end(addr, end);
#line 542
  pt = psb_mmu_pt_map_lock(pd, addr);
#line 543
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
#line 544
    goto ldv_42035;
  } else {

  }
  ldv_42036: 
#line 546
  tmp = psb_mmu_pt_index((uint32_t )addr);
#line 546
  psb_clflush((void *)pt->v + (unsigned long )tmp);
#line 548
  addr = addr + clflush_add;
#line 548
  if ((addr & clflush_mask) < next) {
#line 550
    goto ldv_42036;
  } else {

  }
#line 550
  psb_mmu_pt_unmap_unlock(pt);
  ldv_42035: 
#line 551
  addr = next;
#line 551
  if (next != end) {
#line 553
    goto ldv_42038;
  } else {

  }
#line 552
  address = address + row_add;
#line 535
  i = i + 1U;
  ldv_42041: ;
#line 535
  if (i < rows) {
#line 537
    goto ldv_42040;
  } else {

  }
#line 554
  __asm__  volatile   ("mfence": : : "memory");
#line 555
  return;
}
}
#line 565 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
void psb_mmu_remove_pfn_sequence(struct psb_mmu_pd *pd , unsigned long address , uint32_t num_pages ) 
{ 
  struct psb_mmu_pt *pt ;
  unsigned long addr ;
  unsigned long end ;
  unsigned long next ;
  unsigned long f_address ;

  {
#line 572
  f_address = address;
#line 574
  down_read(& (pd->driver)->sem);
#line 576
  addr = address;
#line 577
  end = (unsigned long )(num_pages << 12) + addr;
  ldv_42056: 
#line 580
  next = psb_pd_addr_end(addr, end);
#line 581
  pt = psb_mmu_pt_alloc_map_lock(pd, addr);
#line 582
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
#line 583
    goto out;
  } else {

  }
  ldv_42054: 
#line 585
  psb_mmu_invalidate_pte(pt, addr);
#line 586
  pt->count = pt->count - 1U;
#line 587
  addr = addr + 4096UL;
#line 587
  if (addr < next) {
#line 589
    goto ldv_42054;
  } else {

  }
#line 588
  psb_mmu_pt_unmap_unlock(pt);
#line 590
  addr = next;
#line 590
  if (next != end) {
#line 592
    goto ldv_42056;
  } else {

  }

  out: ;
#line 593
  if (pd->hw_context != -1) {
#line 594
    psb_mmu_flush_ptes(pd, f_address, num_pages, 1U, 1U);
  } else {

  }
#line 596
  up_read(& (pd->driver)->sem);
#line 598
  if (pd->hw_context != -1) {
#line 599
    psb_mmu_flush(pd->driver);
  } else {

  }
#line 601
  return;
}
}
#line 604 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
void psb_mmu_remove_pages(struct psb_mmu_pd *pd , unsigned long address , uint32_t num_pages ,
                          uint32_t desired_tile_stride , uint32_t hw_tile_stride ) 
{ 
  struct psb_mmu_pt *pt ;
  uint32_t rows ;
  uint32_t i ;
  unsigned long addr ;
  unsigned long end ;
  unsigned long next ;
  unsigned long add ;
  unsigned long row_add ;
  unsigned long f_address ;

  {
#line 609
  rows = 1U;
#line 616
  f_address = address;
#line 618
  if (hw_tile_stride != 0U) {
#line 619
    rows = num_pages / desired_tile_stride;
  } else {
#line 621
    desired_tile_stride = num_pages;
  }
#line 623
  add = (unsigned long )(desired_tile_stride << 12);
#line 624
  row_add = (unsigned long )(hw_tile_stride << 12);
#line 626
  down_read(& (pd->driver)->sem);
#line 630
  i = 0U;
#line 630
  goto ldv_42080;
  ldv_42079: 
#line 632
  addr = address;
#line 633
  end = addr + add;
  ldv_42077: 
#line 636
  next = psb_pd_addr_end(addr, end);
#line 637
  pt = psb_mmu_pt_map_lock(pd, addr);
#line 638
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
#line 639
    goto ldv_42074;
  } else {

  }
  ldv_42075: 
#line 641
  psb_mmu_invalidate_pte(pt, addr);
#line 642
  pt->count = pt->count - 1U;
#line 644
  addr = addr + 4096UL;
#line 644
  if (addr < next) {
#line 646
    goto ldv_42075;
  } else {

  }
#line 645
  psb_mmu_pt_unmap_unlock(pt);
  ldv_42074: 
#line 647
  addr = next;
#line 647
  if (next != end) {
#line 649
    goto ldv_42077;
  } else {

  }
#line 648
  address = address + row_add;
#line 630
  i = i + 1U;
  ldv_42080: ;
#line 630
  if (i < rows) {
#line 632
    goto ldv_42079;
  } else {

  }

#line 650
  if (pd->hw_context != -1) {
#line 651
    psb_mmu_flush_ptes(pd, f_address, num_pages, desired_tile_stride, hw_tile_stride);
  } else {

  }
#line 654
  up_read(& (pd->driver)->sem);
#line 656
  if (pd->hw_context != -1) {
#line 657
    psb_mmu_flush(pd->driver);
  } else {

  }
#line 658
  return;
}
}
#line 660 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
int psb_mmu_insert_pfn_sequence(struct psb_mmu_pd *pd , uint32_t start_pfn , unsigned long address ,
                                uint32_t num_pages , int type ) 
{ 
  struct psb_mmu_pt *pt ;
  uint32_t pte ;
  unsigned long addr ;
  unsigned long end ;
  unsigned long next ;
  unsigned long f_address ;
  int ret ;
  uint32_t tmp ;

  {
#line 669
  f_address = address;
#line 670
  ret = -12;
#line 672
  down_read(& (pd->driver)->sem);
#line 674
  addr = address;
#line 675
  end = (unsigned long )(num_pages << 12) + addr;
  ldv_42099: 
#line 678
  next = psb_pd_addr_end(addr, end);
#line 679
  pt = psb_mmu_pt_alloc_map_lock(pd, addr);
#line 680
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
#line 681
    ret = -12;
#line 682
    goto out;
  } else {

  }
  ldv_42097: 
#line 685
  tmp = start_pfn;
#line 685
  start_pfn = start_pfn + 1U;
#line 685
  pte = psb_mmu_mask_pte(tmp, type);
#line 686
  psb_mmu_set_pte(pt, addr, pte);
#line 687
  pt->count = pt->count + 1U;
#line 688
  addr = addr + 4096UL;
#line 688
  if (addr < next) {
#line 690
    goto ldv_42097;
  } else {

  }
#line 689
  psb_mmu_pt_unmap_unlock(pt);
#line 691
  addr = next;
#line 691
  if (next != end) {
#line 693
    goto ldv_42099;
  } else {

  }
#line 692
  ret = 0;
  out: ;
#line 695
  if (pd->hw_context != -1) {
#line 696
    psb_mmu_flush_ptes(pd, f_address, num_pages, 1U, 1U);
  } else {

  }
#line 698
  up_read(& (pd->driver)->sem);
#line 700
  if (pd->hw_context != -1) {
#line 701
    psb_mmu_flush(pd->driver);
  } else {

  }
#line 703
  return (0);
}
}
#line 706 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
int psb_mmu_insert_pages(struct psb_mmu_pd *pd , struct page **pages , unsigned long address ,
                         uint32_t num_pages , uint32_t desired_tile_stride , uint32_t hw_tile_stride ,
                         int type ) 
{ 
  struct psb_mmu_pt *pt ;
  uint32_t rows ;
  uint32_t i ;
  uint32_t pte ;
  unsigned long addr ;
  unsigned long end ;
  unsigned long next ;
  unsigned long add ;
  unsigned long row_add ;
  unsigned long f_address ;
  int ret ;
  struct page **tmp ;

  {
#line 712
  rows = 1U;
#line 720
  f_address = address;
#line 721
  ret = -12;
#line 723
  if (hw_tile_stride != 0U) {
#line 724
    if (num_pages % desired_tile_stride != 0U) {
#line 725
      return (-22);
    } else {

    }
#line 726
    rows = num_pages / desired_tile_stride;
  } else {
#line 728
    desired_tile_stride = num_pages;
  }
#line 731
  add = (unsigned long )(desired_tile_stride << 12);
#line 732
  row_add = (unsigned long )(hw_tile_stride << 12);
#line 734
  down_read(& (pd->driver)->sem);
#line 736
  i = 0U;
#line 736
  goto ldv_42127;
  ldv_42126: 
#line 738
  addr = address;
#line 739
  end = addr + add;
  ldv_42124: 
#line 742
  next = psb_pd_addr_end(addr, end);
#line 743
  pt = psb_mmu_pt_alloc_map_lock(pd, addr);
#line 744
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
#line 745
    goto out;
  } else {

  }
  ldv_42122: 
#line 747
  tmp = pages;
#line 747
  pages = pages + 1;
#line 747
  pte = psb_mmu_mask_pte((uint32_t )(((long )*tmp + 24189255811072L) / 64L), type);
#line 749
  psb_mmu_set_pte(pt, addr, pte);
#line 750
  pt->count = pt->count + 1U;
#line 751
  addr = addr + 4096UL;
#line 751
  if (addr < next) {
#line 753
    goto ldv_42122;
  } else {

  }
#line 752
  psb_mmu_pt_unmap_unlock(pt);
#line 754
  addr = next;
#line 754
  if (next != end) {
#line 756
    goto ldv_42124;
  } else {

  }
#line 756
  address = address + row_add;
#line 736
  i = i + 1U;
  ldv_42127: ;
#line 736
  if (i < rows) {
#line 738
    goto ldv_42126;
  } else {

  }
#line 759
  ret = 0;
  out: ;
#line 761
  if (pd->hw_context != -1) {
#line 762
    psb_mmu_flush_ptes(pd, f_address, num_pages, desired_tile_stride, hw_tile_stride);
  } else {

  }
#line 765
  up_read(& (pd->driver)->sem);
#line 767
  if (pd->hw_context != -1) {
#line 768
    psb_mmu_flush(pd->driver);
  } else {

  }
#line 770
  return (ret);
}
}
#line 773 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.c"
int psb_mmu_virtual_to_pfn(struct psb_mmu_pd *pd , uint32_t virtual , unsigned long *pfn ) 
{ 
  int ret ;
  struct psb_mmu_pt *pt ;
  uint32_t tmp ;
  spinlock_t *lock ;
  uint32_t *v ;
  void *tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 779
  lock = & (pd->driver)->lock;
#line 781
  down_read(& (pd->driver)->sem);
#line 782
  pt = psb_mmu_pt_map_lock(pd, (unsigned long )virtual);
#line 783
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
#line 786
    spin_lock(lock);
#line 787
    tmp___0 = kmap_atomic(pd->p);
#line 787
    v = (uint32_t *)tmp___0;
#line 788
    tmp___1 = psb_mmu_pd_index(virtual);
#line 788
    tmp = *(v + (unsigned long )tmp___1);
#line 789
    __kunmap_atomic((void *)v);
#line 790
    spin_unlock(lock);
#line 792
    if ((pd->invalid_pde != tmp || (tmp & 1U) == 0U) || (pd->invalid_pte & 1U) == 0U) {
#line 794
      ret = -22;
#line 795
      goto out;
    } else {

    }
#line 797
    ret = 0;
#line 798
    *pfn = (unsigned long )(pd->invalid_pte >> 12);
#line 799
    goto out;
  } else {

  }
#line 801
  tmp___2 = psb_mmu_pt_index(virtual);
#line 801
  tmp = *(pt->v + (unsigned long )tmp___2);
#line 802
  if ((tmp & 1U) == 0U) {
#line 803
    ret = -22;
  } else {
#line 805
    ret = 0;
#line 806
    *pfn = (unsigned long )(tmp >> 12);
  }
#line 808
  psb_mmu_pt_unmap_unlock(pt);
  out: 
#line 810
  up_read(& (pd->driver)->sem);
#line 811
  return (ret);
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
bool ldv_queue_work_on_395(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 432
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 432
  ldv_func_res = tmp;
#line 434
  activate_work_2(ldv_func_arg3, 2);
#line 436
  return (ldv_func_res);
}
}
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
bool ldv_queue_delayed_work_on_396(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 443
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 443
  ldv_func_res = tmp;
#line 445
  activate_work_2(& ldv_func_arg3->work, 2);
#line 447
  return (ldv_func_res);
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
bool ldv_queue_work_on_397(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 454
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 454
  ldv_func_res = tmp;
#line 456
  activate_work_2(ldv_func_arg3, 2);
#line 458
  return (ldv_func_res);
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
void ldv_flush_workqueue_398(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 464
  flush_workqueue(ldv_func_arg1);
#line 466
  call_and_disable_all_2(2);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
bool ldv_queue_delayed_work_on_399(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 473
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 473
  ldv_func_res = tmp;
#line 475
  activate_work_2(& ldv_func_arg3->work, 2);
#line 477
  return (ldv_func_res);
}
}
#line 480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
void ldv_mutex_lock_400(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 483
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 485
  mutex_lock(ldv_func_arg1);
#line 486
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
void ldv_mutex_unlock_401(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 491
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 493
  mutex_unlock(ldv_func_arg1);
#line 494
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
void ldv_mutex_lock_402(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 499
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 501
  mutex_lock(ldv_func_arg1);
#line 502
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
int ldv_mutex_trylock_403(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 508
  tmp = mutex_trylock(ldv_func_arg1);
#line 508
  ldv_func_res = tmp;
#line 510
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 510
  return (tmp___0);
#line 512
  return (ldv_func_res);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
void ldv_mutex_unlock_404(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 518
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 520
  mutex_unlock(ldv_func_arg1);
#line 521
  return;
}
}
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
void ldv_mutex_unlock_405(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 526
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 528
  mutex_unlock(ldv_func_arg1);
#line 529
  return;
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
void ldv_mutex_lock_406(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 534
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 536
  mutex_lock(ldv_func_arg1);
#line 537
  return;
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
void ldv_mutex_lock_407(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 542
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 544
  mutex_lock(ldv_func_arg1);
#line 545
  return;
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
void ldv_mutex_unlock_408(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 550
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 552
  mutex_unlock(ldv_func_arg1);
#line 553
  return;
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
void ldv_mutex_unlock_409(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 558
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 560
  mutex_unlock(ldv_func_arg1);
#line 561
  return;
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
void ldv_mutex_lock_410(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 566
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 568
  mutex_lock(ldv_func_arg1);
#line 569
  return;
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
int ldv_mutex_lock_interruptible_411(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 575
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 575
  ldv_func_res = tmp;
#line 577
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 577
  return (tmp___0);
#line 579
  return (ldv_func_res);
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
int ldv_mutex_trylock_412(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 586
  tmp = mutex_trylock(ldv_func_arg1);
#line 586
  ldv_func_res = tmp;
#line 588
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 588
  return (tmp___0);
#line 590
  return (ldv_func_res);
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
void ldv_mutex_unlock_415(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 617
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 619
  mutex_unlock(ldv_func_arg1);
#line 620
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_448(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_457(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_446(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_449(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_450(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_453(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_454(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_460(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/blitter.o.c.prepared"
int ldv_mutex_lock_interruptible_456(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_445(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_447(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_451(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_452(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_455(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_440(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_442(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_441(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_444(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_443(struct workqueue_struct *ldv_func_arg1 ) ;
#line 23 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/blitter.c"
int gma_blt_wait_idle(struct drm_psb_private *dev_priv ) 
{ 
  unsigned long stop ;
  int busy ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 25
  stop = (unsigned long )jiffies + 250UL;
#line 26
  busy = 1;
#line 29
  if (((int )((dev_priv->dev)->pdev)->device & 65520) == 3040) {
#line 30
    return (0);
  } else {

  }
#line 33
  tmp = ioread32((void *)dev_priv->sgx_reg + 3608U);
#line 33
  if (tmp == 128U) {
#line 33
    tmp___0 = ioread32((void *)dev_priv->sgx_reg + 3588U);
#line 33
    if ((tmp___0 & 16777216U) == 0U) {
#line 35
      return (0);
    } else {

    }
  } else {

  }
  ldv_41879: 
#line 38
  tmp___1 = ioread32((void *)dev_priv->sgx_reg + 3608U);
#line 38
  busy = tmp___1 != 128U;
#line 39
  if (busy != 0 && (long )((unsigned long )jiffies - stop) < 0L) {
#line 41
    goto ldv_41879;
  } else {

  }

#line 41
  if (busy != 0) {
#line 42
    return (-16);
  } else {

  }
  ldv_41887: 
#line 45
  tmp___2 = ioread32((void *)dev_priv->sgx_reg + 3588U);
#line 45
  busy = (tmp___2 & 16777216U) != 0U;
#line 47
  if (busy != 0 && (long )((unsigned long )jiffies - stop) < 0L) {
#line 49
    goto ldv_41887;
  } else {

  }

#line 50
  return (busy != 0 ? -16 : 0);
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/blitter.o.c.prepared"
bool ldv_queue_work_on_440(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 432
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 432
  ldv_func_res = tmp;
#line 434
  activate_work_2(ldv_func_arg3, 2);
#line 436
  return (ldv_func_res);
}
}
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/blitter.o.c.prepared"
bool ldv_queue_delayed_work_on_441(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 443
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 443
  ldv_func_res = tmp;
#line 445
  activate_work_2(& ldv_func_arg3->work, 2);
#line 447
  return (ldv_func_res);
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/blitter.o.c.prepared"
bool ldv_queue_work_on_442(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 454
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 454
  ldv_func_res = tmp;
#line 456
  activate_work_2(ldv_func_arg3, 2);
#line 458
  return (ldv_func_res);
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/blitter.o.c.prepared"
void ldv_flush_workqueue_443(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 464
  flush_workqueue(ldv_func_arg1);
#line 466
  call_and_disable_all_2(2);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/blitter.o.c.prepared"
bool ldv_queue_delayed_work_on_444(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 473
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 473
  ldv_func_res = tmp;
#line 475
  activate_work_2(& ldv_func_arg3->work, 2);
#line 477
  return (ldv_func_res);
}
}
#line 480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/blitter.o.c.prepared"
void ldv_mutex_lock_445(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 483
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 485
  mutex_lock(ldv_func_arg1);
#line 486
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/blitter.o.c.prepared"
void ldv_mutex_unlock_446(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 491
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 493
  mutex_unlock(ldv_func_arg1);
#line 494
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/blitter.o.c.prepared"
void ldv_mutex_lock_447(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 499
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 501
  mutex_lock(ldv_func_arg1);
#line 502
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/blitter.o.c.prepared"
int ldv_mutex_trylock_448(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 508
  tmp = mutex_trylock(ldv_func_arg1);
#line 508
  ldv_func_res = tmp;
#line 510
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 510
  return (tmp___0);
#line 512
  return (ldv_func_res);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/blitter.o.c.prepared"
void ldv_mutex_unlock_449(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 518
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 520
  mutex_unlock(ldv_func_arg1);
#line 521
  return;
}
}
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/blitter.o.c.prepared"
void ldv_mutex_unlock_450(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 526
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 528
  mutex_unlock(ldv_func_arg1);
#line 529
  return;
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/blitter.o.c.prepared"
void ldv_mutex_lock_451(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 534
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 536
  mutex_lock(ldv_func_arg1);
#line 537
  return;
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/blitter.o.c.prepared"
void ldv_mutex_lock_452(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 542
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 544
  mutex_lock(ldv_func_arg1);
#line 545
  return;
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/blitter.o.c.prepared"
void ldv_mutex_unlock_453(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 550
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 552
  mutex_unlock(ldv_func_arg1);
#line 553
  return;
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/blitter.o.c.prepared"
void ldv_mutex_unlock_454(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 558
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 560
  mutex_unlock(ldv_func_arg1);
#line 561
  return;
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/blitter.o.c.prepared"
void ldv_mutex_lock_455(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 566
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 568
  mutex_lock(ldv_func_arg1);
#line 569
  return;
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/blitter.o.c.prepared"
int ldv_mutex_lock_interruptible_456(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 575
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 575
  ldv_func_res = tmp;
#line 577
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 577
  return (tmp___0);
#line 579
  return (ldv_func_res);
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/blitter.o.c.prepared"
int ldv_mutex_trylock_457(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 586
  tmp = mutex_trylock(ldv_func_arg1);
#line 586
  ldv_func_res = tmp;
#line 588
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 588
  return (tmp___0);
#line 590
  return (ldv_func_res);
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/blitter.o.c.prepared"
void ldv_mutex_unlock_460(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 617
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 619
  mutex_unlock(ldv_func_arg1);
#line 620
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_493(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_502(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_491(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_494(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_495(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_498(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_499(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_505(struct mutex *ldv_func_arg1 ) ;
#line 209
void ldv_mutex_unlock_507(struct mutex *ldv_func_arg1 ) ;
#line 213
void ldv_mutex_unlock_508(struct mutex *ldv_func_arg1 ) ;
#line 217
void ldv_mutex_unlock_510(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
int ldv_mutex_lock_interruptible_501(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_490(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_492(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_496(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_497(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_500(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_506(struct mutex *ldv_func_arg1 ) ;
#line 49
void ldv_mutex_lock_509(struct mutex *ldv_func_arg1 ) ;
#line 158
void ldv_mutex_lock_power_mutex(struct mutex *lock ) ;
#line 162
void ldv_mutex_unlock_power_mutex(struct mutex *lock ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_485(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_487(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_486(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_489(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_488(struct workqueue_struct *ldv_func_arg1 ) ;
#line 863 "include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 865
  return ((void *)dev->driver_data);
}
}
#line 867 "include/linux/pci.h"
extern int pci_bus_write_config_dword(struct pci_bus * , unsigned int  , int  , u32  ) ;
#line 902 "include/linux/pci.h"
__inline static int pci_write_config_dword(struct pci_dev  const  *dev , int where ,
                                           u32 val ) 
{ 
  int tmp ;

  {
#line 905
  tmp = pci_bus_write_config_dword(dev->bus, dev->devfn, where, val);
#line 905
  return (tmp);
}
}
#line 949
extern int pci_enable_device(struct pci_dev * ) ;
#line 966
extern void pci_disable_device(struct pci_dev * ) ;
#line 1024
extern int pci_save_state(struct pci_dev * ) ;
#line 1025
extern void pci_restore_state(struct pci_dev * ) ;
#line 1038
extern int pci_set_power_state(struct pci_dev * , pci_power_t  ) ;
#line 1468 "include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
#line 1470
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
#line 1470
  return (tmp);
}
}
#line 36 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/power.h"
void gma_power_init(struct drm_device *dev ) ;
#line 37
void gma_power_uninit(struct drm_device *dev ) ;
#line 42
int gma_power_suspend(struct device *_dev ) ;
#line 43
int gma_power_resume(struct device *_dev ) ;
#line 44
int gma_power_thaw(struct device *_dev ) ;
#line 45
int gma_power_freeze(struct device *_dev ) ;
#line 46
int gma_power_restore(struct device *_dev ) ;
#line 61
bool gma_power_is_on(struct drm_device *dev ) ;
#line 66
int psb_runtime_suspend(struct device *dev ) ;
#line 67
int psb_runtime_resume(struct device *dev ) ;
#line 68
int psb_runtime_idle(struct device *dev ) ;
#line 39 "include/linux/pm_runtime.h"
extern int __pm_runtime_idle(struct device * , int  ) ;
#line 41
extern int __pm_runtime_resume(struct device * , int  ) ;
#line 43
extern int __pm_runtime_set_status(struct device * , unsigned int  ) ;
#line 46
extern void __pm_runtime_disable(struct device * , bool  ) ;
#line 222 "include/linux/pm_runtime.h"
__inline static int pm_runtime_get(struct device *dev ) 
{ 
  int tmp ;

  {
#line 224
  tmp = __pm_runtime_resume(dev, 5);
#line 224
  return (tmp);
}
}
#line 232 "include/linux/pm_runtime.h"
__inline static int pm_runtime_put(struct device *dev ) 
{ 
  int tmp ;

  {
#line 234
  tmp = __pm_runtime_idle(dev, 5);
#line 234
  return (tmp);
}
}
#line 263 "include/linux/pm_runtime.h"
__inline static void pm_runtime_set_suspended(struct device *dev ) 
{ 


  {
#line 265
  __pm_runtime_set_status(dev, 2U);
#line 266
  return;
}
}
#line 268 "include/linux/pm_runtime.h"
__inline static void pm_runtime_disable(struct device *dev ) 
{ 


  {
#line 270
  __pm_runtime_disable(dev, 1);
#line 271
  return;
}
}
#line 681 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
void psb_irq_preinstall(struct drm_device *dev ) ;
#line 682
int psb_irq_postinstall(struct drm_device *dev ) ;
#line 683
void psb_irq_uninstall(struct drm_device *dev ) ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.c"
static struct mutex power_mutex  ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.c"
static spinlock_t power_ctrl_lock  ;
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.c"
void gma_power_init(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;

  {
#line 49
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 52
  dev_priv->apm_base = (uint16_t )dev_priv->apm_reg;
#line 53
  dev_priv->ospm_base = dev_priv->ospm_base & 65535U;
#line 55
  dev_priv->display_power = 1;
#line 56
  dev_priv->display_count = 0;
#line 57
  dev_priv->suspended = 0;
#line 58
  spinlock_check(& power_ctrl_lock);
#line 58
  __raw_spin_lock_init(& power_ctrl_lock.__annonCompField17.rlock, "&(&power_ctrl_lock)->rlock",
                       & __key);
#line 59
  __mutex_init(& power_mutex, "&power_mutex", & __key___0);
#line 61
  if ((unsigned long )(dev_priv->ops)->init_pm != (unsigned long )((void (*/* const  */)(struct drm_device * ))0)) {
#line 62
    (*((dev_priv->ops)->init_pm))(dev);
  } else {

  }
#line 63
  return;
}
}
#line 71 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.c"
void gma_power_uninit(struct drm_device *dev ) 
{ 


  {
#line 73
  pm_runtime_disable(& (dev->pdev)->dev);
#line 74
  pm_runtime_set_suspended(& (dev->pdev)->dev);
#line 75
  return;
}
}
#line 83 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.c"
static void gma_suspend_display(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 85
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 87
  if ((int )dev_priv->suspended) {
#line 88
    return;
  } else {

  }
#line 89
  (*((dev_priv->ops)->save_regs))(dev);
#line 90
  (*((dev_priv->ops)->power_down))(dev);
#line 91
  dev_priv->display_power = 0;
#line 92
  return;
}
}
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.c"
static void gma_resume_display(struct pci_dev *pdev ) 
{ 
  struct drm_device *dev ;
  void *tmp ;
  struct drm_psb_private *dev_priv ;

  {
#line 102
  tmp = pci_get_drvdata(pdev);
#line 102
  dev = (struct drm_device *)tmp;
#line 103
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 106
  (*((dev_priv->ops)->power_up))(dev);
#line 107
  dev_priv->suspended = 0;
#line 108
  dev_priv->display_power = 1;
#line 110
  iowrite32(dev_priv->pge_ctl | 1U, (void *)dev_priv->vdc_reg + 8224U);
#line 111
  pci_write_config_word((struct pci_dev  const  *)pdev, 82, (int )((unsigned int )dev_priv->gmch_ctrl | 4U));
#line 114
  psb_gtt_restore(dev);
#line 115
  (*((dev_priv->ops)->restore_regs))(dev);
#line 116
  return;
}
}
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.c"
static void gma_suspend_pci(struct pci_dev *pdev ) 
{ 
  struct drm_device *dev ;
  void *tmp ;
  struct drm_psb_private *dev_priv ;
  int bsm ;
  int vbt ;

  {
#line 126
  tmp = pci_get_drvdata(pdev);
#line 126
  dev = (struct drm_device *)tmp;
#line 127
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 130
  if ((int )dev_priv->suspended) {
#line 131
    return;
  } else {

  }
#line 133
  pci_save_state(pdev);
#line 134
  pci_read_config_dword((struct pci_dev  const  *)pdev, 92, (u32 *)(& bsm));
#line 135
  dev_priv->regs.saveBSM = (uint32_t )bsm;
#line 136
  pci_read_config_dword((struct pci_dev  const  *)pdev, 252, (u32 *)(& vbt));
#line 137
  dev_priv->regs.saveVBT = (uint32_t )vbt;
#line 138
  pci_read_config_dword((struct pci_dev  const  *)pdev, 148, & dev_priv->msi_addr);
#line 139
  pci_read_config_dword((struct pci_dev  const  *)pdev, 152, & dev_priv->msi_data);
#line 141
  pci_disable_device(pdev);
#line 142
  pci_set_power_state(pdev, 3);
#line 144
  dev_priv->suspended = 1;
#line 145
  return;
}
}
#line 154 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.c"
static bool gma_resume_pci(struct pci_dev *pdev ) 
{ 
  struct drm_device *dev ;
  void *tmp ;
  struct drm_psb_private *dev_priv ;
  int ret ;

  {
#line 156
  tmp = pci_get_drvdata(pdev);
#line 156
  dev = (struct drm_device *)tmp;
#line 157
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 160
  if (! dev_priv->suspended) {
#line 161
    return (1);
  } else {

  }
#line 163
  pci_set_power_state(pdev, 0);
#line 164
  pci_restore_state(pdev);
#line 165
  pci_write_config_dword((struct pci_dev  const  *)pdev, 92, dev_priv->regs.saveBSM);
#line 166
  pci_write_config_dword((struct pci_dev  const  *)pdev, 252, dev_priv->regs.saveVBT);
#line 168
  pci_write_config_dword((struct pci_dev  const  *)pdev, 148, dev_priv->msi_addr);
#line 169
  pci_write_config_dword((struct pci_dev  const  *)pdev, 152, dev_priv->msi_data);
#line 170
  ret = pci_enable_device(pdev);
#line 172
  if (ret != 0) {
#line 173
    dev_err((struct device  const  *)(& pdev->dev), "pci_enable failed: %d\n", ret);
  } else {
#line 175
    dev_priv->suspended = 0;
  }
#line 176
  return ((bool )(! ((int )dev_priv->suspended != 0)));
}
}
#line 188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.c"
int gma_power_suspend(struct device *_dev ) 
{ 
  struct pci_dev *pdev ;
  struct device  const  *__mptr ;
  struct drm_device *dev ;
  void *tmp ;
  struct drm_psb_private *dev_priv ;

  {
#line 190
  __mptr = (struct device  const  *)_dev;
#line 190
  pdev = (struct pci_dev *)__mptr + 0xffffffffffffff68UL;
#line 191
  tmp = pci_get_drvdata(pdev);
#line 191
  dev = (struct drm_device *)tmp;
#line 192
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 194
  ldv_mutex_lock_506(& power_mutex);
#line 195
  if (! dev_priv->suspended) {
#line 196
    if (dev_priv->display_count != 0) {
#line 197
      ldv_mutex_unlock_507(& power_mutex);
#line 198
      dev_err((struct device  const  *)dev->dev, "GPU hardware busy, cannot suspend\n");
#line 199
      return (-16);
    } else {

    }
#line 201
    psb_irq_uninstall(dev);
#line 202
    gma_suspend_display(dev);
#line 203
    gma_suspend_pci(pdev);
  } else {

  }
#line 205
  ldv_mutex_unlock_508(& power_mutex);
#line 206
  return (0);
}
}
#line 215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.c"
int gma_power_resume(struct device *_dev ) 
{ 
  struct pci_dev *pdev ;
  struct device  const  *__mptr ;
  struct drm_device *dev ;
  void *tmp ;

  {
#line 217
  __mptr = (struct device  const  *)_dev;
#line 217
  pdev = (struct pci_dev *)__mptr + 0xffffffffffffff68UL;
#line 218
  tmp = pci_get_drvdata(pdev);
#line 218
  dev = (struct drm_device *)tmp;
#line 220
  ldv_mutex_lock_509(& power_mutex);
#line 221
  gma_resume_pci(pdev);
#line 222
  gma_resume_display(pdev);
#line 223
  psb_irq_preinstall(dev);
#line 224
  psb_irq_postinstall(dev);
#line 225
  ldv_mutex_unlock_510(& power_mutex);
#line 226
  return (0);
}
}
#line 235 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.c"
bool gma_power_is_on(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 237
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 238
  return (dev_priv->display_power);
}
}
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.c"
bool gma_power_begin(struct drm_device *dev , bool force_on ) 
{ 
  struct drm_psb_private *dev_priv ;
  int ret ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  bool tmp___0 ;

  {
#line 251
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 255
  tmp = spinlock_check(& power_ctrl_lock);
#line 255
  flags = _raw_spin_lock_irqsave(tmp);
#line 257
  if ((int )dev_priv->display_power) {
#line 258
    dev_priv->display_count = dev_priv->display_count + 1;
#line 259
    pm_runtime_get(& (dev->pdev)->dev);
#line 260
    spin_unlock_irqrestore(& power_ctrl_lock, flags);
#line 261
    return (1);
  } else {

  }
#line 263
  if (! force_on) {
#line 264
    goto out_false;
  } else {

  }
#line 267
  tmp___0 = gma_resume_pci(dev->pdev);
#line 267
  ret = (int )tmp___0;
#line 268
  if (ret == 0) {
#line 269
    psb_irq_preinstall(dev);
#line 270
    psb_irq_postinstall(dev);
#line 271
    pm_runtime_get(& (dev->pdev)->dev);
#line 272
    dev_priv->display_count = dev_priv->display_count + 1;
#line 273
    spin_unlock_irqrestore(& power_ctrl_lock, flags);
#line 274
    return (1);
  } else {

  }
  out_false: 
#line 277
  spin_unlock_irqrestore(& power_ctrl_lock, flags);
#line 278
  return (0);
}
}
#line 288 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.c"
void gma_power_end(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  int __ret_warn_on ;
  long tmp___0 ;

  {
#line 290
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 292
  tmp = spinlock_check(& power_ctrl_lock);
#line 292
  flags = _raw_spin_lock_irqsave(tmp);
#line 293
  dev_priv->display_count = dev_priv->display_count - 1;
#line 294
  __ret_warn_on = dev_priv->display_count < 0;
#line 294
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 294
  if (tmp___0 != 0L) {
#line 294
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.c",
                       294);
  } else {

  }
#line 294
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 295
  spin_unlock_irqrestore(& power_ctrl_lock, flags);
#line 296
  pm_runtime_put(& (dev->pdev)->dev);
#line 297
  return;
}
}
#line 299 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.c"
int psb_runtime_suspend(struct device *dev ) 
{ 
  int tmp ;

  {
#line 301
  tmp = gma_power_suspend(dev);
#line 301
  return (tmp);
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.c"
int psb_runtime_resume(struct device *dev ) 
{ 
  int tmp ;

  {
#line 306
  tmp = gma_power_resume(dev);
#line 306
  return (tmp);
}
}
#line 309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.c"
int psb_runtime_idle(struct device *dev ) 
{ 
  struct drm_device *drmdev ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct drm_psb_private *dev_priv ;

  {
#line 311
  __mptr = (struct device  const  *)dev;
#line 311
  tmp = pci_get_drvdata((struct pci_dev *)__mptr + 0xffffffffffffff68UL);
#line 311
  drmdev = (struct drm_device *)tmp;
#line 312
  dev_priv = (struct drm_psb_private *)drmdev->dev_private;
#line 313
  if (dev_priv->display_count != 0) {
#line 314
    return (0);
  } else {
#line 316
    return (1);
  }
}
}
#line 319 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.c"
int gma_power_thaw(struct device *_dev ) 
{ 
  int tmp ;

  {
#line 321
  tmp = gma_power_resume(_dev);
#line 321
  return (tmp);
}
}
#line 324 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.c"
int gma_power_freeze(struct device *_dev ) 
{ 
  int tmp ;

  {
#line 326
  tmp = gma_power_suspend(_dev);
#line 326
  return (tmp);
}
}
#line 329 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.c"
int gma_power_restore(struct device *_dev ) 
{ 
  int tmp ;

  {
#line 331
  tmp = gma_power_resume(_dev);
#line 331
  return (tmp);
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
bool ldv_queue_work_on_485(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 432
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 432
  ldv_func_res = tmp;
#line 434
  activate_work_2(ldv_func_arg3, 2);
#line 436
  return (ldv_func_res);
}
}
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
bool ldv_queue_delayed_work_on_486(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 443
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 443
  ldv_func_res = tmp;
#line 445
  activate_work_2(& ldv_func_arg3->work, 2);
#line 447
  return (ldv_func_res);
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
bool ldv_queue_work_on_487(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 454
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 454
  ldv_func_res = tmp;
#line 456
  activate_work_2(ldv_func_arg3, 2);
#line 458
  return (ldv_func_res);
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
void ldv_flush_workqueue_488(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 464
  flush_workqueue(ldv_func_arg1);
#line 466
  call_and_disable_all_2(2);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
bool ldv_queue_delayed_work_on_489(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 473
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 473
  ldv_func_res = tmp;
#line 475
  activate_work_2(& ldv_func_arg3->work, 2);
#line 477
  return (ldv_func_res);
}
}
#line 480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
void ldv_mutex_lock_490(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 483
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 485
  mutex_lock(ldv_func_arg1);
#line 486
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
void ldv_mutex_unlock_491(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 491
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 493
  mutex_unlock(ldv_func_arg1);
#line 494
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
void ldv_mutex_lock_492(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 499
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 501
  mutex_lock(ldv_func_arg1);
#line 502
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
int ldv_mutex_trylock_493(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 508
  tmp = mutex_trylock(ldv_func_arg1);
#line 508
  ldv_func_res = tmp;
#line 510
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 510
  return (tmp___0);
#line 512
  return (ldv_func_res);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
void ldv_mutex_unlock_494(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 518
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 520
  mutex_unlock(ldv_func_arg1);
#line 521
  return;
}
}
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
void ldv_mutex_unlock_495(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 526
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 528
  mutex_unlock(ldv_func_arg1);
#line 529
  return;
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
void ldv_mutex_lock_496(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 534
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 536
  mutex_lock(ldv_func_arg1);
#line 537
  return;
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
void ldv_mutex_lock_497(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 542
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 544
  mutex_lock(ldv_func_arg1);
#line 545
  return;
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
void ldv_mutex_unlock_498(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 550
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 552
  mutex_unlock(ldv_func_arg1);
#line 553
  return;
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
void ldv_mutex_unlock_499(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 558
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 560
  mutex_unlock(ldv_func_arg1);
#line 561
  return;
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
void ldv_mutex_lock_500(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 566
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 568
  mutex_lock(ldv_func_arg1);
#line 569
  return;
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
int ldv_mutex_lock_interruptible_501(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 575
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 575
  ldv_func_res = tmp;
#line 577
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 577
  return (tmp___0);
#line 579
  return (ldv_func_res);
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
int ldv_mutex_trylock_502(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 586
  tmp = mutex_trylock(ldv_func_arg1);
#line 586
  ldv_func_res = tmp;
#line 588
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 588
  return (tmp___0);
#line 590
  return (ldv_func_res);
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
void ldv_mutex_unlock_505(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 617
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 619
  mutex_unlock(ldv_func_arg1);
#line 620
  return;
}
}
#line 622 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
void ldv_mutex_lock_506(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 625
  ldv_mutex_lock_power_mutex(ldv_func_arg1);
#line 627
  mutex_lock(ldv_func_arg1);
#line 628
  return;
}
}
#line 630 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
void ldv_mutex_unlock_507(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 633
  ldv_mutex_unlock_power_mutex(ldv_func_arg1);
#line 635
  mutex_unlock(ldv_func_arg1);
#line 636
  return;
}
}
#line 638 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
void ldv_mutex_unlock_508(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 641
  ldv_mutex_unlock_power_mutex(ldv_func_arg1);
#line 643
  mutex_unlock(ldv_func_arg1);
#line 644
  return;
}
}
#line 646 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
void ldv_mutex_lock_509(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 649
  ldv_mutex_lock_power_mutex(ldv_func_arg1);
#line 651
  mutex_lock(ldv_func_arg1);
#line 652
  return;
}
}
#line 654 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.o.c.prepared"
void ldv_mutex_unlock_510(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 657
  ldv_mutex_unlock_power_mutex(ldv_func_arg1);
#line 659
  mutex_unlock(ldv_func_arg1);
#line 660
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_548(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_557(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_546(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_549(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_550(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_553(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_554(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_560(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_mutex_lock_interruptible_556(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_545(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_547(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_551(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_552(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_555(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_540(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_542(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_541(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_544(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_543(struct workqueue_struct *ldv_func_arg1 ) ;
#line 190 "./arch/x86/include/asm/io.h"
__inline static void *ioremap(resource_size_t offset , unsigned long size ) 
{ 
  void *tmp ;

  {
#line 192
  tmp = ioremap_nocache(offset, size);
#line 192
  return (tmp);
}
}
#line 169 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_47  ;
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct fb_var_screeninfo *psbfb_roll_ops_group0  ;
#line 171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_20  ;
#line 172 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct timer_list *ldv_timer_list_4  ;
#line 173 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *cdv_hdmi_connector_funcs_group0  ;
#line 174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int pci_counter  ;
#line 175 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct work_struct *ldv_work_struct_3_1  ;
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct fb_info *psbfb_ops_group0  ;
#line 177 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_encoder *cdv_hdmi_helper_funcs_group0  ;
#line 178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct gma_clock_t *mrst_clock_funcs_group1  ;
#line 179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_device *cdv_chip_ops_group0  ;
#line 180 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_30  ;
#line 181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_0  ;
#line 182 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_45  ;
#line 183 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_12  ;
#line 184 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *oaktrail_hdmi_connector_funcs_group0  ;
#line 185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_22  ;
#line 186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_54  ;
#line 187 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_14  ;
#line 188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_crtc *psb_fb_helper_funcs_group0  ;
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_file *driver_group0  ;
#line 190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_37  ;
#line 191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_29  ;
#line 192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_17  ;
#line 193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_51  ;
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_framebuffer *cdv_intel_helper_funcs_group1  ;
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_device *psb_mode_funcs_group0  ;
#line 196 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct work_struct *ldv_work_struct_2_0  ;
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_19  ;
#line 198 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_encoder *cdv_intel_lvds_helper_funcs_group0  ;
#line 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_27  ;
#line 200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_9  ;
#line 201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct work_struct *ldv_work_struct_2_2  ;
#line 202 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *cdv_intel_dp_connector_funcs_group0  ;
#line 203 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *cdv_hdmi_connector_helper_funcs_group0  ;
#line 204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ref_cnt  ;
#line 205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_42  ;
#line 206 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_encoder *psb_intel_lvds_helper_funcs_group0  ;
#line 207 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_irq_line_1_1  ;
#line 208 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_work_3_3  ;
#line 209 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *cdv_intel_dp_connector_helper_funcs_group0  ;
#line 210 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_7  ;
#line 211 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_encoder *psb_intel_sdvo_helper_funcs_group0  ;
#line 212 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *cdv_intel_crt_connector_helper_funcs_group0  ;
#line 213 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_encoder *cdv_intel_crt_helper_funcs_group0  ;
#line 214 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_23  ;
#line 215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct work_struct *ldv_work_struct_3_3  ;
#line 216 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_crtc *psb_intel_helper_funcs_group0  ;
#line 217 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_55  ;
#line 218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct file *psb_gem_fops_group2  ;
#line 220 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *psb_intel_lvds_connector_funcs_group0  ;
#line 221 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_59  ;
#line 222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct work_struct *ldv_work_struct_2_1  ;
#line 223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct work_struct *ldv_work_struct_3_2  ;
#line 224 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void *ldv_irq_data_1_0  ;
#line 225 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_6  ;
#line 226 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_display_mode *cdv_intel_dp_helper_funcs_group1  ;
#line 227 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void *ldv_irq_data_1_3  ;
#line 228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_50  ;
#line 229 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_crtc *mrst_clock_funcs_group0  ;
#line 230 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_26  ;
#line 231 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_28  ;
#line 232 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_display_mode *oaktrail_lvds_helper_funcs_group1  ;
#line 233 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct device *psb_pm_ops_group1  ;
#line 234 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_44  ;
#line 236 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_38  ;
#line 237 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct inode *psb_gem_fops_group1  ;
#line 239 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_58  ;
#line 240 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_39  ;
#line 241 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_56  ;
#line 242 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_3  ;
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_irq_line_1_0  ;
#line 244 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_crtc *cdv_clock_funcs_group0  ;
#line 245 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_31  ;
#line 246 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_52  ;
#line 247 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *cdv_intel_lvds_connector_helper_funcs_group0  ;
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_crtc *cdv_intel_crtc_funcs_group0  ;
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_4  ;
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_framebuffer *psb_fb_funcs_group0  ;
#line 251 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_display_mode *oaktrail_hdmi_helper_funcs_group1  ;
#line 252 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_work_2_1  ;
#line 253 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_60  ;
#line 254 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_36  ;
#line 255 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_8  ;
#line 256 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_46  ;
#line 257 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_display_mode *psb_intel_sdvo_helper_funcs_group1  ;
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_15  ;
#line 259 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct fb_info *psbfb_roll_ops_group1  ;
#line 260 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_48  ;
#line 261 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct i2c_adapter *psb_intel_sdvo_ddc_proxy_group0  ;
#line 262 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct vm_area_struct *psbfb_vm_ops_group0  ;
#line 263 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_5  ;
#line 264 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_21  ;
#line 265 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_33  ;
#line 266 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_13  ;
#line 267 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_work_3_2  ;
#line 268 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct pci_dev *psb_pci_driver_group1  ;
#line 269 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_display_mode *psb_intel_lvds_helper_funcs_group1  ;
#line 270 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_work_3_0  ;
#line 271 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_encoder *cdv_intel_dp_helper_funcs_group0  ;
#line 272 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct work_struct *ldv_work_struct_2_3  ;
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_49  ;
#line 274 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct gma_clock_t *psb_clock_funcs_group1  ;
#line 275 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_24  ;
#line 276 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *psb_intel_lvds_connector_helper_funcs_group0  ;
#line 278 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_device *driver_group1  ;
#line 279 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_display_mode *cdv_hdmi_helper_funcs_group1  ;
#line 280 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_display_mode *cdv_intel_crt_helper_funcs_group1  ;
#line 281 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_1  ;
#line 282 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_41  ;
#line 283 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_irq_line_1_2  ;
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_40  ;
#line 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_display_mode *psb_intel_helper_funcs_group2  ;
#line 286 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_framebuffer *psb_intel_helper_funcs_group1  ;
#line 287 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *oaktrail_hdmi_connector_helper_funcs_group0  ;
#line 288 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void *ldv_irq_data_1_1  ;
#line 289 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_display_mode *oaktrail_helper_funcs_group2  ;
#line 290 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_10  ;
#line 292 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_encoder *oaktrail_hdmi_helper_funcs_group0  ;
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct fb_info *psbfb_unaccel_ops_group0  ;
#line 294 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct vm_area_struct *psb_gem_vm_ops_group0  ;
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_encoder *oaktrail_lvds_helper_funcs_group0  ;
#line 296 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *cdv_intel_lvds_connector_funcs_group0  ;
#line 297 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_crtc *psb_clock_funcs_group0  ;
#line 298 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct i2c_adapter *i2c_dp_aux_algo_group0  ;
#line 299 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_work_3_1  ;
#line 300 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_16  ;
#line 301 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct i2c_adapter *oaktrail_hdmi_i2c_algorithm_group0  ;
#line 302 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct gma_clock_t *cdv_clock_funcs_group1  ;
#line 303 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_2  ;
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_43  ;
#line 305 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_crtc *oaktrail_helper_funcs_group0  ;
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_25  ;
#line 307 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_work_2_0  ;
#line 308 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_framebuffer *oaktrail_helper_funcs_group1  ;
#line 309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_device *oaktrail_chip_ops_group0  ;
#line 310 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_57  ;
#line 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void *ldv_irq_data_1_2  ;
#line 312 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct i2c_adapter *gmbus_algorithm_group0  ;
#line 313 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_crtc *psb_intel_crtc_funcs_group0  ;
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct work_struct *ldv_work_struct_3_0  ;
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_11  ;
#line 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_crtc *cdv_intel_helper_funcs_group0  ;
#line 318 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_53  ;
#line 319 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *psb_intel_sdvo_connector_funcs_group0  ;
#line 321 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_18  ;
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_irq_line_1_3  ;
#line 323 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_work_2_2  ;
#line 324 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_display_mode *cdv_intel_lvds_helper_funcs_group1  ;
#line 325 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_32  ;
#line 326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_34  ;
#line 327 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_display_mode *cdv_intel_helper_funcs_group2  ;
#line 328 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_work_2_3  ;
#line 329 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_device *psb_chip_ops_group0  ;
#line 330 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *cdv_intel_crt_connector_funcs_group0  ;
#line 331 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_35  ;
#line 332 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *psb_intel_sdvo_connector_helper_funcs_group0  ;
#line 333
void ldv_initialize_drm_connector_helper_funcs_24(void) ;
#line 334
void work_init_3(void) ;
#line 335
void ldv_initialize_drm_encoder_helper_funcs_25(void) ;
#line 336
void ldv_initialize_drm_crtc_helper_funcs_12(void) ;
#line 337
void ldv_initialize_gma_clock_funcs_11(void) ;
#line 338
void ldv_initialize_drm_encoder_helper_funcs_32(void) ;
#line 339
void ldv_initialize_drm_connector_funcs_23(void) ;
#line 343
void ldv_initialize_drm_crtc_funcs_46(void) ;
#line 345
void ldv_initialize_i2c_algorithm_18(void) ;
#line 347
void ldv_initialize_psb_ops_33(void) ;
#line 348
void ldv_dev_pm_ops_52(void) ;
#line 351
void ldv_initialize_drm_connector_funcs_31(void) ;
#line 353
void ldv_initialize_drm_driver_49(void) ;
#line 354
void ldv_file_operations_50(void) ;
#line 355
void ldv_initialize_drm_encoder_helper_funcs_22(void) ;
#line 357
void ldv_initialize_drm_encoder_helper_funcs_44(void) ;
#line 359
void ldv_initialize_drm_encoder_helper_funcs_17(void) ;
#line 360
void ldv_initialize_gma_clock_funcs_45(void) ;
#line 363
void ldv_initialize_drm_connector_funcs_16(void) ;
#line 364
void ldv_initialize_drm_connector_helper_funcs_8(void) ;
#line 365
void ldv_initialize_i2c_algorithm_36(void) ;
#line 366
void ldv_initialize_drm_connector_funcs_39(void) ;
#line 368
void ldv_initialize_drm_connector_helper_funcs_43(void) ;
#line 369
void work_init_2(void) ;
#line 370
void ldv_initialize_vm_operations_struct_51(void) ;
#line 372
void ldv_initialize_psb_ops_35(void) ;
#line 373
void ldv_initialize_drm_crtc_funcs_27(void) ;
#line 375
void ldv_initialize_drm_crtc_helper_funcs_47(void) ;
#line 376
void ldv_initialize_drm_connector_funcs_42(void) ;
#line 377
void ldv_initialize_drm_encoder_helper_funcs_9(void) ;
#line 378
void ldv_initialize_gma_clock_funcs_26(void) ;
#line 380
void ldv_initialize_drm_encoder_helper_funcs_40(void) ;
#line 382
void ldv_initialize_i2c_algorithm_5(void) ;
#line 383
void ldv_initialize_drm_encoder_helper_funcs_10(void) ;
#line 385
void ldv_pci_driver_48(void) ;
#line 390
void ldv_initialize_drm_crtc_helper_funcs_28(void) ;
#line 391
void ldv_initialize_drm_connector_helper_funcs_30(void) ;
#line 393
void ldv_initialize_drm_connector_helper_funcs_15(void) ;
#line 397
void ldv_initialize_drm_connector_funcs_20(void) ;
#line 398
void ldv_initialize_drm_connector_helper_funcs_21(void) ;
#line 400
void ldv_initialize_drm_connector_funcs_7(void) ;
#line 401
void ldv_initialize_drm_connector_helper_funcs_38(void) ;
#line 403
void ldv_initialize_psb_ops_13(void) ;
#line 82 "./arch/x86/include/asm/cacheflush.h"
extern int set_pages_uc(struct page * , int  ) ;
#line 83
extern int set_pages_wb(struct page * , int  ) ;
#line 812 "include/linux/pci.h"
extern void pci_dev_put(struct pci_dev * ) ;
#line 847
extern struct pci_dev *pci_get_domain_bus_and_slot(int  , unsigned int  , unsigned int  ) ;
#line 849 "include/linux/pci.h"
__inline static struct pci_dev *pci_get_bus_and_slot(unsigned int bus , unsigned int devfn ) 
{ 
  struct pci_dev *tmp ;

  {
#line 852
  tmp = pci_get_domain_bus_and_slot(0, bus, devfn);
#line 852
  return (tmp);
}
}
#line 969
extern void pci_set_master(struct pci_dev * ) ;
#line 890 "include/drm/drmP.h"
extern long drm_ioctl(struct file * , unsigned int  , unsigned long  ) ;
#line 897
extern int drm_open(struct inode * , struct file * ) ;
#line 898
extern ssize_t drm_read(struct file * , char * , size_t  , loff_t * ) ;
#line 900
extern int drm_release(struct inode * , struct file * ) ;
#line 903
extern unsigned int drm_poll(struct file * , struct poll_table_struct * ) ;
#line 920
extern int drm_irq_install(struct drm_device * , int  ) ;
#line 923
extern int drm_vblank_init(struct drm_device * , int  ) ;
#line 978
extern void drm_put_dev(struct drm_device * ) ;
#line 1058
extern int drm_pci_init(struct drm_driver * , struct pci_driver * ) ;
#line 1059
extern void drm_pci_exit(struct drm_driver * , struct pci_driver * ) ;
#line 1061
extern int drm_get_pci_dev(struct pci_dev * , struct pci_device_id  const  * , struct drm_driver * ) ;
#line 1064
extern int drm_pci_set_busid(struct drm_device * , struct drm_master * ) ;
#line 231 "include/drm/drm_crtc_helper.h"
extern void drm_kms_helper_poll_init(struct drm_device * ) ;
#line 47 "include/linux/pm_runtime.h"
extern void pm_runtime_allow(struct device * ) ;
#line 130 "include/drm/drm_gem.h"
extern void drm_gem_vm_open(struct vm_area_struct * ) ;
#line 131
extern void drm_gem_vm_close(struct vm_area_struct * ) ;
#line 134
extern int drm_gem_mmap(struct file * , struct vm_area_struct * ) ;
#line 181
extern int drm_gem_dumb_destroy(struct drm_file * , struct drm_device * , uint32_t  ) ;
#line 28 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/opregion.h"
void psb_intel_opregion_fini(struct drm_device *dev ) ;
#line 29
int psb_intel_opregion_setup(struct drm_device *dev ) ;
#line 30
void psb_intel_opregion_enable_asle(struct drm_device *dev ) ;
#line 678 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
irqreturn_t psb_irq_handler(int irq , void *arg ) ;
#line 690
int psb_enable_vblank(struct drm_device *dev , int pipe ) ;
#line 691
void psb_disable_vblank(struct drm_device *dev , int pipe ) ;
#line 698
u32 psb_get_vblank_counter(struct drm_device *dev , int pipe ) ;
#line 758
struct psb_ops  const  psb_chip_ops ;
#line 761
struct psb_ops  const  oaktrail_chip_ops ;
#line 767
struct psb_ops  const  cdv_chip_ops ;
#line 138 "include/drm/drm_fb_helper.h"
extern bool drm_fb_helper_restore_fbdev_mode_unlocked(struct drm_fb_helper * ) ;
#line 28 "include/acpi/video.h"
extern int acpi_video_register(void) ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.c"
static struct drm_driver driver ;
#line 40
static int psb_pci_probe(struct pci_dev *pdev , struct pci_device_id  const  *ent ) ;
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.c"
static struct pci_device_id  const  pciidlist[28U]  = 
#line 57
  {      {32902U, 33032U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& psb_chip_ops)}, 
        {32902U,
      33033U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& psb_chip_ops)}, 
        {32902U,
      16640U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      16641U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      16642U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      16643U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      16644U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      16645U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      16646U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      16647U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      16648U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      3040U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U, 3041U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U,
      3042U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U, 3043U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U,
      3044U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U, 3045U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U,
      3046U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U, 3047U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U,
      3048U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U, 3049U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U,
      3050U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U, 3051U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U,
      3052U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U, 3053U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U,
      3054U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U, 3055U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {0U,
      0U, 0U, 0U, 0U, 0U, 0UL}};
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.c"
struct pci_device_id  const  __mod_pci__pciidlist_device_table[28U]  ;
#line 106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.c"
static struct drm_ioctl_desc  const  psb_ioctls[0U]  = { };
#line 109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.c"
static void psb_driver_lastclose(struct drm_device *dev ) 
{ 
  int ret ;
  struct drm_psb_private *dev_priv ;
  struct psb_fbdev *fbdev ;
  bool tmp ;
  long tmp___0 ;

  {
#line 112
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 113
  fbdev = (struct psb_fbdev *)dev_priv->fbdev;
#line 115
  tmp = drm_fb_helper_restore_fbdev_mode_unlocked(& fbdev->psb_fb_helper);
#line 115
  ret = (int )tmp;
#line 116
  if (ret != 0) {
#line 117
    tmp___0 = ldv__builtin_expect((long )((int )drm_debug) & 1L, 0L);
#line 117
    if (tmp___0 != 0L) {
#line 117
      drm_ut_debug_printk("psb_driver_lastclose", "failed to restore crtc mode\n");
    } else {

    }
  } else {

  }
#line 119
  return;
}
}
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.c"
static int psb_do_init(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_gtt *pg ;
  uint32_t stolen_gtt ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  unsigned int tmp ;

  {
#line 124
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 125
  pg = & dev_priv->gtt;
#line 129
  if ((pg->mmu_gatt_start & 268435455U) != 0U) {
#line 130
    dev_err((struct device  const  *)dev->dev, "Gatt must be 256M aligned. This is a bug.\n");
#line 131
    return (-22);
  } else {

  }
#line 134
  stolen_gtt = (uint32_t )(pg->stolen_size >> 12) * 4U;
#line 135
  stolen_gtt = (uint32_t )(((unsigned long )stolen_gtt + 4095UL) >> 12);
#line 136
  stolen_gtt = stolen_gtt < pg->gtt_pages ? stolen_gtt : pg->gtt_pages;
#line 138
  dev_priv->gatt_free_offset = pg->mmu_gatt_start + stolen_gtt * 4194304U;
#line 141
  spinlock_check(& dev_priv->irqmask_lock);
#line 141
  __raw_spin_lock_init(& dev_priv->irqmask_lock.__annonCompField17.rlock, "&(&dev_priv->irqmask_lock)->rlock",
                       & __key);
#line 142
  spinlock_check(& dev_priv->lock_2d);
#line 142
  __raw_spin_lock_init(& dev_priv->lock_2d.__annonCompField17.rlock, "&(&dev_priv->lock_2d)->rlock",
                       & __key___0);
#line 144
  iowrite32(0U, (void *)dev_priv->sgx_reg + 3192U);
#line 145
  iowrite32(0U, (void *)dev_priv->sgx_reg + 3196U);
#line 146
  ioread32((void *)dev_priv->sgx_reg + 3196U);
#line 149
  tmp = ioread32((void *)dev_priv->sgx_reg + 3072U);
#line 149
  iowrite32(tmp & 4294836479U, (void *)dev_priv->sgx_reg + 3072U);
#line 151
  ioread32((void *)dev_priv->sgx_reg + 3072U);
#line 153
  psb_spank(dev_priv);
#line 156
  iowrite32(pg->gatt_start, (void *)dev_priv->sgx_reg + 3208U);
#line 157
  ioread32((void *)dev_priv->sgx_reg + 3208U);
#line 159
  return (0);
}
}
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.c"
static int psb_driver_unload(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_gtt *pg ;
  struct psb_mmu_pd *tmp ;

  {
#line 164
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 168
  if ((unsigned long )dev_priv != (unsigned long )((struct drm_psb_private *)0)) {
#line 169
    if ((unsigned long )dev_priv->backlight_device != (unsigned long )((struct backlight_device *)0)) {
#line 170
      gma_backlight_exit(dev);
    } else {

    }
#line 171
    psb_modeset_cleanup(dev);
#line 173
    if ((unsigned long )(dev_priv->ops)->chip_teardown != (unsigned long )((void (*/* const  */)(struct drm_device * ))0)) {
#line 174
      (*((dev_priv->ops)->chip_teardown))(dev);
    } else {

    }
#line 176
    psb_intel_opregion_fini(dev);
#line 178
    if ((unsigned long )dev_priv->pf_pd != (unsigned long )((struct psb_mmu_pd *)0)) {
#line 179
      psb_mmu_free_pagedir(dev_priv->pf_pd);
#line 180
      dev_priv->pf_pd = (struct psb_mmu_pd *)0;
    } else {

    }
#line 182
    if ((unsigned long )dev_priv->mmu != (unsigned long )((struct psb_mmu_driver *)0)) {
#line 183
      pg = & dev_priv->gtt;
#line 185
      down_read(& pg->sem);
#line 186
      tmp = psb_mmu_get_default_pd(dev_priv->mmu);
#line 186
      psb_mmu_remove_pfn_sequence(tmp, (unsigned long )pg->mmu_gatt_start, (uint32_t )(dev_priv->vram_stolen_size >> 12));
#line 191
      up_read(& pg->sem);
#line 192
      psb_mmu_driver_takedown(dev_priv->mmu);
#line 193
      dev_priv->mmu = (struct psb_mmu_driver *)0;
    } else {

    }
#line 195
    psb_gtt_takedown(dev);
#line 196
    if ((unsigned long )dev_priv->scratch_page != (unsigned long )((struct page *)0)) {
#line 197
      set_pages_wb(dev_priv->scratch_page, 1);
#line 198
      __free_pages(dev_priv->scratch_page, 0U);
#line 199
      dev_priv->scratch_page = (struct page *)0;
    } else {

    }
#line 201
    if ((unsigned long )dev_priv->vdc_reg != (unsigned long )((uint8_t *)0U)) {
#line 202
      iounmap((void volatile   *)dev_priv->vdc_reg);
#line 203
      dev_priv->vdc_reg = (uint8_t *)0U;
    } else {

    }
#line 205
    if ((unsigned long )dev_priv->sgx_reg != (unsigned long )((uint8_t *)0U)) {
#line 206
      iounmap((void volatile   *)dev_priv->sgx_reg);
#line 207
      dev_priv->sgx_reg = (uint8_t *)0U;
    } else {

    }
#line 209
    if ((unsigned long )dev_priv->aux_reg != (unsigned long )((uint8_t *)0U)) {
#line 210
      iounmap((void volatile   *)dev_priv->aux_reg);
#line 211
      dev_priv->aux_reg = (uint8_t *)0U;
    } else {

    }
#line 213
    if ((unsigned long )dev_priv->aux_pdev != (unsigned long )((struct pci_dev *)0)) {
#line 214
      pci_dev_put(dev_priv->aux_pdev);
    } else {

    }
#line 215
    if ((unsigned long )dev_priv->lpc_pdev != (unsigned long )((struct pci_dev *)0)) {
#line 216
      pci_dev_put(dev_priv->lpc_pdev);
    } else {

    }
#line 219
    psb_intel_destroy_bios(dev);
#line 221
    kfree((void const   *)dev_priv);
#line 222
    dev->dev_private = (void *)0;
  } else {

  }
#line 224
  gma_power_uninit(dev);
#line 225
  return (0);
}
}
#line 228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.c"
static int psb_driver_load(struct drm_device *dev , unsigned long flags ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned long resource_start ;
  unsigned long resource_len ;
  unsigned long irqflags ;
  int ret ;
  struct drm_connector *connector ;
  struct gma_encoder *gma_encoder ;
  struct psb_gtt *pg ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  struct psb_mmu_pd *tmp___6 ;
  struct psb_mmu_pd *tmp___7 ;
  raw_spinlock_t *tmp___8 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 233
  ret = -12;
#line 239
  tmp = kzalloc(5176UL, 208U);
#line 239
  dev_priv = (struct drm_psb_private *)tmp;
#line 240
  if ((unsigned long )dev_priv == (unsigned long )((struct drm_psb_private *)0)) {
#line 241
    return (-12);
  } else {

  }
#line 243
  dev_priv->ops = (struct psb_ops  const  *)flags;
#line 244
  dev_priv->dev = dev;
#line 245
  dev->dev_private = (void *)dev_priv;
#line 247
  pg = & dev_priv->gtt;
#line 249
  pci_set_master(dev->pdev);
#line 251
  dev_priv->num_pipe = (uint32_t )(dev_priv->ops)->pipes;
#line 253
  resource_start = (unsigned long )(dev->pdev)->resource[0].start;
#line 255
  tmp___0 = ioremap((resource_size_t )resource_start, 524288UL);
#line 255
  dev_priv->vdc_reg = (uint8_t *)tmp___0;
#line 257
  if ((unsigned long )dev_priv->vdc_reg == (unsigned long )((uint8_t *)0U)) {
#line 258
    goto out_err;
  } else {

  }
#line 260
  tmp___1 = ioremap((resource_size_t )((unsigned long )(dev_priv->ops)->sgx_offset + resource_start),
                    32768UL);
#line 260
  dev_priv->sgx_reg = (uint8_t *)tmp___1;
#line 262
  if ((unsigned long )dev_priv->sgx_reg == (unsigned long )((uint8_t *)0U)) {
#line 263
    goto out_err;
  } else {

  }
#line 265
  if (((int )(dev->pdev)->device & 65520) == 16640) {
#line 266
    dev_priv->aux_pdev = pci_get_bus_and_slot(0U, 24U);
#line 268
    if ((unsigned long )dev_priv->aux_pdev != (unsigned long )((struct pci_dev *)0)) {
#line 269
      resource_start = (unsigned long )(dev_priv->aux_pdev)->resource[0].start;
#line 271
      resource_len = (dev_priv->aux_pdev)->resource[0].start != 0ULL || (dev_priv->aux_pdev)->resource[0].end != (dev_priv->aux_pdev)->resource[0].start ? (unsigned long )(((dev_priv->aux_pdev)->resource[0].end - (dev_priv->aux_pdev)->resource[0].start) + 1ULL) : 0UL;
#line 273
      tmp___2 = ioremap_nocache((resource_size_t )resource_start, resource_len);
#line 273
      dev_priv->aux_reg = (uint8_t *)tmp___2;
#line 275
      if ((unsigned long )dev_priv->aux_reg == (unsigned long )((uint8_t *)0U)) {
#line 276
        goto out_err;
      } else {

      }
#line 278
      tmp___3 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 278
      if (tmp___3 != 0L) {
#line 278
        drm_ut_debug_printk("psb_driver_load", "Found aux vdc");
      } else {

      }
    } else {
#line 281
      dev_priv->aux_reg = dev_priv->vdc_reg;
#line 282
      tmp___4 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 282
      if (tmp___4 != 0L) {
#line 282
        drm_ut_debug_printk("psb_driver_load", "Couldn\'t find aux pci device");
      } else {

      }
    }
#line 284
    dev_priv->gmbus_reg = dev_priv->aux_reg;
#line 286
    dev_priv->lpc_pdev = pci_get_bus_and_slot(0U, 248U);
#line 287
    if ((unsigned long )dev_priv->lpc_pdev != (unsigned long )((struct pci_dev *)0)) {
#line 288
      pci_read_config_word((struct pci_dev  const  *)dev_priv->lpc_pdev, 68, & dev_priv->lpc_gpio_base);
#line 290
      pci_write_config_dword((struct pci_dev  const  *)dev_priv->lpc_pdev, 68, (u32 )dev_priv->lpc_gpio_base | 2147483648U);
#line 292
      pci_read_config_word((struct pci_dev  const  *)dev_priv->lpc_pdev, 68, & dev_priv->lpc_gpio_base);
#line 294
      dev_priv->lpc_gpio_base = (unsigned int )dev_priv->lpc_gpio_base & 65472U;
#line 295
      if ((unsigned int )dev_priv->lpc_gpio_base != 0U) {
#line 296
        tmp___5 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 296
        if (tmp___5 != 0L) {
#line 296
          drm_ut_debug_printk("psb_driver_load", "Found LPC GPIO at 0x%04x\n", (int )dev_priv->lpc_gpio_base);
        } else {

        }
      } else {
#line 299
        pci_dev_put(dev_priv->lpc_pdev);
#line 300
        dev_priv->lpc_pdev = (struct pci_dev *)0;
      }
    } else {

    }
  } else {
#line 304
    dev_priv->gmbus_reg = dev_priv->vdc_reg;
  }
#line 307
  psb_intel_opregion_setup(dev);
#line 309
  ret = (*((dev_priv->ops)->chip_setup))(dev);
#line 310
  if (ret != 0) {
#line 311
    goto out_err;
  } else {

  }
#line 314
  gma_power_init(dev);
#line 316
  ret = -12;
#line 318
  dev_priv->scratch_page = alloc_pages(32772U, 0U);
#line 319
  if ((unsigned long )dev_priv->scratch_page == (unsigned long )((struct page *)0)) {
#line 320
    goto out_err;
  } else {

  }
#line 322
  set_pages_uc(dev_priv->scratch_page, 1);
#line 324
  ret = psb_gtt_init(dev, 0);
#line 325
  if (ret != 0) {
#line 326
    goto out_err;
  } else {

  }
#line 328
  dev_priv->mmu = psb_mmu_driver_init(dev, 1, 0, (atomic_t *)0);
#line 329
  if ((unsigned long )dev_priv->mmu == (unsigned long )((struct psb_mmu_driver *)0)) {
#line 330
    goto out_err;
  } else {

  }
#line 332
  dev_priv->pf_pd = psb_mmu_alloc_pd(dev_priv->mmu, 1, 0);
#line 333
  if ((unsigned long )dev_priv->pf_pd == (unsigned long )((struct psb_mmu_pd *)0)) {
#line 334
    goto out_err;
  } else {

  }
#line 336
  ret = psb_do_init(dev);
#line 337
  if (ret != 0) {
#line 338
    return (ret);
  } else {

  }
#line 341
  down_read(& pg->sem);
#line 342
  tmp___6 = psb_mmu_get_default_pd(dev_priv->mmu);
#line 342
  ret = psb_mmu_insert_pfn_sequence(tmp___6, dev_priv->stolen_base >> 12, (unsigned long )pg->gatt_start,
                                    (uint32_t )(pg->stolen_size >> 12), 0);
#line 346
  up_read(& pg->sem);
#line 348
  tmp___7 = psb_mmu_get_default_pd(dev_priv->mmu);
#line 348
  psb_mmu_set_pd_context(tmp___7, 0);
#line 349
  psb_mmu_set_pd_context(dev_priv->pf_pd, 1);
#line 351
  iowrite32(536870912U, (void *)dev_priv->sgx_reg + 2744U);
#line 352
  iowrite32(805306368U, (void *)dev_priv->sgx_reg + 3244U);
#line 354
  acpi_video_register();
#line 357
  ret = drm_vblank_init(dev, (int )dev_priv->num_pipe);
#line 358
  if (ret != 0) {
#line 359
    goto out_err;
  } else {

  }
#line 365
  dev_priv->vdc_irq_mask = 0U;
#line 366
  dev_priv->pipestat[0] = 0U;
#line 367
  dev_priv->pipestat[1] = 0U;
#line 368
  dev_priv->pipestat[2] = 0U;
#line 369
  tmp___8 = spinlock_check(& dev_priv->irqmask_lock);
#line 369
  irqflags = _raw_spin_lock_irqsave(tmp___8);
#line 370
  iowrite32(4294967295U, (void *)dev_priv->vdc_reg + 8344U);
#line 371
  iowrite32(0U, (void *)dev_priv->vdc_reg + 8352U);
#line 372
  iowrite32(4294967295U, (void *)dev_priv->vdc_reg + 8360U);
#line 373
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
#line 375
  drm_irq_install(dev, (int )(dev->pdev)->irq);
#line 377
  dev->vblank_disable_allowed = 1;
#line 378
  dev->max_vblank_count = 16777215U;
#line 379
  (dev->driver)->get_vblank_counter = & psb_get_vblank_counter;
#line 381
  psb_modeset_init(dev);
#line 382
  psb_fbdev_init(dev);
#line 383
  drm_kms_helper_poll_init(dev);
#line 386
  __mptr = (struct list_head  const  *)dev->mode_config.connector_list.next;
#line 386
  connector = (struct drm_connector *)__mptr + 0xffffffffffffffe8UL;
#line 386
  goto ldv_42242;
  ldv_42241: 
#line 388
  gma_encoder = gma_attached_encoder(connector);
#line 390
  switch (gma_encoder->type) {
  case 4: ;
  case 7: 
#line 393
  ret = gma_backlight_init(dev);
#line 394
  goto ldv_42240;
  }
  ldv_42240: 
#line 386
  __mptr___0 = (struct list_head  const  *)connector->head.next;
#line 386
  connector = (struct drm_connector *)__mptr___0 + 0xffffffffffffffe8UL;
  ldv_42242: ;
#line 386
  if ((unsigned long )(& connector->head) != (unsigned long )(& dev->mode_config.connector_list)) {
#line 388
    goto ldv_42241;
  } else {

  }

#line 398
  if (ret != 0) {
#line 399
    return (ret);
  } else {

  }
#line 400
  psb_intel_opregion_enable_asle(dev);
#line 407
  return (0);
  out_err: 
#line 409
  psb_driver_unload(dev);
#line 410
  return (ret);
}
}
#line 413 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.c"
static int psb_driver_device_is_agp(struct drm_device *dev ) 
{ 


  {
#line 415
  return (0);
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.c"
static long psb_unlocked_ioctl(struct file *filp , unsigned int cmd , unsigned long arg ) 
{ 
  struct drm_file *file_priv ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  unsigned int runtime_allowed ;
  long tmp ;

  {
#line 431
  file_priv = (struct drm_file *)filp->private_data;
#line 432
  dev = (file_priv->minor)->dev;
#line 433
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 436
  if (runtime_allowed == 1U && (int )dev_priv->is_lvds_on) {
#line 437
    runtime_allowed = runtime_allowed + 1U;
#line 438
    pm_runtime_allow(& (dev->pdev)->dev);
#line 439
    dev_priv->rpm_enabled = 1;
  } else {

  }
#line 441
  tmp = drm_ioctl(filp, cmd, arg);
#line 441
  return (tmp);
}
}
#line 449 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.c"
static void psb_driver_preclose(struct drm_device *dev , struct drm_file *priv ) 
{ 


  {
#line 451
  return;
}
}
#line 453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.c"
static int psb_pci_probe(struct pci_dev *pdev , struct pci_device_id  const  *ent ) 
{ 
  int tmp ;

  {
#line 455
  tmp = drm_get_pci_dev(pdev, ent, & driver);
#line 455
  return (tmp);
}
}
#line 459 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.c"
static void psb_pci_remove(struct pci_dev *pdev ) 
{ 
  struct drm_device *dev ;
  void *tmp ;

  {
#line 461
  tmp = pci_get_drvdata(pdev);
#line 461
  dev = (struct drm_device *)tmp;
#line 462
  drm_put_dev(dev);
#line 463
  return;
}
}
#line 465 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.c"
static struct dev_pm_ops  const  psb_pm_ops  = 
#line 465
     {0, 0, & gma_power_suspend, & gma_power_resume, & gma_power_freeze, & gma_power_thaw,
    0, & gma_power_restore, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & psb_runtime_suspend,
    & psb_runtime_resume, & psb_runtime_idle};
#line 476 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.c"
static struct vm_operations_struct  const  psb_gem_vm_ops  = 
#line 476
     {& drm_gem_vm_open, & drm_gem_vm_close, & psb_gem_fault, 0, 0, 0, 0, 0, 0, 0, 0};
#line 482 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.c"
static struct file_operations  const  psb_gem_fops  = 
#line 482
     {& __this_module, 0, & drm_read, 0, 0, 0, 0, & drm_poll, & psb_unlocked_ioctl,
    0, & drm_gem_mmap, 0, & drm_open, 0, & drm_release, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0};
#line 492 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.c"
static struct drm_driver driver  = 
#line 492
     {& psb_driver_load, 0, 0, & psb_driver_preclose, 0, & psb_driver_lastclose, & psb_driver_unload,
    0, 0, 0, 0, 0, & drm_pci_set_busid, & psb_get_vblank_counter, & psb_enable_vblank,
    & psb_disable_vblank, & psb_driver_device_is_agp, 0, 0, & psb_irq_handler, & psb_irq_preinstall,
    & psb_irq_postinstall, & psb_irq_uninstall, 0, 0, 0, 0, 0, 0, & psb_gem_free_object,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & psb_gem_dumb_create, & psb_gem_dumb_map_gtt,
    & drm_gem_dumb_destroy, & psb_gem_vm_ops, 1, 0, 0, (char *)"gma500", (char *)"DRM driver for the Intel GMA500, GMA600, GMA3600, GMA3650",
    (char *)"20140314", 12480U, 0, (struct drm_ioctl_desc  const  *)(& psb_ioctls),
    0, & psb_gem_fops, {0, 0}};
#line 527 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.c"
static struct pci_driver psb_pci_driver  = 
#line 527
     {{0, 0}, "gma500", (struct pci_device_id  const  *)(& pciidlist), & psb_pci_probe,
    & psb_pci_remove, 0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0,
                                            0, 0, 0, & psb_pm_ops, 0}, {{{{{{0}},
                                                                           0U, 0U,
                                                                           0, {0,
                                                                               {0,
                                                                                0},
                                                                               0,
                                                                               0,
                                                                               0UL}}}},
                                                                        {0, 0}}};
#line 535 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.c"
static int psb_init(void) 
{ 
  int tmp ;

  {
#line 537
  tmp = drm_pci_init(& driver, & psb_pci_driver);
#line 537
  return (tmp);
}
}
#line 540 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.c"
static void psb_exit(void) 
{ 


  {
#line 542
  drm_pci_exit(& driver, & psb_pci_driver);
#line 543
  return;
}
}
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_20  ;
#line 406
extern int ldv_shutdown_48(void) ;
#line 407
extern int ldv_thaw_early_52(void) ;
#line 408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_18  ;
#line 409 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_2  ;
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_5  ;
#line 411 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_0  ;
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_23  ;
#line 413 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_11  ;
#line 414 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_1  ;
#line 415
extern int ldv_suspend_late_52(void) ;
#line 416 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_22  ;
#line 417 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_15  ;
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_16  ;
#line 419
extern int ldv_restore_noirq_52(void) ;
#line 420
extern int ldv_suspend_noirq_52(void) ;
#line 421
void ldv_check_final_state(void) ;
#line 422 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_8  ;
#line 423
extern int ldv_complete_52(void) ;
#line 424 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_7  ;
#line 425 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_19  ;
#line 426
extern int ldv_resume_noirq_52(void) ;
#line 427 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_14  ;
#line 428
extern int ldv_poweroff_noirq_52(void) ;
#line 429 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_17  ;
#line 430 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_12  ;
#line 431
extern int ldv_thaw_noirq_52(void) ;
#line 432
extern int ldv_resume_early_52(void) ;
#line 433
extern void ldv_initialize(void) ;
#line 434 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_6  ;
#line 435
extern int ldv_poweroff_52(void) ;
#line 436 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_21  ;
#line 437
extern int ldv_prepare_52(void) ;
#line 438
extern int ldv_poweroff_late_52(void) ;
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_13  ;
#line 440
extern int ldv_freeze_late_52(void) ;
#line 441 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_9  ;
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_10  ;
#line 443
extern int ldv_restore_early_52(void) ;
#line 444
extern int ldv_freeze_noirq_52(void) ;
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_4  ;
#line 446 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_3  ;
#line 449 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void ldv_dev_pm_ops_52(void) 
{ 
  void *tmp ;

  {
#line 450
  tmp = ldv_init_zalloc(1416UL);
#line 450
  psb_pm_ops_group1 = (struct device *)tmp;
#line 451
  return;
}
}
#line 454 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void ldv_initialize_drm_driver_49(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 455
  tmp = ldv_init_zalloc(744UL);
#line 455
  driver_group0 = (struct drm_file *)tmp;
#line 456
  tmp___0 = ldv_init_zalloc(3320UL);
#line 456
  driver_group1 = (struct drm_device *)tmp___0;
#line 457
  return;
}
}
#line 459 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void ldv_file_operations_50(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 460
  tmp = ldv_init_zalloc(1000UL);
#line 460
  psb_gem_fops_group1 = (struct inode *)tmp;
#line 461
  tmp___0 = ldv_init_zalloc(504UL);
#line 461
  psb_gem_fops_group2 = (struct file *)tmp___0;
#line 462
  return;
}
}
#line 465 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void ldv_initialize_vm_operations_struct_51(void) 
{ 
  void *tmp ;

  {
#line 466
  tmp = ldv_init_zalloc(184UL);
#line 466
  psb_gem_vm_ops_group0 = (struct vm_area_struct *)tmp;
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void ldv_pci_driver_48(void) 
{ 
  void *tmp ;

  {
#line 470
  tmp = ldv_init_zalloc(2976UL);
#line 470
  psb_pci_driver_group1 = (struct pci_dev *)tmp;
#line 471
  return;
}
}
#line 476
void ldv_main_exported_27(void) ;
#line 477
void ldv_main_exported_28(void) ;
#line 478
void ldv_main_exported_26(void) ;
#line 479
void ldv_main_exported_38(void) ;
#line 480
void ldv_main_exported_39(void) ;
#line 481
void ldv_main_exported_40(void) ;
#line 482
void ldv_main_exported_36(void) ;
#line 483
void ldv_main_exported_37(void) ;
#line 484
void ldv_main_exported_5(void) ;
#line 485
void ldv_main_exported_18(void) ;
#line 486
void ldv_main_exported_16(void) ;
#line 487
void ldv_main_exported_17(void) ;
#line 488
void ldv_main_exported_15(void) ;
#line 489
void ldv_main_exported_14(void) ;
#line 490
void ldv_main_exported_46(void) ;
#line 491
void ldv_main_exported_45(void) ;
#line 492
void ldv_main_exported_47(void) ;
#line 493
void ldv_main_exported_34(void) ;
#line 494
void ldv_main_exported_8(void) ;
#line 495
void ldv_main_exported_6(void) ;
#line 496
void ldv_main_exported_7(void) ;
#line 497
void ldv_main_exported_9(void) ;
#line 498
void ldv_main_exported_13(void) ;
#line 499
void ldv_main_exported_10(void) ;
#line 500
void ldv_main_exported_42(void) ;
#line 501
void ldv_main_exported_43(void) ;
#line 502
void ldv_main_exported_44(void) ;
#line 503
void ldv_main_exported_41(void) ;
#line 512
void ldv_main_exported_11(void) ;
#line 513
void ldv_main_exported_12(void) ;
#line 514
void ldv_main_exported_22(void) ;
#line 515
void ldv_main_exported_21(void) ;
#line 516
void ldv_main_exported_19(void) ;
#line 517
void ldv_main_exported_20(void) ;
#line 518
void ldv_main_exported_35(void) ;
#line 519
void ldv_main_exported_25(void) ;
#line 520
void ldv_main_exported_24(void) ;
#line 521
void ldv_main_exported_23(void) ;
#line 528
void ldv_main_exported_33(void) ;
#line 529
void ldv_main_exported_32(void) ;
#line 530
void ldv_main_exported_30(void) ;
#line 531
void ldv_main_exported_31(void) ;
#line 532
void ldv_main_exported_29(void) ;
#line 536 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int main(void) 
{ 
  int ldvarg85 ;
  int ldvarg84 ;
  int ldvarg94 ;
  struct drm_gem_object *ldvarg91 ;
  void *tmp ;
  struct drm_master *ldvarg88 ;
  void *tmp___0 ;
  unsigned long ldvarg90 ;
  struct drm_mode_create_dumb *ldvarg87 ;
  void *tmp___1 ;
  void *ldvarg86 ;
  void *tmp___2 ;
  uint32_t ldvarg93 ;
  uint64_t *ldvarg92 ;
  void *tmp___3 ;
  uint32_t ldvarg89 ;
  int ldvarg83 ;
  struct pci_device_id *ldvarg110 ;
  void *tmp___4 ;
  size_t ldvarg145 ;
  struct poll_table_struct *ldvarg143 ;
  void *tmp___5 ;
  unsigned long ldvarg140 ;
  char *ldvarg146 ;
  void *tmp___6 ;
  loff_t *ldvarg144 ;
  void *tmp___7 ;
  struct vm_area_struct *ldvarg142 ;
  void *tmp___8 ;
  unsigned int ldvarg141 ;
  struct vm_fault *ldvarg155 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 542
  tmp = ldv_init_zalloc(248UL);
#line 542
  ldvarg91 = (struct drm_gem_object *)tmp;
#line 543
  tmp___0 = ldv_init_zalloc(352UL);
#line 543
  ldvarg88 = (struct drm_master *)tmp___0;
#line 545
  tmp___1 = ldv_init_zalloc(32UL);
#line 545
  ldvarg87 = (struct drm_mode_create_dumb *)tmp___1;
#line 546
  tmp___2 = ldv_init_zalloc(1UL);
#line 546
  ldvarg86 = tmp___2;
#line 548
  tmp___3 = ldv_init_zalloc(8UL);
#line 548
  ldvarg92 = (uint64_t *)tmp___3;
#line 551
  tmp___4 = ldv_init_zalloc(32UL);
#line 551
  ldvarg110 = (struct pci_device_id *)tmp___4;
#line 553
  tmp___5 = ldv_init_zalloc(16UL);
#line 553
  ldvarg143 = (struct poll_table_struct *)tmp___5;
#line 555
  tmp___6 = ldv_init_zalloc(1UL);
#line 555
  ldvarg146 = (char *)tmp___6;
#line 556
  tmp___7 = ldv_init_zalloc(8UL);
#line 556
  ldvarg144 = (loff_t *)tmp___7;
#line 557
  tmp___8 = ldv_init_zalloc(184UL);
#line 557
  ldvarg142 = (struct vm_area_struct *)tmp___8;
#line 559
  tmp___9 = ldv_init_zalloc(56UL);
#line 559
  ldvarg155 = (struct vm_fault *)tmp___9;
#line 537
  ldv_initialize();
#line 539
  ldv_memset((void *)(& ldvarg85), 0, 4UL);
#line 540
  ldv_memset((void *)(& ldvarg84), 0, 4UL);
#line 541
  ldv_memset((void *)(& ldvarg94), 0, 4UL);
#line 544
  ldv_memset((void *)(& ldvarg90), 0, 8UL);
#line 547
  ldv_memset((void *)(& ldvarg93), 0, 4UL);
#line 549
  ldv_memset((void *)(& ldvarg89), 0, 4UL);
#line 550
  ldv_memset((void *)(& ldvarg83), 0, 4UL);
#line 552
  ldv_memset((void *)(& ldvarg145), 0, 8UL);
#line 554
  ldv_memset((void *)(& ldvarg140), 0, 8UL);
#line 558
  ldv_memset((void *)(& ldvarg141), 0, 4UL);
#line 561
  ldv_state_variable_33 = 0;
#line 562
  ldv_state_variable_32 = 0;
#line 563
  ldv_state_variable_21 = 0;
#line 564
  ldv_state_variable_7 = 0;
#line 565
  ldv_state_variable_26 = 0;
#line 566
  ldv_state_variable_17 = 0;
#line 568
  work_init_2();
#line 570
  ldv_state_variable_2 = 1;
#line 572
  ldv_state_variable_1 = 1;
#line 573
  ldv_state_variable_18 = 0;
#line 574
  ldv_state_variable_30 = 0;
#line 575
  ldv_state_variable_16 = 0;
#line 576
  ldv_state_variable_44 = 0;
#line 577
  ldv_state_variable_55 = 0;
#line 578
  ldv_state_variable_27 = 0;
#line 579
  ldv_state_variable_25 = 0;
#line 580
  ldv_state_variable_28 = 0;
#line 581
  ldv_state_variable_57 = 0;
#line 582
  ldv_state_variable_40 = 0;
#line 583
  ldv_state_variable_20 = 0;
#line 584
  ldv_state_variable_14 = 0;
#line 585
  ldv_state_variable_59 = 0;
#line 586
  ldv_state_variable_49 = 0;
#line 587
  ldv_state_variable_24 = 0;
#line 588
  ldv_state_variable_10 = 0;
#line 589
  ldv_state_variable_31 = 0;
#line 590
  ldv_state_variable_35 = 0;
#line 591
  ldv_state_variable_11 = 0;
#line 592
  ldv_state_variable_53 = 0;
#line 593
  ldv_state_variable_48 = 0;
#line 594
  ldv_state_variable_42 = 0;
#line 595
  ldv_state_variable_22 = 0;
#line 596
  ref_cnt = 0;
#line 597
  ldv_state_variable_0 = 1;
#line 598
  ldv_state_variable_46 = 0;
#line 599
  ldv_state_variable_13 = 0;
#line 600
  ldv_state_variable_23 = 0;
#line 601
  ldv_state_variable_29 = 0;
#line 602
  ldv_state_variable_6 = 0;
#line 603
  ldv_state_variable_50 = 0;
#line 604
  ldv_state_variable_39 = 0;
#line 605
  ldv_state_variable_36 = 0;
#line 607
  work_init_3();
#line 609
  ldv_state_variable_3 = 1;
#line 610
  ldv_state_variable_51 = 0;
#line 611
  ldv_state_variable_9 = 0;
#line 612
  ldv_state_variable_58 = 0;
#line 613
  ldv_state_variable_41 = 0;
#line 614
  ldv_state_variable_12 = 0;
#line 615
  ldv_state_variable_47 = 0;
#line 616
  ldv_state_variable_15 = 0;
#line 617
  ldv_state_variable_52 = 0;
#line 618
  ldv_state_variable_38 = 0;
#line 619
  ldv_state_variable_8 = 0;
#line 620
  ldv_state_variable_60 = 0;
#line 622
  ldv_state_variable_4 = 1;
#line 623
  ldv_state_variable_34 = 0;
#line 624
  ldv_state_variable_56 = 0;
#line 625
  ldv_state_variable_45 = 0;
#line 626
  ldv_state_variable_37 = 0;
#line 627
  ldv_state_variable_43 = 0;
#line 628
  ldv_state_variable_19 = 0;
#line 629
  ldv_state_variable_54 = 0;
#line 630
  ldv_state_variable_5 = 0;
  ldv_42642: 
#line 632
  tmp___10 = __VERIFIER_nondet_int();
#line 632
  switch (tmp___10) {
  case 0: ;
#line 636
  if (ldv_state_variable_33 != 0) {
#line 637
    ldv_main_exported_33();
  } else {

  }
#line 640
  goto ldv_42513;
  case 1: ;
#line 644
  if (ldv_state_variable_32 != 0) {
#line 645
    ldv_main_exported_32();
  } else {

  }
#line 648
  goto ldv_42513;
  case 2: ;
#line 652
  if (ldv_state_variable_21 != 0) {
#line 653
    ldv_main_exported_21();
  } else {

  }
#line 656
  goto ldv_42513;
  case 3: ;
#line 660
  if (ldv_state_variable_7 != 0) {
#line 661
    ldv_main_exported_7();
  } else {

  }
#line 664
  goto ldv_42513;
  case 4: ;
#line 668
  if (ldv_state_variable_26 != 0) {
#line 669
    ldv_main_exported_26();
  } else {

  }
#line 672
  goto ldv_42513;
  case 5: ;
#line 676
  if (ldv_state_variable_17 != 0) {
#line 677
    ldv_main_exported_17();
  } else {

  }
#line 680
  goto ldv_42513;
  case 6: ;
#line 687
  goto ldv_42513;
  case 7: ;
#line 694
  goto ldv_42513;
  case 8: ;
#line 698
  if (ldv_state_variable_18 != 0) {
#line 699
    ldv_main_exported_18();
  } else {

  }
#line 702
  goto ldv_42513;
  case 9: ;
#line 706
  if (ldv_state_variable_30 != 0) {
#line 707
    ldv_main_exported_30();
  } else {

  }
#line 710
  goto ldv_42513;
  case 10: ;
#line 714
  if (ldv_state_variable_16 != 0) {
#line 715
    ldv_main_exported_16();
  } else {

  }
#line 718
  goto ldv_42513;
  case 11: ;
#line 722
  if (ldv_state_variable_44 != 0) {
#line 723
    ldv_main_exported_44();
  } else {

  }
#line 726
  goto ldv_42513;
  case 12: ;
#line 730
  if (ldv_state_variable_55 != 0) {
#line 731
    ldv_main_exported_55();
  } else {

  }
#line 734
  goto ldv_42513;
  case 13: ;
#line 738
  if (ldv_state_variable_27 != 0) {
#line 739
    ldv_main_exported_27();
  } else {

  }
#line 742
  goto ldv_42513;
  case 14: ;
#line 746
  if (ldv_state_variable_25 != 0) {
#line 747
    ldv_main_exported_25();
  } else {

  }
#line 750
  goto ldv_42513;
  case 15: ;
#line 754
  if (ldv_state_variable_28 != 0) {
#line 755
    ldv_main_exported_28();
  } else {

  }
#line 758
  goto ldv_42513;
  case 16: ;
#line 762
  if (ldv_state_variable_57 != 0) {
#line 763
    ldv_main_exported_57();
  } else {

  }
#line 766
  goto ldv_42513;
  case 17: ;
#line 770
  if (ldv_state_variable_40 != 0) {
#line 771
    ldv_main_exported_40();
  } else {

  }
#line 774
  goto ldv_42513;
  case 18: ;
#line 778
  if (ldv_state_variable_20 != 0) {
#line 779
    ldv_main_exported_20();
  } else {

  }
#line 782
  goto ldv_42513;
  case 19: ;
#line 786
  if (ldv_state_variable_14 != 0) {
#line 787
    ldv_main_exported_14();
  } else {

  }
#line 790
  goto ldv_42513;
  case 20: ;
#line 794
  if (ldv_state_variable_59 != 0) {
#line 795
    ldv_main_exported_59();
  } else {

  }
#line 798
  goto ldv_42513;
  case 21: ;
#line 802
  if (ldv_state_variable_49 != 0) {
#line 803
    tmp___11 = __VERIFIER_nondet_int();
#line 803
    switch (tmp___11) {
    case 0: ;
#line 806
    if (ldv_state_variable_49 == 1) {
#line 808
      psb_driver_lastclose(driver_group1);
#line 810
      ldv_state_variable_49 = 1;
    } else {

    }
#line 813
    goto ldv_42536;
    case 1: ;
#line 816
    if (ldv_state_variable_49 == 1) {
#line 818
      psb_get_vblank_counter(driver_group1, ldvarg94);
#line 820
      ldv_state_variable_49 = 1;
    } else {

    }
#line 823
    goto ldv_42536;
    case 2: ;
#line 826
    if (ldv_state_variable_49 == 1) {
#line 828
      psb_gem_dumb_map_gtt(driver_group0, driver_group1, ldvarg93, ldvarg92);
#line 830
      ldv_state_variable_49 = 1;
    } else {

    }
#line 833
    goto ldv_42536;
    case 3: ;
#line 836
    if (ldv_state_variable_49 == 1) {
#line 838
      psb_gem_free_object(ldvarg91);
#line 840
      ldv_state_variable_49 = 1;
    } else {

    }
#line 843
    goto ldv_42536;
    case 4: ;
#line 846
    if (ldv_state_variable_49 == 1) {
#line 848
      psb_driver_unload(driver_group1);
#line 850
      ldv_state_variable_49 = 1;
    } else {

    }
#line 853
    goto ldv_42536;
    case 5: ;
#line 856
    if (ldv_state_variable_49 == 1) {
#line 858
      psb_irq_preinstall(driver_group1);
#line 860
      ldv_state_variable_49 = 1;
    } else {

    }
#line 863
    goto ldv_42536;
    case 6: ;
#line 866
    if (ldv_state_variable_49 == 1) {
#line 868
      psb_driver_load(driver_group1, ldvarg90);
#line 870
      ldv_state_variable_49 = 1;
    } else {

    }
#line 873
    goto ldv_42536;
    case 7: ;
#line 876
    if (ldv_state_variable_49 == 1) {
#line 878
      psb_irq_uninstall(driver_group1);
#line 880
      ldv_state_variable_49 = 1;
    } else {

    }
#line 883
    goto ldv_42536;
    case 8: ;
#line 886
    if (ldv_state_variable_49 == 1) {
#line 888
      drm_gem_dumb_destroy(driver_group0, driver_group1, ldvarg89);
#line 890
      ldv_state_variable_49 = 1;
    } else {

    }
#line 893
    goto ldv_42536;
    case 9: ;
#line 896
    if (ldv_state_variable_49 == 1) {
#line 898
      psb_irq_postinstall(driver_group1);
#line 900
      ldv_state_variable_49 = 1;
    } else {

    }
#line 903
    goto ldv_42536;
    case 10: ;
#line 906
    if (ldv_state_variable_49 == 1) {
#line 908
      drm_pci_set_busid(driver_group1, ldvarg88);
#line 910
      ldv_state_variable_49 = 1;
    } else {

    }
#line 913
    goto ldv_42536;
    case 11: ;
#line 916
    if (ldv_state_variable_49 == 1) {
#line 918
      psb_gem_dumb_create(driver_group0, driver_group1, ldvarg87);
#line 920
      ldv_state_variable_49 = 1;
    } else {

    }
#line 923
    goto ldv_42536;
    case 12: ;
#line 926
    if (ldv_state_variable_49 == 1) {
#line 928
      psb_irq_handler(ldvarg85, ldvarg86);
#line 930
      ldv_state_variable_49 = 1;
    } else {

    }
#line 933
    goto ldv_42536;
    case 13: ;
#line 936
    if (ldv_state_variable_49 == 1) {
#line 938
      psb_enable_vblank(driver_group1, ldvarg84);
#line 940
      ldv_state_variable_49 = 1;
    } else {

    }
#line 943
    goto ldv_42536;
    case 14: ;
#line 946
    if (ldv_state_variable_49 == 1) {
#line 948
      psb_driver_preclose(driver_group1, driver_group0);
#line 950
      ldv_state_variable_49 = 1;
    } else {

    }
#line 953
    goto ldv_42536;
    case 15: ;
#line 956
    if (ldv_state_variable_49 == 1) {
#line 958
      psb_driver_device_is_agp(driver_group1);
#line 960
      ldv_state_variable_49 = 1;
    } else {

    }
#line 963
    goto ldv_42536;
    case 16: ;
#line 966
    if (ldv_state_variable_49 == 1) {
#line 968
      psb_disable_vblank(driver_group1, ldvarg83);
#line 970
      ldv_state_variable_49 = 1;
    } else {

    }
#line 973
    goto ldv_42536;
    default: 
#line 974
    ldv_stop();
    }
    ldv_42536: ;
  } else {

  }
#line 978
  goto ldv_42513;
  case 22: ;
#line 982
  if (ldv_state_variable_24 != 0) {
#line 983
    ldv_main_exported_24();
  } else {

  }
#line 986
  goto ldv_42513;
  case 23: ;
#line 990
  if (ldv_state_variable_10 != 0) {
#line 991
    ldv_main_exported_10();
  } else {

  }
#line 994
  goto ldv_42513;
  case 24: ;
#line 998
  if (ldv_state_variable_31 != 0) {
#line 999
    ldv_main_exported_31();
  } else {

  }
#line 1002
  goto ldv_42513;
  case 25: ;
#line 1006
  if (ldv_state_variable_35 != 0) {
#line 1007
    ldv_main_exported_35();
  } else {

  }
#line 1010
  goto ldv_42513;
  case 26: ;
#line 1014
  if (ldv_state_variable_11 != 0) {
#line 1015
    ldv_main_exported_11();
  } else {

  }
#line 1018
  goto ldv_42513;
  case 27: ;
#line 1022
  if (ldv_state_variable_53 != 0) {
#line 1023
    ldv_main_exported_53();
  } else {

  }
#line 1026
  goto ldv_42513;
  case 28: ;
#line 1030
  if (ldv_state_variable_48 != 0) {
#line 1031
    tmp___12 = __VERIFIER_nondet_int();
#line 1031
    switch (tmp___12) {
    case 0: ;
#line 1034
    if (ldv_state_variable_48 == 1) {
#line 1036
      ldv_retval_0 = psb_pci_probe(psb_pci_driver_group1, (struct pci_device_id  const  *)ldvarg110);
#line 1037
      if (ldv_retval_0 == 0) {
#line 1038
        ldv_state_variable_48 = 2;
#line 1039
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 1043
    goto ldv_42562;
    case 1: ;
#line 1046
    if (ldv_state_variable_48 == 2) {
#line 1048
      psb_pci_remove(psb_pci_driver_group1);
#line 1049
      ldv_state_variable_48 = 1;
    } else {

    }
#line 1052
    goto ldv_42562;
    case 2: ;
#line 1055
    if (ldv_state_variable_48 == 2) {
#line 1057
      ldv_shutdown_48();
#line 1058
      ldv_state_variable_48 = 2;
    } else {

    }
#line 1061
    goto ldv_42562;
    default: 
#line 1062
    ldv_stop();
    }
    ldv_42562: ;
  } else {

  }
#line 1066
  goto ldv_42513;
  case 29: ;
#line 1070
  if (ldv_state_variable_42 != 0) {
#line 1071
    ldv_main_exported_42();
  } else {

  }
#line 1074
  goto ldv_42513;
  case 30: ;
#line 1078
  if (ldv_state_variable_22 != 0) {
#line 1079
    ldv_main_exported_22();
  } else {

  }
#line 1082
  goto ldv_42513;
  case 31: ;
#line 1086
  if (ldv_state_variable_0 != 0) {
#line 1087
    tmp___13 = __VERIFIER_nondet_int();
#line 1087
    switch (tmp___13) {
    case 0: ;
#line 1090
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
#line 1092
      psb_exit();
#line 1093
      ldv_state_variable_0 = 2;
#line 1094
      goto ldv_final;
    } else {

    }
#line 1097
    goto ldv_42571;
    case 1: ;
#line 1100
    if (ldv_state_variable_0 == 1) {
#line 1102
      ldv_retval_1 = psb_init();
#line 1104
      if (ldv_retval_1 == 0) {
#line 1105
        ldv_state_variable_0 = 3;
#line 1106
        ldv_state_variable_5 = 1;
#line 1107
        ldv_initialize_i2c_algorithm_5();
#line 1108
        ldv_state_variable_54 = 1;
#line 1109
        ldv_initialize_drm_mode_config_funcs_54();
#line 1110
        ldv_state_variable_19 = 1;
#line 1111
        ldv_state_variable_43 = 1;
#line 1112
        ldv_initialize_drm_connector_helper_funcs_43();
#line 1113
        ldv_state_variable_37 = 1;
#line 1114
        ldv_state_variable_45 = 1;
#line 1115
        ldv_initialize_gma_clock_funcs_45();
#line 1116
        ldv_state_variable_56 = 1;
#line 1117
        ldv_initialize_fb_ops_56();
#line 1118
        ldv_state_variable_34 = 1;
#line 1119
        ldv_state_variable_60 = 1;
#line 1120
        ldv_initialize_drm_framebuffer_funcs_60();
#line 1121
        ldv_state_variable_8 = 1;
#line 1122
        ldv_initialize_drm_connector_helper_funcs_8();
#line 1123
        ldv_state_variable_38 = 1;
#line 1124
        ldv_initialize_drm_connector_helper_funcs_38();
#line 1125
        ldv_state_variable_52 = 1;
#line 1126
        ldv_dev_pm_ops_52();
#line 1127
        ldv_state_variable_15 = 1;
#line 1128
        ldv_initialize_drm_connector_helper_funcs_15();
#line 1129
        ldv_state_variable_47 = 1;
#line 1130
        ldv_initialize_drm_crtc_helper_funcs_47();
#line 1131
        ldv_state_variable_12 = 1;
#line 1132
        ldv_initialize_drm_crtc_helper_funcs_12();
#line 1133
        ldv_state_variable_41 = 1;
#line 1134
        ldv_state_variable_58 = 1;
#line 1135
        ldv_initialize_fb_ops_58();
#line 1136
        ldv_state_variable_9 = 1;
#line 1137
        ldv_initialize_drm_encoder_helper_funcs_9();
#line 1138
        ldv_state_variable_51 = 1;
#line 1139
        ldv_initialize_vm_operations_struct_51();
#line 1140
        ldv_state_variable_36 = 1;
#line 1141
        ldv_initialize_i2c_algorithm_36();
#line 1142
        ldv_state_variable_39 = 1;
#line 1143
        ldv_initialize_drm_connector_funcs_39();
#line 1144
        ldv_state_variable_50 = 1;
#line 1145
        ldv_file_operations_50();
#line 1146
        ldv_state_variable_6 = 1;
#line 1147
        ldv_state_variable_29 = 1;
#line 1148
        ldv_state_variable_23 = 1;
#line 1149
        ldv_initialize_drm_connector_funcs_23();
#line 1150
        ldv_state_variable_13 = 1;
#line 1151
        ldv_initialize_psb_ops_13();
#line 1152
        ldv_state_variable_46 = 1;
#line 1153
        ldv_initialize_drm_crtc_funcs_46();
#line 1154
        ldv_state_variable_22 = 1;
#line 1155
        ldv_initialize_drm_encoder_helper_funcs_22();
#line 1156
        ldv_state_variable_42 = 1;
#line 1157
        ldv_initialize_drm_connector_funcs_42();
#line 1158
        ldv_state_variable_48 = 1;
#line 1159
        ldv_pci_driver_48();
#line 1160
        ldv_state_variable_53 = 1;
#line 1161
        ldv_initialize_i2c_algorithm_53();
#line 1162
        ldv_state_variable_11 = 1;
#line 1163
        ldv_initialize_gma_clock_funcs_11();
#line 1164
        ldv_state_variable_35 = 1;
#line 1165
        ldv_initialize_psb_ops_35();
#line 1166
        ldv_state_variable_31 = 1;
#line 1167
        ldv_initialize_drm_connector_funcs_31();
#line 1168
        ldv_state_variable_10 = 1;
#line 1169
        ldv_initialize_drm_encoder_helper_funcs_10();
#line 1170
        ldv_state_variable_24 = 1;
#line 1171
        ldv_initialize_drm_connector_helper_funcs_24();
#line 1172
        ldv_state_variable_49 = 1;
#line 1173
        ldv_initialize_drm_driver_49();
#line 1174
        ldv_state_variable_59 = 1;
#line 1175
        ldv_initialize_vm_operations_struct_59();
#line 1176
        ldv_state_variable_20 = 1;
#line 1177
        ldv_initialize_drm_connector_funcs_20();
#line 1178
        ldv_state_variable_14 = 1;
#line 1179
        ldv_state_variable_40 = 1;
#line 1180
        ldv_initialize_drm_encoder_helper_funcs_40();
#line 1181
        ldv_state_variable_57 = 1;
#line 1182
        ldv_initialize_fb_ops_57();
#line 1183
        ldv_state_variable_28 = 1;
#line 1184
        ldv_initialize_drm_crtc_helper_funcs_28();
#line 1185
        ldv_state_variable_25 = 1;
#line 1186
        ldv_initialize_drm_encoder_helper_funcs_25();
#line 1187
        ldv_state_variable_27 = 1;
#line 1188
        ldv_initialize_drm_crtc_funcs_27();
#line 1189
        ldv_state_variable_55 = 1;
#line 1190
        ldv_initialize_drm_fb_helper_funcs_55();
#line 1191
        ldv_state_variable_44 = 1;
#line 1192
        ldv_initialize_drm_encoder_helper_funcs_44();
#line 1193
        ldv_state_variable_16 = 1;
#line 1194
        ldv_initialize_drm_connector_funcs_16();
#line 1195
        ldv_state_variable_30 = 1;
#line 1196
        ldv_initialize_drm_connector_helper_funcs_30();
#line 1197
        ldv_state_variable_18 = 1;
#line 1198
        ldv_initialize_i2c_algorithm_18();
#line 1199
        ldv_state_variable_17 = 1;
#line 1200
        ldv_initialize_drm_encoder_helper_funcs_17();
#line 1201
        ldv_state_variable_26 = 1;
#line 1202
        ldv_initialize_gma_clock_funcs_26();
#line 1203
        ldv_state_variable_7 = 1;
#line 1204
        ldv_initialize_drm_connector_funcs_7();
#line 1205
        ldv_state_variable_21 = 1;
#line 1206
        ldv_initialize_drm_connector_helper_funcs_21();
#line 1207
        ldv_state_variable_32 = 1;
#line 1208
        ldv_initialize_drm_encoder_helper_funcs_32();
#line 1209
        ldv_state_variable_33 = 1;
#line 1210
        ldv_initialize_psb_ops_33();
      } else {

      }
#line 1212
      if (ldv_retval_1 != 0) {
#line 1213
        ldv_state_variable_0 = 2;
#line 1214
        goto ldv_final;
      } else {

      }
    } else {

    }
#line 1218
    goto ldv_42571;
    default: 
#line 1219
    ldv_stop();
    }
    ldv_42571: ;
  } else {

  }
#line 1223
  goto ldv_42513;
  case 32: ;
#line 1227
  if (ldv_state_variable_46 != 0) {
#line 1228
    ldv_main_exported_46();
  } else {

  }
#line 1231
  goto ldv_42513;
  case 33: ;
#line 1235
  if (ldv_state_variable_13 != 0) {
#line 1236
    ldv_main_exported_13();
  } else {

  }
#line 1239
  goto ldv_42513;
  case 34: ;
#line 1243
  if (ldv_state_variable_23 != 0) {
#line 1244
    ldv_main_exported_23();
  } else {

  }
#line 1247
  goto ldv_42513;
  case 35: ;
#line 1251
  if (ldv_state_variable_29 != 0) {
#line 1252
    ldv_main_exported_29();
  } else {

  }
#line 1255
  goto ldv_42513;
  case 36: ;
#line 1259
  if (ldv_state_variable_6 != 0) {
#line 1260
    ldv_main_exported_6();
  } else {

  }
#line 1263
  goto ldv_42513;
  case 37: ;
#line 1267
  if (ldv_state_variable_50 != 0) {
#line 1268
    tmp___14 = __VERIFIER_nondet_int();
#line 1268
    switch (tmp___14) {
    case 0: ;
#line 1271
    if (ldv_state_variable_50 == 2) {
#line 1273
      drm_read(psb_gem_fops_group2, ldvarg146, ldvarg145, ldvarg144);
#line 1275
      ldv_state_variable_50 = 2;
    } else {

    }
#line 1278
    goto ldv_42581;
    case 1: ;
#line 1281
    if (ldv_state_variable_50 == 1) {
#line 1283
      drm_poll(psb_gem_fops_group2, ldvarg143);
#line 1285
      ldv_state_variable_50 = 1;
    } else {

    }
#line 1288
    if (ldv_state_variable_50 == 2) {
#line 1290
      drm_poll(psb_gem_fops_group2, ldvarg143);
#line 1292
      ldv_state_variable_50 = 2;
    } else {

    }
#line 1295
    goto ldv_42581;
    case 2: ;
#line 1298
    if (ldv_state_variable_50 == 1) {
#line 1300
      ldv_retval_2 = drm_open(psb_gem_fops_group1, psb_gem_fops_group2);
#line 1301
      if (ldv_retval_2 == 0) {
#line 1302
        ldv_state_variable_50 = 2;
#line 1303
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 1307
    goto ldv_42581;
    case 3: ;
#line 1310
    if (ldv_state_variable_50 == 1) {
#line 1312
      drm_gem_mmap(psb_gem_fops_group2, ldvarg142);
#line 1314
      ldv_state_variable_50 = 1;
    } else {

    }
#line 1317
    if (ldv_state_variable_50 == 2) {
#line 1319
      drm_gem_mmap(psb_gem_fops_group2, ldvarg142);
#line 1321
      ldv_state_variable_50 = 2;
    } else {

    }
#line 1324
    goto ldv_42581;
    case 4: ;
#line 1327
    if (ldv_state_variable_50 == 2) {
#line 1329
      drm_release(psb_gem_fops_group1, psb_gem_fops_group2);
#line 1330
      ldv_state_variable_50 = 1;
#line 1331
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 1334
    goto ldv_42581;
    case 5: ;
#line 1337
    if (ldv_state_variable_50 == 2) {
#line 1339
      psb_unlocked_ioctl(psb_gem_fops_group2, ldvarg141, ldvarg140);
#line 1341
      ldv_state_variable_50 = 2;
    } else {

    }
#line 1344
    goto ldv_42581;
    default: 
#line 1345
    ldv_stop();
    }
    ldv_42581: ;
  } else {

  }
#line 1349
  goto ldv_42513;
  case 38: ;
#line 1353
  if (ldv_state_variable_39 != 0) {
#line 1354
    ldv_main_exported_39();
  } else {

  }
#line 1357
  goto ldv_42513;
  case 39: ;
#line 1361
  if (ldv_state_variable_36 != 0) {
#line 1362
    ldv_main_exported_36();
  } else {

  }
#line 1365
  goto ldv_42513;
  case 40: ;
#line 1372
  goto ldv_42513;
  case 41: ;
#line 1376
  if (ldv_state_variable_51 != 0) {
#line 1377
    tmp___15 = __VERIFIER_nondet_int();
#line 1377
    switch (tmp___15) {
    case 0: ;
#line 1380
    if (ldv_state_variable_51 == 1) {
#line 1382
      psb_gem_fault(psb_gem_vm_ops_group0, ldvarg155);
#line 1384
      ldv_state_variable_51 = 1;
    } else {

    }
#line 1387
    if (ldv_state_variable_51 == 2) {
#line 1389
      psb_gem_fault(psb_gem_vm_ops_group0, ldvarg155);
#line 1391
      ldv_state_variable_51 = 2;
    } else {

    }
#line 1394
    goto ldv_42593;
    case 1: ;
#line 1397
    if (ldv_state_variable_51 == 2) {
#line 1399
      drm_gem_vm_close(psb_gem_vm_ops_group0);
#line 1400
      ldv_state_variable_51 = 1;
    } else {

    }
#line 1403
    goto ldv_42593;
    case 2: ;
#line 1406
    if (ldv_state_variable_51 == 1) {
#line 1408
      drm_gem_vm_open(psb_gem_vm_ops_group0);
#line 1409
      ldv_state_variable_51 = 2;
#line 1410
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 1413
    goto ldv_42593;
    default: 
#line 1414
    ldv_stop();
    }
    ldv_42593: ;
  } else {

  }
#line 1418
  goto ldv_42513;
  case 42: ;
#line 1422
  if (ldv_state_variable_9 != 0) {
#line 1423
    ldv_main_exported_9();
  } else {

  }
#line 1426
  goto ldv_42513;
  case 43: ;
#line 1430
  if (ldv_state_variable_58 != 0) {
#line 1431
    ldv_main_exported_58();
  } else {

  }
#line 1434
  goto ldv_42513;
  case 44: ;
#line 1438
  if (ldv_state_variable_41 != 0) {
#line 1439
    ldv_main_exported_41();
  } else {

  }
#line 1442
  goto ldv_42513;
  case 45: ;
#line 1446
  if (ldv_state_variable_12 != 0) {
#line 1447
    ldv_main_exported_12();
  } else {

  }
#line 1450
  goto ldv_42513;
  case 46: ;
#line 1454
  if (ldv_state_variable_47 != 0) {
#line 1455
    ldv_main_exported_47();
  } else {

  }
#line 1458
  goto ldv_42513;
  case 47: ;
#line 1462
  if (ldv_state_variable_15 != 0) {
#line 1463
    ldv_main_exported_15();
  } else {

  }
#line 1466
  goto ldv_42513;
  case 48: ;
#line 1470
  if (ldv_state_variable_52 != 0) {
#line 1471
    tmp___16 = __VERIFIER_nondet_int();
#line 1471
    switch (tmp___16) {
    case 0: ;
#line 1474
    if (ldv_state_variable_52 == 14) {
#line 1476
      ldv_retval_23 = gma_power_thaw(psb_pm_ops_group1);
#line 1477
      if (ldv_retval_23 == 0) {
#line 1478
        ldv_state_variable_52 = 16;
      } else {

      }
    } else {

    }
#line 1482
    goto ldv_42605;
    case 1: ;
#line 1485
    if (ldv_state_variable_52 == 2) {
#line 1487
      ldv_retval_22 = psb_runtime_resume(psb_pm_ops_group1);
#line 1488
      if (ldv_retval_22 == 0) {
#line 1489
        ldv_state_variable_52 = 1;
#line 1490
        ref_cnt = ref_cnt - 1;
      } else {

      }
    } else {

    }
#line 1494
    goto ldv_42605;
    case 2: ;
#line 1497
    if (ldv_state_variable_52 == 2) {
#line 1499
      psb_runtime_idle(psb_pm_ops_group1);
#line 1501
      ldv_state_variable_52 = 2;
    } else {

    }
#line 1504
    if (ldv_state_variable_52 == 1) {
#line 1506
      psb_runtime_idle(psb_pm_ops_group1);
#line 1508
      ldv_state_variable_52 = 1;
    } else {

    }
#line 1511
    goto ldv_42605;
    case 3: ;
#line 1514
    if (ldv_state_variable_52 == 3) {
#line 1516
      ldv_retval_21 = gma_power_suspend(psb_pm_ops_group1);
#line 1517
      if (ldv_retval_21 == 0) {
#line 1518
        ldv_state_variable_52 = 4;
      } else {

      }
    } else {

    }
#line 1522
    goto ldv_42605;
    case 4: ;
#line 1525
    if (ldv_state_variable_52 == 15) {
#line 1527
      ldv_retval_20 = gma_power_restore(psb_pm_ops_group1);
#line 1528
      if (ldv_retval_20 == 0) {
#line 1529
        ldv_state_variable_52 = 16;
      } else {

      }
    } else {

    }
#line 1533
    goto ldv_42605;
    case 5: ;
#line 1536
    if (ldv_state_variable_52 == 1) {
#line 1538
      ldv_retval_19 = psb_runtime_suspend(psb_pm_ops_group1);
#line 1539
      if (ldv_retval_19 == 0) {
#line 1540
        ldv_state_variable_52 = 2;
#line 1541
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 1545
    goto ldv_42605;
    case 6: ;
#line 1548
    if (ldv_state_variable_52 == 3) {
#line 1550
      ldv_retval_18 = gma_power_freeze(psb_pm_ops_group1);
#line 1551
      if (ldv_retval_18 == 0) {
#line 1552
        ldv_state_variable_52 = 5;
      } else {

      }
    } else {

    }
#line 1556
    goto ldv_42605;
    case 7: ;
#line 1559
    if (ldv_state_variable_52 == 13) {
#line 1561
      ldv_retval_17 = gma_power_resume(psb_pm_ops_group1);
#line 1562
      if (ldv_retval_17 == 0) {
#line 1563
        ldv_state_variable_52 = 16;
      } else {

      }
    } else {

    }
#line 1567
    goto ldv_42605;
    case 8: ;
#line 1570
    if (ldv_state_variable_52 == 4) {
#line 1572
      ldv_retval_16 = ldv_suspend_late_52();
#line 1573
      if (ldv_retval_16 == 0) {
#line 1574
        ldv_state_variable_52 = 7;
      } else {

      }
    } else {

    }
#line 1578
    goto ldv_42605;
    case 9: ;
#line 1581
    if (ldv_state_variable_52 == 12) {
#line 1583
      ldv_retval_15 = ldv_restore_early_52();
#line 1584
      if (ldv_retval_15 == 0) {
#line 1585
        ldv_state_variable_52 = 15;
      } else {

      }
    } else {

    }
#line 1589
    goto ldv_42605;
    case 10: ;
#line 1592
    if (ldv_state_variable_52 == 7) {
#line 1594
      ldv_retval_14 = ldv_resume_early_52();
#line 1595
      if (ldv_retval_14 == 0) {
#line 1596
        ldv_state_variable_52 = 13;
      } else {

      }
    } else {

    }
#line 1600
    goto ldv_42605;
    case 11: ;
#line 1603
    if (ldv_state_variable_52 == 10) {
#line 1605
      ldv_retval_13 = ldv_thaw_early_52();
#line 1606
      if (ldv_retval_13 == 0) {
#line 1607
        ldv_state_variable_52 = 14;
      } else {

      }
    } else {

    }
#line 1611
    goto ldv_42605;
    case 12: ;
#line 1614
    if (ldv_state_variable_52 == 8) {
#line 1616
      ldv_retval_12 = ldv_resume_noirq_52();
#line 1617
      if (ldv_retval_12 == 0) {
#line 1618
        ldv_state_variable_52 = 13;
      } else {

      }
    } else {

    }
#line 1622
    goto ldv_42605;
    case 13: ;
#line 1625
    if (ldv_state_variable_52 == 5) {
#line 1627
      ldv_retval_11 = ldv_freeze_noirq_52();
#line 1628
      if (ldv_retval_11 == 0) {
#line 1629
        ldv_state_variable_52 = 9;
      } else {

      }
    } else {

    }
#line 1633
    goto ldv_42605;
    case 14: ;
#line 1636
    if (ldv_state_variable_52 == 1) {
#line 1638
      ldv_retval_10 = ldv_prepare_52();
#line 1639
      if (ldv_retval_10 == 0) {
#line 1640
        ldv_state_variable_52 = 3;
#line 1641
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 1645
    goto ldv_42605;
    case 15: ;
#line 1648
    if (ldv_state_variable_52 == 5) {
#line 1650
      ldv_retval_9 = ldv_freeze_late_52();
#line 1651
      if (ldv_retval_9 == 0) {
#line 1652
        ldv_state_variable_52 = 10;
      } else {

      }
    } else {

    }
#line 1656
    goto ldv_42605;
    case 16: ;
#line 1659
    if (ldv_state_variable_52 == 9) {
#line 1661
      ldv_retval_8 = ldv_thaw_noirq_52();
#line 1662
      if (ldv_retval_8 == 0) {
#line 1663
        ldv_state_variable_52 = 14;
      } else {

      }
    } else {

    }
#line 1667
    goto ldv_42605;
    case 17: ;
#line 1670
    if (ldv_state_variable_52 == 3) {
#line 1672
      ldv_retval_7 = ldv_poweroff_52();
#line 1673
      if (ldv_retval_7 == 0) {
#line 1674
        ldv_state_variable_52 = 6;
      } else {

      }
    } else {

    }
#line 1678
    goto ldv_42605;
    case 18: ;
#line 1681
    if (ldv_state_variable_52 == 6) {
#line 1683
      ldv_retval_6 = ldv_poweroff_noirq_52();
#line 1684
      if (ldv_retval_6 == 0) {
#line 1685
        ldv_state_variable_52 = 11;
      } else {

      }
    } else {

    }
#line 1689
    goto ldv_42605;
    case 19: ;
#line 1692
    if (ldv_state_variable_52 == 6) {
#line 1694
      ldv_retval_5 = ldv_poweroff_late_52();
#line 1695
      if (ldv_retval_5 == 0) {
#line 1696
        ldv_state_variable_52 = 12;
      } else {

      }
    } else {

    }
#line 1700
    goto ldv_42605;
    case 20: ;
#line 1703
    if (ldv_state_variable_52 == 11) {
#line 1705
      ldv_retval_4 = ldv_restore_noirq_52();
#line 1706
      if (ldv_retval_4 == 0) {
#line 1707
        ldv_state_variable_52 = 15;
      } else {

      }
    } else {

    }
#line 1711
    goto ldv_42605;
    case 21: ;
#line 1714
    if (ldv_state_variable_52 == 4) {
#line 1716
      ldv_retval_3 = ldv_suspend_noirq_52();
#line 1717
      if (ldv_retval_3 == 0) {
#line 1718
        ldv_state_variable_52 = 8;
      } else {

      }
    } else {

    }
#line 1722
    goto ldv_42605;
    case 22: ;
#line 1725
    if (ldv_state_variable_52 == 16) {
#line 1727
      ldv_complete_52();
#line 1728
      ldv_state_variable_52 = 1;
#line 1729
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 1732
    goto ldv_42605;
    default: 
#line 1733
    ldv_stop();
    }
    ldv_42605: ;
  } else {

  }
#line 1737
  goto ldv_42513;
  case 49: ;
#line 1741
  if (ldv_state_variable_38 != 0) {
#line 1742
    ldv_main_exported_38();
  } else {

  }
#line 1745
  goto ldv_42513;
  case 50: ;
#line 1749
  if (ldv_state_variable_8 != 0) {
#line 1750
    ldv_main_exported_8();
  } else {

  }
#line 1753
  goto ldv_42513;
  case 51: ;
#line 1757
  if (ldv_state_variable_60 != 0) {
#line 1758
    ldv_main_exported_60();
  } else {

  }
#line 1761
  goto ldv_42513;
  case 52: ;
#line 1768
  goto ldv_42513;
  case 53: ;
#line 1772
  if (ldv_state_variable_34 != 0) {
#line 1773
    ldv_main_exported_34();
  } else {

  }
#line 1776
  goto ldv_42513;
  case 54: ;
#line 1780
  if (ldv_state_variable_56 != 0) {
#line 1781
    ldv_main_exported_56();
  } else {

  }
#line 1784
  goto ldv_42513;
  case 55: ;
#line 1788
  if (ldv_state_variable_45 != 0) {
#line 1789
    ldv_main_exported_45();
  } else {

  }
#line 1792
  goto ldv_42513;
  case 56: ;
#line 1796
  if (ldv_state_variable_37 != 0) {
#line 1797
    ldv_main_exported_37();
  } else {

  }
#line 1800
  goto ldv_42513;
  case 57: ;
#line 1804
  if (ldv_state_variable_43 != 0) {
#line 1805
    ldv_main_exported_43();
  } else {

  }
#line 1808
  goto ldv_42513;
  case 58: ;
#line 1812
  if (ldv_state_variable_19 != 0) {
#line 1813
    ldv_main_exported_19();
  } else {

  }
#line 1816
  goto ldv_42513;
  case 59: ;
#line 1820
  if (ldv_state_variable_54 != 0) {
#line 1821
    ldv_main_exported_54();
  } else {

  }
#line 1824
  goto ldv_42513;
  case 60: ;
#line 1828
  if (ldv_state_variable_5 != 0) {
#line 1829
    ldv_main_exported_5();
  } else {

  }
#line 1832
  goto ldv_42513;
  default: 
#line 1833
  ldv_stop();
  }
  ldv_42513: ;
#line 1835
  goto ldv_42642;
  ldv_final: 
#line 1837
  ldv_check_final_state();
#line 1838
  return 0;
}
}
#line 1865 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
bool ldv_queue_work_on_540(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 1869
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1869
  ldv_func_res = tmp;
#line 1871
  activate_work_2(ldv_func_arg3, 2);
#line 1873
  return (ldv_func_res);
}
}
#line 1876 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
bool ldv_queue_delayed_work_on_541(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 1880
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1880
  ldv_func_res = tmp;
#line 1882
  activate_work_2(& ldv_func_arg3->work, 2);
#line 1884
  return (ldv_func_res);
}
}
#line 1887 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
bool ldv_queue_work_on_542(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 1891
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1891
  ldv_func_res = tmp;
#line 1893
  activate_work_2(ldv_func_arg3, 2);
#line 1895
  return (ldv_func_res);
}
}
#line 1898 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void ldv_flush_workqueue_543(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1901
  flush_workqueue(ldv_func_arg1);
#line 1903
  call_and_disable_all_2(2);
#line 1904
  return;
}
}
#line 1906 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
bool ldv_queue_delayed_work_on_544(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 1910
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1910
  ldv_func_res = tmp;
#line 1912
  activate_work_2(& ldv_func_arg3->work, 2);
#line 1914
  return (ldv_func_res);
}
}
#line 1917 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void ldv_mutex_lock_545(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1920
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1922
  mutex_lock(ldv_func_arg1);
#line 1923
  return;
}
}
#line 1925 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void ldv_mutex_unlock_546(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1928
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1930
  mutex_unlock(ldv_func_arg1);
#line 1931
  return;
}
}
#line 1933 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void ldv_mutex_lock_547(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1936
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 1938
  mutex_lock(ldv_func_arg1);
#line 1939
  return;
}
}
#line 1941 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_mutex_trylock_548(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1945
  tmp = mutex_trylock(ldv_func_arg1);
#line 1945
  ldv_func_res = tmp;
#line 1947
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 1947
  return (tmp___0);
#line 1949
  return (ldv_func_res);
}
}
#line 1952 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void ldv_mutex_unlock_549(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1955
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 1957
  mutex_unlock(ldv_func_arg1);
#line 1958
  return;
}
}
#line 1960 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void ldv_mutex_unlock_550(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1963
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 1965
  mutex_unlock(ldv_func_arg1);
#line 1966
  return;
}
}
#line 1968 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void ldv_mutex_lock_551(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1971
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 1973
  mutex_lock(ldv_func_arg1);
#line 1974
  return;
}
}
#line 1976 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void ldv_mutex_lock_552(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1979
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 1981
  mutex_lock(ldv_func_arg1);
#line 1982
  return;
}
}
#line 1984 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void ldv_mutex_unlock_553(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1987
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 1989
  mutex_unlock(ldv_func_arg1);
#line 1990
  return;
}
}
#line 1992 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void ldv_mutex_unlock_554(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1995
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 1997
  mutex_unlock(ldv_func_arg1);
#line 1998
  return;
}
}
#line 2000 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void ldv_mutex_lock_555(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2003
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 2005
  mutex_lock(ldv_func_arg1);
#line 2006
  return;
}
}
#line 2008 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_mutex_lock_interruptible_556(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 2012
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 2012
  ldv_func_res = tmp;
#line 2014
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 2014
  return (tmp___0);
#line 2016
  return (ldv_func_res);
}
}
#line 2019 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_mutex_trylock_557(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 2023
  tmp = mutex_trylock(ldv_func_arg1);
#line 2023
  ldv_func_res = tmp;
#line 2025
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 2025
  return (tmp___0);
#line 2027
  return (ldv_func_res);
}
}
#line 2051 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void ldv_mutex_unlock_560(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2054
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 2056
  mutex_unlock(ldv_func_arg1);
#line 2057
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_593(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_602(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_591(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_594(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_595(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_598(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_599(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_605(struct mutex *ldv_func_arg1 ) ;
#line 209
void ldv_mutex_unlock_607(struct mutex *ldv_func_arg1 ) ;
#line 213
void ldv_mutex_unlock_609(struct mutex *ldv_func_arg1 ) ;
#line 217
void ldv_mutex_unlock_610(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
int ldv_mutex_lock_interruptible_601(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_590(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_592(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_596(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_597(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_600(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_606(struct mutex *ldv_func_arg1 ) ;
#line 49
void ldv_mutex_lock_608(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_585(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_587(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_586(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_589(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_588(struct workqueue_struct *ldv_func_arg1 ) ;
#line 1226 "include/drm/drm_crtc.h"
extern void drm_crtc_cleanup(struct drm_crtc * ) ;
#line 1315
extern void drm_encoder_cleanup(struct drm_encoder * ) ;
#line 1429
extern int drm_mode_connector_attach_encoder(struct drm_connector * , struct drm_encoder * ) ;
#line 942 "include/drm/drmP.h"
extern void drm_vblank_off(struct drm_device * , int  ) ;
#line 48 "include/linux/pm_runtime.h"
extern void pm_runtime_forbid(struct device * ) ;
#line 65 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/gma_display.h"
bool gma_pipe_has_type(struct drm_crtc *crtc , int type ) ;
#line 66
void gma_wait_for_vblank(struct drm_device *dev ) ;
#line 67
int gma_pipe_set_base(struct drm_crtc *crtc , int x , int y , struct drm_framebuffer *old_fb ) ;
#line 69
int gma_crtc_cursor_set(struct drm_crtc *crtc , struct drm_file *file_priv , uint32_t handle ,
                        uint32_t width , uint32_t height ) ;
#line 73
int gma_crtc_cursor_move(struct drm_crtc *crtc , int x , int y ) ;
#line 74
void gma_crtc_load_lut(struct drm_crtc *crtc ) ;
#line 75
void gma_crtc_gamma_set(struct drm_crtc *crtc , u16 *red , u16 *green , u16 *blue ,
                        u32 start , u32 size ) ;
#line 77
void gma_crtc_dpms(struct drm_crtc *crtc , int mode ) ;
#line 78
bool gma_crtc_mode_fixup(struct drm_crtc *crtc , struct drm_display_mode  const  *mode ,
                         struct drm_display_mode *adjusted_mode ) ;
#line 81
void gma_crtc_prepare(struct drm_crtc *crtc ) ;
#line 82
void gma_crtc_commit(struct drm_crtc *crtc ) ;
#line 83
void gma_crtc_disable(struct drm_crtc *crtc ) ;
#line 84
void gma_crtc_destroy(struct drm_crtc *crtc ) ;
#line 85
int gma_crtc_set_config(struct drm_mode_set *set ) ;
#line 87
void gma_crtc_save(struct drm_crtc *crtc ) ;
#line 88
void gma_crtc_restore(struct drm_crtc *crtc ) ;
#line 90
void gma_encoder_prepare(struct drm_encoder *encoder ) ;
#line 91
void gma_encoder_commit(struct drm_encoder *encoder ) ;
#line 92
void gma_encoder_destroy(struct drm_encoder *encoder ) ;
#line 93
bool gma_encoder_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode  const  *mode ,
                            struct drm_display_mode *adjusted_mode ) ;
#line 100
bool gma_pll_is_valid(struct drm_crtc *crtc , struct gma_limit_t  const  *limit ,
                      struct gma_clock_t *clock ) ;
#line 103
bool gma_find_best_pll(struct gma_limit_t  const  *limit , struct drm_crtc *crtc ,
                       int target , int refclk , struct gma_clock_t *best_clock ) ;
#line 182 "include/drm/drm_crtc_helper.h"
extern int drm_crtc_helper_set_config(struct drm_mode_set * ) ;
#line 230 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
struct drm_encoder *gma_best_encoder(struct drm_connector *connector ) ;
#line 231
void gma_connector_attach_encoder(struct gma_connector *connector , struct gma_encoder *encoder ) ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c"
bool gma_pipe_has_type(struct drm_crtc *crtc , int type ) 
{ 
  struct drm_device *dev ;
  struct drm_mode_config *mode_config ;
  struct drm_connector *l_entry ;
  struct list_head  const  *__mptr ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct list_head  const  *__mptr___0 ;

  {
#line 34
  dev = crtc->dev;
#line 35
  mode_config = & dev->mode_config;
#line 38
  __mptr = (struct list_head  const  *)mode_config->connector_list.next;
#line 38
  l_entry = (struct drm_connector *)__mptr + 0xffffffffffffffe8UL;
#line 38
  goto ldv_42053;
  ldv_42052: ;
#line 39
  if ((unsigned long )l_entry->encoder != (unsigned long )((struct drm_encoder *)0) && (unsigned long )(l_entry->encoder)->crtc == (unsigned long )crtc) {
#line 40
    tmp = gma_attached_encoder(l_entry);
#line 40
    gma_encoder = tmp;
#line 42
    if (gma_encoder->type == type) {
#line 43
      return (1);
    } else {

    }
  } else {

  }
#line 38
  __mptr___0 = (struct list_head  const  *)l_entry->head.next;
#line 38
  l_entry = (struct drm_connector *)__mptr___0 + 0xffffffffffffffe8UL;
  ldv_42053: ;
#line 38
  if ((unsigned long )(& l_entry->head) != (unsigned long )(& mode_config->connector_list)) {
#line 40
    goto ldv_42052;
  } else {

  }

#line 47
  return (0);
}
}
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c"
void gma_wait_for_vblank(struct drm_device *dev ) 
{ 
  unsigned long __ms ;
  unsigned long tmp ;

  {
#line 53
  __ms = 20UL;
#line 53
  goto ldv_42060;
  ldv_42059: 
#line 53
  __const_udelay(4295000UL);
  ldv_42060: 
#line 53
  tmp = __ms;
#line 53
  __ms = __ms - 1UL;
#line 53
  if (tmp != 0UL) {
#line 55
    goto ldv_42059;
  } else {

  }

#line 62
  return;
}
}
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c"
int gma_pipe_set_base(struct drm_crtc *crtc , int x , int y , struct drm_framebuffer *old_fb ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct psb_framebuffer *psbfb ;
  struct drm_framebuffer  const  *__mptr___0 ;
  int pipe ;
  struct psb_offset  const  *map ;
  unsigned long start ;
  unsigned long offset ;
  u32 dspcntr ;
  int ret ;
  bool tmp ;
  int tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;
  struct drm_framebuffer  const  *__mptr___1 ;

  {
#line 59
  dev = crtc->dev;
#line 60
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 61
  __mptr = (struct drm_crtc  const  *)crtc;
#line 61
  gma_crtc = (struct gma_crtc *)__mptr;
#line 62
  __mptr___0 = (struct drm_framebuffer  const  *)(crtc->primary)->fb;
#line 62
  psbfb = (struct psb_framebuffer *)__mptr___0;
#line 63
  pipe = gma_crtc->pipe;
#line 64
  map = dev_priv->regmap + (unsigned long )pipe;
#line 67
  ret = 0;
#line 69
  tmp = gma_power_begin(dev, 1);
#line 69
  if (tmp) {
#line 69
    tmp___0 = 0;
  } else {
#line 69
    tmp___0 = 1;
  }
#line 69
  if (tmp___0) {
#line 70
    return (0);
  } else {

  }
#line 73
  if ((unsigned long )(crtc->primary)->fb == (unsigned long )((struct drm_framebuffer *)0)) {
#line 74
    dev_err((struct device  const  *)dev->dev, "No FB bound\n");
#line 75
    goto gma_pipe_cleaner;
  } else {

  }
#line 80
  ret = psb_gtt_pin(psbfb->gtt);
#line 81
  if (ret < 0) {
#line 82
    goto gma_pipe_set_base_exit;
  } else {

  }
#line 83
  start = (unsigned long )(psbfb->gtt)->offset;
#line 84
  offset = (unsigned long )(((crtc->primary)->fb)->pitches[0] * (unsigned int )y + (unsigned int )((((crtc->primary)->fb)->bits_per_pixel / 8) * x));
#line 86
  REGISTER_WRITE(dev, map->stride, ((crtc->primary)->fb)->pitches[0]);
#line 88
  dspcntr = REGISTER_READ(dev, map->cntr);
#line 89
  dspcntr = dspcntr & 3288334335U;
#line 91
  switch (((crtc->primary)->fb)->bits_per_pixel) {
  case 8: 
#line 93
  dspcntr = dspcntr | 134217728U;
#line 94
  goto ldv_42085;
  case 16: ;
#line 96
  if (((crtc->primary)->fb)->depth == 15U) {
#line 97
    dspcntr = dspcntr | 268435456U;
  } else {
#line 99
    dspcntr = dspcntr | 335544320U;
  }
#line 100
  goto ldv_42085;
  case 24: ;
  case 32: 
#line 103
  dspcntr = dspcntr | 402653184U;
#line 104
  goto ldv_42085;
  default: 
#line 106
  dev_err((struct device  const  *)dev->dev, "Unknown color depth\n");
#line 107
  ret = -22;
#line 108
  goto gma_pipe_set_base_exit;
  }
  ldv_42085: 
#line 110
  REGISTER_WRITE(dev, map->cntr, dspcntr);
#line 112
  descriptor.modname = "gma500_gfx";
#line 112
  descriptor.function = "gma_pipe_set_base";
#line 112
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c";
#line 112
  descriptor.format = "Writing base %08lX %08lX %d %d\n";
#line 112
  descriptor.lineno = 113U;
#line 112
  descriptor.flags = 0U;
#line 112
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 112
  if (tmp___1 != 0L) {
#line 112
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "Writing base %08lX %08lX %d %d\n",
                      start, offset, x, y);
  } else {

  }
#line 118
  if (((int )(dev->pdev)->device & 65534) == 33032) {
#line 119
    REGISTER_WRITE(dev, map->base, (uint32_t )offset + (uint32_t )start);
#line 120
    REGISTER_READ(dev, map->base);
  } else {
#line 122
    REGISTER_WRITE(dev, map->base, (uint32_t )offset);
#line 123
    REGISTER_READ(dev, map->base);
#line 124
    REGISTER_WRITE(dev, map->surf, (uint32_t )start);
#line 125
    REGISTER_READ(dev, map->surf);
  }
  gma_pipe_cleaner: ;
#line 130
  if ((unsigned long )old_fb != (unsigned long )((struct drm_framebuffer *)0)) {
#line 131
    __mptr___1 = (struct drm_framebuffer  const  *)old_fb;
#line 131
    psb_gtt_unpin(((struct psb_framebuffer *)__mptr___1)->gtt);
  } else {

  }
  gma_pipe_set_base_exit: 
#line 134
  gma_power_end(dev);
#line 135
  return (ret);
}
}
#line 139 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c"
void gma_crtc_load_lut(struct drm_crtc *crtc ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct psb_offset  const  *map ;
  int palreg ;
  int i ;
  bool tmp ;

  {
#line 141
  dev = crtc->dev;
#line 142
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 143
  __mptr = (struct drm_crtc  const  *)crtc;
#line 143
  gma_crtc = (struct gma_crtc *)__mptr;
#line 144
  map = dev_priv->regmap + (unsigned long )gma_crtc->pipe;
#line 145
  palreg = (int )map->palette;
#line 149
  if (! crtc->enabled) {
#line 150
    return;
  } else {

  }
#line 152
  tmp = gma_power_begin(dev, 0);
#line 152
  if ((int )tmp) {
#line 153
    i = 0;
#line 153
    goto ldv_42106;
    ldv_42105: 
#line 154
    REGISTER_WRITE(dev, (uint32_t )(i * 4 + palreg), (uint32_t )(((((int )gma_crtc->lut_r[i] + (int )gma_crtc->lut_adj[i]) << 16) | (((int )gma_crtc->lut_g[i] + (int )gma_crtc->lut_adj[i]) << 8)) | ((int )gma_crtc->lut_b[i] + (int )gma_crtc->lut_adj[i])));
#line 153
    i = i + 1;
    ldv_42106: ;
#line 153
    if (i <= 255) {
#line 155
      goto ldv_42105;
    } else {

    }
#line 162
    gma_power_end(dev);
  } else {
#line 164
    i = 0;
#line 164
    goto ldv_42109;
    ldv_42108: 
#line 166
    dev_priv->regs.pipe[0].palette[i] = (u32 )(((((int )gma_crtc->lut_r[i] + (int )gma_crtc->lut_adj[i]) << 16) | (((int )gma_crtc->lut_g[i] + (int )gma_crtc->lut_adj[i]) << 8)) | ((int )gma_crtc->lut_b[i] + (int )gma_crtc->lut_adj[i]));
#line 164
    i = i + 1;
    ldv_42109: ;
#line 164
    if (i <= 255) {
#line 166
      goto ldv_42108;
    } else {

    }

  }
#line 172
  return;
}
}
#line 178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c"
void gma_crtc_gamma_set(struct drm_crtc *crtc , u16 *red , u16 *green , u16 *blue ,
                        u32 start , u32 size ) 
{ 
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  int i ;
  int end ;

  {
#line 181
  __mptr = (struct drm_crtc  const  *)crtc;
#line 181
  gma_crtc = (struct gma_crtc *)__mptr;
#line 183
  end = (int )(256U < start + size ? 256U : start + size);
#line 185
  i = (int )start;
#line 185
  goto ldv_42125;
  ldv_42124: 
#line 186
  gma_crtc->lut_r[i] = (u8 )((int )*(red + (unsigned long )i) >> 8);
#line 187
  gma_crtc->lut_g[i] = (u8 )((int )*(green + (unsigned long )i) >> 8);
#line 188
  gma_crtc->lut_b[i] = (u8 )((int )*(blue + (unsigned long )i) >> 8);
#line 185
  i = i + 1;
  ldv_42125: ;
#line 185
  if (i < end) {
#line 187
    goto ldv_42124;
  } else {

  }
#line 191
  gma_crtc_load_lut(crtc);
#line 192
  return;
}
}
#line 200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c"
void gma_crtc_dpms(struct drm_crtc *crtc , int mode ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  struct psb_offset  const  *map ;
  u32 temp ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 202
  dev = crtc->dev;
#line 203
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 204
  __mptr = (struct drm_crtc  const  *)crtc;
#line 204
  gma_crtc = (struct gma_crtc *)__mptr;
#line 205
  pipe = gma_crtc->pipe;
#line 206
  map = dev_priv->regmap + (unsigned long )pipe;
#line 213
  if (((int )(dev->pdev)->device & 65520) == 3040) {
#line 214
    (*((dev_priv->ops)->disable_sr))(dev);
  } else {

  }
#line 216
  switch (mode) {
  case 0: ;
  case 1: ;
  case 2: ;
#line 220
  if ((int )gma_crtc->active) {
#line 221
    goto ldv_42142;
  } else {

  }
#line 223
  gma_crtc->active = 1;
#line 226
  temp = REGISTER_READ(dev, map->dpll);
#line 227
  if ((int )temp >= 0) {
#line 228
    REGISTER_WRITE(dev, map->dpll, temp);
#line 229
    REGISTER_READ(dev, map->dpll);
#line 231
    __const_udelay(644250UL);
#line 232
    REGISTER_WRITE(dev, map->dpll, temp | 2147483648U);
#line 233
    REGISTER_READ(dev, map->dpll);
#line 235
    __const_udelay(644250UL);
#line 236
    REGISTER_WRITE(dev, map->dpll, temp | 2147483648U);
#line 237
    REGISTER_READ(dev, map->dpll);
#line 239
    __const_udelay(644250UL);
  } else {

  }
#line 243
  temp = REGISTER_READ(dev, map->cntr);
#line 244
  if ((int )temp >= 0) {
#line 245
    REGISTER_WRITE(dev, map->cntr, temp | 2147483648U);
#line 248
    tmp = REGISTER_READ(dev, map->base);
#line 248
    REGISTER_WRITE(dev, map->base, tmp);
  } else {

  }
#line 251
  __const_udelay(644250UL);
#line 254
  temp = REGISTER_READ(dev, map->conf);
#line 255
  if ((int )temp >= 0) {
#line 256
    REGISTER_WRITE(dev, map->conf, temp | 2147483648U);
  } else {

  }
#line 258
  temp = REGISTER_READ(dev, map->status);
#line 259
  temp = temp & 4294901760U;
#line 260
  temp = temp | 2147483648U;
#line 261
  REGISTER_WRITE(dev, map->status, temp);
#line 262
  REGISTER_READ(dev, map->status);
#line 264
  gma_crtc_load_lut(crtc);
#line 269
  goto ldv_42142;
  case 3: ;
#line 271
  if (! gma_crtc->active) {
#line 272
    goto ldv_42142;
  } else {

  }
#line 274
  gma_crtc->active = 0;
#line 281
  REGISTER_WRITE(dev, 463872U, 2147483648U);
#line 284
  drm_vblank_off(dev, pipe);
#line 287
  gma_wait_for_vblank(dev);
#line 290
  temp = REGISTER_READ(dev, map->cntr);
#line 291
  if ((int )temp < 0) {
#line 292
    REGISTER_WRITE(dev, map->cntr, temp & 2147483647U);
#line 295
    tmp___0 = REGISTER_READ(dev, map->base);
#line 295
    REGISTER_WRITE(dev, map->base, tmp___0);
#line 296
    REGISTER_READ(dev, map->base);
  } else {

  }
#line 300
  temp = REGISTER_READ(dev, map->conf);
#line 301
  if ((int )temp < 0) {
#line 302
    REGISTER_WRITE(dev, map->conf, temp & 2147483647U);
#line 303
    REGISTER_READ(dev, map->conf);
  } else {

  }
#line 307
  gma_wait_for_vblank(dev);
#line 309
  __const_udelay(644250UL);
#line 312
  temp = REGISTER_READ(dev, map->dpll);
#line 313
  if ((int )temp < 0) {
#line 314
    REGISTER_WRITE(dev, map->dpll, temp & 2147483647U);
#line 315
    REGISTER_READ(dev, map->dpll);
  } else {

  }
#line 319
  __const_udelay(644250UL);
#line 320
  goto ldv_42142;
  }
  ldv_42142: ;
#line 323
  if (((int )(dev->pdev)->device & 65520) == 3040) {
#line 324
    (*((dev_priv->ops)->update_wm))(dev, crtc);
  } else {

  }
#line 327
  REGISTER_WRITE(dev, 458800U, 16190U);
#line 328
  return;
}
}
#line 330 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c"
int gma_crtc_cursor_set(struct drm_crtc *crtc , struct drm_file *file_priv , uint32_t handle ,
                        uint32_t width , uint32_t height ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  uint32_t control ;
  uint32_t base ;
  uint32_t temp ;
  size_t addr ;
  struct gtt_range *gt ;
  struct gtt_range *cursor_gt ;
  struct drm_gem_object *obj ;
  void *tmp_dst ;
  void *tmp_src ;
  int ret ;
  int i ;
  int cursor_pages ;
  bool tmp ;
  struct drm_gem_object  const  *__mptr___0 ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  struct drm_gem_object  const  *__mptr___1 ;
  bool tmp___2 ;
  struct drm_gem_object  const  *__mptr___2 ;

  {
#line 335
  dev = crtc->dev;
#line 336
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 337
  __mptr = (struct drm_crtc  const  *)crtc;
#line 337
  gma_crtc = (struct gma_crtc *)__mptr;
#line 338
  pipe = gma_crtc->pipe;
#line 339
  control = pipe == 0 ? 458880U : 458944U;
#line 340
  base = pipe == 0 ? 458884U : 458948U;
#line 342
  addr = 0UL;
#line 344
  cursor_gt = gma_crtc->cursor_gt;
#line 347
  ret = 0;
#line 350
  if (handle == 0U) {
#line 351
    temp = 0U;
#line 352
    ldv_mutex_lock_606(& dev->struct_mutex);
#line 354
    tmp = gma_power_begin(dev, 0);
#line 354
    if ((int )tmp) {
#line 355
      REGISTER_WRITE(dev, control, temp);
#line 356
      REGISTER_WRITE(dev, base, 0U);
#line 357
      gma_power_end(dev);
    } else {

    }
#line 361
    if ((unsigned long )gma_crtc->cursor_obj != (unsigned long )((struct drm_gem_object *)0)) {
#line 362
      __mptr___0 = (struct drm_gem_object  const  *)gma_crtc->cursor_obj;
#line 362
      gt = (struct gtt_range *)__mptr___0 + 0xffffffffffffffc0UL;
#line 364
      psb_gtt_unpin(gt);
#line 365
      drm_gem_object_unreference(gma_crtc->cursor_obj);
#line 366
      gma_crtc->cursor_obj = (struct drm_gem_object *)0;
    } else {

    }
#line 369
    ldv_mutex_unlock_607(& dev->struct_mutex);
#line 370
    return (0);
  } else {

  }
#line 374
  if (width != 64U || height != 64U) {
#line 375
    descriptor.modname = "gma500_gfx";
#line 375
    descriptor.function = "gma_crtc_cursor_set";
#line 375
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c";
#line 375
    descriptor.format = "We currently only support 64x64 cursors\n";
#line 375
    descriptor.lineno = 375U;
#line 375
    descriptor.flags = 0U;
#line 375
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 375
    if (tmp___0 != 0L) {
#line 375
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "We currently only support 64x64 cursors\n");
    } else {

    }
#line 376
    return (-22);
  } else {

  }
#line 379
  ldv_mutex_lock_608(& dev->struct_mutex);
#line 380
  obj = drm_gem_object_lookup(dev, file_priv, handle);
#line 381
  if ((unsigned long )obj == (unsigned long )((struct drm_gem_object *)0)) {
#line 382
    ret = -2;
#line 383
    goto unlock;
  } else {

  }
#line 386
  if (obj->size < (size_t )((width * height) * 4U)) {
#line 387
    descriptor___0.modname = "gma500_gfx";
#line 387
    descriptor___0.function = "gma_crtc_cursor_set";
#line 387
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c";
#line 387
    descriptor___0.format = "Buffer is too small\n";
#line 387
    descriptor___0.lineno = 387U;
#line 387
    descriptor___0.flags = 0U;
#line 387
    tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 387
    if (tmp___1 != 0L) {
#line 387
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)dev->dev, "Buffer is too small\n");
    } else {

    }
#line 388
    ret = -12;
#line 389
    goto unref_cursor;
  } else {

  }
#line 392
  __mptr___1 = (struct drm_gem_object  const  *)obj;
#line 392
  gt = (struct gtt_range *)__mptr___1 + 0xffffffffffffffc0UL;
#line 395
  ret = psb_gtt_pin(gt);
#line 396
  if (ret != 0) {
#line 397
    dev_err((struct device  const  *)dev->dev, "Can not pin down handle 0x%x\n", handle);
#line 398
    goto unref_cursor;
  } else {

  }
#line 401
  if ((int )(dev_priv->ops)->cursor_needs_phys != 0) {
#line 402
    if ((unsigned long )cursor_gt == (unsigned long )((struct gtt_range *)0)) {
#line 403
      dev_err((struct device  const  *)dev->dev, "No hardware cursor mem available");
#line 404
      ret = -12;
#line 405
      goto unref_cursor;
    } else {

    }
#line 409
    if (gt->npage > 4) {
#line 410
      cursor_pages = 4;
    } else {
#line 412
      cursor_pages = gt->npage;
    }
#line 415
    tmp_dst = (void *)dev_priv->vram_addr + (unsigned long )cursor_gt->offset;
#line 416
    i = 0;
#line 416
    goto ldv_42179;
    ldv_42178: 
#line 417
    tmp_src = kmap(*(gt->pages + (unsigned long )i));
#line 418
    memcpy(tmp_dst, (void const   *)tmp_src, 4096UL);
#line 419
    kunmap(*(gt->pages + (unsigned long )i));
#line 420
    tmp_dst = tmp_dst + 4096UL;
#line 416
    i = i + 1;
    ldv_42179: ;
#line 416
    if (i < cursor_pages) {
#line 418
      goto ldv_42178;
    } else {

    }
#line 423
    addr = (size_t )gma_crtc->cursor_addr;
  } else {
#line 425
    addr = (size_t )gt->offset;
#line 426
    gma_crtc->cursor_addr = (uint32_t )addr;
  }
#line 429
  temp = 0U;
#line 431
  temp = (uint32_t )(pipe << 28) | temp;
#line 432
  temp = temp | 67108903U;
#line 434
  tmp___2 = gma_power_begin(dev, 0);
#line 434
  if ((int )tmp___2) {
#line 435
    REGISTER_WRITE(dev, control, temp);
#line 436
    REGISTER_WRITE(dev, base, (uint32_t )addr);
#line 437
    gma_power_end(dev);
  } else {

  }
#line 441
  if ((unsigned long )gma_crtc->cursor_obj != (unsigned long )((struct drm_gem_object *)0)) {
#line 442
    __mptr___2 = (struct drm_gem_object  const  *)gma_crtc->cursor_obj;
#line 442
    gt = (struct gtt_range *)__mptr___2 + 0xffffffffffffffc0UL;
#line 443
    psb_gtt_unpin(gt);
#line 444
    drm_gem_object_unreference(gma_crtc->cursor_obj);
  } else {

  }
#line 447
  gma_crtc->cursor_obj = obj;
  unlock: 
#line 449
  ldv_mutex_unlock_609(& dev->struct_mutex);
#line 450
  return (ret);
  unref_cursor: 
#line 453
  drm_gem_object_unreference(obj);
#line 454
  ldv_mutex_unlock_610(& dev->struct_mutex);
#line 455
  return (ret);
}
}
#line 458 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c"
int gma_crtc_cursor_move(struct drm_crtc *crtc , int x , int y ) 
{ 
  struct drm_device *dev ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  uint32_t temp ;
  uint32_t addr ;
  bool tmp ;

  {
#line 460
  dev = crtc->dev;
#line 461
  __mptr = (struct drm_crtc  const  *)crtc;
#line 461
  gma_crtc = (struct gma_crtc *)__mptr;
#line 462
  pipe = gma_crtc->pipe;
#line 463
  temp = 0U;
#line 466
  if (x < 0) {
#line 467
    temp = temp | 32768U;
#line 468
    x = - x;
  } else {

  }
#line 470
  if (y < 0) {
#line 471
    temp = temp | 2147483648U;
#line 472
    y = - y;
  } else {

  }
#line 475
  temp = ((uint32_t )x & 2047U) | temp;
#line 476
  temp = (uint32_t )((y & 2047) << 16) | temp;
#line 478
  addr = gma_crtc->cursor_addr;
#line 480
  tmp = gma_power_begin(dev, 0);
#line 480
  if ((int )tmp) {
#line 481
    REGISTER_WRITE(dev, pipe == 0 ? 458888U : 458952U, temp);
#line 482
    REGISTER_WRITE(dev, pipe == 0 ? 458884U : 458948U, addr);
#line 483
    gma_power_end(dev);
  } else {

  }
#line 485
  return (0);
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c"
bool gma_encoder_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode  const  *mode ,
                            struct drm_display_mode *adjusted_mode ) 
{ 


  {
#line 492
  return (1);
}
}
#line 495 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c"
bool gma_crtc_mode_fixup(struct drm_crtc *crtc , struct drm_display_mode  const  *mode ,
                         struct drm_display_mode *adjusted_mode ) 
{ 


  {
#line 499
  return (1);
}
}
#line 502 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c"
void gma_crtc_prepare(struct drm_crtc *crtc ) 
{ 
  struct drm_crtc_helper_funcs  const  *crtc_funcs ;

  {
#line 504
  crtc_funcs = (struct drm_crtc_helper_funcs  const  *)crtc->helper_private;
#line 505
  (*(crtc_funcs->dpms))(crtc, 3);
#line 506
  return;
}
}
#line 508 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c"
void gma_crtc_commit(struct drm_crtc *crtc ) 
{ 
  struct drm_crtc_helper_funcs  const  *crtc_funcs ;

  {
#line 510
  crtc_funcs = (struct drm_crtc_helper_funcs  const  *)crtc->helper_private;
#line 511
  (*(crtc_funcs->dpms))(crtc, 0);
#line 512
  return;
}
}
#line 514 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c"
void gma_crtc_disable(struct drm_crtc *crtc ) 
{ 
  struct gtt_range *gt ;
  struct drm_crtc_helper_funcs  const  *crtc_funcs ;
  struct drm_framebuffer  const  *__mptr ;

  {
#line 517
  crtc_funcs = (struct drm_crtc_helper_funcs  const  *)crtc->helper_private;
#line 519
  (*(crtc_funcs->dpms))(crtc, 3);
#line 521
  if ((unsigned long )(crtc->primary)->fb != (unsigned long )((struct drm_framebuffer *)0)) {
#line 522
    __mptr = (struct drm_framebuffer  const  *)(crtc->primary)->fb;
#line 522
    gt = ((struct psb_framebuffer *)__mptr)->gtt;
#line 523
    psb_gtt_unpin(gt);
  } else {

  }
#line 525
  return;
}
}
#line 527 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c"
void gma_crtc_destroy(struct drm_crtc *crtc ) 
{ 
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;

  {
#line 529
  __mptr = (struct drm_crtc  const  *)crtc;
#line 529
  gma_crtc = (struct gma_crtc *)__mptr;
#line 531
  kfree((void const   *)gma_crtc->crtc_state);
#line 532
  drm_crtc_cleanup(crtc);
#line 533
  kfree((void const   *)gma_crtc);
#line 534
  return;
}
}
#line 536 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c"
int gma_crtc_set_config(struct drm_mode_set *set ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  int ret ;
  int tmp ;

  {
#line 538
  dev = (set->crtc)->dev;
#line 539
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 542
  if (dev_priv->rpm_enabled == 0) {
#line 543
    tmp = drm_crtc_helper_set_config(set);
#line 543
    return (tmp);
  } else {

  }
#line 545
  pm_runtime_forbid(& (dev->pdev)->dev);
#line 546
  ret = drm_crtc_helper_set_config(set);
#line 547
  pm_runtime_allow(& (dev->pdev)->dev);
#line 549
  return (ret);
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c"
void gma_crtc_save(struct drm_crtc *crtc ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct psb_intel_crtc_state *crtc_state ;
  struct psb_offset  const  *map ;
  uint32_t palette_reg ;
  int i ;

  {
#line 557
  dev = crtc->dev;
#line 558
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 559
  __mptr = (struct drm_crtc  const  *)crtc;
#line 559
  gma_crtc = (struct gma_crtc *)__mptr;
#line 560
  crtc_state = gma_crtc->crtc_state;
#line 561
  map = dev_priv->regmap + (unsigned long )gma_crtc->pipe;
#line 565
  if ((unsigned long )crtc_state == (unsigned long )((struct psb_intel_crtc_state *)0)) {
#line 566
    dev_err((struct device  const  *)dev->dev, "No CRTC state found\n");
#line 567
    return;
  } else {

  }
#line 570
  crtc_state->saveDSPCNTR = REGISTER_READ(dev, map->cntr);
#line 571
  crtc_state->savePIPECONF = REGISTER_READ(dev, map->conf);
#line 572
  crtc_state->savePIPESRC = REGISTER_READ(dev, map->src);
#line 573
  crtc_state->saveFP0 = REGISTER_READ(dev, map->fp0);
#line 574
  crtc_state->saveFP1 = REGISTER_READ(dev, map->fp1);
#line 575
  crtc_state->saveDPLL = REGISTER_READ(dev, map->dpll);
#line 576
  crtc_state->saveHTOTAL = REGISTER_READ(dev, map->htotal);
#line 577
  crtc_state->saveHBLANK = REGISTER_READ(dev, map->hblank);
#line 578
  crtc_state->saveHSYNC = REGISTER_READ(dev, map->hsync);
#line 579
  crtc_state->saveVTOTAL = REGISTER_READ(dev, map->vtotal);
#line 580
  crtc_state->saveVBLANK = REGISTER_READ(dev, map->vblank);
#line 581
  crtc_state->saveVSYNC = REGISTER_READ(dev, map->vsync);
#line 582
  crtc_state->saveDSPSTRIDE = REGISTER_READ(dev, map->stride);
#line 585
  crtc_state->saveDSPSIZE = REGISTER_READ(dev, map->size);
#line 586
  crtc_state->saveDSPPOS = REGISTER_READ(dev, map->pos);
#line 588
  crtc_state->saveDSPBASE = REGISTER_READ(dev, map->base);
#line 590
  palette_reg = map->palette;
#line 591
  i = 0;
#line 591
  goto ldv_42245;
  ldv_42244: 
#line 592
  crtc_state->savePalette[i] = REGISTER_READ(dev, (uint32_t )(i << 2) + palette_reg);
#line 591
  i = i + 1;
  ldv_42245: ;
#line 591
  if (i <= 255) {
#line 593
    goto ldv_42244;
  } else {

  }

#line 598
  return;
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c"
void gma_crtc_restore(struct drm_crtc *crtc ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct psb_intel_crtc_state *crtc_state ;
  struct psb_offset  const  *map ;
  uint32_t palette_reg ;
  int i ;

  {
#line 600
  dev = crtc->dev;
#line 601
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 602
  __mptr = (struct drm_crtc  const  *)crtc;
#line 602
  gma_crtc = (struct gma_crtc *)__mptr;
#line 603
  crtc_state = gma_crtc->crtc_state;
#line 604
  map = dev_priv->regmap + (unsigned long )gma_crtc->pipe;
#line 608
  if ((unsigned long )crtc_state == (unsigned long )((struct psb_intel_crtc_state *)0)) {
#line 609
    dev_err((struct device  const  *)dev->dev, "No crtc state\n");
#line 610
    return;
  } else {

  }
#line 613
  if ((int )crtc_state->saveDPLL < 0) {
#line 614
    REGISTER_WRITE(dev, map->dpll, crtc_state->saveDPLL & 2147483647U);
#line 616
    REGISTER_READ(dev, map->dpll);
#line 617
    __const_udelay(644250UL);
  } else {

  }
#line 620
  REGISTER_WRITE(dev, map->fp0, crtc_state->saveFP0);
#line 621
  REGISTER_READ(dev, map->fp0);
#line 623
  REGISTER_WRITE(dev, map->fp1, crtc_state->saveFP1);
#line 624
  REGISTER_READ(dev, map->fp1);
#line 626
  REGISTER_WRITE(dev, map->dpll, crtc_state->saveDPLL);
#line 627
  REGISTER_READ(dev, map->dpll);
#line 628
  __const_udelay(644250UL);
#line 630
  REGISTER_WRITE(dev, map->htotal, crtc_state->saveHTOTAL);
#line 631
  REGISTER_WRITE(dev, map->hblank, crtc_state->saveHBLANK);
#line 632
  REGISTER_WRITE(dev, map->hsync, crtc_state->saveHSYNC);
#line 633
  REGISTER_WRITE(dev, map->vtotal, crtc_state->saveVTOTAL);
#line 634
  REGISTER_WRITE(dev, map->vblank, crtc_state->saveVBLANK);
#line 635
  REGISTER_WRITE(dev, map->vsync, crtc_state->saveVSYNC);
#line 636
  REGISTER_WRITE(dev, map->stride, crtc_state->saveDSPSTRIDE);
#line 638
  REGISTER_WRITE(dev, map->size, crtc_state->saveDSPSIZE);
#line 639
  REGISTER_WRITE(dev, map->pos, crtc_state->saveDSPPOS);
#line 641
  REGISTER_WRITE(dev, map->src, crtc_state->savePIPESRC);
#line 642
  REGISTER_WRITE(dev, map->base, crtc_state->saveDSPBASE);
#line 643
  REGISTER_WRITE(dev, map->conf, crtc_state->savePIPECONF);
#line 645
  gma_wait_for_vblank(dev);
#line 647
  REGISTER_WRITE(dev, map->cntr, crtc_state->saveDSPCNTR);
#line 648
  REGISTER_WRITE(dev, map->base, crtc_state->saveDSPBASE);
#line 650
  gma_wait_for_vblank(dev);
#line 652
  palette_reg = map->palette;
#line 653
  i = 0;
#line 653
  goto ldv_42260;
  ldv_42259: 
#line 654
  REGISTER_WRITE(dev, (uint32_t )(i << 2) + palette_reg, crtc_state->savePalette[i]);
#line 653
  i = i + 1;
  ldv_42260: ;
#line 653
  if (i <= 255) {
#line 655
    goto ldv_42259;
  } else {

  }

#line 660
  return;
}
}
#line 657 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c"
void gma_encoder_prepare(struct drm_encoder *encoder ) 
{ 
  struct drm_encoder_helper_funcs  const  *encoder_funcs ;

  {
#line 659
  encoder_funcs = (struct drm_encoder_helper_funcs  const  *)encoder->helper_private;
#line 662
  (*(encoder_funcs->dpms))(encoder, 3);
#line 663
  return;
}
}
#line 665 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c"
void gma_encoder_commit(struct drm_encoder *encoder ) 
{ 
  struct drm_encoder_helper_funcs  const  *encoder_funcs ;

  {
#line 667
  encoder_funcs = (struct drm_encoder_helper_funcs  const  *)encoder->helper_private;
#line 670
  (*(encoder_funcs->dpms))(encoder, 0);
#line 671
  return;
}
}
#line 673 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c"
void gma_encoder_destroy(struct drm_encoder *encoder ) 
{ 
  struct gma_encoder *intel_encoder ;
  struct drm_encoder  const  *__mptr ;

  {
#line 675
  __mptr = (struct drm_encoder  const  *)encoder;
#line 675
  intel_encoder = (struct gma_encoder *)__mptr;
#line 677
  drm_encoder_cleanup(encoder);
#line 678
  kfree((void const   *)intel_encoder);
#line 679
  return;
}
}
#line 682 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c"
struct drm_encoder *gma_best_encoder(struct drm_connector *connector ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;

  {
#line 684
  tmp = gma_attached_encoder(connector);
#line 684
  gma_encoder = tmp;
#line 686
  return (& gma_encoder->base);
}
}
#line 689 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c"
void gma_connector_attach_encoder(struct gma_connector *connector , struct gma_encoder *encoder ) 
{ 


  {
#line 692
  connector->encoder = encoder;
#line 693
  drm_mode_connector_attach_encoder(& connector->base, & encoder->base);
#line 695
  return;
}
}
#line 699 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c"
bool gma_pll_is_valid(struct drm_crtc *crtc , struct gma_limit_t  const  *limit ,
                      struct gma_clock_t *clock ) 
{ 


  {
#line 703
  if (clock->p1 < (int )limit->p1.min || (int )limit->p1.max < clock->p1) {
#line 704
    return (0);
  } else {

  }
#line 705
  if (clock->p < (int )limit->p.min || (int )limit->p.max < clock->p) {
#line 706
    return (0);
  } else {

  }
#line 707
  if (clock->m2 < (int )limit->m2.min || (int )limit->m2.max < clock->m2) {
#line 708
    return (0);
  } else {

  }
#line 709
  if (clock->m1 < (int )limit->m1.min || (int )limit->m1.max < clock->m1) {
#line 710
    return (0);
  } else {

  }
#line 712
  if (clock->m1 <= clock->m2 && clock->m1 != 0) {
#line 713
    return (0);
  } else {

  }
#line 714
  if (clock->m < (int )limit->m.min || (int )limit->m.max < clock->m) {
#line 715
    return (0);
  } else {

  }
#line 716
  if (clock->n < (int )limit->n.min || (int )limit->n.max < clock->n) {
#line 717
    return (0);
  } else {

  }
#line 718
  if (clock->vco < (int )limit->vco.min || (int )limit->vco.max < clock->vco) {
#line 719
    return (0);
  } else {

  }
#line 724
  if (clock->dot < (int )limit->dot.min || (int )limit->dot.max < clock->dot) {
#line 725
    return (0);
  } else {

  }
#line 727
  return (1);
}
}
#line 730 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.c"
bool gma_find_best_pll(struct gma_limit_t  const  *limit , struct drm_crtc *crtc ,
                       int target , int refclk , struct gma_clock_t *best_clock ) 
{ 
  struct drm_device *dev ;
  struct gma_clock_funcs  const  *clock_funcs ;
  struct drm_crtc  const  *__mptr ;
  struct gma_clock_t clock ;
  int err ;
  uint32_t tmp ;
  bool tmp___0 ;
  uint32_t tmp___1 ;
  int this_err ;
  bool tmp___2 ;
  int tmp___3 ;
  long ret ;
  int __x___0 ;

  {
#line 734
  dev = crtc->dev;
#line 736
  __mptr = (struct drm_crtc  const  *)crtc;
#line 736
  clock_funcs = ((struct gma_crtc *)__mptr)->clock_funcs;
#line 738
  err = target;
#line 740
  tmp___0 = gma_pipe_has_type(crtc, 4);
#line 740
  if ((int )tmp___0) {
#line 740
    tmp___1 = REGISTER_READ(dev, 397696U);
#line 740
    if ((int )tmp___1 < 0) {
#line 748
      tmp = REGISTER_READ(dev, 397696U);
#line 748
      if ((tmp & 48U) == 48U) {
#line 750
        clock.p2 = limit->p2.p2_fast;
      } else {
#line 752
        clock.p2 = limit->p2.p2_slow;
      }
    } else {
#line 740
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 754
  if ((int )limit->p2.dot_limit > target) {
#line 755
    clock.p2 = limit->p2.p2_slow;
  } else {
#line 757
    clock.p2 = limit->p2.p2_fast;
  }
#line 760
  memset((void *)best_clock, 0, 36UL);
#line 763
  clock.m1 = limit->m1.min;
#line 763
  goto ldv_42318;
  ldv_42317: 
#line 764
  clock.m2 = limit->m2.min;
#line 764
  goto ldv_42315;
  ldv_42314: 
#line 767
  clock.n = limit->n.min;
#line 767
  goto ldv_42312;
  ldv_42311: 
#line 769
  clock.p1 = limit->p1.min;
#line 769
  goto ldv_42309;
  ldv_42308: 
#line 774
  (*(clock_funcs->clock))(refclk, & clock);
#line 776
  tmp___2 = (*(clock_funcs->pll_is_valid))(crtc, limit, & clock);
#line 776
  if (tmp___2) {
#line 776
    tmp___3 = 0;
  } else {
#line 776
    tmp___3 = 1;
  }
#line 776
  if (tmp___3) {
#line 778
    goto ldv_42303;
  } else {

  }
#line 780
  __x___0 = clock.dot - target;
#line 780
  ret = (long )(__x___0 < 0 ? - __x___0 : __x___0);
#line 780
  this_err = (int )ret;
#line 781
  if (this_err < err) {
#line 782
    *best_clock = clock;
#line 783
    err = this_err;
  } else {

  }
  ldv_42303: 
#line 771
  clock.p1 = clock.p1 + 1;
  ldv_42309: ;
#line 769
  if (clock.p1 <= (int )limit->p1.max) {
#line 772
    goto ldv_42308;
  } else {

  }
#line 768
  clock.n = clock.n + 1;
  ldv_42312: ;
#line 767
  if (clock.n <= (int )limit->n.max) {
#line 770
    goto ldv_42311;
  } else {

  }
#line 766
  clock.m2 = clock.m2 + 1;
  ldv_42315: ;
#line 764
  if ((clock.m2 < clock.m1 || clock.m1 == 0) && clock.m2 <= (int )limit->m2.max) {
#line 768
    goto ldv_42314;
  } else {

  }
#line 763
  clock.m1 = clock.m1 + 1;
  ldv_42318: ;
#line 763
  if (clock.m1 <= (int )limit->m1.max) {
#line 765
    goto ldv_42317;
  } else {

  }

#line 790
  return (err != target);
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
bool ldv_queue_work_on_585(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 432
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 432
  ldv_func_res = tmp;
#line 434
  activate_work_2(ldv_func_arg3, 2);
#line 436
  return (ldv_func_res);
}
}
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
bool ldv_queue_delayed_work_on_586(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 443
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 443
  ldv_func_res = tmp;
#line 445
  activate_work_2(& ldv_func_arg3->work, 2);
#line 447
  return (ldv_func_res);
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
bool ldv_queue_work_on_587(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 454
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 454
  ldv_func_res = tmp;
#line 456
  activate_work_2(ldv_func_arg3, 2);
#line 458
  return (ldv_func_res);
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void ldv_flush_workqueue_588(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 464
  flush_workqueue(ldv_func_arg1);
#line 466
  call_and_disable_all_2(2);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
bool ldv_queue_delayed_work_on_589(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 473
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 473
  ldv_func_res = tmp;
#line 475
  activate_work_2(& ldv_func_arg3->work, 2);
#line 477
  return (ldv_func_res);
}
}
#line 480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void ldv_mutex_lock_590(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 483
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 485
  mutex_lock(ldv_func_arg1);
#line 486
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void ldv_mutex_unlock_591(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 491
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 493
  mutex_unlock(ldv_func_arg1);
#line 494
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void ldv_mutex_lock_592(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 499
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 501
  mutex_lock(ldv_func_arg1);
#line 502
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
int ldv_mutex_trylock_593(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 508
  tmp = mutex_trylock(ldv_func_arg1);
#line 508
  ldv_func_res = tmp;
#line 510
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 510
  return (tmp___0);
#line 512
  return (ldv_func_res);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void ldv_mutex_unlock_594(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 518
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 520
  mutex_unlock(ldv_func_arg1);
#line 521
  return;
}
}
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void ldv_mutex_unlock_595(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 526
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 528
  mutex_unlock(ldv_func_arg1);
#line 529
  return;
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void ldv_mutex_lock_596(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 534
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 536
  mutex_lock(ldv_func_arg1);
#line 537
  return;
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void ldv_mutex_lock_597(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 542
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 544
  mutex_lock(ldv_func_arg1);
#line 545
  return;
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void ldv_mutex_unlock_598(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 550
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 552
  mutex_unlock(ldv_func_arg1);
#line 553
  return;
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void ldv_mutex_unlock_599(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 558
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 560
  mutex_unlock(ldv_func_arg1);
#line 561
  return;
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void ldv_mutex_lock_600(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 566
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 568
  mutex_lock(ldv_func_arg1);
#line 569
  return;
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
int ldv_mutex_lock_interruptible_601(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 575
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 575
  ldv_func_res = tmp;
#line 577
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 577
  return (tmp___0);
#line 579
  return (ldv_func_res);
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
int ldv_mutex_trylock_602(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 586
  tmp = mutex_trylock(ldv_func_arg1);
#line 586
  ldv_func_res = tmp;
#line 588
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 588
  return (tmp___0);
#line 590
  return (ldv_func_res);
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void ldv_mutex_unlock_605(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 617
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 619
  mutex_unlock(ldv_func_arg1);
#line 620
  return;
}
}
#line 622 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void ldv_mutex_lock_606(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 625
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 627
  mutex_lock(ldv_func_arg1);
#line 628
  return;
}
}
#line 630 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void ldv_mutex_unlock_607(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 633
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 635
  mutex_unlock(ldv_func_arg1);
#line 636
  return;
}
}
#line 638 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void ldv_mutex_lock_608(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 641
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 643
  mutex_lock(ldv_func_arg1);
#line 644
  return;
}
}
#line 646 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void ldv_mutex_unlock_609(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 649
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 651
  mutex_unlock(ldv_func_arg1);
#line 652
  return;
}
}
#line 654 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void ldv_mutex_unlock_610(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 657
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 659
  mutex_unlock(ldv_func_arg1);
#line 660
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_648(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_657(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_646(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_649(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_650(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_653(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_654(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_660(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_device.o.c.prepared"
int ldv_mutex_lock_interruptible_656(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_645(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_647(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_651(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_652(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_655(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_640(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_642(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_641(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_644(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_643(struct workqueue_struct *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_device.c"
void gma_get_core_freq(struct drm_device *dev ) 
{ 
  uint32_t clock ;
  struct pci_dev *pci_root ;
  struct pci_dev *tmp ;
  struct drm_psb_private *dev_priv ;

  {
#line 22
  tmp = pci_get_bus_and_slot(0U, 0U);
#line 22
  pci_root = tmp;
#line 23
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 28
  pci_write_config_dword((struct pci_dev  const  *)pci_root, 208, 3489989376U);
#line 29
  pci_read_config_dword((struct pci_dev  const  *)pci_root, 212, & clock);
#line 30
  pci_dev_put(pci_root);
#line 32
  switch (clock & 7U) {
  case 0U: 
#line 34
  dev_priv->core_freq = 100U;
#line 35
  goto ldv_41873;
  case 1U: 
#line 37
  dev_priv->core_freq = 133U;
#line 38
  goto ldv_41873;
  case 2U: 
#line 40
  dev_priv->core_freq = 150U;
#line 41
  goto ldv_41873;
  case 3U: 
#line 43
  dev_priv->core_freq = 178U;
#line 44
  goto ldv_41873;
  case 4U: 
#line 46
  dev_priv->core_freq = 200U;
#line 47
  goto ldv_41873;
  case 5U: ;
  case 6U: ;
  case 7U: 
#line 51
  dev_priv->core_freq = 266U;
#line 52
  goto ldv_41873;
  default: 
#line 54
  dev_priv->core_freq = 0U;
  }
  ldv_41873: ;
#line 57
  return;
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_device.o.c.prepared"
bool ldv_queue_work_on_640(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 432
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 432
  ldv_func_res = tmp;
#line 434
  activate_work_2(ldv_func_arg3, 2);
#line 436
  return (ldv_func_res);
}
}
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_device.o.c.prepared"
bool ldv_queue_delayed_work_on_641(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 443
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 443
  ldv_func_res = tmp;
#line 445
  activate_work_2(& ldv_func_arg3->work, 2);
#line 447
  return (ldv_func_res);
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_device.o.c.prepared"
bool ldv_queue_work_on_642(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 454
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 454
  ldv_func_res = tmp;
#line 456
  activate_work_2(ldv_func_arg3, 2);
#line 458
  return (ldv_func_res);
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_device.o.c.prepared"
void ldv_flush_workqueue_643(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 464
  flush_workqueue(ldv_func_arg1);
#line 466
  call_and_disable_all_2(2);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_device.o.c.prepared"
bool ldv_queue_delayed_work_on_644(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 473
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 473
  ldv_func_res = tmp;
#line 475
  activate_work_2(& ldv_func_arg3->work, 2);
#line 477
  return (ldv_func_res);
}
}
#line 480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_device.o.c.prepared"
void ldv_mutex_lock_645(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 483
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 485
  mutex_lock(ldv_func_arg1);
#line 486
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_device.o.c.prepared"
void ldv_mutex_unlock_646(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 491
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 493
  mutex_unlock(ldv_func_arg1);
#line 494
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_device.o.c.prepared"
void ldv_mutex_lock_647(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 499
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 501
  mutex_lock(ldv_func_arg1);
#line 502
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_device.o.c.prepared"
int ldv_mutex_trylock_648(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 508
  tmp = mutex_trylock(ldv_func_arg1);
#line 508
  ldv_func_res = tmp;
#line 510
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 510
  return (tmp___0);
#line 512
  return (ldv_func_res);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_device.o.c.prepared"
void ldv_mutex_unlock_649(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 518
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 520
  mutex_unlock(ldv_func_arg1);
#line 521
  return;
}
}
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_device.o.c.prepared"
void ldv_mutex_unlock_650(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 526
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 528
  mutex_unlock(ldv_func_arg1);
#line 529
  return;
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_device.o.c.prepared"
void ldv_mutex_lock_651(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 534
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 536
  mutex_lock(ldv_func_arg1);
#line 537
  return;
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_device.o.c.prepared"
void ldv_mutex_lock_652(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 542
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 544
  mutex_lock(ldv_func_arg1);
#line 545
  return;
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_device.o.c.prepared"
void ldv_mutex_unlock_653(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 550
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 552
  mutex_unlock(ldv_func_arg1);
#line 553
  return;
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_device.o.c.prepared"
void ldv_mutex_unlock_654(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 558
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 560
  mutex_unlock(ldv_func_arg1);
#line 561
  return;
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_device.o.c.prepared"
void ldv_mutex_lock_655(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 566
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 568
  mutex_lock(ldv_func_arg1);
#line 569
  return;
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_device.o.c.prepared"
int ldv_mutex_lock_interruptible_656(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 575
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 575
  ldv_func_res = tmp;
#line 577
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 577
  return (tmp___0);
#line 579
  return (ldv_func_res);
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_device.o.c.prepared"
int ldv_mutex_trylock_657(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 586
  tmp = mutex_trylock(ldv_func_arg1);
#line 586
  ldv_func_res = tmp;
#line 588
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 588
  return (tmp___0);
#line 590
  return (ldv_func_res);
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gma_device.o.c.prepared"
void ldv_mutex_unlock_660(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 617
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 619
  mutex_unlock(ldv_func_arg1);
#line 620
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 396 "./arch/x86/include/asm/bitops.h"
__inline static int ffs(int x ) 
{ 
  int r ;

  {
#line 410
  __asm__  ("bsfl %1,%0": "=r" (r): "rm" (x), "0" (-1));
#line 423
  return (r + 1);
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_693(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_702(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_691(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_694(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_695(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_698(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_699(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_705(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
int ldv_mutex_lock_interruptible_701(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_690(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_692(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_696(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_697(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_700(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_685(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_687(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_686(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_689(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_688(struct workqueue_struct *ldv_func_arg1 ) ;
#line 217 "include/drm/drm_modes.h"
extern void drm_mode_set_crtcinfo(struct drm_display_mode * , int  ) ;
#line 1431 "include/drm/drm_crtc.h"
extern int drm_mode_crtc_set_gamma_size(struct drm_crtc * , int  ) ;
#line 46 "include/drm/drm_plane_helper.h"
extern int drm_crtc_init(struct drm_device * , struct drm_crtc * , struct drm_crtc_funcs  const  * ) ;
#line 197 "include/drm/drm_crtc_helper.h"
__inline static void drm_crtc_helper_add(struct drm_crtc *crtc , struct drm_crtc_helper_funcs  const  *funcs ) 
{ 


  {
#line 200
  crtc->helper_private = (void const   *)funcs;
#line 201
  return;
}
}
#line 240 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
struct drm_display_mode *psb_intel_crtc_mode_get(struct drm_device *dev , struct drm_crtc *crtc ) ;
#line 242
struct drm_crtc *psb_intel_get_crtc_from_pipe(struct drm_device *dev , int pipe ) ;
#line 735 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct drm_crtc_helper_funcs  const  psb_intel_helper_funcs ;
#line 736
struct drm_crtc_funcs  const  psb_intel_crtc_funcs ;
#line 35 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.c"
static struct gma_limit_t  const  psb_intel_limits[2U]  = {      {{20000, 400000}, {1400000, 2800000}, {1, 6}, {70, 120}, {8, 18}, {3, 7}, {5,
                                                                                80},
      {1, 8}, {200000, 10, 5}, & gma_find_best_pll}, 
        {{20000, 400000}, {1400000, 2800000}, {1, 6}, {70, 120}, {8, 18}, {3, 7}, {7,
                                                                                98},
      {1, 8}, {112000, 14, 7}, & gma_find_best_pll}};
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.c"
static struct gma_limit_t  const  *psb_intel_limit(struct drm_crtc *crtc , int refclk ) 
{ 
  struct gma_limit_t  const  *limit ;
  bool tmp ;

  {
#line 70
  tmp = gma_pipe_has_type(crtc, 4);
#line 70
  if ((int )tmp) {
#line 71
    limit = (struct gma_limit_t  const  *)(& psb_intel_limits) + 1UL;
  } else {
#line 73
    limit = (struct gma_limit_t  const  *)(& psb_intel_limits);
  }
#line 74
  return (limit);
}
}
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.c"
static void psb_intel_clock(int refclk , struct gma_clock_t *clock ) 
{ 


  {
#line 79
  clock->m = (clock->m1 * 5 + 10) + (clock->m2 + 2);
#line 80
  clock->p = clock->p1 * clock->p2;
#line 81
  clock->vco = (clock->m * refclk) / (clock->n + 2);
#line 82
  clock->dot = clock->vco / clock->p;
#line 83
  return;
}
}
#line 89 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.c"
static int psb_intel_panel_fitter_pipe(struct drm_device *dev ) 
{ 
  u32 pfit_control ;

  {
#line 93
  pfit_control = REGISTER_READ(dev, 397872U);
#line 96
  if ((int )pfit_control >= 0) {
#line 97
    return (-1);
  } else {

  }
#line 99
  return (1);
}
}
#line 102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.c"
static int psb_intel_crtc_mode_set(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                                   struct drm_display_mode *adjusted_mode , int x ,
                                   int y , struct drm_framebuffer *old_fb ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct drm_crtc_helper_funcs  const  *crtc_funcs ;
  int pipe ;
  struct psb_offset  const  *map ;
  int refclk ;
  struct gma_clock_t clock ;
  u32 dpll ;
  u32 fp ;
  u32 dspcntr ;
  u32 pipeconf ;
  bool ok ;
  bool is_sdvo ;
  bool is_lvds ;
  bool is_tv ;
  struct drm_mode_config *mode_config ;
  struct drm_connector *connector ;
  struct gma_limit_t  const  *limit ;
  struct list_head  const  *__mptr___0 ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct list_head  const  *__mptr___1 ;
  int sdvo_pixel_multiply ;
  int tmp___0 ;
  u32 lvds ;
  uint32_t tmp___1 ;

  {
#line 108
  dev = crtc->dev;
#line 109
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 110
  __mptr = (struct drm_crtc  const  *)crtc;
#line 110
  gma_crtc = (struct gma_crtc *)__mptr;
#line 111
  crtc_funcs = (struct drm_crtc_helper_funcs  const  *)crtc->helper_private;
#line 112
  pipe = gma_crtc->pipe;
#line 113
  map = dev_priv->regmap + (unsigned long )pipe;
#line 116
  dpll = 0U;
#line 116
  fp = 0U;
#line 117
  is_sdvo = 0;
#line 118
  is_lvds = 0;
#line 118
  is_tv = 0;
#line 119
  mode_config = & dev->mode_config;
#line 124
  if ((unsigned long )(crtc->primary)->fb == (unsigned long )((struct drm_framebuffer *)0)) {
#line 125
    (*(crtc_funcs->mode_set_base))(crtc, x, y, old_fb);
#line 126
    return (0);
  } else {

  }
#line 129
  __mptr___0 = (struct list_head  const  *)mode_config->connector_list.next;
#line 129
  connector = (struct drm_connector *)__mptr___0 + 0xffffffffffffffe8UL;
#line 129
  goto ldv_42222;
  ldv_42221: 
#line 130
  tmp = gma_attached_encoder(connector);
#line 130
  gma_encoder = tmp;
#line 132
  if ((unsigned long )connector->encoder == (unsigned long )((struct drm_encoder *)0) || (unsigned long )(connector->encoder)->crtc != (unsigned long )crtc) {
#line 134
    goto ldv_42216;
  } else {

  }
#line 136
  switch (gma_encoder->type) {
  case 4: 
#line 138
  is_lvds = 1;
#line 139
  goto ldv_42218;
  case 3: 
#line 141
  is_sdvo = 1;
#line 142
  goto ldv_42218;
  case 5: 
#line 144
  is_tv = 1;
#line 145
  goto ldv_42218;
  }
  ldv_42218: ;
  ldv_42216: 
#line 129
  __mptr___1 = (struct list_head  const  *)connector->head.next;
#line 129
  connector = (struct drm_connector *)__mptr___1 + 0xffffffffffffffe8UL;
  ldv_42222: ;
#line 129
  if ((unsigned long )(& connector->head) != (unsigned long )(& mode_config->connector_list)) {
#line 131
    goto ldv_42221;
  } else {

  }
#line 149
  refclk = 96000;
#line 151
  limit = (*((gma_crtc->clock_funcs)->limit))(crtc, refclk);
#line 153
  ok = (*(limit->find_pll))(limit, crtc, adjusted_mode->clock, refclk, & clock);
#line 155
  if (! ok) {
#line 156
    drm_err("Couldn\'t find PLL settings for mode! target: %d, actual: %d", adjusted_mode->clock,
            clock.dot);
#line 158
    return (0);
  } else {

  }
#line 161
  fp = (u32 )(((clock.n << 16) | (clock.m1 << 8)) | clock.m2);
#line 163
  dpll = 268435456U;
#line 164
  if ((int )is_lvds) {
#line 165
    dpll = dpll | 134217728U;
#line 166
    dpll = dpll | 1073741824U;
  } else {
#line 168
    dpll = dpll | 67108864U;
  }
#line 169
  if ((int )is_sdvo) {
#line 170
    sdvo_pixel_multiply = adjusted_mode->clock / mode->clock;
#line 172
    dpll = dpll | 1073741824U;
#line 173
    dpll = (u32 )((sdvo_pixel_multiply + -1) << 4) | dpll;
  } else {

  }
#line 178
  dpll = (u32 )((1 << (clock.p1 + -1)) << 16) | dpll;
#line 179
  switch (clock.p2) {
  case 5: 
#line 181
  dpll = dpll | 16777216U;
#line 182
  goto ldv_42226;
  case 7: 
#line 184
  dpll = dpll | 16777216U;
#line 185
  goto ldv_42226;
  case 10: 
#line 187
  dpll = dpll;
#line 188
  goto ldv_42226;
  case 14: 
#line 190
  dpll = dpll;
#line 191
  goto ldv_42226;
  }
  ldv_42226: ;
#line 194
  if ((int )is_tv) {
#line 197
    dpll = dpll | 3U;
  } else {

  }
#line 199
  dpll = dpll;
#line 202
  pipeconf = REGISTER_READ(dev, map->conf);
#line 205
  dspcntr = 1073741824U;
#line 207
  if (pipe == 0) {
#line 208
    dspcntr = dspcntr;
  } else {
#line 210
    dspcntr = dspcntr | 16777216U;
  }
#line 212
  dspcntr = dspcntr | 2147483648U;
#line 213
  pipeconf = pipeconf | 2147483648U;
#line 214
  dpll = dpll | 2147483648U;
#line 218
  tmp___0 = psb_intel_panel_fitter_pipe(dev);
#line 218
  if (tmp___0 == pipe) {
#line 219
    REGISTER_WRITE(dev, 397872U, 0U);
  } else {

  }
#line 221
  drm_mode_debug_printmodeline((struct drm_display_mode  const  *)mode);
#line 223
  if ((int )dpll < 0) {
#line 224
    REGISTER_WRITE(dev, map->fp0, fp);
#line 225
    REGISTER_WRITE(dev, map->dpll, dpll & 2147483647U);
#line 226
    REGISTER_READ(dev, map->dpll);
#line 227
    __const_udelay(644250UL);
  } else {

  }
#line 234
  if ((int )is_lvds) {
#line 235
    tmp___1 = REGISTER_READ(dev, 397696U);
#line 235
    lvds = tmp___1;
#line 237
    lvds = lvds & 3221225471U;
#line 238
    if (pipe == 1) {
#line 239
      lvds = lvds | 1073741824U;
    } else {

    }
#line 241
    lvds = lvds | 2147484416U;
#line 246
    lvds = lvds & 4294967235U;
#line 247
    if (clock.p2 == 7) {
#line 248
      lvds = lvds | 60U;
    } else {

    }
#line 255
    REGISTER_WRITE(dev, 397696U, lvds);
#line 256
    REGISTER_READ(dev, 397696U);
  } else {

  }
#line 259
  REGISTER_WRITE(dev, map->fp0, fp);
#line 260
  REGISTER_WRITE(dev, map->dpll, dpll);
#line 261
  REGISTER_READ(dev, map->dpll);
#line 263
  __const_udelay(644250UL);
#line 266
  REGISTER_WRITE(dev, map->dpll, dpll);
#line 268
  REGISTER_READ(dev, map->dpll);
#line 270
  __const_udelay(644250UL);
#line 272
  REGISTER_WRITE(dev, map->htotal, (uint32_t )((adjusted_mode->crtc_hdisplay + -1) | ((adjusted_mode->crtc_htotal + -1) << 16)));
#line 274
  REGISTER_WRITE(dev, map->hblank, (uint32_t )((adjusted_mode->crtc_hblank_start + -1) | ((adjusted_mode->crtc_hblank_end + -1) << 16)));
#line 276
  REGISTER_WRITE(dev, map->hsync, (uint32_t )((adjusted_mode->crtc_hsync_start + -1) | ((adjusted_mode->crtc_hsync_end + -1) << 16)));
#line 278
  REGISTER_WRITE(dev, map->vtotal, (uint32_t )((adjusted_mode->crtc_vdisplay + -1) | ((adjusted_mode->crtc_vtotal + -1) << 16)));
#line 280
  REGISTER_WRITE(dev, map->vblank, (uint32_t )((adjusted_mode->crtc_vblank_start + -1) | ((adjusted_mode->crtc_vblank_end + -1) << 16)));
#line 282
  REGISTER_WRITE(dev, map->vsync, (uint32_t )((adjusted_mode->crtc_vsync_start + -1) | ((adjusted_mode->crtc_vsync_end + -1) << 16)));
#line 287
  REGISTER_WRITE(dev, map->size, (uint32_t )(((mode->vdisplay + -1) << 16) | (mode->hdisplay + -1)));
#line 289
  REGISTER_WRITE(dev, map->pos, 0U);
#line 290
  REGISTER_WRITE(dev, map->src, (uint32_t )(((mode->hdisplay + -1) << 16) | (mode->vdisplay + -1)));
#line 292
  REGISTER_WRITE(dev, map->conf, pipeconf);
#line 293
  REGISTER_READ(dev, map->conf);
#line 295
  gma_wait_for_vblank(dev);
#line 297
  REGISTER_WRITE(dev, map->cntr, dspcntr);
#line 300
  (*(crtc_funcs->mode_set_base))(crtc, x, y, old_fb);
#line 302
  gma_wait_for_vblank(dev);
#line 304
  return (0);
}
}
#line 308 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.c"
static int psb_intel_crtc_clock_get(struct drm_device *dev , struct drm_crtc *crtc ) 
{ 
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct drm_psb_private *dev_priv ;
  int pipe ;
  struct psb_offset  const  *map ;
  u32 dpll ;
  u32 fp ;
  struct gma_clock_t clock ;
  bool is_lvds ;
  struct psb_pipe *p ;
  uint32_t tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 311
  __mptr = (struct drm_crtc  const  *)crtc;
#line 311
  gma_crtc = (struct gma_crtc *)__mptr;
#line 312
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 313
  pipe = gma_crtc->pipe;
#line 314
  map = dev_priv->regmap + (unsigned long )pipe;
#line 319
  p = (struct psb_pipe *)(& dev_priv->regs.pipe) + (unsigned long )pipe;
#line 321
  tmp___1 = gma_power_begin(dev, 0);
#line 321
  if ((int )tmp___1) {
#line 322
    dpll = REGISTER_READ(dev, map->dpll);
#line 323
    if ((dpll & 256U) == 0U) {
#line 324
      fp = REGISTER_READ(dev, map->fp0);
    } else {
#line 326
      fp = REGISTER_READ(dev, map->fp1);
    }
#line 327
    if (pipe == 1) {
#line 327
      tmp = REGISTER_READ(dev, 397696U);
#line 327
      if ((int )tmp < 0) {
#line 327
        tmp___0 = 1;
      } else {
#line 327
        tmp___0 = 0;
      }
    } else {
#line 327
      tmp___0 = 0;
    }
#line 327
    is_lvds = (bool )tmp___0;
#line 328
    gma_power_end(dev);
  } else {
#line 330
    dpll = p->dpll;
#line 332
    if ((dpll & 256U) == 0U) {
#line 333
      fp = p->fp0;
    } else {
#line 335
      fp = p->fp1;
    }
#line 337
    is_lvds = (bool )(pipe == 1 && (int )dev_priv->regs.__annonCompField80.psb.saveLVDS < 0);
  }
#line 341
  clock.m1 = (int )((fp & 16128U) >> 8);
#line 342
  clock.m2 = (int )fp & 63;
#line 343
  clock.n = (int )((fp & 4128768U) >> 16);
#line 345
  if ((int )is_lvds) {
#line 346
    clock.p1 = ffs((int )((dpll & 4128768U) >> 16));
#line 350
    clock.p2 = 14;
#line 352
    if ((dpll & 24576U) == 24576U) {
#line 355
      psb_intel_clock(66000, & clock);
    } else {
#line 357
      psb_intel_clock(48000, & clock);
    }
  } else {
#line 359
    if ((dpll & 2097152U) != 0U) {
#line 360
      clock.p1 = 2;
    } else {
#line 362
      clock.p1 = (int )(((dpll & 2031616U) >> 16) + 2U);
    }
#line 367
    if ((dpll & 8388608U) != 0U) {
#line 368
      clock.p2 = 4;
    } else {
#line 370
      clock.p2 = 2;
    }
#line 372
    psb_intel_clock(48000, & clock);
  }
#line 380
  return (clock.dot);
}
}
#line 384 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.c"
struct drm_display_mode *psb_intel_crtc_mode_get(struct drm_device *dev , struct drm_crtc *crtc ) 
{ 
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  struct drm_display_mode *mode ;
  int htot ;
  int hsync ;
  int vtot ;
  int vsync ;
  struct drm_psb_private *dev_priv ;
  struct psb_pipe *p ;
  struct psb_offset  const  *map ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  bool tmp___3 ;
  void *tmp___4 ;

  {
#line 387
  __mptr = (struct drm_crtc  const  *)crtc;
#line 387
  gma_crtc = (struct gma_crtc *)__mptr;
#line 388
  pipe = gma_crtc->pipe;
#line 394
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 395
  p = (struct psb_pipe *)(& dev_priv->regs.pipe) + (unsigned long )pipe;
#line 396
  map = dev_priv->regmap + (unsigned long )pipe;
#line 398
  tmp___3 = gma_power_begin(dev, 0);
#line 398
  if ((int )tmp___3) {
#line 399
    tmp = REGISTER_READ(dev, map->htotal);
#line 399
    htot = (int )tmp;
#line 400
    tmp___0 = REGISTER_READ(dev, map->hsync);
#line 400
    hsync = (int )tmp___0;
#line 401
    tmp___1 = REGISTER_READ(dev, map->vtotal);
#line 401
    vtot = (int )tmp___1;
#line 402
    tmp___2 = REGISTER_READ(dev, map->vsync);
#line 402
    vsync = (int )tmp___2;
#line 403
    gma_power_end(dev);
  } else {
#line 405
    htot = (int )p->htotal;
#line 406
    hsync = (int )p->hsync;
#line 407
    vtot = (int )p->vtotal;
#line 408
    vsync = (int )p->vsync;
  }
#line 411
  tmp___4 = kzalloc(208UL, 208U);
#line 411
  mode = (struct drm_display_mode *)tmp___4;
#line 412
  if ((unsigned long )mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 413
    return ((struct drm_display_mode *)0);
  } else {

  }
#line 415
  mode->clock = psb_intel_crtc_clock_get(dev, crtc);
#line 416
  mode->hdisplay = (htot & 65535) + 1;
#line 417
  mode->htotal = (int )(((unsigned int )htot >> 16) + 1U);
#line 418
  mode->hsync_start = (hsync & 65535) + 1;
#line 419
  mode->hsync_end = (int )(((unsigned int )hsync >> 16) + 1U);
#line 420
  mode->vdisplay = (vtot & 65535) + 1;
#line 421
  mode->vtotal = (int )(((unsigned int )vtot >> 16) + 1U);
#line 422
  mode->vsync_start = (vsync & 65535) + 1;
#line 423
  mode->vsync_end = (int )(((unsigned int )vsync >> 16) + 1U);
#line 425
  drm_mode_set_name(mode);
#line 426
  drm_mode_set_crtcinfo(mode, 0);
#line 428
  return (mode);
}
}
#line 431 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.c"
struct drm_crtc_helper_funcs  const  psb_intel_helper_funcs  = 
#line 431
     {& gma_crtc_dpms, & gma_crtc_prepare, & gma_crtc_commit, & gma_crtc_mode_fixup,
    & psb_intel_crtc_mode_set, 0, & gma_pipe_set_base, 0, 0, & gma_crtc_disable, 0,
    0, 0, 0};
#line 441 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.c"
struct drm_crtc_funcs  const  psb_intel_crtc_funcs  = 
#line 441
     {& gma_crtc_save, & gma_crtc_restore, 0, & gma_crtc_cursor_set, 0, & gma_crtc_cursor_move,
    & gma_crtc_gamma_set, & gma_crtc_destroy, & gma_crtc_set_config, 0, 0, 0, 0, 0,
    0};
#line 451 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.c"
struct gma_clock_funcs  const  psb_clock_funcs  =    {& psb_intel_clock, & psb_intel_limit, & gma_pll_is_valid};
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.c"
static void psb_intel_cursor_init(struct drm_device *dev , struct gma_crtc *gma_crtc ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 control[3U] ;
  u32 base[3U] ;
  struct gtt_range *cursor_gt ;

  {
#line 464
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 465
  control[0] = 458880U;
#line 465
  control[1] = 458944U;
#line 465
  control[2] = 458976U;
#line 466
  base[0] = 458884U;
#line 466
  base[1] = 458948U;
#line 466
  base[2] = 458980U;
#line 469
  if ((int )(dev_priv->ops)->cursor_needs_phys != 0) {
#line 473
    cursor_gt = psb_gtt_alloc_range(dev, 16384, "cursor", 1, 4096U);
#line 475
    if ((unsigned long )cursor_gt == (unsigned long )((struct gtt_range *)0)) {
#line 476
      gma_crtc->cursor_gt = (struct gtt_range *)0;
#line 477
      goto out;
    } else {

    }
#line 479
    gma_crtc->cursor_gt = cursor_gt;
#line 480
    gma_crtc->cursor_addr = dev_priv->stolen_base + cursor_gt->offset;
  } else {
#line 483
    gma_crtc->cursor_gt = (struct gtt_range *)0;
  }
  out: 
#line 487
  REGISTER_WRITE(dev, control[gma_crtc->pipe], 0U);
#line 488
  REGISTER_WRITE(dev, base[gma_crtc->pipe], 0U);
#line 489
  return;
}
}
#line 491 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.c"
void psb_intel_crtc_init(struct drm_device *dev , int pipe , struct psb_intel_mode_device *mode_dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  int i ;
  uint16_t *r_base ;
  uint16_t *g_base ;
  uint16_t *b_base ;
  void *tmp ;
  void *tmp___0 ;
  long tmp___1 ;

  {
#line 494
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 501
  tmp = kzalloc(2752UL, 208U);
#line 501
  gma_crtc = (struct gma_crtc *)tmp;
#line 504
  if ((unsigned long )gma_crtc == (unsigned long )((struct gma_crtc *)0)) {
#line 505
    return;
  } else {

  }
#line 507
  tmp___0 = kzalloc(1088UL, 208U);
#line 507
  gma_crtc->crtc_state = (struct psb_intel_crtc_state *)tmp___0;
#line 509
  if ((unsigned long )gma_crtc->crtc_state == (unsigned long )((struct psb_intel_crtc_state *)0)) {
#line 510
    dev_err((struct device  const  *)dev->dev, "Crtc state error: No memory\n");
#line 511
    kfree((void const   *)gma_crtc);
#line 512
    return;
  } else {

  }
#line 516
  drm_crtc_init(dev, & gma_crtc->base, (dev_priv->ops)->crtc_funcs);
#line 519
  gma_crtc->clock_funcs = (dev_priv->ops)->clock_funcs;
#line 521
  drm_mode_crtc_set_gamma_size(& gma_crtc->base, 256);
#line 522
  gma_crtc->pipe = pipe;
#line 523
  gma_crtc->plane = pipe;
#line 525
  r_base = gma_crtc->base.gamma_store;
#line 526
  g_base = r_base + 256UL;
#line 527
  b_base = g_base + 256UL;
#line 528
  i = 0;
#line 528
  goto ldv_42286;
  ldv_42285: 
#line 529
  gma_crtc->lut_r[i] = (u8 )i;
#line 530
  gma_crtc->lut_g[i] = (u8 )i;
#line 531
  gma_crtc->lut_b[i] = (u8 )i;
#line 532
  *(r_base + (unsigned long )i) = (int )((uint16_t )i) << 8U;
#line 533
  *(g_base + (unsigned long )i) = (int )((uint16_t )i) << 8U;
#line 534
  *(b_base + (unsigned long )i) = (int )((uint16_t )i) << 8U;
#line 536
  gma_crtc->lut_adj[i] = 0U;
#line 528
  i = i + 1;
  ldv_42286: ;
#line 528
  if (i <= 255) {
#line 530
    goto ldv_42285;
  } else {

  }
#line 539
  gma_crtc->mode_dev = mode_dev;
#line 540
  gma_crtc->cursor_addr = 0U;
#line 542
  drm_crtc_helper_add(& gma_crtc->base, (dev_priv->ops)->crtc_helper);
#line 546
  gma_crtc->mode_set.crtc = & gma_crtc->base;
#line 547
  tmp___1 = ldv__builtin_expect((long )((unsigned int )pipe > 2U || (unsigned long )dev_priv->plane_to_crtc_mapping[gma_crtc->plane] != (unsigned long )((struct drm_crtc *)0)),
                             0L);
#line 547
  if (tmp___1 != 0L) {
#line 547
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.c"),
                         "i" (548), "i" (12UL));
    ldv_42290: ;
#line 547
    goto ldv_42290;
  } else {

  }
#line 549
  dev_priv->plane_to_crtc_mapping[gma_crtc->plane] = & gma_crtc->base;
#line 550
  dev_priv->pipe_to_crtc_mapping[gma_crtc->pipe] = & gma_crtc->base;
#line 551
  gma_crtc->mode_set.connectors = (struct drm_connector **)gma_crtc + 1U;
#line 552
  gma_crtc->mode_set.num_connectors = 0UL;
#line 553
  psb_intel_cursor_init(dev, gma_crtc);
#line 556
  gma_crtc->active = 1;
#line 557
  return;
}
}
#line 559 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.c"
struct drm_crtc *psb_intel_get_crtc_from_pipe(struct drm_device *dev , int pipe ) 
{ 
  struct drm_crtc *crtc ;
  struct list_head  const  *__mptr ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 561
  crtc = (struct drm_crtc *)0;
#line 563
  __mptr = (struct list_head  const  *)dev->mode_config.crtc_list.next;
#line 563
  crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff0UL;
#line 563
  goto ldv_42305;
  ldv_42304: 
#line 564
  __mptr___0 = (struct drm_crtc  const  *)crtc;
#line 564
  gma_crtc = (struct gma_crtc *)__mptr___0;
#line 565
  if (gma_crtc->pipe == pipe) {
#line 566
    goto ldv_42303;
  } else {

  }
#line 563
  __mptr___1 = (struct list_head  const  *)crtc->head.next;
#line 563
  crtc = (struct drm_crtc *)__mptr___1 + 0xfffffffffffffff0UL;
  ldv_42305: ;
#line 563
  if ((unsigned long )(& crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
#line 565
    goto ldv_42304;
  } else {

  }
  ldv_42303: ;
#line 568
  return (crtc);
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.c"
int gma_connector_clones(struct drm_device *dev , int type_mask ) 
{ 
  int index_mask ;
  struct drm_connector *connector ;
  int entry ;
  struct list_head  const  *__mptr ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct list_head  const  *__mptr___0 ;

  {
#line 573
  index_mask = 0;
#line 575
  entry = 0;
#line 577
  __mptr = (struct list_head  const  *)dev->mode_config.connector_list.next;
#line 577
  connector = (struct drm_connector *)__mptr + 0xffffffffffffffe8UL;
#line 577
  goto ldv_42319;
  ldv_42318: 
#line 579
  tmp = gma_attached_encoder(connector);
#line 579
  gma_encoder = tmp;
#line 580
  if ((type_mask >> gma_encoder->type) & 1) {
#line 581
    index_mask = (1 << entry) | index_mask;
  } else {

  }
#line 582
  entry = entry + 1;
#line 577
  __mptr___0 = (struct list_head  const  *)connector->head.next;
#line 577
  connector = (struct drm_connector *)__mptr___0 + 0xffffffffffffffe8UL;
  ldv_42319: ;
#line 577
  if ((unsigned long )(& connector->head) != (unsigned long )(& dev->mode_config.connector_list)) {
#line 579
    goto ldv_42318;
  } else {

  }

#line 584
  return (index_mask);
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
extern int ldv_release_47(void) ;
#line 405
extern int ldv_connect_47(void) ;
#line 406
extern int ldv_probe_46(void) ;
#line 407
extern int ldv_bind_47(void) ;
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void ldv_initialize_drm_crtc_funcs_46(void) 
{ 
  void *tmp ;

  {
#line 411
  tmp = ldv_init_zalloc(1160UL);
#line 411
  psb_intel_crtc_funcs_group0 = (struct drm_crtc *)tmp;
#line 412
  return;
}
}
#line 414 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void ldv_initialize_gma_clock_funcs_45(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 415
  tmp = ldv_init_zalloc(1160UL);
#line 415
  psb_clock_funcs_group0 = (struct drm_crtc *)tmp;
#line 416
  tmp___0 = ldv_init_zalloc(36UL);
#line 416
  psb_clock_funcs_group1 = (struct gma_clock_t *)tmp___0;
#line 417
  return;
}
}
#line 419 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void ldv_initialize_drm_crtc_helper_funcs_47(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 420
  tmp = ldv_init_zalloc(1160UL);
#line 420
  psb_intel_helper_funcs_group0 = (struct drm_crtc *)tmp;
#line 421
  tmp___0 = ldv_init_zalloc(168UL);
#line 421
  psb_intel_helper_funcs_group1 = (struct drm_framebuffer *)tmp___0;
#line 422
  tmp___1 = ldv_init_zalloc(208UL);
#line 422
  psb_intel_helper_funcs_group2 = (struct drm_display_mode *)tmp___1;
#line 423
  return;
}
}
#line 425 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void ldv_main_exported_46(void) 
{ 
  uint32_t ldvarg125 ;
  int ldvarg130 ;
  struct drm_mode_set *ldvarg120 ;
  void *tmp ;
  uint32_t ldvarg129 ;
  u16 *ldvarg123 ;
  void *tmp___0 ;
  uint32_t ldvarg126 ;
  struct drm_file *ldvarg128 ;
  void *tmp___1 ;
  u16 *ldvarg122 ;
  void *tmp___2 ;
  u16 *ldvarg124 ;
  void *tmp___3 ;
  uint32_t ldvarg127 ;
  int ldvarg131 ;
  uint32_t ldvarg121 ;
  int tmp___4 ;

  {
#line 428
  tmp = ldv_init_zalloc(48UL);
#line 428
  ldvarg120 = (struct drm_mode_set *)tmp;
#line 430
  tmp___0 = ldv_init_zalloc(2UL);
#line 430
  ldvarg123 = (u16 *)tmp___0;
#line 432
  tmp___1 = ldv_init_zalloc(744UL);
#line 432
  ldvarg128 = (struct drm_file *)tmp___1;
#line 433
  tmp___2 = ldv_init_zalloc(2UL);
#line 433
  ldvarg122 = (u16 *)tmp___2;
#line 434
  tmp___3 = ldv_init_zalloc(2UL);
#line 434
  ldvarg124 = (u16 *)tmp___3;
#line 426
  ldv_memset((void *)(& ldvarg125), 0, 4UL);
#line 427
  ldv_memset((void *)(& ldvarg130), 0, 4UL);
#line 429
  ldv_memset((void *)(& ldvarg129), 0, 4UL);
#line 431
  ldv_memset((void *)(& ldvarg126), 0, 4UL);
#line 435
  ldv_memset((void *)(& ldvarg127), 0, 4UL);
#line 436
  ldv_memset((void *)(& ldvarg131), 0, 4UL);
#line 437
  ldv_memset((void *)(& ldvarg121), 0, 4UL);
#line 439
  tmp___4 = __VERIFIER_nondet_int();
#line 439
  switch (tmp___4) {
  case 0: ;
#line 442
  if (ldv_state_variable_46 == 1) {
#line 444
    gma_crtc_cursor_move(psb_intel_crtc_funcs_group0, ldvarg131, ldvarg130);
#line 446
    ldv_state_variable_46 = 1;
  } else {

  }
#line 449
  if (ldv_state_variable_46 == 2) {
#line 451
    gma_crtc_cursor_move(psb_intel_crtc_funcs_group0, ldvarg131, ldvarg130);
#line 453
    ldv_state_variable_46 = 2;
  } else {

  }
#line 456
  goto ldv_42354;
  case 1: ;
#line 459
  if (ldv_state_variable_46 == 1) {
#line 461
    gma_crtc_cursor_set(psb_intel_crtc_funcs_group0, ldvarg128, ldvarg127, ldvarg126,
                        ldvarg129);
#line 463
    ldv_state_variable_46 = 1;
  } else {

  }
#line 466
  if (ldv_state_variable_46 == 2) {
#line 468
    gma_crtc_cursor_set(psb_intel_crtc_funcs_group0, ldvarg128, ldvarg127, ldvarg126,
                        ldvarg129);
#line 470
    ldv_state_variable_46 = 2;
  } else {

  }
#line 473
  goto ldv_42354;
  case 2: ;
#line 476
  if (ldv_state_variable_46 == 2) {
#line 478
    gma_crtc_destroy(psb_intel_crtc_funcs_group0);
#line 480
    ldv_state_variable_46 = 1;
#line 481
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 484
  goto ldv_42354;
  case 3: ;
#line 487
  if (ldv_state_variable_46 == 1) {
#line 489
    gma_crtc_save(psb_intel_crtc_funcs_group0);
#line 491
    ldv_state_variable_46 = 1;
  } else {

  }
#line 494
  if (ldv_state_variable_46 == 2) {
#line 496
    gma_crtc_save(psb_intel_crtc_funcs_group0);
#line 498
    ldv_state_variable_46 = 2;
  } else {

  }
#line 501
  goto ldv_42354;
  case 4: ;
#line 504
  if (ldv_state_variable_46 == 1) {
#line 506
    gma_crtc_gamma_set(psb_intel_crtc_funcs_group0, ldvarg124, ldvarg123, ldvarg122,
                       ldvarg125, ldvarg121);
#line 508
    ldv_state_variable_46 = 1;
  } else {

  }
#line 511
  if (ldv_state_variable_46 == 2) {
#line 513
    gma_crtc_gamma_set(psb_intel_crtc_funcs_group0, ldvarg124, ldvarg123, ldvarg122,
                       ldvarg125, ldvarg121);
#line 515
    ldv_state_variable_46 = 2;
  } else {

  }
#line 518
  goto ldv_42354;
  case 5: ;
#line 521
  if (ldv_state_variable_46 == 1) {
#line 523
    gma_crtc_restore(psb_intel_crtc_funcs_group0);
#line 525
    ldv_state_variable_46 = 1;
  } else {

  }
#line 528
  if (ldv_state_variable_46 == 2) {
#line 530
    gma_crtc_restore(psb_intel_crtc_funcs_group0);
#line 532
    ldv_state_variable_46 = 2;
  } else {

  }
#line 535
  goto ldv_42354;
  case 6: ;
#line 538
  if (ldv_state_variable_46 == 1) {
#line 540
    gma_crtc_set_config(ldvarg120);
#line 542
    ldv_state_variable_46 = 1;
  } else {

  }
#line 545
  if (ldv_state_variable_46 == 2) {
#line 547
    gma_crtc_set_config(ldvarg120);
#line 549
    ldv_state_variable_46 = 2;
  } else {

  }
#line 552
  goto ldv_42354;
  case 7: ;
#line 555
  if (ldv_state_variable_46 == 1) {
#line 557
    ldv_probe_46();
#line 559
    ldv_state_variable_46 = 2;
#line 560
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 563
  goto ldv_42354;
  default: 
#line 564
  ldv_stop();
  }
  ldv_42354: ;
#line 568
  return;
}
}
#line 570 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void ldv_main_exported_45(void) 
{ 
  struct gma_limit_t *ldvarg210 ;
  void *tmp ;
  int ldvarg208 ;
  int ldvarg209 ;
  int tmp___0 ;

  {
#line 571
  tmp = ldv_init_zalloc(88UL);
#line 571
  ldvarg210 = (struct gma_limit_t *)tmp;
#line 572
  ldv_memset((void *)(& ldvarg208), 0, 4UL);
#line 573
  ldv_memset((void *)(& ldvarg209), 0, 4UL);
#line 575
  tmp___0 = __VERIFIER_nondet_int();
#line 575
  switch (tmp___0) {
  case 0: ;
#line 578
  if (ldv_state_variable_45 == 1) {
#line 580
    gma_pll_is_valid(psb_clock_funcs_group0, (struct gma_limit_t  const  *)ldvarg210,
                     psb_clock_funcs_group1);
#line 582
    ldv_state_variable_45 = 1;
  } else {

  }
#line 585
  goto ldv_42370;
  case 1: ;
#line 588
  if (ldv_state_variable_45 == 1) {
#line 590
    psb_intel_clock(ldvarg209, psb_clock_funcs_group1);
#line 592
    ldv_state_variable_45 = 1;
  } else {

  }
#line 595
  goto ldv_42370;
  case 2: ;
#line 598
  if (ldv_state_variable_45 == 1) {
#line 600
    psb_intel_limit(psb_clock_funcs_group0, ldvarg208);
#line 602
    ldv_state_variable_45 = 1;
  } else {

  }
#line 605
  goto ldv_42370;
  default: 
#line 606
  ldv_stop();
  }
  ldv_42370: ;
#line 610
  return;
}
}
#line 612 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void ldv_main_exported_47(void) 
{ 
  int ldvarg184 ;
  int ldvarg186 ;
  int ldvarg185 ;
  int ldvarg182 ;
  int ldvarg180 ;
  struct drm_display_mode *ldvarg181 ;
  void *tmp ;
  struct drm_display_mode *ldvarg183 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 618
  tmp = ldv_init_zalloc(208UL);
#line 618
  ldvarg181 = (struct drm_display_mode *)tmp;
#line 619
  tmp___0 = ldv_init_zalloc(208UL);
#line 619
  ldvarg183 = (struct drm_display_mode *)tmp___0;
#line 613
  ldv_memset((void *)(& ldvarg184), 0, 4UL);
#line 614
  ldv_memset((void *)(& ldvarg186), 0, 4UL);
#line 615
  ldv_memset((void *)(& ldvarg185), 0, 4UL);
#line 616
  ldv_memset((void *)(& ldvarg182), 0, 4UL);
#line 617
  ldv_memset((void *)(& ldvarg180), 0, 4UL);
#line 621
  tmp___1 = __VERIFIER_nondet_int();
#line 621
  switch (tmp___1) {
  case 0: ;
#line 624
  if (ldv_state_variable_47 == 1) {
#line 626
    gma_pipe_set_base(psb_intel_helper_funcs_group0, ldvarg186, ldvarg185, psb_intel_helper_funcs_group1);
#line 628
    ldv_state_variable_47 = 1;
  } else {

  }
#line 631
  if (ldv_state_variable_47 == 3) {
#line 633
    gma_pipe_set_base(psb_intel_helper_funcs_group0, ldvarg186, ldvarg185, psb_intel_helper_funcs_group1);
#line 635
    ldv_state_variable_47 = 3;
  } else {

  }
#line 638
  if (ldv_state_variable_47 == 2) {
#line 640
    gma_pipe_set_base(psb_intel_helper_funcs_group0, ldvarg186, ldvarg185, psb_intel_helper_funcs_group1);
#line 642
    ldv_state_variable_47 = 2;
  } else {

  }
#line 645
  goto ldv_42385;
  case 1: ;
#line 648
  if (ldv_state_variable_47 == 1) {
#line 650
    gma_crtc_dpms(psb_intel_helper_funcs_group0, ldvarg184);
#line 652
    ldv_state_variable_47 = 1;
  } else {

  }
#line 655
  if (ldv_state_variable_47 == 3) {
#line 657
    gma_crtc_dpms(psb_intel_helper_funcs_group0, ldvarg184);
#line 659
    ldv_state_variable_47 = 3;
  } else {

  }
#line 662
  if (ldv_state_variable_47 == 2) {
#line 664
    gma_crtc_dpms(psb_intel_helper_funcs_group0, ldvarg184);
#line 666
    ldv_state_variable_47 = 2;
  } else {

  }
#line 669
  goto ldv_42385;
  case 2: ;
#line 672
  if (ldv_state_variable_47 == 1) {
#line 674
    gma_crtc_mode_fixup(psb_intel_helper_funcs_group0, (struct drm_display_mode  const  *)ldvarg183,
                        psb_intel_helper_funcs_group2);
#line 676
    ldv_state_variable_47 = 1;
  } else {

  }
#line 679
  if (ldv_state_variable_47 == 3) {
#line 681
    gma_crtc_mode_fixup(psb_intel_helper_funcs_group0, (struct drm_display_mode  const  *)ldvarg183,
                        psb_intel_helper_funcs_group2);
#line 683
    ldv_state_variable_47 = 3;
  } else {

  }
#line 686
  if (ldv_state_variable_47 == 2) {
#line 688
    gma_crtc_mode_fixup(psb_intel_helper_funcs_group0, (struct drm_display_mode  const  *)ldvarg183,
                        psb_intel_helper_funcs_group2);
#line 690
    ldv_state_variable_47 = 2;
  } else {

  }
#line 693
  goto ldv_42385;
  case 3: ;
#line 696
  if (ldv_state_variable_47 == 1) {
#line 698
    gma_crtc_commit(psb_intel_helper_funcs_group0);
#line 700
    ldv_state_variable_47 = 1;
  } else {

  }
#line 703
  if (ldv_state_variable_47 == 3) {
#line 705
    gma_crtc_commit(psb_intel_helper_funcs_group0);
#line 707
    ldv_state_variable_47 = 3;
  } else {

  }
#line 710
  if (ldv_state_variable_47 == 2) {
#line 712
    gma_crtc_commit(psb_intel_helper_funcs_group0);
#line 714
    ldv_state_variable_47 = 2;
  } else {

  }
#line 717
  goto ldv_42385;
  case 4: ;
#line 720
  if (ldv_state_variable_47 == 1) {
#line 722
    psb_intel_crtc_mode_set(psb_intel_helper_funcs_group0, psb_intel_helper_funcs_group2,
                            ldvarg181, ldvarg180, ldvarg182, psb_intel_helper_funcs_group1);
#line 724
    ldv_state_variable_47 = 1;
  } else {

  }
#line 727
  if (ldv_state_variable_47 == 3) {
#line 729
    psb_intel_crtc_mode_set(psb_intel_helper_funcs_group0, psb_intel_helper_funcs_group2,
                            ldvarg181, ldvarg180, ldvarg182, psb_intel_helper_funcs_group1);
#line 731
    ldv_state_variable_47 = 3;
  } else {

  }
#line 734
  if (ldv_state_variable_47 == 2) {
#line 736
    psb_intel_crtc_mode_set(psb_intel_helper_funcs_group0, psb_intel_helper_funcs_group2,
                            ldvarg181, ldvarg180, ldvarg182, psb_intel_helper_funcs_group1);
#line 738
    ldv_state_variable_47 = 2;
  } else {

  }
#line 741
  goto ldv_42385;
  case 5: ;
#line 744
  if (ldv_state_variable_47 == 3) {
#line 746
    gma_crtc_disable(psb_intel_helper_funcs_group0);
#line 747
    ldv_state_variable_47 = 2;
  } else {

  }
#line 750
  goto ldv_42385;
  case 6: ;
#line 753
  if (ldv_state_variable_47 == 1) {
#line 755
    gma_crtc_prepare(psb_intel_helper_funcs_group0);
#line 757
    ldv_state_variable_47 = 1;
  } else {

  }
#line 760
  if (ldv_state_variable_47 == 3) {
#line 762
    gma_crtc_prepare(psb_intel_helper_funcs_group0);
#line 764
    ldv_state_variable_47 = 3;
  } else {

  }
#line 767
  if (ldv_state_variable_47 == 2) {
#line 769
    gma_crtc_prepare(psb_intel_helper_funcs_group0);
#line 771
    ldv_state_variable_47 = 2;
  } else {

  }
#line 774
  goto ldv_42385;
  case 7: ;
#line 777
  if (ldv_state_variable_47 == 2) {
#line 779
    ldv_release_47();
#line 780
    ldv_state_variable_47 = 1;
#line 781
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 784
  goto ldv_42385;
  case 8: ;
#line 787
  if (ldv_state_variable_47 == 1) {
#line 789
    ldv_bind_47();
#line 790
    ldv_state_variable_47 = 2;
#line 791
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 794
  goto ldv_42385;
  case 9: ;
#line 797
  if (ldv_state_variable_47 == 2) {
#line 799
    ldv_connect_47();
#line 800
    ldv_state_variable_47 = 3;
  } else {

  }
#line 803
  goto ldv_42385;
  default: 
#line 804
  ldv_stop();
  }
  ldv_42385: ;
#line 808
  return;
}
}
#line 833 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
bool ldv_queue_work_on_685(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 837
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 837
  ldv_func_res = tmp;
#line 839
  activate_work_2(ldv_func_arg3, 2);
#line 841
  return (ldv_func_res);
}
}
#line 844 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
bool ldv_queue_delayed_work_on_686(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 848
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 848
  ldv_func_res = tmp;
#line 850
  activate_work_2(& ldv_func_arg3->work, 2);
#line 852
  return (ldv_func_res);
}
}
#line 855 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
bool ldv_queue_work_on_687(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 859
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 859
  ldv_func_res = tmp;
#line 861
  activate_work_2(ldv_func_arg3, 2);
#line 863
  return (ldv_func_res);
}
}
#line 866 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void ldv_flush_workqueue_688(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 869
  flush_workqueue(ldv_func_arg1);
#line 871
  call_and_disable_all_2(2);
#line 872
  return;
}
}
#line 874 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
bool ldv_queue_delayed_work_on_689(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 878
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 878
  ldv_func_res = tmp;
#line 880
  activate_work_2(& ldv_func_arg3->work, 2);
#line 882
  return (ldv_func_res);
}
}
#line 885 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void ldv_mutex_lock_690(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 888
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 890
  mutex_lock(ldv_func_arg1);
#line 891
  return;
}
}
#line 893 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void ldv_mutex_unlock_691(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 896
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 898
  mutex_unlock(ldv_func_arg1);
#line 899
  return;
}
}
#line 901 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void ldv_mutex_lock_692(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 904
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 906
  mutex_lock(ldv_func_arg1);
#line 907
  return;
}
}
#line 909 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
int ldv_mutex_trylock_693(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 913
  tmp = mutex_trylock(ldv_func_arg1);
#line 913
  ldv_func_res = tmp;
#line 915
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 915
  return (tmp___0);
#line 917
  return (ldv_func_res);
}
}
#line 920 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void ldv_mutex_unlock_694(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 923
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 925
  mutex_unlock(ldv_func_arg1);
#line 926
  return;
}
}
#line 928 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void ldv_mutex_unlock_695(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 931
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 933
  mutex_unlock(ldv_func_arg1);
#line 934
  return;
}
}
#line 936 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void ldv_mutex_lock_696(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 939
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 941
  mutex_lock(ldv_func_arg1);
#line 942
  return;
}
}
#line 944 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void ldv_mutex_lock_697(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 947
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 949
  mutex_lock(ldv_func_arg1);
#line 950
  return;
}
}
#line 952 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void ldv_mutex_unlock_698(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 955
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 957
  mutex_unlock(ldv_func_arg1);
#line 958
  return;
}
}
#line 960 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void ldv_mutex_unlock_699(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 963
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 965
  mutex_unlock(ldv_func_arg1);
#line 966
  return;
}
}
#line 968 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void ldv_mutex_lock_700(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 971
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 973
  mutex_lock(ldv_func_arg1);
#line 974
  return;
}
}
#line 976 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
int ldv_mutex_lock_interruptible_701(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 980
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 980
  ldv_func_res = tmp;
#line 982
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 982
  return (tmp___0);
#line 984
  return (ldv_func_res);
}
}
#line 987 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
int ldv_mutex_trylock_702(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 991
  tmp = mutex_trylock(ldv_func_arg1);
#line 991
  ldv_func_res = tmp;
#line 993
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 993
  return (tmp___0);
#line 995
  return (ldv_func_res);
}
}
#line 1019 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void ldv_mutex_unlock_705(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1022
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 1024
  mutex_unlock(ldv_func_arg1);
#line 1025
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 67 "./arch/x86/include/asm/string_64.h"
extern int strcmp(char const   * , char const   * ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_738(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_747(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_736(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_739(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_740(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_743(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_744(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_750(struct mutex *ldv_func_arg1 ) ;
#line 209
void ldv_mutex_unlock_752(struct mutex *ldv_func_arg1 ) ;
#line 213
void ldv_mutex_unlock_753(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
int ldv_mutex_lock_interruptible_746(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_735(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_737(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_741(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_742(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_745(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_751(struct mutex *ldv_func_arg1 ) ;
#line 141
void ldv_mutex_lock_mutex_of_drm_mode_config(struct mutex *lock ) ;
#line 145
void ldv_mutex_unlock_mutex_of_drm_mode_config(struct mutex *lock ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_730(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_732(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_731(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_734(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_733(struct workqueue_struct *ldv_func_arg1 ) ;
#line 1075 "include/linux/device.h"
extern void dev_printk(char const   * , struct device  const  * , char const   * 
                       , ...) ;
#line 1090
extern void _dev_info(struct device  const  * , char const   *  , ...) ;
#line 69 "include/linux/i2c.h"
extern int i2c_transfer(struct i2c_adapter * , struct i2c_msg * , int  ) ;
#line 189 "include/drm/drm_modes.h"
extern void drm_mode_probed_add(struct drm_connector * , struct drm_display_mode * ) ;
#line 221
extern struct drm_display_mode *drm_mode_duplicate(struct drm_device * , struct drm_display_mode  const  * ) ;
#line 1243 "include/drm/drm_crtc.h"
extern int drm_connector_init(struct drm_device * , struct drm_connector * , struct drm_connector_funcs  const  * ,
                              int  ) ;
#line 1247
extern int drm_connector_register(struct drm_connector * ) ;
#line 1248
extern void drm_connector_unregister(struct drm_connector * ) ;
#line 1250
extern void drm_connector_cleanup(struct drm_connector * ) ;
#line 1271
extern int drm_encoder_init(struct drm_device * , struct drm_encoder * , struct drm_encoder_funcs  const  * ,
                            int  ) ;
#line 1365
extern int drm_object_property_set_value(struct drm_mode_object * , struct drm_property * ,
                                         uint64_t  ) ;
#line 1368
extern int drm_object_property_get_value(struct drm_mode_object * , struct drm_property * ,
                                         uint64_t * ) ;
#line 1382
extern void drm_object_attach_property(struct drm_mode_object * , struct drm_property * ,
                                       uint64_t  ) ;
#line 183 "include/drm/drm_crtc_helper.h"
extern bool drm_crtc_helper_set_mode(struct drm_crtc * , struct drm_display_mode * ,
                                     int  , int  , struct drm_framebuffer * ) ;
#line 190
extern void drm_helper_connector_dpms(struct drm_connector * , int  ) ;
#line 203 "include/drm/drm_crtc_helper.h"
__inline static void drm_encoder_helper_add(struct drm_encoder *encoder , struct drm_encoder_helper_funcs  const  *funcs ) 
{ 


  {
#line 206
  encoder->helper_private = (void const   *)funcs;
#line 207
  return;
}
}
#line 209 "include/drm/drm_crtc_helper.h"
__inline static void drm_connector_helper_add(struct drm_connector *connector , struct drm_connector_helper_funcs  const  *funcs ) 
{ 


  {
#line 212
  connector->helper_private = (void const   *)funcs;
#line 213
  return;
}
}
#line 224
extern int drm_helper_probe_single_connector_modes(struct drm_connector * , uint32_t  ,
                                                   uint32_t  ) ;
#line 208 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
int psb_intel_ddc_get_modes(struct drm_connector *connector , struct i2c_adapter *adapter ) ;
#line 218
void psb_intel_lvds_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) ;
#line 220
void psb_intel_lvds_set_brightness(struct drm_device *dev , int level ) ;
#line 252
bool psb_intel_lvds_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode  const  *mode ,
                               struct drm_display_mode *adjusted_mode ) ;
#line 255
int psb_intel_lvds_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode ) ;
#line 257
int psb_intel_lvds_set_property(struct drm_connector *connector , struct drm_property *property ,
                                uint64_t value ) ;
#line 260
void psb_intel_lvds_destroy(struct drm_connector *connector ) ;
#line 261
struct drm_encoder_funcs  const  psb_intel_lvds_enc_funcs ;
#line 740 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct drm_connector_helper_funcs  const  psb_intel_lvds_connector_helper_funcs ;
#line 741
struct drm_connector_funcs  const  psb_intel_lvds_connector_funcs ;
#line 71 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"
static u32 psb_intel_lvds_get_max_backlight(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 ret ;
  bool tmp ;
  uint32_t tmp___0 ;

  {
#line 73
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 76
  tmp = gma_power_begin(dev, 0);
#line 76
  if ((int )tmp) {
#line 77
    ret = REGISTER_READ(dev, 397908U);
#line 78
    gma_power_end(dev);
  } else {
#line 80
    ret = dev_priv->regs.saveBLC_PWM_CTL;
  }
#line 83
  ret = ret >> 17;
#line 86
  ret = ret * 2U;
#line 87
  if (ret == 0U) {
#line 88
    tmp___0 = REGISTER_READ(dev, 397908U);
#line 88
    dev_err((struct device  const  *)dev->dev, "BL bug: Reg %08x save %08X\n", tmp___0,
            dev_priv->regs.saveBLC_PWM_CTL);
  } else {

  }
#line 90
  return (ret);
}
}
#line 99 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"
static int psb_lvds_i2c_set_brightness(struct drm_device *dev , unsigned int level ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_intel_i2c_chan *lvds_i2c_bus ;
  u8 out_buf[2U] ;
  unsigned int blc_i2c_brightness ;
  struct i2c_msg msgs[1U] ;
  struct _ddebug descriptor ;
  long tmp ;
  int tmp___0 ;

  {
#line 102
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 105
  lvds_i2c_bus = dev_priv->lvds_i2c_bus;
#line 109
  msgs[0].addr = (unsigned short )lvds_i2c_bus->slave_addr;
#line 109
  msgs[0].flags = 0U;
#line 109
  msgs[0].len = 2U;
#line 109
  msgs[0].buf = (__u8 *)(& out_buf);
#line 118
  blc_i2c_brightness = (level * 255U) / 100U & 255U;
#line 122
  if ((unsigned int )*((unsigned char *)dev_priv->lvds_bl + 0UL) != 0U) {
#line 123
    blc_i2c_brightness = 255U - blc_i2c_brightness;
  } else {

  }
#line 125
  out_buf[0] = (dev_priv->lvds_bl)->brightnesscmd;
#line 126
  out_buf[1] = (unsigned char )blc_i2c_brightness;
#line 128
  tmp___0 = i2c_transfer(& lvds_i2c_bus->adapter, (struct i2c_msg *)(& msgs), 1);
#line 128
  if (tmp___0 == 1) {
#line 129
    descriptor.modname = "gma500_gfx";
#line 129
    descriptor.function = "psb_lvds_i2c_set_brightness";
#line 129
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c";
#line 129
    descriptor.format = "I2C set brightness.(command, value) (%d, %d)\n";
#line 129
    descriptor.lineno = 131U;
#line 129
    descriptor.flags = 0U;
#line 129
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 129
    if (tmp != 0L) {
#line 129
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "I2C set brightness.(command, value) (%d, %d)\n",
                        (int )(dev_priv->lvds_bl)->brightnesscmd, blc_i2c_brightness);
    } else {

    }
#line 132
    return (0);
  } else {

  }
#line 135
  dev_err((struct device  const  *)dev->dev, "I2C transfer error\n");
#line 136
  return (-1);
}
}
#line 140 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"
static int psb_lvds_pwm_set_brightness(struct drm_device *dev , int level ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 max_pwm_blc ;
  u32 blc_pwm_duty_cycle ;
  long tmp ;

  {
#line 142
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 148
  max_pwm_blc = psb_intel_lvds_get_max_backlight(dev);
#line 151
  tmp = ldv__builtin_expect(max_pwm_blc == 0U, 0L);
#line 151
  if (tmp != 0L) {
#line 151
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"),
                         "i" (151), "i" (12UL));
    ldv_41940: ;
#line 151
    goto ldv_41940;
  } else {

  }
#line 153
  blc_pwm_duty_cycle = ((u32 )level * max_pwm_blc) / 100U;
#line 155
  if ((unsigned int )*((unsigned char *)dev_priv->lvds_bl + 0UL) != 0U) {
#line 156
    blc_pwm_duty_cycle = max_pwm_blc - blc_pwm_duty_cycle;
  } else {

  }
#line 158
  blc_pwm_duty_cycle = blc_pwm_duty_cycle & 65534U;
#line 159
  REGISTER_WRITE(dev, 397908U, (max_pwm_blc << 16) | blc_pwm_duty_cycle);
#line 163
  _dev_info((struct device  const  *)dev->dev, "Backlight lvds set brightness %08x\n",
            (max_pwm_blc << 16) | blc_pwm_duty_cycle);
#line 167
  return (0);
}
}
#line 173 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"
void psb_intel_lvds_set_brightness(struct drm_device *dev , int level ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 175
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 177
  descriptor.modname = "gma500_gfx";
#line 177
  descriptor.function = "psb_intel_lvds_set_brightness";
#line 177
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c";
#line 177
  descriptor.format = "backlight level is %d\n";
#line 177
  descriptor.lineno = 177U;
#line 177
  descriptor.flags = 0U;
#line 177
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 177
  if (tmp != 0L) {
#line 177
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "backlight level is %d\n",
                      level);
  } else {

  }
#line 179
  if ((unsigned long )dev_priv->lvds_bl == (unsigned long )((struct bdb_lvds_backlight *)0)) {
#line 180
    dev_err((struct device  const  *)dev->dev, "NO LVDS backlight info\n");
#line 181
    return;
  } else {

  }
#line 184
  if ((unsigned int )*((unsigned char *)dev_priv->lvds_bl + 0UL) == 1U) {
#line 185
    psb_lvds_i2c_set_brightness(dev, (unsigned int )level);
  } else {
#line 187
    psb_lvds_pwm_set_brightness(dev, level);
  }
#line 188
  return;
}
}
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"
static void psb_intel_lvds_set_backlight(struct drm_device *dev , int level ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 blc_pwm_ctl ;
  bool tmp ;

  {
#line 197
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 200
  tmp = gma_power_begin(dev, 0);
#line 200
  if ((int )tmp) {
#line 201
    blc_pwm_ctl = REGISTER_READ(dev, 397908U);
#line 202
    blc_pwm_ctl = blc_pwm_ctl & 4294901760U;
#line 203
    REGISTER_WRITE(dev, 397908U, blc_pwm_ctl | (u32 )level);
#line 206
    dev_priv->regs.saveBLC_PWM_CTL = blc_pwm_ctl | (u32 )level;
#line 208
    gma_power_end(dev);
  } else {
#line 210
    blc_pwm_ctl = dev_priv->regs.saveBLC_PWM_CTL & 4294901760U;
#line 212
    dev_priv->regs.saveBLC_PWM_CTL = blc_pwm_ctl | (u32 )level;
  }
#line 214
  return;
}
}
#line 220 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"
static void psb_intel_lvds_set_power(struct drm_device *dev , bool on ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  u32 pp_status ;
  bool tmp ;
  int tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 222
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 223
  mode_dev = & dev_priv->mode_dev;
#line 226
  tmp = gma_power_begin(dev, 1);
#line 226
  if (tmp) {
#line 226
    tmp___0 = 0;
  } else {
#line 226
    tmp___0 = 1;
  }
#line 226
  if (tmp___0) {
#line 227
    dev_err((struct device  const  *)dev->dev, "set power, chip off!\n");
#line 228
    return;
  } else {

  }
#line 231
  if ((int )on) {
#line 232
    tmp___1 = REGISTER_READ(dev, 397828U);
#line 232
    REGISTER_WRITE(dev, 397828U, tmp___1 | 1U);
    ldv_41961: 
#line 235
    pp_status = REGISTER_READ(dev, 397824U);
#line 236
    if ((int )pp_status >= 0) {
#line 238
      goto ldv_41961;
    } else {

    }
#line 238
    psb_intel_lvds_set_backlight(dev, mode_dev->backlight_duty_cycle);
  } else {
#line 241
    psb_intel_lvds_set_backlight(dev, 0);
#line 243
    tmp___2 = REGISTER_READ(dev, 397828U);
#line 243
    REGISTER_WRITE(dev, 397828U, tmp___2 & 4294967294U);
    ldv_41963: 
#line 246
    pp_status = REGISTER_READ(dev, 397824U);
#line 247
    if ((int )pp_status < 0) {
#line 249
      goto ldv_41963;
    } else {

    }

  }
#line 250
  gma_power_end(dev);
#line 251
  return;
}
}
#line 253 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"
static void psb_intel_lvds_encoder_dpms(struct drm_encoder *encoder , int mode ) 
{ 
  struct drm_device *dev ;

  {
#line 255
  dev = encoder->dev;
#line 257
  if (mode == 0) {
#line 258
    psb_intel_lvds_set_power(dev, 1);
  } else {
#line 260
    psb_intel_lvds_set_power(dev, 0);
  }
#line 261
  return;
}
}
#line 265 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"
static void psb_intel_lvds_save(struct drm_connector *connector ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct psb_intel_lvds_priv *lvds_priv ;
  u32 tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;

  {
#line 267
  dev = connector->dev;
#line 268
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 270
  tmp = gma_attached_encoder(connector);
#line 270
  gma_encoder = tmp;
#line 271
  lvds_priv = (struct psb_intel_lvds_priv *)gma_encoder->dev_priv;
#line 274
  lvds_priv->savePP_ON = REGISTER_READ(dev, 397832U);
#line 275
  lvds_priv->savePP_OFF = REGISTER_READ(dev, 397836U);
#line 276
  lvds_priv->saveLVDS = REGISTER_READ(dev, 397696U);
#line 277
  lvds_priv->savePP_CONTROL = REGISTER_READ(dev, 397828U);
#line 278
  lvds_priv->savePP_CYCLE = REGISTER_READ(dev, 397840U);
#line 280
  lvds_priv->saveBLC_PWM_CTL = REGISTER_READ(dev, 397908U);
#line 281
  lvds_priv->savePFIT_CONTROL = REGISTER_READ(dev, 397872U);
#line 282
  lvds_priv->savePFIT_PGM_RATIOS = REGISTER_READ(dev, 397876U);
#line 285
  dev_priv->backlight_duty_cycle = (int )dev_priv->regs.saveBLC_PWM_CTL & 65535;
#line 292
  if (dev_priv->backlight_duty_cycle == 0) {
#line 293
    tmp___0 = psb_intel_lvds_get_max_backlight(dev);
#line 293
    dev_priv->backlight_duty_cycle = (int )tmp___0;
  } else {

  }
#line 296
  descriptor.modname = "gma500_gfx";
#line 296
  descriptor.function = "psb_intel_lvds_save";
#line 296
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c";
#line 296
  descriptor.format = "(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\n";
#line 296
  descriptor.lineno = 302U;
#line 296
  descriptor.flags = 0U;
#line 296
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 296
  if (tmp___1 != 0L) {
#line 296
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\n",
                      lvds_priv->savePP_ON, lvds_priv->savePP_OFF, lvds_priv->saveLVDS,
                      lvds_priv->savePP_CONTROL, lvds_priv->savePP_CYCLE, lvds_priv->saveBLC_PWM_CTL);
  } else {

  }
#line 298
  return;
}
}
#line 305 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"
static void psb_intel_lvds_restore(struct drm_connector *connector ) 
{ 
  struct drm_device *dev ;
  u32 pp_status ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct psb_intel_lvds_priv *lvds_priv ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 307
  dev = connector->dev;
#line 309
  tmp = gma_attached_encoder(connector);
#line 309
  gma_encoder = tmp;
#line 310
  lvds_priv = (struct psb_intel_lvds_priv *)gma_encoder->dev_priv;
#line 313
  descriptor.modname = "gma500_gfx";
#line 313
  descriptor.function = "psb_intel_lvds_restore";
#line 313
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c";
#line 313
  descriptor.format = "(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\n";
#line 313
  descriptor.lineno = 319U;
#line 313
  descriptor.flags = 0U;
#line 313
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 313
  if (tmp___0 != 0L) {
#line 313
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\n",
                      lvds_priv->savePP_ON, lvds_priv->savePP_OFF, lvds_priv->saveLVDS,
                      lvds_priv->savePP_CONTROL, lvds_priv->savePP_CYCLE, lvds_priv->saveBLC_PWM_CTL);
  } else {

  }
#line 321
  REGISTER_WRITE(dev, 397908U, lvds_priv->saveBLC_PWM_CTL);
#line 322
  REGISTER_WRITE(dev, 397872U, lvds_priv->savePFIT_CONTROL);
#line 323
  REGISTER_WRITE(dev, 397876U, lvds_priv->savePFIT_PGM_RATIOS);
#line 324
  REGISTER_WRITE(dev, 397832U, lvds_priv->savePP_ON);
#line 325
  REGISTER_WRITE(dev, 397836U, lvds_priv->savePP_OFF);
#line 327
  REGISTER_WRITE(dev, 397840U, lvds_priv->savePP_CYCLE);
#line 328
  REGISTER_WRITE(dev, 397828U, lvds_priv->savePP_CONTROL);
#line 329
  REGISTER_WRITE(dev, 397696U, lvds_priv->saveLVDS);
#line 331
  if ((int )lvds_priv->savePP_CONTROL & 1) {
#line 332
    tmp___1 = REGISTER_READ(dev, 397828U);
#line 332
    REGISTER_WRITE(dev, 397828U, tmp___1 | 1U);
    ldv_41988: 
#line 335
    pp_status = REGISTER_READ(dev, 397824U);
#line 336
    if ((int )pp_status >= 0) {
#line 338
      goto ldv_41988;
    } else {

    }

  } else {
#line 338
    tmp___2 = REGISTER_READ(dev, 397828U);
#line 338
    REGISTER_WRITE(dev, 397828U, tmp___2 & 4294967294U);
    ldv_41990: 
#line 341
    pp_status = REGISTER_READ(dev, 397824U);
#line 342
    if ((int )pp_status < 0) {
#line 344
      goto ldv_41990;
    } else {

    }

  }
#line 350
  return;
}
}
#line 346 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"
int psb_intel_lvds_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct drm_display_mode *fixed_mode ;

  {
#line 349
  dev_priv = (struct drm_psb_private *)(connector->dev)->dev_private;
#line 350
  tmp = gma_attached_encoder(connector);
#line 350
  gma_encoder = tmp;
#line 351
  fixed_mode = dev_priv->mode_dev.panel_fixed_mode;
#line 354
  if (gma_encoder->type == 8) {
#line 355
    fixed_mode = dev_priv->mode_dev.panel_fixed_mode2;
  } else {

  }
#line 358
  if ((mode->flags & 32U) != 0U) {
#line 359
    return (8);
  } else {

  }
#line 362
  if ((mode->flags & 16U) != 0U) {
#line 363
    return (7);
  } else {

  }
#line 365
  if ((unsigned long )fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 366
    if (mode->hdisplay > fixed_mode->hdisplay) {
#line 367
      return (29);
    } else {

    }
#line 368
    if (mode->vdisplay > fixed_mode->vdisplay) {
#line 369
      return (29);
    } else {

    }
  } else {

  }
#line 371
  return (0);
}
}
#line 374 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"
bool psb_intel_lvds_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode  const  *mode ,
                               struct drm_display_mode *adjusted_mode ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct drm_encoder *tmp_encoder ;
  struct drm_display_mode *panel_fixed_mode ;
  struct gma_encoder *gma_encoder ;
  struct drm_encoder  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
#line 378
  dev = encoder->dev;
#line 379
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 380
  mode_dev = & dev_priv->mode_dev;
#line 381
  __mptr = (struct drm_crtc  const  *)encoder->crtc;
#line 381
  gma_crtc = (struct gma_crtc *)__mptr;
#line 383
  panel_fixed_mode = mode_dev->panel_fixed_mode;
#line 384
  __mptr___0 = (struct drm_encoder  const  *)encoder;
#line 384
  gma_encoder = (struct gma_encoder *)__mptr___0;
#line 386
  if (gma_encoder->type == 8) {
#line 387
    panel_fixed_mode = mode_dev->panel_fixed_mode2;
  } else {

  }
#line 390
  if (((int )(dev->pdev)->device & 65520) != 16640 && gma_crtc->pipe == 0) {
#line 391
    printk("\vCan\'t support LVDS on pipe A\n");
#line 392
    return (0);
  } else {

  }
#line 394
  if (((int )(dev->pdev)->device & 65520) == 16640 && gma_crtc->pipe != 0) {
#line 395
    printk("\vMust use PIPE A\n");
#line 396
    return (0);
  } else {

  }
#line 399
  __mptr___1 = (struct list_head  const  *)dev->mode_config.encoder_list.next;
#line 399
  tmp_encoder = (struct drm_encoder *)__mptr___1 + 0xfffffffffffffff8UL;
#line 399
  goto ldv_42020;
  ldv_42019: ;
#line 401
  if ((unsigned long )tmp_encoder != (unsigned long )encoder && (unsigned long )tmp_encoder->crtc == (unsigned long )encoder->crtc) {
#line 403
    printk("\vCan\'t enable LVDS and another encoder on the same pipe\n");
#line 405
    return (0);
  } else {

  }
#line 399
  __mptr___2 = (struct list_head  const  *)tmp_encoder->head.next;
#line 399
  tmp_encoder = (struct drm_encoder *)__mptr___2 + 0xfffffffffffffff8UL;
  ldv_42020: ;
#line 399
  if ((unsigned long )(& tmp_encoder->head) != (unsigned long )(& dev->mode_config.encoder_list)) {
#line 401
    goto ldv_42019;
  } else {

  }

#line 415
  if ((unsigned long )panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 416
    adjusted_mode->hdisplay = panel_fixed_mode->hdisplay;
#line 417
    adjusted_mode->hsync_start = panel_fixed_mode->hsync_start;
#line 418
    adjusted_mode->hsync_end = panel_fixed_mode->hsync_end;
#line 419
    adjusted_mode->htotal = panel_fixed_mode->htotal;
#line 420
    adjusted_mode->vdisplay = panel_fixed_mode->vdisplay;
#line 421
    adjusted_mode->vsync_start = panel_fixed_mode->vsync_start;
#line 422
    adjusted_mode->vsync_end = panel_fixed_mode->vsync_end;
#line 423
    adjusted_mode->vtotal = panel_fixed_mode->vtotal;
#line 424
    adjusted_mode->clock = panel_fixed_mode->clock;
#line 425
    drm_mode_set_crtcinfo(adjusted_mode, 1);
  } else {

  }
#line 435
  return (1);
}
}
#line 438 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"
static void psb_intel_lvds_prepare(struct drm_encoder *encoder ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  bool tmp ;
  int tmp___0 ;

  {
#line 440
  dev = encoder->dev;
#line 441
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 442
  mode_dev = & dev_priv->mode_dev;
#line 444
  tmp = gma_power_begin(dev, 1);
#line 444
  if (tmp) {
#line 444
    tmp___0 = 0;
  } else {
#line 444
    tmp___0 = 1;
  }
#line 444
  if (tmp___0) {
#line 445
    return;
  } else {

  }
#line 447
  mode_dev->saveBLC_PWM_CTL = REGISTER_READ(dev, 397908U);
#line 448
  mode_dev->backlight_duty_cycle = (int )mode_dev->saveBLC_PWM_CTL & 65535;
#line 451
  psb_intel_lvds_set_power(dev, 0);
#line 453
  gma_power_end(dev);
#line 454
  return;
}
}
#line 456 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"
static void psb_intel_lvds_commit(struct drm_encoder *encoder ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  u32 tmp ;

  {
#line 458
  dev = encoder->dev;
#line 459
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 460
  mode_dev = & dev_priv->mode_dev;
#line 462
  if (mode_dev->backlight_duty_cycle == 0) {
#line 463
    tmp = psb_intel_lvds_get_max_backlight(dev);
#line 463
    mode_dev->backlight_duty_cycle = (int )tmp;
  } else {

  }
#line 466
  psb_intel_lvds_set_power(dev, 1);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"
static void psb_intel_lvds_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                    struct drm_display_mode *adjusted_mode ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  u32 pfit_control ;

  {
#line 473
  dev = encoder->dev;
#line 474
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 488
  if (mode->hdisplay != adjusted_mode->hdisplay || mode->vdisplay != adjusted_mode->vdisplay) {
#line 490
    pfit_control = 2147485280U;
  } else {
#line 494
    pfit_control = 0U;
  }
#line 496
  if ((unsigned int )*((unsigned char *)dev_priv + 864UL) != 0U) {
#line 497
    pfit_control = pfit_control | 8U;
  } else {

  }
#line 499
  REGISTER_WRITE(dev, 397872U, pfit_control);
#line 500
  return;
}
}
#line 509 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"
static enum drm_connector_status psb_intel_lvds_detect(struct drm_connector *connector ,
                                                       bool force ) 
{ 


  {
#line 512
  return (1);
}
}
#line 518 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"
static int psb_intel_lvds_get_modes(struct drm_connector *connector ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct psb_intel_lvds_priv *lvds_priv ;
  int ret ;
  struct drm_display_mode *mode ;
  struct drm_display_mode *tmp___0 ;

  {
#line 520
  dev = connector->dev;
#line 521
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 522
  mode_dev = & dev_priv->mode_dev;
#line 523
  tmp = gma_attached_encoder(connector);
#line 523
  gma_encoder = tmp;
#line 524
  lvds_priv = (struct psb_intel_lvds_priv *)gma_encoder->dev_priv;
#line 525
  ret = 0;
#line 527
  if (((int )(dev->pdev)->device & 65520) != 16640) {
#line 528
    ret = psb_intel_ddc_get_modes(connector, & (lvds_priv->i2c_bus)->adapter);
  } else {

  }
#line 530
  if (ret != 0) {
#line 531
    return (ret);
  } else {

  }
#line 537
  connector->display_info.min_vfreq = 0U;
#line 538
  connector->display_info.max_vfreq = 200U;
#line 539
  connector->display_info.min_hfreq = 0U;
#line 540
  connector->display_info.max_hfreq = 200U;
#line 542
  if ((unsigned long )mode_dev->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 543
    tmp___0 = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)mode_dev->panel_fixed_mode);
#line 543
    mode = tmp___0;
#line 545
    drm_mode_probed_add(connector, mode);
#line 546
    return (1);
  } else {

  }
#line 549
  return (0);
}
}
#line 559 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"
void psb_intel_lvds_destroy(struct drm_connector *connector ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct psb_intel_lvds_priv *lvds_priv ;

  {
#line 561
  tmp = gma_attached_encoder(connector);
#line 561
  gma_encoder = tmp;
#line 562
  lvds_priv = (struct psb_intel_lvds_priv *)gma_encoder->dev_priv;
#line 564
  if ((unsigned long )lvds_priv->ddc_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 565
    psb_intel_i2c_destroy(lvds_priv->ddc_bus);
  } else {

  }
#line 566
  drm_connector_unregister(connector);
#line 567
  drm_connector_cleanup(connector);
#line 568
  kfree((void const   *)connector);
#line 569
  return;
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"
int psb_intel_lvds_set_property(struct drm_connector *connector , struct drm_property *property ,
                                uint64_t value ) 
{ 
  struct drm_encoder *encoder ;
  struct gma_crtc *crtc ;
  struct drm_crtc  const  *__mptr ;
  uint64_t curval ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct drm_encoder_helper_funcs  const  *hfuncs ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 575
  encoder = connector->encoder;
#line 577
  if ((unsigned long )encoder == (unsigned long )((struct drm_encoder *)0)) {
#line 578
    return (-1);
  } else {

  }
#line 580
  tmp___6 = strcmp((char const   *)(& property->name), "scaling mode");
#line 580
  if (tmp___6 == 0) {
#line 581
    __mptr = (struct drm_crtc  const  *)encoder->crtc;
#line 581
    crtc = (struct gma_crtc *)__mptr;
#line 584
    if ((unsigned long )crtc == (unsigned long )((struct gma_crtc *)0)) {
#line 585
      goto set_prop_error;
    } else {

    }
#line 587
    switch (value) {
    case 1ULL: ;
#line 589
    goto ldv_42073;
    case 2ULL: ;
#line 591
    goto ldv_42073;
    case 3ULL: ;
#line 593
    goto ldv_42073;
    default: ;
#line 595
    goto set_prop_error;
    }
    ldv_42073: 
#line 598
    tmp = drm_object_property_get_value(& connector->base, property, & curval);
#line 598
    if (tmp != 0) {
#line 601
      goto set_prop_error;
    } else {

    }
#line 603
    if (curval == value) {
#line 604
      goto set_prop_done;
    } else {

    }
#line 606
    tmp___0 = drm_object_property_set_value(& connector->base, property, value);
#line 606
    if (tmp___0 != 0) {
#line 609
      goto set_prop_error;
    } else {

    }
#line 611
    if (crtc->saved_mode.hdisplay != 0 && crtc->saved_mode.vdisplay != 0) {
#line 613
      tmp___1 = drm_crtc_helper_set_mode(encoder->crtc, & crtc->saved_mode, (encoder->crtc)->x,
                                         (encoder->crtc)->y, ((encoder->crtc)->primary)->fb);
#line 613
      if (tmp___1) {
#line 613
        tmp___2 = 0;
      } else {
#line 613
        tmp___2 = 1;
      }
#line 613
      if (tmp___2) {
#line 618
        goto set_prop_error;
      } else {

      }
    } else {

    }
  } else {
#line 620
    tmp___5 = strcmp((char const   *)(& property->name), "backlight");
#line 620
    if (tmp___5 == 0) {
#line 621
      tmp___3 = drm_object_property_set_value(& connector->base, property, value);
#line 621
      if (tmp___3 != 0) {
#line 624
        goto set_prop_error;
      } else {
#line 626
        gma_backlight_set(encoder->dev, (int )value);
      }
    } else {
#line 627
      tmp___4 = strcmp((char const   *)(& property->name), "DPMS");
#line 627
      if (tmp___4 == 0) {
#line 628
        hfuncs = (struct drm_encoder_helper_funcs  const  *)encoder->helper_private;
#line 630
        (*(hfuncs->dpms))(encoder, (int )value);
      } else {

      }
    }
  }
  set_prop_done: ;
#line 634
  return (0);
  set_prop_error: ;
#line 636
  return (-1);
}
}
#line 639 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"
static struct drm_encoder_helper_funcs  const  psb_intel_lvds_helper_funcs  = 
#line 639
     {& psb_intel_lvds_encoder_dpms, 0, 0, & psb_intel_lvds_mode_fixup, & psb_intel_lvds_prepare,
    & psb_intel_lvds_commit, & psb_intel_lvds_mode_set, 0, 0, 0, 0, 0};
#line 648 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"
struct drm_connector_helper_funcs  const  psb_intel_lvds_connector_helper_funcs  =    {& psb_intel_lvds_get_modes,
    (enum drm_mode_status (*)(struct drm_connector * , struct drm_display_mode * ))(& psb_intel_lvds_mode_valid),
    & gma_best_encoder};
#line 654 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"
struct drm_connector_funcs  const  psb_intel_lvds_connector_funcs  = 
#line 654
     {& drm_helper_connector_dpms, & psb_intel_lvds_save, & psb_intel_lvds_restore,
    0, & psb_intel_lvds_detect, & drm_helper_probe_single_connector_modes, & psb_intel_lvds_set_property,
    & psb_intel_lvds_destroy, 0, 0, 0, 0, 0};
#line 665 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"
static void psb_intel_lvds_enc_destroy(struct drm_encoder *encoder ) 
{ 


  {
#line 667
  drm_encoder_cleanup(encoder);
#line 668
  return;
}
}
#line 670 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"
struct drm_encoder_funcs  const  psb_intel_lvds_enc_funcs  =    {0, & psb_intel_lvds_enc_destroy};
#line 683 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c"
void psb_intel_lvds_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_connector *gma_connector ;
  struct psb_intel_lvds_priv *lvds_priv ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct drm_display_mode *scan ;
  struct drm_crtc *crtc ;
  struct drm_psb_private *dev_priv ;
  u32 lvds ;
  int pipe ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 693
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 697
  tmp = kzalloc(152UL, 208U);
#line 697
  gma_encoder = (struct gma_encoder *)tmp;
#line 698
  if ((unsigned long )gma_encoder == (unsigned long )((struct gma_encoder *)0)) {
#line 699
    dev_err((struct device  const  *)dev->dev, "gma_encoder allocation error\n");
#line 700
    return;
  } else {

  }
#line 703
  tmp___0 = kzalloc(944UL, 208U);
#line 703
  gma_connector = (struct gma_connector *)tmp___0;
#line 704
  if ((unsigned long )gma_connector == (unsigned long )((struct gma_connector *)0)) {
#line 705
    dev_err((struct device  const  *)dev->dev, "gma_connector allocation error\n");
#line 706
    goto failed_encoder;
  } else {

  }
#line 709
  tmp___1 = kzalloc(48UL, 208U);
#line 709
  lvds_priv = (struct psb_intel_lvds_priv *)tmp___1;
#line 710
  if ((unsigned long )lvds_priv == (unsigned long )((struct psb_intel_lvds_priv *)0)) {
#line 711
    dev_err((struct device  const  *)dev->dev, "LVDS private allocation error\n");
#line 712
    goto failed_connector;
  } else {

  }
#line 715
  gma_encoder->dev_priv = (void *)lvds_priv;
#line 717
  connector = & gma_connector->base;
#line 718
  encoder = & gma_encoder->base;
#line 719
  drm_connector_init(dev, connector, & psb_intel_lvds_connector_funcs, 7);
#line 723
  drm_encoder_init(dev, encoder, & psb_intel_lvds_enc_funcs, 3);
#line 727
  gma_connector_attach_encoder(gma_connector, gma_encoder);
#line 728
  gma_encoder->type = 4;
#line 730
  drm_encoder_helper_add(encoder, & psb_intel_lvds_helper_funcs);
#line 731
  drm_connector_helper_add(connector, & psb_intel_lvds_connector_helper_funcs);
#line 733
  connector->display_info.subpixel_order = 1;
#line 734
  connector->interlace_allowed = 0;
#line 735
  connector->doublescan_allowed = 0;
#line 738
  drm_object_attach_property(& connector->base, dev->mode_config.scaling_mode_property,
                             1ULL);
#line 741
  drm_object_attach_property(& connector->base, dev_priv->backlight_property, 100ULL);
#line 749
  lvds_priv->i2c_bus = psb_intel_i2c_create(dev, 20500U, "LVDSBLC_B");
#line 750
  if ((unsigned long )lvds_priv->i2c_bus == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 751
    dev_printk("\v", (struct device  const  *)(& (dev->pdev)->dev), "I2C bus registration failed.\n");
#line 753
    goto failed_blc_i2c;
  } else {

  }
#line 755
  (lvds_priv->i2c_bus)->slave_addr = 44U;
#line 756
  dev_priv->lvds_i2c_bus = lvds_priv->i2c_bus;
#line 769
  lvds_priv->ddc_bus = psb_intel_i2c_create(dev, 20504U, "LVDSDDC_C");
#line 770
  if ((unsigned long )lvds_priv->ddc_bus == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 771
    dev_printk("\v", (struct device  const  *)(& (dev->pdev)->dev), "DDC bus registration failed.\n");
#line 773
    goto failed_ddc;
  } else {

  }
#line 780
  ldv_mutex_lock_751(& dev->mode_config.mutex);
#line 781
  psb_intel_ddc_get_modes(connector, & (lvds_priv->ddc_bus)->adapter);
#line 782
  __mptr = (struct list_head  const  *)connector->probed_modes.next;
#line 782
  scan = (struct drm_display_mode *)__mptr;
#line 782
  goto ldv_42110;
  ldv_42109: ;
#line 783
  if ((scan->type & 8U) != 0U) {
#line 784
    mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)scan);
#line 786
    goto out;
  } else {

  }
#line 782
  __mptr___0 = (struct list_head  const  *)scan->head.next;
#line 782
  scan = (struct drm_display_mode *)__mptr___0;
  ldv_42110: ;
#line 782
  if ((unsigned long )(& scan->head) != (unsigned long )(& connector->probed_modes)) {
#line 784
    goto ldv_42109;
  } else {

  }

#line 791
  if ((unsigned long )mode_dev->vbt_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 792
    mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)mode_dev->vbt_mode);
  } else {

  }
#line 795
  if ((unsigned long )mode_dev->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 796
    if ((unsigned long )dev_priv->lfp_lvds_vbt_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 797
      mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)dev_priv->lfp_lvds_vbt_mode);
    } else {

    }
  } else {

  }
#line 806
  lvds = REGISTER_READ(dev, 397696U);
#line 807
  pipe = (lvds & 1073741824U) != 0U;
#line 808
  crtc = psb_intel_get_crtc_from_pipe(dev, pipe);
#line 810
  if ((unsigned long )crtc != (unsigned long )((struct drm_crtc *)0) && (int )lvds < 0) {
#line 811
    mode_dev->panel_fixed_mode = psb_intel_crtc_mode_get(dev, crtc);
#line 813
    if ((unsigned long )mode_dev->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 814
      (mode_dev->panel_fixed_mode)->type = (mode_dev->panel_fixed_mode)->type | 8U;
#line 816
      goto out;
    } else {

    }
  } else {

  }
#line 821
  if ((unsigned long )mode_dev->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 822
    dev_err((struct device  const  *)dev->dev, "Found no modes on the lvds, ignoring the LVDS\n");
#line 823
    goto failed_find;
  } else {

  }
  out: 
#line 831
  ldv_mutex_unlock_752(& dev->mode_config.mutex);
#line 832
  drm_connector_register(connector);
#line 833
  return;
  failed_find: 
#line 836
  ldv_mutex_unlock_753(& dev->mode_config.mutex);
#line 837
  if ((unsigned long )lvds_priv->ddc_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 838
    psb_intel_i2c_destroy(lvds_priv->ddc_bus);
  } else {

  }
  failed_ddc: ;
#line 840
  if ((unsigned long )lvds_priv->i2c_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 841
    psb_intel_i2c_destroy(lvds_priv->i2c_bus);
  } else {

  }
  failed_blc_i2c: 
#line 843
  drm_encoder_cleanup(encoder);
#line 844
  drm_connector_cleanup(connector);
  failed_connector: 
#line 846
  kfree((void const   *)gma_connector);
  failed_encoder: 
#line 848
  kfree((void const   *)gma_encoder);
#line 849
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
extern int ldv_probe_41(void) ;
#line 405
extern int ldv_probe_42(void) ;
#line 408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_initialize_drm_encoder_helper_funcs_44(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 409
  tmp = ldv_init_zalloc(96UL);
#line 409
  psb_intel_lvds_helper_funcs_group0 = (struct drm_encoder *)tmp;
#line 410
  tmp___0 = ldv_init_zalloc(208UL);
#line 410
  psb_intel_lvds_helper_funcs_group1 = (struct drm_display_mode *)tmp___0;
#line 411
  return;
}
}
#line 413 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_initialize_drm_connector_helper_funcs_43(void) 
{ 
  void *tmp ;

  {
#line 414
  tmp = ldv_init_zalloc(936UL);
#line 414
  psb_intel_lvds_connector_helper_funcs_group0 = (struct drm_connector *)tmp;
#line 415
  return;
}
}
#line 417 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_initialize_drm_connector_funcs_42(void) 
{ 
  void *tmp ;

  {
#line 418
  tmp = ldv_init_zalloc(936UL);
#line 418
  psb_intel_lvds_connector_funcs_group0 = (struct drm_connector *)tmp;
#line 419
  return;
}
}
#line 421 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_main_exported_42(void) 
{ 
  bool ldvarg115 ;
  struct drm_property *ldvarg114 ;
  void *tmp ;
  uint64_t ldvarg113 ;
  uint32_t ldvarg112 ;
  int ldvarg116 ;
  uint32_t ldvarg111 ;
  int tmp___0 ;

  {
#line 423
  tmp = ldv_init_zalloc(104UL);
#line 423
  ldvarg114 = (struct drm_property *)tmp;
#line 422
  ldv_memset((void *)(& ldvarg115), 0, 1UL);
#line 424
  ldv_memset((void *)(& ldvarg113), 0, 8UL);
#line 425
  ldv_memset((void *)(& ldvarg112), 0, 4UL);
#line 426
  ldv_memset((void *)(& ldvarg116), 0, 4UL);
#line 427
  ldv_memset((void *)(& ldvarg111), 0, 4UL);
#line 429
  tmp___0 = __VERIFIER_nondet_int();
#line 429
  switch (tmp___0) {
  case 0: ;
#line 432
  if (ldv_state_variable_42 == 1) {
#line 434
    drm_helper_connector_dpms(psb_intel_lvds_connector_funcs_group0, ldvarg116);
#line 436
    ldv_state_variable_42 = 1;
  } else {

  }
#line 439
  if (ldv_state_variable_42 == 2) {
#line 441
    drm_helper_connector_dpms(psb_intel_lvds_connector_funcs_group0, ldvarg116);
#line 443
    ldv_state_variable_42 = 2;
  } else {

  }
#line 446
  goto ldv_42136;
  case 1: ;
#line 449
  if (ldv_state_variable_42 == 1) {
#line 451
    psb_intel_lvds_detect(psb_intel_lvds_connector_funcs_group0, (int )ldvarg115);
#line 453
    ldv_state_variable_42 = 1;
  } else {

  }
#line 456
  if (ldv_state_variable_42 == 2) {
#line 458
    psb_intel_lvds_detect(psb_intel_lvds_connector_funcs_group0, (int )ldvarg115);
#line 460
    ldv_state_variable_42 = 2;
  } else {

  }
#line 463
  goto ldv_42136;
  case 2: ;
#line 466
  if (ldv_state_variable_42 == 1) {
#line 468
    psb_intel_lvds_set_property(psb_intel_lvds_connector_funcs_group0, ldvarg114,
                                ldvarg113);
#line 470
    ldv_state_variable_42 = 1;
  } else {

  }
#line 473
  if (ldv_state_variable_42 == 2) {
#line 475
    psb_intel_lvds_set_property(psb_intel_lvds_connector_funcs_group0, ldvarg114,
                                ldvarg113);
#line 477
    ldv_state_variable_42 = 2;
  } else {

  }
#line 480
  goto ldv_42136;
  case 3: ;
#line 483
  if (ldv_state_variable_42 == 2) {
#line 485
    psb_intel_lvds_destroy(psb_intel_lvds_connector_funcs_group0);
#line 487
    ldv_state_variable_42 = 1;
#line 488
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 491
  goto ldv_42136;
  case 4: ;
#line 494
  if (ldv_state_variable_42 == 1) {
#line 496
    psb_intel_lvds_save(psb_intel_lvds_connector_funcs_group0);
#line 498
    ldv_state_variable_42 = 1;
  } else {

  }
#line 501
  if (ldv_state_variable_42 == 2) {
#line 503
    psb_intel_lvds_save(psb_intel_lvds_connector_funcs_group0);
#line 505
    ldv_state_variable_42 = 2;
  } else {

  }
#line 508
  goto ldv_42136;
  case 5: ;
#line 511
  if (ldv_state_variable_42 == 1) {
#line 513
    psb_intel_lvds_restore(psb_intel_lvds_connector_funcs_group0);
#line 515
    ldv_state_variable_42 = 1;
  } else {

  }
#line 518
  if (ldv_state_variable_42 == 2) {
#line 520
    psb_intel_lvds_restore(psb_intel_lvds_connector_funcs_group0);
#line 522
    ldv_state_variable_42 = 2;
  } else {

  }
#line 525
  goto ldv_42136;
  case 6: ;
#line 528
  if (ldv_state_variable_42 == 1) {
#line 530
    drm_helper_probe_single_connector_modes(psb_intel_lvds_connector_funcs_group0,
                                            ldvarg112, ldvarg111);
#line 532
    ldv_state_variable_42 = 1;
  } else {

  }
#line 535
  if (ldv_state_variable_42 == 2) {
#line 537
    drm_helper_probe_single_connector_modes(psb_intel_lvds_connector_funcs_group0,
                                            ldvarg112, ldvarg111);
#line 539
    ldv_state_variable_42 = 2;
  } else {

  }
#line 542
  goto ldv_42136;
  case 7: ;
#line 545
  if (ldv_state_variable_42 == 1) {
#line 547
    ldv_probe_42();
#line 549
    ldv_state_variable_42 = 2;
#line 550
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 553
  goto ldv_42136;
  default: 
#line 554
  ldv_stop();
  }
  ldv_42136: ;
#line 558
  return;
}
}
#line 560 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_main_exported_43(void) 
{ 
  struct drm_display_mode *ldvarg212 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 561
  tmp = ldv_init_zalloc(208UL);
#line 561
  ldvarg212 = (struct drm_display_mode *)tmp;
#line 563
  tmp___0 = __VERIFIER_nondet_int();
#line 563
  switch (tmp___0) {
  case 0: ;
#line 566
  if (ldv_state_variable_43 == 1) {
#line 568
    psb_intel_lvds_get_modes(psb_intel_lvds_connector_helper_funcs_group0);
#line 570
    ldv_state_variable_43 = 1;
  } else {

  }
#line 573
  goto ldv_42150;
  case 1: ;
#line 576
  if (ldv_state_variable_43 == 1) {
#line 578
    psb_intel_lvds_mode_valid(psb_intel_lvds_connector_helper_funcs_group0, ldvarg212);
#line 580
    ldv_state_variable_43 = 1;
  } else {

  }
#line 583
  goto ldv_42150;
  case 2: ;
#line 586
  if (ldv_state_variable_43 == 1) {
#line 588
    gma_best_encoder(psb_intel_lvds_connector_helper_funcs_group0);
#line 590
    ldv_state_variable_43 = 1;
  } else {

  }
#line 593
  goto ldv_42150;
  default: 
#line 594
  ldv_stop();
  }
  ldv_42150: ;
#line 598
  return;
}
}
#line 600 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_main_exported_44(void) 
{ 
  struct drm_display_mode *ldvarg25 ;
  void *tmp ;
  struct drm_display_mode *ldvarg26 ;
  void *tmp___0 ;
  int ldvarg27 ;
  int tmp___1 ;

  {
#line 601
  tmp = ldv_init_zalloc(208UL);
#line 601
  ldvarg25 = (struct drm_display_mode *)tmp;
#line 602
  tmp___0 = ldv_init_zalloc(208UL);
#line 602
  ldvarg26 = (struct drm_display_mode *)tmp___0;
#line 603
  ldv_memset((void *)(& ldvarg27), 0, 4UL);
#line 605
  tmp___1 = __VERIFIER_nondet_int();
#line 605
  switch (tmp___1) {
  case 0: ;
#line 608
  if (ldv_state_variable_44 == 1) {
#line 610
    psb_intel_lvds_encoder_dpms(psb_intel_lvds_helper_funcs_group0, ldvarg27);
#line 612
    ldv_state_variable_44 = 1;
  } else {

  }
#line 615
  goto ldv_42161;
  case 1: ;
#line 618
  if (ldv_state_variable_44 == 1) {
#line 620
    psb_intel_lvds_mode_fixup(psb_intel_lvds_helper_funcs_group0, (struct drm_display_mode  const  *)ldvarg26,
                              psb_intel_lvds_helper_funcs_group1);
#line 622
    ldv_state_variable_44 = 1;
  } else {

  }
#line 625
  goto ldv_42161;
  case 2: ;
#line 628
  if (ldv_state_variable_44 == 1) {
#line 630
    psb_intel_lvds_commit(psb_intel_lvds_helper_funcs_group0);
#line 632
    ldv_state_variable_44 = 1;
  } else {

  }
#line 635
  goto ldv_42161;
  case 3: ;
#line 638
  if (ldv_state_variable_44 == 1) {
#line 640
    psb_intel_lvds_mode_set(psb_intel_lvds_helper_funcs_group0, psb_intel_lvds_helper_funcs_group1,
                            ldvarg25);
#line 642
    ldv_state_variable_44 = 1;
  } else {

  }
#line 645
  goto ldv_42161;
  case 4: ;
#line 648
  if (ldv_state_variable_44 == 1) {
#line 650
    psb_intel_lvds_prepare(psb_intel_lvds_helper_funcs_group0);
#line 652
    ldv_state_variable_44 = 1;
  } else {

  }
#line 655
  goto ldv_42161;
  default: 
#line 656
  ldv_stop();
  }
  ldv_42161: ;
#line 660
  return;
}
}
#line 662 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_main_exported_41(void) 
{ 
  struct drm_encoder *ldvarg172 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 663
  tmp = ldv_init_zalloc(96UL);
#line 663
  ldvarg172 = (struct drm_encoder *)tmp;
#line 665
  tmp___0 = __VERIFIER_nondet_int();
#line 665
  switch (tmp___0) {
  case 0: ;
#line 668
  if (ldv_state_variable_41 == 2) {
#line 670
    psb_intel_lvds_enc_destroy(ldvarg172);
#line 672
    ldv_state_variable_41 = 1;
#line 673
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 676
  goto ldv_42172;
  case 1: ;
#line 679
  if (ldv_state_variable_41 == 1) {
#line 681
    ldv_probe_41();
#line 683
    ldv_state_variable_41 = 2;
#line 684
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 687
  goto ldv_42172;
  default: 
#line 688
  ldv_stop();
  }
  ldv_42172: ;
#line 692
  return;
}
}
#line 717 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
bool ldv_queue_work_on_730(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 721
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 721
  ldv_func_res = tmp;
#line 723
  activate_work_2(ldv_func_arg3, 2);
#line 725
  return (ldv_func_res);
}
}
#line 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
bool ldv_queue_delayed_work_on_731(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 732
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 732
  ldv_func_res = tmp;
#line 734
  activate_work_2(& ldv_func_arg3->work, 2);
#line 736
  return (ldv_func_res);
}
}
#line 739 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
bool ldv_queue_work_on_732(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 743
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 743
  ldv_func_res = tmp;
#line 745
  activate_work_2(ldv_func_arg3, 2);
#line 747
  return (ldv_func_res);
}
}
#line 750 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_flush_workqueue_733(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 753
  flush_workqueue(ldv_func_arg1);
#line 755
  call_and_disable_all_2(2);
#line 756
  return;
}
}
#line 758 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
bool ldv_queue_delayed_work_on_734(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 762
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 762
  ldv_func_res = tmp;
#line 764
  activate_work_2(& ldv_func_arg3->work, 2);
#line 766
  return (ldv_func_res);
}
}
#line 769 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_mutex_lock_735(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 772
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 774
  mutex_lock(ldv_func_arg1);
#line 775
  return;
}
}
#line 777 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_mutex_unlock_736(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 780
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 782
  mutex_unlock(ldv_func_arg1);
#line 783
  return;
}
}
#line 785 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_mutex_lock_737(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 788
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 790
  mutex_lock(ldv_func_arg1);
#line 791
  return;
}
}
#line 793 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
int ldv_mutex_trylock_738(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 797
  tmp = mutex_trylock(ldv_func_arg1);
#line 797
  ldv_func_res = tmp;
#line 799
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 799
  return (tmp___0);
#line 801
  return (ldv_func_res);
}
}
#line 804 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_mutex_unlock_739(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 807
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 809
  mutex_unlock(ldv_func_arg1);
#line 810
  return;
}
}
#line 812 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_mutex_unlock_740(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 815
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 817
  mutex_unlock(ldv_func_arg1);
#line 818
  return;
}
}
#line 820 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_mutex_lock_741(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 823
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 825
  mutex_lock(ldv_func_arg1);
#line 826
  return;
}
}
#line 828 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_mutex_lock_742(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 831
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 833
  mutex_lock(ldv_func_arg1);
#line 834
  return;
}
}
#line 836 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_mutex_unlock_743(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 839
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 841
  mutex_unlock(ldv_func_arg1);
#line 842
  return;
}
}
#line 844 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_mutex_unlock_744(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 847
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 849
  mutex_unlock(ldv_func_arg1);
#line 850
  return;
}
}
#line 852 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_mutex_lock_745(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 855
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 857
  mutex_lock(ldv_func_arg1);
#line 858
  return;
}
}
#line 860 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
int ldv_mutex_lock_interruptible_746(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 864
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 864
  ldv_func_res = tmp;
#line 866
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 866
  return (tmp___0);
#line 868
  return (ldv_func_res);
}
}
#line 871 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
int ldv_mutex_trylock_747(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 875
  tmp = mutex_trylock(ldv_func_arg1);
#line 875
  ldv_func_res = tmp;
#line 877
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 877
  return (tmp___0);
#line 879
  return (ldv_func_res);
}
}
#line 903 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_mutex_unlock_750(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 906
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 908
  mutex_unlock(ldv_func_arg1);
#line 909
  return;
}
}
#line 911 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_mutex_lock_751(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 914
  ldv_mutex_lock_mutex_of_drm_mode_config(ldv_func_arg1);
#line 916
  mutex_lock(ldv_func_arg1);
#line 917
  return;
}
}
#line 919 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_mutex_unlock_752(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 922
  ldv_mutex_unlock_mutex_of_drm_mode_config(ldv_func_arg1);
#line 924
  mutex_unlock(ldv_func_arg1);
#line 925
  return;
}
}
#line 927 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_mutex_unlock_753(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 930
  ldv_mutex_unlock_mutex_of_drm_mode_config(ldv_func_arg1);
#line 932
  mutex_unlock(ldv_func_arg1);
#line 933
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_789(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_798(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_787(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_790(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_791(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_794(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_795(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_modes.o.c.prepared"
int ldv_mutex_lock_interruptible_797(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_786(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_788(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_792(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_793(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_796(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_781(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_783(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_782(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_785(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_784(struct workqueue_struct *ldv_func_arg1 ) ;
#line 1331 "include/drm/drm_crtc.h"
extern struct edid *drm_get_edid(struct drm_connector * , struct i2c_adapter * ) ;
#line 1334
extern int drm_add_edid_modes(struct drm_connector * , struct edid * ) ;
#line 1342
extern int drm_mode_connector_update_edid_property(struct drm_connector * , struct edid  const  * ) ;
#line 210 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
bool psb_intel_ddc_probe(struct i2c_adapter *adapter ) ;
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_modes.c"
bool psb_intel_ddc_probe(struct i2c_adapter *adapter ) 
{ 
  u8 out_buf[2U] ;
  u8 buf[2U] ;
  int ret ;
  struct i2c_msg msgs[2U] ;

  {
#line 31
  out_buf[0] = 0U;
#line 31
  out_buf[1] = 0U;
#line 34
  msgs[0].addr = 80U;
#line 34
  msgs[0].flags = 0U;
#line 34
  msgs[0].len = 1U;
#line 34
  msgs[0].buf = (__u8 *)(& out_buf);
#line 34
  msgs[1].addr = 80U;
#line 34
  msgs[1].flags = 1U;
#line 34
  msgs[1].len = 1U;
#line 34
  msgs[1].buf = (__u8 *)(& buf);
#line 49
  ret = i2c_transfer(adapter, (struct i2c_msg *)(& msgs), 2);
#line 50
  if (ret == 2) {
#line 51
    return (1);
  } else {

  }
#line 53
  return (0);
}
}
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_modes.c"
int psb_intel_ddc_get_modes(struct drm_connector *connector , struct i2c_adapter *adapter ) 
{ 
  struct edid *edid ;
  int ret ;

  {
#line 66
  ret = 0;
#line 68
  edid = drm_get_edid(connector, adapter);
#line 69
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
#line 70
    drm_mode_connector_update_edid_property(connector, (struct edid  const  *)edid);
#line 71
    ret = drm_add_edid_modes(connector, edid);
#line 72
    kfree((void const   *)edid);
  } else {

  }
#line 74
  return (ret);
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_modes.o.c.prepared"
bool ldv_queue_work_on_781(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 432
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 432
  ldv_func_res = tmp;
#line 434
  activate_work_2(ldv_func_arg3, 2);
#line 436
  return (ldv_func_res);
}
}
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_modes.o.c.prepared"
bool ldv_queue_delayed_work_on_782(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 443
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 443
  ldv_func_res = tmp;
#line 445
  activate_work_2(& ldv_func_arg3->work, 2);
#line 447
  return (ldv_func_res);
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_modes.o.c.prepared"
bool ldv_queue_work_on_783(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 454
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 454
  ldv_func_res = tmp;
#line 456
  activate_work_2(ldv_func_arg3, 2);
#line 458
  return (ldv_func_res);
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_modes.o.c.prepared"
void ldv_flush_workqueue_784(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 464
  flush_workqueue(ldv_func_arg1);
#line 466
  call_and_disable_all_2(2);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_modes.o.c.prepared"
bool ldv_queue_delayed_work_on_785(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 473
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 473
  ldv_func_res = tmp;
#line 475
  activate_work_2(& ldv_func_arg3->work, 2);
#line 477
  return (ldv_func_res);
}
}
#line 480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_modes.o.c.prepared"
void ldv_mutex_lock_786(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 483
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 485
  mutex_lock(ldv_func_arg1);
#line 486
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_modes.o.c.prepared"
void ldv_mutex_unlock_787(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 491
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 493
  mutex_unlock(ldv_func_arg1);
#line 494
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_modes.o.c.prepared"
void ldv_mutex_lock_788(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 499
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 501
  mutex_lock(ldv_func_arg1);
#line 502
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_modes.o.c.prepared"
int ldv_mutex_trylock_789(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 508
  tmp = mutex_trylock(ldv_func_arg1);
#line 508
  ldv_func_res = tmp;
#line 510
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 510
  return (tmp___0);
#line 512
  return (ldv_func_res);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_modes.o.c.prepared"
void ldv_mutex_unlock_790(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 518
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 520
  mutex_unlock(ldv_func_arg1);
#line 521
  return;
}
}
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_modes.o.c.prepared"
void ldv_mutex_unlock_791(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 526
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 528
  mutex_unlock(ldv_func_arg1);
#line 529
  return;
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_modes.o.c.prepared"
void ldv_mutex_lock_792(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 534
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 536
  mutex_lock(ldv_func_arg1);
#line 537
  return;
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_modes.o.c.prepared"
void ldv_mutex_lock_793(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 542
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 544
  mutex_lock(ldv_func_arg1);
#line 545
  return;
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_modes.o.c.prepared"
void ldv_mutex_unlock_794(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 550
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 552
  mutex_unlock(ldv_func_arg1);
#line 553
  return;
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_modes.o.c.prepared"
void ldv_mutex_unlock_795(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 558
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 560
  mutex_unlock(ldv_func_arg1);
#line 561
  return;
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_modes.o.c.prepared"
void ldv_mutex_lock_796(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 566
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 568
  mutex_lock(ldv_func_arg1);
#line 569
  return;
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_modes.o.c.prepared"
int ldv_mutex_lock_interruptible_797(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 575
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 575
  ldv_func_res = tmp;
#line 577
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 577
  return (tmp___0);
#line 579
  return (ldv_func_res);
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_modes.o.c.prepared"
int ldv_mutex_trylock_798(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 586
  tmp = mutex_trylock(ldv_func_arg1);
#line 586
  ldv_func_res = tmp;
#line 588
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 588
  return (tmp___0);
#line 590
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
void *__builtin_alloca(unsigned long  ) ;
#line 1
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 187 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 189
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_831(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_840(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_829(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_832(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_833(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_836(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_837(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_843(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
int ldv_mutex_lock_interruptible_839(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_828(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_830(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_834(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_835(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_838(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_823(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_825(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_824(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_827(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_826(struct workqueue_struct *ldv_func_arg1 ) ;
#line 184 "include/drm/drm_modes.h"
extern void drm_mode_destroy(struct drm_device * , struct drm_display_mode * ) ;
#line 1385 "include/drm/drm_crtc.h"
extern struct drm_property *drm_property_create(struct drm_device * , int  , char const   * ,
                                                int  ) ;
#line 1414
extern int drm_property_add_enum(struct drm_property * , int  , uint64_t  , char const   * ) ;
#line 1486
extern bool drm_detect_hdmi_monitor(struct edid * ) ;
#line 1487
extern bool drm_detect_monitor_audio(struct edid * ) ;
#line 73 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
__inline static void psb_intel_mode_set_pixel_multiplier(struct drm_display_mode *mode ,
                                                         int multiplier ) 
{ 


  {
#line 76
  mode->clock = mode->clock * multiplier;
#line 77
  mode->private_flags = mode->private_flags | multiplier;
#line 78
  return;
}
}
#line 81 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
__inline static int psb_intel_mode_get_pixel_multiplier(struct drm_display_mode  const  *mode ) 
{ 


  {
#line 83
  return ((int )mode->private_flags & 15);
}
}
#line 215
bool psb_intel_sdvo_init(struct drm_device *dev , int sdvo_reg ) ;
#line 829 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
__inline static uint32_t REGISTER_READ_AUX(struct drm_device *dev , uint32_t reg ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned int tmp ;

  {
#line 831
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 832
  tmp = ioread32((void *)dev_priv->aux_reg + (unsigned long )reg);
#line 832
  return (tmp);
}
}
#line 839 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
__inline static uint32_t REGISTER_READ_WITH_AUX(struct drm_device *dev , uint32_t reg ,
                                                int aux ) 
{ 
  uint32_t val ;

  {
#line 844
  if (aux != 0) {
#line 845
    val = REGISTER_READ_AUX(dev, reg);
  } else {
#line 847
    val = REGISTER_READ(dev, reg);
  }
#line 849
  return (val);
}
}
#line 861 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
__inline static void REGISTER_WRITE_AUX(struct drm_device *dev , uint32_t reg , uint32_t val ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 864
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 865
  iowrite32(val, (void *)dev_priv->aux_reg + (unsigned long )reg);
#line 866
  return;
}
}
#line 871 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
__inline static void REGISTER_WRITE_WITH_AUX(struct drm_device *dev , uint32_t reg ,
                                             uint32_t val , int aux ) 
{ 


  {
#line 874
  if (aux != 0) {
#line 875
    REGISTER_WRITE_AUX(dev, reg, val);
  } else {
#line 877
    REGISTER_WRITE(dev, reg, val);
  }
#line 878
  return;
}
}
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static char const   *tv_format_names[19U]  = 
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
  {      "NTSC_M",      "NTSC_J",      "NTSC_443",      "PAL_B", 
        "PAL_D",      "PAL_G",      "PAL_H",      "PAL_I", 
        "PAL_M",      "PAL_N",      "PAL_NC",      "PAL_60", 
        "SECAM_B",      "SECAM_D",      "SECAM_G",      "SECAM_K", 
        "SECAM_K1",      "SECAM_L",      "SECAM_60"};
#line 196 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static struct psb_intel_sdvo *to_psb_intel_sdvo(struct drm_encoder *encoder ) 
{ 
  struct drm_encoder  const  *__mptr ;

  {
#line 198
  __mptr = (struct drm_encoder  const  *)encoder;
#line 198
  return ((struct psb_intel_sdvo *)__mptr);
}
}
#line 201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static struct psb_intel_sdvo *intel_attached_sdvo(struct drm_connector *connector ) 
{ 
  struct gma_encoder  const  *__mptr ;
  struct gma_encoder *tmp ;

  {
#line 203
  tmp = gma_attached_encoder(connector);
#line 203
  __mptr = (struct gma_encoder  const  *)tmp;
#line 203
  return ((struct psb_intel_sdvo *)__mptr);
}
}
#line 207 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static struct psb_intel_sdvo_connector *to_psb_intel_sdvo_connector(struct drm_connector *connector ) 
{ 
  struct gma_connector  const  *__mptr ;
  struct drm_connector  const  *__mptr___0 ;

  {
#line 209
  __mptr___0 = (struct drm_connector  const  *)connector;
#line 209
  __mptr = (struct gma_connector  const  *)((struct gma_connector *)__mptr___0);
#line 209
  return ((struct psb_intel_sdvo_connector *)__mptr);
}
}
#line 213
static bool psb_intel_sdvo_output_setup(struct psb_intel_sdvo *psb_intel_sdvo , uint16_t flags ) ;
#line 215
static bool psb_intel_sdvo_tv_create_property(struct psb_intel_sdvo *psb_intel_sdvo ,
                                              struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ,
                                              int type ) ;
#line 219
static bool psb_intel_sdvo_create_enhance_property(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                   struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ) ;
#line 227 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static void psb_intel_sdvo_write_sdvox(struct psb_intel_sdvo *psb_intel_sdvo , u32 val ) 
{ 
  struct drm_device *dev ;
  u32 bval ;
  u32 cval ;
  int i ;
  int j ;
  int need_aux ;

  {
#line 229
  dev = psb_intel_sdvo->base.base.dev;
#line 230
  bval = val;
#line 230
  cval = val;
#line 232
  need_aux = ((int )(dev->pdev)->device & 65520) == 16640;
#line 234
  j = 0;
#line 234
  goto ldv_42441;
  ldv_42440: ;
#line 235
  if (psb_intel_sdvo->sdvo_reg == 397632) {
#line 236
    cval = REGISTER_READ_WITH_AUX(dev, 397664U, j);
  } else {
#line 238
    bval = REGISTER_READ_WITH_AUX(dev, 397632U, j);
  }
#line 245
  i = 0;
#line 245
  goto ldv_42438;
  ldv_42437: 
#line 246
  REGISTER_WRITE_WITH_AUX(dev, 397632U, bval, j);
#line 247
  REGISTER_READ_WITH_AUX(dev, 397632U, j);
#line 248
  REGISTER_WRITE_WITH_AUX(dev, 397664U, cval, j);
#line 249
  REGISTER_READ_WITH_AUX(dev, 397664U, j);
#line 245
  i = i + 1;
  ldv_42438: ;
#line 245
  if (i <= 1) {
#line 247
    goto ldv_42437;
  } else {

  }
#line 234
  j = j + 1;
  ldv_42441: ;
#line 234
  if (j <= need_aux) {
#line 236
    goto ldv_42440;
  } else {

  }

#line 241
  return;
}
}
#line 254 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_read_byte(struct psb_intel_sdvo *psb_intel_sdvo , u8 addr ,
                                     u8 *ch ) 
{ 
  struct i2c_msg msgs[2U] ;
  int ret ;
  long tmp ;

  {
#line 256
  msgs[0].addr = (unsigned short )psb_intel_sdvo->slave_addr;
#line 256
  msgs[0].flags = 0U;
#line 256
  msgs[0].len = 1U;
#line 256
  msgs[0].buf = & addr;
#line 256
  msgs[1].addr = (unsigned short )psb_intel_sdvo->slave_addr;
#line 256
  msgs[1].flags = 1U;
#line 256
  msgs[1].len = 1U;
#line 256
  msgs[1].buf = ch;
#line 272
  ret = i2c_transfer(psb_intel_sdvo->i2c, (struct i2c_msg *)(& msgs), 2);
#line 272
  if (ret == 2) {
#line 273
    return (1);
  } else {

  }
#line 275
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 275
  if (tmp != 0L) {
#line 275
    drm_ut_debug_printk("psb_intel_sdvo_read_byte", "i2c transfer returned %d\n",
                        ret);
  } else {

  }
#line 276
  return (0);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static struct _sdvo_cmd_name  const  sdvo_cmd_names[107U]  = 
#line 284
  {      {1U, "SDVO_CMD_RESET"}, 
        {2U, "SDVO_CMD_GET_DEVICE_CAPS"}, 
        {134U, "SDVO_CMD_GET_FIRMWARE_REV"}, 
        {3U, "SDVO_CMD_GET_TRAINED_INPUTS"}, 
        {4U, "SDVO_CMD_GET_ACTIVE_OUTPUTS"}, 
        {5U, "SDVO_CMD_SET_ACTIVE_OUTPUTS"}, 
        {6U, "SDVO_CMD_GET_IN_OUT_MAP"}, 
        {7U, "SDVO_CMD_SET_IN_OUT_MAP"}, 
        {11U, "SDVO_CMD_GET_ATTACHED_DISPLAYS"}, 
        {12U, "SDVO_CMD_GET_HOT_PLUG_SUPPORT"}, 
        {13U, "SDVO_CMD_SET_ACTIVE_HOT_PLUG"}, 
        {14U, "SDVO_CMD_GET_ACTIVE_HOT_PLUG"}, 
        {15U, "SDVO_CMD_GET_INTERRUPT_EVENT_SOURCE"}, 
        {16U, "SDVO_CMD_SET_TARGET_INPUT"}, 
        {17U, "SDVO_CMD_SET_TARGET_OUTPUT"}, 
        {18U, "SDVO_CMD_GET_INPUT_TIMINGS_PART1"}, 
        {19U, "SDVO_CMD_GET_INPUT_TIMINGS_PART2"}, 
        {20U, "SDVO_CMD_SET_INPUT_TIMINGS_PART1"}, 
        {21U, "SDVO_CMD_SET_INPUT_TIMINGS_PART2"}, 
        {20U, "SDVO_CMD_SET_INPUT_TIMINGS_PART1"}, 
        {22U, "SDVO_CMD_SET_OUTPUT_TIMINGS_PART1"}, 
        {23U, "SDVO_CMD_SET_OUTPUT_TIMINGS_PART2"}, 
        {24U, "SDVO_CMD_GET_OUTPUT_TIMINGS_PART1"}, 
        {25U, "SDVO_CMD_GET_OUTPUT_TIMINGS_PART2"}, 
        {26U, "SDVO_CMD_CREATE_PREFERRED_INPUT_TIMING"}, 
        {27U, "SDVO_CMD_GET_PREFERRED_INPUT_TIMING_PART1"}, 
        {28U, "SDVO_CMD_GET_PREFERRED_INPUT_TIMING_PART2"}, 
        {29U, "SDVO_CMD_GET_INPUT_PIXEL_CLOCK_RANGE"}, 
        {30U, "SDVO_CMD_GET_OUTPUT_PIXEL_CLOCK_RANGE"}, 
        {31U, "SDVO_CMD_GET_SUPPORTED_CLOCK_RATE_MULTS"}, 
        {32U, "SDVO_CMD_GET_CLOCK_RATE_MULT"}, 
        {33U, "SDVO_CMD_SET_CLOCK_RATE_MULT"}, 
        {39U, "SDVO_CMD_GET_SUPPORTED_TV_FORMATS"}, 
        {40U, "SDVO_CMD_GET_TV_FORMAT"}, 
        {41U, "SDVO_CMD_SET_TV_FORMAT"}, 
        {42U, "SDVO_CMD_GET_SUPPORTED_POWER_STATES"}, 
        {43U, "SDVO_CMD_GET_POWER_STATE"}, 
        {44U, "SDVO_CMD_SET_ENCODER_POWER_STATE"}, 
        {125U, "SDVO_CMD_SET_DISPLAY_POWER_STATE"}, 
        {122U, "SDVO_CMD_SET_CONTROL_BUS_SWITCH"}, 
        {131U, "SDVO_CMD_GET_SDTV_RESOLUTION_SUPPORT"}, 
        {133U, "SDVO_CMD_GET_SCALED_HDTV_RESOLUTION_SUPPORT"}, 
        {132U, "SDVO_CMD_GET_SUPPORTED_ENHANCEMENTS"}, 
        {103U, "SDVO_CMD_GET_MAX_HPOS"}, 
        {104U, "SDVO_CMD_GET_HPOS"}, 
        {105U, "SDVO_CMD_SET_HPOS"}, 
        {106U, "SDVO_CMD_GET_MAX_VPOS"}, 
        {107U, "SDVO_CMD_GET_VPOS"}, 
        {108U, "SDVO_CMD_SET_VPOS"}, 
        {85U, "SDVO_CMD_GET_MAX_SATURATION"}, 
        {86U, "SDVO_CMD_GET_SATURATION"}, 
        {87U, "SDVO_CMD_SET_SATURATION"}, 
        {88U, "SDVO_CMD_GET_MAX_HUE"}, 
        {89U, "SDVO_CMD_GET_HUE"}, 
        {90U, "SDVO_CMD_SET_HUE"}, 
        {94U, "SDVO_CMD_GET_MAX_CONTRAST"}, 
        {95U, "SDVO_CMD_GET_CONTRAST"}, 
        {96U, "SDVO_CMD_SET_CONTRAST"}, 
        {91U, "SDVO_CMD_GET_MAX_BRIGHTNESS"}, 
        {92U, "SDVO_CMD_GET_BRIGHTNESS"}, 
        {93U, "SDVO_CMD_SET_BRIGHTNESS"}, 
        {97U, "SDVO_CMD_GET_MAX_OVERSCAN_H"}, 
        {98U, "SDVO_CMD_GET_OVERSCAN_H"}, 
        {99U, "SDVO_CMD_SET_OVERSCAN_H"}, 
        {100U, "SDVO_CMD_GET_MAX_OVERSCAN_V"}, 
        {101U, "SDVO_CMD_GET_OVERSCAN_V"}, 
        {102U, "SDVO_CMD_SET_OVERSCAN_V"}, 
        {77U, "SDVO_CMD_GET_MAX_FLICKER_FILTER"}, 
        {78U, "SDVO_CMD_GET_FLICKER_FILTER"}, 
        {79U, "SDVO_CMD_SET_FLICKER_FILTER"}, 
        {123U, "SDVO_CMD_GET_MAX_FLICKER_FILTER_ADAPTIVE"}, 
        {80U, "SDVO_CMD_GET_FLICKER_FILTER_ADAPTIVE"}, 
        {81U, "SDVO_CMD_SET_FLICKER_FILTER_ADAPTIVE"}, 
        {82U, "SDVO_CMD_GET_MAX_FLICKER_FILTER_2D"}, 
        {83U, "SDVO_CMD_GET_FLICKER_FILTER_2D"}, 
        {84U, "SDVO_CMD_SET_FLICKER_FILTER_2D"}, 
        {109U, "SDVO_CMD_GET_MAX_SHARPNESS"}, 
        {110U, "SDVO_CMD_GET_SHARPNESS"}, 
        {111U, "SDVO_CMD_SET_SHARPNESS"}, 
        {112U, "SDVO_CMD_GET_DOT_CRAWL"}, 
        {113U, "SDVO_CMD_SET_DOT_CRAWL"}, 
        {116U, "SDVO_CMD_GET_MAX_TV_CHROMA_FILTER"}, 
        {117U, "SDVO_CMD_GET_TV_CHROMA_FILTER"}, 
        {118U, "SDVO_CMD_SET_TV_CHROMA_FILTER"}, 
        {119U, "SDVO_CMD_GET_MAX_TV_LUMA_FILTER"}, 
        {120U, "SDVO_CMD_GET_TV_LUMA_FILTER"}, 
        {121U, "SDVO_CMD_SET_TV_LUMA_FILTER"}, 
        {157U, "SDVO_CMD_GET_SUPP_ENCODE"}, 
        {158U, "SDVO_CMD_GET_ENCODE"}, 
        {159U, "SDVO_CMD_SET_ENCODE"}, 
        {139U, "SDVO_CMD_SET_PIXEL_REPLI"}, 
        {140U, "SDVO_CMD_GET_PIXEL_REPLI"}, 
        {141U, "SDVO_CMD_GET_COLORIMETRY_CAP"}, 
        {142U, "SDVO_CMD_SET_COLORIMETRY"}, 
        {143U, "SDVO_CMD_GET_COLORIMETRY"}, 
        {144U, "SDVO_CMD_GET_AUDIO_ENCRYPT_PREFER"}, 
        {145U, "SDVO_CMD_SET_AUDIO_STAT"}, 
        {146U, "SDVO_CMD_GET_AUDIO_STAT"}, 
        {148U, "SDVO_CMD_GET_HBUF_INDEX"}, 
        {147U, "SDVO_CMD_SET_HBUF_INDEX"}, 
        {149U, "SDVO_CMD_GET_HBUF_INFO"}, 
        {151U, "SDVO_CMD_GET_HBUF_AV_SPLIT"}, 
        {150U, "SDVO_CMD_SET_HBUF_AV_SPLIT"}, 
        {155U, "SDVO_CMD_GET_HBUF_TXRATE"}, 
        {154U, "SDVO_CMD_SET_HBUF_TXRATE"}, 
        {152U, "SDVO_CMD_SET_HBUF_DATA"}, 
        {153U, "SDVO_CMD_GET_HBUF_DATA"}};
#line 401 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static void psb_intel_sdvo_debug_write(struct psb_intel_sdvo *psb_intel_sdvo , u8 cmd ,
                                       void const   *args , int args_len ) 
{ 
  int i ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 406
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 406
  if (tmp != 0L) {
#line 406
    drm_ut_debug_printk("psb_intel_sdvo_debug_write", "%s: W: %02X ", psb_intel_sdvo->sdvo_reg == 397632 ? (char *)"SDVOB" : (char *)"SDVOC",
                        (int )cmd);
  } else {

  }
#line 408
  i = 0;
#line 408
  goto ldv_42464;
  ldv_42463: 
#line 409
  tmp___0 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 409
  if (tmp___0 != 0L) {
#line 409
    drm_ut_debug_printk("psb_intel_sdvo_debug_write", "%02X ", (int )*((u8 *)args + (unsigned long )i));
  } else {

  }
#line 408
  i = i + 1;
  ldv_42464: ;
#line 408
  if (i < args_len) {
#line 410
    goto ldv_42463;
  } else {

  }

#line 410
  goto ldv_42467;
  ldv_42466: 
#line 411
  tmp___1 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 411
  if (tmp___1 != 0L) {
#line 411
    drm_ut_debug_printk("psb_intel_sdvo_debug_write", "   ");
  } else {

  }
#line 410
  i = i + 1;
  ldv_42467: ;
#line 410
  if (i <= 7) {
#line 412
    goto ldv_42466;
  } else {

  }
#line 412
  i = 0;
#line 412
  goto ldv_42473;
  ldv_42472: ;
#line 413
  if ((int )((unsigned char )sdvo_cmd_names[i].cmd) == (int )cmd) {
#line 414
    tmp___2 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 414
    if (tmp___2 != 0L) {
#line 414
      drm_ut_debug_printk("psb_intel_sdvo_debug_write", "(%s)", sdvo_cmd_names[i].name);
    } else {

    }
#line 415
    goto ldv_42471;
  } else {

  }
#line 412
  i = i + 1;
  ldv_42473: ;
#line 412
  if ((unsigned int )i <= 106U) {
#line 414
    goto ldv_42472;
  } else {

  }
  ldv_42471: ;
#line 418
  if (i == 107) {
#line 419
    tmp___3 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 419
    if (tmp___3 != 0L) {
#line 419
      drm_ut_debug_printk("psb_intel_sdvo_debug_write", "(%02X)", (int )cmd);
    } else {

    }
  } else {

  }
#line 420
  tmp___4 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 420
  if (tmp___4 != 0L) {
#line 420
    drm_ut_debug_printk("psb_intel_sdvo_debug_write", "\n");
  } else {

  }
#line 421
  return;
}
}
#line 423 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static char const   *cmd_status_names[7U]  = {      "Power on",      "Success",      "Not supported",      "Invalid arg", 
        "Pending",      "Target not specified",      "Scaling not supported"};
#line 433 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_write_cmd(struct psb_intel_sdvo *psb_intel_sdvo , u8 cmd ,
                                     void const   *args , int args_len ) 
{ 
  u8 *buf ;
  unsigned long __lengthofbuf ;
  void *tmp ;
  u8 status ;
  struct i2c_msg *msgs ;
  unsigned long __lengthofmsgs ;
  void *tmp___0 ;
  int i ;
  int ret ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 436
  __lengthofbuf = (unsigned long )((long )((args_len + 1) * 2));
#line 436
  tmp = __builtin_alloca(sizeof(*buf) * __lengthofbuf);
#line 436
  buf = (u8 *)tmp;
#line 437
  __lengthofmsgs = (unsigned long )((long )(args_len + 3));
#line 437
  tmp___0 = __builtin_alloca(sizeof(*msgs) * __lengthofmsgs);
#line 437
  msgs = (struct i2c_msg *)tmp___0;
#line 440
  psb_intel_sdvo_debug_write(psb_intel_sdvo, (int )cmd, args, args_len);
#line 442
  i = 0;
#line 442
  goto ldv_42489;
  ldv_42488: 
#line 443
  (msgs + i)->addr = (__u16 )psb_intel_sdvo->slave_addr;
#line 444
  (msgs + i)->flags = 0U;
#line 445
  (msgs + i)->len = 2U;
#line 446
  (msgs + i)->buf = (__u8 *)(& buf) + (unsigned long )(i * 2);
#line 447
  *(buf + i * 2) = 7U - (unsigned int )((u8 )i);
#line 448
  *(buf + (i * 2 + 1)) = *((u8 *)args + (unsigned long )i);
#line 442
  i = i + 1;
  ldv_42489: ;
#line 442
  if (i < args_len) {
#line 444
    goto ldv_42488;
  } else {

  }
#line 450
  (msgs + i)->addr = (__u16 )psb_intel_sdvo->slave_addr;
#line 451
  (msgs + i)->flags = 0U;
#line 452
  (msgs + i)->len = 2U;
#line 453
  (msgs + i)->buf = (__u8 *)(& buf) + (unsigned long )(i * 2);
#line 454
  *(buf + i * 2) = 8U;
#line 455
  *(buf + (i * 2 + 1)) = cmd;
#line 458
  status = 9U;
#line 459
  (msgs + (i + 1))->addr = (__u16 )psb_intel_sdvo->slave_addr;
#line 460
  (msgs + (i + 1))->flags = 0U;
#line 461
  (msgs + (i + 1))->len = 1U;
#line 462
  (msgs + (i + 1))->buf = & status;
#line 464
  (msgs + (i + 2))->addr = (__u16 )psb_intel_sdvo->slave_addr;
#line 465
  (msgs + (i + 2))->flags = 1U;
#line 466
  (msgs + (i + 2))->len = 1U;
#line 467
  (msgs + (i + 2))->buf = & status;
#line 469
  ret = i2c_transfer(psb_intel_sdvo->i2c, (struct i2c_msg *)(& msgs), i + 3);
#line 470
  if (ret < 0) {
#line 471
    tmp___1 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 471
    if (tmp___1 != 0L) {
#line 471
      drm_ut_debug_printk("psb_intel_sdvo_write_cmd", "I2c transfer returned %d\n",
                          ret);
    } else {

    }
#line 472
    return (0);
  } else {

  }
#line 474
  if (i + 3 != ret) {
#line 476
    tmp___2 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 476
    if (tmp___2 != 0L) {
#line 476
      drm_ut_debug_printk("psb_intel_sdvo_write_cmd", "I2c transfer returned %d/%d\n",
                          ret, i + 3);
    } else {

    }
#line 477
    return (0);
  } else {

  }
#line 480
  return (1);
}
}
#line 483 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_read_response(struct psb_intel_sdvo *psb_intel_sdvo , void *response ,
                                         int response_len ) 
{ 
  u8 retry ;
  u8 status ;
  int i ;
  long tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  u8 tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;

  {
#line 486
  retry = 5U;
#line 490
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 490
  if (tmp != 0L) {
#line 490
    drm_ut_debug_printk("psb_intel_sdvo_read_response", "%s: R: ", psb_intel_sdvo->sdvo_reg == 397632 ? (char *)"SDVOB" : (char *)"SDVOC");
  } else {

  }
#line 500
  tmp___0 = psb_intel_sdvo_read_byte(psb_intel_sdvo, 9, & status);
#line 500
  if (tmp___0) {
#line 500
    tmp___1 = 0;
  } else {
#line 500
    tmp___1 = 1;
  }
#line 500
  if (tmp___1) {
#line 503
    goto log_fail;
  } else {

  }
#line 505
  goto ldv_42503;
  ldv_42502: 
#line 507
  __const_udelay(64425UL);
#line 508
  tmp___2 = psb_intel_sdvo_read_byte(psb_intel_sdvo, 9, & status);
#line 508
  if (tmp___2) {
#line 508
    tmp___3 = 0;
  } else {
#line 508
    tmp___3 = 1;
  }
#line 508
  if (tmp___3) {
#line 511
    goto log_fail;
  } else {

  }
  ldv_42503: ;
#line 505
  if ((unsigned int )status == 4U || (unsigned int )status == 5U) {
#line 505
    tmp___4 = retry;
#line 505
    retry = (u8 )((int )retry - 1);
#line 505
    if ((unsigned int )tmp___4 != 0U) {
#line 508
      goto ldv_42502;
    } else {
#line 511
      goto ldv_42504;
    }
  } else {

  }
  ldv_42504: ;
#line 514
  if ((unsigned int )status <= 6U) {
#line 515
    tmp___5 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 515
    if (tmp___5 != 0L) {
#line 515
      drm_ut_debug_printk("psb_intel_sdvo_read_response", "(%s)", cmd_status_names[(int )status]);
    } else {

    }
  } else {
#line 517
    tmp___6 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 517
    if (tmp___6 != 0L) {
#line 517
      drm_ut_debug_printk("psb_intel_sdvo_read_response", "(??? %d)", (int )status);
    } else {

    }
  }
#line 519
  if ((unsigned int )status != 1U) {
#line 520
    goto log_fail;
  } else {

  }
#line 523
  i = 0;
#line 523
  goto ldv_42506;
  ldv_42505: 
#line 524
  tmp___7 = psb_intel_sdvo_read_byte(psb_intel_sdvo, (int )((unsigned int )((u8 )i) + 10U),
                                     (u8 *)response + (unsigned long )i);
#line 524
  if (tmp___7) {
#line 524
    tmp___8 = 0;
  } else {
#line 524
    tmp___8 = 1;
  }
#line 524
  if (tmp___8) {
#line 527
    goto log_fail;
  } else {

  }
#line 528
  tmp___9 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 528
  if (tmp___9 != 0L) {
#line 528
    drm_ut_debug_printk("psb_intel_sdvo_read_response", " %02X", (int )*((u8 *)response + (unsigned long )i));
  } else {

  }
#line 523
  i = i + 1;
  ldv_42506: ;
#line 523
  if (i < response_len) {
#line 525
    goto ldv_42505;
  } else {

  }
#line 530
  tmp___10 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 530
  if (tmp___10 != 0L) {
#line 530
    drm_ut_debug_printk("psb_intel_sdvo_read_response", "\n");
  } else {

  }
#line 531
  return (1);
  log_fail: 
#line 534
  tmp___11 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 534
  if (tmp___11 != 0L) {
#line 534
    drm_ut_debug_printk("psb_intel_sdvo_read_response", "... failed\n");
  } else {

  }
#line 535
  return (0);
}
}
#line 538 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static int psb_intel_sdvo_get_pixel_multiplier(struct drm_display_mode *mode ) 
{ 


  {
#line 540
  if (mode->clock > 99999) {
#line 541
    return (1);
  } else
#line 542
  if (mode->clock > 49999) {
#line 543
    return (2);
  } else {
#line 545
    return (4);
  }
}
}
#line 548 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_set_control_bus_switch(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                  u8 ddc_bus ) 
{ 
  bool tmp ;

  {
#line 552
  tmp = psb_intel_sdvo_write_cmd(psb_intel_sdvo, 122, (void const   *)(& ddc_bus),
                                 1);
#line 552
  return (tmp);
}
}
#line 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_set_value(struct psb_intel_sdvo *psb_intel_sdvo , u8 cmd ,
                                     void const   *data , int len ) 
{ 
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 559
  tmp = psb_intel_sdvo_write_cmd(psb_intel_sdvo, (int )cmd, data, len);
#line 559
  if (tmp) {
#line 559
    tmp___0 = 0;
  } else {
#line 559
    tmp___0 = 1;
  }
#line 559
  if (tmp___0) {
#line 560
    return (0);
  } else {

  }
#line 562
  tmp___1 = psb_intel_sdvo_read_response(psb_intel_sdvo, (void *)0, 0);
#line 562
  return (tmp___1);
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_get_value(struct psb_intel_sdvo *psb_intel_sdvo , u8 cmd ,
                                     void *value , int len ) 
{ 
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 568
  tmp = psb_intel_sdvo_write_cmd(psb_intel_sdvo, (int )cmd, (void const   *)0, 0);
#line 568
  if (tmp) {
#line 568
    tmp___0 = 0;
  } else {
#line 568
    tmp___0 = 1;
  }
#line 568
  if (tmp___0) {
#line 569
    return (0);
  } else {

  }
#line 571
  tmp___1 = psb_intel_sdvo_read_response(psb_intel_sdvo, value, len);
#line 571
  return (tmp___1);
}
}
#line 574 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_set_target_input(struct psb_intel_sdvo *psb_intel_sdvo ) 
{ 
  struct psb_intel_sdvo_set_target_input_args targets ;
  bool tmp ;

  {
#line 576
  targets.target_1 = 0U;
#line 576
  targets.pad = (unsigned char)0;
#line 577
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, 16, (void const   *)(& targets),
                                 1);
#line 577
  return (tmp);
}
}
#line 588 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_get_trained_inputs(struct psb_intel_sdvo *psb_intel_sdvo ,
                                              bool *input_1 , bool *input_2 ) 
{ 
  struct psb_intel_sdvo_get_trained_inputs_response response ;
  bool tmp ;
  int tmp___0 ;

  {
#line 593
  tmp = psb_intel_sdvo_get_value(psb_intel_sdvo, 3, (void *)(& response), 1);
#line 593
  if (tmp) {
#line 593
    tmp___0 = 0;
  } else {
#line 593
    tmp___0 = 1;
  }
#line 593
  if (tmp___0) {
#line 595
    return (0);
  } else {

  }
#line 597
  *input_1 = (int )response.input0_trained != 0;
#line 598
  *input_2 = (int )response.input1_trained != 0;
#line 599
  return (1);
}
}
#line 602 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_set_active_outputs(struct psb_intel_sdvo *psb_intel_sdvo ,
                                              u16 outputs ) 
{ 
  bool tmp ;

  {
#line 605
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, 5, (void const   *)(& outputs), 2);
#line 605
  return (tmp);
}
}
#line 634 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_get_input_pixel_clock_range(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                       int *clock_min , int *clock_max ) 
{ 
  struct psb_intel_sdvo_pixel_clock_range clocks ;
  bool tmp ;
  int tmp___0 ;

  {
#line 641
  tmp = psb_intel_sdvo_get_value(psb_intel_sdvo, 29, (void *)(& clocks), 4);
#line 641
  if (tmp) {
#line 641
    tmp___0 = 0;
  } else {
#line 641
    tmp___0 = 1;
  }
#line 641
  if (tmp___0) {
#line 644
    return (0);
  } else {

  }
#line 647
  *clock_min = (int )clocks.min * 10;
#line 648
  *clock_max = (int )clocks.max * 10;
#line 649
  return (1);
}
}
#line 652 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_set_target_output(struct psb_intel_sdvo *psb_intel_sdvo ,
                                             u16 outputs ) 
{ 
  bool tmp ;

  {
#line 655
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, 17, (void const   *)(& outputs),
                                 2);
#line 655
  return (tmp);
}
}
#line 660 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_set_timing(struct psb_intel_sdvo *psb_intel_sdvo , u8 cmd ,
                                      struct psb_intel_sdvo_dtd *dtd ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 663
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, (int )cmd, (void const   *)(& dtd->part1),
                                 8);
#line 663
  if ((int )tmp) {
#line 663
    tmp___0 = psb_intel_sdvo_set_value(psb_intel_sdvo, (int )((unsigned int )cmd + 1U),
                                       (void const   *)(& dtd->part2), 8);
#line 663
    if ((int )tmp___0) {
#line 663
      tmp___1 = 1;
    } else {
#line 663
      tmp___1 = 0;
    }
  } else {
#line 663
    tmp___1 = 0;
  }
#line 663
  return ((bool )tmp___1);
}
}
#line 667 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_set_input_timing(struct psb_intel_sdvo *psb_intel_sdvo ,
                                            struct psb_intel_sdvo_dtd *dtd ) 
{ 
  bool tmp ;

  {
#line 670
  tmp = psb_intel_sdvo_set_timing(psb_intel_sdvo, 20, dtd);
#line 670
  return (tmp);
}
}
#line 674 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_set_output_timing(struct psb_intel_sdvo *psb_intel_sdvo ,
                                             struct psb_intel_sdvo_dtd *dtd ) 
{ 
  bool tmp ;

  {
#line 677
  tmp = psb_intel_sdvo_set_timing(psb_intel_sdvo, 22, dtd);
#line 677
  return (tmp);
}
}
#line 682 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_create_preferred_input_timing(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                         uint16_t clock , uint16_t width ,
                                                         uint16_t height ) 
{ 
  struct psb_intel_sdvo_preferred_input_timing_args args ;
  bool tmp ;

  {
#line 689
  memset((void *)(& args), 0, 7UL);
#line 690
  args.clock = clock;
#line 691
  args.width = width;
#line 692
  args.height = height;
#line 693
  args.interlace = 0U;
#line 695
  if ((int )psb_intel_sdvo->is_lvds && ((psb_intel_sdvo->sdvo_lvds_fixed_mode)->hdisplay != (int )width || (psb_intel_sdvo->sdvo_lvds_fixed_mode)->vdisplay != (int )height)) {
#line 698
    args.scaled = 1U;
  } else {

  }
#line 700
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, 26, (void const   *)(& args), 7);
#line 700
  return (tmp);
}
}
#line 705 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_get_preferred_input_timing(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                      struct psb_intel_sdvo_dtd *dtd ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 710
  tmp = psb_intel_sdvo_get_value(psb_intel_sdvo, 27, (void *)(& dtd->part1), 8);
#line 710
  if ((int )tmp) {
#line 710
    tmp___0 = psb_intel_sdvo_get_value(psb_intel_sdvo, 28, (void *)(& dtd->part2),
                                       8);
#line 710
    if ((int )tmp___0) {
#line 710
      tmp___1 = 1;
    } else {
#line 710
      tmp___1 = 0;
    }
  } else {
#line 710
    tmp___1 = 0;
  }
#line 710
  return ((bool )tmp___1);
}
}
#line 716 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_set_clock_rate_mult(struct psb_intel_sdvo *psb_intel_sdvo ,
                                               u8 val ) 
{ 
  bool tmp ;

  {
#line 718
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, 33, (void const   *)(& val), 1);
#line 718
  return (tmp);
}
}
#line 721 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static void psb_intel_sdvo_get_dtd_from_mode(struct psb_intel_sdvo_dtd *dtd , struct drm_display_mode  const  *mode ) 
{ 
  uint16_t width ;
  uint16_t height ;
  uint16_t h_blank_len ;
  uint16_t h_sync_len ;
  uint16_t v_blank_len ;
  uint16_t v_sync_len ;
  uint16_t h_sync_offset ;
  uint16_t v_sync_offset ;

  {
#line 728
  width = (uint16_t )mode->crtc_hdisplay;
#line 729
  height = (uint16_t )mode->crtc_vdisplay;
#line 732
  h_blank_len = (int )((uint16_t )mode->crtc_hblank_end) - (int )((uint16_t )mode->crtc_hblank_start);
#line 733
  h_sync_len = (int )((uint16_t )mode->crtc_hsync_end) - (int )((uint16_t )mode->crtc_hsync_start);
#line 735
  v_blank_len = (int )((uint16_t )mode->crtc_vblank_end) - (int )((uint16_t )mode->crtc_vblank_start);
#line 736
  v_sync_len = (int )((uint16_t )mode->crtc_vsync_end) - (int )((uint16_t )mode->crtc_vsync_start);
#line 738
  h_sync_offset = (int )((uint16_t )mode->crtc_hsync_start) - (int )((uint16_t )mode->crtc_hblank_start);
#line 739
  v_sync_offset = (int )((uint16_t )mode->crtc_vsync_start) - (int )((uint16_t )mode->crtc_vblank_start);
#line 741
  dtd->part1.clock = (u16 )((int )mode->clock / 10);
#line 742
  dtd->part1.h_active = (u8 )width;
#line 743
  dtd->part1.h_blank = (u8 )h_blank_len;
#line 744
  dtd->part1.h_high = (u8 )((int )((signed char )(((int )width >> 8) << 4)) | ((int )((signed char )((int )h_blank_len >> 8)) & 15));
#line 746
  dtd->part1.v_active = (u8 )height;
#line 747
  dtd->part1.v_blank = (u8 )v_blank_len;
#line 748
  dtd->part1.v_high = (u8 )((int )((signed char )(((int )height >> 8) << 4)) | ((int )((signed char )((int )v_blank_len >> 8)) & 15));
#line 751
  dtd->part2.h_sync_off = (u8 )h_sync_offset;
#line 752
  dtd->part2.h_sync_width = (u8 )h_sync_len;
#line 753
  dtd->part2.v_sync_off_width = (u8 )((int )((signed char )((int )v_sync_offset << 4)) | ((int )((signed char )v_sync_len) & 15));
#line 755
  dtd->part2.sync_off_width_high = (u8 )((((int )((signed char )(((int )h_sync_offset & 768) >> 2)) | (int )((signed char )(((int )h_sync_len & 768) >> 4))) | (int )((signed char )(((int )v_sync_offset & 48) >> 2))) | (int )((signed char )(((int )v_sync_len & 48) >> 4)));
#line 759
  dtd->part2.dtd_flags = 24U;
#line 760
  if ((int )mode->flags & 1) {
#line 761
    dtd->part2.dtd_flags = (u8 )((unsigned int )dtd->part2.dtd_flags | 2U);
  } else {

  }
#line 762
  if (((unsigned int )mode->flags & 4U) != 0U) {
#line 763
    dtd->part2.dtd_flags = (u8 )((unsigned int )dtd->part2.dtd_flags | 4U);
  } else {

  }
#line 765
  dtd->part2.sdvo_flags = 0U;
#line 766
  dtd->part2.v_sync_off_high = (unsigned int )((u8 )v_sync_offset) & 192U;
#line 767
  dtd->part2.reserved = 0U;
#line 768
  return;
}
}
#line 770 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static void psb_intel_sdvo_get_mode_from_dtd(struct drm_display_mode *mode , struct psb_intel_sdvo_dtd  const  *dtd ) 
{ 


  {
#line 773
  mode->hdisplay = (int )dtd->part1.h_active;
#line 774
  mode->hdisplay = mode->hdisplay + ((((int )((unsigned char )dtd->part1.h_high) >> 4) & 15) << 8);
#line 775
  mode->hsync_start = mode->hdisplay + (int )dtd->part2.h_sync_off;
#line 776
  mode->hsync_start = mode->hsync_start + (((int )dtd->part2.sync_off_width_high & 192) << 2);
#line 777
  mode->hsync_end = mode->hsync_start + (int )dtd->part2.h_sync_width;
#line 778
  mode->hsync_end = mode->hsync_end + (((int )dtd->part2.sync_off_width_high & 48) << 4);
#line 779
  mode->htotal = mode->hdisplay + (int )dtd->part1.h_blank;
#line 780
  mode->htotal = mode->htotal + (((int )dtd->part1.h_high & 15) << 8);
#line 782
  mode->vdisplay = (int )dtd->part1.v_active;
#line 783
  mode->vdisplay = mode->vdisplay + ((((int )((unsigned char )dtd->part1.v_high) >> 4) & 15) << 8);
#line 784
  mode->vsync_start = mode->vdisplay;
#line 785
  mode->vsync_start = mode->vsync_start + (((int )((unsigned char )dtd->part2.v_sync_off_width) >> 4) & 15);
#line 786
  mode->vsync_start = mode->vsync_start + (((int )dtd->part2.sync_off_width_high & 12) << 2);
#line 787
  mode->vsync_start = mode->vsync_start + ((int )dtd->part2.v_sync_off_high & 192);
#line 788
  mode->vsync_end = mode->vsync_start + ((int )dtd->part2.v_sync_off_width & 15);
#line 790
  mode->vsync_end = mode->vsync_end + (((int )dtd->part2.sync_off_width_high & 3) << 4);
#line 791
  mode->vtotal = mode->vdisplay + (int )dtd->part1.v_blank;
#line 792
  mode->vtotal = mode->vtotal + (((int )dtd->part1.v_high & 15) << 8);
#line 794
  mode->clock = (int )dtd->part1.clock * 10;
#line 796
  mode->flags = mode->flags & 4294967290U;
#line 797
  if (((int )dtd->part2.dtd_flags & 2) != 0) {
#line 798
    mode->flags = mode->flags | 1U;
  } else {

  }
#line 799
  if (((int )dtd->part2.dtd_flags & 4) != 0) {
#line 800
    mode->flags = mode->flags | 4U;
  } else {

  }
#line 801
  return;
}
}
#line 803 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_check_supp_encode(struct psb_intel_sdvo *psb_intel_sdvo ) 
{ 
  struct psb_intel_sdvo_encode encode ;
  bool tmp ;

  {
#line 808
  tmp = psb_intel_sdvo_get_value(psb_intel_sdvo, 157, (void *)(& encode), 2);
#line 808
  return (tmp);
}
}
#line 813 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_set_encode(struct psb_intel_sdvo *psb_intel_sdvo , uint8_t mode ) 
{ 
  bool tmp ;

  {
#line 816
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, 159, (void const   *)(& mode), 1);
#line 816
  return (tmp);
}
}
#line 819 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_set_colorimetry(struct psb_intel_sdvo *psb_intel_sdvo ,
                                           uint8_t mode ) 
{ 
  bool tmp ;

  {
#line 822
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, 142, (void const   *)(& mode), 1);
#line 822
  return (tmp);
}
}
#line 855 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_set_avi_infoframe(struct psb_intel_sdvo *psb_intel_sdvo ) 
{ 


  {
#line 857
  printk("\016[drm] HDMI is not supported yet");
#line 859
  return (0);
}
}
#line 892 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_set_tv_format(struct psb_intel_sdvo *psb_intel_sdvo ) 
{ 
  struct psb_intel_sdvo_tv_format format ;
  uint32_t format_map ;
  unsigned long _min1 ;
  unsigned long _min2 ;
  bool tmp ;

  {
#line 897
  format_map = (uint32_t )(1 << psb_intel_sdvo->tv_format_index);
#line 898
  memset((void *)(& format), 0, 6UL);
#line 899
  _min1 = 6UL;
#line 899
  _min2 = 4UL;
#line 899
  memcpy((void *)(& format), (void const   *)(& format_map), _min1 < _min2 ? _min1 : _min2);
#line 902
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, 41, (void const   *)(& format), 6);
#line 902
  return (tmp);
}
}
#line 908 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_set_output_timings_from_mode(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                        struct drm_display_mode  const  *mode ) 
{ 
  struct psb_intel_sdvo_dtd output_dtd ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 913
  tmp = psb_intel_sdvo_set_target_output(psb_intel_sdvo, (int )psb_intel_sdvo->attached_output);
#line 913
  if (tmp) {
#line 913
    tmp___0 = 0;
  } else {
#line 913
    tmp___0 = 1;
  }
#line 913
  if (tmp___0) {
#line 915
    return (0);
  } else {

  }
#line 917
  psb_intel_sdvo_get_dtd_from_mode(& output_dtd, mode);
#line 918
  tmp___1 = psb_intel_sdvo_set_output_timing(psb_intel_sdvo, & output_dtd);
#line 918
  if (tmp___1) {
#line 918
    tmp___2 = 0;
  } else {
#line 918
    tmp___2 = 1;
  }
#line 918
  if (tmp___2) {
#line 919
    return (0);
  } else {

  }
#line 921
  return (1);
}
}
#line 925 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_set_input_timings_for_mode(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                      struct drm_display_mode  const  *mode ,
                                                      struct drm_display_mode *adjusted_mode ) 
{ 
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;

  {
#line 930
  tmp = psb_intel_sdvo_set_target_input(psb_intel_sdvo);
#line 930
  if (tmp) {
#line 930
    tmp___0 = 0;
  } else {
#line 930
    tmp___0 = 1;
  }
#line 930
  if (tmp___0) {
#line 931
    return (0);
  } else {

  }
#line 933
  tmp___1 = psb_intel_sdvo_create_preferred_input_timing(psb_intel_sdvo, (int )((uint16_t )((int )mode->clock / 10)),
                                                         (int )((uint16_t )mode->hdisplay),
                                                         (int )((uint16_t )mode->vdisplay));
#line 933
  if (tmp___1) {
#line 933
    tmp___2 = 0;
  } else {
#line 933
    tmp___2 = 1;
  }
#line 933
  if (tmp___2) {
#line 937
    return (0);
  } else {

  }
#line 939
  tmp___3 = psb_intel_sdvo_get_preferred_input_timing(psb_intel_sdvo, & psb_intel_sdvo->input_dtd);
#line 939
  if (tmp___3) {
#line 939
    tmp___4 = 0;
  } else {
#line 939
    tmp___4 = 1;
  }
#line 939
  if (tmp___4) {
#line 941
    return (0);
  } else {

  }
#line 943
  psb_intel_sdvo_get_mode_from_dtd(adjusted_mode, (struct psb_intel_sdvo_dtd  const  *)(& psb_intel_sdvo->input_dtd));
#line 945
  drm_mode_set_crtcinfo(adjusted_mode, 0);
#line 946
  return (1);
}
}
#line 949 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode  const  *mode ,
                                      struct drm_display_mode *adjusted_mode ) 
{ 
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  int multiplier ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 953
  tmp = to_psb_intel_sdvo(encoder);
#line 953
  psb_intel_sdvo = tmp;
#line 961
  if ((int )psb_intel_sdvo->is_tv) {
#line 962
    tmp___0 = psb_intel_sdvo_set_output_timings_from_mode(psb_intel_sdvo, mode);
#line 962
    if (tmp___0) {
#line 962
      tmp___1 = 0;
    } else {
#line 962
      tmp___1 = 1;
    }
#line 962
    if (tmp___1) {
#line 963
      return (0);
    } else {

    }
#line 965
    psb_intel_sdvo_set_input_timings_for_mode(psb_intel_sdvo, mode, adjusted_mode);
  } else
#line 968
  if ((int )psb_intel_sdvo->is_lvds) {
#line 969
    tmp___2 = psb_intel_sdvo_set_output_timings_from_mode(psb_intel_sdvo, (struct drm_display_mode  const  *)psb_intel_sdvo->sdvo_lvds_fixed_mode);
#line 969
    if (tmp___2) {
#line 969
      tmp___3 = 0;
    } else {
#line 969
      tmp___3 = 1;
    }
#line 969
    if (tmp___3) {
#line 971
      return (0);
    } else {

    }
#line 973
    psb_intel_sdvo_set_input_timings_for_mode(psb_intel_sdvo, mode, adjusted_mode);
  } else {

  }
#line 981
  multiplier = psb_intel_sdvo_get_pixel_multiplier(adjusted_mode);
#line 982
  psb_intel_mode_set_pixel_multiplier(adjusted_mode, multiplier);
#line 984
  return (1);
}
}
#line 987 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static void psb_intel_sdvo_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                    struct drm_display_mode *adjusted_mode ) 
{ 
  struct drm_device *dev ;
  struct drm_crtc *crtc ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  u32 sdvox ;
  struct psb_intel_sdvo_in_out_map in_out ;
  struct psb_intel_sdvo_dtd input_dtd ;
  int pixel_multiplier ;
  int tmp___0 ;
  int rate ;
  int need_aux ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;

  {
#line 991
  dev = encoder->dev;
#line 992
  crtc = encoder->crtc;
#line 993
  __mptr = (struct drm_crtc  const  *)crtc;
#line 993
  gma_crtc = (struct gma_crtc *)__mptr;
#line 994
  tmp = to_psb_intel_sdvo(encoder);
#line 994
  psb_intel_sdvo = tmp;
#line 998
  tmp___0 = psb_intel_mode_get_pixel_multiplier((struct drm_display_mode  const  *)adjusted_mode);
#line 998
  pixel_multiplier = tmp___0;
#line 1000
  need_aux = ((int )(dev->pdev)->device & 65520) == 16640;
#line 1002
  if ((unsigned long )mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 1003
    return;
  } else {

  }
#line 1011
  in_out.in0 = psb_intel_sdvo->attached_output;
#line 1012
  in_out.in1 = 0U;
#line 1014
  psb_intel_sdvo_set_value(psb_intel_sdvo, 7, (void const   *)(& in_out), 4);
#line 1019
  tmp___1 = psb_intel_sdvo_set_target_output(psb_intel_sdvo, (int )psb_intel_sdvo->attached_output);
#line 1019
  if (tmp___1) {
#line 1019
    tmp___2 = 0;
  } else {
#line 1019
    tmp___2 = 1;
  }
#line 1019
  if (tmp___2) {
#line 1021
    return;
  } else {

  }
#line 1026
  if ((int )psb_intel_sdvo->is_tv || (int )psb_intel_sdvo->is_lvds) {
#line 1027
    input_dtd = psb_intel_sdvo->input_dtd;
  } else {
#line 1030
    tmp___3 = psb_intel_sdvo_set_target_output(psb_intel_sdvo, (int )psb_intel_sdvo->attached_output);
#line 1030
    if (tmp___3) {
#line 1030
      tmp___4 = 0;
    } else {
#line 1030
      tmp___4 = 1;
    }
#line 1030
    if (tmp___4) {
#line 1032
      return;
    } else {

    }
#line 1034
    psb_intel_sdvo_get_dtd_from_mode(& input_dtd, (struct drm_display_mode  const  *)adjusted_mode);
#line 1035
    psb_intel_sdvo_set_output_timing(psb_intel_sdvo, & input_dtd);
  }
#line 1039
  tmp___5 = psb_intel_sdvo_set_target_input(psb_intel_sdvo);
#line 1039
  if (tmp___5) {
#line 1039
    tmp___6 = 0;
  } else {
#line 1039
    tmp___6 = 1;
  }
#line 1039
  if (tmp___6) {
#line 1040
    return;
  } else {

  }
#line 1042
  if ((int )psb_intel_sdvo->has_hdmi_monitor) {
#line 1043
    psb_intel_sdvo_set_encode(psb_intel_sdvo, 1);
#line 1044
    psb_intel_sdvo_set_colorimetry(psb_intel_sdvo, 0);
#line 1046
    psb_intel_sdvo_set_avi_infoframe(psb_intel_sdvo);
  } else {
#line 1048
    psb_intel_sdvo_set_encode(psb_intel_sdvo, 0);
  }
#line 1050
  if ((int )psb_intel_sdvo->is_tv) {
#line 1050
    tmp___7 = psb_intel_sdvo_set_tv_format(psb_intel_sdvo);
#line 1050
    if (tmp___7) {
#line 1050
      tmp___8 = 0;
    } else {
#line 1050
      tmp___8 = 1;
    }
#line 1050
    if (tmp___8) {
#line 1052
      return;
    } else {

    }
  } else {

  }
#line 1054
  psb_intel_sdvo_set_input_timing(psb_intel_sdvo, & input_dtd);
#line 1056
  switch (pixel_multiplier) {
  default: ;
  case 1: 
#line 1058
  rate = 1;
#line 1058
  goto ldv_42664;
  case 2: 
#line 1059
  rate = 2;
#line 1059
  goto ldv_42664;
  case 4: 
#line 1060
  rate = 8;
#line 1060
  goto ldv_42664;
  }
  ldv_42664: 
#line 1062
  tmp___9 = psb_intel_sdvo_set_clock_rate_mult(psb_intel_sdvo, (int )((u8 )rate));
#line 1062
  if (tmp___9) {
#line 1062
    tmp___10 = 0;
  } else {
#line 1062
    tmp___10 = 1;
  }
#line 1062
  if (tmp___10) {
#line 1063
    return;
  } else {

  }
#line 1066
  if (need_aux != 0) {
#line 1067
    sdvox = REGISTER_READ_AUX(dev, (uint32_t )psb_intel_sdvo->sdvo_reg);
  } else {
#line 1069
    sdvox = REGISTER_READ(dev, (uint32_t )psb_intel_sdvo->sdvo_reg);
  }
#line 1071
  switch (psb_intel_sdvo->sdvo_reg) {
  case 397632: 
#line 1073
  sdvox = sdvox & 212992U;
#line 1074
  goto ldv_42668;
  case 397664: 
#line 1076
  sdvox = sdvox & 131072U;
#line 1077
  goto ldv_42668;
  }
  ldv_42668: 
#line 1079
  sdvox = sdvox | 4718720U;
#line 1081
  if (gma_crtc->pipe == 1) {
#line 1082
    sdvox = sdvox | 1073741824U;
  } else {

  }
#line 1083
  if ((int )psb_intel_sdvo->has_hdmi_audio) {
#line 1084
    sdvox = sdvox | 64U;
  } else {

  }
#line 1090
  if ((int )((signed char )input_dtd.part2.sdvo_flags) < 0) {
#line 1091
    sdvox = sdvox | 536870912U;
  } else {

  }
#line 1092
  psb_intel_sdvo_write_sdvox(psb_intel_sdvo, sdvox);
#line 1093
  return;
}
}
#line 1095 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static void psb_intel_sdvo_dpms(struct drm_encoder *encoder , int mode ) 
{ 
  struct drm_device *dev ;
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  u32 temp ;
  int i ;
  int need_aux ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  bool input1 ;
  bool input2 ;
  u8 status ;
  bool tmp___3 ;
  long tmp___4 ;

  {
#line 1097
  dev = encoder->dev;
#line 1098
  tmp = to_psb_intel_sdvo(encoder);
#line 1098
  psb_intel_sdvo = tmp;
#line 1101
  need_aux = ((int )(dev->pdev)->device & 65520) == 16640;
#line 1103
  switch (mode) {
  case 0: 
#line 1105
  tmp___0 = ldv__builtin_expect((long )((int )drm_debug) & 1L, 0L);
#line 1105
  if (tmp___0 != 0L) {
#line 1105
    drm_ut_debug_printk("psb_intel_sdvo_dpms", "DPMS_ON");
  } else {

  }
#line 1106
  goto ldv_42681;
  case 3: 
#line 1108
  tmp___1 = ldv__builtin_expect((long )((int )drm_debug) & 1L, 0L);
#line 1108
  if (tmp___1 != 0L) {
#line 1108
    drm_ut_debug_printk("psb_intel_sdvo_dpms", "DPMS_OFF");
  } else {

  }
#line 1109
  goto ldv_42681;
  default: 
#line 1111
  tmp___2 = ldv__builtin_expect((long )((int )drm_debug) & 1L, 0L);
#line 1111
  if (tmp___2 != 0L) {
#line 1111
    drm_ut_debug_printk("psb_intel_sdvo_dpms", "DPMS: %d", mode);
  } else {

  }
  }
  ldv_42681: ;
#line 1114
  if (mode != 0) {
#line 1115
    psb_intel_sdvo_set_active_outputs(psb_intel_sdvo, 0);
#line 1119
    if (mode == 3) {
#line 1120
      if (need_aux != 0) {
#line 1121
        temp = REGISTER_READ_AUX(dev, (uint32_t )psb_intel_sdvo->sdvo_reg);
      } else {
#line 1123
        temp = REGISTER_READ(dev, (uint32_t )psb_intel_sdvo->sdvo_reg);
      }
#line 1125
      if ((int )temp < 0) {
#line 1126
        psb_intel_sdvo_write_sdvox(psb_intel_sdvo, temp & 2147483647U);
      } else {

      }
    } else {

    }
  } else {
#line 1133
    if (need_aux != 0) {
#line 1134
      temp = REGISTER_READ_AUX(dev, (uint32_t )psb_intel_sdvo->sdvo_reg);
    } else {
#line 1136
      temp = REGISTER_READ(dev, (uint32_t )psb_intel_sdvo->sdvo_reg);
    }
#line 1138
    if ((int )temp >= 0) {
#line 1139
      psb_intel_sdvo_write_sdvox(psb_intel_sdvo, temp | 2147483648U);
    } else {

    }
#line 1141
    i = 0;
#line 1141
    goto ldv_42688;
    ldv_42687: 
#line 1142
    gma_wait_for_vblank(dev);
#line 1141
    i = i + 1;
    ldv_42688: ;
#line 1141
    if (i <= 1) {
#line 1143
      goto ldv_42687;
    } else {

    }
#line 1144
    tmp___3 = psb_intel_sdvo_get_trained_inputs(psb_intel_sdvo, & input1, & input2);
#line 1144
    status = (u8 )tmp___3;
#line 1149
    if ((unsigned int )status == 1U && ! input1) {
#line 1150
      tmp___4 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1150
      if (tmp___4 != 0L) {
#line 1150
        drm_ut_debug_printk("psb_intel_sdvo_dpms", "First %s output reported failure to sync\n",
                            psb_intel_sdvo->sdvo_reg == 397632 ? (char *)"SDVOB" : (char *)"SDVOC");
      } else {

      }
    } else {

    }
#line 1156
    psb_intel_sdvo_set_active_outputs(psb_intel_sdvo, (int )psb_intel_sdvo->attached_output);
  }
#line 1158
  return;
}
}
#line 1161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static int psb_intel_sdvo_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode ) 
{ 
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;

  {
#line 1164
  tmp = intel_attached_sdvo(connector);
#line 1164
  psb_intel_sdvo = tmp;
#line 1166
  if ((mode->flags & 32U) != 0U) {
#line 1167
    return (8);
  } else {

  }
#line 1169
  if (psb_intel_sdvo->pixel_clock_min > mode->clock) {
#line 1170
    return (16);
  } else {

  }
#line 1172
  if (psb_intel_sdvo->pixel_clock_max < mode->clock) {
#line 1173
    return (15);
  } else {

  }
#line 1175
  if ((int )psb_intel_sdvo->is_lvds) {
#line 1176
    if (mode->hdisplay > (psb_intel_sdvo->sdvo_lvds_fixed_mode)->hdisplay) {
#line 1177
      return (29);
    } else {

    }
#line 1179
    if (mode->vdisplay > (psb_intel_sdvo->sdvo_lvds_fixed_mode)->vdisplay) {
#line 1180
      return (29);
    } else {

    }
  } else {

  }
#line 1183
  return (0);
}
}
#line 1186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_get_capabilities(struct psb_intel_sdvo *psb_intel_sdvo ,
                                            struct psb_intel_sdvo_caps *caps ) 
{ 
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 1189
  tmp = psb_intel_sdvo_get_value(psb_intel_sdvo, 2, (void *)caps, 8);
#line 1189
  if (tmp) {
#line 1189
    tmp___0 = 0;
  } else {
#line 1189
    tmp___0 = 1;
  }
#line 1189
  if (tmp___0) {
#line 1192
    return (0);
  } else {

  }
#line 1194
  tmp___1 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1194
  if (tmp___1 != 0L) {
#line 1194
    drm_ut_debug_printk("psb_intel_sdvo_get_capabilities", "SDVO capabilities:\n  vendor_id: %d\n  device_id: %d\n  device_rev_id: %d\n  sdvo_version_major: %d\n  sdvo_version_minor: %d\n  sdvo_inputs_mask: %d\n  smooth_scaling: %d\n  sharp_scaling: %d\n  up_scaling: %d\n  down_scaling: %d\n  stall_support: %d\n  output_flags: %d\n",
                        (int )caps->vendor_id, (int )caps->device_id, (int )caps->device_rev_id,
                        (int )caps->sdvo_version_major, (int )caps->sdvo_version_minor,
                        (int )caps->sdvo_inputs_mask, (int )caps->smooth_scaling,
                        (int )caps->sharp_scaling, (int )caps->up_scaling, (int )caps->down_scaling,
                        (int )caps->stall_support, (int )caps->output_flags);
  } else {

  }
#line 1220
  return (1);
}
}
#line 1293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_multifunc_encoder(struct psb_intel_sdvo *psb_intel_sdvo ) 
{ 
  int caps ;

  {
#line 1296
  caps = (int )psb_intel_sdvo->caps.output_flags & 15;
#line 1297
  return ((- caps & caps) != 0);
}
}
#line 1301 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static struct edid *psb_intel_sdvo_get_edid(struct drm_connector *connector ) 
{ 
  struct psb_intel_sdvo *sdvo ;
  struct psb_intel_sdvo *tmp ;
  struct edid *tmp___0 ;

  {
#line 1303
  tmp = intel_attached_sdvo(connector);
#line 1303
  sdvo = tmp;
#line 1304
  tmp___0 = drm_get_edid(connector, & sdvo->ddc);
#line 1304
  return (tmp___0);
}
}
#line 1309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static struct edid *psb_intel_sdvo_get_analog_edid(struct drm_connector *connector ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct edid *tmp ;

  {
#line 1311
  dev_priv = (struct drm_psb_private *)(connector->dev)->dev_private;
#line 1313
  tmp = drm_get_edid(connector, & (dev_priv->gmbus + (unsigned long )dev_priv->crt_ddc_pin)->adapter);
#line 1313
  return (tmp);
}
}
#line 1318 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static enum drm_connector_status psb_intel_sdvo_hdmi_sink_detect(struct drm_connector *connector ) 
{ 
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  enum drm_connector_status status ;
  struct edid *edid ;
  u8 ddc ;
  u8 saved_ddc ;
  bool tmp___0 ;
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  struct psb_intel_sdvo_connector *tmp___1 ;

  {
#line 1320
  tmp = intel_attached_sdvo(connector);
#line 1320
  psb_intel_sdvo = tmp;
#line 1324
  edid = psb_intel_sdvo_get_edid(connector);
#line 1326
  if ((unsigned long )edid == (unsigned long )((struct edid *)0)) {
#line 1326
    tmp___0 = psb_intel_sdvo_multifunc_encoder(psb_intel_sdvo);
#line 1326
    if ((int )tmp___0) {
#line 1327
      saved_ddc = psb_intel_sdvo->ddc_bus;
#line 1333
      ddc = (u8 )((int )psb_intel_sdvo->ddc_bus >> 1);
#line 1333
      goto ldv_42722;
      ldv_42721: 
#line 1334
      psb_intel_sdvo->ddc_bus = ddc;
#line 1335
      edid = psb_intel_sdvo_get_edid(connector);
#line 1336
      if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
#line 1337
        goto ldv_42720;
      } else {

      }
#line 1333
      ddc = (u8 )((int )ddc >> 1);
      ldv_42722: ;
#line 1333
      if ((unsigned int )ddc > 1U) {
#line 1335
        goto ldv_42721;
      } else {

      }
      ldv_42720: ;
#line 1343
      if ((unsigned long )edid == (unsigned long )((struct edid *)0)) {
#line 1344
        psb_intel_sdvo->ddc_bus = saved_ddc;
      } else {

      }
    } else {

    }
  } else {

  }
#line 1351
  if ((unsigned long )edid == (unsigned long )((struct edid *)0)) {
#line 1352
    edid = psb_intel_sdvo_get_analog_edid(connector);
  } else {

  }
#line 1354
  status = 3;
#line 1355
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
#line 1357
    if ((int )((signed char )edid->input) < 0) {
#line 1358
      status = 1;
#line 1359
      if ((int )psb_intel_sdvo->is_hdmi) {
#line 1360
        psb_intel_sdvo->has_hdmi_monitor = drm_detect_hdmi_monitor(edid);
#line 1361
        psb_intel_sdvo->has_hdmi_audio = drm_detect_monitor_audio(edid);
      } else {

      }
    } else {
#line 1364
      status = 2;
    }
#line 1365
    kfree((void const   *)edid);
  } else {

  }
#line 1368
  if ((unsigned int )status == 1U) {
#line 1369
    tmp___1 = to_psb_intel_sdvo_connector(connector);
#line 1369
    psb_intel_sdvo_connector = tmp___1;
#line 1370
    if (psb_intel_sdvo_connector->force_audio != 0) {
#line 1371
      psb_intel_sdvo->has_hdmi_audio = psb_intel_sdvo_connector->force_audio > 0;
    } else {

    }
  } else {

  }
#line 1374
  return (status);
}
}
#line 1378 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static enum drm_connector_status psb_intel_sdvo_detect(struct drm_connector *connector ,
                                                       bool force ) 
{ 
  uint16_t response ;
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  struct psb_intel_sdvo_connector *tmp___0 ;
  enum drm_connector_status ret ;
  bool tmp___1 ;
  int tmp___2 ;
  unsigned long __ms ;
  unsigned long tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  struct edid *edid ;

  {
#line 1381
  tmp = intel_attached_sdvo(connector);
#line 1381
  psb_intel_sdvo = tmp;
#line 1382
  tmp___0 = to_psb_intel_sdvo_connector(connector);
#line 1382
  psb_intel_sdvo_connector = tmp___0;
#line 1385
  tmp___1 = psb_intel_sdvo_write_cmd(psb_intel_sdvo, 11, (void const   *)0, 0);
#line 1385
  if (tmp___1) {
#line 1385
    tmp___2 = 0;
  } else {
#line 1385
    tmp___2 = 1;
  }
#line 1385
  if (tmp___2) {
#line 1387
    return (3);
  } else {

  }
#line 1390
  if (((int )psb_intel_sdvo->caps.output_flags & 12) != 0) {
#line 1392
    __ms = 30UL;
#line 1392
    goto ldv_42734;
    ldv_42733: 
#line 1392
    __const_udelay(4295000UL);
    ldv_42734: 
#line 1392
    tmp___3 = __ms;
#line 1392
    __ms = __ms - 1UL;
#line 1392
    if (tmp___3 != 0UL) {
#line 1394
      goto ldv_42733;
    } else {

    }

  } else {

  }
#line 1394
  tmp___4 = psb_intel_sdvo_read_response(psb_intel_sdvo, (void *)(& response), 2);
#line 1394
  if (tmp___4) {
#line 1394
    tmp___5 = 0;
  } else {
#line 1394
    tmp___5 = 1;
  }
#line 1394
  if (tmp___5) {
#line 1395
    return (3);
  } else {

  }
#line 1397
  tmp___6 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1397
  if (tmp___6 != 0L) {
#line 1397
    drm_ut_debug_printk("psb_intel_sdvo_detect", "SDVO response %d %d [%x]\n", (int )response & 255,
                        (int )response >> 8, (int )psb_intel_sdvo_connector->output_flag);
  } else {

  }
#line 1401
  if ((unsigned int )response == 0U) {
#line 1402
    return (2);
  } else {

  }
#line 1404
  psb_intel_sdvo->attached_output = response;
#line 1406
  psb_intel_sdvo->has_hdmi_monitor = 0;
#line 1407
  psb_intel_sdvo->has_hdmi_audio = 0;
#line 1409
  if ((unsigned int )((int )psb_intel_sdvo_connector->output_flag & (int )response) == 0U) {
#line 1410
    ret = 2;
  } else
#line 1411
  if (((int )psb_intel_sdvo_connector->output_flag & 257) != 0) {
#line 1412
    ret = psb_intel_sdvo_hdmi_sink_detect(connector);
  } else {
#line 1417
    edid = psb_intel_sdvo_get_edid(connector);
#line 1418
    if ((unsigned long )edid == (unsigned long )((struct edid *)0)) {
#line 1419
      edid = psb_intel_sdvo_get_analog_edid(connector);
    } else {

    }
#line 1420
    if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
#line 1421
      if ((int )((signed char )edid->input) < 0) {
#line 1422
        ret = 2;
      } else {
#line 1424
        ret = 1;
      }
#line 1425
      kfree((void const   *)edid);
    } else {
#line 1427
      ret = 1;
    }
  }
#line 1431
  if ((unsigned int )ret == 1U) {
#line 1432
    psb_intel_sdvo->is_tv = 0;
#line 1433
    psb_intel_sdvo->is_lvds = 0;
#line 1434
    psb_intel_sdvo->base.needs_tv_clock = 0;
#line 1436
    if (((int )response & 12) != 0) {
#line 1437
      psb_intel_sdvo->is_tv = 1;
#line 1438
      psb_intel_sdvo->base.needs_tv_clock = 1;
    } else {

    }
#line 1440
    if (((int )response & 16448) != 0) {
#line 1441
      psb_intel_sdvo->is_lvds = (unsigned long )psb_intel_sdvo->sdvo_lvds_fixed_mode != (unsigned long )((struct drm_display_mode *)0);
    } else {

    }
  } else {

  }
#line 1444
  return (ret);
}
}
#line 1447 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static void psb_intel_sdvo_get_ddc_modes(struct drm_connector *connector ) 
{ 
  struct edid *edid ;
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  struct psb_intel_sdvo_connector *tmp ;
  bool monitor_is_digital ;
  bool connector_is_digital ;

  {
#line 1452
  edid = psb_intel_sdvo_get_edid(connector);
#line 1460
  if ((unsigned long )edid == (unsigned long )((struct edid *)0)) {
#line 1461
    edid = psb_intel_sdvo_get_analog_edid(connector);
  } else {

  }
#line 1463
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
#line 1464
    tmp = to_psb_intel_sdvo_connector(connector);
#line 1464
    psb_intel_sdvo_connector = tmp;
#line 1465
    monitor_is_digital = (int )((signed char )edid->input) < 0;
#line 1466
    connector_is_digital = ((int )psb_intel_sdvo_connector->output_flag & 257) != 0;
#line 1468
    if ((int )connector_is_digital == (int )monitor_is_digital) {
#line 1469
      drm_mode_connector_update_edid_property(connector, (struct edid  const  *)edid);
#line 1470
      drm_add_edid_modes(connector, edid);
    } else {

    }
#line 1473
    kfree((void const   *)edid);
  } else {

  }
#line 1475
  return;
}
}
#line 1482 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static struct drm_display_mode  const  sdvo_tv_modes[19U]  = 
#line 1482
  {      {{0, 0}, {0U, 3739147998U, 0}, {'3', '2', '0', 'x', '2', '0', '0', '\000'}, 0,
      64U, 5815, 320, 321, 384, 416, 0, 200, 201, 232, 233, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'3', '2', '0', 'x', '2', '4', '0', '\000'}, 0,
      64U, 6814, 320, 321, 384, 416, 0, 240, 241, 272, 273, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'4', '0', '0', 'x', '3', '0', '0', '\000'}, 0,
      64U, 9910, 400, 401, 464, 496, 0, 300, 301, 332, 333, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'6', '4', '0', 'x', '3', '5', '0', '\000'}, 0,
      64U, 16913, 640, 641, 704, 736, 0, 350, 351, 382, 383, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'6', '4', '0', 'x', '4', '0', '0', '\000'}, 0,
      64U, 19121, 640, 641, 704, 736, 0, 400, 401, 432, 433, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'6', '4', '0', 'x', '4', '8', '0', '\000'}, 0,
      64U, 22654, 640, 641, 704, 736, 0, 480, 481, 512, 513, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'7', '0', '4', 'x', '4', '8', '0', '\000'}, 0,
      64U, 24624, 704, 705, 768, 800, 0, 480, 481, 512, 513, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'7', '0', '4', 'x', '5', '7', '6', '\000'}, 0,
      64U, 29232, 704, 705, 768, 800, 0, 576, 577, 608, 609, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'7', '2', '0', 'x', '3', '5', '0', '\000'}, 0,
      64U, 18751, 720, 721, 784, 816, 0, 350, 351, 382, 383, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'7', '2', '0', 'x', '4', '0', '0', '\000'}, 0,
      64U, 21199, 720, 721, 784, 816, 0, 400, 401, 432, 433, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'7', '2', '0', 'x', '4', '8', '0', '\000'}, 0,
      64U, 25116, 720, 721, 784, 816, 0, 480, 481, 512, 513, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'7', '2', '0', 'x', '5', '4', '0', '\000'}, 0,
      64U, 28054, 720, 721, 784, 816, 0, 540, 541, 572, 573, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'7', '2', '0', 'x', '5', '7', '6', '\000'}, 0,
      64U, 29816, 720, 721, 784, 816, 0, 576, 577, 608, 609, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'7', '6', '8', 'x', '5', '7', '6', '\000'}, 0,
      64U, 31570, 768, 769, 832, 864, 0, 576, 577, 608, 609, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'8', '0', '0', 'x', '6', '0', '0', '\000'}, 0,
      64U, 34030, 800, 801, 864, 896, 0, 600, 601, 632, 633, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'8', '3', '2', 'x', '6', '2', '4', '\000'}, 0,
      64U, 36581, 832, 833, 896, 928, 0, 624, 625, 656, 657, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'9', '2', '0', 'x', '7', '6', '6', '\000'}, 0,
      64U, 48707, 920, 921, 984, 1016, 0, 766, 767, 798, 799, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '0', '2', '4', 'x', '7', '6', '8', '\000'},
      0, 64U, 53827, 1024, 1025, 1088, 1120, 0, 768, 769, 800, 801, 0, 5U, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '2', '8', '0', 'x', '1', '0', '2', '4',
                                     '\000'}, 0, 64U, 87265, 1280, 1281, 1344, 1376,
      0, 1024, 1025, 1056, 1057, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0}};
#line 1542 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static void psb_intel_sdvo_get_tv_modes(struct drm_connector *connector ) 
{ 
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  struct psb_intel_sdvo_sdtv_resolution_request tv_res ;
  uint32_t reply ;
  uint32_t format_map ;
  int i ;
  unsigned long _min1 ;
  unsigned long _min2 ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  struct drm_display_mode *nmode ;

  {
#line 1544
  tmp = intel_attached_sdvo(connector);
#line 1544
  psb_intel_sdvo = tmp;
#line 1546
  reply = 0U;
#line 1546
  format_map = 0U;
#line 1552
  format_map = (uint32_t )(1 << psb_intel_sdvo->tv_format_index);
#line 1553
  _min1 = 4UL;
#line 1553
  _min2 = 3UL;
#line 1553
  memcpy((void *)(& tv_res), (void const   *)(& format_map), _min1 < _min2 ? _min1 : _min2);
#line 1556
  tmp___0 = psb_intel_sdvo_set_target_output(psb_intel_sdvo, (int )psb_intel_sdvo->attached_output);
#line 1556
  if (tmp___0) {
#line 1556
    tmp___1 = 0;
  } else {
#line 1556
    tmp___1 = 1;
  }
#line 1556
  if (tmp___1) {
#line 1557
    return;
  } else {

  }
#line 1560
  tmp___2 = psb_intel_sdvo_write_cmd(psb_intel_sdvo, 131, (void const   *)(& tv_res),
                                     3);
#line 1560
  if (tmp___2) {
#line 1560
    tmp___3 = 0;
  } else {
#line 1560
    tmp___3 = 1;
  }
#line 1560
  if (tmp___3) {
#line 1563
    return;
  } else {

  }
#line 1564
  tmp___4 = psb_intel_sdvo_read_response(psb_intel_sdvo, (void *)(& reply), 3);
#line 1564
  if (tmp___4) {
#line 1564
    tmp___5 = 0;
  } else {
#line 1564
    tmp___5 = 1;
  }
#line 1564
  if (tmp___5) {
#line 1565
    return;
  } else {

  }
#line 1567
  i = 0;
#line 1567
  goto ldv_42761;
  ldv_42760: ;
#line 1568
  if (((uint32_t )(1 << i) & reply) != 0U) {
#line 1570
    nmode = drm_mode_duplicate(connector->dev, (struct drm_display_mode  const  *)(& sdvo_tv_modes) + (unsigned long )i);
#line 1572
    if ((unsigned long )nmode != (unsigned long )((struct drm_display_mode *)0)) {
#line 1573
      drm_mode_probed_add(connector, nmode);
    } else {

    }
  } else {

  }
#line 1567
  i = i + 1;
  ldv_42761: ;
#line 1567
  if ((unsigned int )i <= 18U) {
#line 1569
    goto ldv_42760;
  } else {

  }

#line 1574
  return;
}
}
#line 1577 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static void psb_intel_sdvo_get_lvds_modes(struct drm_connector *connector ) 
{ 
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  struct drm_psb_private *dev_priv ;
  struct drm_display_mode *newmode ;
  int tmp___0 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1579
  tmp = intel_attached_sdvo(connector);
#line 1579
  psb_intel_sdvo = tmp;
#line 1580
  dev_priv = (struct drm_psb_private *)(connector->dev)->dev_private;
#line 1588
  psb_intel_ddc_get_modes(connector, psb_intel_sdvo->i2c);
#line 1589
  tmp___0 = list_empty((struct list_head  const  *)(& connector->probed_modes));
#line 1589
  if (tmp___0 == 0) {
#line 1590
    goto end;
  } else {

  }
#line 1593
  if ((unsigned long )dev_priv->sdvo_lvds_vbt_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 1594
    newmode = drm_mode_duplicate(connector->dev, (struct drm_display_mode  const  *)dev_priv->sdvo_lvds_vbt_mode);
#line 1596
    if ((unsigned long )newmode != (unsigned long )((struct drm_display_mode *)0)) {
#line 1598
      newmode->type = 72U;
#line 1600
      drm_mode_probed_add(connector, newmode);
    } else {

    }
  } else {

  }
  end: 
#line 1605
  __mptr = (struct list_head  const  *)connector->probed_modes.next;
#line 1605
  newmode = (struct drm_display_mode *)__mptr;
#line 1605
  goto ldv_42776;
  ldv_42775: ;
#line 1606
  if ((newmode->type & 8U) != 0U) {
#line 1607
    psb_intel_sdvo->sdvo_lvds_fixed_mode = drm_mode_duplicate(connector->dev, (struct drm_display_mode  const  *)newmode);
#line 1610
    drm_mode_set_crtcinfo(psb_intel_sdvo->sdvo_lvds_fixed_mode, 0);
#line 1613
    psb_intel_sdvo->is_lvds = 1;
#line 1614
    goto ldv_42774;
  } else {

  }
#line 1605
  __mptr___0 = (struct list_head  const  *)newmode->head.next;
#line 1605
  newmode = (struct drm_display_mode *)__mptr___0;
  ldv_42776: ;
#line 1605
  if ((unsigned long )(& newmode->head) != (unsigned long )(& connector->probed_modes)) {
#line 1607
    goto ldv_42775;
  } else {

  }
  ldv_42774: ;
#line 1612
  return;
}
}
#line 1620 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static int psb_intel_sdvo_get_modes(struct drm_connector *connector ) 
{ 
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  struct psb_intel_sdvo_connector *tmp ;
  int tmp___0 ;

  {
#line 1622
  tmp = to_psb_intel_sdvo_connector(connector);
#line 1622
  psb_intel_sdvo_connector = tmp;
#line 1624
  if (((int )psb_intel_sdvo_connector->output_flag & 12) != 0) {
#line 1625
    psb_intel_sdvo_get_tv_modes(connector);
  } else
#line 1626
  if (((int )psb_intel_sdvo_connector->output_flag & 16448) != 0) {
#line 1627
    psb_intel_sdvo_get_lvds_modes(connector);
  } else {
#line 1629
    psb_intel_sdvo_get_ddc_modes(connector);
  }
#line 1631
  tmp___0 = list_empty((struct list_head  const  *)(& connector->probed_modes));
#line 1631
  return (tmp___0 == 0);
}
}
#line 1634 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static void psb_intel_sdvo_destroy(struct drm_connector *connector ) 
{ 


  {
#line 1636
  drm_connector_unregister(connector);
#line 1637
  drm_connector_cleanup(connector);
#line 1638
  kfree((void const   *)connector);
#line 1639
  return;
}
}
#line 1641 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_detect_hdmi_audio(struct drm_connector *connector ) 
{ 
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  struct edid *edid ;
  bool has_audio ;

  {
#line 1643
  tmp = intel_attached_sdvo(connector);
#line 1643
  psb_intel_sdvo = tmp;
#line 1645
  has_audio = 0;
#line 1647
  if (! psb_intel_sdvo->is_hdmi) {
#line 1648
    return (0);
  } else {

  }
#line 1650
  edid = psb_intel_sdvo_get_edid(connector);
#line 1651
  if ((unsigned long )edid != (unsigned long )((struct edid *)0) && (int )((signed char )edid->input) < 0) {
#line 1652
    has_audio = drm_detect_monitor_audio(edid);
  } else {

  }
#line 1654
  return (has_audio);
}
}
#line 1658 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static int psb_intel_sdvo_set_property(struct drm_connector *connector , struct drm_property *property ,
                                       uint64_t val ) 
{ 
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  struct psb_intel_sdvo_connector *tmp___0 ;
  struct drm_psb_private *dev_priv ;
  uint16_t temp_value ;
  uint8_t cmd ;
  int ret ;
  int i ;
  bool has_audio ;
  bool tmp___1 ;
  int tmp___2 ;
  struct drm_crtc *crtc ;

  {
#line 1662
  tmp = intel_attached_sdvo(connector);
#line 1662
  psb_intel_sdvo = tmp;
#line 1663
  tmp___0 = to_psb_intel_sdvo_connector(connector);
#line 1663
  psb_intel_sdvo_connector = tmp___0;
#line 1664
  dev_priv = (struct drm_psb_private *)(connector->dev)->dev_private;
#line 1669
  ret = drm_object_property_set_value(& connector->base, property, val);
#line 1670
  if (ret != 0) {
#line 1671
    return (ret);
  } else {

  }
#line 1673
  if ((unsigned long )dev_priv->force_audio_property == (unsigned long )property) {
#line 1674
    i = (int )val;
#line 1677
    if (psb_intel_sdvo_connector->force_audio == i) {
#line 1678
      return (0);
    } else {

    }
#line 1680
    psb_intel_sdvo_connector->force_audio = i;
#line 1682
    if (i == 0) {
#line 1683
      has_audio = psb_intel_sdvo_detect_hdmi_audio(connector);
    } else {
#line 1685
      has_audio = i > 0;
    }
#line 1687
    if ((int )psb_intel_sdvo->has_hdmi_audio == (int )has_audio) {
#line 1688
      return (0);
    } else {

    }
#line 1690
    psb_intel_sdvo->has_hdmi_audio = has_audio;
#line 1691
    goto done;
  } else {

  }
#line 1694
  if ((unsigned long )dev_priv->broadcast_rgb_property == (unsigned long )property) {
#line 1695
    if ((uint64_t )(psb_intel_sdvo->color_range != 0U) == val) {
#line 1696
      return (0);
    } else {

    }
#line 1698
    psb_intel_sdvo->color_range = val != 0ULL ? 256U : 0U;
#line 1699
    goto done;
  } else {

  }
#line 1711
  if ((unsigned long )psb_intel_sdvo_connector->tv_format == (unsigned long )property) {
#line 1712
    if (val > 18ULL) {
#line 1713
      return (-22);
    } else {

    }
#line 1715
    if (psb_intel_sdvo->tv_format_index == (int )psb_intel_sdvo_connector->tv_format_supported[val]) {
#line 1717
      return (0);
    } else {

    }
#line 1719
    psb_intel_sdvo->tv_format_index = (int )psb_intel_sdvo_connector->tv_format_supported[val];
#line 1720
    goto done;
  } else
#line 1721
  if (((int )psb_intel_sdvo_connector->output_flag & 16460) != 0) {
#line 1722
    temp_value = (uint16_t )val;
#line 1723
    if ((unsigned long )psb_intel_sdvo_connector->left == (unsigned long )property) {
#line 1724
      drm_object_property_set_value(& connector->base, psb_intel_sdvo_connector->right,
                                    val);
#line 1726
      if (psb_intel_sdvo_connector->left_margin == (u32 )temp_value) {
#line 1727
        return (0);
      } else {

      }
#line 1729
      psb_intel_sdvo_connector->left_margin = (u32 )temp_value;
#line 1730
      psb_intel_sdvo_connector->right_margin = (u32 )temp_value;
#line 1731
      temp_value = (int )((uint16_t )psb_intel_sdvo_connector->max_hscan) - (int )((uint16_t )psb_intel_sdvo_connector->left_margin);
#line 1733
      cmd = 99U;
#line 1734
      goto set_value;
    } else
#line 1735
    if ((unsigned long )psb_intel_sdvo_connector->right == (unsigned long )property) {
#line 1736
      drm_object_property_set_value(& connector->base, psb_intel_sdvo_connector->left,
                                    val);
#line 1738
      if (psb_intel_sdvo_connector->right_margin == (u32 )temp_value) {
#line 1739
        return (0);
      } else {

      }
#line 1741
      psb_intel_sdvo_connector->left_margin = (u32 )temp_value;
#line 1742
      psb_intel_sdvo_connector->right_margin = (u32 )temp_value;
#line 1743
      temp_value = (int )((uint16_t )psb_intel_sdvo_connector->max_hscan) - (int )((uint16_t )psb_intel_sdvo_connector->left_margin);
#line 1745
      cmd = 99U;
#line 1746
      goto set_value;
    } else
#line 1747
    if ((unsigned long )psb_intel_sdvo_connector->top == (unsigned long )property) {
#line 1748
      drm_object_property_set_value(& connector->base, psb_intel_sdvo_connector->bottom,
                                    val);
#line 1750
      if (psb_intel_sdvo_connector->top_margin == (u32 )temp_value) {
#line 1751
        return (0);
      } else {

      }
#line 1753
      psb_intel_sdvo_connector->top_margin = (u32 )temp_value;
#line 1754
      psb_intel_sdvo_connector->bottom_margin = (u32 )temp_value;
#line 1755
      temp_value = (int )((uint16_t )psb_intel_sdvo_connector->max_vscan) - (int )((uint16_t )psb_intel_sdvo_connector->top_margin);
#line 1757
      cmd = 102U;
#line 1758
      goto set_value;
    } else
#line 1759
    if ((unsigned long )psb_intel_sdvo_connector->bottom == (unsigned long )property) {
#line 1760
      drm_object_property_set_value(& connector->base, psb_intel_sdvo_connector->top,
                                    val);
#line 1762
      if (psb_intel_sdvo_connector->bottom_margin == (u32 )temp_value) {
#line 1763
        return (0);
      } else {

      }
#line 1765
      psb_intel_sdvo_connector->top_margin = (u32 )temp_value;
#line 1766
      psb_intel_sdvo_connector->bottom_margin = (u32 )temp_value;
#line 1767
      temp_value = (int )((uint16_t )psb_intel_sdvo_connector->max_vscan) - (int )((uint16_t )psb_intel_sdvo_connector->top_margin);
#line 1769
      cmd = 102U;
#line 1770
      goto set_value;
    } else {

    }
#line 1772
    if ((unsigned long )psb_intel_sdvo_connector->hpos == (unsigned long )property) {
#line 1772
      if (psb_intel_sdvo_connector->cur_hpos == (u32 )temp_value) {
#line 1772
        return (0);
      } else {

      }
#line 1772
      if (psb_intel_sdvo_connector->max_hpos < (u32 )temp_value) {
#line 1772
        return (-22);
      } else {

      }
#line 1772
      cmd = 105U;
#line 1772
      psb_intel_sdvo_connector->cur_hpos = (u32 )temp_value;
#line 1772
      goto set_value;
    } else {

    }
#line 1773
    if ((unsigned long )psb_intel_sdvo_connector->vpos == (unsigned long )property) {
#line 1773
      if (psb_intel_sdvo_connector->cur_vpos == (u32 )temp_value) {
#line 1773
        return (0);
      } else {

      }
#line 1773
      if (psb_intel_sdvo_connector->max_vpos < (u32 )temp_value) {
#line 1773
        return (-22);
      } else {

      }
#line 1773
      cmd = 108U;
#line 1773
      psb_intel_sdvo_connector->cur_vpos = (u32 )temp_value;
#line 1773
      goto set_value;
    } else {

    }
#line 1774
    if ((unsigned long )psb_intel_sdvo_connector->saturation == (unsigned long )property) {
#line 1774
      if (psb_intel_sdvo_connector->cur_saturation == (u32 )temp_value) {
#line 1774
        return (0);
      } else {

      }
#line 1774
      if (psb_intel_sdvo_connector->max_saturation < (u32 )temp_value) {
#line 1774
        return (-22);
      } else {

      }
#line 1774
      cmd = 87U;
#line 1774
      psb_intel_sdvo_connector->cur_saturation = (u32 )temp_value;
#line 1774
      goto set_value;
    } else {

    }
#line 1775
    if ((unsigned long )psb_intel_sdvo_connector->contrast == (unsigned long )property) {
#line 1775
      if (psb_intel_sdvo_connector->cur_contrast == (u32 )temp_value) {
#line 1775
        return (0);
      } else {

      }
#line 1775
      if (psb_intel_sdvo_connector->max_contrast < (u32 )temp_value) {
#line 1775
        return (-22);
      } else {

      }
#line 1775
      cmd = 96U;
#line 1775
      psb_intel_sdvo_connector->cur_contrast = (u32 )temp_value;
#line 1775
      goto set_value;
    } else {

    }
#line 1776
    if ((unsigned long )psb_intel_sdvo_connector->hue == (unsigned long )property) {
#line 1776
      if (psb_intel_sdvo_connector->cur_hue == (u32 )temp_value) {
#line 1776
        return (0);
      } else {

      }
#line 1776
      if (psb_intel_sdvo_connector->max_hue < (u32 )temp_value) {
#line 1776
        return (-22);
      } else {

      }
#line 1776
      cmd = 90U;
#line 1776
      psb_intel_sdvo_connector->cur_hue = (u32 )temp_value;
#line 1776
      goto set_value;
    } else {

    }
#line 1777
    if ((unsigned long )psb_intel_sdvo_connector->brightness == (unsigned long )property) {
#line 1777
      if (psb_intel_sdvo_connector->cur_brightness == (u32 )temp_value) {
#line 1777
        return (0);
      } else {

      }
#line 1777
      if (psb_intel_sdvo_connector->max_brightness < (u32 )temp_value) {
#line 1777
        return (-22);
      } else {

      }
#line 1777
      cmd = 93U;
#line 1777
      psb_intel_sdvo_connector->cur_brightness = (u32 )temp_value;
#line 1777
      goto set_value;
    } else {

    }
#line 1778
    if ((unsigned long )psb_intel_sdvo_connector->sharpness == (unsigned long )property) {
#line 1778
      if (psb_intel_sdvo_connector->cur_sharpness == (u32 )temp_value) {
#line 1778
        return (0);
      } else {

      }
#line 1778
      if (psb_intel_sdvo_connector->max_sharpness < (u32 )temp_value) {
#line 1778
        return (-22);
      } else {

      }
#line 1778
      cmd = 111U;
#line 1778
      psb_intel_sdvo_connector->cur_sharpness = (u32 )temp_value;
#line 1778
      goto set_value;
    } else {

    }
#line 1779
    if ((unsigned long )psb_intel_sdvo_connector->flicker_filter == (unsigned long )property) {
#line 1779
      if (psb_intel_sdvo_connector->cur_flicker_filter == (u32 )temp_value) {
#line 1779
        return (0);
      } else {

      }
#line 1779
      if (psb_intel_sdvo_connector->max_flicker_filter < (u32 )temp_value) {
#line 1779
        return (-22);
      } else {

      }
#line 1779
      cmd = 79U;
#line 1779
      psb_intel_sdvo_connector->cur_flicker_filter = (u32 )temp_value;
#line 1779
      goto set_value;
    } else {

    }
#line 1780
    if ((unsigned long )psb_intel_sdvo_connector->flicker_filter_2d == (unsigned long )property) {
#line 1780
      if (psb_intel_sdvo_connector->cur_flicker_filter_2d == (u32 )temp_value) {
#line 1780
        return (0);
      } else {

      }
#line 1780
      if (psb_intel_sdvo_connector->max_flicker_filter_2d < (u32 )temp_value) {
#line 1780
        return (-22);
      } else {

      }
#line 1780
      cmd = 84U;
#line 1780
      psb_intel_sdvo_connector->cur_flicker_filter_2d = (u32 )temp_value;
#line 1780
      goto set_value;
    } else {

    }
#line 1781
    if ((unsigned long )psb_intel_sdvo_connector->flicker_filter_adaptive == (unsigned long )property) {
#line 1781
      if (psb_intel_sdvo_connector->cur_flicker_filter_adaptive == (u32 )temp_value) {
#line 1781
        return (0);
      } else {

      }
#line 1781
      if (psb_intel_sdvo_connector->max_flicker_filter_adaptive < (u32 )temp_value) {
#line 1781
        return (-22);
      } else {

      }
#line 1781
      cmd = 81U;
#line 1781
      psb_intel_sdvo_connector->cur_flicker_filter_adaptive = (u32 )temp_value;
#line 1781
      goto set_value;
    } else {

    }
#line 1782
    if ((unsigned long )psb_intel_sdvo_connector->tv_chroma_filter == (unsigned long )property) {
#line 1782
      if (psb_intel_sdvo_connector->cur_tv_chroma_filter == (u32 )temp_value) {
#line 1782
        return (0);
      } else {

      }
#line 1782
      if (psb_intel_sdvo_connector->max_tv_chroma_filter < (u32 )temp_value) {
#line 1782
        return (-22);
      } else {

      }
#line 1782
      cmd = 118U;
#line 1782
      psb_intel_sdvo_connector->cur_tv_chroma_filter = (u32 )temp_value;
#line 1782
      goto set_value;
    } else {

    }
#line 1783
    if ((unsigned long )psb_intel_sdvo_connector->tv_luma_filter == (unsigned long )property) {
#line 1783
      if (psb_intel_sdvo_connector->cur_tv_luma_filter == (u32 )temp_value) {
#line 1783
        return (0);
      } else {

      }
#line 1783
      if (psb_intel_sdvo_connector->max_tv_luma_filter < (u32 )temp_value) {
#line 1783
        return (-22);
      } else {

      }
#line 1783
      cmd = 121U;
#line 1783
      psb_intel_sdvo_connector->cur_tv_luma_filter = (u32 )temp_value;
#line 1783
      goto set_value;
    } else {

    }
#line 1784
    if ((unsigned long )psb_intel_sdvo_connector->dot_crawl == (unsigned long )property) {
#line 1784
      if (psb_intel_sdvo_connector->cur_dot_crawl == (u32 )temp_value) {
#line 1784
        return (0);
      } else {

      }
#line 1784
      if (psb_intel_sdvo_connector->max_dot_crawl < (u32 )temp_value) {
#line 1784
        return (-22);
      } else {

      }
#line 1784
      cmd = 113U;
#line 1784
      psb_intel_sdvo_connector->cur_dot_crawl = (u32 )temp_value;
#line 1784
      goto set_value;
    } else {

    }
  } else {

  }
#line 1787
  return (-22);
  set_value: 
#line 1790
  tmp___1 = psb_intel_sdvo_set_value(psb_intel_sdvo, (int )cmd, (void const   *)(& temp_value),
                                     2);
#line 1790
  if (tmp___1) {
#line 1790
    tmp___2 = 0;
  } else {
#line 1790
    tmp___2 = 1;
  }
#line 1790
  if (tmp___2) {
#line 1791
    return (-5);
  } else {

  }
  done: ;
#line 1795
  if ((unsigned long )psb_intel_sdvo->base.base.crtc != (unsigned long )((struct drm_crtc *)0)) {
#line 1796
    crtc = psb_intel_sdvo->base.base.crtc;
#line 1797
    drm_crtc_helper_set_mode(crtc, & crtc->mode, crtc->x, crtc->y, (crtc->primary)->fb);
  } else {

  }
#line 1801
  return (0);
}
}
#line 1805 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static void psb_intel_sdvo_save(struct drm_connector *connector ) 
{ 
  struct drm_device *dev ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct psb_intel_sdvo *sdvo ;
  struct psb_intel_sdvo *tmp___0 ;

  {
#line 1807
  dev = connector->dev;
#line 1808
  tmp = gma_attached_encoder(connector);
#line 1808
  gma_encoder = tmp;
#line 1809
  tmp___0 = to_psb_intel_sdvo(& gma_encoder->base);
#line 1809
  sdvo = tmp___0;
#line 1811
  sdvo->saveSDVO = REGISTER_READ(dev, (uint32_t )sdvo->sdvo_reg);
#line 1812
  return;
}
}
#line 1814 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static void psb_intel_sdvo_restore(struct drm_connector *connector ) 
{ 
  struct drm_device *dev ;
  struct drm_encoder *encoder ;
  struct gma_encoder *tmp ;
  struct psb_intel_sdvo *sdvo ;
  struct psb_intel_sdvo *tmp___0 ;
  struct drm_crtc *crtc ;

  {
#line 1816
  dev = connector->dev;
#line 1817
  tmp = gma_attached_encoder(connector);
#line 1817
  encoder = & tmp->base;
#line 1818
  tmp___0 = to_psb_intel_sdvo(encoder);
#line 1818
  sdvo = tmp___0;
#line 1819
  crtc = encoder->crtc;
#line 1821
  REGISTER_WRITE(dev, (uint32_t )sdvo->sdvo_reg, sdvo->saveSDVO);
#line 1825
  if ((unsigned int )connector->status == 1U) {
#line 1826
    drm_crtc_helper_set_mode(crtc, & crtc->mode, crtc->x, crtc->y, (struct drm_framebuffer *)0);
  } else {

  }
#line 1827
  return;
}
}
#line 1830 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static struct drm_encoder_helper_funcs  const  psb_intel_sdvo_helper_funcs  = 
#line 1830
     {& psb_intel_sdvo_dpms, 0, 0, & psb_intel_sdvo_mode_fixup, & gma_encoder_prepare,
    & gma_encoder_commit, & psb_intel_sdvo_mode_set, 0, 0, 0, 0, 0};
#line 1838 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static struct drm_connector_funcs  const  psb_intel_sdvo_connector_funcs  = 
#line 1838
     {& drm_helper_connector_dpms, & psb_intel_sdvo_save, & psb_intel_sdvo_restore,
    0, & psb_intel_sdvo_detect, & drm_helper_probe_single_connector_modes, & psb_intel_sdvo_set_property,
    & psb_intel_sdvo_destroy, 0, 0, 0, 0, 0};
#line 1848 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static struct drm_connector_helper_funcs  const  psb_intel_sdvo_connector_helper_funcs  =    {& psb_intel_sdvo_get_modes,
    (enum drm_mode_status (*)(struct drm_connector * , struct drm_display_mode * ))(& psb_intel_sdvo_mode_valid),
    & gma_best_encoder};
#line 1854 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static void psb_intel_sdvo_enc_destroy(struct drm_encoder *encoder ) 
{ 
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;

  {
#line 1856
  tmp = to_psb_intel_sdvo(encoder);
#line 1856
  psb_intel_sdvo = tmp;
#line 1858
  if ((unsigned long )psb_intel_sdvo->sdvo_lvds_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 1859
    drm_mode_destroy(encoder->dev, psb_intel_sdvo->sdvo_lvds_fixed_mode);
  } else {

  }
#line 1862
  i2c_del_adapter(& psb_intel_sdvo->ddc);
#line 1863
  gma_encoder_destroy(encoder);
#line 1864
  return;
}
}
#line 1866 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static struct drm_encoder_funcs  const  psb_intel_sdvo_enc_funcs  =    {0, & psb_intel_sdvo_enc_destroy};
#line 1871 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static void psb_intel_sdvo_guess_ddc_bus(struct psb_intel_sdvo *sdvo ) 
{ 


  {
#line 1877
  sdvo->ddc_bus = 2U;
#line 1878
  return;
}
}
#line 1922 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static void psb_intel_sdvo_select_ddc_bus(struct drm_psb_private *dev_priv , struct psb_intel_sdvo *sdvo ,
                                          u32 reg ) 
{ 
  struct sdvo_device_mapping *mapping ;

  {
#line 1927
  if (reg == 397632U) {
#line 1928
    mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings);
  } else {
#line 1930
    mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings) + 1UL;
  }
#line 1932
  if ((unsigned int )mapping->initialized != 0U) {
#line 1933
    sdvo->ddc_bus = (uint8_t )(1 << ((int )mapping->ddc_pin >> 4));
  } else {
#line 1935
    psb_intel_sdvo_guess_ddc_bus(sdvo);
  }
#line 1936
  return;
}
}
#line 1939 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static void psb_intel_sdvo_select_i2c_bus(struct drm_psb_private *dev_priv , struct psb_intel_sdvo *sdvo ,
                                          u32 reg ) 
{ 
  struct sdvo_device_mapping *mapping ;
  u8 pin ;
  u8 speed ;

  {
#line 1945
  if (reg == 397632U) {
#line 1946
    mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings);
  } else {
#line 1948
    mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings) + 1UL;
  }
#line 1950
  pin = 5U;
#line 1951
  speed = 3U;
#line 1952
  if ((unsigned int )mapping->initialized != 0U) {
#line 1953
    pin = mapping->i2c_pin;
#line 1954
    speed = mapping->i2c_speed;
  } else {

  }
#line 1957
  if ((unsigned int )pin <= 7U) {
#line 1958
    sdvo->i2c = & (dev_priv->gmbus + (unsigned long )pin)->adapter;
#line 1959
    gma_intel_gmbus_set_speed(sdvo->i2c, (int )speed);
#line 1960
    gma_intel_gmbus_force_bit(sdvo->i2c, 1);
  } else {
#line 1962
    sdvo->i2c = & (dev_priv->gmbus + 5UL)->adapter;
  }
#line 1963
  return;
}
}
#line 1966 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_is_hdmi_connector(struct psb_intel_sdvo *psb_intel_sdvo ,
                                             int device ) 
{ 
  bool tmp ;

  {
#line 1968
  tmp = psb_intel_sdvo_check_supp_encode(psb_intel_sdvo);
#line 1968
  return (tmp);
}
}
#line 1972 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static u8 psb_intel_sdvo_get_slave_addr(struct drm_device *dev , int sdvo_reg ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct sdvo_device_mapping *my_mapping ;
  struct sdvo_device_mapping *other_mapping ;

  {
#line 1974
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 1977
  if (sdvo_reg == 397632) {
#line 1978
    my_mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings);
#line 1979
    other_mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings) + 1UL;
  } else {
#line 1981
    my_mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings) + 1UL;
#line 1982
    other_mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings);
  }
#line 1986
  if ((unsigned int )my_mapping->slave_addr != 0U) {
#line 1987
    return (my_mapping->slave_addr);
  } else {

  }
#line 1992
  if ((unsigned int )other_mapping->slave_addr != 0U) {
#line 1993
    if ((unsigned int )other_mapping->slave_addr == 112U) {
#line 1994
      return (114U);
    } else {
#line 1996
      return (112U);
    }
  } else {

  }
#line 2002
  if (sdvo_reg == 397632) {
#line 2003
    return (112U);
  } else {
#line 2005
    return (114U);
  }
}
}
#line 2009 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static void psb_intel_sdvo_connector_init(struct psb_intel_sdvo_connector *connector ,
                                          struct psb_intel_sdvo *encoder ) 
{ 


  {
#line 2012
  drm_connector_init(encoder->base.base.dev, & connector->base.base, & psb_intel_sdvo_connector_funcs,
                     connector->base.base.connector_type);
#line 2017
  drm_connector_helper_add(& connector->base.base, & psb_intel_sdvo_connector_helper_funcs);
#line 2020
  connector->base.base.interlace_allowed = 0;
#line 2021
  connector->base.base.doublescan_allowed = 0;
#line 2022
  connector->base.base.display_info.subpixel_order = 1;
#line 2024
  gma_connector_attach_encoder(& connector->base, & encoder->base);
#line 2025
  drm_connector_register(& connector->base.base);
#line 2026
  return;
}
}
#line 2029 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static void psb_intel_sdvo_add_hdmi_properties(struct psb_intel_sdvo_connector *connector ) 
{ 


  {
#line 2031
  return;
}
}
#line 2040 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_dvi_init(struct psb_intel_sdvo *psb_intel_sdvo , int device ) 
{ 
  struct drm_encoder *encoder ;
  struct drm_connector *connector ;
  struct gma_connector *intel_connector ;
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  void *tmp ;
  bool tmp___0 ;

  {
#line 2042
  encoder = & psb_intel_sdvo->base.base;
#line 2047
  tmp = kzalloc(1248UL, 208U);
#line 2047
  psb_intel_sdvo_connector = (struct psb_intel_sdvo_connector *)tmp;
#line 2048
  if ((unsigned long )psb_intel_sdvo_connector == (unsigned long )((struct psb_intel_sdvo_connector *)0)) {
#line 2049
    return (0);
  } else {

  }
#line 2051
  if (device == 0) {
#line 2052
    psb_intel_sdvo->controlled_output = (uint16_t )((unsigned int )psb_intel_sdvo->controlled_output | 1U);
#line 2053
    psb_intel_sdvo_connector->output_flag = 1U;
  } else
#line 2054
  if (device == 1) {
#line 2055
    psb_intel_sdvo->controlled_output = (uint16_t )((unsigned int )psb_intel_sdvo->controlled_output | 256U);
#line 2056
    psb_intel_sdvo_connector->output_flag = 256U;
  } else {

  }
#line 2059
  intel_connector = & psb_intel_sdvo_connector->base;
#line 2060
  connector = & intel_connector->base;
#line 2062
  encoder->encoder_type = 2;
#line 2063
  connector->connector_type = 3;
#line 2065
  tmp___0 = psb_intel_sdvo_is_hdmi_connector(psb_intel_sdvo, device);
#line 2065
  if ((int )tmp___0) {
#line 2066
    connector->connector_type = 11;
#line 2067
    psb_intel_sdvo->is_hdmi = 1;
  } else {

  }
#line 2069
  psb_intel_sdvo->base.clone_mask = 576;
#line 2072
  psb_intel_sdvo_connector_init(psb_intel_sdvo_connector, psb_intel_sdvo);
#line 2073
  if ((int )psb_intel_sdvo->is_hdmi) {
#line 2074
    psb_intel_sdvo_add_hdmi_properties(psb_intel_sdvo_connector);
  } else {

  }
#line 2076
  return (1);
}
}
#line 2080 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_tv_init(struct psb_intel_sdvo *psb_intel_sdvo , int type ) 
{ 
  struct drm_encoder *encoder ;
  struct drm_connector *connector ;
  struct gma_connector *intel_connector ;
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 2082
  encoder = & psb_intel_sdvo->base.base;
#line 2087
  tmp = kzalloc(1248UL, 208U);
#line 2087
  psb_intel_sdvo_connector = (struct psb_intel_sdvo_connector *)tmp;
#line 2088
  if ((unsigned long )psb_intel_sdvo_connector == (unsigned long )((struct psb_intel_sdvo_connector *)0)) {
#line 2089
    return (0);
  } else {

  }
#line 2091
  intel_connector = & psb_intel_sdvo_connector->base;
#line 2092
  connector = & intel_connector->base;
#line 2093
  encoder->encoder_type = 4;
#line 2094
  connector->connector_type = 6;
#line 2096
  psb_intel_sdvo->controlled_output = (uint16_t )((int )((short )psb_intel_sdvo->controlled_output) | (int )((short )type));
#line 2097
  psb_intel_sdvo_connector->output_flag = (uint16_t )type;
#line 2099
  psb_intel_sdvo->is_tv = 1;
#line 2100
  psb_intel_sdvo->base.needs_tv_clock = 1;
#line 2101
  psb_intel_sdvo->base.clone_mask = 128;
#line 2103
  psb_intel_sdvo_connector_init(psb_intel_sdvo_connector, psb_intel_sdvo);
#line 2105
  tmp___0 = psb_intel_sdvo_tv_create_property(psb_intel_sdvo, psb_intel_sdvo_connector,
                                              type);
#line 2105
  if (tmp___0) {
#line 2105
    tmp___1 = 0;
  } else {
#line 2105
    tmp___1 = 1;
  }
#line 2105
  if (tmp___1) {
#line 2106
    goto err;
  } else {

  }
#line 2108
  tmp___2 = psb_intel_sdvo_create_enhance_property(psb_intel_sdvo, psb_intel_sdvo_connector);
#line 2108
  if (tmp___2) {
#line 2108
    tmp___3 = 0;
  } else {
#line 2108
    tmp___3 = 1;
  }
#line 2108
  if (tmp___3) {
#line 2109
    goto err;
  } else {

  }
#line 2111
  return (1);
  err: 
#line 2114
  psb_intel_sdvo_destroy(connector);
#line 2115
  return (0);
}
}
#line 2119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_analog_init(struct psb_intel_sdvo *psb_intel_sdvo , int device ) 
{ 
  struct drm_encoder *encoder ;
  struct drm_connector *connector ;
  struct gma_connector *intel_connector ;
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  void *tmp ;

  {
#line 2121
  encoder = & psb_intel_sdvo->base.base;
#line 2126
  tmp = kzalloc(1248UL, 208U);
#line 2126
  psb_intel_sdvo_connector = (struct psb_intel_sdvo_connector *)tmp;
#line 2127
  if ((unsigned long )psb_intel_sdvo_connector == (unsigned long )((struct psb_intel_sdvo_connector *)0)) {
#line 2128
    return (0);
  } else {

  }
#line 2130
  intel_connector = & psb_intel_sdvo_connector->base;
#line 2131
  connector = & intel_connector->base;
#line 2132
  connector->polled = 2U;
#line 2133
  encoder->encoder_type = 1;
#line 2134
  connector->connector_type = 1;
#line 2136
  if (device == 0) {
#line 2137
    psb_intel_sdvo->controlled_output = (uint16_t )((unsigned int )psb_intel_sdvo->controlled_output | 2U);
#line 2138
    psb_intel_sdvo_connector->output_flag = 2U;
  } else
#line 2139
  if (device == 1) {
#line 2140
    psb_intel_sdvo->controlled_output = (uint16_t )((unsigned int )psb_intel_sdvo->controlled_output | 512U);
#line 2141
    psb_intel_sdvo_connector->output_flag = 512U;
  } else {

  }
#line 2144
  psb_intel_sdvo->base.clone_mask = 576;
#line 2147
  psb_intel_sdvo_connector_init(psb_intel_sdvo_connector, psb_intel_sdvo);
#line 2149
  return (1);
}
}
#line 2153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_lvds_init(struct psb_intel_sdvo *psb_intel_sdvo , int device ) 
{ 
  struct drm_encoder *encoder ;
  struct drm_connector *connector ;
  struct gma_connector *intel_connector ;
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 2155
  encoder = & psb_intel_sdvo->base.base;
#line 2160
  tmp = kzalloc(1248UL, 208U);
#line 2160
  psb_intel_sdvo_connector = (struct psb_intel_sdvo_connector *)tmp;
#line 2161
  if ((unsigned long )psb_intel_sdvo_connector == (unsigned long )((struct psb_intel_sdvo_connector *)0)) {
#line 2162
    return (0);
  } else {

  }
#line 2164
  intel_connector = & psb_intel_sdvo_connector->base;
#line 2165
  connector = & intel_connector->base;
#line 2166
  encoder->encoder_type = 3;
#line 2167
  connector->connector_type = 7;
#line 2169
  if (device == 0) {
#line 2170
    psb_intel_sdvo->controlled_output = (uint16_t )((unsigned int )psb_intel_sdvo->controlled_output | 64U);
#line 2171
    psb_intel_sdvo_connector->output_flag = 64U;
  } else
#line 2172
  if (device == 1) {
#line 2173
    psb_intel_sdvo->controlled_output = (uint16_t )((unsigned int )psb_intel_sdvo->controlled_output | 16384U);
#line 2174
    psb_intel_sdvo_connector->output_flag = 16384U;
  } else {

  }
#line 2177
  psb_intel_sdvo->base.clone_mask = 768;
#line 2180
  psb_intel_sdvo_connector_init(psb_intel_sdvo_connector, psb_intel_sdvo);
#line 2181
  tmp___0 = psb_intel_sdvo_create_enhance_property(psb_intel_sdvo, psb_intel_sdvo_connector);
#line 2181
  if (tmp___0) {
#line 2181
    tmp___1 = 0;
  } else {
#line 2181
    tmp___1 = 1;
  }
#line 2181
  if (tmp___1) {
#line 2182
    goto err;
  } else {

  }
#line 2184
  return (1);
  err: 
#line 2187
  psb_intel_sdvo_destroy(connector);
#line 2188
  return (0);
}
}
#line 2192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_output_setup(struct psb_intel_sdvo *psb_intel_sdvo , uint16_t flags ) 
{ 
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  bool tmp___13 ;
  int tmp___14 ;
  unsigned char bytes[2U] ;
  long tmp___15 ;

  {
#line 2194
  psb_intel_sdvo->is_tv = 0;
#line 2195
  psb_intel_sdvo->base.needs_tv_clock = 0;
#line 2196
  psb_intel_sdvo->is_lvds = 0;
#line 2200
  if ((int )flags & 1) {
#line 2201
    tmp = psb_intel_sdvo_dvi_init(psb_intel_sdvo, 0);
#line 2201
    if (tmp) {
#line 2201
      tmp___0 = 0;
    } else {
#line 2201
      tmp___0 = 1;
    }
#line 2201
    if (tmp___0) {
#line 2202
      return (0);
    } else {

    }
  } else {

  }
#line 2204
  if (((int )flags & 257) == 257) {
#line 2205
    tmp___1 = psb_intel_sdvo_dvi_init(psb_intel_sdvo, 1);
#line 2205
    if (tmp___1) {
#line 2205
      tmp___2 = 0;
    } else {
#line 2205
      tmp___2 = 1;
    }
#line 2205
    if (tmp___2) {
#line 2206
      return (0);
    } else {

    }
  } else {

  }
#line 2209
  if (((int )flags & 8) != 0) {
#line 2210
    tmp___3 = psb_intel_sdvo_tv_init(psb_intel_sdvo, 8);
#line 2210
    if (tmp___3) {
#line 2210
      tmp___4 = 0;
    } else {
#line 2210
      tmp___4 = 1;
    }
#line 2210
    if (tmp___4) {
#line 2211
      return (0);
    } else {

    }
  } else {

  }
#line 2213
  if (((int )flags & 4) != 0) {
#line 2214
    tmp___5 = psb_intel_sdvo_tv_init(psb_intel_sdvo, 4);
#line 2214
    if (tmp___5) {
#line 2214
      tmp___6 = 0;
    } else {
#line 2214
      tmp___6 = 1;
    }
#line 2214
    if (tmp___6) {
#line 2215
      return (0);
    } else {

    }
  } else {

  }
#line 2217
  if (((int )flags & 2) != 0) {
#line 2218
    tmp___7 = psb_intel_sdvo_analog_init(psb_intel_sdvo, 0);
#line 2218
    if (tmp___7) {
#line 2218
      tmp___8 = 0;
    } else {
#line 2218
      tmp___8 = 1;
    }
#line 2218
    if (tmp___8) {
#line 2219
      return (0);
    } else {

    }
  } else {

  }
#line 2221
  if (((int )flags & 514) == 514) {
#line 2222
    tmp___9 = psb_intel_sdvo_analog_init(psb_intel_sdvo, 1);
#line 2222
    if (tmp___9) {
#line 2222
      tmp___10 = 0;
    } else {
#line 2222
      tmp___10 = 1;
    }
#line 2222
    if (tmp___10) {
#line 2223
      return (0);
    } else {

    }
  } else {

  }
#line 2225
  if (((int )flags & 64) != 0) {
#line 2226
    tmp___11 = psb_intel_sdvo_lvds_init(psb_intel_sdvo, 0);
#line 2226
    if (tmp___11) {
#line 2226
      tmp___12 = 0;
    } else {
#line 2226
      tmp___12 = 1;
    }
#line 2226
    if (tmp___12) {
#line 2227
      return (0);
    } else {

    }
  } else {

  }
#line 2229
  if (((int )flags & 16448) == 16448) {
#line 2230
    tmp___13 = psb_intel_sdvo_lvds_init(psb_intel_sdvo, 1);
#line 2230
    if (tmp___13) {
#line 2230
      tmp___14 = 0;
    } else {
#line 2230
      tmp___14 = 1;
    }
#line 2230
    if (tmp___14) {
#line 2231
      return (0);
    } else {

    }
  } else {

  }
#line 2233
  if (((int )flags & 17231) == 0) {
#line 2236
    psb_intel_sdvo->controlled_output = 0U;
#line 2237
    memcpy((void *)(& bytes), (void const   *)(& psb_intel_sdvo->caps.output_flags),
             2UL);
#line 2238
    tmp___15 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2238
    if (tmp___15 != 0L) {
#line 2238
      drm_ut_debug_printk("psb_intel_sdvo_output_setup", "%s: Unknown SDVO output type (0x%02x%02x)\n",
                          psb_intel_sdvo->sdvo_reg == 397632 ? (char *)"SDVOB" : (char *)"SDVOC",
                          (int )bytes[0], (int )bytes[1]);
    } else {

    }
#line 2241
    return (0);
  } else {

  }
#line 2243
  psb_intel_sdvo->base.crtc_mask = 3;
#line 2245
  return (1);
}
}
#line 2248 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_tv_create_property(struct psb_intel_sdvo *psb_intel_sdvo ,
                                              struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ,
                                              int type ) 
{ 
  struct drm_device *dev ;
  struct psb_intel_sdvo_tv_format format ;
  uint32_t format_map ;
  uint32_t i ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  unsigned long _min1 ;
  unsigned long _min2 ;
  int tmp___3 ;

  {
#line 2252
  dev = psb_intel_sdvo->base.base.dev;
#line 2256
  tmp = psb_intel_sdvo_set_target_output(psb_intel_sdvo, (int )((u16 )type));
#line 2256
  if (tmp) {
#line 2256
    tmp___0 = 0;
  } else {
#line 2256
    tmp___0 = 1;
  }
#line 2256
  if (tmp___0) {
#line 2257
    return (0);
  } else {

  }
#line 2260
  tmp___1 = psb_intel_sdvo_get_value(psb_intel_sdvo, 39, (void *)(& format), 6);
#line 2260
  if (tmp___1) {
#line 2260
    tmp___2 = 0;
  } else {
#line 2260
    tmp___2 = 1;
  }
#line 2260
  if (tmp___2) {
#line 2263
    return (0);
  } else {

  }
#line 2265
  _min1 = 4UL;
#line 2265
  _min2 = 6UL;
#line 2265
  memcpy((void *)(& format_map), (void const   *)(& format), _min1 < _min2 ? _min1 : _min2);
#line 2267
  if (format_map == 0U) {
#line 2268
    return (0);
  } else {

  }
#line 2270
  psb_intel_sdvo_connector->format_supported_num = 0;
#line 2271
  i = 0U;
#line 2271
  goto ldv_42915;
  ldv_42914: ;
#line 2272
  if (((uint32_t )(1 << (int )i) & format_map) != 0U) {
#line 2273
    tmp___3 = psb_intel_sdvo_connector->format_supported_num;
#line 2273
    psb_intel_sdvo_connector->format_supported_num = psb_intel_sdvo_connector->format_supported_num + 1;
#line 2273
    psb_intel_sdvo_connector->tv_format_supported[tmp___3] = (u8 )i;
  } else {

  }
#line 2271
  i = i + 1U;
  ldv_42915: ;
#line 2271
  if (i <= 18U) {
#line 2273
    goto ldv_42914;
  } else {

  }
#line 2276
  psb_intel_sdvo_connector->tv_format = drm_property_create(dev, 8, "mode", psb_intel_sdvo_connector->format_supported_num);
#line 2279
  if ((unsigned long )psb_intel_sdvo_connector->tv_format == (unsigned long )((struct drm_property *)0)) {
#line 2280
    return (0);
  } else {

  }
#line 2282
  i = 0U;
#line 2282
  goto ldv_42918;
  ldv_42917: 
#line 2283
  drm_property_add_enum(psb_intel_sdvo_connector->tv_format, (int )i, (uint64_t )i,
                        tv_format_names[(int )psb_intel_sdvo_connector->tv_format_supported[i]]);
#line 2282
  i = i + 1U;
  ldv_42918: ;
#line 2282
  if ((uint32_t )psb_intel_sdvo_connector->format_supported_num > i) {
#line 2284
    goto ldv_42917;
  } else {

  }
#line 2287
  psb_intel_sdvo->tv_format_index = (int )psb_intel_sdvo_connector->tv_format_supported[0];
#line 2288
  drm_object_attach_property(& psb_intel_sdvo_connector->base.base.base, psb_intel_sdvo_connector->tv_format,
                             0ULL);
#line 2290
  return (1);
}
}
#line 2313 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_create_enhance_property_tv(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                      struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ,
                                                      struct psb_intel_sdvo_enhancements_reply enhancements ) 
{ 
  struct drm_device *dev ;
  struct drm_connector *connector ;
  uint16_t response ;
  uint16_t data_value[2U] ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;
  bool tmp___14 ;
  int tmp___15 ;
  bool tmp___16 ;
  int tmp___17 ;
  long tmp___18 ;
  bool tmp___19 ;
  int tmp___20 ;
  bool tmp___21 ;
  int tmp___22 ;
  long tmp___23 ;
  bool tmp___24 ;
  int tmp___25 ;
  bool tmp___26 ;
  int tmp___27 ;
  long tmp___28 ;
  bool tmp___29 ;
  int tmp___30 ;
  bool tmp___31 ;
  int tmp___32 ;
  long tmp___33 ;
  bool tmp___34 ;
  int tmp___35 ;
  bool tmp___36 ;
  int tmp___37 ;
  long tmp___38 ;
  bool tmp___39 ;
  int tmp___40 ;
  bool tmp___41 ;
  int tmp___42 ;
  long tmp___43 ;
  bool tmp___44 ;
  int tmp___45 ;
  bool tmp___46 ;
  int tmp___47 ;
  long tmp___48 ;
  bool tmp___49 ;
  int tmp___50 ;
  bool tmp___51 ;
  int tmp___52 ;
  long tmp___53 ;
  bool tmp___54 ;
  int tmp___55 ;
  bool tmp___56 ;
  int tmp___57 ;
  long tmp___58 ;
  bool tmp___59 ;
  int tmp___60 ;
  bool tmp___61 ;
  int tmp___62 ;
  long tmp___63 ;
  bool tmp___64 ;
  int tmp___65 ;
  bool tmp___66 ;
  int tmp___67 ;
  long tmp___68 ;
  bool tmp___69 ;
  int tmp___70 ;
  long tmp___71 ;

  {
#line 2317
  dev = psb_intel_sdvo->base.base.dev;
#line 2318
  connector = & psb_intel_sdvo_connector->base.base;
#line 2322
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
#line 2323
    tmp = psb_intel_sdvo_get_value(psb_intel_sdvo, 97, (void *)(& data_value), 4);
#line 2323
    if (tmp) {
#line 2323
      tmp___0 = 0;
    } else {
#line 2323
      tmp___0 = 1;
    }
#line 2323
    if (tmp___0) {
#line 2326
      return (0);
    } else {

    }
#line 2328
    tmp___1 = psb_intel_sdvo_get_value(psb_intel_sdvo, 98, (void *)(& response), 2);
#line 2328
    if (tmp___1) {
#line 2328
      tmp___2 = 0;
    } else {
#line 2328
      tmp___2 = 1;
    }
#line 2328
    if (tmp___2) {
#line 2331
      return (0);
    } else {

    }
#line 2333
    psb_intel_sdvo_connector->max_hscan = (u32 )data_value[0];
#line 2334
    psb_intel_sdvo_connector->left_margin = (u32 )((int )data_value[0] - (int )response);
#line 2335
    psb_intel_sdvo_connector->right_margin = psb_intel_sdvo_connector->left_margin;
#line 2336
    psb_intel_sdvo_connector->left = drm_property_create_range(dev, 0, "left_margin",
                                                               0ULL, (uint64_t )data_value[0]);
#line 2338
    if ((unsigned long )psb_intel_sdvo_connector->left == (unsigned long )((struct drm_property *)0)) {
#line 2339
      return (0);
    } else {

    }
#line 2341
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->left,
                               (uint64_t )psb_intel_sdvo_connector->left_margin);
#line 2345
    psb_intel_sdvo_connector->right = drm_property_create_range(dev, 0, "right_margin",
                                                                0ULL, (uint64_t )data_value[0]);
#line 2347
    if ((unsigned long )psb_intel_sdvo_connector->right == (unsigned long )((struct drm_property *)0)) {
#line 2348
      return (0);
    } else {

    }
#line 2350
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->right,
                               (uint64_t )psb_intel_sdvo_connector->right_margin);
#line 2353
    tmp___3 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2353
    if (tmp___3 != 0L) {
#line 2353
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "h_overscan: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2358
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
#line 2359
    tmp___4 = psb_intel_sdvo_get_value(psb_intel_sdvo, 100, (void *)(& data_value),
                                       4);
#line 2359
    if (tmp___4) {
#line 2359
      tmp___5 = 0;
    } else {
#line 2359
      tmp___5 = 1;
    }
#line 2359
    if (tmp___5) {
#line 2362
      return (0);
    } else {

    }
#line 2364
    tmp___6 = psb_intel_sdvo_get_value(psb_intel_sdvo, 101, (void *)(& response),
                                       2);
#line 2364
    if (tmp___6) {
#line 2364
      tmp___7 = 0;
    } else {
#line 2364
      tmp___7 = 1;
    }
#line 2364
    if (tmp___7) {
#line 2367
      return (0);
    } else {

    }
#line 2369
    psb_intel_sdvo_connector->max_vscan = (u32 )data_value[0];
#line 2370
    psb_intel_sdvo_connector->top_margin = (u32 )((int )data_value[0] - (int )response);
#line 2371
    psb_intel_sdvo_connector->bottom_margin = psb_intel_sdvo_connector->top_margin;
#line 2372
    psb_intel_sdvo_connector->top = drm_property_create_range(dev, 0, "top_margin",
                                                              0ULL, (uint64_t )data_value[0]);
#line 2374
    if ((unsigned long )psb_intel_sdvo_connector->top == (unsigned long )((struct drm_property *)0)) {
#line 2375
      return (0);
    } else {

    }
#line 2377
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->top, (uint64_t )psb_intel_sdvo_connector->top_margin);
#line 2381
    psb_intel_sdvo_connector->bottom = drm_property_create_range(dev, 0, "bottom_margin",
                                                                 0ULL, (uint64_t )data_value[0]);
#line 2383
    if ((unsigned long )psb_intel_sdvo_connector->bottom == (unsigned long )((struct drm_property *)0)) {
#line 2384
      return (0);
    } else {

    }
#line 2386
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->bottom,
                               (uint64_t )psb_intel_sdvo_connector->bottom_margin);
#line 2389
    tmp___8 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2389
    if (tmp___8 != 0L) {
#line 2389
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "v_overscan: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2394
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
#line 2394
    tmp___9 = psb_intel_sdvo_get_value(psb_intel_sdvo, 103, (void *)(& data_value),
                                       4);
#line 2394
    if (tmp___9) {
#line 2394
      tmp___10 = 0;
    } else {
#line 2394
      tmp___10 = 1;
    }
#line 2394
    if (tmp___10) {
#line 2394
      return (0);
    } else {
#line 2394
      tmp___11 = psb_intel_sdvo_get_value(psb_intel_sdvo, 104, (void *)(& response),
                                          2);
#line 2394
      if (tmp___11) {
#line 2394
        tmp___12 = 0;
      } else {
#line 2394
        tmp___12 = 1;
      }
#line 2394
      if (tmp___12) {
#line 2394
        return (0);
      } else {

      }
    }
#line 2394
    psb_intel_sdvo_connector->max_hpos = (u32 )data_value[0];
#line 2394
    psb_intel_sdvo_connector->cur_hpos = (u32 )response;
#line 2394
    psb_intel_sdvo_connector->hpos = drm_property_create_range(dev, 0, "hpos", 0ULL,
                                                               (uint64_t )data_value[0]);
#line 2394
    if ((unsigned long )psb_intel_sdvo_connector->hpos == (unsigned long )((struct drm_property *)0)) {
#line 2394
      return (0);
    } else {

    }
#line 2394
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->hpos,
                               (uint64_t )psb_intel_sdvo_connector->cur_hpos);
#line 2394
    tmp___13 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2394
    if (tmp___13 != 0L) {
#line 2394
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "hpos: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2395
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
#line 2395
    tmp___14 = psb_intel_sdvo_get_value(psb_intel_sdvo, 106, (void *)(& data_value),
                                        4);
#line 2395
    if (tmp___14) {
#line 2395
      tmp___15 = 0;
    } else {
#line 2395
      tmp___15 = 1;
    }
#line 2395
    if (tmp___15) {
#line 2395
      return (0);
    } else {
#line 2395
      tmp___16 = psb_intel_sdvo_get_value(psb_intel_sdvo, 107, (void *)(& response),
                                          2);
#line 2395
      if (tmp___16) {
#line 2395
        tmp___17 = 0;
      } else {
#line 2395
        tmp___17 = 1;
      }
#line 2395
      if (tmp___17) {
#line 2395
        return (0);
      } else {

      }
    }
#line 2395
    psb_intel_sdvo_connector->max_vpos = (u32 )data_value[0];
#line 2395
    psb_intel_sdvo_connector->cur_vpos = (u32 )response;
#line 2395
    psb_intel_sdvo_connector->vpos = drm_property_create_range(dev, 0, "vpos", 0ULL,
                                                               (uint64_t )data_value[0]);
#line 2395
    if ((unsigned long )psb_intel_sdvo_connector->vpos == (unsigned long )((struct drm_property *)0)) {
#line 2395
      return (0);
    } else {

    }
#line 2395
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->vpos,
                               (uint64_t )psb_intel_sdvo_connector->cur_vpos);
#line 2395
    tmp___18 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2395
    if (tmp___18 != 0L) {
#line 2395
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "vpos: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2396
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
#line 2396
    tmp___19 = psb_intel_sdvo_get_value(psb_intel_sdvo, 85, (void *)(& data_value),
                                        4);
#line 2396
    if (tmp___19) {
#line 2396
      tmp___20 = 0;
    } else {
#line 2396
      tmp___20 = 1;
    }
#line 2396
    if (tmp___20) {
#line 2396
      return (0);
    } else {
#line 2396
      tmp___21 = psb_intel_sdvo_get_value(psb_intel_sdvo, 86, (void *)(& response),
                                          2);
#line 2396
      if (tmp___21) {
#line 2396
        tmp___22 = 0;
      } else {
#line 2396
        tmp___22 = 1;
      }
#line 2396
      if (tmp___22) {
#line 2396
        return (0);
      } else {

      }
    }
#line 2396
    psb_intel_sdvo_connector->max_saturation = (u32 )data_value[0];
#line 2396
    psb_intel_sdvo_connector->cur_saturation = (u32 )response;
#line 2396
    psb_intel_sdvo_connector->saturation = drm_property_create_range(dev, 0, "saturation",
                                                                     0ULL, (uint64_t )data_value[0]);
#line 2396
    if ((unsigned long )psb_intel_sdvo_connector->saturation == (unsigned long )((struct drm_property *)0)) {
#line 2396
      return (0);
    } else {

    }
#line 2396
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->saturation,
                               (uint64_t )psb_intel_sdvo_connector->cur_saturation);
#line 2396
    tmp___23 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2396
    if (tmp___23 != 0L) {
#line 2396
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "saturation: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2397
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
#line 2397
    tmp___24 = psb_intel_sdvo_get_value(psb_intel_sdvo, 94, (void *)(& data_value),
                                        4);
#line 2397
    if (tmp___24) {
#line 2397
      tmp___25 = 0;
    } else {
#line 2397
      tmp___25 = 1;
    }
#line 2397
    if (tmp___25) {
#line 2397
      return (0);
    } else {
#line 2397
      tmp___26 = psb_intel_sdvo_get_value(psb_intel_sdvo, 95, (void *)(& response),
                                          2);
#line 2397
      if (tmp___26) {
#line 2397
        tmp___27 = 0;
      } else {
#line 2397
        tmp___27 = 1;
      }
#line 2397
      if (tmp___27) {
#line 2397
        return (0);
      } else {

      }
    }
#line 2397
    psb_intel_sdvo_connector->max_contrast = (u32 )data_value[0];
#line 2397
    psb_intel_sdvo_connector->cur_contrast = (u32 )response;
#line 2397
    psb_intel_sdvo_connector->contrast = drm_property_create_range(dev, 0, "contrast",
                                                                   0ULL, (uint64_t )data_value[0]);
#line 2397
    if ((unsigned long )psb_intel_sdvo_connector->contrast == (unsigned long )((struct drm_property *)0)) {
#line 2397
      return (0);
    } else {

    }
#line 2397
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->contrast,
                               (uint64_t )psb_intel_sdvo_connector->cur_contrast);
#line 2397
    tmp___28 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2397
    if (tmp___28 != 0L) {
#line 2397
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "contrast: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2398
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
#line 2398
    tmp___29 = psb_intel_sdvo_get_value(psb_intel_sdvo, 88, (void *)(& data_value),
                                        4);
#line 2398
    if (tmp___29) {
#line 2398
      tmp___30 = 0;
    } else {
#line 2398
      tmp___30 = 1;
    }
#line 2398
    if (tmp___30) {
#line 2398
      return (0);
    } else {
#line 2398
      tmp___31 = psb_intel_sdvo_get_value(psb_intel_sdvo, 89, (void *)(& response),
                                          2);
#line 2398
      if (tmp___31) {
#line 2398
        tmp___32 = 0;
      } else {
#line 2398
        tmp___32 = 1;
      }
#line 2398
      if (tmp___32) {
#line 2398
        return (0);
      } else {

      }
    }
#line 2398
    psb_intel_sdvo_connector->max_hue = (u32 )data_value[0];
#line 2398
    psb_intel_sdvo_connector->cur_hue = (u32 )response;
#line 2398
    psb_intel_sdvo_connector->hue = drm_property_create_range(dev, 0, "hue", 0ULL,
                                                              (uint64_t )data_value[0]);
#line 2398
    if ((unsigned long )psb_intel_sdvo_connector->hue == (unsigned long )((struct drm_property *)0)) {
#line 2398
      return (0);
    } else {

    }
#line 2398
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->hue, (uint64_t )psb_intel_sdvo_connector->cur_hue);
#line 2398
    tmp___33 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2398
    if (tmp___33 != 0L) {
#line 2398
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "hue: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2399
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
#line 2399
    tmp___34 = psb_intel_sdvo_get_value(psb_intel_sdvo, 109, (void *)(& data_value),
                                        4);
#line 2399
    if (tmp___34) {
#line 2399
      tmp___35 = 0;
    } else {
#line 2399
      tmp___35 = 1;
    }
#line 2399
    if (tmp___35) {
#line 2399
      return (0);
    } else {
#line 2399
      tmp___36 = psb_intel_sdvo_get_value(psb_intel_sdvo, 110, (void *)(& response),
                                          2);
#line 2399
      if (tmp___36) {
#line 2399
        tmp___37 = 0;
      } else {
#line 2399
        tmp___37 = 1;
      }
#line 2399
      if (tmp___37) {
#line 2399
        return (0);
      } else {

      }
    }
#line 2399
    psb_intel_sdvo_connector->max_sharpness = (u32 )data_value[0];
#line 2399
    psb_intel_sdvo_connector->cur_sharpness = (u32 )response;
#line 2399
    psb_intel_sdvo_connector->sharpness = drm_property_create_range(dev, 0, "sharpness",
                                                                    0ULL, (uint64_t )data_value[0]);
#line 2399
    if ((unsigned long )psb_intel_sdvo_connector->sharpness == (unsigned long )((struct drm_property *)0)) {
#line 2399
      return (0);
    } else {

    }
#line 2399
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->sharpness,
                               (uint64_t )psb_intel_sdvo_connector->cur_sharpness);
#line 2399
    tmp___38 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2399
    if (tmp___38 != 0L) {
#line 2399
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "sharpness: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2400
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
#line 2400
    tmp___39 = psb_intel_sdvo_get_value(psb_intel_sdvo, 91, (void *)(& data_value),
                                        4);
#line 2400
    if (tmp___39) {
#line 2400
      tmp___40 = 0;
    } else {
#line 2400
      tmp___40 = 1;
    }
#line 2400
    if (tmp___40) {
#line 2400
      return (0);
    } else {
#line 2400
      tmp___41 = psb_intel_sdvo_get_value(psb_intel_sdvo, 92, (void *)(& response),
                                          2);
#line 2400
      if (tmp___41) {
#line 2400
        tmp___42 = 0;
      } else {
#line 2400
        tmp___42 = 1;
      }
#line 2400
      if (tmp___42) {
#line 2400
        return (0);
      } else {

      }
    }
#line 2400
    psb_intel_sdvo_connector->max_brightness = (u32 )data_value[0];
#line 2400
    psb_intel_sdvo_connector->cur_brightness = (u32 )response;
#line 2400
    psb_intel_sdvo_connector->brightness = drm_property_create_range(dev, 0, "brightness",
                                                                     0ULL, (uint64_t )data_value[0]);
#line 2400
    if ((unsigned long )psb_intel_sdvo_connector->brightness == (unsigned long )((struct drm_property *)0)) {
#line 2400
      return (0);
    } else {

    }
#line 2400
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->brightness,
                               (uint64_t )psb_intel_sdvo_connector->cur_brightness);
#line 2400
    tmp___43 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2400
    if (tmp___43 != 0L) {
#line 2400
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "brightness: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2401
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
#line 2401
    tmp___44 = psb_intel_sdvo_get_value(psb_intel_sdvo, 77, (void *)(& data_value),
                                        4);
#line 2401
    if (tmp___44) {
#line 2401
      tmp___45 = 0;
    } else {
#line 2401
      tmp___45 = 1;
    }
#line 2401
    if (tmp___45) {
#line 2401
      return (0);
    } else {
#line 2401
      tmp___46 = psb_intel_sdvo_get_value(psb_intel_sdvo, 78, (void *)(& response),
                                          2);
#line 2401
      if (tmp___46) {
#line 2401
        tmp___47 = 0;
      } else {
#line 2401
        tmp___47 = 1;
      }
#line 2401
      if (tmp___47) {
#line 2401
        return (0);
      } else {

      }
    }
#line 2401
    psb_intel_sdvo_connector->max_flicker_filter = (u32 )data_value[0];
#line 2401
    psb_intel_sdvo_connector->cur_flicker_filter = (u32 )response;
#line 2401
    psb_intel_sdvo_connector->flicker_filter = drm_property_create_range(dev, 0, "flicker_filter",
                                                                         0ULL, (uint64_t )data_value[0]);
#line 2401
    if ((unsigned long )psb_intel_sdvo_connector->flicker_filter == (unsigned long )((struct drm_property *)0)) {
#line 2401
      return (0);
    } else {

    }
#line 2401
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->flicker_filter,
                               (uint64_t )psb_intel_sdvo_connector->cur_flicker_filter);
#line 2401
    tmp___48 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2401
    if (tmp___48 != 0L) {
#line 2401
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "flicker_filter: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2402
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
#line 2402
    tmp___49 = psb_intel_sdvo_get_value(psb_intel_sdvo, 123, (void *)(& data_value),
                                        4);
#line 2402
    if (tmp___49) {
#line 2402
      tmp___50 = 0;
    } else {
#line 2402
      tmp___50 = 1;
    }
#line 2402
    if (tmp___50) {
#line 2402
      return (0);
    } else {
#line 2402
      tmp___51 = psb_intel_sdvo_get_value(psb_intel_sdvo, 80, (void *)(& response),
                                          2);
#line 2402
      if (tmp___51) {
#line 2402
        tmp___52 = 0;
      } else {
#line 2402
        tmp___52 = 1;
      }
#line 2402
      if (tmp___52) {
#line 2402
        return (0);
      } else {

      }
    }
#line 2402
    psb_intel_sdvo_connector->max_flicker_filter_adaptive = (u32 )data_value[0];
#line 2402
    psb_intel_sdvo_connector->cur_flicker_filter_adaptive = (u32 )response;
#line 2402
    psb_intel_sdvo_connector->flicker_filter_adaptive = drm_property_create_range(dev,
                                                                                  0,
                                                                                  "flicker_filter_adaptive",
                                                                                  0ULL,
                                                                                  (uint64_t )data_value[0]);
#line 2402
    if ((unsigned long )psb_intel_sdvo_connector->flicker_filter_adaptive == (unsigned long )((struct drm_property *)0)) {
#line 2402
      return (0);
    } else {

    }
#line 2402
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->flicker_filter_adaptive,
                               (uint64_t )psb_intel_sdvo_connector->cur_flicker_filter_adaptive);
#line 2402
    tmp___53 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2402
    if (tmp___53 != 0L) {
#line 2402
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "flicker_filter_adaptive: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2403
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
#line 2403
    tmp___54 = psb_intel_sdvo_get_value(psb_intel_sdvo, 82, (void *)(& data_value),
                                        4);
#line 2403
    if (tmp___54) {
#line 2403
      tmp___55 = 0;
    } else {
#line 2403
      tmp___55 = 1;
    }
#line 2403
    if (tmp___55) {
#line 2403
      return (0);
    } else {
#line 2403
      tmp___56 = psb_intel_sdvo_get_value(psb_intel_sdvo, 83, (void *)(& response),
                                          2);
#line 2403
      if (tmp___56) {
#line 2403
        tmp___57 = 0;
      } else {
#line 2403
        tmp___57 = 1;
      }
#line 2403
      if (tmp___57) {
#line 2403
        return (0);
      } else {

      }
    }
#line 2403
    psb_intel_sdvo_connector->max_flicker_filter_2d = (u32 )data_value[0];
#line 2403
    psb_intel_sdvo_connector->cur_flicker_filter_2d = (u32 )response;
#line 2403
    psb_intel_sdvo_connector->flicker_filter_2d = drm_property_create_range(dev, 0,
                                                                            "flicker_filter_2d",
                                                                            0ULL,
                                                                            (uint64_t )data_value[0]);
#line 2403
    if ((unsigned long )psb_intel_sdvo_connector->flicker_filter_2d == (unsigned long )((struct drm_property *)0)) {
#line 2403
      return (0);
    } else {

    }
#line 2403
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->flicker_filter_2d,
                               (uint64_t )psb_intel_sdvo_connector->cur_flicker_filter_2d);
#line 2403
    tmp___58 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2403
    if (tmp___58 != 0L) {
#line 2403
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "flicker_filter_2d: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2404
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
#line 2404
    tmp___59 = psb_intel_sdvo_get_value(psb_intel_sdvo, 116, (void *)(& data_value),
                                        4);
#line 2404
    if (tmp___59) {
#line 2404
      tmp___60 = 0;
    } else {
#line 2404
      tmp___60 = 1;
    }
#line 2404
    if (tmp___60) {
#line 2404
      return (0);
    } else {
#line 2404
      tmp___61 = psb_intel_sdvo_get_value(psb_intel_sdvo, 117, (void *)(& response),
                                          2);
#line 2404
      if (tmp___61) {
#line 2404
        tmp___62 = 0;
      } else {
#line 2404
        tmp___62 = 1;
      }
#line 2404
      if (tmp___62) {
#line 2404
        return (0);
      } else {

      }
    }
#line 2404
    psb_intel_sdvo_connector->max_tv_chroma_filter = (u32 )data_value[0];
#line 2404
    psb_intel_sdvo_connector->cur_tv_chroma_filter = (u32 )response;
#line 2404
    psb_intel_sdvo_connector->tv_chroma_filter = drm_property_create_range(dev, 0,
                                                                           "tv_chroma_filter",
                                                                           0ULL, (uint64_t )data_value[0]);
#line 2404
    if ((unsigned long )psb_intel_sdvo_connector->tv_chroma_filter == (unsigned long )((struct drm_property *)0)) {
#line 2404
      return (0);
    } else {

    }
#line 2404
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->tv_chroma_filter,
                               (uint64_t )psb_intel_sdvo_connector->cur_tv_chroma_filter);
#line 2404
    tmp___63 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2404
    if (tmp___63 != 0L) {
#line 2404
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "tv_chroma_filter: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2405
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
#line 2405
    tmp___64 = psb_intel_sdvo_get_value(psb_intel_sdvo, 119, (void *)(& data_value),
                                        4);
#line 2405
    if (tmp___64) {
#line 2405
      tmp___65 = 0;
    } else {
#line 2405
      tmp___65 = 1;
    }
#line 2405
    if (tmp___65) {
#line 2405
      return (0);
    } else {
#line 2405
      tmp___66 = psb_intel_sdvo_get_value(psb_intel_sdvo, 120, (void *)(& response),
                                          2);
#line 2405
      if (tmp___66) {
#line 2405
        tmp___67 = 0;
      } else {
#line 2405
        tmp___67 = 1;
      }
#line 2405
      if (tmp___67) {
#line 2405
        return (0);
      } else {

      }
    }
#line 2405
    psb_intel_sdvo_connector->max_tv_luma_filter = (u32 )data_value[0];
#line 2405
    psb_intel_sdvo_connector->cur_tv_luma_filter = (u32 )response;
#line 2405
    psb_intel_sdvo_connector->tv_luma_filter = drm_property_create_range(dev, 0, "tv_luma_filter",
                                                                         0ULL, (uint64_t )data_value[0]);
#line 2405
    if ((unsigned long )psb_intel_sdvo_connector->tv_luma_filter == (unsigned long )((struct drm_property *)0)) {
#line 2405
      return (0);
    } else {

    }
#line 2405
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->tv_luma_filter,
                               (uint64_t )psb_intel_sdvo_connector->cur_tv_luma_filter);
#line 2405
    tmp___68 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2405
    if (tmp___68 != 0L) {
#line 2405
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "tv_luma_filter: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2407
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
#line 2408
    tmp___69 = psb_intel_sdvo_get_value(psb_intel_sdvo, 112, (void *)(& response),
                                        2);
#line 2408
    if (tmp___69) {
#line 2408
      tmp___70 = 0;
    } else {
#line 2408
      tmp___70 = 1;
    }
#line 2408
    if (tmp___70) {
#line 2409
      return (0);
    } else {

    }
#line 2411
    psb_intel_sdvo_connector->max_dot_crawl = 1U;
#line 2412
    psb_intel_sdvo_connector->cur_dot_crawl = (u32 )response & 1U;
#line 2413
    psb_intel_sdvo_connector->dot_crawl = drm_property_create_range(dev, 0, "dot_crawl",
                                                                    0ULL, 1ULL);
#line 2415
    if ((unsigned long )psb_intel_sdvo_connector->dot_crawl == (unsigned long )((struct drm_property *)0)) {
#line 2416
      return (0);
    } else {

    }
#line 2418
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->dot_crawl,
                               (uint64_t )psb_intel_sdvo_connector->cur_dot_crawl);
#line 2421
    tmp___71 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2421
    if (tmp___71 != 0L) {
#line 2421
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "dot crawl: current %d\n",
                          (int )response);
    } else {

    }
  } else {

  }
#line 2424
  return (1);
}
}
#line 2428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_create_enhance_property_lvds(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                        struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ,
                                                        struct psb_intel_sdvo_enhancements_reply enhancements ) 
{ 
  struct drm_device *dev ;
  struct drm_connector *connector ;
  uint16_t response ;
  uint16_t data_value[2U] ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 2432
  dev = psb_intel_sdvo->base.base.dev;
#line 2433
  connector = & psb_intel_sdvo_connector->base.base;
#line 2436
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
#line 2436
    tmp = psb_intel_sdvo_get_value(psb_intel_sdvo, 91, (void *)(& data_value), 4);
#line 2436
    if (tmp) {
#line 2436
      tmp___0 = 0;
    } else {
#line 2436
      tmp___0 = 1;
    }
#line 2436
    if (tmp___0) {
#line 2436
      return (0);
    } else {
#line 2436
      tmp___1 = psb_intel_sdvo_get_value(psb_intel_sdvo, 92, (void *)(& response),
                                         2);
#line 2436
      if (tmp___1) {
#line 2436
        tmp___2 = 0;
      } else {
#line 2436
        tmp___2 = 1;
      }
#line 2436
      if (tmp___2) {
#line 2436
        return (0);
      } else {

      }
    }
#line 2436
    psb_intel_sdvo_connector->max_brightness = (u32 )data_value[0];
#line 2436
    psb_intel_sdvo_connector->cur_brightness = (u32 )response;
#line 2436
    psb_intel_sdvo_connector->brightness = drm_property_create_range(dev, 0, "brightness",
                                                                     0ULL, (uint64_t )data_value[0]);
#line 2436
    if ((unsigned long )psb_intel_sdvo_connector->brightness == (unsigned long )((struct drm_property *)0)) {
#line 2436
      return (0);
    } else {

    }
#line 2436
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->brightness,
                               (uint64_t )psb_intel_sdvo_connector->cur_brightness);
#line 2436
    tmp___3 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2436
    if (tmp___3 != 0L) {
#line 2436
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_lvds", "brightness: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2438
  return (1);
}
}
#line 2442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_create_enhance_property(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                   struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ) 
{ 
  union __anonunion_enhancements_280 enhancements ;
  long tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 2452
  enhancements.response = 0U;
#line 2453
  psb_intel_sdvo_get_value(psb_intel_sdvo, 132, (void *)(& enhancements), 2);
#line 2456
  if ((unsigned int )enhancements.response == 0U) {
#line 2457
    tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2457
    if (tmp != 0L) {
#line 2457
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property", "No enhancement is supported\n");
    } else {

    }
#line 2458
    return (1);
  } else {

  }
#line 2461
  if (((int )psb_intel_sdvo_connector->output_flag & 12) != 0) {
#line 2462
    tmp___0 = psb_intel_sdvo_create_enhance_property_tv(psb_intel_sdvo, psb_intel_sdvo_connector,
                                                        enhancements.reply);
#line 2462
    return (tmp___0);
  } else
#line 2463
  if (((int )psb_intel_sdvo_connector->output_flag & 16448) != 0) {
#line 2464
    tmp___1 = psb_intel_sdvo_create_enhance_property_lvds(psb_intel_sdvo, psb_intel_sdvo_connector,
                                                          enhancements.reply);
#line 2464
    return (tmp___1);
  } else {
#line 2466
    return (1);
  }
}
}
#line 2469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static int psb_intel_sdvo_ddc_proxy_xfer(struct i2c_adapter *adapter , struct i2c_msg *msgs ,
                                         int num ) 
{ 
  struct psb_intel_sdvo *sdvo ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2473
  sdvo = (struct psb_intel_sdvo *)adapter->algo_data;
#line 2475
  tmp = psb_intel_sdvo_set_control_bus_switch(sdvo, (int )sdvo->ddc_bus);
#line 2475
  if (tmp) {
#line 2475
    tmp___0 = 0;
  } else {
#line 2475
    tmp___0 = 1;
  }
#line 2475
  if (tmp___0) {
#line 2476
    return (-5);
  } else {

  }
#line 2478
  tmp___1 = (*(((sdvo->i2c)->algo)->master_xfer))(sdvo->i2c, msgs, num);
#line 2478
  return (tmp___1);
}
}
#line 2481 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static u32 psb_intel_sdvo_ddc_proxy_func(struct i2c_adapter *adapter ) 
{ 
  struct psb_intel_sdvo *sdvo ;
  u32 tmp ;

  {
#line 2483
  sdvo = (struct psb_intel_sdvo *)adapter->algo_data;
#line 2484
  tmp = (*(((sdvo->i2c)->algo)->functionality))(sdvo->i2c);
#line 2484
  return (tmp);
}
}
#line 2487 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static struct i2c_algorithm  const  psb_intel_sdvo_ddc_proxy  =    {& psb_intel_sdvo_ddc_proxy_xfer, 0, & psb_intel_sdvo_ddc_proxy_func, 0, 0};
#line 2493 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
static bool psb_intel_sdvo_init_ddc_proxy(struct psb_intel_sdvo *sdvo , struct drm_device *dev ) 
{ 
  int tmp ;

  {
#line 2496
  sdvo->ddc.owner = & __this_module;
#line 2497
  sdvo->ddc.class = 8U;
#line 2498
  snprintf((char *)(& sdvo->ddc.name), 20UL, "SDVO DDC proxy");
#line 2499
  sdvo->ddc.dev.parent = & (dev->pdev)->dev;
#line 2500
  sdvo->ddc.algo_data = (void *)sdvo;
#line 2501
  sdvo->ddc.algo = & psb_intel_sdvo_ddc_proxy;
#line 2503
  tmp = i2c_add_adapter(& sdvo->ddc);
#line 2503
  return (tmp == 0);
}
}
#line 2506 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.c"
bool psb_intel_sdvo_init(struct drm_device *dev , int sdvo_reg ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct gma_encoder *gma_encoder ;
  struct psb_intel_sdvo *psb_intel_sdvo ;
  int i ;
  void *tmp ;
  u8 tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  u8 byte ;
  long tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  bool tmp___13 ;
  int tmp___14 ;
  long tmp___15 ;

  {
#line 2508
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 2513
  tmp = kzalloc(2184UL, 208U);
#line 2513
  psb_intel_sdvo = (struct psb_intel_sdvo *)tmp;
#line 2514
  if ((unsigned long )psb_intel_sdvo == (unsigned long )((struct psb_intel_sdvo *)0)) {
#line 2515
    return (0);
  } else {

  }
#line 2517
  psb_intel_sdvo->sdvo_reg = sdvo_reg;
#line 2518
  tmp___0 = psb_intel_sdvo_get_slave_addr(dev, sdvo_reg);
#line 2518
  psb_intel_sdvo->slave_addr = (u8 )((int )tmp___0 >> 1);
#line 2519
  psb_intel_sdvo_select_i2c_bus(dev_priv, psb_intel_sdvo, (u32 )sdvo_reg);
#line 2520
  tmp___1 = psb_intel_sdvo_init_ddc_proxy(psb_intel_sdvo, dev);
#line 2520
  if (tmp___1) {
#line 2520
    tmp___2 = 0;
  } else {
#line 2520
    tmp___2 = 1;
  }
#line 2520
  if (tmp___2) {
#line 2521
    kfree((void const   *)psb_intel_sdvo);
#line 2522
    return (0);
  } else {

  }
#line 2526
  gma_encoder = & psb_intel_sdvo->base;
#line 2527
  gma_encoder->type = 3;
#line 2528
  drm_encoder_init(dev, & gma_encoder->base, & psb_intel_sdvo_enc_funcs, 0);
#line 2531
  i = 0;
#line 2531
  goto ldv_42976;
  ldv_42975: 
#line 2534
  tmp___4 = psb_intel_sdvo_read_byte(psb_intel_sdvo, (int )((u8 )i), & byte);
#line 2534
  if (tmp___4) {
#line 2534
    tmp___5 = 0;
  } else {
#line 2534
    tmp___5 = 1;
  }
#line 2534
  if (tmp___5) {
#line 2535
    tmp___3 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2535
    if (tmp___3 != 0L) {
#line 2535
      drm_ut_debug_printk("psb_intel_sdvo_init", "No SDVO device found on SDVO%c\n",
                          sdvo_reg == 397632 ? 66 : 67);
    } else {

    }
#line 2537
    goto err;
  } else {

  }
#line 2531
  i = i + 1;
  ldv_42976: ;
#line 2531
  if (i <= 63) {
#line 2533
    goto ldv_42975;
  } else {

  }

#line 2541
  if (sdvo_reg == 397632) {
#line 2542
    dev_priv->hotplug_supported_mask = dev_priv->hotplug_supported_mask | 64U;
  } else {
#line 2544
    dev_priv->hotplug_supported_mask = dev_priv->hotplug_supported_mask | 128U;
  }
#line 2546
  drm_encoder_helper_add(& gma_encoder->base, & psb_intel_sdvo_helper_funcs);
#line 2549
  tmp___6 = psb_intel_sdvo_get_capabilities(psb_intel_sdvo, & psb_intel_sdvo->caps);
#line 2549
  if (tmp___6) {
#line 2549
    tmp___7 = 0;
  } else {
#line 2549
    tmp___7 = 1;
  }
#line 2549
  if (tmp___7) {
#line 2550
    goto err;
  } else {

  }
#line 2552
  tmp___9 = psb_intel_sdvo_output_setup(psb_intel_sdvo, (int )psb_intel_sdvo->caps.output_flags);
#line 2552
  if (tmp___9) {
#line 2552
    tmp___10 = 0;
  } else {
#line 2552
    tmp___10 = 1;
  }
#line 2552
  if (tmp___10) {
#line 2554
    tmp___8 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2554
    if (tmp___8 != 0L) {
#line 2554
      drm_ut_debug_printk("psb_intel_sdvo_init", "SDVO output failed to setup on SDVO%c\n",
                          sdvo_reg == 397632 ? 66 : 67);
    } else {

    }
#line 2556
    goto err;
  } else {

  }
#line 2559
  psb_intel_sdvo_select_ddc_bus(dev_priv, psb_intel_sdvo, (u32 )sdvo_reg);
#line 2562
  tmp___11 = psb_intel_sdvo_set_target_input(psb_intel_sdvo);
#line 2562
  if (tmp___11) {
#line 2562
    tmp___12 = 0;
  } else {
#line 2562
    tmp___12 = 1;
  }
#line 2562
  if (tmp___12) {
#line 2563
    goto err;
  } else {

  }
#line 2565
  tmp___13 = psb_intel_sdvo_get_input_pixel_clock_range(psb_intel_sdvo, & psb_intel_sdvo->pixel_clock_min,
                                                        & psb_intel_sdvo->pixel_clock_max);
#line 2565
  if (tmp___13) {
#line 2565
    tmp___14 = 0;
  } else {
#line 2565
    tmp___14 = 1;
  }
#line 2565
  if (tmp___14) {
#line 2568
    goto err;
  } else {

  }
#line 2570
  tmp___15 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2570
  if (tmp___15 != 0L) {
#line 2570
    drm_ut_debug_printk("psb_intel_sdvo_init", "%s device VID/DID: %02X:%02X.%02X, clock range %dMHz - %dMHz, input 1: %c, input 2: %c, output 1: %c, output 2: %c\n",
                        psb_intel_sdvo->sdvo_reg == 397632 ? (char *)"SDVOB" : (char *)"SDVOC",
                        (int )psb_intel_sdvo->caps.vendor_id, (int )psb_intel_sdvo->caps.device_id,
                        (int )psb_intel_sdvo->caps.device_rev_id, psb_intel_sdvo->pixel_clock_min / 1000,
                        psb_intel_sdvo->pixel_clock_max / 1000, (int )psb_intel_sdvo->caps.sdvo_inputs_mask & 1 ? 89 : 78,
                        ((int )psb_intel_sdvo->caps.sdvo_inputs_mask & 2) != 0 ? 89 : 78,
                        ((int )psb_intel_sdvo->caps.output_flags & 3) != 0 ? 89 : 78,
                        ((int )psb_intel_sdvo->caps.output_flags & 768) != 0 ? 89 : 78);
  } else {

  }
#line 2586
  return (1);
  err: 
#line 2589
  drm_encoder_cleanup(& gma_encoder->base);
#line 2590
  i2c_del_adapter(& psb_intel_sdvo->ddc);
#line 2591
  kfree((void const   *)psb_intel_sdvo);
#line 2593
  return (0);
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
extern int ldv_probe_37(void) ;
#line 405
extern int ldv_probe_39(void) ;
#line 408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_initialize_i2c_algorithm_36(void) 
{ 
  void *tmp ;

  {
#line 409
  tmp = ldv_init_zalloc(1936UL);
#line 409
  psb_intel_sdvo_ddc_proxy_group0 = (struct i2c_adapter *)tmp;
#line 410
  return;
}
}
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_initialize_drm_connector_funcs_39(void) 
{ 
  void *tmp ;

  {
#line 413
  tmp = ldv_init_zalloc(936UL);
#line 413
  psb_intel_sdvo_connector_funcs_group0 = (struct drm_connector *)tmp;
#line 414
  return;
}
}
#line 416 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_initialize_drm_encoder_helper_funcs_40(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 417
  tmp = ldv_init_zalloc(96UL);
#line 417
  psb_intel_sdvo_helper_funcs_group0 = (struct drm_encoder *)tmp;
#line 418
  tmp___0 = ldv_init_zalloc(208UL);
#line 418
  psb_intel_sdvo_helper_funcs_group1 = (struct drm_display_mode *)tmp___0;
#line 419
  return;
}
}
#line 421 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_initialize_drm_connector_helper_funcs_38(void) 
{ 
  void *tmp ;

  {
#line 422
  tmp = ldv_init_zalloc(936UL);
#line 422
  psb_intel_sdvo_connector_helper_funcs_group0 = (struct drm_connector *)tmp;
#line 423
  return;
}
}
#line 425 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_main_exported_38(void) 
{ 
  struct drm_display_mode *ldvarg188 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 426
  tmp = ldv_init_zalloc(208UL);
#line 426
  ldvarg188 = (struct drm_display_mode *)tmp;
#line 428
  tmp___0 = __VERIFIER_nondet_int();
#line 428
  switch (tmp___0) {
  case 0: ;
#line 431
  if (ldv_state_variable_38 == 1) {
#line 433
    psb_intel_sdvo_get_modes(psb_intel_sdvo_connector_helper_funcs_group0);
#line 435
    ldv_state_variable_38 = 1;
  } else {

  }
#line 438
  goto ldv_42999;
  case 1: ;
#line 441
  if (ldv_state_variable_38 == 1) {
#line 443
    psb_intel_sdvo_mode_valid(psb_intel_sdvo_connector_helper_funcs_group0, ldvarg188);
#line 445
    ldv_state_variable_38 = 1;
  } else {

  }
#line 448
  goto ldv_42999;
  case 2: ;
#line 451
  if (ldv_state_variable_38 == 1) {
#line 453
    gma_best_encoder(psb_intel_sdvo_connector_helper_funcs_group0);
#line 455
    ldv_state_variable_38 = 1;
  } else {

  }
#line 458
  goto ldv_42999;
  default: 
#line 459
  ldv_stop();
  }
  ldv_42999: ;
#line 463
  return;
}
}
#line 465 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_main_exported_39(void) 
{ 
  uint32_t ldvarg148 ;
  int ldvarg152 ;
  uint64_t ldvarg149 ;
  bool ldvarg151 ;
  struct drm_property *ldvarg150 ;
  void *tmp ;
  uint32_t ldvarg147 ;
  int tmp___0 ;

  {
#line 470
  tmp = ldv_init_zalloc(104UL);
#line 470
  ldvarg150 = (struct drm_property *)tmp;
#line 466
  ldv_memset((void *)(& ldvarg148), 0, 4UL);
#line 467
  ldv_memset((void *)(& ldvarg152), 0, 4UL);
#line 468
  ldv_memset((void *)(& ldvarg149), 0, 8UL);
#line 469
  ldv_memset((void *)(& ldvarg151), 0, 1UL);
#line 471
  ldv_memset((void *)(& ldvarg147), 0, 4UL);
#line 473
  tmp___0 = __VERIFIER_nondet_int();
#line 473
  switch (tmp___0) {
  case 0: ;
#line 476
  if (ldv_state_variable_39 == 1) {
#line 478
    drm_helper_connector_dpms(psb_intel_sdvo_connector_funcs_group0, ldvarg152);
#line 480
    ldv_state_variable_39 = 1;
  } else {

  }
#line 483
  if (ldv_state_variable_39 == 2) {
#line 485
    drm_helper_connector_dpms(psb_intel_sdvo_connector_funcs_group0, ldvarg152);
#line 487
    ldv_state_variable_39 = 2;
  } else {

  }
#line 490
  goto ldv_43013;
  case 1: ;
#line 493
  if (ldv_state_variable_39 == 1) {
#line 495
    psb_intel_sdvo_detect(psb_intel_sdvo_connector_funcs_group0, (int )ldvarg151);
#line 497
    ldv_state_variable_39 = 1;
  } else {

  }
#line 500
  if (ldv_state_variable_39 == 2) {
#line 502
    psb_intel_sdvo_detect(psb_intel_sdvo_connector_funcs_group0, (int )ldvarg151);
#line 504
    ldv_state_variable_39 = 2;
  } else {

  }
#line 507
  goto ldv_43013;
  case 2: ;
#line 510
  if (ldv_state_variable_39 == 1) {
#line 512
    psb_intel_sdvo_set_property(psb_intel_sdvo_connector_funcs_group0, ldvarg150,
                                ldvarg149);
#line 514
    ldv_state_variable_39 = 1;
  } else {

  }
#line 517
  if (ldv_state_variable_39 == 2) {
#line 519
    psb_intel_sdvo_set_property(psb_intel_sdvo_connector_funcs_group0, ldvarg150,
                                ldvarg149);
#line 521
    ldv_state_variable_39 = 2;
  } else {

  }
#line 524
  goto ldv_43013;
  case 3: ;
#line 527
  if (ldv_state_variable_39 == 2) {
#line 529
    psb_intel_sdvo_destroy(psb_intel_sdvo_connector_funcs_group0);
#line 531
    ldv_state_variable_39 = 1;
#line 532
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 535
  goto ldv_43013;
  case 4: ;
#line 538
  if (ldv_state_variable_39 == 1) {
#line 540
    psb_intel_sdvo_save(psb_intel_sdvo_connector_funcs_group0);
#line 542
    ldv_state_variable_39 = 1;
  } else {

  }
#line 545
  if (ldv_state_variable_39 == 2) {
#line 547
    psb_intel_sdvo_save(psb_intel_sdvo_connector_funcs_group0);
#line 549
    ldv_state_variable_39 = 2;
  } else {

  }
#line 552
  goto ldv_43013;
  case 5: ;
#line 555
  if (ldv_state_variable_39 == 1) {
#line 557
    psb_intel_sdvo_restore(psb_intel_sdvo_connector_funcs_group0);
#line 559
    ldv_state_variable_39 = 1;
  } else {

  }
#line 562
  if (ldv_state_variable_39 == 2) {
#line 564
    psb_intel_sdvo_restore(psb_intel_sdvo_connector_funcs_group0);
#line 566
    ldv_state_variable_39 = 2;
  } else {

  }
#line 569
  goto ldv_43013;
  case 6: ;
#line 572
  if (ldv_state_variable_39 == 1) {
#line 574
    drm_helper_probe_single_connector_modes(psb_intel_sdvo_connector_funcs_group0,
                                            ldvarg148, ldvarg147);
#line 576
    ldv_state_variable_39 = 1;
  } else {

  }
#line 579
  if (ldv_state_variable_39 == 2) {
#line 581
    drm_helper_probe_single_connector_modes(psb_intel_sdvo_connector_funcs_group0,
                                            ldvarg148, ldvarg147);
#line 583
    ldv_state_variable_39 = 2;
  } else {

  }
#line 586
  goto ldv_43013;
  case 7: ;
#line 589
  if (ldv_state_variable_39 == 1) {
#line 591
    ldv_probe_39();
#line 593
    ldv_state_variable_39 = 2;
#line 594
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 597
  goto ldv_43013;
  default: 
#line 598
  ldv_stop();
  }
  ldv_43013: ;
#line 602
  return;
}
}
#line 604 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_main_exported_40(void) 
{ 
  struct drm_display_mode *ldvarg72 ;
  void *tmp ;
  int ldvarg74 ;
  struct drm_display_mode *ldvarg73 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 605
  tmp = ldv_init_zalloc(208UL);
#line 605
  ldvarg72 = (struct drm_display_mode *)tmp;
#line 607
  tmp___0 = ldv_init_zalloc(208UL);
#line 607
  ldvarg73 = (struct drm_display_mode *)tmp___0;
#line 606
  ldv_memset((void *)(& ldvarg74), 0, 4UL);
#line 609
  tmp___1 = __VERIFIER_nondet_int();
#line 609
  switch (tmp___1) {
  case 0: ;
#line 612
  if (ldv_state_variable_40 == 1) {
#line 614
    psb_intel_sdvo_dpms(psb_intel_sdvo_helper_funcs_group0, ldvarg74);
#line 616
    ldv_state_variable_40 = 1;
  } else {

  }
#line 619
  goto ldv_43029;
  case 1: ;
#line 622
  if (ldv_state_variable_40 == 1) {
#line 624
    psb_intel_sdvo_mode_fixup(psb_intel_sdvo_helper_funcs_group0, (struct drm_display_mode  const  *)ldvarg73,
                              psb_intel_sdvo_helper_funcs_group1);
#line 626
    ldv_state_variable_40 = 1;
  } else {

  }
#line 629
  goto ldv_43029;
  case 2: ;
#line 632
  if (ldv_state_variable_40 == 1) {
#line 634
    gma_encoder_commit(psb_intel_sdvo_helper_funcs_group0);
#line 636
    ldv_state_variable_40 = 1;
  } else {

  }
#line 639
  goto ldv_43029;
  case 3: ;
#line 642
  if (ldv_state_variable_40 == 1) {
#line 644
    psb_intel_sdvo_mode_set(psb_intel_sdvo_helper_funcs_group0, psb_intel_sdvo_helper_funcs_group1,
                            ldvarg72);
#line 646
    ldv_state_variable_40 = 1;
  } else {

  }
#line 649
  goto ldv_43029;
  case 4: ;
#line 652
  if (ldv_state_variable_40 == 1) {
#line 654
    gma_encoder_prepare(psb_intel_sdvo_helper_funcs_group0);
#line 656
    ldv_state_variable_40 = 1;
  } else {

  }
#line 659
  goto ldv_43029;
  default: 
#line 660
  ldv_stop();
  }
  ldv_43029: ;
#line 664
  return;
}
}
#line 666 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_main_exported_36(void) 
{ 
  int ldvarg153 ;
  struct i2c_msg *ldvarg154 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 668
  tmp = ldv_init_zalloc(16UL);
#line 668
  ldvarg154 = (struct i2c_msg *)tmp;
#line 667
  ldv_memset((void *)(& ldvarg153), 0, 4UL);
#line 670
  tmp___0 = __VERIFIER_nondet_int();
#line 670
  switch (tmp___0) {
  case 0: ;
#line 673
  if (ldv_state_variable_36 == 1) {
#line 675
    psb_intel_sdvo_ddc_proxy_xfer(psb_intel_sdvo_ddc_proxy_group0, ldvarg154, ldvarg153);
#line 677
    ldv_state_variable_36 = 1;
  } else {

  }
#line 680
  goto ldv_43041;
  case 1: ;
#line 683
  if (ldv_state_variable_36 == 1) {
#line 685
    psb_intel_sdvo_ddc_proxy_func(psb_intel_sdvo_ddc_proxy_group0);
#line 687
    ldv_state_variable_36 = 1;
  } else {

  }
#line 690
  goto ldv_43041;
  default: 
#line 691
  ldv_stop();
  }
  ldv_43041: ;
#line 695
  return;
}
}
#line 697 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_main_exported_37(void) 
{ 
  struct drm_encoder *ldvarg211 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 698
  tmp = ldv_init_zalloc(96UL);
#line 698
  ldvarg211 = (struct drm_encoder *)tmp;
#line 700
  tmp___0 = __VERIFIER_nondet_int();
#line 700
  switch (tmp___0) {
  case 0: ;
#line 703
  if (ldv_state_variable_37 == 2) {
#line 705
    psb_intel_sdvo_enc_destroy(ldvarg211);
#line 707
    ldv_state_variable_37 = 1;
#line 708
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 711
  goto ldv_43049;
  case 1: ;
#line 714
  if (ldv_state_variable_37 == 1) {
#line 716
    ldv_probe_37();
#line 718
    ldv_state_variable_37 = 2;
#line 719
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 722
  goto ldv_43049;
  default: 
#line 723
  ldv_stop();
  }
  ldv_43049: ;
#line 727
  return;
}
}
#line 752 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
bool ldv_queue_work_on_823(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 756
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 756
  ldv_func_res = tmp;
#line 758
  activate_work_2(ldv_func_arg3, 2);
#line 760
  return (ldv_func_res);
}
}
#line 763 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
bool ldv_queue_delayed_work_on_824(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 767
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 767
  ldv_func_res = tmp;
#line 769
  activate_work_2(& ldv_func_arg3->work, 2);
#line 771
  return (ldv_func_res);
}
}
#line 774 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
bool ldv_queue_work_on_825(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 778
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 778
  ldv_func_res = tmp;
#line 780
  activate_work_2(ldv_func_arg3, 2);
#line 782
  return (ldv_func_res);
}
}
#line 785 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_flush_workqueue_826(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 788
  flush_workqueue(ldv_func_arg1);
#line 790
  call_and_disable_all_2(2);
#line 791
  return;
}
}
#line 793 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
bool ldv_queue_delayed_work_on_827(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 797
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 797
  ldv_func_res = tmp;
#line 799
  activate_work_2(& ldv_func_arg3->work, 2);
#line 801
  return (ldv_func_res);
}
}
#line 804 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_mutex_lock_828(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 807
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 809
  mutex_lock(ldv_func_arg1);
#line 810
  return;
}
}
#line 812 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_mutex_unlock_829(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 815
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 817
  mutex_unlock(ldv_func_arg1);
#line 818
  return;
}
}
#line 820 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_mutex_lock_830(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 823
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 825
  mutex_lock(ldv_func_arg1);
#line 826
  return;
}
}
#line 828 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
int ldv_mutex_trylock_831(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 832
  tmp = mutex_trylock(ldv_func_arg1);
#line 832
  ldv_func_res = tmp;
#line 834
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 834
  return (tmp___0);
#line 836
  return (ldv_func_res);
}
}
#line 839 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_mutex_unlock_832(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 842
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 844
  mutex_unlock(ldv_func_arg1);
#line 845
  return;
}
}
#line 847 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_mutex_unlock_833(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 850
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 852
  mutex_unlock(ldv_func_arg1);
#line 853
  return;
}
}
#line 855 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_mutex_lock_834(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 858
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 860
  mutex_lock(ldv_func_arg1);
#line 861
  return;
}
}
#line 863 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_mutex_lock_835(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 866
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 868
  mutex_lock(ldv_func_arg1);
#line 869
  return;
}
}
#line 871 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_mutex_unlock_836(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 874
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 876
  mutex_unlock(ldv_func_arg1);
#line 877
  return;
}
}
#line 879 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_mutex_unlock_837(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 882
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 884
  mutex_unlock(ldv_func_arg1);
#line 885
  return;
}
}
#line 887 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_mutex_lock_838(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 890
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 892
  mutex_lock(ldv_func_arg1);
#line 893
  return;
}
}
#line 895 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
int ldv_mutex_lock_interruptible_839(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 899
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 899
  ldv_func_res = tmp;
#line 901
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 901
  return (tmp___0);
#line 903
  return (ldv_func_res);
}
}
#line 906 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
int ldv_mutex_trylock_840(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 910
  tmp = mutex_trylock(ldv_func_arg1);
#line 910
  ldv_func_res = tmp;
#line 912
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 912
  return (tmp___0);
#line 914
  return (ldv_func_res);
}
}
#line 938 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_mutex_unlock_843(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 941
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 943
  mutex_unlock(ldv_func_arg1);
#line 944
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_876(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_885(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_874(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_877(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_878(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_881(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_882(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_888(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
int ldv_mutex_lock_interruptible_884(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_873(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_875(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_879(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_880(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_883(struct mutex *ldv_func_arg1 ) ;
#line 163 "include/linux/timer.h"
__inline static int timer_pending(struct timer_list  const  *timer ) 
{ 


  {
#line 165
  return ((unsigned long )timer->entry.pprev != (unsigned long )((struct hlist_node **/* const  */)0));
}
}
#line 224
extern void add_timer(struct timer_list * ) ;
#line 229
extern int del_timer_sync(struct timer_list * ) ;
#line 232
int ldv_del_timer_sync_889(struct timer_list *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_868(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_870(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_869(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_872(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_871(struct workqueue_struct *ldv_func_arg1 ) ;
#line 58 "./arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile   *addr ) 
{ 
  unsigned int ret ;

  {
#line 58
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)): "memory");
#line 58
  return (ret);
}
}
#line 339 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
void activate_pending_timer_4(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 380
void choose_timer_4(struct timer_list *timer ) ;
#line 385
void disable_suitable_timer_4(struct timer_list *timer ) ;
#line 388
int reg_timer_4(struct timer_list *timer ) ;
#line 711 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
void psb_lid_timer_init(struct drm_psb_private *dev_priv ) ;
#line 712
void psb_lid_timer_takedown(struct drm_psb_private *dev_priv ) ;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.c"
static void psb_lid_timer_func(unsigned long data ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct drm_device *dev ;
  struct timer_list *lid_timer ;
  unsigned long irq_flags ;
  u32 *lid_state ;
  u32 pp_status ;
  unsigned int tmp ;
  uint32_t tmp___0 ;
  long tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  unsigned int tmp___4 ;
  raw_spinlock_t *tmp___5 ;
  int tmp___6 ;

  {
#line 28
  dev_priv = (struct drm_psb_private *)data;
#line 29
  dev = dev_priv->dev;
#line 30
  lid_timer = & dev_priv->lid_timer;
#line 32
  lid_state = dev_priv->opregion.lid_state;
#line 35
  tmp = readl((void const volatile   *)lid_state);
#line 35
  if (tmp == dev_priv->lid_last_state) {
#line 36
    goto lid_timer_schedule;
  } else {

  }
#line 38
  tmp___4 = readl((void const volatile   *)lid_state);
#line 38
  if ((int )tmp___4 & 1) {
#line 40
    tmp___0 = REGISTER_READ(dev, 397828U);
#line 40
    REGISTER_WRITE(dev, 397828U, tmp___0 | 1U);
    ldv_41908: 
#line 42
    pp_status = REGISTER_READ(dev, 397824U);
#line 44
    if ((int )pp_status >= 0 && (pp_status & 805306368U) != 0U) {
#line 46
      goto ldv_41908;
    } else {

    }
#line 46
    tmp___2 = REGISTER_READ(dev, 397824U);
#line 46
    if ((int )tmp___2 < 0) {
#line 48
      psb_intel_lvds_set_brightness(dev, 100);
    } else {
#line 50
      tmp___1 = ldv__builtin_expect((long )((int )drm_debug) & 1L, 0L);
#line 50
      if (tmp___1 != 0L) {
#line 50
        drm_ut_debug_printk("psb_lid_timer_func", "LVDS panel never powered up");
      } else {

      }
#line 51
      return;
    }
  } else {
#line 54
    psb_intel_lvds_set_brightness(dev, 0);
#line 56
    tmp___3 = REGISTER_READ(dev, 397828U);
#line 56
    REGISTER_WRITE(dev, 397828U, tmp___3 & 4294967294U);
    ldv_41911: 
#line 58
    pp_status = REGISTER_READ(dev, 397824U);
#line 59
    if ((int )pp_status >= 0) {
#line 61
      goto ldv_41911;
    } else {

    }

  }
#line 61
  dev_priv->lid_last_state = readl((void const volatile   *)lid_state);
  lid_timer_schedule: 
#line 64
  tmp___5 = spinlock_check(& dev_priv->lid_lock);
#line 64
  irq_flags = _raw_spin_lock_irqsave(tmp___5);
#line 65
  tmp___6 = timer_pending((struct timer_list  const  *)lid_timer);
#line 65
  if (tmp___6 == 0) {
#line 66
    lid_timer->expires = (unsigned long )jiffies + 25UL;
#line 67
    add_timer(lid_timer);
  } else {

  }
#line 69
  spin_unlock_irqrestore(& dev_priv->lid_lock, irq_flags);
#line 70
  return;
}
}
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.c"
void psb_lid_timer_init(struct drm_psb_private *dev_priv ) 
{ 
  struct timer_list *lid_timer ;
  unsigned long irq_flags ;
  struct lock_class_key __key ;
  raw_spinlock_t *tmp ;

  {
#line 74
  lid_timer = & dev_priv->lid_timer;
#line 77
  spinlock_check(& dev_priv->lid_lock);
#line 77
  __raw_spin_lock_init(& dev_priv->lid_lock.__annonCompField17.rlock, "&(&dev_priv->lid_lock)->rlock",
                       & __key);
#line 78
  tmp = spinlock_check(& dev_priv->lid_lock);
#line 78
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 80
  reg_timer_4(lid_timer);
#line 82
  lid_timer->data = (unsigned long )dev_priv;
#line 83
  lid_timer->function = & psb_lid_timer_func;
#line 84
  lid_timer->expires = (unsigned long )jiffies + 25UL;
#line 86
  add_timer(lid_timer);
#line 87
  spin_unlock_irqrestore(& dev_priv->lid_lock, irq_flags);
#line 88
  return;
}
}
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.c"
void psb_lid_timer_takedown(struct drm_psb_private *dev_priv ) 
{ 


  {
#line 92
  ldv_del_timer_sync_889(& dev_priv->lid_timer);
#line 93
  return;
}
}
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
void activate_pending_timer_4(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 405
  if ((unsigned long )ldv_timer_list_4 == (unsigned long )timer) {
#line 406
    if (ldv_timer_state_4 == 2 || pending_flag != 0) {
#line 407
      ldv_timer_list_4 = timer;
#line 408
      ldv_timer_list_4->data = data;
#line 409
      ldv_timer_state_4 = 1;
    } else {

    }
#line 411
    return;
  } else {

  }
#line 413
  reg_timer_4(timer);
#line 414
  ldv_timer_list_4->data = data;
#line 415
  return;
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
void choose_timer_4(struct timer_list *timer ) 
{ 


  {
#line 419
  LDV_IN_INTERRUPT = 2;
#line 420
  (*(timer->function))(timer->data);
#line 421
  LDV_IN_INTERRUPT = 1;
#line 422
  ldv_timer_state_4 = 2;
#line 423
  return;
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
void disable_suitable_timer_4(struct timer_list *timer ) 
{ 


  {
#line 427
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_4) {
#line 428
    ldv_timer_state_4 = 0;
#line 429
    return;
  } else {

  }
#line 431
  return;
}
}
#line 434 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
int reg_timer_4(struct timer_list *timer ) 
{ 


  {
#line 435
  ldv_timer_list_4 = timer;
#line 436
  ldv_timer_state_4 = 1;
#line 437
  return (0);
}
}
#line 463 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
bool ldv_queue_work_on_868(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 467
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 467
  ldv_func_res = tmp;
#line 469
  activate_work_2(ldv_func_arg3, 2);
#line 471
  return (ldv_func_res);
}
}
#line 474 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
bool ldv_queue_delayed_work_on_869(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 478
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 478
  ldv_func_res = tmp;
#line 480
  activate_work_2(& ldv_func_arg3->work, 2);
#line 482
  return (ldv_func_res);
}
}
#line 485 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
bool ldv_queue_work_on_870(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 489
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 489
  ldv_func_res = tmp;
#line 491
  activate_work_2(ldv_func_arg3, 2);
#line 493
  return (ldv_func_res);
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
void ldv_flush_workqueue_871(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 499
  flush_workqueue(ldv_func_arg1);
#line 501
  call_and_disable_all_2(2);
#line 502
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
bool ldv_queue_delayed_work_on_872(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 508
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 508
  ldv_func_res = tmp;
#line 510
  activate_work_2(& ldv_func_arg3->work, 2);
#line 512
  return (ldv_func_res);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
void ldv_mutex_lock_873(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 518
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 520
  mutex_lock(ldv_func_arg1);
#line 521
  return;
}
}
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
void ldv_mutex_unlock_874(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 526
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 528
  mutex_unlock(ldv_func_arg1);
#line 529
  return;
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
void ldv_mutex_lock_875(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 534
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 536
  mutex_lock(ldv_func_arg1);
#line 537
  return;
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
int ldv_mutex_trylock_876(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 543
  tmp = mutex_trylock(ldv_func_arg1);
#line 543
  ldv_func_res = tmp;
#line 545
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 545
  return (tmp___0);
#line 547
  return (ldv_func_res);
}
}
#line 550 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
void ldv_mutex_unlock_877(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 553
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 555
  mutex_unlock(ldv_func_arg1);
#line 556
  return;
}
}
#line 558 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
void ldv_mutex_unlock_878(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 561
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 563
  mutex_unlock(ldv_func_arg1);
#line 564
  return;
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
void ldv_mutex_lock_879(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 569
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 571
  mutex_lock(ldv_func_arg1);
#line 572
  return;
}
}
#line 574 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
void ldv_mutex_lock_880(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 577
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 579
  mutex_lock(ldv_func_arg1);
#line 580
  return;
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
void ldv_mutex_unlock_881(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 585
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 587
  mutex_unlock(ldv_func_arg1);
#line 588
  return;
}
}
#line 590 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
void ldv_mutex_unlock_882(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 593
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 595
  mutex_unlock(ldv_func_arg1);
#line 596
  return;
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
void ldv_mutex_lock_883(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 601
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 603
  mutex_lock(ldv_func_arg1);
#line 604
  return;
}
}
#line 606 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
int ldv_mutex_lock_interruptible_884(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 610
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 610
  ldv_func_res = tmp;
#line 612
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 612
  return (tmp___0);
#line 614
  return (ldv_func_res);
}
}
#line 617 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
int ldv_mutex_trylock_885(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 621
  tmp = mutex_trylock(ldv_func_arg1);
#line 621
  ldv_func_res = tmp;
#line 623
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 623
  return (tmp___0);
#line 625
  return (ldv_func_res);
}
}
#line 649 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
void ldv_mutex_unlock_888(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 652
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 654
  mutex_unlock(ldv_func_arg1);
#line 655
  return;
}
}
#line 657 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
int ldv_del_timer_sync_889(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
#line 661
  tmp = del_timer_sync(ldv_func_arg1);
#line 661
  ldv_func_res = tmp;
#line 663
  disable_suitable_timer_4(ldv_func_arg1);
#line 665
  return (ldv_func_res);
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_923(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_932(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_921(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_924(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_925(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_928(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_929(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_935(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
int ldv_mutex_lock_interruptible_931(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_920(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_922(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_926(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_927(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_930(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_915(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_917(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_916(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_919(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_918(struct workqueue_struct *ldv_func_arg1 ) ;
#line 934 "include/drm/drmP.h"
extern bool drm_handle_vblank(struct drm_device * , int  ) ;
#line 26 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/opregion.h"
void psb_intel_opregion_asle_intr(struct drm_device *dev ) ;
#line 679 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
int psb_irq_enable_dpst(struct drm_device *dev ) ;
#line 680
int psb_irq_disable_dpst(struct drm_device *dev ) ;
#line 684
void psb_irq_turn_on_dpst(struct drm_device *dev ) ;
#line 685
void psb_irq_turn_off_dpst(struct drm_device *dev ) ;
#line 693
void psb_enable_pipestat(struct drm_psb_private *dev_priv , int pipe , u32 mask ) ;
#line 696
void psb_disable_pipestat(struct drm_psb_private *dev_priv , int pipe , u32 mask ) ;
#line 45 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_irq.h"
int mdfld_enable_te(struct drm_device *dev , int pipe ) ;
#line 46
void mdfld_disable_te(struct drm_device *dev , int pipe ) ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"
__inline static u32 psb_pipestat(int pipe ) 
{ 


  {
#line 40
  if (pipe == 0) {
#line 41
    return (458788U);
  } else {

  }
#line 42
  if (pipe == 1) {
#line 43
    return (462884U);
  } else {

  }
#line 44
  if (pipe == 2) {
#line 45
    return (466980U);
  } else {

  }
#line 46
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"),
                       "i" (46), "i" (12UL));
  ldv_41977: ;
#line 46
  goto ldv_41977;
}
}
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"
__inline static u32 mid_pipe_event(int pipe ) 
{ 


  {
#line 52
  if (pipe == 0) {
#line 53
    return (64U);
  } else {

  }
#line 54
  if (pipe == 1) {
#line 55
    return (16U);
  } else {

  }
#line 56
  if (pipe == 2) {
#line 57
    return (4U);
  } else {

  }
#line 58
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"),
                       "i" (58), "i" (12UL));
  ldv_41981: ;
#line 58
  goto ldv_41981;
}
}
#line 74 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"
__inline static u32 mid_pipeconf(int pipe ) 
{ 


  {
#line 76
  if (pipe == 0) {
#line 77
    return (458760U);
  } else {

  }
#line 78
  if (pipe == 1) {
#line 79
    return (462856U);
  } else {

  }
#line 80
  if (pipe == 2) {
#line 81
    return (466952U);
  } else {

  }
#line 82
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"),
                       "i" (82), "i" (12UL));
  ldv_41989: ;
#line 82
  goto ldv_41989;
}
}
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"
void psb_enable_pipestat(struct drm_psb_private *dev_priv , int pipe , u32 mask ) 
{ 
  u32 reg ;
  u32 tmp ;
  u32 writeVal ;
  unsigned int tmp___0 ;
  bool tmp___1 ;

  {
#line 88
  if ((dev_priv->pipestat[pipe] & mask) != mask) {
#line 89
    tmp = psb_pipestat(pipe);
#line 89
    reg = tmp;
#line 90
    dev_priv->pipestat[pipe] = dev_priv->pipestat[pipe] | mask;
#line 92
    tmp___1 = gma_power_begin(dev_priv->dev, 0);
#line 92
    if ((int )tmp___1) {
#line 93
      tmp___0 = ioread32((void *)dev_priv->vdc_reg + (unsigned long )reg);
#line 93
      writeVal = tmp___0;
#line 94
      writeVal = ((mask >> 16) | mask) | writeVal;
#line 95
      iowrite32(writeVal, (void *)dev_priv->vdc_reg + (unsigned long )reg);
#line 96
      ioread32((void *)dev_priv->vdc_reg + (unsigned long )reg);
#line 97
      gma_power_end(dev_priv->dev);
    } else {

    }
  } else {

  }
#line 100
  return;
}
}
#line 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"
void psb_disable_pipestat(struct drm_psb_private *dev_priv , int pipe , u32 mask ) 
{ 
  u32 reg ;
  u32 tmp ;
  u32 writeVal ;
  unsigned int tmp___0 ;
  bool tmp___1 ;

  {
#line 105
  if ((dev_priv->pipestat[pipe] & mask) != 0U) {
#line 106
    tmp = psb_pipestat(pipe);
#line 106
    reg = tmp;
#line 107
    dev_priv->pipestat[pipe] = dev_priv->pipestat[pipe] & ~ mask;
#line 108
    tmp___1 = gma_power_begin(dev_priv->dev, 0);
#line 108
    if ((int )tmp___1) {
#line 109
      tmp___0 = ioread32((void *)dev_priv->vdc_reg + (unsigned long )reg);
#line 109
      writeVal = tmp___0;
#line 110
      writeVal = ~ mask & writeVal;
#line 111
      iowrite32(writeVal, (void *)dev_priv->vdc_reg + (unsigned long )reg);
#line 112
      ioread32((void *)dev_priv->vdc_reg + (unsigned long )reg);
#line 113
      gma_power_end(dev_priv->dev);
    } else {

    }
  } else {

  }
#line 116
  return;
}
}
#line 118 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"
static void mid_enable_pipe_event(struct drm_psb_private *dev_priv , int pipe ) 
{ 
  u32 pipe_event ;
  u32 tmp ;
  bool tmp___0 ;

  {
#line 120
  tmp___0 = gma_power_begin(dev_priv->dev, 0);
#line 120
  if ((int )tmp___0) {
#line 121
    tmp = mid_pipe_event(pipe);
#line 121
    pipe_event = tmp;
#line 122
    dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask | pipe_event;
#line 123
    iowrite32(~ dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8360U);
#line 124
    iowrite32(dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8352U);
#line 125
    gma_power_end(dev_priv->dev);
  } else {

  }
#line 127
  return;
}
}
#line 129 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"
static void mid_disable_pipe_event(struct drm_psb_private *dev_priv , int pipe ) 
{ 
  u32 pipe_event ;
  u32 tmp ;
  bool tmp___0 ;

  {
#line 131
  if (dev_priv->pipestat[pipe] == 0U) {
#line 132
    tmp___0 = gma_power_begin(dev_priv->dev, 0);
#line 132
    if ((int )tmp___0) {
#line 133
      tmp = mid_pipe_event(pipe);
#line 133
      pipe_event = tmp;
#line 134
      dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask & ~ pipe_event;
#line 135
      iowrite32(~ dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8360U);
#line 136
      iowrite32(dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8352U);
#line 137
      gma_power_end(dev_priv->dev);
    } else {

    }
  } else {

  }
#line 139
  return;
}
}
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"
static void mid_pipe_event_handler(struct drm_device *dev , int pipe ) 
{ 
  struct drm_psb_private *dev_priv ;
  uint32_t pipe_stat_val ;
  uint32_t pipe_stat_reg ;
  u32 tmp ;
  uint32_t pipe_enable ;
  uint32_t pipe_status ;
  uint32_t pipe_clear ;
  uint32_t i ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 148
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 151
  pipe_stat_val = 0U;
#line 152
  tmp = psb_pipestat(pipe);
#line 152
  pipe_stat_reg = tmp;
#line 153
  pipe_enable = dev_priv->pipestat[pipe];
#line 154
  pipe_status = dev_priv->pipestat[pipe] >> 16;
#line 156
  i = 0U;
#line 158
  spin_lock(& dev_priv->irqmask_lock);
#line 160
  pipe_stat_val = ioread32((void *)dev_priv->vdc_reg + (unsigned long )pipe_stat_reg);
#line 161
  pipe_stat_val = (pipe_enable | pipe_status) & pipe_stat_val;
#line 162
  pipe_stat_val = (pipe_stat_val >> 16) & pipe_stat_val;
#line 164
  spin_unlock(& dev_priv->irqmask_lock);
#line 168
  i = 0U;
#line 168
  goto ldv_42027;
  ldv_42026: 
#line 169
  tmp___0 = ioread32((void *)dev_priv->vdc_reg + (unsigned long )pipe_stat_reg);
#line 169
  iowrite32(tmp___0, (void *)dev_priv->vdc_reg + (unsigned long )pipe_stat_reg);
#line 170
  tmp___1 = ioread32((void *)dev_priv->vdc_reg + (unsigned long )pipe_stat_reg);
#line 170
  pipe_clear = tmp___1 & pipe_status;
#line 172
  if (pipe_clear == 0U) {
#line 173
    goto ldv_42025;
  } else {

  }
#line 168
  i = i + 1U;
  ldv_42027: ;
#line 168
  if (i <= 65534U) {
#line 170
    goto ldv_42026;
  } else {

  }
  ldv_42025: ;
#line 176
  if (pipe_clear != 0U) {
#line 177
    tmp___2 = ioread32((void *)dev_priv->vdc_reg + (unsigned long )pipe_stat_reg);
#line 177
    dev_err((struct device  const  *)dev->dev, "%s, can\'t clear status bits for pipe %d, its value = 0x%x.\n",
            "mid_pipe_event_handler", pipe, tmp___2);
  } else {

  }
#line 181
  if ((pipe_stat_val & 2U) != 0U) {
#line 182
    drm_handle_vblank(dev, pipe);
  } else {

  }
#line 184
  if (((unsigned long )pipe_stat_val & 64UL) != 0UL) {
#line 185
    drm_handle_vblank(dev, pipe);
  } else {

  }
#line 186
  return;
}
}
#line 191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"
static void psb_vdc_interrupt(struct drm_device *dev , uint32_t vdc_stat ) 
{ 


  {
#line 193
  if ((int )vdc_stat & 1) {
#line 194
    psb_intel_opregion_asle_intr(dev);
  } else {

  }
#line 196
  if ((vdc_stat & 128U) != 0U) {
#line 197
    mid_pipe_event_handler(dev, 0);
  } else {

  }
#line 199
  if ((vdc_stat & 32U) != 0U) {
#line 200
    mid_pipe_event_handler(dev, 1);
  } else {

  }
#line 201
  return;
}
}
#line 206 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"
static void psb_sgx_interrupt(struct drm_device *dev , u32 stat_1 , u32 stat_2 ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 val ;
  u32 addr ;
  int error ;

  {
#line 208
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 210
  error = 0;
#line 212
  if ((stat_1 & 134217728U) != 0U) {
#line 213
    val = ioread32((void *)dev_priv->sgx_reg + 3588U);
  } else {

  }
#line 215
  if ((stat_2 & 16U) != 0U) {
#line 216
    val = ioread32((void *)dev_priv->sgx_reg + 3076U);
#line 217
    addr = ioread32((void *)dev_priv->sgx_reg + 3080U);
#line 218
    if (val != 0U) {
#line 219
      if ((val & 16384U) != 0U) {
#line 220
        drm_err("SGX MMU page fault:");
      } else {
#line 222
        drm_err("SGX MMU read / write protection fault:");
      }
#line 224
      if ((val & 2U) != 0U) {
#line 225
        drm_err("\tCache requestor");
      } else {

      }
#line 226
      if ((val & 4U) != 0U) {
#line 227
        drm_err("\tTA requestor");
      } else {

      }
#line 228
      if ((val & 8U) != 0U) {
#line 229
        drm_err("\tVDM requestor");
      } else {

      }
#line 230
      if ((val & 16U) != 0U) {
#line 231
        drm_err("\t2D requestor");
      } else {

      }
#line 232
      if ((val & 32U) != 0U) {
#line 233
        drm_err("\tPBE requestor");
      } else {

      }
#line 234
      if ((val & 64U) != 0U) {
#line 235
        drm_err("\tTSP requestor");
      } else {

      }
#line 236
      if ((val & 128U) != 0U) {
#line 237
        drm_err("\tISP requestor");
      } else {

      }
#line 238
      if ((val & 256U) != 0U) {
#line 239
        drm_err("\tUSSEPDS requestor");
      } else {

      }
#line 240
      if ((val & 512U) != 0U) {
#line 241
        drm_err("\tHost requestor");
      } else {

      }
#line 243
      drm_err("\tMMU failing address is 0x%08x.\n", addr);
#line 245
      error = 1;
    } else {

    }
  } else {

  }
#line 250
  iowrite32(stat_1, (void *)dev_priv->sgx_reg + 308U);
#line 251
  iowrite32(stat_2, (void *)dev_priv->sgx_reg + 276U);
#line 252
  ioread32((void *)dev_priv->sgx_reg + 276U);
#line 253
  return;
}
}
#line 255 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"
irqreturn_t psb_irq_handler(int irq , void *arg ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  uint32_t vdc_stat ;
  uint32_t dsp_int ;
  uint32_t sgx_int ;
  uint32_t hotplug_int ;
  u32 sgx_stat_1 ;
  u32 sgx_stat_2 ;
  int handled ;
  bool tmp ;
  uint32_t tmp___0 ;

  {
#line 257
  dev = (struct drm_device *)arg;
#line 258
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 259
  dsp_int = 0U;
#line 259
  sgx_int = 0U;
#line 259
  hotplug_int = 0U;
#line 261
  handled = 0;
#line 263
  spin_lock(& dev_priv->irqmask_lock);
#line 265
  vdc_stat = ioread32((void *)dev_priv->vdc_reg + 8356U);
#line 267
  if ((vdc_stat & 161U) != 0U) {
#line 268
    dsp_int = 1U;
  } else {

  }
#line 275
  if ((vdc_stat & 262144U) != 0U) {
#line 276
    sgx_int = 1U;
  } else {

  }
#line 277
  if ((vdc_stat & 131072U) != 0U) {
#line 278
    hotplug_int = 1U;
  } else {

  }
#line 280
  vdc_stat = dev_priv->vdc_irq_mask & vdc_stat;
#line 281
  spin_unlock(& dev_priv->irqmask_lock);
#line 283
  if (dsp_int != 0U) {
#line 283
    tmp = gma_power_is_on(dev);
#line 283
    if ((int )tmp) {
#line 284
      psb_vdc_interrupt(dev, vdc_stat);
#line 285
      handled = 1;
    } else {

    }
  } else {

  }
#line 288
  if (sgx_int != 0U) {
#line 289
    sgx_stat_1 = ioread32((void *)dev_priv->sgx_reg + 300U);
#line 290
    sgx_stat_2 = ioread32((void *)dev_priv->sgx_reg + 280U);
#line 291
    psb_sgx_interrupt(dev, sgx_stat_1, sgx_stat_2);
#line 292
    handled = 1;
  } else {

  }
#line 297
  if (hotplug_int != 0U && (unsigned long )(dev_priv->ops)->hotplug != (unsigned long )((int (*/* const  */)(struct drm_device * ))0)) {
#line 298
    handled = (*((dev_priv->ops)->hotplug))(dev);
#line 299
    tmp___0 = REGISTER_READ(dev, 397588U);
#line 299
    REGISTER_WRITE(dev, 397588U, tmp___0);
  } else {

  }
#line 302
  iowrite32(vdc_stat, (void *)dev_priv->vdc_reg + 8356U);
#line 303
  ioread32((void *)dev_priv->vdc_reg + 8356U);
#line 304
  __asm__  volatile   ("lfence": : : "memory");
#line 306
  if (handled == 0) {
#line 307
    return (0);
  } else {

  }
#line 309
  return (1);
}
}
#line 312 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"
void psb_irq_preinstall(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;
  raw_spinlock_t *tmp ;
  bool tmp___0 ;

  {
#line 314
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 318
  tmp = spinlock_check(& dev_priv->irqmask_lock);
#line 318
  irqflags = _raw_spin_lock_irqsave(tmp);
#line 320
  tmp___0 = gma_power_is_on(dev);
#line 320
  if ((int )tmp___0) {
#line 321
    iowrite32(4294967295U, (void *)dev_priv->vdc_reg + 8344U);
#line 322
    iowrite32(0U, (void *)dev_priv->vdc_reg + 8360U);
#line 323
    iowrite32(0U, (void *)dev_priv->vdc_reg + 8352U);
#line 324
    iowrite32(0U, (void *)dev_priv->sgx_reg + 304U);
#line 325
    ioread32((void *)dev_priv->sgx_reg + 304U);
  } else {

  }
#line 327
  if ((int )(dev->vblank)->enabled) {
#line 328
    dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask | 128U;
  } else {

  }
#line 329
  if ((int )(dev->vblank + 1UL)->enabled) {
#line 330
    dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask | 32U;
  } else {

  }
#line 340
  if ((unsigned long )(dev_priv->ops)->hotplug != (unsigned long )((int (*/* const  */)(struct drm_device * ))0)) {
#line 341
    dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask | 131072U;
  } else {

  }
#line 342
  dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask | 262145U;
#line 345
  iowrite32(~ dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8360U);
#line 346
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
#line 347
  return;
}
}
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"
int psb_irq_postinstall(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;
  raw_spinlock_t *tmp ;

  {
#line 351
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 354
  tmp = spinlock_check(& dev_priv->irqmask_lock);
#line 354
  irqflags = _raw_spin_lock_irqsave(tmp);
#line 357
  iowrite32(16U, (void *)dev_priv->sgx_reg + 272U);
#line 358
  iowrite32(134217728U, (void *)dev_priv->sgx_reg + 304U);
#line 359
  ioread32((void *)dev_priv->sgx_reg + 304U);
#line 362
  iowrite32(dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8352U);
#line 363
  iowrite32(4294967295U, (void *)dev_priv->vdc_reg + 8344U);
#line 365
  if ((int )(dev->vblank)->enabled) {
#line 366
    psb_enable_pipestat(dev_priv, 0, 131072U);
  } else {
#line 368
    psb_disable_pipestat(dev_priv, 0, 131072U);
  }
#line 370
  if ((int )(dev->vblank + 1UL)->enabled) {
#line 371
    psb_enable_pipestat(dev_priv, 1, 131072U);
  } else {
#line 373
    psb_disable_pipestat(dev_priv, 1, 131072U);
  }
#line 375
  if ((int )(dev->vblank + 2UL)->enabled) {
#line 376
    psb_enable_pipestat(dev_priv, 2, 131072U);
  } else {
#line 378
    psb_disable_pipestat(dev_priv, 2, 131072U);
  }
#line 380
  if ((unsigned long )(dev_priv->ops)->hotplug_enable != (unsigned long )((void (*/* const  */)(struct drm_device * ,
                                                                                                bool  ))0)) {
#line 381
    (*((dev_priv->ops)->hotplug_enable))(dev, 1);
  } else {

  }
#line 383
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
#line 384
  return (0);
}
}
#line 387 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"
void psb_irq_uninstall(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;
  raw_spinlock_t *tmp ;
  unsigned int tmp___0 ;

  {
#line 389
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 392
  tmp = spinlock_check(& dev_priv->irqmask_lock);
#line 392
  irqflags = _raw_spin_lock_irqsave(tmp);
#line 394
  if ((unsigned long )(dev_priv->ops)->hotplug_enable != (unsigned long )((void (*/* const  */)(struct drm_device * ,
                                                                                                bool  ))0)) {
#line 395
    (*((dev_priv->ops)->hotplug_enable))(dev, 0);
  } else {

  }
#line 397
  iowrite32(4294967295U, (void *)dev_priv->vdc_reg + 8344U);
#line 399
  if ((int )(dev->vblank)->enabled) {
#line 400
    psb_disable_pipestat(dev_priv, 0, 131072U);
  } else {

  }
#line 402
  if ((int )(dev->vblank + 1UL)->enabled) {
#line 403
    psb_disable_pipestat(dev_priv, 1, 131072U);
  } else {

  }
#line 405
  if ((int )(dev->vblank + 2UL)->enabled) {
#line 406
    psb_disable_pipestat(dev_priv, 2, 131072U);
  } else {

  }
#line 408
  dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask & 1835008U;
#line 413
  iowrite32(~ dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8360U);
#line 414
  iowrite32(dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8352U);
#line 416
  __asm__  volatile   ("sfence": : : "memory");
#line 419
  tmp___0 = ioread32((void *)dev_priv->vdc_reg + 8356U);
#line 419
  iowrite32(tmp___0, (void *)dev_priv->vdc_reg + 8356U);
#line 420
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
#line 421
  return;
}
}
#line 423 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"
void psb_irq_turn_on_dpst(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 hist_reg ;
  u32 pwm_reg ;
  bool tmp ;

  {
#line 425
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 430
  tmp = gma_power_begin(dev, 0);
#line 430
  if ((int )tmp) {
#line 431
    iowrite32(2147483648U, (void *)dev_priv->vdc_reg + 397920U);
#line 432
    hist_reg = ioread32((void *)dev_priv->vdc_reg + 397920U);
#line 433
    iowrite32(2147483648U, (void *)dev_priv->vdc_reg + 397928U);
#line 434
    hist_reg = ioread32((void *)dev_priv->vdc_reg + 397928U);
#line 436
    iowrite32(2147549440U, (void *)dev_priv->vdc_reg + 397904U);
#line 437
    pwm_reg = ioread32((void *)dev_priv->vdc_reg + 397904U);
#line 438
    iowrite32(pwm_reg | 50331648U, (void *)dev_priv->vdc_reg + 397904U);
#line 441
    pwm_reg = ioread32((void *)dev_priv->vdc_reg + 397904U);
#line 443
    psb_enable_pipestat(dev_priv, 0, 8388608U);
#line 445
    hist_reg = ioread32((void *)dev_priv->vdc_reg + 397928U);
#line 446
    iowrite32(hist_reg | 1073741824U, (void *)dev_priv->vdc_reg + 397928U);
#line 448
    pwm_reg = ioread32((void *)dev_priv->vdc_reg + 397904U);
#line 449
    iowrite32(pwm_reg | 2181103872U, (void *)dev_priv->vdc_reg + 397904U);
#line 452
    gma_power_end(dev);
  } else {

  }
#line 454
  return;
}
}
#line 456 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"
int psb_irq_enable_dpst(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;
  raw_spinlock_t *tmp ;

  {
#line 458
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 462
  tmp = spinlock_check(& dev_priv->irqmask_lock);
#line 462
  irqflags = _raw_spin_lock_irqsave(tmp);
#line 465
  mid_enable_pipe_event(dev_priv, 0);
#line 466
  psb_irq_turn_on_dpst(dev);
#line 468
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
#line 469
  return (0);
}
}
#line 472 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"
void psb_irq_turn_off_dpst(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 hist_reg ;
  u32 pwm_reg ;
  bool tmp ;

  {
#line 474
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 479
  tmp = gma_power_begin(dev, 0);
#line 479
  if ((int )tmp) {
#line 480
    iowrite32(0U, (void *)dev_priv->vdc_reg + 397928U);
#line 481
    hist_reg = ioread32((void *)dev_priv->vdc_reg + 397928U);
#line 483
    psb_disable_pipestat(dev_priv, 0, 8388608U);
#line 485
    pwm_reg = ioread32((void *)dev_priv->vdc_reg + 397904U);
#line 486
    iowrite32(pwm_reg & 4278190079U, (void *)dev_priv->vdc_reg + 397904U);
#line 488
    pwm_reg = ioread32((void *)dev_priv->vdc_reg + 397904U);
#line 490
    gma_power_end(dev);
  } else {

  }
#line 492
  return;
}
}
#line 494 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"
int psb_irq_disable_dpst(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;
  raw_spinlock_t *tmp ;

  {
#line 496
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 500
  tmp = spinlock_check(& dev_priv->irqmask_lock);
#line 500
  irqflags = _raw_spin_lock_irqsave(tmp);
#line 502
  mid_disable_pipe_event(dev_priv, 0);
#line 503
  psb_irq_turn_off_dpst(dev);
#line 505
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
#line 507
  return (0);
}
}
#line 513 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"
int psb_enable_vblank(struct drm_device *dev , int pipe ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;
  uint32_t reg_val ;
  uint32_t pipeconf_reg ;
  u32 tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  raw_spinlock_t *tmp___2 ;

  {
#line 515
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 517
  reg_val = 0U;
#line 518
  tmp = mid_pipeconf(pipe);
#line 518
  pipeconf_reg = tmp;
#line 522
  if (((int )(dev->pdev)->device & 65528) == 304) {
#line 523
    tmp___0 = mdfld_enable_te(dev, pipe);
#line 523
    return (tmp___0);
  } else {

  }
#line 525
  tmp___1 = gma_power_begin(dev, 0);
#line 525
  if ((int )tmp___1) {
#line 526
    reg_val = REGISTER_READ(dev, pipeconf_reg);
#line 527
    gma_power_end(dev);
  } else {

  }
#line 530
  if ((int )reg_val >= 0) {
#line 531
    return (-22);
  } else {

  }
#line 533
  tmp___2 = spinlock_check(& dev_priv->irqmask_lock);
#line 533
  irqflags = _raw_spin_lock_irqsave(tmp___2);
#line 535
  if (pipe == 0) {
#line 536
    dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask | 128U;
  } else
#line 537
  if (pipe == 1) {
#line 538
    dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask | 32U;
  } else {

  }
#line 540
  iowrite32(~ dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8360U);
#line 541
  iowrite32(dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8352U);
#line 542
  psb_enable_pipestat(dev_priv, pipe, 131072U);
#line 544
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
#line 546
  return (0);
}
}
#line 552 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"
void psb_disable_vblank(struct drm_device *dev , int pipe ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;
  raw_spinlock_t *tmp ;

  {
#line 554
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 557
  if (((int )(dev->pdev)->device & 65528) == 304) {
#line 558
    mdfld_disable_te(dev, pipe);
  } else {

  }
#line 559
  tmp = spinlock_check(& dev_priv->irqmask_lock);
#line 559
  irqflags = _raw_spin_lock_irqsave(tmp);
#line 561
  if (pipe == 0) {
#line 562
    dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask & 4294967167U;
  } else
#line 563
  if (pipe == 1) {
#line 564
    dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask & 4294967263U;
  } else {

  }
#line 566
  iowrite32(~ dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8360U);
#line 567
  iowrite32(dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8352U);
#line 568
  psb_disable_pipestat(dev_priv, pipe, 131072U);
#line 570
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
#line 571
  return;
}
}
#line 576 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"
int mdfld_enable_te(struct drm_device *dev , int pipe ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;
  uint32_t reg_val ;
  uint32_t pipeconf_reg ;
  u32 tmp ;
  bool tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
#line 578
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 581
  reg_val = 0U;
#line 582
  tmp = mid_pipeconf(pipe);
#line 582
  pipeconf_reg = tmp;
#line 584
  tmp___0 = gma_power_begin(dev, 0);
#line 584
  if ((int )tmp___0) {
#line 585
    reg_val = REGISTER_READ(dev, pipeconf_reg);
#line 586
    gma_power_end(dev);
  } else {

  }
#line 589
  if ((int )reg_val >= 0) {
#line 590
    return (-22);
  } else {

  }
#line 592
  tmp___1 = spinlock_check(& dev_priv->irqmask_lock);
#line 592
  irqflags = _raw_spin_lock_irqsave(tmp___1);
#line 594
  mid_enable_pipe_event(dev_priv, pipe);
#line 595
  psb_enable_pipestat(dev_priv, pipe, 4194304U);
#line 597
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
#line 599
  return (0);
}
}
#line 605 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"
void mdfld_disable_te(struct drm_device *dev , int pipe ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;
  raw_spinlock_t *tmp ;

  {
#line 607
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 611
  if (! dev_priv->dsr_enable) {
#line 612
    return;
  } else {

  }
#line 614
  tmp = spinlock_check(& dev_priv->irqmask_lock);
#line 614
  irqflags = _raw_spin_lock_irqsave(tmp);
#line 616
  mid_disable_pipe_event(dev_priv, pipe);
#line 617
  psb_disable_pipestat(dev_priv, pipe, 4194304U);
#line 619
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
#line 620
  return;
}
}
#line 625 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c"
u32 psb_get_vblank_counter(struct drm_device *dev , int pipe ) 
{ 
  uint32_t high_frame ;
  uint32_t low_frame ;
  uint32_t pipeconf_reg ;
  uint32_t reg_val ;
  uint32_t high1 ;
  uint32_t high2 ;
  uint32_t low ;
  uint32_t count ;
  bool tmp ;
  int tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;

  {
#line 627
  high_frame = 458816U;
#line 628
  low_frame = 458820U;
#line 629
  pipeconf_reg = 458760U;
#line 630
  reg_val = 0U;
#line 631
  high1 = 0U;
#line 631
  high2 = 0U;
#line 631
  low = 0U;
#line 631
  count = 0U;
#line 633
  switch (pipe) {
  case 0: ;
#line 635
  goto ldv_42160;
  case 1: 
#line 637
  high_frame = 462912U;
#line 638
  low_frame = 462916U;
#line 639
  pipeconf_reg = 462856U;
#line 640
  goto ldv_42160;
  case 2: 
#line 642
  high_frame = 467008U;
#line 643
  low_frame = 467012U;
#line 644
  pipeconf_reg = 466952U;
#line 645
  goto ldv_42160;
  default: 
#line 647
  dev_err((struct device  const  *)dev->dev, "%s, invalid pipe.\n", "psb_get_vblank_counter");
#line 648
  return (0U);
  }
  ldv_42160: 
#line 651
  tmp = gma_power_begin(dev, 0);
#line 651
  if (tmp) {
#line 651
    tmp___0 = 0;
  } else {
#line 651
    tmp___0 = 1;
  }
#line 651
  if (tmp___0) {
#line 652
    return (0U);
  } else {

  }
#line 654
  reg_val = REGISTER_READ(dev, pipeconf_reg);
#line 656
  if ((int )reg_val >= 0) {
#line 657
    dev_err((struct device  const  *)dev->dev, "trying to get vblank count for disabled pipe %d\n",
            pipe);
#line 659
    goto psb_get_vblank_counter_exit;
  } else {

  }
  ldv_42166: 
#line 668
  tmp___1 = REGISTER_READ(dev, high_frame);
#line 668
  high1 = tmp___1 & 65535U;
#line 670
  tmp___2 = REGISTER_READ(dev, low_frame);
#line 670
  low = tmp___2 >> 24;
#line 672
  tmp___3 = REGISTER_READ(dev, high_frame);
#line 672
  high2 = tmp___3 & 65535U;
#line 674
  if (high1 != high2) {
#line 676
    goto ldv_42166;
  } else {

  }
#line 676
  count = (high1 << 8) | low;
  psb_get_vblank_counter_exit: 
#line 680
  gma_power_end(dev);
#line 682
  return (count);
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
bool ldv_queue_work_on_915(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 432
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 432
  ldv_func_res = tmp;
#line 434
  activate_work_2(ldv_func_arg3, 2);
#line 436
  return (ldv_func_res);
}
}
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
bool ldv_queue_delayed_work_on_916(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 443
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 443
  ldv_func_res = tmp;
#line 445
  activate_work_2(& ldv_func_arg3->work, 2);
#line 447
  return (ldv_func_res);
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
bool ldv_queue_work_on_917(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 454
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 454
  ldv_func_res = tmp;
#line 456
  activate_work_2(ldv_func_arg3, 2);
#line 458
  return (ldv_func_res);
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
void ldv_flush_workqueue_918(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 464
  flush_workqueue(ldv_func_arg1);
#line 466
  call_and_disable_all_2(2);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
bool ldv_queue_delayed_work_on_919(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 473
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 473
  ldv_func_res = tmp;
#line 475
  activate_work_2(& ldv_func_arg3->work, 2);
#line 477
  return (ldv_func_res);
}
}
#line 480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
void ldv_mutex_lock_920(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 483
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 485
  mutex_lock(ldv_func_arg1);
#line 486
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
void ldv_mutex_unlock_921(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 491
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 493
  mutex_unlock(ldv_func_arg1);
#line 494
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
void ldv_mutex_lock_922(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 499
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 501
  mutex_lock(ldv_func_arg1);
#line 502
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
int ldv_mutex_trylock_923(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 508
  tmp = mutex_trylock(ldv_func_arg1);
#line 508
  ldv_func_res = tmp;
#line 510
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 510
  return (tmp___0);
#line 512
  return (ldv_func_res);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
void ldv_mutex_unlock_924(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 518
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 520
  mutex_unlock(ldv_func_arg1);
#line 521
  return;
}
}
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
void ldv_mutex_unlock_925(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 526
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 528
  mutex_unlock(ldv_func_arg1);
#line 529
  return;
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
void ldv_mutex_lock_926(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 534
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 536
  mutex_lock(ldv_func_arg1);
#line 537
  return;
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
void ldv_mutex_lock_927(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 542
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 544
  mutex_lock(ldv_func_arg1);
#line 545
  return;
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
void ldv_mutex_unlock_928(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 550
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 552
  mutex_unlock(ldv_func_arg1);
#line 553
  return;
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
void ldv_mutex_unlock_929(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 558
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 560
  mutex_unlock(ldv_func_arg1);
#line 561
  return;
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
void ldv_mutex_lock_930(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 566
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 568
  mutex_lock(ldv_func_arg1);
#line 569
  return;
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
int ldv_mutex_lock_interruptible_931(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 575
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 575
  ldv_func_res = tmp;
#line 577
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 577
  return (tmp___0);
#line 579
  return (ldv_func_res);
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
int ldv_mutex_trylock_932(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 586
  tmp = mutex_trylock(ldv_func_arg1);
#line 586
  ldv_func_res = tmp;
#line 588
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 588
  return (tmp___0);
#line 590
  return (ldv_func_res);
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
void ldv_mutex_unlock_935(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 617
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 619
  mutex_unlock(ldv_func_arg1);
#line 620
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_968(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_977(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_966(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_969(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_970(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_972(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_974(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_980(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
int ldv_mutex_lock_interruptible_976(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_965(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_967(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_971(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_973(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_975(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_960(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_962(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_961(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_964(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_963(struct workqueue_struct *ldv_func_arg1 ) ;
#line 132 "include/drm/drm_modeset_lock.h"
extern void drm_modeset_lock_all(struct drm_device * ) ;
#line 134
extern void drm_modeset_unlock_all(struct drm_device * ) ;
#line 187 "include/drm/drm_crtc_helper.h"
extern bool drm_helper_crtc_in_use(struct drm_crtc * ) ;
#line 27 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/opregion.h"
void psb_intel_opregion_init(struct drm_device *dev ) ;
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.c"
static int psb_output_init(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 33
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 34
  psb_intel_lvds_init(dev, & dev_priv->mode_dev);
#line 35
  psb_intel_sdvo_init(dev, 397632);
#line 36
  return (0);
}
}
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.c"
static void psb_init_pm(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 gating ;
  unsigned int tmp ;

  {
#line 164
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 166
  tmp = ioread32((void *)dev_priv->sgx_reg);
#line 166
  gating = tmp;
#line 167
  gating = gating & 4294967292U;
#line 168
  gating = gating | 1U;
#line 169
  iowrite32(gating, (void *)dev_priv->sgx_reg);
#line 170
  ioread32((void *)dev_priv->sgx_reg);
#line 171
  return;
}
}
#line 180 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.c"
static int psb_save_display_registers(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct drm_crtc *crtc ;
  struct drm_connector *connector ;
  struct psb_state *regs ;
  struct list_head  const  *__mptr ;
  bool tmp ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
#line 182
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 185
  regs = & dev_priv->regs.__annonCompField80.psb;
#line 188
  regs->saveDSPARB = ioread32((void *)dev_priv->vdc_reg + 458800U);
#line 189
  regs->saveDSPFW1 = ioread32((void *)dev_priv->vdc_reg + 458804U);
#line 190
  regs->saveDSPFW2 = ioread32((void *)dev_priv->vdc_reg + 458808U);
#line 191
  regs->saveDSPFW3 = ioread32((void *)dev_priv->vdc_reg + 458812U);
#line 192
  regs->saveDSPFW4 = ioread32((void *)dev_priv->vdc_reg + 458832U);
#line 193
  regs->saveDSPFW5 = ioread32((void *)dev_priv->vdc_reg + 458836U);
#line 194
  regs->saveDSPFW6 = ioread32((void *)dev_priv->vdc_reg + 458840U);
#line 195
  regs->saveCHICKENBIT = ioread32((void *)dev_priv->vdc_reg + 459776U);
#line 198
  drm_modeset_lock_all(dev);
#line 199
  __mptr = (struct list_head  const  *)dev->mode_config.crtc_list.next;
#line 199
  crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff0UL;
#line 199
  goto ldv_41918;
  ldv_41917: 
#line 200
  tmp = drm_helper_crtc_in_use(crtc);
#line 200
  if ((int )tmp) {
#line 201
    (*((crtc->funcs)->save))(crtc);
  } else {

  }
#line 199
  __mptr___0 = (struct list_head  const  *)crtc->head.next;
#line 199
  crtc = (struct drm_crtc *)__mptr___0 + 0xfffffffffffffff0UL;
  ldv_41918: ;
#line 199
  if ((unsigned long )(& crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
#line 201
    goto ldv_41917;
  } else {

  }
#line 204
  __mptr___1 = (struct list_head  const  *)dev->mode_config.connector_list.next;
#line 204
  connector = (struct drm_connector *)__mptr___1 + 0xffffffffffffffe8UL;
#line 204
  goto ldv_41925;
  ldv_41924: ;
#line 205
  if ((unsigned long )(connector->funcs)->save != (unsigned long )((void (*/* const  */)(struct drm_connector * ))0)) {
#line 206
    (*((connector->funcs)->save))(connector);
  } else {

  }
#line 204
  __mptr___2 = (struct list_head  const  *)connector->head.next;
#line 204
  connector = (struct drm_connector *)__mptr___2 + 0xffffffffffffffe8UL;
  ldv_41925: ;
#line 204
  if ((unsigned long )(& connector->head) != (unsigned long )(& dev->mode_config.connector_list)) {
#line 206
    goto ldv_41924;
  } else {

  }
#line 208
  drm_modeset_unlock_all(dev);
#line 209
  return (0);
}
}
#line 218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.c"
static int psb_restore_display_registers(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct drm_crtc *crtc ;
  struct drm_connector *connector ;
  struct psb_state *regs ;
  struct list_head  const  *__mptr ;
  bool tmp ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
#line 220
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 223
  regs = & dev_priv->regs.__annonCompField80.psb;
#line 226
  iowrite32(regs->saveDSPARB, (void *)dev_priv->vdc_reg + 458800U);
#line 227
  iowrite32(regs->saveDSPFW1, (void *)dev_priv->vdc_reg + 458804U);
#line 228
  iowrite32(regs->saveDSPFW2, (void *)dev_priv->vdc_reg + 458808U);
#line 229
  iowrite32(regs->saveDSPFW3, (void *)dev_priv->vdc_reg + 458812U);
#line 230
  iowrite32(regs->saveDSPFW4, (void *)dev_priv->vdc_reg + 458832U);
#line 231
  iowrite32(regs->saveDSPFW5, (void *)dev_priv->vdc_reg + 458836U);
#line 232
  iowrite32(regs->saveDSPFW6, (void *)dev_priv->vdc_reg + 458840U);
#line 233
  iowrite32(regs->saveCHICKENBIT, (void *)dev_priv->vdc_reg + 459776U);
#line 236
  iowrite32(2147483648U, (void *)dev_priv->vdc_reg + 463872U);
#line 238
  drm_modeset_lock_all(dev);
#line 239
  __mptr = (struct list_head  const  *)dev->mode_config.crtc_list.next;
#line 239
  crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff0UL;
#line 239
  goto ldv_41939;
  ldv_41938: 
#line 240
  tmp = drm_helper_crtc_in_use(crtc);
#line 240
  if ((int )tmp) {
#line 241
    (*((crtc->funcs)->restore))(crtc);
  } else {

  }
#line 239
  __mptr___0 = (struct list_head  const  *)crtc->head.next;
#line 239
  crtc = (struct drm_crtc *)__mptr___0 + 0xfffffffffffffff0UL;
  ldv_41939: ;
#line 239
  if ((unsigned long )(& crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
#line 241
    goto ldv_41938;
  } else {

  }
#line 243
  __mptr___1 = (struct list_head  const  *)dev->mode_config.connector_list.next;
#line 243
  connector = (struct drm_connector *)__mptr___1 + 0xffffffffffffffe8UL;
#line 243
  goto ldv_41946;
  ldv_41945: ;
#line 244
  if ((unsigned long )(connector->funcs)->restore != (unsigned long )((void (*/* const  */)(struct drm_connector * ))0)) {
#line 245
    (*((connector->funcs)->restore))(connector);
  } else {

  }
#line 243
  __mptr___2 = (struct list_head  const  *)connector->head.next;
#line 243
  connector = (struct drm_connector *)__mptr___2 + 0xffffffffffffffe8UL;
  ldv_41946: ;
#line 243
  if ((unsigned long )(& connector->head) != (unsigned long )(& dev->mode_config.connector_list)) {
#line 245
    goto ldv_41945;
  } else {

  }
#line 247
  drm_modeset_unlock_all(dev);
#line 248
  return (0);
}
}
#line 251 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.c"
static int psb_power_down(struct drm_device *dev ) 
{ 


  {
#line 253
  return (0);
}
}
#line 256 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.c"
static int psb_power_up(struct drm_device *dev ) 
{ 


  {
#line 258
  return (0);
}
}
#line 262 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.c"
static struct psb_offset  const  psb_regmap[2U]  = {      {24640U, 24644U, 459136U, 458760U, 393244U, 24596U, 0U, 393216U, 393220U, 393224U,
      393228U, 393232U, 393236U, 459144U, 459152U, 459148U, 459164U, 459140U, 459140U,
      458788U, 459140U, 459172U, 40960U}, 
        {24648U, 24652U, 463232U, 462856U, 397340U, 24600U, 0U, 397312U, 397316U, 397320U,
      397324U, 397328U, 397332U, 463240U, 463248U, 463244U, 463260U, 463236U, 463236U,
      462884U, 463236U, 463268U, 43008U}};
#line 313 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.c"
static int psb_chip_setup(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 315
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 316
  dev_priv->regmap = (struct psb_offset  const  *)(& psb_regmap);
#line 317
  gma_get_core_freq(dev);
#line 318
  gma_intel_setup_gmbus(dev);
#line 319
  psb_intel_opregion_init(dev);
#line 320
  psb_intel_init_bios(dev);
#line 321
  return (0);
}
}
#line 324 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.c"
static void psb_chip_teardown(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 326
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 327
  psb_lid_timer_takedown(dev_priv);
#line 328
  gma_intel_teardown_gmbus(dev);
#line 329
  return;
}
}
#line 331 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.c"
struct psb_ops  const  psb_chip_ops  = 
#line 331
     {"Poulsbo", 1U, 2, 2, 262144, 1, 2, 1, 1, & psb_intel_helper_funcs, & psb_intel_crtc_funcs,
    & psb_clock_funcs, & psb_chip_setup, & psb_chip_teardown, 0, & psb_output_init,
    0, 0, & psb_init_pm, & psb_save_display_registers, & psb_restore_display_registers,
    & psb_power_up, & psb_power_down, 0, 0, 0, 0};
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
void ldv_initialize_psb_ops_35(void) 
{ 
  void *tmp ;

  {
#line 406
  tmp = ldv_init_zalloc(3320UL);
#line 406
  psb_chip_ops_group0 = (struct drm_device *)tmp;
#line 407
  return;
}
}
#line 409 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
void ldv_main_exported_35(void) 
{ 
  int tmp ;

  {
#line 411
  tmp = __VERIFIER_nondet_int();
#line 411
  switch (tmp) {
  case 0: ;
#line 414
  if (ldv_state_variable_35 == 1) {
#line 416
    psb_chip_teardown(psb_chip_ops_group0);
#line 418
    ldv_state_variable_35 = 1;
  } else {

  }
#line 421
  goto ldv_41971;
  case 1: ;
#line 424
  if (ldv_state_variable_35 == 1) {
#line 426
    psb_chip_setup(psb_chip_ops_group0);
#line 428
    ldv_state_variable_35 = 1;
  } else {

  }
#line 431
  goto ldv_41971;
  case 2: ;
#line 434
  if (ldv_state_variable_35 == 1) {
#line 436
    psb_init_pm(psb_chip_ops_group0);
#line 438
    ldv_state_variable_35 = 1;
  } else {

  }
#line 441
  goto ldv_41971;
  case 3: ;
#line 444
  if (ldv_state_variable_35 == 1) {
#line 446
    psb_save_display_registers(psb_chip_ops_group0);
#line 448
    ldv_state_variable_35 = 1;
  } else {

  }
#line 451
  goto ldv_41971;
  case 4: ;
#line 454
  if (ldv_state_variable_35 == 1) {
#line 456
    psb_restore_display_registers(psb_chip_ops_group0);
#line 458
    ldv_state_variable_35 = 1;
  } else {

  }
#line 461
  goto ldv_41971;
  case 5: ;
#line 464
  if (ldv_state_variable_35 == 1) {
#line 466
    psb_power_down(psb_chip_ops_group0);
#line 468
    ldv_state_variable_35 = 1;
  } else {

  }
#line 471
  goto ldv_41971;
  case 6: ;
#line 474
  if (ldv_state_variable_35 == 1) {
#line 476
    psb_output_init(psb_chip_ops_group0);
#line 478
    ldv_state_variable_35 = 1;
  } else {

  }
#line 481
  goto ldv_41971;
  case 7: ;
#line 484
  if (ldv_state_variable_35 == 1) {
#line 486
    psb_power_up(psb_chip_ops_group0);
#line 488
    ldv_state_variable_35 = 1;
  } else {

  }
#line 491
  goto ldv_41971;
  default: 
#line 492
  ldv_stop();
  }
  ldv_41971: ;
#line 496
  return;
}
}
#line 521 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
bool ldv_queue_work_on_960(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 525
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 525
  ldv_func_res = tmp;
#line 527
  activate_work_2(ldv_func_arg3, 2);
#line 529
  return (ldv_func_res);
}
}
#line 532 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
bool ldv_queue_delayed_work_on_961(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 536
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 536
  ldv_func_res = tmp;
#line 538
  activate_work_2(& ldv_func_arg3->work, 2);
#line 540
  return (ldv_func_res);
}
}
#line 543 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
bool ldv_queue_work_on_962(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 547
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 547
  ldv_func_res = tmp;
#line 549
  activate_work_2(ldv_func_arg3, 2);
#line 551
  return (ldv_func_res);
}
}
#line 554 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
void ldv_flush_workqueue_963(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 557
  flush_workqueue(ldv_func_arg1);
#line 559
  call_and_disable_all_2(2);
#line 560
  return;
}
}
#line 562 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
bool ldv_queue_delayed_work_on_964(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 566
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 566
  ldv_func_res = tmp;
#line 568
  activate_work_2(& ldv_func_arg3->work, 2);
#line 570
  return (ldv_func_res);
}
}
#line 573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
void ldv_mutex_lock_965(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 576
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 578
  mutex_lock(ldv_func_arg1);
#line 579
  return;
}
}
#line 581 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
void ldv_mutex_unlock_966(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 584
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 586
  mutex_unlock(ldv_func_arg1);
#line 587
  return;
}
}
#line 589 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
void ldv_mutex_lock_967(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 592
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 594
  mutex_lock(ldv_func_arg1);
#line 595
  return;
}
}
#line 597 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
int ldv_mutex_trylock_968(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 601
  tmp = mutex_trylock(ldv_func_arg1);
#line 601
  ldv_func_res = tmp;
#line 603
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 603
  return (tmp___0);
#line 605
  return (ldv_func_res);
}
}
#line 608 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
void ldv_mutex_unlock_969(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 611
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 613
  mutex_unlock(ldv_func_arg1);
#line 614
  return;
}
}
#line 616 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
void ldv_mutex_unlock_970(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 619
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 621
  mutex_unlock(ldv_func_arg1);
#line 622
  return;
}
}
#line 624 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
void ldv_mutex_lock_971(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 627
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 629
  mutex_lock(ldv_func_arg1);
#line 630
  return;
}
}
#line 632 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
void ldv_mutex_unlock_972(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 635
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 637
  mutex_unlock(ldv_func_arg1);
#line 638
  return;
}
}
#line 640 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
void ldv_mutex_lock_973(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 643
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 645
  mutex_lock(ldv_func_arg1);
#line 646
  return;
}
}
#line 648 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
void ldv_mutex_unlock_974(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 651
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 653
  mutex_unlock(ldv_func_arg1);
#line 654
  return;
}
}
#line 656 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
void ldv_mutex_lock_975(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 659
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 661
  mutex_lock(ldv_func_arg1);
#line 662
  return;
}
}
#line 664 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
int ldv_mutex_lock_interruptible_976(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 668
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 668
  ldv_func_res = tmp;
#line 670
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 670
  return (tmp___0);
#line 672
  return (ldv_func_res);
}
}
#line 675 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
int ldv_mutex_trylock_977(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 679
  tmp = mutex_trylock(ldv_func_arg1);
#line 679
  ldv_func_res = tmp;
#line 681
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 681
  return (tmp___0);
#line 683
  return (ldv_func_res);
}
}
#line 707 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
void ldv_mutex_unlock_980(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 710
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 712
  mutex_unlock(ldv_func_arg1);
#line 713
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_1013(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_1022(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_1011(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_1014(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_1015(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_1018(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_1019(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_1025(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
int ldv_mutex_lock_interruptible_1021(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_1010(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_1012(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_1016(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_1017(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_1020(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_1005(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_1007(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_1006(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_1009(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_1008(struct workqueue_struct *ldv_func_arg1 ) ;
#line 215 "./arch/x86/include/asm/io.h"
__inline static void memcpy_fromio(void *dst , void const volatile   *src , size_t count ) 
{ 


  {
#line 217
  memcpy(dst, (void const   *)src, count);
#line 218
  return;
}
}
#line 1086 "include/linux/device.h"
extern void dev_warn(struct device  const  * , char const   *  , ...) ;
#line 20 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/mid_bios.h"
int mid_chip_setup(struct drm_device *dev ) ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c"
static void mid_get_fuse_settings(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct pci_dev *pci_root ;
  struct pci_dev *tmp ;
  uint32_t fuse_value ;
  uint32_t fuse_value_tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;
  struct _ddebug descriptor___0 ;
  long tmp___2 ;

  {
#line 34
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 35
  tmp = pci_get_bus_and_slot(0U, 0U);
#line 35
  pci_root = tmp;
#line 36
  fuse_value = 0U;
#line 37
  fuse_value_tmp = 0U;
#line 47
  if ((unsigned long )pci_root == (unsigned long )((struct pci_dev *)0)) {
#line 48
    __ret_warn_on = 1;
#line 48
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 48
    if (tmp___0 != 0L) {
#line 48
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c",
                         48);
    } else {

    }
#line 48
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 49
    return;
  } else {

  }
#line 53
  pci_write_config_dword((struct pci_dev  const  *)pci_root, 208, 3498116608U);
#line 54
  pci_read_config_dword((struct pci_dev  const  *)pci_root, 212, & fuse_value);
#line 57
  if (((int )(dev->pdev)->device & 65520) == 16640) {
#line 58
    dev_priv->iLVDS_enable = fuse_value & 2048U;
  } else {

  }
#line 60
  printk("\016[drm] internal display is %s\n", dev_priv->iLVDS_enable != 0U ? (char *)"LVDS display" : (char *)"MIPI display");
#line 64
  if (dev_priv->iLVDS_enable != 0U) {
#line 65
    dev_priv->is_lvds_on = 1;
#line 66
    dev_priv->is_mipi_on = 0;
  } else {
#line 68
    dev_priv->is_mipi_on = 1;
#line 69
    dev_priv->is_lvds_on = 0;
  }
#line 72
  dev_priv->video_device_fuse = fuse_value;
#line 74
  pci_write_config_dword((struct pci_dev  const  *)pci_root, 208, 3498117376U);
#line 75
  pci_read_config_dword((struct pci_dev  const  *)pci_root, 212, & fuse_value);
#line 77
  descriptor.modname = "gma500_gfx";
#line 77
  descriptor.function = "mid_get_fuse_settings";
#line 77
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c";
#line 77
  descriptor.format = "SKU values is 0x%x.\n";
#line 77
  descriptor.lineno = 77U;
#line 77
  descriptor.flags = 0U;
#line 77
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 77
  if (tmp___1 != 0L) {
#line 77
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "SKU values is 0x%x.\n",
                      fuse_value);
  } else {

  }
#line 78
  fuse_value_tmp = (fuse_value & 28672U) >> 12;
#line 80
  dev_priv->fuse_reg_value = fuse_value;
#line 82
  switch (fuse_value_tmp) {
  case 0U: 
#line 84
  dev_priv->core_freq = 200U;
#line 85
  goto ldv_41880;
  case 1U: 
#line 87
  dev_priv->core_freq = 100U;
#line 88
  goto ldv_41880;
  case 2U: 
#line 90
  dev_priv->core_freq = 166U;
#line 91
  goto ldv_41880;
  default: 
#line 93
  dev_warn((struct device  const  *)dev->dev, "Invalid SKU values, SKU value = 0x%08x\n",
           fuse_value_tmp);
#line 95
  dev_priv->core_freq = 0U;
  }
  ldv_41880: 
#line 97
  descriptor___0.modname = "gma500_gfx";
#line 97
  descriptor___0.function = "mid_get_fuse_settings";
#line 97
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c";
#line 97
  descriptor___0.format = "LNC core clk is %dMHz.\n";
#line 97
  descriptor___0.lineno = 97U;
#line 97
  descriptor___0.flags = 0U;
#line 97
  tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 97
  if (tmp___2 != 0L) {
#line 97
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)dev->dev, "LNC core clk is %dMHz.\n",
                      dev_priv->core_freq);
  } else {

  }
#line 98
  pci_dev_put(pci_root);
#line 99
  return;
}
}
#line 104 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c"
static void mid_get_pci_revID(struct drm_psb_private *dev_priv ) 
{ 
  uint32_t platform_rev_id ;
  struct pci_dev *pci_gfx_root ;
  struct pci_dev *tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;

  {
#line 106
  platform_rev_id = 0U;
#line 107
  tmp = pci_get_bus_and_slot(0U, 16U);
#line 107
  pci_gfx_root = tmp;
#line 109
  if ((unsigned long )pci_gfx_root == (unsigned long )((struct pci_dev *)0)) {
#line 110
    __ret_warn_on = 1;
#line 110
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 110
    if (tmp___0 != 0L) {
#line 110
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c",
                         110);
    } else {

    }
#line 110
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 111
    return;
  } else {

  }
#line 113
  pci_read_config_dword((struct pci_dev  const  *)pci_gfx_root, 8, & platform_rev_id);
#line 114
  dev_priv->platform_rev_id = (unsigned char )platform_rev_id;
#line 115
  pci_dev_put(pci_gfx_root);
#line 116
  descriptor.modname = "gma500_gfx";
#line 116
  descriptor.function = "mid_get_pci_revID";
#line 116
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c";
#line 116
  descriptor.format = "platform_rev_id is %x\n";
#line 116
  descriptor.lineno = 117U;
#line 116
  descriptor.flags = 0U;
#line 116
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 116
  if (tmp___1 != 0L) {
#line 116
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)(dev_priv->dev)->dev,
                      "platform_rev_id is %x\n", (int )dev_priv->platform_rev_id);
  } else {

  }
#line 118
  return;
}
}
#line 142 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c"
static int read_vbt_r0(u32 addr , struct vbt_r0 *vbt ) 
{ 
  void *vbt_virtual ;

  {
#line 146
  vbt_virtual = ioremap((resource_size_t )addr, 7UL);
#line 147
  if ((unsigned long )vbt_virtual == (unsigned long )((void *)0)) {
#line 148
    return (-1);
  } else {

  }
#line 150
  memcpy_fromio((void *)vbt, (void const volatile   *)vbt_virtual, 7UL);
#line 151
  iounmap((void volatile   *)vbt_virtual);
#line 153
  return (0);
}
}
#line 156 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c"
static int read_vbt_r10(u32 addr , struct vbt_r10 *vbt ) 
{ 
  void *vbt_virtual ;

  {
#line 160
  vbt_virtual = ioremap((resource_size_t )addr, 16UL);
#line 161
  if ((unsigned long )vbt_virtual == (unsigned long )((void *)0)) {
#line 162
    return (-1);
  } else {

  }
#line 164
  memcpy_fromio((void *)vbt, (void const volatile   *)vbt_virtual, 16UL);
#line 165
  iounmap((void volatile   *)vbt_virtual);
#line 167
  return (0);
}
}
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c"
static int mid_get_vbt_data_r0(struct drm_psb_private *dev_priv , u32 addr ) 
{ 
  struct vbt_r0 vbt ;
  void *gct_virtual ;
  struct gct_r0 gct ;
  u8 bpi ;
  int tmp ;

  {
#line 177
  tmp = read_vbt_r0(addr, & vbt);
#line 177
  if (tmp != 0) {
#line 178
    return (-1);
  } else {

  }
#line 180
  gct_virtual = ioremap((resource_size_t )((unsigned long )addr + 7UL), (unsigned long )vbt.size - 7UL);
#line 181
  if ((unsigned long )gct_virtual == (unsigned long )((void *)0)) {
#line 182
    return (-1);
  } else {

  }
#line 183
  memcpy_fromio((void *)(& gct), (void const volatile   *)gct_virtual, 161UL);
#line 184
  iounmap((void volatile   *)gct_virtual);
#line 186
  bpi = gct.__annonCompField77.PD.BootPanelIndex;
#line 187
  dev_priv->gct_data.bpi = bpi;
#line 188
  dev_priv->gct_data.pt = gct.__annonCompField77.PD.PanelType;
#line 189
  dev_priv->gct_data.DTD = gct.panel[(int )bpi].DTD;
#line 190
  dev_priv->gct_data.Panel_Port_Control = gct.panel[(int )bpi].Panel_Port_Control;
#line 192
  dev_priv->gct_data.Panel_MIPI_Display_Descriptor = gct.panel[(int )bpi].Panel_MIPI_Display_Descriptor;
#line 195
  return (0);
}
}
#line 198 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c"
static int mid_get_vbt_data_r1(struct drm_psb_private *dev_priv , u32 addr ) 
{ 
  struct vbt_r0 vbt ;
  void *gct_virtual ;
  struct gct_r1 gct ;
  u8 bpi ;
  int tmp ;

  {
#line 205
  tmp = read_vbt_r0(addr, & vbt);
#line 205
  if (tmp != 0) {
#line 206
    return (-1);
  } else {

  }
#line 208
  gct_virtual = ioremap((resource_size_t )((unsigned long )addr + 7UL), (unsigned long )vbt.size - 7UL);
#line 209
  if ((unsigned long )gct_virtual == (unsigned long )((void *)0)) {
#line 210
    return (-1);
  } else {

  }
#line 211
  memcpy_fromio((void *)(& gct), (void const volatile   *)gct_virtual, 153UL);
#line 212
  iounmap((void volatile   *)gct_virtual);
#line 214
  bpi = gct.__annonCompField78.PD.BootPanelIndex;
#line 215
  dev_priv->gct_data.bpi = bpi;
#line 216
  dev_priv->gct_data.pt = gct.__annonCompField78.PD.PanelType;
#line 217
  dev_priv->gct_data.DTD = gct.panel[(int )bpi].DTD;
#line 218
  dev_priv->gct_data.Panel_Port_Control = gct.panel[(int )bpi].Panel_Port_Control;
#line 220
  dev_priv->gct_data.Panel_MIPI_Display_Descriptor = gct.panel[(int )bpi].Panel_MIPI_Display_Descriptor;
#line 223
  return (0);
}
}
#line 226 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c"
static int mid_get_vbt_data_r10(struct drm_psb_private *dev_priv , u32 addr ) 
{ 
  struct vbt_r10 vbt ;
  void *gct_virtual ;
  struct gct_r10 *gct ;
  struct oaktrail_timing_info *dp_ti ;
  struct gct_r10_timing_info *ti ;
  int ret ;
  int tmp ;
  void *tmp___0 ;

  {
#line 231
  dp_ti = & dev_priv->gct_data.DTD;
#line 233
  ret = -1;
#line 235
  tmp = read_vbt_r10(addr, & vbt);
#line 235
  if (tmp != 0) {
#line 236
    return (-1);
  } else {

  }
#line 238
  tmp___0 = kmalloc((unsigned long )vbt.panel_count * 28UL, 208U);
#line 238
  gct = (struct gct_r10 *)tmp___0;
#line 239
  if ((unsigned long )gct == (unsigned long )((struct gct_r10 *)0)) {
#line 240
    return (-1);
  } else {

  }
#line 242
  gct_virtual = ioremap((resource_size_t )((unsigned long )addr + 16UL), (unsigned long )vbt.panel_count * 28UL);
#line 244
  if ((unsigned long )gct_virtual == (unsigned long )((void *)0)) {
#line 245
    goto out;
  } else {

  }
#line 246
  memcpy_fromio((void *)gct, (void const volatile   *)gct_virtual, 28UL);
#line 247
  iounmap((void volatile   *)gct_virtual);
#line 249
  dev_priv->gct_data.bpi = vbt.primary_panel_idx;
#line 250
  dev_priv->gct_data.Panel_MIPI_Display_Descriptor = (gct + (unsigned long )vbt.primary_panel_idx)->Panel_MIPI_Display_Descriptor;
#line 253
  ti = & (gct + (unsigned long )vbt.primary_panel_idx)->DTD;
#line 254
  dp_ti->pixel_clock = ti->pixel_clock;
#line 255
  dp_ti->hactive_hi = ti->hactive_hi;
#line 256
  dp_ti->hactive_lo = ti->hactive_lo;
#line 257
  dp_ti->hblank_hi = ti->hblank_hi;
#line 258
  dp_ti->hblank_lo = ti->hblank_lo;
#line 259
  dp_ti->hsync_offset_hi = ti->hsync_offset_hi;
#line 260
  dp_ti->hsync_offset_lo = ti->hsync_offset_lo;
#line 261
  dp_ti->hsync_pulse_width_hi = ti->hsync_pulse_width_hi;
#line 262
  dp_ti->hsync_pulse_width_lo = ti->hsync_pulse_width_lo;
#line 263
  dp_ti->vactive_hi = ti->vactive_hi;
#line 264
  dp_ti->vactive_lo = ti->vactive_lo;
#line 265
  dp_ti->vblank_hi = ti->vblank_hi;
#line 266
  dp_ti->vblank_lo = ti->vblank_lo;
#line 267
  dp_ti->vsync_offset_hi = ti->vsync_offset_hi;
#line 268
  dp_ti->vsync_offset_lo = ti->vsync_offset_lo;
#line 269
  dp_ti->vsync_pulse_width_hi = ti->vsync_pulse_width_hi;
#line 270
  dp_ti->vsync_pulse_width_lo = ti->vsync_pulse_width_lo;
#line 272
  ret = 0;
  out: 
#line 274
  kfree((void const   *)gct);
#line 275
  return (ret);
}
}
#line 278 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c"
static void mid_get_vbt_data(struct drm_psb_private *dev_priv ) 
{ 
  struct drm_device *dev ;
  u32 addr ;
  u8 *vbt_virtual ;
  struct mid_vbt_header vbt_header ;
  struct pci_dev *pci_gfx_root ;
  struct pci_dev *tmp ;
  int ret ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  struct _ddebug descriptor___0 ;
  long tmp___3 ;

  {
#line 280
  dev = dev_priv->dev;
#line 284
  tmp = pci_get_bus_and_slot(0U, 16U);
#line 284
  pci_gfx_root = tmp;
#line 285
  ret = -1;
#line 288
  pci_read_config_dword((struct pci_dev  const  *)pci_gfx_root, 252, & addr);
#line 289
  pci_dev_put(pci_gfx_root);
#line 291
  descriptor.modname = "gma500_gfx";
#line 291
  descriptor.function = "mid_get_vbt_data";
#line 291
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c";
#line 291
  descriptor.format = "drm platform config address is %x\n";
#line 291
  descriptor.lineno = 291U;
#line 291
  descriptor.flags = 0U;
#line 291
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 291
  if (tmp___0 != 0L) {
#line 291
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "drm platform config address is %x\n",
                      addr);
  } else {

  }
#line 293
  if (addr == 0U) {
#line 294
    goto out;
  } else {

  }
#line 297
  tmp___1 = ioremap((resource_size_t )addr, 5UL);
#line 297
  vbt_virtual = (u8 *)tmp___1;
#line 298
  if ((unsigned long )vbt_virtual == (unsigned long )((u8 *)0U)) {
#line 299
    goto out;
  } else {

  }
#line 301
  memcpy_fromio((void *)(& vbt_header), (void const volatile   *)vbt_virtual, 5UL);
#line 302
  iounmap((void volatile   *)vbt_virtual);
#line 304
  tmp___2 = memcmp((void const   *)(& vbt_header.signature), (void const   *)"$GCT",
                   4UL);
#line 304
  if (tmp___2 != 0) {
#line 305
    goto out;
  } else {

  }
#line 307
  descriptor___0.modname = "gma500_gfx";
#line 307
  descriptor___0.function = "mid_get_vbt_data";
#line 307
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c";
#line 307
  descriptor___0.format = "GCT revision is %02x\n";
#line 307
  descriptor___0.lineno = 307U;
#line 307
  descriptor___0.flags = 0U;
#line 307
  tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 307
  if (tmp___3 != 0L) {
#line 307
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)dev->dev, "GCT revision is %02x\n",
                      (int )vbt_header.revision);
  } else {

  }
#line 309
  switch ((int )vbt_header.revision) {
  case 0: 
#line 311
  ret = mid_get_vbt_data_r0(dev_priv, addr);
#line 312
  goto ldv_41960;
  case 1: 
#line 314
  ret = mid_get_vbt_data_r1(dev_priv, addr);
#line 315
  goto ldv_41960;
  case 16: 
#line 317
  ret = mid_get_vbt_data_r10(dev_priv, addr);
#line 318
  goto ldv_41960;
  default: 
#line 320
  dev_err((struct device  const  *)dev->dev, "Unknown revision of GCT!\n");
  }
  ldv_41960: ;
  out: ;
#line 324
  if (ret != 0) {
#line 325
    dev_err((struct device  const  *)dev->dev, "Unable to read GCT!");
  } else {
#line 327
    dev_priv->has_gct = 1;
  }
#line 328
  return;
}
}
#line 330 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c"
int mid_chip_setup(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 332
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 333
  mid_get_fuse_settings(dev);
#line 334
  mid_get_vbt_data(dev_priv);
#line 335
  mid_get_pci_revID(dev_priv);
#line 336
  return (0);
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
bool ldv_queue_work_on_1005(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 432
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 432
  ldv_func_res = tmp;
#line 434
  activate_work_2(ldv_func_arg3, 2);
#line 436
  return (ldv_func_res);
}
}
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
bool ldv_queue_delayed_work_on_1006(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 443
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 443
  ldv_func_res = tmp;
#line 445
  activate_work_2(& ldv_func_arg3->work, 2);
#line 447
  return (ldv_func_res);
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
bool ldv_queue_work_on_1007(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 454
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 454
  ldv_func_res = tmp;
#line 456
  activate_work_2(ldv_func_arg3, 2);
#line 458
  return (ldv_func_res);
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
void ldv_flush_workqueue_1008(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 464
  flush_workqueue(ldv_func_arg1);
#line 466
  call_and_disable_all_2(2);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
bool ldv_queue_delayed_work_on_1009(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 473
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 473
  ldv_func_res = tmp;
#line 475
  activate_work_2(& ldv_func_arg3->work, 2);
#line 477
  return (ldv_func_res);
}
}
#line 480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
void ldv_mutex_lock_1010(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 483
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 485
  mutex_lock(ldv_func_arg1);
#line 486
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
void ldv_mutex_unlock_1011(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 491
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 493
  mutex_unlock(ldv_func_arg1);
#line 494
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
void ldv_mutex_lock_1012(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 499
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 501
  mutex_lock(ldv_func_arg1);
#line 502
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
int ldv_mutex_trylock_1013(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 508
  tmp = mutex_trylock(ldv_func_arg1);
#line 508
  ldv_func_res = tmp;
#line 510
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 510
  return (tmp___0);
#line 512
  return (ldv_func_res);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
void ldv_mutex_unlock_1014(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 518
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 520
  mutex_unlock(ldv_func_arg1);
#line 521
  return;
}
}
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
void ldv_mutex_unlock_1015(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 526
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 528
  mutex_unlock(ldv_func_arg1);
#line 529
  return;
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
void ldv_mutex_lock_1016(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 534
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 536
  mutex_lock(ldv_func_arg1);
#line 537
  return;
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
void ldv_mutex_lock_1017(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 542
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 544
  mutex_lock(ldv_func_arg1);
#line 545
  return;
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
void ldv_mutex_unlock_1018(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 550
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 552
  mutex_unlock(ldv_func_arg1);
#line 553
  return;
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
void ldv_mutex_unlock_1019(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 558
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 560
  mutex_unlock(ldv_func_arg1);
#line 561
  return;
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
void ldv_mutex_lock_1020(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 566
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 568
  mutex_lock(ldv_func_arg1);
#line 569
  return;
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
int ldv_mutex_lock_interruptible_1021(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 575
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 575
  ldv_func_res = tmp;
#line 577
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 577
  return (tmp___0);
#line 579
  return (ldv_func_res);
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
int ldv_mutex_trylock_1022(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 586
  tmp = mutex_trylock(ldv_func_arg1);
#line 586
  ldv_func_res = tmp;
#line 588
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 588
  return (tmp___0);
#line 590
  return (ldv_func_res);
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
void ldv_mutex_unlock_1025(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 617
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 619
  mutex_unlock(ldv_func_arg1);
#line 620
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 25 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 280 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_1058(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_1067(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_1056(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_1059(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_1060(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_1063(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_1064(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_1070(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
int ldv_mutex_lock_interruptible_1066(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_1055(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_1057(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_1061(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_1062(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_1065(struct mutex *ldv_func_arg1 ) ;
#line 181 "include/linux/workqueue.h"
extern void __init_work(struct work_struct * , int  ) ;
#line 352
extern struct workqueue_struct *system_wq ;
#line 433
bool ldv_queue_work_on_1050(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_1052(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_1051(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_1054(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_1053(struct workqueue_struct *ldv_func_arg1 ) ;
#line 464
extern bool cancel_work_sync(struct work_struct * ) ;
#line 467
bool ldv_cancel_work_sync_1071(struct work_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_1050(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 528 "include/linux/workqueue.h"
__inline static bool schedule_work(struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 530
  tmp = queue_work(system_wq, work);
#line 530
  return (tmp);
}
}
#line 183 "./arch/x86/include/asm/io.h"
extern void *ioremap_cache(resource_size_t  , unsigned long  ) ;
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void invoke_work_2(void) ;
#line 387
void disable_work_2(struct work_struct *work ) ;
#line 401
void call_and_disable_work_2(struct work_struct *work ) ;
#line 482 "include/acpi/acpi_bus.h"
extern int register_acpi_notifier(struct notifier_block * ) ;
#line 483
extern int unregister_acpi_notifier(struct notifier_block * ) ;
#line 9 "include/acpi/acpi_io.h"
__inline static void *acpi_os_ioremap(acpi_physical_address phys , acpi_size size ) 
{ 
  void *tmp ;

  {
#line 12
  tmp = ioremap_cache(phys, (unsigned long )size);
#line 12
  return (tmp);
}
}
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.c"
static struct psb_intel_opregion *system_opregion  ;
#line 148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.c"
static u32 asle_set_backlight(struct drm_device *dev , u32 bclp ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct opregion_asle *asle ;
  struct backlight_device *bd ;
  long tmp ;

  {
#line 150
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 151
  asle = dev_priv->opregion.asle;
#line 152
  bd = dev_priv->backlight_device;
#line 154
  tmp = ldv__builtin_expect((drm_debug & 2U) != 0U, 0L);
#line 154
  if (tmp != 0L) {
#line 154
    drm_ut_debug_printk("asle_set_backlight", "asle set backlight %x\n", bclp);
  } else {

  }
#line 156
  if ((int )bclp >= 0) {
#line 157
    return (4096U);
  } else {

  }
#line 159
  if ((unsigned long )bd == (unsigned long )((struct backlight_device *)0)) {
#line 160
    return (4096U);
  } else {

  }
#line 162
  bclp = bclp & 2147483647U;
#line 163
  if (bclp > 255U) {
#line 164
    return (4096U);
  } else {

  }
#line 171
  asle->cblv = (bclp * 100U) / 255U | 2147483648U;
#line 173
  return (0U);
}
}
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.c"
static void psb_intel_opregion_asle_work(struct work_struct *work ) 
{ 
  struct psb_intel_opregion *opregion ;
  struct work_struct  const  *__mptr ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_opregion  const  *__mptr___0 ;
  struct opregion_asle *asle ;
  u32 asle_stat ;
  u32 asle_req ;
  long tmp ;
  u32 tmp___0 ;

  {
#line 179
  __mptr = (struct work_struct  const  *)work;
#line 179
  opregion = (struct psb_intel_opregion *)__mptr + 0xffffffffffffffd0UL;
#line 181
  __mptr___0 = (struct psb_intel_opregion  const  *)opregion;
#line 181
  dev_priv = (struct drm_psb_private *)__mptr___0 + 0xffffffffffffed40UL;
#line 182
  asle = opregion->asle;
#line 183
  asle_stat = 0U;
#line 186
  if ((unsigned long )asle == (unsigned long )((struct opregion_asle *)0)) {
#line 187
    return;
  } else {

  }
#line 189
  asle_req = asle->aslc & 15U;
#line 190
  if (asle_req == 0U) {
#line 191
    tmp = ldv__builtin_expect((drm_debug & 2U) != 0U, 0L);
#line 191
    if (tmp != 0L) {
#line 191
      drm_ut_debug_printk("psb_intel_opregion_asle_work", "non asle set request??\n");
    } else {

    }
#line 192
    return;
  } else {

  }
#line 195
  if ((asle_req & 2U) != 0U) {
#line 196
    tmp___0 = asle_set_backlight(dev_priv->dev, asle->bclp);
#line 196
    asle_stat = tmp___0 | asle_stat;
  } else {

  }
#line 198
  asle->aslc = asle_stat;
#line 199
  return;
}
}
#line 202 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.c"
void psb_intel_opregion_asle_intr(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 204
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 206
  if ((unsigned long )dev_priv->opregion.asle != (unsigned long )((struct opregion_asle *)0)) {
#line 207
    schedule_work(& dev_priv->opregion.asle_work);
  } else {

  }
#line 208
  return;
}
}
#line 215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.c"
void psb_intel_opregion_enable_asle(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct opregion_asle *asle ;

  {
#line 217
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 218
  asle = dev_priv->opregion.asle;
#line 220
  if ((unsigned long )asle != (unsigned long )((struct opregion_asle *)0) && (unsigned long )system_opregion != (unsigned long )((struct psb_intel_opregion *)0)) {
#line 223
    psb_enable_pipestat(dev_priv, 0, 4194304U);
#line 224
    psb_enable_pipestat(dev_priv, 1, 4194304U);
#line 226
    asle->tche = 15U;
#line 228
    asle->ardy = 1U;
  } else {

  }
#line 230
  return;
}
}
#line 237 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.c"
static int psb_intel_opregion_video_event(struct notifier_block *nb , unsigned long val ,
                                          void *data ) 
{ 
  struct opregion_acpi *acpi ;

  {
#line 249
  if ((unsigned long )system_opregion == (unsigned long )((struct psb_intel_opregion *)0)) {
#line 250
    return (0);
  } else {

  }
#line 252
  acpi = system_opregion->acpi;
#line 253
  acpi->csts = 0U;
#line 255
  return (1);
}
}
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.c"
static struct notifier_block psb_intel_opregion_notifier  =    {& psb_intel_opregion_video_event, 0, 0};
#line 262 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.c"
void psb_intel_opregion_init(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_intel_opregion *opregion ;

  {
#line 264
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 265
  opregion = & dev_priv->opregion;
#line 267
  if ((unsigned long )opregion->header == (unsigned long )((struct opregion_header *)0)) {
#line 268
    return;
  } else {

  }
#line 270
  if ((unsigned long )opregion->acpi != (unsigned long )((struct opregion_acpi *)0)) {
#line 274
    (opregion->acpi)->csts = 0U;
#line 275
    (opregion->acpi)->drdy = 1U;
#line 277
    system_opregion = opregion;
#line 278
    register_acpi_notifier(& psb_intel_opregion_notifier);
  } else {

  }
#line 280
  return;
}
}
#line 282 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.c"
void psb_intel_opregion_fini(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_intel_opregion *opregion ;

  {
#line 284
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 285
  opregion = & dev_priv->opregion;
#line 287
  if ((unsigned long )opregion->header == (unsigned long )((struct opregion_header *)0)) {
#line 288
    return;
  } else {

  }
#line 290
  if ((unsigned long )opregion->acpi != (unsigned long )((struct opregion_acpi *)0)) {
#line 291
    (opregion->acpi)->drdy = 0U;
#line 293
    system_opregion = (struct psb_intel_opregion *)0;
#line 294
    unregister_acpi_notifier(& psb_intel_opregion_notifier);
  } else {

  }
#line 297
  ldv_cancel_work_sync_1071(& opregion->asle_work);
#line 300
  iounmap((void volatile   *)opregion->header);
#line 301
  opregion->header = (struct opregion_header *)0;
#line 302
  opregion->acpi = (struct opregion_acpi *)0;
#line 303
  opregion->swsci = (struct opregion_swsci *)0;
#line 304
  opregion->asle = (struct opregion_asle *)0;
#line 305
  opregion->vbt = (void *)0;
#line 306
  return;
}
}
#line 308 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.c"
int psb_intel_opregion_setup(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_intel_opregion *opregion ;
  u32 opregion_phy ;
  u32 mboxes ;
  void *base ;
  int err ;
  long tmp ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 310
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 311
  opregion = & dev_priv->opregion;
#line 314
  err = 0;
#line 316
  pci_read_config_dword((struct pci_dev  const  *)dev->pdev, 252, & opregion_phy);
#line 317
  if (opregion_phy == 0U) {
#line 318
    tmp = ldv__builtin_expect((drm_debug & 2U) != 0U, 0L);
#line 318
    if (tmp != 0L) {
#line 318
      drm_ut_debug_printk("psb_intel_opregion_setup", "ACPI Opregion not supported\n");
    } else {

    }
#line 319
    return (-524);
  } else {

  }
#line 322
  __init_work(& opregion->asle_work, 0);
#line 322
  __constr_expr_0.counter = 137438953408L;
#line 322
  opregion->asle_work.data = __constr_expr_0;
#line 322
  lockdep_init_map(& opregion->asle_work.lockdep_map, "(&opregion->asle_work)", & __key,
                   0);
#line 322
  INIT_LIST_HEAD(& opregion->asle_work.entry);
#line 322
  opregion->asle_work.func = & psb_intel_opregion_asle_work;
#line 324
  tmp___0 = ldv__builtin_expect((long )((int )drm_debug) & 1L, 0L);
#line 324
  if (tmp___0 != 0L) {
#line 324
    drm_ut_debug_printk("psb_intel_opregion_setup", "OpRegion detected at 0x%8x\n",
                        opregion_phy);
  } else {

  }
#line 325
  base = acpi_os_ioremap((acpi_physical_address )opregion_phy, 8192ULL);
#line 326
  if ((unsigned long )base == (unsigned long )((void *)0)) {
#line 327
    return (-12);
  } else {

  }
#line 329
  tmp___2 = memcmp((void const   *)base, (void const   *)"IntelGraphicsMem", 16UL);
#line 329
  if (tmp___2 != 0) {
#line 330
    tmp___1 = ldv__builtin_expect((drm_debug & 2U) != 0U, 0L);
#line 330
    if (tmp___1 != 0L) {
#line 330
      drm_ut_debug_printk("psb_intel_opregion_setup", "opregion signature mismatch\n");
    } else {

    }
#line 331
    err = -22;
#line 332
    goto err_out;
  } else {

  }
#line 335
  opregion->header = (struct opregion_header *)base;
#line 336
  opregion->vbt = base + 1024UL;
#line 338
  opregion->lid_state = (u32 *)base + 428U;
#line 340
  mboxes = (opregion->header)->mboxes;
#line 341
  if ((int )mboxes & 1) {
#line 342
    tmp___3 = ldv__builtin_expect((drm_debug & 2U) != 0U, 0L);
#line 342
    if (tmp___3 != 0L) {
#line 342
      drm_ut_debug_printk("psb_intel_opregion_setup", "Public ACPI methods supported\n");
    } else {

    }
#line 343
    opregion->acpi = (struct opregion_acpi *)base + 256U;
  } else {

  }
#line 346
  if ((mboxes & 4U) != 0U) {
#line 347
    tmp___4 = ldv__builtin_expect((drm_debug & 2U) != 0U, 0L);
#line 347
    if (tmp___4 != 0L) {
#line 347
      drm_ut_debug_printk("psb_intel_opregion_setup", "ASLE supported\n");
    } else {

    }
#line 348
    opregion->asle = (struct opregion_asle *)base + 768U;
  } else {

  }
#line 351
  return (0);
  err_out: 
#line 354
  iounmap((void volatile   *)base);
#line 355
  return (err);
}
}
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void call_and_disable_all_2(int state ) 
{ 


  {
#line 407
  if (ldv_work_2_0 == state) {
#line 408
    call_and_disable_work_2(ldv_work_struct_2_0);
  } else {

  }
#line 409
  if (ldv_work_2_1 == state) {
#line 410
    call_and_disable_work_2(ldv_work_struct_2_1);
  } else {

  }
#line 411
  if (ldv_work_2_2 == state) {
#line 412
    call_and_disable_work_2(ldv_work_struct_2_2);
  } else {

  }
#line 413
  if (ldv_work_2_3 == state) {
#line 414
    call_and_disable_work_2(ldv_work_struct_2_3);
  } else {

  }
#line 415
  return;
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void invoke_work_2(void) 
{ 
  int tmp ;

  {
#line 420
  tmp = __VERIFIER_nondet_int();
#line 420
  switch (tmp) {
  case 0: ;
#line 422
  if (ldv_work_2_0 == 2 || ldv_work_2_0 == 3) {
#line 423
    ldv_work_2_0 = 4;
#line 424
    psb_intel_opregion_asle_work(ldv_work_struct_2_0);
#line 425
    ldv_work_2_0 = 1;
  } else {

  }
#line 428
  goto ldv_45717;
  case 1: ;
#line 430
  if (ldv_work_2_1 == 2 || ldv_work_2_1 == 3) {
#line 431
    ldv_work_2_1 = 4;
#line 432
    psb_intel_opregion_asle_work(ldv_work_struct_2_0);
#line 433
    ldv_work_2_1 = 1;
  } else {

  }
#line 436
  goto ldv_45717;
  case 2: ;
#line 438
  if (ldv_work_2_2 == 2 || ldv_work_2_2 == 3) {
#line 439
    ldv_work_2_2 = 4;
#line 440
    psb_intel_opregion_asle_work(ldv_work_struct_2_0);
#line 441
    ldv_work_2_2 = 1;
  } else {

  }
#line 444
  goto ldv_45717;
  case 3: ;
#line 446
  if (ldv_work_2_3 == 2 || ldv_work_2_3 == 3) {
#line 447
    ldv_work_2_3 = 4;
#line 448
    psb_intel_opregion_asle_work(ldv_work_struct_2_0);
#line 449
    ldv_work_2_3 = 1;
  } else {

  }
#line 452
  goto ldv_45717;
  default: 
#line 453
  ldv_stop();
  }
  ldv_45717: ;
#line 455
  return;
}
}
#line 459 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void work_init_2(void) 
{ 


  {
#line 460
  ldv_work_2_0 = 0;
#line 461
  ldv_work_2_1 = 0;
#line 462
  ldv_work_2_2 = 0;
#line 463
  ldv_work_2_3 = 0;
#line 464
  return;
}
}
#line 467 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void activate_work_2(struct work_struct *work , int state ) 
{ 


  {
#line 468
  if (ldv_work_2_0 == 0) {
#line 469
    ldv_work_struct_2_0 = work;
#line 470
    ldv_work_2_0 = state;
#line 471
    return;
  } else {

  }
#line 474
  if (ldv_work_2_1 == 0) {
#line 475
    ldv_work_struct_2_1 = work;
#line 476
    ldv_work_2_1 = state;
#line 477
    return;
  } else {

  }
#line 480
  if (ldv_work_2_2 == 0) {
#line 481
    ldv_work_struct_2_2 = work;
#line 482
    ldv_work_2_2 = state;
#line 483
    return;
  } else {

  }
#line 486
  if (ldv_work_2_3 == 0) {
#line 487
    ldv_work_struct_2_3 = work;
#line 488
    ldv_work_2_3 = state;
#line 489
    return;
  } else {

  }
#line 491
  return;
}
}
#line 494 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void disable_work_2(struct work_struct *work ) 
{ 


  {
#line 496
  if ((ldv_work_2_0 == 3 || ldv_work_2_0 == 2) && (unsigned long )ldv_work_struct_2_0 == (unsigned long )work) {
#line 498
    ldv_work_2_0 = 1;
  } else {

  }
#line 500
  if ((ldv_work_2_1 == 3 || ldv_work_2_1 == 2) && (unsigned long )ldv_work_struct_2_1 == (unsigned long )work) {
#line 502
    ldv_work_2_1 = 1;
  } else {

  }
#line 504
  if ((ldv_work_2_2 == 3 || ldv_work_2_2 == 2) && (unsigned long )ldv_work_struct_2_2 == (unsigned long )work) {
#line 506
    ldv_work_2_2 = 1;
  } else {

  }
#line 508
  if ((ldv_work_2_3 == 3 || ldv_work_2_3 == 2) && (unsigned long )ldv_work_struct_2_3 == (unsigned long )work) {
#line 510
    ldv_work_2_3 = 1;
  } else {

  }
#line 511
  return;
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void call_and_disable_work_2(struct work_struct *work ) 
{ 


  {
#line 518
  if ((ldv_work_2_0 == 2 || ldv_work_2_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_0) {
#line 520
    psb_intel_opregion_asle_work(work);
#line 521
    ldv_work_2_0 = 1;
#line 522
    return;
  } else {

  }
#line 524
  if ((ldv_work_2_1 == 2 || ldv_work_2_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_1) {
#line 526
    psb_intel_opregion_asle_work(work);
#line 527
    ldv_work_2_1 = 1;
#line 528
    return;
  } else {

  }
#line 530
  if ((ldv_work_2_2 == 2 || ldv_work_2_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_2) {
#line 532
    psb_intel_opregion_asle_work(work);
#line 533
    ldv_work_2_2 = 1;
#line 534
    return;
  } else {

  }
#line 536
  if ((ldv_work_2_3 == 2 || ldv_work_2_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_3) {
#line 538
    psb_intel_opregion_asle_work(work);
#line 539
    ldv_work_2_3 = 1;
#line 540
    return;
  } else {

  }
#line 542
  return;
}
}
#line 545 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void ldv_main_exported_34(void) 
{ 
  unsigned long ldvarg194 ;
  struct notifier_block *ldvarg192 ;
  void *tmp ;
  void *ldvarg193 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 547
  tmp = ldv_init_zalloc(24UL);
#line 547
  ldvarg192 = (struct notifier_block *)tmp;
#line 548
  tmp___0 = ldv_init_zalloc(1UL);
#line 548
  ldvarg193 = tmp___0;
#line 546
  ldv_memset((void *)(& ldvarg194), 0, 8UL);
#line 550
  tmp___1 = __VERIFIER_nondet_int();
#line 550
  switch (tmp___1) {
  case 0: ;
#line 553
  if (ldv_state_variable_34 == 1) {
#line 555
    psb_intel_opregion_video_event(ldvarg192, ldvarg194, ldvarg193);
#line 557
    ldv_state_variable_34 = 1;
  } else {

  }
#line 560
  goto ldv_45744;
  default: 
#line 561
  ldv_stop();
  }
  ldv_45744: ;
#line 565
  return;
}
}
#line 590 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
bool ldv_queue_work_on_1050(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 594
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 594
  ldv_func_res = tmp;
#line 596
  activate_work_2(ldv_func_arg3, 2);
#line 598
  return (ldv_func_res);
}
}
#line 601 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
bool ldv_queue_delayed_work_on_1051(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 605
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 605
  ldv_func_res = tmp;
#line 607
  activate_work_2(& ldv_func_arg3->work, 2);
#line 609
  return (ldv_func_res);
}
}
#line 612 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
bool ldv_queue_work_on_1052(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 616
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 616
  ldv_func_res = tmp;
#line 618
  activate_work_2(ldv_func_arg3, 2);
#line 620
  return (ldv_func_res);
}
}
#line 623 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void ldv_flush_workqueue_1053(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 626
  flush_workqueue(ldv_func_arg1);
#line 628
  call_and_disable_all_2(2);
#line 629
  return;
}
}
#line 631 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
bool ldv_queue_delayed_work_on_1054(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 635
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 635
  ldv_func_res = tmp;
#line 637
  activate_work_2(& ldv_func_arg3->work, 2);
#line 639
  return (ldv_func_res);
}
}
#line 642 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void ldv_mutex_lock_1055(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 645
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 647
  mutex_lock(ldv_func_arg1);
#line 648
  return;
}
}
#line 650 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void ldv_mutex_unlock_1056(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 653
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 655
  mutex_unlock(ldv_func_arg1);
#line 656
  return;
}
}
#line 658 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void ldv_mutex_lock_1057(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 661
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 663
  mutex_lock(ldv_func_arg1);
#line 664
  return;
}
}
#line 666 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
int ldv_mutex_trylock_1058(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 670
  tmp = mutex_trylock(ldv_func_arg1);
#line 670
  ldv_func_res = tmp;
#line 672
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 672
  return (tmp___0);
#line 674
  return (ldv_func_res);
}
}
#line 677 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void ldv_mutex_unlock_1059(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 680
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 682
  mutex_unlock(ldv_func_arg1);
#line 683
  return;
}
}
#line 685 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void ldv_mutex_unlock_1060(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 688
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 690
  mutex_unlock(ldv_func_arg1);
#line 691
  return;
}
}
#line 693 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void ldv_mutex_lock_1061(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 696
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 698
  mutex_lock(ldv_func_arg1);
#line 699
  return;
}
}
#line 701 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void ldv_mutex_lock_1062(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 704
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 706
  mutex_lock(ldv_func_arg1);
#line 707
  return;
}
}
#line 709 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void ldv_mutex_unlock_1063(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 712
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 714
  mutex_unlock(ldv_func_arg1);
#line 715
  return;
}
}
#line 717 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void ldv_mutex_unlock_1064(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 720
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 722
  mutex_unlock(ldv_func_arg1);
#line 723
  return;
}
}
#line 725 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void ldv_mutex_lock_1065(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 728
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 730
  mutex_lock(ldv_func_arg1);
#line 731
  return;
}
}
#line 733 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
int ldv_mutex_lock_interruptible_1066(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 737
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 737
  ldv_func_res = tmp;
#line 739
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 739
  return (tmp___0);
#line 741
  return (ldv_func_res);
}
}
#line 744 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
int ldv_mutex_trylock_1067(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 748
  tmp = mutex_trylock(ldv_func_arg1);
#line 748
  ldv_func_res = tmp;
#line 750
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 750
  return (tmp___0);
#line 752
  return (ldv_func_res);
}
}
#line 776 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void ldv_mutex_unlock_1070(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 779
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 781
  mutex_unlock(ldv_func_arg1);
#line 782
  return;
}
}
#line 784 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
bool ldv_cancel_work_sync_1071(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  bool tmp ;

  {
#line 788
  tmp = cancel_work_sync(ldv_func_arg1);
#line 788
  ldv_func_res = tmp;
#line 790
  disable_work_2(ldv_func_arg1);
#line 792
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_1105(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_1114(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_1103(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_1106(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_1107(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_1109(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_1111(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_1117(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
int ldv_mutex_lock_interruptible_1113(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_1102(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_1104(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_1108(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_1110(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_1112(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_1097(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_1099(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_1098(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_1101(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_1100(struct workqueue_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work___0(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_1097(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 528 "include/linux/workqueue.h"
__inline static bool schedule_work___0(struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 530
  tmp = queue_work___0(system_wq, work);
#line 530
  return (tmp);
}
}
#line 320 "./arch/x86/include/asm/io.h"
__inline static void outb(unsigned char value , int port ) 
{ 


  {
#line 320
  __asm__  volatile   ("outb %b0, %w1": : "a" (value), "Nd" (port));
#line 321
  return;
}
}
#line 320 "./arch/x86/include/asm/io.h"
__inline static unsigned char inb(int port ) 
{ 
  unsigned char value ;

  {
#line 320
  __asm__  volatile   ("inb %w1, %b0": "=a" (value): "Nd" (port));
#line 320
  return (value);
}
}
#line 322 "./arch/x86/include/asm/io.h"
__inline static void outl(unsigned int value , int port ) 
{ 


  {
#line 322
  __asm__  volatile   ("outl %0, %w1": : "a" (value), "Nd" (port));
#line 323
  return;
}
}
#line 322 "./arch/x86/include/asm/io.h"
__inline static unsigned int inl(int port ) 
{ 
  unsigned int value ;

  {
#line 322
  __asm__  volatile   ("inl %w1, %0": "=a" (value): "Nd" (port));
#line 322
  return (value);
}
}
#line 343 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void activate_work_3(struct work_struct *work , int state ) ;
#line 349
void call_and_disable_work_3(struct work_struct *work ) ;
#line 351
void disable_work_3(struct work_struct *work ) ;
#line 391
void invoke_work_3(void) ;
#line 398
void call_and_disable_all_3(int state ) ;
#line 857 "include/linux/pci.h"
extern int pci_bus_read_config_byte(struct pci_bus * , unsigned int  , int  , u8 * ) ;
#line 863
extern int pci_bus_write_config_byte(struct pci_bus * , unsigned int  , int  , u8  ) ;
#line 881 "include/linux/pci.h"
__inline static int pci_read_config_byte(struct pci_dev  const  *dev , int where ,
                                         u8 *val ) 
{ 
  int tmp ;

  {
#line 883
  tmp = pci_bus_read_config_byte(dev->bus, dev->devfn, where, val);
#line 883
  return (tmp);
}
}
#line 894 "include/linux/pci.h"
__inline static int pci_write_config_byte(struct pci_dev  const  *dev , int where ,
                                          u8 val ) 
{ 
  int tmp ;

  {
#line 896
  tmp = pci_bus_write_config_byte(dev->bus, dev->devfn, where, (int )val);
#line 896
  return (tmp);
}
}
#line 1216
extern int pci_enable_msi_range(struct pci_dev * , int  , int  ) ;
#line 1217 "include/linux/pci.h"
__inline static int pci_enable_msi_exact(struct pci_dev *dev , int nvec ) 
{ 
  int rc ;
  int tmp ;

  {
#line 1219
  tmp = pci_enable_msi_range(dev, nvec, nvec);
#line 1219
  rc = tmp;
#line 1220
  if (rc < 0) {
#line 1221
    return (rc);
  } else {

  }
#line 1222
  return (0);
}
}
#line 1336 "include/drm/drm_crtc.h"
extern void drm_mode_config_reset(struct drm_device * ) ;
#line 215 "include/drm/drm_crtc_helper.h"
extern void drm_helper_resume_force_mode(struct drm_device * ) ;
#line 233
extern bool drm_helper_hpd_irq_event(struct drm_device * ) ;
#line 271 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
void cdv_intel_dp_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ,
                       int output_reg ) ;
#line 283
void cdv_intel_attach_force_audio_property(struct drm_connector *connector ) ;
#line 284
void cdv_intel_attach_broadcast_rgb_property(struct drm_connector *connector ) ;
#line 18 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/cdv_device.h"
struct drm_crtc_helper_funcs  const  cdv_intel_helper_funcs ;
#line 19
struct drm_crtc_funcs  const  cdv_intel_crtc_funcs ;
#line 20
struct gma_clock_funcs  const  cdv_clock_funcs ;
#line 21
void cdv_intel_crt_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) ;
#line 23
void cdv_intel_lvds_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) ;
#line 25
void cdv_hdmi_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ,
                   int reg ) ;
#line 29
void cdv_update_wm(struct drm_device *dev , struct drm_crtc *crtc ) ;
#line 30
void cdv_disable_sr(struct drm_device *dev ) ;
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.c"
static void cdv_disable_vga(struct drm_device *dev ) 
{ 
  u8 sr1 ;
  u32 vga_reg ;

  {
#line 39
  vga_reg = 463872U;
#line 41
  outb(1, 964);
#line 42
  sr1 = inb(965);
#line 43
  outb((int )((unsigned int )sr1 | 32U), 965);
#line 44
  __const_udelay(1288500UL);
#line 46
  REGISTER_WRITE(dev, vga_reg, 2147483648U);
#line 47
  REGISTER_READ(dev, vga_reg);
#line 48
  return;
}
}
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.c"
static int cdv_output_init(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 52
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 54
  drm_mode_create_scaling_mode_property(dev);
#line 56
  cdv_disable_vga(dev);
#line 58
  cdv_intel_crt_init(dev, & dev_priv->mode_dev);
#line 59
  cdv_intel_lvds_init(dev, & dev_priv->mode_dev);
#line 62
  tmp___0 = REGISTER_READ(dev, 397632U);
#line 62
  if ((tmp___0 & 4U) != 0U) {
#line 63
    cdv_hdmi_init(dev, & dev_priv->mode_dev, 397632);
#line 64
    tmp = REGISTER_READ(dev, 409856U);
#line 64
    if ((tmp & 4U) != 0U) {
#line 65
      cdv_intel_dp_init(dev, & dev_priv->mode_dev, 409856);
    } else {

    }
  } else {

  }
#line 68
  tmp___2 = REGISTER_READ(dev, 397664U);
#line 68
  if ((tmp___2 & 4U) != 0U) {
#line 69
    cdv_hdmi_init(dev, & dev_priv->mode_dev, 397664);
#line 70
    tmp___1 = REGISTER_READ(dev, 410112U);
#line 70
    if ((tmp___1 & 4U) != 0U) {
#line 71
      cdv_intel_dp_init(dev, & dev_priv->mode_dev, 410112);
    } else {

    }
  } else {

  }
#line 73
  return (0);
}
}
#line 188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.c"
__inline static u32 CDV_MSG_READ32(uint port , uint offset ) 
{ 
  int mcr ;
  uint32_t ret_val ;
  struct pci_dev *pci_root ;
  struct pci_dev *tmp ;

  {
#line 190
  mcr = (int )(((port << 16) | (offset << 8)) | 268435456U);
#line 191
  ret_val = 0U;
#line 192
  tmp = pci_get_bus_and_slot(0U, 0U);
#line 192
  pci_root = tmp;
#line 193
  pci_write_config_dword((struct pci_dev  const  *)pci_root, 208, (u32 )mcr);
#line 194
  pci_read_config_dword((struct pci_dev  const  *)pci_root, 212, & ret_val);
#line 195
  pci_dev_put(pci_root);
#line 196
  return (ret_val);
}
}
#line 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.c"
__inline static void CDV_MSG_WRITE32(uint port , uint offset , u32 value ) 
{ 
  int mcr ;
  struct pci_dev *pci_root ;
  struct pci_dev *tmp ;

  {
#line 201
  mcr = (int )(((port << 16) | (offset << 8)) | 285212912U);
#line 202
  tmp = pci_get_bus_and_slot(0U, 0U);
#line 202
  pci_root = tmp;
#line 203
  pci_write_config_dword((struct pci_dev  const  *)pci_root, 212, value);
#line 204
  pci_write_config_dword((struct pci_dev  const  *)pci_root, 208, (u32 )mcr);
#line 205
  pci_dev_put(pci_root);
#line 206
  return;
}
}
#line 215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.c"
static void cdv_init_pm(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 pwr_cnt ;
  int i ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 pwr_sts ;
  unsigned int tmp___1 ;

  {
#line 217
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 221
  tmp = CDV_MSG_READ32(4U, 122U);
#line 221
  dev_priv->apm_base = (uint16_t )tmp;
#line 223
  tmp___0 = CDV_MSG_READ32(4U, 120U);
#line 223
  dev_priv->ospm_base = tmp___0 & 65535U;
#line 227
  pwr_cnt = inl((int )dev_priv->apm_base);
#line 230
  pwr_cnt = pwr_cnt & 4294967292U;
#line 231
  pwr_cnt = pwr_cnt | 2U;
#line 232
  outl(pwr_cnt, (int )dev_priv->apm_base);
#line 235
  i = 0;
#line 235
  goto ldv_41948;
  ldv_41947: 
#line 236
  tmp___1 = inl((int )dev_priv->apm_base + 4);
#line 236
  pwr_sts = tmp___1;
#line 237
  if ((pwr_sts & 3U) == 0U) {
#line 238
    return;
  } else {

  }
#line 239
  __const_udelay(42950UL);
#line 235
  i = i + 1;
  ldv_41948: ;
#line 235
  if (i <= 4) {
#line 237
    goto ldv_41947;
  } else {

  }
#line 241
  dev_err((struct device  const  *)dev->dev, "GPU: power management timed out.\n");
#line 242
  return;
}
}
#line 244 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.c"
static void cdv_errata(struct drm_device *dev ) 
{ 


  {
#line 254
  CDV_MSG_WRITE32(3U, 48U, 134377736U);
#line 255
  return;
}
}
#line 264 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.c"
static int cdv_save_display_registers(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_save_area *regs ;
  struct drm_connector *connector ;
  struct _ddebug descriptor ;
  long tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 266
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 267
  regs = & dev_priv->regs;
#line 270
  descriptor.modname = "gma500_gfx";
#line 270
  descriptor.function = "cdv_save_display_registers";
#line 270
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.c";
#line 270
  descriptor.format = "Saving GPU registers.\n";
#line 270
  descriptor.lineno = 270U;
#line 270
  descriptor.flags = 0U;
#line 270
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 270
  if (tmp != 0L) {
#line 270
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "Saving GPU registers.\n");
  } else {

  }
#line 272
  pci_read_config_byte((struct pci_dev  const  *)dev->pdev, 244, & regs->__annonCompField80.cdv.saveLBB);
#line 274
  regs->__annonCompField80.cdv.saveDSPCLK_GATE_D = REGISTER_READ(dev, 25088U);
#line 275
  regs->__annonCompField80.cdv.saveRAMCLK_GATE_D = REGISTER_READ(dev, 25104U);
#line 277
  regs->__annonCompField80.cdv.saveDSPARB = REGISTER_READ(dev, 458800U);
#line 278
  regs->__annonCompField80.cdv.saveDSPFW[0] = REGISTER_READ(dev, 458804U);
#line 279
  regs->__annonCompField80.cdv.saveDSPFW[1] = REGISTER_READ(dev, 458808U);
#line 280
  regs->__annonCompField80.cdv.saveDSPFW[2] = REGISTER_READ(dev, 458812U);
#line 281
  regs->__annonCompField80.cdv.saveDSPFW[3] = REGISTER_READ(dev, 458832U);
#line 282
  regs->__annonCompField80.cdv.saveDSPFW[4] = REGISTER_READ(dev, 458836U);
#line 283
  regs->__annonCompField80.cdv.saveDSPFW[5] = REGISTER_READ(dev, 458840U);
#line 285
  regs->__annonCompField80.cdv.saveADPA = REGISTER_READ(dev, 397568U);
#line 287
  regs->__annonCompField80.cdv.savePP_CONTROL = REGISTER_READ(dev, 397828U);
#line 288
  regs->__annonCompField80.cdv.savePFIT_PGM_RATIOS = REGISTER_READ(dev, 397876U);
#line 289
  regs->saveBLC_PWM_CTL = REGISTER_READ(dev, 397908U);
#line 290
  regs->saveBLC_PWM_CTL2 = REGISTER_READ(dev, 397904U);
#line 291
  regs->__annonCompField80.cdv.saveLVDS = REGISTER_READ(dev, 397696U);
#line 293
  regs->__annonCompField80.cdv.savePFIT_CONTROL = REGISTER_READ(dev, 397872U);
#line 295
  regs->__annonCompField80.cdv.savePP_ON_DELAYS = REGISTER_READ(dev, 397832U);
#line 296
  regs->__annonCompField80.cdv.savePP_OFF_DELAYS = REGISTER_READ(dev, 397836U);
#line 297
  regs->__annonCompField80.cdv.savePP_CYCLE = REGISTER_READ(dev, 397840U);
#line 299
  regs->__annonCompField80.cdv.saveVGACNTRL = REGISTER_READ(dev, 463872U);
#line 301
  regs->__annonCompField80.cdv.saveIER = REGISTER_READ(dev, 8352U);
#line 302
  regs->__annonCompField80.cdv.saveIMR = REGISTER_READ(dev, 8360U);
#line 304
  __mptr = (struct list_head  const  *)dev->mode_config.connector_list.next;
#line 304
  connector = (struct drm_connector *)__mptr + 0xffffffffffffffe8UL;
#line 304
  goto ldv_41966;
  ldv_41965: 
#line 305
  (*((connector->funcs)->dpms))(connector, 3);
#line 304
  __mptr___0 = (struct list_head  const  *)connector->head.next;
#line 304
  connector = (struct drm_connector *)__mptr___0 + 0xffffffffffffffe8UL;
  ldv_41966: ;
#line 304
  if ((unsigned long )(& connector->head) != (unsigned long )(& dev->mode_config.connector_list)) {
#line 306
    goto ldv_41965;
  } else {

  }

#line 307
  return (0);
}
}
#line 318 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.c"
static int cdv_restore_display_registers(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_save_area *regs ;
  struct drm_connector *connector ;
  u32 temp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 320
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 321
  regs = & dev_priv->regs;
#line 325
  pci_write_config_byte((struct pci_dev  const  *)dev->pdev, 244, (int )regs->__annonCompField80.cdv.saveLBB);
#line 327
  REGISTER_WRITE(dev, 25088U, regs->__annonCompField80.cdv.saveDSPCLK_GATE_D);
#line 328
  REGISTER_WRITE(dev, 25104U, regs->__annonCompField80.cdv.saveRAMCLK_GATE_D);
#line 331
  REGISTER_WRITE(dev, 8464U, 0U);
#line 332
  REGISTER_WRITE(dev, 8464U, 5U);
#line 334
  temp = REGISTER_READ(dev, 24596U);
#line 335
  if ((temp & 536870912U) == 0U) {
#line 336
    REGISTER_WRITE(dev, 24596U, temp | 536870912U);
#line 337
    REGISTER_READ(dev, 24596U);
  } else {

  }
#line 340
  temp = REGISTER_READ(dev, 24600U);
#line 341
  if ((temp & 536870912U) == 0U) {
#line 342
    REGISTER_WRITE(dev, 24600U, temp | 536870912U);
#line 343
    REGISTER_READ(dev, 24600U);
  } else {

  }
#line 346
  __const_udelay(2147500UL);
#line 348
  REGISTER_WRITE(dev, 458804U, regs->__annonCompField80.cdv.saveDSPFW[0]);
#line 349
  REGISTER_WRITE(dev, 458808U, regs->__annonCompField80.cdv.saveDSPFW[1]);
#line 350
  REGISTER_WRITE(dev, 458812U, regs->__annonCompField80.cdv.saveDSPFW[2]);
#line 351
  REGISTER_WRITE(dev, 458832U, regs->__annonCompField80.cdv.saveDSPFW[3]);
#line 352
  REGISTER_WRITE(dev, 458836U, regs->__annonCompField80.cdv.saveDSPFW[4]);
#line 353
  REGISTER_WRITE(dev, 458840U, regs->__annonCompField80.cdv.saveDSPFW[5]);
#line 355
  REGISTER_WRITE(dev, 458800U, regs->__annonCompField80.cdv.saveDSPARB);
#line 356
  REGISTER_WRITE(dev, 397568U, regs->__annonCompField80.cdv.saveADPA);
#line 358
  REGISTER_WRITE(dev, 397904U, regs->saveBLC_PWM_CTL2);
#line 359
  REGISTER_WRITE(dev, 397696U, regs->__annonCompField80.cdv.saveLVDS);
#line 360
  REGISTER_WRITE(dev, 397872U, regs->__annonCompField80.cdv.savePFIT_CONTROL);
#line 361
  REGISTER_WRITE(dev, 397876U, regs->__annonCompField80.cdv.savePFIT_PGM_RATIOS);
#line 362
  REGISTER_WRITE(dev, 397908U, regs->saveBLC_PWM_CTL);
#line 363
  REGISTER_WRITE(dev, 397832U, regs->__annonCompField80.cdv.savePP_ON_DELAYS);
#line 364
  REGISTER_WRITE(dev, 397836U, regs->__annonCompField80.cdv.savePP_OFF_DELAYS);
#line 365
  REGISTER_WRITE(dev, 397840U, regs->__annonCompField80.cdv.savePP_CYCLE);
#line 366
  REGISTER_WRITE(dev, 397828U, regs->__annonCompField80.cdv.savePP_CONTROL);
#line 368
  REGISTER_WRITE(dev, 463872U, regs->__annonCompField80.cdv.saveVGACNTRL);
#line 370
  REGISTER_WRITE(dev, 8352U, regs->__annonCompField80.cdv.saveIER);
#line 371
  REGISTER_WRITE(dev, 8360U, regs->__annonCompField80.cdv.saveIMR);
#line 374
  cdv_errata(dev);
#line 376
  drm_mode_config_reset(dev);
#line 378
  __mptr = (struct list_head  const  *)dev->mode_config.connector_list.next;
#line 378
  connector = (struct drm_connector *)__mptr + 0xffffffffffffffe8UL;
#line 378
  goto ldv_41980;
  ldv_41979: 
#line 379
  (*((connector->funcs)->dpms))(connector, 0);
#line 378
  __mptr___0 = (struct list_head  const  *)connector->head.next;
#line 378
  connector = (struct drm_connector *)__mptr___0 + 0xffffffffffffffe8UL;
  ldv_41980: ;
#line 378
  if ((unsigned long )(& connector->head) != (unsigned long )(& dev->mode_config.connector_list)) {
#line 380
    goto ldv_41979;
  } else {

  }
#line 382
  drm_helper_resume_force_mode(dev);
#line 383
  return (0);
}
}
#line 386 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.c"
static int cdv_power_down(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 pwr_cnt ;
  u32 pwr_mask ;
  u32 pwr_sts ;
  int tries ;
  int tmp ;

  {
#line 388
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 390
  tries = 5;
#line 392
  pwr_cnt = inl((int )dev_priv->apm_base);
#line 393
  pwr_cnt = pwr_cnt & 4294967292U;
#line 394
  pwr_cnt = pwr_cnt | 1U;
#line 395
  pwr_mask = 3U;
#line 397
  outl(pwr_cnt, (int )dev_priv->apm_base);
#line 399
  goto ldv_41991;
  ldv_41990: 
#line 400
  pwr_sts = inl((int )dev_priv->apm_base + 4);
#line 401
  if ((pwr_sts & pwr_mask) == 3U) {
#line 402
    return (0);
  } else {

  }
#line 403
  __const_udelay(42950UL);
  ldv_41991: 
#line 399
  tmp = tries;
#line 399
  tries = tries - 1;
#line 399
  if (tmp != 0) {
#line 401
    goto ldv_41990;
  } else {

  }

#line 405
  return (0);
}
}
#line 408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.c"
static int cdv_power_up(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 pwr_cnt ;
  u32 pwr_mask ;
  u32 pwr_sts ;
  int tries ;
  int tmp ;

  {
#line 410
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 412
  tries = 5;
#line 414
  pwr_cnt = inl((int )dev_priv->apm_base);
#line 415
  pwr_cnt = pwr_cnt & 4294967292U;
#line 416
  pwr_cnt = pwr_cnt | 2U;
#line 417
  pwr_mask = 3U;
#line 419
  outl(pwr_cnt, (int )dev_priv->apm_base);
#line 421
  goto ldv_42002;
  ldv_42001: 
#line 422
  pwr_sts = inl((int )dev_priv->apm_base + 4);
#line 423
  if ((pwr_sts & pwr_mask) == 0U) {
#line 424
    return (0);
  } else {

  }
#line 425
  __const_udelay(42950UL);
  ldv_42002: 
#line 421
  tmp = tries;
#line 421
  tries = tries - 1;
#line 421
  if (tmp != 0) {
#line 423
    goto ldv_42001;
  } else {

  }

#line 427
  return (0);
}
}
#line 430 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.c"
static void cdv_hotplug_work_func(struct work_struct *work ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct work_struct  const  *__mptr ;
  struct drm_device *dev ;

  {
#line 432
  __mptr = (struct work_struct  const  *)work;
#line 432
  dev_priv = (struct drm_psb_private *)__mptr + 0xffffffffffffee58UL;
#line 434
  dev = dev_priv->dev;
#line 437
  drm_helper_hpd_irq_event(dev);
#line 438
  return;
}
}
#line 443 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.c"
static int cdv_hotplug_event(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  uint32_t tmp ;

  {
#line 445
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 446
  schedule_work___0(& dev_priv->hotplug_work);
#line 447
  tmp = REGISTER_READ(dev, 397588U);
#line 447
  REGISTER_WRITE(dev, 397588U, tmp);
#line 448
  return (1);
}
}
#line 451 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.c"
static void cdv_hotplug_enable(struct drm_device *dev , bool on ) 
{ 
  u32 hotplug ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 453
  if ((int )on) {
#line 454
    tmp = REGISTER_READ(dev, 397584U);
#line 454
    hotplug = tmp;
#line 455
    hotplug = hotplug | 939524608U;
#line 457
    REGISTER_WRITE(dev, 397584U, hotplug);
  } else {
#line 459
    REGISTER_WRITE(dev, 397584U, 0U);
#line 460
    tmp___0 = REGISTER_READ(dev, 397588U);
#line 460
    REGISTER_WRITE(dev, 397588U, tmp___0);
  }
#line 462
  return;
}
}
#line 464 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.c"
static char const   *force_audio_names[3U]  = {      "off",      "auto",      "on"};
#line 470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.c"
void cdv_intel_attach_force_audio_property(struct drm_connector *connector ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct drm_property *prop ;
  int i ;

  {
#line 472
  dev = connector->dev;
#line 473
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 477
  prop = dev_priv->force_audio_property;
#line 478
  if ((unsigned long )prop == (unsigned long )((struct drm_property *)0)) {
#line 479
    prop = drm_property_create(dev, 8, "audio", 3);
#line 482
    if ((unsigned long )prop == (unsigned long )((struct drm_property *)0)) {
#line 483
      return;
    } else {

    }
#line 485
    i = 0;
#line 485
    goto ldv_42033;
    ldv_42032: 
#line 486
    drm_property_add_enum(prop, i, (uint64_t )(i + -1), force_audio_names[i]);
#line 485
    i = i + 1;
    ldv_42033: ;
#line 485
    if ((unsigned int )i <= 2U) {
#line 487
      goto ldv_42032;
    } else {

    }
#line 488
    dev_priv->force_audio_property = prop;
  } else {

  }
#line 490
  drm_object_attach_property(& connector->base, prop, 0ULL);
#line 491
  return;
}
}
#line 494 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.c"
static char const   *broadcast_rgb_names[2U]  = {      "Full",      "Limited 16:235"};
#line 499 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.c"
void cdv_intel_attach_broadcast_rgb_property(struct drm_connector *connector ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct drm_property *prop ;
  int i ;

  {
#line 501
  dev = connector->dev;
#line 502
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 506
  prop = dev_priv->broadcast_rgb_property;
#line 507
  if ((unsigned long )prop == (unsigned long )((struct drm_property *)0)) {
#line 508
    prop = drm_property_create(dev, 8, "Broadcast RGB", 2);
#line 511
    if ((unsigned long )prop == (unsigned long )((struct drm_property *)0)) {
#line 512
      return;
    } else {

    }
#line 514
    i = 0;
#line 514
    goto ldv_42048;
    ldv_42047: 
#line 515
    drm_property_add_enum(prop, i, (uint64_t )i, broadcast_rgb_names[i]);
#line 514
    i = i + 1;
    ldv_42048: ;
#line 514
    if ((unsigned int )i <= 1U) {
#line 516
      goto ldv_42047;
    } else {

    }
#line 517
    dev_priv->broadcast_rgb_property = prop;
  } else {

  }
#line 520
  drm_object_attach_property(& connector->base, prop, 0ULL);
#line 521
  return;
}
}
#line 524 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.c"
static struct psb_offset  const  cdv_regmap[2U]  = {      {24640U, 24644U, 459136U, 458760U, 393244U, 24596U, 24604U, 393216U, 393220U,
      393224U, 393228U, 393232U, 393236U, 459144U, 459152U, 459148U, 459164U, 459140U,
      459140U, 458788U, 459140U, 459172U, 40960U}, 
        {24648U, 24652U, 463232U, 462856U, 397340U, 24600U, 24608U, 397312U, 397316U,
      397320U, 397324U, 397328U, 397332U, 463240U, 463248U, 463244U, 463260U, 463236U,
      463236U, 462884U, 463236U, 463268U, 43008U}};
#line 577 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.c"
static int cdv_chip_setup(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  int tmp ;

  {
#line 579
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 580
  __init_work(& dev_priv->hotplug_work, 0);
#line 580
  __constr_expr_0.counter = 137438953408L;
#line 580
  dev_priv->hotplug_work.data = __constr_expr_0;
#line 580
  lockdep_init_map(& dev_priv->hotplug_work.lockdep_map, "(&dev_priv->hotplug_work)",
                   & __key, 0);
#line 580
  INIT_LIST_HEAD(& dev_priv->hotplug_work.entry);
#line 580
  dev_priv->hotplug_work.func = & cdv_hotplug_work_func;
#line 582
  tmp = pci_enable_msi_exact(dev->pdev, 1);
#line 582
  if (tmp != 0) {
#line 583
    dev_warn((struct device  const  *)dev->dev, "Enabling MSI failed!\n");
  } else {

  }
#line 584
  dev_priv->regmap = (struct psb_offset  const  *)(& cdv_regmap);
#line 585
  gma_get_core_freq(dev);
#line 586
  psb_intel_opregion_init(dev);
#line 587
  psb_intel_init_bios(dev);
#line 588
  cdv_hotplug_enable(dev, 0);
#line 589
  return (0);
}
}
#line 594 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.c"
struct psb_ops  const  cdv_chip_ops  = 
#line 594
     {"GMA3600/3650", 0U, 2, 2, 524288, 3, 2, 1, 0, & cdv_intel_helper_funcs, & cdv_intel_crtc_funcs,
    & cdv_clock_funcs, & cdv_chip_setup, 0, & cdv_errata, & cdv_output_init, & cdv_hotplug_event,
    & cdv_hotplug_enable, & cdv_init_pm, & cdv_save_display_registers, & cdv_restore_display_registers,
    & cdv_power_up, & cdv_power_down, & cdv_update_wm, & cdv_disable_sr, 0, 0};
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void work_init_3(void) 
{ 


  {
#line 406
  ldv_work_3_0 = 0;
#line 407
  ldv_work_3_1 = 0;
#line 408
  ldv_work_3_2 = 0;
#line 409
  ldv_work_3_3 = 0;
#line 410
  return;
}
}
#line 413 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void activate_work_3(struct work_struct *work , int state ) 
{ 


  {
#line 414
  if (ldv_work_3_0 == 0) {
#line 415
    ldv_work_struct_3_0 = work;
#line 416
    ldv_work_3_0 = state;
#line 417
    return;
  } else {

  }
#line 420
  if (ldv_work_3_1 == 0) {
#line 421
    ldv_work_struct_3_1 = work;
#line 422
    ldv_work_3_1 = state;
#line 423
    return;
  } else {

  }
#line 426
  if (ldv_work_3_2 == 0) {
#line 427
    ldv_work_struct_3_2 = work;
#line 428
    ldv_work_3_2 = state;
#line 429
    return;
  } else {

  }
#line 432
  if (ldv_work_3_3 == 0) {
#line 433
    ldv_work_struct_3_3 = work;
#line 434
    ldv_work_3_3 = state;
#line 435
    return;
  } else {

  }
#line 437
  return;
}
}
#line 440 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void ldv_initialize_psb_ops_33(void) 
{ 
  void *tmp ;

  {
#line 441
  tmp = ldv_init_zalloc(3320UL);
#line 441
  cdv_chip_ops_group0 = (struct drm_device *)tmp;
#line 442
  return;
}
}
#line 444 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void call_and_disable_work_3(struct work_struct *work ) 
{ 


  {
#line 447
  if ((ldv_work_3_0 == 2 || ldv_work_3_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_0) {
#line 449
    cdv_hotplug_work_func(work);
#line 450
    ldv_work_3_0 = 1;
#line 451
    return;
  } else {

  }
#line 453
  if ((ldv_work_3_1 == 2 || ldv_work_3_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_1) {
#line 455
    cdv_hotplug_work_func(work);
#line 456
    ldv_work_3_1 = 1;
#line 457
    return;
  } else {

  }
#line 459
  if ((ldv_work_3_2 == 2 || ldv_work_3_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_2) {
#line 461
    cdv_hotplug_work_func(work);
#line 462
    ldv_work_3_2 = 1;
#line 463
    return;
  } else {

  }
#line 465
  if ((ldv_work_3_3 == 2 || ldv_work_3_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_3) {
#line 467
    cdv_hotplug_work_func(work);
#line 468
    ldv_work_3_3 = 1;
#line 469
    return;
  } else {

  }
#line 471
  return;
}
}
#line 474 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void disable_work_3(struct work_struct *work ) 
{ 


  {
#line 476
  if ((ldv_work_3_0 == 3 || ldv_work_3_0 == 2) && (unsigned long )ldv_work_struct_3_0 == (unsigned long )work) {
#line 478
    ldv_work_3_0 = 1;
  } else {

  }
#line 480
  if ((ldv_work_3_1 == 3 || ldv_work_3_1 == 2) && (unsigned long )ldv_work_struct_3_1 == (unsigned long )work) {
#line 482
    ldv_work_3_1 = 1;
  } else {

  }
#line 484
  if ((ldv_work_3_2 == 3 || ldv_work_3_2 == 2) && (unsigned long )ldv_work_struct_3_2 == (unsigned long )work) {
#line 486
    ldv_work_3_2 = 1;
  } else {

  }
#line 488
  if ((ldv_work_3_3 == 3 || ldv_work_3_3 == 2) && (unsigned long )ldv_work_struct_3_3 == (unsigned long )work) {
#line 490
    ldv_work_3_3 = 1;
  } else {

  }
#line 491
  return;
}
}
#line 495 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void invoke_work_3(void) 
{ 
  int tmp ;

  {
#line 497
  tmp = __VERIFIER_nondet_int();
#line 497
  switch (tmp) {
  case 0: ;
#line 499
  if (ldv_work_3_0 == 2 || ldv_work_3_0 == 3) {
#line 500
    ldv_work_3_0 = 4;
#line 501
    cdv_hotplug_work_func(ldv_work_struct_3_0);
#line 502
    ldv_work_3_0 = 1;
  } else {

  }
#line 505
  goto ldv_42082;
  case 1: ;
#line 507
  if (ldv_work_3_1 == 2 || ldv_work_3_1 == 3) {
#line 508
    ldv_work_3_1 = 4;
#line 509
    cdv_hotplug_work_func(ldv_work_struct_3_0);
#line 510
    ldv_work_3_1 = 1;
  } else {

  }
#line 513
  goto ldv_42082;
  case 2: ;
#line 515
  if (ldv_work_3_2 == 2 || ldv_work_3_2 == 3) {
#line 516
    ldv_work_3_2 = 4;
#line 517
    cdv_hotplug_work_func(ldv_work_struct_3_0);
#line 518
    ldv_work_3_2 = 1;
  } else {

  }
#line 521
  goto ldv_42082;
  case 3: ;
#line 523
  if (ldv_work_3_3 == 2 || ldv_work_3_3 == 3) {
#line 524
    ldv_work_3_3 = 4;
#line 525
    cdv_hotplug_work_func(ldv_work_struct_3_0);
#line 526
    ldv_work_3_3 = 1;
  } else {

  }
#line 529
  goto ldv_42082;
  default: 
#line 530
  ldv_stop();
  }
  ldv_42082: ;
#line 532
  return;
}
}
#line 536 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void call_and_disable_all_3(int state ) 
{ 


  {
#line 538
  if (ldv_work_3_0 == state) {
#line 539
    call_and_disable_work_3(ldv_work_struct_3_0);
  } else {

  }
#line 540
  if (ldv_work_3_1 == state) {
#line 541
    call_and_disable_work_3(ldv_work_struct_3_1);
  } else {

  }
#line 542
  if (ldv_work_3_2 == state) {
#line 543
    call_and_disable_work_3(ldv_work_struct_3_2);
  } else {

  }
#line 544
  if (ldv_work_3_3 == state) {
#line 545
    call_and_disable_work_3(ldv_work_struct_3_3);
  } else {

  }
#line 546
  return;
}
}
#line 549 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void ldv_main_exported_33(void) 
{ 
  struct drm_crtc *ldvarg0 ;
  void *tmp ;
  bool ldvarg1 ;
  int tmp___0 ;

  {
#line 550
  tmp = ldv_init_zalloc(1160UL);
#line 550
  ldvarg0 = (struct drm_crtc *)tmp;
#line 551
  ldv_memset((void *)(& ldvarg1), 0, 1UL);
#line 553
  tmp___0 = __VERIFIER_nondet_int();
#line 553
  switch (tmp___0) {
  case 0: ;
#line 556
  if (ldv_state_variable_33 == 1) {
#line 558
    cdv_chip_setup(cdv_chip_ops_group0);
#line 560
    ldv_state_variable_33 = 1;
  } else {

  }
#line 563
  goto ldv_42096;
  case 1: ;
#line 566
  if (ldv_state_variable_33 == 1) {
#line 568
    cdv_errata(cdv_chip_ops_group0);
#line 570
    ldv_state_variable_33 = 1;
  } else {

  }
#line 573
  goto ldv_42096;
  case 2: ;
#line 576
  if (ldv_state_variable_33 == 1) {
#line 578
    cdv_init_pm(cdv_chip_ops_group0);
#line 580
    ldv_state_variable_33 = 1;
  } else {

  }
#line 583
  goto ldv_42096;
  case 3: ;
#line 586
  if (ldv_state_variable_33 == 1) {
#line 588
    cdv_disable_sr(cdv_chip_ops_group0);
#line 590
    ldv_state_variable_33 = 1;
  } else {

  }
#line 593
  goto ldv_42096;
  case 4: ;
#line 596
  if (ldv_state_variable_33 == 1) {
#line 598
    cdv_hotplug_enable(cdv_chip_ops_group0, (int )ldvarg1);
#line 600
    ldv_state_variable_33 = 1;
  } else {

  }
#line 603
  goto ldv_42096;
  case 5: ;
#line 606
  if (ldv_state_variable_33 == 1) {
#line 608
    cdv_hotplug_event(cdv_chip_ops_group0);
#line 610
    ldv_state_variable_33 = 1;
  } else {

  }
#line 613
  goto ldv_42096;
  case 6: ;
#line 616
  if (ldv_state_variable_33 == 1) {
#line 618
    cdv_save_display_registers(cdv_chip_ops_group0);
#line 620
    ldv_state_variable_33 = 1;
  } else {

  }
#line 623
  goto ldv_42096;
  case 7: ;
#line 626
  if (ldv_state_variable_33 == 1) {
#line 628
    cdv_restore_display_registers(cdv_chip_ops_group0);
#line 630
    ldv_state_variable_33 = 1;
  } else {

  }
#line 633
  goto ldv_42096;
  case 8: ;
#line 636
  if (ldv_state_variable_33 == 1) {
#line 638
    cdv_update_wm(cdv_chip_ops_group0, ldvarg0);
#line 640
    ldv_state_variable_33 = 1;
  } else {

  }
#line 643
  goto ldv_42096;
  case 9: ;
#line 646
  if (ldv_state_variable_33 == 1) {
#line 648
    cdv_power_down(cdv_chip_ops_group0);
#line 650
    ldv_state_variable_33 = 1;
  } else {

  }
#line 653
  goto ldv_42096;
  case 10: ;
#line 656
  if (ldv_state_variable_33 == 1) {
#line 658
    cdv_output_init(cdv_chip_ops_group0);
#line 660
    ldv_state_variable_33 = 1;
  } else {

  }
#line 663
  goto ldv_42096;
  case 11: ;
#line 666
  if (ldv_state_variable_33 == 1) {
#line 668
    cdv_power_up(cdv_chip_ops_group0);
#line 670
    ldv_state_variable_33 = 1;
  } else {

  }
#line 673
  goto ldv_42096;
  default: 
#line 674
  ldv_stop();
  }
  ldv_42096: ;
#line 678
  return;
}
}
#line 703 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
bool ldv_queue_work_on_1097(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 707
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 707
  ldv_func_res = tmp;
#line 709
  activate_work_2(ldv_func_arg3, 2);
#line 711
  return (ldv_func_res);
}
}
#line 714 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
bool ldv_queue_delayed_work_on_1098(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 718
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 718
  ldv_func_res = tmp;
#line 720
  activate_work_2(& ldv_func_arg3->work, 2);
#line 722
  return (ldv_func_res);
}
}
#line 725 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
bool ldv_queue_work_on_1099(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 729
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 729
  ldv_func_res = tmp;
#line 731
  activate_work_2(ldv_func_arg3, 2);
#line 733
  return (ldv_func_res);
}
}
#line 736 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void ldv_flush_workqueue_1100(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 739
  flush_workqueue(ldv_func_arg1);
#line 741
  call_and_disable_all_2(2);
#line 742
  return;
}
}
#line 744 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
bool ldv_queue_delayed_work_on_1101(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 748
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 748
  ldv_func_res = tmp;
#line 750
  activate_work_2(& ldv_func_arg3->work, 2);
#line 752
  return (ldv_func_res);
}
}
#line 755 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void ldv_mutex_lock_1102(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 758
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 760
  mutex_lock(ldv_func_arg1);
#line 761
  return;
}
}
#line 763 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void ldv_mutex_unlock_1103(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 766
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 768
  mutex_unlock(ldv_func_arg1);
#line 769
  return;
}
}
#line 771 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void ldv_mutex_lock_1104(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 774
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 776
  mutex_lock(ldv_func_arg1);
#line 777
  return;
}
}
#line 779 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
int ldv_mutex_trylock_1105(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 783
  tmp = mutex_trylock(ldv_func_arg1);
#line 783
  ldv_func_res = tmp;
#line 785
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 785
  return (tmp___0);
#line 787
  return (ldv_func_res);
}
}
#line 790 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void ldv_mutex_unlock_1106(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 793
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 795
  mutex_unlock(ldv_func_arg1);
#line 796
  return;
}
}
#line 798 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void ldv_mutex_unlock_1107(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 801
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 803
  mutex_unlock(ldv_func_arg1);
#line 804
  return;
}
}
#line 806 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void ldv_mutex_lock_1108(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 809
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 811
  mutex_lock(ldv_func_arg1);
#line 812
  return;
}
}
#line 814 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void ldv_mutex_unlock_1109(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 817
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 819
  mutex_unlock(ldv_func_arg1);
#line 820
  return;
}
}
#line 822 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void ldv_mutex_lock_1110(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 825
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 827
  mutex_lock(ldv_func_arg1);
#line 828
  return;
}
}
#line 830 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void ldv_mutex_unlock_1111(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 833
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 835
  mutex_unlock(ldv_func_arg1);
#line 836
  return;
}
}
#line 838 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void ldv_mutex_lock_1112(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 841
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 843
  mutex_lock(ldv_func_arg1);
#line 844
  return;
}
}
#line 846 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
int ldv_mutex_lock_interruptible_1113(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 850
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 850
  ldv_func_res = tmp;
#line 852
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 852
  return (tmp___0);
#line 854
  return (ldv_func_res);
}
}
#line 857 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
int ldv_mutex_trylock_1114(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 861
  tmp = mutex_trylock(ldv_func_arg1);
#line 861
  ldv_func_res = tmp;
#line 863
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 863
  return (tmp___0);
#line 865
  return (ldv_func_res);
}
}
#line 889 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void ldv_mutex_unlock_1117(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 892
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 894
  mutex_unlock(ldv_func_arg1);
#line 895
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_1150(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_1159(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_1148(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_1151(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_1152(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_1155(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_1156(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_1162(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
int ldv_mutex_lock_interruptible_1158(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_1147(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_1149(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_1153(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_1154(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_1157(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_1142(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_1144(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_1143(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_1146(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_1145(struct workqueue_struct *ldv_func_arg1 ) ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.c"
static void cdv_intel_crt_dpms(struct drm_encoder *encoder , int mode ) 
{ 
  struct drm_device *dev ;
  u32 temp ;
  u32 reg ;

  {
#line 41
  dev = encoder->dev;
#line 43
  reg = 397568U;
#line 45
  temp = REGISTER_READ(dev, reg);
#line 46
  temp = temp & 4294964223U;
#line 47
  temp = temp & 2147483647U;
#line 49
  switch (mode) {
  case 0: 
#line 51
  temp = temp | 2147483648U;
#line 52
  goto ldv_41923;
  case 1: 
#line 54
  temp = temp | 2147484672U;
#line 55
  goto ldv_41923;
  case 2: 
#line 57
  temp = temp | 2147485696U;
#line 58
  goto ldv_41923;
  case 3: 
#line 60
  temp = temp | 3072U;
#line 61
  goto ldv_41923;
  }
  ldv_41923: 
#line 64
  REGISTER_WRITE(dev, reg, temp);
#line 65
  return;
}
}
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.c"
static int cdv_intel_crt_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode ) 
{ 


  {
#line 70
  if ((mode->flags & 32U) != 0U) {
#line 71
    return (8);
  } else {

  }
#line 74
  if (mode->clock <= 19999) {
#line 75
    return (16);
  } else {

  }
#line 78
  if (mode->clock > 355000) {
#line 79
    return (15);
  } else {

  }
#line 81
  return (0);
}
}
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.c"
static void cdv_intel_crt_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                   struct drm_display_mode *adjusted_mode ) 
{ 
  struct drm_device *dev ;
  struct drm_crtc *crtc ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  int dpll_md_reg ;
  u32 adpa ;
  u32 dpll_md ;
  u32 adpa_reg ;

  {
#line 89
  dev = encoder->dev;
#line 90
  crtc = encoder->crtc;
#line 91
  __mptr = (struct drm_crtc  const  *)crtc;
#line 91
  gma_crtc = (struct gma_crtc *)__mptr;
#line 96
  if (gma_crtc->pipe == 0) {
#line 97
    dpll_md_reg = 24604;
  } else {
#line 99
    dpll_md_reg = 24608;
  }
#line 101
  adpa_reg = 397568U;
#line 108
  dpll_md = REGISTER_READ(dev, (uint32_t )dpll_md_reg);
#line 109
  REGISTER_WRITE(dev, (uint32_t )dpll_md_reg, dpll_md & 4294951167U);
#line 113
  adpa = 0U;
#line 114
  if ((int )adjusted_mode->flags & 1) {
#line 115
    adpa = adpa | 8U;
  } else {

  }
#line 116
  if ((adjusted_mode->flags & 4U) != 0U) {
#line 117
    adpa = adpa | 16U;
  } else {

  }
#line 119
  if (gma_crtc->pipe == 0) {
#line 120
    adpa = adpa;
  } else {
#line 122
    adpa = adpa | 1073741824U;
  }
#line 124
  REGISTER_WRITE(dev, adpa_reg, adpa);
#line 125
  return;
}
}
#line 134 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.c"
static bool cdv_intel_crt_detect_hotplug(struct drm_connector *connector , bool force ) 
{ 
  struct drm_device *dev ;
  u32 hotplug_en ;
  int i ;
  int tries ;
  int ret ;
  u32 orig ;
  unsigned long timeout ;
  unsigned long tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 137
  dev = connector->dev;
#line 139
  tries = 0;
#line 139
  ret = 0;
#line 146
  tries = 2;
#line 148
  hotplug_en = REGISTER_READ(dev, 397584U);
#line 148
  orig = hotplug_en;
#line 149
  hotplug_en = hotplug_en & 4294967047U;
#line 150
  hotplug_en = hotplug_en | 8U;
#line 152
  hotplug_en = hotplug_en | 256U;
#line 153
  hotplug_en = hotplug_en | 32U;
#line 155
  i = 0;
#line 155
  goto ldv_41965;
  ldv_41964: 
#line 158
  REGISTER_WRITE(dev, 397584U, hotplug_en);
#line 159
  tmp = msecs_to_jiffies(1000U);
#line 159
  timeout = tmp + (unsigned long )jiffies;
  ldv_41963: 
#line 162
  tmp___0 = REGISTER_READ(dev, 397584U);
#line 162
  if ((tmp___0 & 8U) == 0U) {
#line 164
    goto ldv_41956;
  } else {

  }
#line 165
  msleep(1U);
#line 166
  if ((long )((unsigned long )jiffies - timeout) < 0L) {
#line 168
    goto ldv_41963;
  } else {

  }
  ldv_41956: 
#line 155
  i = i + 1;
  ldv_41965: ;
#line 155
  if (i < tries) {
#line 157
    goto ldv_41964;
  } else {

  }
#line 169
  tmp___1 = REGISTER_READ(dev, 397588U);
#line 169
  if ((tmp___1 & 768U) != 0U) {
#line 171
    ret = 1;
  } else {

  }
#line 174
  REGISTER_WRITE(dev, 397588U, 2048U);
#line 177
  REGISTER_WRITE(dev, 397584U, orig);
#line 178
  return (ret != 0);
}
}
#line 181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.c"
static enum drm_connector_status cdv_intel_crt_detect(struct drm_connector *connector ,
                                                      bool force ) 
{ 
  bool tmp ;

  {
#line 184
  tmp = cdv_intel_crt_detect_hotplug(connector, (int )force);
#line 184
  if ((int )tmp) {
#line 185
    return (1);
  } else {
#line 187
    return (2);
  }
}
}
#line 190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.c"
static void cdv_intel_crt_destroy(struct drm_connector *connector ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;

  {
#line 192
  tmp = gma_attached_encoder(connector);
#line 192
  gma_encoder = tmp;
#line 194
  psb_intel_i2c_destroy(gma_encoder->ddc_bus);
#line 195
  drm_connector_unregister(connector);
#line 196
  drm_connector_cleanup(connector);
#line 197
  kfree((void const   *)connector);
#line 198
  return;
}
}
#line 200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.c"
static int cdv_intel_crt_get_modes(struct drm_connector *connector ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  int tmp___0 ;

  {
#line 202
  tmp = gma_attached_encoder(connector);
#line 202
  gma_encoder = tmp;
#line 203
  tmp___0 = psb_intel_ddc_get_modes(connector, & (gma_encoder->ddc_bus)->adapter);
#line 203
  return (tmp___0);
}
}
#line 207 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.c"
static int cdv_intel_crt_set_property(struct drm_connector *connector , struct drm_property *property ,
                                      uint64_t value ) 
{ 


  {
#line 211
  return (0);
}
}
#line 218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.c"
static struct drm_encoder_helper_funcs  const  cdv_intel_crt_helper_funcs  = 
#line 218
     {& cdv_intel_crt_dpms, 0, 0, & gma_encoder_mode_fixup, & gma_encoder_prepare, & gma_encoder_commit,
    & cdv_intel_crt_mode_set, 0, 0, 0, 0, 0};
#line 226 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.c"
static struct drm_connector_funcs  const  cdv_intel_crt_connector_funcs  = 
#line 226
     {& drm_helper_connector_dpms, 0, 0, 0, & cdv_intel_crt_detect, & drm_helper_probe_single_connector_modes,
    & cdv_intel_crt_set_property, & cdv_intel_crt_destroy, 0, 0, 0, 0, 0};
#line 235 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.c"
static struct drm_connector_helper_funcs  const  cdv_intel_crt_connector_helper_funcs  =    {& cdv_intel_crt_get_modes,
    (enum drm_mode_status (*)(struct drm_connector * , struct drm_display_mode * ))(& cdv_intel_crt_mode_valid),
    & gma_best_encoder};
#line 241 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.c"
static void cdv_intel_crt_enc_destroy(struct drm_encoder *encoder ) 
{ 


  {
#line 243
  drm_encoder_cleanup(encoder);
#line 244
  return;
}
}
#line 246 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.c"
static struct drm_encoder_funcs  const  cdv_intel_crt_enc_funcs  =    {0, & cdv_intel_crt_enc_destroy};
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.c"
void cdv_intel_crt_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) 
{ 
  struct gma_connector *gma_connector ;
  struct gma_encoder *gma_encoder ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  u32 i2c_reg ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 261
  tmp = kzalloc(152UL, 208U);
#line 261
  gma_encoder = (struct gma_encoder *)tmp;
#line 262
  if ((unsigned long )gma_encoder == (unsigned long )((struct gma_encoder *)0)) {
#line 263
    return;
  } else {

  }
#line 265
  tmp___0 = kzalloc(944UL, 208U);
#line 265
  gma_connector = (struct gma_connector *)tmp___0;
#line 266
  if ((unsigned long )gma_connector == (unsigned long )((struct gma_connector *)0)) {
#line 267
    goto failed_connector;
  } else {

  }
#line 269
  connector = & gma_connector->base;
#line 270
  connector->polled = 1U;
#line 271
  drm_connector_init(dev, connector, & cdv_intel_crt_connector_funcs, 1);
#line 274
  encoder = & gma_encoder->base;
#line 275
  drm_encoder_init(dev, encoder, & cdv_intel_crt_enc_funcs, 1);
#line 278
  gma_connector_attach_encoder(gma_connector, gma_encoder);
#line 281
  i2c_reg = 20496U;
#line 287
  gma_encoder->ddc_bus = psb_intel_i2c_create(dev, i2c_reg, "CRTDDC_A");
#line 289
  if ((unsigned long )gma_encoder->ddc_bus == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 290
    dev_printk("\v", (struct device  const  *)(& (dev->pdev)->dev), "DDC bus registration failed.\n");
#line 292
    goto failed_ddc;
  } else {

  }
#line 295
  gma_encoder->type = 1;
#line 300
  connector->interlace_allowed = 0;
#line 301
  connector->doublescan_allowed = 0;
#line 303
  drm_encoder_helper_add(encoder, & cdv_intel_crt_helper_funcs);
#line 304
  drm_connector_helper_add(connector, & cdv_intel_crt_connector_helper_funcs);
#line 307
  drm_connector_register(connector);
#line 309
  return;
  failed_ddc: 
#line 311
  drm_encoder_cleanup(& gma_encoder->base);
#line 312
  drm_connector_cleanup(& gma_connector->base);
#line 313
  kfree((void const   *)gma_connector);
  failed_connector: 
#line 315
  kfree((void const   *)gma_encoder);
#line 316
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
extern int ldv_probe_31(void) ;
#line 405
extern int ldv_probe_29(void) ;
#line 408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_initialize_drm_encoder_helper_funcs_32(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 409
  tmp = ldv_init_zalloc(96UL);
#line 409
  cdv_intel_crt_helper_funcs_group0 = (struct drm_encoder *)tmp;
#line 410
  tmp___0 = ldv_init_zalloc(208UL);
#line 410
  cdv_intel_crt_helper_funcs_group1 = (struct drm_display_mode *)tmp___0;
#line 411
  return;
}
}
#line 413 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_initialize_drm_connector_funcs_31(void) 
{ 
  void *tmp ;

  {
#line 414
  tmp = ldv_init_zalloc(936UL);
#line 414
  cdv_intel_crt_connector_funcs_group0 = (struct drm_connector *)tmp;
#line 415
  return;
}
}
#line 417 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_initialize_drm_connector_helper_funcs_30(void) 
{ 
  void *tmp ;

  {
#line 418
  tmp = ldv_init_zalloc(936UL);
#line 418
  cdv_intel_crt_connector_helper_funcs_group0 = (struct drm_connector *)tmp;
#line 419
  return;
}
}
#line 421 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_main_exported_32(void) 
{ 
  struct drm_display_mode *ldvarg2 ;
  void *tmp ;
  struct drm_display_mode *ldvarg3 ;
  void *tmp___0 ;
  int ldvarg4 ;
  int tmp___1 ;

  {
#line 422
  tmp = ldv_init_zalloc(208UL);
#line 422
  ldvarg2 = (struct drm_display_mode *)tmp;
#line 423
  tmp___0 = ldv_init_zalloc(208UL);
#line 423
  ldvarg3 = (struct drm_display_mode *)tmp___0;
#line 424
  ldv_memset((void *)(& ldvarg4), 0, 4UL);
#line 426
  tmp___1 = __VERIFIER_nondet_int();
#line 426
  switch (tmp___1) {
  case 0: ;
#line 429
  if (ldv_state_variable_32 == 1) {
#line 431
    cdv_intel_crt_dpms(cdv_intel_crt_helper_funcs_group0, ldvarg4);
#line 433
    ldv_state_variable_32 = 1;
  } else {

  }
#line 436
  goto ldv_42022;
  case 1: ;
#line 439
  if (ldv_state_variable_32 == 1) {
#line 441
    gma_encoder_mode_fixup(cdv_intel_crt_helper_funcs_group0, (struct drm_display_mode  const  *)ldvarg3,
                           cdv_intel_crt_helper_funcs_group1);
#line 443
    ldv_state_variable_32 = 1;
  } else {

  }
#line 446
  goto ldv_42022;
  case 2: ;
#line 449
  if (ldv_state_variable_32 == 1) {
#line 451
    gma_encoder_commit(cdv_intel_crt_helper_funcs_group0);
#line 453
    ldv_state_variable_32 = 1;
  } else {

  }
#line 456
  goto ldv_42022;
  case 3: ;
#line 459
  if (ldv_state_variable_32 == 1) {
#line 461
    cdv_intel_crt_mode_set(cdv_intel_crt_helper_funcs_group0, cdv_intel_crt_helper_funcs_group1,
                           ldvarg2);
#line 463
    ldv_state_variable_32 = 1;
  } else {

  }
#line 466
  goto ldv_42022;
  case 4: ;
#line 469
  if (ldv_state_variable_32 == 1) {
#line 471
    gma_encoder_prepare(cdv_intel_crt_helper_funcs_group0);
#line 473
    ldv_state_variable_32 = 1;
  } else {

  }
#line 476
  goto ldv_42022;
  default: 
#line 477
  ldv_stop();
  }
  ldv_42022: ;
#line 481
  return;
}
}
#line 483 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_main_exported_30(void) 
{ 
  struct drm_display_mode *ldvarg18 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 484
  tmp = ldv_init_zalloc(208UL);
#line 484
  ldvarg18 = (struct drm_display_mode *)tmp;
#line 486
  tmp___0 = __VERIFIER_nondet_int();
#line 486
  switch (tmp___0) {
  case 0: ;
#line 489
  if (ldv_state_variable_30 == 1) {
#line 491
    cdv_intel_crt_get_modes(cdv_intel_crt_connector_helper_funcs_group0);
#line 493
    ldv_state_variable_30 = 1;
  } else {

  }
#line 496
  goto ldv_42033;
  case 1: ;
#line 499
  if (ldv_state_variable_30 == 1) {
#line 501
    cdv_intel_crt_mode_valid(cdv_intel_crt_connector_helper_funcs_group0, ldvarg18);
#line 503
    ldv_state_variable_30 = 1;
  } else {

  }
#line 506
  goto ldv_42033;
  case 2: ;
#line 509
  if (ldv_state_variable_30 == 1) {
#line 511
    gma_best_encoder(cdv_intel_crt_connector_helper_funcs_group0);
#line 513
    ldv_state_variable_30 = 1;
  } else {

  }
#line 516
  goto ldv_42033;
  default: 
#line 517
  ldv_stop();
  }
  ldv_42033: ;
#line 521
  return;
}
}
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_main_exported_31(void) 
{ 
  uint32_t ldvarg99 ;
  bool ldvarg103 ;
  uint32_t ldvarg100 ;
  uint64_t ldvarg101 ;
  struct drm_property *ldvarg102 ;
  void *tmp ;
  int ldvarg104 ;
  int tmp___0 ;

  {
#line 528
  tmp = ldv_init_zalloc(104UL);
#line 528
  ldvarg102 = (struct drm_property *)tmp;
#line 524
  ldv_memset((void *)(& ldvarg99), 0, 4UL);
#line 525
  ldv_memset((void *)(& ldvarg103), 0, 1UL);
#line 526
  ldv_memset((void *)(& ldvarg100), 0, 4UL);
#line 527
  ldv_memset((void *)(& ldvarg101), 0, 8UL);
#line 529
  ldv_memset((void *)(& ldvarg104), 0, 4UL);
#line 531
  tmp___0 = __VERIFIER_nondet_int();
#line 531
  switch (tmp___0) {
  case 0: ;
#line 534
  if (ldv_state_variable_31 == 1) {
#line 536
    drm_helper_connector_dpms(cdv_intel_crt_connector_funcs_group0, ldvarg104);
#line 538
    ldv_state_variable_31 = 1;
  } else {

  }
#line 541
  if (ldv_state_variable_31 == 2) {
#line 543
    drm_helper_connector_dpms(cdv_intel_crt_connector_funcs_group0, ldvarg104);
#line 545
    ldv_state_variable_31 = 2;
  } else {

  }
#line 548
  goto ldv_42047;
  case 1: ;
#line 551
  if (ldv_state_variable_31 == 1) {
#line 553
    cdv_intel_crt_detect(cdv_intel_crt_connector_funcs_group0, (int )ldvarg103);
#line 555
    ldv_state_variable_31 = 1;
  } else {

  }
#line 558
  if (ldv_state_variable_31 == 2) {
#line 560
    cdv_intel_crt_detect(cdv_intel_crt_connector_funcs_group0, (int )ldvarg103);
#line 562
    ldv_state_variable_31 = 2;
  } else {

  }
#line 565
  goto ldv_42047;
  case 2: ;
#line 568
  if (ldv_state_variable_31 == 1) {
#line 570
    cdv_intel_crt_set_property(cdv_intel_crt_connector_funcs_group0, ldvarg102, ldvarg101);
#line 572
    ldv_state_variable_31 = 1;
  } else {

  }
#line 575
  if (ldv_state_variable_31 == 2) {
#line 577
    cdv_intel_crt_set_property(cdv_intel_crt_connector_funcs_group0, ldvarg102, ldvarg101);
#line 579
    ldv_state_variable_31 = 2;
  } else {

  }
#line 582
  goto ldv_42047;
  case 3: ;
#line 585
  if (ldv_state_variable_31 == 2) {
#line 587
    cdv_intel_crt_destroy(cdv_intel_crt_connector_funcs_group0);
#line 589
    ldv_state_variable_31 = 1;
#line 590
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 593
  goto ldv_42047;
  case 4: ;
#line 596
  if (ldv_state_variable_31 == 1) {
#line 598
    drm_helper_probe_single_connector_modes(cdv_intel_crt_connector_funcs_group0,
                                            ldvarg100, ldvarg99);
#line 600
    ldv_state_variable_31 = 1;
  } else {

  }
#line 603
  if (ldv_state_variable_31 == 2) {
#line 605
    drm_helper_probe_single_connector_modes(cdv_intel_crt_connector_funcs_group0,
                                            ldvarg100, ldvarg99);
#line 607
    ldv_state_variable_31 = 2;
  } else {

  }
#line 610
  goto ldv_42047;
  case 5: ;
#line 613
  if (ldv_state_variable_31 == 1) {
#line 615
    ldv_probe_31();
#line 617
    ldv_state_variable_31 = 2;
#line 618
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 621
  goto ldv_42047;
  default: 
#line 622
  ldv_stop();
  }
  ldv_42047: ;
#line 626
  return;
}
}
#line 628 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_main_exported_29(void) 
{ 
  struct drm_encoder *ldvarg138 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 629
  tmp = ldv_init_zalloc(96UL);
#line 629
  ldvarg138 = (struct drm_encoder *)tmp;
#line 631
  tmp___0 = __VERIFIER_nondet_int();
#line 631
  switch (tmp___0) {
  case 0: ;
#line 634
  if (ldv_state_variable_29 == 2) {
#line 636
    cdv_intel_crt_enc_destroy(ldvarg138);
#line 638
    ldv_state_variable_29 = 1;
#line 639
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 642
  goto ldv_42059;
  case 1: ;
#line 645
  if (ldv_state_variable_29 == 1) {
#line 647
    ldv_probe_29();
#line 649
    ldv_state_variable_29 = 2;
#line 650
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 653
  goto ldv_42059;
  default: 
#line 654
  ldv_stop();
  }
  ldv_42059: ;
#line 658
  return;
}
}
#line 683 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
bool ldv_queue_work_on_1142(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 687
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 687
  ldv_func_res = tmp;
#line 689
  activate_work_2(ldv_func_arg3, 2);
#line 691
  return (ldv_func_res);
}
}
#line 694 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
bool ldv_queue_delayed_work_on_1143(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 698
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 698
  ldv_func_res = tmp;
#line 700
  activate_work_2(& ldv_func_arg3->work, 2);
#line 702
  return (ldv_func_res);
}
}
#line 705 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
bool ldv_queue_work_on_1144(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 709
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 709
  ldv_func_res = tmp;
#line 711
  activate_work_2(ldv_func_arg3, 2);
#line 713
  return (ldv_func_res);
}
}
#line 716 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_flush_workqueue_1145(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 719
  flush_workqueue(ldv_func_arg1);
#line 721
  call_and_disable_all_2(2);
#line 722
  return;
}
}
#line 724 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
bool ldv_queue_delayed_work_on_1146(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 728
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 728
  ldv_func_res = tmp;
#line 730
  activate_work_2(& ldv_func_arg3->work, 2);
#line 732
  return (ldv_func_res);
}
}
#line 735 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_mutex_lock_1147(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 738
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 740
  mutex_lock(ldv_func_arg1);
#line 741
  return;
}
}
#line 743 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_mutex_unlock_1148(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 746
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 748
  mutex_unlock(ldv_func_arg1);
#line 749
  return;
}
}
#line 751 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_mutex_lock_1149(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 754
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 756
  mutex_lock(ldv_func_arg1);
#line 757
  return;
}
}
#line 759 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
int ldv_mutex_trylock_1150(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 763
  tmp = mutex_trylock(ldv_func_arg1);
#line 763
  ldv_func_res = tmp;
#line 765
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 765
  return (tmp___0);
#line 767
  return (ldv_func_res);
}
}
#line 770 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_mutex_unlock_1151(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 773
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 775
  mutex_unlock(ldv_func_arg1);
#line 776
  return;
}
}
#line 778 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_mutex_unlock_1152(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 781
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 783
  mutex_unlock(ldv_func_arg1);
#line 784
  return;
}
}
#line 786 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_mutex_lock_1153(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 789
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 791
  mutex_lock(ldv_func_arg1);
#line 792
  return;
}
}
#line 794 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_mutex_lock_1154(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 797
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 799
  mutex_lock(ldv_func_arg1);
#line 800
  return;
}
}
#line 802 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_mutex_unlock_1155(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 805
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 807
  mutex_unlock(ldv_func_arg1);
#line 808
  return;
}
}
#line 810 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_mutex_unlock_1156(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 813
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 815
  mutex_unlock(ldv_func_arg1);
#line 816
  return;
}
}
#line 818 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_mutex_lock_1157(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 821
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 823
  mutex_lock(ldv_func_arg1);
#line 824
  return;
}
}
#line 826 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
int ldv_mutex_lock_interruptible_1158(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 830
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 830
  ldv_func_res = tmp;
#line 832
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 832
  return (tmp___0);
#line 834
  return (ldv_func_res);
}
}
#line 837 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
int ldv_mutex_trylock_1159(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 841
  tmp = mutex_trylock(ldv_func_arg1);
#line 841
  ldv_func_res = tmp;
#line 843
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 843
  return (tmp___0);
#line 845
  return (ldv_func_res);
}
}
#line 869 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_mutex_unlock_1162(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 872
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 874
  mutex_unlock(ldv_func_arg1);
#line 875
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_1195(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_1204(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_1193(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_1196(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_1197(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_1200(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_1201(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_1207(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
int ldv_mutex_lock_interruptible_1203(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_1192(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_1194(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_1198(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_1199(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_1202(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_1187(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_1189(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_1188(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_1191(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_1190(struct workqueue_struct *ldv_func_arg1 ) ;
#line 272 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
void cdv_intel_dp_set_m_n(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                          struct drm_display_mode *adjusted_mode ) ;
#line 279
int cdv_sb_read(struct drm_device *dev , u32 reg , u32 *val ) ;
#line 280
int cdv_sb_write(struct drm_device *dev , u32 reg , u32 val ) ;
#line 281
void cdv_sb_reset(struct drm_device *dev ) ;
#line 27 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/cdv_device.h"
struct drm_display_mode *cdv_intel_crtc_mode_get(struct drm_device *dev , struct drm_crtc *crtc ) ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c"
static bool cdv_intel_find_dp_pll(struct gma_limit_t  const  *limit , struct drm_crtc *crtc ,
                                  int target , int refclk , struct gma_clock_t *best_clock ) ;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c"
static struct gma_limit_t  const  cdv_intel_limits[6U]  = {      {{20000, 115500}, {1800000, 3600000}, {2, 6}, {60, 160}, {0, 0}, {58, 158}, {28,
                                                                                  140},
      {2, 10}, {200000, 14, 14}, & gma_find_best_pll}, 
        {{20000, 115500}, {1800000, 3600000}, {2, 6}, {60, 160}, {0, 0}, {58, 158}, {28,
                                                                                  140},
      {2, 10}, {200000, 14, 14}, & gma_find_best_pll}, 
        {{20000, 400000}, {1809000, 3564000}, {1, 1}, {67, 132}, {0, 0}, {65, 130}, {5,
                                                                                  90},
      {1, 9}, {225000, 10, 5}, & gma_find_best_pll}, 
        {{20000, 400000}, {1800000, 3600000}, {2, 6}, {60, 160}, {0, 0}, {58, 158}, {5,
                                                                                  100},
      {1, 10}, {225000, 10, 5}, & gma_find_best_pll}, 
        {{160000, 272000}, {1809000, 3564000}, {1, 1}, {67, 132}, {0, 0}, {65, 130},
      {5, 90}, {1, 9}, {225000, 10, 10}, & cdv_intel_find_dp_pll}, 
        {{160000, 272000}, {1800000, 3600000}, {2, 6}, {60, 164}, {0, 0}, {58, 162},
      {5, 100}, {1, 10}, {225000, 10, 10}, & cdv_intel_find_dp_pll}};
#line 139 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c"
int cdv_sb_read(struct drm_device *dev , u32 reg , u32 *val ) 
{ 
  int ret ;
  unsigned long timeout__ ;
  unsigned long tmp ;
  int ret__ ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___0 ;
  uint32_t tmp___1 ;
  unsigned long timeout_____0 ;
  unsigned long tmp___2 ;
  int ret_____0 ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;
  int tmp___3 ;
  uint32_t tmp___4 ;

  {
#line 143
  tmp = msecs_to_jiffies(1000U);
#line 143
  timeout__ = tmp + (unsigned long )jiffies;
#line 143
  ret__ = 0;
#line 143
  goto ldv_42105;
  ldv_42104: ;
#line 143
  if ((long )(timeout__ - (unsigned long )jiffies) < 0L) {
#line 143
    ret__ = -110;
#line 143
    goto ldv_42062;
  } else {

  }
#line 143
  __vpp_verify = (void const   *)0;
#line 143
  switch (4UL) {
  case 1UL: ;
#line 143
  switch (4UL) {
  case 1UL: 
#line 143
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 143
  goto ldv_42068;
  case 2UL: 
#line 143
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 143
  goto ldv_42068;
  case 4UL: 
#line 143
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 143
  goto ldv_42068;
  case 8UL: 
#line 143
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 143
  goto ldv_42068;
  default: 
#line 143
  __bad_percpu_size();
  }
  ldv_42068: 
#line 143
  pscr_ret__ = pfo_ret__;
#line 143
  goto ldv_42074;
  case 2UL: ;
#line 143
  switch (4UL) {
  case 1UL: 
#line 143
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 143
  goto ldv_42078;
  case 2UL: 
#line 143
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 143
  goto ldv_42078;
  case 4UL: 
#line 143
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 143
  goto ldv_42078;
  case 8UL: 
#line 143
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 143
  goto ldv_42078;
  default: 
#line 143
  __bad_percpu_size();
  }
  ldv_42078: 
#line 143
  pscr_ret__ = pfo_ret_____0;
#line 143
  goto ldv_42074;
  case 4UL: ;
#line 143
  switch (4UL) {
  case 1UL: 
#line 143
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 143
  goto ldv_42087;
  case 2UL: 
#line 143
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 143
  goto ldv_42087;
  case 4UL: 
#line 143
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 143
  goto ldv_42087;
  case 8UL: 
#line 143
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 143
  goto ldv_42087;
  default: 
#line 143
  __bad_percpu_size();
  }
  ldv_42087: 
#line 143
  pscr_ret__ = pfo_ret_____1;
#line 143
  goto ldv_42074;
  case 8UL: ;
#line 143
  switch (4UL) {
  case 1UL: 
#line 143
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 143
  goto ldv_42096;
  case 2UL: 
#line 143
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 143
  goto ldv_42096;
  case 4UL: 
#line 143
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 143
  goto ldv_42096;
  case 8UL: 
#line 143
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 143
  goto ldv_42096;
  default: 
#line 143
  __bad_percpu_size();
  }
  ldv_42096: 
#line 143
  pscr_ret__ = pfo_ret_____2;
#line 143
  goto ldv_42074;
  default: 
#line 143
  __bad_size_call_parameter();
#line 143
  goto ldv_42074;
  }
  ldv_42074: 
#line 143
  tmp___0 = atomic_read((atomic_t const   *)(& kgdb_active));
#line 143
  if (pscr_ret__ != tmp___0) {
#line 143
    msleep(1U);
  } else {

  }
  ldv_42105: 
#line 143
  tmp___1 = REGISTER_READ(dev, 8448U);
#line 143
  if ((int )tmp___1 & 1) {
#line 145
    goto ldv_42104;
  } else {

  }
  ldv_42062: 
#line 143
  ret = ret__;
#line 144
  if (ret != 0) {
#line 145
    drm_err("timeout waiting for SB to idle before read\n");
#line 146
    return (ret);
  } else {

  }
#line 149
  REGISTER_WRITE(dev, 8456U, reg);
#line 150
  REGISTER_WRITE(dev, 8448U, 35056U);
#line 155
  tmp___2 = msecs_to_jiffies(1000U);
#line 155
  timeout_____0 = tmp___2 + (unsigned long )jiffies;
#line 155
  ret_____0 = 0;
#line 155
  goto ldv_42158;
  ldv_42157: ;
#line 155
  if ((long )(timeout_____0 - (unsigned long )jiffies) < 0L) {
#line 155
    ret_____0 = -110;
#line 155
    goto ldv_42115;
  } else {

  }
#line 155
  __vpp_verify___0 = (void const   *)0;
#line 155
  switch (4UL) {
  case 1UL: ;
#line 155
  switch (4UL) {
  case 1UL: 
#line 155
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 155
  goto ldv_42121;
  case 2UL: 
#line 155
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 155
  goto ldv_42121;
  case 4UL: 
#line 155
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 155
  goto ldv_42121;
  case 8UL: 
#line 155
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 155
  goto ldv_42121;
  default: 
#line 155
  __bad_percpu_size();
  }
  ldv_42121: 
#line 155
  pscr_ret_____0 = pfo_ret_____3;
#line 155
  goto ldv_42127;
  case 2UL: ;
#line 155
  switch (4UL) {
  case 1UL: 
#line 155
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 155
  goto ldv_42131;
  case 2UL: 
#line 155
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 155
  goto ldv_42131;
  case 4UL: 
#line 155
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 155
  goto ldv_42131;
  case 8UL: 
#line 155
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 155
  goto ldv_42131;
  default: 
#line 155
  __bad_percpu_size();
  }
  ldv_42131: 
#line 155
  pscr_ret_____0 = pfo_ret_____4;
#line 155
  goto ldv_42127;
  case 4UL: ;
#line 155
  switch (4UL) {
  case 1UL: 
#line 155
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 155
  goto ldv_42140;
  case 2UL: 
#line 155
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 155
  goto ldv_42140;
  case 4UL: 
#line 155
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 155
  goto ldv_42140;
  case 8UL: 
#line 155
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 155
  goto ldv_42140;
  default: 
#line 155
  __bad_percpu_size();
  }
  ldv_42140: 
#line 155
  pscr_ret_____0 = pfo_ret_____5;
#line 155
  goto ldv_42127;
  case 8UL: ;
#line 155
  switch (4UL) {
  case 1UL: 
#line 155
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 155
  goto ldv_42149;
  case 2UL: 
#line 155
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 155
  goto ldv_42149;
  case 4UL: 
#line 155
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 155
  goto ldv_42149;
  case 8UL: 
#line 155
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 155
  goto ldv_42149;
  default: 
#line 155
  __bad_percpu_size();
  }
  ldv_42149: 
#line 155
  pscr_ret_____0 = pfo_ret_____6;
#line 155
  goto ldv_42127;
  default: 
#line 155
  __bad_size_call_parameter();
#line 155
  goto ldv_42127;
  }
  ldv_42127: 
#line 155
  tmp___3 = atomic_read((atomic_t const   *)(& kgdb_active));
#line 155
  if (pscr_ret_____0 != tmp___3) {
#line 155
    msleep(1U);
  } else {

  }
  ldv_42158: 
#line 155
  tmp___4 = REGISTER_READ(dev, 8448U);
#line 155
  if ((int )tmp___4 & 1) {
#line 157
    goto ldv_42157;
  } else {

  }
  ldv_42115: 
#line 155
  ret = ret_____0;
#line 156
  if (ret != 0) {
#line 157
    drm_err("timeout waiting for SB to idle after read\n");
#line 158
    return (ret);
  } else {

  }
#line 161
  *val = REGISTER_READ(dev, 8452U);
#line 163
  return (0);
}
}
#line 166 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c"
int cdv_sb_write(struct drm_device *dev , u32 reg , u32 val ) 
{ 
  int ret ;
  bool dpio_debug ;
  u32 temp ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long timeout__ ;
  unsigned long tmp___2 ;
  int ret__ ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___3 ;
  uint32_t tmp___4 ;
  unsigned long timeout_____0 ;
  unsigned long tmp___5 ;
  int ret_____0 ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;
  int tmp___6 ;
  uint32_t tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;

  {
#line 169
  dpio_debug = 1;
#line 172
  if ((int )dpio_debug) {
#line 173
    tmp___0 = cdv_sb_read(dev, reg, & temp);
#line 173
    if (tmp___0 == 0) {
#line 174
      tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 174
      if (tmp != 0L) {
#line 174
        drm_ut_debug_printk("cdv_sb_write", "0x%08x: 0x%08x (before)\n", reg, temp);
      } else {

      }
    } else {

    }
#line 175
    tmp___1 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 175
    if (tmp___1 != 0L) {
#line 175
      drm_ut_debug_printk("cdv_sb_write", "0x%08x: 0x%08x\n", reg, val);
    } else {

    }
  } else {

  }
#line 178
  tmp___2 = msecs_to_jiffies(1000U);
#line 178
  timeout__ = tmp___2 + (unsigned long )jiffies;
#line 178
  ret__ = 0;
#line 178
  goto ldv_42220;
  ldv_42219: ;
#line 178
  if ((long )(timeout__ - (unsigned long )jiffies) < 0L) {
#line 178
    ret__ = -110;
#line 178
    goto ldv_42177;
  } else {

  }
#line 178
  __vpp_verify = (void const   *)0;
#line 178
  switch (4UL) {
  case 1UL: ;
#line 178
  switch (4UL) {
  case 1UL: 
#line 178
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 178
  goto ldv_42183;
  case 2UL: 
#line 178
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 178
  goto ldv_42183;
  case 4UL: 
#line 178
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 178
  goto ldv_42183;
  case 8UL: 
#line 178
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 178
  goto ldv_42183;
  default: 
#line 178
  __bad_percpu_size();
  }
  ldv_42183: 
#line 178
  pscr_ret__ = pfo_ret__;
#line 178
  goto ldv_42189;
  case 2UL: ;
#line 178
  switch (4UL) {
  case 1UL: 
#line 178
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 178
  goto ldv_42193;
  case 2UL: 
#line 178
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 178
  goto ldv_42193;
  case 4UL: 
#line 178
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 178
  goto ldv_42193;
  case 8UL: 
#line 178
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 178
  goto ldv_42193;
  default: 
#line 178
  __bad_percpu_size();
  }
  ldv_42193: 
#line 178
  pscr_ret__ = pfo_ret_____0;
#line 178
  goto ldv_42189;
  case 4UL: ;
#line 178
  switch (4UL) {
  case 1UL: 
#line 178
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 178
  goto ldv_42202;
  case 2UL: 
#line 178
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 178
  goto ldv_42202;
  case 4UL: 
#line 178
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 178
  goto ldv_42202;
  case 8UL: 
#line 178
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 178
  goto ldv_42202;
  default: 
#line 178
  __bad_percpu_size();
  }
  ldv_42202: 
#line 178
  pscr_ret__ = pfo_ret_____1;
#line 178
  goto ldv_42189;
  case 8UL: ;
#line 178
  switch (4UL) {
  case 1UL: 
#line 178
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 178
  goto ldv_42211;
  case 2UL: 
#line 178
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 178
  goto ldv_42211;
  case 4UL: 
#line 178
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 178
  goto ldv_42211;
  case 8UL: 
#line 178
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 178
  goto ldv_42211;
  default: 
#line 178
  __bad_percpu_size();
  }
  ldv_42211: 
#line 178
  pscr_ret__ = pfo_ret_____2;
#line 178
  goto ldv_42189;
  default: 
#line 178
  __bad_size_call_parameter();
#line 178
  goto ldv_42189;
  }
  ldv_42189: 
#line 178
  tmp___3 = atomic_read((atomic_t const   *)(& kgdb_active));
#line 178
  if (pscr_ret__ != tmp___3) {
#line 178
    msleep(1U);
  } else {

  }
  ldv_42220: 
#line 178
  tmp___4 = REGISTER_READ(dev, 8448U);
#line 178
  if ((int )tmp___4 & 1) {
#line 180
    goto ldv_42219;
  } else {

  }
  ldv_42177: 
#line 178
  ret = ret__;
#line 179
  if (ret != 0) {
#line 180
    drm_err("timeout waiting for SB to idle before write\n");
#line 181
    return (ret);
  } else {

  }
#line 184
  REGISTER_WRITE(dev, 8456U, reg);
#line 185
  REGISTER_WRITE(dev, 8452U, val);
#line 186
  REGISTER_WRITE(dev, 8448U, 100592U);
#line 191
  tmp___5 = msecs_to_jiffies(1000U);
#line 191
  timeout_____0 = tmp___5 + (unsigned long )jiffies;
#line 191
  ret_____0 = 0;
#line 191
  goto ldv_42273;
  ldv_42272: ;
#line 191
  if ((long )(timeout_____0 - (unsigned long )jiffies) < 0L) {
#line 191
    ret_____0 = -110;
#line 191
    goto ldv_42230;
  } else {

  }
#line 191
  __vpp_verify___0 = (void const   *)0;
#line 191
  switch (4UL) {
  case 1UL: ;
#line 191
  switch (4UL) {
  case 1UL: 
#line 191
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 191
  goto ldv_42236;
  case 2UL: 
#line 191
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 191
  goto ldv_42236;
  case 4UL: 
#line 191
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 191
  goto ldv_42236;
  case 8UL: 
#line 191
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 191
  goto ldv_42236;
  default: 
#line 191
  __bad_percpu_size();
  }
  ldv_42236: 
#line 191
  pscr_ret_____0 = pfo_ret_____3;
#line 191
  goto ldv_42242;
  case 2UL: ;
#line 191
  switch (4UL) {
  case 1UL: 
#line 191
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 191
  goto ldv_42246;
  case 2UL: 
#line 191
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 191
  goto ldv_42246;
  case 4UL: 
#line 191
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 191
  goto ldv_42246;
  case 8UL: 
#line 191
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 191
  goto ldv_42246;
  default: 
#line 191
  __bad_percpu_size();
  }
  ldv_42246: 
#line 191
  pscr_ret_____0 = pfo_ret_____4;
#line 191
  goto ldv_42242;
  case 4UL: ;
#line 191
  switch (4UL) {
  case 1UL: 
#line 191
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 191
  goto ldv_42255;
  case 2UL: 
#line 191
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 191
  goto ldv_42255;
  case 4UL: 
#line 191
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 191
  goto ldv_42255;
  case 8UL: 
#line 191
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 191
  goto ldv_42255;
  default: 
#line 191
  __bad_percpu_size();
  }
  ldv_42255: 
#line 191
  pscr_ret_____0 = pfo_ret_____5;
#line 191
  goto ldv_42242;
  case 8UL: ;
#line 191
  switch (4UL) {
  case 1UL: 
#line 191
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 191
  goto ldv_42264;
  case 2UL: 
#line 191
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 191
  goto ldv_42264;
  case 4UL: 
#line 191
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 191
  goto ldv_42264;
  case 8UL: 
#line 191
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 191
  goto ldv_42264;
  default: 
#line 191
  __bad_percpu_size();
  }
  ldv_42264: 
#line 191
  pscr_ret_____0 = pfo_ret_____6;
#line 191
  goto ldv_42242;
  default: 
#line 191
  __bad_size_call_parameter();
#line 191
  goto ldv_42242;
  }
  ldv_42242: 
#line 191
  tmp___6 = atomic_read((atomic_t const   *)(& kgdb_active));
#line 191
  if (pscr_ret_____0 != tmp___6) {
#line 191
    msleep(1U);
  } else {

  }
  ldv_42273: 
#line 191
  tmp___7 = REGISTER_READ(dev, 8448U);
#line 191
  if ((int )tmp___7 & 1) {
#line 193
    goto ldv_42272;
  } else {

  }
  ldv_42230: 
#line 191
  ret = ret_____0;
#line 192
  if (ret != 0) {
#line 193
    drm_err("timeout waiting for SB to idle after write\n");
#line 194
    return (ret);
  } else {

  }
#line 197
  if ((int )dpio_debug) {
#line 198
    tmp___9 = cdv_sb_read(dev, reg, & temp);
#line 198
    if (tmp___9 == 0) {
#line 199
      tmp___8 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 199
      if (tmp___8 != 0L) {
#line 199
        drm_ut_debug_printk("cdv_sb_write", "0x%08x: 0x%08x (after)\n", reg, temp);
      } else {

      }
    } else {

    }
  } else {

  }
#line 202
  return (0);
}
}
#line 208 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c"
void cdv_sb_reset(struct drm_device *dev ) 
{ 


  {
#line 211
  REGISTER_WRITE(dev, 8464U, 0U);
#line 212
  REGISTER_READ(dev, 8464U);
#line 213
  REGISTER_WRITE(dev, 8464U, 5U);
#line 214
  return;
}
}
#line 222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c"
static int cdv_dpll_set_clock_cdv(struct drm_device *dev , struct drm_crtc *crtc ,
                                  struct gma_clock_t *clock , bool is_lvds , u32 ddi_select ) 
{ 
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  u32 m ;
  u32 n_vco ;
  u32 p ;
  int ret ;
  int dpll_reg ;
  int ref_sfr ;
  u32 ref_value ;
  u32 lane_reg ;
  u32 lane_value ;
  long tmp ;
  long tmp___0 ;

  {
#line 225
  __mptr = (struct drm_crtc  const  *)crtc;
#line 225
  gma_crtc = (struct gma_crtc *)__mptr;
#line 226
  pipe = gma_crtc->pipe;
#line 228
  ret = 0;
#line 229
  dpll_reg = pipe == 0 ? 24596 : 24600;
#line 230
  ref_sfr = pipe == 0 ? 32784 : 32816;
#line 234
  cdv_sb_reset(dev);
#line 236
  REGISTER_WRITE(dev, (uint32_t )dpll_reg, 805306368U);
#line 238
  __const_udelay(429500UL);
#line 241
  ref_value = 6858497U;
#line 243
  cdv_sb_write(dev, (u32 )(pipe * 32 + 32792), ref_value);
#line 260
  ret = cdv_sb_read(dev, (u32 )ref_sfr, & ref_value);
#line 261
  if (ret != 0) {
#line 262
    return (ret);
  } else {

  }
#line 263
  ref_value = ref_value & 4294942719U;
#line 266
  if ((pipe == 1 && ! is_lvds) && (ddi_select & 32768U) == 0U) {
#line 267
    tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 267
    if (tmp != 0L) {
#line 267
      drm_ut_debug_printk("cdv_dpll_set_clock_cdv", "use DPLLA for pipe B\n");
    } else {

    }
#line 268
    ref_value = ref_value | 16384U;
  } else {
#line 270
    tmp___0 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 270
    if (tmp___0 != 0L) {
#line 270
      drm_ut_debug_printk("cdv_dpll_set_clock_cdv", "use their DPLL for pipe A/B\n");
    } else {

    }
#line 271
    ref_value = ref_value | 8192U;
  }
#line 273
  ret = cdv_sb_write(dev, (u32 )ref_sfr, ref_value);
#line 274
  if (ret != 0) {
#line 275
    return (ret);
  } else {

  }
#line 277
  ret = cdv_sb_read(dev, (u32 )(pipe * 32 + 32776), & m);
#line 278
  if (ret != 0) {
#line 279
    return (ret);
  } else {

  }
#line 280
  m = m & 16777215U;
#line 281
  m = (u32 )(clock->m2 << 24) | m;
#line 282
  ret = cdv_sb_write(dev, (u32 )(pipe * 32 + 32776), m);
#line 283
  if (ret != 0) {
#line 284
    return (ret);
  } else {

  }
#line 286
  ret = cdv_sb_read(dev, (u32 )(pipe * 32 + 32788), & n_vco);
#line 287
  if (ret != 0) {
#line 288
    return (ret);
  } else {

  }
#line 291
  n_vco = n_vco & 65535U;
#line 292
  n_vco = n_vco | 263U;
#line 293
  n_vco = n_vco & 16777215U;
#line 297
  n_vco = (u32 )(clock->n << 26) | n_vco;
#line 299
  if (clock->vco <= 2249999) {
#line 300
    n_vco = n_vco | 33554432U;
#line 301
    n_vco = n_vco;
  } else
#line 302
  if (clock->vco <= 2749999) {
#line 303
    n_vco = n_vco | 16777216U;
#line 304
    n_vco = n_vco | 1073741824U;
  } else
#line 305
  if (clock->vco <= 3299999) {
#line 306
    n_vco = n_vco;
#line 307
    n_vco = n_vco | 2147483648U;
  } else {
#line 309
    n_vco = n_vco;
#line 310
    n_vco = n_vco | 3221225472U;
  }
#line 313
  ret = cdv_sb_write(dev, (u32 )(pipe * 32 + 32788), n_vco);
#line 314
  if (ret != 0) {
#line 315
    return (ret);
  } else {

  }
#line 317
  ret = cdv_sb_read(dev, (u32 )(pipe * 32 + 32796), & p);
#line 318
  if (ret != 0) {
#line 319
    return (ret);
  } else {

  }
#line 320
  p = p & 1073680383U;
#line 321
  p = ((u32 )(clock->p1 << 12) & 65535U) | p;
#line 322
  switch (clock->p2) {
  case 5: 
#line 324
  p = p | 1073741824U;
#line 325
  goto ldv_42300;
  case 10: 
#line 327
  p = p;
#line 328
  goto ldv_42300;
  case 14: 
#line 330
  p = p | 2147483648U;
#line 331
  goto ldv_42300;
  case 7: 
#line 333
  p = p | 3221225472U;
#line 334
  goto ldv_42300;
  default: 
#line 336
  drm_err("Bad P2 clock: %d\n", clock->p2);
#line 337
  return (-22);
  }
  ldv_42300: 
#line 339
  ret = cdv_sb_write(dev, (u32 )(pipe * 32 + 32796), p);
#line 340
  if (ret != 0) {
#line 341
    return (ret);
  } else {

  }
#line 343
  if (ddi_select != 0U) {
#line 344
    if ((ddi_select & 3U) == 1U) {
#line 345
      lane_reg = 288U;
#line 346
      cdv_sb_read(dev, lane_reg, & lane_value);
#line 347
      lane_value = lane_value & 4287627263U;
#line 348
      lane_value = lane_value | 3145728U;
#line 349
      cdv_sb_write(dev, lane_reg, lane_value);
#line 351
      lane_reg = 544U;
#line 352
      cdv_sb_read(dev, lane_reg, & lane_value);
#line 353
      lane_value = lane_value & 4287627263U;
#line 354
      lane_value = lane_value | 3145728U;
#line 355
      cdv_sb_write(dev, lane_reg, lane_value);
    } else {
#line 357
      lane_reg = 8992U;
#line 358
      cdv_sb_read(dev, lane_reg, & lane_value);
#line 359
      lane_value = lane_value & 4287627263U;
#line 360
      lane_value = lane_value | 3145728U;
#line 361
      cdv_sb_write(dev, lane_reg, lane_value);
#line 363
      lane_reg = 9248U;
#line 364
      cdv_sb_read(dev, lane_reg, & lane_value);
#line 365
      lane_value = lane_value & 4287627263U;
#line 366
      lane_value = lane_value | 3145728U;
#line 367
      cdv_sb_write(dev, lane_reg, lane_value);
    }
  } else {

  }
#line 370
  return (0);
}
}
#line 373 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c"
static struct gma_limit_t  const  *cdv_intel_limit(struct drm_crtc *crtc , int refclk ) 
{ 
  struct gma_limit_t  const  *limit ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 377
  tmp___1 = gma_pipe_has_type(crtc, 4);
#line 377
  if ((int )tmp___1) {
#line 382
    if (refclk == 96000) {
#line 383
      limit = (struct gma_limit_t  const  *)(& cdv_intel_limits);
    } else {
#line 385
      limit = (struct gma_limit_t  const  *)(& cdv_intel_limits) + 1UL;
    }
  } else {
#line 386
    tmp = gma_pipe_has_type(crtc, 9);
#line 386
    if ((int )tmp) {
#line 386
      goto _L;
    } else {
#line 386
      tmp___0 = gma_pipe_has_type(crtc, 10);
#line 386
      if ((int )tmp___0) {
        _L: /* CIL Label */ 
#line 388
        if (refclk == 27000) {
#line 389
          limit = (struct gma_limit_t  const  *)(& cdv_intel_limits) + 4UL;
        } else {
#line 391
          limit = (struct gma_limit_t  const  *)(& cdv_intel_limits) + 5UL;
        }
      } else
#line 393
      if (refclk == 27000) {
#line 394
        limit = (struct gma_limit_t  const  *)(& cdv_intel_limits) + 2UL;
      } else {
#line 396
        limit = (struct gma_limit_t  const  *)(& cdv_intel_limits) + 3UL;
      }
    }
  }
#line 398
  return (limit);
}
}
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c"
static void cdv_intel_clock(int refclk , struct gma_clock_t *clock ) 
{ 


  {
#line 404
  clock->m = clock->m2 + 2;
#line 405
  clock->p = clock->p1 * clock->p2;
#line 406
  clock->vco = (clock->m * refclk) / clock->n;
#line 407
  clock->dot = clock->vco / clock->p;
#line 408
  return;
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c"
static bool cdv_intel_find_dp_pll(struct gma_limit_t  const  *limit , struct drm_crtc *crtc ,
                                  int target , int refclk , struct gma_clock_t *best_clock ) 
{ 
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct gma_clock_t clock ;

  {
#line 415
  __mptr = (struct drm_crtc  const  *)crtc;
#line 415
  gma_crtc = (struct gma_crtc *)__mptr;
#line 418
  switch (refclk) {
  case 27000: ;
#line 420
  if (target <= 199999) {
#line 421
    clock.p1 = 2;
#line 422
    clock.p2 = 10;
#line 423
    clock.n = 1;
#line 424
    clock.m1 = 0;
#line 425
    clock.m2 = 118;
  } else {
#line 427
    clock.p1 = 1;
#line 428
    clock.p2 = 10;
#line 429
    clock.n = 1;
#line 430
    clock.m1 = 0;
#line 431
    clock.m2 = 98;
  }
#line 433
  goto ldv_42326;
  case 100000: ;
#line 436
  if (target <= 199999) {
#line 437
    clock.p1 = 2;
#line 438
    clock.p2 = 10;
#line 439
    clock.n = 5;
#line 440
    clock.m1 = 0;
#line 441
    clock.m2 = 160;
  } else {
#line 443
    clock.p1 = 1;
#line 444
    clock.p2 = 10;
#line 445
    clock.n = 5;
#line 446
    clock.m1 = 0;
#line 447
    clock.m2 = 133;
  }
#line 449
  goto ldv_42326;
  default: ;
#line 452
  return (0);
  }
  ldv_42326: 
#line 455
  (*((gma_crtc->clock_funcs)->clock))(refclk, & clock);
#line 456
  memcpy((void *)best_clock, (void const   *)(& clock), 36UL);
#line 457
  return (1);
}
}
#line 463 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c"
static bool cdv_intel_pipe_enabled(struct drm_device *dev , int pipe ) 
{ 
  struct drm_crtc *crtc ;
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;

  {
#line 466
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 467
  gma_crtc = (struct gma_crtc *)0;
#line 469
  crtc = dev_priv->pipe_to_crtc_mapping[pipe];
#line 470
  __mptr = (struct drm_crtc  const  *)crtc;
#line 470
  gma_crtc = (struct gma_crtc *)__mptr;
#line 472
  if ((unsigned long )(crtc->primary)->fb == (unsigned long )((struct drm_framebuffer *)0) || ! gma_crtc->active) {
#line 473
    return (0);
  } else {

  }
#line 474
  return (1);
}
}
#line 477 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c"
void cdv_disable_sr(struct drm_device *dev ) 
{ 
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 479
  tmp___0 = REGISTER_READ(dev, 8416U);
#line 479
  if ((tmp___0 & 32768U) != 0U) {
#line 482
    tmp = REGISTER_READ(dev, 8416U);
#line 482
    REGISTER_WRITE(dev, 8416U, tmp & 4294934527U);
#line 483
    REGISTER_READ(dev, 8416U);
#line 485
    gma_wait_for_vblank(dev);
#line 490
    REGISTER_WRITE(dev, 196608U, 0U);
#line 491
    REGISTER_READ(dev, 196608U);
#line 493
    gma_wait_for_vblank(dev);
  } else {

  }
#line 495
  return;
}
}
#line 498 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c"
void cdv_update_wm(struct drm_device *dev , struct drm_crtc *crtc ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  u32 fw ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 500
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 501
  __mptr = (struct drm_crtc  const  *)crtc;
#line 501
  gma_crtc = (struct gma_crtc *)__mptr;
#line 504
  tmp___0 = cdv_intel_pipe_enabled(dev, 0);
#line 504
  tmp___1 = cdv_intel_pipe_enabled(dev, 1);
#line 504
  if ((int )tmp___0 != (int )tmp___1) {
#line 507
    fw = REGISTER_READ(dev, 458804U);
#line 508
    fw = fw & 8388607U;
#line 509
    fw = fw | 1056964608U;
#line 510
    fw = fw & 4290838527U;
#line 511
    fw = fw | 262144U;
#line 512
    REGISTER_WRITE(dev, 458804U, fw);
#line 514
    fw = REGISTER_READ(dev, 458808U);
#line 515
    fw = fw & 4294951167U;
#line 516
    fw = fw | 1536U;
#line 517
    fw = fw & 4294967168U;
#line 518
    fw = fw | 8U;
#line 519
    REGISTER_WRITE(dev, 458808U, fw);
#line 521
    REGISTER_WRITE(dev, 458812U, 905969664U);
#line 526
    if (gma_crtc->pipe == 1) {
#line 526
      tmp = gma_pipe_has_type(crtc, 4);
#line 526
      if ((int )tmp) {
#line 528
        REGISTER_WRITE(dev, 458836U, 262960U);
      } else {
#line 530
        fw = 50594564U;
#line 534
        REGISTER_WRITE(dev, 458836U, fw);
      }
    } else {
#line 530
      fw = 50594564U;
#line 534
      REGISTER_WRITE(dev, 458836U, fw);
    }
#line 537
    REGISTER_WRITE(dev, 458840U, 16U);
#line 539
    gma_wait_for_vblank(dev);
#line 542
    REGISTER_WRITE(dev, 8416U, 32768U);
#line 543
    REGISTER_READ(dev, 8416U);
#line 544
    gma_wait_for_vblank(dev);
  } else {
#line 549
    REGISTER_WRITE(dev, 458804U, 1065879560U);
#line 550
    REGISTER_WRITE(dev, 458808U, 184680962U);
#line 551
    REGISTER_WRITE(dev, 458812U, 603979776U);
#line 552
    REGISTER_WRITE(dev, 458832U, 134414850U);
#line 553
    REGISTER_WRITE(dev, 458836U, 16843009U);
#line 554
    REGISTER_WRITE(dev, 458840U, 464U);
#line 556
    gma_wait_for_vblank(dev);
#line 558
    (*((dev_priv->ops)->disable_sr))(dev);
  }
#line 560
  return;
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c"
static int cdv_intel_panel_fitter_pipe(struct drm_device *dev ) 
{ 
  u32 pfit_control ;

  {
#line 570
  pfit_control = REGISTER_READ(dev, 397872U);
#line 573
  if ((int )pfit_control >= 0) {
#line 574
    return (-1);
  } else {

  }
#line 575
  return ((int )(pfit_control >> 29) & 3);
}
}
#line 578 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c"
static int cdv_intel_crtc_mode_set(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                                   struct drm_display_mode *adjusted_mode , int x ,
                                   int y , struct drm_framebuffer *old_fb ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  struct psb_offset  const  *map ;
  int refclk ;
  struct gma_clock_t clock ;
  u32 dpll ;
  u32 dspcntr ;
  u32 pipeconf ;
  bool ok ;
  bool is_crt ;
  bool is_lvds ;
  bool is_tv ;
  bool is_hdmi ;
  bool is_dp ;
  struct drm_mode_config *mode_config ;
  struct drm_connector *connector ;
  struct gma_limit_t  const  *limit ;
  u32 ddi_select ;
  bool is_edp___0 ;
  struct list_head  const  *__mptr___0 ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct list_head  const  *__mptr___1 ;
  long tmp___0 ;
  uint32_t tmp___1 ;
  u32 lvds ;
  uint32_t tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  int sdvo_pixel_multiply ;
  struct drm_crtc_helper_funcs  const  *crtc_funcs ;

  {
#line 584
  dev = crtc->dev;
#line 585
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 586
  __mptr = (struct drm_crtc  const  *)crtc;
#line 586
  gma_crtc = (struct gma_crtc *)__mptr;
#line 587
  pipe = gma_crtc->pipe;
#line 588
  map = dev_priv->regmap + (unsigned long )pipe;
#line 591
  dpll = 0U;
#line 593
  is_crt = 0;
#line 593
  is_lvds = 0;
#line 593
  is_tv = 0;
#line 594
  is_hdmi = 0;
#line 594
  is_dp = 0;
#line 595
  mode_config = & dev->mode_config;
#line 598
  ddi_select = 0U;
#line 599
  is_edp___0 = 0;
#line 601
  __mptr___0 = (struct list_head  const  *)mode_config->connector_list.next;
#line 601
  connector = (struct drm_connector *)__mptr___0 + 0xffffffffffffffe8UL;
#line 601
  goto ldv_42400;
  ldv_42399: 
#line 602
  tmp = gma_attached_encoder(connector);
#line 602
  gma_encoder = tmp;
#line 605
  if ((unsigned long )connector->encoder == (unsigned long )((struct drm_encoder *)0) || (unsigned long )(connector->encoder)->crtc != (unsigned long )crtc) {
#line 607
    goto ldv_42390;
  } else {

  }
#line 609
  ddi_select = gma_encoder->ddi_select;
#line 610
  switch (gma_encoder->type) {
  case 4: 
#line 612
  is_lvds = 1;
#line 613
  goto ldv_42392;
  case 5: 
#line 615
  is_tv = 1;
#line 616
  goto ldv_42392;
  case 1: 
#line 618
  is_crt = 1;
#line 619
  goto ldv_42392;
  case 6: 
#line 621
  is_hdmi = 1;
#line 622
  goto ldv_42392;
  case 9: 
#line 624
  is_dp = 1;
#line 625
  goto ldv_42392;
  case 10: 
#line 627
  is_edp___0 = 1;
#line 628
  goto ldv_42392;
  default: 
#line 630
  drm_err("invalid output type.\n");
#line 631
  return (0);
  }
  ldv_42392: ;
  ldv_42390: 
#line 601
  __mptr___1 = (struct list_head  const  *)connector->head.next;
#line 601
  connector = (struct drm_connector *)__mptr___1 + 0xffffffffffffffe8UL;
  ldv_42400: ;
#line 601
  if ((unsigned long )(& connector->head) != (unsigned long )(& mode_config->connector_list)) {
#line 603
    goto ldv_42399;
  } else {

  }

#line 635
  if ((int )dev_priv->dplla_96mhz) {
#line 637
    refclk = 96000;
  } else {
#line 640
    refclk = 27000;
  }
#line 641
  if ((int )is_dp || (int )is_edp___0) {
#line 650
    if (pipe == 0) {
#line 651
      refclk = 27000;
    } else {
#line 653
      refclk = 100000;
    }
  } else {

  }
#line 656
  if ((int )is_lvds && (unsigned int )*((unsigned char *)dev_priv + 864UL) != 0U) {
#line 657
    refclk = dev_priv->lvds_ssc_freq * 1000;
#line 658
    tmp___0 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 658
    if (tmp___0 != 0L) {
#line 658
      drm_ut_debug_printk("cdv_intel_crtc_mode_set", "Use SSC reference clock %d Mhz\n",
                          dev_priv->lvds_ssc_freq);
    } else {

    }
  } else {

  }
#line 661
  drm_mode_debug_printmodeline((struct drm_display_mode  const  *)adjusted_mode);
#line 663
  limit = (*((gma_crtc->clock_funcs)->limit))(crtc, refclk);
#line 665
  ok = (*(limit->find_pll))(limit, crtc, adjusted_mode->clock, refclk, & clock);
#line 667
  if (! ok) {
#line 668
    drm_err("Couldn\'t find PLL settings for mode! target: %d, actual: %d", adjusted_mode->clock,
            clock.dot);
#line 670
    return (0);
  } else {

  }
#line 673
  dpll = 268435456U;
#line 674
  if ((int )is_tv) {
#line 677
    dpll = dpll | 3U;
  } else {

  }
#line 681
  if ((int )is_dp || (int )is_edp___0) {
#line 682
    cdv_intel_dp_set_m_n(crtc, mode, adjusted_mode);
  } else {
#line 684
    REGISTER_WRITE(dev, (uint32_t )(pipe * 4096 + 458832), 0U);
#line 685
    REGISTER_WRITE(dev, (uint32_t )(pipe * 4096 + 458836), 0U);
#line 686
    REGISTER_WRITE(dev, (uint32_t )(pipe * 4096 + 458848), 0U);
#line 687
    REGISTER_WRITE(dev, (uint32_t )(pipe * 4096 + 458852), 0U);
  }
#line 690
  dpll = dpll | 536870912U;
#line 698
  pipeconf = REGISTER_READ(dev, map->conf);
#line 700
  pipeconf = pipeconf & 4294967071U;
#line 701
  if ((int )is_edp___0) {
#line 702
    switch (dev_priv->edp.bpp) {
    case 24: 
#line 704
    pipeconf = pipeconf;
#line 705
    goto ldv_42404;
    case 18: 
#line 707
    pipeconf = pipeconf | 64U;
#line 708
    goto ldv_42404;
    case 30: 
#line 710
    pipeconf = pipeconf | 32U;
#line 711
    goto ldv_42404;
    default: 
#line 713
    pipeconf = pipeconf;
#line 714
    goto ldv_42404;
    }
    ldv_42404: ;
  } else
#line 716
  if ((int )is_lvds) {
#line 718
    tmp___1 = REGISTER_READ(dev, 397696U);
#line 718
    if ((tmp___1 & 192U) == 192U) {
#line 719
      pipeconf = pipeconf;
    } else {
#line 721
      pipeconf = pipeconf | 64U;
    }
  } else {
#line 723
    pipeconf = pipeconf;
  }
#line 726
  dspcntr = 1073741824U;
#line 728
  if (pipe == 0) {
#line 729
    dspcntr = dspcntr;
  } else {
#line 731
    dspcntr = dspcntr | 16777216U;
  }
#line 733
  dspcntr = dspcntr | 2147483648U;
#line 734
  pipeconf = pipeconf | 2147483648U;
#line 736
  REGISTER_WRITE(dev, map->dpll, dpll | 805306368U);
#line 737
  REGISTER_READ(dev, map->dpll);
#line 739
  cdv_dpll_set_clock_cdv(dev, crtc, & clock, (int )is_lvds, ddi_select);
#line 741
  __const_udelay(644250UL);
#line 748
  if ((int )is_lvds) {
#line 749
    tmp___2 = REGISTER_READ(dev, 397696U);
#line 749
    lvds = tmp___2;
#line 751
    lvds = lvds | 3221226240U;
#line 758
    if (clock.p2 == 7) {
#line 759
      lvds = lvds | 60U;
    } else {
#line 761
      lvds = lvds & 4294967235U;
    }
#line 768
    REGISTER_WRITE(dev, 397696U, lvds);
#line 769
    REGISTER_READ(dev, 397696U);
  } else {

  }
#line 772
  dpll = dpll | 2147483648U;
#line 775
  tmp___3 = cdv_intel_panel_fitter_pipe(dev);
#line 775
  if (tmp___3 == pipe) {
#line 776
    REGISTER_WRITE(dev, 397872U, 0U);
  } else {

  }
#line 778
  tmp___4 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 778
  if (tmp___4 != 0L) {
#line 778
    drm_ut_debug_printk("cdv_intel_crtc_mode_set", "Mode for pipe %c:\n", pipe == 0 ? 65 : 66);
  } else {

  }
#line 779
  drm_mode_debug_printmodeline((struct drm_display_mode  const  *)mode);
#line 781
  tmp___5 = REGISTER_READ(dev, map->dpll);
#line 781
  REGISTER_WRITE(dev, map->dpll, (tmp___5 & 2147450879U) | 2147483648U);
#line 783
  REGISTER_READ(dev, map->dpll);
#line 785
  __const_udelay(644250UL);
#line 787
  tmp___6 = REGISTER_READ(dev, map->dpll);
#line 787
  if ((tmp___6 & 32768U) == 0U) {
#line 788
    dev_err((struct device  const  *)dev->dev, "Failed to get DPLL lock\n");
#line 789
    return (-16);
  } else {

  }
#line 793
  sdvo_pixel_multiply = adjusted_mode->clock / mode->clock;
#line 794
  REGISTER_WRITE(dev, map->dpll_md, (uint32_t )((sdvo_pixel_multiply + -1) << 8));
#line 797
  REGISTER_WRITE(dev, map->htotal, (uint32_t )((adjusted_mode->crtc_hdisplay + -1) | ((adjusted_mode->crtc_htotal + -1) << 16)));
#line 799
  REGISTER_WRITE(dev, map->hblank, (uint32_t )((adjusted_mode->crtc_hblank_start + -1) | ((adjusted_mode->crtc_hblank_end + -1) << 16)));
#line 801
  REGISTER_WRITE(dev, map->hsync, (uint32_t )((adjusted_mode->crtc_hsync_start + -1) | ((adjusted_mode->crtc_hsync_end + -1) << 16)));
#line 803
  REGISTER_WRITE(dev, map->vtotal, (uint32_t )((adjusted_mode->crtc_vdisplay + -1) | ((adjusted_mode->crtc_vtotal + -1) << 16)));
#line 805
  REGISTER_WRITE(dev, map->vblank, (uint32_t )((adjusted_mode->crtc_vblank_start + -1) | ((adjusted_mode->crtc_vblank_end + -1) << 16)));
#line 807
  REGISTER_WRITE(dev, map->vsync, (uint32_t )((adjusted_mode->crtc_vsync_start + -1) | ((adjusted_mode->crtc_vsync_end + -1) << 16)));
#line 812
  REGISTER_WRITE(dev, map->size, (uint32_t )(((mode->vdisplay + -1) << 16) | (mode->hdisplay + -1)));
#line 814
  REGISTER_WRITE(dev, map->pos, 0U);
#line 815
  REGISTER_WRITE(dev, map->src, (uint32_t )(((mode->hdisplay + -1) << 16) | (mode->vdisplay + -1)));
#line 817
  REGISTER_WRITE(dev, map->conf, pipeconf);
#line 818
  REGISTER_READ(dev, map->conf);
#line 820
  gma_wait_for_vblank(dev);
#line 822
  REGISTER_WRITE(dev, map->cntr, dspcntr);
#line 826
  crtc_funcs = (struct drm_crtc_helper_funcs  const  *)crtc->helper_private;
#line 828
  (*(crtc_funcs->mode_set_base))(crtc, x, y, old_fb);
#line 831
  gma_wait_for_vblank(dev);
#line 833
  return (0);
}
}
#line 840 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c"
static void i8xx_clock(int refclk , struct gma_clock_t *clock ) 
{ 


  {
#line 842
  clock->m = (clock->m1 * 5 + 10) + (clock->m2 + 2);
#line 843
  clock->p = clock->p1 * clock->p2;
#line 844
  clock->vco = (clock->m * refclk) / (clock->n + 2);
#line 845
  clock->dot = clock->vco / clock->p;
#line 846
  return;
}
}
#line 849 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c"
static int cdv_intel_crtc_clock_get(struct drm_device *dev , struct drm_crtc *crtc ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  struct psb_offset  const  *map ;
  u32 dpll ;
  u32 fp ;
  struct gma_clock_t clock ;
  bool is_lvds ;
  struct psb_pipe *p ;
  uint32_t tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 852
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 853
  __mptr = (struct drm_crtc  const  *)crtc;
#line 853
  gma_crtc = (struct gma_crtc *)__mptr;
#line 854
  pipe = gma_crtc->pipe;
#line 855
  map = dev_priv->regmap + (unsigned long )pipe;
#line 860
  p = (struct psb_pipe *)(& dev_priv->regs.pipe) + (unsigned long )pipe;
#line 862
  tmp___1 = gma_power_begin(dev, 0);
#line 862
  if ((int )tmp___1) {
#line 863
    dpll = REGISTER_READ(dev, map->dpll);
#line 864
    if ((dpll & 256U) == 0U) {
#line 865
      fp = REGISTER_READ(dev, map->fp0);
    } else {
#line 867
      fp = REGISTER_READ(dev, map->fp1);
    }
#line 868
    if (pipe == 1) {
#line 868
      tmp = REGISTER_READ(dev, 397696U);
#line 868
      if ((int )tmp < 0) {
#line 868
        tmp___0 = 1;
      } else {
#line 868
        tmp___0 = 0;
      }
    } else {
#line 868
      tmp___0 = 0;
    }
#line 868
    is_lvds = (bool )tmp___0;
#line 869
    gma_power_end(dev);
  } else {
#line 871
    dpll = p->dpll;
#line 872
    if ((dpll & 256U) == 0U) {
#line 873
      fp = p->fp0;
    } else {
#line 875
      fp = p->fp1;
    }
#line 877
    is_lvds = (bool )(pipe == 1 && (int )dev_priv->regs.__annonCompField80.psb.saveLVDS < 0);
  }
#line 881
  clock.m1 = (int )((fp & 16128U) >> 8);
#line 882
  clock.m2 = (int )fp & 63;
#line 883
  clock.n = (int )((fp & 4128768U) >> 16);
#line 885
  if ((int )is_lvds) {
#line 886
    clock.p1 = ffs((int )((dpll & 4128768U) >> 16));
#line 890
    if (clock.p1 == 0) {
#line 891
      clock.p1 = 4;
#line 892
      dev_err((struct device  const  *)dev->dev, "PLL %d\n", dpll);
    } else {

    }
#line 894
    clock.p2 = 14;
#line 896
    if ((dpll & 24576U) == 24576U) {
#line 899
      i8xx_clock(66000, & clock);
    } else {
#line 901
      i8xx_clock(48000, & clock);
    }
  } else {
#line 903
    if ((dpll & 2097152U) != 0U) {
#line 904
      clock.p1 = 2;
    } else {
#line 906
      clock.p1 = (int )(((dpll & 2031616U) >> 16) + 2U);
    }
#line 911
    if ((dpll & 8388608U) != 0U) {
#line 912
      clock.p2 = 4;
    } else {
#line 914
      clock.p2 = 2;
    }
#line 916
    i8xx_clock(48000, & clock);
  }
#line 924
  return (clock.dot);
}
}
#line 928 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c"
struct drm_display_mode *cdv_intel_crtc_mode_get(struct drm_device *dev , struct drm_crtc *crtc ) 
{ 
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  struct drm_psb_private *dev_priv ;
  struct psb_pipe *p ;
  struct psb_offset  const  *map ;
  struct drm_display_mode *mode ;
  int htot ;
  int hsync ;
  int vtot ;
  int vsync ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  bool tmp___3 ;
  void *tmp___4 ;

  {
#line 931
  __mptr = (struct drm_crtc  const  *)crtc;
#line 931
  gma_crtc = (struct gma_crtc *)__mptr;
#line 932
  pipe = gma_crtc->pipe;
#line 933
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 934
  p = (struct psb_pipe *)(& dev_priv->regs.pipe) + (unsigned long )pipe;
#line 935
  map = dev_priv->regmap + (unsigned long )pipe;
#line 942
  tmp___3 = gma_power_begin(dev, 0);
#line 942
  if ((int )tmp___3) {
#line 943
    tmp = REGISTER_READ(dev, map->htotal);
#line 943
    htot = (int )tmp;
#line 944
    tmp___0 = REGISTER_READ(dev, map->hsync);
#line 944
    hsync = (int )tmp___0;
#line 945
    tmp___1 = REGISTER_READ(dev, map->vtotal);
#line 945
    vtot = (int )tmp___1;
#line 946
    tmp___2 = REGISTER_READ(dev, map->vsync);
#line 946
    vsync = (int )tmp___2;
#line 947
    gma_power_end(dev);
  } else {
#line 949
    htot = (int )p->htotal;
#line 950
    hsync = (int )p->hsync;
#line 951
    vtot = (int )p->vtotal;
#line 952
    vsync = (int )p->vsync;
  }
#line 955
  tmp___4 = kzalloc(208UL, 208U);
#line 955
  mode = (struct drm_display_mode *)tmp___4;
#line 956
  if ((unsigned long )mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 957
    return ((struct drm_display_mode *)0);
  } else {

  }
#line 959
  mode->clock = cdv_intel_crtc_clock_get(dev, crtc);
#line 960
  mode->hdisplay = (htot & 65535) + 1;
#line 961
  mode->htotal = (int )(((unsigned int )htot >> 16) + 1U);
#line 962
  mode->hsync_start = (hsync & 65535) + 1;
#line 963
  mode->hsync_end = (int )(((unsigned int )hsync >> 16) + 1U);
#line 964
  mode->vdisplay = (vtot & 65535) + 1;
#line 965
  mode->vtotal = (int )(((unsigned int )vtot >> 16) + 1U);
#line 966
  mode->vsync_start = (vsync & 65535) + 1;
#line 967
  mode->vsync_end = (int )(((unsigned int )vsync >> 16) + 1U);
#line 969
  drm_mode_set_name(mode);
#line 970
  drm_mode_set_crtcinfo(mode, 0);
#line 972
  return (mode);
}
}
#line 975 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c"
struct drm_crtc_helper_funcs  const  cdv_intel_helper_funcs  = 
#line 975
     {& gma_crtc_dpms, & gma_crtc_prepare, & gma_crtc_commit, & gma_crtc_mode_fixup,
    & cdv_intel_crtc_mode_set, 0, & gma_pipe_set_base, 0, 0, & gma_crtc_disable, 0,
    0, 0, 0};
#line 985 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c"
struct drm_crtc_funcs  const  cdv_intel_crtc_funcs  = 
#line 985
     {& gma_crtc_save, & gma_crtc_restore, 0, & gma_crtc_cursor_set, 0, & gma_crtc_cursor_move,
    & gma_crtc_gamma_set, & gma_crtc_destroy, & gma_crtc_set_config, 0, 0, 0, 0, 0,
    0};
#line 995 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c"
struct gma_clock_funcs  const  cdv_clock_funcs  =    {& cdv_intel_clock, & cdv_intel_limit, & gma_pll_is_valid};
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
extern int ldv_connect_28(void) ;
#line 405
extern int ldv_bind_28(void) ;
#line 406
extern int ldv_probe_27(void) ;
#line 407
extern int ldv_release_28(void) ;
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void ldv_initialize_drm_crtc_funcs_27(void) 
{ 
  void *tmp ;

  {
#line 411
  tmp = ldv_init_zalloc(1160UL);
#line 411
  cdv_intel_crtc_funcs_group0 = (struct drm_crtc *)tmp;
#line 412
  return;
}
}
#line 414 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void ldv_initialize_gma_clock_funcs_26(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 415
  tmp = ldv_init_zalloc(1160UL);
#line 415
  cdv_clock_funcs_group0 = (struct drm_crtc *)tmp;
#line 416
  tmp___0 = ldv_init_zalloc(36UL);
#line 416
  cdv_clock_funcs_group1 = (struct gma_clock_t *)tmp___0;
#line 417
  return;
}
}
#line 419 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void ldv_initialize_drm_crtc_helper_funcs_28(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 420
  tmp = ldv_init_zalloc(1160UL);
#line 420
  cdv_intel_helper_funcs_group0 = (struct drm_crtc *)tmp;
#line 421
  tmp___0 = ldv_init_zalloc(168UL);
#line 421
  cdv_intel_helper_funcs_group1 = (struct drm_framebuffer *)tmp___0;
#line 422
  tmp___1 = ldv_init_zalloc(208UL);
#line 422
  cdv_intel_helper_funcs_group2 = (struct drm_display_mode *)tmp___1;
#line 423
  return;
}
}
#line 425 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void ldv_main_exported_27(void) 
{ 
  uint32_t ldvarg47 ;
  uint32_t ldvarg44 ;
  u16 *ldvarg40 ;
  void *tmp ;
  int ldvarg48 ;
  struct drm_file *ldvarg46 ;
  void *tmp___0 ;
  int ldvarg49 ;
  struct drm_mode_set *ldvarg38 ;
  void *tmp___1 ;
  u16 *ldvarg42 ;
  void *tmp___2 ;
  uint32_t ldvarg43 ;
  u16 *ldvarg41 ;
  void *tmp___3 ;
  uint32_t ldvarg39 ;
  uint32_t ldvarg45 ;
  int tmp___4 ;

  {
#line 428
  tmp = ldv_init_zalloc(2UL);
#line 428
  ldvarg40 = (u16 *)tmp;
#line 430
  tmp___0 = ldv_init_zalloc(744UL);
#line 430
  ldvarg46 = (struct drm_file *)tmp___0;
#line 432
  tmp___1 = ldv_init_zalloc(48UL);
#line 432
  ldvarg38 = (struct drm_mode_set *)tmp___1;
#line 433
  tmp___2 = ldv_init_zalloc(2UL);
#line 433
  ldvarg42 = (u16 *)tmp___2;
#line 435
  tmp___3 = ldv_init_zalloc(2UL);
#line 435
  ldvarg41 = (u16 *)tmp___3;
#line 426
  ldv_memset((void *)(& ldvarg47), 0, 4UL);
#line 427
  ldv_memset((void *)(& ldvarg44), 0, 4UL);
#line 429
  ldv_memset((void *)(& ldvarg48), 0, 4UL);
#line 431
  ldv_memset((void *)(& ldvarg49), 0, 4UL);
#line 434
  ldv_memset((void *)(& ldvarg43), 0, 4UL);
#line 436
  ldv_memset((void *)(& ldvarg39), 0, 4UL);
#line 437
  ldv_memset((void *)(& ldvarg45), 0, 4UL);
#line 439
  tmp___4 = __VERIFIER_nondet_int();
#line 439
  switch (tmp___4) {
  case 0: ;
#line 442
  if (ldv_state_variable_27 == 1) {
#line 444
    gma_crtc_cursor_move(cdv_intel_crtc_funcs_group0, ldvarg49, ldvarg48);
#line 446
    ldv_state_variable_27 = 1;
  } else {

  }
#line 449
  if (ldv_state_variable_27 == 2) {
#line 451
    gma_crtc_cursor_move(cdv_intel_crtc_funcs_group0, ldvarg49, ldvarg48);
#line 453
    ldv_state_variable_27 = 2;
  } else {

  }
#line 456
  goto ldv_42482;
  case 1: ;
#line 459
  if (ldv_state_variable_27 == 1) {
#line 461
    gma_crtc_cursor_set(cdv_intel_crtc_funcs_group0, ldvarg46, ldvarg45, ldvarg44,
                        ldvarg47);
#line 463
    ldv_state_variable_27 = 1;
  } else {

  }
#line 466
  if (ldv_state_variable_27 == 2) {
#line 468
    gma_crtc_cursor_set(cdv_intel_crtc_funcs_group0, ldvarg46, ldvarg45, ldvarg44,
                        ldvarg47);
#line 470
    ldv_state_variable_27 = 2;
  } else {

  }
#line 473
  goto ldv_42482;
  case 2: ;
#line 476
  if (ldv_state_variable_27 == 2) {
#line 478
    gma_crtc_destroy(cdv_intel_crtc_funcs_group0);
#line 480
    ldv_state_variable_27 = 1;
#line 481
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 484
  goto ldv_42482;
  case 3: ;
#line 487
  if (ldv_state_variable_27 == 1) {
#line 489
    gma_crtc_save(cdv_intel_crtc_funcs_group0);
#line 491
    ldv_state_variable_27 = 1;
  } else {

  }
#line 494
  if (ldv_state_variable_27 == 2) {
#line 496
    gma_crtc_save(cdv_intel_crtc_funcs_group0);
#line 498
    ldv_state_variable_27 = 2;
  } else {

  }
#line 501
  goto ldv_42482;
  case 4: ;
#line 504
  if (ldv_state_variable_27 == 1) {
#line 506
    gma_crtc_gamma_set(cdv_intel_crtc_funcs_group0, ldvarg42, ldvarg41, ldvarg40,
                       ldvarg43, ldvarg39);
#line 508
    ldv_state_variable_27 = 1;
  } else {

  }
#line 511
  if (ldv_state_variable_27 == 2) {
#line 513
    gma_crtc_gamma_set(cdv_intel_crtc_funcs_group0, ldvarg42, ldvarg41, ldvarg40,
                       ldvarg43, ldvarg39);
#line 515
    ldv_state_variable_27 = 2;
  } else {

  }
#line 518
  goto ldv_42482;
  case 5: ;
#line 521
  if (ldv_state_variable_27 == 1) {
#line 523
    gma_crtc_restore(cdv_intel_crtc_funcs_group0);
#line 525
    ldv_state_variable_27 = 1;
  } else {

  }
#line 528
  if (ldv_state_variable_27 == 2) {
#line 530
    gma_crtc_restore(cdv_intel_crtc_funcs_group0);
#line 532
    ldv_state_variable_27 = 2;
  } else {

  }
#line 535
  goto ldv_42482;
  case 6: ;
#line 538
  if (ldv_state_variable_27 == 1) {
#line 540
    gma_crtc_set_config(ldvarg38);
#line 542
    ldv_state_variable_27 = 1;
  } else {

  }
#line 545
  if (ldv_state_variable_27 == 2) {
#line 547
    gma_crtc_set_config(ldvarg38);
#line 549
    ldv_state_variable_27 = 2;
  } else {

  }
#line 552
  goto ldv_42482;
  case 7: ;
#line 555
  if (ldv_state_variable_27 == 1) {
#line 557
    ldv_probe_27();
#line 559
    ldv_state_variable_27 = 2;
#line 560
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 563
  goto ldv_42482;
  default: 
#line 564
  ldv_stop();
  }
  ldv_42482: ;
#line 568
  return;
}
}
#line 570 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void ldv_main_exported_28(void) 
{ 
  struct drm_display_mode *ldvarg56 ;
  void *tmp ;
  int ldvarg59 ;
  int ldvarg55 ;
  int ldvarg53 ;
  struct drm_display_mode *ldvarg54 ;
  void *tmp___0 ;
  int ldvarg58 ;
  int ldvarg57 ;
  int tmp___1 ;

  {
#line 571
  tmp = ldv_init_zalloc(208UL);
#line 571
  ldvarg56 = (struct drm_display_mode *)tmp;
#line 575
  tmp___0 = ldv_init_zalloc(208UL);
#line 575
  ldvarg54 = (struct drm_display_mode *)tmp___0;
#line 572
  ldv_memset((void *)(& ldvarg59), 0, 4UL);
#line 573
  ldv_memset((void *)(& ldvarg55), 0, 4UL);
#line 574
  ldv_memset((void *)(& ldvarg53), 0, 4UL);
#line 576
  ldv_memset((void *)(& ldvarg58), 0, 4UL);
#line 577
  ldv_memset((void *)(& ldvarg57), 0, 4UL);
#line 579
  tmp___1 = __VERIFIER_nondet_int();
#line 579
  switch (tmp___1) {
  case 0: ;
#line 582
  if (ldv_state_variable_28 == 1) {
#line 584
    gma_pipe_set_base(cdv_intel_helper_funcs_group0, ldvarg59, ldvarg58, cdv_intel_helper_funcs_group1);
#line 586
    ldv_state_variable_28 = 1;
  } else {

  }
#line 589
  if (ldv_state_variable_28 == 3) {
#line 591
    gma_pipe_set_base(cdv_intel_helper_funcs_group0, ldvarg59, ldvarg58, cdv_intel_helper_funcs_group1);
#line 593
    ldv_state_variable_28 = 3;
  } else {

  }
#line 596
  if (ldv_state_variable_28 == 2) {
#line 598
    gma_pipe_set_base(cdv_intel_helper_funcs_group0, ldvarg59, ldvarg58, cdv_intel_helper_funcs_group1);
#line 600
    ldv_state_variable_28 = 2;
  } else {

  }
#line 603
  goto ldv_42502;
  case 1: ;
#line 606
  if (ldv_state_variable_28 == 1) {
#line 608
    gma_crtc_dpms(cdv_intel_helper_funcs_group0, ldvarg57);
#line 610
    ldv_state_variable_28 = 1;
  } else {

  }
#line 613
  if (ldv_state_variable_28 == 3) {
#line 615
    gma_crtc_dpms(cdv_intel_helper_funcs_group0, ldvarg57);
#line 617
    ldv_state_variable_28 = 3;
  } else {

  }
#line 620
  if (ldv_state_variable_28 == 2) {
#line 622
    gma_crtc_dpms(cdv_intel_helper_funcs_group0, ldvarg57);
#line 624
    ldv_state_variable_28 = 2;
  } else {

  }
#line 627
  goto ldv_42502;
  case 2: ;
#line 630
  if (ldv_state_variable_28 == 1) {
#line 632
    gma_crtc_mode_fixup(cdv_intel_helper_funcs_group0, (struct drm_display_mode  const  *)ldvarg56,
                        cdv_intel_helper_funcs_group2);
#line 634
    ldv_state_variable_28 = 1;
  } else {

  }
#line 637
  if (ldv_state_variable_28 == 3) {
#line 639
    gma_crtc_mode_fixup(cdv_intel_helper_funcs_group0, (struct drm_display_mode  const  *)ldvarg56,
                        cdv_intel_helper_funcs_group2);
#line 641
    ldv_state_variable_28 = 3;
  } else {

  }
#line 644
  if (ldv_state_variable_28 == 2) {
#line 646
    gma_crtc_mode_fixup(cdv_intel_helper_funcs_group0, (struct drm_display_mode  const  *)ldvarg56,
                        cdv_intel_helper_funcs_group2);
#line 648
    ldv_state_variable_28 = 2;
  } else {

  }
#line 651
  goto ldv_42502;
  case 3: ;
#line 654
  if (ldv_state_variable_28 == 1) {
#line 656
    gma_crtc_commit(cdv_intel_helper_funcs_group0);
#line 658
    ldv_state_variable_28 = 1;
  } else {

  }
#line 661
  if (ldv_state_variable_28 == 3) {
#line 663
    gma_crtc_commit(cdv_intel_helper_funcs_group0);
#line 665
    ldv_state_variable_28 = 3;
  } else {

  }
#line 668
  if (ldv_state_variable_28 == 2) {
#line 670
    gma_crtc_commit(cdv_intel_helper_funcs_group0);
#line 672
    ldv_state_variable_28 = 2;
  } else {

  }
#line 675
  goto ldv_42502;
  case 4: ;
#line 678
  if (ldv_state_variable_28 == 1) {
#line 680
    cdv_intel_crtc_mode_set(cdv_intel_helper_funcs_group0, cdv_intel_helper_funcs_group2,
                            ldvarg54, ldvarg53, ldvarg55, cdv_intel_helper_funcs_group1);
#line 682
    ldv_state_variable_28 = 1;
  } else {

  }
#line 685
  if (ldv_state_variable_28 == 3) {
#line 687
    cdv_intel_crtc_mode_set(cdv_intel_helper_funcs_group0, cdv_intel_helper_funcs_group2,
                            ldvarg54, ldvarg53, ldvarg55, cdv_intel_helper_funcs_group1);
#line 689
    ldv_state_variable_28 = 3;
  } else {

  }
#line 692
  if (ldv_state_variable_28 == 2) {
#line 694
    cdv_intel_crtc_mode_set(cdv_intel_helper_funcs_group0, cdv_intel_helper_funcs_group2,
                            ldvarg54, ldvarg53, ldvarg55, cdv_intel_helper_funcs_group1);
#line 696
    ldv_state_variable_28 = 2;
  } else {

  }
#line 699
  goto ldv_42502;
  case 5: ;
#line 702
  if (ldv_state_variable_28 == 3) {
#line 704
    gma_crtc_disable(cdv_intel_helper_funcs_group0);
#line 705
    ldv_state_variable_28 = 2;
  } else {

  }
#line 708
  goto ldv_42502;
  case 6: ;
#line 711
  if (ldv_state_variable_28 == 1) {
#line 713
    gma_crtc_prepare(cdv_intel_helper_funcs_group0);
#line 715
    ldv_state_variable_28 = 1;
  } else {

  }
#line 718
  if (ldv_state_variable_28 == 3) {
#line 720
    gma_crtc_prepare(cdv_intel_helper_funcs_group0);
#line 722
    ldv_state_variable_28 = 3;
  } else {

  }
#line 725
  if (ldv_state_variable_28 == 2) {
#line 727
    gma_crtc_prepare(cdv_intel_helper_funcs_group0);
#line 729
    ldv_state_variable_28 = 2;
  } else {

  }
#line 732
  goto ldv_42502;
  case 7: ;
#line 735
  if (ldv_state_variable_28 == 2) {
#line 737
    ldv_release_28();
#line 738
    ldv_state_variable_28 = 1;
#line 739
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 742
  goto ldv_42502;
  case 8: ;
#line 745
  if (ldv_state_variable_28 == 1) {
#line 747
    ldv_bind_28();
#line 748
    ldv_state_variable_28 = 2;
#line 749
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 752
  goto ldv_42502;
  case 9: ;
#line 755
  if (ldv_state_variable_28 == 2) {
#line 757
    ldv_connect_28();
#line 758
    ldv_state_variable_28 = 3;
  } else {

  }
#line 761
  goto ldv_42502;
  default: 
#line 762
  ldv_stop();
  }
  ldv_42502: ;
#line 766
  return;
}
}
#line 768 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void ldv_main_exported_26(void) 
{ 
  struct gma_limit_t *ldvarg12 ;
  void *tmp ;
  int ldvarg10 ;
  int ldvarg11 ;
  int tmp___0 ;

  {
#line 769
  tmp = ldv_init_zalloc(88UL);
#line 769
  ldvarg12 = (struct gma_limit_t *)tmp;
#line 770
  ldv_memset((void *)(& ldvarg10), 0, 4UL);
#line 771
  ldv_memset((void *)(& ldvarg11), 0, 4UL);
#line 773
  tmp___0 = __VERIFIER_nondet_int();
#line 773
  switch (tmp___0) {
  case 0: ;
#line 776
  if (ldv_state_variable_26 == 1) {
#line 778
    gma_pll_is_valid(cdv_clock_funcs_group0, (struct gma_limit_t  const  *)ldvarg12,
                     cdv_clock_funcs_group1);
#line 780
    ldv_state_variable_26 = 1;
  } else {

  }
#line 783
  goto ldv_42520;
  case 1: ;
#line 786
  if (ldv_state_variable_26 == 1) {
#line 788
    cdv_intel_clock(ldvarg11, cdv_clock_funcs_group1);
#line 790
    ldv_state_variable_26 = 1;
  } else {

  }
#line 793
  goto ldv_42520;
  case 2: ;
#line 796
  if (ldv_state_variable_26 == 1) {
#line 798
    cdv_intel_limit(cdv_clock_funcs_group0, ldvarg10);
#line 800
    ldv_state_variable_26 = 1;
  } else {

  }
#line 803
  goto ldv_42520;
  default: 
#line 804
  ldv_stop();
  }
  ldv_42520: ;
#line 808
  return;
}
}
#line 833 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
bool ldv_queue_work_on_1187(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 837
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 837
  ldv_func_res = tmp;
#line 839
  activate_work_2(ldv_func_arg3, 2);
#line 841
  return (ldv_func_res);
}
}
#line 844 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
bool ldv_queue_delayed_work_on_1188(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 848
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 848
  ldv_func_res = tmp;
#line 850
  activate_work_2(& ldv_func_arg3->work, 2);
#line 852
  return (ldv_func_res);
}
}
#line 855 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
bool ldv_queue_work_on_1189(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 859
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 859
  ldv_func_res = tmp;
#line 861
  activate_work_2(ldv_func_arg3, 2);
#line 863
  return (ldv_func_res);
}
}
#line 866 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void ldv_flush_workqueue_1190(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 869
  flush_workqueue(ldv_func_arg1);
#line 871
  call_and_disable_all_2(2);
#line 872
  return;
}
}
#line 874 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
bool ldv_queue_delayed_work_on_1191(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 878
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 878
  ldv_func_res = tmp;
#line 880
  activate_work_2(& ldv_func_arg3->work, 2);
#line 882
  return (ldv_func_res);
}
}
#line 885 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void ldv_mutex_lock_1192(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 888
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 890
  mutex_lock(ldv_func_arg1);
#line 891
  return;
}
}
#line 893 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void ldv_mutex_unlock_1193(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 896
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 898
  mutex_unlock(ldv_func_arg1);
#line 899
  return;
}
}
#line 901 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void ldv_mutex_lock_1194(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 904
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 906
  mutex_lock(ldv_func_arg1);
#line 907
  return;
}
}
#line 909 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
int ldv_mutex_trylock_1195(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 913
  tmp = mutex_trylock(ldv_func_arg1);
#line 913
  ldv_func_res = tmp;
#line 915
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 915
  return (tmp___0);
#line 917
  return (ldv_func_res);
}
}
#line 920 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void ldv_mutex_unlock_1196(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 923
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 925
  mutex_unlock(ldv_func_arg1);
#line 926
  return;
}
}
#line 928 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void ldv_mutex_unlock_1197(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 931
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 933
  mutex_unlock(ldv_func_arg1);
#line 934
  return;
}
}
#line 936 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void ldv_mutex_lock_1198(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 939
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 941
  mutex_lock(ldv_func_arg1);
#line 942
  return;
}
}
#line 944 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void ldv_mutex_lock_1199(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 947
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 949
  mutex_lock(ldv_func_arg1);
#line 950
  return;
}
}
#line 952 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void ldv_mutex_unlock_1200(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 955
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 957
  mutex_unlock(ldv_func_arg1);
#line 958
  return;
}
}
#line 960 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void ldv_mutex_unlock_1201(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 963
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 965
  mutex_unlock(ldv_func_arg1);
#line 966
  return;
}
}
#line 968 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void ldv_mutex_lock_1202(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 971
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 973
  mutex_lock(ldv_func_arg1);
#line 974
  return;
}
}
#line 976 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
int ldv_mutex_lock_interruptible_1203(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 980
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 980
  ldv_func_res = tmp;
#line 982
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 982
  return (tmp___0);
#line 984
  return (ldv_func_res);
}
}
#line 987 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
int ldv_mutex_trylock_1204(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 991
  tmp = mutex_trylock(ldv_func_arg1);
#line 991
  ldv_func_res = tmp;
#line 993
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 993
  return (tmp___0);
#line 995
  return (ldv_func_res);
}
}
#line 1019 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void ldv_mutex_unlock_1207(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1022
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 1024
  mutex_unlock(ldv_func_arg1);
#line 1025
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_1240(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_1249(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_1238(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_1241(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_1242(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_1245(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_1246(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_1252(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
int ldv_mutex_lock_interruptible_1248(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_1237(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_1239(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_1243(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_1244(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_1247(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_1232(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_1234(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_1233(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_1236(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_1235(struct workqueue_struct *ldv_func_arg1 ) ;
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.c"
static void cdv_hdmi_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                              struct drm_display_mode *adjusted_mode ) 
{ 
  struct drm_device *dev ;
  struct gma_encoder *gma_encoder ;
  struct drm_encoder  const  *__mptr ;
  struct mid_intel_hdmi_priv *hdmi_priv ;
  u32 hdmib ;
  struct drm_crtc *crtc ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr___0 ;

  {
#line 66
  dev = encoder->dev;
#line 67
  __mptr = (struct drm_encoder  const  *)encoder;
#line 67
  gma_encoder = (struct gma_encoder *)__mptr;
#line 68
  hdmi_priv = (struct mid_intel_hdmi_priv *)gma_encoder->dev_priv;
#line 70
  crtc = encoder->crtc;
#line 71
  __mptr___0 = (struct drm_crtc  const  *)crtc;
#line 71
  gma_crtc = (struct gma_crtc *)__mptr___0;
#line 73
  hdmib = 2048U;
#line 75
  if ((adjusted_mode->flags & 4U) != 0U) {
#line 76
    hdmib = hdmib | 16U;
  } else {

  }
#line 77
  if ((int )adjusted_mode->flags & 1) {
#line 78
    hdmib = hdmib | 8U;
  } else {

  }
#line 80
  if (gma_crtc->pipe == 1) {
#line 81
    hdmib = hdmib | 1073741824U;
  } else {

  }
#line 83
  if ((int )hdmi_priv->has_hdmi_audio) {
#line 84
    hdmib = hdmib | 64U;
#line 85
    hdmib = hdmib | 512U;
  } else {

  }
#line 88
  REGISTER_WRITE(dev, hdmi_priv->hdmi_reg, hdmib);
#line 89
  REGISTER_READ(dev, hdmi_priv->hdmi_reg);
#line 90
  return;
}
}
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.c"
static void cdv_hdmi_dpms(struct drm_encoder *encoder , int mode ) 
{ 
  struct drm_device *dev ;
  struct gma_encoder *gma_encoder ;
  struct drm_encoder  const  *__mptr ;
  struct mid_intel_hdmi_priv *hdmi_priv ;
  u32 hdmib ;

  {
#line 94
  dev = encoder->dev;
#line 95
  __mptr = (struct drm_encoder  const  *)encoder;
#line 95
  gma_encoder = (struct gma_encoder *)__mptr;
#line 96
  hdmi_priv = (struct mid_intel_hdmi_priv *)gma_encoder->dev_priv;
#line 99
  hdmib = REGISTER_READ(dev, hdmi_priv->hdmi_reg);
#line 101
  if (mode != 0) {
#line 102
    REGISTER_WRITE(dev, hdmi_priv->hdmi_reg, hdmib & 2147483647U);
  } else {
#line 104
    REGISTER_WRITE(dev, hdmi_priv->hdmi_reg, hdmib | 2147483648U);
  }
#line 105
  REGISTER_READ(dev, hdmi_priv->hdmi_reg);
#line 106
  return;
}
}
#line 108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.c"
static void cdv_hdmi_save(struct drm_connector *connector ) 
{ 
  struct drm_device *dev ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct mid_intel_hdmi_priv *hdmi_priv ;

  {
#line 110
  dev = connector->dev;
#line 111
  tmp = gma_attached_encoder(connector);
#line 111
  gma_encoder = tmp;
#line 112
  hdmi_priv = (struct mid_intel_hdmi_priv *)gma_encoder->dev_priv;
#line 114
  hdmi_priv->save_HDMIB = REGISTER_READ(dev, hdmi_priv->hdmi_reg);
#line 115
  return;
}
}
#line 117 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.c"
static void cdv_hdmi_restore(struct drm_connector *connector ) 
{ 
  struct drm_device *dev ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct mid_intel_hdmi_priv *hdmi_priv ;

  {
#line 119
  dev = connector->dev;
#line 120
  tmp = gma_attached_encoder(connector);
#line 120
  gma_encoder = tmp;
#line 121
  hdmi_priv = (struct mid_intel_hdmi_priv *)gma_encoder->dev_priv;
#line 123
  REGISTER_WRITE(dev, hdmi_priv->hdmi_reg, hdmi_priv->save_HDMIB);
#line 124
  REGISTER_READ(dev, hdmi_priv->hdmi_reg);
#line 125
  return;
}
}
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.c"
static enum drm_connector_status cdv_hdmi_detect(struct drm_connector *connector ,
                                                 bool force ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct mid_intel_hdmi_priv *hdmi_priv ;
  struct edid *edid ;
  enum drm_connector_status status ;

  {
#line 130
  tmp = gma_attached_encoder(connector);
#line 130
  gma_encoder = tmp;
#line 131
  hdmi_priv = (struct mid_intel_hdmi_priv *)gma_encoder->dev_priv;
#line 132
  edid = (struct edid *)0;
#line 133
  status = 2;
#line 135
  edid = drm_get_edid(connector, & (gma_encoder->i2c_bus)->adapter);
#line 137
  hdmi_priv->has_hdmi_sink = 0;
#line 138
  hdmi_priv->has_hdmi_audio = 0;
#line 139
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
#line 140
    if ((int )((signed char )edid->input) < 0) {
#line 141
      status = 1;
#line 142
      hdmi_priv->has_hdmi_sink = drm_detect_hdmi_monitor(edid);
#line 144
      hdmi_priv->has_hdmi_audio = drm_detect_monitor_audio(edid);
    } else {

    }
#line 147
    kfree((void const   *)edid);
  } else {

  }
#line 149
  return (status);
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.c"
static int cdv_hdmi_set_property(struct drm_connector *connector , struct drm_property *property ,
                                 uint64_t value ) 
{ 
  struct drm_encoder *encoder ;
  struct gma_crtc *crtc ;
  struct drm_crtc  const  *__mptr ;
  bool centre ;
  uint64_t curValue ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  struct drm_encoder_helper_funcs  const  *helpers ;
  int tmp___3 ;

  {
#line 156
  encoder = connector->encoder;
#line 158
  tmp___3 = strcmp((char const   *)(& property->name), "scaling mode");
#line 158
  if (tmp___3 == 0 && (unsigned long )encoder != (unsigned long )((struct drm_encoder *)0)) {
#line 159
    __mptr = (struct drm_crtc  const  *)encoder->crtc;
#line 159
    crtc = (struct gma_crtc *)__mptr;
#line 163
    if ((unsigned long )crtc == (unsigned long )((struct gma_crtc *)0)) {
#line 164
      return (-1);
    } else {

    }
#line 166
    switch (value) {
    case 1ULL: ;
#line 168
    goto ldv_42139;
    case 2ULL: ;
#line 170
    goto ldv_42139;
    case 3ULL: ;
#line 172
    goto ldv_42139;
    default: ;
#line 174
    return (-1);
    }
    ldv_42139: 
#line 177
    tmp = drm_object_property_get_value(& connector->base, property, & curValue);
#line 177
    if (tmp != 0) {
#line 179
      return (-1);
    } else {

    }
#line 181
    if (curValue == value) {
#line 182
      return (0);
    } else {

    }
#line 184
    tmp___0 = drm_object_property_set_value(& connector->base, property, value);
#line 184
    if (tmp___0 != 0) {
#line 186
      return (-1);
    } else {

    }
#line 188
    centre = (bool )(curValue == 2ULL || value == 2ULL);
#line 191
    if (crtc->saved_mode.hdisplay != 0 && crtc->saved_mode.vdisplay != 0) {
#line 193
      if ((int )centre) {
#line 194
        tmp___1 = drm_crtc_helper_set_mode(encoder->crtc, & crtc->saved_mode, (encoder->crtc)->x,
                                           (encoder->crtc)->y, ((encoder->crtc)->primary)->fb);
#line 194
        if (tmp___1) {
#line 194
          tmp___2 = 0;
        } else {
#line 194
          tmp___2 = 1;
        }
#line 194
        if (tmp___2) {
#line 196
          return (-1);
        } else {

        }
      } else {
#line 198
        helpers = (struct drm_encoder_helper_funcs  const  *)encoder->helper_private;
#line 200
        (*(helpers->mode_set))(encoder, & crtc->saved_mode, & crtc->saved_adjusted_mode);
      }
    } else {

    }
  } else {

  }
#line 205
  return (0);
}
}
#line 211 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.c"
static int cdv_hdmi_get_modes(struct drm_connector *connector ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct edid *edid ;
  int ret ;

  {
#line 213
  tmp = gma_attached_encoder(connector);
#line 213
  gma_encoder = tmp;
#line 214
  edid = (struct edid *)0;
#line 215
  ret = 0;
#line 217
  edid = drm_get_edid(connector, & (gma_encoder->i2c_bus)->adapter);
#line 218
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
#line 219
    drm_mode_connector_update_edid_property(connector, (struct edid  const  *)edid);
#line 220
    ret = drm_add_edid_modes(connector, edid);
#line 221
    kfree((void const   *)edid);
  } else {

  }
#line 223
  return (ret);
}
}
#line 226 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.c"
static int cdv_hdmi_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode ) 
{ 


  {
#line 229
  if (mode->clock > 165000) {
#line 230
    return (15);
  } else {

  }
#line 231
  if (mode->clock <= 19999) {
#line 232
    return (15);
  } else {

  }
#line 235
  if ((mode->flags & 32U) != 0U) {
#line 236
    return (8);
  } else {

  }
#line 239
  if ((mode->flags & 16U) != 0U) {
#line 240
    return (7);
  } else {

  }
#line 242
  return (0);
}
}
#line 245 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.c"
static void cdv_hdmi_destroy(struct drm_connector *connector ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;

  {
#line 247
  tmp = gma_attached_encoder(connector);
#line 247
  gma_encoder = tmp;
#line 249
  if ((unsigned long )gma_encoder->i2c_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 250
    psb_intel_i2c_destroy(gma_encoder->i2c_bus);
  } else {

  }
#line 251
  drm_connector_unregister(connector);
#line 252
  drm_connector_cleanup(connector);
#line 253
  kfree((void const   *)connector);
#line 254
  return;
}
}
#line 256 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.c"
static struct drm_encoder_helper_funcs  const  cdv_hdmi_helper_funcs  = 
#line 256
     {& cdv_hdmi_dpms, 0, 0, & gma_encoder_mode_fixup, & gma_encoder_prepare, & gma_encoder_commit,
    & cdv_hdmi_mode_set, 0, 0, 0, 0, 0};
#line 265 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.c"
static struct drm_connector_helper_funcs  const  cdv_hdmi_connector_helper_funcs  =    {& cdv_hdmi_get_modes,
    (enum drm_mode_status (*)(struct drm_connector * , struct drm_display_mode * ))(& cdv_hdmi_mode_valid),
    & gma_best_encoder};
#line 271 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.c"
static struct drm_connector_funcs  const  cdv_hdmi_connector_funcs  = 
#line 271
     {& drm_helper_connector_dpms, & cdv_hdmi_save, & cdv_hdmi_restore, 0, & cdv_hdmi_detect,
    & drm_helper_probe_single_connector_modes, & cdv_hdmi_set_property, & cdv_hdmi_destroy,
    0, 0, 0, 0, 0};
#line 281 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.c"
void cdv_hdmi_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ,
                   int reg ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_connector *gma_connector ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct mid_intel_hdmi_priv *hdmi_priv ;
  int ddc_bus ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 291
  tmp = kzalloc(152UL, 208U);
#line 291
  gma_encoder = (struct gma_encoder *)tmp;
#line 293
  if ((unsigned long )gma_encoder == (unsigned long )((struct gma_encoder *)0)) {
#line 294
    return;
  } else {

  }
#line 296
  tmp___0 = kzalloc(944UL, 208U);
#line 296
  gma_connector = (struct gma_connector *)tmp___0;
#line 299
  if ((unsigned long )gma_connector == (unsigned long )((struct gma_connector *)0)) {
#line 300
    goto err_connector;
  } else {

  }
#line 302
  tmp___1 = kzalloc(40UL, 208U);
#line 302
  hdmi_priv = (struct mid_intel_hdmi_priv *)tmp___1;
#line 304
  if ((unsigned long )hdmi_priv == (unsigned long )((struct mid_intel_hdmi_priv *)0)) {
#line 305
    goto err_priv;
  } else {

  }
#line 307
  connector = & gma_connector->base;
#line 308
  connector->polled = 1U;
#line 309
  encoder = & gma_encoder->base;
#line 310
  drm_connector_init(dev, connector, & cdv_hdmi_connector_funcs, 3);
#line 314
  drm_encoder_init(dev, encoder, & psb_intel_lvds_enc_funcs, 2);
#line 317
  gma_connector_attach_encoder(gma_connector, gma_encoder);
#line 318
  gma_encoder->type = 6;
#line 319
  hdmi_priv->hdmi_reg = (u32 )reg;
#line 320
  hdmi_priv->has_hdmi_sink = 0;
#line 321
  gma_encoder->dev_priv = (void *)hdmi_priv;
#line 323
  drm_encoder_helper_add(encoder, & cdv_hdmi_helper_funcs);
#line 324
  drm_connector_helper_add(connector, & cdv_hdmi_connector_helper_funcs);
#line 326
  connector->display_info.subpixel_order = 1;
#line 327
  connector->interlace_allowed = 0;
#line 328
  connector->doublescan_allowed = 0;
#line 330
  drm_object_attach_property(& connector->base, dev->mode_config.scaling_mode_property,
                             1ULL);
#line 334
  switch (reg) {
  case 397632: 
#line 336
  ddc_bus = 20512;
#line 337
  gma_encoder->ddi_select = 1U;
#line 338
  goto ldv_42175;
  case 397664: 
#line 340
  ddc_bus = 20508;
#line 341
  gma_encoder->ddi_select = 2U;
#line 342
  goto ldv_42175;
  default: 
#line 344
  drm_err("unknown reg 0x%x for HDMI\n", reg);
#line 345
  goto failed_ddc;
  }
  ldv_42175: 
#line 349
  gma_encoder->i2c_bus = psb_intel_i2c_create(dev, (u32 const   )ddc_bus, reg == 397632 ? "HDMIB" : "HDMIC");
#line 352
  if ((unsigned long )gma_encoder->i2c_bus == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 353
    dev_err((struct device  const  *)dev->dev, "No ddc adapter available!\n");
#line 354
    goto failed_ddc;
  } else {

  }
#line 357
  hdmi_priv->hdmi_i2c_adapter = & (gma_encoder->i2c_bus)->adapter;
#line 358
  hdmi_priv->dev = dev;
#line 359
  drm_connector_register(connector);
#line 360
  return;
  failed_ddc: 
#line 363
  drm_encoder_cleanup(encoder);
#line 364
  drm_connector_cleanup(connector);
  err_priv: 
#line 366
  kfree((void const   *)gma_connector);
  err_connector: 
#line 368
  kfree((void const   *)gma_encoder);
#line 369
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
extern int ldv_probe_23(void) ;
#line 407 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void ldv_initialize_drm_connector_helper_funcs_24(void) 
{ 
  void *tmp ;

  {
#line 408
  tmp = ldv_init_zalloc(936UL);
#line 408
  cdv_hdmi_connector_helper_funcs_group0 = (struct drm_connector *)tmp;
#line 409
  return;
}
}
#line 411 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void ldv_initialize_drm_encoder_helper_funcs_25(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 412
  tmp = ldv_init_zalloc(96UL);
#line 412
  cdv_hdmi_helper_funcs_group0 = (struct drm_encoder *)tmp;
#line 413
  tmp___0 = ldv_init_zalloc(208UL);
#line 413
  cdv_hdmi_helper_funcs_group1 = (struct drm_display_mode *)tmp___0;
#line 414
  return;
}
}
#line 416 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void ldv_initialize_drm_connector_funcs_23(void) 
{ 
  void *tmp ;

  {
#line 417
  tmp = ldv_init_zalloc(936UL);
#line 417
  cdv_hdmi_connector_funcs_group0 = (struct drm_connector *)tmp;
#line 418
  return;
}
}
#line 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void ldv_main_exported_25(void) 
{ 
  struct drm_display_mode *ldvarg50 ;
  void *tmp ;
  int ldvarg52 ;
  struct drm_display_mode *ldvarg51 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 421
  tmp = ldv_init_zalloc(208UL);
#line 421
  ldvarg50 = (struct drm_display_mode *)tmp;
#line 423
  tmp___0 = ldv_init_zalloc(208UL);
#line 423
  ldvarg51 = (struct drm_display_mode *)tmp___0;
#line 422
  ldv_memset((void *)(& ldvarg52), 0, 4UL);
#line 425
  tmp___1 = __VERIFIER_nondet_int();
#line 425
  switch (tmp___1) {
  case 0: ;
#line 428
  if (ldv_state_variable_25 == 1) {
#line 430
    cdv_hdmi_dpms(cdv_hdmi_helper_funcs_group0, ldvarg52);
#line 432
    ldv_state_variable_25 = 1;
  } else {

  }
#line 435
  goto ldv_42197;
  case 1: ;
#line 438
  if (ldv_state_variable_25 == 1) {
#line 440
    gma_encoder_mode_fixup(cdv_hdmi_helper_funcs_group0, (struct drm_display_mode  const  *)ldvarg51,
                           cdv_hdmi_helper_funcs_group1);
#line 442
    ldv_state_variable_25 = 1;
  } else {

  }
#line 445
  goto ldv_42197;
  case 2: ;
#line 448
  if (ldv_state_variable_25 == 1) {
#line 450
    gma_encoder_commit(cdv_hdmi_helper_funcs_group0);
#line 452
    ldv_state_variable_25 = 1;
  } else {

  }
#line 455
  goto ldv_42197;
  case 3: ;
#line 458
  if (ldv_state_variable_25 == 1) {
#line 460
    cdv_hdmi_mode_set(cdv_hdmi_helper_funcs_group0, cdv_hdmi_helper_funcs_group1,
                      ldvarg50);
#line 462
    ldv_state_variable_25 = 1;
  } else {

  }
#line 465
  goto ldv_42197;
  case 4: ;
#line 468
  if (ldv_state_variable_25 == 1) {
#line 470
    gma_encoder_prepare(cdv_hdmi_helper_funcs_group0);
#line 472
    ldv_state_variable_25 = 1;
  } else {

  }
#line 475
  goto ldv_42197;
  default: 
#line 476
  ldv_stop();
  }
  ldv_42197: ;
#line 480
  return;
}
}
#line 482 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void ldv_main_exported_24(void) 
{ 
  struct drm_display_mode *ldvarg95 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 483
  tmp = ldv_init_zalloc(208UL);
#line 483
  ldvarg95 = (struct drm_display_mode *)tmp;
#line 485
  tmp___0 = __VERIFIER_nondet_int();
#line 485
  switch (tmp___0) {
  case 0: ;
#line 488
  if (ldv_state_variable_24 == 1) {
#line 490
    cdv_hdmi_get_modes(cdv_hdmi_connector_helper_funcs_group0);
#line 492
    ldv_state_variable_24 = 1;
  } else {

  }
#line 495
  goto ldv_42208;
  case 1: ;
#line 498
  if (ldv_state_variable_24 == 1) {
#line 500
    cdv_hdmi_mode_valid(cdv_hdmi_connector_helper_funcs_group0, ldvarg95);
#line 502
    ldv_state_variable_24 = 1;
  } else {

  }
#line 505
  goto ldv_42208;
  case 2: ;
#line 508
  if (ldv_state_variable_24 == 1) {
#line 510
    gma_best_encoder(cdv_hdmi_connector_helper_funcs_group0);
#line 512
    ldv_state_variable_24 = 1;
  } else {

  }
#line 515
  goto ldv_42208;
  default: 
#line 516
  ldv_stop();
  }
  ldv_42208: ;
#line 520
  return;
}
}
#line 522 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void ldv_main_exported_23(void) 
{ 
  uint32_t ldvarg132 ;
  uint32_t ldvarg133 ;
  struct drm_property *ldvarg135 ;
  void *tmp ;
  uint64_t ldvarg134 ;
  int ldvarg137 ;
  bool ldvarg136 ;
  int tmp___0 ;

  {
#line 525
  tmp = ldv_init_zalloc(104UL);
#line 525
  ldvarg135 = (struct drm_property *)tmp;
#line 523
  ldv_memset((void *)(& ldvarg132), 0, 4UL);
#line 524
  ldv_memset((void *)(& ldvarg133), 0, 4UL);
#line 526
  ldv_memset((void *)(& ldvarg134), 0, 8UL);
#line 527
  ldv_memset((void *)(& ldvarg137), 0, 4UL);
#line 528
  ldv_memset((void *)(& ldvarg136), 0, 1UL);
#line 530
  tmp___0 = __VERIFIER_nondet_int();
#line 530
  switch (tmp___0) {
  case 0: ;
#line 533
  if (ldv_state_variable_23 == 1) {
#line 535
    drm_helper_connector_dpms(cdv_hdmi_connector_funcs_group0, ldvarg137);
#line 537
    ldv_state_variable_23 = 1;
  } else {

  }
#line 540
  if (ldv_state_variable_23 == 2) {
#line 542
    drm_helper_connector_dpms(cdv_hdmi_connector_funcs_group0, ldvarg137);
#line 544
    ldv_state_variable_23 = 2;
  } else {

  }
#line 547
  goto ldv_42222;
  case 1: ;
#line 550
  if (ldv_state_variable_23 == 1) {
#line 552
    cdv_hdmi_detect(cdv_hdmi_connector_funcs_group0, (int )ldvarg136);
#line 554
    ldv_state_variable_23 = 1;
  } else {

  }
#line 557
  if (ldv_state_variable_23 == 2) {
#line 559
    cdv_hdmi_detect(cdv_hdmi_connector_funcs_group0, (int )ldvarg136);
#line 561
    ldv_state_variable_23 = 2;
  } else {

  }
#line 564
  goto ldv_42222;
  case 2: ;
#line 567
  if (ldv_state_variable_23 == 1) {
#line 569
    cdv_hdmi_set_property(cdv_hdmi_connector_funcs_group0, ldvarg135, ldvarg134);
#line 571
    ldv_state_variable_23 = 1;
  } else {

  }
#line 574
  if (ldv_state_variable_23 == 2) {
#line 576
    cdv_hdmi_set_property(cdv_hdmi_connector_funcs_group0, ldvarg135, ldvarg134);
#line 578
    ldv_state_variable_23 = 2;
  } else {

  }
#line 581
  goto ldv_42222;
  case 3: ;
#line 584
  if (ldv_state_variable_23 == 2) {
#line 586
    cdv_hdmi_destroy(cdv_hdmi_connector_funcs_group0);
#line 588
    ldv_state_variable_23 = 1;
#line 589
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 592
  goto ldv_42222;
  case 4: ;
#line 595
  if (ldv_state_variable_23 == 1) {
#line 597
    cdv_hdmi_save(cdv_hdmi_connector_funcs_group0);
#line 599
    ldv_state_variable_23 = 1;
  } else {

  }
#line 602
  if (ldv_state_variable_23 == 2) {
#line 604
    cdv_hdmi_save(cdv_hdmi_connector_funcs_group0);
#line 606
    ldv_state_variable_23 = 2;
  } else {

  }
#line 609
  goto ldv_42222;
  case 5: ;
#line 612
  if (ldv_state_variable_23 == 1) {
#line 614
    cdv_hdmi_restore(cdv_hdmi_connector_funcs_group0);
#line 616
    ldv_state_variable_23 = 1;
  } else {

  }
#line 619
  if (ldv_state_variable_23 == 2) {
#line 621
    cdv_hdmi_restore(cdv_hdmi_connector_funcs_group0);
#line 623
    ldv_state_variable_23 = 2;
  } else {

  }
#line 626
  goto ldv_42222;
  case 6: ;
#line 629
  if (ldv_state_variable_23 == 1) {
#line 631
    drm_helper_probe_single_connector_modes(cdv_hdmi_connector_funcs_group0, ldvarg133,
                                            ldvarg132);
#line 633
    ldv_state_variable_23 = 1;
  } else {

  }
#line 636
  if (ldv_state_variable_23 == 2) {
#line 638
    drm_helper_probe_single_connector_modes(cdv_hdmi_connector_funcs_group0, ldvarg133,
                                            ldvarg132);
#line 640
    ldv_state_variable_23 = 2;
  } else {

  }
#line 643
  goto ldv_42222;
  case 7: ;
#line 646
  if (ldv_state_variable_23 == 1) {
#line 648
    ldv_probe_23();
#line 650
    ldv_state_variable_23 = 2;
#line 651
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 654
  goto ldv_42222;
  default: 
#line 655
  ldv_stop();
  }
  ldv_42222: ;
#line 659
  return;
}
}
#line 684 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
bool ldv_queue_work_on_1232(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 688
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 688
  ldv_func_res = tmp;
#line 690
  activate_work_2(ldv_func_arg3, 2);
#line 692
  return (ldv_func_res);
}
}
#line 695 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
bool ldv_queue_delayed_work_on_1233(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 699
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 699
  ldv_func_res = tmp;
#line 701
  activate_work_2(& ldv_func_arg3->work, 2);
#line 703
  return (ldv_func_res);
}
}
#line 706 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
bool ldv_queue_work_on_1234(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 710
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 710
  ldv_func_res = tmp;
#line 712
  activate_work_2(ldv_func_arg3, 2);
#line 714
  return (ldv_func_res);
}
}
#line 717 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void ldv_flush_workqueue_1235(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 720
  flush_workqueue(ldv_func_arg1);
#line 722
  call_and_disable_all_2(2);
#line 723
  return;
}
}
#line 725 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
bool ldv_queue_delayed_work_on_1236(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 729
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 729
  ldv_func_res = tmp;
#line 731
  activate_work_2(& ldv_func_arg3->work, 2);
#line 733
  return (ldv_func_res);
}
}
#line 736 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void ldv_mutex_lock_1237(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 739
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 741
  mutex_lock(ldv_func_arg1);
#line 742
  return;
}
}
#line 744 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void ldv_mutex_unlock_1238(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 747
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 749
  mutex_unlock(ldv_func_arg1);
#line 750
  return;
}
}
#line 752 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void ldv_mutex_lock_1239(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 755
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 757
  mutex_lock(ldv_func_arg1);
#line 758
  return;
}
}
#line 760 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
int ldv_mutex_trylock_1240(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 764
  tmp = mutex_trylock(ldv_func_arg1);
#line 764
  ldv_func_res = tmp;
#line 766
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 766
  return (tmp___0);
#line 768
  return (ldv_func_res);
}
}
#line 771 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void ldv_mutex_unlock_1241(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 774
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 776
  mutex_unlock(ldv_func_arg1);
#line 777
  return;
}
}
#line 779 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void ldv_mutex_unlock_1242(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 782
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 784
  mutex_unlock(ldv_func_arg1);
#line 785
  return;
}
}
#line 787 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void ldv_mutex_lock_1243(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 790
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 792
  mutex_lock(ldv_func_arg1);
#line 793
  return;
}
}
#line 795 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void ldv_mutex_lock_1244(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 798
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 800
  mutex_lock(ldv_func_arg1);
#line 801
  return;
}
}
#line 803 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void ldv_mutex_unlock_1245(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 806
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 808
  mutex_unlock(ldv_func_arg1);
#line 809
  return;
}
}
#line 811 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void ldv_mutex_unlock_1246(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 814
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 816
  mutex_unlock(ldv_func_arg1);
#line 817
  return;
}
}
#line 819 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void ldv_mutex_lock_1247(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 822
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 824
  mutex_lock(ldv_func_arg1);
#line 825
  return;
}
}
#line 827 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
int ldv_mutex_lock_interruptible_1248(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 831
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 831
  ldv_func_res = tmp;
#line 833
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 833
  return (tmp___0);
#line 835
  return (ldv_func_res);
}
}
#line 838 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
int ldv_mutex_trylock_1249(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 842
  tmp = mutex_trylock(ldv_func_arg1);
#line 842
  ldv_func_res = tmp;
#line 844
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 844
  return (tmp___0);
#line 846
  return (ldv_func_res);
}
}
#line 870 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void ldv_mutex_unlock_1252(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 873
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 875
  mutex_unlock(ldv_func_arg1);
#line 876
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_1285(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_1294(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_1283(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_1286(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_1287(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_1290(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_1291(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_1297(struct mutex *ldv_func_arg1 ) ;
#line 209
void ldv_mutex_unlock_1299(struct mutex *ldv_func_arg1 ) ;
#line 213
void ldv_mutex_unlock_1300(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
int ldv_mutex_lock_interruptible_1293(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_1282(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_1284(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_1288(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_1289(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_1292(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_1298(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_1277(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_1279(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_1278(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_1281(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_1280(struct workqueue_struct *ldv_func_arg1 ) ;
#line 69 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.c"
static u32 cdv_intel_lvds_get_max_backlight(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 retval ;
  uint32_t tmp ;
  bool tmp___0 ;

  {
#line 71
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 74
  tmp___0 = gma_power_begin(dev, 0);
#line 74
  if ((int )tmp___0) {
#line 75
    tmp = REGISTER_READ(dev, 397908U);
#line 75
    retval = (tmp >> 17) * 2U;
#line 79
    gma_power_end(dev);
  } else {
#line 81
    retval = (dev_priv->regs.saveBLC_PWM_CTL >> 17) * 2U;
  }
#line 85
  return (retval);
}
}
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.c"
static void cdv_intel_lvds_set_backlight(struct drm_device *dev , int level ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 blc_pwm_ctl ;
  uint32_t tmp ;
  bool tmp___0 ;

  {
#line 178
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 181
  tmp___0 = gma_power_begin(dev, 0);
#line 181
  if ((int )tmp___0) {
#line 182
    tmp = REGISTER_READ(dev, 397908U);
#line 182
    blc_pwm_ctl = tmp & 4294901760U;
#line 184
    REGISTER_WRITE(dev, 397908U, blc_pwm_ctl | (u32 )level);
#line 187
    gma_power_end(dev);
  } else {
#line 189
    blc_pwm_ctl = dev_priv->regs.saveBLC_PWM_CTL & 4294901760U;
#line 191
    dev_priv->regs.saveBLC_PWM_CTL = blc_pwm_ctl | (u32 )level;
  }
#line 193
  return;
}
}
#line 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.c"
static void cdv_intel_lvds_set_power(struct drm_device *dev , struct drm_encoder *encoder ,
                                     bool on ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 pp_status ;
  bool tmp ;
  int tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 202
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 205
  tmp = gma_power_begin(dev, 1);
#line 205
  if (tmp) {
#line 205
    tmp___0 = 0;
  } else {
#line 205
    tmp___0 = 1;
  }
#line 205
  if (tmp___0) {
#line 206
    return;
  } else {

  }
#line 208
  if ((int )on) {
#line 209
    tmp___1 = REGISTER_READ(dev, 397828U);
#line 209
    REGISTER_WRITE(dev, 397828U, tmp___1 | 1U);
    ldv_42068: 
#line 212
    pp_status = REGISTER_READ(dev, 397824U);
#line 213
    if ((int )pp_status >= 0) {
#line 215
      goto ldv_42068;
    } else {

    }
#line 215
    cdv_intel_lvds_set_backlight(dev, dev_priv->mode_dev.backlight_duty_cycle);
  } else {
#line 218
    cdv_intel_lvds_set_backlight(dev, 0);
#line 220
    tmp___2 = REGISTER_READ(dev, 397828U);
#line 220
    REGISTER_WRITE(dev, 397828U, tmp___2 & 4294967294U);
    ldv_42070: 
#line 223
    pp_status = REGISTER_READ(dev, 397824U);
#line 224
    if ((int )pp_status < 0) {
#line 226
      goto ldv_42070;
    } else {

    }

  }
#line 226
  gma_power_end(dev);
#line 227
  return;
}
}
#line 229 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.c"
static void cdv_intel_lvds_encoder_dpms(struct drm_encoder *encoder , int mode ) 
{ 
  struct drm_device *dev ;

  {
#line 231
  dev = encoder->dev;
#line 232
  if (mode == 0) {
#line 233
    cdv_intel_lvds_set_power(dev, encoder, 1);
  } else {
#line 235
    cdv_intel_lvds_set_power(dev, encoder, 0);
  }
#line 236
  return;
}
}
#line 239 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.c"
static void cdv_intel_lvds_save(struct drm_connector *connector ) 
{ 


  {
#line 241
  return;
}
}
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.c"
static void cdv_intel_lvds_restore(struct drm_connector *connector ) 
{ 


  {
#line 245
  return;
}
}
#line 247 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.c"
static int cdv_intel_lvds_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct drm_display_mode *fixed_mode ;

  {
#line 250
  dev = connector->dev;
#line 251
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 252
  fixed_mode = dev_priv->mode_dev.panel_fixed_mode;
#line 256
  if ((mode->flags & 32U) != 0U) {
#line 257
    return (8);
  } else {

  }
#line 260
  if ((mode->flags & 16U) != 0U) {
#line 261
    return (7);
  } else {

  }
#line 263
  if ((unsigned long )fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 264
    if (mode->hdisplay > fixed_mode->hdisplay) {
#line 265
      return (29);
    } else {

    }
#line 266
    if (mode->vdisplay > fixed_mode->vdisplay) {
#line 267
      return (29);
    } else {

    }
  } else {

  }
#line 269
  return (0);
}
}
#line 272 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.c"
static bool cdv_intel_lvds_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode  const  *mode ,
                                      struct drm_display_mode *adjusted_mode ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  struct drm_encoder *tmp_encoder ;
  struct drm_display_mode *panel_fixed_mode ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 276
  dev = encoder->dev;
#line 277
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 278
  mode_dev = & dev_priv->mode_dev;
#line 280
  panel_fixed_mode = mode_dev->panel_fixed_mode;
#line 283
  __mptr = (struct list_head  const  *)dev->mode_config.encoder_list.next;
#line 283
  tmp_encoder = (struct drm_encoder *)__mptr + 0xfffffffffffffff8UL;
#line 283
  goto ldv_42105;
  ldv_42104: ;
#line 285
  if ((unsigned long )tmp_encoder != (unsigned long )encoder && (unsigned long )tmp_encoder->crtc == (unsigned long )encoder->crtc) {
#line 287
    printk("\vCan\'t enable LVDS and another encoder on the same pipe\n");
#line 289
    return (0);
  } else {

  }
#line 283
  __mptr___0 = (struct list_head  const  *)tmp_encoder->head.next;
#line 283
  tmp_encoder = (struct drm_encoder *)__mptr___0 + 0xfffffffffffffff8UL;
  ldv_42105: ;
#line 283
  if ((unsigned long )(& tmp_encoder->head) != (unsigned long )(& dev->mode_config.encoder_list)) {
#line 285
    goto ldv_42104;
  } else {

  }

#line 299
  if ((unsigned long )panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 300
    adjusted_mode->hdisplay = panel_fixed_mode->hdisplay;
#line 301
    adjusted_mode->hsync_start = panel_fixed_mode->hsync_start;
#line 302
    adjusted_mode->hsync_end = panel_fixed_mode->hsync_end;
#line 303
    adjusted_mode->htotal = panel_fixed_mode->htotal;
#line 304
    adjusted_mode->vdisplay = panel_fixed_mode->vdisplay;
#line 305
    adjusted_mode->vsync_start = panel_fixed_mode->vsync_start;
#line 306
    adjusted_mode->vsync_end = panel_fixed_mode->vsync_end;
#line 307
    adjusted_mode->vtotal = panel_fixed_mode->vtotal;
#line 308
    adjusted_mode->clock = panel_fixed_mode->clock;
#line 309
    drm_mode_set_crtcinfo(adjusted_mode, 1);
  } else {

  }
#line 319
  return (1);
}
}
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.c"
static void cdv_intel_lvds_prepare(struct drm_encoder *encoder ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  bool tmp ;
  int tmp___0 ;

  {
#line 324
  dev = encoder->dev;
#line 325
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 326
  mode_dev = & dev_priv->mode_dev;
#line 328
  tmp = gma_power_begin(dev, 1);
#line 328
  if (tmp) {
#line 328
    tmp___0 = 0;
  } else {
#line 328
    tmp___0 = 1;
  }
#line 328
  if (tmp___0) {
#line 329
    return;
  } else {

  }
#line 331
  mode_dev->saveBLC_PWM_CTL = REGISTER_READ(dev, 397908U);
#line 332
  mode_dev->backlight_duty_cycle = (int )mode_dev->saveBLC_PWM_CTL & 65535;
#line 335
  cdv_intel_lvds_set_power(dev, encoder, 0);
#line 337
  gma_power_end(dev);
#line 338
  return;
}
}
#line 340 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.c"
static void cdv_intel_lvds_commit(struct drm_encoder *encoder ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  u32 tmp ;

  {
#line 342
  dev = encoder->dev;
#line 343
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 344
  mode_dev = & dev_priv->mode_dev;
#line 346
  if (mode_dev->backlight_duty_cycle == 0) {
#line 347
    tmp = cdv_intel_lvds_get_max_backlight(dev);
#line 347
    mode_dev->backlight_duty_cycle = (int )tmp;
  } else {

  }
#line 350
  cdv_intel_lvds_set_power(dev, encoder, 1);
#line 351
  return;
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.c"
static void cdv_intel_lvds_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                    struct drm_display_mode *adjusted_mode ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  u32 pfit_control ;

  {
#line 357
  dev = encoder->dev;
#line 358
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 359
  __mptr = (struct drm_crtc  const  *)encoder->crtc;
#line 359
  gma_crtc = (struct gma_crtc *)__mptr;
#line 373
  if (mode->hdisplay != adjusted_mode->hdisplay || mode->vdisplay != adjusted_mode->vdisplay) {
#line 375
    pfit_control = 2147485280U;
  } else {
#line 379
    pfit_control = 0U;
  }
#line 381
  pfit_control = (u32 )(gma_crtc->pipe << 29) | pfit_control;
#line 383
  if ((unsigned int )*((unsigned char *)dev_priv + 864UL) != 0U) {
#line 384
    pfit_control = pfit_control | 8U;
  } else {

  }
#line 386
  REGISTER_WRITE(dev, 397872U, pfit_control);
#line 387
  return;
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.c"
static enum drm_connector_status cdv_intel_lvds_detect(struct drm_connector *connector ,
                                                       bool force ) 
{ 


  {
#line 399
  return (1);
}
}
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.c"
static int cdv_intel_lvds_get_modes(struct drm_connector *connector ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct psb_intel_mode_device *mode_dev ;
  int ret ;
  struct drm_display_mode *mode ;
  struct drm_display_mode *tmp___0 ;

  {
#line 407
  dev = connector->dev;
#line 408
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 409
  tmp = gma_attached_encoder(connector);
#line 409
  gma_encoder = tmp;
#line 410
  mode_dev = & dev_priv->mode_dev;
#line 413
  ret = psb_intel_ddc_get_modes(connector, & (gma_encoder->i2c_bus)->adapter);
#line 415
  if (ret != 0) {
#line 416
    return (ret);
  } else {

  }
#line 422
  connector->display_info.min_vfreq = 0U;
#line 423
  connector->display_info.max_vfreq = 200U;
#line 424
  connector->display_info.min_hfreq = 0U;
#line 425
  connector->display_info.max_hfreq = 200U;
#line 426
  if ((unsigned long )mode_dev->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 427
    tmp___0 = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)mode_dev->panel_fixed_mode);
#line 427
    mode = tmp___0;
#line 429
    drm_mode_probed_add(connector, mode);
#line 430
    return (1);
  } else {

  }
#line 433
  return (0);
}
}
#line 443 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.c"
static void cdv_intel_lvds_destroy(struct drm_connector *connector ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;

  {
#line 445
  tmp = gma_attached_encoder(connector);
#line 445
  gma_encoder = tmp;
#line 447
  if ((unsigned long )gma_encoder->i2c_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 448
    psb_intel_i2c_destroy(gma_encoder->i2c_bus);
  } else {

  }
#line 449
  drm_connector_unregister(connector);
#line 450
  drm_connector_cleanup(connector);
#line 451
  kfree((void const   *)connector);
#line 452
  return;
}
}
#line 454 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.c"
static int cdv_intel_lvds_set_property(struct drm_connector *connector , struct drm_property *property ,
                                       uint64_t value ) 
{ 
  struct drm_encoder *encoder ;
  struct gma_crtc *crtc ;
  struct drm_crtc  const  *__mptr ;
  uint64_t curValue ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct drm_encoder_helper_funcs  const  *helpers ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 458
  encoder = connector->encoder;
#line 460
  tmp___6 = strcmp((char const   *)(& property->name), "scaling mode");
#line 460
  if (tmp___6 == 0 && (unsigned long )encoder != (unsigned long )((struct drm_encoder *)0)) {
#line 461
    __mptr = (struct drm_crtc  const  *)encoder->crtc;
#line 461
    crtc = (struct gma_crtc *)__mptr;
#line 464
    if ((unsigned long )crtc == (unsigned long )((struct gma_crtc *)0)) {
#line 465
      return (-1);
    } else {

    }
#line 467
    switch (value) {
    case 1ULL: ;
#line 469
    goto ldv_42158;
    case 2ULL: ;
#line 471
    goto ldv_42158;
    case 3ULL: ;
#line 473
    goto ldv_42158;
    default: ;
#line 475
    return (-1);
    }
    ldv_42158: 
#line 478
    tmp = drm_object_property_get_value(& connector->base, property, & curValue);
#line 478
    if (tmp != 0) {
#line 481
      return (-1);
    } else {

    }
#line 483
    if (curValue == value) {
#line 484
      return (0);
    } else {

    }
#line 486
    tmp___0 = drm_object_property_set_value(& connector->base, property, value);
#line 486
    if (tmp___0 != 0) {
#line 489
      return (-1);
    } else {

    }
#line 491
    if (crtc->saved_mode.hdisplay != 0 && crtc->saved_mode.vdisplay != 0) {
#line 493
      tmp___1 = drm_crtc_helper_set_mode(encoder->crtc, & crtc->saved_mode, (encoder->crtc)->x,
                                         (encoder->crtc)->y, ((encoder->crtc)->primary)->fb);
#line 493
      if (tmp___1) {
#line 493
        tmp___2 = 0;
      } else {
#line 493
        tmp___2 = 1;
      }
#line 493
      if (tmp___2) {
#line 498
        return (-1);
      } else {

      }
    } else {

    }
  } else {
#line 500
    tmp___5 = strcmp((char const   *)(& property->name), "backlight");
#line 500
    if (tmp___5 == 0 && (unsigned long )encoder != (unsigned long )((struct drm_encoder *)0)) {
#line 501
      tmp___3 = drm_object_property_set_value(& connector->base, property, value);
#line 501
      if (tmp___3 != 0) {
#line 504
        return (-1);
      } else {
#line 506
        gma_backlight_set(encoder->dev, (int )value);
      }
    } else {
#line 507
      tmp___4 = strcmp((char const   *)(& property->name), "DPMS");
#line 507
      if (tmp___4 == 0 && (unsigned long )encoder != (unsigned long )((struct drm_encoder *)0)) {
#line 508
        helpers = (struct drm_encoder_helper_funcs  const  *)encoder->helper_private;
#line 510
        (*(helpers->dpms))(encoder, (int )value);
      } else {

      }
    }
  }
#line 512
  return (0);
}
}
#line 516 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.c"
static struct drm_encoder_helper_funcs  const  cdv_intel_lvds_helper_funcs  = 
#line 516
     {& cdv_intel_lvds_encoder_dpms, 0, 0, & cdv_intel_lvds_mode_fixup, & cdv_intel_lvds_prepare,
    & cdv_intel_lvds_commit, & cdv_intel_lvds_mode_set, 0, 0, 0, 0, 0};
#line 525 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.c"
static struct drm_connector_helper_funcs  const  cdv_intel_lvds_connector_helper_funcs  =    {& cdv_intel_lvds_get_modes,
    (enum drm_mode_status (*)(struct drm_connector * , struct drm_display_mode * ))(& cdv_intel_lvds_mode_valid),
    & gma_best_encoder};
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.c"
static struct drm_connector_funcs  const  cdv_intel_lvds_connector_funcs  = 
#line 531
     {& drm_helper_connector_dpms, & cdv_intel_lvds_save, & cdv_intel_lvds_restore,
    0, & cdv_intel_lvds_detect, & drm_helper_probe_single_connector_modes, & cdv_intel_lvds_set_property,
    & cdv_intel_lvds_destroy, 0, 0, 0, 0, 0};
#line 542 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.c"
static void cdv_intel_lvds_enc_destroy(struct drm_encoder *encoder ) 
{ 


  {
#line 544
  drm_encoder_cleanup(encoder);
#line 545
  return;
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.c"
static struct drm_encoder_funcs  const  cdv_intel_lvds_enc_funcs  =    {0, & cdv_intel_lvds_enc_destroy};
#line 558 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.c"
static bool lvds_is_present_in_vbt(struct drm_device *dev , u8 *i2c_pin ) 
{ 
  struct drm_psb_private *dev_priv ;
  int i ;
  struct child_device_config *child ;

  {
#line 561
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 564
  if (dev_priv->child_dev_num == 0) {
#line 565
    return (1);
  } else {

  }
#line 567
  i = 0;
#line 567
  goto ldv_42179;
  ldv_42178: 
#line 568
  child = dev_priv->child_dev + (unsigned long )i;
#line 574
  if ((unsigned int )child->device_type != 4130U && (unsigned int )child->device_type != 34U) {
#line 576
    goto ldv_42177;
  } else {

  }
#line 578
  if ((unsigned int )child->i2c_pin != 0U) {
#line 579
    *i2c_pin = child->i2c_pin;
  } else {

  }
#line 586
  if ((unsigned int )child->addin_offset != 0U) {
#line 587
    return (1);
  } else {

  }
#line 594
  if ((unsigned long )dev_priv->opregion.vbt != (unsigned long )((void *)0)) {
#line 595
    return (1);
  } else {

  }
  ldv_42177: 
#line 567
  i = i + 1;
  ldv_42179: ;
#line 567
  if (dev_priv->child_dev_num > i) {
#line 569
    goto ldv_42178;
  } else {

  }

#line 598
  return (0);
}
}
#line 608 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.c"
void cdv_intel_lvds_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_connector *gma_connector ;
  struct cdv_intel_lvds_priv *lvds_priv ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct drm_display_mode *scan ;
  struct drm_crtc *crtc ;
  struct drm_psb_private *dev_priv ;
  u32 lvds ;
  int pipe ;
  u8 pin ;
  long tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  long tmp___5 ;
  u32 pwm ;

  {
#line 618
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 623
  pin = 3U;
#line 624
  tmp___0 = lvds_is_present_in_vbt(dev, & pin);
#line 624
  if (tmp___0) {
#line 624
    tmp___1 = 0;
  } else {
#line 624
    tmp___1 = 1;
  }
#line 624
  if (tmp___1) {
#line 625
    tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 625
    if (tmp != 0L) {
#line 625
      drm_ut_debug_printk("cdv_intel_lvds_init", "LVDS is not present in VBT\n");
    } else {

    }
#line 626
    return;
  } else {

  }
#line 629
  tmp___2 = kzalloc(152UL, 208U);
#line 629
  gma_encoder = (struct gma_encoder *)tmp___2;
#line 631
  if ((unsigned long )gma_encoder == (unsigned long )((struct gma_encoder *)0)) {
#line 632
    return;
  } else {

  }
#line 634
  tmp___3 = kzalloc(944UL, 208U);
#line 634
  gma_connector = (struct gma_connector *)tmp___3;
#line 636
  if ((unsigned long )gma_connector == (unsigned long )((struct gma_connector *)0)) {
#line 637
    goto failed_connector;
  } else {

  }
#line 639
  tmp___4 = kzalloc(32UL, 208U);
#line 639
  lvds_priv = (struct cdv_intel_lvds_priv *)tmp___4;
#line 640
  if ((unsigned long )lvds_priv == (unsigned long )((struct cdv_intel_lvds_priv *)0)) {
#line 641
    goto failed_lvds_priv;
  } else {

  }
#line 643
  gma_encoder->dev_priv = (void *)lvds_priv;
#line 645
  connector = & gma_connector->base;
#line 646
  encoder = & gma_encoder->base;
#line 649
  drm_connector_init(dev, connector, & cdv_intel_lvds_connector_funcs, 7);
#line 653
  drm_encoder_init(dev, encoder, & cdv_intel_lvds_enc_funcs, 3);
#line 658
  gma_connector_attach_encoder(gma_connector, gma_encoder);
#line 659
  gma_encoder->type = 4;
#line 661
  drm_encoder_helper_add(encoder, & cdv_intel_lvds_helper_funcs);
#line 662
  drm_connector_helper_add(connector, & cdv_intel_lvds_connector_helper_funcs);
#line 664
  connector->display_info.subpixel_order = 1;
#line 665
  connector->interlace_allowed = 0;
#line 666
  connector->doublescan_allowed = 0;
#line 669
  drm_object_attach_property(& connector->base, dev->mode_config.scaling_mode_property,
                             1ULL);
#line 672
  drm_object_attach_property(& connector->base, dev_priv->backlight_property, 100ULL);
#line 680
  gma_encoder->i2c_bus = psb_intel_i2c_create(dev, 20500U, "LVDSBLC_B");
#line 683
  if ((unsigned long )gma_encoder->i2c_bus == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 684
    dev_printk("\v", (struct device  const  *)(& (dev->pdev)->dev), "I2C bus registration failed.\n");
#line 686
    goto failed_blc_i2c;
  } else {

  }
#line 688
  (gma_encoder->i2c_bus)->slave_addr = 44U;
#line 689
  dev_priv->lvds_i2c_bus = gma_encoder->i2c_bus;
#line 702
  gma_encoder->ddc_bus = psb_intel_i2c_create(dev, 20504U, "LVDSDDC_C");
#line 705
  if ((unsigned long )gma_encoder->ddc_bus == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 706
    dev_printk("\v", (struct device  const  *)(& (dev->pdev)->dev), "DDC bus registration failed.\n");
#line 708
    goto failed_ddc;
  } else {

  }
#line 715
  ldv_mutex_lock_1298(& dev->mode_config.mutex);
#line 716
  psb_intel_ddc_get_modes(connector, & (gma_encoder->ddc_bus)->adapter);
#line 718
  __mptr = (struct list_head  const  *)connector->probed_modes.next;
#line 718
  scan = (struct drm_display_mode *)__mptr;
#line 718
  goto ldv_42207;
  ldv_42206: ;
#line 719
  if ((scan->type & 8U) != 0U) {
#line 720
    mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)scan);
#line 722
    goto out;
  } else {

  }
#line 718
  __mptr___0 = (struct list_head  const  *)scan->head.next;
#line 718
  scan = (struct drm_display_mode *)__mptr___0;
  ldv_42207: ;
#line 718
  if ((unsigned long )(& scan->head) != (unsigned long )(& connector->probed_modes)) {
#line 720
    goto ldv_42206;
  } else {

  }

#line 727
  if ((unsigned long )dev_priv->lfp_lvds_vbt_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 728
    mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)dev_priv->lfp_lvds_vbt_mode);
#line 730
    if ((unsigned long )mode_dev->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 731
      (mode_dev->panel_fixed_mode)->type = (mode_dev->panel_fixed_mode)->type | 8U;
#line 733
      goto out;
    } else {

    }
  } else {

  }
#line 741
  lvds = REGISTER_READ(dev, 397696U);
#line 742
  pipe = (lvds & 1073741824U) != 0U;
#line 743
  crtc = psb_intel_get_crtc_from_pipe(dev, pipe);
#line 745
  if ((unsigned long )crtc != (unsigned long )((struct drm_crtc *)0) && (int )lvds < 0) {
#line 746
    mode_dev->panel_fixed_mode = cdv_intel_crtc_mode_get(dev, crtc);
#line 748
    if ((unsigned long )mode_dev->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 749
      (mode_dev->panel_fixed_mode)->type = (mode_dev->panel_fixed_mode)->type | 8U;
#line 751
      goto out;
    } else {

    }
  } else {

  }
#line 756
  if ((unsigned long )mode_dev->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 757
    tmp___5 = ldv__builtin_expect((long )((int )drm_debug) & 1L, 0L);
#line 757
    if (tmp___5 != 0L) {
#line 757
      drm_ut_debug_printk("cdv_intel_lvds_init", "Found no modes on the lvds, ignoring the LVDS\n");
    } else {

    }
#line 759
    goto failed_find;
  } else {

  }
#line 766
  pwm = REGISTER_READ(dev, 397904U);
#line 767
  if (pipe == 1) {
#line 768
    pwm = pwm | 536870912U;
  } else {
#line 770
    pwm = pwm & 3758096383U;
  }
#line 771
  pwm = pwm | 2147483648U;
#line 772
  REGISTER_WRITE(dev, 397904U, pwm);
  out: 
#line 776
  ldv_mutex_unlock_1299(& dev->mode_config.mutex);
#line 777
  drm_connector_register(connector);
#line 778
  return;
  failed_find: 
#line 781
  ldv_mutex_unlock_1300(& dev->mode_config.mutex);
#line 782
  printk("\vFailed find\n");
#line 783
  if ((unsigned long )gma_encoder->ddc_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 784
    psb_intel_i2c_destroy(gma_encoder->ddc_bus);
  } else {

  }
  failed_ddc: 
#line 786
  printk("\vFailed DDC\n");
#line 787
  if ((unsigned long )gma_encoder->i2c_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 788
    psb_intel_i2c_destroy(gma_encoder->i2c_bus);
  } else {

  }
  failed_blc_i2c: 
#line 790
  printk("\vFailed BLC\n");
#line 791
  drm_encoder_cleanup(encoder);
#line 792
  drm_connector_cleanup(connector);
#line 793
  kfree((void const   *)lvds_priv);
  failed_lvds_priv: 
#line 795
  kfree((void const   *)gma_connector);
  failed_connector: 
#line 797
  kfree((void const   *)gma_encoder);
#line 798
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
extern int ldv_probe_19(void) ;
#line 405
extern int ldv_probe_20(void) ;
#line 408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_initialize_drm_encoder_helper_funcs_22(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 409
  tmp = ldv_init_zalloc(96UL);
#line 409
  cdv_intel_lvds_helper_funcs_group0 = (struct drm_encoder *)tmp;
#line 410
  tmp___0 = ldv_init_zalloc(208UL);
#line 410
  cdv_intel_lvds_helper_funcs_group1 = (struct drm_display_mode *)tmp___0;
#line 411
  return;
}
}
#line 413 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_initialize_drm_connector_funcs_20(void) 
{ 
  void *tmp ;

  {
#line 414
  tmp = ldv_init_zalloc(936UL);
#line 414
  cdv_intel_lvds_connector_funcs_group0 = (struct drm_connector *)tmp;
#line 415
  return;
}
}
#line 417 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_initialize_drm_connector_helper_funcs_21(void) 
{ 
  void *tmp ;

  {
#line 418
  tmp = ldv_init_zalloc(936UL);
#line 418
  cdv_intel_lvds_connector_helper_funcs_group0 = (struct drm_connector *)tmp;
#line 419
  return;
}
}
#line 421 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_main_exported_22(void) 
{ 
  struct drm_display_mode *ldvarg118 ;
  void *tmp ;
  struct drm_display_mode *ldvarg117 ;
  void *tmp___0 ;
  int ldvarg119 ;
  int tmp___1 ;

  {
#line 422
  tmp = ldv_init_zalloc(208UL);
#line 422
  ldvarg118 = (struct drm_display_mode *)tmp;
#line 423
  tmp___0 = ldv_init_zalloc(208UL);
#line 423
  ldvarg117 = (struct drm_display_mode *)tmp___0;
#line 424
  ldv_memset((void *)(& ldvarg119), 0, 4UL);
#line 426
  tmp___1 = __VERIFIER_nondet_int();
#line 426
  switch (tmp___1) {
  case 0: ;
#line 429
  if (ldv_state_variable_22 == 1) {
#line 431
    cdv_intel_lvds_encoder_dpms(cdv_intel_lvds_helper_funcs_group0, ldvarg119);
#line 433
    ldv_state_variable_22 = 1;
  } else {

  }
#line 436
  goto ldv_42231;
  case 1: ;
#line 439
  if (ldv_state_variable_22 == 1) {
#line 441
    cdv_intel_lvds_mode_fixup(cdv_intel_lvds_helper_funcs_group0, (struct drm_display_mode  const  *)ldvarg118,
                              cdv_intel_lvds_helper_funcs_group1);
#line 443
    ldv_state_variable_22 = 1;
  } else {

  }
#line 446
  goto ldv_42231;
  case 2: ;
#line 449
  if (ldv_state_variable_22 == 1) {
#line 451
    cdv_intel_lvds_commit(cdv_intel_lvds_helper_funcs_group0);
#line 453
    ldv_state_variable_22 = 1;
  } else {

  }
#line 456
  goto ldv_42231;
  case 3: ;
#line 459
  if (ldv_state_variable_22 == 1) {
#line 461
    cdv_intel_lvds_mode_set(cdv_intel_lvds_helper_funcs_group0, cdv_intel_lvds_helper_funcs_group1,
                            ldvarg117);
#line 463
    ldv_state_variable_22 = 1;
  } else {

  }
#line 466
  goto ldv_42231;
  case 4: ;
#line 469
  if (ldv_state_variable_22 == 1) {
#line 471
    cdv_intel_lvds_prepare(cdv_intel_lvds_helper_funcs_group0);
#line 473
    ldv_state_variable_22 = 1;
  } else {

  }
#line 476
  goto ldv_42231;
  default: 
#line 477
  ldv_stop();
  }
  ldv_42231: ;
#line 481
  return;
}
}
#line 483 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_main_exported_21(void) 
{ 
  struct drm_display_mode *ldvarg5 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 484
  tmp = ldv_init_zalloc(208UL);
#line 484
  ldvarg5 = (struct drm_display_mode *)tmp;
#line 486
  tmp___0 = __VERIFIER_nondet_int();
#line 486
  switch (tmp___0) {
  case 0: ;
#line 489
  if (ldv_state_variable_21 == 1) {
#line 491
    cdv_intel_lvds_get_modes(cdv_intel_lvds_connector_helper_funcs_group0);
#line 493
    ldv_state_variable_21 = 1;
  } else {

  }
#line 496
  goto ldv_42242;
  case 1: ;
#line 499
  if (ldv_state_variable_21 == 1) {
#line 501
    cdv_intel_lvds_mode_valid(cdv_intel_lvds_connector_helper_funcs_group0, ldvarg5);
#line 503
    ldv_state_variable_21 = 1;
  } else {

  }
#line 506
  goto ldv_42242;
  case 2: ;
#line 509
  if (ldv_state_variable_21 == 1) {
#line 511
    gma_best_encoder(cdv_intel_lvds_connector_helper_funcs_group0);
#line 513
    ldv_state_variable_21 = 1;
  } else {

  }
#line 516
  goto ldv_42242;
  default: 
#line 517
  ldv_stop();
  }
  ldv_42242: ;
#line 521
  return;
}
}
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_main_exported_19(void) 
{ 
  struct drm_encoder *ldvarg213 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 524
  tmp = ldv_init_zalloc(96UL);
#line 524
  ldvarg213 = (struct drm_encoder *)tmp;
#line 526
  tmp___0 = __VERIFIER_nondet_int();
#line 526
  switch (tmp___0) {
  case 0: ;
#line 529
  if (ldv_state_variable_19 == 2) {
#line 531
    cdv_intel_lvds_enc_destroy(ldvarg213);
#line 533
    ldv_state_variable_19 = 1;
#line 534
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 537
  goto ldv_42251;
  case 1: ;
#line 540
  if (ldv_state_variable_19 == 1) {
#line 542
    ldv_probe_19();
#line 544
    ldv_state_variable_19 = 2;
#line 545
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 548
  goto ldv_42251;
  default: 
#line 549
  ldv_stop();
  }
  ldv_42251: ;
#line 553
  return;
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_main_exported_20(void) 
{ 
  uint32_t ldvarg75 ;
  uint32_t ldvarg76 ;
  struct drm_property *ldvarg78 ;
  void *tmp ;
  int ldvarg80 ;
  bool ldvarg79 ;
  uint64_t ldvarg77 ;
  int tmp___0 ;

  {
#line 558
  tmp = ldv_init_zalloc(104UL);
#line 558
  ldvarg78 = (struct drm_property *)tmp;
#line 556
  ldv_memset((void *)(& ldvarg75), 0, 4UL);
#line 557
  ldv_memset((void *)(& ldvarg76), 0, 4UL);
#line 559
  ldv_memset((void *)(& ldvarg80), 0, 4UL);
#line 560
  ldv_memset((void *)(& ldvarg79), 0, 1UL);
#line 561
  ldv_memset((void *)(& ldvarg77), 0, 8UL);
#line 563
  tmp___0 = __VERIFIER_nondet_int();
#line 563
  switch (tmp___0) {
  case 0: ;
#line 566
  if (ldv_state_variable_20 == 1) {
#line 568
    drm_helper_connector_dpms(cdv_intel_lvds_connector_funcs_group0, ldvarg80);
#line 570
    ldv_state_variable_20 = 1;
  } else {

  }
#line 573
  if (ldv_state_variable_20 == 2) {
#line 575
    drm_helper_connector_dpms(cdv_intel_lvds_connector_funcs_group0, ldvarg80);
#line 577
    ldv_state_variable_20 = 2;
  } else {

  }
#line 580
  goto ldv_42264;
  case 1: ;
#line 583
  if (ldv_state_variable_20 == 1) {
#line 585
    cdv_intel_lvds_detect(cdv_intel_lvds_connector_funcs_group0, (int )ldvarg79);
#line 587
    ldv_state_variable_20 = 1;
  } else {

  }
#line 590
  if (ldv_state_variable_20 == 2) {
#line 592
    cdv_intel_lvds_detect(cdv_intel_lvds_connector_funcs_group0, (int )ldvarg79);
#line 594
    ldv_state_variable_20 = 2;
  } else {

  }
#line 597
  goto ldv_42264;
  case 2: ;
#line 600
  if (ldv_state_variable_20 == 1) {
#line 602
    cdv_intel_lvds_set_property(cdv_intel_lvds_connector_funcs_group0, ldvarg78, ldvarg77);
#line 604
    ldv_state_variable_20 = 1;
  } else {

  }
#line 607
  if (ldv_state_variable_20 == 2) {
#line 609
    cdv_intel_lvds_set_property(cdv_intel_lvds_connector_funcs_group0, ldvarg78, ldvarg77);
#line 611
    ldv_state_variable_20 = 2;
  } else {

  }
#line 614
  goto ldv_42264;
  case 3: ;
#line 617
  if (ldv_state_variable_20 == 2) {
#line 619
    cdv_intel_lvds_destroy(cdv_intel_lvds_connector_funcs_group0);
#line 621
    ldv_state_variable_20 = 1;
#line 622
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 625
  goto ldv_42264;
  case 4: ;
#line 628
  if (ldv_state_variable_20 == 1) {
#line 630
    cdv_intel_lvds_save(cdv_intel_lvds_connector_funcs_group0);
#line 632
    ldv_state_variable_20 = 1;
  } else {

  }
#line 635
  if (ldv_state_variable_20 == 2) {
#line 637
    cdv_intel_lvds_save(cdv_intel_lvds_connector_funcs_group0);
#line 639
    ldv_state_variable_20 = 2;
  } else {

  }
#line 642
  goto ldv_42264;
  case 5: ;
#line 645
  if (ldv_state_variable_20 == 1) {
#line 647
    cdv_intel_lvds_restore(cdv_intel_lvds_connector_funcs_group0);
#line 649
    ldv_state_variable_20 = 1;
  } else {

  }
#line 652
  if (ldv_state_variable_20 == 2) {
#line 654
    cdv_intel_lvds_restore(cdv_intel_lvds_connector_funcs_group0);
#line 656
    ldv_state_variable_20 = 2;
  } else {

  }
#line 659
  goto ldv_42264;
  case 6: ;
#line 662
  if (ldv_state_variable_20 == 1) {
#line 664
    drm_helper_probe_single_connector_modes(cdv_intel_lvds_connector_funcs_group0,
                                            ldvarg76, ldvarg75);
#line 666
    ldv_state_variable_20 = 1;
  } else {

  }
#line 669
  if (ldv_state_variable_20 == 2) {
#line 671
    drm_helper_probe_single_connector_modes(cdv_intel_lvds_connector_funcs_group0,
                                            ldvarg76, ldvarg75);
#line 673
    ldv_state_variable_20 = 2;
  } else {

  }
#line 676
  goto ldv_42264;
  case 7: ;
#line 679
  if (ldv_state_variable_20 == 1) {
#line 681
    ldv_probe_20();
#line 683
    ldv_state_variable_20 = 2;
#line 684
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 687
  goto ldv_42264;
  default: 
#line 688
  ldv_stop();
  }
  ldv_42264: ;
#line 692
  return;
}
}
#line 717 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
bool ldv_queue_work_on_1277(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 721
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 721
  ldv_func_res = tmp;
#line 723
  activate_work_2(ldv_func_arg3, 2);
#line 725
  return (ldv_func_res);
}
}
#line 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
bool ldv_queue_delayed_work_on_1278(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 732
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 732
  ldv_func_res = tmp;
#line 734
  activate_work_2(& ldv_func_arg3->work, 2);
#line 736
  return (ldv_func_res);
}
}
#line 739 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
bool ldv_queue_work_on_1279(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 743
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 743
  ldv_func_res = tmp;
#line 745
  activate_work_2(ldv_func_arg3, 2);
#line 747
  return (ldv_func_res);
}
}
#line 750 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_flush_workqueue_1280(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 753
  flush_workqueue(ldv_func_arg1);
#line 755
  call_and_disable_all_2(2);
#line 756
  return;
}
}
#line 758 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
bool ldv_queue_delayed_work_on_1281(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 762
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 762
  ldv_func_res = tmp;
#line 764
  activate_work_2(& ldv_func_arg3->work, 2);
#line 766
  return (ldv_func_res);
}
}
#line 769 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_mutex_lock_1282(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 772
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 774
  mutex_lock(ldv_func_arg1);
#line 775
  return;
}
}
#line 777 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_mutex_unlock_1283(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 780
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 782
  mutex_unlock(ldv_func_arg1);
#line 783
  return;
}
}
#line 785 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_mutex_lock_1284(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 788
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 790
  mutex_lock(ldv_func_arg1);
#line 791
  return;
}
}
#line 793 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
int ldv_mutex_trylock_1285(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 797
  tmp = mutex_trylock(ldv_func_arg1);
#line 797
  ldv_func_res = tmp;
#line 799
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 799
  return (tmp___0);
#line 801
  return (ldv_func_res);
}
}
#line 804 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_mutex_unlock_1286(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 807
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 809
  mutex_unlock(ldv_func_arg1);
#line 810
  return;
}
}
#line 812 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_mutex_unlock_1287(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 815
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 817
  mutex_unlock(ldv_func_arg1);
#line 818
  return;
}
}
#line 820 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_mutex_lock_1288(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 823
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 825
  mutex_lock(ldv_func_arg1);
#line 826
  return;
}
}
#line 828 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_mutex_lock_1289(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 831
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 833
  mutex_lock(ldv_func_arg1);
#line 834
  return;
}
}
#line 836 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_mutex_unlock_1290(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 839
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 841
  mutex_unlock(ldv_func_arg1);
#line 842
  return;
}
}
#line 844 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_mutex_unlock_1291(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 847
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 849
  mutex_unlock(ldv_func_arg1);
#line 850
  return;
}
}
#line 852 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_mutex_lock_1292(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 855
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 857
  mutex_lock(ldv_func_arg1);
#line 858
  return;
}
}
#line 860 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
int ldv_mutex_lock_interruptible_1293(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 864
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 864
  ldv_func_res = tmp;
#line 866
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 866
  return (tmp___0);
#line 868
  return (ldv_func_res);
}
}
#line 871 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
int ldv_mutex_trylock_1294(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 875
  tmp = mutex_trylock(ldv_func_arg1);
#line 875
  ldv_func_res = tmp;
#line 877
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 877
  return (tmp___0);
#line 879
  return (ldv_func_res);
}
}
#line 903 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_mutex_unlock_1297(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 906
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 908
  mutex_unlock(ldv_func_arg1);
#line 909
  return;
}
}
#line 911 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_mutex_lock_1298(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 914
  ldv_mutex_lock_mutex_of_drm_mode_config(ldv_func_arg1);
#line 916
  mutex_lock(ldv_func_arg1);
#line 917
  return;
}
}
#line 919 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_mutex_unlock_1299(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 922
  ldv_mutex_unlock_mutex_of_drm_mode_config(ldv_func_arg1);
#line 924
  mutex_unlock(ldv_func_arg1);
#line 925
  return;
}
}
#line 927 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_mutex_unlock_1300(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 930
  ldv_mutex_unlock_mutex_of_drm_mode_config(ldv_func_arg1);
#line 932
  mutex_unlock(ldv_func_arg1);
#line 933
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 23 "include/linux/string.h"
extern char *strncpy(char * , char const   * , __kernel_size_t  ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_1336(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_1345(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_1334(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_1337(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_1338(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_1341(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_1342(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_1348(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
int ldv_mutex_lock_interruptible_1344(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_1333(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_1335(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_1339(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_1340(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_1343(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_1328(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_1330(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_1329(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_1332(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_1331(struct workqueue_struct *ldv_func_arg1 ) ;
#line 58 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static int i2c_algo_dp_aux_transaction(struct i2c_adapter *adapter , int mode , uint8_t write_byte ,
                                       uint8_t *read_byte ) 
{ 
  struct i2c_algo_dp_aux_data *algo_data ;
  int ret ;

  {
#line 61
  algo_data = (struct i2c_algo_dp_aux_data *)adapter->algo_data;
#line 64
  ret = (*(algo_data->aux_ch))(adapter, mode, (int )write_byte, read_byte);
#line 66
  return (ret);
}
}
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static int i2c_algo_dp_aux_address(struct i2c_adapter *adapter , u16 address , bool reading ) 
{ 
  struct i2c_algo_dp_aux_data *algo_data ;
  int mode ;
  int ret ;

  {
#line 81
  algo_data = (struct i2c_algo_dp_aux_data *)adapter->algo_data;
#line 82
  mode = 1;
#line 85
  if ((int )reading) {
#line 86
    mode = mode | 4;
  } else {
#line 88
    mode = mode | 2;
  }
#line 89
  algo_data->address = address;
#line 90
  algo_data->running = 1;
#line 91
  ret = i2c_algo_dp_aux_transaction(adapter, mode, 0, (uint8_t *)0U);
#line 92
  return (ret);
}
}
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void i2c_algo_dp_aux_stop(struct i2c_adapter *adapter , bool reading ) 
{ 
  struct i2c_algo_dp_aux_data *algo_data ;
  int mode ;

  {
#line 102
  algo_data = (struct i2c_algo_dp_aux_data *)adapter->algo_data;
#line 103
  mode = 8;
#line 105
  if ((int )reading) {
#line 106
    mode = mode | 4;
  } else {
#line 108
    mode = mode | 2;
  }
#line 109
  if ((int )algo_data->running) {
#line 110
    i2c_algo_dp_aux_transaction(adapter, mode, 0, (uint8_t *)0U);
#line 111
    algo_data->running = 0;
  } else {

  }
#line 113
  return;
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static int i2c_algo_dp_aux_put_byte(struct i2c_adapter *adapter , u8 byte ) 
{ 
  struct i2c_algo_dp_aux_data *algo_data ;
  int ret ;

  {
#line 122
  algo_data = (struct i2c_algo_dp_aux_data *)adapter->algo_data;
#line 125
  if (! algo_data->running) {
#line 126
    return (-5);
  } else {

  }
#line 128
  ret = i2c_algo_dp_aux_transaction(adapter, 2, (int )byte, (uint8_t *)0U);
#line 129
  return (ret);
}
}
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static int i2c_algo_dp_aux_get_byte(struct i2c_adapter *adapter , u8 *byte_ret ) 
{ 
  struct i2c_algo_dp_aux_data *algo_data ;
  int ret ;

  {
#line 139
  algo_data = (struct i2c_algo_dp_aux_data *)adapter->algo_data;
#line 142
  if (! algo_data->running) {
#line 143
    return (-5);
  } else {

  }
#line 145
  ret = i2c_algo_dp_aux_transaction(adapter, 4, 0, byte_ret);
#line 146
  return (ret);
}
}
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static int i2c_algo_dp_aux_xfer(struct i2c_adapter *adapter , struct i2c_msg *msgs ,
                                int num ) 
{ 
  int ret ;
  bool reading ;
  int m ;
  int b ;
  u16 len ;
  u8 *buf ;
  long tmp ;

  {
#line 154
  ret = 0;
#line 155
  reading = 0;
#line 159
  m = 0;
#line 159
  goto ldv_41955;
  ldv_41954: 
#line 160
  len = (msgs + (unsigned long )m)->len;
#line 161
  buf = (msgs + (unsigned long )m)->buf;
#line 162
  reading = ((int )(msgs + (unsigned long )m)->flags & 1) != 0;
#line 163
  ret = i2c_algo_dp_aux_address(adapter, (int )(msgs + (unsigned long )m)->addr, (int )reading);
#line 164
  if (ret < 0) {
#line 165
    goto ldv_41947;
  } else {

  }
#line 166
  if ((int )reading) {
#line 167
    b = 0;
#line 167
    goto ldv_41950;
    ldv_41949: 
#line 168
    ret = i2c_algo_dp_aux_get_byte(adapter, buf + (unsigned long )b);
#line 169
    if (ret < 0) {
#line 170
      goto ldv_41948;
    } else {

    }
#line 167
    b = b + 1;
    ldv_41950: ;
#line 167
    if ((int )len > b) {
#line 169
      goto ldv_41949;
    } else {

    }
    ldv_41948: ;
  } else {
#line 173
    b = 0;
#line 173
    goto ldv_41953;
    ldv_41952: 
#line 174
    ret = i2c_algo_dp_aux_put_byte(adapter, (int )*(buf + (unsigned long )b));
#line 175
    if (ret < 0) {
#line 176
      goto ldv_41951;
    } else {

    }
#line 173
    b = b + 1;
    ldv_41953: ;
#line 173
    if ((int )len > b) {
#line 175
      goto ldv_41952;
    } else {

    }
    ldv_41951: ;
  }
#line 179
  if (ret < 0) {
#line 180
    goto ldv_41947;
  } else {

  }
#line 159
  m = m + 1;
  ldv_41955: ;
#line 159
  if (m < num) {
#line 161
    goto ldv_41954;
  } else {

  }
  ldv_41947: ;
#line 182
  if (ret >= 0) {
#line 183
    ret = num;
  } else {

  }
#line 184
  i2c_algo_dp_aux_stop(adapter, (int )reading);
#line 185
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 185
  if (tmp != 0L) {
#line 185
    drm_ut_debug_printk("i2c_algo_dp_aux_xfer", "dp_aux_xfer return %d\n", ret);
  } else {

  }
#line 186
  return (ret);
}
}
#line 190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static u32 i2c_algo_dp_aux_functionality(struct i2c_adapter *adapter ) 
{ 


  {
#line 192
  return (268402699U);
}
}
#line 198 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static struct i2c_algorithm  const  i2c_dp_aux_algo  =    {& i2c_algo_dp_aux_xfer, 0, & i2c_algo_dp_aux_functionality, 0, 0};
#line 204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void i2c_dp_aux_reset_bus(struct i2c_adapter *adapter ) 
{ 


  {
#line 206
  i2c_algo_dp_aux_address(adapter, 0, 0);
#line 207
  i2c_algo_dp_aux_stop(adapter, 0);
#line 208
  return;
}
}
#line 211 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static int i2c_dp_aux_prepare_bus(struct i2c_adapter *adapter ) 
{ 


  {
#line 213
  adapter->algo = & i2c_dp_aux_algo;
#line 214
  adapter->retries = 3;
#line 215
  i2c_dp_aux_reset_bus(adapter);
#line 216
  return (0);
}
}
#line 224 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static int i2c_dp_aux_add_bus(struct i2c_adapter *adapter ) 
{ 
  int error ;

  {
#line 228
  error = i2c_dp_aux_prepare_bus(adapter);
#line 229
  if (error != 0) {
#line 230
    return (error);
  } else {

  }
#line 231
  error = i2c_add_adapter(adapter);
#line 232
  return (error);
}
}
#line 291 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static struct ddi_regoff ddi_DP_train_table[2U]  = {      {33068U, 33060U, 33108U, 33096U, 33100U, 33104U, 33112U}, 
        {33324U, 33316U, 33364U, 33352U, 33356U, 33360U, 33368U}};
#line 300 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static uint32_t dp_vswing_premph_table[8U]  = 
#line 300
  {      1429440852U,      16384U,      1431144788U,      8192U, 
        1432783188U,      0U,      1436205268U,      24576U};
#line 313 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static bool is_edp(struct gma_encoder *encoder ) 
{ 


  {
#line 315
  return (encoder->type == 10);
}
}
#line 319
static void cdv_intel_dp_start_link_train(struct gma_encoder *encoder ) ;
#line 320
static void cdv_intel_dp_complete_link_train(struct gma_encoder *encoder ) ;
#line 321
static void cdv_intel_dp_link_down(struct gma_encoder *encoder ) ;
#line 324 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static int cdv_intel_dp_max_lane_count(struct gma_encoder *encoder ) 
{ 
  struct cdv_intel_dp *intel_dp ;
  int max_lane_count ;

  {
#line 326
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 327
  max_lane_count = 4;
#line 329
  if ((unsigned int )intel_dp->dpcd[0] > 16U) {
#line 330
    max_lane_count = (int )intel_dp->dpcd[2] & 31;
#line 331
    switch (max_lane_count) {
    case 1: ;
    case 2: ;
    case 4: ;
#line 333
    goto ldv_42020;
    default: 
#line 335
    max_lane_count = 4;
    }
    ldv_42020: ;
  } else {

  }
#line 338
  return (max_lane_count);
}
}
#line 342 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static int cdv_intel_dp_max_link_bw(struct gma_encoder *encoder ) 
{ 
  struct cdv_intel_dp *intel_dp ;
  int max_link_bw ;

  {
#line 344
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 345
  max_link_bw = (int )intel_dp->dpcd[1];
#line 347
  switch (max_link_bw) {
  case 6: ;
  case 10: ;
#line 350
  goto ldv_42029;
  default: 
#line 352
  max_link_bw = 6;
#line 353
  goto ldv_42029;
  }
  ldv_42029: ;
#line 355
  return (max_link_bw);
}
}
#line 359 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static int cdv_intel_dp_link_clock(uint8_t link_bw ) 
{ 


  {
#line 361
  if ((unsigned int )link_bw == 10U) {
#line 362
    return (270000);
  } else {
#line 364
    return (162000);
  }
}
}
#line 368 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static int cdv_intel_dp_link_required(int pixel_clock , int bpp ) 
{ 


  {
#line 370
  return ((pixel_clock * bpp + 7) / 8);
}
}
#line 374 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static int cdv_intel_dp_max_data_rate(int max_link_clock , int max_lanes ) 
{ 


  {
#line 376
  return (((max_link_clock * max_lanes) * 19) / 20);
}
}
#line 379 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void cdv_intel_edp_panel_vdd_on(struct gma_encoder *intel_encoder ) 
{ 
  struct drm_device *dev ;
  struct cdv_intel_dp *intel_dp ;
  u32 pp ;
  long tmp ;
  long tmp___0 ;

  {
#line 381
  dev = intel_encoder->base.dev;
#line 382
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
#line 385
  if ((int )intel_dp->panel_on) {
#line 386
    tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 386
    if (tmp != 0L) {
#line 386
      drm_ut_debug_printk("cdv_intel_edp_panel_vdd_on", "Skip VDD on because of panel on\n");
    } else {

    }
#line 387
    return;
  } else {

  }
#line 389
  tmp___0 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 389
  if (tmp___0 != 0L) {
#line 389
    drm_ut_debug_printk("cdv_intel_edp_panel_vdd_on", "\n");
  } else {

  }
#line 391
  pp = REGISTER_READ(dev, 397828U);
#line 393
  pp = pp | 8U;
#line 394
  REGISTER_WRITE(dev, 397828U, pp);
#line 395
  REGISTER_READ(dev, 397828U);
#line 396
  msleep((unsigned int )intel_dp->panel_power_up_delay);
#line 397
  return;
}
}
#line 399 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void cdv_intel_edp_panel_vdd_off(struct gma_encoder *intel_encoder ) 
{ 
  struct drm_device *dev ;
  u32 pp ;
  long tmp ;

  {
#line 401
  dev = intel_encoder->base.dev;
#line 404
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 404
  if (tmp != 0L) {
#line 404
    drm_ut_debug_printk("cdv_intel_edp_panel_vdd_off", "\n");
  } else {

  }
#line 405
  pp = REGISTER_READ(dev, 397828U);
#line 407
  pp = pp & 4294967287U;
#line 408
  REGISTER_WRITE(dev, 397828U, pp);
#line 409
  REGISTER_READ(dev, 397828U);
#line 410
  return;
}
}
#line 414 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static bool cdv_intel_edp_panel_on(struct gma_encoder *intel_encoder ) 
{ 
  struct drm_device *dev ;
  struct cdv_intel_dp *intel_dp ;
  u32 pp ;
  u32 idle_on_mask ;
  long tmp ;
  uint32_t tmp___0 ;
  long tmp___1 ;
  unsigned long timeout__ ;
  unsigned long tmp___2 ;
  int ret__ ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___3 ;
  uint32_t tmp___4 ;

  {
#line 416
  dev = intel_encoder->base.dev;
#line 417
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
#line 418
  idle_on_mask = 2147483648U;
#line 420
  if ((int )intel_dp->panel_on) {
#line 421
    return (1);
  } else {

  }
#line 423
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 423
  if (tmp != 0L) {
#line 423
    drm_ut_debug_printk("cdv_intel_edp_panel_on", "\n");
  } else {

  }
#line 424
  pp = REGISTER_READ(dev, 397828U);
#line 425
  pp = pp & 65535U;
#line 427
  pp = pp | 2882338817U;
#line 428
  REGISTER_WRITE(dev, 397828U, pp);
#line 429
  REGISTER_READ(dev, 397828U);
#line 431
  tmp___2 = msecs_to_jiffies(1000U);
#line 431
  timeout__ = tmp___2 + (unsigned long )jiffies;
#line 431
  ret__ = 0;
#line 431
  goto ldv_42114;
  ldv_42113: ;
#line 431
  if ((long )(timeout__ - (unsigned long )jiffies) < 0L) {
#line 431
    ret__ = -110;
#line 431
    goto ldv_42071;
  } else {

  }
#line 431
  __vpp_verify = (void const   *)0;
#line 431
  switch (4UL) {
  case 1UL: ;
#line 431
  switch (4UL) {
  case 1UL: 
#line 431
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 431
  goto ldv_42077;
  case 2UL: 
#line 431
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 431
  goto ldv_42077;
  case 4UL: 
#line 431
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 431
  goto ldv_42077;
  case 8UL: 
#line 431
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 431
  goto ldv_42077;
  default: 
#line 431
  __bad_percpu_size();
  }
  ldv_42077: 
#line 431
  pscr_ret__ = pfo_ret__;
#line 431
  goto ldv_42083;
  case 2UL: ;
#line 431
  switch (4UL) {
  case 1UL: 
#line 431
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 431
  goto ldv_42087;
  case 2UL: 
#line 431
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 431
  goto ldv_42087;
  case 4UL: 
#line 431
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 431
  goto ldv_42087;
  case 8UL: 
#line 431
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 431
  goto ldv_42087;
  default: 
#line 431
  __bad_percpu_size();
  }
  ldv_42087: 
#line 431
  pscr_ret__ = pfo_ret_____0;
#line 431
  goto ldv_42083;
  case 4UL: ;
#line 431
  switch (4UL) {
  case 1UL: 
#line 431
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 431
  goto ldv_42096;
  case 2UL: 
#line 431
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 431
  goto ldv_42096;
  case 4UL: 
#line 431
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 431
  goto ldv_42096;
  case 8UL: 
#line 431
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 431
  goto ldv_42096;
  default: 
#line 431
  __bad_percpu_size();
  }
  ldv_42096: 
#line 431
  pscr_ret__ = pfo_ret_____1;
#line 431
  goto ldv_42083;
  case 8UL: ;
#line 431
  switch (4UL) {
  case 1UL: 
#line 431
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 431
  goto ldv_42105;
  case 2UL: 
#line 431
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 431
  goto ldv_42105;
  case 4UL: 
#line 431
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 431
  goto ldv_42105;
  case 8UL: 
#line 431
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 431
  goto ldv_42105;
  default: 
#line 431
  __bad_percpu_size();
  }
  ldv_42105: 
#line 431
  pscr_ret__ = pfo_ret_____2;
#line 431
  goto ldv_42083;
  default: 
#line 431
  __bad_size_call_parameter();
#line 431
  goto ldv_42083;
  }
  ldv_42083: 
#line 431
  tmp___3 = atomic_read((atomic_t const   *)(& kgdb_active));
#line 431
  if (pscr_ret__ != tmp___3) {
#line 431
    msleep(1U);
  } else {

  }
  ldv_42114: 
#line 431
  tmp___4 = REGISTER_READ(dev, 397824U);
#line 431
  if ((tmp___4 & idle_on_mask) != idle_on_mask) {
#line 433
    goto ldv_42113;
  } else {

  }
  ldv_42071: ;
#line 431
  if (ret__ != 0) {
#line 432
    tmp___1 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 432
    if (tmp___1 != 0L) {
#line 432
      tmp___0 = REGISTER_READ(dev, 397824U);
#line 432
      drm_ut_debug_printk("cdv_intel_edp_panel_on", "Error in Powering up eDP panel, status %x\n",
                          tmp___0);
    } else {

    }
#line 433
    intel_dp->panel_on = 0;
  } else {
#line 435
    intel_dp->panel_on = 1;
  }
#line 436
  msleep((unsigned int )intel_dp->panel_power_up_delay);
#line 438
  return (0);
}
}
#line 441 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void cdv_intel_edp_panel_off(struct gma_encoder *intel_encoder ) 
{ 
  struct drm_device *dev ;
  u32 pp ;
  u32 idle_off_mask ;
  struct cdv_intel_dp *intel_dp ;
  long tmp ;
  uint32_t tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  unsigned long timeout__ ;
  unsigned long tmp___3 ;
  int ret__ ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___4 ;
  uint32_t tmp___5 ;
  long tmp___6 ;

  {
#line 443
  dev = intel_encoder->base.dev;
#line 444
  idle_off_mask = 2147483648U;
#line 445
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
#line 447
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 447
  if (tmp != 0L) {
#line 447
    drm_ut_debug_printk("cdv_intel_edp_panel_off", "\n");
  } else {

  }
#line 449
  pp = REGISTER_READ(dev, 397828U);
#line 451
  if ((pp & 1U) == 0U) {
#line 452
    return;
  } else {

  }
#line 454
  intel_dp->panel_on = 0;
#line 455
  pp = pp & 65535U;
#line 458
  pp = pp & 4294967294U;
#line 459
  pp = pp & 4294967287U;
#line 460
  pp = pp & 4294967291U;
#line 461
  REGISTER_WRITE(dev, 397828U, pp);
#line 462
  REGISTER_READ(dev, 397828U);
#line 463
  tmp___1 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 463
  if (tmp___1 != 0L) {
#line 463
    tmp___0 = REGISTER_READ(dev, 397824U);
#line 463
    drm_ut_debug_printk("cdv_intel_edp_panel_off", "PP_STATUS %x\n", tmp___0);
  } else {

  }
#line 465
  tmp___3 = msecs_to_jiffies(1000U);
#line 465
  timeout__ = tmp___3 + (unsigned long )jiffies;
#line 465
  ret__ = 0;
#line 465
  goto ldv_42175;
  ldv_42174: ;
#line 465
  if ((long )(timeout__ - (unsigned long )jiffies) < 0L) {
#line 465
    ret__ = -110;
#line 465
    goto ldv_42132;
  } else {

  }
#line 465
  __vpp_verify = (void const   *)0;
#line 465
  switch (4UL) {
  case 1UL: ;
#line 465
  switch (4UL) {
  case 1UL: 
#line 465
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 465
  goto ldv_42138;
  case 2UL: 
#line 465
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 465
  goto ldv_42138;
  case 4UL: 
#line 465
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 465
  goto ldv_42138;
  case 8UL: 
#line 465
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 465
  goto ldv_42138;
  default: 
#line 465
  __bad_percpu_size();
  }
  ldv_42138: 
#line 465
  pscr_ret__ = pfo_ret__;
#line 465
  goto ldv_42144;
  case 2UL: ;
#line 465
  switch (4UL) {
  case 1UL: 
#line 465
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 465
  goto ldv_42148;
  case 2UL: 
#line 465
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 465
  goto ldv_42148;
  case 4UL: 
#line 465
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 465
  goto ldv_42148;
  case 8UL: 
#line 465
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 465
  goto ldv_42148;
  default: 
#line 465
  __bad_percpu_size();
  }
  ldv_42148: 
#line 465
  pscr_ret__ = pfo_ret_____0;
#line 465
  goto ldv_42144;
  case 4UL: ;
#line 465
  switch (4UL) {
  case 1UL: 
#line 465
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 465
  goto ldv_42157;
  case 2UL: 
#line 465
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 465
  goto ldv_42157;
  case 4UL: 
#line 465
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 465
  goto ldv_42157;
  case 8UL: 
#line 465
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 465
  goto ldv_42157;
  default: 
#line 465
  __bad_percpu_size();
  }
  ldv_42157: 
#line 465
  pscr_ret__ = pfo_ret_____1;
#line 465
  goto ldv_42144;
  case 8UL: ;
#line 465
  switch (4UL) {
  case 1UL: 
#line 465
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 465
  goto ldv_42166;
  case 2UL: 
#line 465
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 465
  goto ldv_42166;
  case 4UL: 
#line 465
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 465
  goto ldv_42166;
  case 8UL: 
#line 465
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 465
  goto ldv_42166;
  default: 
#line 465
  __bad_percpu_size();
  }
  ldv_42166: 
#line 465
  pscr_ret__ = pfo_ret_____2;
#line 465
  goto ldv_42144;
  default: 
#line 465
  __bad_size_call_parameter();
#line 465
  goto ldv_42144;
  }
  ldv_42144: 
#line 465
  tmp___4 = atomic_read((atomic_t const   *)(& kgdb_active));
#line 465
  if (pscr_ret__ != tmp___4) {
#line 465
    msleep(1U);
  } else {

  }
  ldv_42175: 
#line 465
  tmp___5 = REGISTER_READ(dev, 397824U);
#line 465
  if ((tmp___5 & idle_off_mask) != 0U) {
#line 467
    goto ldv_42174;
  } else {

  }
  ldv_42132: ;
#line 465
  if (ret__ != 0) {
#line 466
    tmp___2 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 466
    if (tmp___2 != 0L) {
#line 466
      drm_ut_debug_printk("cdv_intel_edp_panel_off", "Error in turning off Panel\n");
    } else {

    }
  } else {

  }
#line 469
  msleep((unsigned int )intel_dp->panel_power_cycle_delay);
#line 470
  tmp___6 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 470
  if (tmp___6 != 0L) {
#line 470
    drm_ut_debug_printk("cdv_intel_edp_panel_off", "Over\n");
  } else {

  }
#line 471
  return;
}
}
#line 473 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void cdv_intel_edp_backlight_on(struct gma_encoder *intel_encoder ) 
{ 
  struct drm_device *dev ;
  u32 pp ;
  long tmp ;

  {
#line 475
  dev = intel_encoder->base.dev;
#line 478
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 478
  if (tmp != 0L) {
#line 478
    drm_ut_debug_printk("cdv_intel_edp_backlight_on", "\n");
  } else {

  }
#line 485
  msleep(300U);
#line 486
  pp = REGISTER_READ(dev, 397828U);
#line 488
  pp = pp | 4U;
#line 489
  REGISTER_WRITE(dev, 397828U, pp);
#line 490
  gma_backlight_enable(dev);
#line 491
  return;
}
}
#line 493 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void cdv_intel_edp_backlight_off(struct gma_encoder *intel_encoder ) 
{ 
  struct drm_device *dev ;
  struct cdv_intel_dp *intel_dp ;
  u32 pp ;
  long tmp ;

  {
#line 495
  dev = intel_encoder->base.dev;
#line 496
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
#line 499
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 499
  if (tmp != 0L) {
#line 499
    drm_ut_debug_printk("cdv_intel_edp_backlight_off", "\n");
  } else {

  }
#line 500
  gma_backlight_disable(dev);
#line 501
  msleep(10U);
#line 502
  pp = REGISTER_READ(dev, 397828U);
#line 504
  pp = pp & 4294967291U;
#line 505
  REGISTER_WRITE(dev, 397828U, pp);
#line 506
  msleep((unsigned int )intel_dp->backlight_off_delay);
#line 507
  return;
}
}
#line 510 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static int cdv_intel_dp_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode ) 
{ 
  struct gma_encoder *encoder ;
  struct gma_encoder *tmp ;
  struct cdv_intel_dp *intel_dp ;
  int max_link_clock ;
  int tmp___0 ;
  int tmp___1 ;
  int max_lanes ;
  int tmp___2 ;
  struct drm_psb_private *dev_priv ;
  bool tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  bool tmp___10 ;

  {
#line 513
  tmp = gma_attached_encoder(connector);
#line 513
  encoder = tmp;
#line 514
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 515
  tmp___0 = cdv_intel_dp_max_link_bw(encoder);
#line 515
  tmp___1 = cdv_intel_dp_link_clock((int )((uint8_t )tmp___0));
#line 515
  max_link_clock = tmp___1;
#line 516
  tmp___2 = cdv_intel_dp_max_lane_count(encoder);
#line 516
  max_lanes = tmp___2;
#line 517
  dev_priv = (struct drm_psb_private *)(connector->dev)->dev_private;
#line 519
  tmp___3 = is_edp(encoder);
#line 519
  if ((int )tmp___3 && (unsigned long )intel_dp->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 520
    if (mode->hdisplay > (intel_dp->panel_fixed_mode)->hdisplay) {
#line 521
      return (29);
    } else {

    }
#line 522
    if (mode->vdisplay > (intel_dp->panel_fixed_mode)->vdisplay) {
#line 523
      return (29);
    } else {

    }
  } else {

  }
#line 528
  tmp___4 = is_edp(encoder);
#line 528
  if (tmp___4) {
#line 528
    tmp___5 = 0;
  } else {
#line 528
    tmp___5 = 1;
  }
#line 528
  if (tmp___5) {
#line 528
    tmp___6 = cdv_intel_dp_link_required(mode->clock, dev_priv->edp.bpp);
#line 528
    tmp___7 = cdv_intel_dp_max_data_rate(max_link_clock, max_lanes);
#line 528
    if (tmp___6 > tmp___7) {
#line 531
      return (15);
    } else {

    }
  } else {

  }
#line 533
  tmp___10 = is_edp(encoder);
#line 533
  if ((int )tmp___10) {
#line 534
    tmp___8 = cdv_intel_dp_link_required(mode->clock, 24);
#line 534
    tmp___9 = cdv_intel_dp_max_data_rate(max_link_clock, max_lanes);
#line 534
    if (tmp___8 > tmp___9) {
#line 536
      return (15);
    } else {

    }
  } else {

  }
#line 539
  if (mode->clock <= 9999) {
#line 540
    return (16);
  } else {

  }
#line 542
  return (0);
}
}
#line 546 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static uint32_t pack_aux(uint8_t *src , int src_bytes ) 
{ 
  int i ;
  uint32_t v ;

  {
#line 549
  v = 0U;
#line 551
  if (src_bytes > 4) {
#line 552
    src_bytes = 4;
  } else {

  }
#line 553
  i = 0;
#line 553
  goto ldv_42206;
  ldv_42205: 
#line 554
  v = ((unsigned int )*(src + (unsigned long )i) << (3 - i) * 8) | v;
#line 553
  i = i + 1;
  ldv_42206: ;
#line 553
  if (i < src_bytes) {
#line 555
    goto ldv_42205;
  } else {

  }

#line 555
  return (v);
}
}
#line 559 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void unpack_aux(uint32_t src , uint8_t *dst , int dst_bytes ) 
{ 
  int i ;

  {
#line 562
  if (dst_bytes > 4) {
#line 563
    dst_bytes = 4;
  } else {

  }
#line 564
  i = 0;
#line 564
  goto ldv_42215;
  ldv_42214: 
#line 565
  *(dst + (unsigned long )i) = (uint8_t )(src >> (3 - i) * 8);
#line 564
  i = i + 1;
  ldv_42215: ;
#line 564
  if (i < dst_bytes) {
#line 566
    goto ldv_42214;
  } else {

  }

#line 571
  return;
}
}
#line 569 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static int cdv_intel_dp_aux_ch(struct gma_encoder *encoder , uint8_t *send , int send_bytes ,
                               uint8_t *recv , int recv_size ) 
{ 
  struct cdv_intel_dp *intel_dp ;
  uint32_t output_reg ;
  struct drm_device *dev ;
  uint32_t ch_ctl ;
  uint32_t ch_data ;
  int i ;
  int recv_bytes ;
  uint32_t status ;
  uint32_t aux_clock_divider ;
  int try ;
  int precharge ;
  bool tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  long tmp___3 ;
  uint32_t tmp___4 ;

  {
#line 573
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 574
  output_reg = intel_dp->output_reg;
#line 575
  dev = encoder->base.dev;
#line 576
  ch_ctl = output_reg + 16U;
#line 577
  ch_data = ch_ctl + 4U;
#line 590
  aux_clock_divider = 100U;
#line 592
  precharge = 4;
#line 593
  tmp = is_edp(encoder);
#line 593
  if ((int )tmp) {
#line 594
    precharge = 10;
  } else {

  }
#line 596
  tmp___1 = REGISTER_READ(dev, ch_ctl);
#line 596
  if ((int )tmp___1 < 0) {
#line 597
    tmp___0 = REGISTER_READ(dev, ch_ctl);
#line 597
    drm_err("dp_aux_ch not started status 0x%08x\n", tmp___0);
#line 599
    return (-16);
  } else {

  }
#line 603
  try = 0;
#line 603
  goto ldv_42242;
  ldv_42241: 
#line 605
  i = 0;
#line 605
  goto ldv_42236;
  ldv_42235: 
#line 606
  tmp___2 = pack_aux(send + (unsigned long )i, send_bytes - i);
#line 606
  REGISTER_WRITE(dev, ch_data + (uint32_t )i, tmp___2);
#line 605
  i = i + 4;
  ldv_42236: ;
#line 605
  if (i < send_bytes) {
#line 607
    goto ldv_42235;
  } else {

  }
#line 610
  REGISTER_WRITE(dev, ch_ctl, ((uint32_t )(((long )(send_bytes << 20) | (-0x7FFFFFFF-1)) | (long )(precharge << 16)) | aux_clock_divider) | 1375731712U);
  ldv_42239: 
#line 620
  status = REGISTER_READ(dev, ch_ctl);
#line 621
  if ((int )status >= 0) {
#line 622
    goto ldv_42238;
  } else {

  }
#line 623
  __const_udelay(429500UL);
#line 624
  goto ldv_42239;
  ldv_42238: 
#line 627
  REGISTER_WRITE(dev, ch_ctl, status | 1375731712U);
#line 632
  if ((status & 1073741824U) != 0U) {
#line 633
    goto ldv_42240;
  } else {

  }
#line 603
  try = try + 1;
  ldv_42242: ;
#line 603
  if (try <= 4) {
#line 605
    goto ldv_42241;
  } else {

  }
  ldv_42240: ;
#line 636
  if ((status & 1073741824U) == 0U) {
#line 637
    drm_err("dp_aux_ch not done status 0x%08x\n", status);
#line 638
    return (-16);
  } else {

  }
#line 644
  if ((status & 33554432U) != 0U) {
#line 645
    drm_err("dp_aux_ch receive error status 0x%08x\n", status);
#line 646
    return (-5);
  } else {

  }
#line 651
  if ((status & 268435456U) != 0U) {
#line 652
    tmp___3 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 652
    if (tmp___3 != 0L) {
#line 652
      drm_ut_debug_printk("cdv_intel_dp_aux_ch", "dp_aux_ch timeout status 0x%08x\n",
                          status);
    } else {

    }
#line 653
    return (-110);
  } else {

  }
#line 657
  recv_bytes = (int )((status & 32505856U) >> 20);
#line 659
  if (recv_bytes > recv_size) {
#line 660
    recv_bytes = recv_size;
  } else {

  }
#line 662
  i = 0;
#line 662
  goto ldv_42245;
  ldv_42244: 
#line 663
  tmp___4 = REGISTER_READ(dev, ch_data + (uint32_t )i);
#line 663
  unpack_aux(tmp___4, recv + (unsigned long )i, recv_bytes - i);
#line 662
  i = i + 4;
  ldv_42245: ;
#line 662
  if (i < recv_bytes) {
#line 664
    goto ldv_42244;
  } else {

  }

#line 666
  return (recv_bytes);
}
}
#line 671 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static int cdv_intel_dp_aux_native_write(struct gma_encoder *encoder , uint16_t address ,
                                         uint8_t *send , int send_bytes ) 
{ 
  int ret ;
  uint8_t msg[20U] ;
  int msg_bytes ;
  uint8_t ack ;

  {
#line 679
  if (send_bytes > 16) {
#line 680
    return (-1);
  } else {

  }
#line 681
  msg[0] = 128U;
#line 682
  msg[1] = (uint8_t )((int )address >> 8);
#line 683
  msg[2] = (uint8_t )address;
#line 684
  msg[3] = (unsigned int )((uint8_t )send_bytes) + 255U;
#line 685
  memcpy((void *)(& msg) + 4U, (void const   *)send, (size_t )send_bytes);
#line 686
  msg_bytes = send_bytes + 4;
  ldv_42258: 
#line 688
  ret = cdv_intel_dp_aux_ch(encoder, (uint8_t *)(& msg), msg_bytes, & ack, 1);
#line 689
  if (ret < 0) {
#line 690
    return (ret);
  } else {

  }
#line 691
  ack = (uint8_t )((int )ack >> 4);
#line 692
  if (((int )ack & 3) == 0) {
#line 693
    goto ldv_42257;
  } else
#line 694
  if (((int )ack & 3) == 2) {
#line 695
    __const_udelay(429500UL);
  } else {
#line 697
    return (-5);
  }
#line 698
  goto ldv_42258;
  ldv_42257: ;
#line 699
  return (send_bytes);
}
}
#line 704 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static int cdv_intel_dp_aux_native_write_1(struct gma_encoder *encoder , uint16_t address ,
                                           uint8_t byte ) 
{ 
  int tmp ;

  {
#line 707
  tmp = cdv_intel_dp_aux_native_write(encoder, (int )address, & byte, 1);
#line 707
  return (tmp);
}
}
#line 712 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static int cdv_intel_dp_aux_native_read(struct gma_encoder *encoder , uint16_t address ,
                                        uint8_t *recv , int recv_bytes ) 
{ 
  uint8_t msg[4U] ;
  int msg_bytes ;
  uint8_t reply[20U] ;
  int reply_bytes ;
  uint8_t ack ;
  int ret ;

  {
#line 722
  msg[0] = 144U;
#line 723
  msg[1] = (uint8_t )((int )address >> 8);
#line 724
  msg[2] = (uint8_t )address;
#line 725
  msg[3] = (unsigned int )((uint8_t )recv_bytes) + 255U;
#line 727
  msg_bytes = 4;
#line 728
  reply_bytes = recv_bytes + 1;
  ldv_42276: 
#line 731
  ret = cdv_intel_dp_aux_ch(encoder, (uint8_t *)(& msg), msg_bytes, (uint8_t *)(& reply),
                            reply_bytes);
#line 733
  if (ret == 0) {
#line 734
    return (-71);
  } else {

  }
#line 735
  if (ret < 0) {
#line 736
    return (ret);
  } else {

  }
#line 737
  ack = (uint8_t )((int )reply[0] >> 4);
#line 738
  if (((int )ack & 3) == 0) {
#line 739
    memcpy((void *)recv, (void const   *)(& reply) + 1U, (size_t )(ret + -1));
#line 740
    return (ret + -1);
  } else
#line 742
  if (((int )ack & 3) == 2) {
#line 743
    __const_udelay(429500UL);
  } else {
#line 745
    return (-5);
  }
#line 746
  goto ldv_42276;
}
}
#line 750 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static int cdv_intel_dp_i2c_aux_ch(struct i2c_adapter *adapter , int mode , uint8_t write_byte ,
                                   uint8_t *read_byte ) 
{ 
  struct i2c_algo_dp_aux_data *algo_data ;
  struct cdv_intel_dp *intel_dp ;
  struct i2c_adapter  const  *__mptr ;
  struct gma_encoder *encoder ;
  uint16_t address ;
  uint8_t msg[5U] ;
  uint8_t reply[2U] ;
  unsigned int retry ;
  int msg_bytes ;
  int reply_bytes ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 753
  algo_data = (struct i2c_algo_dp_aux_data *)adapter->algo_data;
#line 754
  __mptr = (struct i2c_adapter  const  *)adapter;
#line 754
  intel_dp = (struct cdv_intel_dp *)__mptr + 0xffffffffffffffd0UL;
#line 757
  encoder = intel_dp->encoder;
#line 758
  address = algo_data->address;
#line 767
  if ((mode & 4) != 0) {
#line 768
    msg[0] = 16U;
  } else {
#line 770
    msg[0] = 0U;
  }
#line 772
  if ((mode & 8) == 0) {
#line 773
    msg[0] = (uint8_t )((unsigned int )msg[0] | 64U);
  } else {

  }
#line 775
  msg[1] = (uint8_t )((int )address >> 8);
#line 776
  msg[2] = (uint8_t )address;
#line 778
  switch (mode) {
  case 2: 
#line 780
  msg[3] = 0U;
#line 781
  msg[4] = write_byte;
#line 782
  msg_bytes = 5;
#line 783
  reply_bytes = 1;
#line 784
  goto ldv_42296;
  case 4: 
#line 786
  msg[3] = 0U;
#line 787
  msg_bytes = 4;
#line 788
  reply_bytes = 2;
#line 789
  goto ldv_42296;
  default: 
#line 791
  msg_bytes = 3;
#line 792
  reply_bytes = 1;
#line 793
  goto ldv_42296;
  }
  ldv_42296: 
#line 796
  retry = 0U;
#line 796
  goto ldv_42312;
  ldv_42311: 
#line 797
  ret = cdv_intel_dp_aux_ch(encoder, (uint8_t *)(& msg), msg_bytes, (uint8_t *)(& reply),
                            reply_bytes);
#line 800
  if (ret < 0) {
#line 801
    tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 801
    if (tmp != 0L) {
#line 801
      drm_ut_debug_printk("cdv_intel_dp_i2c_aux_ch", "aux_ch failed %d\n", ret);
    } else {

    }
#line 802
    return (ret);
  } else {

  }
#line 805
  switch (((int )reply[0] >> 4) & 3) {
  case 0: ;
#line 810
  goto ldv_42301;
  case 1: 
#line 812
  tmp___0 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 812
  if (tmp___0 != 0L) {
#line 812
    drm_ut_debug_printk("cdv_intel_dp_i2c_aux_ch", "aux_ch native nack\n");
  } else {

  }
#line 813
  return (-121);
  case 2: 
#line 815
  __const_udelay(429500UL);
#line 816
  goto ldv_42304;
  default: 
#line 818
  drm_err("aux_ch invalid native reply 0x%02x\n", (int )reply[0]);
#line 820
  return (-121);
  }
  ldv_42301: ;
#line 823
  switch (((int )reply[0] >> 4) & 12) {
  case 0: ;
#line 825
  if (mode == 4) {
#line 826
    *read_byte = reply[1];
  } else {

  }
#line 828
  return (reply_bytes + -1);
  case 4: 
#line 830
  tmp___1 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 830
  if (tmp___1 != 0L) {
#line 830
    drm_ut_debug_printk("cdv_intel_dp_i2c_aux_ch", "aux_i2c nack\n");
  } else {

  }
#line 831
  return (-121);
  case 8: 
#line 833
  tmp___2 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 833
  if (tmp___2 != 0L) {
#line 833
    drm_ut_debug_printk("cdv_intel_dp_i2c_aux_ch", "aux_i2c defer\n");
  } else {

  }
#line 834
  __const_udelay(429500UL);
#line 835
  goto ldv_42309;
  default: 
#line 837
  drm_err("aux_i2c invalid reply 0x%02x\n", (int )reply[0]);
#line 838
  return (-121);
  }
  ldv_42309: ;
  ldv_42304: 
#line 796
  retry = retry + 1U;
  ldv_42312: ;
#line 796
  if (retry <= 4U) {
#line 798
    goto ldv_42311;
  } else {

  }
#line 842
  drm_err("too many retries, giving up\n");
#line 843
  return (-121);
}
}
#line 847 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static int cdv_intel_dp_i2c_init(struct gma_connector *connector , struct gma_encoder *encoder ,
                                 char const   *name ) 
{ 
  struct cdv_intel_dp *intel_dp ;
  int ret ;
  long tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 850
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 853
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 853
  if (tmp != 0L) {
#line 853
    drm_ut_debug_printk("cdv_intel_dp_i2c_init", "i2c_init %s\n", name);
  } else {

  }
#line 855
  intel_dp->algo.running = 0;
#line 856
  intel_dp->algo.address = 0U;
#line 857
  intel_dp->algo.aux_ch = & cdv_intel_dp_i2c_aux_ch;
#line 859
  memset((void *)(& intel_dp->adapter), 0, 1936UL);
#line 860
  intel_dp->adapter.owner = & __this_module;
#line 861
  intel_dp->adapter.class = 8U;
#line 862
  strncpy((char *)(& intel_dp->adapter.name), name, 47UL);
#line 863
  intel_dp->adapter.name[47UL] = 0;
#line 864
  intel_dp->adapter.algo_data = (void *)(& intel_dp->algo);
#line 865
  intel_dp->adapter.dev.parent = connector->base.kdev;
#line 867
  tmp___0 = is_edp(encoder);
#line 867
  if ((int )tmp___0) {
#line 868
    cdv_intel_edp_panel_vdd_on(encoder);
  } else {

  }
#line 869
  ret = i2c_dp_aux_add_bus(& intel_dp->adapter);
#line 870
  tmp___1 = is_edp(encoder);
#line 870
  if ((int )tmp___1) {
#line 871
    cdv_intel_edp_panel_vdd_off(encoder);
  } else {

  }
#line 873
  return (ret);
}
}
#line 876 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void cdv_intel_fixed_panel_mode(struct drm_display_mode *fixed_mode , struct drm_display_mode *adjusted_mode ) 
{ 


  {
#line 879
  adjusted_mode->hdisplay = fixed_mode->hdisplay;
#line 880
  adjusted_mode->hsync_start = fixed_mode->hsync_start;
#line 881
  adjusted_mode->hsync_end = fixed_mode->hsync_end;
#line 882
  adjusted_mode->htotal = fixed_mode->htotal;
#line 884
  adjusted_mode->vdisplay = fixed_mode->vdisplay;
#line 885
  adjusted_mode->vsync_start = fixed_mode->vsync_start;
#line 886
  adjusted_mode->vsync_end = fixed_mode->vsync_end;
#line 887
  adjusted_mode->vtotal = fixed_mode->vtotal;
#line 889
  adjusted_mode->clock = fixed_mode->clock;
#line 891
  drm_mode_set_crtcinfo(adjusted_mode, 1);
#line 892
  return;
}
}
#line 895 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static bool cdv_intel_dp_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode  const  *mode ,
                                    struct drm_display_mode *adjusted_mode ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct gma_encoder *intel_encoder ;
  struct drm_encoder  const  *__mptr ;
  struct cdv_intel_dp *intel_dp ;
  int lane_count ;
  int clock ;
  int max_lane_count ;
  int tmp ;
  int max_clock ;
  int tmp___0 ;
  int bws[2U] ;
  int refclock ;
  int bpp ;
  bool tmp___1 ;
  int link_avail ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  bool tmp___7 ;

  {
#line 898
  dev_priv = (struct drm_psb_private *)(encoder->dev)->dev_private;
#line 899
  __mptr = (struct drm_encoder  const  *)encoder;
#line 899
  intel_encoder = (struct gma_encoder *)__mptr;
#line 900
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
#line 902
  tmp = cdv_intel_dp_max_lane_count(intel_encoder);
#line 902
  max_lane_count = tmp;
#line 903
  tmp___0 = cdv_intel_dp_max_link_bw(intel_encoder);
#line 903
  max_clock = tmp___0 == 10;
#line 904
  bws[0] = 6;
#line 904
  bws[1] = 10;
#line 905
  refclock = mode->clock;
#line 906
  bpp = 24;
#line 908
  tmp___1 = is_edp(intel_encoder);
#line 908
  if ((int )tmp___1 && (unsigned long )intel_dp->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 909
    cdv_intel_fixed_panel_mode(intel_dp->panel_fixed_mode, adjusted_mode);
#line 910
    refclock = (intel_dp->panel_fixed_mode)->clock;
#line 911
    bpp = dev_priv->edp.bpp;
  } else {

  }
#line 914
  lane_count = 1;
#line 914
  goto ldv_42349;
  ldv_42348: 
#line 915
  clock = max_clock;
#line 915
  goto ldv_42346;
  ldv_42345: 
#line 916
  tmp___2 = cdv_intel_dp_link_clock((int )((uint8_t )bws[clock]));
#line 916
  tmp___3 = cdv_intel_dp_max_data_rate(tmp___2, lane_count);
#line 916
  link_avail = tmp___3;
#line 918
  tmp___5 = cdv_intel_dp_link_required(refclock, bpp);
#line 918
  if (tmp___5 <= link_avail) {
#line 919
    intel_dp->link_bw = (uint8_t )bws[clock];
#line 920
    intel_dp->lane_count = (uint8_t )lane_count;
#line 921
    adjusted_mode->clock = cdv_intel_dp_link_clock((int )intel_dp->link_bw);
#line 922
    tmp___4 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 922
    if (tmp___4 != 0L) {
#line 922
      drm_ut_debug_printk("cdv_intel_dp_mode_fixup", "Display port link bw %02x lane count %d clock %d\n",
                          (int )intel_dp->link_bw, (int )intel_dp->lane_count, adjusted_mode->clock);
    } else {

    }
#line 926
    return (1);
  } else {

  }
#line 915
  clock = clock - 1;
  ldv_42346: ;
#line 915
  if (clock >= 0) {
#line 917
    goto ldv_42345;
  } else {

  }
#line 914
  lane_count = lane_count << 1;
  ldv_42349: ;
#line 914
  if (lane_count <= max_lane_count) {
#line 916
    goto ldv_42348;
  } else {

  }
#line 930
  tmp___7 = is_edp(intel_encoder);
#line 930
  if ((int )tmp___7) {
#line 932
    intel_dp->lane_count = (uint8_t )max_lane_count;
#line 933
    intel_dp->link_bw = (uint8_t )bws[max_clock];
#line 934
    adjusted_mode->clock = cdv_intel_dp_link_clock((int )intel_dp->link_bw);
#line 935
    tmp___6 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 935
    if (tmp___6 != 0L) {
#line 935
      drm_ut_debug_printk("cdv_intel_dp_mode_fixup", "Force picking display port link bw %02x lane count %d clock %d\n",
                          (int )intel_dp->link_bw, (int )intel_dp->lane_count, adjusted_mode->clock);
    } else {

    }
#line 940
    return (1);
  } else {

  }
#line 942
  return (0);
}
}
#line 954 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void cdv_intel_reduce_ratio(uint32_t *num , uint32_t *den ) 
{ 
  uint64_t value ;
  uint64_t m ;
  uint32_t __base ;
  uint32_t __rem ;

  {
#line 962
  m = (uint64_t )*num;
#line 963
  value = m * 8388608ULL;
#line 964
  __base = *den;
#line 964
  __rem = (uint32_t )(value % (uint64_t )__base);
#line 964
  value = value / (uint64_t )__base;
#line 964
  m = (uint64_t )__rem;
#line 965
  *num = (uint32_t )value;
#line 966
  *den = 8388608U;
#line 967
  return;
}
}
#line 970 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void cdv_intel_dp_compute_m_n(int bpp , int nlanes , int pixel_clock , int link_clock ,
                                     struct cdv_intel_dp_m_n *m_n ) 
{ 


  {
#line 976
  m_n->tu = 64U;
#line 977
  m_n->gmch_m = (uint32_t )((pixel_clock * bpp + 7) >> 3);
#line 978
  m_n->gmch_n = (uint32_t )(link_clock * nlanes);
#line 979
  cdv_intel_reduce_ratio(& m_n->gmch_m, & m_n->gmch_n);
#line 980
  m_n->link_m = (uint32_t )pixel_clock;
#line 981
  m_n->link_n = (uint32_t )link_clock;
#line 982
  cdv_intel_reduce_ratio(& m_n->link_m, & m_n->link_n);
#line 983
  return;
}
}
#line 986 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
void cdv_intel_dp_set_m_n(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                          struct drm_display_mode *adjusted_mode ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct drm_mode_config *mode_config ;
  struct drm_encoder *encoder ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  int lane_count ;
  int bpp ;
  struct cdv_intel_dp_m_n m_n ;
  int pipe ;
  struct list_head  const  *__mptr___0 ;
  struct gma_encoder *intel_encoder ;
  struct cdv_intel_dp *intel_dp ;
  struct drm_encoder  const  *__mptr___1 ;
  bool tmp ;
  struct list_head  const  *__mptr___2 ;

  {
#line 989
  dev = crtc->dev;
#line 990
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 991
  mode_config = & dev->mode_config;
#line 993
  __mptr = (struct drm_crtc  const  *)crtc;
#line 993
  gma_crtc = (struct gma_crtc *)__mptr;
#line 994
  lane_count = 4;
#line 994
  bpp = 24;
#line 996
  pipe = gma_crtc->pipe;
#line 1001
  __mptr___0 = (struct list_head  const  *)mode_config->encoder_list.next;
#line 1001
  encoder = (struct drm_encoder *)__mptr___0 + 0xfffffffffffffff8UL;
#line 1001
  goto ldv_42400;
  ldv_42399: ;
#line 1005
  if ((unsigned long )encoder->crtc != (unsigned long )crtc) {
#line 1006
    goto ldv_42395;
  } else {

  }
#line 1008
  __mptr___1 = (struct drm_encoder  const  *)encoder;
#line 1008
  intel_encoder = (struct gma_encoder *)__mptr___1;
#line 1009
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
#line 1010
  if (intel_encoder->type == 9) {
#line 1011
    lane_count = (int )intel_dp->lane_count;
#line 1012
    goto ldv_42398;
  } else {
#line 1013
    tmp = is_edp(intel_encoder);
#line 1013
    if ((int )tmp) {
#line 1014
      lane_count = (int )intel_dp->lane_count;
#line 1015
      bpp = dev_priv->edp.bpp;
#line 1016
      goto ldv_42398;
    } else {

    }
  }
  ldv_42395: 
#line 1001
  __mptr___2 = (struct list_head  const  *)encoder->head.next;
#line 1001
  encoder = (struct drm_encoder *)__mptr___2 + 0xfffffffffffffff8UL;
  ldv_42400: ;
#line 1001
  if ((unsigned long )(& encoder->head) != (unsigned long )(& mode_config->encoder_list)) {
#line 1003
    goto ldv_42399;
  } else {

  }
  ldv_42398: 
#line 1025
  cdv_intel_dp_compute_m_n(bpp, lane_count, mode->clock, adjusted_mode->clock, & m_n);
#line 1029
  REGISTER_WRITE(dev, (uint32_t )(pipe * 4096 + 458832), ((m_n.tu - 1U) << 25) | m_n.gmch_m);
#line 1032
  REGISTER_WRITE(dev, (uint32_t )(pipe * 4096 + 458836), m_n.gmch_n);
#line 1033
  REGISTER_WRITE(dev, (uint32_t )(pipe * 4096 + 458848), m_n.link_m);
#line 1034
  REGISTER_WRITE(dev, (uint32_t )(pipe * 4096 + 458852), m_n.link_n);
#line 1035
  return;
}
}
#line 1039 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void cdv_intel_dp_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                  struct drm_display_mode *adjusted_mode ) 
{ 
  struct gma_encoder *intel_encoder ;
  struct drm_encoder  const  *__mptr ;
  struct drm_crtc *crtc ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr___0 ;
  struct cdv_intel_dp *intel_dp ;
  struct drm_device *dev ;
  long tmp ;
  uint32_t pfit_control ;
  bool tmp___0 ;

  {
#line 1042
  __mptr = (struct drm_encoder  const  *)encoder;
#line 1042
  intel_encoder = (struct gma_encoder *)__mptr;
#line 1043
  crtc = encoder->crtc;
#line 1044
  __mptr___0 = (struct drm_crtc  const  *)crtc;
#line 1044
  gma_crtc = (struct gma_crtc *)__mptr___0;
#line 1045
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
#line 1046
  dev = encoder->dev;
#line 1048
  intel_dp->DP = 0U;
#line 1049
  intel_dp->DP = intel_dp->DP | intel_dp->color_range;
#line 1051
  if ((int )adjusted_mode->flags & 1) {
#line 1052
    intel_dp->DP = intel_dp->DP | 8U;
  } else {

  }
#line 1053
  if ((adjusted_mode->flags & 4U) != 0U) {
#line 1054
    intel_dp->DP = intel_dp->DP | 16U;
  } else {

  }
#line 1056
  intel_dp->DP = intel_dp->DP | 805306368U;
#line 1058
  switch ((int )intel_dp->lane_count) {
  case 1: 
#line 1060
  intel_dp->DP = intel_dp->DP;
#line 1061
  goto ldv_42416;
  case 2: 
#line 1063
  intel_dp->DP = intel_dp->DP | 524288U;
#line 1064
  goto ldv_42416;
  case 4: 
#line 1066
  intel_dp->DP = intel_dp->DP | 1572864U;
#line 1067
  goto ldv_42416;
  }
  ldv_42416: ;
#line 1069
  if ((int )intel_dp->has_audio) {
#line 1070
    intel_dp->DP = intel_dp->DP | 64U;
  } else {

  }
#line 1072
  memset((void *)(& intel_dp->link_configuration), 0, 9UL);
#line 1073
  intel_dp->link_configuration[0] = intel_dp->link_bw;
#line 1074
  intel_dp->link_configuration[1] = intel_dp->lane_count;
#line 1079
  if ((unsigned int )intel_dp->dpcd[0] > 16U && (int )((signed char )intel_dp->dpcd[2]) < 0) {
#line 1081
    intel_dp->link_configuration[1] = (uint8_t )((unsigned int )intel_dp->link_configuration[1] | 128U);
#line 1082
    intel_dp->DP = intel_dp->DP | 262144U;
  } else {

  }
#line 1086
  if (gma_crtc->pipe == 1) {
#line 1087
    intel_dp->DP = intel_dp->DP | 1073741824U;
  } else {

  }
#line 1089
  REGISTER_WRITE(dev, intel_dp->output_reg, intel_dp->DP | 2147483648U);
#line 1090
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1090
  if (tmp != 0L) {
#line 1090
    drm_ut_debug_printk("cdv_intel_dp_mode_set", "DP expected reg is %x\n", intel_dp->DP);
  } else {

  }
#line 1091
  tmp___0 = is_edp(intel_encoder);
#line 1091
  if ((int )tmp___0) {
#line 1093
    cdv_intel_edp_panel_on(intel_encoder);
#line 1095
    if (mode->hdisplay != adjusted_mode->hdisplay || mode->vdisplay != adjusted_mode->vdisplay) {
#line 1097
      pfit_control = 2147483648U;
    } else {
#line 1099
      pfit_control = 0U;
    }
#line 1101
    pfit_control = (uint32_t )(gma_crtc->pipe << 29) | pfit_control;
#line 1103
    REGISTER_WRITE(dev, 397872U, pfit_control);
  } else {

  }
#line 1105
  return;
}
}
#line 1109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void cdv_intel_dp_sink_dpms(struct gma_encoder *encoder , int mode ) 
{ 
  struct cdv_intel_dp *intel_dp ;
  int ret ;
  int i ;
  long tmp ;

  {
#line 1111
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1115
  if ((unsigned int )intel_dp->dpcd[0] <= 16U) {
#line 1116
    return;
  } else {

  }
#line 1118
  if (mode != 0) {
#line 1119
    ret = cdv_intel_dp_aux_native_write_1(encoder, 1536, 2);
#line 1121
    if (ret != 1) {
#line 1122
      tmp = ldv__builtin_expect((drm_debug & 2U) != 0U, 0L);
#line 1122
      if (tmp != 0L) {
#line 1122
        drm_ut_debug_printk("cdv_intel_dp_sink_dpms", "failed to write sink power state\n");
      } else {

      }
    } else {

    }
  } else {
#line 1128
    i = 0;
#line 1128
    goto ldv_42431;
    ldv_42430: 
#line 1129
    ret = cdv_intel_dp_aux_native_write_1(encoder, 1536, 1);
#line 1132
    if (ret == 1) {
#line 1133
      goto ldv_42429;
    } else {

    }
#line 1134
    __const_udelay(4295000UL);
#line 1128
    i = i + 1;
    ldv_42431: ;
#line 1128
    if (i <= 2) {
#line 1130
      goto ldv_42430;
    } else {

    }
    ldv_42429: ;
  }
#line 1136
  return;
}
}
#line 1139 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void cdv_intel_dp_prepare(struct drm_encoder *encoder ) 
{ 
  struct gma_encoder *intel_encoder ;
  struct drm_encoder  const  *__mptr ;
  int edp ;
  bool tmp ;

  {
#line 1141
  __mptr = (struct drm_encoder  const  *)encoder;
#line 1141
  intel_encoder = (struct gma_encoder *)__mptr;
#line 1142
  tmp = is_edp(intel_encoder);
#line 1142
  edp = (int )tmp;
#line 1144
  if (edp != 0) {
#line 1145
    cdv_intel_edp_backlight_off(intel_encoder);
#line 1146
    cdv_intel_edp_panel_off(intel_encoder);
#line 1147
    cdv_intel_edp_panel_vdd_on(intel_encoder);
  } else {

  }
#line 1150
  cdv_intel_dp_sink_dpms(intel_encoder, 0);
#line 1151
  cdv_intel_dp_link_down(intel_encoder);
#line 1152
  if (edp != 0) {
#line 1153
    cdv_intel_edp_panel_vdd_off(intel_encoder);
  } else {

  }
#line 1154
  return;
}
}
#line 1156 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void cdv_intel_dp_commit(struct drm_encoder *encoder ) 
{ 
  struct gma_encoder *intel_encoder ;
  struct drm_encoder  const  *__mptr ;
  int edp ;
  bool tmp ;

  {
#line 1158
  __mptr = (struct drm_encoder  const  *)encoder;
#line 1158
  intel_encoder = (struct gma_encoder *)__mptr;
#line 1159
  tmp = is_edp(intel_encoder);
#line 1159
  edp = (int )tmp;
#line 1161
  if (edp != 0) {
#line 1162
    cdv_intel_edp_panel_on(intel_encoder);
  } else {

  }
#line 1163
  cdv_intel_dp_start_link_train(intel_encoder);
#line 1164
  cdv_intel_dp_complete_link_train(intel_encoder);
#line 1165
  if (edp != 0) {
#line 1166
    cdv_intel_edp_backlight_on(intel_encoder);
  } else {

  }
#line 1167
  return;
}
}
#line 1170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void cdv_intel_dp_dpms(struct drm_encoder *encoder , int mode ) 
{ 
  struct gma_encoder *intel_encoder ;
  struct drm_encoder  const  *__mptr ;
  struct cdv_intel_dp *intel_dp ;
  struct drm_device *dev ;
  uint32_t dp_reg ;
  uint32_t tmp ;
  int edp ;
  bool tmp___0 ;

  {
#line 1172
  __mptr = (struct drm_encoder  const  *)encoder;
#line 1172
  intel_encoder = (struct gma_encoder *)__mptr;
#line 1173
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
#line 1174
  dev = encoder->dev;
#line 1175
  tmp = REGISTER_READ(dev, intel_dp->output_reg);
#line 1175
  dp_reg = tmp;
#line 1176
  tmp___0 = is_edp(intel_encoder);
#line 1176
  edp = (int )tmp___0;
#line 1178
  if (mode != 0) {
#line 1179
    if (edp != 0) {
#line 1180
      cdv_intel_edp_backlight_off(intel_encoder);
#line 1181
      cdv_intel_edp_panel_vdd_on(intel_encoder);
    } else {

    }
#line 1183
    cdv_intel_dp_sink_dpms(intel_encoder, mode);
#line 1184
    cdv_intel_dp_link_down(intel_encoder);
#line 1185
    if (edp != 0) {
#line 1186
      cdv_intel_edp_panel_vdd_off(intel_encoder);
#line 1187
      cdv_intel_edp_panel_off(intel_encoder);
    } else {

    }
  } else {
#line 1190
    if (edp != 0) {
#line 1191
      cdv_intel_edp_panel_on(intel_encoder);
    } else {

    }
#line 1192
    cdv_intel_dp_sink_dpms(intel_encoder, mode);
#line 1193
    if ((int )dp_reg >= 0) {
#line 1194
      cdv_intel_dp_start_link_train(intel_encoder);
#line 1195
      cdv_intel_dp_complete_link_train(intel_encoder);
    } else {

    }
#line 1197
    if (edp != 0) {
#line 1198
      cdv_intel_edp_backlight_on(intel_encoder);
    } else {

    }
  }
#line 1200
  return;
}
}
#line 1207 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static bool cdv_intel_dp_aux_native_read_retry(struct gma_encoder *encoder , uint16_t address ,
                                               uint8_t *recv , int recv_bytes ) 
{ 
  int ret ;
  int i ;

  {
#line 1216
  i = 0;
#line 1216
  goto ldv_42466;
  ldv_42465: 
#line 1217
  ret = cdv_intel_dp_aux_native_read(encoder, (int )address, recv, recv_bytes);
#line 1219
  if (ret == recv_bytes) {
#line 1220
    return (1);
  } else {

  }
#line 1221
  __const_udelay(4295000UL);
#line 1216
  i = i + 1;
  ldv_42466: ;
#line 1216
  if (i <= 2) {
#line 1218
    goto ldv_42465;
  } else {

  }

#line 1224
  return (0);
}
}
#line 1232 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static bool cdv_intel_dp_get_link_status(struct gma_encoder *encoder ) 
{ 
  struct cdv_intel_dp *intel_dp ;
  bool tmp ;

  {
#line 1234
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1235
  tmp = cdv_intel_dp_aux_native_read_retry(encoder, 514, (uint8_t *)(& intel_dp->link_status),
                                           6);
#line 1235
  return (tmp);
}
}
#line 1242 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static uint8_t cdv_intel_dp_link_status(uint8_t *link_status , int r ) 
{ 


  {
#line 1245
  return (*(link_status + ((unsigned long )r + 0xfffffffffffffdfeUL)));
}
}
#line 1249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static uint8_t cdv_intel_get_adjust_request_voltage(uint8_t *link_status , int lane ) 
{ 
  int i ;
  int s ;
  uint8_t l ;
  uint8_t tmp ;

  {
#line 1252
  i = (lane >> 1) + 518;
#line 1253
  s = lane & 1 ? 4 : 0;
#line 1256
  tmp = cdv_intel_dp_link_status(link_status, i);
#line 1256
  l = tmp;
#line 1258
  return ((unsigned int )((uint8_t )((int )l >> s)) & 3U);
}
}
#line 1262 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static uint8_t cdv_intel_get_adjust_request_pre_emphasis(uint8_t *link_status , int lane ) 
{ 
  int i ;
  int s ;
  uint8_t l ;
  uint8_t tmp ;

  {
#line 1265
  i = (lane >> 1) + 518;
#line 1266
  s = lane & 1 ? 6 : 2;
#line 1269
  tmp = cdv_intel_dp_link_status(link_status, i);
#line 1269
  l = tmp;
#line 1271
  return (((unsigned int )((uint8_t )((int )l >> s)) & 3U) << 3U);
}
}
#line 1306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void cdv_intel_get_adjust_train(struct gma_encoder *encoder ) 
{ 
  struct cdv_intel_dp *intel_dp ;
  uint8_t v ;
  uint8_t p ;
  int lane ;
  uint8_t this_v ;
  uint8_t tmp ;
  uint8_t this_p ;
  uint8_t tmp___0 ;

  {
#line 1308
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1309
  v = 0U;
#line 1310
  p = 0U;
#line 1313
  lane = 0;
#line 1313
  goto ldv_42500;
  ldv_42499: 
#line 1314
  tmp = cdv_intel_get_adjust_request_voltage((uint8_t *)(& intel_dp->link_status),
                                             lane);
#line 1314
  this_v = tmp;
#line 1315
  tmp___0 = cdv_intel_get_adjust_request_pre_emphasis((uint8_t *)(& intel_dp->link_status),
                                                      lane);
#line 1315
  this_p = tmp___0;
#line 1317
  if ((int )this_v > (int )v) {
#line 1318
    v = this_v;
  } else {

  }
#line 1319
  if ((int )this_p > (int )p) {
#line 1320
    p = this_p;
  } else {

  }
#line 1313
  lane = lane + 1;
  ldv_42500: ;
#line 1313
  if ((int )intel_dp->lane_count > lane) {
#line 1315
    goto ldv_42499;
  } else {

  }

#line 1323
  if ((unsigned int )v > 2U) {
#line 1324
    v = 7U;
  } else {

  }
#line 1326
  if ((unsigned int )p == 24U) {
#line 1327
    p = (uint8_t )((unsigned int )p | 32U);
  } else {

  }
#line 1329
  lane = 0;
#line 1329
  goto ldv_42503;
  ldv_42502: 
#line 1330
  intel_dp->train_set[lane] = (uint8_t )((int )v | (int )p);
#line 1329
  lane = lane + 1;
  ldv_42503: ;
#line 1329
  if (lane <= 3) {
#line 1331
    goto ldv_42502;
  } else {

  }

#line 1336
  return;
}
}
#line 1335 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static uint8_t cdv_intel_get_lane_status(uint8_t *link_status , int lane ) 
{ 
  int i ;
  int s ;
  uint8_t l ;
  uint8_t tmp ;

  {
#line 1338
  i = (lane >> 1) + 514;
#line 1339
  s = (lane & 1) * 4;
#line 1340
  tmp = cdv_intel_dp_link_status(link_status, i);
#line 1340
  l = tmp;
#line 1342
  return ((unsigned int )((uint8_t )((int )l >> s)) & 15U);
}
}
#line 1347 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static bool cdv_intel_clock_recovery_ok(uint8_t *link_status , int lane_count ) 
{ 
  int lane ;
  uint8_t lane_status ;

  {
#line 1352
  lane = 0;
#line 1352
  goto ldv_42519;
  ldv_42518: 
#line 1353
  lane_status = cdv_intel_get_lane_status(link_status, lane);
#line 1354
  if (((int )lane_status & 1) == 0) {
#line 1355
    return (0);
  } else {

  }
#line 1352
  lane = lane + 1;
  ldv_42519: ;
#line 1352
  if (lane < lane_count) {
#line 1354
    goto ldv_42518;
  } else {

  }

#line 1357
  return (1);
}
}
#line 1365 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static bool cdv_intel_channel_eq_ok(struct gma_encoder *encoder ) 
{ 
  struct cdv_intel_dp *intel_dp ;
  uint8_t lane_align ;
  uint8_t lane_status ;
  int lane ;

  {
#line 1367
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1372
  lane_align = cdv_intel_dp_link_status((uint8_t *)(& intel_dp->link_status), 516);
#line 1374
  if (((int )lane_align & 1) == 0) {
#line 1375
    return (0);
  } else {

  }
#line 1376
  lane = 0;
#line 1376
  goto ldv_42529;
  ldv_42528: 
#line 1377
  lane_status = cdv_intel_get_lane_status((uint8_t *)(& intel_dp->link_status), lane);
#line 1378
  if (((int )lane_status & 7) != 7) {
#line 1379
    return (0);
  } else {

  }
#line 1376
  lane = lane + 1;
  ldv_42529: ;
#line 1376
  if ((int )intel_dp->lane_count > lane) {
#line 1378
    goto ldv_42528;
  } else {

  }

#line 1381
  return (1);
}
}
#line 1385 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static bool cdv_intel_dp_set_link_train(struct gma_encoder *encoder , uint32_t dp_reg_value ,
                                        uint8_t dp_train_pat ) 
{ 
  struct drm_device *dev ;
  int ret ;
  struct cdv_intel_dp *intel_dp ;
  long tmp ;

  {
#line 1390
  dev = encoder->base.dev;
#line 1392
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1394
  REGISTER_WRITE(dev, intel_dp->output_reg, dp_reg_value);
#line 1395
  REGISTER_READ(dev, intel_dp->output_reg);
#line 1397
  ret = cdv_intel_dp_aux_native_write_1(encoder, 258, (int )dp_train_pat);
#line 1401
  if (ret != 1) {
#line 1402
    tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1402
    if (tmp != 0L) {
#line 1402
      drm_ut_debug_printk("cdv_intel_dp_set_link_train", "Failure in setting link pattern %x\n",
                          (int )dp_train_pat);
    } else {

    }
#line 1404
    return (0);
  } else {

  }
#line 1407
  return (1);
}
}
#line 1412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static bool cdv_intel_dplink_set_level(struct gma_encoder *encoder , uint8_t dp_train_pat ) 
{ 
  int ret ;
  struct cdv_intel_dp *intel_dp ;
  long tmp ;

  {
#line 1417
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1419
  ret = cdv_intel_dp_aux_native_write(encoder, 259, (uint8_t *)(& intel_dp->train_set),
                                      (int )intel_dp->lane_count);
#line 1424
  if ((int )intel_dp->lane_count != ret) {
#line 1425
    tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1425
    if (tmp != 0L) {
#line 1425
      drm_ut_debug_printk("cdv_intel_dplink_set_level", "Failure in setting level %d, lane_cnt= %d\n",
                          (int )intel_dp->train_set[0], (int )intel_dp->lane_count);
    } else {

    }
#line 1427
    return (0);
  } else {

  }
#line 1429
  return (1);
}
}
#line 1433 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void cdv_intel_dp_set_vswing_premph(struct gma_encoder *encoder , uint8_t signal_level ) 
{ 
  struct drm_device *dev ;
  struct cdv_intel_dp *intel_dp ;
  struct ddi_regoff *ddi_reg ;
  int vswing ;
  int premph ;
  int index ;
  long tmp ;

  {
#line 1435
  dev = encoder->base.dev;
#line 1436
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1440
  if (intel_dp->output_reg == 409856U) {
#line 1441
    ddi_reg = (struct ddi_regoff *)(& ddi_DP_train_table);
  } else {
#line 1443
    ddi_reg = (struct ddi_regoff *)(& ddi_DP_train_table) + 1UL;
  }
#line 1445
  vswing = (int )signal_level & 3;
#line 1446
  premph = ((int )signal_level & 24) >> 3;
#line 1449
  if (vswing + premph > 3) {
#line 1450
    return;
  } else {

  }
#line 1452
  return;
#line 1454
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1454
  if (tmp != 0L) {
#line 1454
    drm_ut_debug_printk("cdv_intel_dp_set_vswing_premph", "Test2\n");
  } else {

  }
#line 1456
  cdv_sb_reset(dev);
#line 1459
  cdv_sb_write(dev, ddi_reg->VSwing5, 84226362U);
#line 1462
  cdv_sb_write(dev, ddi_reg->VSwing1, 1128292437U);
#line 1467
  index = (vswing + premph) * 2;
#line 1468
  if (premph == 1 && vswing == 1) {
#line 1469
    cdv_sb_write(dev, ddi_reg->VSwing2, 1433635156U);
  } else {
#line 1471
    cdv_sb_write(dev, ddi_reg->VSwing2, dp_vswing_premph_table[index]);
  }
#line 1474
  if (vswing + premph == 3) {
#line 1475
    cdv_sb_write(dev, ddi_reg->VSwing3, 1887445056U);
  } else {
#line 1477
    cdv_sb_write(dev, ddi_reg->VSwing3, 1082138688U);
  }
#line 1483
  cdv_sb_write(dev, ddi_reg->VSwing1, 3275776085U);
#line 1488
  cdv_sb_write(dev, ddi_reg->PreEmph1, 520290368U);
#line 1491
  index = premph * 2 + 1;
#line 1492
  cdv_sb_write(dev, ddi_reg->PreEmph2, dp_vswing_premph_table[index]);
#line 1493
  return;
}
}
#line 1499 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void cdv_intel_dp_start_link_train(struct gma_encoder *encoder ) 
{ 
  struct drm_device *dev ;
  struct cdv_intel_dp *intel_dp ;
  int i ;
  uint8_t voltage ;
  bool clock_recovery ;
  int tries ;
  u32 reg ;
  uint32_t DP ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  bool tmp___9 ;
  long tmp___10 ;

  {
#line 1501
  dev = encoder->base.dev;
#line 1502
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1505
  clock_recovery = 0;
#line 1508
  DP = intel_dp->DP;
#line 1510
  DP = DP | 2147483648U;
#line 1511
  DP = DP & 3489660927U;
#line 1513
  reg = DP;
#line 1514
  reg = reg;
#line 1516
  REGISTER_WRITE(dev, intel_dp->output_reg, reg);
#line 1517
  REGISTER_READ(dev, intel_dp->output_reg);
#line 1518
  gma_wait_for_vblank(dev);
#line 1520
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1520
  if (tmp != 0L) {
#line 1520
    drm_ut_debug_printk("cdv_intel_dp_start_link_train", "Link config\n");
  } else {

  }
#line 1522
  cdv_intel_dp_aux_native_write(encoder, 256, (uint8_t *)(& intel_dp->link_configuration),
                                2);
#line 1526
  memset((void *)(& intel_dp->train_set), 0, 4UL);
#line 1527
  voltage = 0U;
#line 1528
  tries = 0;
#line 1529
  clock_recovery = 0;
#line 1531
  tmp___0 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1531
  if (tmp___0 != 0L) {
#line 1531
    drm_ut_debug_printk("cdv_intel_dp_start_link_train", "Start train\n");
  } else {

  }
#line 1532
  reg = DP;
  ldv_42574: 
#line 1537
  tmp___1 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1537
  if (tmp___1 != 0L) {
#line 1537
    drm_ut_debug_printk("cdv_intel_dp_start_link_train", "DP Link Train Set %x, Link_config %x, %x\n",
                        (int )intel_dp->train_set[0], (int )intel_dp->link_configuration[0],
                        (int )intel_dp->link_configuration[1]);
  } else {

  }
#line 1542
  tmp___3 = cdv_intel_dp_set_link_train(encoder, reg, 1);
#line 1542
  if (tmp___3) {
#line 1542
    tmp___4 = 0;
  } else {
#line 1542
    tmp___4 = 1;
  }
#line 1542
  if (tmp___4) {
#line 1543
    tmp___2 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1543
    if (tmp___2 != 0L) {
#line 1543
      drm_ut_debug_printk("cdv_intel_dp_start_link_train", "Failure in aux-transfer setting pattern 1\n");
    } else {

    }
  } else {

  }
#line 1545
  cdv_intel_dp_set_vswing_premph(encoder, (int )intel_dp->train_set[0]);
#line 1548
  cdv_intel_dplink_set_level(encoder, 1);
#line 1550
  __const_udelay(859000UL);
#line 1551
  tmp___5 = cdv_intel_dp_get_link_status(encoder);
#line 1551
  if (tmp___5) {
#line 1551
    tmp___6 = 0;
  } else {
#line 1551
    tmp___6 = 1;
  }
#line 1551
  if (tmp___6) {
#line 1552
    goto ldv_42570;
  } else {

  }
#line 1554
  tmp___7 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1554
  if (tmp___7 != 0L) {
#line 1554
    drm_ut_debug_printk("cdv_intel_dp_start_link_train", "DP Link status %x, %x, %x, %x, %x, %x\n",
                        (int )intel_dp->link_status[0], (int )intel_dp->link_status[1],
                        (int )intel_dp->link_status[2], (int )intel_dp->link_status[3],
                        (int )intel_dp->link_status[4], (int )intel_dp->link_status[5]);
  } else {

  }
#line 1558
  tmp___9 = cdv_intel_clock_recovery_ok((uint8_t *)(& intel_dp->link_status), (int )intel_dp->lane_count);
#line 1558
  if ((int )tmp___9) {
#line 1559
    tmp___8 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1559
    if (tmp___8 != 0L) {
#line 1559
      drm_ut_debug_printk("cdv_intel_dp_start_link_train", "PT1 train is done\n");
    } else {

    }
#line 1560
    clock_recovery = 1;
#line 1561
    goto ldv_42570;
  } else {

  }
#line 1565
  i = 0;
#line 1565
  goto ldv_42573;
  ldv_42572: ;
#line 1566
  if (((int )intel_dp->train_set[i] & 4) == 0) {
#line 1567
    goto ldv_42571;
  } else {

  }
#line 1565
  i = i + 1;
  ldv_42573: ;
#line 1565
  if ((int )intel_dp->lane_count > i) {
#line 1567
    goto ldv_42572;
  } else {

  }
  ldv_42571: ;
#line 1568
  if ((int )intel_dp->lane_count == i) {
#line 1569
    goto ldv_42570;
  } else {

  }
#line 1572
  if (((int )intel_dp->train_set[0] & 3) == (int )voltage) {
#line 1573
    tries = tries + 1;
#line 1574
    if (tries == 5) {
#line 1575
      goto ldv_42570;
    } else {

    }
  } else {
#line 1577
    tries = 0;
  }
#line 1578
  voltage = (unsigned int )intel_dp->train_set[0] & 3U;
#line 1581
  cdv_intel_get_adjust_train(encoder);
#line 1583
  goto ldv_42574;
  ldv_42570: ;
#line 1585
  if (! clock_recovery) {
#line 1586
    tmp___10 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1586
    if (tmp___10 != 0L) {
#line 1586
      drm_ut_debug_printk("cdv_intel_dp_start_link_train", "failure in DP patter 1 training, train set %x\n",
                          (int )intel_dp->train_set[0]);
    } else {

    }
  } else {

  }
#line 1589
  intel_dp->DP = DP;
#line 1590
  return;
}
}
#line 1593 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void cdv_intel_dp_complete_link_train(struct gma_encoder *encoder ) 
{ 
  struct drm_device *dev ;
  struct cdv_intel_dp *intel_dp ;
  bool channel_eq ;
  int tries ;
  int cr_tries ;
  u32 reg ;
  uint32_t DP ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  bool tmp___10 ;

  {
#line 1595
  dev = encoder->base.dev;
#line 1596
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1597
  channel_eq = 0;
#line 1600
  DP = intel_dp->DP;
#line 1603
  tries = 0;
#line 1604
  cr_tries = 0;
#line 1605
  channel_eq = 0;
#line 1607
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1607
  if (tmp != 0L) {
#line 1607
    drm_ut_debug_printk("cdv_intel_dp_complete_link_train", "\n");
  } else {

  }
#line 1608
  reg = DP | 268435456U;
  ldv_42588: 
#line 1612
  tmp___0 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1612
  if (tmp___0 != 0L) {
#line 1612
    drm_ut_debug_printk("cdv_intel_dp_complete_link_train", "DP Link Train Set %x, Link_config %x, %x\n",
                        (int )intel_dp->train_set[0], (int )intel_dp->link_configuration[0],
                        (int )intel_dp->link_configuration[1]);
  } else {

  }
#line 1618
  tmp___2 = cdv_intel_dp_set_link_train(encoder, reg, 2);
#line 1618
  if (tmp___2) {
#line 1618
    tmp___3 = 0;
  } else {
#line 1618
    tmp___3 = 1;
  }
#line 1618
  if (tmp___3) {
#line 1620
    tmp___1 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1620
    if (tmp___1 != 0L) {
#line 1620
      drm_ut_debug_printk("cdv_intel_dp_complete_link_train", "Failure in aux-transfer setting pattern 2\n");
    } else {

    }
  } else {

  }
#line 1624
  if (cr_tries > 5) {
#line 1625
    drm_err("failed to train DP, aborting\n");
#line 1626
    cdv_intel_dp_link_down(encoder);
#line 1627
    goto ldv_42586;
  } else {

  }
#line 1630
  cdv_intel_dp_set_vswing_premph(encoder, (int )intel_dp->train_set[0]);
#line 1632
  cdv_intel_dplink_set_level(encoder, 2);
#line 1634
  __const_udelay(4295000UL);
#line 1635
  tmp___4 = cdv_intel_dp_get_link_status(encoder);
#line 1635
  if (tmp___4) {
#line 1635
    tmp___5 = 0;
  } else {
#line 1635
    tmp___5 = 1;
  }
#line 1635
  if (tmp___5) {
#line 1636
    goto ldv_42586;
  } else {

  }
#line 1638
  tmp___6 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1638
  if (tmp___6 != 0L) {
#line 1638
    drm_ut_debug_printk("cdv_intel_dp_complete_link_train", "DP Link status %x, %x, %x, %x, %x, %x\n",
                        (int )intel_dp->link_status[0], (int )intel_dp->link_status[1],
                        (int )intel_dp->link_status[2], (int )intel_dp->link_status[3],
                        (int )intel_dp->link_status[4], (int )intel_dp->link_status[5]);
  } else {

  }
#line 1643
  tmp___7 = cdv_intel_clock_recovery_ok((uint8_t *)(& intel_dp->link_status), (int )intel_dp->lane_count);
#line 1643
  if (tmp___7) {
#line 1643
    tmp___8 = 0;
  } else {
#line 1643
    tmp___8 = 1;
  }
#line 1643
  if (tmp___8) {
#line 1644
    cdv_intel_dp_start_link_train(encoder);
#line 1645
    cr_tries = cr_tries + 1;
#line 1646
    goto ldv_42587;
  } else {

  }
#line 1649
  tmp___10 = cdv_intel_channel_eq_ok(encoder);
#line 1649
  if ((int )tmp___10) {
#line 1650
    tmp___9 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1650
    if (tmp___9 != 0L) {
#line 1650
      drm_ut_debug_printk("cdv_intel_dp_complete_link_train", "PT2 train is done\n");
    } else {

    }
#line 1651
    channel_eq = 1;
#line 1652
    goto ldv_42586;
  } else {

  }
#line 1656
  if (tries > 5) {
#line 1657
    cdv_intel_dp_link_down(encoder);
#line 1658
    cdv_intel_dp_start_link_train(encoder);
#line 1659
    tries = 0;
#line 1660
    cr_tries = cr_tries + 1;
#line 1661
    goto ldv_42587;
  } else {

  }
#line 1665
  cdv_intel_get_adjust_train(encoder);
#line 1666
  tries = tries + 1;
  ldv_42587: ;
#line 1668
  goto ldv_42588;
  ldv_42586: 
#line 1670
  reg = DP | 805306368U;
#line 1672
  REGISTER_WRITE(dev, intel_dp->output_reg, reg);
#line 1673
  REGISTER_READ(dev, intel_dp->output_reg);
#line 1674
  cdv_intel_dp_aux_native_write_1(encoder, 258, 0);
#line 1675
  return;
}
}
#line 1679 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void cdv_intel_dp_link_down(struct gma_encoder *encoder ) 
{ 
  struct drm_device *dev ;
  struct cdv_intel_dp *intel_dp ;
  uint32_t DP ;
  uint32_t tmp ;
  long tmp___0 ;

  {
#line 1681
  dev = encoder->base.dev;
#line 1682
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1683
  DP = intel_dp->DP;
#line 1685
  tmp = REGISTER_READ(dev, intel_dp->output_reg);
#line 1685
  if ((int )tmp >= 0) {
#line 1686
    return;
  } else {

  }
#line 1688
  tmp___0 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1688
  if (tmp___0 != 0L) {
#line 1688
    drm_ut_debug_printk("cdv_intel_dp_link_down", "\n");
  } else {

  }
#line 1692
  DP = DP & 3489660927U;
#line 1693
  REGISTER_WRITE(dev, intel_dp->output_reg, DP | 536870912U);
#line 1695
  REGISTER_READ(dev, intel_dp->output_reg);
#line 1697
  msleep(17U);
#line 1699
  REGISTER_WRITE(dev, intel_dp->output_reg, DP & 2147483647U);
#line 1700
  REGISTER_READ(dev, intel_dp->output_reg);
#line 1701
  return;
}
}
#line 1703 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static enum drm_connector_status cdv_dp_detect(struct gma_encoder *encoder ) 
{ 
  struct cdv_intel_dp *intel_dp ;
  enum drm_connector_status status ;
  int tmp ;
  long tmp___0 ;

  {
#line 1705
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1708
  status = 2;
#line 1709
  tmp = cdv_intel_dp_aux_native_read(encoder, 0, (uint8_t *)(& intel_dp->dpcd), 4);
#line 1709
  if (tmp == 4) {
#line 1712
    if ((unsigned int )intel_dp->dpcd[0] != 0U) {
#line 1713
      status = 1;
    } else {

    }
  } else {

  }
#line 1715
  if ((unsigned int )status == 1U) {
#line 1716
    tmp___0 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1716
    if (tmp___0 != 0L) {
#line 1716
      drm_ut_debug_printk("cdv_dp_detect", "DPCD: Rev=%x LN_Rate=%x LN_CNT=%x LN_DOWNSP=%x\n",
                          (int )intel_dp->dpcd[0], (int )intel_dp->dpcd[1], (int )intel_dp->dpcd[2],
                          (int )intel_dp->dpcd[3]);
    } else {

    }
  } else {

  }
#line 1719
  return (status);
}
}
#line 1729 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static enum drm_connector_status cdv_intel_dp_detect(struct drm_connector *connector ,
                                                     bool force ) 
{ 
  struct gma_encoder *encoder ;
  struct gma_encoder *tmp ;
  struct cdv_intel_dp *intel_dp ;
  enum drm_connector_status status ;
  struct edid *edid ;
  int edp ;
  bool tmp___0 ;

  {
#line 1731
  tmp = gma_attached_encoder(connector);
#line 1731
  encoder = tmp;
#line 1732
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1734
  edid = (struct edid *)0;
#line 1735
  tmp___0 = is_edp(encoder);
#line 1735
  edp = (int )tmp___0;
#line 1737
  intel_dp->has_audio = 0;
#line 1739
  if (edp != 0) {
#line 1740
    cdv_intel_edp_panel_vdd_on(encoder);
  } else {

  }
#line 1741
  status = cdv_dp_detect(encoder);
#line 1742
  if ((unsigned int )status != 1U) {
#line 1743
    if (edp != 0) {
#line 1744
      cdv_intel_edp_panel_vdd_off(encoder);
    } else {

    }
#line 1745
    return (status);
  } else {

  }
#line 1748
  if (intel_dp->force_audio != 0) {
#line 1749
    intel_dp->has_audio = intel_dp->force_audio > 0;
  } else {
#line 1751
    edid = drm_get_edid(connector, & intel_dp->adapter);
#line 1752
    if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
#line 1753
      intel_dp->has_audio = drm_detect_monitor_audio(edid);
#line 1754
      kfree((void const   *)edid);
    } else {

    }
  }
#line 1757
  if (edp != 0) {
#line 1758
    cdv_intel_edp_panel_vdd_off(encoder);
  } else {

  }
#line 1760
  return (1);
}
}
#line 1763 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static int cdv_intel_dp_get_modes(struct drm_connector *connector ) 
{ 
  struct gma_encoder *intel_encoder ;
  struct gma_encoder *tmp ;
  struct cdv_intel_dp *intel_dp ;
  struct edid *edid ;
  int ret ;
  int edp ;
  bool tmp___0 ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct drm_display_mode *newmode ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct drm_display_mode *mode ;
  bool tmp___1 ;

  {
#line 1765
  tmp = gma_attached_encoder(connector);
#line 1765
  intel_encoder = tmp;
#line 1766
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
#line 1767
  edid = (struct edid *)0;
#line 1768
  ret = 0;
#line 1769
  tmp___0 = is_edp(intel_encoder);
#line 1769
  edp = (int )tmp___0;
#line 1772
  edid = drm_get_edid(connector, & intel_dp->adapter);
#line 1773
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
#line 1774
    drm_mode_connector_update_edid_property(connector, (struct edid  const  *)edid);
#line 1775
    ret = drm_add_edid_modes(connector, edid);
#line 1776
    kfree((void const   *)edid);
  } else {

  }
#line 1779
  tmp___1 = is_edp(intel_encoder);
#line 1779
  if ((int )tmp___1) {
#line 1780
    dev = connector->dev;
#line 1781
    dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 1783
    cdv_intel_edp_panel_vdd_off(intel_encoder);
#line 1784
    if (ret != 0) {
#line 1785
      if (edp != 0 && (unsigned long )intel_dp->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 1787
        __mptr = (struct list_head  const  *)connector->probed_modes.next;
#line 1787
        newmode = (struct drm_display_mode *)__mptr;
#line 1787
        goto ldv_42628;
        ldv_42627: ;
#line 1789
        if ((newmode->type & 8U) != 0U) {
#line 1790
          intel_dp->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)newmode);
#line 1792
          goto ldv_42626;
        } else {

        }
#line 1787
        __mptr___0 = (struct list_head  const  *)newmode->head.next;
#line 1787
        newmode = (struct drm_display_mode *)__mptr___0;
        ldv_42628: ;
#line 1787
        if ((unsigned long )(& newmode->head) != (unsigned long )(& connector->probed_modes)) {
#line 1789
          goto ldv_42627;
        } else {

        }
        ldv_42626: ;
      } else {

      }
#line 1797
      return (ret);
    } else {

    }
#line 1799
    if ((unsigned long )intel_dp->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0) && (unsigned long )dev_priv->lfp_lvds_vbt_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 1800
      intel_dp->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)dev_priv->lfp_lvds_vbt_mode);
#line 1802
      if ((unsigned long )intel_dp->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 1803
        (intel_dp->panel_fixed_mode)->type = (intel_dp->panel_fixed_mode)->type | 8U;
      } else {

      }
    } else {

    }
#line 1807
    if ((unsigned long )intel_dp->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 1809
      mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)intel_dp->panel_fixed_mode);
#line 1810
      drm_mode_probed_add(connector, mode);
#line 1811
      return (1);
    } else {

    }
  } else {

  }
#line 1815
  return (ret);
}
}
#line 1819 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static bool cdv_intel_dp_detect_audio(struct drm_connector *connector ) 
{ 
  struct gma_encoder *encoder ;
  struct gma_encoder *tmp ;
  struct cdv_intel_dp *intel_dp ;
  struct edid *edid ;
  bool has_audio ;
  int edp ;
  bool tmp___0 ;

  {
#line 1821
  tmp = gma_attached_encoder(connector);
#line 1821
  encoder = tmp;
#line 1822
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1824
  has_audio = 0;
#line 1825
  tmp___0 = is_edp(encoder);
#line 1825
  edp = (int )tmp___0;
#line 1827
  if (edp != 0) {
#line 1828
    cdv_intel_edp_panel_vdd_on(encoder);
  } else {

  }
#line 1830
  edid = drm_get_edid(connector, & intel_dp->adapter);
#line 1831
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
#line 1832
    has_audio = drm_detect_monitor_audio(edid);
#line 1833
    kfree((void const   *)edid);
  } else {

  }
#line 1835
  if (edp != 0) {
#line 1836
    cdv_intel_edp_panel_vdd_off(encoder);
  } else {

  }
#line 1838
  return (has_audio);
}
}
#line 1842 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static int cdv_intel_dp_set_property(struct drm_connector *connector , struct drm_property *property ,
                                     uint64_t val ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct gma_encoder *encoder ;
  struct gma_encoder *tmp ;
  struct cdv_intel_dp *intel_dp ;
  int ret ;
  int i ;
  bool has_audio ;
  struct drm_crtc *crtc ;

  {
#line 1846
  dev_priv = (struct drm_psb_private *)(connector->dev)->dev_private;
#line 1847
  tmp = gma_attached_encoder(connector);
#line 1847
  encoder = tmp;
#line 1848
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1851
  ret = drm_object_property_set_value(& connector->base, property, val);
#line 1852
  if (ret != 0) {
#line 1853
    return (ret);
  } else {

  }
#line 1855
  if ((unsigned long )dev_priv->force_audio_property == (unsigned long )property) {
#line 1856
    i = (int )val;
#line 1859
    if (intel_dp->force_audio == i) {
#line 1860
      return (0);
    } else {

    }
#line 1862
    intel_dp->force_audio = i;
#line 1864
    if (i == 0) {
#line 1865
      has_audio = cdv_intel_dp_detect_audio(connector);
    } else {
#line 1867
      has_audio = i > 0;
    }
#line 1869
    if ((int )intel_dp->has_audio == (int )has_audio) {
#line 1870
      return (0);
    } else {

    }
#line 1872
    intel_dp->has_audio = has_audio;
#line 1873
    goto done;
  } else {

  }
#line 1876
  if ((unsigned long )dev_priv->broadcast_rgb_property == (unsigned long )property) {
#line 1877
    if ((uint64_t )(intel_dp->color_range != 0U) == val) {
#line 1878
      return (0);
    } else {

    }
#line 1880
    intel_dp->color_range = val != 0ULL ? 256U : 0U;
#line 1881
    goto done;
  } else {

  }
#line 1884
  return (-22);
  done: ;
#line 1887
  if ((unsigned long )encoder->base.crtc != (unsigned long )((struct drm_crtc *)0)) {
#line 1888
    crtc = encoder->base.crtc;
#line 1889
    drm_crtc_helper_set_mode(crtc, & crtc->mode, crtc->x, crtc->y, (crtc->primary)->fb);
  } else {

  }
#line 1894
  return (0);
}
}
#line 1898 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void cdv_intel_dp_destroy(struct drm_connector *connector ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct cdv_intel_dp *intel_dp ;
  bool tmp___0 ;

  {
#line 1900
  tmp = gma_attached_encoder(connector);
#line 1900
  gma_encoder = tmp;
#line 1901
  intel_dp = (struct cdv_intel_dp *)gma_encoder->dev_priv;
#line 1903
  tmp___0 = is_edp(gma_encoder);
#line 1903
  if ((int )tmp___0) {
#line 1905
    if ((unsigned long )intel_dp->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 1906
      kfree((void const   *)intel_dp->panel_fixed_mode);
#line 1907
      intel_dp->panel_fixed_mode = (struct drm_display_mode *)0;
    } else {

    }
  } else {

  }
#line 1910
  i2c_del_adapter(& intel_dp->adapter);
#line 1911
  drm_connector_unregister(connector);
#line 1912
  drm_connector_cleanup(connector);
#line 1913
  kfree((void const   *)connector);
#line 1914
  return;
}
}
#line 1916 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void cdv_intel_dp_encoder_destroy(struct drm_encoder *encoder ) 
{ 


  {
#line 1918
  drm_encoder_cleanup(encoder);
#line 1919
  return;
}
}
#line 1921 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static struct drm_encoder_helper_funcs  const  cdv_intel_dp_helper_funcs  = 
#line 1921
     {& cdv_intel_dp_dpms, 0, 0, & cdv_intel_dp_mode_fixup, & cdv_intel_dp_prepare,
    & cdv_intel_dp_commit, & cdv_intel_dp_mode_set, 0, 0, 0, 0, 0};
#line 1929 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static struct drm_connector_funcs  const  cdv_intel_dp_connector_funcs  = 
#line 1929
     {& drm_helper_connector_dpms, 0, 0, 0, & cdv_intel_dp_detect, & drm_helper_probe_single_connector_modes,
    & cdv_intel_dp_set_property, & cdv_intel_dp_destroy, 0, 0, 0, 0, 0};
#line 1937 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static struct drm_connector_helper_funcs  const  cdv_intel_dp_connector_helper_funcs  =    {& cdv_intel_dp_get_modes,
    (enum drm_mode_status (*)(struct drm_connector * , struct drm_display_mode * ))(& cdv_intel_dp_mode_valid),
    & gma_best_encoder};
#line 1943 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static struct drm_encoder_funcs  const  cdv_intel_dp_enc_funcs  =    {0, & cdv_intel_dp_encoder_destroy};
#line 1948 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void cdv_intel_dp_add_properties(struct drm_connector *connector ) 
{ 


  {
#line 1950
  cdv_intel_attach_force_audio_property(connector);
#line 1951
  cdv_intel_attach_broadcast_rgb_property(connector);
#line 1952
  return;
}
}
#line 1955 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static bool cdv_intel_dpc_is_edp(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct child_device_config *p_child ;
  int i ;

  {
#line 1957
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 1961
  if (dev_priv->child_dev_num == 0) {
#line 1962
    return (0);
  } else {

  }
#line 1964
  i = 0;
#line 1964
  goto ldv_42673;
  ldv_42672: 
#line 1965
  p_child = dev_priv->child_dev + (unsigned long )i;
#line 1967
  if ((unsigned int )p_child->dvo_port == 8U && (unsigned int )p_child->device_type == 30918U) {
#line 1969
    return (1);
  } else {

  }
#line 1964
  i = i + 1;
  ldv_42673: ;
#line 1964
  if (dev_priv->child_dev_num > i) {
#line 1966
    goto ldv_42672;
  } else {

  }

#line 1971
  return (0);
}
}
#line 1979 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
static void cdv_disable_intel_clock_gating(struct drm_device *dev ) 
{ 
  u32 reg_value ;

  {
#line 1982
  reg_value = REGISTER_READ(dev, 25088U);
#line 1984
  reg_value = reg_value | 1124083776U;
#line 1991
  REGISTER_WRITE(dev, 25088U, reg_value);
#line 1993
  __const_udelay(2147500UL);
#line 1995
  return;
}
}
#line 1997 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.c"
void cdv_intel_dp_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ,
                       int output_reg ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_connector *gma_connector ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct cdv_intel_dp *intel_dp ;
  char const   *name ;
  int type ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  bool tmp___2 ;
  int ret ;
  struct edp_power_seq cur ;
  u32 pp_on ;
  u32 pp_off ;
  u32 pp_div ;
  u32 pwm_ctrl ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  bool tmp___7 ;

  {
#line 2004
  name = (char const   *)0;
#line 2005
  type = 10;
#line 2007
  tmp = kzalloc(152UL, 208U);
#line 2007
  gma_encoder = (struct gma_encoder *)tmp;
#line 2008
  if ((unsigned long )gma_encoder == (unsigned long )((struct gma_encoder *)0)) {
#line 2009
    return;
  } else {

  }
#line 2010
  tmp___0 = kzalloc(944UL, 208U);
#line 2010
  gma_connector = (struct gma_connector *)tmp___0;
#line 2011
  if ((unsigned long )gma_connector == (unsigned long )((struct gma_connector *)0)) {
#line 2012
    goto err_connector;
  } else {

  }
#line 2013
  tmp___1 = kzalloc(2048UL, 208U);
#line 2013
  intel_dp = (struct cdv_intel_dp *)tmp___1;
#line 2014
  if ((unsigned long )intel_dp == (unsigned long )((struct cdv_intel_dp *)0)) {
#line 2015
    goto err_priv;
  } else {

  }
#line 2017
  if (output_reg == 410112) {
#line 2017
    tmp___2 = cdv_intel_dpc_is_edp(dev);
#line 2017
    if ((int )tmp___2) {
#line 2018
      type = 14;
    } else {

    }
  } else {

  }
#line 2020
  connector = & gma_connector->base;
#line 2021
  encoder = & gma_encoder->base;
#line 2023
  drm_connector_init(dev, connector, & cdv_intel_dp_connector_funcs, type);
#line 2024
  drm_encoder_init(dev, encoder, & cdv_intel_dp_enc_funcs, 2);
#line 2026
  gma_connector_attach_encoder(gma_connector, gma_encoder);
#line 2028
  if (type == 10) {
#line 2029
    gma_encoder->type = 9;
  } else {
#line 2031
    gma_encoder->type = 10;
  }
#line 2034
  gma_encoder->dev_priv = (void *)intel_dp;
#line 2035
  intel_dp->encoder = gma_encoder;
#line 2036
  intel_dp->output_reg = (uint32_t )output_reg;
#line 2038
  drm_encoder_helper_add(encoder, & cdv_intel_dp_helper_funcs);
#line 2039
  drm_connector_helper_add(connector, & cdv_intel_dp_connector_helper_funcs);
#line 2041
  connector->polled = 1U;
#line 2042
  connector->interlace_allowed = 0;
#line 2043
  connector->doublescan_allowed = 0;
#line 2045
  drm_connector_register(connector);
#line 2048
  switch (output_reg) {
  case 409856: 
#line 2050
  name = "DPDDC-B";
#line 2051
  gma_encoder->ddi_select = 32769U;
#line 2052
  goto ldv_42694;
  case 410112: 
#line 2054
  name = "DPDDC-C";
#line 2055
  gma_encoder->ddi_select = 32770U;
#line 2056
  goto ldv_42694;
  }
  ldv_42694: 
#line 2059
  cdv_disable_intel_clock_gating(dev);
#line 2061
  cdv_intel_dp_i2c_init(gma_connector, gma_encoder, name);
#line 2063
  cdv_intel_dp_add_properties(connector);
#line 2065
  tmp___7 = is_edp(gma_encoder);
#line 2065
  if ((int )tmp___7) {
#line 2071
    pp_on = REGISTER_READ(dev, 397828U);
#line 2072
    pp_on = pp_on & 65535U;
#line 2073
    pp_on = pp_on | 2882338816U;
#line 2075
    REGISTER_WRITE(dev, 397828U, pp_on);
#line 2077
    pwm_ctrl = REGISTER_READ(dev, 397904U);
#line 2078
    pwm_ctrl = pwm_ctrl | 536870912U;
#line 2079
    REGISTER_WRITE(dev, 397904U, pwm_ctrl);
#line 2081
    pp_on = REGISTER_READ(dev, 397832U);
#line 2082
    pp_off = REGISTER_READ(dev, 397836U);
#line 2083
    pp_div = REGISTER_READ(dev, 397840U);
#line 2086
    cur.t1_t3 = (u16 )((pp_on & 536805376U) >> 16);
#line 2089
    cur.t8 = (unsigned int )((u16 )pp_on) & 8191U;
#line 2092
    cur.t9 = (unsigned int )((u16 )pp_off) & 8191U;
#line 2095
    cur.t10 = (u16 )((pp_off & 536805376U) >> 16);
#line 2098
    cur.t11_t12 = (unsigned int )((u16 )pp_div) & 31U;
#line 2101
    tmp___3 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2101
    if (tmp___3 != 0L) {
#line 2101
      drm_ut_debug_printk("cdv_intel_dp_init", "cur t1_t3 %d t8 %d t9 %d t10 %d t11_t12 %d\n",
                          (int )cur.t1_t3, (int )cur.t8, (int )cur.t9, (int )cur.t10,
                          (int )cur.t11_t12);
    } else {

    }
#line 2105
    intel_dp->panel_power_up_delay = (int )((unsigned int )cur.t1_t3 / 10U);
#line 2106
    intel_dp->backlight_on_delay = (int )((unsigned int )cur.t8 / 10U);
#line 2107
    intel_dp->backlight_off_delay = (int )((unsigned int )cur.t9 / 10U);
#line 2108
    intel_dp->panel_power_down_delay = (int )((unsigned int )cur.t10 / 10U);
#line 2109
    intel_dp->panel_power_cycle_delay = ((int )cur.t11_t12 + -1) * 100;
#line 2111
    tmp___4 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2111
    if (tmp___4 != 0L) {
#line 2111
      drm_ut_debug_printk("cdv_intel_dp_init", "panel power up delay %d, power down delay %d, power cycle delay %d\n",
                          intel_dp->panel_power_up_delay, intel_dp->panel_power_down_delay,
                          intel_dp->panel_power_cycle_delay);
    } else {

    }
#line 2115
    tmp___5 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2115
    if (tmp___5 != 0L) {
#line 2115
      drm_ut_debug_printk("cdv_intel_dp_init", "backlight on delay %d, off delay %d\n",
                          intel_dp->backlight_on_delay, intel_dp->backlight_off_delay);
    } else {

    }
#line 2119
    cdv_intel_edp_panel_vdd_on(gma_encoder);
#line 2120
    ret = cdv_intel_dp_aux_native_read(gma_encoder, 0, (uint8_t *)(& intel_dp->dpcd),
                                       4);
#line 2123
    cdv_intel_edp_panel_vdd_off(gma_encoder);
#line 2124
    if (ret == 0) {
#line 2126
      printk("\016[drm] failed to retrieve link info, disabling eDP\n");
#line 2127
      cdv_intel_dp_encoder_destroy(encoder);
#line 2128
      cdv_intel_dp_destroy(connector);
#line 2129
      goto err_priv;
    } else {
#line 2131
      tmp___6 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2131
      if (tmp___6 != 0L) {
#line 2131
        drm_ut_debug_printk("cdv_intel_dp_init", "DPCD: Rev=%x LN_Rate=%x LN_CNT=%x LN_DOWNSP=%x\n",
                            (int )intel_dp->dpcd[0], (int )intel_dp->dpcd[1], (int )intel_dp->dpcd[2],
                            (int )intel_dp->dpcd[3]);
      } else {

      }
    }
  } else {

  }
#line 2141
  return;
  err_priv: 
#line 2144
  kfree((void const   *)gma_connector);
  err_connector: 
#line 2146
  kfree((void const   *)gma_encoder);
#line 2147
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
extern int ldv_probe_16(void) ;
#line 405
extern int ldv_probe_14(void) ;
#line 408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_initialize_i2c_algorithm_18(void) 
{ 
  void *tmp ;

  {
#line 409
  tmp = ldv_init_zalloc(1936UL);
#line 409
  i2c_dp_aux_algo_group0 = (struct i2c_adapter *)tmp;
#line 410
  return;
}
}
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_initialize_drm_encoder_helper_funcs_17(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 413
  tmp = ldv_init_zalloc(96UL);
#line 413
  cdv_intel_dp_helper_funcs_group0 = (struct drm_encoder *)tmp;
#line 414
  tmp___0 = ldv_init_zalloc(208UL);
#line 414
  cdv_intel_dp_helper_funcs_group1 = (struct drm_display_mode *)tmp___0;
#line 415
  return;
}
}
#line 417 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_initialize_drm_connector_funcs_16(void) 
{ 
  void *tmp ;

  {
#line 418
  tmp = ldv_init_zalloc(936UL);
#line 418
  cdv_intel_dp_connector_funcs_group0 = (struct drm_connector *)tmp;
#line 419
  return;
}
}
#line 421 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_initialize_drm_connector_helper_funcs_15(void) 
{ 
  void *tmp ;

  {
#line 422
  tmp = ldv_init_zalloc(936UL);
#line 422
  cdv_intel_dp_connector_helper_funcs_group0 = (struct drm_connector *)tmp;
#line 423
  return;
}
}
#line 425 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_main_exported_18(void) 
{ 
  int ldvarg16 ;
  struct i2c_msg *ldvarg17 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 427
  tmp = ldv_init_zalloc(16UL);
#line 427
  ldvarg17 = (struct i2c_msg *)tmp;
#line 426
  ldv_memset((void *)(& ldvarg16), 0, 4UL);
#line 429
  tmp___0 = __VERIFIER_nondet_int();
#line 429
  switch (tmp___0) {
  case 0: ;
#line 432
  if (ldv_state_variable_18 == 1) {
#line 434
    i2c_algo_dp_aux_xfer(i2c_dp_aux_algo_group0, ldvarg17, ldvarg16);
#line 436
    ldv_state_variable_18 = 1;
  } else {

  }
#line 439
  goto ldv_42725;
  case 1: ;
#line 442
  if (ldv_state_variable_18 == 1) {
#line 444
    i2c_algo_dp_aux_functionality(i2c_dp_aux_algo_group0);
#line 446
    ldv_state_variable_18 = 1;
  } else {

  }
#line 449
  goto ldv_42725;
  default: 
#line 450
  ldv_stop();
  }
  ldv_42725: ;
#line 454
  return;
}
}
#line 456 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_main_exported_16(void) 
{ 
  uint32_t ldvarg19 ;
  struct drm_property *ldvarg22 ;
  void *tmp ;
  bool ldvarg23 ;
  uint32_t ldvarg20 ;
  uint64_t ldvarg21 ;
  int ldvarg24 ;
  int tmp___0 ;

  {
#line 458
  tmp = ldv_init_zalloc(104UL);
#line 458
  ldvarg22 = (struct drm_property *)tmp;
#line 457
  ldv_memset((void *)(& ldvarg19), 0, 4UL);
#line 459
  ldv_memset((void *)(& ldvarg23), 0, 1UL);
#line 460
  ldv_memset((void *)(& ldvarg20), 0, 4UL);
#line 461
  ldv_memset((void *)(& ldvarg21), 0, 8UL);
#line 462
  ldv_memset((void *)(& ldvarg24), 0, 4UL);
#line 464
  tmp___0 = __VERIFIER_nondet_int();
#line 464
  switch (tmp___0) {
  case 0: ;
#line 467
  if (ldv_state_variable_16 == 1) {
#line 469
    drm_helper_connector_dpms(cdv_intel_dp_connector_funcs_group0, ldvarg24);
#line 471
    ldv_state_variable_16 = 1;
  } else {

  }
#line 474
  if (ldv_state_variable_16 == 2) {
#line 476
    drm_helper_connector_dpms(cdv_intel_dp_connector_funcs_group0, ldvarg24);
#line 478
    ldv_state_variable_16 = 2;
  } else {

  }
#line 481
  goto ldv_42738;
  case 1: ;
#line 484
  if (ldv_state_variable_16 == 1) {
#line 486
    cdv_intel_dp_detect(cdv_intel_dp_connector_funcs_group0, (int )ldvarg23);
#line 488
    ldv_state_variable_16 = 1;
  } else {

  }
#line 491
  if (ldv_state_variable_16 == 2) {
#line 493
    cdv_intel_dp_detect(cdv_intel_dp_connector_funcs_group0, (int )ldvarg23);
#line 495
    ldv_state_variable_16 = 2;
  } else {

  }
#line 498
  goto ldv_42738;
  case 2: ;
#line 501
  if (ldv_state_variable_16 == 1) {
#line 503
    cdv_intel_dp_set_property(cdv_intel_dp_connector_funcs_group0, ldvarg22, ldvarg21);
#line 505
    ldv_state_variable_16 = 1;
  } else {

  }
#line 508
  if (ldv_state_variable_16 == 2) {
#line 510
    cdv_intel_dp_set_property(cdv_intel_dp_connector_funcs_group0, ldvarg22, ldvarg21);
#line 512
    ldv_state_variable_16 = 2;
  } else {

  }
#line 515
  goto ldv_42738;
  case 3: ;
#line 518
  if (ldv_state_variable_16 == 2) {
#line 520
    cdv_intel_dp_destroy(cdv_intel_dp_connector_funcs_group0);
#line 522
    ldv_state_variable_16 = 1;
#line 523
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 526
  goto ldv_42738;
  case 4: ;
#line 529
  if (ldv_state_variable_16 == 1) {
#line 531
    drm_helper_probe_single_connector_modes(cdv_intel_dp_connector_funcs_group0, ldvarg20,
                                            ldvarg19);
#line 533
    ldv_state_variable_16 = 1;
  } else {

  }
#line 536
  if (ldv_state_variable_16 == 2) {
#line 538
    drm_helper_probe_single_connector_modes(cdv_intel_dp_connector_funcs_group0, ldvarg20,
                                            ldvarg19);
#line 540
    ldv_state_variable_16 = 2;
  } else {

  }
#line 543
  goto ldv_42738;
  case 5: ;
#line 546
  if (ldv_state_variable_16 == 1) {
#line 548
    ldv_probe_16();
#line 550
    ldv_state_variable_16 = 2;
#line 551
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 554
  goto ldv_42738;
  default: 
#line 555
  ldv_stop();
  }
  ldv_42738: ;
#line 559
  return;
}
}
#line 561 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_main_exported_17(void) 
{ 
  int ldvarg15 ;
  struct drm_display_mode *ldvarg13 ;
  void *tmp ;
  struct drm_display_mode *ldvarg14 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 563
  tmp = ldv_init_zalloc(208UL);
#line 563
  ldvarg13 = (struct drm_display_mode *)tmp;
#line 564
  tmp___0 = ldv_init_zalloc(208UL);
#line 564
  ldvarg14 = (struct drm_display_mode *)tmp___0;
#line 562
  ldv_memset((void *)(& ldvarg15), 0, 4UL);
#line 566
  tmp___1 = __VERIFIER_nondet_int();
#line 566
  switch (tmp___1) {
  case 0: ;
#line 569
  if (ldv_state_variable_17 == 1) {
#line 571
    cdv_intel_dp_dpms(cdv_intel_dp_helper_funcs_group0, ldvarg15);
#line 573
    ldv_state_variable_17 = 1;
  } else {

  }
#line 576
  goto ldv_42752;
  case 1: ;
#line 579
  if (ldv_state_variable_17 == 1) {
#line 581
    cdv_intel_dp_mode_fixup(cdv_intel_dp_helper_funcs_group0, (struct drm_display_mode  const  *)ldvarg14,
                            cdv_intel_dp_helper_funcs_group1);
#line 583
    ldv_state_variable_17 = 1;
  } else {

  }
#line 586
  goto ldv_42752;
  case 2: ;
#line 589
  if (ldv_state_variable_17 == 1) {
#line 591
    cdv_intel_dp_commit(cdv_intel_dp_helper_funcs_group0);
#line 593
    ldv_state_variable_17 = 1;
  } else {

  }
#line 596
  goto ldv_42752;
  case 3: ;
#line 599
  if (ldv_state_variable_17 == 1) {
#line 601
    cdv_intel_dp_mode_set(cdv_intel_dp_helper_funcs_group0, cdv_intel_dp_helper_funcs_group1,
                          ldvarg13);
#line 603
    ldv_state_variable_17 = 1;
  } else {

  }
#line 606
  goto ldv_42752;
  case 4: ;
#line 609
  if (ldv_state_variable_17 == 1) {
#line 611
    cdv_intel_dp_prepare(cdv_intel_dp_helper_funcs_group0);
#line 613
    ldv_state_variable_17 = 1;
  } else {

  }
#line 616
  goto ldv_42752;
  default: 
#line 617
  ldv_stop();
  }
  ldv_42752: ;
#line 621
  return;
}
}
#line 623 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_main_exported_15(void) 
{ 
  struct drm_display_mode *ldvarg187 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 624
  tmp = ldv_init_zalloc(208UL);
#line 624
  ldvarg187 = (struct drm_display_mode *)tmp;
#line 626
  tmp___0 = __VERIFIER_nondet_int();
#line 626
  switch (tmp___0) {
  case 0: ;
#line 629
  if (ldv_state_variable_15 == 1) {
#line 631
    cdv_intel_dp_get_modes(cdv_intel_dp_connector_helper_funcs_group0);
#line 633
    ldv_state_variable_15 = 1;
  } else {

  }
#line 636
  goto ldv_42763;
  case 1: ;
#line 639
  if (ldv_state_variable_15 == 1) {
#line 641
    cdv_intel_dp_mode_valid(cdv_intel_dp_connector_helper_funcs_group0, ldvarg187);
#line 643
    ldv_state_variable_15 = 1;
  } else {

  }
#line 646
  goto ldv_42763;
  case 2: ;
#line 649
  if (ldv_state_variable_15 == 1) {
#line 651
    gma_best_encoder(cdv_intel_dp_connector_helper_funcs_group0);
#line 653
    ldv_state_variable_15 = 1;
  } else {

  }
#line 656
  goto ldv_42763;
  default: 
#line 657
  ldv_stop();
  }
  ldv_42763: ;
#line 661
  return;
}
}
#line 663 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_main_exported_14(void) 
{ 
  struct drm_encoder *ldvarg81 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 664
  tmp = ldv_init_zalloc(96UL);
#line 664
  ldvarg81 = (struct drm_encoder *)tmp;
#line 666
  tmp___0 = __VERIFIER_nondet_int();
#line 666
  switch (tmp___0) {
  case 0: ;
#line 669
  if (ldv_state_variable_14 == 2) {
#line 671
    cdv_intel_dp_encoder_destroy(ldvarg81);
#line 673
    ldv_state_variable_14 = 1;
#line 674
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 677
  goto ldv_42772;
  case 1: ;
#line 680
  if (ldv_state_variable_14 == 1) {
#line 682
    ldv_probe_14();
#line 684
    ldv_state_variable_14 = 2;
#line 685
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 688
  goto ldv_42772;
  default: 
#line 689
  ldv_stop();
  }
  ldv_42772: ;
#line 693
  return;
}
}
#line 718 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
bool ldv_queue_work_on_1328(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 722
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 722
  ldv_func_res = tmp;
#line 724
  activate_work_2(ldv_func_arg3, 2);
#line 726
  return (ldv_func_res);
}
}
#line 729 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
bool ldv_queue_delayed_work_on_1329(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 733
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 733
  ldv_func_res = tmp;
#line 735
  activate_work_2(& ldv_func_arg3->work, 2);
#line 737
  return (ldv_func_res);
}
}
#line 740 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
bool ldv_queue_work_on_1330(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 744
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 744
  ldv_func_res = tmp;
#line 746
  activate_work_2(ldv_func_arg3, 2);
#line 748
  return (ldv_func_res);
}
}
#line 751 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_flush_workqueue_1331(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 754
  flush_workqueue(ldv_func_arg1);
#line 756
  call_and_disable_all_2(2);
#line 757
  return;
}
}
#line 759 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
bool ldv_queue_delayed_work_on_1332(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 763
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 763
  ldv_func_res = tmp;
#line 765
  activate_work_2(& ldv_func_arg3->work, 2);
#line 767
  return (ldv_func_res);
}
}
#line 770 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_mutex_lock_1333(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 773
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 775
  mutex_lock(ldv_func_arg1);
#line 776
  return;
}
}
#line 778 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_mutex_unlock_1334(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 781
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 783
  mutex_unlock(ldv_func_arg1);
#line 784
  return;
}
}
#line 786 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_mutex_lock_1335(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 789
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 791
  mutex_lock(ldv_func_arg1);
#line 792
  return;
}
}
#line 794 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
int ldv_mutex_trylock_1336(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 798
  tmp = mutex_trylock(ldv_func_arg1);
#line 798
  ldv_func_res = tmp;
#line 800
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 800
  return (tmp___0);
#line 802
  return (ldv_func_res);
}
}
#line 805 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_mutex_unlock_1337(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 808
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 810
  mutex_unlock(ldv_func_arg1);
#line 811
  return;
}
}
#line 813 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_mutex_unlock_1338(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 816
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 818
  mutex_unlock(ldv_func_arg1);
#line 819
  return;
}
}
#line 821 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_mutex_lock_1339(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 824
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 826
  mutex_lock(ldv_func_arg1);
#line 827
  return;
}
}
#line 829 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_mutex_lock_1340(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 832
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 834
  mutex_lock(ldv_func_arg1);
#line 835
  return;
}
}
#line 837 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_mutex_unlock_1341(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 840
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 842
  mutex_unlock(ldv_func_arg1);
#line 843
  return;
}
}
#line 845 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_mutex_unlock_1342(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 848
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 850
  mutex_unlock(ldv_func_arg1);
#line 851
  return;
}
}
#line 853 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_mutex_lock_1343(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 856
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 858
  mutex_lock(ldv_func_arg1);
#line 859
  return;
}
}
#line 861 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
int ldv_mutex_lock_interruptible_1344(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 865
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 865
  ldv_func_res = tmp;
#line 867
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 867
  return (tmp___0);
#line 869
  return (ldv_func_res);
}
}
#line 872 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
int ldv_mutex_trylock_1345(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 876
  tmp = mutex_trylock(ldv_func_arg1);
#line 876
  ldv_func_res = tmp;
#line 878
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 878
  return (tmp___0);
#line 880
  return (ldv_func_res);
}
}
#line 904 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_mutex_unlock_1348(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 907
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 909
  mutex_unlock(ldv_func_arg1);
#line 910
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_1381(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_1390(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_1379(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_1382(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_1383(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_1385(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_1387(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_1393(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
int ldv_mutex_lock_interruptible_1389(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_1378(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_1380(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_1384(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_1386(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_1388(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_1373(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_1375(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_1374(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_1377(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_1376(struct workqueue_struct *ldv_func_arg1 ) ;
#line 221 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
void oaktrail_lvds_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) ;
#line 245 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/oaktrail.h"
void oaktrail_hdmi_setup(struct drm_device *dev ) ;
#line 246
void oaktrail_hdmi_teardown(struct drm_device *dev ) ;
#line 249
void oaktrail_hdmi_save(struct drm_device *dev ) ;
#line 250
void oaktrail_hdmi_restore(struct drm_device *dev ) ;
#line 251
void oaktrail_hdmi_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) ;
#line 728 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct drm_crtc_helper_funcs  const  oaktrail_helper_funcs ;
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.c"
static int oaktrail_output_init(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 36
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 37
  if (dev_priv->iLVDS_enable != 0U) {
#line 38
    oaktrail_lvds_init(dev, & dev_priv->mode_dev);
  } else {
#line 40
    dev_err((struct device  const  *)dev->dev, "DSI is not supported\n");
  }
#line 41
  if ((unsigned long )dev_priv->hdmi_priv != (unsigned long )((struct oaktrail_hdmi_dev *)0)) {
#line 42
    oaktrail_hdmi_init(dev, & dev_priv->mode_dev);
  } else {

  }
#line 44
  psb_intel_sdvo_init(dev, 397632);
#line 46
  return (0);
}
}
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.c"
static int oaktrail_save_display_registers(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_save_area *regs ;
  struct psb_pipe *p ;
  int i ;
  u32 pp_stat ;

  {
#line 191
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 192
  regs = & dev_priv->regs;
#line 193
  p = (struct psb_pipe *)(& regs->pipe);
#line 198
  regs->__annonCompField80.psb.saveDSPARB = ioread32((void *)dev_priv->vdc_reg + 458800U);
#line 199
  regs->__annonCompField80.psb.saveDSPFW1 = ioread32((void *)dev_priv->vdc_reg + 458804U);
#line 200
  regs->__annonCompField80.psb.saveDSPFW2 = ioread32((void *)dev_priv->vdc_reg + 458808U);
#line 201
  regs->__annonCompField80.psb.saveDSPFW3 = ioread32((void *)dev_priv->vdc_reg + 458812U);
#line 202
  regs->__annonCompField80.psb.saveDSPFW4 = ioread32((void *)dev_priv->vdc_reg + 458832U);
#line 203
  regs->__annonCompField80.psb.saveDSPFW5 = ioread32((void *)dev_priv->vdc_reg + 458836U);
#line 204
  regs->__annonCompField80.psb.saveDSPFW6 = ioread32((void *)dev_priv->vdc_reg + 458840U);
#line 205
  regs->__annonCompField80.psb.saveCHICKENBIT = ioread32((void *)dev_priv->vdc_reg + 459776U);
#line 208
  p->conf = ioread32((void *)dev_priv->vdc_reg + 458760U);
#line 209
  p->src = ioread32((void *)dev_priv->vdc_reg + 393244U);
#line 210
  p->fp0 = ioread32((void *)dev_priv->vdc_reg + 61504U);
#line 211
  p->fp1 = ioread32((void *)dev_priv->vdc_reg + 61508U);
#line 212
  p->dpll = ioread32((void *)dev_priv->vdc_reg + 61460U);
#line 213
  p->htotal = ioread32((void *)dev_priv->vdc_reg + 393216U);
#line 214
  p->hblank = ioread32((void *)dev_priv->vdc_reg + 393220U);
#line 215
  p->hsync = ioread32((void *)dev_priv->vdc_reg + 393224U);
#line 216
  p->vtotal = ioread32((void *)dev_priv->vdc_reg + 393228U);
#line 217
  p->vblank = ioread32((void *)dev_priv->vdc_reg + 393232U);
#line 218
  p->vsync = ioread32((void *)dev_priv->vdc_reg + 393236U);
#line 219
  regs->__annonCompField80.psb.saveBCLRPAT_A = ioread32((void *)dev_priv->vdc_reg + 393248U);
#line 220
  p->cntr = ioread32((void *)dev_priv->vdc_reg + 459136U);
#line 221
  p->stride = ioread32((void *)dev_priv->vdc_reg + 459144U);
#line 222
  p->addr = ioread32((void *)dev_priv->vdc_reg + 459140U);
#line 223
  p->surf = ioread32((void *)dev_priv->vdc_reg + 459164U);
#line 224
  p->linoff = ioread32((void *)dev_priv->vdc_reg + 459140U);
#line 225
  p->tileoff = ioread32((void *)dev_priv->vdc_reg + 459172U);
#line 228
  regs->__annonCompField80.psb.saveDSPACURSOR_CTRL = ioread32((void *)dev_priv->vdc_reg + 458880U);
#line 229
  regs->__annonCompField80.psb.saveDSPACURSOR_BASE = ioread32((void *)dev_priv->vdc_reg + 458884U);
#line 230
  regs->__annonCompField80.psb.saveDSPACURSOR_POS = ioread32((void *)dev_priv->vdc_reg + 458888U);
#line 233
  i = 0;
#line 233
  goto ldv_42184;
  ldv_42183: 
#line 234
  p->palette[i] = ioread32((void *)dev_priv->vdc_reg + (unsigned long )((i << 2) + 40960));
#line 233
  i = i + 1;
  ldv_42184: ;
#line 233
  if (i <= 255) {
#line 235
    goto ldv_42183;
  } else {

  }

#line 236
  if ((unsigned long )dev_priv->hdmi_priv != (unsigned long )((struct oaktrail_hdmi_dev *)0)) {
#line 237
    oaktrail_hdmi_save(dev);
  } else {

  }
#line 240
  regs->__annonCompField80.psb.savePERF_MODE = ioread32((void *)dev_priv->vdc_reg + 8436U);
#line 243
  regs->__annonCompField80.psb.savePP_CONTROL = ioread32((void *)dev_priv->vdc_reg + 397828U);
#line 244
  regs->__annonCompField80.psb.savePFIT_PGM_RATIOS = ioread32((void *)dev_priv->vdc_reg + 397876U);
#line 245
  regs->__annonCompField80.psb.savePFIT_AUTO_RATIOS = ioread32((void *)dev_priv->vdc_reg + 397880U);
#line 246
  regs->saveBLC_PWM_CTL = ioread32((void *)dev_priv->vdc_reg + 397908U);
#line 247
  regs->saveBLC_PWM_CTL2 = ioread32((void *)dev_priv->vdc_reg + 397904U);
#line 248
  regs->__annonCompField80.psb.saveLVDS = ioread32((void *)dev_priv->vdc_reg + 397696U);
#line 249
  regs->__annonCompField80.psb.savePFIT_CONTROL = ioread32((void *)dev_priv->vdc_reg + 397872U);
#line 250
  regs->__annonCompField80.psb.savePP_ON_DELAYS = ioread32((void *)dev_priv->vdc_reg + 397832U);
#line 251
  regs->__annonCompField80.psb.savePP_OFF_DELAYS = ioread32((void *)dev_priv->vdc_reg + 397836U);
#line 252
  regs->__annonCompField80.psb.savePP_DIVISOR = ioread32((void *)dev_priv->vdc_reg + 397840U);
#line 255
  regs->__annonCompField80.psb.saveOV_OVADD = ioread32((void *)dev_priv->vdc_reg + 196608U);
#line 256
  regs->__annonCompField80.psb.saveOV_OGAMC0 = ioread32((void *)dev_priv->vdc_reg + 196644U);
#line 257
  regs->__annonCompField80.psb.saveOV_OGAMC1 = ioread32((void *)dev_priv->vdc_reg + 196640U);
#line 258
  regs->__annonCompField80.psb.saveOV_OGAMC2 = ioread32((void *)dev_priv->vdc_reg + 196636U);
#line 259
  regs->__annonCompField80.psb.saveOV_OGAMC3 = ioread32((void *)dev_priv->vdc_reg + 196632U);
#line 260
  regs->__annonCompField80.psb.saveOV_OGAMC4 = ioread32((void *)dev_priv->vdc_reg + 196628U);
#line 261
  regs->__annonCompField80.psb.saveOV_OGAMC5 = ioread32((void *)dev_priv->vdc_reg + 196624U);
#line 264
  regs->__annonCompField80.psb.saveHISTOGRAM_INT_CONTROL_REG = ioread32((void *)dev_priv->vdc_reg + 397928U);
#line 266
  regs->__annonCompField80.psb.saveHISTOGRAM_LOGIC_CONTROL_REG = ioread32((void *)dev_priv->vdc_reg + 397920U);
#line 268
  regs->__annonCompField80.psb.savePWM_CONTROL_LOGIC = ioread32((void *)dev_priv->vdc_reg + 397904U);
#line 270
  if (dev_priv->iLVDS_enable != 0U) {
#line 272
    iowrite32(0U, (void *)dev_priv->vdc_reg + 397828U);
    ldv_42186: 
#line 275
    pp_stat = ioread32((void *)dev_priv->vdc_reg + 397824U);
#line 276
    if ((int )pp_stat < 0) {
#line 278
      goto ldv_42186;
    } else {

    }
#line 279
    iowrite32(1476395008U, (void *)dev_priv->vdc_reg + 459136U);
#line 281
    iowrite32(0U, (void *)dev_priv->vdc_reg + 459164U);
#line 284
    msleep(4U);
#line 287
    iowrite32(0U, (void *)dev_priv->vdc_reg + 458760U);
#line 289
    msleep(8U);
#line 292
    iowrite32(0U, (void *)dev_priv->vdc_reg + 61460U);
  } else {

  }
#line 294
  return (0);
}
}
#line 303 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.c"
static int oaktrail_restore_display_registers(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_save_area *regs ;
  struct psb_pipe *p ;
  u32 pp_stat ;
  int i ;

  {
#line 305
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 306
  regs = & dev_priv->regs;
#line 307
  p = (struct psb_pipe *)(& regs->pipe);
#line 312
  iowrite32(regs->__annonCompField80.psb.saveDSPARB, (void *)dev_priv->vdc_reg + 458800U);
#line 313
  iowrite32(regs->__annonCompField80.psb.saveDSPFW1, (void *)dev_priv->vdc_reg + 458804U);
#line 314
  iowrite32(regs->__annonCompField80.psb.saveDSPFW2, (void *)dev_priv->vdc_reg + 458808U);
#line 315
  iowrite32(regs->__annonCompField80.psb.saveDSPFW3, (void *)dev_priv->vdc_reg + 458812U);
#line 316
  iowrite32(regs->__annonCompField80.psb.saveDSPFW4, (void *)dev_priv->vdc_reg + 458832U);
#line 317
  iowrite32(regs->__annonCompField80.psb.saveDSPFW5, (void *)dev_priv->vdc_reg + 458836U);
#line 318
  iowrite32(regs->__annonCompField80.psb.saveDSPFW6, (void *)dev_priv->vdc_reg + 458840U);
#line 319
  iowrite32(regs->__annonCompField80.psb.saveCHICKENBIT, (void *)dev_priv->vdc_reg + 459776U);
#line 322
  iowrite32(2147483648U, (void *)dev_priv->vdc_reg + 463872U);
#line 325
  iowrite32(p->fp0, (void *)dev_priv->vdc_reg + 61504U);
#line 326
  iowrite32(p->fp1, (void *)dev_priv->vdc_reg + 61508U);
#line 329
  iowrite32(p->dpll, (void *)dev_priv->vdc_reg + 61460U);
#line 330
  __const_udelay(644250UL);
#line 333
  iowrite32(p->htotal, (void *)dev_priv->vdc_reg + 393216U);
#line 334
  iowrite32(p->hblank, (void *)dev_priv->vdc_reg + 393220U);
#line 335
  iowrite32(p->hsync, (void *)dev_priv->vdc_reg + 393224U);
#line 336
  iowrite32(p->vtotal, (void *)dev_priv->vdc_reg + 393228U);
#line 337
  iowrite32(p->vblank, (void *)dev_priv->vdc_reg + 393232U);
#line 338
  iowrite32(p->vsync, (void *)dev_priv->vdc_reg + 393236U);
#line 339
  iowrite32(p->src, (void *)dev_priv->vdc_reg + 393244U);
#line 340
  iowrite32(regs->__annonCompField80.psb.saveBCLRPAT_A, (void *)dev_priv->vdc_reg + 393248U);
#line 343
  iowrite32(regs->__annonCompField80.psb.savePERF_MODE, (void *)dev_priv->vdc_reg + 8436U);
#line 346
  if (dev_priv->iLVDS_enable != 0U) {
#line 347
    iowrite32(p->conf, (void *)dev_priv->vdc_reg + 458760U);
  } else {

  }
#line 350
  iowrite32(p->linoff, (void *)dev_priv->vdc_reg + 459140U);
#line 351
  iowrite32(p->stride, (void *)dev_priv->vdc_reg + 459144U);
#line 352
  iowrite32(p->tileoff, (void *)dev_priv->vdc_reg + 459172U);
#line 355
  iowrite32(p->cntr, (void *)dev_priv->vdc_reg + 459136U);
#line 356
  iowrite32(p->surf, (void *)dev_priv->vdc_reg + 459164U);
#line 359
  iowrite32(regs->__annonCompField80.psb.saveDSPACURSOR_CTRL, (void *)dev_priv->vdc_reg + 458880U);
#line 360
  iowrite32(regs->__annonCompField80.psb.saveDSPACURSOR_POS, (void *)dev_priv->vdc_reg + 458888U);
#line 361
  iowrite32(regs->__annonCompField80.psb.saveDSPACURSOR_BASE, (void *)dev_priv->vdc_reg + 458884U);
#line 364
  i = 0;
#line 364
  goto ldv_42197;
  ldv_42196: 
#line 365
  iowrite32(p->palette[i], (void *)dev_priv->vdc_reg + (unsigned long )((i << 2) + 40960));
#line 364
  i = i + 1;
  ldv_42197: ;
#line 364
  if (i <= 255) {
#line 366
    goto ldv_42196;
  } else {

  }

#line 367
  if ((unsigned long )dev_priv->hdmi_priv != (unsigned long )((struct oaktrail_hdmi_dev *)0)) {
#line 368
    oaktrail_hdmi_restore(dev);
  } else {

  }
#line 370
  if (dev_priv->iLVDS_enable != 0U) {
#line 371
    iowrite32(regs->saveBLC_PWM_CTL2, (void *)dev_priv->vdc_reg + 397904U);
#line 372
    iowrite32(regs->__annonCompField80.psb.saveLVDS, (void *)dev_priv->vdc_reg + 397696U);
#line 373
    iowrite32(regs->__annonCompField80.psb.savePFIT_CONTROL, (void *)dev_priv->vdc_reg + 397872U);
#line 374
    iowrite32(regs->__annonCompField80.psb.savePFIT_PGM_RATIOS, (void *)dev_priv->vdc_reg + 397876U);
#line 375
    iowrite32(regs->__annonCompField80.psb.savePFIT_AUTO_RATIOS, (void *)dev_priv->vdc_reg + 397880U);
#line 376
    iowrite32(regs->saveBLC_PWM_CTL, (void *)dev_priv->vdc_reg + 397908U);
#line 377
    iowrite32(regs->__annonCompField80.psb.savePP_ON_DELAYS, (void *)dev_priv->vdc_reg + 397832U);
#line 378
    iowrite32(regs->__annonCompField80.psb.savePP_OFF_DELAYS, (void *)dev_priv->vdc_reg + 397836U);
#line 379
    iowrite32(regs->__annonCompField80.psb.savePP_DIVISOR, (void *)dev_priv->vdc_reg + 397840U);
#line 380
    iowrite32(regs->__annonCompField80.psb.savePP_CONTROL, (void *)dev_priv->vdc_reg + 397828U);
  } else {

  }
  ldv_42199: 
#line 385
  pp_stat = ioread32((void *)dev_priv->vdc_reg + 397824U);
#line 386
  if ((pp_stat & 134217728U) != 0U) {
#line 388
    goto ldv_42199;
  } else {

  }

  ldv_42201: 
#line 390
  pp_stat = ioread32((void *)dev_priv->vdc_reg + 397824U);
#line 391
  if ((pp_stat & 268435456U) != 0U) {
#line 393
    goto ldv_42201;
  } else {

  }
#line 394
  iowrite32(regs->__annonCompField80.psb.saveOV_OVADD, (void *)dev_priv->vdc_reg + 196608U);
#line 395
  iowrite32(regs->__annonCompField80.psb.saveOV_OGAMC0, (void *)dev_priv->vdc_reg + 196644U);
#line 396
  iowrite32(regs->__annonCompField80.psb.saveOV_OGAMC1, (void *)dev_priv->vdc_reg + 196640U);
#line 397
  iowrite32(regs->__annonCompField80.psb.saveOV_OGAMC2, (void *)dev_priv->vdc_reg + 196636U);
#line 398
  iowrite32(regs->__annonCompField80.psb.saveOV_OGAMC3, (void *)dev_priv->vdc_reg + 196632U);
#line 399
  iowrite32(regs->__annonCompField80.psb.saveOV_OGAMC4, (void *)dev_priv->vdc_reg + 196628U);
#line 400
  iowrite32(regs->__annonCompField80.psb.saveOV_OGAMC5, (void *)dev_priv->vdc_reg + 196624U);
#line 403
  iowrite32(regs->__annonCompField80.psb.saveHISTOGRAM_INT_CONTROL_REG, (void *)dev_priv->vdc_reg + 397928U);
#line 405
  iowrite32(regs->__annonCompField80.psb.saveHISTOGRAM_LOGIC_CONTROL_REG, (void *)dev_priv->vdc_reg + 397920U);
#line 407
  iowrite32(regs->__annonCompField80.psb.savePWM_CONTROL_LOGIC, (void *)dev_priv->vdc_reg + 397904U);
#line 409
  return (0);
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.c"
static int oaktrail_power_down(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 pwr_mask ;
  u32 pwr_sts ;

  {
#line 420
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 424
  pwr_mask = 12U;
#line 425
  outl(pwr_mask, (int )(dev_priv->ospm_base + 32U));
  ldv_42210: 
#line 428
  pwr_sts = inl((int )(dev_priv->ospm_base + 48U));
#line 429
  if ((pwr_sts & pwr_mask) == pwr_mask) {
#line 430
    goto ldv_42209;
  } else {
#line 432
    __const_udelay(42950UL);
  }
#line 433
  goto ldv_42210;
  ldv_42209: ;
#line 434
  return (0);
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.c"
static int oaktrail_power_up(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 pwr_mask ;
  u32 pwr_sts ;
  u32 pwr_cnt ;

  {
#line 444
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 445
  pwr_mask = 12U;
#line 448
  pwr_cnt = inl((int )(dev_priv->ospm_base + 32U));
#line 449
  pwr_cnt = ~ pwr_mask & pwr_cnt;
#line 450
  outl(pwr_cnt, (int )(dev_priv->ospm_base + 32U));
  ldv_42219: 
#line 453
  pwr_sts = inl((int )(dev_priv->ospm_base + 48U));
#line 454
  if ((pwr_sts & pwr_mask) == 0U) {
#line 455
    goto ldv_42218;
  } else {
#line 457
    __const_udelay(42950UL);
  }
#line 458
  goto ldv_42219;
  ldv_42218: ;
#line 459
  return (0);
}
}
#line 463 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.c"
static struct psb_offset  const  oaktrail_regmap[2U]  = {      {61504U, 61508U, 459136U, 458760U, 393244U, 61460U, 0U, 393216U, 393220U, 393224U,
      393228U, 393232U, 393236U, 459144U, 459152U, 459148U, 459164U, 459164U, 459164U,
      458788U, 459140U, 459172U, 40960U}, 
        {24648U, 24652U, 463232U, 462856U, 397340U, 24600U, 0U, 397312U, 397316U, 397320U,
      397324U, 397328U, 397332U, 463240U, 463248U, 463244U, 463260U, 463236U, 463236U,
      462884U, 463236U, 463268U, 43008U}};
#line 514 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.c"
static int oaktrail_chip_setup(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  int ret ;
  int tmp ;

  {
#line 516
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 519
  tmp = pci_enable_msi_exact(dev->pdev, 1);
#line 519
  if (tmp != 0) {
#line 520
    dev_warn((struct device  const  *)dev->dev, "Enabling MSI failed!\n");
  } else {

  }
#line 522
  dev_priv->regmap = (struct psb_offset  const  *)(& oaktrail_regmap);
#line 524
  ret = mid_chip_setup(dev);
#line 525
  if (ret < 0) {
#line 526
    return (ret);
  } else {

  }
#line 527
  if (! dev_priv->has_gct) {
#line 529
    psb_intel_opregion_init(dev);
#line 530
    psb_intel_init_bios(dev);
  } else {

  }
#line 532
  gma_intel_setup_gmbus(dev);
#line 533
  oaktrail_hdmi_setup(dev);
#line 534
  return (0);
}
}
#line 537 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.c"
static void oaktrail_teardown(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 539
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 541
  gma_intel_teardown_gmbus(dev);
#line 542
  oaktrail_hdmi_teardown(dev);
#line 543
  if (! dev_priv->has_gct) {
#line 544
    psb_intel_destroy_bios(dev);
  } else {

  }
#line 545
  return;
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.c"
struct psb_ops  const  oaktrail_chip_ops  = 
#line 547
     {"Oaktrail", 1U, 2, 2, 524288, 2, 1, 2, 0, & oaktrail_helper_funcs, & psb_intel_crtc_funcs,
    0, & oaktrail_chip_setup, & oaktrail_teardown, 0, & oaktrail_output_init, 0, 0,
    0, & oaktrail_save_display_registers, & oaktrail_restore_display_registers, & oaktrail_power_up,
    & oaktrail_power_down, 0, 0, 0, 1};
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
void ldv_initialize_psb_ops_13(void) 
{ 
  void *tmp ;

  {
#line 406
  tmp = ldv_init_zalloc(3320UL);
#line 406
  oaktrail_chip_ops_group0 = (struct drm_device *)tmp;
#line 407
  return;
}
}
#line 409 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
void ldv_main_exported_13(void) 
{ 
  int tmp ;

  {
#line 411
  tmp = __VERIFIER_nondet_int();
#line 411
  switch (tmp) {
  case 0: ;
#line 414
  if (ldv_state_variable_13 == 1) {
#line 416
    oaktrail_teardown(oaktrail_chip_ops_group0);
#line 418
    ldv_state_variable_13 = 1;
  } else {

  }
#line 421
  goto ldv_42238;
  case 1: ;
#line 424
  if (ldv_state_variable_13 == 1) {
#line 426
    oaktrail_chip_setup(oaktrail_chip_ops_group0);
#line 428
    ldv_state_variable_13 = 1;
  } else {

  }
#line 431
  goto ldv_42238;
  case 2: ;
#line 434
  if (ldv_state_variable_13 == 1) {
#line 436
    oaktrail_save_display_registers(oaktrail_chip_ops_group0);
#line 438
    ldv_state_variable_13 = 1;
  } else {

  }
#line 441
  goto ldv_42238;
  case 3: ;
#line 444
  if (ldv_state_variable_13 == 1) {
#line 446
    oaktrail_restore_display_registers(oaktrail_chip_ops_group0);
#line 448
    ldv_state_variable_13 = 1;
  } else {

  }
#line 451
  goto ldv_42238;
  case 4: ;
#line 454
  if (ldv_state_variable_13 == 1) {
#line 456
    oaktrail_power_down(oaktrail_chip_ops_group0);
#line 458
    ldv_state_variable_13 = 1;
  } else {

  }
#line 461
  goto ldv_42238;
  case 5: ;
#line 464
  if (ldv_state_variable_13 == 1) {
#line 466
    oaktrail_output_init(oaktrail_chip_ops_group0);
#line 468
    ldv_state_variable_13 = 1;
  } else {

  }
#line 471
  goto ldv_42238;
  case 6: ;
#line 474
  if (ldv_state_variable_13 == 1) {
#line 476
    oaktrail_power_up(oaktrail_chip_ops_group0);
#line 478
    ldv_state_variable_13 = 1;
  } else {

  }
#line 481
  goto ldv_42238;
  default: 
#line 482
  ldv_stop();
  }
  ldv_42238: ;
#line 486
  return;
}
}
#line 511 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
bool ldv_queue_work_on_1373(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 515
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 515
  ldv_func_res = tmp;
#line 517
  activate_work_2(ldv_func_arg3, 2);
#line 519
  return (ldv_func_res);
}
}
#line 522 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
bool ldv_queue_delayed_work_on_1374(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 526
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 526
  ldv_func_res = tmp;
#line 528
  activate_work_2(& ldv_func_arg3->work, 2);
#line 530
  return (ldv_func_res);
}
}
#line 533 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
bool ldv_queue_work_on_1375(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 537
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 537
  ldv_func_res = tmp;
#line 539
  activate_work_2(ldv_func_arg3, 2);
#line 541
  return (ldv_func_res);
}
}
#line 544 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
void ldv_flush_workqueue_1376(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 547
  flush_workqueue(ldv_func_arg1);
#line 549
  call_and_disable_all_2(2);
#line 550
  return;
}
}
#line 552 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
bool ldv_queue_delayed_work_on_1377(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 556
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 556
  ldv_func_res = tmp;
#line 558
  activate_work_2(& ldv_func_arg3->work, 2);
#line 560
  return (ldv_func_res);
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
void ldv_mutex_lock_1378(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 566
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 568
  mutex_lock(ldv_func_arg1);
#line 569
  return;
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
void ldv_mutex_unlock_1379(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 574
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 576
  mutex_unlock(ldv_func_arg1);
#line 577
  return;
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
void ldv_mutex_lock_1380(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 582
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 584
  mutex_lock(ldv_func_arg1);
#line 585
  return;
}
}
#line 587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
int ldv_mutex_trylock_1381(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 591
  tmp = mutex_trylock(ldv_func_arg1);
#line 591
  ldv_func_res = tmp;
#line 593
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 593
  return (tmp___0);
#line 595
  return (ldv_func_res);
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
void ldv_mutex_unlock_1382(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 601
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 603
  mutex_unlock(ldv_func_arg1);
#line 604
  return;
}
}
#line 606 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
void ldv_mutex_unlock_1383(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 609
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 611
  mutex_unlock(ldv_func_arg1);
#line 612
  return;
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
void ldv_mutex_lock_1384(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 617
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 619
  mutex_lock(ldv_func_arg1);
#line 620
  return;
}
}
#line 622 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
void ldv_mutex_unlock_1385(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 625
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 627
  mutex_unlock(ldv_func_arg1);
#line 628
  return;
}
}
#line 630 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
void ldv_mutex_lock_1386(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 633
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 635
  mutex_lock(ldv_func_arg1);
#line 636
  return;
}
}
#line 638 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
void ldv_mutex_unlock_1387(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 641
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 643
  mutex_unlock(ldv_func_arg1);
#line 644
  return;
}
}
#line 646 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
void ldv_mutex_lock_1388(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 649
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 651
  mutex_lock(ldv_func_arg1);
#line 652
  return;
}
}
#line 654 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
int ldv_mutex_lock_interruptible_1389(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 658
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 658
  ldv_func_res = tmp;
#line 660
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 660
  return (tmp___0);
#line 662
  return (ldv_func_res);
}
}
#line 665 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
int ldv_mutex_trylock_1390(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 669
  tmp = mutex_trylock(ldv_func_arg1);
#line 669
  ldv_func_res = tmp;
#line 671
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 671
  return (tmp___0);
#line 673
  return (ldv_func_res);
}
}
#line 697 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
void ldv_mutex_unlock_1393(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 700
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 702
  mutex_unlock(ldv_func_arg1);
#line 703
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_1426(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_1435(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_1424(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_1427(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_1428(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_1431(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_1432(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_1438(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
int ldv_mutex_lock_interruptible_1434(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_1423(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_1425(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_1429(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_1430(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_1433(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_1418(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_1420(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_1419(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_1422(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_1421(struct workqueue_struct *ldv_func_arg1 ) ;
#line 252 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/oaktrail.h"
int oaktrail_crtc_hdmi_mode_set(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                                struct drm_display_mode *adjusted_mode , int x , int y ,
                                struct drm_framebuffer *old_fb ) ;
#line 255
void oaktrail_crtc_hdmi_dpms(struct drm_crtc *crtc , int mode ) ;
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.c"
static bool mrst_lvds_find_best_pll(struct gma_limit_t  const  *limit , struct drm_crtc *crtc ,
                                    int target , int refclk , struct gma_clock_t *best_clock ) ;
#line 50
static bool mrst_sdvo_find_best_pll(struct gma_limit_t  const  *limit , struct drm_crtc *crtc ,
                                    int target , int refclk , struct gma_clock_t *best_clock ) ;
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.c"
static struct gma_limit_t  const  mrst_limits[4U]  = {      {{19750, 120000}, {0, 0}, {0, 0}, {20, 34}, {0, 0}, {0, 0}, {0, 0}, {2, 8}, {0,
                                                                                  0,
                                                                                  0},
      & mrst_lvds_find_best_pll}, 
        {{19750, 120000}, {0, 0}, {0, 0}, {12, 20}, {0, 0}, {0, 0}, {0, 0}, {2, 7}, {0,
                                                                                  0,
                                                                                  0},
      & mrst_lvds_find_best_pll}, 
        {{19750, 120000}, {0, 0}, {0, 0}, {10, 17}, {0, 0}, {0, 0}, {0, 0}, {2, 8}, {0,
                                                                                  0,
                                                                                  0},
      & mrst_lvds_find_best_pll}, 
        {{0, 0}, {1400000, 2800000}, {3, 7}, {80, 137}, {0, 0}, {0, 0}, {0, 0}, {1, 2},
      {200000, 10, 10}, & mrst_sdvo_find_best_pll}};
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.c"
static u32 const   oaktrail_m_converts[26U]  = 
#line 84
  {      43U,      21U,      42U,      53U, 
        26U,      13U,      38U,      51U, 
        25U,      44U,      54U,      59U, 
        29U,      46U,      55U,      27U, 
        45U,      22U,      11U,      37U, 
        18U,      9U,      36U,      50U, 
        57U,      28U};
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.c"
static struct gma_limit_t  const  *mrst_limit(struct drm_crtc *crtc , int refclk ) 
{ 
  struct gma_limit_t  const  *limit ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 93
  limit = (struct gma_limit_t  const  *)0;
#line 94
  dev = crtc->dev;
#line 95
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 97
  tmp___0 = gma_pipe_has_type(crtc, 4);
#line 97
  if ((int )tmp___0) {
#line 97
    goto _L;
  } else {
#line 97
    tmp___1 = gma_pipe_has_type(crtc, 7);
#line 97
    if ((int )tmp___1) {
      _L: /* CIL Label */ 
#line 99
      switch (dev_priv->core_freq) {
      case 100U: 
#line 101
      limit = (struct gma_limit_t  const  *)(& mrst_limits);
#line 102
      goto ldv_42042;
      case 166U: 
#line 104
      limit = (struct gma_limit_t  const  *)(& mrst_limits) + 1UL;
#line 105
      goto ldv_42042;
      case 200U: 
#line 107
      limit = (struct gma_limit_t  const  *)(& mrst_limits) + 2UL;
#line 108
      goto ldv_42042;
      }
      ldv_42042: ;
    } else {
#line 110
      tmp = gma_pipe_has_type(crtc, 3);
#line 110
      if ((int )tmp) {
#line 111
        limit = (struct gma_limit_t  const  *)(& mrst_limits) + 3UL;
      } else {
#line 113
        limit = (struct gma_limit_t  const  *)0;
#line 114
        dev_err((struct device  const  *)dev->dev, "mrst_limit Wrong display type.\n");
      }
    }
  }
#line 117
  return (limit);
}
}
#line 121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.c"
static void mrst_lvds_clock(int refclk , struct gma_clock_t *clock ) 
{ 


  {
#line 123
  clock->dot = (clock->m * refclk) / (clock->p1 * 14);
#line 124
  return;
}
}
#line 126 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.c"
static void mrst_print_pll(struct gma_clock_t *clock ) 
{ 
  long tmp ;

  {
#line 128
  tmp = ldv__builtin_expect((drm_debug & 2U) != 0U, 0L);
#line 128
  if (tmp != 0L) {
#line 128
    drm_ut_debug_printk("mrst_print_pll", "dotclock=%d,  m=%d, m1=%d, m2=%d, n=%d, p1=%d, p2=%d\n",
                        clock->dot, clock->m, clock->m1, clock->m2, clock->n, clock->p1,
                        clock->p2);
  } else {

  }
#line 129
  return;
}
}
#line 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.c"
static bool mrst_sdvo_find_best_pll(struct gma_limit_t  const  *limit , struct drm_crtc *crtc ,
                                    int target , int refclk , struct gma_clock_t *best_clock ) 
{ 
  struct gma_clock_t clock ;
  u32 target_vco ;
  u32 actual_freq ;
  s32 freq_error ;
  s32 min_error ;

  {
#line 139
  min_error = 100000;
#line 141
  memset((void *)best_clock, 0, 36UL);
#line 143
  clock.m = limit->m.min;
#line 143
  goto ldv_42074;
  ldv_42073: 
#line 144
  clock.n = limit->n.min;
#line 144
  goto ldv_42070;
  ldv_42069: 
#line 146
  clock.p1 = limit->p1.min;
#line 146
  goto ldv_42068;
  ldv_42067: 
#line 149
  clock.p = clock.p1 * (int )limit->p2.p2_slow;
#line 150
  target_vco = (u32 )(clock.p * target);
#line 153
  if ((u32 )limit->vco.max < target_vco) {
#line 154
    goto ldv_42065;
  } else {

  }
#line 156
  if ((u32 )limit->vco.min > target_vco) {
#line 157
    goto ldv_42066;
  } else {

  }
#line 159
  actual_freq = (u32 )((clock.m * refclk) / (clock.n * clock.p));
#line 161
  freq_error = (s32 )(10000U - (u32 )(target * 10000) / actual_freq);
#line 164
  if (- min_error > freq_error) {
#line 167
    goto ldv_42065;
  } else {

  }
#line 170
  if (freq_error < 0) {
#line 171
    freq_error = - freq_error;
  } else {

  }
#line 173
  if (freq_error < min_error) {
#line 174
    min_error = freq_error;
#line 175
    *best_clock = clock;
  } else {

  }
  ldv_42066: 
#line 147
  clock.p1 = clock.p1 + 1;
  ldv_42068: ;
#line 146
  if (clock.p1 <= (int )limit->p1.max) {
#line 149
    goto ldv_42067;
  } else {

  }
  ldv_42065: 
#line 145
  clock.n = clock.n + 1;
  ldv_42070: ;
#line 144
  if (clock.n <= (int )limit->n.max) {
#line 146
    goto ldv_42069;
  } else {

  }

#line 179
  if (min_error == 0) {
#line 180
    goto ldv_42072;
  } else {

  }
#line 143
  clock.m = clock.m + 1;
  ldv_42074: ;
#line 143
  if (clock.m <= (int )limit->m.max) {
#line 145
    goto ldv_42073;
  } else {

  }
  ldv_42072: ;
#line 183
  return (min_error == 0);
}
}
#line 190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.c"
static bool mrst_lvds_find_best_pll(struct gma_limit_t  const  *limit , struct drm_crtc *crtc ,
                                    int target , int refclk , struct gma_clock_t *best_clock ) 
{ 
  struct gma_clock_t clock ;
  int err ;
  int this_err ;
  long ret ;
  int __x___0 ;

  {
#line 195
  err = target;
#line 197
  memset((void *)best_clock, 0, 36UL);
#line 199
  clock.m = limit->m.min;
#line 199
  goto ldv_42093;
  ldv_42092: 
#line 200
  clock.p1 = limit->p1.min;
#line 200
  goto ldv_42090;
  ldv_42089: 
#line 204
  mrst_lvds_clock(refclk, & clock);
#line 206
  __x___0 = clock.dot - target;
#line 206
  ret = (long )(__x___0 < 0 ? - __x___0 : __x___0);
#line 206
  this_err = (int )ret;
#line 207
  if (this_err < err) {
#line 208
    *best_clock = clock;
#line 209
    err = this_err;
  } else {

  }
#line 201
  clock.p1 = clock.p1 + 1;
  ldv_42090: ;
#line 200
  if (clock.p1 <= (int )limit->p1.max) {
#line 202
    goto ldv_42089;
  } else {

  }
#line 199
  clock.m = clock.m + 1;
  ldv_42093: ;
#line 199
  if (clock.m <= (int )limit->m.max) {
#line 201
    goto ldv_42092;
  } else {

  }

#line 213
  return (err != target);
}
}
#line 222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.c"
static void oaktrail_crtc_dpms(struct drm_crtc *crtc , int mode ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  struct psb_offset  const  *map ;
  u32 temp ;
  int i ;
  int need_aux ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;

  {
#line 224
  dev = crtc->dev;
#line 225
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 226
  __mptr = (struct drm_crtc  const  *)crtc;
#line 226
  gma_crtc = (struct gma_crtc *)__mptr;
#line 227
  pipe = gma_crtc->pipe;
#line 228
  map = dev_priv->regmap + (unsigned long )pipe;
#line 231
  tmp = gma_pipe_has_type(crtc, 3);
#line 231
  need_aux = (int )tmp;
#line 233
  tmp___0 = gma_pipe_has_type(crtc, 6);
#line 233
  if ((int )tmp___0) {
#line 234
    oaktrail_crtc_hdmi_dpms(crtc, mode);
#line 235
    return;
  } else {

  }
#line 238
  tmp___1 = gma_power_begin(dev, 1);
#line 238
  if (tmp___1) {
#line 238
    tmp___2 = 0;
  } else {
#line 238
    tmp___2 = 1;
  }
#line 238
  if (tmp___2) {
#line 239
    return;
  } else {

  }
#line 244
  switch (mode) {
  case 0: ;
  case 1: ;
  case 2: 
#line 248
  i = 0;
#line 248
  goto ldv_42113;
  ldv_42112: 
#line 250
  temp = REGISTER_READ_WITH_AUX(dev, map->dpll, i);
#line 251
  if ((int )temp >= 0) {
#line 252
    REGISTER_WRITE_WITH_AUX(dev, map->dpll, temp, i);
#line 253
    REGISTER_READ_WITH_AUX(dev, map->dpll, i);
#line 255
    __const_udelay(644250UL);
#line 256
    REGISTER_WRITE_WITH_AUX(dev, map->dpll, temp | 2147483648U, i);
#line 258
    REGISTER_READ_WITH_AUX(dev, map->dpll, i);
#line 260
    __const_udelay(644250UL);
#line 261
    REGISTER_WRITE_WITH_AUX(dev, map->dpll, temp | 2147483648U, i);
#line 263
    REGISTER_READ_WITH_AUX(dev, map->dpll, i);
#line 265
    __const_udelay(644250UL);
  } else {

  }
#line 269
  temp = REGISTER_READ_WITH_AUX(dev, map->conf, i);
#line 270
  if ((int )temp >= 0) {
#line 271
    REGISTER_WRITE_WITH_AUX(dev, map->conf, temp | 2147483648U, i);
  } else {

  }
#line 276
  temp = REGISTER_READ_WITH_AUX(dev, map->cntr, i);
#line 277
  if ((int )temp >= 0) {
#line 278
    REGISTER_WRITE_WITH_AUX(dev, map->cntr, temp | 2147483648U, i);
#line 282
    tmp___3 = REGISTER_READ_WITH_AUX(dev, map->base, i);
#line 282
    REGISTER_WRITE_WITH_AUX(dev, map->base, tmp___3, i);
  } else {

  }
#line 248
  i = i + 1;
  ldv_42113: ;
#line 248
  if (i <= need_aux) {
#line 250
    goto ldv_42112;
  } else {

  }
#line 287
  gma_crtc_load_lut(crtc);
#line 292
  goto ldv_42115;
  case 3: 
#line 298
  i = 0;
#line 298
  goto ldv_42118;
  ldv_42117: 
#line 300
  REGISTER_WRITE_WITH_AUX(dev, 463872U, 2147483648U, i);
#line 302
  temp = REGISTER_READ_WITH_AUX(dev, map->cntr, i);
#line 303
  if ((int )temp < 0) {
#line 304
    REGISTER_WRITE_WITH_AUX(dev, map->cntr, temp & 2147483647U, i);
#line 307
    tmp___4 = REGISTER_READ(dev, map->base);
#line 307
    REGISTER_WRITE_WITH_AUX(dev, map->base, tmp___4, i);
#line 309
    REGISTER_READ_WITH_AUX(dev, map->base, i);
  } else {

  }
#line 313
  temp = REGISTER_READ_WITH_AUX(dev, map->conf, i);
#line 314
  if ((int )temp < 0) {
#line 315
    REGISTER_WRITE_WITH_AUX(dev, map->conf, temp & 2147483647U, i);
#line 317
    REGISTER_READ_WITH_AUX(dev, map->conf, i);
  } else {

  }
#line 320
  gma_wait_for_vblank(dev);
#line 322
  temp = REGISTER_READ_WITH_AUX(dev, map->dpll, i);
#line 323
  if ((int )temp < 0) {
#line 324
    REGISTER_WRITE_WITH_AUX(dev, map->dpll, temp & 2147483647U, i);
#line 326
    REGISTER_READ_WITH_AUX(dev, map->dpll, i);
  } else {

  }
#line 330
  __const_udelay(644250UL);
#line 298
  i = i + 1;
  ldv_42118: ;
#line 298
  if (i <= need_aux) {
#line 300
    goto ldv_42117;
  } else {

  }

#line 332
  goto ldv_42115;
  }
  ldv_42115: 
#line 336
  REGISTER_WRITE(dev, 458800U, 16256U);
#line 337
  REGISTER_WRITE(dev, 458804U, 1066337284U);
#line 338
  REGISTER_WRITE(dev, 458808U, 67374852U);
#line 339
  REGISTER_WRITE(dev, 458812U, 0U);
#line 340
  REGISTER_WRITE(dev, 458832U, 67372036U);
#line 341
  REGISTER_WRITE(dev, 458836U, 67372036U);
#line 342
  REGISTER_WRITE(dev, 458840U, 120U);
#line 343
  tmp___5 = REGISTER_READ(dev, 459776U);
#line 343
  REGISTER_WRITE(dev, 459776U, tmp___5 | 49216U);
#line 345
  gma_power_end(dev);
#line 346
  return;
}
}
#line 352 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.c"
static int oaktrail_panel_fitter_pipe(struct drm_device *dev ) 
{ 
  u32 pfit_control ;

  {
#line 356
  pfit_control = REGISTER_READ(dev, 397872U);
#line 359
  if ((int )pfit_control >= 0) {
#line 360
    return (-1);
  } else {

  }
#line 361
  return ((int )(pfit_control >> 29) & 3);
}
}
#line 364 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.c"
static int oaktrail_crtc_mode_set(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                                  struct drm_display_mode *adjusted_mode , int x ,
                                  int y , struct drm_framebuffer *old_fb ) 
{ 
  struct drm_device *dev ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct drm_psb_private *dev_priv ;
  int pipe ;
  struct psb_offset  const  *map ;
  int refclk ;
  struct gma_clock_t clock ;
  struct gma_limit_t  const  *limit ;
  u32 dpll ;
  u32 fp ;
  u32 dspcntr ;
  u32 pipeconf ;
  bool ok ;
  bool is_sdvo ;
  bool is_lvds ;
  bool is_mipi ;
  struct drm_mode_config *mode_config ;
  struct gma_encoder *gma_encoder ;
  uint64_t scalingType ;
  struct drm_connector *connector ;
  int i ;
  int need_aux ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  int tmp___4 ;
  int offsetX ;
  int offsetY ;
  struct drm_crtc_helper_funcs  const  *crtc_funcs ;
  int sdvo_pixel_multiply ;

  {
#line 370
  dev = crtc->dev;
#line 371
  __mptr = (struct drm_crtc  const  *)crtc;
#line 371
  gma_crtc = (struct gma_crtc *)__mptr;
#line 372
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 373
  pipe = gma_crtc->pipe;
#line 374
  map = dev_priv->regmap + (unsigned long )pipe;
#line 375
  refclk = 0;
#line 378
  dpll = 0U;
#line 378
  fp = 0U;
#line 379
  is_sdvo = 0;
#line 380
  is_lvds = 0;
#line 381
  is_mipi = 0;
#line 382
  mode_config = & dev->mode_config;
#line 383
  gma_encoder = (struct gma_encoder *)0;
#line 384
  scalingType = 1ULL;
#line 387
  tmp = gma_pipe_has_type(crtc, 3);
#line 387
  need_aux = (int )tmp;
#line 389
  tmp___1 = gma_pipe_has_type(crtc, 6);
#line 389
  if ((int )tmp___1) {
#line 390
    tmp___0 = oaktrail_crtc_hdmi_mode_set(crtc, mode, adjusted_mode, x, y, old_fb);
#line 390
    return (tmp___0);
  } else {

  }
#line 392
  tmp___2 = gma_power_begin(dev, 1);
#line 392
  if (tmp___2) {
#line 392
    tmp___3 = 0;
  } else {
#line 392
    tmp___3 = 1;
  }
#line 392
  if (tmp___3) {
#line 393
    return (0);
  } else {

  }
#line 395
  memcpy((void *)(& gma_crtc->saved_mode), (void const   *)mode, 208UL);
#line 398
  memcpy((void *)(& gma_crtc->saved_adjusted_mode), (void const   *)adjusted_mode,
           208UL);
#line 402
  __mptr___0 = (struct list_head  const  *)mode_config->connector_list.next;
#line 402
  connector = (struct drm_connector *)__mptr___0 + 0xffffffffffffffe8UL;
#line 402
  goto ldv_42166;
  ldv_42165: ;
#line 403
  if ((unsigned long )connector->encoder == (unsigned long )((struct drm_encoder *)0) || (unsigned long )(connector->encoder)->crtc != (unsigned long )crtc) {
#line 404
    goto ldv_42160;
  } else {

  }
#line 406
  gma_encoder = gma_attached_encoder(connector);
#line 408
  switch (gma_encoder->type) {
  case 4: 
#line 410
  is_lvds = 1;
#line 411
  goto ldv_42162;
  case 3: 
#line 413
  is_sdvo = 1;
#line 414
  goto ldv_42162;
  case 7: 
#line 416
  is_mipi = 1;
#line 417
  goto ldv_42162;
  }
  ldv_42162: ;
  ldv_42160: 
#line 402
  __mptr___1 = (struct list_head  const  *)connector->head.next;
#line 402
  connector = (struct drm_connector *)__mptr___1 + 0xffffffffffffffe8UL;
  ldv_42166: ;
#line 402
  if ((unsigned long )(& connector->head) != (unsigned long )(& mode_config->connector_list)) {
#line 404
    goto ldv_42165;
  } else {

  }
#line 422
  i = 0;
#line 422
  goto ldv_42169;
  ldv_42168: 
#line 423
  REGISTER_WRITE_WITH_AUX(dev, 463872U, 2147483648U, i);
#line 422
  i = i + 1;
  ldv_42169: ;
#line 422
  if (i <= need_aux) {
#line 424
    goto ldv_42168;
  } else {

  }
#line 426
  tmp___4 = oaktrail_panel_fitter_pipe(dev);
#line 426
  if (tmp___4 == pipe) {
#line 427
    REGISTER_WRITE(dev, 397872U, 0U);
  } else {

  }
#line 429
  i = 0;
#line 429
  goto ldv_42172;
  ldv_42171: 
#line 430
  REGISTER_WRITE_WITH_AUX(dev, map->src, (uint32_t )(((mode->crtc_hdisplay + -1) << 16) | (mode->crtc_vdisplay + -1)),
                          i);
#line 429
  i = i + 1;
  ldv_42172: ;
#line 429
  if (i <= need_aux) {
#line 431
    goto ldv_42171;
  } else {

  }

#line 434
  if ((unsigned long )gma_encoder != (unsigned long )((struct gma_encoder *)0)) {
#line 435
    drm_object_property_get_value(& connector->base, dev->mode_config.scaling_mode_property,
                                  & scalingType);
  } else {

  }
#line 438
  if (scalingType == 2ULL) {
#line 442
    offsetX = 0;
#line 442
    offsetY = 0;
#line 444
    offsetX = (adjusted_mode->crtc_hdisplay - mode->crtc_hdisplay) / 2;
#line 446
    offsetY = (adjusted_mode->crtc_vdisplay - mode->crtc_vdisplay) / 2;
#line 449
    i = 0;
#line 449
    goto ldv_42177;
    ldv_42176: 
#line 450
    REGISTER_WRITE_WITH_AUX(dev, map->htotal, (uint32_t )((mode->crtc_hdisplay + -1) | ((adjusted_mode->crtc_htotal + -1) << 16)),
                            i);
#line 452
    REGISTER_WRITE_WITH_AUX(dev, map->vtotal, (uint32_t )((mode->crtc_vdisplay + -1) | ((adjusted_mode->crtc_vtotal + -1) << 16)),
                            i);
#line 454
    REGISTER_WRITE_WITH_AUX(dev, map->hblank, (uint32_t )(((adjusted_mode->crtc_hblank_start - offsetX) + -1) | (((adjusted_mode->crtc_hblank_end - offsetX) + -1) << 16)),
                            i);
#line 457
    REGISTER_WRITE_WITH_AUX(dev, map->hsync, (uint32_t )(((adjusted_mode->crtc_hsync_start - offsetX) + -1) | (((adjusted_mode->crtc_hsync_end - offsetX) + -1) << 16)),
                            i);
#line 460
    REGISTER_WRITE_WITH_AUX(dev, map->vblank, (uint32_t )(((adjusted_mode->crtc_vblank_start - offsetY) + -1) | (((adjusted_mode->crtc_vblank_end - offsetY) + -1) << 16)),
                            i);
#line 463
    REGISTER_WRITE_WITH_AUX(dev, map->vsync, (uint32_t )(((adjusted_mode->crtc_vsync_start - offsetY) + -1) | (((adjusted_mode->crtc_vsync_end - offsetY) + -1) << 16)),
                            i);
#line 449
    i = i + 1;
    ldv_42177: ;
#line 449
    if (i <= need_aux) {
#line 451
      goto ldv_42176;
    } else {

    }

  } else {
#line 468
    i = 0;
#line 468
    goto ldv_42180;
    ldv_42179: 
#line 469
    REGISTER_WRITE_WITH_AUX(dev, map->htotal, (uint32_t )((adjusted_mode->crtc_hdisplay + -1) | ((adjusted_mode->crtc_htotal + -1) << 16)),
                            i);
#line 471
    REGISTER_WRITE_WITH_AUX(dev, map->vtotal, (uint32_t )((adjusted_mode->crtc_vdisplay + -1) | ((adjusted_mode->crtc_vtotal + -1) << 16)),
                            i);
#line 473
    REGISTER_WRITE_WITH_AUX(dev, map->hblank, (uint32_t )((adjusted_mode->crtc_hblank_start + -1) | ((adjusted_mode->crtc_hblank_end + -1) << 16)),
                            i);
#line 475
    REGISTER_WRITE_WITH_AUX(dev, map->hsync, (uint32_t )((adjusted_mode->crtc_hsync_start + -1) | ((adjusted_mode->crtc_hsync_end + -1) << 16)),
                            i);
#line 477
    REGISTER_WRITE_WITH_AUX(dev, map->vblank, (uint32_t )((adjusted_mode->crtc_vblank_start + -1) | ((adjusted_mode->crtc_vblank_end + -1) << 16)),
                            i);
#line 479
    REGISTER_WRITE_WITH_AUX(dev, map->vsync, (uint32_t )((adjusted_mode->crtc_vsync_start + -1) | ((adjusted_mode->crtc_vsync_end + -1) << 16)),
                            i);
#line 468
    i = i + 1;
    ldv_42180: ;
#line 468
    if (i <= need_aux) {
#line 470
      goto ldv_42179;
    } else {

    }

  }
#line 486
  crtc_funcs = (struct drm_crtc_helper_funcs  const  *)crtc->helper_private;
#line 488
  (*(crtc_funcs->mode_set_base))(crtc, x, y, old_fb);
#line 492
  pipeconf = REGISTER_READ(dev, map->conf);
#line 495
  dspcntr = REGISTER_READ(dev, map->cntr);
#line 496
  dspcntr = dspcntr | 1073741824U;
#line 498
  if (pipe == 0) {
#line 499
    dspcntr = dspcntr;
  } else {
#line 501
    dspcntr = dspcntr | 16777216U;
  }
#line 503
  if ((int )is_mipi) {
#line 504
    goto oaktrail_crtc_mode_set_exit;
  } else {

  }
#line 507
  dpll = 0U;
#line 509
  refclk = (int )is_sdvo ? 96000 : (int )(dev_priv->core_freq * 1000U);
#line 510
  limit = mrst_limit(crtc, refclk);
#line 511
  ok = (*(limit->find_pll))(limit, crtc, adjusted_mode->clock, refclk, & clock);
#line 514
  if ((int )is_sdvo) {
#line 516
    clock.p1 = (int )(1L << (clock.p1 + -1));
#line 517
    clock.m = clock.m + -2;
#line 518
    clock.n = (int )(1L << (clock.n + -1));
  } else {

  }
#line 521
  if (! ok) {
#line 522
    drm_err("Failed to find proper PLL settings");
  } else {

  }
#line 524
  mrst_print_pll(& clock);
#line 526
  if ((int )is_sdvo) {
#line 527
    fp = (u32 )((clock.n << 16) | clock.m);
  } else {
#line 529
    fp = oaktrail_m_converts[clock.m + -10] << 8;
  }
#line 531
  dpll = dpll | 268435456U;
#line 534
  dpll = dpll | 2147483648U;
#line 536
  if ((int )is_lvds) {
#line 537
    dpll = dpll | 134217728U;
  } else {
#line 539
    dpll = dpll | 67108864U;
  }
#line 541
  if ((int )is_sdvo) {
#line 542
    sdvo_pixel_multiply = adjusted_mode->clock / mode->clock;
#line 545
    dpll = dpll | 1073741824U;
#line 546
    dpll = (u32 )((sdvo_pixel_multiply + -1) << 4) | dpll;
  } else {

  }
#line 553
  if ((int )is_sdvo) {
#line 554
    dpll = (u32 )(clock.p1 << 16) | dpll;
  } else {
#line 556
    dpll = (u32 )((1 << (clock.p1 + -2)) << 17) | dpll;
  }
#line 558
  dpll = dpll | 2147483648U;
#line 560
  if ((int )dpll < 0) {
#line 561
    i = 0;
#line 561
    goto ldv_42186;
    ldv_42185: 
#line 562
    REGISTER_WRITE_WITH_AUX(dev, map->fp0, fp, i);
#line 563
    REGISTER_WRITE_WITH_AUX(dev, map->dpll, dpll & 2147483647U, i);
#line 564
    REGISTER_READ_WITH_AUX(dev, map->dpll, i);
#line 566
    __const_udelay(644250UL);
#line 561
    i = i + 1;
    ldv_42186: ;
#line 561
    if (i <= need_aux) {
#line 563
      goto ldv_42185;
    } else {

    }

  } else {

  }
#line 570
  i = 0;
#line 570
  goto ldv_42189;
  ldv_42188: 
#line 571
  REGISTER_WRITE_WITH_AUX(dev, map->fp0, fp, i);
#line 572
  REGISTER_WRITE_WITH_AUX(dev, map->dpll, dpll, i);
#line 573
  REGISTER_READ_WITH_AUX(dev, map->dpll, i);
#line 575
  __const_udelay(644250UL);
#line 578
  REGISTER_WRITE_WITH_AUX(dev, map->dpll, dpll, i);
#line 579
  REGISTER_READ_WITH_AUX(dev, map->dpll, i);
#line 581
  __const_udelay(644250UL);
#line 583
  REGISTER_WRITE_WITH_AUX(dev, map->conf, pipeconf, i);
#line 584
  REGISTER_READ_WITH_AUX(dev, map->conf, i);
#line 585
  gma_wait_for_vblank(dev);
#line 587
  REGISTER_WRITE_WITH_AUX(dev, map->cntr, dspcntr, i);
#line 588
  gma_wait_for_vblank(dev);
#line 570
  i = i + 1;
  ldv_42189: ;
#line 570
  if (i <= need_aux) {
#line 572
    goto ldv_42188;
  } else {

  }

  oaktrail_crtc_mode_set_exit: 
#line 592
  gma_power_end(dev);
#line 593
  return (0);
}
}
#line 596 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.c"
static int oaktrail_pipe_set_base(struct drm_crtc *crtc , int x , int y , struct drm_framebuffer *old_fb ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct psb_framebuffer *psbfb ;
  struct drm_framebuffer  const  *__mptr___0 ;
  int pipe ;
  struct psb_offset  const  *map ;
  unsigned long start ;
  unsigned long offset ;
  u32 dspcntr ;
  int ret ;
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 599
  dev = crtc->dev;
#line 600
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 601
  __mptr = (struct drm_crtc  const  *)crtc;
#line 601
  gma_crtc = (struct gma_crtc *)__mptr;
#line 602
  __mptr___0 = (struct drm_framebuffer  const  *)(crtc->primary)->fb;
#line 602
  psbfb = (struct psb_framebuffer *)__mptr___0;
#line 603
  pipe = gma_crtc->pipe;
#line 604
  map = dev_priv->regmap + (unsigned long )pipe;
#line 608
  ret = 0;
#line 611
  if ((unsigned long )(crtc->primary)->fb == (unsigned long )((struct drm_framebuffer *)0)) {
#line 612
    descriptor.modname = "gma500_gfx";
#line 612
    descriptor.function = "oaktrail_pipe_set_base";
#line 612
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.c";
#line 612
    descriptor.format = "No FB bound\n";
#line 612
    descriptor.lineno = 612U;
#line 612
    descriptor.flags = 0U;
#line 612
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 612
    if (tmp != 0L) {
#line 612
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "No FB bound\n");
    } else {

    }
#line 613
    return (0);
  } else {

  }
#line 616
  tmp___0 = gma_power_begin(dev, 1);
#line 616
  if (tmp___0) {
#line 616
    tmp___1 = 0;
  } else {
#line 616
    tmp___1 = 1;
  }
#line 616
  if (tmp___1) {
#line 617
    return (0);
  } else {

  }
#line 619
  start = (unsigned long )(psbfb->gtt)->offset;
#line 620
  offset = (unsigned long )(((crtc->primary)->fb)->pitches[0] * (unsigned int )y + (unsigned int )((((crtc->primary)->fb)->bits_per_pixel / 8) * x));
#line 622
  REGISTER_WRITE(dev, map->stride, ((crtc->primary)->fb)->pitches[0]);
#line 624
  dspcntr = REGISTER_READ(dev, map->cntr);
#line 625
  dspcntr = dspcntr & 3288334335U;
#line 627
  switch (((crtc->primary)->fb)->bits_per_pixel) {
  case 8: 
#line 629
  dspcntr = dspcntr | 134217728U;
#line 630
  goto ldv_42214;
  case 16: ;
#line 632
  if (((crtc->primary)->fb)->depth == 15U) {
#line 633
    dspcntr = dspcntr | 268435456U;
  } else {
#line 635
    dspcntr = dspcntr | 335544320U;
  }
#line 636
  goto ldv_42214;
  case 24: ;
  case 32: 
#line 639
  dspcntr = dspcntr | 402653184U;
#line 640
  goto ldv_42214;
  default: 
#line 642
  dev_err((struct device  const  *)dev->dev, "Unknown color depth\n");
#line 643
  ret = -22;
#line 644
  goto pipe_set_base_exit;
  }
  ldv_42214: 
#line 646
  REGISTER_WRITE(dev, map->cntr, dspcntr);
#line 648
  REGISTER_WRITE(dev, map->base, (uint32_t )offset);
#line 649
  REGISTER_READ(dev, map->base);
#line 650
  REGISTER_WRITE(dev, map->surf, (uint32_t )start);
#line 651
  REGISTER_READ(dev, map->surf);
  pipe_set_base_exit: 
#line 654
  gma_power_end(dev);
#line 655
  return (ret);
}
}
#line 658 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.c"
struct drm_crtc_helper_funcs  const  oaktrail_helper_funcs  = 
#line 658
     {& oaktrail_crtc_dpms, & gma_crtc_prepare, & gma_crtc_commit, & gma_crtc_mode_fixup,
    & oaktrail_crtc_mode_set, 0, & oaktrail_pipe_set_base, 0, 0, 0, 0, 0, 0, 0};
#line 668 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.c"
struct gma_clock_funcs  const  mrst_clock_funcs  =    {& mrst_lvds_clock, & mrst_limit, & gma_pll_is_valid};
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
void ldv_initialize_drm_crtc_helper_funcs_12(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 406
  tmp = ldv_init_zalloc(1160UL);
#line 406
  oaktrail_helper_funcs_group0 = (struct drm_crtc *)tmp;
#line 407
  tmp___0 = ldv_init_zalloc(168UL);
#line 407
  oaktrail_helper_funcs_group1 = (struct drm_framebuffer *)tmp___0;
#line 408
  tmp___1 = ldv_init_zalloc(208UL);
#line 408
  oaktrail_helper_funcs_group2 = (struct drm_display_mode *)tmp___1;
#line 409
  return;
}
}
#line 411 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
void ldv_initialize_gma_clock_funcs_11(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 412
  tmp = ldv_init_zalloc(1160UL);
#line 412
  mrst_clock_funcs_group0 = (struct drm_crtc *)tmp;
#line 413
  tmp___0 = ldv_init_zalloc(36UL);
#line 413
  mrst_clock_funcs_group1 = (struct gma_clock_t *)tmp___0;
#line 414
  return;
}
}
#line 416 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
void ldv_main_exported_11(void) 
{ 
  struct gma_limit_t *ldvarg107 ;
  void *tmp ;
  int ldvarg105 ;
  int ldvarg106 ;
  int tmp___0 ;

  {
#line 417
  tmp = ldv_init_zalloc(88UL);
#line 417
  ldvarg107 = (struct gma_limit_t *)tmp;
#line 418
  ldv_memset((void *)(& ldvarg105), 0, 4UL);
#line 419
  ldv_memset((void *)(& ldvarg106), 0, 4UL);
#line 421
  tmp___0 = __VERIFIER_nondet_int();
#line 421
  switch (tmp___0) {
  case 0: ;
#line 424
  if (ldv_state_variable_11 == 1) {
#line 426
    gma_pll_is_valid(mrst_clock_funcs_group0, (struct gma_limit_t  const  *)ldvarg107,
                     mrst_clock_funcs_group1);
#line 428
    ldv_state_variable_11 = 1;
  } else {

  }
#line 431
  goto ldv_42235;
  case 1: ;
#line 434
  if (ldv_state_variable_11 == 1) {
#line 436
    mrst_lvds_clock(ldvarg106, mrst_clock_funcs_group1);
#line 438
    ldv_state_variable_11 = 1;
  } else {

  }
#line 441
  goto ldv_42235;
  case 2: ;
#line 444
  if (ldv_state_variable_11 == 1) {
#line 446
    mrst_limit(mrst_clock_funcs_group0, ldvarg105);
#line 448
    ldv_state_variable_11 = 1;
  } else {

  }
#line 451
  goto ldv_42235;
  default: 
#line 452
  ldv_stop();
  }
  ldv_42235: ;
#line 456
  return;
}
}
#line 458 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
void ldv_main_exported_12(void) 
{ 
  int ldvarg179 ;
  int ldvarg173 ;
  int ldvarg178 ;
  struct drm_display_mode *ldvarg176 ;
  void *tmp ;
  struct drm_display_mode *ldvarg174 ;
  void *tmp___0 ;
  int ldvarg175 ;
  int ldvarg177 ;
  int tmp___1 ;

  {
#line 462
  tmp = ldv_init_zalloc(208UL);
#line 462
  ldvarg176 = (struct drm_display_mode *)tmp;
#line 463
  tmp___0 = ldv_init_zalloc(208UL);
#line 463
  ldvarg174 = (struct drm_display_mode *)tmp___0;
#line 459
  ldv_memset((void *)(& ldvarg179), 0, 4UL);
#line 460
  ldv_memset((void *)(& ldvarg173), 0, 4UL);
#line 461
  ldv_memset((void *)(& ldvarg178), 0, 4UL);
#line 464
  ldv_memset((void *)(& ldvarg175), 0, 4UL);
#line 465
  ldv_memset((void *)(& ldvarg177), 0, 4UL);
#line 467
  tmp___1 = __VERIFIER_nondet_int();
#line 467
  switch (tmp___1) {
  case 0: ;
#line 470
  if (ldv_state_variable_12 == 1) {
#line 472
    oaktrail_pipe_set_base(oaktrail_helper_funcs_group0, ldvarg179, ldvarg178, oaktrail_helper_funcs_group1);
#line 474
    ldv_state_variable_12 = 1;
  } else {

  }
#line 477
  goto ldv_42250;
  case 1: ;
#line 480
  if (ldv_state_variable_12 == 1) {
#line 482
    oaktrail_crtc_dpms(oaktrail_helper_funcs_group0, ldvarg177);
#line 484
    ldv_state_variable_12 = 1;
  } else {

  }
#line 487
  goto ldv_42250;
  case 2: ;
#line 490
  if (ldv_state_variable_12 == 1) {
#line 492
    gma_crtc_mode_fixup(oaktrail_helper_funcs_group0, (struct drm_display_mode  const  *)ldvarg176,
                        oaktrail_helper_funcs_group2);
#line 494
    ldv_state_variable_12 = 1;
  } else {

  }
#line 497
  goto ldv_42250;
  case 3: ;
#line 500
  if (ldv_state_variable_12 == 1) {
#line 502
    gma_crtc_commit(oaktrail_helper_funcs_group0);
#line 504
    ldv_state_variable_12 = 1;
  } else {

  }
#line 507
  goto ldv_42250;
  case 4: ;
#line 510
  if (ldv_state_variable_12 == 1) {
#line 512
    oaktrail_crtc_mode_set(oaktrail_helper_funcs_group0, oaktrail_helper_funcs_group2,
                           ldvarg174, ldvarg173, ldvarg175, oaktrail_helper_funcs_group1);
#line 514
    ldv_state_variable_12 = 1;
  } else {

  }
#line 517
  goto ldv_42250;
  case 5: ;
#line 520
  if (ldv_state_variable_12 == 1) {
#line 522
    gma_crtc_prepare(oaktrail_helper_funcs_group0);
#line 524
    ldv_state_variable_12 = 1;
  } else {

  }
#line 527
  goto ldv_42250;
  default: 
#line 528
  ldv_stop();
  }
  ldv_42250: ;
#line 532
  return;
}
}
#line 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
bool ldv_queue_work_on_1418(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 561
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 561
  ldv_func_res = tmp;
#line 563
  activate_work_2(ldv_func_arg3, 2);
#line 565
  return (ldv_func_res);
}
}
#line 568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
bool ldv_queue_delayed_work_on_1419(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 572
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 572
  ldv_func_res = tmp;
#line 574
  activate_work_2(& ldv_func_arg3->work, 2);
#line 576
  return (ldv_func_res);
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
bool ldv_queue_work_on_1420(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 583
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 583
  ldv_func_res = tmp;
#line 585
  activate_work_2(ldv_func_arg3, 2);
#line 587
  return (ldv_func_res);
}
}
#line 590 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
void ldv_flush_workqueue_1421(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 593
  flush_workqueue(ldv_func_arg1);
#line 595
  call_and_disable_all_2(2);
#line 596
  return;
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
bool ldv_queue_delayed_work_on_1422(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 602
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 602
  ldv_func_res = tmp;
#line 604
  activate_work_2(& ldv_func_arg3->work, 2);
#line 606
  return (ldv_func_res);
}
}
#line 609 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
void ldv_mutex_lock_1423(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 612
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 614
  mutex_lock(ldv_func_arg1);
#line 615
  return;
}
}
#line 617 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
void ldv_mutex_unlock_1424(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 620
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 622
  mutex_unlock(ldv_func_arg1);
#line 623
  return;
}
}
#line 625 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
void ldv_mutex_lock_1425(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 628
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 630
  mutex_lock(ldv_func_arg1);
#line 631
  return;
}
}
#line 633 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
int ldv_mutex_trylock_1426(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 637
  tmp = mutex_trylock(ldv_func_arg1);
#line 637
  ldv_func_res = tmp;
#line 639
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 639
  return (tmp___0);
#line 641
  return (ldv_func_res);
}
}
#line 644 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
void ldv_mutex_unlock_1427(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 647
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 649
  mutex_unlock(ldv_func_arg1);
#line 650
  return;
}
}
#line 652 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
void ldv_mutex_unlock_1428(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 655
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 657
  mutex_unlock(ldv_func_arg1);
#line 658
  return;
}
}
#line 660 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
void ldv_mutex_lock_1429(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 663
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 665
  mutex_lock(ldv_func_arg1);
#line 666
  return;
}
}
#line 668 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
void ldv_mutex_lock_1430(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 671
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 673
  mutex_lock(ldv_func_arg1);
#line 674
  return;
}
}
#line 676 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
void ldv_mutex_unlock_1431(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 679
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 681
  mutex_unlock(ldv_func_arg1);
#line 682
  return;
}
}
#line 684 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
void ldv_mutex_unlock_1432(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 687
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 689
  mutex_unlock(ldv_func_arg1);
#line 690
  return;
}
}
#line 692 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
void ldv_mutex_lock_1433(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 695
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 697
  mutex_lock(ldv_func_arg1);
#line 698
  return;
}
}
#line 700 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
int ldv_mutex_lock_interruptible_1434(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 704
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 704
  ldv_func_res = tmp;
#line 706
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 706
  return (tmp___0);
#line 708
  return (ldv_func_res);
}
}
#line 711 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
int ldv_mutex_trylock_1435(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 715
  tmp = mutex_trylock(ldv_func_arg1);
#line 715
  ldv_func_res = tmp;
#line 717
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 717
  return (tmp___0);
#line 719
  return (ldv_func_res);
}
}
#line 743 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
void ldv_mutex_unlock_1438(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 746
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 748
  mutex_unlock(ldv_func_arg1);
#line 749
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_1471(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_1480(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_1469(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_1472(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_1473(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_1476(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_1477(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_1483(struct mutex *ldv_func_arg1 ) ;
#line 209
void ldv_mutex_unlock_1485(struct mutex *ldv_func_arg1 ) ;
#line 213
void ldv_mutex_unlock_1486(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
int ldv_mutex_lock_interruptible_1479(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_1468(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_1470(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_1474(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_1475(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_1478(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_1484(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_1463(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_1465(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_1464(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_1467(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_1466(struct workqueue_struct *ldv_func_arg1 ) ;
#line 598 "include/linux/i2c.h"
extern struct i2c_adapter *i2c_get_adapter(int  ) ;
#line 207 "include/linux/pm_runtime.h"
__inline static int pm_request_idle(struct device *dev ) 
{ 
  int tmp ;

  {
#line 209
  tmp = __pm_runtime_idle(dev, 1);
#line 209
  return (tmp);
}
}
#line 226 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
void oaktrail_lvds_i2c_init(struct drm_encoder *encoder ) ;
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.c"
static void oaktrail_lvds_set_power(struct drm_device *dev , struct gma_encoder *gma_encoder ,
                                    bool on ) 
{ 
  u32 pp_status ;
  struct drm_psb_private *dev_priv ;
  bool tmp ;
  int tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 50
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 52
  tmp = gma_power_begin(dev, 1);
#line 52
  if (tmp) {
#line 52
    tmp___0 = 0;
  } else {
#line 52
    tmp___0 = 1;
  }
#line 52
  if (tmp___0) {
#line 53
    return;
  } else {

  }
#line 55
  if ((int )on) {
#line 56
    tmp___1 = REGISTER_READ(dev, 397828U);
#line 56
    REGISTER_WRITE(dev, 397828U, tmp___1 | 1U);
    ldv_42017: 
#line 59
    pp_status = REGISTER_READ(dev, 397824U);
#line 60
    if ((pp_status & 3221225472U) == 1073741824U) {
#line 62
      goto ldv_42017;
    } else {

    }
#line 61
    dev_priv->is_lvds_on = 1;
#line 62
    if ((unsigned long )(dev_priv->ops)->lvds_bl_power != (unsigned long )((void (*/* const  */)(struct drm_device * ,
                                                                                                 bool  ))0)) {
#line 63
      (*((dev_priv->ops)->lvds_bl_power))(dev, 1);
    } else {

    }
  } else {
#line 65
    if ((unsigned long )(dev_priv->ops)->lvds_bl_power != (unsigned long )((void (*/* const  */)(struct drm_device * ,
                                                                                                 bool  ))0)) {
#line 66
      (*((dev_priv->ops)->lvds_bl_power))(dev, 0);
    } else {

    }
#line 67
    tmp___2 = REGISTER_READ(dev, 397828U);
#line 67
    REGISTER_WRITE(dev, 397828U, tmp___2 & 4294967294U);
    ldv_42019: 
#line 70
    pp_status = REGISTER_READ(dev, 397824U);
#line 71
    if ((int )pp_status < 0) {
#line 73
      goto ldv_42019;
    } else {

    }
#line 72
    dev_priv->is_lvds_on = 0;
#line 73
    pm_request_idle(& (dev->pdev)->dev);
  }
#line 75
  gma_power_end(dev);
#line 76
  return;
}
}
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.c"
static void oaktrail_lvds_dpms(struct drm_encoder *encoder , int mode ) 
{ 
  struct drm_device *dev ;
  struct gma_encoder *gma_encoder ;
  struct drm_encoder  const  *__mptr ;

  {
#line 80
  dev = encoder->dev;
#line 81
  __mptr = (struct drm_encoder  const  *)encoder;
#line 81
  gma_encoder = (struct gma_encoder *)__mptr;
#line 83
  if (mode == 0) {
#line 84
    oaktrail_lvds_set_power(dev, gma_encoder, 1);
  } else {
#line 86
    oaktrail_lvds_set_power(dev, gma_encoder, 0);
  }
#line 87
  return;
}
}
#line 91 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.c"
static void oaktrail_lvds_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                   struct drm_display_mode *adjusted_mode ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  struct drm_mode_config *mode_config ;
  struct drm_connector *connector ;
  struct drm_crtc *crtc ;
  u32 lvds_port ;
  uint64_t v ;
  bool tmp ;
  int tmp___0 ;
  uint32_t tmp___1 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 95
  dev = encoder->dev;
#line 96
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 97
  mode_dev = & dev_priv->mode_dev;
#line 98
  mode_config = & dev->mode_config;
#line 99
  connector = (struct drm_connector *)0;
#line 100
  crtc = encoder->crtc;
#line 102
  v = 1ULL;
#line 104
  tmp = gma_power_begin(dev, 1);
#line 104
  if (tmp) {
#line 104
    tmp___0 = 0;
  } else {
#line 104
    tmp___0 = 1;
  }
#line 104
  if (tmp___0) {
#line 105
    return;
  } else {

  }
#line 112
  tmp___1 = REGISTER_READ(dev, 397696U);
#line 112
  lvds_port = (tmp___1 & 1073709055U) | 2147516416U;
#line 119
  if ((int )mode_dev->panel_wants_dither || (unsigned int )*((unsigned char *)dev_priv + 864UL) != 0U) {
#line 120
    lvds_port = lvds_port | 33554432U;
  } else {

  }
#line 122
  REGISTER_WRITE(dev, 397696U, lvds_port);
#line 125
  __mptr = (struct list_head  const  *)mode_config->connector_list.next;
#line 125
  connector = (struct drm_connector *)__mptr + 0xffffffffffffffe8UL;
#line 125
  goto ldv_42048;
  ldv_42047: ;
#line 126
  if ((unsigned long )connector->encoder == (unsigned long )((struct drm_encoder *)0) || (unsigned long )(connector->encoder)->crtc != (unsigned long )crtc) {

  } else {

  }
#line 125
  __mptr___0 = (struct list_head  const  *)connector->head.next;
#line 125
  connector = (struct drm_connector *)__mptr___0 + 0xffffffffffffffe8UL;
  ldv_42048: ;
#line 125
  if ((unsigned long )(& connector->head) != (unsigned long )(& mode_config->connector_list)) {
#line 127
    goto ldv_42047;
  } else {

  }

#line 130
  if ((unsigned long )connector == (unsigned long )((struct drm_connector *)0)) {
#line 131
    drm_err("Couldn\'t find connector when setting mode");
#line 132
    return;
  } else {

  }
#line 135
  drm_object_property_get_value(& connector->base, dev->mode_config.scaling_mode_property,
                                & v);
#line 140
  if (v == 2ULL) {
#line 141
    REGISTER_WRITE(dev, 397872U, 0U);
  } else
#line 142
  if (v == 3ULL) {
#line 143
    if (mode->vdisplay != adjusted_mode->crtc_vdisplay || mode->hdisplay != adjusted_mode->crtc_hdisplay) {
#line 145
      if (adjusted_mode->crtc_hdisplay * mode->vdisplay == mode->hdisplay * adjusted_mode->crtc_vdisplay) {
#line 147
        REGISTER_WRITE(dev, 397872U, 2147483648U);
      } else
#line 148
      if (adjusted_mode->crtc_hdisplay * mode->vdisplay > mode->hdisplay * adjusted_mode->crtc_vdisplay) {
#line 151
        REGISTER_WRITE(dev, 397872U, 2281701376U);
      } else {
#line 154
        REGISTER_WRITE(dev, 397872U, 2348810240U);
      }
    } else {
#line 157
      REGISTER_WRITE(dev, 397872U, 2147483648U);
    }
  } else {
#line 159
    REGISTER_WRITE(dev, 397872U, 2147483648U);
  }
#line 161
  gma_power_end(dev);
#line 162
  return;
}
}
#line 164 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.c"
static void oaktrail_lvds_prepare(struct drm_encoder *encoder ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_encoder *gma_encoder ;
  struct drm_encoder  const  *__mptr ;
  struct psb_intel_mode_device *mode_dev ;
  bool tmp ;
  int tmp___0 ;

  {
#line 166
  dev = encoder->dev;
#line 167
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 168
  __mptr = (struct drm_encoder  const  *)encoder;
#line 168
  gma_encoder = (struct gma_encoder *)__mptr;
#line 169
  mode_dev = & dev_priv->mode_dev;
#line 171
  tmp = gma_power_begin(dev, 1);
#line 171
  if (tmp) {
#line 171
    tmp___0 = 0;
  } else {
#line 171
    tmp___0 = 1;
  }
#line 171
  if (tmp___0) {
#line 172
    return;
  } else {

  }
#line 174
  mode_dev->saveBLC_PWM_CTL = REGISTER_READ(dev, 397908U);
#line 175
  mode_dev->backlight_duty_cycle = (int )mode_dev->saveBLC_PWM_CTL & 65535;
#line 177
  oaktrail_lvds_set_power(dev, gma_encoder, 0);
#line 178
  gma_power_end(dev);
#line 179
  return;
}
}
#line 181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.c"
static u32 oaktrail_lvds_get_max_backlight(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 ret ;
  uint32_t tmp ;
  bool tmp___0 ;

  {
#line 183
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 186
  tmp___0 = gma_power_begin(dev, 0);
#line 186
  if ((int )tmp___0) {
#line 187
    tmp = REGISTER_READ(dev, 397908U);
#line 187
    ret = (tmp >> 17) * 2U;
#line 191
    gma_power_end(dev);
  } else {
#line 193
    ret = (dev_priv->regs.saveBLC_PWM_CTL >> 17) * 2U;
  }
#line 197
  return (ret);
}
}
#line 200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.c"
static void oaktrail_lvds_commit(struct drm_encoder *encoder ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_encoder *gma_encoder ;
  struct drm_encoder  const  *__mptr ;
  struct psb_intel_mode_device *mode_dev ;
  u32 tmp ;

  {
#line 202
  dev = encoder->dev;
#line 203
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 204
  __mptr = (struct drm_encoder  const  *)encoder;
#line 204
  gma_encoder = (struct gma_encoder *)__mptr;
#line 205
  mode_dev = & dev_priv->mode_dev;
#line 207
  if (mode_dev->backlight_duty_cycle == 0) {
#line 208
    tmp = oaktrail_lvds_get_max_backlight(dev);
#line 208
    mode_dev->backlight_duty_cycle = (int )tmp;
  } else {

  }
#line 210
  oaktrail_lvds_set_power(dev, gma_encoder, 1);
#line 211
  return;
}
}
#line 213 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.c"
static struct drm_encoder_helper_funcs  const  oaktrail_lvds_helper_funcs  = 
#line 213
     {& oaktrail_lvds_dpms, 0, 0, & psb_intel_lvds_mode_fixup, & oaktrail_lvds_prepare,
    & oaktrail_lvds_commit, & oaktrail_lvds_mode_set, 0, 0, 0, 0, 0};
#line 223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.c"
static void oaktrail_lvds_get_configuration_mode(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) 
{ 
  struct drm_display_mode *mode ;
  struct drm_psb_private *dev_priv ;
  struct oaktrail_timing_info *ti ;
  void *tmp ;

  {
#line 226
  mode = (struct drm_display_mode *)0;
#line 227
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 228
  ti = & dev_priv->gct_data.DTD;
#line 230
  mode_dev->panel_fixed_mode = (struct drm_display_mode *)0;
#line 233
  if ((int )dev_priv->has_gct) {
#line 234
    tmp = kzalloc(208UL, 208U);
#line 234
    mode = (struct drm_display_mode *)tmp;
#line 235
    if ((unsigned long )mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 236
      return;
    } else {

    }
#line 238
    mode->hdisplay = ((int )ti->hactive_hi << 8) | (int )ti->hactive_lo;
#line 239
    mode->vdisplay = ((int )ti->vactive_hi << 8) | (int )ti->vactive_lo;
#line 240
    mode->hsync_start = mode->hdisplay + (((int )ti->hsync_offset_hi << 8) | (int )ti->hsync_offset_lo);
#line 243
    mode->hsync_end = mode->hsync_start + (((int )ti->hsync_pulse_width_hi << 8) | (int )ti->hsync_pulse_width_lo);
#line 246
    mode->htotal = mode->hdisplay + (((int )ti->hblank_hi << 8) | (int )ti->hblank_lo);
#line 248
    mode->vsync_start = mode->vdisplay + (((int )ti->vsync_offset_hi << 4) | (int )ti->vsync_offset_lo);
#line 251
    mode->vsync_end = mode->vsync_start + (((int )ti->vsync_pulse_width_hi << 4) | (int )ti->vsync_pulse_width_lo);
#line 254
    mode->vtotal = mode->vdisplay + (((int )ti->vblank_hi << 8) | (int )ti->vblank_lo);
#line 256
    mode->clock = (int )ti->pixel_clock * 10;
#line 268
    mode_dev->panel_fixed_mode = mode;
  } else {

  }
#line 272
  if ((unsigned long )mode_dev->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0) && (unsigned long )mode_dev->vbt_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 273
    mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)mode_dev->vbt_mode);
  } else {

  }
#line 277
  if ((unsigned long )mode_dev->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 278
    if ((unsigned long )dev_priv->lfp_lvds_vbt_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 279
      mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)dev_priv->lfp_lvds_vbt_mode);
    } else {

    }
  } else {

  }
#line 284
  if ((unsigned long )mode_dev->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 285
    return;
  } else {

  }
#line 287
  drm_mode_set_name(mode_dev->panel_fixed_mode);
#line 288
  drm_mode_set_crtcinfo(mode_dev->panel_fixed_mode, 0);
#line 289
  return;
}
}
#line 298 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.c"
void oaktrail_lvds_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_connector *gma_connector ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct drm_psb_private *dev_priv ;
  struct edid *edid ;
  struct i2c_adapter *i2c_adap ;
  struct drm_display_mode *scan ;
  void *tmp ;
  void *tmp___0 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;

  {
#line 305
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 310
  tmp = kzalloc(152UL, 208U);
#line 310
  gma_encoder = (struct gma_encoder *)tmp;
#line 311
  if ((unsigned long )gma_encoder == (unsigned long )((struct gma_encoder *)0)) {
#line 312
    return;
  } else {

  }
#line 314
  tmp___0 = kzalloc(944UL, 208U);
#line 314
  gma_connector = (struct gma_connector *)tmp___0;
#line 315
  if ((unsigned long )gma_connector == (unsigned long )((struct gma_connector *)0)) {
#line 316
    goto failed_connector;
  } else {

  }
#line 318
  connector = & gma_connector->base;
#line 319
  encoder = & gma_encoder->base;
#line 320
  dev_priv->is_lvds_on = 1;
#line 321
  drm_connector_init(dev, connector, & psb_intel_lvds_connector_funcs, 7);
#line 325
  drm_encoder_init(dev, encoder, & psb_intel_lvds_enc_funcs, 3);
#line 328
  gma_connector_attach_encoder(gma_connector, gma_encoder);
#line 329
  gma_encoder->type = 4;
#line 331
  drm_encoder_helper_add(encoder, & oaktrail_lvds_helper_funcs);
#line 332
  drm_connector_helper_add(connector, & psb_intel_lvds_connector_helper_funcs);
#line 334
  connector->display_info.subpixel_order = 1;
#line 335
  connector->interlace_allowed = 0;
#line 336
  connector->doublescan_allowed = 0;
#line 338
  drm_object_attach_property(& connector->base, dev->mode_config.scaling_mode_property,
                             1ULL);
#line 341
  drm_object_attach_property(& connector->base, dev_priv->backlight_property, 100ULL);
#line 345
  mode_dev->panel_wants_dither = 0;
#line 346
  if ((int )dev_priv->has_gct) {
#line 347
    mode_dev->panel_wants_dither = (dev_priv->gct_data.Panel_Port_Control & 33554432U) != 0U;
  } else {

  }
#line 349
  if ((unsigned int )*((unsigned char *)dev_priv + 864UL) != 0U) {
#line 350
    mode_dev->panel_wants_dither = 1;
  } else {

  }
#line 362
  edid = (struct edid *)0;
#line 363
  ldv_mutex_lock_1484(& dev->mode_config.mutex);
#line 364
  i2c_adap = i2c_get_adapter((dev_priv->ops)->i2c_bus);
#line 365
  if ((unsigned long )i2c_adap != (unsigned long )((struct i2c_adapter *)0)) {
#line 366
    edid = drm_get_edid(connector, i2c_adap);
  } else {

  }
#line 367
  if ((unsigned long )edid == (unsigned long )((struct edid *)0) && (unsigned int )dev_priv->lpc_gpio_base != 0U) {
#line 368
    oaktrail_lvds_i2c_init(encoder);
#line 369
    if ((unsigned long )gma_encoder->ddc_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 370
      i2c_adap = & (gma_encoder->ddc_bus)->adapter;
#line 371
      edid = drm_get_edid(connector, i2c_adap);
    } else {

    }
  } else {

  }
#line 378
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
#line 379
    drm_mode_connector_update_edid_property(connector, (struct edid  const  *)edid);
#line 380
    drm_add_edid_modes(connector, edid);
#line 381
    kfree((void const   *)edid);
#line 383
    __mptr = (struct list_head  const  *)connector->probed_modes.next;
#line 383
    scan = (struct drm_display_mode *)__mptr;
#line 383
    goto ldv_42100;
    ldv_42099: ;
#line 384
    if ((scan->type & 8U) != 0U) {
#line 385
      mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)scan);
#line 387
      goto out;
    } else {

    }
#line 383
    __mptr___0 = (struct list_head  const  *)scan->head.next;
#line 383
    scan = (struct drm_display_mode *)__mptr___0;
    ldv_42100: ;
#line 383
    if ((unsigned long )(& scan->head) != (unsigned long )(& connector->probed_modes)) {
#line 385
      goto ldv_42099;
    } else {

    }

  } else {
#line 391
    dev_err((struct device  const  *)dev->dev, "No ddc adapter available!\n");
  }
#line 396
  oaktrail_lvds_get_configuration_mode(dev, mode_dev);
#line 398
  if ((unsigned long )mode_dev->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 399
    (mode_dev->panel_fixed_mode)->type = (mode_dev->panel_fixed_mode)->type | 8U;
#line 400
    goto out;
  } else {

  }
#line 404
  if ((unsigned long )mode_dev->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 405
    dev_err((struct device  const  *)dev->dev, "Found no modes on the lvds, ignoring the LVDS\n");
#line 406
    goto failed_find;
  } else {

  }
  out: 
#line 410
  ldv_mutex_unlock_1485(& dev->mode_config.mutex);
#line 412
  drm_connector_register(connector);
#line 413
  return;
  failed_find: 
#line 416
  ldv_mutex_unlock_1486(& dev->mode_config.mutex);
#line 418
  descriptor.modname = "gma500_gfx";
#line 418
  descriptor.function = "oaktrail_lvds_init";
#line 418
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.c";
#line 418
  descriptor.format = "No LVDS modes found, disabling.\n";
#line 418
  descriptor.lineno = 418U;
#line 418
  descriptor.flags = 0U;
#line 418
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 418
  if (tmp___1 != 0L) {
#line 418
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "No LVDS modes found, disabling.\n");
  } else {

  }
#line 419
  if ((unsigned long )gma_encoder->ddc_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 420
    psb_intel_i2c_destroy(gma_encoder->ddc_bus);
#line 421
    gma_encoder->ddc_bus = (struct psb_intel_i2c_chan *)0;
  } else {

  }
#line 426
  drm_encoder_cleanup(encoder);
#line 427
  drm_connector_cleanup(connector);
#line 428
  kfree((void const   *)gma_connector);
  failed_connector: 
#line 430
  kfree((void const   *)gma_encoder);
#line 431
  return;
}
}
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
void ldv_initialize_drm_encoder_helper_funcs_10(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 406
  tmp = ldv_init_zalloc(96UL);
#line 406
  oaktrail_lvds_helper_funcs_group0 = (struct drm_encoder *)tmp;
#line 407
  tmp___0 = ldv_init_zalloc(208UL);
#line 407
  oaktrail_lvds_helper_funcs_group1 = (struct drm_display_mode *)tmp___0;
#line 408
  return;
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
void ldv_main_exported_10(void) 
{ 
  struct drm_display_mode *ldvarg96 ;
  void *tmp ;
  struct drm_display_mode *ldvarg97 ;
  void *tmp___0 ;
  int ldvarg98 ;
  int tmp___1 ;

  {
#line 411
  tmp = ldv_init_zalloc(208UL);
#line 411
  ldvarg96 = (struct drm_display_mode *)tmp;
#line 412
  tmp___0 = ldv_init_zalloc(208UL);
#line 412
  ldvarg97 = (struct drm_display_mode *)tmp___0;
#line 413
  ldv_memset((void *)(& ldvarg98), 0, 4UL);
#line 415
  tmp___1 = __VERIFIER_nondet_int();
#line 415
  switch (tmp___1) {
  case 0: ;
#line 418
  if (ldv_state_variable_10 == 1) {
#line 420
    oaktrail_lvds_dpms(oaktrail_lvds_helper_funcs_group0, ldvarg98);
#line 422
    ldv_state_variable_10 = 1;
  } else {

  }
#line 425
  goto ldv_42115;
  case 1: ;
#line 428
  if (ldv_state_variable_10 == 1) {
#line 430
    psb_intel_lvds_mode_fixup(oaktrail_lvds_helper_funcs_group0, (struct drm_display_mode  const  *)ldvarg97,
                              oaktrail_lvds_helper_funcs_group1);
#line 432
    ldv_state_variable_10 = 1;
  } else {

  }
#line 435
  goto ldv_42115;
  case 2: ;
#line 438
  if (ldv_state_variable_10 == 1) {
#line 440
    oaktrail_lvds_commit(oaktrail_lvds_helper_funcs_group0);
#line 442
    ldv_state_variable_10 = 1;
  } else {

  }
#line 445
  goto ldv_42115;
  case 3: ;
#line 448
  if (ldv_state_variable_10 == 1) {
#line 450
    oaktrail_lvds_mode_set(oaktrail_lvds_helper_funcs_group0, oaktrail_lvds_helper_funcs_group1,
                           ldvarg96);
#line 452
    ldv_state_variable_10 = 1;
  } else {

  }
#line 455
  goto ldv_42115;
  case 4: ;
#line 458
  if (ldv_state_variable_10 == 1) {
#line 460
    oaktrail_lvds_prepare(oaktrail_lvds_helper_funcs_group0);
#line 462
    ldv_state_variable_10 = 1;
  } else {

  }
#line 465
  goto ldv_42115;
  default: 
#line 466
  ldv_stop();
  }
  ldv_42115: ;
#line 470
  return;
}
}
#line 495 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
bool ldv_queue_work_on_1463(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 499
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 499
  ldv_func_res = tmp;
#line 501
  activate_work_2(ldv_func_arg3, 2);
#line 503
  return (ldv_func_res);
}
}
#line 506 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
bool ldv_queue_delayed_work_on_1464(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 510
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 510
  ldv_func_res = tmp;
#line 512
  activate_work_2(& ldv_func_arg3->work, 2);
#line 514
  return (ldv_func_res);
}
}
#line 517 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
bool ldv_queue_work_on_1465(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 521
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 521
  ldv_func_res = tmp;
#line 523
  activate_work_2(ldv_func_arg3, 2);
#line 525
  return (ldv_func_res);
}
}
#line 528 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
void ldv_flush_workqueue_1466(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 531
  flush_workqueue(ldv_func_arg1);
#line 533
  call_and_disable_all_2(2);
#line 534
  return;
}
}
#line 536 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
bool ldv_queue_delayed_work_on_1467(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 540
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 540
  ldv_func_res = tmp;
#line 542
  activate_work_2(& ldv_func_arg3->work, 2);
#line 544
  return (ldv_func_res);
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
void ldv_mutex_lock_1468(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 550
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 552
  mutex_lock(ldv_func_arg1);
#line 553
  return;
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
void ldv_mutex_unlock_1469(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 558
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 560
  mutex_unlock(ldv_func_arg1);
#line 561
  return;
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
void ldv_mutex_lock_1470(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 566
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 568
  mutex_lock(ldv_func_arg1);
#line 569
  return;
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
int ldv_mutex_trylock_1471(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 575
  tmp = mutex_trylock(ldv_func_arg1);
#line 575
  ldv_func_res = tmp;
#line 577
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 577
  return (tmp___0);
#line 579
  return (ldv_func_res);
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
void ldv_mutex_unlock_1472(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 585
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 587
  mutex_unlock(ldv_func_arg1);
#line 588
  return;
}
}
#line 590 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
void ldv_mutex_unlock_1473(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 593
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 595
  mutex_unlock(ldv_func_arg1);
#line 596
  return;
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
void ldv_mutex_lock_1474(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 601
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 603
  mutex_lock(ldv_func_arg1);
#line 604
  return;
}
}
#line 606 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
void ldv_mutex_lock_1475(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 609
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 611
  mutex_lock(ldv_func_arg1);
#line 612
  return;
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
void ldv_mutex_unlock_1476(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 617
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 619
  mutex_unlock(ldv_func_arg1);
#line 620
  return;
}
}
#line 622 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
void ldv_mutex_unlock_1477(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 625
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 627
  mutex_unlock(ldv_func_arg1);
#line 628
  return;
}
}
#line 630 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
void ldv_mutex_lock_1478(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 633
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 635
  mutex_lock(ldv_func_arg1);
#line 636
  return;
}
}
#line 638 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
int ldv_mutex_lock_interruptible_1479(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 642
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 642
  ldv_func_res = tmp;
#line 644
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 644
  return (tmp___0);
#line 646
  return (ldv_func_res);
}
}
#line 649 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
int ldv_mutex_trylock_1480(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 653
  tmp = mutex_trylock(ldv_func_arg1);
#line 653
  ldv_func_res = tmp;
#line 655
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 655
  return (tmp___0);
#line 657
  return (ldv_func_res);
}
}
#line 681 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
void ldv_mutex_unlock_1483(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 684
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 686
  mutex_unlock(ldv_func_arg1);
#line 687
  return;
}
}
#line 689 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
void ldv_mutex_lock_1484(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 692
  ldv_mutex_lock_mutex_of_drm_mode_config(ldv_func_arg1);
#line 694
  mutex_lock(ldv_func_arg1);
#line 695
  return;
}
}
#line 697 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
void ldv_mutex_unlock_1485(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 700
  ldv_mutex_unlock_mutex_of_drm_mode_config(ldv_func_arg1);
#line 702
  mutex_unlock(ldv_func_arg1);
#line 703
  return;
}
}
#line 705 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
void ldv_mutex_unlock_1486(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 708
  ldv_mutex_unlock_mutex_of_drm_mode_config(ldv_func_arg1);
#line 710
  mutex_unlock(ldv_func_arg1);
#line 711
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_1522(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_1531(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_1520(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_1523(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_1524(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_1527(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_1528(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_1534(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.o.c.prepared"
int ldv_mutex_lock_interruptible_1530(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_1519(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_1521(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_1525(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_1526(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_1529(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_1514(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_1516(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_1515(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_1518(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_1517(struct workqueue_struct *ldv_func_arg1 ) ;
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.c"
static int get_clock___1(void *data ) 
{ 
  struct psb_intel_i2c_chan *chan ;
  u32 val ;
  u32 tmp ;
  unsigned int tmp___0 ;

  {
#line 69
  chan = (struct psb_intel_i2c_chan *)data;
#line 72
  val = inl((int )(chan->reg + 36U));
#line 73
  val = val | 8U;
#line 74
  outl(val, (int )(chan->reg + 36U));
#line 75
  tmp = inl((int )(chan->reg + 40U));
#line 76
  tmp___0 = inl((int )(chan->reg + 40U));
#line 76
  val = (tmp___0 & 8U) != 0U;
#line 78
  return ((int )val);
}
}
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.c"
static int get_data___1(void *data ) 
{ 
  struct psb_intel_i2c_chan *chan ;
  u32 val ;
  u32 tmp ;
  unsigned int tmp___0 ;

  {
#line 83
  chan = (struct psb_intel_i2c_chan *)data;
#line 86
  val = inl((int )(chan->reg + 36U));
#line 87
  val = val | 16U;
#line 88
  outl(val, (int )(chan->reg + 36U));
#line 89
  tmp = inl((int )(chan->reg + 40U));
#line 90
  tmp___0 = inl((int )(chan->reg + 40U));
#line 90
  val = (tmp___0 & 16U) != 0U;
#line 92
  return ((int )val);
}
}
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.c"
static void set_clock___1(void *data , int state_high ) 
{ 
  struct psb_intel_i2c_chan *chan ;
  u32 val ;

  {
#line 97
  chan = (struct psb_intel_i2c_chan *)data;
#line 100
  if (state_high != 0) {
#line 101
    val = inl((int )(chan->reg + 36U));
#line 102
    val = val | 8U;
#line 103
    outl(val, (int )(chan->reg + 36U));
  } else {
#line 105
    val = inl((int )(chan->reg + 36U));
#line 106
    val = val & 4294967287U;
#line 107
    outl(val, (int )(chan->reg + 36U));
#line 108
    val = inl((int )(chan->reg + 40U));
#line 109
    val = val & 4294967287U;
#line 110
    outl(val, (int )(chan->reg + 40U));
  }
#line 112
  return;
}
}
#line 114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.c"
static void set_data___1(void *data , int state_high ) 
{ 
  struct psb_intel_i2c_chan *chan ;
  u32 val ;

  {
#line 116
  chan = (struct psb_intel_i2c_chan *)data;
#line 119
  if (state_high != 0) {
#line 120
    val = inl((int )(chan->reg + 36U));
#line 121
    val = val | 16U;
#line 122
    outl(val, (int )(chan->reg + 36U));
  } else {
#line 124
    val = inl((int )(chan->reg + 36U));
#line 125
    val = val & 4294967279U;
#line 126
    outl(val, (int )(chan->reg + 36U));
#line 127
    val = inl((int )(chan->reg + 40U));
#line 128
    val = val & 4294967279U;
#line 129
    outl(val, (int )(chan->reg + 40U));
  }
#line 131
  return;
}
}
#line 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.c"
void oaktrail_lvds_i2c_init(struct drm_encoder *encoder ) 
{ 
  struct drm_device *dev ;
  struct gma_encoder *gma_encoder ;
  struct drm_encoder  const  *__mptr ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_i2c_chan *chan ;
  void *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 135
  dev = encoder->dev;
#line 136
  __mptr = (struct drm_encoder  const  *)encoder;
#line 136
  gma_encoder = (struct gma_encoder *)__mptr;
#line 137
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 140
  tmp = kzalloc(2024UL, 208U);
#line 140
  chan = (struct psb_intel_i2c_chan *)tmp;
#line 141
  if ((unsigned long )chan == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 142
    return;
  } else {

  }
#line 144
  chan->drm_dev = dev;
#line 145
  chan->reg = (u32 )dev_priv->lpc_gpio_base;
#line 146
  strncpy((char *)(& chan->adapter.name), "gma500 LPC", 19UL);
#line 147
  chan->adapter.owner = & __this_module;
#line 148
  chan->adapter.algo_data = (void *)(& chan->algo);
#line 149
  chan->adapter.dev.parent = & (dev->pdev)->dev;
#line 150
  chan->algo.setsda = & set_data___1;
#line 151
  chan->algo.setscl = & set_clock___1;
#line 152
  chan->algo.getsda = & get_data___1;
#line 153
  chan->algo.getscl = & get_clock___1;
#line 154
  chan->algo.udelay = 100;
#line 155
  tmp___0 = usecs_to_jiffies(2200U);
#line 155
  chan->algo.timeout = (int )tmp___0;
#line 156
  chan->algo.data = (void *)chan;
#line 158
  i2c_set_adapdata(& chan->adapter, (void *)chan);
#line 160
  set_data___1((void *)chan, 1);
#line 161
  set_clock___1((void *)chan, 1);
#line 162
  __const_udelay(214750UL);
#line 164
  tmp___1 = i2c_bit_add_bus(& chan->adapter);
#line 164
  if (tmp___1 != 0) {
#line 165
    kfree((void const   *)chan);
#line 166
    return;
  } else {

  }
#line 169
  gma_encoder->ddc_bus = chan;
#line 170
  return;
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.o.c.prepared"
bool ldv_queue_work_on_1514(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 432
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 432
  ldv_func_res = tmp;
#line 434
  activate_work_2(ldv_func_arg3, 2);
#line 436
  return (ldv_func_res);
}
}
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.o.c.prepared"
bool ldv_queue_delayed_work_on_1515(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 443
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 443
  ldv_func_res = tmp;
#line 445
  activate_work_2(& ldv_func_arg3->work, 2);
#line 447
  return (ldv_func_res);
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.o.c.prepared"
bool ldv_queue_work_on_1516(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 454
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 454
  ldv_func_res = tmp;
#line 456
  activate_work_2(ldv_func_arg3, 2);
#line 458
  return (ldv_func_res);
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.o.c.prepared"
void ldv_flush_workqueue_1517(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 464
  flush_workqueue(ldv_func_arg1);
#line 466
  call_and_disable_all_2(2);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.o.c.prepared"
bool ldv_queue_delayed_work_on_1518(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 473
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 473
  ldv_func_res = tmp;
#line 475
  activate_work_2(& ldv_func_arg3->work, 2);
#line 477
  return (ldv_func_res);
}
}
#line 480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.o.c.prepared"
void ldv_mutex_lock_1519(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 483
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 485
  mutex_lock(ldv_func_arg1);
#line 486
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.o.c.prepared"
void ldv_mutex_unlock_1520(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 491
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 493
  mutex_unlock(ldv_func_arg1);
#line 494
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.o.c.prepared"
void ldv_mutex_lock_1521(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 499
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 501
  mutex_lock(ldv_func_arg1);
#line 502
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.o.c.prepared"
int ldv_mutex_trylock_1522(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 508
  tmp = mutex_trylock(ldv_func_arg1);
#line 508
  ldv_func_res = tmp;
#line 510
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 510
  return (tmp___0);
#line 512
  return (ldv_func_res);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.o.c.prepared"
void ldv_mutex_unlock_1523(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 518
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 520
  mutex_unlock(ldv_func_arg1);
#line 521
  return;
}
}
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.o.c.prepared"
void ldv_mutex_unlock_1524(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 526
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 528
  mutex_unlock(ldv_func_arg1);
#line 529
  return;
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.o.c.prepared"
void ldv_mutex_lock_1525(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 534
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 536
  mutex_lock(ldv_func_arg1);
#line 537
  return;
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.o.c.prepared"
void ldv_mutex_lock_1526(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 542
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 544
  mutex_lock(ldv_func_arg1);
#line 545
  return;
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.o.c.prepared"
void ldv_mutex_unlock_1527(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 550
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 552
  mutex_unlock(ldv_func_arg1);
#line 553
  return;
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.o.c.prepared"
void ldv_mutex_unlock_1528(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 558
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 560
  mutex_unlock(ldv_func_arg1);
#line 561
  return;
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.o.c.prepared"
void ldv_mutex_lock_1529(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 566
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 568
  mutex_lock(ldv_func_arg1);
#line 569
  return;
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.o.c.prepared"
int ldv_mutex_lock_interruptible_1530(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 575
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 575
  ldv_func_res = tmp;
#line 577
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 577
  return (tmp___0);
#line 579
  return (ldv_func_res);
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.o.c.prepared"
int ldv_mutex_trylock_1531(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 586
  tmp = mutex_trylock(ldv_func_arg1);
#line 586
  ldv_func_res = tmp;
#line 588
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 588
  return (tmp___0);
#line 590
  return (ldv_func_res);
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.o.c.prepared"
void ldv_mutex_unlock_1534(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 617
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 619
  mutex_unlock(ldv_func_arg1);
#line 620
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_1567(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_1576(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_1565(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_1568(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_1569(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_1572(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_1573(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_1579(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
int ldv_mutex_lock_interruptible_1575(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_1564(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_1566(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_1570(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_1571(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_1574(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_1559(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_1561(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_1560(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_1563(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_1562(struct workqueue_struct *ldv_func_arg1 ) ;
#line 66 "./arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 


  {
#line 66
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
#line 67
  return;
}
}
#line 841 "include/linux/pci.h"
extern struct pci_dev *pci_get_device(unsigned int  , unsigned int  , struct pci_dev * ) ;
#line 1473 "include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 


  {
#line 1475
  dev_set_drvdata(& pdev->dev, data);
#line 1476
  return;
}
}
#line 247 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/gpu/drm/gma500/oaktrail.h"
int oaktrail_hdmi_i2c_init(struct pci_dev *dev ) ;
#line 248
void oaktrail_hdmi_i2c_exit(struct pci_dev *dev ) ;
#line 121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
static struct oaktrail_hdmi_limit  const  oaktrail_hdmi_limit  =    {{320000, 1650000}, {1, 15}, {1, 64}, {2, 4095}};
#line 128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
static void oaktrail_hdmi_audio_enable(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct oaktrail_hdmi_dev *hdmi_dev ;

  {
#line 130
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 131
  hdmi_dev = dev_priv->hdmi_priv;
#line 133
  writel(103U, (void volatile   *)hdmi_dev->regs + 4096U);
#line 134
  readl((void const volatile   *)hdmi_dev->regs + 4096U);
#line 136
  writel(16U, (void volatile   *)hdmi_dev->regs + 20904U);
#line 137
  readl((void const volatile   *)hdmi_dev->regs + 20904U);
#line 139
  writel(1U, (void volatile   *)hdmi_dev->regs + 16384U);
#line 140
  readl((void const volatile   *)hdmi_dev->regs + 16384U);
#line 141
  return;
}
}
#line 143 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
static void oaktrail_hdmi_audio_disable(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct oaktrail_hdmi_dev *hdmi_dev ;

  {
#line 145
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 146
  hdmi_dev = dev_priv->hdmi_priv;
#line 148
  writel(0U, (void volatile   *)hdmi_dev->regs + 20904U);
#line 149
  readl((void const volatile   *)hdmi_dev->regs + 20904U);
#line 151
  writel(0U, (void volatile   *)hdmi_dev->regs + 16384U);
#line 152
  readl((void const volatile   *)hdmi_dev->regs + 16384U);
#line 154
  writel(71U, (void volatile   *)hdmi_dev->regs + 4096U);
#line 155
  readl((void const volatile   *)hdmi_dev->regs + 4096U);
#line 156
  return;
}
}
#line 158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
static unsigned int htotal_calculate(struct drm_display_mode *mode ) 
{ 
  u32 htotal ;
  u32 new_crtc_htotal ;
  long tmp ;

  {
#line 162
  htotal = (u32 )((mode->crtc_hdisplay + -1) | ((mode->crtc_htotal + -1) << 16));
#line 168
  new_crtc_htotal = (u32 )(((mode->crtc_htotal + -1) * 200000) / mode->clock);
#line 170
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 170
  if (tmp != 0L) {
#line 170
    drm_ut_debug_printk("htotal_calculate", "new crtc htotal 0x%4x\n", new_crtc_htotal);
  } else {

  }
#line 171
  return ((u32 )(mode->crtc_hdisplay + -1) | (new_crtc_htotal << 16));
}
}
#line 174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
static void oaktrail_hdmi_find_dpll(struct drm_crtc *crtc , int target , int refclk ,
                                    struct oaktrail_hdmi_clock *best_clock ) 
{ 
  int np_min ;
  int np_max ;
  int nr_min ;
  int nr_max ;
  int np ;
  int nr ;
  int nf ;
  int __x ;
  int __d ;
  long tmp ;

  {
#line 180
  np_min = (((int )oaktrail_hdmi_limit.vco.min + target * 10) + -1) / (target * 10);
#line 181
  np_max = (int )oaktrail_hdmi_limit.vco.max / (target * 10);
#line 182
  if ((int )oaktrail_hdmi_limit.np.min > np_min) {
#line 183
    np_min = oaktrail_hdmi_limit.np.min;
  } else {

  }
#line 184
  if ((int )oaktrail_hdmi_limit.np.max < np_max) {
#line 185
    np_max = oaktrail_hdmi_limit.np.max;
  } else {

  }
#line 187
  nr_min = ((refclk * 1000 + (target * 10) * np_max) + -1) / ((target * 10) * np_max);
#line 188
  nr_max = ((refclk * 1000 + (target * 10) * np_min) + -1) / ((target * 10) * np_min);
#line 189
  if ((int )oaktrail_hdmi_limit.nr.min > nr_min) {
#line 190
    nr_min = oaktrail_hdmi_limit.nr.min;
  } else {

  }
#line 191
  if ((int )oaktrail_hdmi_limit.nr.max < nr_max) {
#line 192
    nr_max = oaktrail_hdmi_limit.nr.max;
  } else {

  }
#line 194
  np = ((refclk * 1000 + (target * 10) * nr_max) + -1) / ((target * 10) * nr_max);
#line 195
  nr = ((refclk * 1000 + (target * 10) * np) + -1) / ((target * 10) * np);
#line 196
  __x = ((target * 10) * np) * nr;
#line 196
  __d = refclk;
#line 196
  nf = __x > 0 ? (__d / 2 + __x) / __d : (__x - __d / 2) / __d;
#line 197
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 197
  if (tmp != 0L) {
#line 197
    drm_ut_debug_printk("oaktrail_hdmi_find_dpll", "np, nr, nf %d %d %d\n", np, nr,
                        nf);
  } else {

  }
#line 203
  best_clock->np = np;
#line 204
  best_clock->nr = nr + -1;
#line 205
  best_clock->nf = nf << 14;
#line 206
  return;
}
}
#line 208 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
static void scu_busy_loop(void *scu_base ) 
{ 
  u32 status ;
  u32 loop_count ;
  long tmp ;

  {
#line 210
  status = 0U;
#line 211
  loop_count = 0U;
#line 213
  status = readl((void const volatile   *)scu_base + 4U);
#line 214
  goto ldv_41948;
  ldv_41947: 
#line 215
  __const_udelay(4295UL);
#line 216
  status = readl((void const volatile   *)scu_base + 4U);
#line 217
  loop_count = loop_count + 1U;
#line 219
  if (loop_count > 1000U) {
#line 220
    tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 220
    if (tmp != 0L) {
#line 220
      drm_ut_debug_printk("scu_busy_loop", "SCU IPC timed out");
    } else {

    }
#line 221
    return;
  } else {

  }
  ldv_41948: ;
#line 214
  if ((int )status & 1) {
#line 216
    goto ldv_41947;
  } else {

  }

#line 221
  return;
}
}
#line 232 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
static void oaktrail_hdmi_reset(struct drm_device *dev ) 
{ 
  void *base ;
  unsigned long scu_ipc_mmio ;
  int scu_len ;

  {
#line 235
  scu_ipc_mmio = 4279353344UL;
#line 236
  scu_len = 1024;
#line 238
  base = ioremap((unsigned long long )scu_ipc_mmio, (unsigned long )scu_len);
#line 239
  if ((unsigned long )base == (unsigned long )((void *)0)) {
#line 240
    drm_err("failed to map scu mmio\n");
#line 241
    return;
  } else {

  }
#line 245
  writel(4279357720U, (void volatile   *)base + 12U);
#line 246
  writel(2147483615U, (void volatile   *)base + 128U);
#line 247
  writel(270341U, (void volatile   *)base);
#line 248
  scu_busy_loop(base);
#line 251
  writel(4279357720U, (void volatile   *)base + 12U);
#line 252
  writel(2147483647U, (void volatile   *)base + 128U);
#line 253
  writel(270341U, (void volatile   *)base);
#line 254
  scu_busy_loop(base);
#line 256
  iounmap((void volatile   *)base);
#line 257
  return;
}
}
#line 259 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
int oaktrail_crtc_hdmi_mode_set(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                                struct drm_display_mode *adjusted_mode , int x , int y ,
                                struct drm_framebuffer *old_fb ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct oaktrail_hdmi_dev *hdmi_dev ;
  int pipe ;
  int htot_reg ;
  int hblank_reg ;
  int hsync_reg ;
  int vtot_reg ;
  int vblank_reg ;
  int vsync_reg ;
  int dspsize_reg ;
  int dsppos_reg ;
  int pipesrc_reg ;
  int pipeconf_reg ;
  int refclk ;
  struct oaktrail_hdmi_clock clock ;
  u32 dspcntr ;
  u32 pipeconf ;
  u32 dpll ;
  u32 temp ;
  int dspcntr_reg ;
  bool tmp ;
  int tmp___0 ;
  struct drm_crtc_helper_funcs  const  *crtc_funcs ;

  {
#line 265
  dev = crtc->dev;
#line 266
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 267
  hdmi_dev = dev_priv->hdmi_priv;
#line 268
  pipe = 1;
#line 269
  htot_reg = pipe == 0 ? 393216 : 397312;
#line 270
  hblank_reg = pipe == 0 ? 393220 : 397316;
#line 271
  hsync_reg = pipe == 0 ? 393224 : 397320;
#line 272
  vtot_reg = pipe == 0 ? 393228 : 397324;
#line 273
  vblank_reg = pipe == 0 ? 393232 : 397328;
#line 274
  vsync_reg = pipe == 0 ? 393236 : 397332;
#line 275
  dspsize_reg = pipe == 0 ? 459152 : 463248;
#line 276
  dsppos_reg = pipe == 0 ? 459148 : 463244;
#line 277
  pipesrc_reg = pipe == 0 ? 393244 : 397340;
#line 278
  pipeconf_reg = pipe == 0 ? 458760 : 462856;
#line 282
  dspcntr_reg = 463232;
#line 284
  tmp = gma_power_begin(dev, 1);
#line 284
  if (tmp) {
#line 284
    tmp___0 = 0;
  } else {
#line 284
    tmp___0 = 1;
  }
#line 284
  if (tmp___0) {
#line 285
    return (0);
  } else {

  }
#line 288
  REGISTER_WRITE(dev, 463872U, 2147483648U);
#line 291
  dpll = REGISTER_READ(dev, 24576U);
#line 292
  if ((dpll & 16U) == 0U) {
#line 293
    REGISTER_WRITE(dev, 24576U, dpll | 24U);
#line 294
    REGISTER_WRITE(dev, 24580U, 0U);
#line 295
    REGISTER_WRITE(dev, 24592U, 1U);
  } else {

  }
#line 297
  __const_udelay(644250UL);
#line 300
  oaktrail_hdmi_reset(dev);
#line 303
  refclk = 25000;
#line 304
  oaktrail_hdmi_find_dpll(crtc, adjusted_mode->clock, refclk, & clock);
#line 307
  dpll = REGISTER_READ(dev, 24576U);
#line 308
  dpll = dpll & 4293984255U;
#line 309
  dpll = dpll & 4294967271U;
#line 310
  REGISTER_WRITE(dev, 24576U, 8U);
#line 311
  REGISTER_WRITE(dev, 24580U, (uint32_t )((clock.nf << 6) | clock.nr));
#line 312
  REGISTER_WRITE(dev, 24588U, (uint32_t )((clock.nf >> 14) + -1));
#line 313
  REGISTER_WRITE(dev, 24576U, ((u32 )(clock.np << 16) | dpll) | 3U);
#line 314
  REGISTER_WRITE(dev, 24596U, 2147483648U);
#line 315
  REGISTER_WRITE(dev, 24584U, 2147811586U);
#line 316
  __const_udelay(644250UL);
#line 319
  writel(509U, (void volatile   *)hdmi_dev->regs + 4100U);
#line 320
  writel(1U, (void volatile   *)hdmi_dev->regs + 8192U);
#line 321
  writel(0U, (void volatile   *)hdmi_dev->regs + 8200U);
#line 322
  writel(8U, (void volatile   *)hdmi_dev->regs + 12592U);
#line 323
  writel(25167888U, (void volatile   *)hdmi_dev->regs + 4124U);
#line 325
  temp = htotal_calculate(adjusted_mode);
#line 326
  REGISTER_WRITE(dev, (uint32_t )htot_reg, temp);
#line 327
  REGISTER_WRITE(dev, (uint32_t )hblank_reg, (uint32_t )((adjusted_mode->crtc_hblank_start + -1) | ((adjusted_mode->crtc_hblank_end + -1) << 16)));
#line 328
  REGISTER_WRITE(dev, (uint32_t )hsync_reg, (uint32_t )((adjusted_mode->crtc_hsync_start + -1) | ((adjusted_mode->crtc_hsync_end + -1) << 16)));
#line 329
  REGISTER_WRITE(dev, (uint32_t )vtot_reg, (uint32_t )((adjusted_mode->crtc_vdisplay + -1) | ((adjusted_mode->crtc_vtotal + -1) << 16)));
#line 330
  REGISTER_WRITE(dev, (uint32_t )vblank_reg, (uint32_t )((adjusted_mode->crtc_vblank_start + -1) | ((adjusted_mode->crtc_vblank_end + -1) << 16)));
#line 331
  REGISTER_WRITE(dev, (uint32_t )vsync_reg, (uint32_t )((adjusted_mode->crtc_vsync_start + -1) | ((adjusted_mode->crtc_vsync_end + -1) << 16)));
#line 332
  REGISTER_WRITE(dev, (uint32_t )pipesrc_reg, (uint32_t )(((mode->crtc_hdisplay + -1) << 16) | (mode->crtc_vdisplay + -1)));
#line 334
  REGISTER_WRITE(dev, 12544U, (uint32_t )((adjusted_mode->crtc_hdisplay + -1) | ((adjusted_mode->crtc_htotal + -1) << 16)));
#line 335
  REGISTER_WRITE(dev, 12548U, (uint32_t )((adjusted_mode->crtc_hblank_start + -1) | ((adjusted_mode->crtc_hblank_end + -1) << 16)));
#line 336
  REGISTER_WRITE(dev, 12552U, (uint32_t )((adjusted_mode->crtc_hsync_start + -1) | ((adjusted_mode->crtc_hsync_end + -1) << 16)));
#line 337
  REGISTER_WRITE(dev, 12556U, (uint32_t )((adjusted_mode->crtc_vdisplay + -1) | ((adjusted_mode->crtc_vtotal + -1) << 16)));
#line 338
  REGISTER_WRITE(dev, 12560U, (uint32_t )((adjusted_mode->crtc_vblank_start + -1) | ((adjusted_mode->crtc_vblank_end + -1) << 16)));
#line 339
  REGISTER_WRITE(dev, 12564U, (uint32_t )((adjusted_mode->crtc_vsync_start + -1) | ((adjusted_mode->crtc_vsync_end + -1) << 16)));
#line 340
  REGISTER_WRITE(dev, 12572U, (uint32_t )(((mode->crtc_hdisplay + -1) << 16) | (mode->crtc_vdisplay + -1)));
#line 342
  temp = (u32 )(adjusted_mode->crtc_hblank_end - adjusted_mode->crtc_hblank_start);
#line 343
  writel((u32 )((adjusted_mode->crtc_hdisplay + -1) << 16) | temp, (void volatile   *)hdmi_dev->regs + 12544U);
#line 345
  REGISTER_WRITE(dev, (uint32_t )dspsize_reg, (uint32_t )(((mode->vdisplay + -1) << 16) | (mode->hdisplay + -1)));
#line 346
  REGISTER_WRITE(dev, (uint32_t )dsppos_reg, 0U);
#line 350
  crtc_funcs = (struct drm_crtc_helper_funcs  const  *)crtc->helper_private;
#line 351
  (*(crtc_funcs->mode_set_base))(crtc, x, y, old_fb);
#line 355
  dspcntr = REGISTER_READ(dev, (uint32_t )dspcntr_reg);
#line 356
  dspcntr = dspcntr | 1073741824U;
#line 357
  dspcntr = dspcntr | 16777216U;
#line 358
  dspcntr = dspcntr | 2147483648U;
#line 361
  pipeconf = REGISTER_READ(dev, (uint32_t )pipeconf_reg);
#line 362
  pipeconf = pipeconf | 2147483648U;
#line 364
  REGISTER_WRITE(dev, (uint32_t )pipeconf_reg, pipeconf);
#line 365
  REGISTER_READ(dev, (uint32_t )pipeconf_reg);
#line 367
  REGISTER_WRITE(dev, 14344U, pipeconf);
#line 368
  REGISTER_READ(dev, 14344U);
#line 369
  gma_wait_for_vblank(dev);
#line 371
  REGISTER_WRITE(dev, (uint32_t )dspcntr_reg, dspcntr);
#line 372
  gma_wait_for_vblank(dev);
#line 374
  gma_power_end(dev);
#line 376
  return (0);
}
}
#line 379 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
void oaktrail_crtc_hdmi_dpms(struct drm_crtc *crtc , int mode ) 
{ 
  struct drm_device *dev ;
  u32 temp ;
  long tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 381
  dev = crtc->dev;
#line 384
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 384
  if (tmp != 0L) {
#line 384
    drm_ut_debug_printk("oaktrail_crtc_hdmi_dpms", "%s %d\n", "oaktrail_crtc_hdmi_dpms",
                        mode);
  } else {

  }
#line 386
  switch (mode) {
  case 3: 
#line 388
  REGISTER_WRITE(dev, 463872U, 2147483648U);
#line 391
  temp = REGISTER_READ(dev, 463232U);
#line 392
  if ((int )temp < 0) {
#line 393
    REGISTER_WRITE(dev, 463232U, temp & 2147483647U);
#line 394
    REGISTER_READ(dev, 463232U);
#line 396
    tmp___0 = REGISTER_READ(dev, 463260U);
#line 396
    REGISTER_WRITE(dev, 463260U, tmp___0);
#line 397
    REGISTER_READ(dev, 463260U);
  } else {

  }
#line 401
  temp = REGISTER_READ(dev, 462856U);
#line 402
  if ((int )temp < 0) {
#line 403
    REGISTER_WRITE(dev, 462856U, temp & 2147483647U);
#line 404
    REGISTER_READ(dev, 462856U);
  } else {

  }
#line 408
  temp = REGISTER_READ(dev, 14344U);
#line 409
  if ((int )temp < 0) {
#line 410
    REGISTER_WRITE(dev, 14344U, temp & 2147483647U);
#line 411
    REGISTER_READ(dev, 14344U);
  } else {

  }
#line 415
  __const_udelay(644250UL);
#line 418
  temp = REGISTER_READ(dev, 24576U);
#line 419
  if ((temp & 16U) == 0U) {
#line 420
    REGISTER_WRITE(dev, 24576U, temp | 24U);
#line 421
    REGISTER_WRITE(dev, 24592U, 1U);
  } else {

  }
#line 425
  __const_udelay(644250UL);
#line 427
  goto ldv_41994;
  case 0: ;
  case 1: ;
  case 2: 
#line 432
  temp = REGISTER_READ(dev, 24576U);
#line 433
  if ((temp & 16U) != 0U) {
#line 434
    REGISTER_WRITE(dev, 24576U, temp & 4294967271U);
#line 435
    temp = REGISTER_READ(dev, 24584U);
#line 436
    REGISTER_WRITE(dev, 24584U, temp | 2147483906U);
#line 437
    REGISTER_READ(dev, 24584U);
  } else {

  }
#line 440
  __const_udelay(644250UL);
#line 443
  temp = REGISTER_READ(dev, 462856U);
#line 444
  if ((int )temp >= 0) {
#line 445
    REGISTER_WRITE(dev, 462856U, temp | 2147483648U);
#line 446
    REGISTER_READ(dev, 462856U);
  } else {

  }
#line 450
  temp = REGISTER_READ(dev, 14344U);
#line 451
  if ((int )temp >= 0) {
#line 452
    REGISTER_WRITE(dev, 14344U, temp | 2147483648U);
#line 453
    REGISTER_READ(dev, 14344U);
  } else {

  }
#line 456
  gma_wait_for_vblank(dev);
#line 459
  temp = REGISTER_READ(dev, 463232U);
#line 460
  if ((int )temp >= 0) {
#line 461
    REGISTER_WRITE(dev, 463232U, temp | 2147483648U);
#line 463
    tmp___1 = REGISTER_READ(dev, 463260U);
#line 463
    REGISTER_WRITE(dev, 463260U, tmp___1);
#line 464
    REGISTER_READ(dev, 463260U);
  } else {

  }
#line 467
  gma_crtc_load_lut(crtc);
  }
  ldv_41994: 
#line 471
  REGISTER_WRITE(dev, 458800U, 16319U);
#line 474
  REGISTER_WRITE(dev, 458804U, 1065880074U);
#line 477
  REGISTER_WRITE(dev, 458808U, 184944648U);
#line 480
  REGISTER_WRITE(dev, 458832U, 134415364U);
#line 483
  REGISTER_WRITE(dev, 458836U, 67372036U);
#line 486
  REGISTER_WRITE(dev, 459776U, 16384U);
#line 488
  return;
}
}
#line 491 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
static void oaktrail_hdmi_dpms(struct drm_encoder *encoder , int mode ) 
{ 
  int dpms_mode ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct oaktrail_hdmi_dev *hdmi_dev ;
  u32 temp ;

  {
#line 493
  dpms_mode = -1;
#line 495
  dev = encoder->dev;
#line 496
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 497
  hdmi_dev = dev_priv->hdmi_priv;
#line 500
  if (dpms_mode == mode) {
#line 501
    return;
  } else {

  }
#line 503
  if (mode != 0) {
#line 504
    temp = 0U;
  } else {
#line 506
    temp = 153U;
  }
#line 508
  dpms_mode = mode;
#line 509
  writel(temp, (void volatile   *)hdmi_dev->regs + 12288U);
#line 510
  return;
}
}
#line 512 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
static int oaktrail_hdmi_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode ) 
{ 


  {
#line 515
  if (mode->clock > 165000) {
#line 516
    return (15);
  } else {

  }
#line 517
  if (mode->clock <= 19999) {
#line 518
    return (16);
  } else {

  }
#line 520
  if ((mode->flags & 32U) != 0U) {
#line 521
    return (8);
  } else {

  }
#line 523
  return (0);
}
}
#line 527 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
static enum drm_connector_status oaktrail_hdmi_detect(struct drm_connector *connector ,
                                                      bool force ) 
{ 
  enum drm_connector_status status ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct oaktrail_hdmi_dev *hdmi_dev ;
  u32 temp ;
  long tmp ;

  {
#line 530
  dev = connector->dev;
#line 531
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 532
  hdmi_dev = dev_priv->hdmi_priv;
#line 535
  temp = readl((void const volatile   *)hdmi_dev->regs + 4104U);
#line 536
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 536
  if (tmp != 0L) {
#line 536
    drm_ut_debug_printk("oaktrail_hdmi_detect", "HDMI_HSR %x\n", temp);
  } else {

  }
#line 538
  if ((int )temp & 1) {
#line 539
    status = 1;
  } else {
#line 541
    status = 2;
  }
#line 543
  return (status);
}
}
#line 546 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
static unsigned char const   raw_edid[128U]  = 
#line 546
  {      0U,      255U,      255U,      255U, 
        255U,      255U,      255U,      0U, 
        16U,      172U,      47U,      160U, 
        83U,      85U,      51U,      48U, 
        22U,      19U,      1U,      3U, 
        14U,      58U,      36U,      120U, 
        234U,      233U,      245U,      172U, 
        81U,      48U,      180U,      37U, 
        17U,      80U,      84U,      165U, 
        75U,      0U,      129U,      128U, 
        169U,      64U,      113U,      79U, 
        179U,      0U,      1U,      1U, 
        1U,      1U,      1U,      1U, 
        1U,      1U,      40U,      60U, 
        128U,      160U,      112U,      176U, 
        35U,      64U,      48U,      32U, 
        54U,      0U,      70U,      108U, 
        33U,      0U,      0U,      26U, 
        0U,      0U,      0U,      255U, 
        0U,      71U,      78U,      55U, 
        50U,      49U,      57U,      53U, 
        82U,      48U,      51U,      85U, 
        83U,      10U,      0U,      0U, 
        0U,      252U,      0U,      68U, 
        69U,      76U,      76U,      32U, 
        50U,      55U,      48U,      57U, 
        87U,      10U,      32U,      32U, 
        0U,      0U,      0U,      253U, 
        0U,      56U,      76U,      30U, 
        83U,      17U,      0U,      10U, 
        32U,      32U,      32U,      32U, 
        32U,      32U,      0U,      141U};
#line 560 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
static int oaktrail_hdmi_get_modes(struct drm_connector *connector ) 
{ 
  struct i2c_adapter *i2c_adap ;
  struct edid *edid ;
  int ret ;

  {
#line 564
  ret = 0;
#line 571
  i2c_adap = i2c_get_adapter(3);
#line 572
  if ((unsigned long )i2c_adap == (unsigned long )((struct i2c_adapter *)0)) {
#line 573
    drm_err("No ddc adapter available!\n");
#line 574
    edid = (struct edid *)(& raw_edid);
  } else {
#line 576
    edid = (struct edid *)(& raw_edid);
  }
#line 580
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
#line 581
    drm_mode_connector_update_edid_property(connector, (struct edid  const  *)edid);
#line 582
    ret = drm_add_edid_modes(connector, edid);
  } else {

  }
#line 584
  return (ret);
}
}
#line 587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
static void oaktrail_hdmi_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                   struct drm_display_mode *adjusted_mode ) 
{ 
  struct drm_device *dev ;

  {
#line 591
  dev = encoder->dev;
#line 593
  oaktrail_hdmi_audio_enable(dev);
#line 594
  return;
}
}
#line 597 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
static void oaktrail_hdmi_destroy(struct drm_connector *connector ) 
{ 


  {
#line 599
  return;
}
}
#line 602 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
static struct drm_encoder_helper_funcs  const  oaktrail_hdmi_helper_funcs  = 
#line 602
     {& oaktrail_hdmi_dpms, 0, 0, & gma_encoder_mode_fixup, & gma_encoder_prepare, & gma_encoder_commit,
    & oaktrail_hdmi_mode_set, 0, 0, 0, 0, 0};
#line 611 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
static struct drm_connector_helper_funcs  const  oaktrail_hdmi_connector_helper_funcs  =    {& oaktrail_hdmi_get_modes,
    (enum drm_mode_status (*)(struct drm_connector * , struct drm_display_mode * ))(& oaktrail_hdmi_mode_valid),
    & gma_best_encoder};
#line 617 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
static struct drm_connector_funcs  const  oaktrail_hdmi_connector_funcs  = 
#line 617
     {& drm_helper_connector_dpms, 0, 0, 0, & oaktrail_hdmi_detect, & drm_helper_probe_single_connector_modes,
    0, & oaktrail_hdmi_destroy, 0, 0, 0, 0, 0};
#line 624 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
static void oaktrail_hdmi_enc_destroy(struct drm_encoder *encoder ) 
{ 


  {
#line 626
  drm_encoder_cleanup(encoder);
#line 627
  return;
}
}
#line 629 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
static struct drm_encoder_funcs  const  oaktrail_hdmi_enc_funcs  =    {0, & oaktrail_hdmi_enc_destroy};
#line 633 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
void oaktrail_hdmi_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_connector *gma_connector ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 641
  tmp = kzalloc(152UL, 208U);
#line 641
  gma_encoder = (struct gma_encoder *)tmp;
#line 642
  if ((unsigned long )gma_encoder == (unsigned long )((struct gma_encoder *)0)) {
#line 643
    return;
  } else {

  }
#line 645
  tmp___0 = kzalloc(944UL, 208U);
#line 645
  gma_connector = (struct gma_connector *)tmp___0;
#line 646
  if ((unsigned long )gma_connector == (unsigned long )((struct gma_connector *)0)) {
#line 647
    goto failed_connector;
  } else {

  }
#line 649
  connector = & gma_connector->base;
#line 650
  encoder = & gma_encoder->base;
#line 651
  drm_connector_init(dev, connector, & oaktrail_hdmi_connector_funcs, 3);
#line 655
  drm_encoder_init(dev, encoder, & oaktrail_hdmi_enc_funcs, 2);
#line 659
  gma_connector_attach_encoder(gma_connector, gma_encoder);
#line 661
  gma_encoder->type = 6;
#line 662
  drm_encoder_helper_add(encoder, & oaktrail_hdmi_helper_funcs);
#line 663
  drm_connector_helper_add(connector, & oaktrail_hdmi_connector_helper_funcs);
#line 665
  connector->display_info.subpixel_order = 1;
#line 666
  connector->interlace_allowed = 0;
#line 667
  connector->doublescan_allowed = 0;
#line 668
  drm_connector_register(connector);
#line 669
  _dev_info((struct device  const  *)dev->dev, "HDMI initialised.\n");
#line 671
  return;
  failed_connector: 
#line 674
  kfree((void const   *)gma_encoder);
#line 675
  return;
}
}
#line 682 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
void oaktrail_hdmi_setup(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct pci_dev *pdev ;
  struct oaktrail_hdmi_dev *hdmi_dev ;
  int ret ;
  void *tmp ;

  {
#line 684
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 689
  pdev = pci_get_device(32902U, 2061U, (struct pci_dev *)0);
#line 690
  if ((unsigned long )pdev == (unsigned long )((struct pci_dev *)0)) {
#line 691
    return;
  } else {

  }
#line 693
  tmp = kzalloc(96UL, 208U);
#line 693
  hdmi_dev = (struct oaktrail_hdmi_dev *)tmp;
#line 694
  if ((unsigned long )hdmi_dev == (unsigned long )((struct oaktrail_hdmi_dev *)0)) {
#line 695
    dev_err((struct device  const  *)dev->dev, "failed to allocate memory\n");
#line 696
    goto out;
  } else {

  }
#line 700
  ret = pci_enable_device(pdev);
#line 701
  if (ret != 0) {
#line 702
    dev_err((struct device  const  *)dev->dev, "failed to enable hdmi controller\n");
#line 703
    goto free;
  } else {

  }
#line 706
  hdmi_dev->mmio = (unsigned int )pdev->resource[0].start;
#line 707
  hdmi_dev->mmio_len = pdev->resource[0].start != 0ULL || pdev->resource[0].end != pdev->resource[0].start ? ((unsigned int )pdev->resource[0].end - (unsigned int )pdev->resource[0].start) + 1U : 0U;
#line 708
  hdmi_dev->regs = ioremap((resource_size_t )hdmi_dev->mmio, (unsigned long )hdmi_dev->mmio_len);
#line 709
  if ((unsigned long )hdmi_dev->regs == (unsigned long )((void *)0)) {
#line 710
    dev_err((struct device  const  *)dev->dev, "failed to map hdmi mmio\n");
#line 711
    goto free;
  } else {

  }
#line 714
  hdmi_dev->dev = pdev;
#line 715
  pci_set_drvdata(pdev, (void *)hdmi_dev);
#line 718
  ret = oaktrail_hdmi_i2c_init(hdmi_dev->dev);
#line 719
  if (ret != 0) {
#line 720
    dev_err((struct device  const  *)dev->dev, "HDMI I2C initialization failed\n");
  } else {

  }
#line 722
  dev_priv->hdmi_priv = hdmi_dev;
#line 723
  oaktrail_hdmi_audio_disable(dev);
#line 725
  _dev_info((struct device  const  *)dev->dev, "HDMI hardware present.\n");
#line 727
  return;
  free: 
#line 730
  kfree((void const   *)hdmi_dev);
  out: ;
#line 732
  return;
}
}
#line 735 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
void oaktrail_hdmi_teardown(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct oaktrail_hdmi_dev *hdmi_dev ;
  struct pci_dev *pdev ;

  {
#line 737
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 738
  hdmi_dev = dev_priv->hdmi_priv;
#line 741
  if ((unsigned long )hdmi_dev != (unsigned long )((struct oaktrail_hdmi_dev *)0)) {
#line 742
    pdev = hdmi_dev->dev;
#line 743
    pci_set_drvdata(pdev, (void *)0);
#line 744
    oaktrail_hdmi_i2c_exit(pdev);
#line 745
    iounmap((void volatile   *)hdmi_dev->regs);
#line 746
    kfree((void const   *)hdmi_dev);
#line 747
    pci_dev_put(pdev);
  } else {

  }
#line 749
  return;
}
}
#line 752 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
void oaktrail_hdmi_save(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct oaktrail_hdmi_dev *hdmi_dev ;
  struct psb_state *regs ;
  struct psb_pipe *pipeb ;
  int i ;

  {
#line 754
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 755
  hdmi_dev = dev_priv->hdmi_priv;
#line 756
  regs = & dev_priv->regs.__annonCompField80.psb;
#line 757
  pipeb = (struct psb_pipe *)(& dev_priv->regs.pipe) + 1UL;
#line 761
  hdmi_dev->saveDPLL_CTRL = ioread32((void *)dev_priv->vdc_reg + 24576U);
#line 762
  hdmi_dev->saveDPLL_DIV_CTRL = ioread32((void *)dev_priv->vdc_reg + 24580U);
#line 763
  hdmi_dev->saveDPLL_ADJUST = ioread32((void *)dev_priv->vdc_reg + 24588U);
#line 764
  hdmi_dev->saveDPLL_UPDATE = ioread32((void *)dev_priv->vdc_reg + 24596U);
#line 765
  hdmi_dev->saveDPLL_CLK_ENABLE = ioread32((void *)dev_priv->vdc_reg + 24584U);
#line 768
  pipeb->conf = ioread32((void *)dev_priv->vdc_reg + 462856U);
#line 769
  pipeb->src = ioread32((void *)dev_priv->vdc_reg + 397340U);
#line 770
  pipeb->htotal = ioread32((void *)dev_priv->vdc_reg + 397312U);
#line 771
  pipeb->hblank = ioread32((void *)dev_priv->vdc_reg + 397316U);
#line 772
  pipeb->hsync = ioread32((void *)dev_priv->vdc_reg + 397320U);
#line 773
  pipeb->vtotal = ioread32((void *)dev_priv->vdc_reg + 397324U);
#line 774
  pipeb->vblank = ioread32((void *)dev_priv->vdc_reg + 397328U);
#line 775
  pipeb->vsync = ioread32((void *)dev_priv->vdc_reg + 397332U);
#line 777
  hdmi_dev->savePCH_PIPEBCONF = ioread32((void *)dev_priv->vdc_reg + 14344U);
#line 778
  hdmi_dev->savePCH_PIPEBSRC = ioread32((void *)dev_priv->vdc_reg + 12572U);
#line 779
  hdmi_dev->savePCH_HTOTAL_B = ioread32((void *)dev_priv->vdc_reg + 12544U);
#line 780
  hdmi_dev->savePCH_HBLANK_B = ioread32((void *)dev_priv->vdc_reg + 12548U);
#line 781
  hdmi_dev->savePCH_HSYNC_B = ioread32((void *)dev_priv->vdc_reg + 12552U);
#line 782
  hdmi_dev->savePCH_VTOTAL_B = ioread32((void *)dev_priv->vdc_reg + 12556U);
#line 783
  hdmi_dev->savePCH_VBLANK_B = ioread32((void *)dev_priv->vdc_reg + 12560U);
#line 784
  hdmi_dev->savePCH_VSYNC_B = ioread32((void *)dev_priv->vdc_reg + 12564U);
#line 787
  pipeb->cntr = ioread32((void *)dev_priv->vdc_reg + 463232U);
#line 788
  pipeb->stride = ioread32((void *)dev_priv->vdc_reg + 463240U);
#line 789
  pipeb->addr = ioread32((void *)dev_priv->vdc_reg + 463236U);
#line 790
  pipeb->surf = ioread32((void *)dev_priv->vdc_reg + 463260U);
#line 791
  pipeb->linoff = ioread32((void *)dev_priv->vdc_reg + 463236U);
#line 792
  pipeb->tileoff = ioread32((void *)dev_priv->vdc_reg + 463268U);
#line 795
  regs->saveDSPBCURSOR_CTRL = ioread32((void *)dev_priv->vdc_reg + 458944U);
#line 796
  regs->saveDSPBCURSOR_BASE = ioread32((void *)dev_priv->vdc_reg + 458948U);
#line 797
  regs->saveDSPBCURSOR_POS = ioread32((void *)dev_priv->vdc_reg + 458952U);
#line 800
  i = 0;
#line 800
  goto ldv_42078;
  ldv_42077: 
#line 801
  pipeb->palette[i] = ioread32((void *)dev_priv->vdc_reg + (unsigned long )((i << 2) + 43008));
#line 800
  i = i + 1;
  ldv_42078: ;
#line 800
  if (i <= 255) {
#line 802
    goto ldv_42077;
  } else {

  }

#line 807
  return;
}
}
#line 805 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.c"
void oaktrail_hdmi_restore(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct oaktrail_hdmi_dev *hdmi_dev ;
  struct psb_state *regs ;
  struct psb_pipe *pipeb ;
  int i ;

  {
#line 807
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 808
  hdmi_dev = dev_priv->hdmi_priv;
#line 809
  regs = & dev_priv->regs.__annonCompField80.psb;
#line 810
  pipeb = (struct psb_pipe *)(& dev_priv->regs.pipe) + 1UL;
#line 814
  iowrite32(hdmi_dev->saveDPLL_CTRL, (void *)dev_priv->vdc_reg + 24576U);
#line 815
  iowrite32(hdmi_dev->saveDPLL_DIV_CTRL, (void *)dev_priv->vdc_reg + 24580U);
#line 816
  iowrite32(hdmi_dev->saveDPLL_ADJUST, (void *)dev_priv->vdc_reg + 24588U);
#line 817
  iowrite32(hdmi_dev->saveDPLL_UPDATE, (void *)dev_priv->vdc_reg + 24596U);
#line 818
  iowrite32(hdmi_dev->saveDPLL_CLK_ENABLE, (void *)dev_priv->vdc_reg + 24584U);
#line 819
  __const_udelay(644250UL);
#line 822
  iowrite32(pipeb->src, (void *)dev_priv->vdc_reg + 397340U);
#line 823
  iowrite32(pipeb->htotal, (void *)dev_priv->vdc_reg + 397312U);
#line 824
  iowrite32(pipeb->hblank, (void *)dev_priv->vdc_reg + 397316U);
#line 825
  iowrite32(pipeb->hsync, (void *)dev_priv->vdc_reg + 397320U);
#line 826
  iowrite32(pipeb->vtotal, (void *)dev_priv->vdc_reg + 397324U);
#line 827
  iowrite32(pipeb->vblank, (void *)dev_priv->vdc_reg + 397328U);
#line 828
  iowrite32(pipeb->vsync, (void *)dev_priv->vdc_reg + 397332U);
#line 830
  iowrite32(hdmi_dev->savePCH_PIPEBSRC, (void *)dev_priv->vdc_reg + 12572U);
#line 831
  iowrite32(hdmi_dev->savePCH_HTOTAL_B, (void *)dev_priv->vdc_reg + 12544U);
#line 832
  iowrite32(hdmi_dev->savePCH_HBLANK_B, (void *)dev_priv->vdc_reg + 12548U);
#line 833
  iowrite32(hdmi_dev->savePCH_HSYNC_B, (void *)dev_priv->vdc_reg + 12552U);
#line 834
  iowrite32(hdmi_dev->savePCH_VTOTAL_B, (void *)dev_priv->vdc_reg + 12556U);
#line 835
  iowrite32(hdmi_dev->savePCH_VBLANK_B, (void *)dev_priv->vdc_reg + 12560U);
#line 836
  iowrite32(hdmi_dev->savePCH_VSYNC_B, (void *)dev_priv->vdc_reg + 12564U);
#line 838
  iowrite32(pipeb->conf, (void *)dev_priv->vdc_reg + 462856U);
#line 839
  iowrite32(hdmi_dev->savePCH_PIPEBCONF, (void *)dev_priv->vdc_reg + 14344U);
#line 842
  iowrite32(pipeb->linoff, (void *)dev_priv->vdc_reg + 463236U);
#line 843
  iowrite32(pipeb->stride, (void *)dev_priv->vdc_reg + 463240U);
#line 844
  iowrite32(pipeb->tileoff, (void *)dev_priv->vdc_reg + 463268U);
#line 845
  iowrite32(pipeb->cntr, (void *)dev_priv->vdc_reg + 463232U);
#line 846
  iowrite32(pipeb->surf, (void *)dev_priv->vdc_reg + 463260U);
#line 849
  iowrite32(regs->saveDSPBCURSOR_CTRL, (void *)dev_priv->vdc_reg + 458944U);
#line 850
  iowrite32(regs->saveDSPBCURSOR_POS, (void *)dev_priv->vdc_reg + 458952U);
#line 851
  iowrite32(regs->saveDSPBCURSOR_BASE, (void *)dev_priv->vdc_reg + 458948U);
#line 854
  i = 0;
#line 854
  goto ldv_42089;
  ldv_42088: 
#line 855
  iowrite32(pipeb->palette[i], (void *)dev_priv->vdc_reg + (unsigned long )((i << 2) + 43008));
#line 854
  i = i + 1;
  ldv_42089: ;
#line 854
  if (i <= 255) {
#line 856
    goto ldv_42088;
  } else {

  }

#line 861
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
extern int ldv_probe_7(void) ;
#line 405
extern int ldv_probe_6(void) ;
#line 408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_initialize_drm_connector_helper_funcs_8(void) 
{ 
  void *tmp ;

  {
#line 409
  tmp = ldv_init_zalloc(936UL);
#line 409
  oaktrail_hdmi_connector_helper_funcs_group0 = (struct drm_connector *)tmp;
#line 410
  return;
}
}
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_initialize_drm_encoder_helper_funcs_9(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 413
  tmp = ldv_init_zalloc(96UL);
#line 413
  oaktrail_hdmi_helper_funcs_group0 = (struct drm_encoder *)tmp;
#line 414
  tmp___0 = ldv_init_zalloc(208UL);
#line 414
  oaktrail_hdmi_helper_funcs_group1 = (struct drm_display_mode *)tmp___0;
#line 415
  return;
}
}
#line 417 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_initialize_drm_connector_funcs_7(void) 
{ 
  void *tmp ;

  {
#line 418
  tmp = ldv_init_zalloc(936UL);
#line 418
  oaktrail_hdmi_connector_funcs_group0 = (struct drm_connector *)tmp;
#line 419
  return;
}
}
#line 421 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_main_exported_8(void) 
{ 
  struct drm_display_mode *ldvarg189 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 422
  tmp = ldv_init_zalloc(208UL);
#line 422
  ldvarg189 = (struct drm_display_mode *)tmp;
#line 424
  tmp___0 = __VERIFIER_nondet_int();
#line 424
  switch (tmp___0) {
  case 0: ;
#line 427
  if (ldv_state_variable_8 == 1) {
#line 429
    oaktrail_hdmi_get_modes(oaktrail_hdmi_connector_helper_funcs_group0);
#line 431
    ldv_state_variable_8 = 1;
  } else {

  }
#line 434
  goto ldv_42109;
  case 1: ;
#line 437
  if (ldv_state_variable_8 == 1) {
#line 439
    oaktrail_hdmi_mode_valid(oaktrail_hdmi_connector_helper_funcs_group0, ldvarg189);
#line 441
    ldv_state_variable_8 = 1;
  } else {

  }
#line 444
  goto ldv_42109;
  case 2: ;
#line 447
  if (ldv_state_variable_8 == 1) {
#line 449
    gma_best_encoder(oaktrail_hdmi_connector_helper_funcs_group0);
#line 451
    ldv_state_variable_8 = 1;
  } else {

  }
#line 454
  goto ldv_42109;
  default: 
#line 455
  ldv_stop();
  }
  ldv_42109: ;
#line 459
  return;
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_main_exported_6(void) 
{ 
  struct drm_encoder *ldvarg139 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 462
  tmp = ldv_init_zalloc(96UL);
#line 462
  ldvarg139 = (struct drm_encoder *)tmp;
#line 464
  tmp___0 = __VERIFIER_nondet_int();
#line 464
  switch (tmp___0) {
  case 0: ;
#line 467
  if (ldv_state_variable_6 == 2) {
#line 469
    oaktrail_hdmi_enc_destroy(ldvarg139);
#line 471
    ldv_state_variable_6 = 1;
#line 472
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 475
  goto ldv_42118;
  case 1: ;
#line 478
  if (ldv_state_variable_6 == 1) {
#line 480
    ldv_probe_6();
#line 482
    ldv_state_variable_6 = 2;
#line 483
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 486
  goto ldv_42118;
  default: 
#line 487
  ldv_stop();
  }
  ldv_42118: ;
#line 491
  return;
}
}
#line 493 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_main_exported_7(void) 
{ 
  uint32_t ldvarg6 ;
  int ldvarg9 ;
  uint32_t ldvarg7 ;
  bool ldvarg8 ;
  int tmp ;

  {
#line 494
  ldv_memset((void *)(& ldvarg6), 0, 4UL);
#line 495
  ldv_memset((void *)(& ldvarg9), 0, 4UL);
#line 496
  ldv_memset((void *)(& ldvarg7), 0, 4UL);
#line 497
  ldv_memset((void *)(& ldvarg8), 0, 1UL);
#line 499
  tmp = __VERIFIER_nondet_int();
#line 499
  switch (tmp) {
  case 0: ;
#line 502
  if (ldv_state_variable_7 == 1) {
#line 504
    drm_helper_connector_dpms(oaktrail_hdmi_connector_funcs_group0, ldvarg9);
#line 506
    ldv_state_variable_7 = 1;
  } else {

  }
#line 509
  if (ldv_state_variable_7 == 2) {
#line 511
    drm_helper_connector_dpms(oaktrail_hdmi_connector_funcs_group0, ldvarg9);
#line 513
    ldv_state_variable_7 = 2;
  } else {

  }
#line 516
  goto ldv_42129;
  case 1: ;
#line 519
  if (ldv_state_variable_7 == 1) {
#line 521
    oaktrail_hdmi_detect(oaktrail_hdmi_connector_funcs_group0, (int )ldvarg8);
#line 523
    ldv_state_variable_7 = 1;
  } else {

  }
#line 526
  if (ldv_state_variable_7 == 2) {
#line 528
    oaktrail_hdmi_detect(oaktrail_hdmi_connector_funcs_group0, (int )ldvarg8);
#line 530
    ldv_state_variable_7 = 2;
  } else {

  }
#line 533
  goto ldv_42129;
  case 2: ;
#line 536
  if (ldv_state_variable_7 == 2) {
#line 538
    oaktrail_hdmi_destroy(oaktrail_hdmi_connector_funcs_group0);
#line 540
    ldv_state_variable_7 = 1;
#line 541
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 544
  goto ldv_42129;
  case 3: ;
#line 547
  if (ldv_state_variable_7 == 1) {
#line 549
    drm_helper_probe_single_connector_modes(oaktrail_hdmi_connector_funcs_group0,
                                            ldvarg7, ldvarg6);
#line 551
    ldv_state_variable_7 = 1;
  } else {

  }
#line 554
  if (ldv_state_variable_7 == 2) {
#line 556
    drm_helper_probe_single_connector_modes(oaktrail_hdmi_connector_funcs_group0,
                                            ldvarg7, ldvarg6);
#line 558
    ldv_state_variable_7 = 2;
  } else {

  }
#line 561
  goto ldv_42129;
  case 4: ;
#line 564
  if (ldv_state_variable_7 == 1) {
#line 566
    ldv_probe_7();
#line 568
    ldv_state_variable_7 = 2;
#line 569
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 572
  goto ldv_42129;
  default: 
#line 573
  ldv_stop();
  }
  ldv_42129: ;
#line 577
  return;
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_main_exported_9(void) 
{ 
  int ldvarg158 ;
  struct drm_display_mode *ldvarg157 ;
  void *tmp ;
  struct drm_display_mode *ldvarg156 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 581
  tmp = ldv_init_zalloc(208UL);
#line 581
  ldvarg157 = (struct drm_display_mode *)tmp;
#line 582
  tmp___0 = ldv_init_zalloc(208UL);
#line 582
  ldvarg156 = (struct drm_display_mode *)tmp___0;
#line 580
  ldv_memset((void *)(& ldvarg158), 0, 4UL);
#line 584
  tmp___1 = __VERIFIER_nondet_int();
#line 584
  switch (tmp___1) {
  case 0: ;
#line 587
  if (ldv_state_variable_9 == 1) {
#line 589
    oaktrail_hdmi_dpms(oaktrail_hdmi_helper_funcs_group0, ldvarg158);
#line 591
    ldv_state_variable_9 = 1;
  } else {

  }
#line 594
  goto ldv_42142;
  case 1: ;
#line 597
  if (ldv_state_variable_9 == 1) {
#line 599
    gma_encoder_mode_fixup(oaktrail_hdmi_helper_funcs_group0, (struct drm_display_mode  const  *)ldvarg157,
                           oaktrail_hdmi_helper_funcs_group1);
#line 601
    ldv_state_variable_9 = 1;
  } else {

  }
#line 604
  goto ldv_42142;
  case 2: ;
#line 607
  if (ldv_state_variable_9 == 1) {
#line 609
    gma_encoder_commit(oaktrail_hdmi_helper_funcs_group0);
#line 611
    ldv_state_variable_9 = 1;
  } else {

  }
#line 614
  goto ldv_42142;
  case 3: ;
#line 617
  if (ldv_state_variable_9 == 1) {
#line 619
    oaktrail_hdmi_mode_set(oaktrail_hdmi_helper_funcs_group0, oaktrail_hdmi_helper_funcs_group1,
                           ldvarg156);
#line 621
    ldv_state_variable_9 = 1;
  } else {

  }
#line 624
  goto ldv_42142;
  case 4: ;
#line 627
  if (ldv_state_variable_9 == 1) {
#line 629
    gma_encoder_prepare(oaktrail_hdmi_helper_funcs_group0);
#line 631
    ldv_state_variable_9 = 1;
  } else {

  }
#line 634
  goto ldv_42142;
  default: 
#line 635
  ldv_stop();
  }
  ldv_42142: ;
#line 639
  return;
}
}
#line 664 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
bool ldv_queue_work_on_1559(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 668
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 668
  ldv_func_res = tmp;
#line 670
  activate_work_2(ldv_func_arg3, 2);
#line 672
  return (ldv_func_res);
}
}
#line 675 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
bool ldv_queue_delayed_work_on_1560(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 679
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 679
  ldv_func_res = tmp;
#line 681
  activate_work_2(& ldv_func_arg3->work, 2);
#line 683
  return (ldv_func_res);
}
}
#line 686 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
bool ldv_queue_work_on_1561(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 690
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 690
  ldv_func_res = tmp;
#line 692
  activate_work_2(ldv_func_arg3, 2);
#line 694
  return (ldv_func_res);
}
}
#line 697 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_flush_workqueue_1562(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 700
  flush_workqueue(ldv_func_arg1);
#line 702
  call_and_disable_all_2(2);
#line 703
  return;
}
}
#line 705 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
bool ldv_queue_delayed_work_on_1563(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 709
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 709
  ldv_func_res = tmp;
#line 711
  activate_work_2(& ldv_func_arg3->work, 2);
#line 713
  return (ldv_func_res);
}
}
#line 716 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_mutex_lock_1564(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 719
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 721
  mutex_lock(ldv_func_arg1);
#line 722
  return;
}
}
#line 724 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_mutex_unlock_1565(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 727
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 729
  mutex_unlock(ldv_func_arg1);
#line 730
  return;
}
}
#line 732 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_mutex_lock_1566(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 735
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 737
  mutex_lock(ldv_func_arg1);
#line 738
  return;
}
}
#line 740 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
int ldv_mutex_trylock_1567(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 744
  tmp = mutex_trylock(ldv_func_arg1);
#line 744
  ldv_func_res = tmp;
#line 746
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 746
  return (tmp___0);
#line 748
  return (ldv_func_res);
}
}
#line 751 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_mutex_unlock_1568(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 754
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 756
  mutex_unlock(ldv_func_arg1);
#line 757
  return;
}
}
#line 759 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_mutex_unlock_1569(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 762
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 764
  mutex_unlock(ldv_func_arg1);
#line 765
  return;
}
}
#line 767 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_mutex_lock_1570(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 770
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 772
  mutex_lock(ldv_func_arg1);
#line 773
  return;
}
}
#line 775 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_mutex_lock_1571(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 778
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 780
  mutex_lock(ldv_func_arg1);
#line 781
  return;
}
}
#line 783 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_mutex_unlock_1572(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 786
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 788
  mutex_unlock(ldv_func_arg1);
#line 789
  return;
}
}
#line 791 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_mutex_unlock_1573(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 794
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 796
  mutex_unlock(ldv_func_arg1);
#line 797
  return;
}
}
#line 799 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_mutex_lock_1574(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 802
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 804
  mutex_lock(ldv_func_arg1);
#line 805
  return;
}
}
#line 807 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
int ldv_mutex_lock_interruptible_1575(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 811
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 811
  ldv_func_res = tmp;
#line 813
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 813
  return (tmp___0);
#line 815
  return (ldv_func_res);
}
}
#line 818 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
int ldv_mutex_trylock_1576(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 822
  tmp = mutex_trylock(ldv_func_arg1);
#line 822
  ldv_func_res = tmp;
#line 824
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 824
  return (tmp___0);
#line 826
  return (ldv_func_res);
}
}
#line 850 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_mutex_unlock_1579(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 853
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 855
  mutex_unlock(ldv_func_arg1);
#line 856
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_1612(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_1621(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_1610(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_1613(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_1614(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_1617(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_1618(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_1624(struct mutex *ldv_func_arg1 ) ;
#line 209
void ldv_mutex_unlock_1626(struct mutex *ldv_func_arg1 ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
int ldv_mutex_lock_interruptible_1620(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_1609(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_1611(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_1615(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_1616(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_1619(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_1625(struct mutex *ldv_func_arg1 ) ;
#line 76
void ldv_mutex_lock_i2c_lock_of_hdmi_i2c_dev(struct mutex *lock ) ;
#line 80
void ldv_mutex_unlock_i2c_lock_of_hdmi_i2c_dev(struct mutex *lock ) ;
#line 72 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 73 "include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ 
  struct lock_class_key __key ;

  {
#line 75
  x->done = 0U;
#line 76
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
#line 78
  return;
}
}
#line 86 "include/linux/completion.h"
__inline static void reinit_completion(struct completion *x ) 
{ 


  {
#line 88
  x->done = 0U;
#line 89
  return;
}
}
#line 99
extern long wait_for_completion_interruptible_timeout(struct completion * , unsigned long  ) ;
#line 106
extern void complete(struct completion * ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_1604(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_1606(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_1605(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_1608(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_1607(struct workqueue_struct *ldv_func_arg1 ) ;
#line 341 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) ;
#line 355
void disable_suitable_irq_1(int line , void *data ) ;
#line 357
void activate_suitable_irq_1(int line , void *data ) ;
#line 378
void choose_interrupt_1(void) ;
#line 393
int ldv_irq_1(int state , int line , void *data ) ;
#line 523 "include/linux/i2c.h"
__inline static void *i2c_get_adapdata(struct i2c_adapter  const  *dev ) 
{ 
  void *tmp ;

  {
#line 525
  tmp = dev_get_drvdata(& dev->dev);
#line 525
  return (tmp);
}
}
#line 581
extern int i2c_add_numbered_adapter(struct i2c_adapter * ) ;
#line 127 "include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 132 "include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
#line 135
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))0, flags,
                             name, dev);
#line 135
  return (tmp);
}
}
#line 141
__inline static int ldv_request_irq_1627(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                   void * ) ,
                                         unsigned long flags , char const   *name ,
                                         void *dev ) ;
#line 150
extern void free_irq(unsigned int  , void * ) ;
#line 153
void ldv_free_irq_1628(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.c"
static void hdmi_i2c_irq_enable(struct oaktrail_hdmi_dev *hdmi_dev ) 
{ 
  u32 temp ;

  {
#line 81
  temp = readl((void const volatile   *)hdmi_dev->regs + 4100U);
#line 82
  temp = temp | 28U;
#line 83
  writel(temp, (void volatile   *)hdmi_dev->regs + 4100U);
#line 84
  readl((void const volatile   *)hdmi_dev->regs + 4100U);
#line 85
  return;
}
}
#line 87 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.c"
static void hdmi_i2c_irq_disable(struct oaktrail_hdmi_dev *hdmi_dev ) 
{ 


  {
#line 89
  writel(0U, (void volatile   *)hdmi_dev->regs + 4100U);
#line 90
  readl((void const volatile   *)hdmi_dev->regs + 4100U);
#line 91
  return;
}
}
#line 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.c"
static int xfer_read(struct i2c_adapter *adap , struct i2c_msg *pmsg ) 
{ 
  struct oaktrail_hdmi_dev *hdmi_dev ;
  void *tmp ;
  struct hdmi_i2c_dev *i2c_dev ;
  u32 temp ;

  {
#line 95
  tmp = i2c_get_adapdata((struct i2c_adapter  const  *)adap);
#line 95
  hdmi_dev = (struct oaktrail_hdmi_dev *)tmp;
#line 96
  i2c_dev = hdmi_dev->i2c_dev;
#line 99
  i2c_dev->status = 0;
#line 100
  i2c_dev->msg = pmsg;
#line 101
  i2c_dev->buf_offset = 0;
#line 102
  reinit_completion(& i2c_dev->complete);
#line 105
  temp = (u32 )(((int )pmsg->len << 20) | 13);
#line 106
  writel(temp, (void volatile   *)hdmi_dev->regs + 4672U);
#line 107
  readl((void const volatile   *)hdmi_dev->regs + 4672U);
#line 109
  goto ldv_41922;
  ldv_41921: 
#line 110
  wait_for_completion_interruptible_timeout(& i2c_dev->complete, 2500UL);
  ldv_41922: ;
#line 109
  if (i2c_dev->status != 2) {
#line 111
    goto ldv_41921;
  } else {

  }

#line 113
  return (0);
}
}
#line 116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.c"
static int xfer_write(struct i2c_adapter *adap , struct i2c_msg *pmsg ) 
{ 


  {
#line 121
  return (0);
}
}
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.c"
static int oaktrail_hdmi_i2c_access(struct i2c_adapter *adap , struct i2c_msg *pmsg ,
                                    int num ) 
{ 
  struct oaktrail_hdmi_dev *hdmi_dev ;
  void *tmp ;
  struct hdmi_i2c_dev *i2c_dev ;
  int i ;

  {
#line 128
  tmp = i2c_get_adapdata((struct i2c_adapter  const  *)adap);
#line 128
  hdmi_dev = (struct oaktrail_hdmi_dev *)tmp;
#line 129
  i2c_dev = hdmi_dev->i2c_dev;
#line 132
  ldv_mutex_lock_1625(& i2c_dev->i2c_lock);
#line 135
  writel(34656U, (void volatile   *)hdmi_dev->regs + 4352U);
#line 138
  hdmi_i2c_irq_enable(hdmi_dev);
#line 139
  i = 0;
#line 139
  goto ldv_41937;
  ldv_41936: ;
#line 140
  if ((unsigned int )pmsg->len != 0U && (unsigned long )pmsg->buf != (unsigned long )((__u8 *)0U)) {
#line 141
    if ((int )pmsg->flags & 1) {
#line 142
      xfer_read(adap, pmsg);
    } else {
#line 144
      xfer_write(adap, pmsg);
    }
  } else {

  }
#line 146
  pmsg = pmsg + 1;
#line 139
  i = i + 1;
  ldv_41937: ;
#line 139
  if (i < num) {
#line 141
    goto ldv_41936;
  } else {

  }
#line 150
  hdmi_i2c_irq_disable(hdmi_dev);
#line 152
  ldv_mutex_unlock_1626(& i2c_dev->i2c_lock);
#line 154
  return (i);
}
}
#line 157 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.c"
static u32 oaktrail_hdmi_i2c_func(struct i2c_adapter *adapter ) 
{ 


  {
#line 159
  return (3U);
}
}
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.c"
static struct i2c_algorithm  const  oaktrail_hdmi_i2c_algorithm  =    {& oaktrail_hdmi_i2c_access, 0, & oaktrail_hdmi_i2c_func, 0, 0};
#line 167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.c"
static struct i2c_adapter oaktrail_hdmi_i2c_adapter  = 
#line 167
     {& __this_module, 8U, & oaktrail_hdmi_i2c_algorithm, 0, {{{{0}}, 0U, 0U, 0, {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}},
                                                            {0}, 0, 0, 0, 0, 0, 0,
                                                            0}, 0, 0, {0, 0, {0, {0,
                                                                                  0},
                                                                              0, 0,
                                                                              0, 0,
                                                                              {{0}},
                                                                              {{{0L},
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}},
                                                                               {{0,
                                                                                 0},
                                                                                0UL,
                                                                                0,
                                                                                0UL,
                                                                                0U,
                                                                                0,
                                                                                0,
                                                                                0,
                                                                                {(char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0},
                                                                                {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}},
                                                                               0,
                                                                               0},
                                                                              (unsigned char)0,
                                                                              (unsigned char)0,
                                                                              (unsigned char)0,
                                                                              (unsigned char)0,
                                                                              (unsigned char)0},
                                                                       0, 0, {{0},
                                                                              {{{{{0}},
                                                                                 0U,
                                                                                 0U,
                                                                                 0,
                                                                                 {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}}}},
                                                                              {0,
                                                                               0},
                                                                              0, 0,
                                                                              {0,
                                                                               {0,
                                                                                0},
                                                                               0,
                                                                               0,
                                                                               0UL}},
                                                                       0, 0, 0, 0,
                                                                       {{0}, (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (_Bool)0,
                                                                        (_Bool)0,
                                                                        (_Bool)0,
                                                                        (_Bool)0,
                                                                        (_Bool)0,
                                                                        (_Bool)0,
                                                                        (_Bool)0,
                                                                        {{{{{0}},
                                                                           0U, 0U,
                                                                           0, {0,
                                                                               {0,
                                                                                0},
                                                                               0,
                                                                               0,
                                                                               0UL}}}},
                                                                        {0, 0}, {0U,
                                                                                 {{{{{{0}},
                                                                                     0U,
                                                                                     0U,
                                                                                     0,
                                                                                     {0,
                                                                                      {0,
                                                                                       0},
                                                                                      0,
                                                                                      0,
                                                                                      0UL}}}},
                                                                                  {0,
                                                                                   0}}},
                                                                        0, (_Bool)0,
                                                                        (_Bool)0,
                                                                        {{0, 0}, 0UL,
                                                                         0, 0UL, 0U,
                                                                         0, 0, 0,
                                                                         {(char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0},
                                                                         {0, {0, 0},
                                                                          0, 0, 0UL}},
                                                                        0UL, {{0L},
                                                                              {0,
                                                                               0},
                                                                              0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}},
                                                                        {{{{{{0}},
                                                                            0U, 0U,
                                                                            0, {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}}}},
                                                                         {0, 0}},
                                                                        0, {0}, {0},
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        0, 0, 0, 0,
                                                                        0UL, 0UL,
                                                                        0UL, 0UL,
                                                                        0, 0, 0},
                                                                       0, 0, 0, 0,
                                                                       0ULL, 0UL,
                                                                       0, {0, 0},
                                                                       0, 0, {0, 0},
                                                                       0, 0, 0U, 0U,
                                                                       {{{{{0}}, 0U,
                                                                          0U, 0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}}}},
                                                                       {0, 0}, {0,
                                                                                {0,
                                                                                 0},
                                                                                {{0}}},
                                                                       0, 0, 0, 0,
                                                                       (_Bool)0, (_Bool)0},
    3, {'o', 'a', 'k', 't', 'r', 'a', 'i', 'l', '_', 'h', 'd', 'm', 'i', '_', 'i',
        '2', 'c', '\000'}, {0U, {{{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0,
                                                                                  0}}},
    {{0}, {{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}, 0, 0, {0, {0, 0},
                                                                         0, 0, 0UL}},
    {0, 0}, 0, 0};
#line 175 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.c"
static void hdmi_i2c_read(struct oaktrail_hdmi_dev *hdmi_dev ) 
{ 
  struct hdmi_i2c_dev *i2c_dev ;
  struct i2c_msg *msg ;
  u8 *buf ;
  u32 temp ;
  int i ;
  int offset ;

  {
#line 177
  i2c_dev = hdmi_dev->i2c_dev;
#line 178
  msg = i2c_dev->msg;
#line 179
  buf = msg->buf;
#line 183
  offset = i2c_dev->buf_offset;
#line 184
  i = 0;
#line 184
  goto ldv_41954;
  ldv_41953: 
#line 185
  temp = readl((void const volatile   *)hdmi_dev->regs + (unsigned long )((i + 1152) * 4));
#line 186
  memcpy((void *)buf + (unsigned long )(i * 4 + offset), (void const   *)(& temp),
           4UL);
#line 184
  i = i + 1;
  ldv_41954: ;
#line 184
  if (i <= 15) {
#line 186
    goto ldv_41953;
  } else {

  }
#line 188
  i2c_dev->buf_offset = i2c_dev->buf_offset + 64;
#line 191
  temp = readl((void const volatile   *)hdmi_dev->regs + 4108U);
#line 192
  writel(temp | 8U, (void volatile   *)hdmi_dev->regs + 4108U);
#line 193
  readl((void const volatile   *)hdmi_dev->regs + 4108U);
#line 196
  temp = readl((void const volatile   *)hdmi_dev->regs + 4672U);
#line 197
  writel(temp | 2U, (void volatile   *)hdmi_dev->regs + 4672U);
#line 198
  readl((void const volatile   *)hdmi_dev->regs + 4672U);
#line 200
  i2c_dev->status = 1;
#line 201
  return;
}
}
#line 204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.c"
static void hdmi_i2c_transaction_done(struct oaktrail_hdmi_dev *hdmi_dev ) 
{ 
  struct hdmi_i2c_dev *i2c_dev ;
  u32 temp ;

  {
#line 206
  i2c_dev = hdmi_dev->i2c_dev;
#line 210
  temp = readl((void const volatile   *)hdmi_dev->regs + 4108U);
#line 211
  writel(temp | 4U, (void volatile   *)hdmi_dev->regs + 4108U);
#line 212
  readl((void const volatile   *)hdmi_dev->regs + 4108U);
#line 215
  temp = readl((void const volatile   *)hdmi_dev->regs + 4672U);
#line 216
  writel(temp & 4294967294U, (void volatile   *)hdmi_dev->regs + 4672U);
#line 217
  readl((void const volatile   *)hdmi_dev->regs + 4672U);
#line 219
  i2c_dev->status = 2;
#line 220
  return;
}
}
#line 223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.c"
static irqreturn_t oaktrail_hdmi_i2c_handler(int this_irq , void *dev ) 
{ 
  struct oaktrail_hdmi_dev *hdmi_dev ;
  struct hdmi_i2c_dev *i2c_dev ;
  u32 stat ;

  {
#line 225
  hdmi_dev = (struct oaktrail_hdmi_dev *)dev;
#line 226
  i2c_dev = hdmi_dev->i2c_dev;
#line 229
  stat = readl((void const volatile   *)hdmi_dev->regs + 4108U);
#line 231
  if ((int )stat & 1) {
#line 232
    writel(stat | 1U, (void volatile   *)hdmi_dev->regs + 4108U);
#line 233
    readl((void const volatile   *)hdmi_dev->regs + 4108U);
  } else {

  }
#line 236
  if ((stat & 8U) != 0U) {
#line 237
    hdmi_i2c_read(hdmi_dev);
  } else {

  }
#line 239
  if ((stat & 4U) != 0U) {
#line 240
    hdmi_i2c_transaction_done(hdmi_dev);
  } else {

  }
#line 242
  complete(& i2c_dev->complete);
#line 244
  return (1);
}
}
#line 251 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.c"
static void oaktrail_hdmi_i2c_gpio_fix(void) 
{ 
  void *base ;
  unsigned int gpio_base ;
  int gpio_len ;
  u32 temp ;
  long tmp ;
  long tmp___0 ;

  {
#line 254
  gpio_base = 4279418880U;
#line 255
  gpio_len = 4096;
#line 258
  base = ioremap((unsigned long long )gpio_base, (unsigned long )gpio_len);
#line 259
  if ((unsigned long )base == (unsigned long )((void *)0)) {
#line 260
    drm_err("gpio ioremap fail\n");
#line 261
    return;
  } else {

  }
#line 264
  temp = readl((void const volatile   *)base + 68U);
#line 265
  tmp = ldv__builtin_expect((drm_debug & 2U) != 0U, 0L);
#line 265
  if (tmp != 0L) {
#line 265
    drm_ut_debug_printk("oaktrail_hdmi_i2c_gpio_fix", "old gpio val %x\n", temp);
  } else {

  }
#line 266
  writel(temp | 2560U, (void volatile   *)base + 68U);
#line 267
  temp = readl((void const volatile   *)base + 68U);
#line 268
  tmp___0 = ldv__builtin_expect((drm_debug & 2U) != 0U, 0L);
#line 268
  if (tmp___0 != 0L) {
#line 268
    drm_ut_debug_printk("oaktrail_hdmi_i2c_gpio_fix", "new gpio val %x\n", temp);
  } else {

  }
#line 270
  iounmap((void volatile   *)base);
#line 271
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.c"
int oaktrail_hdmi_i2c_init(struct pci_dev *dev ) 
{ 
  struct oaktrail_hdmi_dev *hdmi_dev ;
  struct hdmi_i2c_dev *i2c_dev ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  struct lock_class_key __key ;

  {
#line 279
  tmp = pci_get_drvdata(dev);
#line 279
  hdmi_dev = (struct oaktrail_hdmi_dev *)tmp;
#line 281
  tmp___0 = kzalloc(288UL, 208U);
#line 281
  i2c_dev = (struct hdmi_i2c_dev *)tmp___0;
#line 282
  if ((unsigned long )i2c_dev == (unsigned long )((struct hdmi_i2c_dev *)0)) {
#line 283
    drm_err("Can\'t allocate interface\n");
#line 284
    ret = -12;
#line 285
    goto exit;
  } else {

  }
#line 288
  i2c_dev->adap = & oaktrail_hdmi_i2c_adapter;
#line 289
  i2c_dev->status = 0;
#line 290
  init_completion(& i2c_dev->complete);
#line 291
  __mutex_init(& i2c_dev->i2c_lock, "&i2c_dev->i2c_lock", & __key);
#line 292
  i2c_set_adapdata(& oaktrail_hdmi_i2c_adapter, (void *)hdmi_dev);
#line 293
  hdmi_dev->i2c_dev = i2c_dev;
#line 296
  oaktrail_hdmi_i2c_gpio_fix();
#line 299
  ret = ldv_request_irq_1627(dev->irq, & oaktrail_hdmi_i2c_handler, 128UL, (char const   *)(& oaktrail_hdmi_i2c_adapter.name),
                             (void *)hdmi_dev);
#line 301
  if (ret != 0) {
#line 302
    drm_err("Failed to request IRQ for I2C controller\n");
#line 303
    goto err;
  } else {

  }
#line 307
  ret = i2c_add_numbered_adapter(& oaktrail_hdmi_i2c_adapter);
#line 308
  return (ret);
  err: 
#line 311
  kfree((void const   *)i2c_dev);
  exit: ;
#line 313
  return (ret);
}
}
#line 316 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.c"
void oaktrail_hdmi_i2c_exit(struct pci_dev *dev ) 
{ 
  struct oaktrail_hdmi_dev *hdmi_dev ;
  struct hdmi_i2c_dev *i2c_dev ;
  void *tmp ;

  {
#line 321
  tmp = pci_get_drvdata(dev);
#line 321
  hdmi_dev = (struct oaktrail_hdmi_dev *)tmp;
#line 322
  i2c_del_adapter(& oaktrail_hdmi_i2c_adapter);
#line 324
  i2c_dev = hdmi_dev->i2c_dev;
#line 325
  kfree((void const   *)i2c_dev);
#line 326
  ldv_free_irq_1628(dev->irq, (void *)hdmi_dev);
#line 327
  return;
}
}
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
#line 406
  if ((unsigned long )handler == (unsigned long )(& oaktrail_hdmi_i2c_handler)) {
#line 407
    return (1);
  } else {

  }
#line 409
  return (0);
}
}
#line 413 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void disable_suitable_irq_1(int line , void *data ) 
{ 


  {
#line 414
  if (ldv_irq_1_0 != 0 && line == ldv_irq_line_1_0) {
#line 415
    ldv_irq_1_0 = 0;
#line 416
    return;
  } else {

  }
#line 418
  if (ldv_irq_1_1 != 0 && line == ldv_irq_line_1_1) {
#line 419
    ldv_irq_1_1 = 0;
#line 420
    return;
  } else {

  }
#line 422
  if (ldv_irq_1_2 != 0 && line == ldv_irq_line_1_2) {
#line 423
    ldv_irq_1_2 = 0;
#line 424
    return;
  } else {

  }
#line 426
  if (ldv_irq_1_3 != 0 && line == ldv_irq_line_1_3) {
#line 427
    ldv_irq_1_3 = 0;
#line 428
    return;
  } else {

  }
#line 430
  return;
}
}
#line 434 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void activate_suitable_irq_1(int line , void *data ) 
{ 


  {
#line 435
  if (ldv_irq_1_0 == 0) {
#line 436
    ldv_irq_line_1_0 = line;
#line 437
    ldv_irq_data_1_0 = data;
#line 438
    ldv_irq_1_0 = 1;
#line 439
    return;
  } else {

  }
#line 441
  if (ldv_irq_1_1 == 0) {
#line 442
    ldv_irq_line_1_1 = line;
#line 443
    ldv_irq_data_1_1 = data;
#line 444
    ldv_irq_1_1 = 1;
#line 445
    return;
  } else {

  }
#line 447
  if (ldv_irq_1_2 == 0) {
#line 448
    ldv_irq_line_1_2 = line;
#line 449
    ldv_irq_data_1_2 = data;
#line 450
    ldv_irq_1_2 = 1;
#line 451
    return;
  } else {

  }
#line 453
  if (ldv_irq_1_3 == 0) {
#line 454
    ldv_irq_line_1_3 = line;
#line 455
    ldv_irq_data_1_3 = data;
#line 456
    ldv_irq_1_3 = 1;
#line 457
    return;
  } else {

  }
#line 459
  return;
}
}
#line 463 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void choose_interrupt_1(void) 
{ 
  int tmp ;

  {
#line 464
  tmp = __VERIFIER_nondet_int();
#line 464
  switch (tmp) {
  case 0: 
#line 466
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_0, ldv_irq_line_1_0, ldv_irq_data_1_0);
#line 468
  goto ldv_42007;
  case 1: 
#line 470
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_1, ldv_irq_line_1_1, ldv_irq_data_1_1);
#line 472
  goto ldv_42007;
  case 2: 
#line 474
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_2, ldv_irq_line_1_2, ldv_irq_data_1_2);
#line 476
  goto ldv_42007;
  case 3: 
#line 478
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_3, ldv_irq_line_1_3, ldv_irq_data_1_3);
#line 480
  goto ldv_42007;
  default: 
#line 481
  ldv_stop();
  }
  ldv_42007: ;
#line 483
  return;
}
}
#line 487 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void ldv_initialize_i2c_algorithm_5(void) 
{ 
  void *tmp ;

  {
#line 488
  tmp = ldv_init_zalloc(1936UL);
#line 488
  oaktrail_hdmi_i2c_algorithm_group0 = (struct i2c_adapter *)tmp;
#line 489
  return;
}
}
#line 491 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
int ldv_irq_1(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;
  int tmp___0 ;

  {
#line 493
  tmp = __VERIFIER_nondet_int();
#line 493
  irq_retval = (irqreturn_t )tmp;
#line 495
  if (state != 0) {
#line 496
    tmp___0 = __VERIFIER_nondet_int();
#line 496
    switch (tmp___0) {
    case 0: ;
#line 498
    if (state == 1) {
#line 499
      LDV_IN_INTERRUPT = 2;
#line 500
      irq_retval = oaktrail_hdmi_i2c_handler(line, data);
#line 501
      LDV_IN_INTERRUPT = 1;
#line 502
      return (state);
    } else {

    }
#line 505
    goto ldv_42022;
    default: 
#line 506
    ldv_stop();
    }
    ldv_42022: ;
  } else {

  }
#line 509
  return (state);
}
}
#line 514 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void ldv_main_exported_5(void) 
{ 
  int ldvarg216 ;
  struct i2c_msg *ldvarg217 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 516
  tmp = ldv_init_zalloc(16UL);
#line 516
  ldvarg217 = (struct i2c_msg *)tmp;
#line 515
  ldv_memset((void *)(& ldvarg216), 0, 4UL);
#line 518
  tmp___0 = __VERIFIER_nondet_int();
#line 518
  switch (tmp___0) {
  case 0: ;
#line 521
  if (ldv_state_variable_5 == 1) {
#line 523
    oaktrail_hdmi_i2c_access(oaktrail_hdmi_i2c_algorithm_group0, ldvarg217, ldvarg216);
#line 525
    ldv_state_variable_5 = 1;
  } else {

  }
#line 528
  goto ldv_42030;
  case 1: ;
#line 531
  if (ldv_state_variable_5 == 1) {
#line 533
    oaktrail_hdmi_i2c_func(oaktrail_hdmi_i2c_algorithm_group0);
#line 535
    ldv_state_variable_5 = 1;
  } else {

  }
#line 538
  goto ldv_42030;
  default: 
#line 539
  ldv_stop();
  }
  ldv_42030: ;
#line 543
  return;
}
}
#line 568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
bool ldv_queue_work_on_1604(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 572
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 572
  ldv_func_res = tmp;
#line 574
  activate_work_2(ldv_func_arg3, 2);
#line 576
  return (ldv_func_res);
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
bool ldv_queue_delayed_work_on_1605(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 583
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 583
  ldv_func_res = tmp;
#line 585
  activate_work_2(& ldv_func_arg3->work, 2);
#line 587
  return (ldv_func_res);
}
}
#line 590 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
bool ldv_queue_work_on_1606(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                            struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 594
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 594
  ldv_func_res = tmp;
#line 596
  activate_work_2(ldv_func_arg3, 2);
#line 598
  return (ldv_func_res);
}
}
#line 601 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void ldv_flush_workqueue_1607(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 604
  flush_workqueue(ldv_func_arg1);
#line 606
  call_and_disable_all_2(2);
#line 607
  return;
}
}
#line 609 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
bool ldv_queue_delayed_work_on_1608(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                    struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 613
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 613
  ldv_func_res = tmp;
#line 615
  activate_work_2(& ldv_func_arg3->work, 2);
#line 617
  return (ldv_func_res);
}
}
#line 620 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void ldv_mutex_lock_1609(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 623
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 625
  mutex_lock(ldv_func_arg1);
#line 626
  return;
}
}
#line 628 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void ldv_mutex_unlock_1610(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 631
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 633
  mutex_unlock(ldv_func_arg1);
#line 634
  return;
}
}
#line 636 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void ldv_mutex_lock_1611(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 639
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 641
  mutex_lock(ldv_func_arg1);
#line 642
  return;
}
}
#line 644 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
int ldv_mutex_trylock_1612(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 648
  tmp = mutex_trylock(ldv_func_arg1);
#line 648
  ldv_func_res = tmp;
#line 650
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 650
  return (tmp___0);
#line 652
  return (ldv_func_res);
}
}
#line 655 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void ldv_mutex_unlock_1613(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 658
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 660
  mutex_unlock(ldv_func_arg1);
#line 661
  return;
}
}
#line 663 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void ldv_mutex_unlock_1614(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 666
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 668
  mutex_unlock(ldv_func_arg1);
#line 669
  return;
}
}
#line 671 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void ldv_mutex_lock_1615(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 674
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 676
  mutex_lock(ldv_func_arg1);
#line 677
  return;
}
}
#line 679 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void ldv_mutex_lock_1616(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 682
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 684
  mutex_lock(ldv_func_arg1);
#line 685
  return;
}
}
#line 687 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void ldv_mutex_unlock_1617(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 690
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 692
  mutex_unlock(ldv_func_arg1);
#line 693
  return;
}
}
#line 695 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void ldv_mutex_unlock_1618(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 698
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 700
  mutex_unlock(ldv_func_arg1);
#line 701
  return;
}
}
#line 703 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void ldv_mutex_lock_1619(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 706
  ldv_mutex_lock_base_of_ww_mutex(ldv_func_arg1);
#line 708
  mutex_lock(ldv_func_arg1);
#line 709
  return;
}
}
#line 711 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
int ldv_mutex_lock_interruptible_1620(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 715
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 715
  ldv_func_res = tmp;
#line 717
  tmp___0 = ldv_mutex_lock_interruptible_base_of_ww_mutex(ldv_func_arg1);
#line 717
  return (tmp___0);
#line 719
  return (ldv_func_res);
}
}
#line 722 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
int ldv_mutex_trylock_1621(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 726
  tmp = mutex_trylock(ldv_func_arg1);
#line 726
  ldv_func_res = tmp;
#line 728
  tmp___0 = ldv_mutex_trylock_base_of_ww_mutex(ldv_func_arg1);
#line 728
  return (tmp___0);
#line 730
  return (ldv_func_res);
}
}
#line 754 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void ldv_mutex_unlock_1624(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 757
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 759
  mutex_unlock(ldv_func_arg1);
#line 760
  return;
}
}
#line 762 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void ldv_mutex_lock_1625(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 765
  ldv_mutex_lock_i2c_lock_of_hdmi_i2c_dev(ldv_func_arg1);
#line 767
  mutex_lock(ldv_func_arg1);
#line 768
  return;
}
}
#line 770 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void ldv_mutex_unlock_1626(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 773
  ldv_mutex_unlock_i2c_lock_of_hdmi_i2c_dev(ldv_func_arg1);
#line 775
  mutex_unlock(ldv_func_arg1);
#line 776
  return;
}
}
#line 778 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
__inline static int ldv_request_irq_1627(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                   void * ) ,
                                         unsigned long flags , char const   *name ,
                                         void *dev ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 782
  tmp = request_irq(irq, handler, flags, name, dev);
#line 782
  ldv_func_res = tmp;
#line 784
  tmp___0 = reg_check_1(handler);
#line 784
  if (tmp___0 != 0 && ldv_func_res == 0) {
#line 785
    activate_suitable_irq_1((int )irq, dev);
  } else {

  }
#line 788
  return (ldv_func_res);
}
}
#line 791 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void ldv_free_irq_1628(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 794
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 796
  disable_suitable_irq_1((int )ldv_func_arg1, ldv_func_arg2);
#line 797
  return;
}
}
#line 12 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static int ldv_undef_int_negative(void) 
{ 
  int ret ;
  int tmp ;

  {
#line 34
  tmp = ldv_undef_int();
#line 34
  ret = tmp;
#line 36
  if (ret >= 0) {
#line 36
    ldv_stop();
  } else {

  }
#line 38
  return (ret);
}
}
#line 7 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err(void const   *ptr ) 
{ 


  {
#line 10
  return ((unsigned long )ptr > 2012UL);
}
}
#line 14 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 17
  return ((void *)(2012L - error));
}
}
#line 21 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 24
  return ((long )(2012UL - (unsigned long )ptr));
}
}
#line 28 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 31
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 31
    tmp___0 = 1;
  } else {
#line 31
    tmp = ldv_is_err(ptr);
#line 31
    if ((int )tmp) {
#line 31
      tmp___0 = 1;
    } else {
#line 31
      tmp___0 = 0;
    }
  }
#line 31
  return ((bool )tmp___0);
}
}
#line 8 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_base_of_ww_mutex  =    1;
#line 11 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_base_of_ww_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 16
  if (ldv_mutex_base_of_ww_mutex != 1) {
#line 16
    ldv_error();
  } else {

  }
#line 19
  nondetermined = ldv_undef_int();
#line 22
  if (nondetermined != 0) {
#line 25
    ldv_mutex_base_of_ww_mutex = 2;
#line 27
    return (0);
  } else {
#line 32
    return (-4);
  }
}
}
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_base_of_ww_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 42
  if (ldv_mutex_base_of_ww_mutex != 1) {
#line 42
    ldv_error();
  } else {

  }
#line 45
  nondetermined = ldv_undef_int();
#line 48
  if (nondetermined != 0) {
#line 51
    ldv_mutex_base_of_ww_mutex = 2;
#line 53
    return (0);
  } else {
#line 58
    return (-4);
  }
}
}
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_base_of_ww_mutex(struct mutex *lock ) 
{ 


  {
#line 66
  if (ldv_mutex_base_of_ww_mutex != 1) {
#line 66
    ldv_error();
  } else {

  }
#line 68
  ldv_mutex_base_of_ww_mutex = 2;
#line 69
  return;
}
}
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_base_of_ww_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 77
  if (ldv_mutex_base_of_ww_mutex != 1) {
#line 77
    ldv_error();
  } else {

  }
#line 80
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 83
  if (is_mutex_held_by_another_thread != 0) {
#line 86
    return (0);
  } else {
#line 91
    ldv_mutex_base_of_ww_mutex = 2;
#line 93
    return (1);
  }
}
}
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_base_of_ww_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 103
  if (ldv_mutex_base_of_ww_mutex != 1) {
#line 103
    ldv_error();
  } else {

  }
#line 106
  atomic_value_after_dec = ldv_undef_int();
#line 109
  if (atomic_value_after_dec == 0) {
#line 112
    ldv_mutex_base_of_ww_mutex = 2;
#line 114
    return (1);
  } else {

  }
#line 118
  return (0);
}
}
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_base_of_ww_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 127
  if (ldv_mutex_base_of_ww_mutex == 1) {
#line 130
    nondetermined = ldv_undef_int();
#line 133
    if (nondetermined != 0) {
#line 136
      return (0);
    } else {
#line 141
      return (1);
    }
  } else {
#line 147
    return (1);
  }
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_base_of_ww_mutex(struct mutex *lock ) 
{ 


  {
#line 155
  if (ldv_mutex_base_of_ww_mutex != 2) {
#line 155
    ldv_error();
  } else {

  }
#line 157
  ldv_mutex_base_of_ww_mutex = 1;
#line 158
  return;
}
}
#line 163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_base_of_ww_mutex(void) 
{ 


  {
#line 166
  ldv_mutex_lock_base_of_ww_mutex((struct mutex *)0);
#line 167
  return;
}
}
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_base_of_ww_mutex(void) 
{ 
  int tmp ;

  {
#line 172
  tmp = ldv_mutex_trylock_base_of_ww_mutex((struct mutex *)0);
#line 172
  return (tmp);
}
}
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_base_of_ww_mutex(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 178
  tmp___0 = ldv_undef_int();
#line 178
  if (tmp___0 != 0) {
#line 180
    ldv_mutex_lock_base_of_ww_mutex((struct mutex *)0);
#line 182
    return (0);
  } else {
#line 185
    tmp = ldv_undef_int_negative();
#line 185
    return (tmp);
  }
}
}
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_base_of_ww_mutex(void) 
{ 


  {
#line 191
  ldv_mutex_unlock_base_of_ww_mutex((struct mutex *)0);
#line 192
  return;
}
}
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_gtt_mutex_of_drm_psb_private  =    1;
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_gtt_mutex_of_drm_psb_private(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 202
  if (ldv_mutex_gtt_mutex_of_drm_psb_private != 1) {
#line 202
    ldv_error();
  } else {

  }
#line 205
  nondetermined = ldv_undef_int();
#line 208
  if (nondetermined != 0) {
#line 211
    ldv_mutex_gtt_mutex_of_drm_psb_private = 2;
#line 213
    return (0);
  } else {
#line 218
    return (-4);
  }
}
}
#line 223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_gtt_mutex_of_drm_psb_private(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 228
  if (ldv_mutex_gtt_mutex_of_drm_psb_private != 1) {
#line 228
    ldv_error();
  } else {

  }
#line 231
  nondetermined = ldv_undef_int();
#line 234
  if (nondetermined != 0) {
#line 237
    ldv_mutex_gtt_mutex_of_drm_psb_private = 2;
#line 239
    return (0);
  } else {
#line 244
    return (-4);
  }
}
}
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_gtt_mutex_of_drm_psb_private(struct mutex *lock ) 
{ 


  {
#line 252
  if (ldv_mutex_gtt_mutex_of_drm_psb_private != 1) {
#line 252
    ldv_error();
  } else {

  }
#line 254
  ldv_mutex_gtt_mutex_of_drm_psb_private = 2;
#line 255
  return;
}
}
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_gtt_mutex_of_drm_psb_private(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 263
  if (ldv_mutex_gtt_mutex_of_drm_psb_private != 1) {
#line 263
    ldv_error();
  } else {

  }
#line 266
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 269
  if (is_mutex_held_by_another_thread != 0) {
#line 272
    return (0);
  } else {
#line 277
    ldv_mutex_gtt_mutex_of_drm_psb_private = 2;
#line 279
    return (1);
  }
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_gtt_mutex_of_drm_psb_private(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 289
  if (ldv_mutex_gtt_mutex_of_drm_psb_private != 1) {
#line 289
    ldv_error();
  } else {

  }
#line 292
  atomic_value_after_dec = ldv_undef_int();
#line 295
  if (atomic_value_after_dec == 0) {
#line 298
    ldv_mutex_gtt_mutex_of_drm_psb_private = 2;
#line 300
    return (1);
  } else {

  }
#line 304
  return (0);
}
}
#line 309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_gtt_mutex_of_drm_psb_private(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 313
  if (ldv_mutex_gtt_mutex_of_drm_psb_private == 1) {
#line 316
    nondetermined = ldv_undef_int();
#line 319
    if (nondetermined != 0) {
#line 322
      return (0);
    } else {
#line 327
      return (1);
    }
  } else {
#line 333
    return (1);
  }
}
}
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_gtt_mutex_of_drm_psb_private(struct mutex *lock ) 
{ 


  {
#line 341
  if (ldv_mutex_gtt_mutex_of_drm_psb_private != 2) {
#line 341
    ldv_error();
  } else {

  }
#line 343
  ldv_mutex_gtt_mutex_of_drm_psb_private = 1;
#line 344
  return;
}
}
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_gtt_mutex_of_drm_psb_private(void) 
{ 


  {
#line 352
  ldv_mutex_lock_gtt_mutex_of_drm_psb_private((struct mutex *)0);
#line 353
  return;
}
}
#line 356 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_gtt_mutex_of_drm_psb_private(void) 
{ 
  int tmp ;

  {
#line 358
  tmp = ldv_mutex_trylock_gtt_mutex_of_drm_psb_private((struct mutex *)0);
#line 358
  return (tmp);
}
}
#line 362 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_gtt_mutex_of_drm_psb_private(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 364
  tmp___0 = ldv_undef_int();
#line 364
  if (tmp___0 != 0) {
#line 366
    ldv_mutex_lock_gtt_mutex_of_drm_psb_private((struct mutex *)0);
#line 368
    return (0);
  } else {
#line 371
    tmp = ldv_undef_int_negative();
#line 371
    return (tmp);
  }
}
}
#line 375 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_gtt_mutex_of_drm_psb_private(void) 
{ 


  {
#line 377
  ldv_mutex_unlock_gtt_mutex_of_drm_psb_private((struct mutex *)0);
#line 378
  return;
}
}
#line 380 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_i2c_lock_of_hdmi_i2c_dev  =    1;
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_i2c_lock_of_hdmi_i2c_dev(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 388
  if (ldv_mutex_i2c_lock_of_hdmi_i2c_dev != 1) {
#line 388
    ldv_error();
  } else {

  }
#line 391
  nondetermined = ldv_undef_int();
#line 394
  if (nondetermined != 0) {
#line 397
    ldv_mutex_i2c_lock_of_hdmi_i2c_dev = 2;
#line 399
    return (0);
  } else {
#line 404
    return (-4);
  }
}
}
#line 409 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_i2c_lock_of_hdmi_i2c_dev(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 414
  if (ldv_mutex_i2c_lock_of_hdmi_i2c_dev != 1) {
#line 414
    ldv_error();
  } else {

  }
#line 417
  nondetermined = ldv_undef_int();
#line 420
  if (nondetermined != 0) {
#line 423
    ldv_mutex_i2c_lock_of_hdmi_i2c_dev = 2;
#line 425
    return (0);
  } else {
#line 430
    return (-4);
  }
}
}
#line 435 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_i2c_lock_of_hdmi_i2c_dev(struct mutex *lock ) 
{ 


  {
#line 438
  if (ldv_mutex_i2c_lock_of_hdmi_i2c_dev != 1) {
#line 438
    ldv_error();
  } else {

  }
#line 440
  ldv_mutex_i2c_lock_of_hdmi_i2c_dev = 2;
#line 441
  return;
}
}
#line 444 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_i2c_lock_of_hdmi_i2c_dev(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 449
  if (ldv_mutex_i2c_lock_of_hdmi_i2c_dev != 1) {
#line 449
    ldv_error();
  } else {

  }
#line 452
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 455
  if (is_mutex_held_by_another_thread != 0) {
#line 458
    return (0);
  } else {
#line 463
    ldv_mutex_i2c_lock_of_hdmi_i2c_dev = 2;
#line 465
    return (1);
  }
}
}
#line 470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_i2c_lock_of_hdmi_i2c_dev(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 475
  if (ldv_mutex_i2c_lock_of_hdmi_i2c_dev != 1) {
#line 475
    ldv_error();
  } else {

  }
#line 478
  atomic_value_after_dec = ldv_undef_int();
#line 481
  if (atomic_value_after_dec == 0) {
#line 484
    ldv_mutex_i2c_lock_of_hdmi_i2c_dev = 2;
#line 486
    return (1);
  } else {

  }
#line 490
  return (0);
}
}
#line 495 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_i2c_lock_of_hdmi_i2c_dev(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 499
  if (ldv_mutex_i2c_lock_of_hdmi_i2c_dev == 1) {
#line 502
    nondetermined = ldv_undef_int();
#line 505
    if (nondetermined != 0) {
#line 508
      return (0);
    } else {
#line 513
      return (1);
    }
  } else {
#line 519
    return (1);
  }
}
}
#line 524 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_i2c_lock_of_hdmi_i2c_dev(struct mutex *lock ) 
{ 


  {
#line 527
  if (ldv_mutex_i2c_lock_of_hdmi_i2c_dev != 2) {
#line 527
    ldv_error();
  } else {

  }
#line 529
  ldv_mutex_i2c_lock_of_hdmi_i2c_dev = 1;
#line 530
  return;
}
}
#line 535 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_i2c_lock_of_hdmi_i2c_dev(void) 
{ 


  {
#line 538
  ldv_mutex_lock_i2c_lock_of_hdmi_i2c_dev((struct mutex *)0);
#line 539
  return;
}
}
#line 542 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_i2c_lock_of_hdmi_i2c_dev(void) 
{ 
  int tmp ;

  {
#line 544
  tmp = ldv_mutex_trylock_i2c_lock_of_hdmi_i2c_dev((struct mutex *)0);
#line 544
  return (tmp);
}
}
#line 548 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_i2c_lock_of_hdmi_i2c_dev(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 550
  tmp___0 = ldv_undef_int();
#line 550
  if (tmp___0 != 0) {
#line 552
    ldv_mutex_lock_i2c_lock_of_hdmi_i2c_dev((struct mutex *)0);
#line 554
    return (0);
  } else {
#line 557
    tmp = ldv_undef_int_negative();
#line 557
    return (tmp);
  }
}
}
#line 561 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_i2c_lock_of_hdmi_i2c_dev(void) 
{ 


  {
#line 563
  ldv_mutex_unlock_i2c_lock_of_hdmi_i2c_dev((struct mutex *)0);
#line 564
  return;
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_i_mutex_of_inode  =    1;
#line 569 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 574
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 574
    ldv_error();
  } else {

  }
#line 577
  nondetermined = ldv_undef_int();
#line 580
  if (nondetermined != 0) {
#line 583
    ldv_mutex_i_mutex_of_inode = 2;
#line 585
    return (0);
  } else {
#line 590
    return (-4);
  }
}
}
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 600
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 600
    ldv_error();
  } else {

  }
#line 603
  nondetermined = ldv_undef_int();
#line 606
  if (nondetermined != 0) {
#line 609
    ldv_mutex_i_mutex_of_inode = 2;
#line 611
    return (0);
  } else {
#line 616
    return (-4);
  }
}
}
#line 621 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
#line 624
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 624
    ldv_error();
  } else {

  }
#line 626
  ldv_mutex_i_mutex_of_inode = 2;
#line 627
  return;
}
}
#line 630 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 635
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 635
    ldv_error();
  } else {

  }
#line 638
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 641
  if (is_mutex_held_by_another_thread != 0) {
#line 644
    return (0);
  } else {
#line 649
    ldv_mutex_i_mutex_of_inode = 2;
#line 651
    return (1);
  }
}
}
#line 656 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_i_mutex_of_inode(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 661
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 661
    ldv_error();
  } else {

  }
#line 664
  atomic_value_after_dec = ldv_undef_int();
#line 667
  if (atomic_value_after_dec == 0) {
#line 670
    ldv_mutex_i_mutex_of_inode = 2;
#line 672
    return (1);
  } else {

  }
#line 676
  return (0);
}
}
#line 681 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 685
  if (ldv_mutex_i_mutex_of_inode == 1) {
#line 688
    nondetermined = ldv_undef_int();
#line 691
    if (nondetermined != 0) {
#line 694
      return (0);
    } else {
#line 699
      return (1);
    }
  } else {
#line 705
    return (1);
  }
}
}
#line 710 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
#line 713
  if (ldv_mutex_i_mutex_of_inode != 2) {
#line 713
    ldv_error();
  } else {

  }
#line 715
  ldv_mutex_i_mutex_of_inode = 1;
#line 716
  return;
}
}
#line 721 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_i_mutex_of_inode(void) 
{ 


  {
#line 724
  ldv_mutex_lock_i_mutex_of_inode((struct mutex *)0);
#line 725
  return;
}
}
#line 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_i_mutex_of_inode(void) 
{ 
  int tmp ;

  {
#line 730
  tmp = ldv_mutex_trylock_i_mutex_of_inode((struct mutex *)0);
#line 730
  return (tmp);
}
}
#line 734 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_i_mutex_of_inode(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 736
  tmp___0 = ldv_undef_int();
#line 736
  if (tmp___0 != 0) {
#line 738
    ldv_mutex_lock_i_mutex_of_inode((struct mutex *)0);
#line 740
    return (0);
  } else {
#line 743
    tmp = ldv_undef_int_negative();
#line 743
    return (tmp);
  }
}
}
#line 747 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_i_mutex_of_inode(void) 
{ 


  {
#line 749
  ldv_mutex_unlock_i_mutex_of_inode((struct mutex *)0);
#line 750
  return;
}
}
#line 752 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lock  =    1;
#line 755 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 760
  if (ldv_mutex_lock != 1) {
#line 760
    ldv_error();
  } else {

  }
#line 763
  nondetermined = ldv_undef_int();
#line 766
  if (nondetermined != 0) {
#line 769
    ldv_mutex_lock = 2;
#line 771
    return (0);
  } else {
#line 776
    return (-4);
  }
}
}
#line 781 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 786
  if (ldv_mutex_lock != 1) {
#line 786
    ldv_error();
  } else {

  }
#line 789
  nondetermined = ldv_undef_int();
#line 792
  if (nondetermined != 0) {
#line 795
    ldv_mutex_lock = 2;
#line 797
    return (0);
  } else {
#line 802
    return (-4);
  }
}
}
#line 807 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lock(struct mutex *lock ) 
{ 


  {
#line 810
  if (ldv_mutex_lock != 1) {
#line 810
    ldv_error();
  } else {

  }
#line 812
  ldv_mutex_lock = 2;
#line 813
  return;
}
}
#line 816 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lock(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 821
  if (ldv_mutex_lock != 1) {
#line 821
    ldv_error();
  } else {

  }
#line 824
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 827
  if (is_mutex_held_by_another_thread != 0) {
#line 830
    return (0);
  } else {
#line 835
    ldv_mutex_lock = 2;
#line 837
    return (1);
  }
}
}
#line 842 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lock(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 847
  if (ldv_mutex_lock != 1) {
#line 847
    ldv_error();
  } else {

  }
#line 850
  atomic_value_after_dec = ldv_undef_int();
#line 853
  if (atomic_value_after_dec == 0) {
#line 856
    ldv_mutex_lock = 2;
#line 858
    return (1);
  } else {

  }
#line 862
  return (0);
}
}
#line 867 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 871
  if (ldv_mutex_lock == 1) {
#line 874
    nondetermined = ldv_undef_int();
#line 877
    if (nondetermined != 0) {
#line 880
      return (0);
    } else {
#line 885
      return (1);
    }
  } else {
#line 891
    return (1);
  }
}
}
#line 896 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lock(struct mutex *lock ) 
{ 


  {
#line 899
  if (ldv_mutex_lock != 2) {
#line 899
    ldv_error();
  } else {

  }
#line 901
  ldv_mutex_lock = 1;
#line 902
  return;
}
}
#line 907 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_lock(void) 
{ 


  {
#line 910
  ldv_mutex_lock_lock((struct mutex *)0);
#line 911
  return;
}
}
#line 914 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_lock(void) 
{ 
  int tmp ;

  {
#line 916
  tmp = ldv_mutex_trylock_lock((struct mutex *)0);
#line 916
  return (tmp);
}
}
#line 920 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_lock(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 922
  tmp___0 = ldv_undef_int();
#line 922
  if (tmp___0 != 0) {
#line 924
    ldv_mutex_lock_lock((struct mutex *)0);
#line 926
    return (0);
  } else {
#line 929
    tmp = ldv_undef_int_negative();
#line 929
    return (tmp);
  }
}
}
#line 933 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_lock(void) 
{ 


  {
#line 935
  ldv_mutex_unlock_lock((struct mutex *)0);
#line 936
  return;
}
}
#line 938 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lock_of_fb_info  =    1;
#line 941 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lock_of_fb_info(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 946
  if (ldv_mutex_lock_of_fb_info != 1) {
#line 946
    ldv_error();
  } else {

  }
#line 949
  nondetermined = ldv_undef_int();
#line 952
  if (nondetermined != 0) {
#line 955
    ldv_mutex_lock_of_fb_info = 2;
#line 957
    return (0);
  } else {
#line 962
    return (-4);
  }
}
}
#line 967 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lock_of_fb_info(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 972
  if (ldv_mutex_lock_of_fb_info != 1) {
#line 972
    ldv_error();
  } else {

  }
#line 975
  nondetermined = ldv_undef_int();
#line 978
  if (nondetermined != 0) {
#line 981
    ldv_mutex_lock_of_fb_info = 2;
#line 983
    return (0);
  } else {
#line 988
    return (-4);
  }
}
}
#line 993 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lock_of_fb_info(struct mutex *lock ) 
{ 


  {
#line 996
  if (ldv_mutex_lock_of_fb_info != 1) {
#line 996
    ldv_error();
  } else {

  }
#line 998
  ldv_mutex_lock_of_fb_info = 2;
#line 999
  return;
}
}
#line 1002 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lock_of_fb_info(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1007
  if (ldv_mutex_lock_of_fb_info != 1) {
#line 1007
    ldv_error();
  } else {

  }
#line 1010
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 1013
  if (is_mutex_held_by_another_thread != 0) {
#line 1016
    return (0);
  } else {
#line 1021
    ldv_mutex_lock_of_fb_info = 2;
#line 1023
    return (1);
  }
}
}
#line 1028 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lock_of_fb_info(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1033
  if (ldv_mutex_lock_of_fb_info != 1) {
#line 1033
    ldv_error();
  } else {

  }
#line 1036
  atomic_value_after_dec = ldv_undef_int();
#line 1039
  if (atomic_value_after_dec == 0) {
#line 1042
    ldv_mutex_lock_of_fb_info = 2;
#line 1044
    return (1);
  } else {

  }
#line 1048
  return (0);
}
}
#line 1053 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lock_of_fb_info(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1057
  if (ldv_mutex_lock_of_fb_info == 1) {
#line 1060
    nondetermined = ldv_undef_int();
#line 1063
    if (nondetermined != 0) {
#line 1066
      return (0);
    } else {
#line 1071
      return (1);
    }
  } else {
#line 1077
    return (1);
  }
}
}
#line 1082 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lock_of_fb_info(struct mutex *lock ) 
{ 


  {
#line 1085
  if (ldv_mutex_lock_of_fb_info != 2) {
#line 1085
    ldv_error();
  } else {

  }
#line 1087
  ldv_mutex_lock_of_fb_info = 1;
#line 1088
  return;
}
}
#line 1093 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_lock_of_fb_info(void) 
{ 


  {
#line 1096
  ldv_mutex_lock_lock_of_fb_info((struct mutex *)0);
#line 1097
  return;
}
}
#line 1100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_lock_of_fb_info(void) 
{ 
  int tmp ;

  {
#line 1102
  tmp = ldv_mutex_trylock_lock_of_fb_info((struct mutex *)0);
#line 1102
  return (tmp);
}
}
#line 1106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_lock_of_fb_info(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1108
  tmp___0 = ldv_undef_int();
#line 1108
  if (tmp___0 != 0) {
#line 1110
    ldv_mutex_lock_lock_of_fb_info((struct mutex *)0);
#line 1112
    return (0);
  } else {
#line 1115
    tmp = ldv_undef_int_negative();
#line 1115
    return (tmp);
  }
}
}
#line 1119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_lock_of_fb_info(void) 
{ 


  {
#line 1121
  ldv_mutex_unlock_lock_of_fb_info((struct mutex *)0);
#line 1122
  return;
}
}
#line 1124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_device  =    1;
#line 1127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1132
  if (ldv_mutex_mutex_of_device != 1) {
#line 1132
    ldv_error();
  } else {

  }
#line 1135
  nondetermined = ldv_undef_int();
#line 1138
  if (nondetermined != 0) {
#line 1141
    ldv_mutex_mutex_of_device = 2;
#line 1143
    return (0);
  } else {
#line 1148
    return (-4);
  }
}
}
#line 1153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1158
  if (ldv_mutex_mutex_of_device != 1) {
#line 1158
    ldv_error();
  } else {

  }
#line 1161
  nondetermined = ldv_undef_int();
#line 1164
  if (nondetermined != 0) {
#line 1167
    ldv_mutex_mutex_of_device = 2;
#line 1169
    return (0);
  } else {
#line 1174
    return (-4);
  }
}
}
#line 1179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) 
{ 


  {
#line 1182
  if (ldv_mutex_mutex_of_device != 1) {
#line 1182
    ldv_error();
  } else {

  }
#line 1184
  ldv_mutex_mutex_of_device = 2;
#line 1185
  return;
}
}
#line 1188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1193
  if (ldv_mutex_mutex_of_device != 1) {
#line 1193
    ldv_error();
  } else {

  }
#line 1196
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 1199
  if (is_mutex_held_by_another_thread != 0) {
#line 1202
    return (0);
  } else {
#line 1207
    ldv_mutex_mutex_of_device = 2;
#line 1209
    return (1);
  }
}
}
#line 1214 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_device(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1219
  if (ldv_mutex_mutex_of_device != 1) {
#line 1219
    ldv_error();
  } else {

  }
#line 1222
  atomic_value_after_dec = ldv_undef_int();
#line 1225
  if (atomic_value_after_dec == 0) {
#line 1228
    ldv_mutex_mutex_of_device = 2;
#line 1230
    return (1);
  } else {

  }
#line 1234
  return (0);
}
}
#line 1239 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1243
  if (ldv_mutex_mutex_of_device == 1) {
#line 1246
    nondetermined = ldv_undef_int();
#line 1249
    if (nondetermined != 0) {
#line 1252
      return (0);
    } else {
#line 1257
      return (1);
    }
  } else {
#line 1263
    return (1);
  }
}
}
#line 1268 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) 
{ 


  {
#line 1271
  if (ldv_mutex_mutex_of_device != 2) {
#line 1271
    ldv_error();
  } else {

  }
#line 1273
  ldv_mutex_mutex_of_device = 1;
#line 1274
  return;
}
}
#line 1279 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_mutex_of_device(void) 
{ 


  {
#line 1282
  ldv_mutex_lock_mutex_of_device((struct mutex *)0);
#line 1283
  return;
}
}
#line 1286 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_mutex_of_device(void) 
{ 
  int tmp ;

  {
#line 1288
  tmp = ldv_mutex_trylock_mutex_of_device((struct mutex *)0);
#line 1288
  return (tmp);
}
}
#line 1292 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_mutex_of_device(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1294
  tmp___0 = ldv_undef_int();
#line 1294
  if (tmp___0 != 0) {
#line 1296
    ldv_mutex_lock_mutex_of_device((struct mutex *)0);
#line 1298
    return (0);
  } else {
#line 1301
    tmp = ldv_undef_int_negative();
#line 1301
    return (tmp);
  }
}
}
#line 1305 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_mutex_of_device(void) 
{ 


  {
#line 1307
  ldv_mutex_unlock_mutex_of_device((struct mutex *)0);
#line 1308
  return;
}
}
#line 1310 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_drm_mode_config  =    1;
#line 1313 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_drm_mode_config(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1318
  if (ldv_mutex_mutex_of_drm_mode_config != 1) {
#line 1318
    ldv_error();
  } else {

  }
#line 1321
  nondetermined = ldv_undef_int();
#line 1324
  if (nondetermined != 0) {
#line 1327
    ldv_mutex_mutex_of_drm_mode_config = 2;
#line 1329
    return (0);
  } else {
#line 1334
    return (-4);
  }
}
}
#line 1339 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_drm_mode_config(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1344
  if (ldv_mutex_mutex_of_drm_mode_config != 1) {
#line 1344
    ldv_error();
  } else {

  }
#line 1347
  nondetermined = ldv_undef_int();
#line 1350
  if (nondetermined != 0) {
#line 1353
    ldv_mutex_mutex_of_drm_mode_config = 2;
#line 1355
    return (0);
  } else {
#line 1360
    return (-4);
  }
}
}
#line 1365 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_drm_mode_config(struct mutex *lock ) 
{ 


  {
#line 1368
  if (ldv_mutex_mutex_of_drm_mode_config != 1) {
#line 1368
    ldv_error();
  } else {

  }
#line 1370
  ldv_mutex_mutex_of_drm_mode_config = 2;
#line 1371
  return;
}
}
#line 1374 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_drm_mode_config(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1379
  if (ldv_mutex_mutex_of_drm_mode_config != 1) {
#line 1379
    ldv_error();
  } else {

  }
#line 1382
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 1385
  if (is_mutex_held_by_another_thread != 0) {
#line 1388
    return (0);
  } else {
#line 1393
    ldv_mutex_mutex_of_drm_mode_config = 2;
#line 1395
    return (1);
  }
}
}
#line 1400 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_drm_mode_config(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1405
  if (ldv_mutex_mutex_of_drm_mode_config != 1) {
#line 1405
    ldv_error();
  } else {

  }
#line 1408
  atomic_value_after_dec = ldv_undef_int();
#line 1411
  if (atomic_value_after_dec == 0) {
#line 1414
    ldv_mutex_mutex_of_drm_mode_config = 2;
#line 1416
    return (1);
  } else {

  }
#line 1420
  return (0);
}
}
#line 1425 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_drm_mode_config(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1429
  if (ldv_mutex_mutex_of_drm_mode_config == 1) {
#line 1432
    nondetermined = ldv_undef_int();
#line 1435
    if (nondetermined != 0) {
#line 1438
      return (0);
    } else {
#line 1443
      return (1);
    }
  } else {
#line 1449
    return (1);
  }
}
}
#line 1454 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_drm_mode_config(struct mutex *lock ) 
{ 


  {
#line 1457
  if (ldv_mutex_mutex_of_drm_mode_config != 2) {
#line 1457
    ldv_error();
  } else {

  }
#line 1459
  ldv_mutex_mutex_of_drm_mode_config = 1;
#line 1460
  return;
}
}
#line 1465 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_mutex_of_drm_mode_config(void) 
{ 


  {
#line 1468
  ldv_mutex_lock_mutex_of_drm_mode_config((struct mutex *)0);
#line 1469
  return;
}
}
#line 1472 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_mutex_of_drm_mode_config(void) 
{ 
  int tmp ;

  {
#line 1474
  tmp = ldv_mutex_trylock_mutex_of_drm_mode_config((struct mutex *)0);
#line 1474
  return (tmp);
}
}
#line 1478 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_mutex_of_drm_mode_config(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1480
  tmp___0 = ldv_undef_int();
#line 1480
  if (tmp___0 != 0) {
#line 1482
    ldv_mutex_lock_mutex_of_drm_mode_config((struct mutex *)0);
#line 1484
    return (0);
  } else {
#line 1487
    tmp = ldv_undef_int_negative();
#line 1487
    return (tmp);
  }
}
}
#line 1491 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_mutex_of_drm_mode_config(void) 
{ 


  {
#line 1493
  ldv_mutex_unlock_mutex_of_drm_mode_config((struct mutex *)0);
#line 1494
  return;
}
}
#line 1496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_power_mutex  =    1;
#line 1499 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_power_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1504
  if (ldv_mutex_power_mutex != 1) {
#line 1504
    ldv_error();
  } else {

  }
#line 1507
  nondetermined = ldv_undef_int();
#line 1510
  if (nondetermined != 0) {
#line 1513
    ldv_mutex_power_mutex = 2;
#line 1515
    return (0);
  } else {
#line 1520
    return (-4);
  }
}
}
#line 1525 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_power_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1530
  if (ldv_mutex_power_mutex != 1) {
#line 1530
    ldv_error();
  } else {

  }
#line 1533
  nondetermined = ldv_undef_int();
#line 1536
  if (nondetermined != 0) {
#line 1539
    ldv_mutex_power_mutex = 2;
#line 1541
    return (0);
  } else {
#line 1546
    return (-4);
  }
}
}
#line 1551 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_power_mutex(struct mutex *lock ) 
{ 


  {
#line 1554
  if (ldv_mutex_power_mutex != 1) {
#line 1554
    ldv_error();
  } else {

  }
#line 1556
  ldv_mutex_power_mutex = 2;
#line 1557
  return;
}
}
#line 1560 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_power_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1565
  if (ldv_mutex_power_mutex != 1) {
#line 1565
    ldv_error();
  } else {

  }
#line 1568
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 1571
  if (is_mutex_held_by_another_thread != 0) {
#line 1574
    return (0);
  } else {
#line 1579
    ldv_mutex_power_mutex = 2;
#line 1581
    return (1);
  }
}
}
#line 1586 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_power_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1591
  if (ldv_mutex_power_mutex != 1) {
#line 1591
    ldv_error();
  } else {

  }
#line 1594
  atomic_value_after_dec = ldv_undef_int();
#line 1597
  if (atomic_value_after_dec == 0) {
#line 1600
    ldv_mutex_power_mutex = 2;
#line 1602
    return (1);
  } else {

  }
#line 1606
  return (0);
}
}
#line 1611 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_power_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1615
  if (ldv_mutex_power_mutex == 1) {
#line 1618
    nondetermined = ldv_undef_int();
#line 1621
    if (nondetermined != 0) {
#line 1624
      return (0);
    } else {
#line 1629
      return (1);
    }
  } else {
#line 1635
    return (1);
  }
}
}
#line 1640 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_power_mutex(struct mutex *lock ) 
{ 


  {
#line 1643
  if (ldv_mutex_power_mutex != 2) {
#line 1643
    ldv_error();
  } else {

  }
#line 1645
  ldv_mutex_power_mutex = 1;
#line 1646
  return;
}
}
#line 1651 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_power_mutex(void) 
{ 


  {
#line 1654
  ldv_mutex_lock_power_mutex((struct mutex *)0);
#line 1655
  return;
}
}
#line 1658 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_power_mutex(void) 
{ 
  int tmp ;

  {
#line 1660
  tmp = ldv_mutex_trylock_power_mutex((struct mutex *)0);
#line 1660
  return (tmp);
}
}
#line 1664 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_power_mutex(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1666
  tmp___0 = ldv_undef_int();
#line 1666
  if (tmp___0 != 0) {
#line 1668
    ldv_mutex_lock_power_mutex((struct mutex *)0);
#line 1670
    return (0);
  } else {
#line 1673
    tmp = ldv_undef_int_negative();
#line 1673
    return (tmp);
  }
}
}
#line 1677 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_power_mutex(void) 
{ 


  {
#line 1679
  ldv_mutex_unlock_power_mutex((struct mutex *)0);
#line 1680
  return;
}
}
#line 1682 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_struct_mutex_of_drm_device  =    1;
#line 1685 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_struct_mutex_of_drm_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1690
  if (ldv_mutex_struct_mutex_of_drm_device != 1) {
#line 1690
    ldv_error();
  } else {

  }
#line 1693
  nondetermined = ldv_undef_int();
#line 1696
  if (nondetermined != 0) {
#line 1699
    ldv_mutex_struct_mutex_of_drm_device = 2;
#line 1701
    return (0);
  } else {
#line 1706
    return (-4);
  }
}
}
#line 1711 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_struct_mutex_of_drm_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1716
  if (ldv_mutex_struct_mutex_of_drm_device != 1) {
#line 1716
    ldv_error();
  } else {

  }
#line 1719
  nondetermined = ldv_undef_int();
#line 1722
  if (nondetermined != 0) {
#line 1725
    ldv_mutex_struct_mutex_of_drm_device = 2;
#line 1727
    return (0);
  } else {
#line 1732
    return (-4);
  }
}
}
#line 1737 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_struct_mutex_of_drm_device(struct mutex *lock ) 
{ 


  {
#line 1740
  if (ldv_mutex_struct_mutex_of_drm_device != 1) {
#line 1740
    ldv_error();
  } else {

  }
#line 1742
  ldv_mutex_struct_mutex_of_drm_device = 2;
#line 1743
  return;
}
}
#line 1746 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_struct_mutex_of_drm_device(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1751
  if (ldv_mutex_struct_mutex_of_drm_device != 1) {
#line 1751
    ldv_error();
  } else {

  }
#line 1754
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 1757
  if (is_mutex_held_by_another_thread != 0) {
#line 1760
    return (0);
  } else {
#line 1765
    ldv_mutex_struct_mutex_of_drm_device = 2;
#line 1767
    return (1);
  }
}
}
#line 1772 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_struct_mutex_of_drm_device(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1777
  if (ldv_mutex_struct_mutex_of_drm_device != 1) {
#line 1777
    ldv_error();
  } else {

  }
#line 1780
  atomic_value_after_dec = ldv_undef_int();
#line 1783
  if (atomic_value_after_dec == 0) {
#line 1786
    ldv_mutex_struct_mutex_of_drm_device = 2;
#line 1788
    return (1);
  } else {

  }
#line 1792
  return (0);
}
}
#line 1797 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_struct_mutex_of_drm_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1801
  if (ldv_mutex_struct_mutex_of_drm_device == 1) {
#line 1804
    nondetermined = ldv_undef_int();
#line 1807
    if (nondetermined != 0) {
#line 1810
      return (0);
    } else {
#line 1815
      return (1);
    }
  } else {
#line 1821
    return (1);
  }
}
}
#line 1826 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_struct_mutex_of_drm_device(struct mutex *lock ) 
{ 


  {
#line 1829
  if (ldv_mutex_struct_mutex_of_drm_device != 2) {
#line 1829
    ldv_error();
  } else {

  }
#line 1831
  ldv_mutex_struct_mutex_of_drm_device = 1;
#line 1832
  return;
}
}
#line 1837 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_struct_mutex_of_drm_device(void) 
{ 


  {
#line 1840
  ldv_mutex_lock_struct_mutex_of_drm_device((struct mutex *)0);
#line 1841
  return;
}
}
#line 1844 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_struct_mutex_of_drm_device(void) 
{ 
  int tmp ;

  {
#line 1846
  tmp = ldv_mutex_trylock_struct_mutex_of_drm_device((struct mutex *)0);
#line 1846
  return (tmp);
}
}
#line 1850 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_struct_mutex_of_drm_device(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1852
  tmp___0 = ldv_undef_int();
#line 1852
  if (tmp___0 != 0) {
#line 1854
    ldv_mutex_lock_struct_mutex_of_drm_device((struct mutex *)0);
#line 1856
    return (0);
  } else {
#line 1859
    tmp = ldv_undef_int_negative();
#line 1859
    return (tmp);
  }
}
}
#line 1863 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_struct_mutex_of_drm_device(void) 
{ 


  {
#line 1865
  ldv_mutex_unlock_struct_mutex_of_drm_device((struct mutex *)0);
#line 1866
  return;
}
}
#line 1868 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_update_lock_of_backlight_device  =    1;
#line 1871 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_update_lock_of_backlight_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1876
  if (ldv_mutex_update_lock_of_backlight_device != 1) {
#line 1876
    ldv_error();
  } else {

  }
#line 1879
  nondetermined = ldv_undef_int();
#line 1882
  if (nondetermined != 0) {
#line 1885
    ldv_mutex_update_lock_of_backlight_device = 2;
#line 1887
    return (0);
  } else {
#line 1892
    return (-4);
  }
}
}
#line 1897 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_update_lock_of_backlight_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1902
  if (ldv_mutex_update_lock_of_backlight_device != 1) {
#line 1902
    ldv_error();
  } else {

  }
#line 1905
  nondetermined = ldv_undef_int();
#line 1908
  if (nondetermined != 0) {
#line 1911
    ldv_mutex_update_lock_of_backlight_device = 2;
#line 1913
    return (0);
  } else {
#line 1918
    return (-4);
  }
}
}
#line 1923 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_update_lock_of_backlight_device(struct mutex *lock ) 
{ 


  {
#line 1926
  if (ldv_mutex_update_lock_of_backlight_device != 1) {
#line 1926
    ldv_error();
  } else {

  }
#line 1928
  ldv_mutex_update_lock_of_backlight_device = 2;
#line 1929
  return;
}
}
#line 1932 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_update_lock_of_backlight_device(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1937
  if (ldv_mutex_update_lock_of_backlight_device != 1) {
#line 1937
    ldv_error();
  } else {

  }
#line 1940
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 1943
  if (is_mutex_held_by_another_thread != 0) {
#line 1946
    return (0);
  } else {
#line 1951
    ldv_mutex_update_lock_of_backlight_device = 2;
#line 1953
    return (1);
  }
}
}
#line 1958 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_update_lock_of_backlight_device(atomic_t *cnt ,
                                                                  struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1963
  if (ldv_mutex_update_lock_of_backlight_device != 1) {
#line 1963
    ldv_error();
  } else {

  }
#line 1966
  atomic_value_after_dec = ldv_undef_int();
#line 1969
  if (atomic_value_after_dec == 0) {
#line 1972
    ldv_mutex_update_lock_of_backlight_device = 2;
#line 1974
    return (1);
  } else {

  }
#line 1978
  return (0);
}
}
#line 1983 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_update_lock_of_backlight_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1987
  if (ldv_mutex_update_lock_of_backlight_device == 1) {
#line 1990
    nondetermined = ldv_undef_int();
#line 1993
    if (nondetermined != 0) {
#line 1996
      return (0);
    } else {
#line 2001
      return (1);
    }
  } else {
#line 2007
    return (1);
  }
}
}
#line 2012 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_update_lock_of_backlight_device(struct mutex *lock ) 
{ 


  {
#line 2015
  if (ldv_mutex_update_lock_of_backlight_device != 2) {
#line 2015
    ldv_error();
  } else {

  }
#line 2017
  ldv_mutex_update_lock_of_backlight_device = 1;
#line 2018
  return;
}
}
#line 2023 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_update_lock_of_backlight_device(void) 
{ 


  {
#line 2026
  ldv_mutex_lock_update_lock_of_backlight_device((struct mutex *)0);
#line 2027
  return;
}
}
#line 2030 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_update_lock_of_backlight_device(void) 
{ 
  int tmp ;

  {
#line 2032
  tmp = ldv_mutex_trylock_update_lock_of_backlight_device((struct mutex *)0);
#line 2032
  return (tmp);
}
}
#line 2036 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_update_lock_of_backlight_device(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2038
  tmp___0 = ldv_undef_int();
#line 2038
  if (tmp___0 != 0) {
#line 2040
    ldv_mutex_lock_update_lock_of_backlight_device((struct mutex *)0);
#line 2042
    return (0);
  } else {
#line 2045
    tmp = ldv_undef_int_negative();
#line 2045
    return (tmp);
  }
}
}
#line 2049 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_update_lock_of_backlight_device(void) 
{ 


  {
#line 2051
  ldv_mutex_unlock_update_lock_of_backlight_device((struct mutex *)0);
#line 2052
  return;
}
}
#line 2056 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10068/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 2059
  if (ldv_mutex_base_of_ww_mutex != 1) {
#line 2059
    ldv_error();
  } else {

  }
#line 2061
  if (ldv_mutex_gtt_mutex_of_drm_psb_private != 1) {
#line 2061
    ldv_error();
  } else {

  }
#line 2063
  if (ldv_mutex_i2c_lock_of_hdmi_i2c_dev != 1) {
#line 2063
    ldv_error();
  } else {

  }
#line 2065
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 2065
    ldv_error();
  } else {

  }
#line 2067
  if (ldv_mutex_lock != 1) {
#line 2067
    ldv_error();
  } else {

  }
#line 2069
  if (ldv_mutex_lock_of_fb_info != 1) {
#line 2069
    ldv_error();
  } else {

  }
#line 2071
  if (ldv_mutex_mutex_of_device != 1) {
#line 2071
    ldv_error();
  } else {

  }
#line 2073
  if (ldv_mutex_mutex_of_drm_mode_config != 1) {
#line 2073
    ldv_error();
  } else {

  }
#line 2075
  if (ldv_mutex_power_mutex != 1) {
#line 2075
    ldv_error();
  } else {

  }
#line 2077
  if (ldv_mutex_struct_mutex_of_drm_device != 1) {
#line 2077
    ldv_error();
  } else {

  }
#line 2079
  if (ldv_mutex_update_lock_of_backlight_device != 1) {
#line 2079
    ldv_error();
  } else {

  }
#line 2083
  return;
}
}
